{
  "Title": "Error Propagation",
  "Content": "The codebase uses an error propagation mechanism that works as follows:\n\n\n* A function that is supposed to return value `X`, instead returns a tuple `(NO_ERROR, X)`\n* A function that would normally error out instead returns a tuple `(ERROR_NAME, 0)`\n* Note that in both cases, the first return value is an error code (an `enum` type named `Error`)\n* Whenever a function returns an error, the calling function has to check it and then bubbles it up (ie. the caller returns the error tuple, possibly adding context to the error message)\n* At the top level, the error/context codes are emitted in an event and then the error code is returned. The transaction is successful.\n* The UI will need to convert the error codes into an error message\n\n\nThis scheme has the benefit of providing useful failure messages when an operation fails. However, there are serious negative properties of this pattern which we discuss below.\n\n\n* First, the error propagation scheme violates the “Fail Early and Loudly” principle. Errors are not trapped when they are found. Callers have to remember to check and handle the returned error codes. Failure to do so can have serious security consequences.\n* The scheme also increases both the size and the complexity of the code base. We estimate that abandoning the current scheme in favor of the traditional require/assert/revert paradigm would reduce the size of the (Solidity) codebase by 40%-60%. This would, additionally, make the code itself easier to read and understand — which is an often overlooked but important property of secure code.\n* The increased code complexity is not just a matter of cognitive overhead for those attempting to read/understand the code. It also results in very large increases in gas costs due to all the extra required opcodes. From the user’s perspective, this is a strong argument against this pattern.\n* Implementation of the scheme makes it incompatible with battle-tested libraries (like SafeMath) and requires the use of custom math functions that reproduce the same functionality except that they return errors instead of throwing on failure.\n* The default value of an uninitialized `Error` enum is the `Error.NO_ERROR` value. This means that if a new `Error` variable is declared and returned by a function without having been set, the caller will assume that there was no error. That is, the default assumption by error handlers is that everything went according to plan. It would be safer to assume, by default, that things did *not* go according to plan unless verified otherwise. While this property is not inherent to this error-handling pattern, it is a feature of the particular implementation we audited.\n* It does not cover every case, leading to inconsistencies within the code base. For example, the [`CEther` `mint` function](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CEther.sol#L34) reverts on failure, whereas the [`CErc20` `mint` function](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CErc20.sol#L48) returns an error code.\n* Finally, lack of a `revert` on failure is counter to what most Ethereum users have come to expect. For instance, a failed call to `CToken.transfer` via MetaMask will result in a `success` message from MetaMask even though the transfer failed. While this may not technically violate the ERC20 standard, it is counter-intuitive and increases the probability of user error.\n\n\nWith all of that said, it appears that all errors *are* properly handled in the code we audited. If considering a refactor of the contracts at some point in the future, we strongly recommend moving away from this error propagation pattern and instead using off-chain tools to evaluate failed transactions in order to display meaningful error messages to users.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/CEther.sol",
      "content": "pragma solidity ^0.5.8;\n\nimport \"./CToken.sol\";\n\n/**\n * @title Compound's CEther Contract\n * @notice CToken which wraps Ether\n * @author Compound\n */\ncontract CEther is CToken {\n    /**\n     * @notice Construct a new CEther money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     */\n    constructor(ComptrollerInterface comptroller_,\n                InterestRateModel interestRateModel_,\n                uint initialExchangeRateMantissa_,\n                string memory name_,\n                string memory symbol_,\n                uint decimals_) public\n    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {}\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Reverts upon any failure\n     */\n    function mint() external payable {\n        requireNoError(mintInternal(msg.value), \"mint failed\");\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(redeemAmount);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @dev Reverts upon any failure\n     */\n    function repayBorrow() external payable {\n        requireNoError(repayBorrowInternal(msg.value), \"repayBorrow failed\");\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @dev Reverts upon any failure\n     * @param borrower the account with the debt being payed off\n     */\n    function repayBorrowBehalf(address borrower) external payable {\n        requireNoError(repayBorrowBehalfInternal(borrower, msg.value), \"repayBorrowBehalf failed\");\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @dev Reverts upon any failure\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     */\n    function liquidateBorrow(address borrower, CToken cTokenCollateral) external payable {\n        requireNoError(liquidateBorrowInternal(borrower, msg.value, cTokenCollateral), \"liquidateBorrow failed\");\n    }\n\n    /**\n     * @notice Send Ether to CEther to mint\n     */\n    function () external payable {\n        requireNoError(mintInternal(msg.value), \"mint failed\");\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of Ether, before this message\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of Ether owned by this contract\n     */\n    function getCashPrior() internal view returns (uint) {\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\n        require(err == MathError.NO_ERROR);\n        return startingBalance;\n    }\n\n    /**\n     * @notice Checks whether the requested transfer matches the `msg`\n     * @dev Does NOT do a transfer\n     * @param from Address sending the Ether\n     * @param amount Amount of Ether being sent\n     * @return Whether or not the transfer checks out\n     */\n    function checkTransferIn(address from, uint amount) internal view returns (Error) {\n        // Sanity checks\n        require(msg.sender == from, \"sender mismatch\");\n        require(msg.value == amount, \"value mismatch\");\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @notice Perform the actual transfer in, which is a no-op\n     * @param from Address sending the Ether\n     * @param amount Amount of Ether being sent\n     * @return Success\n     */\n    function doTransferIn(address from, uint amount) internal returns (Error) {\n        // Sanity checks\n        require(msg.sender == from, \"sender mismatch\");\n        require(msg.value == amount, \"value mismatch\");\n        return Error.NO_ERROR;\n    }\n\n    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n        /* Send the Ether, with minimal gas and revert on failure */\n        to.transfer(amount);\n        return Error.NO_ERROR;\n    }\n\n    function requireNoError(uint errCode, string memory message) internal pure {\n        if (errCode == uint(Error.NO_ERROR)) {\n            return;\n        }\n\n        bytes memory fullMessage = new bytes(bytes(message).length + 5);\n        uint i;\n\n        for (i = 0; i < bytes(message).length; i++) {\n            fullMessage[i] = bytes(message)[i];\n        }\n\n        fullMessage[i+0] = byte(uint8(32));\n        fullMessage[i+1] = byte(uint8(40));\n        fullMessage[i+2] = byte(uint8(48 + ( errCode / 10 )));\n        fullMessage[i+3] = byte(uint8(48 + ( errCode % 10 )));\n        fullMessage[i+4] = byte(uint8(41));\n\n        require(errCode == uint(Error.NO_ERROR), string(fullMessage));\n    }\n}"
    }
  ]
}