{
  "Title": "M-15: Liquidators can prevent users from making their positions healthy during an unpause",
  "Content": "# Issue M-15: Liquidators can prevent users from making their positions healthy during an unpause \n\nSource: https://github.com/sherlock-audit/2023-05-perennial-judging/issues/190 \n\n## Found by \nAkshaySrivastav, SolidityATL, rvierdiiev\n## Summary\nThe Perennial protocol has a paused state in which all operations are paused. The protocol can be unpaused by privileged accounts. But when this unpause happens the liquidators can frontrun and liquidate user positions before those users get a chance to make their positions healthy.  \n\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/collateral/Collateral.sol#L108-L135\n\n## Vulnerability Detail\nThe `pauser` address can pause the perennial protocol using the `Controller.updatePaused` function. Once the protocol is paused all these operations cannot be done by users:\n- Open/close/modify current make or take positions on a product.\n- Deposit or withdraw collateral.\n- Liquidate under-collateralized positions.\n\nThough, real prices from oracles will surely move up or down during this paused period. If the oracle prices go down, the users won't be allowed to add more collateral to their positions or close their positions. Hence their positions will get under-collateralized (based upon real prices).\n\nOnce the protocol is unpaused the liquidators can front-run most users and liquidate their positions. Most users will not get a chance to make their position healthy.\n\nThis results in loss of funds for the users.\n\nPerennial also has the concept of settlement delay. Any position opened/closed at oracle version `n` is settled at oracle version `n + 1`. This also alleviates the frontrunning liquidation issue. While validating an account's health before liquidation, the protocol only considers the current maintenance requirement for the account (not the next). This makes users more prone to getting front-runned and liquidated.\n\nRef: [audit finding](https://github.com/sherlock-audit/2023-03-notional-judging/issues/203)\n\n## Impact\nBy front-running any collateral deposit or position closure of a legitimate user which became under-collateralized during the paused state, the liquidator can unfairly liquidate user positions and collect liquidation profit as soon as the protocol is unpaused. This causes loss of funds to the user.\n\n## Code Snippet\n\nCollateral\n```solidity\n    function depositTo(address account, IProduct product, UFixed18 amount)\n    external\n    nonReentrant\n    notPaused\n    notZeroAddress(account)\n    isProduct(product)\n    collateralInvariant(account, product)\n    {\n        _products[product].creditAccount(account, amount);\n        token.pull(msg.sender, amount);\n\n        emit Deposit(account, product, amount);\n    }\n```\n\nProduct\n```solidity\n    function closeTakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        closeInvariant(account)\n        liquidationInvariant(account)\n    {\n        _closeTake(account, amount);\n    }\n\n    function closeMakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        takerInvariant\n        closeInvariant(account)\n        liquidationInvariant(account)\n    {\n        _closeMake(account, amount);\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider adding a grace period after unpausing during which liquidation remains blocked to allow users to avoid unfair liquidation by closing their positions or supplying additional collateral.\n\n\n\n## Discussion\n\n**akshaysrivastav**\n\nEscalate for 10 USDC\n\nI think this issue should be considered as valid. As per the comment [here](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/168#issuecomment-1601554168), the protocol team can disagree with the mitigation suggested in #168 but the validity of issue should be accepted. The report clearly shows how a protocol owner actions (pause) will result in unfair liquidations causing loss of funds to users.\n\nAlso it is unlikely that on unpause human users will be able to secure their positions before MEV/liquidation bots capture the available profit. Hence the loss is certain.\n\nFor reference, a similar issue was consider valid in the recent [Notional V3](https://github.com/sherlock-audit/2023-03-notional-judging/issues/203) contest. Maintaining a consistent valid/invalid classification standard will be ideal here.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I think this issue should be considered as valid. As per the comment [here](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/168#issuecomment-1601554168), the protocol team can disagree with the mitigation suggested in #168 but the validity of issue should be accepted. The report clearly shows how a protocol owner actions (pause) will result in unfair liquidations causing loss of funds to users.\n> \n> Also it is unlikely that on unpause human users will be able to secure their positions before MEV/liquidation bots capture the available profit. Hence the loss is certain.\n> \n> For reference, a similar issue was consider valid in the recent [Notional V3](https://github.com/sherlock-audit/2023-03-notional-judging/issues/203) contest. Maintaining a consistent valid/invalid classification standard will be ideal here.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**KenzoAgada**\n\nSherlock:\n- At the main issue, #168, I wrote that \"This can be considered as an un-mandatory \"idea for improvement\", but I think that the risk is there so this is a reasonable submission, and if I recall correctly, was accepted by Sherlock judges in the past.\"\n- The sponsor disputed the issue and replied that \"By introducing a time delay to allow traders to optionally increase their collateral to meet maintenance requirements the Product runs the risk of going into further shortfall if the traders opt to not increase their margin. The fairest option for both liquidators and other traders in the protocol is to require that traders are paying attention and self-liquidate (to retain the fee) if they so chose.\".\n- I accepted the sponsor's POV and closed the issue as a design choice.\n- However here the escalator says that even if the sponsor would not like to implement the mitigation, the _validity_ of the issue should be accepted.\n- This issue has been accepted recently in [Notional](https://github.com/sherlock-audit/2023-03-notional-judging/issues/203) and [Blueberry](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/290). But unlike here, there the sponsor confirmed the issues.\n\nI think the watson raises a valid point. Even if the sponsor chose not to allow this as a design choice, the issue itself is there, was accepted by Sherlock in the past, and therefore should probably be accepted here as well.\nI think restoring it to medium is fair.\n\n**jacksanford1**\n\nSeems like a valid issue if true. The recommended fix's acceptance/rejection is not relevant to the issue itself. \n\nThis is a temporary freezing (pause) induced by the protocol team, but it can cause the protocol to enter a state where on unpause many users will lose their funds to MEV (due to being liquidatable) before the user can salvage the position potentially. \n\nBorderline Low issue but we can make it a Medium since it can result in a significant loss of funds for many users at the same time. \n\n**jacksanford1**\n\nResult:\nMedium\nHas Duplicates\nReasoning can be found in the previous message.\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [akshaysrivastav](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/190/#issuecomment-1614784003): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/79",
  "Code": [
    {
      "filename": "perennial-mono/packages/perennial/contracts/collateral/Collateral.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\nimport \"@equilibria/root/control/unstructured/UInitializable.sol\";\nimport \"@equilibria/root/control/unstructured/UReentrancyGuard.sol\";\nimport \"../interfaces/ICollateral.sol\";\nimport \"./types/OptimisticLedger.sol\";\nimport \"../controller/UControllerProvider.sol\";\n\n/**\n * @title Collateral\n * @notice Manages logic and state for all collateral accounts in the protocol.\n */\ncontract Collateral is ICollateral, UInitializable, UControllerProvider, UReentrancyGuard {\n    /// @dev ERC20 stablecoin for collateral\n    Token18 public immutable token;\n\n    /// @dev Per product collateral state\n    mapping(IProduct => OptimisticLedger) private _products;\n\n    /// @dev Protocol and product fees collected, but not yet claimed\n    mapping(address => UFixed18) public fees;\n\n    /**\n     * @notice Initializes the immutable contract state\n     * @dev Called at implementation instantiate and constant for that implementation.\n     * @param token_ Collateral ERC20 stablecoin address\n     */\n    constructor(Token18 token_) {\n        token = token_;\n    }\n\n    /**\n     * @notice Initializes the contract state\n     * @dev Must be called atomically as part of the upgradeable proxy deployment to\n     *      avoid front-running\n     * @param controller_ Factory contract address\n     */\n    function initialize(IController controller_) external initializer(1) {\n        __UControllerProvider__initialize(controller_);\n        __UReentrancyGuard__initialize();\n    }\n\n    /**\n     * @notice Deposits `amount` collateral from `msg.sender` to `account`'s `product`\n     *         account\n     * @param account Account to deposit the collateral for\n     * @param product Product to credit the collateral to\n     * @param amount Amount of collateral to deposit\n     */\n    function depositTo(address account, IProduct product, UFixed18 amount)\n    external\n    nonReentrant\n    notPaused\n    notZeroAddress(account)\n    isProduct(product)\n    collateralInvariant(account, product)\n    {\n        _products[product].creditAccount(account, amount);\n        token.pull(msg.sender, amount);\n\n        emit Deposit(account, product, amount);\n    }\n\n    /**\n     * @notice Withdraws `amount` collateral from `msg.sender`'s `product` account\n     *         and sends it to `receiver`\n     * @param receiver Account to withdraw the collateral to\n     * @param product Product to withdraw the collateral from\n     * @param amount Amount of collateral to withdraw\n     */\n    function withdrawTo(address receiver, IProduct product, UFixed18 amount) external {\n        withdrawFrom(msg.sender, receiver, product, amount);\n    }\n\n    /**\n     * @notice Withdraws `amount` collateral from `account`'s `product` account\n     *         and sends it to `receiver`\n     * @param account Account to withdraw the collateral from\n     * @param receiver Account to withdraw the collateral to\n     * @param product Product to withdraw the collateral from\n     * @param amount Amount of collateral to withdraw\n     */\n    function withdrawFrom(address account, address receiver, IProduct product, UFixed18 amount)\n    public\n    nonReentrant\n    notPaused\n    notZeroAddress(receiver)\n    isProduct(product)\n    onlyAccountOrMultiInvoker(account)\n    settleForAccount(account, product)\n    collateralInvariant(account, product)\n    maintenanceInvariant(account, product)\n    {\n        amount = amount.eq(UFixed18Lib.MAX) ? collateral(account, product) : amount;\n        _products[product].debitAccount(account, amount);\n        token.push(receiver, amount);\n\n        emit Withdrawal(account, product, amount);\n    }\n\n    /**\n     * @notice Liquidates `account`'s `product` collateral account\n     * @dev Account must be under-collateralized, fee returned immediately to `msg.sender`\n     * @param account Account to liquidate\n     * @param product Product to liquidate for\n     */\n    function liquidate(address account, IProduct product)\n    external\n    nonReentrant\n    notPaused\n    isProduct(product)\n    settleForAccount(account, product)\n    {\n        if (product.isLiquidating(account)) revert CollateralAccountLiquidatingError(account);\n\n        UFixed18 totalMaintenance = product.maintenance(account);\n        UFixed18 totalCollateral = collateral(account, product);\n\n        if (!totalMaintenance.gt(totalCollateral))\n            revert CollateralCantLiquidate(totalMaintenance, totalCollateral);\n\n        product.closeAll(account);\n\n        // claim fee\n        UFixed18 liquidationFee = controller().liquidationFee();\n        // If maintenance is less than minCollateral, use minCollateral for fee amount\n        UFixed18 collateralForFee = UFixed18Lib.max(totalMaintenance, controller().minCollateral());\n        UFixed18 fee = UFixed18Lib.min(totalCollateral, collateralForFee.mul(liquidationFee));\n\n        _products[product].debitAccount(account, fee);\n        token.push(msg.sender, fee);\n\n        emit Liquidation(account, product, msg.sender, fee);\n    }\n\n    /**\n     * @notice Credits `amount` to `account`'s collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel.\n     *      Moves collateral within a product, any collateral leaving the product due to\n     *      fees has already been accounted for in the settleProduct flywheel.\n     *      Debits in excess of the account balance get recorded as shortfall, and can be\n     *      resolved by the product owner as needed.\n     * @param account Account to credit\n     * @param amount Amount to credit the account (can be negative)\n     */\n    function settleAccount(address account, Fixed18 amount) external onlyProduct {\n        IProduct product = IProduct(msg.sender);\n\n        UFixed18 newShortfall = _products[product].settleAccount(account, amount);\n\n        emit AccountSettle(product, account, amount, newShortfall);\n    }\n\n    /**\n     * @notice Debits `amount` from product's total collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel\n     *      Removes collateral from the product as fees.\n     * @param amount Amount to debit from the account\n     */\n    function settleProduct(UFixed18 amount) external onlyProduct {\n        (IProduct product, IController controller) = (IProduct(msg.sender), controller());\n\n        address protocolTreasury = controller.treasury();\n        address productTreasury = controller.treasury(product);\n\n        UFixed18 protocolFee = amount.mul(controller.protocolFee());\n        UFixed18 productFee = amount.sub(protocolFee);\n\n        _products[product].debit(amount);\n        fees[protocolTreasury] = fees[protocolTreasury].add(protocolFee);\n        fees[productTreasury] = fees[productTreasury].add(productFee);\n\n        emit ProductSettle(product, protocolFee, productFee);\n    }\n\n    /**\n     * @notice Returns the balance of `account`'s `product` collateral account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return The balance of the collateral account\n     */\n    function collateral(address account, IProduct product) public view returns (UFixed18) {\n        return _products[product].balances[account];\n    }\n\n    /**\n     * @notice Returns the total balance of `product`'s collateral\n     * @param product Product to return for\n     * @return The total balance of collateral in the product\n     */\n    function collateral(IProduct product) external view returns (UFixed18) {\n        return _products[product].total;\n    }\n\n    /**\n     * @notice Returns the current shortfall of `product`'s collateral\n     * @param product Product to return for\n     * @return The current shortfall of the product\n     */\n    function shortfall(IProduct product) external view returns (UFixed18) {\n        return _products[product].shortfall;\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatable(address account, IProduct product) external view returns (bool) {\n        if (product.isLiquidating(account)) return false;\n\n        return product.maintenance(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     *         after the next oracle version settlement\n     * @dev Takes into account the current pre-position on the account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatableNext(address account, IProduct product) external view returns (bool) {\n        return product.maintenanceNext(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Injects additional collateral into a product to resolve shortfall\n     * @dev Shortfall is a measure of settled insolvency in the market\n     *      This hook can be used by the product owner or an insurance fund to re-capitalize an insolvent market\n     * @param product Product to resolve shortfall for\n     * @param amount Amount of shortfall to resolve\n     */\n    function resolveShortfall(IProduct product, UFixed18 amount) external isProduct(product) notPaused {\n        _products[product].resolve(amount);\n        token.pull(msg.sender, amount);\n\n        emit ShortfallResolution(product, amount);\n    }\n\n    /**\n     * @notice Claims all of `msg.sender`'s fees\n     */\n    function claimFee() external notPaused {\n        UFixed18 amount = fees[msg.sender];\n\n        fees[msg.sender] = UFixed18Lib.ZERO;\n        token.push(msg.sender, amount);\n\n        emit FeeClaim(msg.sender, amount);\n    }\n\n    /// @dev Ensure that the address is non-zero\n    modifier notZeroAddress(address account) {\n        if (account == address(0)) revert CollateralZeroAddressError();\n\n        _;\n    }\n\n    /// @dev Ensure that the user has sufficient margin for both current and next maintenance\n    modifier maintenanceInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 maintenance = product.maintenance(account);\n        UFixed18 maintenanceNext = product.maintenanceNext(account);\n\n        if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))\n            revert CollateralInsufficientCollateralError();\n    }\n\n    /// @dev Ensure that the account is either empty or above the collateral minimum\n    modifier collateralInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 accountCollateral = collateral(account, product);\n        if (!accountCollateral.isZero() && accountCollateral.lt(controller().minCollateral()))\n            revert CollateralUnderLimitError();\n    }\n\n    /// @dev Helper to fully settle an account's state\n    modifier settleForAccount(address account, IProduct product) {\n        product.settleAccount(account);\n\n        _;\n    }\n}"
    }
  ]
}