{
  "Title": "M-5: Vault Inflation Attack",
  "Content": "# Issue M-5: Vault Inflation Attack \n\nSource: https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/190 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nsantipu\\_, xiaoming90\n## Summary\n\nMalicious users can perform an inflation attack against the vault to steal the assets of the victim.\n\n## Vulnerability Detail\n\nA malicious user can perform a donation to execute a classic first depositor/ERC4626 inflation Attack against the FlatCoin vault. The general process of this attack is well-known, and a detailed explanation of this attack can be found in many of the resources such as the following:\n\n- https://blog.openzeppelin.com/a-novel-defense-against-erc4626-inflation-attacks\n- https://mixbytes.io/blog/overview-of-the-inflation-attack\n\nIn short, to kick-start the attack, the malicious user will often usually mint the smallest possible amount of shares (e.g., 1 wei) and then donate significant assets to the vault to inflate the number of assets per share. Subsequently, it will cause a rounding error when other users deposit.\n\nHowever, in Flatcoin, there are various safeguards in place to mitigate this attack. Thus, one would need to perform additional steps to workaround/bypass the existing controls.\n\nLet's divide the setup of the attack into two main parts:\n\n1. Malicious user mint 1 mint of share\n2. Donate or transfer assets to the vault to inflate the assets per share\n\n#### Part 1 - Malicious user mint 1 mint of share\n\nUsers could attempt to mint 1 wei of share. However, the validation check at Line 79 will revert as the share minted is less than `MIN_LIQUIDITY` = 10_000. However, this minimum liquidation requirement check can be bypassed.\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/StableModule.sol#L61\n\n```solidity\nFile: StableModule.sol\n61:     function executeDeposit(\n62:         address _account,\n63:         uint64 _executableAtTime,\n64:         FlatcoinStructs.AnnouncedStableDeposit calldata _announcedDeposit\n65:     ) external whenNotPaused onlyAuthorizedModule returns (uint256 _liquidityMinted) {\n66:         uint256 depositAmount = _announcedDeposit.depositAmount;\n67: \n68:         uint32 maxAge = _getMaxAge(_executableAtTime);\n69: \n70:         _liquidityMinted = (depositAmount * (10 ** decimals())) / stableCollateralPerShare(maxAge);\n71: \n72:         if (_liquidityMinted < _announcedDeposit.minAmountOut)\n73:             revert FlatcoinErrors.HighSlippage(_liquidityMinted, _announcedDeposit.minAmountOut);\n74: \n75:         _mint(_account, _liquidityMinted);\n76: \n77:         vault.updateStableCollateralTotal(int256(depositAmount));\n78: \n79:         if (totalSupply() < MIN_LIQUIDITY) // @audit-info MIN_LIQUIDITY = 10_000\n80:             revert FlatcoinErrors.AmountTooSmall({amount: totalSupply(), minAmount: MIN_LIQUIDITY});\n```\n\nFirst, Bob mints 10000 wei shares via `executeDeposit` function. Next, Bob withdraws 9999 wei shares via the `executeWithdraw`. In the end, Bob successfully owned only 1 wei share, which is the prerequisite for this attack.\n\n#### Part 2 - Donate or transfer assets to the vault to inflate the assets per share\n\nThe vault tracks the number of collateral within the state variables. Thus, simply transferring rETH collateral to the vault directly will not work, and the assets per share will remain the same.\n\nTo work around this, Bob creates a large number of accounts (with different wallet addresses). He could choose any or both of the following methods to indirectly transfer collateral to the LP pool/vault to inflate the assets per share:\n\n1) Open a large number of leveraged long positions with the intention of incurring large amounts of losses. The long positions' losses are the gains of the LPs, and the collateral per share will increase.\n2) Open a large number of leveraged long positions till the max skew of 120%. Thus, this will cause the funding rate to increase, and the long will have to pay the LPs, which will also increase the collateral per share.\n\n#### Triggering rounding error\n\nThe `stableCollateralPerShare` will be inflated at this point. Following is the formula used to determine the number of shares minted to the depositor.\n\nIf the `depositAmount` by the victim is not sufficiently large enough, the amount of shares minted to the depositor will round down to zero.\n\n```solidity\n_collateralPerShare = (stableBalance * (10 ** decimals())) / totalSupply;\n_liquidityMinted = (depositAmount * (10 ** decimals())) / _collateralPerShare\n```\n\nFinally, the attacker withdraws their share from the pool. Since they are the only ones with any shares, this withdrawal equals the balance of the vault. This means the attacker also withdraws the tokens deposited by the victim earlier.\n\n## Impact\n\nMalicous users could steal the assets of the victim.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/StableModule.sol#L61\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nA `MIN_LIQUIDITY` amount of shares needs to exist within the vault to guard against a common inflation attack.\n\nHowever, the current approach of only checking if the `totalSupply() < MIN_LIQUIDITY` is not sufficient, and could be bypassed by making use of the withdraw function.\n\nA more robust approach to ensuring that there is always a minimum number of shares to guard against inflation attack is to mint a certain amount of shares to zero address (dead address) during contract deployment (similar to what has been implemented in Uniswap V2). \n\n\n\n## Discussion\n\n**sherlock-admin**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**ubl4nk** commented:\n> invalid or Low-Impact -> Bob can't deposit 10_000 wei and withdraw 9_999, because there are delayed-orders (orders become pending), there are no sorted orders and keepers can select to execute which orders first\n\n**takarez** commented:\n>  invalid\n\n\n\n**0xLogos**\n\nEscalate \n\nLow. Attack is too risky.\n\nThere is no frontrunning so attacker must prepare attack in advance. Someone can deposit amount larger than attacker expected and take his money.\n\n**sherlock-admin2**\n\n> Escalate \n> \n> Low. Attack is too risky.\n> \n> There is no frontrunning so attacker must prepare attack in advance. Someone can deposit amount larger than attacker expected and take his money.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xLogos**\n\n> If the depositAmount by the victim is not sufficiently large enough, the amount of shares minted to the depositor will round down to zero.\n\nBut if deposit is large enough, attacker will lose.\n\n**santipu03**\n\nHi @0xLogos,\n\nCheck my dup issue for clarification (#128) but the attacker can easily provoke a permanent DoS on the Vault by being the first depositor. In case a user deposits an insane amount of funds to pass the `MIN_LIQUIDITY` check, the attacker would be able to steal most of the funds as a classic inflation attack. \n\n**xiaoming9090**\n\n> Escalate\n> \n> Low. Attack is too risky.\n> \n> There is no frontrunning so attacker must prepare attack in advance. Someone can deposit amount larger than attacker expected and take his money.\n\nThe escalation is invalid. Refer to the santipu03 response above. To add to his response:\n\nThe attack can be executed without frontrunning once the vault has been \"set up\" by the malicious user (After completing Steps 1 and 2 in the above report). Afterward, victims whose `depositAmount` is not sufficiently large enough will lose their assets to the attacker.\n\nAlso, the claim in the escalation that someone depositing an amount larger than the attacker will cause the attacker's money to be stolen is baseless.\n\n**0xcrunch**\n\nThis is a low/QA, the issue can be easily mitigated by sponsor conducting a sacrificial deposit in the same transaction of deploying the Vault.\n\n\n**xiaoming9090**\n\n> This is a low/QA, the issue can be easily mitigated by sponsor conducting a sacrificial deposit in the same transaction of deploying the Vault.\n\nDisagree. There is no evidence provided to Watsons in the public domain during the audit contest period (22 Jan to 4 Feb) that states that the protocol team will perform a sacrificial deposit when deploying the vault.\n\n**r0ck3tzx**\n\nThis attack is absolutely not practical in the environment where front-running is not possible such as Base and its not possible to have general MEV agents - see the recent Radiant hack. If this issue would be considered valid then all reported front-running issues should be as well. Thus the The low/QA severity is more appropriate for this issue.\n\n\n**Czar102**\n\nI believe that this is a borderline Med/Low that should be included as Med since it's possible to guess, or to somehow get to know the timing of the deposit, which is the only information the attacker needs.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**nevillehuang**\n\nAgree with @Czar102 and @xiaoming9090 \n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xLogos](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/190/#issuecomment-1956476732): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/132",
  "Code": [
    {
      "filename": "flatcoin-v1/src/StableModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/math/SafeCastUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/interfaces/IERC20Upgradeable.sol\";\nimport {ERC20LockableUpgradeable} from \"./misc/ERC20LockableUpgradeable.sol\";\n\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {IStableModule} from \"./interfaces/IStableModule.sol\";\nimport {IPointsModule} from \"./interfaces/IPointsModule.sol\";\n\n/// @title StableModule\n/// @author dHEDGE\n/// @notice Contains functions to handle stable LP deposits and withdrawals.\ncontract StableModule is IStableModule, ModuleUpgradeable, ERC20LockableUpgradeable {\n    using SafeCastUpgradeable for *;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using PerpMath for int256;\n    using PerpMath for uint256;\n\n    uint256 public constant MIN_LIQUIDITY = 10_000; // minimum totalSupply that is allowable\n\n    /// @notice Fee for stable LP redemptions.\n    /// @dev 1e18 = 100%\n    uint256 public stableWithdrawFee;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(IFlatcoinVault _vault, uint256 _stableWithdrawFee) external initializer {\n        __Module_init(FlatcoinModuleKeys._STABLE_MODULE_KEY, _vault);\n        __ERC20_init(\"Flatmoney\", \"UNIT\");\n\n        setStableWithdrawFee(_stableWithdrawFee);\n    }\n\n    /////////////////////////////////////////////\n    //         External Write Functions        //\n    /////////////////////////////////////////////\n\n    /// @notice User delayed deposit into the stable LP. Mints ERC20 token receipt.\n    /// @dev Needs to be used in conjunction with DelayedOrder module.\n    /// @param _account The usser account which has a pending deposit.\n    /// @param _executableAtTime The time at which the order can be executed.\n    /// @param _announcedDeposit The pending order.\n    /// @return _liquidityMinted The amount of LP tokens minted.\n    function executeDeposit(\n        address _account,\n        uint64 _executableAtTime,\n        FlatcoinStructs.AnnouncedStableDeposit calldata _announcedDeposit\n    ) external whenNotPaused onlyAuthorizedModule returns (uint256 _liquidityMinted) {\n        uint256 depositAmount = _announcedDeposit.depositAmount;\n\n        uint32 maxAge = _getMaxAge(_executableAtTime);\n\n        _liquidityMinted = (depositAmount * (10 ** decimals())) / stableCollateralPerShare(maxAge);\n\n        if (_liquidityMinted < _announcedDeposit.minAmountOut)\n            revert FlatcoinErrors.HighSlippage(_liquidityMinted, _announcedDeposit.minAmountOut);\n\n        _mint(_account, _liquidityMinted);\n\n        vault.updateStableCollateralTotal(int256(depositAmount));\n\n        if (totalSupply() < MIN_LIQUIDITY)\n            revert FlatcoinErrors.AmountTooSmall({amount: totalSupply(), minAmount: MIN_LIQUIDITY});\n\n        // Mint points\n        IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n        pointsModule.mintDeposit(_account, _announcedDeposit.depositAmount);\n\n        emit FlatcoinEvents.Deposit(_account, depositAmount, _liquidityMinted);\n    }\n\n    /// @notice User delayed withdrawal from the stable LP. Burns ERC20 token receipt.\n    /// @dev Needs to be used in conjunction with DelayedOrder module.\n    /// @param _account The usser account which has a pending withdrawal.\n    /// @param _executableAtTime The time at which the order can be executed.\n    /// @param _announcedWithdraw The pending order.\n    /// @return _amountOut The amount of collateral withdrawn.\n    /// @return _withdrawFee The fee paid to the remaining LPs.\n    function executeWithdraw(\n        address _account,\n        uint64 _executableAtTime,\n        FlatcoinStructs.AnnouncedStableWithdraw calldata _announcedWithdraw\n    ) external whenNotPaused onlyAuthorizedModule returns (uint256 _amountOut, uint256 _withdrawFee) {\n        uint256 withdrawAmount = _announcedWithdraw.withdrawAmount;\n\n        uint32 maxAge = _getMaxAge(_executableAtTime);\n\n        uint256 stableCollateralPerShareBefore = stableCollateralPerShare(maxAge);\n        _amountOut = (withdrawAmount * stableCollateralPerShareBefore) / (10 ** decimals());\n\n        // Unlock the locked LP tokens before burning.\n        // This is because if the amount to be burned is locked, the burn will fail due to `_beforeTokenTransfer`.\n        _unlock(_account, withdrawAmount);\n\n        _burn(_account, withdrawAmount);\n\n        vault.updateStableCollateralTotal(-int256(_amountOut));\n\n        uint256 stableCollateralPerShareAfter = stableCollateralPerShare(maxAge);\n\n        // Check that there is no significant impact on stable token price.\n        // This should never happen and means that too much value or not enough value was withdrawn.\n        if (totalSupply() > 0) {\n            if (\n                stableCollateralPerShareAfter < stableCollateralPerShareBefore - 1e6 ||\n                stableCollateralPerShareAfter > stableCollateralPerShareBefore + 1e6\n            ) revert FlatcoinErrors.PriceImpactDuringWithdraw();\n\n            // Apply the withdraw fee if it's not the final withdrawal.\n            _withdrawFee = (stableWithdrawFee * _amountOut) / 1e18;\n\n            // additionalSkew = 0 because withdrawal was already processed above.\n            vault.checkSkewMax({additionalSkew: 0});\n        } else {\n            // Need to check there are no longs open before allowing full system withdrawal.\n            uint256 sizeOpenedTotal = vault.getVaultSummary().globalPositions.sizeOpenedTotal;\n\n            if (sizeOpenedTotal != 0) revert FlatcoinErrors.MaxSkewReached(sizeOpenedTotal);\n            if (stableCollateralPerShareAfter != 1e18) revert FlatcoinErrors.PriceImpactDuringFullWithdraw();\n        }\n\n        emit FlatcoinEvents.Withdraw(_account, _amountOut, withdrawAmount);\n    }\n\n    /// @notice Function to lock a certain amount of an account's LP tokens.\n    /// @dev This function is used to lock LP tokens when an account announces a delayed order.\n    /// @param _account The account to lock the LP tokens from.\n    /// @param _amount The amount of LP tokens to lock.\n    function lock(address _account, uint256 _amount) public onlyAuthorizedModule {\n        _lock(_account, _amount);\n    }\n\n    /// @notice Function to unlock a certain amount of an account's LP tokens.\n    /// @dev This function is used to unlock LP tokens when an account cancels a delayed order\n    ///      or when an order is executed.\n    /// @param _account The account to unlock the LP tokens from.\n    /// @param _amount The amount of LP tokens to unlock.\n    function unlock(address _account, uint256 _amount) public onlyAuthorizedModule {\n        _unlock(_account, _amount);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Total collateral available for withdrawal.\n    /// @dev Balance takes into account trader profit and loss and funding rate.\n    /// @return _stableCollateralBalance The total collateral available for withdrawal.\n    function stableCollateralTotalAfterSettlement() public view returns (uint256 _stableCollateralBalance) {\n        return stableCollateralTotalAfterSettlement({_maxAge: type(uint32).max});\n    }\n\n    /// @notice Function to calculate total stable side collateral after accounting for trader profit and loss and funding fees.\n    /// @param _maxAge The oldest price oracle timestamp that can be used. Set to 0 to ignore.\n    /// @return _stableCollateralBalance The total collateral available for withdrawal.\n    function stableCollateralTotalAfterSettlement(\n        uint32 _maxAge\n    ) public view returns (uint256 _stableCollateralBalance) {\n        // Assumption => pnlTotal = pnlLong + fundingAccruedLong\n        // The assumption is based on the fact that stable LPs are the counterparty to leverage traders.\n        // If the `pnlLong` is +ve that means the traders won and the LPs lost between the last funding rate update and now.\n        // Similary if the `fundingAccruedLong` is +ve that means the market was skewed short-side.\n        // When we combine these two terms, we get the total profit/loss of the leverage traders.\n        // NOTE: This function if called after settlement returns only the PnL as funding has already been adjusted\n        //      due to calling `_settleFundingFees()`. Although this still means `netTotal` includes the funding\n        //      adjusted long PnL, it might not be clear to the reader of the code.\n        int256 netTotal = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY))\n            .fundingAdjustedLongPnLTotal({maxAge: _maxAge});\n\n        // The flatcoin LPs are the counterparty to the leverage traders.\n        // So when the traders win, the flatcoin LPs lose and vice versa.\n        // Therefore we subtract the leverage trader profits and add the losses\n        int256 totalAfterSettlement = int256(vault.stableCollateralTotal()) - netTotal;\n\n        if (totalAfterSettlement < 0) {\n            _stableCollateralBalance = 0;\n        } else {\n            _stableCollateralBalance = uint256(totalAfterSettlement);\n        }\n    }\n\n    /// @notice Function to calculate the collateral per share.\n    /// @return _collateralPerShare The collateral per share.\n    function stableCollateralPerShare() public view returns (uint256 _collateralPerShare) {\n        return stableCollateralPerShare({_maxAge: type(uint32).max});\n    }\n\n    /// @notice Function to calculate the collateral per share.\n    /// @param _maxAge The oldest price oracle timestamp that can be used.\n    /// @return _collateralPerShare The collateral per share.\n    function stableCollateralPerShare(uint32 _maxAge) public view returns (uint256 _collateralPerShare) {\n        uint256 totalSupply = totalSupply();\n\n        if (totalSupply > 0) {\n            uint256 stableBalance = stableCollateralTotalAfterSettlement(_maxAge);\n\n            _collateralPerShare = (stableBalance * (10 ** decimals())) / totalSupply;\n        } else {\n            // no shares have been minted yet\n            _collateralPerShare = 1e18;\n        }\n    }\n\n    /// @notice Quoter function for getting the stable deposit amount out.\n    /// @param _depositAmount The amount of collateral to deposit.\n    /// @return _amountOut The amount of LP tokens minted.\n    function stableDepositQuote(uint256 _depositAmount) public view returns (uint256 _amountOut) {\n        return (_depositAmount * (10 ** decimals())) / stableCollateralPerShare();\n    }\n\n    /// @notice Quoter function for getting the stable withdraw amount out.\n    /// @param _withdrawAmount The amount of LP tokens to withdraw.\n    /// @return _amountOut The amount of collateral withdrawn.\n    function stableWithdrawQuote(uint256 _withdrawAmount) public view returns (uint256 _amountOut) {\n        _amountOut = (_withdrawAmount * stableCollateralPerShare()) / (10 ** decimals());\n\n        // Take out the withdrawal fee\n        _amountOut -= (_amountOut * stableWithdrawFee) / 1e18;\n    }\n\n    /// @notice Function to get the locked amount of an account.\n    /// @param _account The account to get the locked amount for.\n    /// @return _amountLocked The amount of LP tokens locked.\n    function getLockedAmount(address _account) public view returns (uint256 _amountLocked) {\n        return _lockedAmount[_account];\n    }\n\n    /////////////////////////////////////////////\n    //            Internal Functions           //\n    /////////////////////////////////////////////\n\n    /// @notice Returns the maximum age of the oracle price to be used.\n    /// @param _executableAtTime The time at which the order is executable.\n    /// @return _maxAge The maximum age of the oracle price to be used.\n    function _getMaxAge(uint64 _executableAtTime) internal view returns (uint32 _maxAge) {\n        return (block.timestamp - _executableAtTime).toUint32();\n    }\n\n    /////////////////////////////////////////////\n    //             Owner Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Setter for the stable withdraw fee.\n    /// @dev Fees can be set to 0 if needed.\n    /// @param _stableWithdrawFee The new stable withdraw fee.\n    function setStableWithdrawFee(uint256 _stableWithdrawFee) public onlyOwner {\n        // Set fee cap to max 1%.\n        // This is to avoid fat fingering but if any change is needed, the owner needs to\n        // upgrade this module.\n        if (_stableWithdrawFee > 0.01e18) revert FlatcoinErrors.InvalidFee(_stableWithdrawFee);\n\n        stableWithdrawFee = _stableWithdrawFee;\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/StableModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/math/SafeCastUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/interfaces/IERC20Upgradeable.sol\";\nimport {ERC20LockableUpgradeable} from \"./misc/ERC20LockableUpgradeable.sol\";\n\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {IStableModule} from \"./interfaces/IStableModule.sol\";\nimport {IPointsModule} from \"./interfaces/IPointsModule.sol\";\n\n/// @title StableModule\n/// @author dHEDGE\n/// @notice Contains functions to handle stable LP deposits and withdrawals.\ncontract StableModule is IStableModule, ModuleUpgradeable, ERC20LockableUpgradeable {\n    using SafeCastUpgradeable for *;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using PerpMath for int256;\n    using PerpMath for uint256;\n\n    uint256 public constant MIN_LIQUIDITY = 10_000; // minimum totalSupply that is allowable\n\n    /// @notice Fee for stable LP redemptions.\n    /// @dev 1e18 = 100%\n    uint256 public stableWithdrawFee;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(IFlatcoinVault _vault, uint256 _stableWithdrawFee) external initializer {\n        __Module_init(FlatcoinModuleKeys._STABLE_MODULE_KEY, _vault);\n        __ERC20_init(\"Flatmoney\", \"UNIT\");\n\n        setStableWithdrawFee(_stableWithdrawFee);\n    }\n\n    /////////////////////////////////////////////\n    //         External Write Functions        //\n    /////////////////////////////////////////////\n\n    /// @notice User delayed deposit into the stable LP. Mints ERC20 token receipt.\n    /// @dev Needs to be used in conjunction with DelayedOrder module.\n    /// @param _account The usser account which has a pending deposit.\n    /// @param _executableAtTime The time at which the order can be executed.\n    /// @param _announcedDeposit The pending order.\n    /// @return _liquidityMinted The amount of LP tokens minted.\n    function executeDeposit(\n        address _account,\n        uint64 _executableAtTime,\n        FlatcoinStructs.AnnouncedStableDeposit calldata _announcedDeposit\n    ) external whenNotPaused onlyAuthorizedModule returns (uint256 _liquidityMinted) {\n        uint256 depositAmount = _announcedDeposit.depositAmount;\n\n        uint32 maxAge = _getMaxAge(_executableAtTime);\n\n        _liquidityMinted = (depositAmount * (10 ** decimals())) / stableCollateralPerShare(maxAge);\n\n        if (_liquidityMinted < _announcedDeposit.minAmountOut)\n            revert FlatcoinErrors.HighSlippage(_liquidityMinted, _announcedDeposit.minAmountOut);\n\n        _mint(_account, _liquidityMinted);\n\n        vault.updateStableCollateralTotal(int256(depositAmount));\n\n        if (totalSupply() < MIN_LIQUIDITY)\n            revert FlatcoinErrors.AmountTooSmall({amount: totalSupply(), minAmount: MIN_LIQUIDITY});\n\n        // Mint points\n        IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n        pointsModule.mintDeposit(_account, _announcedDeposit.depositAmount);\n\n        emit FlatcoinEvents.Deposit(_account, depositAmount, _liquidityMinted);\n    }\n\n    /// @notice User delayed withdrawal from the stable LP. Burns ERC20 token receipt.\n    /// @dev Needs to be used in conjunction with DelayedOrder module.\n    /// @param _account The usser account which has a pending withdrawal.\n    /// @param _executableAtTime The time at which the order can be executed.\n    /// @param _announcedWithdraw The pending order.\n    /// @return _amountOut The amount of collateral withdrawn.\n    /// @return _withdrawFee The fee paid to the remaining LPs.\n    function executeWithdraw(\n        address _account,\n        uint64 _executableAtTime,\n        FlatcoinStructs.AnnouncedStableWithdraw calldata _announcedWithdraw\n    ) external whenNotPaused onlyAuthorizedModule returns (uint256 _amountOut, uint256 _withdrawFee) {\n        uint256 withdrawAmount = _announcedWithdraw.withdrawAmount;\n\n        uint32 maxAge = _getMaxAge(_executableAtTime);\n\n        uint256 stableCollateralPerShareBefore = stableCollateralPerShare(maxAge);\n        _amountOut = (withdrawAmount * stableCollateralPerShareBefore) / (10 ** decimals());\n\n        // Unlock the locked LP tokens before burning.\n        // This is because if the amount to be burned is locked, the burn will fail due to `_beforeTokenTransfer`.\n        _unlock(_account, withdrawAmount);\n\n        _burn(_account, withdrawAmount);\n\n        vault.updateStableCollateralTotal(-int256(_amountOut));\n\n        uint256 stableCollateralPerShareAfter = stableCollateralPerShare(maxAge);\n\n        // Check that there is no significant impact on stable token price.\n        // This should never happen and means that too much value or not enough value was withdrawn.\n        if (totalSupply() > 0) {\n            if (\n                stableCollateralPerShareAfter < stableCollateralPerShareBefore - 1e6 ||\n                stableCollateralPerShareAfter > stableCollateralPerShareBefore + 1e6\n            ) revert FlatcoinErrors.PriceImpactDuringWithdraw();\n\n            // Apply the withdraw fee if it's not the final withdrawal.\n            _withdrawFee = (stableWithdrawFee * _amountOut) / 1e18;\n\n            // additionalSkew = 0 because withdrawal was already processed above.\n            vault.checkSkewMax({additionalSkew: 0});\n        } else {\n            // Need to check there are no longs open before allowing full system withdrawal.\n            uint256 sizeOpenedTotal = vault.getVaultSummary().globalPositions.sizeOpenedTotal;\n\n            if (sizeOpenedTotal != 0) revert FlatcoinErrors.MaxSkewReached(sizeOpenedTotal);\n            if (stableCollateralPerShareAfter != 1e18) revert FlatcoinErrors.PriceImpactDuringFullWithdraw();\n        }\n\n        emit FlatcoinEvents.Withdraw(_account, _amountOut, withdrawAmount);\n    }\n\n    /// @notice Function to lock a certain amount of an account's LP tokens.\n    /// @dev This function is used to lock LP tokens when an account announces a delayed order.\n    /// @param _account The account to lock the LP tokens from.\n    /// @param _amount The amount of LP tokens to lock.\n    function lock(address _account, uint256 _amount) public onlyAuthorizedModule {\n        _lock(_account, _amount);\n    }\n\n    /// @notice Function to unlock a certain amount of an account's LP tokens.\n    /// @dev This function is used to unlock LP tokens when an account cancels a delayed order\n    ///      or when an order is executed.\n    /// @param _account The account to unlock the LP tokens from.\n    /// @param _amount The amount of LP tokens to unlock.\n    function unlock(address _account, uint256 _amount) public onlyAuthorizedModule {\n        _unlock(_account, _amount);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Total collateral available for withdrawal.\n    /// @dev Balance takes into account trader profit and loss and funding rate.\n    /// @return _stableCollateralBalance The total collateral available for withdrawal.\n    function stableCollateralTotalAfterSettlement() public view returns (uint256 _stableCollateralBalance) {\n        return stableCollateralTotalAfterSettlement({_maxAge: type(uint32).max});\n    }\n\n    /// @notice Function to calculate total stable side collateral after accounting for trader profit and loss and funding fees.\n    /// @param _maxAge The oldest price oracle timestamp that can be used. Set to 0 to ignore.\n    /// @return _stableCollateralBalance The total collateral available for withdrawal.\n    function stableCollateralTotalAfterSettlement(\n        uint32 _maxAge\n    ) public view returns (uint256 _stableCollateralBalance) {\n        // Assumption => pnlTotal = pnlLong + fundingAccruedLong\n        // The assumption is based on the fact that stable LPs are the counterparty to leverage traders.\n        // If the `pnlLong` is +ve that means the traders won and the LPs lost between the last funding rate update and now.\n        // Similary if the `fundingAccruedLong` is +ve that means the market was skewed short-side.\n        // When we combine these two terms, we get the total profit/loss of the leverage traders.\n        // NOTE: This function if called after settlement returns only the PnL as funding has already been adjusted\n        //      due to calling `_settleFundingFees()`. Although this still means `netTotal` includes the funding\n        //      adjusted long PnL, it might not be clear to the reader of the code.\n        int256 netTotal = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY))\n            .fundingAdjustedLongPnLTotal({maxAge: _maxAge});\n\n        // The flatcoin LPs are the counterparty to the leverage traders.\n        // So when the traders win, the flatcoin LPs lose and vice versa.\n        // Therefore we subtract the leverage trader profits and add the losses\n        int256 totalAfterSettlement = int256(vault.stableCollateralTotal()) - netTotal;\n\n        if (totalAfterSettlement < 0) {\n            _stableCollateralBalance = 0;\n        } else {\n            _stableCollateralBalance = uint256(totalAfterSettlement);\n        }\n    }\n\n    /// @notice Function to calculate the collateral per share.\n    /// @return _collateralPerShare The collateral per share.\n    function stableCollateralPerShare() public view returns (uint256 _collateralPerShare) {\n        return stableCollateralPerShare({_maxAge: type(uint32).max});\n    }\n\n    /// @notice Function to calculate the collateral per share.\n    /// @param _maxAge The oldest price oracle timestamp that can be used.\n    /// @return _collateralPerShare The collateral per share.\n    function stableCollateralPerShare(uint32 _maxAge) public view returns (uint256 _collateralPerShare) {\n        uint256 totalSupply = totalSupply();\n\n        if (totalSupply > 0) {\n            uint256 stableBalance = stableCollateralTotalAfterSettlement(_maxAge);\n\n            _collateralPerShare = (stableBalance * (10 ** decimals())) / totalSupply;\n        } else {\n            // no shares have been minted yet\n            _collateralPerShare = 1e18;\n        }\n    }\n\n    /// @notice Quoter function for getting the stable deposit amount out.\n    /// @param _depositAmount The amount of collateral to deposit.\n    /// @return _amountOut The amount of LP tokens minted.\n    function stableDepositQuote(uint256 _depositAmount) public view returns (uint256 _amountOut) {\n        return (_depositAmount * (10 ** decimals())) / stableCollateralPerShare();\n    }\n\n    /// @notice Quoter function for getting the stable withdraw amount out.\n    /// @param _withdrawAmount The amount of LP tokens to withdraw.\n    /// @return _amountOut The amount of collateral withdrawn.\n    function stableWithdrawQuote(uint256 _withdrawAmount) public view returns (uint256 _amountOut) {\n        _amountOut = (_withdrawAmount * stableCollateralPerShare()) / (10 ** decimals());\n\n        // Take out the withdrawal fee\n        _amountOut -= (_amountOut * stableWithdrawFee) / 1e18;\n    }\n\n    /// @notice Function to get the locked amount of an account.\n    /// @param _account The account to get the locked amount for.\n    /// @return _amountLocked The amount of LP tokens locked.\n    function getLockedAmount(address _account) public view returns (uint256 _amountLocked) {\n        return _lockedAmount[_account];\n    }\n\n    /////////////////////////////////////////////\n    //            Internal Functions           //\n    /////////////////////////////////////////////\n\n    /// @notice Returns the maximum age of the oracle price to be used.\n    /// @param _executableAtTime The time at which the order is executable.\n    /// @return _maxAge The maximum age of the oracle price to be used.\n    function _getMaxAge(uint64 _executableAtTime) internal view returns (uint32 _maxAge) {\n        return (block.timestamp - _executableAtTime).toUint32();\n    }\n\n    /////////////////////////////////////////////\n    //             Owner Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Setter for the stable withdraw fee.\n    /// @dev Fees can be set to 0 if needed.\n    /// @param _stableWithdrawFee The new stable withdraw fee.\n    function setStableWithdrawFee(uint256 _stableWithdrawFee) public onlyOwner {\n        // Set fee cap to max 1%.\n        // This is to avoid fat fingering but if any change is needed, the owner needs to\n        // upgrade this module.\n        if (_stableWithdrawFee > 0.01e18) revert FlatcoinErrors.InvalidFee(_stableWithdrawFee);\n\n        stableWithdrawFee = _stableWithdrawFee;\n    }\n}"
    }
  ]
}