{
  "Title": "[H-02] `withdrawTo` Does Not Sync Before Checking A Position's Margin Requirements",
  "Content": "_Submitted by leastwood_\n\n#### Impact\n\nThe `maintenanceInvariant` modifier in `Collateral` aims to check if a user meets the margin requirements to withdraw collateral by checking its current and next maintenance. `maintenanceInvariant` inevitably calls `AccountPosition.maintenance` which uses the oracle's price to calculate the margin requirements for a given position. Hence, if the oracle has not synced in a long time, `maintenanceInvariant` may end up utilising an outdated price for a withdrawal. This may allow a user to withdraw collateral on an undercollaterized position.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/Collateral.sol#L67-L76>\n\n```solidity\nfunction withdrawTo(address account, IProduct product, UFixed18 amount)\nnotPaused\ncollateralInvariant(msg.sender, product)\nmaintenanceInvariant(msg.sender, product)\nexternal {\n    _products[product].debitAccount(msg.sender, amount);\n    token.push(account, amount);\n\n    emit Withdrawal(msg.sender, product, amount);\n}\n```\n<https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/Collateral.sol#L233-L241>\n```solidity\nmodifier maintenanceInvariant(address account, IProduct product) {\n    _;\n\n    UFixed18 maintenance = product.maintenance(account);\n    UFixed18 maintenanceNext = product.maintenanceNext(account);\n\n    if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))\n        revert CollateralInsufficientCollateralError();\n}\n```\n<https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/types/position/AccountPosition.sol#L71-L75>\n```solidity\nfunction maintenanceInternal(Position memory position, IProductProvider provider) private view returns (UFixed18) {\n    Fixed18 oraclePrice = provider.priceAtVersion(provider.currentVersion());\n    UFixed18 notionalMax = Fixed18Lib.from(position.max()).mul(oraclePrice).abs();\n    return notionalMax.mul(provider.maintenance());\n}\n```\n#### Tools Used\n\nManual code review.\n\n#### Recommended Mitigation Steps\n\nConsider adding `settleForAccount(msg.sender)` to the `Collateral.withdrawTo` function to ensure the most up to date oracle price is used when assessing an account's margin requirements.\n\n**[kbrizzle (Perennial) confirmed](https://github.com/code-423n4/2021-12-perennial-findings/issues/74#issuecomment-996589429):**\n > Great catch ðŸ™ \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-12-perennial-findings/issues/74#issuecomment-1001590562):**\n > With most onChain protocols where there is potential for undercollateralized positions and liquidations, it is very important to accrue a user position before making any changes to their balance.\n> \n> The warden identified a potential way for a user to withdraw funds while their account is below margin requirements.\n> \n> Because this impacts the core functionality functionality of the protocol (accounting), I'm raising the severity to high\n> \n> Mitigation seems to be straightforward\n\n\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-12-perennial",
  "Code": [
    {
      "filename": "protocol/contracts/collateral/Collateral.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/ICollateral.sol\";\nimport \"./types/OptimisticLedger.sol\";\nimport \"../utils/unstructured/UReentrancyGuard.sol\";\nimport \"../factory/UFactoryProvider.sol\";\n\n/**\n * @title Collateral\n * @notice Manages logic and state for all collateral accounts in the protocol.\n */\ncontract Collateral is ICollateral, UFactoryProvider, UReentrancyGuard {\n    using UFixed18Lib for UFixed18;\n    using Token18Lib for Token18;\n    using OptimisticLedgerLib for OptimisticLedger;\n\n    /// @dev ERC20 stablecoin for collateral\n    Token18 public token;\n\n    /// @dev Fee on maintenance for liquidation\n    UFixed18 public liquidationFee;\n\n    /// @dev Per product collateral state\n    mapping(IProduct => OptimisticLedger) private _products;\n\n    /// @dev Protocol and product fees collected, but not yet claimed\n    mapping(address => UFixed18) public fees;\n\n    /**\n     * @notice Initializes the contract state\n     * @param factory_ Factory contract address\n     * @param token_ Collateral ERC20 stablecoin address\n     */\n    function initialize(IFactory factory_, Token18 token_) external {\n        UFactoryProvider__initialize(factory_);\n        UReentrancyGuard__initialize();\n\n        token = token_;\n        liquidationFee = UFixed18Lib.ratio(50, 100);\n    }\n\n    /**\n     * @notice Deposits `amount` collateral from `msg.sender` to `account`'s `product`\n     *         account\n     * @param account Account to deposit the collateral for\n     * @param product Product to credit the collateral to\n     * @param amount Amount of collateral to deposit\n     */\n    function depositTo(address account, IProduct product, UFixed18 amount)\n    notPaused\n    collateralInvariant(account, product)\n    external {\n        _products[product].creditAccount(account, amount);\n        token.pull(msg.sender, amount);\n\n        emit Deposit(account, product, amount);\n    }\n\n    /**\n     * @notice Withdraws `amount` collateral from `msg.sender`'s `product` account\n     *         and sends it to `account`\n     * @param account Account to withdraw the collateral to\n     * @param product Product to withdraw the collateral from\n     * @param amount Amount of collateral to withdraw\n     */\n    function withdrawTo(address account, IProduct product, UFixed18 amount)\n    notPaused\n    collateralInvariant(msg.sender, product)\n    maintenanceInvariant(msg.sender, product)\n    external {\n        _products[product].debitAccount(msg.sender, amount);\n        token.push(account, amount);\n\n        emit Withdrawal(msg.sender, product, amount);\n    }\n\n    /**\n     * @notice Liquidates `account`'s `product` collateral account\n     * @dev Account must be under-collateralized, fee returned immediately to `msg.sender`\n     * @param account Account to liquidate\n     * @param product Product to liquidate for\n     */\n    function liquidate(address account, IProduct product) notPaused nonReentrant external {\n        // settle\n        product.settle();\n        product.settleAccount(account);\n\n        // liquidate\n        UFixed18 totalMaintenance = product.maintenance(account);\n        UFixed18 totalCollateral = collateral(account, product);\n\n        if (!totalMaintenance.gt(totalCollateral))\n            revert CollateralCantLiquidate(totalMaintenance, totalCollateral);\n\n        product.closeAll(account);\n\n        // claim fee\n        UFixed18 fee = UFixed18Lib.min(totalCollateral, totalMaintenance.mul(liquidationFee));\n\n        _products[product].debitAccount(account, fee);\n        token.push(msg.sender, fee);\n\n        emit Liquidation(account, product, msg.sender, fee);\n    }\n\n    /**\n     * @notice Credits `amount` to `account`'s collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel.\n     *      Moves collateral within a product, any collateral leaving the product due to\n     *      fees has already been accounted for in the settleProduct flywheel.\n     *      Debits in excess of the account balance get recorded as shortfall, and can be\n     *      resolved by the product owner as needed.\n     * @param account Account to credit\n     * @param amount Amount to credit the account (can be negative)\n     */\n    function settleAccount(address account, Fixed18 amount) onlyProduct external {\n        IProduct product = IProduct(msg.sender);\n\n        UFixed18 newShortfall = _products[product].settleAccount(account, amount);\n\n        emit AccountSettle(product, account, amount, newShortfall);\n    }\n\n    /**\n     * @notice Debits `amount` from product's total collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel\n     *      Removes collateral from the product as fees.\n     * @param amount Amount to debit from the account\n     */\n    function settleProduct(UFixed18 amount) onlyProduct external {\n        IProduct product = IProduct(msg.sender);\n\n        address protocolTreasury = factory().treasury();\n        address productTreasury = factory().treasury(product);\n\n        UFixed18 protocolFee = amount.mul(factory().fee());\n        UFixed18 productFee = amount.sub(protocolFee);\n\n        _products[product].debit(amount);\n        fees[protocolTreasury] = fees[protocolTreasury].add(protocolFee);\n        fees[productTreasury] = fees[productTreasury].add(productFee);\n\n        emit ProductSettle(product, protocolFee, productFee);\n    }\n\n    /**\n     * @notice Returns the balance of `account`'s `product` collateral account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return The balance of the collateral account\n     */\n    function collateral(address account, IProduct product) public view returns (UFixed18) {\n        return _products[product].balances[account];\n    }\n\n    /**\n     * @notice Returns the total balance of `product`'s collateral\n     * @param product Product to return for\n     * @return The total balance of collateral in the product\n     */\n    function collateral(IProduct product) public view returns (UFixed18) {\n        return _products[product].total;\n    }\n\n    /**\n     * @notice Returns the current shortfall of `product`'s collateral\n     * @param product Product to return for\n     * @return The current shortfall of the product\n     */\n    function shortfall(IProduct product) public view returns (UFixed18) {\n        return _products[product].shortfall;\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatable(address account, IProduct product) external view returns (bool) {\n        return product.maintenance(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     *         after the next oracle version settlement\n     * @dev Takes into account the current pre-position on the account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatableNext(address account, IProduct product) external view returns (bool) {\n        return product.maintenanceNext(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Injects additional collateral into a product to resolve shortfall\n     * @dev Shortfall is a measure of settled insolvency in the market\n     *      This hook can be used by the product owner or an insurance fund to re-capitalize an insolvent market\n     * @param product Product to resolve shortfall for\n     * @param amount Amount of shortfall to resolve\n     */\n    function resolveShortfall(IProduct product, UFixed18 amount) notPaused external {\n        _products[product].resolve(amount);\n        token.pull(msg.sender, amount);\n\n        emit ShortfallResolution(product, amount);\n    }\n\n    /**\n     * @notice Claims all of `msg.sender`'s fees\n     */\n    function claimFee() notPaused external {\n        UFixed18 amount = fees[msg.sender];\n\n        fees[msg.sender] = UFixed18Lib.ZERO;\n        token.push(msg.sender, amount);\n\n        emit FeeClaim(msg.sender, amount);\n    }\n\n    /**\n     * @notice Updates the liquidation fee\n     * @param newLiquidationFee New liquidation fee\n     */\n    function updateLiquidationFee(UFixed18 newLiquidationFee) onlyOwner external {\n        liquidationFee = newLiquidationFee;\n        emit LiquidationFeeUpdated(newLiquidationFee);\n    }\n\n    /// @dev Ensure that the user has sufficient margin for both current and next maintenance\n    modifier maintenanceInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 maintenance = product.maintenance(account);\n        UFixed18 maintenanceNext = product.maintenanceNext(account);\n\n        if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))\n            revert CollateralInsufficientCollateralError();\n    }\n\n    /// @dev Ensure that the account is either empty or above the collateral minimum\n    modifier collateralInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 accountCollateral = collateral(account, product);\n        if (!accountCollateral.isZero() && accountCollateral.lt(factory().minCollateral()))\n            revert CollateralUnderLimitError();\n    }\n}"
    },
    {
      "filename": "protocol/contracts/collateral/Collateral.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/ICollateral.sol\";\nimport \"./types/OptimisticLedger.sol\";\nimport \"../utils/unstructured/UReentrancyGuard.sol\";\nimport \"../factory/UFactoryProvider.sol\";\n\n/**\n * @title Collateral\n * @notice Manages logic and state for all collateral accounts in the protocol.\n */\ncontract Collateral is ICollateral, UFactoryProvider, UReentrancyGuard {\n    using UFixed18Lib for UFixed18;\n    using Token18Lib for Token18;\n    using OptimisticLedgerLib for OptimisticLedger;\n\n    /// @dev ERC20 stablecoin for collateral\n    Token18 public token;\n\n    /// @dev Fee on maintenance for liquidation\n    UFixed18 public liquidationFee;\n\n    /// @dev Per product collateral state\n    mapping(IProduct => OptimisticLedger) private _products;\n\n    /// @dev Protocol and product fees collected, but not yet claimed\n    mapping(address => UFixed18) public fees;\n\n    /**\n     * @notice Initializes the contract state\n     * @param factory_ Factory contract address\n     * @param token_ Collateral ERC20 stablecoin address\n     */\n    function initialize(IFactory factory_, Token18 token_) external {\n        UFactoryProvider__initialize(factory_);\n        UReentrancyGuard__initialize();\n\n        token = token_;\n        liquidationFee = UFixed18Lib.ratio(50, 100);\n    }\n\n    /**\n     * @notice Deposits `amount` collateral from `msg.sender` to `account`'s `product`\n     *         account\n     * @param account Account to deposit the collateral for\n     * @param product Product to credit the collateral to\n     * @param amount Amount of collateral to deposit\n     */\n    function depositTo(address account, IProduct product, UFixed18 amount)\n    notPaused\n    collateralInvariant(account, product)\n    external {\n        _products[product].creditAccount(account, amount);\n        token.pull(msg.sender, amount);\n\n        emit Deposit(account, product, amount);\n    }\n\n    /**\n     * @notice Withdraws `amount` collateral from `msg.sender`'s `product` account\n     *         and sends it to `account`\n     * @param account Account to withdraw the collateral to\n     * @param product Product to withdraw the collateral from\n     * @param amount Amount of collateral to withdraw\n     */\n    function withdrawTo(address account, IProduct product, UFixed18 amount)\n    notPaused\n    collateralInvariant(msg.sender, product)\n    maintenanceInvariant(msg.sender, product)\n    external {\n        _products[product].debitAccount(msg.sender, amount);\n        token.push(account, amount);\n\n        emit Withdrawal(msg.sender, product, amount);\n    }\n\n    /**\n     * @notice Liquidates `account`'s `product` collateral account\n     * @dev Account must be under-collateralized, fee returned immediately to `msg.sender`\n     * @param account Account to liquidate\n     * @param product Product to liquidate for\n     */\n    function liquidate(address account, IProduct product) notPaused nonReentrant external {\n        // settle\n        product.settle();\n        product.settleAccount(account);\n\n        // liquidate\n        UFixed18 totalMaintenance = product.maintenance(account);\n        UFixed18 totalCollateral = collateral(account, product);\n\n        if (!totalMaintenance.gt(totalCollateral))\n            revert CollateralCantLiquidate(totalMaintenance, totalCollateral);\n\n        product.closeAll(account);\n\n        // claim fee\n        UFixed18 fee = UFixed18Lib.min(totalCollateral, totalMaintenance.mul(liquidationFee));\n\n        _products[product].debitAccount(account, fee);\n        token.push(msg.sender, fee);\n\n        emit Liquidation(account, product, msg.sender, fee);\n    }\n\n    /**\n     * @notice Credits `amount` to `account`'s collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel.\n     *      Moves collateral within a product, any collateral leaving the product due to\n     *      fees has already been accounted for in the settleProduct flywheel.\n     *      Debits in excess of the account balance get recorded as shortfall, and can be\n     *      resolved by the product owner as needed.\n     * @param account Account to credit\n     * @param amount Amount to credit the account (can be negative)\n     */\n    function settleAccount(address account, Fixed18 amount) onlyProduct external {\n        IProduct product = IProduct(msg.sender);\n\n        UFixed18 newShortfall = _products[product].settleAccount(account, amount);\n\n        emit AccountSettle(product, account, amount, newShortfall);\n    }\n\n    /**\n     * @notice Debits `amount` from product's total collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel\n     *      Removes collateral from the product as fees.\n     * @param amount Amount to debit from the account\n     */\n    function settleProduct(UFixed18 amount) onlyProduct external {\n        IProduct product = IProduct(msg.sender);\n\n        address protocolTreasury = factory().treasury();\n        address productTreasury = factory().treasury(product);\n\n        UFixed18 protocolFee = amount.mul(factory().fee());\n        UFixed18 productFee = amount.sub(protocolFee);\n\n        _products[product].debit(amount);\n        fees[protocolTreasury] = fees[protocolTreasury].add(protocolFee);\n        fees[productTreasury] = fees[productTreasury].add(productFee);\n\n        emit ProductSettle(product, protocolFee, productFee);\n    }\n\n    /**\n     * @notice Returns the balance of `account`'s `product` collateral account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return The balance of the collateral account\n     */\n    function collateral(address account, IProduct product) public view returns (UFixed18) {\n        return _products[product].balances[account];\n    }\n\n    /**\n     * @notice Returns the total balance of `product`'s collateral\n     * @param product Product to return for\n     * @return The total balance of collateral in the product\n     */\n    function collateral(IProduct product) public view returns (UFixed18) {\n        return _products[product].total;\n    }\n\n    /**\n     * @notice Returns the current shortfall of `product`'s collateral\n     * @param product Product to return for\n     * @return The current shortfall of the product\n     */\n    function shortfall(IProduct product) public view returns (UFixed18) {\n        return _products[product].shortfall;\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatable(address account, IProduct product) external view returns (bool) {\n        return product.maintenance(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     *         after the next oracle version settlement\n     * @dev Takes into account the current pre-position on the account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatableNext(address account, IProduct product) external view returns (bool) {\n        return product.maintenanceNext(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Injects additional collateral into a product to resolve shortfall\n     * @dev Shortfall is a measure of settled insolvency in the market\n     *      This hook can be used by the product owner or an insurance fund to re-capitalize an insolvent market\n     * @param product Product to resolve shortfall for\n     * @param amount Amount of shortfall to resolve\n     */\n    function resolveShortfall(IProduct product, UFixed18 amount) notPaused external {\n        _products[product].resolve(amount);\n        token.pull(msg.sender, amount);\n\n        emit ShortfallResolution(product, amount);\n    }\n\n    /**\n     * @notice Claims all of `msg.sender`'s fees\n     */\n    function claimFee() notPaused external {\n        UFixed18 amount = fees[msg.sender];\n\n        fees[msg.sender] = UFixed18Lib.ZERO;\n        token.push(msg.sender, amount);\n\n        emit FeeClaim(msg.sender, amount);\n    }\n\n    /**\n     * @notice Updates the liquidation fee\n     * @param newLiquidationFee New liquidation fee\n     */\n    function updateLiquidationFee(UFixed18 newLiquidationFee) onlyOwner external {\n        liquidationFee = newLiquidationFee;\n        emit LiquidationFeeUpdated(newLiquidationFee);\n    }\n\n    /// @dev Ensure that the user has sufficient margin for both current and next maintenance\n    modifier maintenanceInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 maintenance = product.maintenance(account);\n        UFixed18 maintenanceNext = product.maintenanceNext(account);\n\n        if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))\n            revert CollateralInsufficientCollateralError();\n    }\n\n    /// @dev Ensure that the account is either empty or above the collateral minimum\n    modifier collateralInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 accountCollateral = collateral(account, product);\n        if (!accountCollateral.isZero() && accountCollateral.lt(factory().minCollateral()))\n            revert CollateralUnderLimitError();\n    }\n}"
    },
    {
      "filename": "protocol/contracts/product/types/position/AccountPosition.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./PrePosition.sol\";\nimport \"../accumulator/Accumulator.sol\";\n\n/// @dev AccountPosition type\nstruct AccountPosition {\n    /// @dev The current settled position of the account\n    Position position;\n\n    /// @dev The current position delta pending-settlement\n    PrePosition pre;\n\n    /// @dev Whether the account is currently locked for liquidation\n    bool liquidation;\n}\n\n/**\n * @title AccountPositionLib\n * @notice Library that manages an account-level position.\n */\nlibrary AccountPositionLib {\n    using UFixed18Lib for UFixed18;\n    using Fixed18Lib for Fixed18;\n    using PositionLib for Position;\n    using PrePositionLib for PrePosition;\n\n    /**\n     * @notice Settled the account's position to oracle version `toOracleVersion`\n     * @param self The struct to operate on\n     * @param provider The parameter provider of the product\n     * @param toOracleVersion The oracle version to accumulate to\n     * @return positionFee The fee accrued from opening or closing a new position\n     */\n    function settle(AccountPosition storage self, IProductProvider provider, uint256 toOracleVersion) internal returns (UFixed18 positionFee) {\n        bool settled;\n        (self.position, positionFee, settled) = self.position.settled(self.pre, provider, toOracleVersion);\n        if (settled) delete self.pre;\n    }\n\n    /**\n     * @notice Returns the current maintenance requirement for the account\n     * @param self The struct to operate on\n     * @param provider The parameter provider of the product\n     * @return Current maintenance requirement for the account\n     */\n    function maintenance(AccountPosition storage self, IProductProvider provider) internal view returns (UFixed18) {\n        if (self.liquidation) return UFixed18Lib.ZERO;\n        return maintenanceInternal(self.position, provider);\n    }\n\n    /**\n     * @notice Returns the maintenance requirement after the next oracle version settlement\n     * @dev Includes the current pending-settlement position delta, assumes no price change\n     * @param self The struct to operate on\n     * @param provider The parameter provider of the product\n     * @return Next maintenance requirement for the account\n     */\n    function maintenanceNext(AccountPosition storage self, IProductProvider provider) internal view returns (UFixed18) {\n        return maintenanceInternal(self.position.next(self.pre), provider);\n    }\n\n    /**\n      @notice Returns the maintenance requirement for a given `position`\n     * @dev Internal helper\n     * @param position The position to compete the maintenance requirement for\n     * @param provider The parameter provider of the product\n     * @return Next maintenance requirement for the account\n     */\n    function maintenanceInternal(Position memory position, IProductProvider provider) private view returns (UFixed18) {\n        Fixed18 oraclePrice = provider.priceAtVersion(provider.currentVersion());\n        UFixed18 notionalMax = Fixed18Lib.from(position.max()).mul(oraclePrice).abs();\n        return notionalMax.mul(provider.maintenance());\n    }\n\n    /**\n     * @notice Returns whether an account is completely closed, i.e. no position or pre-position\n     * @param self The struct to operate on\n     * @return Whether the account is closed\n     */\n    function isClosed(AccountPosition memory self) internal pure returns (bool) {\n        return self.pre.isEmpty() && self.position.isEmpty();\n    }\n\n    /**\n     * @notice Returns whether an account has opened position on both sides of the market (maker vs taker)\n     * @dev Used to verify the invariant that a single account can only have a position on one side of the\n     *      market at a time\n     * @param self The struct to operate on\n     * @return Whether the account is currently doubled sided\n     */\n    function isDoubleSided(AccountPosition storage self) internal view returns (bool) {\n        bool makerEmpty = self.position.maker.isZero() && self.pre.openPosition.maker.isZero() && self.pre.closePosition.maker.isZero();\n        bool takerEmpty = self.position.taker.isZero() && self.pre.openPosition.taker.isZero() && self.pre.closePosition.taker.isZero();\n\n        return !makerEmpty && !takerEmpty;\n    }\n\n    /**\n     * @notice Returns whether the account's pending-settlement delta closes more position than is open\n     * @dev Used to verify the invariant that an account cannot settle into having a negative position\n     * @param self The struct to operate on\n     * @return Whether the account is currently over closed\n     */\n    function isOverClosed(AccountPosition storage self) internal view returns (bool) {\n        Position memory nextOpen = self.position.add(self.pre.openPosition);\n\n        return  self.pre.closePosition.maker.gt(nextOpen.maker) || self.pre.closePosition.taker.gt(nextOpen.taker);\n    }\n}"
    }
  ]
}