{
  "Title": "[7] Optimize names to save gas",
  "Content": "\n`public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: notional-wrapped-fcash/contracts/wfCashBase.sol   #1\n\n/// @audit getToken()\n16:   abstract contract wfCashBase is ERC777Upgradeable, IWrappedfCash {\n```\n\n<https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashBase.sol#L16>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-06-notional-coop",
  "Code": [
    {
      "filename": "notional-wrapped-fcash/contracts/wfCashBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./lib/Constants.sol\";\nimport \"./lib/DateTime.sol\";\nimport \"./lib/EncodeDecode.sol\";\nimport \"../interfaces/notional/INotionalV2.sol\";\nimport \"../interfaces/notional/IWrappedfCash.sol\";\nimport \"../interfaces/WETH9.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin-upgradeable/contracts/token/ERC777/ERC777Upgradeable.sol\";\n\nabstract contract wfCashBase is ERC777Upgradeable, IWrappedfCash {\n    using SafeERC20 for IERC20;\n\n    /// @notice address to the NotionalV2 system\n    INotionalV2 public immutable NotionalV2;\n    WETH9 public immutable WETH;\n\n    /// @dev Storage slot for fCash id. Read only and set on initialization\n    uint256 private _fCashId;\n\n    /// @notice Constructor is called only on deployment to set the Notional address, rest of state\n    /// is initialized on the proxy.\n    /// @dev Ensure initializer modifier is on the constructor to prevent an attack on UUPSUpgradeable contracts\n    constructor(INotionalV2 _notional, WETH9 _weth) initializer {\n        NotionalV2 = _notional;\n        WETH = _weth;\n    }\n\n    /// @notice Initializes a proxy for a specific fCash asset\n    function initialize(uint16 currencyId, uint40 maturity) external override initializer {\n        CashGroupSettings memory cashGroup = NotionalV2.getCashGroup(currencyId);\n        require(cashGroup.maxMarketIndex > 0, \"Invalid currency\");\n        // Ensure that the maturity is not past the max market index, also ensure that the maturity\n        // is not in the past. This statement will allow idiosyncratic (non-tradable) fCash assets.\n        require(\n            DateTime.isValidMaturity(cashGroup.maxMarketIndex, maturity, block.timestamp),\n            \"Invalid maturity\"\n        );\n\n        // Get the corresponding fCash ID\n        _fCashId = EncodeDecode.encodeERC1155Id(currencyId, maturity, Constants.FCASH_ASSET_TYPE);\n\n        (IERC20 underlyingToken, /* */) = getUnderlyingToken();\n        (IERC20 assetToken, /* */, /* */) = getAssetToken();\n\n        string memory _symbol = address(underlyingToken) == Constants.ETH_ADDRESS\n            ? \"ETH\"\n            : IERC20Metadata(address(underlyingToken)).symbol();\n\n        string memory _maturity = Strings.toString(maturity);\n\n        __ERC777_init(\n            // name\n            string(abi.encodePacked(\"Wrapped f\", _symbol, \" @ \", _maturity)),\n            // symbol\n            string(abi.encodePacked(\"wf\", _symbol, \":\", _maturity)),\n            // no default operators\n            new address[](0)\n        );\n\n        // Set approvals for Notional. It is possible for an asset token address to equal the underlying\n        // token address when there is no money market involved.\n        assetToken.safeApprove(address(NotionalV2), type(uint256).max);\n        if (\n            address(assetToken) != address(underlyingToken) &&\n            address(underlyingToken) != Constants.ETH_ADDRESS\n        ) {\n            underlyingToken.safeApprove(address(NotionalV2), type(uint256).max);\n        }\n    }\n\n    /// @notice Returns the underlying fCash ID of the token\n    function getfCashId() public view override returns (uint256) {\n        return _fCashId;\n    }\n\n    /// @notice Returns the underlying fCash maturity of the token\n    function getMaturity() public view override returns (uint40 maturity) {\n        (/* */, maturity, /* */) = EncodeDecode.decodeERC1155Id(_fCashId);\n    }\n\n    /// @notice True if the fCash has matured, assets mature exactly on the block time\n    function hasMatured() public view override returns (bool) {\n        return getMaturity() <= block.timestamp;\n    }\n\n    /// @notice Returns the underlying fCash currency\n    function getCurrencyId() public view override returns (uint16 currencyId) {\n        (currencyId, /* */, /* */) = EncodeDecode.decodeERC1155Id(_fCashId);\n    }\n\n    /// @notice Returns the components of the fCash idd\n    function getDecodedID() public view override returns (uint16 currencyId, uint40 maturity) {\n        (currencyId, maturity, /* */) = EncodeDecode.decodeERC1155Id(_fCashId);\n    }\n\n    /// @notice fCash is always denominated in 8 decimal places\n    function decimals() public pure override returns (uint8) {\n        return 8;\n    }\n\n    /// @notice Returns the current market index for this fCash asset. If this returns\n    /// zero that means it is idiosyncratic and cannot be traded.\n    function getMarketIndex() public view override returns (uint8) {\n        (uint256 marketIndex, bool isIdiosyncratic) = DateTime.getMarketIndex(\n            Constants.MAX_TRADED_MARKET_INDEX,\n            getMaturity(),\n            block.timestamp\n        );\n\n        if (isIdiosyncratic) return 0;\n        // Market index as defined does not overflow this conversion\n        return uint8(marketIndex);\n    }\n\n    /// @notice Returns the token and precision of the token that this token settles\n    /// to. For example, fUSDC will return the USDC token address and 1e6. The zero\n    /// address will represent ETH.\n    function getUnderlyingToken() public view override returns (IERC20 underlyingToken, int256 underlyingPrecision) {\n        (Token memory asset, Token memory underlying) = NotionalV2.getCurrency(getCurrencyId());\n\n        if (asset.tokenType == TokenType.NonMintable) {\n            // In this case the asset token is the underlying\n            return (IERC20(asset.tokenAddress), asset.decimals);\n        } else {\n            return (IERC20(underlying.tokenAddress), underlying.decimals);\n        }\n    }\n\n    /// @notice Returns the asset token which the fCash settles to. This will be an interest\n    /// bearing token like a cToken or aToken.\n    function getAssetToken() public view override returns (IERC20 assetToken, int256 underlyingPrecision, TokenType tokenType) {\n        (Token memory asset, /* Token memory underlying */) = NotionalV2.getCurrency(getCurrencyId());\n        return (IERC20(asset.tokenAddress), asset.decimals, asset.tokenType);\n    }\n\n    function getToken(bool useUnderlying) public view returns (IERC20 token, bool isETH) {\n        if (useUnderlying) {\n            (token, /* */) = getUnderlyingToken();\n        } else {\n            (token, /* */, /* */) = getAssetToken();\n        }\n        isETH = address(token) == Constants.ETH_ADDRESS;\n    }\n}"
    }
  ]
}