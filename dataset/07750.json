{
  "Title": "[M-03] The sorting logic is not strict enough",
  "Content": "\nWhen the seller finalizes his auction, all bids are sorted according to the `quotePerBase` and it's calculated using the `FixedPointMathLib.mulDivDown()`.\n\nAnd the earliest bid will be used first for the same `quotePerBase` but this ratio is not strict enough so that the worse bid might be filled than the better one.\n\nAs a result, the seller might receive fewer quote token than he wants.\n\n### Proof of Concept\n\nThis is the test to show the scenario.\n\n```solidity\n    function testAuditWrongSorting() public {\n        // this test will show that it is possible the seller can not claim the best bid because of the inaccurate comparison in finalization\n        uint128 K = 1<<64;\n        baseToSell = K + 2;\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n\n        bidder1.setAuctionId(aid);\n        bidder1.bidOnAuctionWithSalt(K+1, K, \"Worse bidder\");\n        bidder2.setAuctionId(aid);\n        bidder2.bidOnAuctionWithSalt(K+2, K+1, \"Better bidder\"); // This is the better bid because (K+1)/(K+2) > K/(K+1)\n\n        vm.warp(endTime);\n\n        uint256[] memory bidIndices = new uint[](2);\n        bidIndices[0] = 1; // the seller is smart enough to choose the correct order to (1, 0)\n        bidIndices[1] = 0;\n\n        vm.expectRevert(ISizeSealed.InvalidSorting.selector);\n        seller.finalize(bidIndices, K+2, K+1); // this reverts because of #273\n\n        // next the seller is forced to call the finalize with parameter K+1, K preferring the first bidder\n        bidIndices[0] = 0;\n        bidIndices[1] = 1;\n        seller.finalize(bidIndices, K+1, K);\n\n        // at this point the seller gets K quote tokens while he could get K+1 quote tokens with the better bidder\n        assertEq(quoteToken.balanceOf(address(seller)), K);\n    }\n```\n\nThis is the output of the test.\n\n```solidity\n    Running 1 test for src/test/SizeSealed.t.sol:SizeSealedTest\n    [PASS] testAuditWrongSorting() (gas: 984991)\n    Test result: ok. 1 passed; 0 failed; finished in 7.22ms\n```\n\nWhen it calculates the [quotePerBase](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L269), they are same each other with `(base, quote) = (K+1, K) and (K+2, K+1) when K = 1<<64`.\n\nSo the seller can receive `K+1` of the quote token but he got `K`.\n\nI think `K` is realistic enough with the 18 decimals token because K is around 18 &ast; 1e18.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nAs we can see from the test, it's not strict enough to compare bidders using `quotePerBase`.\n\nWe can compare them by multiplying them like below.\n\n$\\frac {quote1}{base1} >= \\frac{quote2}{base2} <=> quote1 &ast; base2 >= quote2 &ast; base1 $\n\nSo we can add 2 elements to `FinalizeData` struct and modify [this comparison](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L269-L277) like below.\n\n```solidity\n    struct FinalizeData {\n        uint256 reserveQuotePerBase;\n        uint128 totalBaseAmount;\n        uint128 filledBase;\n        uint256 previousQuotePerBase;\n        uint256 previousIndex;\n        uint128 previousQuote; //++++++++++++\n        uint128 previousBase; //+++++++++++\n    }\n```\n\n```solidity\n    uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount);\n    if (quotePerBase >= data.previousQuotePerBase) {\n        // If last bid was the same price, make sure we filled the earliest bid first\n        if (quotePerBase == data.previousQuotePerBase) {\n            uint256 currentMult = uint256(b.quoteAmount) * data.previousBase; //mult for current bid\n            uint256 previousMult = uint256(data.previousQuote) * baseAmount; //mult for the previous bid\n\n            if (currentMult > previousMult) { // current bid is better\n                revert InvalidSorting();    \n            }\n\n            if (currentMult == previousMult && data.previousIndex > bidIndex) revert InvalidSorting();\n        } else {\n            revert InvalidSorting();\n        }\n    }\n\n    ...\n\n    data.previousBase = baseAmount;\n    data.previousQuote = b.quoteAmount;\n```\n\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-11-size-findings/issues/97#issuecomment-1309172738):**\n > hmmm....  I think the summary is loss of precision leads to small difference in sorting.  Will leave open for sponsor review, but may be QA without showing a larger impact \n\n**[RagePit (SIZE) confirmed and commented](https://github.com/code-423n4/2022-11-size-findings/issues/97#issuecomment-1321318749):**\n > very nice find, although its only a small loss in precision the possibility of unfair sorting should be addressed\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-11-size-findings/issues/97#issuecomment-1329859282):**\n > With 1e18 points of precision, the difference between the theoretically correct calculation and the actual calculation is basically non existent. Therefore, impact is purely theoretical, as a competitive bidder could by the same logic over-bid by a tiny amount in the corrected calculation as well. \n> Also, it is worth remembering that quote1 & quote2 are unknown until revealed, when it's too late to over-bid.\n\n**[hansfriese (warden) commented](https://github.com/code-423n4/2022-11-size-findings/issues/97#issuecomment-1330084026):**\n > The definition of a better bid is the seller can earn more quote tokens (even if it's 1 wei) by using the bidder.\n> As we can see from the test, the seller can receive more amount of quote tokens if he uses the worse bidder.\n> It means the sorting method using 1e18 is not good enough.\n> If we implement the suggested comparison method(quote1 &ast; base2 > quote2 &ast; base1), it's impossible to receive more funds by using the worse bidder because the comparison is strict.\n> This issue has no relation to the over-bid and just shows the incorrect sorting logic.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-11-size-findings/issues/97#issuecomment-1330152376):**\n > Yeah Hans you are very much correct in that sorting logic can theoretically be incorrect. I'm talking about the impact, not the root cause. Don't you agree that the difference in calculation and the fact quote is unknown makes impact completely nullified?\n> \n> Regardless it's a well a spotted sneaky bug.\n\n**[hansfriese (warden) commented](https://github.com/code-423n4/2022-11-size-findings/issues/97#issuecomment-1330163540):**\n > I think we can't say it's 100% impossible to have the above situation although the bidders place a bid without knowing others.\n> \n> It says about the Med risk like below in the document.\n> \n> 2 - Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> \n> I think my test case would be a possible assumption.\n> \n> I feel I am defending my issue too much. I won't reply anymore and will follow the judge's decision.\n> \n> Thanks for your feedback.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-11-size-findings/issues/97#issuecomment-1335304455):**\n > Thanks for the comments and fact based discussion which is always welcomed, going to move forward with a M here. \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-size-contest",
  "Code": [
    {
      "filename": "src/SizeSealed.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ECCMath} from \"./util/ECCMath.sol\";\nimport {ISizeSealed} from \"./interfaces/ISizeSealed.sol\";\nimport {CommonTokenMath} from \"./util/CommonTokenMath.sol\";\n\n/// @title Size Sealed Auction\n/// @author Size Market\ncontract SizeSealed is ISizeSealed {\n    ///////////////////////////////\n    ///          STATE          ///\n    ///////////////////////////////\n\n    uint256 public currentAuctionId;\n\n    mapping(uint256 => Auction) public idToAuction;\n\n    ///////////////////////////////////////////////////\n    ///                  MODIFIERS                  ///\n    ///////////////////////////////////////////////////\n\n    modifier atState(Auction storage a, States _state) {\n        if (block.timestamp < a.timings.startTimestamp) {\n            if (_state != States.Created) revert InvalidState();\n        } else if (block.timestamp < a.timings.endTimestamp) {\n            if (_state != States.AcceptingBids) revert InvalidState();\n        } else if (a.data.lowestQuote != type(uint128).max) {\n            if (_state != States.Finalized) revert InvalidState();\n        } else if (block.timestamp <= a.timings.endTimestamp + 24 hours) {\n            if (_state != States.RevealPeriod) revert InvalidState();\n        } else if (block.timestamp > a.timings.endTimestamp + 24 hours) {\n            if (_state != States.Voided) revert InvalidState();\n        } else {\n            revert();\n        }\n        _;\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n    ///                          AUCTION LOGIC                          ///\n    ///////////////////////////////////////////////////////////////////////\n\n    /// @notice Creates a new sealed auction\n    /// @dev Transfers the `baseToken` from `msg.sender` to the contract\n    /// @return `auctionId` unique to that auction\n    /// @param auctionParams Parameters used during the auction\n    /// @param timings The timestamps at which the auction starts/ends\n    /// @param encryptedSellerPrivKey Encrypted seller's ephemeral private key\n    function createAuction(\n        AuctionParameters calldata auctionParams,\n        Timings calldata timings,\n        bytes calldata encryptedSellerPrivKey\n    ) external returns (uint256) {\n        if (timings.endTimestamp <= block.timestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.startTimestamp >= timings.endTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.endTimestamp > timings.vestingStartTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.vestingStartTimestamp > timings.vestingEndTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.cliffPercent > 1e18) {\n            revert InvalidCliffPercent();\n        }\n        // Revert if the min bid is more than the total reserve of the auction\n        if (\n            FixedPointMathLib.mulDivDown(\n                auctionParams.minimumBidQuote, type(uint128).max, auctionParams.totalBaseAmount\n            ) > auctionParams.reserveQuotePerBase\n        ) {\n            revert InvalidReserve();\n        }\n\n        uint256 auctionId = ++currentAuctionId;\n\n        Auction storage a = idToAuction[auctionId];\n        a.timings = timings;\n\n        a.data.seller = msg.sender;\n        a.data.lowestQuote = type(uint128).max;\n\n        a.params = auctionParams;\n\n        // Passes https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol#L9\n        // Transfer base tokens to auction contract and check for tax tokens\n        uint256 balanceBeforeTransfer = ERC20(auctionParams.baseToken).balanceOf(address(this));\n\n        SafeTransferLib.safeTransferFrom(\n            ERC20(auctionParams.baseToken), msg.sender, address(this), auctionParams.totalBaseAmount\n        );\n\n        uint256 balanceAfterTransfer = ERC20(auctionParams.baseToken).balanceOf(address(this));\n        if (balanceAfterTransfer - balanceBeforeTransfer != auctionParams.totalBaseAmount) {\n            revert UnexpectedBalanceChange();\n        }\n\n        emit AuctionCreated(auctionId, msg.sender, auctionParams, timings, encryptedSellerPrivKey);\n\n        return auctionId;\n    }\n\n    /// @notice Bid on a runnning auction\n    /// @dev Transfers `quoteAmount` of `quoteToken` from bidder to contract\n    /// @return Index of the bid\n    /// @param auctionId Id of the auction to bid on\n    /// @param quoteAmount Amount of `quoteTokens` bidding on a committed amount of `baseTokens`\n    /// @param commitment Hash commitment of the `baseAmount`\n    /// @param pubKey Public key used to encrypt `baseAmount`\n    /// @param encryptedMessage `baseAmount` encrypted to the seller's public key\n    /// @param encryptedPrivateKey Encrypted private key for on-chain storage\n    /// @param proof Merkle proof that checks seller against `merkleRoot` if there is a whitelist\n    function bid(\n        uint256 auctionId,\n        uint128 quoteAmount,\n        bytes32 commitment,\n        ECCMath.Point calldata pubKey,\n        bytes32 encryptedMessage,\n        bytes calldata encryptedPrivateKey,\n        bytes32[] calldata proof\n    ) external atState(idToAuction[auctionId], States.AcceptingBids) returns (uint256) {\n        Auction storage a = idToAuction[auctionId];\n        if (a.params.merkleRoot != bytes32(0)) {\n            bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n            if (!MerkleProofLib.verify(proof, a.params.merkleRoot, leaf)) {\n                revert InvalidProof();\n            }\n        }\n\n        // Seller cannot bid on their own auction\n        if (msg.sender == a.data.seller) {\n            revert UnauthorizedCaller();\n        }\n\n        if (quoteAmount == 0 || quoteAmount == type(uint128).max || quoteAmount < a.params.minimumBidQuote) {\n            revert InvalidBidAmount();\n        }\n\n        EncryptedBid memory ebid;\n        ebid.sender = msg.sender;\n        ebid.quoteAmount = quoteAmount;\n        ebid.commitment = commitment;\n        ebid.pubKey = pubKey;\n        ebid.encryptedMessage = encryptedMessage;\n\n        uint256 bidIndex = a.bids.length;\n        // Max of 1000 bids on an auction to prevent DOS\n        if (bidIndex >= 1000) {\n            revert InvalidState();\n        }\n\n        a.bids.push(ebid);\n\n        SafeTransferLib.safeTransferFrom(ERC20(a.params.quoteToken), msg.sender, address(this), quoteAmount);\n\n        emit Bid(\n            msg.sender, auctionId, bidIndex, quoteAmount, commitment, pubKey, encryptedMessage, encryptedPrivateKey\n        );\n\n        return bidIndex;\n    }\n\n    /// @notice Reveals the private key of the seller\n    /// @dev All valid bids are decrypted after this\n    ///      finalizeData should be empty if seller does not wish to finalize in this tx\n    /// @param privateKey Private key corresponding to the auctions public key\n    /// @param finalizeData Calldata that will be sent to finalize()\n    function reveal(uint256 auctionId, uint256 privateKey, bytes calldata finalizeData)\n        external\n        atState(idToAuction[auctionId], States.RevealPeriod)\n    {\n        Auction storage a = idToAuction[auctionId];\n        if (a.data.seller != msg.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        ECCMath.Point memory pubKey = ECCMath.publicKey(privateKey);\n        if (pubKey.x != a.params.pubKey.x || pubKey.y != a.params.pubKey.y || (pubKey.x == 1 && pubKey.y == 1)) {\n            revert InvalidPrivateKey();\n        }\n\n        a.data.privKey = privateKey;\n\n        emit RevealedKey(auctionId, privateKey);\n\n        if (finalizeData.length != 0) {\n            (uint256[] memory bidIndices, uint128 clearingBase, uint128 clearingQuote) =\n                abi.decode(finalizeData, (uint256[], uint128, uint128));\n            finalize(auctionId, bidIndices, clearingBase, clearingQuote);\n        }\n    }\n\n    // Used to get around stack too deep errors -- even with viaIr\n    struct FinalizeData {\n        uint256 reserveQuotePerBase;\n        uint128 totalBaseAmount;\n        uint128 filledBase;\n        uint256 previousQuotePerBase;\n        uint256 previousIndex;\n    }\n\n    /// @notice Finalises an auction by revealing all bids\n    /// @dev Calculates the minimum `quotePerBase` and marks successful bids\n    /// @param auctionId `auctionId` of the auction to bid on\n    /// @param bidIndices Bids sorted by price descending\n    /// @param clearingBase Denominator in the clearing price calculation\n    /// @param clearingQuote Numerator in the clearing price calculation\n    function finalize(uint256 auctionId, uint256[] memory bidIndices, uint128 clearingBase, uint128 clearingQuote)\n        public\n        atState(idToAuction[auctionId], States.RevealPeriod)\n    {\n        Auction storage a = idToAuction[auctionId];\n        uint256 sellerPriv = a.data.privKey;\n        if (sellerPriv == 0) {\n            revert InvalidPrivateKey();\n        }\n\n        if (bidIndices.length != a.bids.length) {\n            revert InvalidCalldata();\n        }\n\n        FinalizeData memory data;\n        data.reserveQuotePerBase = a.params.reserveQuotePerBase;\n        data.totalBaseAmount = a.params.totalBaseAmount;\n        data.previousQuotePerBase = type(uint256).max;\n\n        // Last filled bid is the clearing price\n        a.data.lowestBase = clearingBase;\n        a.data.lowestQuote = clearingQuote;\n\n        // Bitmap of all the bid indices that have been processed\n        uint256[] memory seenBidMap = new uint256[]((bidIndices.length/256)+1);\n\n        // Fill orders from highest price to lowest price\n        for (uint256 i; i < bidIndices.length; i++) {\n            uint256 bidIndex = bidIndices[i];\n            EncryptedBid storage b = a.bids[bidIndex];\n\n            // Verify this bid index hasn't been seen before\n            uint256 bitmapIndex = bidIndex / 256;\n            uint256 bitMap = seenBidMap[bitmapIndex];\n            uint256 indexBit = 1 << (bidIndex % 256);\n            if (bitMap & indexBit == 1) revert InvalidState();\n            seenBidMap[bitmapIndex] = bitMap | indexBit;\n\n            // G^k1^k2 == G^k2^k1\n            ECCMath.Point memory sharedPoint = ECCMath.ecMul(b.pubKey, sellerPriv);\n            // If the bidder public key isn't on the bn128 curve\n            if (sharedPoint.x == 1 && sharedPoint.y == 1) continue;\n\n            bytes32 decryptedMessage = ECCMath.decryptMessage(sharedPoint, b.encryptedMessage);\n            // If the bidder didn't faithfully submit commitment or pubkey\n            // Or the bid was cancelled\n            if (computeCommitment(decryptedMessage) != b.commitment) continue;\n\n            // First 128 bits are the base amount, last are random salt\n            uint128 baseAmount = uint128(uint256(decryptedMessage >> 128));\n\n            // Require that bids are passed in descending price\n            uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount);\n            if (quotePerBase >= data.previousQuotePerBase) {\n                // If last bid was the same price, make sure we filled the earliest bid first\n                if (quotePerBase == data.previousQuotePerBase) {\n                    if (data.previousIndex > bidIndex) revert InvalidSorting();\n                } else {\n                    revert InvalidSorting();\n                }\n            }\n\n            // Only fill if above reserve price\n            if (quotePerBase < data.reserveQuotePerBase) continue;\n\n            // Auction has been fully filled\n            if (data.filledBase == data.totalBaseAmount) continue;\n\n            data.previousQuotePerBase = quotePerBase;\n            data.previousIndex = bidIndex;\n\n            // Fill the remaining unfilled base amount\n            if (data.filledBase + baseAmount > data.totalBaseAmount) {\n                baseAmount = data.totalBaseAmount - data.filledBase;\n            }\n\n            b.filledBaseAmount = baseAmount;\n            data.filledBase += baseAmount;\n        }\n\n        if (data.previousQuotePerBase != FixedPointMathLib.mulDivDown(clearingQuote, type(uint128).max, clearingBase)) {\n            revert InvalidCalldata();\n        }\n\n        // seenBidMap[0:len-1] should be full\n        for (uint256 i; i < seenBidMap.length - 1; i++) {\n            if (seenBidMap[i] != type(uint256).max) {\n                revert InvalidState();\n            }\n        }\n\n        // seenBidMap[-1] should only have the last N bits set\n        if (seenBidMap[seenBidMap.length - 1] != (1 << (bidIndices.length % 256)) - 1) {\n            revert InvalidState();\n        }\n\n        if (data.filledBase > data.totalBaseAmount) {\n            revert InvalidState();\n        }\n\n        // Transfer the left over baseToken\n        if (data.totalBaseAmount != data.filledBase) {\n            uint128 unsoldBase = data.totalBaseAmount - data.filledBase;\n            a.params.totalBaseAmount = data.filledBase;\n            SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), a.data.seller, unsoldBase);\n        }\n\n        // Calculate quote amount based on clearing price\n        uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), a.data.seller, filledQuote);\n\n        emit AuctionFinalized(auctionId, bidIndices, data.filledBase, filledQuote);\n    }\n\n    /// @notice Called after finalize for unsuccessful bidders to return funds\n    /// @dev Returns all `quoteToken` to the original bidder\n    /// @param auctionId `auctionId` of the auction to bid on\n    /// @param bidIndex Index of the failed bid to be refunded\n    function refund(uint256 auctionId, uint256 bidIndex) external atState(idToAuction[auctionId], States.Finalized) {\n        Auction storage a = idToAuction[auctionId];\n        EncryptedBid storage b = a.bids[bidIndex];\n        if (msg.sender != b.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        if (b.filledBaseAmount != 0) {\n            revert InvalidState();\n        }\n\n        b.sender = address(0);\n\n        emit BidRefund(auctionId, bidIndex);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, b.quoteAmount);\n    }\n\n    /// @notice Called after finalize for successful bidders\n    /// @dev Returns won `baseToken` & any unfilled `quoteToken` to the bidder\n    /// @param auctionId `auctionId` of the auction bid on\n    /// @param bidIndex Index of the successful bid\n    function withdraw(uint256 auctionId, uint256 bidIndex) external atState(idToAuction[auctionId], States.Finalized) {\n        Auction storage a = idToAuction[auctionId];\n        EncryptedBid storage b = a.bids[bidIndex];\n        if (msg.sender != b.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        uint128 baseAmount = b.filledBaseAmount;\n        if (baseAmount == 0) {\n            revert InvalidState();\n        }\n\n        uint128 baseTokensAvailable = tokensAvailableForWithdrawal(auctionId, baseAmount);\n        baseTokensAvailable = baseTokensAvailable - b.baseWithdrawn;\n\n        b.baseWithdrawn += baseTokensAvailable;\n\n        // Refund unfilled quoteAmount on first withdraw\n        if (b.quoteAmount != 0) {\n            uint256 quoteBought = FixedPointMathLib.mulDivDown(baseAmount, a.data.lowestQuote, a.data.lowestBase);\n            uint256 refundedQuote = b.quoteAmount - quoteBought;\n            b.quoteAmount = 0;\n\n            SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, refundedQuote);\n        }\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), msg.sender, baseTokensAvailable);\n\n        emit Withdrawal(auctionId, bidIndex, baseTokensAvailable, baseAmount - b.baseWithdrawn);\n    }\n\n    /// @dev Transfers `baseToken` back to seller and will enable withdraws for bidders\n    /// @param auctionId `auctionId` of the auction to be cancelled\n    function cancelAuction(uint256 auctionId) external {\n        Auction storage a = idToAuction[auctionId];\n        if (msg.sender != a.data.seller) {\n            revert UnauthorizedCaller();\n        }\n        // Only allow cancellations before finalization\n        // Equivalent to atState(idToAuction[auctionId], ~STATE_FINALIZED)\n        if (a.data.lowestQuote != type(uint128).max) {\n            revert InvalidState();\n        }\n\n        // Allowing bidders to cancel bids (withdraw quote)\n        // Auction considered forever States.AcceptingBids but nobody can finalize\n        a.data.seller = address(0);\n        a.timings.endTimestamp = type(uint32).max;\n\n        emit AuctionCancelled(auctionId);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), msg.sender, a.params.totalBaseAmount);\n    }\n\n    /// @dev Transfers `quoteToken` back to bidder and prevents bid from being finalised\n    /// @param auctionId `auctionId` of the auction to be cancelled\n    /// @param bidIndex Index of the bid to be cancelled\n    function cancelBid(uint256 auctionId, uint256 bidIndex)\n        external\n    {\n        Auction storage a = idToAuction[auctionId];\n        EncryptedBid storage b = a.bids[bidIndex];\n        if (msg.sender != b.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        // Only allow bid cancellations while not finalized or in the reveal period\n        if (block.timestamp >= a.timings.endTimestamp) {\n            if (a.data.lowestQuote != type(uint128).max || block.timestamp <= a.timings.endTimestamp + 24 hours) {\n                revert InvalidState();\n            }\n        }\n\n        // Prevent any futher access to this EncryptedBid\n        b.sender = address(0);\n\n        // Prevent seller from finalizing a cancelled bid\n        b.commitment = 0;\n\n        emit BidCancelled(auctionId, bidIndex);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, b.quoteAmount);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    ///                            UTIL FUNCTIONS                            ///\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Calculates available unlocked tokens for an auction\n    /// @dev Uses vesting parameters to account for cliff & linearity\n    /// @return tokensAvailable Amount of unlocked `baseToken` at the current time\n    /// @param auctionId `auctionId` of the auction bid on\n    /// @param baseAmount Amount of total vested `baseToken`\n    function tokensAvailableForWithdrawal(uint256 auctionId, uint128 baseAmount)\n        public\n        view\n        returns (uint128 tokensAvailable)\n    {\n        Auction storage a = idToAuction[auctionId];\n        return CommonTokenMath.tokensAvailableAtTime(\n            a.timings.vestingStartTimestamp,\n            a.timings.vestingEndTimestamp,\n            uint32(block.timestamp),\n            a.timings.cliffPercent,\n            baseAmount\n        );\n    }\n\n    function computeCommitment(bytes32 message) public pure returns (bytes32) {\n        return keccak256(abi.encode(message));\n    }\n\n    function computeMessage(uint128 baseAmount, bytes16 salt) external pure returns (bytes32) {\n        return bytes32(abi.encodePacked(baseAmount, salt));\n    }\n\n    function getTimings(uint256 auctionId) external view returns (Timings memory timings) {\n        timings = idToAuction[auctionId].timings;\n    }\n\n    function getAuctionData(uint256 auctionId) external view returns (AuctionData memory data) {\n        data = idToAuction[auctionId].data;\n    }\n}"
    },
    {
      "filename": "src/SizeSealed.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ECCMath} from \"./util/ECCMath.sol\";\nimport {ISizeSealed} from \"./interfaces/ISizeSealed.sol\";\nimport {CommonTokenMath} from \"./util/CommonTokenMath.sol\";\n\n/// @title Size Sealed Auction\n/// @author Size Market\ncontract SizeSealed is ISizeSealed {\n    ///////////////////////////////\n    ///          STATE          ///\n    ///////////////////////////////\n\n    uint256 public currentAuctionId;\n\n    mapping(uint256 => Auction) public idToAuction;\n\n    ///////////////////////////////////////////////////\n    ///                  MODIFIERS                  ///\n    ///////////////////////////////////////////////////\n\n    modifier atState(Auction storage a, States _state) {\n        if (block.timestamp < a.timings.startTimestamp) {\n            if (_state != States.Created) revert InvalidState();\n        } else if (block.timestamp < a.timings.endTimestamp) {\n            if (_state != States.AcceptingBids) revert InvalidState();\n        } else if (a.data.lowestQuote != type(uint128).max) {\n            if (_state != States.Finalized) revert InvalidState();\n        } else if (block.timestamp <= a.timings.endTimestamp + 24 hours) {\n            if (_state != States.RevealPeriod) revert InvalidState();\n        } else if (block.timestamp > a.timings.endTimestamp + 24 hours) {\n            if (_state != States.Voided) revert InvalidState();\n        } else {\n            revert();\n        }\n        _;\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n    ///                          AUCTION LOGIC                          ///\n    ///////////////////////////////////////////////////////////////////////\n\n    /// @notice Creates a new sealed auction\n    /// @dev Transfers the `baseToken` from `msg.sender` to the contract\n    /// @return `auctionId` unique to that auction\n    /// @param auctionParams Parameters used during the auction\n    /// @param timings The timestamps at which the auction starts/ends\n    /// @param encryptedSellerPrivKey Encrypted seller's ephemeral private key\n    function createAuction(\n        AuctionParameters calldata auctionParams,\n        Timings calldata timings,\n        bytes calldata encryptedSellerPrivKey\n    ) external returns (uint256) {\n        if (timings.endTimestamp <= block.timestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.startTimestamp >= timings.endTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.endTimestamp > timings.vestingStartTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.vestingStartTimestamp > timings.vestingEndTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.cliffPercent > 1e18) {\n            revert InvalidCliffPercent();\n        }\n        // Revert if the min bid is more than the total reserve of the auction\n        if (\n            FixedPointMathLib.mulDivDown(\n                auctionParams.minimumBidQuote, type(uint128).max, auctionParams.totalBaseAmount\n            ) > auctionParams.reserveQuotePerBase\n        ) {\n            revert InvalidReserve();\n        }\n\n        uint256 auctionId = ++currentAuctionId;\n\n        Auction storage a = idToAuction[auctionId];\n        a.timings = timings;\n\n        a.data.seller = msg.sender;\n        a.data.lowestQuote = type(uint128).max;\n\n        a.params = auctionParams;\n\n        // Passes https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol#L9\n        // Transfer base tokens to auction contract and check for tax tokens\n        uint256 balanceBeforeTransfer = ERC20(auctionParams.baseToken).balanceOf(address(this));\n\n        SafeTransferLib.safeTransferFrom(\n            ERC20(auctionParams.baseToken), msg.sender, address(this), auctionParams.totalBaseAmount\n        );\n\n        uint256 balanceAfterTransfer = ERC20(auctionParams.baseToken).balanceOf(address(this));\n        if (balanceAfterTransfer - balanceBeforeTransfer != auctionParams.totalBaseAmount) {\n            revert UnexpectedBalanceChange();\n        }\n\n        emit AuctionCreated(auctionId, msg.sender, auctionParams, timings, encryptedSellerPrivKey);\n\n        return auctionId;\n    }\n\n    /// @notice Bid on a runnning auction\n    /// @dev Transfers `quoteAmount` of `quoteToken` from bidder to contract\n    /// @return Index of the bid\n    /// @param auctionId Id of the auction to bid on\n    /// @param quoteAmount Amount of `quoteTokens` bidding on a committed amount of `baseTokens`\n    /// @param commitment Hash commitment of the `baseAmount`\n    /// @param pubKey Public key used to encrypt `baseAmount`\n    /// @param encryptedMessage `baseAmount` encrypted to the seller's public key\n    /// @param encryptedPrivateKey Encrypted private key for on-chain storage\n    /// @param proof Merkle proof that checks seller against `merkleRoot` if there is a whitelist\n    function bid(\n        uint256 auctionId,\n        uint128 quoteAmount,\n        bytes32 commitment,\n        ECCMath.Point calldata pubKey,\n        bytes32 encryptedMessage,\n        bytes calldata encryptedPrivateKey,\n        bytes32[] calldata proof\n    ) external atState(idToAuction[auctionId], States.AcceptingBids) returns (uint256) {\n        Auction storage a = idToAuction[auctionId];\n        if (a.params.merkleRoot != bytes32(0)) {\n            bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n            if (!MerkleProofLib.verify(proof, a.params.merkleRoot, leaf)) {\n                revert InvalidProof();\n            }\n        }\n\n        // Seller cannot bid on their own auction\n        if (msg.sender == a.data.seller) {\n            revert UnauthorizedCaller();\n        }\n\n        if (quoteAmount == 0 || quoteAmount == type(uint128).max || quoteAmount < a.params.minimumBidQuote) {\n            revert InvalidBidAmount();\n        }\n\n        EncryptedBid memory ebid;\n        ebid.sender = msg.sender;\n        ebid.quoteAmount = quoteAmount;\n        ebid.commitment = commitment;\n        ebid.pubKey = pubKey;\n        ebid.encryptedMessage = encryptedMessage;\n\n        uint256 bidIndex = a.bids.length;\n        // Max of 1000 bids on an auction to prevent DOS\n        if (bidIndex >= 1000) {\n            revert InvalidState();\n        }\n\n        a.bids.push(ebid);\n\n        SafeTransferLib.safeTransferFrom(ERC20(a.params.quoteToken), msg.sender, address(this), quoteAmount);\n\n        emit Bid(\n            msg.sender, auctionId, bidIndex, quoteAmount, commitment, pubKey, encryptedMessage, encryptedPrivateKey\n        );\n\n        return bidIndex;\n    }\n\n    /// @notice Reveals the private key of the seller\n    /// @dev All valid bids are decrypted after this\n    ///      finalizeData should be empty if seller does not wish to finalize in this tx\n    /// @param privateKey Private key corresponding to the auctions public key\n    /// @param finalizeData Calldata that will be sent to finalize()\n    function reveal(uint256 auctionId, uint256 privateKey, bytes calldata finalizeData)\n        external\n        atState(idToAuction[auctionId], States.RevealPeriod)\n    {\n        Auction storage a = idToAuction[auctionId];\n        if (a.data.seller != msg.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        ECCMath.Point memory pubKey = ECCMath.publicKey(privateKey);\n        if (pubKey.x != a.params.pubKey.x || pubKey.y != a.params.pubKey.y || (pubKey.x == 1 && pubKey.y == 1)) {\n            revert InvalidPrivateKey();\n        }\n\n        a.data.privKey = privateKey;\n\n        emit RevealedKey(auctionId, privateKey);\n\n        if (finalizeData.length != 0) {\n            (uint256[] memory bidIndices, uint128 clearingBase, uint128 clearingQuote) =\n                abi.decode(finalizeData, (uint256[], uint128, uint128));\n            finalize(auctionId, bidIndices, clearingBase, clearingQuote);\n        }\n    }\n\n    // Used to get around stack too deep errors -- even with viaIr\n    struct FinalizeData {\n        uint256 reserveQuotePerBase;\n        uint128 totalBaseAmount;\n        uint128 filledBase;\n        uint256 previousQuotePerBase;\n        uint256 previousIndex;\n    }\n\n    /// @notice Finalises an auction by revealing all bids\n    /// @dev Calculates the minimum `quotePerBase` and marks successful bids\n    /// @param auctionId `auctionId` of the auction to bid on\n    /// @param bidIndices Bids sorted by price descending\n    /// @param clearingBase Denominator in the clearing price calculation\n    /// @param clearingQuote Numerator in the clearing price calculation\n    function finalize(uint256 auctionId, uint256[] memory bidIndices, uint128 clearingBase, uint128 clearingQuote)\n        public\n        atState(idToAuction[auctionId], States.RevealPeriod)\n    {\n        Auction storage a = idToAuction[auctionId];\n        uint256 sellerPriv = a.data.privKey;\n        if (sellerPriv == 0) {\n            revert InvalidPrivateKey();\n        }\n\n        if (bidIndices.length != a.bids.length) {\n            revert InvalidCalldata();\n        }\n\n        FinalizeData memory data;\n        data.reserveQuotePerBase = a.params.reserveQuotePerBase;\n        data.totalBaseAmount = a.params.totalBaseAmount;\n        data.previousQuotePerBase = type(uint256).max;\n\n        // Last filled bid is the clearing price\n        a.data.lowestBase = clearingBase;\n        a.data.lowestQuote = clearingQuote;\n\n        // Bitmap of all the bid indices that have been processed\n        uint256[] memory seenBidMap = new uint256[]((bidIndices.length/256)+1);\n\n        // Fill orders from highest price to lowest price\n        for (uint256 i; i < bidIndices.length; i++) {\n            uint256 bidIndex = bidIndices[i];\n            EncryptedBid storage b = a.bids[bidIndex];\n\n            // Verify this bid index hasn't been seen before\n            uint256 bitmapIndex = bidIndex / 256;\n            uint256 bitMap = seenBidMap[bitmapIndex];\n            uint256 indexBit = 1 << (bidIndex % 256);\n            if (bitMap & indexBit == 1) revert InvalidState();\n            seenBidMap[bitmapIndex] = bitMap | indexBit;\n\n            // G^k1^k2 == G^k2^k1\n            ECCMath.Point memory sharedPoint = ECCMath.ecMul(b.pubKey, sellerPriv);\n            // If the bidder public key isn't on the bn128 curve\n            if (sharedPoint.x == 1 && sharedPoint.y == 1) continue;\n\n            bytes32 decryptedMessage = ECCMath.decryptMessage(sharedPoint, b.encryptedMessage);\n            // If the bidder didn't faithfully submit commitment or pubkey\n            // Or the bid was cancelled\n            if (computeCommitment(decryptedMessage) != b.commitment) continue;\n\n            // First 128 bits are the base amount, last are random salt\n            uint128 baseAmount = uint128(uint256(decryptedMessage >> 128));\n\n            // Require that bids are passed in descending price\n            uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount);\n            if (quotePerBase >= data.previousQuotePerBase) {\n                // If last bid was the same price, make sure we filled the earliest bid first\n                if (quotePerBase == data.previousQuotePerBase) {\n                    if (data.previousIndex > bidIndex) revert InvalidSorting();\n                } else {\n                    revert InvalidSorting();\n                }\n            }\n\n            // Only fill if above reserve price\n            if (quotePerBase < data.reserveQuotePerBase) continue;\n\n            // Auction has been fully filled\n            if (data.filledBase == data.totalBaseAmount) continue;\n\n            data.previousQuotePerBase = quotePerBase;\n            data.previousIndex = bidIndex;\n\n            // Fill the remaining unfilled base amount\n            if (data.filledBase + baseAmount > data.totalBaseAmount) {\n                baseAmount = data.totalBaseAmount - data.filledBase;\n            }\n\n            b.filledBaseAmount = baseAmount;\n            data.filledBase += baseAmount;\n        }\n\n        if (data.previousQuotePerBase != FixedPointMathLib.mulDivDown(clearingQuote, type(uint128).max, clearingBase)) {\n            revert InvalidCalldata();\n        }\n\n        // seenBidMap[0:len-1] should be full\n        for (uint256 i; i < seenBidMap.length - 1; i++) {\n            if (seenBidMap[i] != type(uint256).max) {\n                revert InvalidState();\n            }\n        }\n\n        // seenBidMap[-1] should only have the last N bits set\n        if (seenBidMap[seenBidMap.length - 1] != (1 << (bidIndices.length % 256)) - 1) {\n            revert InvalidState();\n        }\n\n        if (data.filledBase > data.totalBaseAmount) {\n            revert InvalidState();\n        }\n\n        // Transfer the left over baseToken\n        if (data.totalBaseAmount != da"
    }
  ]
}