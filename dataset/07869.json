{
  "Title": "[M-02] beforeTokenTransfer called with wrong parameters in LBToken._burn",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-10-traderjoe/blob/37258d595d596c195507234f795fa34e319b0a68/src/LBToken.sol#L237\n\n\n# Vulnerability details\n\n## Impact\nIn `LBToken._burn`, the `_beforeTokenTransfer` hook is called with `from = address(0)` and `to = _account`:\n```solidity\n_beforeTokenTransfer(address(0), _account, _id, _amount);\n```\nThrough a lucky coincidence, it turns out that this in the current setup does not cause a high severity issue. `_burn` is always called with `_account = address(this)`, which means that `LBPair._beforeTokenTransfer` is a NOP. However, this wrong call is very dangerous for future extensions or protocol that built on top of the protocol / fork it.\n\n## Proof Of Concept\nLet's say the protocol is extended with some logic that needs to track mints / burns. The canonical way to do this would be:\n```solidity\nfunction _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount\n    ) internal override(LBToken) {\n\tif (_from == address(0)) {\n\t\t// Mint Logic\n\t} else if (_to == address(0)) {\n\t\t// Burn Logic\n\t}\n}\n```\nSuch an extension would break, which could lead to loss of funds or a bricked system.\n\n## Recommended Mitigation Steps\nCall the hook correctly:\n```solidity\n_beforeTokenTransfer(_account, address(0), _id, _amount);\n```",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-trader-joe-v2-contest",
  "Code": [
    {
      "filename": "src/LBToken.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin/utils/structs/EnumerableSet.sol\";\n\nimport \"./LBErrors.sol\";\nimport \"./interfaces/ILBToken.sol\";\n\n/// @title Liquidity Book Token\n/// @author Trader Joe\n/// @notice The LBToken is an implementation of a multi-token.\n/// It allows to create multi-ERC20 represented by their ids\ncontract LBToken is ILBToken {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /// @dev Mapping from token id to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    /// @dev Mapping from account to spender approvals\n    mapping(address => mapping(address => bool)) private _spenderApprovals;\n\n    /// @dev Mapping from token id to total supplies\n    mapping(uint256 => uint256) private _totalSupplies;\n\n    /// @dev  Mapping from account to set of ids, where user currently have a non-zero balance\n    mapping(address => EnumerableSet.UintSet) private _userIds;\n\n    string private constant _name = \"Liquidity Book Token\";\n    string private constant _symbol = \"LBT\";\n\n    modifier checkApproval(address _from, address _spender) {\n        if (!_isApprovedForAll(_from, _spender)) revert LBToken__SpenderNotApproved(_from, _spender);\n        _;\n    }\n\n    modifier checkAddresses(address _from, address _to) {\n        if (_from == address(0) || _to == address(0)) revert LBToken__TransferFromOrToAddress0();\n        _;\n    }\n\n    modifier checkLength(uint256 _lengthA, uint256 _lengthB) {\n        if (_lengthA != _lengthB) revert LBToken__LengthMismatch(_lengthA, _lengthB);\n        _;\n    }\n\n    /// @notice Returns the name of the token\n    /// @return The name of the token\n    function name() public pure virtual override returns (string memory) {\n        return _name;\n    }\n\n    /// @notice Returns the symbol of the token, usually a shorter version of the name\n    /// @return The symbol of the token\n    function symbol() public pure virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /// @notice Returns the total supply of token of type `id`\n    /// @dev This is the amount of token of type `id` minted minus the amount burned\n    /// @param _id The token id\n    /// @return The total supply of that token id\n    function totalSupply(uint256 _id) public view virtual override returns (uint256) {\n        return _totalSupplies[_id];\n    }\n\n    /// @notice Returns the amount of tokens of type `id` owned by `_account`\n    /// @param _account The address of the owner\n    /// @param _id The token id\n    /// @return The amount of tokens of type `id` owned by `_account`\n    function balanceOf(address _account, uint256 _id) public view virtual override returns (uint256) {\n        return _balances[_id][_account];\n    }\n\n    /// @notice Return the balance of multiple (account/id) pairs\n    /// @param _accounts The addresses of the owners\n    /// @param _ids The token ids\n    /// @return batchBalances The balance for each (account, id) pair\n    function balanceOfBatch(address[] memory _accounts, uint256[] memory _ids)\n        public\n        view\n        virtual\n        override\n        checkLength(_accounts.length, _ids.length)\n        returns (uint256[] memory batchBalances)\n    {\n        batchBalances = new uint256[](_accounts.length);\n\n        unchecked {\n            for (uint256 i; i < _accounts.length; ++i) {\n                batchBalances[i] = balanceOf(_accounts[i], _ids[i]);\n            }\n        }\n    }\n\n    /// @notice Returns the type id at index `_index` where `account` has a non-zero balance\n    /// @param _account The address of the account\n    /// @param _index The position index\n    /// @return The `account` non-zero position at index `_index`\n    function userPositionAtIndex(address _account, uint256 _index) public view virtual override returns (uint256) {\n        return _userIds[_account].at(_index);\n    }\n\n    /// @notice Returns the number of non-zero balances of `account`\n    /// @param _account The address of the account\n    /// @return The number of non-zero balances of `account`\n    function userPositionNumber(address _account) public view virtual override returns (uint256) {\n        return _userIds[_account].length();\n    }\n\n    /// @notice Returns true if `spender` is approved to transfer `_account`'s tokens\n    /// @param _owner The address of the owner\n    /// @param _spender The address of the spender\n    /// @return True if `spender` is approved to transfer `_account`'s tokens\n    function isApprovedForAll(address _owner, address _spender) public view virtual override returns (bool) {\n        return _isApprovedForAll(_owner, _spender);\n    }\n\n    /// @notice Grants or revokes permission to `spender` to transfer the caller's tokens, according to `approved`\n    /// @param _spender The address of the spender\n    /// @param _approved The boolean value to grant or revoke permission\n    function setApprovalForAll(address _spender, bool _approved) public virtual override {\n        _setApprovalForAll(msg.sender, _spender, _approved);\n    }\n\n    /// @notice Transfers `_amount` token of type `_id` from `_from` to `_to`\n    /// @param _from The address of the owner of the token\n    /// @param _to The address of the recipient\n    /// @param _id The token id\n    /// @param _amount The amount to send\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount\n    ) public virtual override checkAddresses(_from, _to) checkApproval(_from, msg.sender) {\n        address _spender = msg.sender;\n\n        _transfer(_from, _to, _id, _amount);\n\n        emit TransferSingle(_spender, _from, _to, _id, _amount);\n    }\n\n    /// @notice Batch transfers `_amount` tokens of type `_id` from `_from` to `_to`\n    /// @param _from The address of the owner of the tokens\n    /// @param _to The address of the recipient\n    /// @param _ids The list of token ids\n    /// @param _amounts The list of amounts to send\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _amounts\n    )\n        public\n        virtual\n        override\n        checkLength(_ids.length, _amounts.length)\n        checkAddresses(_from, _to)\n        checkApproval(_from, msg.sender)\n    {\n        unchecked {\n            for (uint256 i; i < _ids.length; ++i) {\n                _transfer(_from, _to, _ids[i], _amounts[i]);\n            }\n        }\n\n        emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\n    }\n\n    /// @notice Internal function to transfer `_amount` tokens of type `_id` from `_from` to `_to`\n    /// @param _from The address of the owner of the token\n    /// @param _to The address of the recipient\n    /// @param _id The token id\n    /// @param _amount The amount to send\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount\n    ) internal virtual {\n        uint256 _fromBalance = _balances[_id][_from];\n        if (_fromBalance < _amount) revert LBToken__TransferExceedsBalance(_from, _id, _amount);\n\n        _beforeTokenTransfer(_from, _to, _id, _amount);\n\n        uint256 _toBalance = _balances[_id][_to];\n\n        unchecked {\n            _balances[_id][_from] = _fromBalance - _amount;\n            _balances[_id][_to] = _toBalance + _amount;\n        }\n\n        _remove(_from, _id, _fromBalance, _amount);\n        _add(_to, _id, _toBalance, _amount);\n    }\n\n    /// @dev Creates `_amount` tokens of type `_id`, and assigns them to `_account`\n    /// @param _account The address of the recipient\n    /// @param _id The token id\n    /// @param _amount The amount to mint\n    function _mint(\n        address _account,\n        uint256 _id,\n        uint256 _amount\n    ) internal virtual {\n        if (_account == address(0)) revert LBToken__MintToAddress0();\n\n        _beforeTokenTransfer(address(0), _account, _id, _amount);\n\n        _totalSupplies[_id] += _amount;\n\n        uint256 _accountBalance = _balances[_id][_account];\n        unchecked {\n            _balances[_id][_account] = _accountBalance + _amount;\n        }\n\n        _add(_account, _id, _accountBalance, _amount);\n\n        emit TransferSingle(msg.sender, address(0), _account, _id, _amount);\n    }\n\n    /// @dev Destroys `_amount` tokens of type `_id` from `_account`\n    /// @param _account The address of the owner\n    /// @param _id The token id\n    /// @param _amount The amount to destroy\n    function _burn(\n        address _account,\n        uint256 _id,\n        uint256 _amount\n    ) internal virtual {\n        if (_account == address(0)) revert LBToken__BurnFromAddress0();\n\n        uint256 _accountBalance = _balances[_id][_account];\n        if (_accountBalance < _amount) revert LBToken__BurnExceedsBalance(_account, _id, _amount);\n\n        _beforeTokenTransfer(address(0), _account, _id, _amount);\n\n        unchecked {\n            _balances[_id][_account] = _accountBalance - _amount;\n            _totalSupplies[_id] -= _amount;\n        }\n\n        _remove(_account, _id, _accountBalance, _amount);\n\n        emit TransferSingle(msg.sender, _account, address(0), _id, _amount);\n    }\n\n    /// @notice Grants or revokes permission to `spender` to transfer the caller's tokens, according to `approved`\n    /// @param _owner The address of the owner\n    /// @param _spender The address of the spender\n    /// @param _approved The boolean value to grant or revoke permission\n    function _setApprovalForAll(\n        address _owner,\n        address _spender,\n        bool _approved\n    ) internal virtual {\n        if (_owner == _spender) revert LBToken__SelfApproval(_owner);\n\n        _spenderApprovals[_owner][_spender] = _approved;\n        emit ApprovalForAll(_owner, _spender, _approved);\n    }\n\n    /// @notice Returns true if `spender` is approved to transfer `owner`'s tokens\n    /// or if `sender` is the `owner`\n    /// @param _owner The address of the owner\n    /// @param _spender The address of the spender\n    /// @return True if `spender` is approved to transfer `owner`'s tokens\n    function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) {\n        return _owner == _spender || _spenderApprovals[_owner][_spender];\n    }\n\n    /// @notice Internal function to add an id to an user's set\n    /// @param _account The user's address\n    /// @param _id The id of the token\n    /// @param _accountBalance The user's balance\n    /// @param _amount The amount of tokens\n    function _add(\n        address _account,\n        uint256 _id,\n        uint256 _accountBalance,\n        uint256 _amount\n    ) internal {\n        if (_accountBalance == 0 && _amount != 0) {\n            _userIds[_account].add(_id);\n        }\n    }\n\n    /// @notice Internal function to remove an id from an user's set\n    /// @param _account The user's address\n    /// @param _id The id of the token\n    /// @param _accountBalance The user's balance\n    /// @param _amount The amount of tokens\n    function _remove(\n        address _account,\n        uint256 _id,\n        uint256 _accountBalance,\n        uint256 _amount\n    ) internal {\n        if (_accountBalance == _amount && _amount != 0) {\n            _userIds[_account].remove(_id);\n        }\n    }\n\n    /// @notice Hook that is called before any token transfer. This includes minting\n    /// and burning.\n    ///\n    /// Calling conditions (for each `id` and `amount` pair):\n    ///\n    /// - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n    /// of token type `id` will be  transferred to `to`.\n    /// - When `from` is zero, `amount` tokens of token type `id` will be minted\n    /// for `to`.\n    /// - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n    /// will be burned.\n    /// - `from` and `to` are never both zero.\n    /// @param from The address of the owner of the token\n    /// @param to The address of the recipient of the  token\n    /// @param id The id of the token\n    /// @param amount The amount of token of type `id`\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {}\n}"
    }
  ]
}