{
  "Title": "[G-01] Tightly pack storage variables/optimize the order of variable declaration",
  "Content": "The EVM works with 32 byte words. Variables less than 32 bytes can be declared next to eachother in storage and this will pack the values together into a single 32 byte storage slot (if the values combined are <= 32 bytes). If the variables packed together are retrieved together in functions we will effectively save ~2000 gas with every subsequent SLOAD for that storage slot. This is due to us incurring a `Gwarmaccess (100 gas)` versus a `Gcoldsload (2100 gas)`.\nHere, the storage variables can be tightly packed from:\n\n<details>\n\n### We can pack `admin and delay` by reducing the size of delay to uint8, or any other type less than uint96 (Save 1 SLOT: 2100 GAS)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol#L89-L91\n\n**This is possible because we constrain the value of `delay` to 0 - 30** \n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol\n89:    address public admin;\n90:    address public pendingAdmin;\n91:    uint256 public delay;\n```\n\nWe can see why it's safe to reduce the size of the variable delay. When setting delay we are checking that the value set should be between **MINIMUM\\_DELAY and MAXIMUM\\_DELAY** which are constant variables with values 0 and 30 respectively.<br>\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol#L103-L110\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol\n103:    function setDelay(uint256 delay_) public {\n\n105:        require(delay_ >= MINIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must exceed minimum delay.');\n106:        require(delay_ <= MAXIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must not exceed maximum delay.');\n107:        delay = delay_;\n```\n\n**The refactored code would be like this, note that we pack with admin as they are accessed in one transaction**\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol\nindex f4f85883..ab900fed 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol\n@@ -87,8 +87,9 @@ contract NounsDAOExecutorV2 is UUPSUpgradeable, Initializable {\n     uint256 public constant MAXIMUM_DELAY = 30 days;\n\n     address public admin;\n+    uint8 public delay;\n     address public pendingAdmin;\n-    uint256 public delay;\n```\nSome other parts of the code will pass a uint256 thus we can type cast those parts eg \n```diff\n     function setDelay(uint256 delay_) public {\n         require(msg.sender == address(this), 'NounsDAOExecutor::setDelay: Call must come from NounsDAOExecutor.');\n         require(delay_ >= MINIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must exceed minimum delay.');\n         require(delay_ <= MAXIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must not exceed maximum delay.');\n-        delay = delay_;\n+        delay = uint8(delay_);\n\n         emit NewDelay(delay_);\n     }\n```\n\n### Pack admin and delay together by reducing size of delay (Save 1 SLOT: 2.1K Gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol#L66-L68\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n66:    address public admin;\n67:    address public pendingAdmin;\n68:    uint256 public delay;\n```\nWhen setting delay, we have a conditional check that ensures the value of delay is between  2 and 30\n```solidity\n        require(delay_ >= MINIMUM_DELAY, 'NounsDAOExecutor::constructor: Delay must exceed minimum delay.');\n        require(delay_ <= MAXIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must not exceed maximum delay.');\n```\nAs such we know delay will always be less than 30. We can therefore reduce the size of the data type to uint8 and pack the variable with `admin`\n\n```diff\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n@@ -64,9 +64,9 @@ contract NounsDAOExecutor {\n     uint256 public constant MAXIMUM_DELAY = 30 days;\n\n     address public admin;\n+    uint8 public delay;\n     address public pendingAdmin;\n-    uint256 public delay;\n```\n\n### Both duration and timeBuffer can be changed to uint48 (Save 3 SLOTS: 6300 Gas )\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol#L50-L69\n\n**We pack nouns with duration, weth with timeBuffer and minBidIncrementPercentage**\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol\n\n50:    // The Nouns ERC721 token contract\n51:    INounsToken public nouns;\n\n53:    // The address of the WETH contract\n54:    address public weth;\n\n56:    // The minimum amount of time left in an auction after a new bid is created\n57:    uint256 public timeBuffer;\n\n59:    // The minimum price accepted in an auction\n60:    uint256 public reservePrice;\n\n62:    // The minimum percentage difference between the last bid amount and the current bid\n63:    uint8 public minBidIncrementPercentage;\n\n65:    // The duration of a single auction\n66:    uint256 public duration;\n\n68:    // The active auction\n69:    INounsAuctionHouse.Auction public auction;\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol b/packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol\nindex 0bd594b6..2746e3d6 100644\n--- a/packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol\n+++ b/packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol\n@@ -49,21 +49,21 @@ contract NounsAuctionHouseFork is\n\n     // The Nouns ERC721 token contract\n     INounsToken public nouns;\n+    // The duration of a single auction\n+    uint48 public duration;\n\n     // The address of the WETH contract\n     address public weth;\n\n     // The minimum amount of time left in an auction after a new bid is created\n-    uint256 public timeBuffer;\n-\n-    // The minimum price accepted in an auction\n-    uint256 public reservePrice;\n+    uint48 public timeBuffer;\n\n     // The minimum percentage difference between the last bid amount and the current bid\n     uint8 public minBidIncrementPercentage;\n\n-    // The duration of a single auction\n-    uint256 public duration;\n+    // The minimum price accepted in an auction\n+    uint256 public reservePrice;\n+\n\n     // The active auction\n     INounsAuctionHouse.Auction public auction;\n```\n\n### Pack minter with isMinterLocked, descriptor with isDescriptorLocked, seeder with isSeederLocked, escrow with both forkId and forkingPeriodEndTimestamp : From 10 slots to 8 slots (Save 2 SLOTS)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol#L48-L85\n\n**1 SLOT = 2k Gas**<br>\n **Total gas saved: 4K gas**\n\n*For forkingPeriodEndTimestamp we can reduce the size to uint48 as it should be safe for timestamp*\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\n\n49:    address public minter;\n\n52:    INounsDescriptorMinimal public descriptor;\n\n55:    INounsSeeder public seeder;\n\n58:    INounsDAOForkEscrow public escrow;\n\n61:    uint32 public forkId;\n\n64:    uint256 public remainingTokensToClaim;\n\n67:    uint256 public forkingPeriodEndTimestamp;\n\n70:    bool public isMinterLocked;\n\n73:    bool public isDescriptorLocked;\n\n76:    bool public isSeederLocked;\n\n79:    mapping(uint256 => INounsSeeder.Seed) public seeds;\n\n82:    uint256 private _currentNounId;\n\n85:    string private _contractURIHash = 'QmZi1n79FqWt2tTLwCqiy6nLM6xLGRsEPQ5JmReJQKNNzX';\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol b/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\nindex a1f9d6d3..ba8947db 100644\n--- a/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\n+++ b/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\n@@ -48,11 +48,20 @@ contract NounsTokenFork is INounsTokenFork, OwnableUpgradeable, ERC721Checkpoint\n     /// @notice  An address who has permissions to mint Nouns\n     address public minter;\n\n+    /// @notice Whether the minter can be updated\n+    bool public isMinterLocked;\n+\n     /// @notice The Nouns token URI descriptor\n     INounsDescriptorMinimal public descriptor;\n\n+    /// @notice Whether the descriptor can be updated\n+    bool public isDescriptorLocked;\n+\n     /// @notice The Nouns token seeder\n     INounsSeeder public seeder;\n+\n+    /// @notice Whether the seeder can be updated\n+    bool public isSeederLocked;\n\n     /// @notice The escrow contract used to verify ownership of the original Nouns in the post-fork claiming process\n     INounsDAOForkEscrow public escrow;\n@@ -60,20 +69,11 @@ contract NounsTokenFork is INounsTokenFork, OwnableUpgradeable, ERC721Checkpoint\n     /// @notice The fork ID, used when querying the escrow for token ownership\n     uint32 public forkId;\n\n-    /// @notice How many tokens are still available to be claimed by Nouners who put their original Nouns in escrow\n-    uint256 public remainingTokensToClaim;\n-\n     /// @notice The forking period expiration timestamp, after which new tokens cannot be claimed by the original DAO\n-    uint256 public forkingPeriodEndTimestamp;\n+    uint48 public forkingPeriodEndTimestamp;\n\n-    /// @notice Whether the minter can be updated\n-    bool public isMinterLocked;\n-\n-    /// @notice Whether the descriptor can be updated\n-    bool public isDescriptorLocked;\n-\n-    /// @notice Whether the seeder can be updated\n-    bool public isSeederLocked;\n+    /// @notice How many tokens are still available to be claimed by Nouners who put their original Nouns in escrow\n+    uint256 public remainingTokensToClaim;\n\n     /// @notice The noun seeds\n     mapping(uint256 => INounsSeeder.Seed) public seeds;\n```\n\n### Due to how variables are constrained during allocation, their sizes can be reduced to uint48 (Save 4 Slots ) From 10 slots to 6 slots\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol#L380-L403\n\nGas saved: `4 SLots * 2.1K gas` = 8.4K gas\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol\ncontract NounsDAOStorageV1Adjusted is NounsDAOProxyStorage {\n382:    address public vetoer;\n\n385:    uint256 public votingDelay;\n\n388:    uint256 public votingPeriod;\n\n391:    uint256 public proposalThresholdBPS;\n\n394:    uint256 public quorumVotesBPS;\n\n397:    uint256 public proposalCount;\n\n400:    INounsDAOExecutor public timelock;\n\n403:    NounsTokenLike public nouns;\n```\n\n**Whenever votingDelay, votingPeriod, proposalThresholdBPS are being assigned a value, we ensure the value has a limit** See below\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L150-L161\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n150:        require(\n151:            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,\n152:            'NounsDAO::initialize: invalid voting period'\n153:        );\n154:        require(\n155:            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,\n156:            'NounsDAO::initialize: invalid voting delay'\n157:        );\n158:        require(\n159:            proposalThresholdBPS_ >= MIN_PROPOSAL_THRESHOLD_BPS && proposalThresholdBPS_ <= MAX_PROPOSAL_THRESHOLD_BPS,\n160:            'NounsDAO::initialize: invalid proposal threshold bps'\n161:        );\n```\nThe above checks are always made whenever we need to set a value to our storage values. As the checks ensure our values don't exceed a certain number(constant numbers defined) we can inspect the value of the constants and make sure our chosen data type would fit the number.\n\nFor all constants defined in our contracts, for the selected variables here, uint48 would fit without loosing any precision.\n\nWe can therefore pack as follows\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol b/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol\nindex 8fb0b4d3..3fed7bc2 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol\n@@ -382,17 +382,11 @@ contract NounsDAOStorageV1Adjusted is NounsDAOProxyStorage {\n     address public vetoer;\n\n     /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\n-    uint256 public votingDelay;\n+    uint48 public votingDelay;\n\n     /// @notice The duration of voting on a proposal, in blocks\n-    uint256 public votingPeriod;\n-\n-    /// @notice The basis point number of votes required in order for a voter to become a proposer. *DIFFERS from GovernerBravo\n-    uint256 public proposalThresholdBPS;\n-\n-    /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. *DIFFERS from GovernerBravo\n-    uint256 public quorumVotesBPS;\n-\n+    uint48 public votingPeriod;\n+\n     /// @notice The total number of proposals\n     uint256 public proposalCount;\n\n@@ -401,6 +395,10 @@ contract NounsDAOStorageV1Adjusted is NounsDAOProxyStorage {\n\n     /// @notice The address of the Nouns tokens\n     NounsTokenLike public nouns;\n+        /// @notice The basis point number of votes required in order for a voter to become a proposer. *DIFFERS from GovernerBravo\n+    uint48 public proposalThresholdBPS;\n+    /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. *DIFFERS from GovernerBravo\n+    uint48 public quorumVotesBPS;\n\n     /// @notice The official record of all proposals ever proposed\n     mapping(uint256 => Proposal) internal _proposals;\n```\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-nounsdao",
  "Code": [
    {
      "filename": "packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title The Nouns DAO executor and treasury, supporting DAO fork\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// NounsDAOExecutor2.sol is a modified version of Compound Lab's Timelock.sol:\n// https://github.com/compound-finance/compound-protocol/blob/20abad28055a2f91df48a90f8bb6009279a4cb35/contracts/Timelock.sol\n//\n// Timelock.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n// MODIFICATIONS\n// NounsDAOExecutor2.sol is a modified version of NounsDAOExecutor.sol\n//\n// NounsDAOExecutor.sol modifications:\n// NounsDAOExecutor.sol modifies Timelock to use Solidity 0.8.x receive(), fallback(), and built-in over/underflow protection\n// This contract acts as executor of Nouns DAO governance and its treasury, so it has been modified to accept ETH.\n//\n//\n// NounsDAOExecutor2.sol modifications:\n// - `sendETH` and `sendERC20` functions used for DAO forks\n// - is upgradable via UUPSUpgradeable. uses intializer instead of constructor.\n// - `GRACE_PERIOD` has been increased from 14 days to 21 days to allow more time in case of a forking period\n\npragma solidity ^0.8.19;\n\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport { Initializable } from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport { UUPSUpgradeable } from '@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol';\nimport { Address } from '@openzeppelin/contracts/utils/Address.sol';\n\ncontract NounsDAOExecutorV2 is UUPSUpgradeable, Initializable {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event ExecuteTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event QueueTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event ETHSent(address indexed to, uint256 amount);\n    event ERC20Sent(address indexed to, address indexed erc20Token, uint256 amount);\n\n    string public constant NAME = 'NounsDAOExecutorV2';\n\n    /// @dev increased grace period from 14 days to 21 days to allow more time in case of a forking period\n    uint256 public constant GRACE_PERIOD = 21 days;\n    uint256 public constant MINIMUM_DELAY = 2 days;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    function initialize(address admin_, uint256 delay_) public virtual initializer {\n        require(delay_ >= MINIMUM_DELAY, 'NounsDAOExecutor::constructor: Delay must exceed minimum delay.');\n        require(delay_ <= MAXIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must not exceed maximum delay.');\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    function setDelay(uint256 delay_) public {\n        require(msg.sender == address(this), 'NounsDAOExecutor::setDelay: Call must come from NounsDAOExecutor.');\n        require(delay_ >= MINIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must exceed minimum delay.');\n        require(delay_ <= MAXIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must not exceed maximum delay.');\n        delay = delay_;\n\n        emit NewDelay(delay_);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, 'NounsDAOExecutor::acceptAdmin: Call must come from pendingAdmin.');\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(msg.sender);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(\n            msg.sender == address(this),\n            'NounsDAOExecutor::setPendingAdmin: Call must come from NounsDAOExecutor.'\n        );\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin_);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(msg.sender == admin, 'NounsDAOExecutor::queueTransaction: Call must come from admin.');\n        require(\n            eta >= getBlockTimestamp() + delay,\n            'NounsDAOExecutor::queueTransaction: Estimated execution block must satisfy delay.'\n        );\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public {\n        require(msg.sender == admin, 'NounsDAOExecutor::cancelTransaction: Call must come from admin.');\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes memory) {\n        require(msg.sender == admin, 'NounsDAOExecutor::executeTransaction: Call must come from admin.');\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"NounsDAOExecutor::executeTransaction: Transaction hasn't been queued.\");\n        require(\n            getBlockTimestamp() >= eta,\n            \"NounsDAOExecutor::executeTransaction: Transaction hasn't surpassed time lock.\"\n        );\n        require(\n            getBlockTimestamp() <= eta + GRACE_PERIOD,\n            'NounsDAOExecutor::executeTransaction: Transaction is stale.'\n        );\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{ value: value }(callData);\n        require(success, 'NounsDAOExecutor::executeTransaction: Transaction execution reverted.');\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function sendETH(address payable recipient, uint256 ethToSend) external {\n        require(msg.sender == admin, 'NounsDAOExecutor::sendETH: Call must come from admin.');\n\n        recipient.sendValue(ethToSend);\n\n        emit ETHSent(recipient, ethToSend);\n    }\n\n    function sendERC20(\n        address recipient,\n        address erc20Token,\n        uint256 tokensToSend\n    ) external {\n        require(msg.sender == admin, 'NounsDAOExecutor::sendERC20: Call must come from admin.');\n\n        IERC20(erc20Token).safeTransfer(recipient, tokensToSend);\n\n        emit ERC20Sent(recipient, erc20Token, tokensToSend);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address) internal view override {\n        require(\n            msg.sender == address(this),\n            'NounsDAOExecutor::_authorizeUpgrade: Call must come from NounsDAOExecutor.'\n        );\n    }\n}"
    },
    {
      "filename": "packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title The Nouns DAO executor and treasury, supporting DAO fork\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// NounsDAOExecutor2.sol is a modified version of Compound Lab's Timelock.sol:\n// https://github.com/compound-finance/compound-protocol/blob/20abad28055a2f91df48a90f8bb6009279a4cb35/contracts/Timelock.sol\n//\n// Timelock.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n// MODIFICATIONS\n// NounsDAOExecutor2.sol is a modified version of NounsDAOExecutor.sol\n//\n// NounsDAOExecutor.sol modifications:\n// NounsDAOExecutor.sol modifies Timelock to use Solidity 0.8.x receive(), fallback(), and built-in over/underflow protection\n// This contract acts as executor of Nouns DAO governance and its treasury, so it has been modified to accept ETH.\n//\n//\n// NounsDAOExecutor2.sol modifications:\n// - `sendETH` and `sendERC20` functions used for DAO forks\n// - is upgradable via UUPSUpgradeable. uses intializer instead of constructor.\n// - `GRACE_PERIOD` has been increased from 14 days to 21 days to allow more time in case of a forking period\n\npragma solidity ^0.8.19;\n\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport { Initializable } from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport { UUPSUpgradeable } from '@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol';\nimport { Address } from '@openzeppelin/contracts/utils/Address.sol';\n\ncontract NounsDAOExecutorV2 is UUPSUpgradeable, Initializable {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event ExecuteTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event QueueTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event ETHSent(address indexed to, uint256 amount);\n    event ERC20Sent(address indexed to, address indexed erc20Token, uint256 amount);\n\n    string public constant NAME = 'NounsDAOExecutorV2';\n\n    /// @dev increased grace period from 14 days to 21 days to allow more time in case of a forking period\n    uint256 public constant GRACE_PERIOD = 21 days;\n    uint256 public constant MINIMUM_DELAY = 2 days;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    function initialize(address admin_, uint256 delay_) public virtual initializer {\n        require(delay_ >= MINIMUM_DELAY, 'NounsDAOExecutor::constructor: Delay must exceed minimum delay.');\n        require(delay_ <= MAXIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must not exceed maximum delay.');\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    function setDelay(uint256 delay_) public {\n        require(msg.sender == address(this), 'NounsDAOExecutor::setDelay: Call must come from NounsDAOExecutor.');\n        require(delay_ >= MINIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must exceed minimum delay.');\n        require(delay_ <= MAXIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must not exceed maximum delay.');\n        delay = delay_;\n\n        emit NewDelay(delay_);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, 'NounsDAOExecutor::acceptAdmin: Call must come from pendingAdmin.');\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(msg.sender);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(\n            msg.sender == address(this),\n            'NounsDAOExecutor::setPendingAdmin: Call must come from NounsDAOExecutor.'\n        );\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin_);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(msg.sender == admin, 'NounsDAOExecutor::queueTransaction: Call must come from admin.');\n        require(\n            eta >= getBlockTimestamp() + delay,\n            'NounsDAOExecutor::queueTransaction: Estimated execution block must satisfy delay.'\n        );\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public {\n        require(msg.sender == admin, 'NounsDAOExecutor::cancelTransaction: Call must come from admin.');\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes memory) {\n        require(msg.sender == admin, 'NounsDAOExecutor::executeTransaction: Call must come from admin.');\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"NounsDAOExecutor::executeTransaction: Transaction hasn't been queued.\");\n        require(\n            getBlockTimestamp() >= eta,\n            \"NounsDAOExecutor::executeTransaction: Transaction hasn't surpassed time lock.\"\n        );\n        require(\n            getBlockTimestamp() <= eta + GRACE_PERIOD,\n            'NounsDAOExecutor::executeTransaction: Transaction is stale.'\n        );\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{ value: value }(callData);\n        require(success, 'NounsDAOExecutor::executeTransaction: Transaction execution reverted.');\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function sendETH(address payable recipient, uint256 ethToSend) external {\n        require(msg.sender == admin, 'NounsDAOExecutor::sendETH: Call must come from admin.');\n\n        recipient.sendValue(ethToSend);\n\n        emit ETHSent(recipient, ethToSend);\n    }\n\n    function sendERC20(\n        address recipient,\n        address erc20Token,\n        uint256 tokensToSend\n    ) external {\n        require(msg.sender == admin, 'NounsDAOExecutor::sendERC20: Call must come from admin.');\n\n        IERC20(erc20Token).safeTransfer(recipient, tokensToSend);\n\n        emit ERC20Sent(recipient, erc20Token, tokensToSend);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address) internal view override {\n        require(\n            msg.sender == address(this),\n            'NounsDAOExecutor::_authorizeUpgrade: Call must come from NounsDAOExecutor.'\n        );\n    }\n}"
    },
    {
      "filename": "packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title The Nouns DAO executor and treasury\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// NounsDAOExecutor.sol is a modified version of Compound Lab's Timelock.sol:\n// https://github.com/compound-finance/compound-protocol/blob/20abad28055a2f91df48a90f8bb6009279a4cb35/contracts/Timelock.sol\n//\n// Timelock.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n// MODIFICATIONS\n// NounsDAOExecutor.sol modifies Timelock to use Solidity 0.8.x receive(), fallback(), and built-in over/underflow protection\n// This contract acts as executor of Nouns DAO governance and its treasury, so it has been modified to accept ETH.\n\npragma solidity ^0.8.6;\n\ncontract NounsDAOExecutor {\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event ExecuteTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event QueueTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    uint256 public constant GRACE_PERIOD = 14 days;\n    uint256 public constant MINIMUM_DELAY = 2 days;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    constructor(address admin_, uint256 delay_) {\n        require(delay_ >= MINIMUM_DELAY, 'NounsDAOExecutor::constructor: Delay must exceed minimum delay.');\n        require(delay_ <= MAXIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must not exceed maximum delay.');\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    function setDelay(uint256 delay_) public {\n        require(msg.sender == address(this), 'NounsDAOExecutor::setDelay: Call must come from NounsDAOExecutor.');\n        require(delay_ >= MINIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must exceed minimum delay.');\n        require(delay_ <= MAXIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must not exceed maximum delay.');\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, 'NounsDAOExecutor::acceptAdmin: Call must come from pendingAdmin.');\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(\n            msg.sender == address(this),\n            'NounsDAOExecutor::setPendingAdmin: Call must come from NounsDAOExecutor.'\n        );\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(msg.sender == admin, 'NounsDAOExecutor::queueTransaction: Call must come from admin.');\n        require(\n            eta >= getBlockTimestamp() + delay,\n            'NounsDAOExecutor::queueTransaction: Estimated execution block must satisfy delay.'\n        );\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public {\n        require(msg.sender == admin, 'NounsDAOExecutor::cancelTransaction: Call must come from admin.');\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes memory) {\n        require(msg.sender == admin, 'NounsDAOExecutor::executeTransaction: Call must come from admin.');\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"NounsDAOExecutor::executeTransaction: Transaction hasn't been queued.\");\n        require(\n            getBlockTimestamp() >= eta,\n            \"NounsDAOExecutor::executeTransaction: Transaction hasn't surpassed time lock.\"\n        );\n        require(\n            getBlockTimestamp() <= eta + GRACE_PERIOD,\n            'NounsDAOExecutor::executeTransaction: Transaction is stale.'\n        );\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{ value: value }(callData);\n        require(success, 'NounsDAOExecutor::executeTransaction: Transaction execution reverted.');\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    },
    {
      "filename": "packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The Nouns DAO auction house, supporting UUPS upgrades\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// NounsAuctionHouseFork.sol is a modified version of NounsAuctionHouse.sol.\n// NounsAuctionHouse.sol is a modified version of Zora's AuctionHouse.sol:\n// https://github.com/ourzora/auction-house/blob/54a12ec1a6cf562e49f0a4917990474b11350a2d/contracts/AuctionHouse.sol\n//\n// AuctionHouse.sol source code Copyright Zora licensed under the GPL-3.0 license.\n// With modifications by Nounders DAO.\n//\n// NounsAuctionHouseFork.sol Modifications:\n// - Proxy pattern changed from Transparent to UUPS.\n// - Owner is set in the initialize function, instead of in a follow-up transaction.\n\npragma solidity ^0.8.19;\n\nimport { PausableUpgradeable } from '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport { ReentrancyGuardUpgradeable } from '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport { OwnableUpgradeable } from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { INounsAuctionHouse } from '../../../interfaces/INounsAuctionHouse.sol';\nimport { INounsToken } from '../../../interfaces/INounsToken.sol';\nimport { IWETH } from '../../../interfaces/IWETH.sol';\nimport { UUPSUpgradeable } from '@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol';\n\ncontract NounsAuctionHouseFork is\n    INounsAuctionHouse,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    UUPSUpgradeable\n{\n    string public constant NAME = 'NounsAuctionHouseFork';\n\n    // The Nouns ERC721 token contract\n    INounsToken public nouns;\n\n    // The address of the WETH contract\n    address public weth;\n\n    // The minimum amount of time left in an auction after a new bid is created\n    uint256 public timeBuffer;\n\n    // The minimum price accepted in an auction\n    uint256 public reservePrice;\n\n    // The minimum percentage difference between the last bid amount and the current bid\n    uint8 public minBidIncrementPercentage;\n\n    // The duration of a single auction\n    uint256 public duration;\n\n    // The active auction\n    INounsAuctionHouse.Auction public auction;\n\n    /**\n     * @notice Initialize the auction house and base contracts,\n     * populate configuration values, and pause the contract.\n     * @dev This function can only be called once.\n     */\n    function initialize(\n        address _owner,\n        INounsToken _nouns,\n        address _weth,\n        uint256 _timeBuffer,\n        uint256 _reservePrice,\n        uint8 _minBidIncrementPercentage,\n        uint256 _duration\n    ) external initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        _transferOwnership(_owner);\n\n        _pause();\n\n        nouns = _nouns;\n        weth = _weth;\n        timeBuffer = _timeBuffer;\n        reservePrice = _reservePrice;\n        minBidIncrementPercentage = _minBidIncrementPercentage;\n        duration = _duration;\n    }\n\n    /**\n     * @notice Settle the current auction, mint a new Noun, and put it up for auction.\n     */\n    function settleCurrentAndCreateNewAuction() external override nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /**\n     * @notice Settle the current auction.\n     * @dev This function can only be called when the contract is paused.\n     */\n    function settleAuction() external override whenPaused nonReentrant {\n        _settleAuction();\n    }\n\n    /**\n     * @notice Create a bid for a Noun, with a given amount.\n     * @dev This contract only accepts payment in ETH.\n     */\n    function createBid(uint256 nounId) external payable override nonReentrant {\n        INounsAuctionHouse.Auction memory _auction = auction;\n\n        require(_auction.nounId == nounId, 'Noun not up for auction');\n        require(block.timestamp < _auction.endTime, 'Auction expired');\n        require(msg.value >= reservePrice, 'Must send at least reservePrice');\n        require(\n            msg.value >= _auction.amount + ((_auction.amount * minBidIncrementPercentage) / 100),\n            'Must send more than last bid by minBidIncrementPercentage amount'\n        );\n\n        address payable lastBidder = _auction.bidder;\n\n        // Refund the last bidder, if applicable\n        if (lastBidder != address(0)) {\n            _safeTransferETHWithFallback(lastBidder, _auction.amount);\n        }\n\n        auction.amount = msg.value;\n        auction.bidder = payable(msg.sender);\n\n        // Extend the auction if the bid was received within `timeBuffer` of the auction end time\n        bool extended = _auction.endTime - block.timestamp < timeBuffer;\n        if (extended) {\n            auction.endTime = _auction.endTime = block.timestamp + timeBuffer;\n        }\n\n        emit AuctionBid(_auction.nounId, msg.sender, msg.value, extended);\n\n        if (extended) {\n            emit AuctionExtended(_auction.nounId, _auction.endTime);\n        }\n    }\n\n    /**\n     * @notice Pause the Nouns auction house.\n     * @dev This function can only be called by the owner when the\n     * contract is unpaused. While no new auctions can be started when paused,\n     * anyone can settle an ongoing auction.\n     */\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the Nouns auction house.\n     * @dev This function can only be called by the owner when the\n     * contract is paused. If required, this function will start a new auction.\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n\n        if (auction.startTime == 0 || auction.settled) {\n            _createAuction();\n        }\n    }\n\n    /**\n     * @notice Set the auction time buffer.\n     * @dev Only callable by the owner.\n     */\n    function setTimeBuffer(uint256 _timeBuffer) external override onlyOwner {\n        timeBuffer = _timeBuffer;\n\n        emit AuctionTimeBufferUpdated(_timeBuffer);\n    }\n\n    /**\n     * @notice Set the auction reserve price.\n     * @dev Only callable by the owner.\n     */\n    function setReservePrice(uint256 _reservePrice) external override onlyOwner {\n        reservePrice = _reservePrice;\n\n        emit AuctionReservePriceUpdated(_reservePrice);\n    }\n\n    /**\n     * @notice Set the auction minimum bid increment percentage.\n     * @dev Only callable by the owner.\n     */\n    function setMinBidIncrementPercentage(uint8 _minBidIncrementPercentage) external override onlyOwner {\n        minBidIncrementPercentage = _minBidIncrementPercentage;\n\n        emit AuctionMinBidIncrementPercentageUpdated(_minBidIncrementPercentage);\n    }\n\n    /**\n     * @notice Create an auction.\n     * @dev Store the auction details in the `auction` state variable and emit an AuctionCreated event.\n     * If the mint reverts, the minter was updated without pausing this contract first. To remedy this,\n     * catch the revert and pause this contract.\n     */\n    function _createAuction() internal {\n        try nouns.mint() returns (uint256 nounId) {\n            uint256 startTime = block.timestamp;\n            uint256 endTime = startTime + duration;\n\n            auction = Auction({\n                nounId: nounId,\n                amount: 0,\n                startTime: startTime,\n                endTime"
    }
  ]
}