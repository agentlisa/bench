{
  "Title": "Print to console",
  "Content": "##### Description\nThis code was used for testing:\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/adapters/UniswapV3.sol#L230\n##### Recommendation\nWe recommend removing these lines.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/adapters/UniswapV3.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\n// (c) Gearbox.fi, 2021\npragma solidity ^0.7.4;\npragma abicoder v2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {ISwapRouter} from \"../integrations/uniswap/IUniswapV3.sol\";\nimport {BytesLib} from \"../integrations/uniswap/BytesLib.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ICreditFilter} from \"../interfaces/ICreditFilter.sol\";\nimport {ICreditManager} from \"../interfaces/ICreditManager.sol\";\nimport {CreditManager} from \"../credit/CreditManager.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @title UniswapV3 Router adapter\ncontract UniswapV3Adapter is ISwapRouter {\n    using BytesLib for bytes;\n    using SafeMath for uint256;\n\n    ICreditManager public creditManager;\n    ICreditFilter public creditFilter;\n    address public swapContract;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n\n    /// @dev Constructor\n    /// @param _creditManager Address Credit manager\n    /// @param _swapContract Address of swap contract\n    constructor(address _creditManager, address _swapContract) {\n        creditManager = ICreditManager(_creditManager);\n        creditFilter = ICreditFilter(creditManager.creditFilter());\n        swapContract = _swapContract;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        override\n        returns (uint256 amountOut)\n    {\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        );\n\n        creditManager.provideCreditAccountAllowance(\n            creditAccount,\n            swapContract,\n            params.tokenIn\n        );\n\n        ExactInputSingleParams memory paramsUpdate = params;\n        paramsUpdate.recipient = creditAccount;\n\n        // 0x414bf389 = exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(0x414bf389), // +\n            paramsUpdate\n        );\n\n        uint256 balanceBefore = IERC20(paramsUpdate.tokenIn).balanceOf(\n            creditAccount\n        );\n\n        // ToDo: Check for partial execution\n        bytes memory result = creditManager.executeOrder(\n            msg.sender,\n            swapContract,\n            data\n        );\n        (amountOut) = abi.decode(result, (uint256));\n\n        creditFilter.checkCollateralChange(\n            creditAccount,\n            params.tokenIn,\n            params.tokenOut,\n            balanceBefore.sub(\n                IERC20(paramsUpdate.tokenIn).balanceOf(creditAccount)\n            ),\n            amountOut\n        );\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params)\n        external\n        payable\n        override\n        returns (uint256 amountOut)\n    {\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        );\n\n        (address tokenIn, address tokenOut) = _extractTokens(params.path);\n\n        creditManager.provideCreditAccountAllowance(\n            creditAccount,\n            swapContract,\n            tokenIn\n        );\n\n        ExactInputParams memory paramsUpdate = params;\n        paramsUpdate.recipient = creditAccount;\n\n        // 0xc04b8d59 = exactInput((bytes,address,uint256,uint256,uint256))\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(0xc04b8d59), // +\n            paramsUpdate\n        );\n\n        uint256 balanceBefore = IERC20(tokenIn).balanceOf(creditAccount);\n\n        bytes memory result = creditManager.executeOrder(\n            msg.sender,\n            swapContract,\n            data\n        );\n        (amountOut) = abi.decode(result, (uint256));\n\n        creditFilter.checkCollateralChange(\n            creditAccount,\n            tokenIn,\n            tokenOut,\n            balanceBefore.sub(IERC20(tokenIn).balanceOf(creditAccount)),\n            amountOut\n        );\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\n        external\n        payable\n        override\n        returns (uint256 amountIn)\n    {\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        );\n\n        creditManager.provideCreditAccountAllowance(\n            creditAccount,\n            swapContract,\n            params.tokenIn\n        );\n\n        ExactOutputSingleParams memory paramsUpdate = params;\n        paramsUpdate.recipient = creditAccount;\n\n        //\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(0xdb3e2198), //+\n            paramsUpdate\n        );\n\n        uint256 balanceBefore = IERC20(paramsUpdate.tokenOut).balanceOf(\n            creditAccount\n        );\n\n        bytes memory result = creditManager.executeOrder(\n            msg.sender,\n            swapContract,\n            data\n        );\n        (amountIn) = abi.decode(result, (uint256));\n\n        creditFilter.checkCollateralChange(\n            creditAccount,\n            params.tokenIn,\n            params.tokenOut,\n            amountIn,\n            IERC20(paramsUpdate.tokenOut).balanceOf(creditAccount).sub(\n                balanceBefore\n            )\n        );\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params)\n        external\n        payable\n        override\n        returns (uint256 amountIn)\n    {\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        );\n\n        (address tokenOut, address tokenIn) = _extractTokens(params.path);\n\n        console.log(tokenIn);\n        console.log(tokenOut);\n\n        creditManager.provideCreditAccountAllowance(\n            creditAccount,\n            swapContract,\n            tokenIn\n        );\n\n        ExactOutputParams memory paramsUpdate = params;\n        paramsUpdate.recipient = creditAccount;\n\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(0xf28c0498), // exactOutput((bytes,address,uint256,uint256,uint256))\n            paramsUpdate\n        );\n\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(creditAccount);\n\n        {\n            bytes memory result = creditManager.executeOrder(\n                msg.sender,\n                swapContract,\n                data\n            );\n            (amountIn) = abi.decode(result, (uint256));\n        }\n\n        console.log(\"balanceBefore\");\n        console.log(balanceBefore);\n        console.log(IERC20(tokenOut).balanceOf(creditAccount));\n\n        creditFilter.checkCollateralChange(\n            creditAccount,\n            tokenIn,\n            tokenOut,\n            amountIn,\n            IERC20(tokenOut).balanceOf(creditAccount).sub(balanceBefore)\n        );\n    }\n\n    function _extractTokens(bytes memory path)\n        internal\n        pure\n        returns (address tokenA, address tokenB)\n    {\n        tokenA = path.toAddress(0);\n        tokenB = path.toAddress(path.length - ADDR_SIZE);\n    }\n}"
    }
  ]
}