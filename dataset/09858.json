{
  "Title": "[H-02] Gas pricing can be used to extort funds from users of SChain owner",
  "Content": "_Submitted by kirk-baird, also found by leastwood_\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/CommunityPool.sol#L82-L112>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/MessageProxyForMainnet.sol#L235-L250>\n\n### Impact\n\nThe function `refundGasByUser()` can be exploited by the message sender to drain nodes and SChain owners of their balances when processing incoming messages.\n\nWhen a node collates a set of exits from an SChain to Ethereum, they are submitted on-chain via `MessageProxyForMainnet.sol`.  For each message to a registered contract the user is required to pay for the refund via `CommunityPool.refundGasByUser()`.\n\nThe issue occurs in `CommunityPool.refundGasByUser()`  as the amount to be refunded is calculated as `uint amount = tx.gasprice * gas;`, where `gas` is the gas used by the message. Since `tx.gasprice` is set by the node and there is no upper bounds on the price. Since EIP1559 the gas price is `BaseFee + Tip` and although `Base` is predetermined `Tip` is any arbitrary non-zero integer.\n\nThe attack is for a node to set an excessively high `tx.gasprice` which will be refunded out of the balance of the user who initiated the outgoing transaction or if that user has insufficient balance then from the SChain owner.  Since the node submitting the transaction is refunded for their gas they do not lose from setting a higher gas price.\n\nThe impact of the attack is that the user requesting the exit and/or the SChain owner may have their ETH balances depleted to refund the submitter. The impact is worsened as if the user has insufficient balance a message will be sent to the SChain preventing them from making further exits until they have sufficient balance.\n\nNote a similar issue may be seen in `IWallets.refundGasBySchain()` depending on how the gas calculations are performed (they are not in scope but the `TestWallet` also uses `tx.gasprice` in the same manner).\n\n### Proof of Concept\n\nProcessing incoming messages in `MessageProxyForMainnet.sol`\n\n```solidity\n        for (uint256 i = 0; i < messages.length; i++) {\n            gasTotal = gasleft();\n            if (isContractRegistered(bytes32(0), messages[i].destinationContract)) {\n                address receiver = _getGasPayer(fromSchainHash, messages[i], startingCounter + i);\n                _callReceiverContract(fromSchainHash, messages[i], startingCounter + i);\n                notReimbursedGas += communityPool.refundGasByUser(\n                    fromSchainHash,\n                    payable(msg.sender),\n                    receiver,\n                    gasTotal - gasleft() + additionalGasPerMessage\n                );\n            } else {\n                _callReceiverContract(fromSchainHash, messages[i], startingCounter + i);\n                notReimbursedGas += gasTotal - gasleft() + additionalGasPerMessage;\n            }\n        }\n```\n\nRefunding gas in `CommunityPool.sol`\n\n```solidity\n    function refundGasByUser(\n        bytes32 schainHash,\n        address payable node,\n        address user,\n        uint gas\n    )\n        external\n        override\n        onlyMessageProxy\n        returns (uint)\n    {\n        require(node != address(0), \"Node address must be set\");\n        if (!activeUsers[user][schainHash]) {\n            return gas;\n        }\n        uint amount = tx.gasprice * gas;\n        if (amount > _userWallets[user][schainHash]) {\n            amount = _userWallets[user][schainHash];\n        }\n        _userWallets[user][schainHash] = _userWallets[user][schainHash] - amount;\n        if (!_balanceIsSufficient(schainHash, user, 0)) {\n            activeUsers[user][schainHash] = false;\n            messageProxy.postOutgoingMessage(\n                schainHash,\n                schainLinks[schainHash],\n                Messages.encodeLockUserMessage(user)\n            );\n        }\n        node.sendValue(amount);\n        return (tx.gasprice * gas - amount) / tx.gasprice;\n    }\n```\n\n### Recommended Mitigation Steps\n\nOne solution to avoid excessive over refunding of gas fees is to use a gas price oracle rather than `tx.gasprice`.\n\nAn alternate solution is to set a maximum gas price and have some incentives for the node submitting at a gas price below the maximum.\n\n**[cstrangedk (SKALE) resolved](https://github.com/code-423n4/2022-02-skale-findings/issues/28#issuecomment-1176670089):**\n > Resolved via https://github.com/skalenetwork/IMA/pull/1165/\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-02-skale-contest",
  "Code": [
    {
      "filename": "contracts/mainnet/CommunityPool.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    CommunityPool.sol - SKALE Manager\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaiev\n    @author Artem Payvin\n    @author Vadim Yavorsky\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.8.6;\n\nimport \"@skalenetwork/ima-interfaces/mainnet/ICommunityPool.sol\";\nimport \"@skalenetwork/skale-manager-interfaces/IWallets.sol\";\n\nimport \"../Messages.sol\";\nimport \"./Twin.sol\";\n\n\n/**\n * @title CommunityPool\n * @dev Contract contains logic to perform automatic self-recharging ETH for nodes.\n */\ncontract CommunityPool is Twin, ICommunityPool {\n\n    using AddressUpgradeable for address payable;\n\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n\n    // address of user => schainHash => balance of gas wallet in ETH\n    mapping(address => mapping(bytes32 => uint)) private _userWallets;\n\n    // address of user => schainHash => true if unlocked for transferring\n    mapping(address => mapping(bytes32 => bool)) public activeUsers;\n\n    uint public minTransactionGas;    \n\n    /**\n     * @dev Emitted when minimal value in gas for transactions from schain to mainnet was changed \n     */\n    event MinTransactionGasWasChanged(\n        uint oldValue,\n        uint newValue\n    );\n\n    function initialize(\n        IContractManager contractManagerOfSkaleManagerValue,\n        ILinker linker,\n        IMessageProxyForMainnet messageProxyValue\n    )\n        external\n        override\n        initializer\n    {\n        Twin.initialize(contractManagerOfSkaleManagerValue, messageProxyValue);\n        _setupRole(LINKER_ROLE, address(linker));\n        minTransactionGas = 1e6;\n    }\n\n    /**\n     * @dev Allows MessageProxyForMainnet to reimburse gas for transactions \n     * that transfer funds from schain to mainnet.\n     * \n     * Requirements:\n     * \n     * - User that receives funds should have enough funds in their gas wallet.\n     * - Address that should be reimbursed for executing transaction must not be null.\n     */\n    function refundGasByUser(\n        bytes32 schainHash,\n        address payable node,\n        address user,\n        uint gas\n    )\n        external\n        override\n        onlyMessageProxy\n        returns (uint)\n    {\n        require(node != address(0), \"Node address must be set\");\n        if (!activeUsers[user][schainHash]) {\n            return gas;\n        }\n        uint amount = tx.gasprice * gas;\n        if (amount > _userWallets[user][schainHash]) {\n            amount = _userWallets[user][schainHash];\n        }\n        _userWallets[user][schainHash] = _userWallets[user][schainHash] - amount;\n        if (!_balanceIsSufficient(schainHash, user, 0)) {\n            activeUsers[user][schainHash] = false;\n            messageProxy.postOutgoingMessage(\n                schainHash,\n                schainLinks[schainHash],\n                Messages.encodeLockUserMessage(user)\n            );\n        }\n        node.sendValue(amount);\n        return (tx.gasprice * gas - amount) / tx.gasprice;\n    }\n\n    function refundGasBySchainWallet(\n        bytes32 schainHash,\n        address payable node,\n        uint gas\n    )\n        external\n        override\n        onlyMessageProxy\n        returns (bool)\n    {\n        if (gas > 0) {\n            IWallets(contractManagerOfSkaleManager.getContract(\"Wallets\")).refundGasBySchain(\n                schainHash,\n                node,\n                gas,\n                false\n            );\n        }\n        return true;\n    }\n\n    /**\n     * @dev Allows `msg.sender` to recharge their wallet for further gas reimbursement.\n     * \n     * Requirements:\n     * \n     * - 'msg.sender` should recharge their gas wallet for amount that enough to reimburse any \n     *   transaction from schain to mainnet.\n     */\n    function rechargeUserWallet(string calldata schainName, address user) external payable override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(\n            _balanceIsSufficient(schainHash, user, msg.value),\n            \"Not enough ETH for transaction\"\n        );\n        _userWallets[user][schainHash] = _userWallets[user][schainHash] + msg.value;\n        if (!activeUsers[user][schainHash]) {\n            activeUsers[user][schainHash] = true;\n            messageProxy.postOutgoingMessage(\n                schainHash,\n                schainLinks[schainHash],\n                Messages.encodeActivateUserMessage(user)\n            );\n        }\n    }\n\n    /**\n     * @dev Allows `msg.sender` to withdraw funds from their gas wallet.\n     * If `msg.sender` withdraws too much funds,\n     * then he will no longer be able to transfer their tokens on ETH from schain to mainnet.\n     * \n     * Requirements:\n     * \n     * - 'msg.sender` must have sufficient amount of ETH on their gas wallet.\n     */\n    function withdrawFunds(string calldata schainName, uint amount) external override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(amount <= _userWallets[msg.sender][schainHash], \"Balance is too low\");\n        require(!messageProxy.messageInProgress(), \"Message is in progress\");\n        _userWallets[msg.sender][schainHash] = _userWallets[msg.sender][schainHash] - amount;\n        if (\n            !_balanceIsSufficient(schainHash, msg.sender, 0) &&\n            activeUsers[msg.sender][schainHash]\n        ) {\n            activeUsers[msg.sender][schainHash] = false;\n            messageProxy.postOutgoingMessage(\n                schainHash,\n                schainLinks[schainHash],\n                Messages.encodeLockUserMessage(msg.sender)\n            );\n        }\n        payable(msg.sender).sendValue(amount);\n    }\n\n    /**\n     * @dev Allows `msg.sender` set the amount of gas that should be \n     * enough for reimbursing any transaction from schain to mainnet.\n     * \n     * Requirements:\n     * \n     * - 'msg.sender` must have sufficient amount of ETH on their gas wallet.\n     */\n    function setMinTransactionGas(uint newMinTransactionGas) external override {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"CONSTANT_SETTER_ROLE is required\");\n        emit MinTransactionGasWasChanged(minTransactionGas, newMinTransactionGas);\n        minTransactionGas = newMinTransactionGas;\n    }\n\n    /**\n     * @dev Returns the amount of ETH on gas wallet for particular user.\n     */\n    function getBalance(address user, string calldata schainName) external view override returns (uint) {\n        return _userWallets[user][keccak256(abi.encodePacked(schainName))];\n    }\n\n    /**\n     * @dev Checks whether user is active and wallet was recharged for sufficient amount.\n     */\n    function checkUserBalance(bytes32 schainHash, address receiver) external view override returns (bool) {\n        return activeUsers[receiver][schainHash] && _balanceIsSufficient(schainHash, receiver, 0);\n    }\n\n    /**\n     * @dev Checks whether user wallet was recharged for sufficient amount.\n     */\n    function _balanceIsSufficient(bytes32 schainHash, address receiver, uint256 delta) private view returns (bool) {\n        return delta + _userWallets[receiver][schainHash] >= minTransactionGas * tx.gasprice;\n    } \n}"
    },
    {
      "filename": "contracts/mainnet/MessageProxyForMainnet.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxyForMainnet.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@skalenetwork/skale-manager-interfaces/IWallets.sol\";\nimport \"@skalenetwork/skale-manager-interfaces/ISchains.sol\";\nimport \"@skalenetwork/ima-interfaces/mainnet/IMessageProxyForMainnet.sol\";\nimport \"@skalenetwork/ima-interfaces/mainnet/ICommunityPool.sol\";\n\nimport \"../MessageProxy.sol\";\nimport \"./SkaleManagerClient.sol\";\nimport \"./CommunityPool.sol\";\n\ninterface IMessageProxyForMainnetInitializeFunction is IMessageProxyForMainnet {\n    function initializeAllRegisteredContracts(\n        bytes32 schainHash,\n        address[] calldata contracts\n    ) external;\n}\n\n\n/**\n * @title Message Proxy for Mainnet\n * @dev Runs on Mainnet, contains functions to manage the incoming messages from\n * `targetSchainName` and outgoing messages to `fromSchainName`. Every SKALE chain with \n * IMA is therefore connected to MessageProxyForMainnet.\n *\n * Messages from SKALE chains are signed using BLS threshold signatures from the\n * nodes in the chain. Since Ethereum Mainnet has no BLS public key, mainnet\n * messages do not need to be signed.\n */\ncontract MessageProxyForMainnet is SkaleManagerClient, MessageProxy, IMessageProxyForMainnetInitializeFunction {\n\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * 16 Agents\n     * Synchronize time with time.nist.gov\n     * Every agent checks if it is their time slot\n     * Time slots are in increments of 10 seconds\n     * At the start of their slot each agent:\n     * For each connected schain:\n     * Read incoming counter on the dst chain\n     * Read outgoing counter on the src chain\n     * Calculate the difference outgoing - incoming\n     * Call postIncomingMessages function passing (un)signed message array\n     * ID of this schain, Chain 0 represents ETH mainnet,\n    */\n\n    ICommunityPool public communityPool;\n\n    uint256 public headerMessageGasCost;\n    uint256 public messageGasCost;\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _registryContracts;\n    string public version;\n    bool public override messageInProgress;\n\n    /**\n     * @dev Emitted when gas cost for message header was changed.\n     */\n    event GasCostMessageHeaderWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when gas cost for message was changed.\n     */\n    event GasCostMessageWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Reentrancy guard for postIncomingMessages.\n     */\n    modifier messageInProgressLocker() {\n        require(!messageInProgress, \"Message is in progress\");\n        messageInProgress = true;\n        _;\n        messageInProgress = false;\n    }\n\n    /**\n     * @dev Allows DEFAULT_ADMIN_ROLE to initialize registered contracts\n     * Notice - this function will be executed only once during upgrade\n     * \n     * Requirements:\n     * \n     * `msg.sender` should have DEFAULT_ADMIN_ROLE\n     */\n    function initializeAllRegisteredContracts(\n        bytes32 schainHash,\n        address[] calldata contracts\n    ) external override {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"Sender is not authorized\");\n        for (uint256 i = 0; i < contracts.length; i++) {\n            if (\n                deprecatedRegistryContracts[schainHash][contracts[i]] &&\n                !_registryContracts[schainHash].contains(contracts[i])\n            ) {\n                _registryContracts[schainHash].add(contracts[i]);\n                delete deprecatedRegistryContracts[schainHash][contracts[i]];\n            }\n        }\n    }\n\n    /**\n     * @dev Allows `msg.sender` to connect schain with MessageProxyOnMainnet for transferring messages.\n     * \n     * Requirements:\n     * \n     * - Schain name must not be `Mainnet`.\n     */\n    function addConnectedChain(string calldata schainName) external override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(schainHash != MAINNET_HASH, \"SKALE chain name is incorrect\");\n        _addConnectedChain(schainHash);\n    }\n\n    /**\n     * @dev Allows owner of the contract to set CommunityPool address for gas reimbursement.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as DEFAULT_ADMIN_ROLE.\n     * - Address of CommunityPool contract must not be null.\n     */\n    function setCommunityPool(ICommunityPool newCommunityPoolAddress) external override {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"Not authorized caller\");\n        require(address(newCommunityPoolAddress) != address(0), \"CommunityPool address has to be set\");\n        communityPool = newCommunityPoolAddress;\n    }\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for being able to transfer messages from custom contracts.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Schain name must not be `Mainnet`.\n     */\n    function registerExtraContract(string memory schainName, address extraContract) external override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(\n            hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender) ||\n            isSchainOwner(msg.sender, schainHash),\n            \"Not enough permissions to register extra contract\"\n        );\n        require(schainHash != MAINNET_HASH, \"Schain hash can not be equal Mainnet\");        \n        _registerExtraContract(schainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Schain name must not be `Mainnet`.\n     */\n    function removeExtraContract(string memory schainName, address extraContract) external override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(\n            hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender) ||\n            isSchainOwner(msg.sender, schainHash),\n            \"Not enough permissions to register extra contract\"\n        );\n        require(schainHash != MAINNET_HASH, \"Schain hash can not be equal Mainnet\");\n        _removeExtraContract(schainHash, extraContract);\n    }\n\n    /**\n     * @dev Posts incoming message from `fromSchainName`. \n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be authorized caller.\n     * - `fromSchainName` must be initialized.\n     * - `startingCounter` must be equal to the chain's incoming message counter.\n     * - If destination chain is Mainnet, message signature must be valid.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        override(IMessageProxy, MessageProxy)\n        messageInProgressLocker\n    {\n        uint256 gasTotal = gasleft();\n        bytes32 fromSchainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(_checkSchainBalance(fromSchainHash), \"Schain wallet has not enough funds\");\n        require(connectedChains[fromSchainHash].inited, \"Chain is not initialized\");\n        require(messages.length <= MESSAGES_LENGTH, \"Too many messages\");\n        require(\n            startingCounter == connectedChains[fromSchainHash].incomingMessageCounter,\n            \"Starting counter is not equal to incoming message counter\");\n\n        require(\n            _verifyMessages(\n                fromSchainName,\n                _hashedArray(messages, startingCounter, fromSchainName),\n                sign\n            ),\n            \"Signature is not verified\"\n        );\n        uint additionalGasPerMessage = \n            (gasTotal - gasleft() + headerMessageGasCost + messages.length * messageGasCost) / messages.length;\n        uint notReimbursedGas = 0;\n        for (uint256 i = 0; i < messages.length; i++) {\n            gasTotal = gasleft();\n            if (isContractRegistered(bytes32(0), messages[i].destinationContract)) {\n                address receiver = _getGasPayer(fromSchainHash, messages[i], startingCounter + i);\n                _callReceiverContract(fromSchainHash, messages[i], startingCounter + i);\n                notReimbursedGas += communityPool.refundGasByUser(\n                    fromSchainHash,\n                    payable(msg.sender),\n                    receiver,\n                    gasTotal - gasleft() + additionalGasPerMessage\n                );\n            } else {\n                _callReceiverContract(fromSchainHash, messages[i], startingCounter + i);\n                notReimbursedGas += gasTotal - gasleft() + additionalGasPerMessage;\n            }\n        }\n        connectedChains[fromSchainHash].incomingMessageCounter += messages.length;\n        communityPool.refundGasBySchainWallet(fromSchainHash, payable(msg.sender), notReimbursedGas);\n    }\n\n    /**\n     * @dev Sets headerMessageGasCost to a new value.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as CONSTANT_SETTER_ROLE.\n     */\n    function setNewHeaderMessageGasCost(uint256 newHeaderMessageGasCost) external override onlyConstantSetter {\n        emit GasCostMessageHeaderWasChanged(headerMessageGasCost, newHeaderMessageGasCost);\n        headerMessageGasCost = newHeaderMessageGasCost;\n    }\n\n    /**\n     * @dev Sets messageGasCost to a new value.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as CONSTANT_SETTER_ROLE.\n     */\n    function setNewMessageGasCost(uint256 newMessageGasCost) external override onlyConstantSetter {\n        emit GasCostMessageWasChanged(messageGasCost, newMessageGasCost);\n        messageGasCost = newMessageGasCost;\n    }\n\n    /**\n     * @dev Sets new version of contracts on mainnet\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted DEFAULT_ADMIN_ROLE.\n     */\n    function setVersion(string calldata newVersion) external override {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        emit VersionUpdated(version, newVersion);\n        version = newVersion;\n    }\n\n    /**\n     * @dev Creates a new MessageProxyForMainnet contract.\n     */\n    function initialize(IContractManager contractManagerOfSkaleManagerValue) public virtual override initializer {\n        SkaleManagerClient.initialize(contractManagerOfSkaleManagerValue);\n        MessageProxy.initializeMessageProxy(1e6);\n        headerMessageGasCost = 70000;\n        messageGasCost = 9000;\n    }\n\n    /**\n     * @dev Checks whether chain is currently connected.\n     * \n     * Note: Mainnet chain does not have a public key, and is implicitly \n     * connected to MessageProxy.\n     * \n     * Requirements:\n     * \n     * - `schainName` must not be Mainnet.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        override(IMessageProxy, MessageProxy)\n        returns (bool)\n    {\n        require(keccak256(abi.encodePacked(schainName)) != MAINNET_HASH, \"Schain id can not be equal Mainnet\");\n        return super.isConnectedChain(schainName);\n    }\n\n    // private\n\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view override {\n        require(\n            isContractRegistered(bytes32(0), msg.sender)\n                || isContractRegistered(targetChainHash, msg.sender)\n                || isSchainOwner(msg.sender, targetChainHash),\n            \"Sender contract is not registered\"\n        );        \n    }\n\n    /**\n     * @dev Converts calldata structure to memory structure and checks\n     * whether message BLS signature is valid.\n     */\n    function _verifyMessages(\n        string calldata fromSchainName,\n        bytes32 hashedMessages,\n        MessageProxyForMainnet.Signature calldata sign\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return ISchains(\n            contractManagerOfSkaleManager.getContract(\"Schains\")\n        ).verifySchainSignature(\n            sign.blsSignature[0],\n            sign.blsSignature[1],\n            hashedMessages,\n            sign.counter,\n            sign.hashA,\n            sign.hashB,\n            fromSchainName\n        );\n    }\n\n    /**\n     * @dev Checks whether balance of schain wallet is sufficient for \n     * for custom message reimbursement.\n     */\n    function _checkSchainBalance(bytes32 schainHash) internal view returns (bool) {\n        return IWallets(\n            contractManagerOfSkaleManager.getContract(\"Wallets\")\n        ).getSchainBalance(schainHash) >= (MESSAGES_LENGTH + 1) * gasLimit * tx.gasprice;\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        override\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage)\n    {\n        return _registryContracts;\n    }\n}"
    }
  ]
}