{
  "Title": "[H-05] Signatures can be replayed in `withdraw()` to withdraw more tokens than the user originally intended.",
  "Content": "\nSignatures can be replayed in `withdraw()` to withdraw more tokens than the user originally intended.\n\n### Vulnerability Details\n\nIn the TimelockTokenPool.sol contracts, users can provide a signature to allow someone else to withdraw all their withdrawable tokens on their behalf using their signature. [TimelockTokenPool.sol#L170)  ](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/team/TimelockTokenPool.sol#L170)\n\n        function withdraw(address _to, bytes memory _sig) external {\n            if (_to == address(0)) revert INVALID_PARAM();\n            bytes32 hash = keccak256(abi.encodePacked(\"Withdraw unlocked Taiko token to: \", _to));\n     @>     address recipient = ECDSA.recover(hash, _sig);\n            _withdraw(recipient, _to);\n        }\n\nAs seen from above, the signature provided does not include a nonce and this can lead to signature replay attacks. Due to the lack of a nonce,  withdraw() can be called multiple times with the same signature. Therefore, if a user provides a signature to withdraw all his withdrawable tokens at one particular time, an attacker can repeatedly call withdraw() with the same signature to withdraw more tokens than the user originally intended.\nThe vulnerability is similar to [Arbitrum H-01](https://solodit.xyz/issues/h-01-signatures-can-be-replayed-in-castvotewithreasonandparamsbysig-to-use-up-more-votes-than-a-user-intended-code4rena-arbitrum-foundation-arbitrum-foundation-git) where  user's signatures could be replayed to use up more votes than a user intended due to a lack of nonce.\n\n### Recommended Mitigation Steps\n\nConsider using a nonce or other signature replay protection in the TimelockTokenPool contract.\n\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/60#issuecomment-2032045461):**\n > Valid bug report, trying to fix it in this PR: https://github.com/taikoxyz/taiko-mono/pull/16611/files\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/team/TimelockTokenPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../common/EssentialContract.sol\";\n\n/// @title TimelockTokenPool\n/// @notice Contract for managing Taiko tokens allocated to different roles and\n/// individuals.\n///\n/// Manages Taiko tokens through a three-state lifecycle: \"allocated\" to\n/// \"granted, owned, and locked,\" and finally to \"granted, owned, and unlocked.\"\n/// Allocation doesn't transfer ownership unless specified by grant settings.\n/// Conditional allocated tokens can be canceled by invoking `void()`, making\n/// them available for other uses. Once granted and owned, tokens are\n/// irreversible and their unlock schedules are immutable.\n///\n/// We should deploy multiple instances of this contract for different roles:\n/// - investors\n/// - team members, advisors, etc.\n/// - grant program grantees\n/// @custom:security-contact security@taiko.xyz\ncontract TimelockTokenPool is EssentialContract {\n    using SafeERC20 for IERC20;\n\n    struct Grant {\n        uint128 amount;\n        // If non-zero, each TKO (1E18) will need some USD stable to purchase.\n        uint128 costPerToken;\n        // If non-zero, indicates the start time for the recipient to receive\n        // tokens, subject to an unlocking schedule.\n        uint64 grantStart;\n        // If non-zero, indicates the time after which the token to be received\n        // will be actually non-zero\n        uint64 grantCliff;\n        // If non-zero, specifies the total seconds required for the recipient\n        // to fully own all granted tokens.\n        uint32 grantPeriod;\n        // If non-zero, indicates the start time for the recipient to unlock\n        // tokens.\n        uint64 unlockStart;\n        // If non-zero, indicates the time after which the unlock will be\n        // actually non-zero\n        uint64 unlockCliff;\n        // If non-zero, specifies the total seconds required for the recipient\n        // to fully unlock all owned tokens.\n        uint32 unlockPeriod;\n    }\n\n    struct Recipient {\n        uint128 amountWithdrawn;\n        uint128 costPaid;\n        Grant grant;\n    }\n\n    /// @notice The Taiko token address.\n    address public taikoToken;\n\n    /// @notice The cost token address.\n    address public costToken;\n\n    /// @notice The shared vault address.\n    address public sharedVault;\n\n    /// @notice The total amount of tokens granted.\n    uint128 public totalAmountGranted;\n\n    /// @notice The total amount of tokens voided.\n    uint128 public totalAmountVoided;\n\n    /// @notice The total amount of tokens withdrawn.\n    uint128 public totalAmountWithdrawn;\n\n    /// @notice The total cost paid.\n    uint128 public totalCostPaid;\n\n    /// @notice Mapping of recipient address to grant information.\n    mapping(address recipient => Recipient receipt) public recipients;\n\n    uint128[44] private __gap;\n\n    /// @notice Emitted when a grant is made.\n    /// @param recipient The grant recipient address.\n    /// @param grant The grant.\n    event Granted(address indexed recipient, Grant grant);\n\n    /// @notice Emitted when a grant is voided.\n    /// @param recipient The grant recipient address.\n    /// @param amount The amount of tokens voided.\n    event Voided(address indexed recipient, uint128 amount);\n\n    /// @notice Emitted when tokens are withdrawn.\n    /// @param recipient The grant recipient address.\n    /// @param to The address where the granted and unlocked tokens shall be sent to.\n    /// @param amount The amount of tokens withdrawn.\n    /// @param cost The cost.\n    event Withdrawn(address indexed recipient, address to, uint128 amount, uint128 cost);\n\n    error ALREADY_GRANTED();\n    error INVALID_GRANT();\n    error INVALID_PARAM();\n    error NOTHING_TO_VOID();\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner address.\n    /// @param _taikoToken The Taiko token address.\n    /// @param _costToken The cost token address.\n    /// @param _sharedVault The shared vault address.\n    function init(\n        address _owner,\n        address _taikoToken,\n        address _costToken,\n        address _sharedVault\n    )\n        external\n        initializer\n    {\n        __Essential_init(_owner);\n        if (_taikoToken == address(0)) revert INVALID_PARAM();\n        taikoToken = _taikoToken;\n\n        if (_costToken == address(0)) revert INVALID_PARAM();\n        costToken = _costToken;\n\n        if (_sharedVault == address(0)) revert INVALID_PARAM();\n        sharedVault = _sharedVault;\n    }\n\n    /// @notice Gives a grant to a address with its own unlock schedule.\n    /// This transaction should happen on a regular basis, e.g., quarterly.\n    /// @param _recipient The grant recipient address.\n    /// @param _grant The grant struct.\n    function grant(address _recipient, Grant memory _grant) external onlyOwner {\n        if (_recipient == address(0)) revert INVALID_PARAM();\n        if (recipients[_recipient].grant.amount != 0) revert ALREADY_GRANTED();\n\n        _validateGrant(_grant);\n\n        totalAmountGranted += _grant.amount;\n        recipients[_recipient].grant = _grant;\n        emit Granted(_recipient, _grant);\n    }\n\n    /// @notice Puts a stop to all grants for a given recipient. Tokens already\n    /// granted to the recipient will NOT be voided but are subject to the\n    /// original unlock schedule.\n    /// @param _recipient The grant recipient address.\n    function void(address _recipient) external onlyOwner {\n        Recipient storage r = recipients[_recipient];\n        uint128 amountVoided = _voidGrant(r.grant);\n\n        if (amountVoided == 0) revert NOTHING_TO_VOID();\n\n        totalAmountVoided += amountVoided;\n        emit Voided(_recipient, amountVoided);\n    }\n\n    /// @notice Withdraws all withdrawable tokens.\n    function withdraw() external {\n        _withdraw(msg.sender, msg.sender);\n    }\n\n    /// @notice Withdraws all withdrawable tokens.\n    /// @param _to The address where the granted and unlocked tokens shall be sent to.\n    /// @param _sig Signature provided by the grant recipient.\n    function withdraw(address _to, bytes memory _sig) external {\n        if (_to == address(0)) revert INVALID_PARAM();\n        bytes32 hash = keccak256(abi.encodePacked(\"Withdraw unlocked Taiko token to: \", _to));\n        address recipient = ECDSA.recover(hash, _sig);\n        _withdraw(recipient, _to);\n    }\n\n    /// @notice Returns the summary of the grant for a given recipient.\n    function getMyGrantSummary(address _recipient)\n        public\n        view\n        returns (\n            uint128 amountOwned,\n            uint128 amountUnlocked,\n            uint128 amountWithdrawn,\n            uint128 amountToWithdraw,\n            uint128 costToWithdraw\n        )\n    {\n        Recipient storage r = recipients[_recipient];\n\n        amountOwned = _getAmountOwned(r.grant);\n        amountUnlocked = _getAmountUnlocked(r.grant);\n\n        amountWithdrawn = r.amountWithdrawn;\n        amountToWithdraw = amountUnlocked - amountWithdrawn;\n\n        // Note: precision is maintained at the token level rather than the wei level, otherwise,\n        // `costPaid` must be a uint256.\n        uint128 _amountUnlocked = amountUnlocked / 1e18; // divide first\n        costToWithdraw = _amountUnlocked * r.grant.costPerToken - r.costPaid;\n    }\n\n    /// @notice Returns the grant for a given recipient.\n    /// @param _recipient The grant recipient address.\n    /// @return The grant.\n    function getMyGrant(address _recipient) public view returns (Grant memory) {\n        return recipients[_recipient].grant;\n    }\n\n    function _withdraw(address _recipient, address _to) private {\n        Recipient storage r = recipients[_recipient];\n\n        (,,, uint128 amountToWithdraw, uint128 costToWithdraw) = getMyGrantSummary(_recipient);\n\n        r.amountWithdrawn += amountToWithdraw;\n        r.costPaid += costToWithdraw;\n\n        totalAmountWithdrawn += amountToWithdraw;\n        totalCostPaid += costToWithdraw;\n\n        IERC20(taikoToken).transferFrom(sharedVault, _to, amountToWithdraw);\n        IERC20(costToken).safeTransferFrom(_recipient, sharedVault, costToWithdraw);\n\n        emit Withdrawn(_recipient, _to, amountToWithdraw, costToWithdraw);\n    }\n\n    function _voidGrant(Grant storage _grant) private returns (uint128 amountVoided) {\n        uint128 amountOwned = _getAmountOwned(_grant);\n\n        amountVoided = _grant.amount - amountOwned;\n        _grant.amount = amountOwned;\n\n        _grant.grantStart = 0;\n        _grant.grantPeriod = 0;\n    }\n\n    function _getAmountOwned(Grant memory _grant) private view returns (uint128) {\n        return _calcAmount(_grant.amount, _grant.grantStart, _grant.grantCliff, _grant.grantPeriod);\n    }\n\n    function _getAmountUnlocked(Grant memory _grant) private view returns (uint128) {\n        return _calcAmount(\n            _getAmountOwned(_grant), _grant.unlockStart, _grant.unlockCliff, _grant.unlockPeriod\n        );\n    }\n\n    function _calcAmount(\n        uint128 _amount,\n        uint64 _start,\n        uint64 _cliff,\n        uint64 _period\n    )\n        private\n        view\n        returns (uint128)\n    {\n        if (_amount == 0) return 0;\n        if (_start == 0) return _amount;\n        if (block.timestamp <= _start) return 0;\n\n        if (_period == 0) return _amount;\n        if (block.timestamp >= _start + _period) return _amount;\n\n        if (block.timestamp <= _cliff) return 0;\n\n        return _amount * uint64(block.timestamp - _start) / _period;\n    }\n\n    function _validateGrant(Grant memory _grant) private pure {\n        if (_grant.amount == 0) revert INVALID_GRANT();\n        _validateCliff(_grant.grantStart, _grant.grantCliff, _grant.grantPeriod);\n        _validateCliff(_grant.unlockStart, _grant.unlockCliff, _grant.unlockPeriod);\n    }\n\n    function _validateCliff(uint64 _start, uint64 _cliff, uint32 _period) private pure {\n        if (_start == 0 || _period == 0) {\n            if (_cliff > 0) revert INVALID_GRANT();\n        } else {\n            if (_cliff > 0 && _cliff <= _start) revert INVALID_GRANT();\n            if (_cliff >= _start + _period) revert INVALID_GRANT();\n        }\n    }\n}"
    }
  ]
}