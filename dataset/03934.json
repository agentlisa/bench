{
  "Title": "[M05] ETH and FEI can get locked in EthUniswapPCVDeposit",
  "Content": "The [`deposit` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pcv/EthUniswapPCVDeposit.sol#L26) in `EthUniswapPCVDeposit` takes an ETH amount, mints an amount of `FEI`, and uses these to add liquidity to the ETH/FEI Uniswap Pool. The precise amount of `FEI` to mint is calculated in the [`_getAmountFeiToDeposit` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pcv/UniswapPCVDeposit.sol#L48).\n\n\nWhen accepting liquidity, the Uniswap contract [calculates the precise ratio needed](https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/UniswapV2Router01.sol#L46) to maintain the current price, and will not accept liquidity in a different ratio. In the case of a token, this means [Uniswap fetches the exact token amount](https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/UniswapV2Router01.sol#L91) using `transferFrom`, and, in the case of ETH, Uniswap [returns any excess ETH deposited to the sender](https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/UniswapV2Router01.sol#L95). The [`deposit` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pcv/EthUniswapPCVDeposit.sol#L26) does not handle the case where Uniswap does not accept 100% of the ETH and `FEI` as liquidity. This means that if `_getAmountFeiToDeposit` calculates the incorrect amount of `FEI` and ETH to deposit, `FEI` or ETH will become locked inside the `EthUniswapPCVDeposit` contract.\n\n\nThere are two reasons that the `_getAmountFeiToDeposit` might incorrectly calculate the ratio of `FEI` to ETH:\n\n\n* [Fei’s `_getAmountFeiToDeposit`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pcv/UniswapPCVDeposit.sol#L48). and [Uniswap’s `_addLiquidity`](https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/UniswapV2Router01.sol#L30) calculate the amounts to deposit slightly differently: Fei calculates the [`FEI` needed given the reserve sizes and an ETH amount](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pcv/UniswapPCVDeposit.sol#L53), whereas Uniswap calculates the [ETH needed given the reserve sizes and a `FEI` amount](https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/UniswapV2Router01.sol#L46). While this difference is minimal, it leads to small differences in the amounts to deposit.\n* `_getAmountFeiToDeposit` does not always use the actual reserve amounts from Uniswap. The function [`getReserves`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/refs/UniRef.sol#L49) alters the [`FEI` reserve amount used in calculations](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/refs/UniRef.sol#L54-L57) if the Uniswap Pair’s `FEI` balance is larger than the reserve amount, leading to a difference in the ratio used in calculations.\n\n\nConsider implementing logic to handle any `FEI` or ETH that remains in the `EthUniswapPCVDeposit` contract after adding liquidity to Uniswap. Alternatively, consider altering the calculations to exactly mirror those performed in Uniswap.\n\n\n**Update:** *Fixed in [PR#30](https://github.com/fei-protocol/fei-protocol-core/pull/30). The `EthUniswapPCVDeposit` now burns the dust `FEI` after adding liquidity to the ETH/FEI Liquidity Pool, and dust ETH is tacked onto the next deposit.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/pcv/EthUniswapPCVDeposit.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./UniswapPCVDeposit.sol\";\n\n/// @title implementation for an ETH Uniswap LP PCV Deposit\n/// @author Fei Protocol\ncontract EthUniswapPCVDeposit is UniswapPCVDeposit {\n    using Address for address payable;\n\n\t/// @notice ETH Uniswap PCV Deposit constructor\n\t/// @param _core Fei Core for reference\n\t/// @param _pair Uniswap Pair to deposit to\n\t/// @param _router Uniswap Router\n\t/// @param _oracle oracle for reference\n    constructor(\n        address _core, \n        address _pair, \n        address _router, \n        address _oracle\n    ) public UniswapPCVDeposit(_core, _pair, _router, _oracle) {}\n\n    receive() external payable {}\n\n    function deposit(uint ethAmount) external override payable postGenesis {\n    \trequire(ethAmount == msg.value, \"Bonding Curve: Sent value does not equal input\");\n        \n        uint feiAmount = _getAmountFeiToDeposit(ethAmount);\n\n        _addLiquidity(ethAmount, feiAmount);\n\n        emit Deposit(msg.sender, ethAmount);\n    }\n\n    function _removeLiquidity(uint liquidity) internal override returns (uint) {\n        (, uint amountWithdrawn) = router.removeLiquidityETH(\n            address(fei()),\n            liquidity,\n            0,\n            0,\n            address(this),\n            uint(-1)\n        );\n        return amountWithdrawn;\n    }\n\n    function _transferWithdrawn(address to, uint amount) internal override {\n        payable(to).sendValue(amount);\n    }\n\n    function _addLiquidity(uint ethAmount, uint feiAmount) internal {\n        _mintFei(feiAmount);\n        \n        router.addLiquidityETH{value : ethAmount}(address(fei()),\n            feiAmount,\n            0,\n            0,\n            address(this),\n            uint(-1)\n        );\n    }\n}"
    },
    {
      "filename": "contracts/UniswapV2Router01.sol",
      "content": "pragma solidity =0.6.6;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '@uniswap/lib/contracts/libraries/TransferHelper.sol';\n\nimport './libraries/UniswapV2Library.sol';\nimport './interfaces/IUniswapV2Router01.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IWETH.sol';\n\ncontract UniswapV2Router01 is IUniswapV2Router01 {\n    address public immutable override factory;\n    address public immutable override WETH;\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n        _;\n    }\n\n    constructor(address _factory, address _WETH) public {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) private returns (uint amountA, uint amountB) {\n        // create the pair if it doesn't exist yet\n        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n            IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n        }\n        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IUniswapV2Pair(pair).mint(to);\n    }\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = IUniswapV2Pair(pair).mint(to);\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH); // refund dust eth, if any\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public override ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n    }\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public override ensure(deadline) returns (uint amountToken, uint amountETH) {\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external override returns (uint amountA, uint amountB) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n    }\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external override returns (uint amountToken, uint amountETH) {\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to) private {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);\n        _swap(amounts, path, to);\n    }\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]); // refund dust eth, if any\n    }\n\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure override returns (uint amountB) {\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) public pure override returns (uint amountOut) {\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n    }\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) public pure override returns (uint amountIn) {\n        return UniswapV2Library.getAmountOut(amountOut, reserveIn, reserveOut);\n    }\n\n    function getAmountsOut(uint amountIn, address[] memory path) public view override returns (uint[] memory amounts) {\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    }\n\n    function getAmountsIn(uint amountOut, address[] memory path) public view override returns (uint[] memory amounts) {\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    }\n}"
    },
    {
      "filename": "contracts/pcv/UniswapPCVDeposit.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol\";\nimport \"./IPCVDeposit.sol\";\nimport \"../external/Decimal.sol\";\nimport \"../refs/UniRef.sol\";\n\n/// @title abstract implementation for Uniswap LP PCV Deposit\n/// @author Fei Protocol\nabstract contract UniswapPCVDeposit is IPCVDeposit, UniRef {\n\tusing Decimal for Decimal.D256;\n\n\t/// @notice Uniswap PCV Deposit constructor\n\t/// @param _core Fei Core for reference\n\t/// @param _pair Uniswap Pair to deposit to\n\t/// @param _router Uniswap Router\n\t/// @param _oracle oracle for reference\n\tconstructor(\n\t\taddress _core, \n\t\taddress _pair, \n\t\taddress _router, \n\t\taddress _oracle\n\t) public UniRef(_core, _pair, _router, _oracle) {}\n\n\tfunction withdraw(address to, uint amountUnderlying) external override onlyPCVController {\n    \tuint totalUnderlying = totalValue();\n    \trequire(amountUnderlying <= totalUnderlying, \"UniswapPCVDeposit: Insufficient underlying\");\n\n    \tuint totalLiquidity = liquidityOwned();\n    \tDecimal.D256 memory ratioToWithdraw = Decimal.ratio(amountUnderlying, totalUnderlying);\n    \tuint liquidityToWithdraw = ratioToWithdraw.mul(totalLiquidity).asUint256();\n\n    \tuint amountWithdrawn = _removeLiquidity(liquidityToWithdraw);\n\t\t\n    \t_transferWithdrawn(to, amountWithdrawn);\n\t\t\n    \t_burnFeiHeld();\n\n    \temit Withdrawal(msg.sender, to, amountWithdrawn);\n    }\n\n\tfunction totalValue() public view override returns(uint) {\n\t\t(, uint tokenReserves) = getReserves();\n    \treturn ratioOwned().mul(tokenReserves).asUint256();\n    }\n\n\tfunction _getAmountFeiToDeposit(uint amountToken) internal view returns (uint amountFei) {\n\t\t(uint feiReserves, uint tokenReserves) = getReserves();\n\t\tif (feiReserves == 0 || tokenReserves == 0) {\n\t\t\treturn peg().mul(amountToken).asUint256();\n\t\t}\n\t\treturn UniswapV2Library.quote(amountToken, tokenReserves, feiReserves);\n\t}\n\n    function _removeLiquidity(uint amount) internal virtual returns(uint);\n\n    function _transferWithdrawn(address to, uint amount) internal virtual;\n\n}"
    },
    {
      "filename": "contracts/refs/UniRef.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\nimport \"./OracleRef.sol\";\nimport \"./IUniRef.sol\";\n\n/// @title UniRef abstract implementation contract\n/// @author Fei Protocol\nabstract contract UniRef is IUniRef, OracleRef {\n\tusing Decimal for Decimal.D256;\n\tusing Babylonian for uint;\n\n\tIUniswapV2Router02 public override router;\n\tIUniswapV2Pair public override pair;\n\n\t/// @notice UniRef constructor\n\t/// @param _core Fei Core to reference\n    /// @param _pair Uniswap pair to reference\n    /// @param _router Uniswap Router to reference\n    /// @param _oracle oracle to reference\n\tconstructor(address _core, address _pair, address _router, address _oracle) \n        public OracleRef(_core, _oracle) \n    {\n        setupPair(_pair);\n\n        router = IUniswapV2Router02(_router);\n\n        approveToken(address(fei()));\n        approveToken(token());\n        approveToken(_pair);\n    }\n\n\tfunction setPair(address _pair) external override onlyGovernor {\n\t\tsetupPair(_pair);\n\n        approveToken(token());\n        approveToken(_pair);\n\t}\n\n\tfunction token() public override view returns (address) {\n\t\taddress token0 = pair.token0();\n\t\tif (address(fei()) == token0) {\n\t\t\treturn pair.token1();\n\t\t}\n\t\treturn token0;\n\t}\n\n\tfunction getReserves() public override view returns (uint feiReserves, uint tokenReserves) {\n        address token0 = pair.token0();\n        (uint reserve0, uint reserve1,) = pair.getReserves();\n        (feiReserves, tokenReserves) = address(fei()) == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n        \n        uint feiBalance = fei().balanceOf(address(pair));\n        if(feiBalance > feiReserves) {\n            feiReserves = feiBalance;\n        }\n        return (feiReserves, tokenReserves);\n\t}\n\n\tfunction liquidityOwned() public override view returns (uint) {\n\t\treturn pair.balanceOf(address(this));\n\t}\n\n    /// @notice ratio of all pair liquidity owned by this contract\n\tfunction ratioOwned() internal view returns (Decimal.D256 memory) {\t\n    \tuint balance = liquidityOwned();\n    \tuint total = pair.totalSupply();\n    \treturn Decimal.ratio(balance, total);\n    }\n\n    /// @notice returns true if price is below the peg\n    /// @dev counterintuitively checks if peg < price because price is reported as FEI per X\n    function isBelowPeg(Decimal.D256 memory peg) internal view returns (bool) {\n        (Decimal.D256 memory price,,) = getUniswapPrice();\n        return peg.lessThan(price);\n    }\n\n    /// @notice approves a token for the router\n    function approveToken(address _token) internal {\n    \tIERC20(_token).approve(address(router), uint(-1));\n    }\n\n    function setupPair(address _pair) internal {\n    \tpair = IUniswapV2Pair(_pair);\n        emit PairUpdate(_pair);\n    }\n\n    function isPair(address account) internal view returns(bool) {\n        return address(pair) == account;\n    }\n\n    /// @notice utility for calculating absolute distance from peg based on reserves\n    /// @param reserveTarget pair reserves of the asset desired to trade with\n    /// @param reserveOther pair reserves of the non-traded asset\n    /// @param peg the target peg reported as Target per Other \n    function getAmountToPeg(\n        uint reserveTarget, \n        uint reserveOther, \n        Decimal.D256 memory peg\n    ) internal pure returns (uint) {\n        uint radicand = peg.mul(reserveTarget).mul(reserveOther).asUint256();\n        uint root = radicand.sqrt();\n        if (root > reserveTarget) {\n            return root - reserveTarget;\n        }\n        return reserveTarget - root;\n    }\n\n    /// @notice calculate amount of Fei needed to trade back to the peg\n    function getAmountToPegFei() internal view returns (uint) {\n        (uint feiReserves, uint tokenReserves) = getReserves();\n        return getAmountToPeg(feiReserves, tokenReserves, peg());\n    }\n\n    /// @notice calculate amount of the not Fei token needed to trade back to the peg\n    function getAmountToPegOther() internal view returns (uint) {\n        (uint feiReserves, uint tokenReserves) = getReserves();\n        return getAmountToPeg(tokenReserves, feiReserves, invert(peg()));\n    }\n\n    /// @notice get uniswap price and reserves\n    /// @return price reported as Fei per X\n    /// @return reserveFei fei reserves\n    /// @return reserveOther non-fei reserves\n    function getUniswapPrice() internal view returns(\n        Decimal.D256 memory, \n        uint reserveFei, \n        uint reserveOther\n    ) {\n        (reserveFei, reserveOther) = getReserves();\n        return (Decimal.ratio(reserveFei, reserveOther), reserveFei, reserveOther);\n    }\n\n    /// @notice get final uniswap price after hypothetical FEI trade\n    /// @param amountFei a signed integer representing FEI trade. Positive=sell, negative=buy\n    /// @param reserveFei fei reserves\n    /// @param reserveOther non-fei reserves\n    function getFinalPrice(\n    \tint256 amountFei, \n    \tuint reserveFei, \n    \tuint reserveOther\n    ) internal pure returns (Decimal.D256 memory) {\n    \tuint k = reserveFei * reserveOther;\n    \tuint adjustedReserveFei = uint(int256(reserveFei) + amountFei);\n    \tuint adjustedReserveOther = k / adjustedReserveFei;\n    \treturn Decimal.ratio(adjustedReserveFei, adjustedReserveOther); // alt: adjustedReserveFei^2 / k\n    }\n\n    /// @notice return the percent distance from peg before and after a hypothetical trade\n    /// @param amountIn a signed amount of FEI to be traded. Positive=sell, negative=buy \n    /// @return initialDeviation the percent distance from peg before trade\n    /// @return finalDeviation the percent distance from peg after hypothetical trade\n    /// @dev deviations will return Decimal.zero() if above peg\n    function getPriceDeviations(int256 amountIn) internal view returns (\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation\n    ) {\n        (Decimal.D256 memory price, uint reserveFei, uint reserveOther) = getUniswapPrice();\n        initialDeviation = calculateDeviation(price, peg());\n\n        Decimal.D256 memory finalPrice = getFinalPrice(amountIn, reserveFei, reserveOther);\n        finalDeviation = calculateDeviation(finalPrice, peg());\n        \n        return (initialDeviation, finalDeviation);\n    }\n\n    /// @notice return current percent distance from peg\n    /// @dev will return Decimal.zero() if above peg\n    function getDistanceToPeg() internal view returns(Decimal.D256 memory distance) {\n        (Decimal.D256 memory price, , ) = getUniswapPrice();\n        return calculateDeviation(price, peg()); \n    }\n\n    /// @notice get deviation from peg as a percent given price\n    /// @dev will return Decimal.zero() if above peg\n    function calculateDeviation(\n        Decimal.D256 memory price, \n        Decimal.D256 memory peg\n    ) internal pure returns (Decimal.D256 memory) {\n        // If price <= peg, then FEI is more expensive and above peg\n        // In this case we can just return zero for deviation\n        if (price.lessThanOrEqualTo(peg)) {\n            return Decimal.zero();\n        }\n        Decimal.D256 memory delta = price.sub(peg, \"UniRef: price exceeds peg\"); // Should never error\n        return delta.div(peg);\n    }\n}"
    }
  ]
}