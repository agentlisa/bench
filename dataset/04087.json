{
  "Title": "Incorrect logic when burning and minting tokens",
  "Content": "##### Description\n* The `mint()` function defined at the line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/facets/ERC20/ERC20Facet.sol#L44 is for minting new tokens.\nThe amount of tokens is increased on the wallet with the address `_receiver`.\nBut the ERC-20 specification also uses the value of the `totalSupply` variable.\nThis variable is not incremented here.\n\n* At line: https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/facets/ERC20/ERC20Facet.sol#L48. The `burn()` function is for burning tokens. The amount of tokens is reduced on the wallet with the address `_from`.\nBut the ERC-20 specification also uses the value of the `totalSupply` variable. The value of this variable is not decremented here.\nAt the same time, the value of the variable `totalSupply` is used 7 times for calculations in this smart contract: \nhttps://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/facets/Basket/BasketFacet.sol.\n\n##### Recommendation\nThis problem needs to be corrected so that the calculations would be correct.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/facets/ERC20/ERC20Facet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"diamond-2/contracts/libraries/LibDiamond.sol\";\n\nimport \"../../interfaces/IERC20Facet.sol\";\nimport \"./LibERC20Storage.sol\";\nimport \"./LibERC20.sol\";\nimport \"../shared/Access/CallProtection.sol\";\n\ncontract ERC20Facet is IERC20, IERC20Facet, CallProtection {\n  using SafeMath for uint256;\n\n  function initialize(\n    uint256 _initialSupply,\n    string memory _name,\n    string memory _symbol\n  ) external override {\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    require(msg.sender == ds.contractOwner, \"Must own the contract.\");\n\n    LibERC20.mint(msg.sender, _initialSupply);\n\n    es.name = _name;\n    es.symbol = _symbol;\n  }\n\n  function name() external view override returns (string memory) {\n    return LibERC20Storage.erc20Storage().name;\n  }\n\n  function symbol() external view override returns (string memory) {\n    return LibERC20Storage.erc20Storage().symbol;\n  }\n\n  function decimals() external pure override returns (uint8) {\n    return 18;\n  }\n\n  function mint(address _receiver, uint256 _amount) external override protectedCall {\n    LibERC20.mint(_receiver, _amount);\n  }\n\n  function burn(address _from, uint256 _amount) external override protectedCall {\n    LibERC20.burn(_from, _amount);\n  }\n\n  function approve(address _spender, uint256 _amount)\n    external\n    override\n    returns (bool)\n  {\n    LibERC20Storage.erc20Storage().allowances[msg.sender][_spender] = _amount;\n    emit Approval(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  function transfer(address _to, uint256 _amount)\n    external\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, _to, _amount);\n    return true;\n  }\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external override returns (bool) {\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    // Update approval if not set to max uint256\n    if (es.allowances[_from][msg.sender] != uint256(-1)) {\n      uint256 newApproval = es.allowances[_from][msg.sender].sub(_amount);\n      es.allowances[_from][msg.sender] = newApproval;\n      emit Approval(_from, msg.sender, newApproval);\n    }\n\n    _transfer(_from, _to, _amount);\n  }\n\n  function allowance(address _owner, address _spender)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return LibERC20Storage.erc20Storage().allowances[_owner][_spender];\n  }\n\n  function balanceOf(address _of) external view override returns (uint256) {\n    return LibERC20Storage.erc20Storage().balances[_of];\n  }\n\n  function totalSupply() external view override returns (uint256) {\n    return LibERC20Storage.erc20Storage().totalSupply;\n  }\n\n  function _transfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal {\n    if (_to == address(0)) {\n      return LibERC20.burn(msg.sender, _amount);\n    }\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    es.balances[_from] = es.balances[_from].sub(_amount);\n    es.balances[_to] = es.balances[_to].add(_amount);\n\n    emit Transfer(_from, _to, _amount);\n  }\n}"
    },
    {
      "filename": "contracts/facets/ERC20/ERC20Facet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"diamond-2/contracts/libraries/LibDiamond.sol\";\n\nimport \"../../interfaces/IERC20Facet.sol\";\nimport \"./LibERC20Storage.sol\";\nimport \"./LibERC20.sol\";\nimport \"../shared/Access/CallProtection.sol\";\n\ncontract ERC20Facet is IERC20, IERC20Facet, CallProtection {\n  using SafeMath for uint256;\n\n  function initialize(\n    uint256 _initialSupply,\n    string memory _name,\n    string memory _symbol\n  ) external override {\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    require(msg.sender == ds.contractOwner, \"Must own the contract.\");\n\n    LibERC20.mint(msg.sender, _initialSupply);\n\n    es.name = _name;\n    es.symbol = _symbol;\n  }\n\n  function name() external view override returns (string memory) {\n    return LibERC20Storage.erc20Storage().name;\n  }\n\n  function symbol() external view override returns (string memory) {\n    return LibERC20Storage.erc20Storage().symbol;\n  }\n\n  function decimals() external pure override returns (uint8) {\n    return 18;\n  }\n\n  function mint(address _receiver, uint256 _amount) external override protectedCall {\n    LibERC20.mint(_receiver, _amount);\n  }\n\n  function burn(address _from, uint256 _amount) external override protectedCall {\n    LibERC20.burn(_from, _amount);\n  }\n\n  function approve(address _spender, uint256 _amount)\n    external\n    override\n    returns (bool)\n  {\n    LibERC20Storage.erc20Storage().allowances[msg.sender][_spender] = _amount;\n    emit Approval(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  function transfer(address _to, uint256 _amount)\n    external\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, _to, _amount);\n    return true;\n  }\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external override returns (bool) {\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    // Update approval if not set to max uint256\n    if (es.allowances[_from][msg.sender] != uint256(-1)) {\n      uint256 newApproval = es.allowances[_from][msg.sender].sub(_amount);\n      es.allowances[_from][msg.sender] = newApproval;\n      emit Approval(_from, msg.sender, newApproval);\n    }\n\n    _transfer(_from, _to, _amount);\n  }\n\n  function allowance(address _owner, address _spender)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return LibERC20Storage.erc20Storage().allowances[_owner][_spender];\n  }\n\n  function balanceOf(address _of) external view override returns (uint256) {\n    return LibERC20Storage.erc20Storage().balances[_of];\n  }\n\n  function totalSupply() external view override returns (uint256) {\n    return LibERC20Storage.erc20Storage().totalSupply;\n  }\n\n  function _transfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal {\n    if (_to == address(0)) {\n      return LibERC20.burn(msg.sender, _amount);\n    }\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    es.balances[_from] = es.balances[_from].sub(_amount);\n    es.balances[_to] = es.balances[_to].add(_amount);\n\n    emit Transfer(_from, _to, _amount);\n  }\n}"
    }
  ]
}