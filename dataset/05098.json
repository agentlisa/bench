{
  "Title": "[M-08] Borrowers can DoS liquidations by repaying as little as 1 share.",
  "Content": "\nLiquidations can be DoSed which increments the risk of bad debt being generated on position.\n\n### Proof of Concept\n\nWhen a liquidator is liquidating a position in `WiseLending`, the liquidator needs to specify the amount of shares to be repaid. The liquidation logic checks if the positions are indeed liquidable, if so, it validates if the number of shares to be liquidated exceeds the total amount of shares that can be liquidated by using the [`WiseSecurityHelper.checkMaxShares() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurityHelper.sol#L876-L900). If the amount of shares the liquidator intends to liquidate exceeds the maximum amount of liquidable shares, the execution is reverted.\n\n- When the position has generated bad debt, the liquidation can liquidate all the user's `borrowShares` on the pool been liquidated.\n- When the position has not generated bad debt, the maximum amount of liquidable shares is 50% of the existing user's `borrowShares` on the pool being liquidated.\n\nThe problem with this approach is that borrowers can frontrun the liquidation and repay as little as 1 share of the existing debt on the same pool that the liquidator decided to liquidate the debt from. This will cause when the liquidation is executed, the total borrow shares of the user on the pool being liquidated to be lower. If the liquidator was trying to liquidate the maximum possible amount of shares, now, the `maxShares` that can be liquidated will be slightly less than the amount of shares that the liquidator specified, which will cause the tx to revert.\n\n```\n    function checkMaxShares(\n        uint256 _nftId,\n        address _tokenToPayback,\n        uint256 _borrowETHTotal,\n        uint256 _unweightedCollateralETH,\n        uint256 _shareAmountToPay\n    )\n        public\n        view\n    {\n        //@audit-ok => total borrowShares a position owns for a _tokenToPayback pool\n        uint256 totalSharesUser = WISE_LENDING.getPositionBorrowShares(\n            _nftId,\n            _tokenToPayback\n        );\n\n        //@audit-info => If baddebt, maxShares that can be liquidated are the totalSharesUser\n        //@audit-info => If not baddebt, maxShares can be 50% of the total borrowShares\n        uint256 maxShares = checkBadDebtThreshold(_borrowETHTotal, _unweightedCollateralETH)\n            ? totalSharesUser\n            : totalSharesUser * MAX_LIQUIDATION_50 / PRECISION_FACTOR_E18;\n\n        if (_shareAmountToPay <= maxShares) {\n            return;\n        }\n\n        //@audit-issue => reverts if the amount of shares to be repaid exceeds maxShares!\n        revert TooManyShares();\n    }\n```\n\nFor example, if there is a position in a liquidable state that has 100 `borrowShares` on the `PoolA`, and a liquidator decides to liquidate the maximum possible amount of shares from this position, it will send a tx to liquidate 50 shares from that position on the `PoolA`. The position's owner can use the [`WiseLending.paybackExactShares() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L1204-L1238) to repay 1 share and frontrun the liquidator's tx. Now, when the liquidator's tx is executed, the position is still liquidable, but it only has 99 `borrowShares` on the `PoolA`. As a result of this, the [`WiseSecurityHelper.checkMaxShares() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurityHelper.sol#L876-L900) will determine that the maximum possible amount of liquidable shares is 49.5, and because the liquidator specified that he intended to liquidate 50 shares, the tx will be reverted.\n\n### Recommended Mitigation Steps\n\nIn the [`WiseSecurityHelper.checkMaxShares() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurityHelper.sol#L876-L900), if the `_shareAmountToPay` exceeds `maxShares`, don't revert; re-adjust the number of shares that can be liquidated. Return the final value of `_shareAmountToPay` and forward it back to the [`WiseLending.liquidatePartiallyFromTokens() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L1250-L1309). Then, use the final value of `shareAmountToPay` to compute the exact amount of tokens to be repaid in the [`WiseLending.liquidatePartiallyFromTokens() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L1250-L1309).\n\n`WiseSecurity.sol`:\n\n```\n    function checksLiquidation(\n        ...\n        uint256 _shareAmountToPay\n    )\n        external\n        view\n    +   returns (uint256)\n    {\n        ...\n\n\n    -   checkMaxShares(\n    +   return checkMaxShares( \n            _nftIdLiquidate,\n            _tokenToPayback,\n            borrowETHTotal,\n            unweightedCollateralETH,\n            _shareAmountToPay\n        );\n    }\n```\n\n`WiseSecurityHelper.sol`:\n\n```\nfunction checkMaxShares(\n    ...\n    uint256 _shareAmountToPay\n)\n    public\n    view\n+   returns (uint256)    \n{\n    ...\n\n    uint256 maxShares = checkBadDebtThreshold(_borrowETHTotal, _unweightedCollateralETH)\n            ? totalSharesUser\n            : totalSharesUser * MAX_LIQUIDATION_50 / PRECISION_FACTOR_E18;\n\n    if (_shareAmountToPay <= maxShares) {\n-       return;\n+       return _shareAmountToPay;\n+   } else {\n+       return maxShares;\n+   }\n\n-   revert TooManyShares();\n}\n```\n\n`WiseLending.sol`:\n\n```\n    function liquidatePartiallyFromTokens(\n        ...\n        uint256 _shareAmountToPay\n    )\n        ...\n    {\n        ...\n\n    -   data.shareAmountToPay = _shareAmountToPay;\n\n        ...\n\n        //@audit-info => First, determine the maximum amount of liquidable shares\n    +   data.shareAmountToPay = WISE_SECURITY.checksLiquidation(\n    +     _nftId,\n    +     _paybackToken,\n    +     _shareAmountToPay\n    +   );\n\n        //@audit-info => Then, compute the exact amount of tokens required to liquidate the final amount of liquidable shares\n        data.paybackAmount = paybackAmount(\n            _paybackToken,\n    -       _shareAmountToPay\n    +       data.shareAmountToPay\n        );\n\n        ...\n\n    -   WISE_SECURITY.checksLiquidation(\n    -       _nftId,\n    -       _paybackToken,\n    -       _shareAmountToPay\n    -   );\n\n        ...\n    }\n```\n\n### Assessed type\n\nContext\n\n**[vonMangoldt (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/237#issuecomment-2009554797):**\n > Instead of wasting gas by frontrunning a newbie liquidator they could also make money and liquidate themselves. On Arbitrum it's not possible at all. If liquidators don't use tools like flashbots or eden, it's their own fault. No reason to do anything here, in my opinion. Dismissed.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/237#issuecomment-2020890116):**\n > Whether the option for liquidators to bypass hacks through private mempools is grounds for reducing severity of their abuse is not a trivial question and would best be standardized in the Supreme Court.\n> \n> I'm taking a stance that this cheap hack is annoying enough for liquidators to be worth Medium severity. Note that if private mempool is in-scope, attacker can use it as well and insert the annoying TX at start of block.\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/237#issuecomment-2090437915):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n>\n> Mentioned issue does not seem to be in interest of the borrower, since borrower is more incentivized to perform self-liquidation to earn than preventing others, which becomes a race on who will liquidate first making liquidation a more desired outcome for both parties, no intention to gate the minimum payback threshold by admin.\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/WiseSecurity/WiseSecurityHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./WiseSecurityDeclarations.sol\";\n\nabstract contract WiseSecurityHelper is WiseSecurityDeclarations {\n\n    /**\n     * @dev Read function returning weighted and\n     * and unweighted total collateral of a\n     * postion with {_nftId} (unweighted means\n     * collateral factor equals 1E18).\n     */\n    function overallETHCollateralsBoth(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256, uint256)\n    {\n        uint256 amount;\n        uint256 weightedTotal;\n        uint256 unweightedAmount;\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            amount = getFullCollateralETH(\n                _nftId,\n                tokenAddress\n            );\n\n            weightedTotal += amount\n                * WISE_LENDING.lendingPoolData(tokenAddress).collateralFactor\n                / PRECISION_FACTOR_E18;\n\n            unweightedAmount += amount;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (\n            weightedTotal,\n            unweightedAmount\n        );\n    }\n\n    /**\n     * @dev Read function returning weighted\n     *  total collateral of a postion with {_nftId}.\n     */\n    function overallETHCollateralsWeighted(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 weightedTotal)\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            _checkPoolCondition(\n                tokenAddress\n            );\n\n            weightedTotal += WISE_LENDING.lendingPoolData(tokenAddress).collateralFactor\n                * getFullCollateralETH(\n                    _nftId,\n                    tokenAddress\n                ) / PRECISION_FACTOR_E18;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Read function returning unweighted\n     *  total collateral of a postion with {_nftId}\n     * (unweighted means collateral factor equals 1E18).\n     */\n    function overallETHCollateralsBare(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 amount)\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            amount += getFullCollateralETH(\n                _nftId,\n                tokenAddress\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Internal calculation function returning\n     * the updated weighted collateral amount of a\n     * postion with {_nftId}. Result can be\n     * extrapolated linear with length {_interval}.\n     */\n    function _overallETHCollateralsWeighted(\n        uint256 _nftId,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256 weightedTotal)\n    {\n        uint256 i;\n        address tokenAddress;\n\n        uint256 l = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            _checkPoolCondition(\n                tokenAddress\n            );\n\n            weightedTotal += WISE_LENDING.lendingPoolData(tokenAddress).collateralFactor\n                * _getCollateralOfTokenETHUpdated(\n                    _nftId,\n                    tokenAddress,\n                    _interval\n                ) / PRECISION_FACTOR_E18;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Read function returning the full bare\n     * collateral amount of a {_poolToken} from a\n     * {_nftId}. Full means sum of private and\n     * public added funds.\n     */\n    function getFullCollateralETH(\n        uint256 _nftId,\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256 ethCollateral)\n    {\n        ethCollateral = _getTokensInEth(\n            _poolToken,\n            WISE_LENDING.getPureCollateralAmount(\n                _nftId,\n                _poolToken\n            )\n        );\n\n        if (_isUncollateralized(_nftId, _poolToken) == true) {\n            return ethCollateral;\n        }\n\n        if (WISE_LENDING.getPositionLendingShares(_nftId, _poolToken) == 0) {\n            return ethCollateral;\n        }\n\n        ethCollateral += getETHCollateral(\n            _nftId,\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Wrapper function checking if a supplied\n     * fund is uncollateralized.\n     */\n    function _isUncollateralized(\n        uint256 _nftId,\n        address _poolToken\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return WISE_LENDING.isUncollateralized(\n            _nftId,\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Read function returning the full\n     * collateral amount of a {_poolToken} from a\n     * {_nftId} updated to current values.\n     * Full means sum of private and public added\n     * funds. Can be extrapolated linear within\n     * {_interval}.\n     */\n    function _getCollateralOfTokenETHUpdated(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256 ethCollateral)\n    {\n        ethCollateral = _getTokensInEth(\n            _poolToken,\n            WISE_LENDING.getPureCollateralAmount(\n                _nftId,\n                _poolToken\n            )\n        );\n\n        if (_isUncollateralized(_nftId, _poolToken) == true) {\n            return ethCollateral;\n        }\n\n        ethCollateral += getETHCollateralUpdated(\n            _nftId,\n            _poolToken,\n            _interval\n        );\n    }\n\n    /**\n     * @dev Read function returning the full\n     * (private and public) collateral amount\n     * of a {_poolToken} from a {_nftId} updated\n     * to current values. Can be extrapolated\n     * linear within {_interval}.\n     */\n    function getETHCollateralUpdated(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _interval\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 lendingShares = WISE_LENDING.getPositionLendingShares(\n            _nftId,\n            _poolToken\n        );\n\n        if (lendingShares == 0) {\n            return 0;\n        }\n\n        uint256 currentTotalLendingShares = WISE_LENDING.getTotalDepositShares(\n            _poolToken\n        );\n\n        uint256 updatedPseudo = _getUpdatedPseudoPool(\n            _poolToken,\n            _interval\n        );\n\n        uint256 updatedToken = lendingShares\n            * updatedPseudo\n            / currentTotalLendingShares;\n\n        return _getTokensInEth(\n            _poolToken,\n            updatedToken\n        );\n    }\n\n    /**\n     * @dev Read function returning the public\n     * collateral amount of a {_poolToken} from a\n     * {_nftId}.\n     */\n    function getETHCollateral(\n        uint256 _nftId,\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _getTokensInEth(\n            _poolToken,\n            getPositionLendingAmount(\n                _nftId,\n                _poolToken\n            )\n        );\n    }\n\n    function _getTokensInEth(\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return WISE_ORACLE.getTokensInETH(\n            _poolToken,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Read function returning the total\n     * borrow amount of a postion with {_nftId}.\n     * No heartbeat or blacklisted checks are\n     * included in this function!\n     */\n    function overallETHBorrowBare(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 buffer)\n    {\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionBorrowTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            buffer += getETHBorrow(\n                _nftId,\n                WISE_LENDING.getPositionBorrowTokenByIndex(\n                    _nftId,\n                    i\n                )\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Read function returning the total\n     * borrow amount of a postion with {_nftId}.\n     * No blacklisted check is included\n     * in this function!\n     */\n    function overallETHBorrowHeartbeat(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 buffer)\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionBorrowTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionBorrowTokenByIndex(\n                _nftId,\n                i\n            );\n\n            buffer += getETHBorrow(\n                _nftId,\n                tokenAddress\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Read function returning the total\n     * borrow amount of a postion with {_nftId}.\n     */\n    function overallETHBorrow(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 buffer)\n    {\n        uint256 i;\n        address tokenAddress;\n\n        uint256 l = WISE_LENDING.getPositionBorrowTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionBorrowTokenByIndex(\n                _nftId,\n                i\n            );\n\n            _checkPoolCondition(\n                tokenAddress\n            );\n\n            buffer += getETHBorrow(\n                _nftId,\n                tokenAddress\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function combining hearbeat\n     * and blacklisted checks.\n     */\n    function _checkBlacklisted(\n        address _poolToken\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return wasBlacklisted[_poolToken] == true;\n    }\n\n    /**\n     * @dev Read function returning the total\n     * updated current borrow amount of a\n     * postion with {_nftId}. Can be\n     * extrapolated linear with {_intervall}.\n     */\n    function _overallETHBorrow(\n        uint256 _nftId,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256 buffer)\n    {\n        uint256 i;\n        address tokenAddress;\n\n        uint256 l = WISE_LENDING.getPositionBorrowTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionBorrowTokenByIndex(\n                _nftId,\n                i\n            );\n\n            _checkPoolCondition(\n                tokenAddress\n            );\n\n            buffer += _getETHBorrowUpdated(\n                _nftId,\n                tokenAddress,\n                _interval\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function calculating\n     * the updated pseudo borrow amount of\n     * {_poolToken}. Result can be extrapolated\n     * linear with {_interval}.\n     */\n    function _getUpdatedPseudoBorrow(\n        address _poolToken,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 currentPseudo = WISE_LENDING.getPseudoTotalBorrowAmount(\n            _poolToken\n        );\n\n        return _getInterest(\n            _poolToken,\n            _interval\n        ) + currentPseudo;\n    }\n\n    /**\n     * @dev Internal function calculating\n     * the updated pseudo lending amount of\n     * {_poolToken}. Result can be extrapolated\n     * linear with {_interval}.\n     */\n    function _getUpdatedPseudoPool(\n        address _poolToken,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 currentPseudo = WISE_LENDING.getPseudoTotalPool(\n            _poolToken\n        );\n\n        return _getInterest(_poolToken, _interval)\n            * (PRECISION_FACTOR_E18 - WISE_LENDING.globalPoolData(_poolToken).poolFee)\n            / PRECISION_FACTOR_E18\n            + currentPseudo;\n    }\n\n    /**\n     * @dev Internal math function calculating\n     * the accumulated interest amount for\n     * {_poolToken}. Result can be extrapolated\n     * linear with {_interval}.\n     */\n    function _getInterest(\n        address _poolToken,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        BorrowPoolEntry memory borrowPoolData = WISE_LENDING.borrowPoolData(\n            _poolToken\n        );\n\n        uint256 timeInterval = _interval\n            + block.timestamp\n            - WISE_LENDING.getTimeStamp(_poolToken);\n\n        uint256 rate = timeInterval\n            * borrowPoolData.borrowRate\n            * WISE_LENDING.getPseudoTotalBorrowAmount(_poolToken)\n            / PRECISION_FACTOR_E18\n            / ONE_YEAR;\n\n        return rate;\n    }\n\n    /**\n     * @dev Read function returning the full\n     * borrow amount of a {_poolToken} from a\n     * {_nftId} updated to current values.\n     * Can be extrapolated linear within\n     * {_interval}.\n     */\n    function _getETHBorrowUpdated(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _intervall\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 borrowShares = WISE_LENDING.getPositionBorrowShares(\n            _nftId,\n            _poolToken\n        );\n\n        if (borrowShares == 0) {\n            return 0;\n        }\n\n        uint256 currentTotalBorrowShares = WISE_LENDING.getTotalBorrowShares(\n            _poolToken\n        );\n\n        uint256 updatesPseudo = _getUpdatedPseudoBorrow(\n            _poolToken,\n            _intervall\n        );\n\n        uint256 updatedToken = borrowShares\n            * updatesPseudo\n            / currentTotalBorrowShares;\n\n        return _getTokensInEth(\n            _poolToken,\n            updatedToken\n        );\n    }\n\n    /**\n     * @dev Read function returning the borow\n     * amount of a {_poolToken} from a {_nftId}.\n     */\n    function getETHBorrow(\n        uint256 _nftId,\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _getTokensInEth(\n            _poolToken,\n            getPositionBorrowAmount(\n                _nftId,\n                _poolToken\n            )\n        );\n    }\n\n    /**\n     * @dev Read function checking if\n     * {_poolToken} is allowed to borrow.\n     */\n    function checkTokenAllowed(\n        address _poolAddress\n    )\n        public\n        view\n    {\n        if (WISE_LENDING.borrowPoolData(_poolAddress).allowBorrow == false) {\n            revert NotAllowedToBorrow();\n        }\n    }\n\n    /**\n     * @dev Check if chainLink feed was\n     * updated within expected timeframe\n     */\n    function checkHeartbeat(\n        address _poolToken\n    )\n        public\n        view\n        returns (bool)\n    {\n        return WISE_ORACLE.chainLinkIsDead(_poolToken) == false;\n    }\n\n    /**\n     * @dev Check if the postion with\n     * {_nftId} is locked for interactions.\n     */\n    function _checkPositionLocked(\n        uint256 _nftId\n    )\n        internal\n        view\n    {\n        if (WISE_LENDING.positionLocked(_nftId) == true) {\n            revert PositionLockedWiseSecurity();\n        }\n    }\n\n    /**\n     * @dev Wrapper function for external\n     * {_checkMaxFee} call.\n     */\n    function checkMaxFee(\n        uint256 _paybackETH,\n        uint256 _feeLiquidation,\n        uint256 _maxFeeETH\n    )\n        external\n        pure\n        returns (uint256)\n    {\n        return _checkMaxFee(\n            _paybackETH,\n            _feeLiquidation,\n            _maxFeeETH\n        );\n    }\n\n    /**\n     * @dev Returning the possible fee\n     * for liquidation.\n     */\n    function _checkMaxFee(\n        uint256 _paybackETH,\n        uint256 _liquidationFee,\n        uint256 _maxFeeETH\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 feeETH = _paybackETH\n            * _liquidationFee\n            / PRECISION_FACTOR_E18;\n\n        return feeETH < _maxFeeETH\n            ? feeETH\n            : _maxFeeETH;\n    }\n\n    /**\n     * @dev Math function computing the\n     * percentage of the receiving token\n     * which the liquidator receivs for\n     * liquidation.\n     */\n    function calculateWishPercentage(\n        uint256 _nftId,\n        address _receiveToken,\n        uint256 _paybackETH,\n        uint256 _maxFeeETH,\n        uint256 _baseRewardLiquidation\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 feeETH = _checkMaxFee(\n            _paybackETH,\n            _baseRewardLiquidation,\n            _maxFeeETH\n        );\n\n        uint256 numerator = (feeETH + _paybackETH)\n            * PRECISION_FACTOR_E18;\n\n        uint256 denominator = getFullCollateralETH(\n            _nftId,\n            _receiveToken\n        );\n\n        return numerator / denominator + 1;\n    }\n\n    /**\n     * @dev Check function for withdraw flow.\n     * Tests if debt ratio is not greater than\n     * 100% after withdraw of {_poolToken} for\n     * {_amount}.\n     */\n    function _checkHealthState(\n        uint256 _nftId,\n        bool _powerFarm\n    )\n        internal\n        view\n    {\n        if (_getState(_nftId, _powerFarm) == true) {\n            revert ResultsInBadDebt();\n        }\n    }\n\n    function _getState(\n        uint256 _nftId,\n        bool _powerFarm\n    )\n        internal\n        view\n        returns (bool)\n    {\n        uint256 borrowAmount = overallETHBorrow(\n            _nftId\n        );\n\n        if (borrowAmount == 0) {\n            return false;\n        }\n\n        uint256 overallCollateral = _powerFarm == true\n            ? overallETHCollateralsBare(_nftId)\n            : overallETHCollateralsWeighted(_nftId);\n\n        return overallCollateral\n            * BORROW_PERCENTAGE_CAP\n            / PRECISION_FACTOR_E18\n            < borrowAmount;\n    }\n\n    /**\n     * @dev Check function for registration\n     * of power farms. User can only register\n     * when the postion is empty!\n     */\n    function checksRegister(\n        uint256 _nftId,\n        address _caller\n    )\n        public\n        view\n    {\n        checkOwnerPosition(\n            _nftId,\n            _caller\n        );\n\n        if (overallETHCollateralsWeighted(_nftId) > 0) {\n            revert NotAllowedWiseSecurity();\n        }\n    }\n\n    /**\n     * @dev Pure math function comparing\n     * borrow and collateral amount for\n     * liquidation.\n     */\n    function canLiquidate(\n        uint256 _borrowETHTotal,\n        uint256 _weightedCollateralETH\n    )\n        public\n        pure\n    {\n        if (_borrowETHTotal < _weightedCollateralETH) {\n            revert LiquidationDenied();\n        }\n    }\n\n    /**\n     * @dev Helper function for liquidation checking\n     * return amount of receiving shares for liquidator.\n     * Has to be smaller 50% when no bad debt occurs.\n     */\n    function checkMaxShares(\n        uint256 _nftId,\n        address _tokenToPayback,\n        uint256 _borrowETHTotal,\n        uint256 _unweightedCollateralETH,\n        uint256 _shareAmountToPay\n    )\n        public\n        view\n    {\n        uint256 totalSharesUser = WISE_LENDING.getPositionBorrowShares(\n            _nftId,\n            _tokenToPayback\n        );\n\n        uint256 maxShares = checkBadDebtThreshold(_borrowETHTotal, _unweightedCollateralETH)\n            ? totalSharesUser\n            : totalSharesUser * MAX_LIQUIDATION_50 / PRECISION_FACTOR_E18;\n\n        if (_shareAmountToPay <= maxShares) {\n            return;\n        }\n\n        revert TooManyShares();\n    }\n\n    /**\n     * @dev Helper function for liquidation checking\n     * if postion has bad debt.\n     */\n    function checkBadDebtThreshold(\n        uint256 _borrowETHTotal,\n        uint256 _unweightedCollateral\n    )\n        public\n        pure\n        returns (bool)\n    {\n        return _borrowETHTotal * PRECISION_FACTOR_E18\n            >= _unweightedCollateral * BAD_DEBT_THRESHOLD;\n    }\n\n    /**\n     * @dev Helper function computing lending\n     * token amount for {_poolToken}.\n     */\n    function getPositionLendingAmount(\n        uint256 _nftId,\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return WISE_LENDING.cashoutAmount(\n            {\n                _poolToken: _poolToken,\n                _shares: WISE_LENDING.getPositionLendingShares(\n                    _nftId,\n                    _poolToken\n                )\n            }\n        );\n    }\n\n    /**\n     * @dev Helper function computing borrow\n     * token amount for {_poolToken}.\n     */\n    function getPositionBorrowAmount(\n        uint256 _nftId,\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return WISE_LENDING.paybackAmount(\n            _poolToken,\n            WISE_LENDING.getPositionBorrowShares(\n                _nftId,\n                _poolToken\n            )\n        );\n    }\n\n    /**\n     * @dev Helper function checking the owner\n     * of {_nftId}. Reverts if owner is invalid.\n     */\n    function checkOwnerPosition(\n        uint256 _nftId,\n        address _caller\n    )\n        public\n        view\n    {\n        if (POSITION_NFTS.isOwner(\n            _nftId,\n            _caller\n        ) == false) {\n            revert NotOwner();\n        }\n    }\n\n    /**\n     * @dev Wrapper function returning the borrow\n     * rate from pool with token {_poolToken}.\n     */\n    function getBorrowRate(\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return WISE_LENDING.borrowPoolData(_poolToken).borrowRate;\n    }\n\n    /**\n     * @dev View function returning the lending\n     * rate from pool with token {_poolToken}.\n     */\n    function getLendingRate(\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 pseudoTotalPool = WISE_LENDING.getPseudoTotalPool(\n            _poolToken\n        );\n\n        if (pseudoTotalPool == 0) {\n            return 0;\n        }\n\n        uint256 adjustedRate = getBorrowRate(_poolToken)\n            * (PRECISION_FACTOR_E18 - WISE_LENDING.globalPoolData(_poolToken).poolFee)\n            / PRECISION_FACTOR_E18;\n\n        return adjustedRate\n            * WISE_LENDING.getPseudoTotalBorrowAmount(_poolToken)\n            / pseudoTotalPool;\n    }\n\n    /**\n     * @dev Internal helper function calculating\n     * the possible withdraw amount of {_poolToken}\n     * under current borrow and collateral amount\n     * of {_nftId}.\n     */\n    function _getPossibleWithdrawAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 term = _overallETHBorrow(_nftId, _interval)\n            * PRECISION_FACTOR_E18\n            / BORROW_PERCENTAGE_CAP;\n\n        uint256 withdrawETH = PRECISION_FACTOR_E18\n            * (_overallETHCollateralsWeighted(_nftId, _interval) - term)\n            / WISE_LENDING.lendingPoolData(_poolToken).collateralFactor;\n\n        return WISE_ORACLE.getTokensFromETH(\n            _poolToken,\n            withdrawETH\n        );\n    }\n\n    /**\n     * Locking or unlocking all pools for borrow\n     * and deposit actions. Performs action for\n     * all pools.\n     */\n    function _setPoolState(\n        bool _state\n    )\n        internal\n    {\n        uint256 i;\n        uint256 len = FEE_MANAGER.getPoolTokenAddressesLength();\n\n        while(i < len) {\n\n            wasBlacklisted[\n                FEE_MANAGER.getPoolTokenAdressesByIndex(i)\n            ] = _state;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Wrapper for {_checkBlacklisted}.\n     */\n    function _checkPoolCondition(\n        address _poolToken\n    )\n        internal\n        view\n    {\n        if (_checkBlacklisted(_poolToken) == true) {\n            revert TokenBlackListed();\n        }\n    }\n\n    /**\n     * @dev Internal helper checking of success\n     * for a low level byte call of a function\n     * with {.call()}.\n     */\n    function _checkSuccess(\n        bool _success\n    )\n        internal\n        pure\n    {\n        if (_success == false) {\n            revert SecuritySwapFailed();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/WiseLending.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author RenÃ© Hochmuth\n * @author Christoph Krpoun\n * @author Vitally Marinchenko\n */\n\nimport \"./PoolManager.sol\";\n\n/**\n * @dev WISE lending is an automated lending platform on which users can collateralize\n * their assets and borrow tokens against them.\n *\n * Users need to pay borrow rates for debt tokens, which are reflected in a borrow APY for\n * each asset type (pool). This borrow rate is variable over time and determined through the\n * utilization of the pool. The bounding curve is a family of different bonding curves adjusted\n * automatically by LASA (Lending Automated Scaling Algorithm). For more information, see:\n * [https://wisesoft.gitbook.io/wise/wise-lending-protocol/lasa-ai]\n *\n * In addition to normal deposit, withdraw, borrow, and payback functions, there are other\n * interacting modes:\n *\n * - Solely deposit and withdraw allows the user to keep their funds private, enabling\n *    them to withdraw even when the pools are borrowed empty.\n *\n * - Aave pools  allow for maximal capital efficiency by earning aave supply APY for not\n *   borrowed funds.\n *\n * - Special curve pools nside beefy farms can be used as collateral, opening up new usage\n *   possibilities for these asset types.\n *\n * - Users can pay back their borrow with lending shares of the same asset type, making it\n *   easier to manage their positions.\n *\n * - Users save their collaterals and borrows inside a position NFT, making it possible\n *   to trade their whole positions or use them in second-layer contracts\n *   (e.g., spot trading with PTP NFT trading platforms).\n */\n\ncontract WiseLending is PoolManager {\n\n    /**\n     * @dev Standard receive functions forwarding\n     * directly send ETH to the master address.\n     */\n    receive()\n        external\n        payable\n    {\n        if (msg.sender == WETH_ADDRESS) {\n            return;\n        }\n\n        _sendValue(\n            master,\n            msg.value\n        );\n    }\n\n    /**\n     * @dev Checks if position is healthy\n     * after all state changes are done.\n     */\n    modifier healthStateCheck(\n        uint256 _nftId\n    ) {\n        _;\n\n        _healthStateCheck(\n            _nftId\n        );\n    }\n\n    function _healthStateCheck(\n        uint256 _nftId\n    )\n        private\n    {\n        _checkHealthState(\n            _nftId,\n            powerFarmCheck\n        );\n\n        if (powerFarmCheck == true) {\n            powerFarmCheck = false;\n        }\n    }\n\n    /**\n     * @dev Runs the LASA algorithm known as\n     * Lending Automated Scaling Algorithm\n     * and updates pool data based on token\n     */\n    modifier syncPool(\n        address _poolToken\n    ) {\n        (\n            uint256 lendSharePrice,\n            uint256 borrowSharePrice\n        ) = _syncPoolBeforeCodeExecution(\n            _poolToken\n        );\n\n        _;\n\n        _syncPoolAfterCodeExecution(\n            _poolToken,\n            lendSharePrice,\n            borrowSharePrice\n        );\n    }\n\n    constructor(\n        address _master,\n        address _wiseOracleHubAddress,\n        address _nftContract\n    )\n        WiseLendingDeclaration(\n            _master,\n            _wiseOracleHubAddress,\n            _nftContract\n        )\n    {}\n\n    function _emitFundsSolelyWithdrawn(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        emit FundsSolelyWithdrawn(\n            _caller,\n            _nftId,\n            _poolToken,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    function _emitFundsSolelyDeposited(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        emit FundsSolelyDeposited(\n            _caller,\n            _nftId,\n            _poolToken,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Fetches share price of lending shares.\n     */\n    function _getSharePrice(\n        address _poolToken\n    )\n        private\n        view\n        returns (\n            uint256,\n            uint256\n        )\n    {\n        uint256 borrowSharePrice = borrowPoolData[_poolToken].pseudoTotalBorrowAmount\n            * PRECISION_FACTOR_E18\n            / borrowPoolData[_poolToken].totalBorrowShares;\n\n        _validateParameter(\n            MIN_BORROW_SHARE_PRICE,\n            borrowSharePrice\n        );\n\n        return (\n            lendingPoolData[_poolToken].pseudoTotalPool\n                * PRECISION_FACTOR_E18\n                / lendingPoolData[_poolToken].totalDepositShares,\n            borrowSharePrice\n        );\n    }\n\n    function _checkHealthState(\n        uint256 _nftId,\n        bool _powerFarm\n    )\n        internal\n        view\n    {\n        WISE_SECURITY.checkHealthState(\n            _nftId,\n            _powerFarm\n        );\n    }\n\n    /**\n     * @dev Compares share prices before and after\n     * execution. If borrow share price increased\n     * or lending share price decreased, revert.\n     */\n    function _compareSharePrices(\n        address _poolToken,\n        uint256 _lendSharePriceBefore,\n        uint256 _borrowSharePriceBefore\n    )\n        private\n        view\n    {\n        (\n            uint256 lendSharePriceAfter,\n            uint256 borrowSharePriceAfter\n        ) = _getSharePrice(\n            _poolToken\n        );\n\n        uint256 currentSharePriceMax = _getCurrentSharePriceMax(\n            _poolToken\n        );\n\n        _validateParameter(\n            _lendSharePriceBefore,\n            lendSharePriceAfter\n        );\n\n        _validateParameter(\n            lendSharePriceAfter,\n            currentSharePriceMax\n        );\n\n        _validateParameter(\n            _borrowSharePriceBefore,\n            currentSharePriceMax\n        );\n\n        _validateParameter(\n            borrowSharePriceAfter,\n            _borrowSharePriceBefore\n        );\n    }\n\n    /**\n    * @dev Since pool inception share price\n    * increase for both lending and borrow shares\n    * is capped at 500% apr max in between a transaction.\n    */\n    function _getCurrentSharePriceMax(\n        address _poolToken\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 timeDifference = block.timestamp\n            - timestampsPoolData[_poolToken].initialTimeStamp;\n\n        return timeDifference\n            * RESTRICTION_FACTOR\n            + PRECISION_FACTOR_E18;\n    }\n\n    /**\n     * @dev First part of pool sync updating pseudo\n     * amounts. Is skipped when powerFarms or aaveHub\n     * is calling the function.\n     */\n    function _syncPoolBeforeCodeExecution(\n        address _poolToken\n    )\n        private\n        returns (\n            uint256 lendSharePrice,\n            uint256 borrowSharePrice\n        )\n    {\n        _checkReentrancy();\n\n        _preparePool(\n            _poolToken\n        );\n\n        if (_aboveThreshold(_poolToken) == true) {\n            _scalingAlgorithm(\n                _poolToken\n            );\n        }\n\n        (\n            lendSharePrice,\n            borrowSharePrice\n        ) = _getSharePrice(\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Second part of pool sync updating\n     * the borrow pool rate and share price.\n     */\n    function _syncPoolAfterCodeExecution(\n        address _poolToken,\n        uint256 _lendSharePriceBefore,\n        uint256 _borrowSharePriceBefore\n    )\n        private\n    {\n        _newBorrowRate(\n            _poolToken\n        );\n\n        _compareSharePrices(\n            _poolTok"
    }
  ]
}