{
  "Title": "[G-01] Remove or replace unused state variables",
  "Content": "\nSaves a storage slot. If the variable is assigned a non-zero value, saves Gsset (20000 gas). If it's assigned a zero value, saves Gsreset (2900 gas). If the variable remains unassigned, there is no gas savings unless the variable is `public`, in which case the compiler-generated non-payable getter deployment cost is saved. If the state variable is overriding an interface's public function, mark the variable as `constant` or `immutable` so that it does not use a storage slot\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: convex-platform/contracts/contracts/RewardFactory.sol   #1\n\n28:       mapping(address => uint256[]) public rewardActiveList;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/RewardFactory.sol#L28>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "convex-platform/contracts/contracts/RewardFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"./BaseRewardPool4626.sol\";\nimport \"./VirtualBalanceRewardPool.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n\n/**\n * @title   RewardFactory\n * @author  ConvexFinance\n * @notice  Used to deploy reward pools when a new pool is added to the Booster\n *          contract. This contract deploys two types of reward pools:\n *          - BaseRewardPool handles CRV rewards for guages\n *          - VirtualBalanceRewardPool for extra rewards\n */\ncontract RewardFactory {\n    using Address for address;\n\n    address public immutable operator;\n    address public immutable crv;\n\n    mapping (address => bool) private rewardAccess;\n    mapping(address => uint256[]) public rewardActiveList;\n\n\n    event RewardPoolCreated(address rewardPool, uint256 _pid, address depositToken);\n    event TokenRewardPoolCreated(address rewardPool, address token, address mainRewards, address operator);\n\n    event AccessChanged(address stash, bool hasAccess);\n\n    /**\n     * @param _operator   Contract operator is Booster\n     * @param _crv        CRV token address\n     */\n    constructor(address _operator, address _crv) public {\n        operator = _operator;\n        crv = _crv;\n    }\n\n    //stash contracts need access to create new Virtual balance pools for extra gauge incentives(ex. snx)\n    function setAccess(address _stash, bool _status) external{\n        require(msg.sender == operator, \"!auth\");\n        rewardAccess[_stash] = _status;\n\n        emit AccessChanged(_stash, _status);\n    }\n\n    /**\n     * @notice Create a Managed Reward Pool to handle distribution of all crv mined in a pool\n     */\n    function CreateCrvRewards(uint256 _pid, address _depositToken, address _lptoken) external returns (address) {\n        require(msg.sender == operator, \"!auth\");\n\n        //operator = booster(deposit) contract so that new crv can be added and distributed\n        //reward manager = this factory so that extra incentive tokens(ex. snx) can be linked to the main managed reward pool\n        BaseRewardPool4626 rewardPool = new BaseRewardPool4626(_pid,_depositToken,crv,operator, address(this), _lptoken);\n\n        emit RewardPoolCreated(address(rewardPool), _pid, _depositToken);\n        return address(rewardPool);\n    }\n\n    /**\n     * @notice  Create a virtual balance reward pool that mimics the balance of a pool's main reward contract\n     *          used for extra incentive tokens(ex. snx) as well as vecrv fees\n     */\n    function CreateTokenRewards(address _token, address _mainRewards, address _operator) external returns (address) {\n        require(msg.sender == operator || rewardAccess[msg.sender] == true, \"!auth\");\n\n        //create new pool, use main pool for balance lookup\n        VirtualBalanceRewardPool rewardPool = new VirtualBalanceRewardPool(_mainRewards,_token,_operator);\n        address rAddress = address(rewardPool);\n        //add the new pool to main pool's list of extra rewards, assuming this factory has \"reward manager\" role\n        IRewards(_mainRewards).addExtraReward(rAddress);\n\n        emit TokenRewardPoolCreated(rAddress, _token, _mainRewards, _operator);\n        //return new pool's address\n        return rAddress;\n    }\n}"
    }
  ]
}