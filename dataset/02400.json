{
  "Title": "Admin can bypass the upgrade delay by `setDelay`",
  "Content": "##### Description\nThe contract implements a special flow to upgrade the wallet core with delay, but the admin can force an immediate upgrade by reducing the delay using setDelay().\nhttps://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/EnsoBeacon.sol#L208\n\nThis will deprive users of the ability to check implementations before applying.\n\n##### Recommendation\nWe recommend improving the upgrade delay flow.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/EnsoBeacon.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"./interfaces/IBeacon.sol\";\nimport \"./interfaces/IOwnable.sol\";\nimport \"./interfaces/IUUPS.sol\";\n\ncontract EnsoBeacon is IBeacon {\n    address public admin;\n    address public delegate;\n    address public factory;\n    address public coreImplementation;\n    address public fallbackImplementation;\n\n    address public pendingAdmin;\n    address public pendingDelegate;\n    address public pendingCoreImplementation;\n    address public pendingFactoryImplementation;\n    bytes public pendingFactoryUpgradeData;\n\n    uint256 public delay;\n    uint256 public upgradeTimestamp;\n\n    event CoreUpgraded(address previousImplementation, address newImplementation);\n    event FallbackUpgraded(address previousImplementation, address newImplementation);\n    event EmergencyUpgrade();\n    event AdministrationTransferred(address previousAdmin, address newAdmin);\n    event AdministrationTransferStarted(address previousAdmin, address newAdmin);\n    event DelegationTransferred(address previousDelegate, address newDelegate);\n    event DelegationTransferStarted(address previousDelegate, address newDelegate);\n    event Factory(address newFactory);\n    event Delay(uint256 newDelay);\n\n    error InvalidImplementation();\n    error InvalidAccount();\n    error NotPermitted();\n    error NoPendingUpgrade();\n    error Wait();\n\n    modifier onlyAdmin {\n        if (msg.sender != admin) revert NotPermitted();\n        _;\n    }\n\n    modifier onlyDelegate {\n        if (msg.sender != delegate) revert NotPermitted();\n        _;\n    }\n\n    constructor(\n        address coreImplementation_,\n        address fallbackImplementation_\n    ) {\n        admin = msg.sender;\n        delegate = msg.sender;\n        coreImplementation = coreImplementation_;\n        fallbackImplementation = fallbackImplementation_;\n    }\n\n    // @notice The current core implementation\n    // @dev Called by proxy contracts to get the implementation address\n    function implementation() external view override returns (address) {\n        return coreImplementation;\n    }\n\n    // @notice Switch from the core implementation to the fallback implemenation\n    function emergencyUpgrade() external onlyDelegate {\n        _upgradeCore(fallbackImplementation);\n        emit EmergencyUpgrade();\n    }\n\n    // @notice Finalize the new core implementation\n    function finalizeUpgrade() external {\n        // Load timestamp and check\n        uint256 timestamp = upgradeTimestamp;\n        if (timestamp == 0) revert NoPendingUpgrade();\n        if (timestamp + delay > block.timestamp) revert Wait();\n        delete upgradeTimestamp;\n        // Load implementation data and check\n        address newImplementation = pendingCoreImplementation;\n        address factoryImplementation = pendingFactoryImplementation;\n        bytes memory data = pendingFactoryUpgradeData;\n        if (newImplementation == address(0)) revert InvalidImplementation(); // sanity check\n        delete pendingCoreImplementation;\n        delete pendingFactoryImplementation;\n        delete pendingFactoryUpgradeData;\n        // Upgrade\n        _upgradeCore(newImplementation);\n        if (factoryImplementation != address(0)) _upgradeFactory(factoryImplementation, data);\n    }\n\n    // @notice Initialize an upgrade to a new core implementation\n    // @param newImplementation The address of the new core implementation\n    // @param factoryImplementation Optionally include a new factory implementation to upgrade the factory simultaneously. Pass zero address if no upgrade is needed\n    // @param data Calldata for upgrading the new factory. Pass zero bytes if factory is not being upgraded or no additional call needs to be made\n    function upgradeCore(\n        address newImplementation,\n        address factoryImplementation,\n        bytes memory data\n    ) external onlyAdmin {\n        if (newImplementation == address(0)) revert InvalidImplementation();\n        upgradeTimestamp = block.timestamp;\n        pendingCoreImplementation = newImplementation;\n        // If the following is null data, at least we ensure that any old pending values are overwritten\n        pendingFactoryImplementation = factoryImplementation;\n        pendingFactoryUpgradeData = data;\n    }\n\n    // @notice Upgrade the fallback implementation\n    // @param newImplementation The address of the new fallback implementation\n    function upgradeFallback(address newImplementation) external onlyAdmin {\n        if (newImplementation == address(0)) revert InvalidImplementation();\n        if (newImplementation == fallbackImplementation) revert InvalidImplementation();\n        address previousImplementation = fallbackImplementation;\n        fallbackImplementation = newImplementation;\n        emit FallbackUpgraded(previousImplementation, newImplementation);\n    }\n\n    // @notice Upgrade the factory implementation\n    // @param newImplementation The address of the new factory implementation\n    // @param data Calldata for upgrading the new factory. Pass zero bytes if no additional call needs to be made\n    function upgradeFactory(address newImplementation, bytes memory data) external onlyAdmin {\n        _upgradeFactory(newImplementation, data);\n    }\n\n    // @notice Initiate transfer of the admin role\n    // @notice newAdmin The address of the new admin\n    function transferAdministration(address newAdmin) external onlyAdmin {\n        if (newAdmin == address(0)) revert InvalidAccount();\n        if (newAdmin == admin) revert InvalidAccount();\n        pendingAdmin = newAdmin;\n        emit AdministrationTransferStarted(admin, newAdmin);\n    }\n\n    // @notice Accept new admin role\n    // @dev Only the pending admin can call this function\n    function acceptAdministration() external {\n        if (msg.sender != pendingAdmin) revert NotPermitted();\n        delete pendingAdmin;\n        address previousAdmin = admin;\n        admin = msg.sender;\n        emit AdministrationTransferred(previousAdmin, msg.sender);\n    }\n\n    // @notice Renounce admin role. No upgrades can be done if this function is called.\n    // @dev This function renounes both the admin and the delegate roles.\n    function renounceAdministration() external onlyAdmin {\n        address previousAdmin = admin;\n        address previousDelegate = delegate;\n        delete admin;\n        delete delegate;\n        delete pendingAdmin;\n        delete pendingDelegate;\n        emit AdministrationTransferred(previousAdmin, address(0));\n        emit DelegationTransferred(previousDelegate, address(0));\n    }\n\n    // @notice Initiate transfer of the delegate role\n    // @notice newDelegate The address of the new delegate\n    function transferDelegation(address newDelegate) external onlyAdmin {\n        if (newDelegate == address(0)) revert InvalidAccount();\n        if (newDelegate == delegate) revert InvalidAccount();\n        pendingDelegate = newDelegate;\n        emit DelegationTransferStarted(delegate, newDelegate);\n    }\n\n    // @notice Accept new delegate role\n    // @dev Only the pending delegate can call this function\n    function acceptDelegation() external {\n        if (msg.sender != pendingDelegate) revert NotPermitted();\n        delete pendingDelegate;\n        address previousDelegate = delegate;\n        delegate = msg.sender;\n        emit DelegationTransferred(previousDelegate, msg.sender);\n    }\n\n    // @notice Renounce delegate role. Emergency upgrades cannot happen while this role remain unfilled.\n    // @dev The admin can alway give this role to another address with the transferDelegation function\n    function renounceDelegation() external onlyDelegate {\n        address previousDelegate = delegate;\n        delete delegate;\n        emit DelegationTransferred(previousDelegate, address(0));\n    }\n\n    // @notice Transfer ownership of a contract that is owned by this contract\n    // @param ownable The address of the contract that is getting it's ownership transferred\n    // @param newOwner The address of the new owner\n    function transferOwnership(address ownable, address newOwner) external onlyAdmin {\n        IOwnable(ownable).transferOwnership(newOwner);\n    }\n\n    // @notice Accept ownership of another contract by this contract\n    // @param ownable The address of the contract that is getting it's ownership transferred\n    function acceptOwnership(address ownable) external onlyAdmin {\n        IOwnable(ownable).acceptOwnership();\n    }\n\n    // @notice Set the current factory address in state\n    // @param newFactory The address of the new factory\n    function setFactory(address newFactory) external onlyAdmin {\n        factory = newFactory;\n        emit Factory(newFactory);\n    }\n\n    // @notice Update the delay between in initiating an upgrade and finalizing the upgrade\n    // @param newDelay The new delay in seconds\n    function setDelay(uint256 newDelay) external onlyAdmin {\n        delay = newDelay;\n        emit Delay(newDelay);\n    }\n\n    // @notice Internal function for setting the new core implementation\n    // @param newImplementation The address of the new implementation\n    function _upgradeCore(address newImplementation) internal {\n        if (newImplementation == address(0)) revert InvalidImplementation();\n        //if (newImplementation == coreImplementation) revert InvalidImplementation();\n        address previousImplementation = coreImplementation;\n        coreImplementation = newImplementation;\n        emit CoreUpgraded(previousImplementation, newImplementation);\n    }\n\n    // @notice Internal function for upgrading the factory implementation\n    // @param newImplementation The address of the new factory implementation\n    // @param data Calldata for upgrading the new factory. Pass zero bytes if no additional call needs to be made\n    function _upgradeFactory(address newImplementation, bytes memory data) internal {\n        if (data.length > 0) {\n            IUUPS(factory).upgradeToAndCall(newImplementation, data);\n        } else {\n            IUUPS(factory).upgradeTo(newImplementation);\n        }\n    }\n}"
    }
  ]
}