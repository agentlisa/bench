{
  "Title": "[H-05] Wrong use of `nftID` to check if a `PowerFarm` position is an Aave position",
  "Content": "\nWhen a `PowerFarm` position is created its `keyId` is used as a key in the `isAave` mapping to indicate if it is an Aave position or not. The `keyId` is the index of the Power Farm NFT linked with the position.\n\n[PendlePowerManager.sol#L129-L130](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerManager.sol#L129C1-L130C1)\n\n```solidity\n        isAave[keyId] = _isAave;\n```\n\nThe `keyId` is also linked with another `nftId`. This other `nftId` is used to hold the `keyId`s Power Farm position in the `WiseLending` contract. They are linked together in the `farmingKeys` mapping of the `MinterReserver` contract.\n\n[MinterReserver.sol#L88C1-L91C46](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PowerFarmNFTs/MinterReserver.sol#L88C1-L91C46)\n\n```solidity\n        uint256 keyId = _getNextReserveKey();\n\n        reservedKeys[_userAddress] = keyId;\n        farmingKeys[keyId] = _wiseLendingNFT;\n```\n\nThe issue is the check if a position is an Aave position is done using the `WiseLending` `nftId` instead of the Power Farm's `keyId`. This occurs five times in the code:\n\nIt is used in `getLiveDebtRatio()` to know the pool token borrowed so the `borrowShares` can be retrieved.\n\n[PendlePowerFarm.sol#L64-L70](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarm.sol#L64-L70)\n\n```solidity\n        uint256 borrowShares = isAave[_nftId]\n            ? _getPositionBorrowSharesAave(\n                _nftId\n            )\n            : _getPositionBorrowShares(\n                _nftId\n        );\n```\n\nIt is used in `_manuallyPaybackShares()` to know the pool token to pay back.\n\n[PendlePowerFarm.sol#L127-L129](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarm.sol#L127-L129)\n\n```solidity\n        if (isAave[_nftId] == true) {\n            poolAddress = AAVE_WETH_ADDRESS;\n        }\n```\n\nIt is used in `checkDebtRatio()` to know the pool token borrowed so the `borrowShares` can be retrieved.\n\n[PendlePowerFarmMathLogic.sol#L396-L402](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmMathLogic.sol#L396-L402)\n\n```solidity\n   ❌    uint256 borrowShares = isAave[_nftId]\n            ? _getPositionBorrowSharesAave(\n                _nftId\n            )\n            : _getPositionBorrowShares(\n                _nftId\n        );\n```\n\nIt is used in `_coreLiquidation()` to select a token to payback and to know the pool token borrowed so the `borrowShares` can be retrieved.\n\n[PendlePowerFarmLeverageLogic.sol#L575-L590](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L575-L590)\n\n```solidity\n   ❌    address paybackToken = isAave[_nftId] == true\n            ? AAVE_WETH_ADDRESS\n            : WETH_ADDRESS;\n\n        paybackAmount = WISE_LENDING.paybackAmount(\n            paybackToken,\n            _shareAmountToPay\n        );\n\n   ❌    uint256 cutoffShares = isAave[_nftId] == true\n            ? _getPositionBorrowSharesAave(_nftId)\n                * FIVTY_PERCENT\n                / PRECISION_FACTOR_E18\n            : _getPositionBorrowShares(_nftId)\n                * FIVTY_PERCENT\n                / PRECISION_FACTOR_E18;\n```\n\nThese have the following effects:\n\n- For `getLiveDebtRatio()`, users would get zero when they try to retrieve their debt ratio.\n- For `_manuallyPaybackShares()` users won't be able to pay back their shares manually from the `PowerFarm` contract since it'll fetch zero shares as borrow shares.\n- The last two instances are used in liquidation and allow a malicious user to have a position that can't be liquidated even though it is eligible for liquidation. The malicious user can:\n    1. Create an Aave `PowerFarm` position.\n    2. The position becomes eligible for liquidation after some price changes.\n    3. Liquidators cannot liquidate the position because the call to `_coreLiquidation` first calls `checkDebtRatio()` which uses the wrong `borrowShares` to calculate the debt ratio and returns true. Thus, causing a revert.\n\n[PendlePowerFarmLeverageLogic.sol#L571C1-L574C1](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L571C1-L574C1)\n\n```solidity\n        if (_checkDebtRatio(_nftId) == true) {\n            revert DebtRatioTooLow();\n        }\n```\n\n### Impact\n\n1. Malicious users can open positions that can't get liquidated.\n2. Users can't pay back manually when it is an Aave position.\n3. `getLiveDebtRatio()` returns zero always when it is an Aave position.\n\n### Proof of Concept\n\nThere are 3 tests below and they can all be run in [PendlePowerFarmControllerBase.t.sol](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmControllerBase.t.sol).\n\n- `testAaveGetLiveDebtRatio()` shows that `getLiveDebtRatio()` returns zero.\n- `testAaveManuallyPayback()` shows that borrowed tokens can't be paid back using `manuallyPaybackShares()`.\n- `testCannotLiquidate()` shows that Aave positions cannot be liquidated.\n\n```solidity\n    function testAaveGetLiveDebtRatio() public cheatSetup(true){\n        _prepareAave();\n        uint256 keyID = powerFarmManagerInstance.enterFarm(\n            true,\n            1 ether,\n            15 ether,\n            entrySpread\n        );\n\n        uint nftId = powerFarmManagerInstance.farmingKeys(keyID);\n        // gets borrow shares of weth instead of aeth\n        uint ratio = powerFarmManagerInstance.getLiveDebtRatio(nftId);\n        assertEq(ratio, 0);\n    }\n\n    function testAaveManuallyPayback() public cheatSetup(true){\n        _prepareAave();\n        uint256 keyID = powerFarmManagerInstance.enterFarm(\n            true,\n            1 ether,\n            15 ether,\n            entrySpread\n        );\n\n        uint nftId = powerFarmManagerInstance.farmingKeys(keyID);\n        uint borrowShares = wiseLendingInstance.getPositionBorrowShares(nftId, AWETH);\n        // tries to payback weth instead of aweth and reverts with an arithmetic underflow\n        // since the position has 0 weth borrow shares\n        vm.expectRevert();\n        powerFarmManagerInstance.manuallyPaybackShares(keyID, borrowShares);\n    }\n    \n    error DebtRatioTooLow();\n    function testCannotLiquidate() public cheatSetup(true){\n        _prepareAave();\n        uint256 keyID = powerFarmManagerInstance.enterFarm(\n            true,\n            1 ether,\n            15 ether,\n            entrySpread\n        );\n\n        // increase collateral factors to make position eligible for liquidation\n        wiseLendingInstance.setPoolParameters(AWETH, 99e16, type(uint256).max); // increasw Wiselending coll factor\n        vm.store(address(powerFarmManagerInstance), bytes32(uint(2)), bytes32(uint(99e16))); //increasw PowerFarm coll factor\n        assertEq(powerFarmManagerInstance.collateralFactor(), 99e16);\n\n        uint nftId = powerFarmManagerInstance.farmingKeys(keyID);\n        uint borrowShares = wiseLendingInstance.getPositionBorrowShares(nftId, AWETH);\n        // will revert if it can't be liquidated\n        wiseSecurityInstance.checksLiquidation(nftId, AWETH, borrowShares);\n\n        uint nftIdLiquidator = positionNftsInstance.mintPosition();\n\n        vm.expectRevert(DebtRatioTooLow.selector);\n        powerFarmManagerInstance.liquidatePartiallyFromToken(nftId, nftIdLiquidator, borrowShares );\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider checking if a position is an Aave position using the `keyId` of the position.\n\n[PendlePowerFarm.sol#L64-L70](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarm.sol#L64-L70)\n\n```solidity\n-       uint256 borrowShares = isAave[_nftId]\n+       uint256 borrowShares = isAave[keyId]\n            ? _getPositionBorrowSharesAave(\n                _nftId\n            )\n            : _getPositionBorrowShares(\n                _nftId\n        );\n```\n\n[PendlePowerFarm.sol#L127-L129](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarm.sol#L127-L129)\n\n```solidity\n-       if (isAave[_nftId] == true) {\n+       if (isAave[keyId] == true) {\n            poolAddress = AAVE_WETH_ADDRESS;\n        }\n```\n\n[PendlePowerFarmMathLogic.sol#L396-L402](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmMathLogic.sol#L396-L402)\n\n```solidity\n-        uint256 borrowShares = isAave[_nftId]\n+        uint256 borrowShares = isAave[keyId]\n            ? _getPositionBorrowSharesAave(\n                _nftId\n            )\n            : _getPositionBorrowShares(\n                _nftId\n        );\n```\n\n[PendlePowerFarmLeverageLogic.sol#L575-L590](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L575-L590)\n\n```solidity\n-        address paybackToken = isAave[_nftId] == true\n+        address paybackToken = isAave[keyId] == true\n            ? AAVE_WETH_ADDRESS\n            : WETH_ADDRESS;\n\n        paybackAmount = WISE_LENDING.paybackAmount(\n            paybackToken,\n            _shareAmountToPay\n        );\n\n-       uint256 cutoffShares = isAave[_nftId] == true\n+       uint256 cutoffShares = isAave[keyId] == true\n            ? _getPositionBorrowSharesAave(_nftId)\n                * FIVTY_PERCENT\n                / PRECISION_FACTOR_E18\n            : _getPositionBorrowShares(_nftId)\n                * FIVTY_PERCENT\n                / PRECISION_FACTOR_E18;\n```\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/32#issuecomment-2004563704):**\n > While this is marked as High, we would like to bring this to a Medium, as there is still a way to liquidate such nft/user should that even occur (depending if there's AavePool present etc).\n> \n> @vonMangoldt can provide details on how this can be mitigated and user can still be liquidated even if they would have a chance to enter with the wrong `isAave` flag.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/32#issuecomment-2082901877):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/PowerFarms/PendlePowerFarm/PendlePowerManager.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author René Hochmuth\n * @author Christoph Krpoun\n * @author Vitally Marinchenko\n */\n\nimport \"./PendlePowerFarm.sol\";\nimport \"../../OwnableMaster.sol\";\nimport \"../PowerFarmNFTs/MinterReserver.sol\";\n\ncontract PendlePowerManager is OwnableMaster, PendlePowerFarm, MinterReserver {\n\n    /**\n     * @dev Standard receive functions forwarding\n     * directly send ETH to the master address.\n     */\n    receive()\n        external\n        payable\n    {\n        emit ETHReceived(\n            msg.value,\n            msg.sender\n        );\n    }\n\n    constructor(\n        address _wiseLendingAddress,\n        address _pendleChilTokenAddress,\n        address _pendleRouter,\n        address _entryAsset,\n        address _pendleSy,\n        address _underlyingMarket,\n        address _routerStatic,\n        address _dexAddress,\n        uint256 _collateralFactor,\n        address _powerFarmNFTs\n    )\n        OwnableMaster(\n            msg.sender\n        )\n        MinterReserver(\n            _powerFarmNFTs\n        )\n        PendlePowerFarmDeclarations(\n            _wiseLendingAddress,\n            _pendleChilTokenAddress,\n            _pendleRouter,\n            _entryAsset,\n            _pendleSy,\n            _underlyingMarket,\n            _routerStatic,\n            _dexAddress,\n            _collateralFactor\n        )\n    {\n    }\n\n    function changeMinDeposit(\n        uint256 _newMinDeposit\n    )\n        external\n        onlyMaster\n    {\n        minDepositEthAmount = _newMinDeposit;\n\n        emit MinDepositChange(\n            _newMinDeposit,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev External function deactivating the power farm by\n     * disableing the openPosition function. Allowing user\n     * to manualy payback and withdraw.\n     */\n    function shutDownFarm(\n        bool _state\n    )\n        external\n        onlyMaster\n    {\n        isShutdown = _state;\n\n        emit FarmStatus(\n            _state,\n            block.timestamp\n        );\n    }\n\n    function enterFarm(\n        bool _isAave,\n        uint256 _amount,\n        uint256 _leverage,\n        uint256 _allowedSpread\n    )\n        external\n        isActive\n        updatePools\n        returns (uint256)\n    {\n        uint256 wiseLendingNFT = _getWiseLendingNFT();\n\n        _safeTransferFrom(\n            WETH_ADDRESS,\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        _openPosition(\n            _isAave,\n            wiseLendingNFT,\n            _amount,\n            _leverage,\n            _allowedSpread\n        );\n\n        uint256 keyId = _reserveKey(\n            msg.sender,\n            wiseLendingNFT\n        );\n\n        isAave[keyId] = _isAave;\n\n        emit FarmEntry(\n            keyId,\n            wiseLendingNFT,\n            _leverage,\n            _amount,\n            block.timestamp\n        );\n\n        return keyId;\n    }\n\n    function enterFarmETH(\n        bool _isAave,\n        uint256 _leverage,\n        uint256 _allowedSpread\n    )\n        external\n        payable\n        isActive\n        updatePools\n        returns (uint256)\n    {\n        uint256 wiseLendingNFT = _getWiseLendingNFT();\n\n        _wrapETH(\n            msg.value\n        );\n\n        _openPosition(\n            _isAave,\n            wiseLendingNFT,\n            msg.value,\n            _leverage,\n            _allowedSpread\n        );\n\n        uint256 keyId = _reserveKey(\n            msg.sender,\n            wiseLendingNFT\n        );\n\n        isAave[keyId] = _isAave;\n\n        emit FarmEntry(\n            keyId,\n            wiseLendingNFT,\n            _leverage,\n            msg.value,\n            block.timestamp\n        );\n\n        return keyId;\n    }\n\n    function _getWiseLendingNFT()\n        internal\n        returns (uint256)\n    {\n        if (availableNFTCount == 0) {\n\n            uint256 nftId = POSITION_NFT.mintPosition();\n\n            _registrationFarm(\n                nftId\n            );\n\n            POSITION_NFT.approve(\n                AAVE_HUB_ADDRESS,\n                nftId\n            );\n\n            return nftId;\n        }\n\n        return availableNFTs[\n            availableNFTCount--\n        ];\n    }\n\n    function exitFarm(\n        uint256 _keyId,\n        uint256 _allowedSpread,\n        bool _ethBack\n    )\n        external\n        updatePools\n        onlyKeyOwner(_keyId)\n    {\n        uint256 wiseLendingNFT = farmingKeys[\n            _keyId\n        ];\n\n        delete farmingKeys[\n            _keyId\n        ];\n\n        if (reservedKeys[msg.sender] == _keyId) {\n            reservedKeys[msg.sender] = 0;\n        } else {\n            FARMS_NFTS.burnKey(\n                _keyId\n            );\n        }\n\n        availableNFTs[\n            ++availableNFTCount\n        ] = wiseLendingNFT;\n\n        _closingPosition(\n            isAave[_keyId],\n            wiseLendingNFT,\n            _allowedSpread,\n            _ethBack\n        );\n\n        emit FarmExit(\n            _keyId,\n            wiseLendingNFT,\n            _allowedSpread,\n            block.timestamp\n        );\n    }\n\n    function manuallyPaybackShares(\n        uint256 _keyId,\n        uint256 _paybackShares\n    )\n        external\n        updatePools\n    {\n        _manuallyPaybackShares(\n            farmingKeys[_keyId],\n            _paybackShares\n        );\n\n        emit ManualPaybackShares(\n            _keyId,\n            farmingKeys[_keyId],\n            _paybackShares,\n            block.timestamp\n        );\n    }\n\n    function manuallyWithdrawShares(\n        uint256 _keyId,\n        uint256 _withdrawShares\n    )\n        external\n        updatePools\n        onlyKeyOwner(_keyId)\n    {\n        uint256 wiseLendingNFT = farmingKeys[\n            _keyId\n        ];\n\n        _manuallyWithdrawShares(\n            wiseLendingNFT,\n            _withdrawShares\n        );\n\n        if (_checkDebtRatio(wiseLendingNFT) == false) {\n            revert DebtRatioTooHigh();\n        }\n\n        emit ManualWithdrawShares(\n            _keyId,\n            wiseLendingNFT,\n            _withdrawShares,\n            block.timestamp\n        );\n    }\n}"
    },
    {
      "filename": "contracts/PowerFarms/PowerFarmNFTs/MinterReserver.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"../../InterfaceHub/IPowerFarmsNFTs.sol\";\n\nerror InvalidKey();\nerror AlreadyReserved();\n\ncontract MinterReserver {\n\n    IPowerFarmsNFTs immutable FARMS_NFTS;\n\n    // Tracks increment of keys\n    uint256 public totalMinted;\n\n    // Tracks reserved counter\n    uint256 public totalReserved;\n\n    // Tracks amount of reusable NFTs\n    uint256 public availableNFTCount;\n\n    // Maps access to wiseLendingNFT through farmNFT\n    mapping(uint256 => uint256) public farmingKeys;\n\n    // Tracks reserved NFTs mapped to address\n    mapping(address => uint256) public reservedKeys;\n\n    // Tracks reusable wiseLendingNFTs after burn\n    mapping(uint256 => uint256) public availableNFTs;\n\n    modifier onlyKeyOwner(\n        uint256 _keyId\n    ) {\n        _onlyKeyOwner(\n            _keyId\n        );\n        _;\n    }\n\n    function _onlyKeyOwner(\n        uint256 _keyId\n    )\n        private\n        view\n    {\n        require(\n            isOwner(\n                _keyId,\n                msg.sender\n            ) == true\n        );\n    }\n\n    constructor(\n        address _powerFarmNFTs\n    ) {\n        FARMS_NFTS = IPowerFarmsNFTs(\n            _powerFarmNFTs\n        );\n    }\n\n    function _incrementReserved()\n        internal\n        returns (uint256)\n    {\n        return ++totalReserved;\n    }\n\n    function _getNextReserveKey()\n        internal\n        returns (uint256)\n    {\n        return totalMinted + _incrementReserved();\n    }\n\n    function _reserveKey(\n        address _userAddress,\n        uint256 _wiseLendingNFT\n    )\n        internal\n        returns (uint256)\n    {\n        if (reservedKeys[_userAddress] > 0) {\n            revert AlreadyReserved();\n        }\n\n        uint256 keyId = _getNextReserveKey();\n\n        reservedKeys[_userAddress] = keyId;\n        farmingKeys[keyId] = _wiseLendingNFT;\n\n        return keyId;\n    }\n\n    function isOwner(\n        uint256 _keyId,\n        address _owner\n    )\n        public\n        view\n        returns (bool)\n    {\n        if (reservedKeys[_owner] == _keyId) {\n            return true;\n        }\n\n        if (FARMS_NFTS.ownerOf(_keyId) == _owner) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function _mintKeyForUser(\n        uint256 _keyId,\n        address _userAddress\n    )\n        internal\n        returns (uint256)\n    {\n        if (_keyId == 0) {\n            revert InvalidKey();\n        }\n\n        delete reservedKeys[\n            _userAddress\n        ];\n\n        FARMS_NFTS.mintKey(\n            _userAddress,\n            _keyId\n        );\n\n        totalMinted++;\n        totalReserved--;\n\n        return _keyId;\n    }\n\n    function mintReserved()\n        external\n        returns (uint256)\n    {\n        return _mintKeyForUser(\n            reservedKeys[\n                msg.sender\n            ],\n            msg.sender\n        );\n    }\n\n    event ERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes _data\n    );\n\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    )\n        external\n        returns (bytes4)\n    {\n        emit ERC721Received(\n            _operator,\n            _from,\n            _tokenId,\n            _data\n        );\n\n        return this.onERC721Received.selector;\n    }\n}"
    },
    {
      "filename": "contracts/PowerFarms/PendlePowerFarm/PendlePowerFarm.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./PendlePowerFarmLeverageLogic.sol\";\n\nabstract contract PendlePowerFarm is PendlePowerFarmLeverageLogic {\n\n    /**\n     * @dev External view function approximating the\n     * new resulting net APY for a position setup.\n     *\n     * Note: Not 100% accurate because no syncPool is performed.\n     */\n    function getApproxNetAPY(\n        uint256 _initialAmount,\n        uint256 _leverage,\n        uint256 _pendleChildApy\n    )\n        external\n        view\n        returns (\n            uint256,\n            bool\n        )\n    {\n        return _getApproxNetAPY(\n            _initialAmount,\n            _leverage,\n            _pendleChildApy\n        );\n    }\n\n    /**\n     * @dev External view function approximating the\n     * new borrow amount for the pool when {_borrowAmount}\n     * is borrowed.\n     *\n     * Note: Not 100% accurate because no syncPool is performed.\n     */\n    function getNewBorrowRate(\n        uint256 _borrowAmount\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getNewBorrowRate(\n            _borrowAmount\n        );\n    }\n\n    /**\n     * @dev View functions returning the current\n     * debt ratio of the postion with {_nftId}\n     */\n    function getLiveDebtRatio(\n        uint256 _nftId\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 borrowShares = isAave[_nftId]\n            ? _getPositionBorrowSharesAave(\n                _nftId\n            )\n            : _getPositionBorrowShares(\n                _nftId\n            );\n\n        if (borrowShares == 0) {\n            return 0;\n        }\n\n        uint256 totalCollateral = getTotalWeightedCollateralETH(\n            _nftId\n        );\n\n        if (totalCollateral == 0) {\n            return 0;\n        }\n\n        return getPositionBorrowETH(_nftId)\n            * PRECISION_FACTOR_E18\n            / totalCollateral;\n    }\n\n    /**\n     * @dev Liquidation function for open power farm\n     * postions which have a debtratio greater than 100%.\n     */\n    function liquidatePartiallyFromToken(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        uint256 _shareAmountToPay\n    )\n        external\n        updatePools\n        returns (\n            uint256 paybackAmount,\n            uint256 receivingAmount\n        )\n    {\n        return _coreLiquidation(\n            _nftId,\n            _nftIdLiquidator,\n            _shareAmountToPay\n        );\n    }\n\n    /**\n     * @dev Manually payback function for users. Takes\n     * {_paybackShares} which can be converted\n     * into token with {paybackAmount()} or vice verse\n     * with {calculateBorrowShares()} from wise lending\n     * contract.\n     */\n    function _manuallyPaybackShares(\n        uint256 _nftId,\n        uint256 _paybackShares\n    )\n        internal\n    {\n        address poolAddress = WETH_ADDRESS;\n\n        if (isAave[_nftId] == true) {\n            poolAddress = AAVE_WETH_ADDRESS;\n        }\n\n        uint256 paybackAmount = WISE_LENDING.paybackAmount(\n            poolAddress,\n            _paybackShares\n        );\n\n        _safeTransferFrom(\n            poolAddress,\n            msg.sender,\n            address(this),\n            paybackAmount\n        );\n\n        WISE_LENDING.paybackExactShares(\n            _nftId,\n            poolAddress,\n            _paybackShares\n        );\n    }\n\n    /**\n     * @dev Manually withdraw function for users. Takes\n     * {_withdrawShares} which can be converted\n     * into token with {cashoutAmount()} or vice verse\n     * with {calculateLendingShares()} from wise lending\n     * contract.\n     */\n    function _manuallyWithdrawShares(\n        uint256 _nftId,\n        uint256 _withdrawShares\n    )\n        internal\n    {\n        uint256 withdrawAmount = WISE_LENDING.cashoutAmount(\n            PENDLE_CHILD,\n            _withdrawShares\n        );\n\n        withdrawAmount = WISE_LENDING.withdrawExactShares(\n            _nftId,\n            PENDLE_CHILD,\n            _withdrawShares\n        );\n\n        _safeTransfer(\n            PENDLE_CHILD,\n            msg.sender,\n            withdrawAmount\n        );\n    }\n\n    /**\n     * @dev Internal function combining the core\n     * logic for {openPosition()}.\n     */\n    function _openPosition(\n        bool _isAave,\n        uint256 _nftId,\n        uint256 _initialAmount,\n        uint256 _leverage,\n        uint256 _allowedSpread\n    )\n        internal\n    {\n        if (_leverage > MAX_LEVERAGE) {\n            revert LeverageTooHigh();\n        }\n\n        uint256 leveragedAmount = getLeverageAmount(\n            _initialAmount,\n            _leverage\n        );\n\n        if (_notBelowMinDepositAmount(leveragedAmount) == false) {\n            revert AmountTooSmall();\n        }\n\n        _executeBalancerFlashLoan(\n            {\n                _nftId: _nftId,\n                _flashAmount: leveragedAmount - _initialAmount,\n                _initialAmount: _initialAmount,\n                _lendingShares: 0,\n                _borrowShares: 0,\n                _allowedSpread: _allowedSpread,\n                _ethBack: false,\n                _isAave: _isAave\n            }\n        );\n    }\n\n    /**\n     * @dev Internal function combining the core\n     * logic for {closingPosition()}.\n     *\n     * Note: {_allowedSpread} passed through UI by asking user\n     * the percentage of acceptable value loss by closing position.\n     * Units are in ether where 100% = 1 ether -> 0% loss acceptable\n     * 1.01 ether -> 1% loss acceptable and so on.\n     */\n    function _closingPosition(\n        bool _isAave,\n        uint256 _nftId,\n        uint256 _allowedSpread,\n        bool _ethBack\n    )\n        internal\n    {\n        uint256 borrowShares = _isAave == false\n            ? _getPositionBorrowShares(\n                _nftId\n            )\n            : _getPositionBorrowSharesAave(\n                _nftId\n            );\n\n        uint256 borrowTokenAmount = _isAave == false\n            ? _getPositionBorrowTokenAmount(\n                _nftId\n            )\n            : _getPositionBorrowTokenAmountAave(\n                _nftId\n            );\n\n        _executeBalancerFlashLoan(\n            {\n                _nftId: _nftId,\n                _flashAmount: borrowTokenAmount,\n                _initialAmount: 0,\n                _lendingShares: _getPositionLendingShares(\n                    _nftId\n                ),\n                _borrowShares: borrowShares,\n                _allowedSpread: _allowedSpread,\n                _ethBack: _ethBack,\n                _isAave: _isAave\n            }\n        );\n    }\n\n    /**\n     * @dev Makes a call to WISE_LENDING to\n     * register {_nftId} for specific farm use.\n     */\n    function _registrationFarm(\n        uint256 _nftId\n    )\n        internal\n    {\n        WISE_LENDING.setRegistrationIsolationPool(\n            _nftId,\n            true\n        );\n\n        emit RegistrationFarm(\n            _nftId,\n            block.timestamp\n        );\n    }\n}"
    },
    {
      "filename": "contracts/PowerFarms/PendlePowerFarm/PendlePowerFarm.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./PendlePowerFarmLeverageLogic.sol\";\n\nabstract contract PendlePowerFarm is PendlePowerFarmLeverageLogic {\n\n    /**\n     * @dev External view function approximating the\n     * new resulting net APY for a position setup.\n     *\n     * Note: Not 100% accurate because no syncPool is performed.\n     */\n    function getApproxNetAPY(\n        uint256 _initialAmount,\n        uint256 _leverage,\n        uint256 _pendleChildApy\n    )\n        external\n        view\n        returns (\n            uint256,\n            bool\n        )\n    {\n        return _getApproxNetAPY(\n            _initialAmount,\n            _leverage,\n            _pendleChildApy\n        );\n    }\n\n    /**\n     * @dev External view function approximating the\n     * new borrow amount for the pool when {_borrowAmount}\n     * is borrowed.\n     *\n     * Note: Not 100% accurate because no syncPool is performed.\n     */\n    function getNewBorrowRate(\n        uint256 _borrowAmount\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getNewBorrowRate(\n            _borrowAmount\n        );\n    }\n\n    /**\n     * @dev View functions returning the current\n     * debt ratio of the postion with {_nftId}\n     */\n    function getLiveDebtRatio(\n        uint256 _nftId\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 borrowShares = isAave[_nftId]\n            ? _getPositionBorrowSharesAave(\n                _nftId\n            )\n            : _getPositionBorrowShares(\n                _nftId\n            );\n\n        if (borrowShares == 0) {\n            return 0;\n        }\n\n        uint256 totalCollateral = getTotalWeightedCollateralETH(\n            _nftId\n        );\n\n        if (totalCollateral == 0) {\n            return 0;\n        }\n\n        return getPositionBorrowETH(_nftId)\n            * PRECISION_FACTOR_E18\n            / totalCollateral;\n    }\n\n    /**\n     * @dev Liquidation function for open power farm\n     * postions which have a debtratio greater than 100%.\n     */\n    function liquidatePartiallyFromToken(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        uint256 _shareAmountToPay\n    )\n        external\n        updatePools\n        returns (\n            uint256 paybackAmount,\n            uint256 receivingAmount\n        )\n    {\n        return _coreLiquidation(\n            _nftId,\n            _nftIdLiquidator,\n            _shareAmountToPay\n        );\n    }\n\n    /**\n     * @dev Manually payback function for users. Takes\n     * {_paybackShares} which can be converted\n     * into token with {paybackAmount()} or vice verse\n     * with {calculateBorrowShares()} from wise lending\n     * contract.\n     */\n    function _manuallyPaybackShares(\n        uint256 _nftId,\n        uint256 _paybackShares\n    )\n        internal\n    {\n        address poolAddress = WETH_ADDRESS;\n\n        if (isAave[_nftId] == true) {\n            poolAddress = AAVE_WETH_ADDRESS;\n        }\n\n        uint256 paybackAmount = WISE_LENDING.paybackAmount(\n            poolAddress,\n            _paybackShares\n        );\n\n        _safeTransferFrom(\n            poolAddress,\n            msg.sender,\n            address(this),\n            paybackAmount\n        );\n\n        WISE_LENDING.paybackExactShares(\n            _nftId,\n            poolAddress,\n            _paybackShares\n        );\n    }\n\n    /**\n     * @dev Manually withdraw function for users. Takes\n     * {_withdrawShares} which can be converted\n     * into token with {cashoutAmount()} or vice verse\n     * with {calculateLendingShares()} from wise lending\n     * contract.\n     */\n    function _manuallyWithdrawShares(\n        uint256 _nftId,\n        uint256 _withdrawShares\n    )\n        internal\n    {\n        uint256 withdrawAmount = WISE_LENDING.cashoutAmount(\n            PENDLE_CHILD,\n            _withdrawShares\n        );\n\n        withdrawAmount = WISE_LENDING.withdrawExactShares(\n            _nftId,\n            PENDLE_CHILD,\n            _withdrawShares\n        );\n\n        _safeTransfer(\n            PENDLE_CHILD,\n            msg.sender,\n            withdrawAmount\n        );\n    }\n\n    /**\n     * @dev Internal function combining the core\n     * logic for {openPosition()}.\n     */\n    function _openPosition(\n        bool _isAave,\n        uint256 _nftId,\n        uint256 _initialAmount,\n        uint256 _leverage,\n        uint256 _allowedSpread\n    )\n        internal\n    {\n        if (_leverage > MAX_LEVERAGE) {\n            revert LeverageTooHigh();\n        }\n\n        uint256 leveragedAmount = getLeverageAmount(\n            _initialAmount,\n            _leverage\n        );\n\n        if (_notBelowMinDepositAmount(leveragedAmount) == false) {\n            revert AmountTooSmall();\n        }\n\n        _executeBalancerFlashLoan(\n            {\n                _nftId: _nftId,\n                _flashAmount: leveragedAmount - _initialAmount,\n                _initialAmount: _initialAmount,\n                _lendingShares: 0,\n                _borrowShares: 0,\n                _allowedSpread: _allowedSpread,\n                _ethBack: false,\n                _isAave: _isAave\n            }\n        );\n    }\n\n    /**\n     * @dev Internal function combining the core\n     * logic for {closingPosition()}.\n     *\n     * Note: {_allowedSpread} passed through UI by asking user\n     * the percentage of acceptable value loss by closing position.\n     * Units are in ether where 100% = 1 ether -> 0% loss acceptable\n     * 1.01 ether -> 1% loss acceptable and so on.\n     */\n    function _closingPosition(\n        bool _isAave,\n        uint256 _nftId,\n        uint256 _allowedSpread,\n        bool _ethBack\n    )\n        internal\n    {\n        uint256 borrowShares = _isAave == false\n            ? _getPositionBorrowShares(\n                _nftId\n            )\n            : _getPositionBorrowSharesAave(\n                _nftId\n            );\n\n        uint256 borrowTokenAmount = _isAave == false\n            ? _getPositionBorrowTokenAmount(\n                _nftId\n            )\n            : _getPositionBorrowTokenAmountAave(\n                _nftId\n            );\n\n        _executeBalancerFlashLoan(\n            {\n                _nftId: _nftId,\n                _flashAmount: borrowTokenAmount,\n                _initialAmount: 0,\n                _lendingShares: _getPositionLendingShares(\n                    _nftId\n                ),\n                _borrowShares: borrowShares,\n                _allowedSpread: _allowedSpread,\n                _ethBack: _ethBack,\n                _isAave: _isAave\n            }\n        );\n    }\n\n    /**\n     * @dev Makes a call to WISE_LENDING to\n     * register {_nftId} for specific farm use.\n     */\n    function _registrationFarm(\n        uint256 _nftId\n    )\n        internal\n    {\n        WISE_LENDING.setRegistrationIsolationPool(\n            _nftId,\n            true\n        );\n\n        emit RegistrationFarm(\n            _nftId,\n            block.timestamp\n        );\n    }\n}"
    },
    {
      "filename": "contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmMathLogic.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./PendlePowerFarmDeclarations.sol\";\n\nabstract contract PendlePowerFarmMathLogic is PendlePowerFarmDeclarations {\n\n    modifier updatePools() {\n        _checkReentrancy();\n        _updatePools();\n        _;\n    }\n\n    /**\n     * @dev Update logic for pools via wise lending\n     * interfaces\n     */\n    function _updatePools()\n        private\n    {\n        WISE_LENDING.syncManually(\n            WETH_ADDRESS\n        );\n\n        WISE_LENDING.syncManually(\n            AAVE_WETH_ADDRESS\n        );\n\n        WISE_LENDING.syncManually(\n            PENDLE_CHILD\n        );\n    }\n\n    function _checkReentrancy()\n        private\n        view\n    {\n        if (sendingProgress == true) {\n            revert AccessDenied();\n        }\n\n        if (WISE_LENDING.sendingProgress() == true) {\n            revert AccessDenied();\n        }\n\n        if (AAVE_HUB.sendingProgressAaveHub() == true) {\n            revert AccessDenied();\n        }\n    }\n\n    /**\n     * @dev Internal function getting the\n     * borrow shares from position {_nftId}\n     * with token {_borrowToken}\n     */\n    function _getPositionBorrowShares(\n        uint256 _nftId\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return WISE_LENDING.getPositionBorrowShares(\n            _nftId,\n            WETH_ADDRESS\n        );\n    }\n\n    /**\n     * @dev Internal function getting the\n     * borrow shares of aave from position {_nftId}\n     * with token {_borrowToken}\n     */\n    function _getPositionBorrowSharesAave(\n        uint256 _nftId\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return WISE_LENDING.getPositionBorrowShares(\n            _nftId,\n            AAVE_WETH_ADDRESS\n        );\n    }\n\n    /**\n     * @dev Internal function converting\n     * borrow shares into tokens.\n     */\n    function _getPositionBorrowTokenAmount(\n        uint256 _nftId\n    )\n        internal\n        view\n        returns (uint256 tokenAmount)\n    {\n        uint256 positionBorrowShares = _getPositionBorrowShares(\n            _nftId\n        );\n\n        if (positionBorrowShares > 0) {\n            tokenAmount = WISE_LENDING.paybackAmount(\n                WETH_ADDRESS,\n                positionBorrowShares\n            );\n        }\n    }\n\n    function _getPositionBorrowTokenAmountAave(\n        uint256 _nftId\n    )\n        internal\n        view\n        returns (uint256 tokenAmountAave)\n    {\n        uint256 positionBorrowSharesAave = _getPositionBorrowSharesAave(\n            _nftId\n        );\n\n        if (positionBorrowSharesAave > 0) {\n\n            tokenAmountAave = WISE_LENDING.paybackAmount(\n                AAVE_WETH_ADDRESS,\n                positionBorrowSharesAave\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function getting the\n     * lending shares from position {_nftId}\n     * with token {_borrowToken}\n     */\n    function _getPositionLendingShares(\n        uint256 _nftId\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return WISE_LENDING.getPositionLendingShares(\n            _nftId,\n            PENDLE_CHILD\n        );\n    }\n\n    /**\n     * @dev Internal function converting\n     * lending shares into tokens.\n     */\n    function _getPostionCollateralTokenAmount(\n        uint256 _nftId\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return WISE_LENDING.cashoutAmount(\n            {\n                _poolToken: PENDLE_CHILD,\n                _shares: _getPositionLendingShares(\n                    _nftId\n                )\n            }\n        );\n    }\n\n    /**\n     * @dev Read function returning the total\n     * borrow amount in ETH from postion {_nftId}\n     */\n    function getPositionBorrowETH(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 borrowTokenAmount;\n        uint256 borrowShares = _getPositionBorrowShares(\n            _nftId\n        );\n\n        if (borrowShares > 0) {\n            borrowTokenAmount = _getPositionBorrowTokenAmount(\n                _nftId\n            );\n        }\n\n        uint256 borrowSharesAave = _getPositionBorrowSharesAave(\n            _nftId\n        );\n\n        uint256 borrowTokenAmountAave;\n\n        if (borrowSharesAave > 0) {\n            borrowTokenAmountAave = _getPositionBorrowTokenAmountAave(\n                _nftId\n            );\n        }\n\n        uint256 tokenValueEth;\n\n        if (borrowShares > 0) {\n            tokenValueEth = _getTokensInETH(\n                WETH_ADDRESS,\n                borrowTokenAmount\n            );\n        }\n\n        if (borrowTokenAmountAave == 0) {\n            return tokenValueEth;\n        }\n\n        uint256 tokenValueAaveEth = _getTokensInETH(\n            AAVE_WETH_ADDRESS,\n            borrowTokenAmountAave\n        );\n\n        return tokenValueEth + tokenValueAaveEth;\n    }\n\n    /**\n     * @dev Read function returning the total\n     * lending amount in ETH from postion {_nftId}\n     */\n    function getTotalWeightedCollateralETH(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _getTokensInETH(\n            PENDLE_CHILD,\n            _getPostionCollateralTokenAmount(_nftId)\n        )\n            * collateralFactor\n            / PRECISION_FACTOR_E18;\n    }\n\n    function _getTokensInETH(\n        address _tokenAddress,\n        uint256 _tokenAmount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return ORACLE_HUB.getTokensInETH(\n            _tokenAddress,\n            _tokenAmount\n        );\n    }\n\n    function _getEthInTokens(\n        address _tokenAddress,\n        uint256 _ethAmount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return ORACLE_HUB.getTokensFromETH(\n            _tokenAddress,\n            _ethAmount\n        );\n    }\n\n    function getLeverageAmount(\n        uint256 _initialAmount,\n        uint256 _leverage\n    )\n        public\n        pure\n        returns (uint256)\n    {\n        return _initialAmount\n            * _leverage\n            / PRECISION_FACTOR_E18;\n    }\n\n    /**\n     * @dev Internal function with math logic for approximating\n     * the net APY for the postion aftrer creation.\n     */\n    function _getApproxNetAPY(\n        uint256 _initialAmount,\n        uint256 _leverage,\n        uint256 _wstETHAPY\n    )\n        internal\n        view\n        returns (\n            uint256,\n            bool\n        )\n    {\n        if (_leverage < PRECISION_FACTOR_E18) {\n            return (\n                0,\n                false\n            );\n        }\n\n        uint256 leveragedAmount = getLeverageAmount(\n            _initialAmount,\n            _leverage\n        );\n\n        uint256 flashloanAmount = leveragedAmount\n            - _initialAmount;\n\n        uint256 newBorrowRate = _getNewBorrowRate(\n            flashloanAmount\n        );\n\n        uint256 leveragedPositivAPY = _wstETHAPY\n            * _leverage\n            / PRECISION_FACTOR_E18;\n\n        uint256 leveragedNegativeAPY = newBorrowRate\n            * (_leverage - PRECISION_FACTOR_E18)\n            / PRECISION_FACTOR_E18;\n\n        bool isPositive = leveragedPositivAPY >= leveragedNegativeAPY;\n\n        uint256 netAPY = isPositive == true\n            ? leveragedPositivAPY - leveragedNegativeAPY\n            : leveragedNegativeAPY - leveragedPositivAPY;\n\n        return (\n            netAPY,\n            isPositive\n        );\n    }\n\n    /**\n     * @dev Internal function with math logic for approximating\n     * the new borrow APY.\n     */\n    function _getNewBorrowRate(\n        uint256 _borrowAmount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 totalPool = WISE_LENDING.getTotalPool(\n            ENTRY_ASSET\n        );\n\n        uint256 pseudoPool = WISE_LENDING.getPseudoTotalPool(\n            ENTRY_ASSET\n        );\n\n        if (totalPool > pseudoPool) {\n            return 0;\n        }\n\n        uint256 newUtilization = PRECISION_FACTOR_E18 - (PRECISION_FACTOR_E18\n            * (totalPool - _borrowAmount)\n            / pseudoPool\n        );\n\n        uint256 pole = WISE_LENDING.borrowRatesData(\n            ENTRY_ASSET\n        ).pole;\n\n        uint256 mulFactor = WISE_LENDING.borrowRatesData(\n            ENTRY_ASSET\n        ).multiplicativeFactor;\n\n        uint256 baseDivider = pole\n            * (pole - newUtilization);\n\n        return mulFactor\n            * PRECISION_FACTOR_E18\n            * newUtilization\n            / baseDivider;\n    }\n\n    /**\n     * @dev Internal function checking if a position\n     * with {_nftId} has a debt ratio under 100%.\n     */\n    function _checkDebtRatio(\n        uint256 _nftId\n    )\n        internal\n        view\n        returns (bool)\n    {\n        uint256 borrowShares = isAave[_nftId]\n            ? _getPositionBorrowSharesAave(\n                _nftId\n            )\n            : _getPositionBorrowShares(\n                _nftId\n        );\n\n        if (b"
    }
  ]
}