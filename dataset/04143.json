{
  "Title": "[M08] Not using SafeMath functions",
  "Content": "There are several places in the code base where regular Solidity arithmetic operators are used. For example:\n\n\n* In [line 298 of the `GlobalSettlement` contract](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L298) `/` is used.\n* In [line 196 of the `Coin` contract](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/Coin.sol#L196) `++` is used.\n* In [line 565 of the `TaxCollector` contract](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/TaxCollector.sol#L565) `/` is used.\n\n\nThese operators do not protect against overflows, underflows or division by `0` and may silently fail or return unexpected values.  \n\nConsider always performing arithmetic operations with functions that protect the code from such scenarios, like the [math libraries of OpenZeppelin contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/release-v3.2.0/contracts/math).\n\n\n***Update:** Acknowledged, and will not fix. Reflexer Labsâ€™ statement for this issue:*\n\n\n\n> \n>  We understand the concern although we would like to stick to the same functions used in MCD\n> \n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/GlobalSettlement.sol",
      "content": "/// GlobalSettlement.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n// Copyright (C) 2018 Lev Livnev <lev@liv.nev.org.uk>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nabstract contract SAFEEngineLike {\n    function coinBalance(address) virtual public view returns (uint256);\n    function collateralTypes(bytes32) virtual public view returns (\n        uint256 debtAmount,        // [wad]\n        uint256 accumulatedRate,   // [ray]\n        uint256 safetyPrice,       // [ray]\n        uint256 debtCeiling,       // [rad]\n        uint256 debtFloor,         // [rad]\n        uint256 liquidationPrice   // [ray]\n    );\n    function safes(bytes32,address) virtual public view returns (\n        uint256 lockedCollateral, // [wad]\n        uint256 generatedDebt     // [wad]\n    );\n    function globalDebt() virtual public returns (uint256);\n    function transferInternalCoins(address src, address dst, uint256 rad) virtual external;\n    function approveSAFEModification(address) virtual external;\n    function transferCollateral(bytes32 collateralType, address src, address dst, uint256 wad) virtual external;\n    function confiscateSAFECollateralAndDebt(bytes32 collateralType, address safe, address collateralSource, address debtDestination, int256 deltaCollateral, int256 deltaDebt) virtual external;\n    function createUnbackedDebt(address debtDestination, address coinDestination, uint256 rad) virtual external;\n    function disableContract() virtual external;\n}\nabstract contract LiquidationEngineLike {\n    function collateralTypes(bytes32) virtual public view returns (\n        address collateralAuctionHouse,\n        uint256 liquidationPenalty,     // [wad]\n        uint256 liquidationQuantity     // [rad]\n    );\n    function disableContract() virtual external;\n}\nabstract contract StabilityFeeTreasuryLike {\n    function disableContract() virtual external;\n}\nabstract contract AccountingEngineLike {\n    function disableContract() virtual external;\n}\nabstract contract CoinSavingsAccountLike {\n    function disableContract() virtual external;\n}\nabstract contract CollateralAuctionHouseLike {\n    function bidAmount(uint id) virtual public view returns (uint256);\n    function remainingAmountToSell(uint id) virtual public view returns (uint256);\n    function forgoneCollateralReceiver(uint id) virtual public view returns (address);\n    function amountToRaise(uint id) virtual public view returns (uint256);\n    function terminateAuctionPrematurely(uint auctionId) virtual external;\n}\nabstract contract OracleLike {\n    function read() virtual public view returns (uint256);\n}\nabstract contract OracleRelayerLike {\n    function redemptionPrice() virtual public returns (uint256);\n    function collateralTypes(bytes32) virtual public view returns (\n        OracleLike orcl,\n        uint256 safetyCRatio,\n        uint256 liquidationCRatio\n    );\n    function disableContract() virtual external;\n}\n\n/*\n    This is the Global Settlement module. It is an\n    involved, stateful process that takes place over nine steps.\n    First we freeze the system and lock the prices for each collateral type.\n    1. `shutdownSystem()`:\n        - freezes user entrypoints\n        - cancels collateral/surplus auctions\n        - starts cooldown period\n    2. `freezeCollateralType(collateralType)`:\n       - set the final price for each collateralType, reading off the price feed\n    We must process some system state before it is possible to calculate\n    the final coin / collateral price. In particular, we need to determine:\n      a. `collateralShortfall` (considers under-collateralised SAFEs)\n      b. `outstandingCoinSupply` (after including system surplus / deficit)\n    We determine (a) by processing all under-collateralised SAFEs with\n    `processSAFE`\n    3. `processSAFE(collateralType, safe)`:\n       - cancels SAFE debt\n       - any excess collateral remains\n       - backing collateral taken\n    We determine (b) by processing ongoing coin generating processes,\n    i.e. auctions. We need to ensure that auctions will not generate any\n    further coin income. In the two-way auction model this occurs when\n    all auctions are in the reverse (`decreaseSoldAmount`) phase. There are two ways\n    of ensuring this:\n    4.  i) `shutdownCooldown`: set the cooldown period to be at least as long as the\n           longest auction duration, which needs to be determined by the\n           shutdown administrator.\n           This takes a fairly predictable time to occur but with altered\n           auction dynamics due to the now varying price of the system coin.\n       ii) `fastTrackAuction`: cancel all ongoing auctions and seize the collateral.\n           This allows for faster processing at the expense of more\n           processing calls. This option allows coin holders to retrieve\n           their collateral faster.\n           `fastTrackAuction(collateralType, auctionId)`:\n            - cancel individual collateral auctions in the `increaseBidSize` (forward) phase\n            - retrieves collateral and returns coins to bidder\n            - `decreaseSoldAmount` (reverse) phase auctions can continue normally\n    Option (i), `shutdownCooldown`, is sufficient for processing the system\n    settlement but option (ii), `fastTrackAuction`, will speed it up. Both options\n    are available in this implementation, with `fastTrackAuction` being enabled on a\n    per-auction basis.\n    When a SAFE has been processed and has no debt remaining, the\n    remaining collateral can be removed.\n    5. `freeCollateral(collateralType)`:\n        - remove collateral from the caller's SAFE\n        - owner can call as needed\n    After the processing period has elapsed, we enable calculation of\n    the final price for each collateral type.\n    6. `setOutstandingCoinSupply()`:\n       - only callable after processing time period elapsed\n       - assumption that all under-collateralised SAFEs are processed\n       - fixes the total outstanding supply of coin\n       - may also require extra SAFE processing to cover system surplus\n    7. `calculateCashPrice(collateralType)`:\n        - calculate `collateralCashPrice`\n        - adjusts `collateralCashPrice` in the case of deficit / surplus\n    At this point we have computed the final price for each collateral\n    type and coin holders can now turn their coin into collateral. Each\n    unit coin can claim a fixed basket of collateral.\n    Coin holders must first `prepareCoinsForRedeeming` into a `coinBag`. Once prepared,\n    coins cannot be transferred out of the bag. More coin can be added to a bag later.\n    8. `prepareCoinsForRedeeming(coinAmount)`:\n        - put some coins into a bag in order to 'redeemCollateral'. The bigger the bag, the more collateral the user can claim.\n    9. `redeemCollateral(collateralType, collateralAmount)`:\n        - exchange some coin from your bag for tokens from a specific collateral type\n        - the amount of collateral available to redeem is limited by how big your bag is\n*/\n\ncontract GlobalSettlement {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"GlobalSettlement/account-not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    SAFEEngineLike            public safeEngine;\n    LiquidationEngineLike    public liquidationEngine;\n    AccountingEngineLike     public accountingEngine;\n    OracleRelayerLike        public oracleRelayer;\n    CoinSavingsAccountLike   public coinSavingsAccount;\n    StabilityFeeTreasuryLike public stabilityFeeTreasury;\n\n    uint256  public contractEnabled;\n    uint256  public shutdownTime;\n    uint256  public shutdownCooldown;\n    uint256  public outstandingCoinSupply;                                      // [rad]\n\n    mapping (bytes32 => uint256) public finalCoinPerCollateralPrice;            // [ray]\n    mapping (bytes32 => uint256) public collateralShortfall;                    // [wad]\n    mapping (bytes32 => uint256) public collateralTotalDebt;                    // [wad]\n    mapping (bytes32 => uint256) public collateralCashPrice;                    // [ray]\n\n    mapping (address => uint256)                      public coinBag;           // [wad]\n    mapping (bytes32 => mapping (address => uint256)) public coinsUsedToRedeem; // [wad]\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 parameter, uint data);\n    event ModifyParameters(bytes32 parameter, address data);\n    event ShutdownSystem();\n    event FreezeCollateralType(bytes32 collateralType, uint finalCoinPerCollateralPrice);\n    event FastTrackAuction(bytes32 collateralType, uint256 auctionId, uint256 collateralTotalDebt);\n    event ProcessSAFE(bytes32 collateralType, address safe, uint256 collateralShortfall);\n    event FreeCollateral(bytes32 collateralType, address sender, int collateralAmount);\n    event SetOutstandingCoinSupply(uint256 outstandingCoinSupply);\n    event CalculateCashPrice(bytes32 collateralType, uint collateralCashPrice);\n    event PrepareCoinsForRedeeming(address sender, uint coinBag);\n    event RedeemCollateral(bytes32 collateralType, address sender, uint coinsAmount, uint collateralAmount);\n\n    // --- Init ---\n    constructor() public {\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addition(uint x, uint y) internal pure returns (uint z) {\n        z = x + y;\n        require(z >= x);\n    }\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function minimum(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n    function rmultiply(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, y) / RAY;\n    }\n    function rdivide(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, RAY) / y;\n    }\n    function wdivide(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, WAD) / y;\n    }\n\n    // --- Administration ---\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        require(contractEnabled == 1, \"GlobalSettlement/contract-not-enabled\");\n        if (parameter == \"safeEngine\") safeEngine = SAFEEngineLike(data);\n        else if (parameter == \"liquidationEngine\") liquidationEngine = LiquidationEngineLike(data);\n        else if (parameter == \"accountingEngine\") accountingEngine = AccountingEngineLike(data);\n        else if (parameter == \"oracleRelayer\") oracleRelayer = OracleRelayerLike(data);\n        else if (parameter == \"coinSavingsAccount\") coinSavingsAccount = CoinSavingsAccountLike(data);\n        else if (parameter == \"stabilityFeeTreasury\") stabilityFeeTreasury = StabilityFeeTreasuryLike(data);\n        else revert(\"GlobalSettlement/modify-unrecognized-parameter\");\n        emit ModifyParameters(parameter, data);\n    }\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        require(contractEnabled == 1, \"GlobalSettlement/contract-not-enabled\");\n        if (parameter == \"shutdownCooldown\") shutdownCooldown = data;\n        else revert(\"GlobalSettlement/modify-unrecognized-parameter\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Settlement ---\n    function shutdownSystem() external isAuthorized {\n        require(contractEnabled == 1, \"GlobalSettlement/contract-not-enabled\");\n        contractEnabled = 0;\n        shutdownTime = now;\n        safeEngine.disableContract();\n        liquidationEngine.disableContract();\n        // treasury must be disabled before AccountingEngine so that all surplus is gathered in one place\n        if (address(stabilityFeeTreasury) != address(0)) {\n          stabilityFeeTreasury.disableContract();\n        }\n        accountingEngine.disableContract();\n        oracleRelayer.disableContract();\n        if (address(coinSavingsAccount) != address(0)) {\n          coinSavingsAccount.disableContract();\n        }\n        emit ShutdownSystem();\n    }\n\n    function freezeCollateralType(bytes32 collateralType) external {\n        require(contractEnabled == 0, \"GlobalSettlement/contract-still-enabled\");\n        require(finalCoinPerCollateralPrice[collateralType] == 0, \"GlobalSettlement/final-collateral-price-already-defined\");\n        (collateralTotalDebt[collateralType],,,,,) = safeEngine.collateralTypes(collateralType);\n        (OracleLike orcl,,) = oracleRelayer.collateralTypes(collateralType);\n        // redemptionPrice is a ray, orcl returns a wad\n        finalCoinPerCollateralPrice[collateralType] = wdivide(oracleRelayer.redemptionPrice(), uint(orcl.read()));\n        emit FreezeCollateralType(collateralType, finalCoinPerCollateralPrice[collateralType]);\n    }\n    function fastTrackAuction(bytes32 collateralType, uint256 auctionId) external {\n        require(finalCoinPerCollateralPrice[collateralType] != 0, \"GlobalSettlement/final-collateral-price-not-defined\");\n\n        (address auctionHouse_,,)    = liquidationEngine.collateralTypes(collateralType);\n        CollateralAuctionHouseLike collateralAuctionHouse = CollateralAuctionHouseLike(auctionHouse_);\n        (, uint accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);\n\n        uint bidAmount                    = collateralAuctionHouse.bidAmount(auctionId);\n        uint collateralToSell             = collateralAuctionHouse.remainingAmountToSell(auctionId);\n        address forgoneCollateralReceiver = collateralAuctionHouse.forgoneCollateralReceiver(auctionId);\n        uint amountToRaise                = collateralAuctionHouse.amountToRaise(auctionId);\n\n        safeEngine.createUnbackedDebt(address(accountingEngine), address(accountingEngine), amountToRaise);\n        safeEngine.createUnbackedDebt(address(accountingEngine), address(this), bidAmount);\n        safeEngine.approveSAFEModification(address(collateralAuctionHouse));\n        collateralAuctionHouse.terminateAuctionPrematurely(auctionId);\n\n        uint debt_ = amountToRaise / accumulatedRate;\n        collateralTotalDebt[collateralType] = addition(collateralTotalDebt[collateralType], debt_);\n        require(int(collateralToSell) >= 0 && int(debt_) >= 0, \"GlobalSettlement/overflow\");\n        safeEngine.confiscateSAFECollateralAndDebt(collateralType, forgoneCollateralReceiver, address(this), address(accountingEngine), int(collateralToSell), int(debt_));\n        emit FastTrackAuction(collateralType, auctionId, collateralTotalDebt[collateralType]);\n    }\n    function processSAFE(bytes32 collateralType, address safe) external {\n        require(finalCoinPerCollateralPrice[collateralType] != 0, \"GlobalSettlement/final-collateral-price-not-defined\");\n        (, uint accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);\n        (uint safeCollateral, uint safeDebt) = safeEngine.safes(collateralType, safe);\n\n        uint amountOwed = rmultiply(rmultiply(safeDebt, accumulatedRate), finalCoinPerCollateralPrice[collateralType]);\n        uint minCollateral = minimum(safeCollateral, amountOwed);\n        collateralShortfall[collateralType] = addition(\n            collateralShortfall[collateralType],\n            subtract(amountOwed, minCollateral)\n        );\n\n        require(minCollateral <= 2**255 && safeDebt <= 2**255, \"GlobalSettlement/overflow\");\n        safeEngine.confiscateSAFECollateralAndDebt(\n            collateralType,\n            safe,\n            address(this),\n            address(accountingEngine),\n            -int(minCollateral),\n            -int(safeDebt)\n        );\n\n        emit ProcessSAFE(collateralType, safe, collateralShortfall[collateralType]);\n    }\n    function freeCollateral(bytes32 collateralType) external {\n        require(contractEnabled == 0, \"GlobalSettlement/contract-still-enabled\");\n        (uint safeCollateral, uint safeDebt) = safeEngine.safes(collateralType, msg.sender);\n        require(safeDebt == 0, \"GlobalSettlement/art-not-zero\");\n        require(safeCollateral <= 2**255, \"GlobalSettlement/overflow\");\n        safeEngine.confiscateSAFECollateralAndDebt(\n          collateralType,\n          msg.sender,\n          msg.sender,\n          address(accountingEngine),\n          -int(safeCollateral),\n          0\n        );\n        emit FreeCollateral(collateralType, msg.sender, -int(safeCollateral));\n    }\n    function setOutstandingCoinSupply() external {\n        require(contractEnabled == 0, \"GlobalSettlement/contract-still-enabled\");\n        require(outstandingCoinSupply == 0, \"GlobalSettlement/outstanding-coin-supply-not-zero\");\n        require(safeEngine.coinBalance(address(accountingEngine)) == 0, \"GlobalSettlement/surplus-not-zero\");\n        require(now >= addition(shutdownTime, shutdownCooldown), \"GlobalSettlement/shutdown-cooldown-not-finished\");\n        outstandingCoinSupply = safeEngine.globalDebt();\n        emit SetOutstandingCoinSupply(outstandingCoinSupply);\n    }\n    function calculateCashPrice(bytes32 collateralType) external {\n        require(outstandingCoinSupply != 0, \"GlobalSettlement/outstanding-coin-supply-zero\");\n        require(collateralCashPrice[collateralType] == 0, \"GlobalSettlement/collateral-cash-price-already-defined\");\n\n        (, uint accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);\n        uint256 redemptionAdjustedDebt = rmultiply(\n          rmultiply(collateralTotalDebt[collateralType], accumulatedRate), finalCoinPerCollateralPrice[collateralType]\n        );\n        collateralCashPrice[collateralType] = rdivide(\n          multiply(subtract(redemptionAdjustedDebt, collateralShortfall[collateralType]), RAY), outstandingCoinSupply\n        );\n        emit CalculateCashPrice(collateralType, collateralCashPrice[collateralType]);\n    }\n    function prepareCoinsForRedeeming(uint256 coinAmount) external {\n        require(outstandingCoinSupply != 0, \"GlobalSettlement/outstanding-coin-supply-zero\");\n        safeEngine.transferInternalCoins(msg.sender, address(accountingEngine), multiply(coinAmount, RAY));\n        coinBag[msg.sender] = addition(coinBag[msg.sender], coinAmount);\n        emit PrepareCoinsForRedeeming(msg.sender, coinBag[msg.sender]);\n    }\n    function redeemCollateral(bytes32 collateralType, uint coinsAmount) external {\n        require(collateralCashPrice[collateralType] != 0, \"GlobalSettlement/collateral-cash-price-not-defined\");\n        uint collateralAmount = rmultiply(coinsAmount, collateralCashPrice[collateralType]);\n        safeEngine.transferCollateral(\n          collateralType,\n          address(this),\n          msg.sender,\n          collateralAmount\n        );\n        coinsUsedToRedeem[collateralType][msg.sender] = addition(coinsUsedToRedeem[collateralType][msg.sender], coinsAmount);\n        require(coinsUsedToRedeem[collateralType][msg.sender] <= coinBag[msg.sender], \"GlobalSettlement/insufficient-bag-balance\");\n        emit RedeemCollateral(collateralType, msg.sender, coinsAmount, collateralAmount);\n    }\n}"
    },
    {
      "filename": "src/Coin.sol",
      "content": "// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\ncontract Coin {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"Coin/account-not-authorized\");\n        _;\n    }\n\n    modifier canChangeData() {\n        require(changeData == 1, \"Coin/cannot-change-namings\");\n        _;\n    }\n\n    // --- ERC20 Data ---\n    string  public name;\n    string  public symbol;\n    string  public version = \"1\";\n\n    uint8   public constant decimals = 18;\n\n    uint256 public chainId;\n    uint256 public totalSupply;\n    uint256 public changeData;\n\n    mapping (address => uint)                      public balanceOf;\n    mapping (address => mapping (address => uint)) public allowance;\n    mapping (address => uint)                      public nonces;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event Approval(address indexed src, address indexed guy, uint amount);\n    event Transfer(address indexed src, address indexed dst, uint amount);\n    event ModifyParameters(bytes32 parameter, uint data);\n\n    // --- Math ---\n    function addition(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n\n    // --- EIP712 niceties ---\n    bytes32 public DOMAIN_SEPARATOR;\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 chainId_\n      ) public {\n        authorizedAccounts[msg.sender] = 1;\n        name          = name_;\n        symbol        = symbol_;\n        changeData    = 1;\n        chainId       = chainId_;\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(name)),\n            keccak256(bytes(version)),\n            chainId_,\n            address(this)\n        ));\n        emit AddAuthorization(msg.sender);\n        emit ModifyParameters(\"changeData\", 1);\n    }\n\n    // --- Administration ---\n    function modifyParameters(bytes32 parameter, uint data) external isAuthorized canChangeData {\n        if (parameter == \"changeData\") {\n          changeData = data;\n        }\n        else revert(\"Coin/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Naming ---\n    function setName(string calldata name_) external isAuthorized canChangeData {\n        name             = name_;\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(name)),\n            keccak256(bytes(version)),\n            chainId,\n            address(this)\n        ));\n    }\n    function setSymbol(string calldata symbol_) external isAuthorized canChangeData {\n        symbol = symbol_;\n    }\n\n    // --- Token ---\n    function transfer(address dst, uint amount) external returns (bool) {\n        return transferFrom(msg.sender, dst, amount);\n    }\n    function transferFrom(address src, address dst, uint amount)\n        public returns (bool)\n    {\n        require(balanceOf[src] >= amount, \"Coin/insufficient-balance\");\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= amount, \"Coin/insufficient-allowance\");\n            allowance[src][msg.sender] = subtract(allowance[src][msg.sender], amount);\n        }\n        balanceOf[src] = subtract(balanceOf[src], amount);\n        balanceOf[dst] = addition(balanceOf[dst], amount);\n        emit Transfer(src, dst, amount);\n        return true;\n    }\n    function mint(address usr, uint amount) external isAuthorized {\n        balanceOf[usr] = addition(balanceOf[usr], amount);\n        totalSupply    = addition(totalSupply, amount);\n        emit Transfer(address(0), usr, amount);\n    }\n    function burn(address usr, uint amount) external {\n        require(balanceOf[usr] >= amount, \"Coin/insufficient-balance\");\n        if (usr != msg.sender && allowance[usr][msg.sender] != uint(-1)) {\n            require(allowance[usr][msg.sender] >= amount, \"Coin/insufficient-allowance\");\n            allowance[usr][msg.sender] = subtract(allowance[usr][msg.sender], amount);\n        }\n        balanceOf[usr] = subtract(balanceOf[usr], amount);\n        totalSupply    = subtract(totalSupply, amount);\n        emit Transfer(usr, address(0), amount);\n    }\n    function approve(address usr, uint amount) external returns (bool) {\n        allowance[msg.sender][usr] = amount;\n        emit Approval(msg.sender, usr, amount);\n        return true;\n    }\n\n    // --- Alias ---\n    function push(address usr, uint amount) external {\n        transferFrom(msg.sender, usr, amount);\n    }\n    function pull(address usr, uint amount) external {\n        transferFrom(usr, msg.sender, amount);\n    }\n    function move(address src, address dst, uint amount) external {\n        transferFrom(src, dst, amount);\n    }\n\n    // --- Approve by signature ---\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external\n    {\n        require(changeData != 1, \"Coin/can-still-change-namings\");\n        bytes32 digest =\n            keccak256(abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH,\n                                     holder,\n                                     spender,\n                                     nonce,\n                                     expiry,\n                                     allowed))\n        ));\n\n        require(holder != address(0), \"Coin/invalid-address-0\");\n        require(holder == ecrecover(digest, v, r, s), \"Coin/invalid-permit\");\n        require(expiry == 0 || now <= expiry, \"Coin/permit-expired\");\n        require(nonce == nonces[holder]++, \"Coin/invalid-nonce\");\n        uint wad = allowed ? uint(-1) : 0;\n        allowance[holder][spender] = wad;\n        emit Approval(holder, spender, wad);\n    }\n}"
    },
    {
      "filename": "src/TaxCollector.sol",
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nimport \"./LinkedList.sol\";\n\nabstract contract SAFEEngineLike {\n    function collateralTypes(bytes32) virtual public view returns (\n        uint256 debtAmount,       // [wad]\n        uint256 accumulatedRate   // [ray]\n    );\n    function updateAccumulatedRate(bytes32,address,int) virtual external;\n    function coinBalance(address) virtual public view returns (uint);\n}\n\ncontract TaxCollector {\n    using LinkedList for LinkedList.List;\n\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"TaxCollector/account-not-authorized\");\n        _;\n    }\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event InitializeCollateralType(bytes32 collateralType);\n    event ModifyParameters(\n      bytes32 collateralType,\n      bytes32 parameter,\n      uint data\n    );\n    event ModifyParameters(bytes32 parameter, uint data);\n    event ModifyParameters(bytes32 parameter, address data);\n    event ModifyParameters(\n      bytes32 collateralType,\n      uint256 position,\n      uint256 val\n    );\n    event ModifyParameters(\n      bytes32 collateralType,\n      uint256 position,\n      uint256 taxPercentage,\n      address receiverAccount\n    );\n    event AddSecondaryReceiver(\n      bytes32 collateralType,\n      uint secondaryReceiverNonce,\n      uint latestSecondaryReceiver,\n      uint secondaryReceiverAllotedTax,\n      uint secondaryReceiverRevenueSources\n    );\n    event ModifySecondaryReceiver(\n      bytes32 collateralType,\n      uint secondaryReceiverNonce,\n      uint latestSecondaryReceiver,\n      uint secondaryReceiverAllotedTax,\n      uint secondaryReceiverRevenueSources\n    );\n    event CollectTax(bytes32 collateralType, uint latestAccumulatedRate, int deltaRate);\n    event DistributeTax(bytes32 collateralType, address target, int taxCut);\n\n    // --- Data ---\n    struct CollateralType {\n        // Per second borrow rate for this specific collateral type\n        uint256 stabilityFee;\n        // When SF was last collected for this collateral type\n        uint256 updateTime;\n    }\n    // SF receiver\n    struct TaxReceiver {\n        // Whether this receiver can accept a negative rate (taking SF from it)\n        uint256 canTakeBackTax;                                                 // [bool]\n        // Percentage of SF allocated to this receiver\n        uint256 taxPercentage;                                                  // [ray%]\n    }\n\n    // Data about each collateral type\n    mapping (bytes32 => CollateralType)                  public collateralTypes;\n    // Percentage of each collateral's SF that goes to other addresses apart from the primary receiver\n    mapping (bytes32 => uint)                            public secondaryReceiverAllotedTax;              // [%ray]\n    // Whether an address is already used for a tax receiver\n    mapping (address => uint256)                         public usedSecondaryReceiver;                    // [bool]\n    // Address associated to each tax receiver index\n    mapping (uint256 => address)                         public secondaryReceiverAccounts;\n    // How many collateral types send SF to a specific tax receiver\n    mapping (address => uint256)                         public secondaryReceiverRevenueSources;\n    // Tax receiver data\n    mapping (bytes32 => mapping(uint256 => TaxReceiver)) public secondaryTaxReceivers;\n\n    address    public primaryTaxReceiver;\n    // Base stability fee charged to all collateral types\n    uint256    public globalStabilityFe"
    }
  ]
}