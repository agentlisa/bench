{
  "Title": "H-3: Clearinghouse.sol#claimDefaulted()",
  "Content": "# Issue H-3: Clearinghouse.sol#claimDefaulted() \n\nSource: https://github.com/sherlock-audit/2023-08-cooler-judging/issues/176 \n\n## Found by \nIgnite, deth\n`Clearinghouse` doesn't approve the `MINTR` to handle tokens in his name, which bricks the entire function.\n\n## Vulnerability Detail\nInside `claimDefaulted` on the [last line](https://github.com/sherlock-audit/2023-08-cooler/blob/6d34cd12a2a15d2c92307d44782d6eae1474ab25/Cooler/src/Clearinghouse.sol#L244) we call `MINTR.burnOhm` which in turn calls [OHM.burnFrom](https://github.com/OlympusDAO/olympus-v3/blob/19236eb1c02464df8fb79c7b59b7195d7511b338/src/modules/MINTR/OlympusMinter.sol#L50-L61). The [docs for MINTR.burnFrom](https://docs.olympusdao.finance/main/technical/contract-docs/modules/MINTR/OlympusMinter/#burnohm) state: \"Burn OHM from an address. Must have approval.\". We can confirm that this is the case when looking at `OHM` source code and it's `burnFrom`. I found 2 `OHM` tokens that are currently deployed on mainnet, so I'm linking both their addresses: https://etherscan.io/token/0x383518188c0c6d7730d91b2c03a03c837814a899#code, https://etherscan.io/token/0x64aa3364f17a4d01c6f1751fd97c2bd3d7e7f1d5#code. Both addresses use the same `burnFrom` logic and in both cases they require an `allowance`. Nowhere in the contract do we approve the `MINTR` to handle `OHM` tokens in the name of `Clearinghouse`, in fact `OHM` isn't even specified in `Clearinghouse`.  \n\nSide note:\nThe test `testFuzz_claimDefaulted` succeeds, because `MockOhm` is written incorrectly. When `burnFrom` gets called `MockOhm` calls the inherited `_burn` function, which burns tokens from `msg.sender`. The mock doesn't represent how the real `OHM.burnFrom` works.\n## Impact\n`Claimdefault` will always revert.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-08-cooler/blob/6d34cd12a2a15d2c92307d44782d6eae1474ab25/Cooler/src/Clearinghouse.sol#L244\n## Tool used\nManual Review\n\n## Recommendation\nAdd a variable `ohm` which will be the `OHM` address and approve the necessary tokens to the `MINTR` before calling `MINTR.burnOhm`.\n\n\n\n## Discussion\n\n**jkoppel**\n\nSeems real\n\n**0xRusowsky**\n\nConfirmed, but disagree with the severity.\nDefaults could still happen via the Cooler contracts and OHM could be burned ad-hoc by the DAO.\n\n**0xRusowsky**\n\nAfter discussing it internally, we don't mind if it's labeled as high or medium cause we would need to deploy a new policy (so it would require some extra work on our end)\n\n**0xRusowsky**\n\n- https://github.com/ohmzeus/Cooler/pull/52\n\n**jkoppel**\n\nFix approved.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/107",
  "Code": [
    {
      "filename": "Cooler/src/Clearinghouse.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {ROLESv1, RolesConsumer} from \"olympus-v3/modules/ROLES/OlympusRoles.sol\";\nimport {TRSRYv1} from \"olympus-v3/modules/TRSRY/TRSRY.v1.sol\";\nimport {MINTRv1} from \"olympus-v3/modules/MINTR/MINTR.v1.sol\";\nimport \"olympus-v3/Kernel.sol\";\n\nimport {IStaking} from \"interfaces/IStaking.sol\";\n\nimport {CoolerFactory, Cooler} from \"src/CoolerFactory.sol\";\nimport {CoolerCallback} from \"src/CoolerCallback.sol\";\n\n/// @title  Olympus Clearinghouse.\n/// @notice Olympus Clearinghouse (Policy) Contract.\n/// @dev    The Olympus Clearinghouse is a lending facility built on top of Cooler Loans. The Clearinghouse\n///         ensures that OHM holders can take loans against their gOHM holdings according to the parameters\n///         approved by the community in OIP-144 and its subsequent RFCs. The Clearinghouse parameters are\n///         immutable, because of that, if backing was to increase substantially, a new governance process\n///         to fork this implementation with upgraded parameters should take place.\n///         Although the Cooler contracts allow lenders to transfer ownership of their repayment rights, the\n///         Clearinghouse doesn't implement any functions to use that feature.\ncontract Clearinghouse is Policy, RolesConsumer, CoolerCallback {\n\n    // --- ERRORS ----------------------------------------------------\n\n    error BadEscrow();\n    error DurationMaximum();\n    error OnlyBurnable();\n    error TooEarlyToFund();\n    error LengthDiscrepancy();\n\n    // --- EVENTS ----------------------------------------------------\n\n    event Deactivated();\n    event Reactivated();\n    \n    // --- RELEVANT CONTRACTS ----------------------------------------\n\n    ERC20 public immutable dai;             // Debt token\n    ERC4626 public immutable sdai;          // Idle DAI will wrapped into sDAI\n    ERC20 public immutable gOHM;            // Collateral token\n    IStaking public immutable staking;      // Necessary to unstake (and burn) OHM from defaults\n    \n    // --- MODULES ---------------------------------------------------\n\n    TRSRYv1 public TRSRY;      // Olympus V3 Treasury Module\n    MINTRv1 public MINTR;      // Olympus V3 Minter Module\n\n    // --- PARAMETER BOUNDS ------------------------------------------\n\n    uint256 public constant INTEREST_RATE = 5e15;               // 0.5% anually\n    uint256 public constant LOAN_TO_COLLATERAL = 3000e18;       // 3,000 DAI/gOHM\n    uint256 public constant DURATION = 121 days;                // Four months\n    uint256 public constant FUND_CADENCE = 7 days;              // One week\n    uint256 public constant FUND_AMOUNT = 18_000_000e18;        // 18 million\n    uint256 public constant MAX_REWARD = 1e17;                  // 0.1 gOHM\n\n    // --- STATE VARIABLES -------------------------------------------\n\n    /// @notice determines whether the contract can be funded or not.\n    bool public active;\n\n    /// @notice timestamp at which the next rebalance can occur.\n    uint256 public fundTime;\n\n    /// @notice outstanding loan receivables.\n    /// Incremented when a loan is taken or rolled.\n    /// Decremented when a loan is repaid or collateral is burned.\n    uint256 public receivables;\n\n    // --- INITIALIZATION --------------------------------------------\n\n    constructor(\n        address gohm_,\n        address staking_,\n        address sdai_,\n        address coolerFactory_,\n        address kernel_\n    ) Policy(Kernel(kernel_)) CoolerCallback(coolerFactory_) {\n        // Store the relevant contracts.\n        gOHM = ERC20(gohm_);\n        staking = IStaking(staking_);\n        sdai = ERC4626(sdai_);\n        dai = ERC20(sdai.asset());\n        \n        // Initialize the contract status and its funding schedule.\n        active = true;\n        fundTime = block.timestamp;\n    }\n\n    /// @notice Default framework setup. Configure dependencies for olympus-v3 modules.\n    /// @dev    This function will be called when the `executor` installs the Clearinghouse\n    ///         policy in the olympus-v3 `Kernel`.\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](3);\n        dependencies[0] = toKeycode(\"TRSRY\");\n        dependencies[1] = toKeycode(\"MINTR\");\n        dependencies[2] = toKeycode(\"ROLES\");\n\n        TRSRY = TRSRYv1(getModuleAddress(toKeycode(\"TRSRY\")));\n        MINTR = MINTRv1(getModuleAddress(toKeycode(\"MINTR\")));\n        ROLES = ROLESv1(getModuleAddress(toKeycode(\"ROLES\")));\n    }\n\n    /// @notice Default framework setup. Request permissions for interacting with olympus-v3 modules.\n    /// @dev    This function will be called when the `executor` installs the Clearinghouse\n    ///         policy in the olympus-v3 `Kernel`.\n    function requestPermissions() external view override returns (Permissions[] memory requests) {\n        Keycode TRSRY_KEYCODE = toKeycode(\"TRSRY\");\n\n        requests = new Permissions[](4);\n        requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setDebt.selector);\n        requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.increaseWithdrawApproval.selector);\n        requests[2] = Permissions(TRSRY_KEYCODE, TRSRY.withdrawReserves.selector);\n        requests[3] = Permissions(toKeycode(\"MINTR\"), MINTR.burnOhm.selector);\n    }\n\n    // --- OPERATION -------------------------------------------------\n\n    /// @notice Lend to a cooler.\n    /// @dev    To simplify the UX and easily ensure that all holders get the same terms,\n    ///         this function requests a new loan and clears it in the same transaction.\n    /// @param  cooler_ to lend to.\n    /// @param  amount_ of DAI to lend.\n    /// @return the id of the granted loan.\n    function lendToCooler(Cooler cooler_, uint256 amount_) external returns (uint256) {\n        // Attempt a clearinghouse <> treasury rebalance.\n        rebalance();\n        // Validate that cooler was deployed by the trusted factory.\n        if (!factory.created(address(cooler_))) revert OnlyFromFactory();\n        // Validate cooler collateral and debt tokens.\n        if (cooler_.collateral() != gOHM || cooler_.debt() != dai) revert BadEscrow();\n\n        // Compute and access collateral. Increment loan receivables.\n        uint256 collateral = cooler_.collateralFor(amount_, LOAN_TO_COLLATERAL);\n        receivables += debtForCollateral(collateral);\n        gOHM.transferFrom(msg.sender, address(this), collateral);\n\n        // Create a new loan request.\n        gOHM.approve(address(cooler_), collateral);\n        uint256 reqID = cooler_.requestLoan(amount_, INTEREST_RATE, LOAN_TO_COLLATERAL, DURATION);\n\n        // Clear the created loan request by providing enough DAI.\n        sdai.withdraw(amount_, address(this), address(this));\n        dai.approve(address(cooler_), amount_);\n        uint256 loanID = cooler_.clearRequest(reqID, true, true);\n        \n        return loanID;\n    }\n\n    /// @notice Rollover an existing loan.\n    /// @dev    To simplify the UX and easily ensure that all holders get the same terms,\n    ///         this function provides the governance-approved terms for a rollover and\n    ///         does the loan rollover in the same transaction.\n    /// @param  cooler_ to provide terms.\n    /// @param  loanID_ of loan in cooler.\n    function rollLoan(Cooler cooler_, uint256 loanID_) external {\n        // Validate that cooler was deployed by the trusted factory.\n        if (!factory.created(address(cooler_))) revert OnlyFromFactory();\n\n        // Provide rollover terms.\n        cooler_.provideNewTermsForRoll(loanID_, INTEREST_RATE, LOAN_TO_COLLATERAL, DURATION);\n\n        // Increment loan receivables by applying the interest to the previous debt.\n        uint256 newDebt = cooler_.interestFor(\n            cooler_.getLoan(loanID_).amount,\n            INTEREST_RATE,              \n            DURATION\n        );\n        receivables += newDebt;    \n\n        // If necessary, pledge more collateral from user.\n        uint256 newCollateral = cooler_.newCollateralFor(loanID_);\n        if (newCollateral > 0) {\n            gOHM.transferFrom(msg.sender, address(this), newCollateral);\n            gOHM.approve(address(cooler_), newCollateral);\n        }\n\n        // Roll loan.\n        cooler_.rollLoan(loanID_);\n    }\n\n    /// @notice Batch several default claims to save gas.\n    ///         The elements on both arrays must be paired based on their index.\n    /// @dev    Implements an auction style reward system that linearly increases up to a max reward.\n    /// @param  coolers_ Array of contracts where the default must be claimed.\n    /// @param  loans_ Array of defaulted loan ids.\n    function claimDefaulted(address[] calldata coolers_, uint256[] calldata loans_) external {\n        uint256 loans = loans_.length;\n        if (loans != coolers_.length) revert LengthDiscrepancy();\n\n        uint256 totalDebt;\n        uint256 totalInterest;\n        uint256 totalCollateral;\n        uint256 keeperRewards;\n        for (uint256 i=0; i < loans;) {\n            // Validate that cooler was deployed by the trusted factory.\n            if (!factory.created(coolers_[i])) revert OnlyFromFactory();\n            \n            // Claim defaults and update cached metrics.\n            (uint256 debt, uint256 collateral, uint256 elapsed) = Cooler(coolers_[i]).claimDefaulted(loans_[i]);\n            uint256 interest = interestFromDebt(debt);\n            unchecked {\n                // Cannot overflow due to max supply limits for both tokens\n                totalDebt += debt;\n                totalInterest += interest;\n                totalCollateral += collateral;\n                // There will not exist more than 2**256 loans\n                ++i;\n            }\n\n            // Cap rewards to 5% of the collateral to avoid OHM holder's dillution.\n            uint256 maxAuctionReward = collateral * 5e16 / 1e18;\n            // Cap rewards to avoid exorbitant amounts.\n            uint256 maxReward = (maxAuctionReward < MAX_REWARD)\n                ? maxAuctionReward\n                : MAX_REWARD;\n            // Calculate rewards based on the elapsed time since default.\n            keeperRewards = (elapsed < 7 days)\n                ? keeperRewards + maxReward * elapsed / 7 days\n                : keeperRewards + maxReward;\n        }\n\n        // Decrement loan receivables.\n        receivables = (receivables > totalDebt) ? receivables - totalDebt : 0;\n        // Update outstanding debt owed to the Treasury upon default.\n        uint256 outstandingDebt = TRSRY.reserveDebt(dai, address(this));\n        // debt owed to TRSRY = user debt - user interest\n        TRSRY.setDebt({\n            debtor_: address(this),\n            token_: dai,\n            amount_: (outstandingDebt > (totalDebt - totalInterest))\n                ? outstandingDebt - (totalDebt - totalInterest)\n                : 0\n        });\n\n        // Reward keeper.\n        gOHM.transfer(msg.sender, keeperRewards);\n        // Unstake and burn the collateral of the defaulted loans.\n        gOHM.approve(address(staking), totalCollateral - keeperRewards);\n        MINTR.burnOhm(address(this), staking.unstake(address(this), totalCollateral - keeperRewards, false, false));\n    }\n\n    // --- CALLBACKS -----------------------------------------------------\n\n    /// @notice Overridden callback to decrement loan receivables.\n    /// @param *unused loadID_ of the load.\n    /// @param amount_ repaid (in DAI).\n    function _onRepay(uint256, uint256 amount_) internal override {\n        _sweepIntoDSR(amount_);\n\n        // Decrement loan receivables.\n        receivables = (receivables > amount_) ? receivables - amount_ : 0;\n    }\n    \n    /// @notice Unused callback since rollovers are handled by the clearinghouse.\n    /// @dev Overriden and left empty to save gas.\n    function _onRoll(uint256, uint256, uint256) internal override {}\n\n    /// @notice Unused callback since defaults are handled by the clearinghouse.\n    /// @dev Overriden and left empty to save gas.\n    function _onDefault(uint256, uint256, uint256) internal override {}\n\n    // --- FUNDING ---------------------------------------------------\n\n    /// @notice Fund loan liquidity from treasury.\n    /// @dev    Exposure is always capped at FUND_AMOUNT and rebalanced at up to FUND_CADANCE.\n    ///         If several rebalances are available (because some were missed), calling this\n    ///         function several times won't impact the funds controlled by the contract.\n    ///         If the emergency shutdown is triggered, a rebalance will send funds back to\n    ///         the treasury.\n    /// @return False if too early to rebalance. Otherwise, true.\n    function rebalance() public returns (bool) {\n        // If the contract is deactivated, defund.\n        uint256 maxFundAmount = active ? FUND_AMOUNT : 0;        \n        // Update funding schedule if necessary.\n        if (fundTime > block.timestamp) return false;\n        fundTime += FUND_CADENCE;\n\n        uint256 daiBalance = sdai.maxWithdraw(address(this));\n        uint256 outstandingDebt = TRSRY.reserveDebt(dai, address(this));\n        // Rebalance funds on hand with treasury's reserves.\n        if (daiBalance < maxFundAmount) {\n            // Since users loans are denominated in DAI, the clearinghouse\n            // debt is set in DAI terms. It must be adjusted when funding.\n            uint256 fundAmount = maxFundAmount - daiBalance;\n            TRSRY.setDebt({\n                debtor_: address(this),\n                token_: dai,\n                amount_: outstandingDebt + fundAmount\n            });\n\n            // Since TRSRY holds sDAI, a conversion must be done before\n            // funding the clearinghouse.\n            uint256 sdaiAmount = sdai.previewWithdraw(fundAmount);\n            TRSRY.increaseWithdrawApproval(address(this), sdai, sdaiAmount);\n            TRSRY.withdrawReserves(address(this), sdai, sdaiAmount);\n\n            // Sweep DAI into DSR if necessary.\n            uint256 idle = dai.balanceOf(address(this));\n            if (idle != 0) _sweepIntoDSR(idle);\n        } else if (daiBalance > maxFundAmount) {\n            // Since users loans are denominated in DAI, the clearinghouse\n            // debt is set in DAI terms. It must be adjusted when defunding.\n            uint256 defundAmount = daiBalance - maxFundAmount;\n            TRSRY.setDebt({\n                debtor_: address(this),\n                token_: dai,\n                amount_: (outstandingDebt > defundAmount) ? outstandingDebt - defundAmount : 0\n            });\n\n            // Since TRSRY holds sDAI, a conversion must be done before\n            // sending sDAI back.\n            uint256 sdaiAmount = sdai.previewWithdraw(defundAmount);\n            sdai.approve(address(TRSRY), sdaiAmount);\n            sdai.transfer(address(TRSRY), sdaiAmount);\n        }\n        return true;\n    }\n\n    /// @notice Sweep excess DAI into vault.\n    function sweepIntoDSR() public {\n        uint256 daiBalance = dai.balanceOf(address(this));\n        _sweepIntoDSR(daiBalance);\n    }\n\n    /// @notice Sweep excess DAI into vault.\n    function _sweepIntoDSR(uint256 amount_) internal {\n        dai.approve(address(sdai), amount_);\n        sdai.deposit(amount_, address(this));\n    }\n\n    /// @notice Return funds to treasury.\n    /// @param  token_ to transfer.\n    /// @param  amount_ to transfer.\n    function defund(ERC20 token_, uint256 amount_) public onlyRole(\"cooler_overseer\") {\n        if (token_ == gOHM) revert OnlyBurnable();\n        if (token_ == sdai || token_ == dai) {\n            // Since users loans are denominated in DAI, the clearinghouse\n            // debt is set in DAI terms. It must be adjusted when defunding.\n            uint256 outstandingDebt = TRSRY.reserveDebt(dai, address(this));\n            uint256 daiAmount = (token_ == sdai)\n                ? sdai.previewRedeem(amount_)\n                : amount_;\n    \n            TRSRY.setDebt({\n                debtor_: address(this),\n                token_: dai,\n                amount_: (outstandingDebt > daiAmount) ? outstandingDebt - daiAmount : 0\n            });\n        }\n\n        token_.transfer(address(TRSRY), amount_);\n    }\n\n    /// @notice Deactivate the contract and return funds to treasury.\n    function emergencyShutdown() external onlyRole(\"emergency_shutdown\") {\n        active = false;\n\n        // If necessary, defund sDAI.\n        uint256 sdaiBalance = sdai.balanceOf(address(this));\n        if (sdaiBalance != 0) defund(sdai, sdaiBalance);\n\n        // If necessary, defund DAI.\n        uint256 daiBalance = dai.balanceOf(address(this));\n        if (daiBalance != 0) defund(dai, daiBalance);\n\n        emit Deactivated();\n    }\n\n    /// @notice Reactivate the contract.\n    function reactivate() external onlyRole(\"cooler_overseer\") {\n        active = true;\n\n        emit Reactivated();\n    }\n\n    // --- AUX FUNCTIONS ---------------------------------------------\n    \n    /// @notice view function computing loan for a collateral amount.\n    /// @param  collateral_ amount of gOHM.\n    /// @return debt (amount to be lent + interest) for a given collateral amount.\n    function debtForCollateral(uint256 collateral_) public pure returns (uint256) {\n        uint256 interestPercent = (INTEREST_RATE * DURATION) / 365 days;\n        uint256 loan = collateral_ * LOAN_TO_COLLATERAL / 1e18;\n        uint256 interest = loan * interestPercent / 1e18;\n        return loan + interest;\n    }\n    \n    /// @notice view function to compute the interest for a given debt amount.\n    /// @param debt_ amount of gOHM.\n    function interestFromDebt(uint256 debt_) public pure returns (uint256) {\n        uint256 interestPercent = (INTEREST_RATE * DURATION) / 365 days;\n        return debt_ * interestPercent / 1e18;\n    }\n}"
    },
    {
      "filename": "Cooler/src/Clearinghouse.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {ROLESv1, RolesConsumer} from \"olympus-v3/modules/ROLES/OlympusRoles.sol\";\nimport {TRSRYv1} from \"olympus-v3/modules/TRSRY/TRSRY.v1.sol\";\nimport {MINTRv1} from \"olympus-v3/modules/MINTR/MINTR.v1.sol\";\nimport \"olympus-v3/Kernel.sol\";\n\nimport {IStaking} from \"interfaces/IStaking.sol\";\n\nimport {CoolerFactory, Cooler} from \"src/CoolerFactory.sol\";\nimport {CoolerCallback} from \"src/CoolerCallback.sol\";\n\n/// @title  Olympus Clearinghouse.\n/// @notice Olympus Clearinghouse (Policy) Contract.\n/// @dev    The Olympus Clearinghouse is a lending facility built on top of Cooler Loans. The Clearinghouse\n///         ensures that OHM holders can take loans against their gOHM holdings according to the parameters\n///         approved by the community in OIP-144 and its subsequent RFCs. The Clearinghouse parameters are\n///         immutable, because of that, if backing was to increase substantially, a new governance process\n///         to fork this implementation with upgraded parameters should take place.\n///         Although the Cooler contracts allow lenders to transfer ownership of their repayment rights, the\n///         Clearinghouse doesn't implement any functions to use that feature.\ncontract Clearinghouse is Policy, RolesConsumer, CoolerCallback {\n\n    // --- ERRORS ----------------------------------------------------\n\n    error BadEscrow();\n    error DurationMaximum();\n    error OnlyBurnable();\n    error TooEarlyToFund();\n    error LengthDiscrepancy();\n\n    // --- EVENTS ----------------------------------------------------\n\n    event Deactivated();\n    event Reactivated();\n    \n    // --- RELEVANT CONTRACTS ----------------------------------------\n\n    ERC20 public immutable dai;             // Debt token\n    ERC4626 public immutable sdai;          // Idle DAI will wrapped into sDAI\n    ERC20 public immutable gOHM;            // Collateral token\n    IStaking public immutable staking;      // Necessary to unstake (and burn) OHM from defaults\n    \n    // --- MODULES ---------------------------------------------------\n\n    TRSRYv1 public TRSRY;      // Olympus V3 Treasury Module\n    MINTRv1 public MINTR;      // Olympus V3 Minter Module\n\n    // --- PARAMETER BOUNDS ------------------------------------------\n\n    uint256 public constant INTEREST_RATE = 5e15;               // 0.5% anually\n    uint256 public constant LOAN_TO_COLLATERAL = 3000e18;       // 3,000 DAI/gOHM\n    uint256 public constant DURATION = 121 days;                // Four months\n    uint256 public constant FUND_CADENCE = 7 days;              // One week\n    uint256 public constant FUND_AMOUNT = 18_000_000e18;        // 18 million\n    uint256 public constant MAX_REWARD = 1e17;                  // 0.1 gOHM\n\n    // --- STATE VARIABLES -------------------------------------------\n\n    /// @notice determines whether the contract can be funded or not.\n    bool public active;\n\n    /// @notice timestamp at which the next rebalance can occur.\n    uint256 public fundTime;\n\n    /// @notice outstanding loan receivables.\n    /// Incremented when a loan is taken or rolled.\n    /// Decremented when a loan is repaid or collateral is burned.\n    uint256 public receivables;\n\n    // --- INITIALIZATION --------------------------------------------\n\n    constructor(\n        address gohm_,\n        address staking_,\n        address sdai_,\n        address coolerFactory_,\n        address kernel_\n    ) Policy(Kernel(kernel_)) CoolerCallback(coolerFactory_) {\n        // Store the relevant contracts.\n        gOHM = ERC20(gohm_);\n        staking = IStaking(staking_);\n        sdai = ERC4626(sdai_);\n        dai = ERC20(sdai.asset());\n        \n        // Initialize the contract status and its funding schedule.\n        active = true;\n        fundTime = block.timestamp;\n    }\n\n    /// @notice Default framework setup. Configure dependencies for olympus-v3 modules.\n    /// @dev    This function will be called when the `executor` installs the Clearinghouse\n    ///         policy in the olympus-v3 `Kernel`.\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](3);\n        dependencies[0] = toKeycode(\"TRSRY\");\n        dependencies[1] = toKeycode(\"MINTR\");\n        dependencies[2] = toKeycode(\"ROLES\");\n\n        TRSRY = TRSRYv1(getModuleAddress(toKeycode(\"TRSRY\")));\n        MINTR = MINTRv1(getModuleAddress(toKeycode(\"MINTR\")));\n        ROLES = ROLESv1(getModuleAddress(toKeycode(\"ROLES\")));\n    }\n\n    /// @notice Default framework setup. Request permissions for interacting with olympus-v3 modules.\n    /// @dev    This function will be called when the `executor` installs the Clearinghouse\n    ///         policy in the olympus-v3 `Kernel`.\n    function requestPermissions() external view override returns (Permissions[] memory requests) {\n        Keycode TRSRY_KEYCODE = toKeycode(\"TRSRY\");\n\n        requests = new Permissions[](4);\n        requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setDebt.selector);\n        requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.increaseWithdrawApproval.selector);\n        requests[2] = Permissions(TRSRY_KEYCODE, TRSRY.withdrawReserves.selector);\n        requests[3] = Permissions(toKeycode(\"MINTR\"), MINTR.burnOhm.selector);\n    }\n\n    // --- OPERATION -------------------------------------------------\n\n    /// @notice Lend to a cooler.\n    /// @dev    To simplify the UX and easily ensure that all holders get the same terms,\n    ///         this function requests a new loan and clears it in the same transaction.\n    /// @param  cooler_ to lend to.\n    /// @param  amount_ of DAI to lend.\n    /// @return the id of the granted loan.\n    function lendToCooler(Cooler cooler_, uint256 amount_) external returns (uint256) {\n        // Attempt a clearinghouse <> treasury rebalance.\n        rebalance();\n        // Validate that cooler was deployed by the trusted factory.\n        if (!factory.created(address(cooler_))) revert OnlyFromFactory();\n        // Validate cooler collateral and debt tokens.\n        if (cooler_.collateral() != gOHM || cooler_.debt() != dai) revert BadEscrow();\n\n        // Compute and access collateral. Increment loan receivables.\n        uint256 collateral = cooler_.collateralFor(amount_, LOAN_TO_COLLATERAL);\n        receivables += debtForCollateral(collateral);\n        gOHM.transferFrom(msg.sender, address(this), collateral);\n\n        // Create a new loan request.\n        gOHM.approve(address(cooler_), collateral);\n        uint256 reqID = cooler_.requestLoan(amount_, INTEREST_RATE, LOAN_TO_COLLATERAL, DURATION);\n\n        // Clear the created loan request by providing enough DAI.\n        sdai.withdraw(amount_, address(this), address(this));\n        dai.approve(address(cooler_), amount_);\n        uint256 loanID = cooler_.clearRequest(reqID, true, true);\n        \n        return loanID;\n    }\n\n    /// @notice Rollover an existing loan.\n    /// @dev    To simplify the UX and easily ensure that all holders get the same terms,\n    ///         this function provides the governance-approved terms for a rollover and\n    ///         does the loan rollover in the same transaction.\n    /// @param  cooler_ to provide terms.\n    /// @param  loanID_ of loan in cooler.\n    function rollLoan(Cooler cooler_, uint256 loanID_) external {\n        // Validate that cooler was deployed by the trusted factory.\n        if (!factory.created(address(cooler_))) revert OnlyFromFactory();\n\n        // Provide rollover terms.\n        cooler_.provideNewTermsForRoll(loanID_, INTEREST_RATE, LOAN_TO_COLLATERAL, DURATION);\n\n        // Increment loan receivables by applying the interest to the previous debt.\n        uint256 newDebt = cooler_.interestFor(\n            cooler_.getLoan(loanID_).amount,\n            INTEREST_RATE,              \n            DURATION\n        );\n        receivables += newDebt;    \n\n        // If necessary, pledge more collateral from user.\n        uint256 newCollateral = cooler_.newCollateralFor(loanID_);\n        if (newCollateral > 0) {\n            gOHM.transferFrom(msg.sender, address(this), newCollateral);\n            gOHM.approve(address(cooler_), newCollateral);\n        }\n\n        // Roll loan.\n        cooler_.rollLoan(loanID_);\n    }\n\n    /// @notice Batch several default claims to save gas.\n    ///         The elements on both arrays must be paired based on their index.\n    /// @dev    Implements an auction style reward system that linearly increases up to a max reward.\n    /// @param  coolers_ Array of contracts where the default must be claimed.\n    /// @param  loans_ Array of defaulted loan ids.\n    function claimDefaulted(address[] calldata coolers_, uint256[] calldata loans_) external {\n        uint256 loans = loans_.length;\n        if (loans != coolers_.length) revert LengthDiscrepancy();\n\n        uint256 totalDebt;\n        uint256 totalInterest;\n        uint256 totalCollateral;\n        uint256 keeperRewards;\n        for (uint256 i=0; i < loans;) {\n            // Validate that cooler was deployed by the trusted factory.\n            if (!factory.created(coolers_[i])) revert OnlyFromFactory();\n            \n            // Claim defaults and update cached metrics.\n            (uint256 debt, uint256 collateral, uint256 elapsed) = Cooler(coolers_[i]).claimDefaulted(loans_[i]);\n            uint256 interest = interestFromDebt(debt);\n            unchecked {\n                // Cannot overflow due to max supply limits for both tokens\n                totalDebt += debt;\n                totalInterest += interest;\n                totalCollateral += collateral;\n                // There will not exist more than 2**256 loans\n                ++i;\n            }\n\n            // Cap rewards to 5% of the collateral to avoid OHM holder's dillution.\n            uint256 maxAuctionReward = collateral * 5e16 / 1e18;\n            // Cap rewards to avoid exorbitant amounts.\n            uint256 maxReward = (maxAuctionReward < MAX_REWARD)\n                ? maxAuctionReward\n                : MAX_REWARD;\n            // Calculate rewards based on the elapsed time since default.\n            keeperRewards = (elapsed < 7 days)\n                ? keeperRewards + maxReward * elapsed / 7 days\n                : keeperRewards + maxReward;\n        }\n\n        // Decrement loan receivables.\n        receivables = (receivables > totalDebt) ? receivables - totalDebt : 0;\n        // Update outstanding debt owed to the Treasury upon default.\n        uint256 outstandingDebt = TRSRY.reserveDebt(dai, address(this));\n        // debt owed to TRSRY = user debt - user interest\n        TRSRY.setDebt({\n            debtor_: address(this),\n            token_: dai,\n            amount_: (outstandingDebt > (totalDebt - totalInterest))\n                ? outstandingDebt - (totalDebt - totalInterest)\n                : 0\n        });\n\n        // Reward keeper.\n        gOHM.transfer(msg.sender, keeperRewards);\n        // Unstake and burn the collateral of the defaulted loans.\n        gOHM.approve(address(staking), totalCollateral - keeperRewards);\n        MINTR.burnOhm(address(this), staking.unstake(address(this), totalCollateral - keeperRewards, false, false));\n    }\n\n    // --- CALLBACKS -----------------------------------------------------\n\n    /// @notice Overridden callback to decrement loan receivables.\n    /// @param *unused loadID_ of the load.\n    /// @param amount_ repaid (in DAI).\n    function _onRepay(uint256, uint256 amount_) internal override {\n        _sweepIntoDSR(amount_);\n\n        // Decrement loan receivables.\n        receivables = (receivables > amount_) ? receivables - amount_ : 0;\n    }\n    \n    /// @notice Unused callback since rollovers are handled by the clearinghouse.\n    /// @dev Overriden and left empty to save gas.\n    function _onRoll(uint256, uint256, uint256) internal override {}\n\n    /// @notice Unused callback since defaults are handled by the clearinghouse.\n    /// @dev Overriden and left empty to save gas.\n    function _onDefault(uint256, uint256, uint256) internal override {}\n\n    // --- FUNDING ---------------------------------------------------\n\n    /// @notice Fund loan liquidity from treasury.\n    /// @dev    Exposure is always capped at FUND_AMOUNT and rebalanced at up to FUND_CADANCE.\n    ///         If several rebalances are available (because some were missed), calling this\n    ///         function several times won't impact the funds controlled by the contract.\n    ///         If the emergency shutdown is triggered, a rebalance will send funds back to\n    ///         the treasury.\n    /// @return False if too early to rebalance. Otherwise, true.\n    function rebalance() public returns (bool) {\n        // If the contract is deactivated, defund.\n        uint256 maxFundAmount = active ? FUND_AMOUNT : 0;        \n        // Update funding schedule if necessary.\n        if (fundTime > block.timestamp) return false;\n        fundTime += FUND_CADENCE;\n\n        uint256 daiBalance = sdai.maxWithdraw(address(this));\n        uint256 outstandingDebt = TRSRY.reserveDebt(dai, address(this));\n        // Rebalance funds on hand with treasury's reserves.\n        if (daiBalance < maxFundAmount) {\n            // Since users loans are denominated in DAI, the clearinghouse\n            // debt is set in DAI terms. It must be adjusted when funding.\n            uint256 fundAmount = maxFundAmount - daiBalance;\n            TRSRY.setDebt({\n                debtor_: address(this),\n                token_: dai,\n                amount_: outstandingDebt + fundAmount\n            });\n\n            // Since TRSRY holds sDAI, a conversion must be done before\n            // funding the clearinghouse.\n            uint256 sdaiAmount = sdai.previewWithdraw(fundAmount);\n            TRSRY.increaseWithdrawApproval(address(this), sdai, sdaiAmount);\n            TRSRY.withdrawReserves(address(this), sdai, sdaiAmount);\n\n            // Sweep DAI into DSR if necessary.\n            uint256 idle = dai.balanceOf(address(this));\n            if (idle != 0) _sweepIntoDSR(idle);\n        } else if (daiBalance > maxFundAmount) {\n            // Since users loans are denominated in DAI, the clearinghouse\n            // debt is set in DAI terms. It must be adjusted when defunding.\n            uint256 defundAmount = daiBalance - maxFundAmount;\n            TRSRY.setDebt({\n                debtor_: address(this),\n                token_: dai,\n                amount_: (outstandingDebt > defundAmount) ? outstandingDebt - defundAmount : 0\n            });\n\n            // Since TRSRY holds sDAI, a conversion must be done before\n            // sending sDAI back.\n            uint256 sdaiAmount = sdai.previewWithdraw(defundAmount);\n            sdai.approve(address(TRSRY), sdaiAmo"
    }
  ]
}