{
  "Title": "[M-11] Usage of deprecated transfer to send ETH",
  "Content": "_Submitted by peritoflores, also found by JC and StyxRave_\n\n<https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/swappers/SwapperRouter.sol#L140>\n\n<https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/swappers/SwapperRouter.sol#L280>\n\n### Impact\n\nUsage of deprecated transfer Swap can revert.\n\n### Proof of Concept\n\nThe original `transfer` used to send eth uses a fixed stipend 2300 gas.   This was used to prevent reentrancy.   However this limit your protocol to interact with others contracts that need more than that to process the transaction.\n\nA good article about that:\n<https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/>.\n\n### Recommended Mitigation Steps\n\nUsed call instead.  For example\n\n        (bool success, ) = msg.sender.call{amount}(\"\");\n        require(success, \"Transfer failed.\");\n\n**[chase-manning (Backd) confirmed](https://github.com/code-423n4/2022-05-backd-findings/issues/180)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-backd-findings/issues/180#issuecomment-1159810449):**\n > While submission is lazy in that it doesn't show the ways in which it could revert, (for example most of the times even a transfer to a gnosis-safe will not revert as the gas stipend is sufficient)\n> \n> It's true that `transfer`s gas stipend may run out, causing reverts\n> \n> For this reason I agree with Med Severity.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-backd-tokenomics-contest",
  "Code": [
    {
      "filename": "protocol/contracts/swappers/SwapperRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../access/Authorization.sol\";\n\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/DecimalScale.sol\";\nimport \"../../libraries/ScaledMath.sol\";\n\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../../interfaces/ISwapperRouter.sol\";\nimport \"../../interfaces/vendor/UniswapRouter02.sol\";\nimport \"../../interfaces/vendor/IWETH.sol\";\nimport \"../../interfaces/IERC20Full.sol\";\nimport \"../../interfaces/vendor/ICurveSwapEth.sol\";\n\n/**\n * The swapper router handles the swapping from one token to another.\n * By default it does all swaps through WETH, in two steps checking which DEX is better for each stage of the swap.\n * It also supports ETH in or out and handles it by converting to WETH and back.\n */\ncontract SwapperRouter is ISwapperRouter, Authorization {\n    using SafeERC20 for IERC20;\n    using DecimalScale for uint256;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    // Dex contracts\n    address private constant _UNISWAP = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // Uniswap Router, used for swapping tokens on Uniswap\n    address private constant _SUSHISWAP = address(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); // Sushiswap Router, used for swapping tokens on Sushiswap\n    IWETH private constant _WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH, used for wrapping and unwrapping ETH for swaps\n\n    IAddressProvider private immutable _addressProvider; // Address provider used for getting oracle provider\n\n    uint256 public slippageTolerance; // The amount of slippage to allow from the oracle price of an asset\n    mapping(address => ICurveSwapEth) public curvePools; // Curve Pool to use for swapping with WETH\n\n    event Swapped(address fromToken, address toToken, uint256 amountIn, uint256 amountOut); // Emmited after a successfull swap\n    event SetSlippageTolerance(uint256 value); // Emitted after a successful setting of slippage tolerance\n    event SetCurvePool(address token, address curvePool); // Emitted after a successful setting of a Curve Pool\n\n    constructor(address addressProvider_)\n        Authorization(IAddressProvider(addressProvider_).getRoleManager())\n    {\n        _addressProvider = IAddressProvider(addressProvider_);\n        slippageTolerance = 0.97e18;\n    }\n\n    receive() external payable {} // Used for receiving ETH when unwrapping WETH\n\n    /**\n     * @notice Swaps all of the users balance of fromToken for toToken.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @return amountOut The amount of toToken received.\n     */\n    function swapAll(address fromToken_, address toToken_)\n        external\n        payable\n        override\n        returns (uint256 amountOut)\n    {\n        // Swapping if from token is ETH\n        if (fromToken_ == address(0)) {\n            return swap(fromToken_, toToken_, address(this).balance);\n        }\n\n        // Swapping if from token is ERC20\n        return swap(fromToken_, toToken_, IERC20(fromToken_).balanceOf(address(msg.sender)));\n    }\n\n    /**\n     * @notice Set slippage tolerance for swaps.\n     * @dev Stored as a multiplier, e.g. 2% would be set as 0.98.\n     * @param slippageTolerance_ New slippage tolerance.\n     */\n    function setSlippageTolerance(uint256 slippageTolerance_) external override onlyGovernance {\n        require(slippageTolerance_ <= ScaledMath.ONE, Error.INVALID_SLIPPAGE_TOLERANCE);\n        slippageTolerance = slippageTolerance_;\n        emit SetSlippageTolerance(slippageTolerance_);\n    }\n\n    /**\n     * @notice Sets the Curve Pool to use for swapping a token with WETH.\n     * @dev To use Uniswap or Sushiswap instead, set the Curve Pool to the zero address.\n     * @param token_ The token to set the Curve Pool for.\n     * @param curvePool_ The address of the Curve Pool.\n     */\n    function setCurvePool(address token_, address curvePool_) external override onlyGovernance {\n        require(token_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        require(curvePool_ != address(curvePools[token_]), Error.SAME_ADDRESS_NOT_ALLOWED);\n        curvePools[token_] = ICurveSwapEth(curvePool_);\n        emit SetCurvePool(token_, curvePool_);\n    }\n\n    /**\n     * @notice Gets the amount of toToken received by swapping amountIn of fromToken.\n     * @dev In the case where a custom swapper is used, return value may not be precise.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @param amountIn_ The amount of fromToken being swapped.\n     * @return amountOut The amount of toToken received by swapping amountIn of fromToken.\n     */\n    function getAmountOut(\n        address fromToken_,\n        address toToken_,\n        uint256 amountIn_\n    ) external view override returns (uint256 amountOut) {\n        if (fromToken_ == toToken_ || amountIn_ == 0) return amountIn_;\n\n        return _getTokenOut(toToken_, _getWethOut(fromToken_, amountIn_));\n    }\n\n    /**\n     * @notice Swaps an amount of fromToken to toToken.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @param amountIn_ The amount of fromToken to swap for toToken.\n     * @return amountOut The amount of toToken received.\n     */\n    function swap(\n        address fromToken_,\n        address toToken_,\n        uint256 amountIn_\n    ) public payable override returns (uint256 amountOut) {\n        // Validating ETH value sent\n        require(msg.value == (fromToken_ == address(0) ? amountIn_ : 0), Error.INVALID_AMOUNT);\n        if (amountIn_ == 0) {\n            emit Swapped(fromToken_, toToken_, 0, 0);\n            return 0;\n        }\n\n        // Handling swap between the same token\n        if (fromToken_ == toToken_) {\n            if (fromToken_ == address(0)) {\n                payable(msg.sender).transfer(amountIn_);\n            }\n            emit Swapped(fromToken_, toToken_, amountIn_, amountIn_);\n            return amountIn_;\n        }\n\n        // Transferring to contract if ERC20\n        if (fromToken_ != address(0)) {\n            IERC20(fromToken_).safeTransferFrom(msg.sender, address(this), amountIn_);\n        }\n\n        // Swapping token via WETH\n        uint256 amountOut_ = _swapWethForToken(toToken_, _swapForWeth(fromToken_));\n        emit Swapped(fromToken_, toToken_, amountIn_, amountOut_);\n        return _returnTokens(toToken_, amountOut_);\n    }\n\n    /**\n     * @dev Swaps the full contract balance of token to WETH.\n     * @param token_ The token to swap to WETH.\n     * @return amountOut The amount of WETH received from the swap.\n     */\n    function _swapForWeth(address token_) internal returns (uint256 amountOut) {\n        if (token_ == address(_WETH)) return _WETH.balanceOf(address(this));\n\n        // Handling ETH -> WETH\n        if (token_ == address(0)) {\n            uint256 ethBalance_ = address(this).balance;\n            if (ethBalance_ == 0) return 0;\n            _WETH.deposit{value: ethBalance_}();\n            return ethBalance_;\n        }\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            uint256 amount_ = IERC20(token_).balanceOf(address(this));\n            if (amount_ == 0) return 0;\n            _approve(token_, address(curvePool_));\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            curvePool_.exchange(\n                tokenIndex_,\n                wethIndex_,\n                amount_,\n                _minWethAmountOut(amount_, token_)\n            );\n            return _WETH.balanceOf(address(this));\n        }\n\n        // Handling ERC20 -> WETH\n        return _swap(token_, address(_WETH), IERC20(token_).balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Swaps the full contract balance of WETH to token.\n     * @param token_ The token to swap WETH to.\n     * @return amountOut The amount of token received from the swap.\n     */\n    function _swapWethForToken(address token_, uint256 amount_)\n        internal\n        returns (uint256 amountOut)\n    {\n        if (amount_ == 0) return 0;\n        if (token_ == address(_WETH)) return amount_;\n\n        // Handling WETH -> ETH\n        if (token_ == address(0)) {\n            _WETH.withdraw(amount_);\n            return amount_;\n        }\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            _approve(address(_WETH), address(curvePool_));\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            curvePool_.exchange(\n                wethIndex_,\n                tokenIndex_,\n                amount_,\n                _minTokenAmountOut(amount_, token_)\n            );\n            return IERC20(token_).balanceOf(address(this));\n        }\n\n        // Handling WETH -> ERC20\n        return _swap(address(_WETH), token_, amount_);\n    }\n\n    /**\n     * @dev Swaps an amount of fromToken to toToken.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @param amount_ The amount of fromToken to swap.\n     * @return amountOut The amount of toToken received from the swap.\n     */\n    function _swap(\n        address fromToken_,\n        address toToken_,\n        uint256 amount_\n    ) internal returns (uint256 amountOut) {\n        if (amount_ == 0) return 0;\n        if (fromToken_ == toToken_) return amount_;\n        address dex_ = _getBestDex(fromToken_, toToken_, amount_);\n        _approve(fromToken_, dex_);\n        address[] memory path_ = new address[](2);\n        path_[0] = fromToken_;\n        path_[1] = toToken_;\n        return\n            UniswapRouter02(dex_).swapExactTokensForTokens(\n                amount_,\n                _getAmountOutMin(amount_, fromToken_, toToken_),\n                path_,\n                address(this),\n                block.timestamp\n            )[1];\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token_ The token to approve for.\n     * @param spender_ The spender to approve.\n     */\n    function _approve(address token_, address spender_) internal {\n        if (IERC20(token_).allowance(address(this), spender_) > 0) return;\n        IERC20(token_).safeApprove(spender_, type(uint256).max);\n    }\n\n    /**\n     * @dev Returns an amount of tokens to the sender.\n     * @param token_ The token to return to sender.\n     * @param amount_ The amount of tokens to return to sender.\n     * @return amountReturned The amount of tokens returned to sender.\n     */\n    function _returnTokens(address token_, uint256 amount_)\n        internal\n        returns (uint256 amountReturned)\n    {\n        // Returning if ETH\n        if (token_ == address(0)) {\n            payable(msg.sender).transfer(amount_);\n            return amount_;\n        }\n\n        // Returning if ERC20\n        IERC20(token_).safeTransfer(msg.sender, amount_);\n        return amount_;\n    }\n\n    /**\n     * @dev Gets the amount of WETH received by swapping amount of token\n     *      In the case where a custom swapper is used, return value may not be precise.\n     * @param token_ The token to swap from.\n     * @param amount_ The mount of token being swapped.\n     * @return amountOut The amount of WETH received by swapping amount of token.\n     */\n    function _getWethOut(address token_, uint256 amount_)\n        internal\n        view\n        returns (uint256 amountOut)\n    {\n        if (token_ == address(_WETH) || token_ == address(0)) return amount_;\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            return curvePool_.get_dy(tokenIndex_, wethIndex_, amount_);\n        }\n\n        return\n            _tokenAmountOut(\n                token_,\n                address(_WETH),\n                amount_,\n                _getBestDex(token_, address(_WETH), amount_)\n            );\n    }\n\n    /**\n     * @dev Gets the amount of token received by swapping amount of WETH\n     *      In the case where a custom swapper is used, return value may not be precise.\n     * @param token_ The token to swap to.\n     * @param amount_ The amount of WETH being swapped.\n     * @return amountOut The amount of token received by swapping amount of WETH.\n     */\n    function _getTokenOut(address token_, uint256 amount_)\n        internal\n        view\n        returns (uint256 amountOut)\n    {\n        if (token_ == address(_WETH) || token_ == address(0)) return amount_;\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            return curvePool_.get_dy(wethIndex_, tokenIndex_, amount_);\n        }\n\n        return\n            _tokenAmountOut(\n                address(_WETH),\n                token_,\n                amount_,\n                _getBestDex(address(_WETH), token_, amount_)\n            );\n    }\n\n    /**\n     * @dev Gets the best dex to use for swapping tokens based on which gives the highest amount out.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @param amount_ The amount of fromToken to swap.\n     * @return bestDex The best dex to use for swapping tokens based on which gives the highest amount out\n     */\n    function _getBestDex(\n        address fromToken_,\n        address toToken_,\n        uint256 amount_\n    ) internal view returns (address bestDex) {\n        address uniswap_ = _UNISWAP;\n        address sushiswap_ = _SUSHISWAP;\n        return\n            _tokenAmountOut(fromToken_, toToken_, amount_, uniswap_) >=\n                _tokenAmountOut(fromToken_, toToken_, amount_, sushiswap_)\n                ? uniswap_\n                : sushiswap_;\n    }\n\n    /**\n     * @notice Gets the amount of toToken received by swapping amountIn of fromToken.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @param amountIn_ The amount of fromToken being swapped.\n     * @param dex_ The DEX to use for the swap.\n     * @return amountOut The amount of toToken received by swapping amountIn of fromToken.\n     */\n    function _tokenAmountOut(\n        address fromToken_,\n        address toToken_,\n        uint256 amountIn_,\n        address dex_\n    ) internal view returns (uint256 amountOut) {\n        address[] memory path_ = new address[](2);\n        path_[0] = fromToken_;\n        path_[1] = toToken_;\n        return UniswapRouter02(dex_).getAmountsOut(amountIn_, path_)[1];\n    }\n\n    /**\n     * @dev Returns the minimum amount of toToken_ to receive from swap.\n     * @param amount_ The amount of fromToken_ being swapped.\n     * @param fromToken_ The Token being swapped from.\n     * @param toToken_ The Token being swapped to.\n     * @return amountOutMin The minimum amount of toToken_ to receive from swap.\n     */\n    function _getAmountOutMin(\n        uint256 amount_,\n        address fromToken_,\n        address toToken_\n    ) internal view returns (uint256 amountOutMin) {\n        return\n            fromToken_ == address(_WETH)\n                ? _minTokenAmountOut(amount_, toToken_)\n                : _minWethAmountOut(amount_, fromToken_);\n    }\n\n    /**\n     * @dev Returns the minimum amount of Token to receive from swap.\n     * @param wethAmount_ The amount of WETH being swapped.\n     * @param token_ The Token the WETH is being swapped to.\n     * @return minAmountOut The minimum amount of Token to receive from swap.\n     */\n    function _minTokenAmountOut(uint256 wethAmount_, address token_)\n        internal\n        view\n        returns (uint256 minAmountOut)\n    {\n        uint256 priceInEth_ = _getPriceInEth(token_);\n        if (priceInEth_ == 0) return 0;\n        return\n            wethAmount_.scaledDiv(priceInEth_).scaledMul(slippageTolerance).scaleTo(\n                IERC20Full(token_).decimals()\n            );\n    }\n\n    /**\n     * @dev Returns the minimum amount of WETH to receive from swap.\n     * @param tokenAmount_ The amount of Token being swapped.\n     * @param token_ The Token that is being swapped for WETH.\n     * @return minAmountOut The minimum amount of WETH to receive from swap.\n     */\n    function _minWethAmountOut(uint256 tokenAmount_, address token_)\n        internal\n        view\n        returns (uint256 minAmountOut)\n    {\n        uint256 priceInEth_ = _getPriceInEth(token_);\n        if (priceInEth_ == 0) return 0;\n        return\n            tokenAmount_.scaledMul(priceInEth_).scaledMul(slippageTolerance).scaleFrom(\n                IERC20Full(token_).decimals()\n            );\n    }\n\n    /**\n     * @dev Returns the price in ETH of the given token. If no oracle exists for the token, returns 0.\n     * @param token_ The token to get the price for.\n     * @return tokenPriceInEth The price of the token in ETH.\n     */\n    function _getPriceInEth(address token_) internal view returns (uint256 tokenPriceInEth) {\n        try _addressProvider.getOracleProvider().getPriceETH(token_) returns (uint256 price_) {\n            return price_;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * @dev Returns the Curve Pool coin indices for a given Token.\n     * @param curvePool_ The Curve Pool to return the indices for.\n     * @param token_ The Token to get the indices for.\n     * @return wethIndex_ The coin index for WETH.\n     * @return tokenIndex_ The coin index for the Token.\n     */\n    function _getIndices(ICurveSwapEth curvePool_, address token_)\n        internal\n        view\n        returns (uint256 wethIndex_, uint256 tokenIndex_)\n    {\n        return curvePool_.coins(1) == token_ ? (0, 1) : (1, 0);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/swappers/SwapperRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../access/Authorization.sol\";\n\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/DecimalScale.sol\";\nimport \"../../libraries/ScaledMath.sol\";\n\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../../interfaces/ISwapperRouter.sol\";\nimport \"../../interfaces/vendor/UniswapRouter02.sol\";\nimport \"../../interfaces/vendor/IWETH.sol\";\nimport \"../../interfaces/IERC20Full.sol\";\nimport \"../../interfaces/vendor/ICurveSwapEth.sol\";\n\n/**\n * The swapper router handles the swapping from one token to another.\n * By default it does all swaps through WETH, in two steps checking which DEX is better for each stage of the swap.\n * It also supports ETH in or out and handles it by converting to WETH and back.\n */\ncontract SwapperRouter is ISwapperRouter, Authorization {\n    using SafeERC20 for IERC20;\n    using DecimalScale for uint256;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    // Dex contracts\n    address private constant _UNISWAP = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // Uniswap Router, used for swapping tokens on Uniswap\n    address private constant _SUSHISWAP = address(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); // Sushiswap Router, used for swapping tokens on Sushiswap\n    IWETH private constant _WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH, used for wrapping and unwrapping ETH for swaps\n\n    IAddressProvider private immutable _addressProvider; // Address provider used for getting oracle provider\n\n    uint256 public slippageTolerance; // The amount of slippage to allow from the oracle price of an asset\n    mapping(address => ICurveSwapEth) public curvePools; // Curve Pool to use for swapping with WETH\n\n    event Swapped(address fromToken, address toToken, uint256 amountIn, uint256 amountOut); // Emmited after a successfull swap\n    event SetSlippageTolerance(uint256 value); // Emitted after a successful setting of slippage tolerance\n    event SetCurvePool(address token, address curvePool); // Emitted after a successful setting of a Curve Pool\n\n    constructor(address addressProvider_)\n        Authorization(IAddressProvider(addressProvider_).getRoleManager())\n    {\n        _addressProvider = IAddressProvider(addressProvider_);\n        slippageTolerance = 0.97e18;\n    }\n\n    receive() external payable {} // Used for receiving ETH when unwrapping WETH\n\n    /**\n     * @notice Swaps all of the users balance of fromToken for toToken.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @return amountOut The amount of toToken received.\n     */\n    function swapAll(address fromToken_, address toToken_)\n        external\n        payable\n        override\n        returns (uint256 amountOut)\n    {\n        // Swapping if from token is ETH\n        if (fromToken_ == address(0)) {\n            return swap(fromToken_, toToken_, address(this).balance);\n        }\n\n        // Swapping if from token is ERC20\n        return swap(fromToken_, toToken_, IERC20(fromToken_).balanceOf(address(msg.sender)));\n    }\n\n    /**\n     * @notice Set slippage tolerance for swaps.\n     * @dev Stored as a multiplier, e.g. 2% would be set as 0.98.\n     * @param slippageTolerance_ New slippage tolerance.\n     */\n    function setSlippageTolerance(uint256 slippageTolerance_) external override onlyGovernance {\n        require(slippageTolerance_ <= ScaledMath.ONE, Error.INVALID_SLIPPAGE_TOLERANCE);\n        slippageTolerance = slippageTolerance_;\n        emit SetSlippageTolerance(slippageTolerance_);\n    }\n\n    /**\n     * @notice Sets the Curve Pool to use for swapping a token with WETH.\n     * @dev To use Uniswap or Sushiswap instead, set the Curve Pool to the zero address.\n     * @param token_ The token to set the Curve Pool for.\n     * @param curvePool_ The address of the Curve Pool.\n     */\n    function setCurvePool(address token_, address curvePool_) external override onlyGovernance {\n        require(token_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        require(curvePool_ != address(curvePools[token_]), Error.SAME_ADDRESS_NOT_ALLOWED);\n        curvePools[token_] = ICurveSwapEth(curvePool_);\n        emit SetCurvePool(token_, curvePool_);\n    }\n\n    /**\n     * @notice Gets the amount of toToken received by swapping amountIn of fromToken.\n     * @dev In the case where a custom swapper is used, return value may not be precise.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @param amountIn_ The amount of fromToken being swapped.\n     * @return amountOut The amount of toToken received by swapping amountIn of fromToken.\n     */\n    function getAmountOut(\n        address fromToken_,\n        address toToken_,\n        uint256 amountIn_\n    ) external view override returns (uint256 amountOut) {\n        if (fromToken_ == toToken_ || amountIn_ == 0) return amountIn_;\n\n        return _getTokenOut(toToken_, _getWethOut(fromToken_, amountIn_));\n    }\n\n    /**\n     * @notice Swaps an amount of fromToken to toToken.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @param amountIn_ The amount of fromToken to swap for toToken.\n     * @return amountOut The amount of toToken received.\n     */\n    function swap(\n        address fromToken_,\n        address toToken_,\n        uint256 amountIn_\n    ) public payable override returns (uint256 amountOut) {\n        // Validating ETH value sent\n        require(msg.value == (fromToken_ == address(0) ? amountIn_ : 0), Error.INVALID_AMOUNT);\n        if (amountIn_ == 0) {\n            emit Swapped(fromToken_, toToken_, 0, 0);\n            return 0;\n        }\n\n        // Handling swap between the same token\n        if (fromToken_ == toToken_) {\n            if (fromToken_ == address(0)) {\n                payable(msg.sender).transfer(amountIn_);\n            }\n            emit Swapped(fromToken_, toToken_, amountIn_, amountIn_);\n            return amountIn_;\n        }\n\n        // Transferring to contract if ERC20\n        if (fromToken_ != address(0)) {\n            IERC20(fromToken_).safeTransferFrom(msg.sender, address(this), amountIn_);\n        }\n\n        // Swapping token via WETH\n        uint256 amountOut_ = _swapWethForToken(toToken_, _swapForWeth(fromToken_));\n        emit Swapped(fromToken_, toToken_, amountIn_, amountOut_);\n        return _returnTokens(toToken_, amountOut_);\n    }\n\n    /**\n     * @dev Swaps the full contract balance of token to WETH.\n     * @param token_ The token to swap to WETH.\n     * @return amountOut The amount of WETH received from the swap.\n     */\n    function _swapForWeth(address token_) internal returns (uint256 amountOut) {\n        if (token_ == address(_WETH)) return _WETH.balanceOf(address(this));\n\n        // Handling ETH -> WETH\n        if (token_ == address(0)) {\n            uint256 ethBalance_ = address(this).balance;\n            if (ethBalance_ == 0) return 0;\n            _WETH.deposit{value: ethBalance_}();\n            return ethBalance_;\n        }\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            uint256 amount_ = IERC20(token_).balanceOf(address(this));\n            if (amount_ == 0) return 0;\n            _approve(token_, address(curvePool_));\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            curvePool_.exchange(\n                tokenIndex_,\n                wethIndex_,\n                amount_,\n                _minWethAmountOut(amount_, token_)\n            );\n            return _WETH.balanceOf(address(this));\n        }\n\n        // Handling ERC20 -> WETH\n        return _swap(token_, address(_WETH), IERC20(token_).balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Swaps the full contract balance of WETH to token.\n     * @param token_ The token to swap WETH to.\n     * @return amountOut The amount of token received from the swap.\n     */\n    function _swapWethForToken(address token_, uint256 amount_)\n        internal\n        returns (uint256 amountOut)\n    {\n        if (amount_ == 0) return 0;\n        if (token_ == address(_WETH)) return amount_;\n\n        // Handling WETH -> ETH\n        if (token_ == address(0)) {\n            _WETH.withdraw(amount_);\n            return amount_;\n        }\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            _approve(address(_WETH), address(curvePool_));\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            curvePool_.exchange(\n                wethIndex_,\n                tokenIndex_,\n                amount_,\n                _minTokenAmountOut(amount_, token_)\n            );\n            return IERC20(token_).balanceOf(address(this));\n        }\n\n        // Handling WETH -> ERC20\n        return _swap(address(_WETH), token_, amount_);\n    }\n\n    /**\n     * @dev Swaps an amount of fromToken to toToken.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @param amount_ The amount of fromToken to swap.\n     * @return amountOut The amount of toToken received from the swap.\n     */\n    function _swap(\n        address fromToken_,\n        address toToken_,\n        uint256 amount_\n    ) internal returns (uint256 amountOut) {\n        if (amount_ == 0) return 0;\n        if (fromToken_ == toToken_) return amount_;\n        address dex_ = _getBestDex(fromToken_, toToken_, amount_);\n        _approve(fromToken_, dex_);\n        address[] memory path_ = new address[](2);\n        path_[0] = fromToken_;\n        path_[1] = toToken_;\n        return\n            UniswapRouter02(dex_).swapExactTokensForTokens(\n                amount_,\n                _getAmountOutMin(amount_, fromToken_, toToken_),\n                path_,\n                address(this),\n                block.timestamp\n            )[1];\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token_ The token to approve for.\n     * @param spender_ The spender to approve.\n     */\n    function _approve(address token_, address spender_) internal {\n        if (IERC20(token_).allowance(address(this), spender_) > 0) return;\n        IERC20(token_).safeApprove(spender_, type(uint256).max);\n    }\n\n    /**\n     * @dev Returns an amount of tokens to the sender.\n     * @param token_ The token to return to sender.\n     * @param amount_ The amount of tokens to return to sender.\n     * @return amountReturned The amount of tokens returned to sender.\n     */\n    function _returnTokens(address token_, uint256 amount_)\n        internal\n        returns (uint256 amountReturned)\n    {\n        // Returning if ETH\n        if (token_ == address(0)) {\n            payable(msg.sender).transfer(amount_);\n            return amount_;\n        }\n\n        // Returning if ERC20\n        IERC20(token_).safeTransfer(msg.sender, amount_);\n        return amount_;\n    }\n\n    /**\n     * @dev Gets the amount of WETH received by swapping amount of token\n     *      In the case where a custom swapper is used, return value may not be precise.\n     * @param token_ The token to swap from.\n     * @param amount_ The mount of token being swapped.\n     * @return amountOut The amount of WETH received by swapping amount of token.\n     */\n    function _getWethOut(address token_, uint256 amount_)\n        internal\n        view\n        returns (uint256 amountOut)\n    {\n        if (token_ == address(_WETH) || token_ == address(0)) return amount_;\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            return curvePool_.get_dy(tokenIndex_, wethIndex_, amount_);\n        }\n\n        return\n            _tokenAmountOut(\n                token_,\n                address(_WETH),\n                amount_,\n                _getBestDex(token_, address(_WETH), amount_)\n            );\n    }\n\n    /**\n     * @dev Gets the amount of token received by swapping amount of WETH\n     *      In the case where a custom swapper is used, return value may not be precise.\n     * @param token_ The token to swap to.\n     * @param amount_ The amount of WETH being swapped.\n     * @return amountOut The amount of token received by swapping amount of WETH.\n     */\n    function _getTokenOut(address token_, uint256 amount_)\n        internal\n        view\n        returns (uint256 amountOut)\n    {\n        if (token_ == address(_WETH) || token_ == address(0)) return amount_;\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            return curvePool_.get_dy(wethIndex_, tokenIndex_, amount_);\n        }\n\n        return\n            _tokenAmountOut(\n                address(_WETH),\n                token_,\n                amount_,\n                _getBestDex(address(_WETH), token_, amount_)\n            );\n    }\n\n    /**\n     * @dev Gets the best dex to use for swapping tokens based on which gives the highest amount out.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @param amount_ The amount of fromToken to swap.\n     * @return bestDex The best dex to use for swapping tokens based on which gives the highest amount out\n     */\n    function _getBestDex(\n        address fromToken_,\n        address toToken_,\n        uint256 amount_\n    ) internal view returns (address bestDex) {\n        address uniswap_ = _UNISWAP;\n        address sushiswap_ = _SUSHISWAP;\n        return\n            _tokenAmountOut(fromToken_, toToken_, amount_, uniswap_) >=\n                _tokenAmountOut(fromToken_, toToken_, amount_, sushiswap_)\n                ? uniswap_\n                : sushiswap_;\n    }\n\n    /**\n     * @notice Gets the amount of toToken received by swapping amountIn of fromToken.\n     * @param fromToken_ The token to swap from.\n     * @param t"
    }
  ]
}