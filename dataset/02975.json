{
  "Title": "M-3: `epochsByBuyer[]` can lose records",
  "Content": "# Issue M-3: `epochsByBuyer[]` can lose records \n\nSource: https://github.com/sherlock-audit/2022-09-knox-judging/issues/86 \n\n## Found by \nrvierdiiev, hansfriese, \\_\\_141345\\_\\_, bin2chen\n\n## Summary\n\nWhen `cancelLimitOrder()`, the `epoch` will be removed from `epochsByBuyer[]`, but the user could have other orders on the orderbook, the record will be inaccurate and mislead the users.\n\n\n## Vulnerability Detail\n\nIf a user put 2 limit orders with different prices, 2 separate id will be assigned, but only 1 epoch will be added to the `epochsByBuyer[]` array. \nIf the user cancel 1 of the orders, the `epoch` will be removed from `epochsByBuyer[]`, it will be impossible to track the other orders put by the user. And the `getEpochsByBuyer()` function will return inaccurate result.\n\n\n\n## Impact\n\nIf some users rely on the results of `getEpochsByBuyer()` for new orders, the returned inaccurate results could be misleading, and cause potential loss to the users due to wrong information.\n\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L545-L553\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/Auction.sol#L220\n\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nOnly remove the `epochsByBuyer` records when all the orders of the user is cancelled.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/4",
  "Code": [
    {
      "filename": "knox-contracts/contracts/auction/AuctionInternal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@solidstate/contracts/access/ownable/OwnableInternal.sol\";\nimport \"@solidstate/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@solidstate/contracts/token/ERC20/IERC20.sol\";\nimport \"@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol\";\nimport \"@solidstate/contracts/utils/IWETH.sol\";\nimport \"@solidstate/contracts/utils/SafeERC20.sol\";\n\nimport \"../libraries/OptionMath.sol\";\n\nimport \"../vendor/IPremiaPool.sol\";\n\nimport \"../vault/IVault.sol\";\n\nimport \"./AuctionStorage.sol\";\nimport \"./IAuctionEvents.sol\";\n\n/**\n * @title Knox Dutch Auction Internal Contract\n */\n\ncontract AuctionInternal is IAuctionEvents, OwnableInternal {\n    using ABDKMath64x64 for int128;\n    using ABDKMath64x64 for uint256;\n    using ABDKMath64x64Token for int128;\n    using ABDKMath64x64Token for uint256;\n    using AuctionStorage for AuctionStorage.Layout;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using OptionMath for uint256;\n    using OrderBook for OrderBook.Index;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH;\n\n    bool internal immutable isCall;\n    uint8 internal immutable baseDecimals;\n    uint8 internal immutable underlyingDecimals;\n\n    IERC20 public immutable ERC20;\n    IPremiaPool public immutable Pool;\n    IVault public immutable Vault;\n    IWETH public immutable WETH;\n\n    constructor(\n        bool _isCall,\n        address pool,\n        address vault,\n        address weth\n    ) {\n        isCall = _isCall;\n\n        Pool = IPremiaPool(pool);\n        IPremiaPool.PoolSettings memory settings = Pool.getPoolSettings();\n        address asset = isCall ? settings.underlying : settings.base;\n\n        baseDecimals = IERC20Metadata(settings.base).decimals();\n        underlyingDecimals = IERC20Metadata(settings.underlying).decimals();\n\n        ERC20 = IERC20(asset);\n        Vault = IVault(vault);\n        WETH = IWETH(weth);\n    }\n\n    /************************************************\n     *  ACCESS CONTROL\n     ***********************************************/\n\n    /**\n     * @dev Throws if called by any account other than the vault\n     */\n    modifier onlyVault() {\n        AuctionStorage.Layout storage l = AuctionStorage.layout();\n        require(msg.sender == address(Vault), \"!vault\");\n        _;\n    }\n\n    /**\n     * @dev Throws if limit orders are not allowed\n     * @param auction storage params\n     */\n    function _limitOrdersAllowed(AuctionStorage.Auction storage auction)\n        internal\n        view\n    {\n        require(\n            AuctionStorage.Status.INITIALIZED == auction.status,\n            \"status != initialized\"\n        );\n        _auctionHasNotEnded(auction);\n    }\n\n    /**\n     * @dev Throws if market orders are not allowed\n     * @param auction storage params\n     */\n    function _marketOrdersAllowed(AuctionStorage.Auction storage auction)\n        internal\n        view\n    {\n        require(\n            AuctionStorage.Status.INITIALIZED == auction.status,\n            \"status != initialized\"\n        );\n        _auctionHasStarted(auction);\n        _auctionHasNotEnded(auction);\n    }\n\n    /**\n     * @dev Throws if auction has not started.\n     * @param auction storage params\n     */\n    function _auctionHasStarted(AuctionStorage.Auction storage auction)\n        private\n        view\n    {\n        require(auction.startTime > 0, \"start time is not set\");\n        require(block.timestamp >= auction.startTime, \"auction not started\");\n    }\n\n    /**\n     * @dev Throws if auction has ended.\n     * @param auction storage params\n     */\n    function _auctionHasNotEnded(AuctionStorage.Auction storage auction)\n        private\n        view\n    {\n        require(auction.endTime > 0, \"end time is not set\");\n        require(block.timestamp <= auction.endTime, \"auction has ended\");\n    }\n\n    /************************************************\n     *  PRICING\n     ***********************************************/\n\n    /**\n     * @notice returns the last price paid during the auction\n     * @param auction storage params\n     * @return price as 64x64 fixed point number\n     */\n    function _lastPrice64x64(AuctionStorage.Auction storage auction)\n        internal\n        view\n        returns (int128)\n    {\n        return auction.lastPrice64x64;\n    }\n\n    /**\n     * @notice calculates the current price using the price curve function\n     * @param auction storage params\n     * @return price as 64x64 fixed point number\n     */\n    function _priceCurve64x64(AuctionStorage.Auction storage auction)\n        internal\n        view\n        returns (int128)\n    {\n        uint256 startTime = auction.startTime;\n        uint256 totalTime = auction.endTime - auction.startTime;\n\n        int128 maxPrice64x64 = auction.maxPrice64x64;\n        int128 minPrice64x64 = auction.minPrice64x64;\n\n        /**\n         *\n         * price curve equation:\n         * assumes max price is always greater than min price\n         * assumes the time remaining is in the range of 0 and 1\n         * ------------------------------\n         * time_remaning_percent(t) = (t - time_start) / time_total\n         * price(t) = max_price - time_remaning_percent(t) * (max_price - min_price)\n         *\n         */\n\n        if (block.timestamp <= startTime) return maxPrice64x64;\n\n        uint256 elapsed = block.timestamp - startTime;\n        int128 timeRemaining64x64 = elapsed.divu(totalTime);\n\n        int128 x = maxPrice64x64.sub(minPrice64x64);\n        int128 y = timeRemaining64x64.mul(x);\n        return maxPrice64x64.sub(y);\n    }\n\n    /**\n     * @notice returns the current price established by the price curve if the auction\n     * is still ongoing, otherwise the last price paid is returned\n     * @param auction storage params\n     * @return price as 64x64 fixed point number\n     */\n    function _clearingPrice64x64(AuctionStorage.Auction storage auction)\n        internal\n        view\n        returns (int128)\n    {\n        if (\n            auction.status == AuctionStorage.Status.FINALIZED ||\n            auction.status == AuctionStorage.Status.PROCESSED ||\n            auction.status == AuctionStorage.Status.CANCELLED\n        ) {\n            return _lastPrice64x64(auction);\n        }\n        return _priceCurve64x64(auction);\n    }\n\n    /************************************************\n     *  WITHDRAW\n     ***********************************************/\n\n    /**\n     * @notice withdraws any amount(s) owed to the buyer (fill and/or refund)\n     * @param l auction storage layout\n     * @param epoch epoch id\n     */\n    function _withdraw(AuctionStorage.Layout storage l, uint64 epoch) internal {\n        (uint256 refund, uint256 fill) =\n            _previewWithdraw(l, false, epoch, msg.sender);\n\n        l.epochsByBuyer[msg.sender].remove(epoch);\n\n        // fetches the exercised value of the options\n        (bool expired, uint256 exercisedAmount) =\n            _getExerciseAmount(l, epoch, fill);\n\n        if (expired) {\n            if (exercisedAmount > 0) {\n                // if expired ITM, adjust refund by the amount exercised\n                refund += exercisedAmount;\n            }\n\n            // set fill to 0, buyer will not receive any long tokens\n            fill = 0;\n        }\n\n        if (fill > 0) {\n            // transfers long tokens to msg.sender\n            Pool.safeTransferFrom(\n                address(this),\n                msg.sender,\n                l.auctions[epoch].longTokenId,\n                fill,\n                \"\"\n            );\n        }\n\n        if (refund > 0) {\n            // transfers refunded premium to msg.sender\n            ERC20.safeTransfer(msg.sender, refund);\n        }\n\n        emit OrderWithdrawn(epoch, msg.sender, refund, fill);\n    }\n\n    /**\n     * @notice calculates amount(s) owed to the buyer\n     * @param epoch epoch id\n     * @param buyer address of buyer\n     * @return amount refunded\n     * @return amount filled\n     */\n    function _previewWithdraw(uint64 epoch, address buyer)\n        internal\n        returns (uint256, uint256)\n    {\n        AuctionStorage.Layout storage l = AuctionStorage.layout();\n        return _previewWithdraw(l, true, epoch, buyer);\n    }\n\n    /**\n     * @notice traverses the orderbook and returns the refund and fill amounts\n     * @param l auction storage layout\n     * @param epoch epoch id\n     * @param buyer address of buyer\n     * @return amount refunded\n     * @return amount filled\n     */\n    function _previewWithdraw(\n        AuctionStorage.Layout storage l,\n        bool isPreview,\n        uint64 epoch,\n        address buyer\n    ) private returns (uint256, uint256) {\n        AuctionStorage.Auction storage auction = l.auctions[epoch];\n        OrderBook.Index storage orderbook = l.orderbooks[epoch];\n\n        uint256 refund;\n        uint256 fill;\n\n        int128 lastPrice64x64 = _clearingPrice64x64(auction);\n\n        uint256 totalContractsSold;\n        uint256 next = orderbook._head();\n        uint256 length = orderbook._length();\n\n        // traverse the order book and return orders placed by the buyer\n        for (uint256 i = 1; i <= length; i++) {\n            OrderBook.Data memory data = orderbook._getOrderById(next);\n            next = orderbook._getNextOrder(next);\n\n            if (data.buyer == buyer) {\n                if (\n                    lastPrice64x64 < type(int128).max &&\n                    data.price64x64 >= lastPrice64x64\n                ) {\n                    // if the auction has not been cancelled, and the order price is greater than or\n                    // equal to the last price, fill the order and calculate the refund amount\n                    uint256 paid = data.price64x64.mulu(data.size);\n                    uint256 cost = lastPrice64x64.mulu(data.size);\n\n                    if (\n                        totalContractsSold + data.size >= auction.totalContracts\n                    ) {\n                        // if part of the current order exceeds the total contracts available, partially\n                        // fill the order, and refund the remainder\n                        uint256 remainder =\n                            auction.totalContracts - totalContractsSold;\n\n                        cost = lastPrice64x64.mulu(remainder);\n                        fill += remainder;\n                    } else {\n                        // otherwise, fill the entire order\n                        fill += data.size;\n                    }\n\n                    // the refund takes the difference between the amount paid and the \"true\" cost of\n                    // of the order. the \"true\" cost can be calculated when the clearing price has been\n                    // set.\n                    refund += paid - cost;\n                } else {\n                    // if last price >= type(int128).max, auction has been cancelled, only send refund\n                    // if price < last price, the bid is too low, only send refund\n                    refund += data.price64x64.mulu(data.size);\n                }\n\n                if (!isPreview) {\n                    // when a withdrawal is made, remove the order from the order book\n                    orderbook._remove(data.id);\n                }\n            }\n\n            totalContractsSold += data.size;\n        }\n\n        return (refund, fill);\n    }\n\n    /************************************************\n     *  FINALIZE AUCTION\n     ***********************************************/\n\n    /**\n     * @notice traverses the orderbook and checks if the auction has reached 100% utilization\n     * @param l auction storage layout\n     * @param epoch epoch id\n     * @return true if the auction has reached 100% utilization\n     */\n    function _processOrders(AuctionStorage.Layout storage l, uint64 epoch)\n        private\n        returns (bool)\n    {\n        OrderBook.Index storage orderbook = l.orderbooks[epoch];\n        AuctionStorage.Auction storage auction = l.auctions[epoch];\n\n        uint256 next = orderbook._head();\n        uint256 length = orderbook._length();\n\n        uint256 totalContracts = _getTotalContracts(auction);\n\n        if (auction.totalContracts <= 0) {\n            // sets totalContracts if this is the first bid.\n            auction.totalContracts = totalContracts;\n        }\n\n        uint256 totalContractsSold;\n        int128 lastPrice64x64;\n\n        // traverse the order book and sum the contracts sold until the utilization == 100% or\n        // the end of the orderbook has been reached.\n        for (uint256 i = 1; i <= length; i++) {\n            OrderBook.Data memory data = orderbook._getOrderById(next);\n            next = orderbook._getNextOrder(next);\n\n            // orders in the order book are sorted by price in a descending order. if the\n            // order price < clearing price the last order which should be accepeted has\n            // been reached.\n            if (data.price64x64 < _clearingPrice64x64(auction)) break;\n\n            // checks if utilization >= 100%\n            if (totalContractsSold + data.size >= totalContracts) {\n                auction.lastPrice64x64 = data.price64x64;\n                auction.totalContractsSold = totalContracts;\n                return true;\n            }\n\n            totalContractsSold += data.size;\n            lastPrice64x64 = data.price64x64;\n        }\n\n        /**\n         * sets the last price reached in the order book equal to the last price paid in the auction.\n         *\n         *\n         * Orderbook | price curve == 96\n         * ---------\n         * id -  price\n         * 0  -  100\n         * 1  -  97 --- last price\n         * 2  -  95\n         * */\n\n        auction.lastPrice64x64 = lastPrice64x64;\n        auction.totalContractsSold = totalContractsSold;\n        return false;\n    }\n\n    /**\n     * @notice determines whether the auction has reached finality. the end criteria for the auction are\n     * met if the auction has reached 100% utilization or the end time has been exceeded.\n     * @param l auction storage layout\n     * @param auction storage params\n     * @param epoch epoch id\n     */\n    function _finalizeAuction(\n        AuctionStorage.Layout storage l,\n        AuctionStorage.Auction storage auction,\n        uint64 epoch\n    ) internal {\n        if (_processOrders(l, epoch) || block.timestamp > auction.endTime) {\n            auction.status = AuctionStorage.Status.FINALIZED;\n            emit AuctionStatusSet(epoch, auction.status);\n        }\n    }\n\n    /************************************************\n     *  VIEW\n     ***********************************************/\n\n    /**\n     * @notice calculates the total number of contracts that can be sold during the auction\n     * @param auction storage params\n     * @return total contracts available\n     */\n    function _getTotalContracts(AuctionStorage.Auction storage auction)\n        internal\n        view\n        returns (uint256)\n    {\n        if (auction.totalContracts <= 0) {\n            // if the total contracts has not been set for the auction, the vault contract\n            // will be queried and the amount will be determined from the collateral in the vault.\n\n            uint256 totalCollateral = Vault.totalCollateral();\n            int128 strike64x64 = auction.strike64x64;\n\n            return\n                totalCollateral.fromContractsToCollateral(\n                    isCall,\n                    baseDecimals,\n                    strike64x64\n                );\n        }\n\n        return auction.totalContracts;\n    }\n\n    /************************************************\n     *  PURCHASE HELPERS\n     ***********************************************/\n\n    /**\n     * @notice checks whether the limit order parameters are valid and returns the cost\n     * @param l auction storage layout\n     * @param price64x64 max price as 64x64 fixed point number\n     * @param size amount of contracts\n     * @return cost of the order given the size and price\n     */\n    function _validateLimitOrder(\n        AuctionStorage.Layout storage l,\n        int128 price64x64,\n        uint256 size\n    ) internal view returns (uint256) {\n        require(price64x64 > 0, \"price <= 0\");\n        require(size >= l.minSize, \"size < minimum\");\n\n        uint256 cost = price64x64.mulu(size);\n        return cost;\n    }\n\n    /**\n     * @notice checks whether the market order parameters are valid and returns the price and cost\n     * @param l auction storage layout\n     * @param auction storage params\n     * @param size amount of contracts\n     * @param maxCost max cost of buyer is willing to pay\n     * @return price established by the price curve\n     * @return cost of the order given the size and price\n     */\n    function _validateMarketOrder(\n        AuctionStorage.Layout storage l,\n        AuctionStorage.Auction storage auction,\n        uint256 size,\n        uint256 maxCost\n    ) internal view returns (int128, uint256) {\n        require(size >= l.minSize, \"size < minimum\");\n\n        int128 price64x64 = _priceCurve64x64(auction);\n        uint256 cost = price64x64.mulu(size);\n\n        require(maxCost >= cost, \"cost > maxCost\");\n        return (price64x64, cost);\n    }\n\n    /**\n     * @notice transfers the premium to the buyer if a refund is due, ortherwise, pull funds\n     * from buyer if funds are owed to the auction contract.\n     * @param credited amount already paid by the buyer\n     * @param cost total amount which must be paid by the buyer\n     * @param buyer account being debited or credited\n     */\n    function _transferAssets(\n        uint256 credited,\n        uint256 cost,\n        address buyer\n    ) internal {\n        if (credited > cost) {\n            // refund buyer the amount overpaid\n            ERC20.safeTransfer(buyer, credited - cost);\n        } else if (cost > credited) {\n            // an approve() by the msg.sender is required beforehand\n            ERC20.safeTransferFrom(buyer, address(this), cost - credited);\n        }\n    }\n\n    /**\n     * @notice checks whether the market order parameters are valid and returns the price and cost\n     * @param l auction storage layout\n     * @param auction storage params\n     * @param epoch epoch id\n     * @param price64x64 max price as 64x64 fixed point number\n     * @param size amount of contracts\n     * @param isLimitOrder true, if the order is a limit order\n     */\n    function _addOrder(\n        AuctionStorage.Layout storage l,\n        AuctionStorage.Auction storage auction,\n        uint64 epoch,\n        int128 price64x64,\n        uint256 size,\n        bool isLimitOrder\n    ) internal {\n        l.epochsByBuyer[msg.sender].add(epoch);\n\n        uint256 id = l.orderbooks[epoch]._insert(price64x64, size, msg.sender);\n\n        if (block.timestamp >= auction.startTime) {\n            _finalizeAuction(l, auction, epoch);\n        }\n\n        emit OrderAdded(epoch, id, msg.sender, price64x64, size, isLimitOrder);\n    }\n\n    /**\n     * @notice wraps ETH sent to the contract and credits the amount, if the collateral asset\n     * is not WETH, the transaction will revert\n     * @param amount total collateral deposited\n     * @return credited amount\n     */\n    function _wrapNativeToken(uint256 amount) internal returns (uint256) {\n        uint256 credit;\n\n        if (msg.value > 0) {\n            require(address(ERC20) == address(WETH), \"collateral != wETH\");\n\n            if (msg.value > amount) {\n                // if the ETH amount is greater than the amount needed, it will be sent\n                // back to the msg.sender\n                unchecked {\n                    (bool success, ) =\n                        payable(msg.sender).call{value: msg.value - amount}(\"\");\n\n                    require(success, \"ETH refund failed\");\n\n                    credit = amount;\n                }\n            } else {\n                credit = msg.value;\n            }\n\n            WETH.deposit{value: credit}();\n        }\n\n        return credit;\n    }\n\n    /**\n     * @notice pull token from user, send to exchangeHelper trigger a trade from\n     * ExchangeHelper, and credits the amount\n     * @param Exchange ExchangeHelper contract interface\n     * @param s swap arguments\n     * @param tokenOut token to swap for. should always equal to the collateral asset\n     * @return credited amount\n     */\n    function _swapForPoolTokens(\n        IExchangeHelper Exchange,\n        IExchangeHelper.SwapArgs calldata s,\n        address tokenOut\n    ) internal returns (uint256) {\n        if (msg.value > 0) {\n            require(s.tokenIn == address(WETH), \"tokenIn != wETH\");\n            WETH.deposit{value: msg.value}();\n            WETH.safeTransfer(address(Exchange), msg.value);\n        }\n\n        if (s.amountInMax > 0) {\n            IERC20(s.tokenIn).safeTransferFrom(\n                msg.sender,\n                address(Exchange),\n                s.amountInMax\n            );\n        }\n\n        uint256 amountCredited =\n            Exchange.swapWithToken(\n                s.tokenIn,\n                tokenOut,\n                s.amountInMax + msg.value,\n                s.callee,\n                s.allowanceTarget,\n                s.data,\n                s.refundAddress\n            );\n\n        require(\n            amountCredited >= s.amountOutMin,\n            \"not enough output from trade\"\n        );\n\n        return amountCredited;\n    }\n\n    /************************************************\n     * HELPERS\n     ***********************************************/\n\n    /**\n     * @notice cancels all orders and finalizes the auction\n     * @param auction the auction to cancel\n     */\n    function _cancel(AuctionStorage.Auction storage auction, uint64 epoch)\n        internal\n    {\n        auction.lastPrice64x64 = type(int128).max;\n        auction.status = AuctionStorage.Status.CANCELLED;\n        auction.totalPremiums = 0;\n        emit AuctionStatusSet(epoch, auction.status);\n    }\n\n    /**\n     * @notice calculates the expected proceeds of the option if it has expired\n     * @param epoch epoch id\n     * @param size amount of contracts\n     * @return true if the option has expired\n     * @return the exercised amount\n     */\n    function _getExerciseAmount(\n        AuctionStorage.Layout storage l,\n        uint64 epoch,\n        uint256 size\n    ) private view returns (bool, uint256) {\n        AuctionStorage.Auction storage auction = l.auctions[epoch];\n\n        uint64 expiry = auction.expiry;\n        int128 strike64x64 = auction.strike64x64;\n\n        if (block.timestamp < expiry) return (false, 0);\n\n        int128 spot64x64 = Pool.getPriceAfter64x64(expiry);\n        uint256 amount;\n\n        if (isCall && spot64x64 > strike64x64) {\n            amount = spot64x64.sub(strike64x64).div(spot64x64).mulu(size);\n        } else if (!isCall && strike64x64 > spot64x64) {\n            uint256 value = strike64x64.sub(spot64x64).mulu(size);\n\n            // converts the value to the base asset amount, this is particularly important where the\n            // the decimals of the underlying are different from the base (e.g. wBTC/DAI)\n            amount = OptionMath.toBaseTokenAmount(\n                underlyingDecimals,\n                baseDecimals,\n                value\n            );\n        }\n\n        return (true, amount);\n    }\n}"
    },
    {
      "filename": "knox-contracts/contracts/auction/Auction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@solidstate/contracts/introspection/ERC165Storage.sol\";\nimport \"@solidstate/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"./AuctionInternal.sol\";\nimport \"./IAuction.sol\";\n\n/**\n * @title Knox Dutch Auction Contract\n * @dev deployed standalone and referenced by AuctionProxy\n */\n\ncontract Auction is AuctionInternal, IAuction, ReentrancyGuard {\n    using ABDKMath64x64 for int128;\n    using AuctionStorage for AuctionStorage.Layout;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using ERC165Storage for ERC165Storage.Layout;\n    using OrderBook for OrderBook.Index;\n    using SafeERC20 for IERC20;\n\n    constructor(\n        bool isCall,\n        address pool,\n        address vault,\n        address weth\n    ) AuctionInternal(isCall, pool, vault, weth) {}\n\n    /************************************************\n     *  ADMIN\n     ***********************************************/\n\n    /**\n     * @inheritdoc IAuction\n     */\n    function setExchangeHelper(address newExchangeHelper) external onlyOwner {\n        AuctionStorage.Layout storage l = AuctionStorage.layout();\n\n        require(newExchangeHelper != address(0), \"address not provided\");\n        require(\n            newExchangeHelper != address(l.Exchange),\n            \"new address equals old\"\n        );\n\n        emit ExchangeHelperSet(\n            address(l.Exchange),\n            newExchangeHelper,\n            msg.sender\n        );\n\n        l.Exchange = IExchangeHelper(newExchangeHelper);\n    }\n\n    /************************************************\n     *  INITIALIZE AUCTION\n     ***********************************************/\n\n    /**\n     * @inheritdoc IAuction\n     */\n    function initialize(AuctionStorage.InitAuction memory initAuction)\n        external\n        onlyVault\n    {\n        AuctionStorage.Layout storage l = AuctionStorage.layout();\n        AuctionStorage.Auction storage auction = l.auctions[initAuction.epoch];\n\n        require(\n            auction.status == AuctionStorage.Status.UNINITIALIZED,\n            \"status != uninitialized\"\n        );\n\n        if (\n            initAuction.startTime >= initAuction.endTime ||\n            block.timestamp > initAuction.startTime ||\n            block.timestamp > initAuction.expiry ||\n            initAuction.strike64x64 <= 0 ||\n            initAuction.longTokenId <= 0\n        ) {\n            // the auction is cancelled if the start time is greater than or equal to\n            // the end time, the current time is greater than the start time, or the\n            // option parameters are invalid\n            _cancel(l.auctions[initAuction.epoch], initAuction.epoch);\n        } else {\n            auction.status = AuctionStorage.Status.INITIALIZED;\n            auction.expiry = initAuction.expiry;\n            auction.strike64x64 = initAuction.strike64x64;\n            auction.startTime = initAuction.startTime;\n            auction.endTime = initAuction.endTime;\n            auction.longTokenId = initAuction.longTokenId;\n            emit AuctionStatusSet(initAuction.epoch, auction.status);\n        }\n    }\n\n    /**\n     * @inheritdoc IAuction\n     */\n    function setAuctionPrices(\n        uint64 epoch,\n        int128 maxPrice64x64,\n        int128 minPrice64x64\n    ) external onlyVault {\n        AuctionStorage.Layout storage l = AuctionStorage.layout();\n        AuctionStorage.Auction storage auction = l.auctions[epoch];\n\n        require(\n            AuctionStorage.Status.INITIALIZED == auction.status,\n            \"status != initialized\"\n        );\n\n        // stores the auction max/ min prices\n        auction.maxPrice64x64 = maxPrice64x64;\n        auction.minPrice64x64 = minPrice64x64;\n\n        if (\n            auction.maxPrice64x64 <= 0 ||\n            auction.minPrice64x64 <= 0 ||\n            auction.maxPrice64x64 <= auction.minPrice64x64\n        ) {\n            // if either price is 0 or the max price is less than or equal to the min price,\n            // the auction should always be cancelled.\n            _cancel(l.auctions[epoch], epoch);\n        }\n    }\n\n    /************************************************\n     *  PRICING\n     ***********************************************/\n\n    /**\n     * @inheritdoc IAuction\n     */\n    function lastPrice64x64(uint64 epoch) external view returns (int128) {\n        AuctionStorage.Layout storage l = AuctionStorage.layout();\n        AuctionStorage.Auction storage auction = l.auctions[epoch];\n        return _lastPrice64x64(auction);\n    }\n\n    /**\n     * @inheritdoc IAuction\n     */\n    function priceCurve64x64(uint64 epoch) external view returns (int128) {\n        AuctionStorage.Layout storage l = AuctionStorage.layout();\n        AuctionStorage.Auction storage auction = l.auctions[epoch];\n        return _priceCurve64x64(auction);\n    }\n\n    /**\n     * @inheritdoc IAuction\n     */\n    function clearingPrice64x64(uint64 epoch) external view returns (int128) {\n        AuctionStorage.Layout storage l = AuctionStorage.layout();\n        AuctionStorage.Auction storage auction = l.auctions[epoch];\n        return _clearingPrice64x64(auction);\n    }\n\n    /************************************************\n     *  PURCHASE\n     ***********************************************/\n\n    /**\n     * @inheritdoc IAuction\n     */\n    function addLimitOrder(\n        uint64 epoch,\n        int128 price64x64,\n        uint256 size\n    ) external payable nonReentrant {\n        AuctionStorage.Layout storage l = AuctionStorage.layout();\n        AuctionStorage.Auction storage auction = l.auctions[epoch];\n\n        _limitOrdersAllowed(auction);\n\n        uint256 cost = _validateLimitOrder(l, price64x64, size);\n        uint256 credited = _wrapNativeToken(cost);\n        // an approve() by the msg.sender is required beforehand\n        ERC20.safeTransferFrom(msg.sender, address(this), cost - credited);\n        _addOrder(l, auction, epoch, price64x64, size, true);\n    }\n\n    /**\n     * @inheritdoc IAuction\n     */\n    function swapAndAddLimitOrder(\n        IExchangeHelper.SwapArgs calldata s,\n        uint64 epoch,\n        int128 price64x64,\n        uint256 size\n    ) external payable nonReentrant {\n        AuctionStorage.Layout storage l = AuctionStorage.layout();\n        AuctionStorage.Auction storage auction = l.auctions[epoch];\n\n        _limitOrdersAllowed(auction);\n\n        uint256 cost = _validateLimitOrder(l, price64x64, size);\n        uint256 credited = _swapForPoolTokens(l.Exchange, s, address(ERC20));\n        _transferAssets(credited, cost, msg.sender);\n        _addOrder(l, auction, epoch, price64x64, size, true);\n    }\n\n    /**\n     * @inheritdoc IAuction\n     */\n    function cancelLimitOrder(uint64 epoch, uint256 id) external nonReentrant {\n        AuctionStorage.Layout storage l = AuctionStorage.layout();\n        AuctionStorage.Auction storage auction = l.auctions[epoch];\n\n        _limitOrdersAllowed(auction);\n\n        require(id > 0, \"invalid order id\");\n\n        OrderBook.Index storage orderbook = l.orderbooks[epoch];\n        OrderBook.Data memory data = orderbook._getOrderById(id);\n\n        require(data.buyer != address(0), \"order does not exist\");\n        require(data.buyer == msg.sender, \"buyer != msg.sender\");\n\n        orderbook._remove(id);\n        l.epochsByBuyer[data.buyer].remove(epoch);\n\n        if (block.timestamp >= auction.startTime) {\n            _finalizeAuction(l, auction, epoch);\n        }\n\n        uint256 cost = data.price64x64.mulu(data.size);\n        ERC20.safeTransfer(msg.sender, cost);\n\n        emit OrderCanceled(epoch, id, msg.sender);\n    }\n\n    /**\n     * @inheritdoc IAuction\n     */\n    function addMarketOrder(\n        uint64 epoch,\n        uint256 size,\n        uint256 maxCost\n    ) external payable nonReentrant {\n        AuctionStorage.Layout storage l = AuctionStorage.layout();\n        AuctionStorage.Auction storage auction = l.auctions[epoch];\n\n        _marketOrdersAllowed(auction);\n\n        (int128 price64x64, uint256 cost) =\n            _validateMarketOrder(l, auction, size, maxCost);\n\n        uint256 credited = _wrapNativeToken(cost);\n        // an approve() by the msg.sender is required beforehand\n        ERC20.safeTransferFrom(msg.sender, address(this), cost - credited);\n        _addOrder(l, auction, epoch, price64x64, size, false);\n    }\n\n    /**\n     * @inheritdoc IAuction\n     */\n    function swapAndAddMarketOrder(\n        IExchangeHelper.SwapArgs calldata s,\n        uint64 epoch,\n        uint256 size,\n        uint256 maxCost\n    ) external payable nonReentrant {\n        AuctionStorage.Layout storage l = AuctionStorage.layout();\n        AuctionStorage.Auction storage auction = l.auctions[epoch];\n\n        _marketOrdersAllowed(auction);\n\n        (int128 price64x64, uint256 cost) =\n            _validateMarketOrder(l, auction, size, maxCost);\n\n        uint256 credited = _swapForPoolTokens(l.Exchange, s, address(ERC20));\n        _transferAssets(credited, cost, msg.sender);\n        _addOrder(l, auction, epoch, price64x64, size, false);\n    }\n\n    /************************************************\n     *  WITHDRAW\n     ***********************************************/\n\n    /**\n     * @inheritdoc IAuction\n     */\n    function withdraw(uint64 epoch) external nonReentrant {\n        AuctionStorage.Layout storage l = AuctionStorage.layout();\n        AuctionStorage.Auction storage auction = l.auctions[epoch];\n\n        require(\n            AuctionStorage.Status.PROCESSED == auction.status ||\n                AuctionStorage."
    }
  ]
}