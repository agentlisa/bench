{
  "Title": "[H-09] Repeated calls to `multiStakerClaim` in the same block leads to loss of funds",
  "Content": "\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L172-L210><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L185><br>\n\nA malicious user can repeatedly claim the same staker reward for an epoch, provided the transactions all happen in the same block. This can effectively be done using services like [Flashbots bundles](https://docs.flashbots.net/Flashbots-auction/searchers/faq/#can-you-give-a-step-by-step-description-of-how-flashbots-works-for-a-searcher-today) and will result in the draining of the WETH balance of the `RewardDistributor` contract.\n\nThe idea is to bypass the require statement [line 185](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L185) which checks if a claim has been already done for the epoch, **for a specific token ID**. By moving the locked tokens in a new lock, a new token ID will be generated and can be used to claim the rewards again, **if the transaction happens in the same block for which the epoch is updated**.\n\nIndeed, when `multiStakerClaim()` is called, the `rewardETH` will be calculated from the amount of tokens locked in `tokenids[tindex]` at the block that triggered the epoch change (variable `epochBeginTime`). If, during this time, an attacker transfers its staked tokens to a new vault using the [`merge`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L893) function of the VE token, the function will calculate the amount of staked tokens for the newly created tokenID **as the same as the original tokenID reward**.\n\nA example abuse will look like this (pseudo-code adapted from the PoC) :\n\n```javascript\nlockID = voteEscrow.create_lock(amount, 1 week); // Create lock #1 before\n// IN THE BLOCK OF EPOCH CHANGE\nrewardDistributor.multiStakerClaim([lockId], [0]); // Claim epoch 0 rewards for lock #1\nvoteEscrow.create_lock(1, 1 week); // Create lock #2 (requires 1 Golom token, could be created in advance)\nvoteEscrow.merge(lockId, lockId + 1); // Transfer lock #1 tokens to lock #2\nrewardDistributor.multiStakerClaim([lockId + 1], [0]); // Claim same epoch rewards for lock #2\n// repeat ...\n```\n\nTo abuse this, the attacker needs to follow this steps:\n\n*   Have some locked Golom tokens.\n*   Wait for a `addFee` call that will trigger an epoch change (this can be monitored by looking at the mempool or predicted from block timestamps). Services like Flashbots also [allows for specifying a range of blocks for bundles](https://docs.flashbots.net/Flashbots-auction/searchers/faq/#how-do-i-target-a-timestamp-range-instead-of-a-block-number-when-submitting-a-bundle) for better targeting.\n*   Send a bundle of transactions to be included with the block containing the epoch changing transaction (see the PoC for an example of transactions).\n\nNote that this needs to succeed only once to allow an attacker to drain all WETH funds so if the bundle isn't included for a particular epoch, given the frequency of epoch changes, the bundle will eventually be included and trigger the exploit.\n\n### Proof of Concept\n\nSee warden's [original submission](https://github.com/code-423n4/2022-07-golom-findings/issues/139) for full proof of concept.\n\n### Recommended Mitigation Steps\n\nI initially thought about a few possible solutions:\n\n*   Checking a lock creation time to prevent claiming from locks created in the same block **but the attacker can just create the blocks beforehand.**\n*   Tracking the `msg.sender` or `tx.origin` for preventing multiple calls to `multiStakerClaim` in the same block **but the attacker can just send transactions from different addresses.**\n*   Preventing the merging of locks **but the attacker can just create locks in advance and withdraw/add funds continuously between old/new locks.**\n\nNone really fixes the vulnerability as it comes from the feature of **locks being tradable** meaning it's not practically feasable to know if a lock has already be claimed by an individual **just by looking at the lock ID**.\n\nA possible solution would be to find a way to prevent multiple calls to the same function within a block or better, make a checkpoint of the locks balances for each `epochBeginTime` and uses these values for calculating the rewards (instead of querying the VE contract in the loop).\n\n**[0xsaruman (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/139)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/139#issuecomment-1237934237):**\n > Removed `merge()`<br>\n> Ref: https://github.com/golom-protocol/contracts/commit/b987077f2a227273bc7051e382bd55264162a77e\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-07-golom-contest",
  "Code": [
    {
      "filename": "contracts/rewards/RewardDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n// stores daily trades\n// is minter of token, first interaction mints tokens and distributes tokens\n// gives prorata tokens to traders and exchange daily\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport 'hardhat/console.sol';\n\ninterface ERC20 {\n    function totalSupply() external returns (uint256);\n\n    function balanceOf(address account) external returns (uint256);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function mint(address account, uint256 amount) external;\n\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    function deposit() external payable;\n}\n\ninterface VE {\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function totalSupplyAtT(uint256 t) external view returns (uint256);\n\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    function totalSupplyAt(uint256 _block) external view returns (uint256);\n\n    function balanceOfAtNFT(uint256 _tokenId, uint256 _block) external view returns (uint256);\n}\n\ncontract RewardDistributor is Ownable {\n    address public trader;\n    uint256 public epoch = 0;\n    uint256 public startTime; // timestamp at which the contracts need to be activated\n\n    uint256 constant dailyEmission = 600000 * 10**18;\n\n    address public pendingTrader;\n    uint256 public traderEnableDate;\n\n    address public pendingVoteEscrow;\n    uint256 public voteEscrowEnableDate;\n    VE public ve;\n\n    uint256 constant secsInDay = 24 * 60 * 60;\n    mapping(address => mapping(uint256 => uint256)) public feesTrader; // fees accumulated by address of trader per epoch\n    mapping(address => mapping(uint256 => uint256)) public feesExchange; // fees accumulated by exchange of trader per epoch\n    mapping(uint256 => uint256) public epochTotalFee; // total fee of epoch\n    mapping(uint256 => uint256) public rewardTrader; // reward minted each epoc for trader\n    mapping(uint256 => uint256) public rewardExchange; // reward minted each epoc for exhange\n    mapping(uint256 => uint256) public rewardLP; // reward minted each epoc for LP\n    mapping(uint256 => uint256) public rewardStaker; // reward minted each epoc for stakers\n    mapping(uint256 => uint256) public epochBeginTime; // what time previous epoch ended\n    mapping(uint256 => uint256) public claimedUpto; // epoch upto which tokenid has claimed\n    mapping(uint256 => mapping(uint256 => uint256)) public claimed; // epoch upto which tokenid has claimed\n    ERC20 public rewardToken;\n    ERC20 public weth;\n    event NewEpoch(uint256 indexed epochNo, uint256 tokenMinted, uint256 rewardStaker, uint256 previousEpochFee);\n\n    // epochs,trader, token\n\n    constructor(\n        address _weth,\n        address _trader,\n        address _token,\n        address _governance\n    ) {\n        weth = ERC20(_weth);\n        trader = _trader;\n        rewardToken = ERC20(_token);\n        _transferOwnership(_governance); // set the new owner\n        startTime = 1659211200;\n    }\n\n    modifier onlyTrader() {\n        require(msg.sender == trader);\n        _;\n    }\n\n    // at starttime epoch 1 starts , first trade changes epoch from 0 to 1 , emits tokens stores the rewards for epoch 1 ,\n    // after 1 day , first trade changes epoch from 1 to 2, changes eth in contract to weth and stores rewardstakedeth , emits tokens stores the rewards for epoch 2\n\n    /// @dev Add fees contributed by the Seller of nft and the exchange/frontend that facilated the trade\n    /// @param addr the address that contributed in fees\n    /// @param fee the fee contributed by these addresses\n    function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n        //console.log(block.timestamp,epoch,fee);\n        if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n            // if supply is greater then a billion dont mint anything, dont add trades\n            return;\n        }\n\n        // if 24 hours have passed since last epoch change\n        if (block.timestamp > startTime + (epoch) * secsInDay) {\n            // this assumes atleast 1 trade is done daily??????\n            // logic to decide how much token to emit\n            // emission = daily * (1 - (balance of locker/ total supply))  full if 0 locked and 0 if all locked\n            // uint256 tokenToEmit = dailyEmission * rewardToken.balanceOf()/\n            // emissions is decided by epoch begiining locked/circulating , and amount each nft gets also decided at epoch begining\n            uint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /\n                rewardToken.totalSupply();\n            uint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();\n            // deposit previous epoch fee to weth for distribution to stakers\n\n            uint256 previousEpochFee = epochTotalFee[epoch];\n            epoch = epoch + 1;\n            rewardStaker[epoch] = stakerReward;\n            rewardTrader[epoch] = ((tokenToEmit - stakerReward) * 67) / 100;\n            rewardExchange[epoch] = ((tokenToEmit - stakerReward) * 33) / 100;\n            rewardToken.mint(address(this), tokenToEmit);\n            epochBeginTime[epoch] = block.number;\n            if (previousEpochFee > 0) {\n                if (epoch == 1){\n                    epochTotalFee[0] =  address(this).balance; // staking and trading rewards start at epoch 1, for epoch 0 all contract ETH balance is converted to staker rewards rewards.\n                    weth.deposit{value: address(this).balance}();  \n                }else{\n                    weth.deposit{value: previousEpochFee}();\n                }\n            }\n            emit NewEpoch(epoch, tokenToEmit, stakerReward, previousEpochFee);\n        }\n        feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;\n        feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;\n        epochTotalFee[epoch] = epochTotalFee[epoch] + fee;\n        return;\n    }\n\n    // allows sellers of nft to claim there previous epoch rewards\n    function traderClaim(address addr, uint256[] memory epochs) public {\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epochs.length; index++) {\n            require(epochs[index] < epoch);\n            reward =\n                reward +\n                (rewardTrader[epochs[index]] * feesTrader[addr][epochs[index]]) /\n                epochTotalFee[epochs[index]];\n            feesTrader[addr][epochs[index]] = 0;\n        }\n        rewardToken.transfer(addr, reward);\n    }\n\n    // allows exchange that facilated the nft trades to claim there previous epoch rewards\n    function exchangeClaim(address addr, uint256[] memory epochs) public {\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epochs.length; index++) {\n            require(epochs[index] < epoch);\n            reward =\n                reward +\n                (rewardExchange[epochs[index]] * feesExchange[addr][epochs[index]]) /\n                epochTotalFee[epochs[index]];\n            feesExchange[addr][epochs[index]] = 0;\n        }\n        rewardToken.transfer(addr, reward);\n    }\n\n    /// @dev allows VeNFT holders to claim there token and eth rewards\n    ///      all tokenids must have a common owner\n    /// @param tokenids the nft ids to claim rewards for all ids in the list must belong to 1 address\n    /// @param epochs the list of epochs to claim rewards\n    function multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {\n        require(address(ve) != address(0), ' VE not added yet');\n\n        uint256 reward = 0;\n        uint256 rewardEth = 0;\n        address tokenowner = ve.ownerOf(tokenids[0]);\n\n        // for each tokenid\n        for (uint256 tindex = 0; tindex < tokenids.length; tindex++) {\n            require(tokenowner == ve.ownerOf(tokenids[tindex]), 'Can only claim for a single Address together');\n            // for each epoch\n            for (uint256 index = 0; index < epochs.length; index++) {\n                require(epochs[index] < epoch, 'cant claim for future epochs');\n                require(claimed[tokenids[tindex]][epochs[index]] == 0, 'cant claim if already claimed');\n                claimed[tokenids[tindex]][epochs[index]] = 1;\n                if (epochs[index] == 0){\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[0] *\n                            ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[1])) /\n                        ve.totalSupplyAt(epochBeginTime[1]);\n\n                }else{\n                    reward =\n                        reward +\n                        (rewardStaker[epochs[index]] * ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[epochs[index]])) /\n                        ve.totalSupplyAt(epochBeginTime[epochs[index]]);\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[epochs[index]] *\n                            ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[epochs[index]])) /\n                        ve.totalSupplyAt(epochBeginTime[epochs[index]]);\n                }\n\n            }\n        }\n        rewardToken.transfer(tokenowner, reward);\n        weth.transfer(tokenowner, rewardEth);\n    }\n\n\n    /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n    /// @param tokenid the nft id to claim rewards for all ids in the list must belong to 1 address\n    function stakerRewards(uint256 tokenid) public view returns (\n            uint256,\n            uint256,\n            uint256[] memory\n        ){\n        require(address(ve) != address(0), ' VE not added yet');\n\n        uint256 reward = 0;\n        uint256 rewardEth = 0;\n        uint256[] memory unclaimedepochs = new uint256[](epoch);\n        // for each epoch\n        for (uint256 index = 0; index < epoch; index++) {\n            unclaimedepochs[index]=claimed[tokenid][index];\n            if (claimed[tokenid][index] == 0){\n                if (index == 0){\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[0] *\n                            ve.balanceOfAtNFT(tokenid, epochBeginTime[1])) /\n                        ve.totalSupplyAt(epochBeginTime[1]);\n\n                }else{\n                    reward =\n                        reward +\n                        (rewardStaker[index] * ve.balanceOfAtNFT(tokenid, epochBeginTime[index])) /\n                        ve.totalSupplyAt(epochBeginTime[index]);\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[index] *\n                            ve.balanceOfAtNFT(tokenid, epochBeginTime[index])) /\n                        ve.totalSupplyAt(epochBeginTime[index]);\n                }\n            }\n        }\n        return (reward, rewardEth, unclaimedepochs);\n    }\n\n    /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n    /// @param addr the nft id to claim rewards for all ids in the list must belong to 1 address\n    function traderRewards(address addr) public view returns (\n            uint256        \n            ){\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epoch; index++) {\n            reward =\n                reward +\n                (rewardTrader[index] * feesTrader[addr][index]) /\n                epochTotalFee[index];\n        }\n        return (reward);\n    }\n\n    /// @dev returns unclaimed golom rewards of a trader\n    /// @param addr the nft id to claim rewards for all ids in the list must belong to 1 address\n    function exchangeRewards(address addr) public view returns (\n            uint256\n        ){\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epoch; index++) {\n            reward =\n                reward +\n                (rewardExchange[index] * feesExchange[addr][index]) /\n                epochTotalFee[index];\n        }\n        return (reward);\n    }\n\n    /// @notice Changes the trader address with timelock\n    /// @dev executeChangeTrader needs to be called after 1 days\n    /// @param _trader New trader address\n    function changeTrader(address _trader) external onlyOwner {\n        traderEnableDate = block.timestamp + 1 days;\n        pendingTrader = _trader;\n    }\n\n    /// @notice Execute's the change trader function\n    function executeChangeTrader() external onlyOwner {\n        require(traderEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n        trader = pendingTrader;\n    }\n\n    /// @notice Adds vote escrow contract for multi staker claim\n    /// @param _voteEscrow Address of the voteEscrow contract\n    function addVoteEscrow(address _voteEscrow) external onlyOwner {\n        if (address(ve) == address(0)) {\n            ve = VE(pendingVoteEscrow);\n        } else {\n            voteEscrowEnableDate = block.timestamp + 1 days;\n            pendingVoteEscrow = _voteEscrow;\n        }\n    }\n\n    /// @notice Adds vote escrow contract for multi staker claim\n    function executeAddVoteEscrow() external onlyOwner {\n        require(voteEscrowEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n        ve = VE(pendingVoteEscrow);\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/rewards/RewardDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n// stores daily trades\n// is minter of token, first interaction mints tokens and distributes tokens\n// gives prorata tokens to traders and exchange daily\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport 'hardhat/console.sol';\n\ninterface ERC20 {\n    function totalSupply() external returns (uint256);\n\n    function balanceOf(address account) external returns (uint256);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function mint(address account, uint256 amount) external;\n\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    function deposit() external payable;\n}\n\ninterface VE {\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function totalSupplyAtT(uint256 t) external view returns (uint256);\n\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    function totalSupplyAt(uint256 _block) external view returns (uint256);\n\n    function balanceOfAtNFT(uint256 _tokenId, uint256 _block) external view returns (uint256);\n}\n\ncontract RewardDistributor is Ownable {\n    address public trader;\n    uint256 public epoch = 0;\n    uint256 public startTime; // timestamp at which the contracts need to be activated\n\n    uint256 constant dailyEmission = 600000 * 10**18;\n\n    address public pendingTrader;\n    uint256 public traderEnableDate;\n\n    address public pendingVoteEscrow;\n    uint256 public voteEscrowEnableDate;\n    VE public ve;\n\n    uint256 constant secsInDay = 24 * 60 * 60;\n    mapping(address => mapping(uint256 => uint256)) public feesTrader; // fees accumulated by address of trader per epoch\n    mapping(address => mapping(uint256 => uint256)) public feesExchange; // fees accumulated by exchange of trader per epoch\n    mapping(uint256 => uint256) public epochTotalFee; // total fee of epoch\n    mapping(uint256 => uint256) public rewardTrader; // reward minted each epoc for trader\n    mapping(uint256 => uint256) public rewardExchange; // reward minted each epoc for exhange\n    mapping(uint256 => uint256) public rewardLP; // reward minted each epoc for LP\n    mapping(uint256 => uint256) public rewardStaker; // reward minted each epoc for stakers\n    mapping(uint256 => uint256) public epochBeginTime; // what time previous epoch ended\n    mapping(uint256 => uint256) public claimedUpto; // epoch upto which tokenid has claimed\n    mapping(uint256 => mapping(uint256 => uint256)) public claimed; // epoch upto which tokenid has claimed\n    ERC20 public rewardToken;\n    ERC20 public weth;\n    event NewEpoch(uint256 indexed epochNo, uint256 tokenMinted, uint256 rewardStaker, uint256 previousEpochFee);\n\n    // epochs,trader, token\n\n    constructor(\n        address _weth,\n        address _trader,\n        address _token,\n        address _governance\n    ) {\n        weth = ERC20(_weth);\n        trader = _trader;\n        rewardToken = ERC20(_token);\n        _transferOwnership(_governance); // set the new owner\n        startTime = 1659211200;\n    }\n\n    modifier onlyTrader() {\n        require(msg.sender == trader);\n        _;\n    }\n\n    // at starttime epoch 1 starts , first trade changes epoch from 0 to 1 , emits tokens stores the rewards for epoch 1 ,\n    // after 1 day , first trade changes epoch from 1 to 2, changes eth in contract to weth and stores rewardstakedeth , emits tokens stores the rewards for epoch 2\n\n    /// @dev Add fees contributed by the Seller of nft and the exchange/frontend that facilated the trade\n    /// @param addr the address that contributed in fees\n    /// @param fee the fee contributed by these addresses\n    function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n        //console.log(block.timestamp,epoch,fee);\n        if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n            // if supply is greater then a billion dont mint anything, dont add trades\n            return;\n        }\n\n        // if 24 hours have passed since last epoch change\n        if (block.timestamp > startTime + (epoch) * secsInDay) {\n            // this assumes atleast 1 trade is done daily??????\n            // logic to decide how much token to emit\n            // emission = daily * (1 - (balance of locker/ total supply))  full if 0 locked and 0 if all locked\n            // uint256 tokenToEmit = dailyEmission * rewardToken.balanceOf()/\n            // emissions is decided by epoch begiining locked/circulating , and amount each nft gets also decided at epoch begining\n            uint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /\n                rewardToken.totalSupply();\n            uint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();\n            // deposit previous epoch fee to weth for distribution to stakers\n\n            uint256 previousEpochFee = epochTotalFee[epoch];\n            epoch = epoch + 1;\n            rewardStaker[epoch] = stakerReward;\n            rewardTrader[epoch] = ((tokenToEmit - stakerReward) * 67) / 100;\n            rewardExchange[epoch] = ((tokenToEmit - stakerReward) * 33) / 100;\n            rewardToken.mint(address(this), tokenToEmit);\n            epochBeginTime[epoch] = block.number;\n            if (previousEpochFee > 0) {\n                if (epoch == 1){\n                    epochTotalFee[0] =  address(this).balance; // staking and trading rewards start at epoch 1, for epoch 0 all contract ETH balance is converted to staker rewards rewards.\n                    weth.deposit{value: address(this).balance}();  \n                }else{\n                    weth.deposit{value: previousEpochFee}();\n                }\n            }\n            emit NewEpoch(epoch, tokenToEmit, stakerReward, previousEpochFee);\n        }\n        feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;\n        feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;\n        epochTotalFee[epoch] = epochTotalFee[epoch] + fee;\n        return;\n    }\n\n    // allows sellers of nft to claim there previous epoch rewards\n    function traderClaim(address addr, uint256[] memory epochs) public {\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epochs.length; index++) {\n            require(epochs[index] < epoch);\n            reward =\n                reward +\n                (rewardTrader[epochs[index]] * feesTrader[addr][epochs[index]]) /\n                epochTotalFee[epochs[index]];\n            feesTrader[addr][epochs[index]] = 0;\n        }\n        rewardToken.transfer(addr, reward);\n    }\n\n    // allows exchange that facilated the nft trades to claim there previous epoch rewards\n    function exchangeClaim(address addr, uint256[] memory epochs) public {\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epochs.length; index++) {\n            require(epochs[index] < epoch);\n            reward =\n                reward +\n                (rewardExchange[epochs[index]] * feesExchange[addr][epochs[index]]) /\n                epochTotalFee[epochs[index]];\n            feesExchange[addr][epochs[index]] = 0;\n        }\n        rewardToken.transfer(addr, reward);\n    }\n\n    /// @dev allows VeNFT holders to claim there token and eth rewards\n    ///      all tokenids must have a common owner\n    /// @param tokenids the nft ids to claim rewards for all ids in the list must belong to 1 address\n    /// @param epochs the list of epochs to claim rewards\n    function multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {\n        require(address(ve) != address(0), ' VE not added yet');\n\n        uint256 reward = 0;\n        uint256 rewardEth = 0;\n        address tokenowner = ve.ownerOf(tokenids[0]);\n\n        // for each tokenid\n        for (uint256 tindex = 0; tindex < tokenids.length; tindex++) {\n            require(tokenowner == ve.ownerOf(tokenids[tindex]), 'Can only claim for a single Address together');\n            // for each epoch\n            for (uint256 index = 0; index < epochs.length; index++) {\n                require(epochs[index] < epoch, 'cant claim for future epochs');\n                require(claimed[tokenids[tindex]][epochs[index]] == 0, 'cant claim if already claimed');\n                claimed[tokenids[tindex]][epochs[index]] = 1;\n                if (epochs[index] == 0){\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[0] *\n                            ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[1])) /\n                        ve.totalSupplyAt(epochBeginTime[1]);\n\n                }else{\n                    reward =\n                        reward +\n                        (rewardStaker[epochs[index]] * ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[epochs[index]])) /\n                        ve.totalSupplyAt(epochBeginTime[epochs[index]]);\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[epochs[index]] *\n                            ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[epochs[index]])) /\n                        ve.totalSupplyAt(epochBeginTime[epochs[index]]);\n                }\n\n            }\n        }\n        rewardToken.transfer(tokenowner, reward);\n        weth.transfer(tokenowner, rewardEth);\n    }\n\n\n    /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n    /// @param tokenid the nft id to claim rewards for all ids in the list must belong to 1 address\n    function stakerRewards(uint256 tokenid) public view returns (\n            uint256,\n            uint256,\n            uint256[] memory\n        ){\n        require(address(ve) != address(0), ' VE not added yet');\n\n        uint256 reward = 0;\n        uint256 rewardEth = 0;\n        uint256[] memory unclaimedepochs = new uint256[](epoch);\n        // for each epoch\n        for (uint256 index = 0; index < epoch; index++) {\n            unclaimedepochs[index]=claimed[tokenid][index];\n            if (claimed[tokenid][index] == 0){\n                if (index == 0){\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[0] *\n                            ve.balanceOfAtNFT(tokenid, epochBeginTime[1])) /\n                        ve.totalSupplyAt(epochBeginTime[1]);\n\n                }else{\n                    reward =\n                        reward +\n                        (rewardStaker[index] * ve.balanceOfAtNFT(tokenid, epochBeginTime[index])) /\n                        ve.totalSupplyAt(epochBeginTime[index]);\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[index] *\n                            ve.balanceOfAtNFT(tokenid, epochBeginTime[index])) /\n                        ve.totalSupplyAt(epochBeginTime[index]);\n                }\n            }\n        }\n        return (reward, rewardEth, unclaimedepochs);\n    }\n\n    /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n    /// @param addr the nft id to claim rewards for all ids in the list must belong to 1 address\n    function traderRewards(address addr) public view returns (\n            uint256        \n            ){\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epoch; index++) {\n            reward =\n                reward +\n                (rewardTrader[index] * feesTrader[addr][index]) /\n                epochTotalFee[index];\n        }\n        return (reward);\n    }\n\n    /// @dev returns unclaimed golom rewards of a trader\n    /// @param addr the nft id to claim rewards for all ids in the list must belong to 1 address\n    function exchangeRewards(address addr) public view returns (\n            uint256\n        ){\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epoch; index++) {\n            reward =\n                reward +\n                (rewardExchange[index] * feesExchange[addr][index]) /\n                epochTotalFee[index];\n        }\n        return (reward);\n    }\n\n    /// @notice Changes the trader address with timelock\n    /// @dev executeChangeTrader needs to be called after 1 days\n    /// @param _trader New trader address\n    function changeTrader(address _trader) external onlyOwner {\n        traderEnableDate = block.timestamp + 1 days;\n        pendingTrader = _trader;\n    }\n\n    /// @notice Execute's the change trader function\n    function executeChangeTrader() external onlyOwner {\n        require(traderEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n        trader = pendingTrader;\n    }\n\n    /// @notice Adds vote escrow contract for multi staker claim\n    /// @param _voteEscrow Address of the voteEscrow contract\n    function addVoteEscrow(address _voteEscrow) external onlyOwner {\n        if (address(ve) == address(0)) {\n            ve = VE(pendingVoteEscrow);\n        } else {\n            voteEscrowEnableDate = block.timestamp + 1 days;\n            pendingVoteEscrow = _voteEscrow;\n        }\n    }\n\n    /// @notice Adds vote escrow contract for multi staker claim\n    function executeAddVoteEscrow() external onlyOwner {\n        require(voteEscrowEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n        ve = VE(pendingVoteEscrow);\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/rewards/RewardDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n// stores daily trades\n// is minter of token, first interaction mints tokens and distributes tokens\n// gives prorata tokens to traders and exchange daily\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport 'hardhat/console.sol';\n\ninterface ERC20 {\n    function totalSupply() external returns (uint256);\n\n    function balanceOf(address account) external returns (uint256);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function mint(address account, uint256 amount) external;\n\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    function deposit() external payable;\n}\n\ninterface VE {\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function totalSupplyAtT(uint256 t) external view returns (uint256);\n\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    function totalSupplyAt(uint256 _block) external view returns (uint256);\n\n    function balanceOfAtNFT(uint256 _tokenId, uint256 _block) external view returns (uint256);\n}\n\ncontract RewardDistributor is Ownable {\n    address public trader;\n    uint256 public epoch = 0;\n    uint256 public startTime; // timestamp at which the contracts need to be activated\n\n    uint256 constant dailyEmission = 600000 * 10**18;\n\n    address public pendingTrader;\n    uint256 public traderEnableDate;\n\n    address public pendingVoteEscrow;\n    uint256 public voteEscrowEnableDate;\n    VE public ve;\n\n    uint256 constant secsInDay = 24 * 60 * 60;\n    mapping(address => mapping(uint256 => uint256)) public feesTrader; // fees accumulated by address of trader per epoch\n    mapping(address => mapping(uint256 => uint256)) public feesExchange; // fees accumulated by exchange of trader per epoch\n    mapping(uint256 => uint256) public epochTotalFee; // total fee of epoch\n    mapping(uint256 => uint256) public rewardTrader; // reward minted each epoc for trader\n    mapping(uint256 => uint256) public rewardExchange; // reward minted each epoc for exhange\n    mapping(uint256 => uint256) public rewardLP; // reward minted each epoc for LP\n    mapping(uint256 => uint256) public rewardStaker; // reward minted each epoc for stakers\n    mapping(uint256 => uint256) public epochBeginTime; // what time previous epoch ended\n    mapping(uint256 => uint256) public claimedUpto; // epoch upto which tokenid has claimed\n    mapping(uint256 => mapping(uint256 => uint256)) public claimed; // epoch upto which tokenid has claimed\n    ERC20 public rewardToken;\n    ERC20 public weth;\n    event NewEpoch(uint256 indexed epochNo, uint256 tokenMinted, uint256 rewardStaker, uint256 previousEpochFee);\n\n    // epochs,trader, token\n\n    constructor(\n        address _weth,\n        address _trader,\n        address _token,\n        address _governance\n    ) {\n        weth = ERC20(_weth);\n        trader = _trader;\n        rewardToken = ERC20(_token);\n        _transferOwnership(_governance); // set the new owner\n        startTime = 1659211200;\n    }\n\n    modifier onlyTrader() {\n        require(msg.sender == trader);\n        _;\n    }\n\n    // at starttime epoch 1 starts , first trade changes epoch from 0 to 1 , emits tokens stores the rewards for epoch 1 ,\n    // after 1 day , first trade changes epoch from 1 to 2, changes eth in contract to weth and stores rewardstakedeth , emits tokens stores the rewards for epoch 2\n\n    /// @dev Add fees contributed by the Seller of nft and the exchange/frontend that facilated the trade\n    /// @param addr the address that contributed in fees\n    /// @param fee the fee contributed by these addresses\n    function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n        //console.log(block.timestamp,epoch,fee);\n        if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n            // if supply is greater then a billion dont mint anything, dont add trades\n            return;\n        }\n\n        // if 24 hours have passed since last epoch change\n        if (block.timestamp > startTime + (epoch) * secsInDay) {\n            // this assumes atleast 1 trade is done daily??????\n            // logic to decide how much token to emit\n            // emission = daily * (1 - (balance of locker/ total supply))  full if 0 locked and 0 if all locked\n            // uint256 tokenToEmit = dailyEmission * rewardToken.balanceOf()/\n            // emissions is decided by epoch begiining locked/circulating , and amount each nft gets also decided at epoch begining\n            uint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /\n                rewardToken.totalSupply();\n            uint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();\n            // deposit previous epoch fee to weth for distribution to stakers\n\n            uint256 previousEpochFee = epochTotalFee[epoch];\n            epoch = epoch + 1;\n            rewardStaker[epoch] = stakerReward;\n            rewardTrader[epoch] = ((tokenToEmit - stakerReward) * 67) / 100;\n            rewardExchange[epoch] = ((tokenToEmit - stakerReward) * 33) / 100;\n            rewardToken.mint(address(this), tokenToEmit);\n            epochBeginTime[epoch]"
    }
  ]
}