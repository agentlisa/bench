{
  "Title": "[M-05] Losing fund during force deployment",
  "Content": "\nDuring force deployment, if the fund is not properly transferred to the to-be-force-deployed contract, the fund will remain in the contract `ContractDeployer` and can not easily be recovered.\n\n### Proof of Concept\n\nThe function `forceDeployOnAddresses` in contract `ContractDeployer` is used only during an upgrade to set bytecodes on specific addresses.<br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L232>\n\nThe ETH sent to this function will be used to initialize to-be-force-deployed contracts. The ETH sent should be equal to the aggregated value needed for each contract.<br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L240>\n\nThen the function externally calls itself, and send the required value to itself.<br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L245>\n\nIf any of this call is unsuccessful, the whole transaction will not revert, and the loop continues to deploy all the contract on the provided `newAddress`.\n\nIf for any reason, the deployment was not successful, the transferred ETH will remain in `ContractDeployer`, and can not be used for the next deployments (because the aggregated amount is compared with `msg.value` not the ETH balance of the contract). In other words, `FORCE_DEPLOYER` fund will be in `ContractDeployer`, and it can not be easily recoverred.\n\nThe possibility of unsuccessful deployment is not low:\n\nIt can happen if the bytecode is not known already.<br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L213><br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L296>\n\nIt can happen during storing constructing bytecode hash.<br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L214><br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/AccountCodeStorage.sol#L36>\n\nIt can happen during constructing contract and transferring the value.<br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L223>\n\n### Recommended Mitigation Steps\n\nBy using try/catch, the fund can be transferred to an address that the governor has control to be used later.\n\n    function forceDeployOnAddresses(ForceDeployment[] calldata _deployments)\n            external\n            payable\n        {\n            // remaining of the code\n\n            for (uint256 i = 0; i < deploymentsLength; ++i) {\n                try\n                    this.forceDeployOnAddress{value: _deployments[i].value}(\n                        _deployments[i],\n                        msg.sender\n                    )\n                {} catch {\n                    ETH_TOKEN_SYSTEM_CONTRACT.transferFromTo(\n                        address(this),\n                        SomeAddress,\n                        _deployments[i].value\n                    );\n                }\n            }\n        }\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/64#issuecomment-1482499007):**\n > Loss of funds due to reverts, keeping separate for now.\n>\n > See [#95](https://github.com/code-423n4/2023-03-zksync-findings/issues/95) for loss of value due to not calling constructor.\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/64#issuecomment-1485063467):**\n > The goal was to force deploy multiple of contracts (especially system contracts during the upgrade). If any deployment was unsuccessful, the whole transaction should not be reverted. So, the fund reverted during the failed deployment should be transferred to a valid address (not stay in `ContractDeployer`) as suggested by the warden. The recommended mitigation is also good.\n> \n> Severity is **Medium**.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/64#issuecomment-1497447273):**\n > Per the Sponsor's comment, the Warden has shown how, due to a lack of sweep on revert, funds sent in a sequence of multiple deployments can be lost when one of the deployment fails.\n> \n> This is in contrast to having the entire deployment reverting.\n> \n> Because the behavior is unintended and funds can be lost conditionally on a revert, I believe Medium Severity to be appropriate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-03-zksync",
  "Code": [
    {
      "filename": "contracts/ContractDeployer.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ImmutableData} from \"./interfaces/IImmutableSimulator.sol\";\nimport \"./interfaces/IContractDeployer.sol\";\nimport {CREATE2_PREFIX, CREATE_PREFIX, NONCE_HOLDER_SYSTEM_CONTRACT, ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT, FORCE_DEPLOYER, MAX_SYSTEM_CONTRACT_ADDRESS, KNOWN_CODE_STORAGE_CONTRACT, ETH_TOKEN_SYSTEM_CONTRACT, IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT} from \"./Constants.sol\";\n\nimport \"./libraries/Utils.sol\";\nimport \"./libraries/EfficientCall.sol\";\nimport {SystemContractHelper, ISystemContract} from \"./libraries/SystemContractHelper.sol\";\n\n/**\n * @author Matter Labs\n * @notice System smart contract that is responsible for deploying other smart contracts on zkSync.\n * @dev The contract is responsible for generating the address of the deployed smart contract,\n * incrementing the deployment nonce and making sure that the constructor is never called twice in a contract.\n * Note, contracts with bytecode that have already been published to L1 once\n * do not need to be published anymore.\n */\ncontract ContractDeployer is IContractDeployer, ISystemContract {\n    /// @notice Information about an account contract.\n    /// @dev For EOA and simple contracts (i.e. not accounts) this value is 0.\n    mapping(address => AccountInfo) internal _accountInfo;\n\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"Callable only by self\");\n        _;\n    }\n\n    /// @notice Returns information about a certain account.\n    function getAccountInfo(address _address) external view returns (AccountInfo memory info) {\n        return _accountInfo[_address];\n    }\n\n    /// @notice Returns the account abstraction version if `_address` is a deployed contract.\n    /// Returns the latest supported account abstraction version if `_address` is an EOA.\n    function extendedAccountVersion(address _address) public view returns (AccountAbstractionVersion) {\n        AccountInfo memory info = _accountInfo[_address];\n        if (info.supportedAAVersion != AccountAbstractionVersion.None) {\n            return info.supportedAAVersion;\n        }\n\n        // It is an EOA, it is still an account.\n        if (ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.getRawCodeHash(_address) == 0) {\n            return AccountAbstractionVersion.Version1;\n        }\n\n        return AccountAbstractionVersion.None;\n    }\n\n    /// @notice Stores the new account information\n    function _storeAccountInfo(address _address, AccountInfo memory _newInfo) internal {\n        _accountInfo[_address] = _newInfo;\n    }\n\n    /// @notice Update the used version of the account.\n    /// @param _version The new version of the AA protocol to use.\n    /// @dev Note that it allows changes from account to non-account and vice versa.\n    function updateAccountVersion(AccountAbstractionVersion _version) external onlySystemCall {\n        _accountInfo[msg.sender].supportedAAVersion = _version;\n\n        emit AccountVersionUpdated(msg.sender, _version);\n    }\n\n    /// @notice Updates the nonce ordering of the account. Currently,\n    /// it only allows changes from sequential to arbitrary ordering.\n    /// @param _nonceOrdering The new nonce ordering to use.\n    function updateNonceOrdering(AccountNonceOrdering _nonceOrdering) external onlySystemCall {\n        AccountInfo memory currentInfo = _accountInfo[msg.sender];\n\n        require(\n            _nonceOrdering == AccountNonceOrdering.Arbitrary &&\n                currentInfo.nonceOrdering == AccountNonceOrdering.Sequential,\n            \"It is only possible to change from sequential to arbitrary ordering\"\n        );\n\n        currentInfo.nonceOrdering = _nonceOrdering;\n        _storeAccountInfo(msg.sender, currentInfo);\n\n        emit AccountNonceOrderingUpdated(msg.sender, _nonceOrdering);\n    }\n\n    /// @notice Calculates the address of a deployed contract via create2\n    /// @param _sender The account that deploys the contract.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _salt The create2 salt.\n    /// @param _input The constructor data.\n    /// @return newAddress The derived address of the account.\n    function getNewAddressCreate2(\n        address _sender,\n        bytes32 _bytecodeHash,\n        bytes32 _salt,\n        bytes calldata _input\n    ) public view override returns (address newAddress) {\n        // No collision is possible with the Ethereum's CREATE2, since\n        // the prefix begins with 0x20....\n        bytes32 constructorInputHash = EfficientCall.keccak(_input);\n\n        bytes32 hash = keccak256(\n            bytes.concat(CREATE2_PREFIX, bytes32(uint256(uint160(_sender))), _salt, _bytecodeHash, constructorInputHash)\n        );\n\n        newAddress = address(uint160(uint256(hash)));\n    }\n\n    /// @notice Calculates the address of a deployed contract via create\n    /// @param _sender The account that deploys the contract.\n    /// @param _senderNonce The deploy nonce of the sender's account.\n    function getNewAddressCreate(\n        address _sender,\n        uint256 _senderNonce\n    ) public pure override returns (address newAddress) {\n        // No collision is possible with the Ethereum's CREATE, since\n        // the prefix begins with 0x63....\n        bytes32 hash = keccak256(\n            bytes.concat(CREATE_PREFIX, bytes32(uint256(uint160(_sender))), bytes32(_senderNonce))\n        );\n\n        newAddress = address(uint160(uint256(hash)));\n    }\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The CREATE2 salt\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata\n    /// @dev In case of a revert, the zero address should be returned.\n    function create2(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable override returns (address) {\n        return create2Account(_salt, _bytecodeHash, _input, AccountAbstractionVersion.None);\n    }\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE` opcode.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata\n    /// @dev This method also accepts nonce as one of its parameters.\n    /// It is not used anywhere and it needed simply for the consistency for the compiler\n    /// @dev In case of a revert, the zero address should be returned.\n    /// Note: this method may be callable only in system mode,\n    /// that is checked in the `createAccount` by `onlySystemCall` modifier.\n    function create(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable override returns (address) {\n        return createAccount(_salt, _bytecodeHash, _input, AccountAbstractionVersion.None);\n    }\n\n    /// @notice Deploys a contract account with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The CREATE2 salt\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    /// @param _aaVersion The account abstraction version to use.\n    /// @dev In case of a revert, the zero address should be returned.\n    /// Note: this method may be callable only in system mode,\n    /// that is checked in the `createAccount` by `onlySystemCall` modifier.\n    function create2Account(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) public payable override onlySystemCall returns (address) {\n        NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n        address newAddress = getNewAddressCreate2(msg.sender, _bytecodeHash, _salt, _input);\n\n        _nonSystemDeployOnAddress(_bytecodeHash, newAddress, _aaVersion, _input);\n\n        return newAddress;\n    }\n\n    /// @notice Deploys a contract account with similar address derivation rules to the EVM's `CREATE` opcode.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    /// @param _aaVersion The account abstraction version to use.\n    /// @dev This method also accepts salt as one of its parameters.\n    /// It is not used anywhere and it needed simply for the consistency for the compiler\n    /// @dev In case of a revert, the zero address should be returned.\n    function createAccount(\n        bytes32, // salt\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) public payable override onlySystemCall returns (address) {\n        uint256 senderNonce = NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n        address newAddress = getNewAddressCreate(msg.sender, senderNonce);\n\n        _nonSystemDeployOnAddress(_bytecodeHash, newAddress, _aaVersion, _input);\n\n        return newAddress;\n    }\n\n    /// @notice A struct that describes a forced deployment on an address\n    struct ForceDeployment {\n        // The bytecode hash to put on an address\n        bytes32 bytecodeHash;\n        // The address on which to deploy the bytecodehash to\n        address newAddress;\n        // Whether to run the constructor on the force deployment\n        bool callConstructor;\n        // The value with which to initialize a contract\n        uint256 value;\n        // The constructor calldata\n        bytes input;\n    }\n\n    /// @notice The method that can be used to forcefully deploy a contract.\n    /// @param _deployment Information about the forced deployment.\n    /// @param _sender The `msg.sender` inside the constructor call.\n    function forceDeployOnAddress(ForceDeployment calldata _deployment, address _sender) external payable onlySelf {\n        _ensureBytecodeIsKnown(_deployment.bytecodeHash);\n        _storeConstructingByteCodeHashOnAddress(_deployment.newAddress, _deployment.bytecodeHash);\n\n        AccountInfo memory newAccountInfo;\n        newAccountInfo.supportedAAVersion = AccountAbstractionVersion.None;\n        // Accounts have sequential nonces by default.\n        newAccountInfo.nonceOrdering = AccountNonceOrdering.Sequential;\n        _storeAccountInfo(_deployment.newAddress, newAccountInfo);\n\n        if (_deployment.callConstructor) {\n            _constructContract(_sender, _deployment.newAddress, _deployment.input, false);\n        }\n\n        emit ContractDeployed(_sender, _deployment.bytecodeHash, _deployment.newAddress);\n    }\n\n    /// @notice This method is to be used only during an upgrade to set bytecodes on specific addresses.\n    /// @dev We do not require `onlySystemCall` here, since the method is accessible only\n    /// by `FORCE_DEPLOYER`.\n    function forceDeployOnAddresses(ForceDeployment[] calldata _deployments) external payable {\n        require(msg.sender == FORCE_DEPLOYER, \"Can only be called by FORCE_DEPLOYER_CONTRACT\");\n\n        uint256 deploymentsLength = _deployments.length;\n        // We need to ensure that the `value` provided by the call is enough to provide `value`\n        // for all of the deployments\n        uint256 sumOfValues = 0;\n        for (uint256 i = 0; i < deploymentsLength; ++i) {\n            sumOfValues += _deployments[i].value;\n        }\n        require(msg.value == sumOfValues, \"`value` provided is not equal to the combined `value`s of deployments\");\n\n        for (uint256 i = 0; i < deploymentsLength; ++i) {\n            this.forceDeployOnAddress{value: _deployments[i].value}(_deployments[i], msg.sender);\n        }\n    }\n\n    function _nonSystemDeployOnAddress(\n        bytes32 _bytecodeHash,\n        address _newAddress,\n        AccountAbstractionVersion _aaVersion,\n        bytes calldata _input\n    ) internal {\n        require(_bytecodeHash != bytes32(0x0), \"BytecodeHash can not be zero\");\n        require(uint160(_newAddress) > MAX_SYSTEM_CONTRACT_ADDRESS, \"Can not deploy contracts in kernel space\");\n\n        // We do not allow deploying twice on the same address.\n        require(\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.getCodeHash(uint256(uint160(_newAddress))) == 0x0,\n            \"Code hash is non-zero\"\n        );\n        // Do not allow deploying contracts to default accounts that have already executed transactions.\n        require(NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(_newAddress) == 0x00, \"Account is occupied\");\n\n        _performDeployOnAddress(_bytecodeHash, _newAddress, _aaVersion, _input);\n    }\n\n    /// @notice Deploy a certain bytecode on the address.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _newAddress The address of the contract to be deployed.\n    /// @param _aaVersion The version of the account abstraction protocol to use.\n    /// @param _input The constructor calldata.\n    function _performDeployOnAddress(\n        bytes32 _bytecodeHash,\n        address _newAddress,\n        AccountAbstractionVersion _aaVersion,\n        bytes calldata _input\n    ) internal {\n        _ensureBytecodeIsKnown(_bytecodeHash);\n        _storeConstructingByteCodeHashOnAddress(_newAddress, _bytecodeHash);\n\n        AccountInfo memory newAccountInfo;\n        newAccountInfo.supportedAAVersion = _aaVersion;\n        // Accounts have sequential nonces by default.\n        newAccountInfo.nonceOrdering = AccountNonceOrdering.Sequential;\n        _storeAccountInfo(_newAddress, newAccountInfo);\n\n        _constructContract(msg.sender, _newAddress, _input, false);\n        emit ContractDeployed(msg.sender, _bytecodeHash, _newAddress);\n    }\n\n    /// @notice Check that bytecode hash is marked as known on the `KnownCodeStorage` system contracts\n    function _ensureBytecodeIsKnown(bytes32 _bytecodeHash) internal view {\n        uint256 knownCodeMarker = KNOWN_CODE_STORAGE_CONTRACT.getMarker(_bytecodeHash);\n        require(knownCodeMarker > 0, \"The code hash is not known\");\n    }\n\n    /// @notice Ensures that the _newAddress and assigns a new contract hash to it\n    /// @param _newAddress The address of the deployed contract\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    function _storeConstructingByteCodeHashOnAddress(address _newAddress, bytes32 _bytecodeHash) internal {\n        // Set the \"isConstructor\" flag to the bytecode hash\n        bytes32 constructingBytecodeHash = Utils.constructingBytecodeHash(_bytecodeHash);\n        ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.storeAccountConstructingCodeHash(_newAddress, constructingBytecodeHash);\n    }\n\n    /// @notice Transfers the `msg.value` ETH to the deployed account & invokes its constructor.\n    /// This function must revert in case the deployment fails.\n    /// @param _sender The msg.sender to be used in the constructor\n    /// @param _newAddress The address of the deployed contract\n    /// @param _input The constructor calldata\n    /// @param _isSystem Whether the call should be a system call (could be possibly required in the future).\n    function _constructContract(address _sender, address _newAddress, bytes calldata _input, bool _isSystem) internal {\n        // Transfer the balance to the new address on the constructor call.\n        uint256 value = msg.value;\n        if (value > 0) {\n            ETH_TOKEN_SYSTEM_CONTRACT.transferFromTo(address(this), _newAddress, value);\n            // Safe to cast value, because `msg.value` <= `uint128.max` due to `MessageValueSimulator` invariant\n            SystemContractHelper.setValueForNextFarCall(uint128(value));\n        }\n\n        bytes memory returnData = EfficientCall.mimicCall(gasleft(), _newAddress, _input, _sender, true, _isSystem);\n        ImmutableData[] memory immutables = abi.decode(returnData, (ImmutableData[]));\n        IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT.setImmutables(_newAddress, immutables);\n        ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.markAccountCodeHashAsConstructed(_newAddress);\n    }\n}"
    },
    {
      "filename": "contracts/ContractDeployer.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ImmutableData} from \"./interfaces/IImmutableSimulator.sol\";\nimport \"./interfaces/IContractDeployer.sol\";\nimport {CREATE2_PREFIX, CREATE_PREFIX, NONCE_HOLDER_SYSTEM_CONTRACT, ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT, FORCE_DEPLOYER, MAX_SYSTEM_CONTRACT_ADDRESS, KNOWN_CODE_STORAGE_CONTRACT, ETH_TOKEN_SYSTEM_CONTRACT, IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT} from \"./Constants.sol\";\n\nimport \"./libraries/Utils.sol\";\nimport \"./libraries/EfficientCall.sol\";\nimport {SystemContractHelper, ISystemContract} from \"./libraries/SystemContractHelper.sol\";\n\n/**\n * @author Matter Labs\n * @notice System smart contract that is responsible for deploying other smart contracts on zkSync.\n * @dev The contract is responsible for generating the address of the deployed smart contract,\n * incrementing the deployment nonce and making sure that the constructor is never called twice in a contract.\n * Note, contracts with bytecode that have already been published to L1 once\n * do not need to be published anymore.\n */\ncontract ContractDeployer is IContractDeployer, ISystemContract {\n    /// @notice Information about an account contract.\n    /// @dev For EOA and simple contracts (i.e. not accounts) this value is 0.\n    mapping(address => AccountInfo) internal _accountInfo;\n\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"Callable only by self\");\n        _;\n    }\n\n    /// @notice Returns information about a certain account.\n    function getAccountInfo(address _address) external view returns (AccountInfo memory info) {\n        return _accountInfo[_address];\n    }\n\n    /// @notice Returns the account abstraction version if `_address` is a deployed contract.\n    /// Returns the latest supported account abstraction version if `_address` is an EOA.\n    function extendedAccountVersion(address _address) public view returns (AccountAbstractionVersion) {\n        AccountInfo memory info = _accountInfo[_address];\n        if (info.supportedAAVersion != AccountAbstractionVersion.None) {\n            return info.supportedAAVersion;\n        }\n\n        // It is an EOA, it is still an account.\n        if (ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.getRawCodeHash(_address) == 0) {\n            return AccountAbstractionVersion.Version1;\n        }\n\n        return AccountAbstractionVersion.None;\n    }\n\n    /// @notice Stores the new account information\n    function _storeAccountInfo(address _address, AccountInfo memory _newInfo) internal {\n        _accountInfo[_address] = _newInfo;\n    }\n\n    /// @notice Update the used version of the account.\n    /// @param _version The new version of the AA protocol to use.\n    /// @dev Note that it allows changes from account to non-account and vice versa.\n    function updateAccountVersion(AccountAbstractionVersion _version) external onlySystemCall {\n        _accountInfo[msg.sender].supportedAAVersion = _version;\n\n        emit AccountVersionUpdated(msg.sender, _version);\n    }\n\n    /// @notice Updates the nonce ordering of the account. Currently,\n    /// it only allows changes from sequential to arbitrary ordering.\n    /// @param _nonceOrdering The new nonce ordering to use.\n    function updateNonceOrdering(AccountNonceOrdering _nonceOrdering) external onlySystemCall {\n        AccountInfo memory currentInfo = _accountInfo[msg.sender];\n\n        require(\n            _nonceOrdering == AccountNonceOrdering.Arbitrary &&\n                currentInfo.nonceOrdering == AccountNonceOrdering.Sequential,\n            \"It is only possible to change from sequential to arbitrary ordering\"\n        );\n\n        currentInfo.nonceOrdering = _nonceOrdering;\n        _storeAccountInfo(msg.sender, currentInfo);\n\n        emit AccountNonceOrderingUpdated(msg.sender, _nonceOrdering);\n    }\n\n    /// @notice Calculates the address of a deployed contract via create2\n    /// @param _sender The account that deploys the contract.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _salt The create2 salt.\n    /// @param _input The constructor data.\n    /// @return newAddress The derived address of the account.\n    function getNewAddressCreate2(\n        address _sender,\n        bytes32 _bytecodeHash,\n        bytes32 _salt,\n        bytes calldata _input\n    ) public view override returns (address newAddress) {\n        // No collision is possible with the Ethereum's CREATE2, since\n        // the prefix begins with 0x20....\n        bytes32 constructorInputHash = EfficientCall.keccak(_input);\n\n        bytes32 hash = keccak256(\n            bytes.concat(CREATE2_PREFIX, bytes32(uint256(uint160(_sender))), _salt, _bytecodeHash, constructorInputHash)\n        );\n\n        newAddress = address(uint160(uint256(hash)));\n    }\n\n    /// @notice Calculates the address of a deployed contract via create\n    /// @param _sender The account that deploys the contract.\n    /// @param _senderNonce The deploy nonce of the sender's account.\n    function getNewAddressCreate(\n        address _sender,\n        uint256 _senderNonce\n    ) public pure override returns (address newAddress) {\n        // No collision is possible with the Ethereum's CREATE, since\n        // the prefix begins with 0x63....\n        bytes32 hash = keccak256(\n            bytes.concat(CREATE_PREFIX, bytes32(uint256(uint160(_sender))), bytes32(_senderNonce))\n        );\n\n        newAddress = address(uint160(uint256(hash)));\n    }\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The CREATE2 salt\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata\n    /// @dev In case of a revert, the zero address should be returned.\n    function create2(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable override returns (address) {\n        return create2Account(_salt, _bytecodeHash, _input, AccountAbstractionVersion.None);\n    }\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE` opcode.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata\n    /// @dev This method also accepts nonce as one of its parameters.\n    /// It is not used anywhere and it needed simply for the consistency for the compiler\n    /// @dev In case of a revert, the zero address should be returned.\n    /// Note: this method may be callable only in system mode,\n    /// that is checked in the `createAccount` by `onlySystemCall` modifier.\n    function create(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable override returns (address) {\n        return createAccount(_salt, _bytecodeHash, _input, AccountAbstractionVersion.None);\n    }\n\n    /// @notice Deploys a contract account with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The CREATE2 salt\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    /// @param _aaVersion The account abstraction version to use.\n    /// @dev In case of a revert, the zero address should be returned.\n    /// Note: this method may be callable only in system mode,\n    /// that is checked in the `createAccount` by `onlySystemCall` modifier.\n    function create2Account(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) public payable override onlySystemCall returns (address) {\n        NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n        address newAddress = getNewAddressCreate2(msg.sender, _bytecodeHash, _salt, _input);\n\n        _nonSystemDeployOnAddress(_bytecodeHash, newAddress, _aaVersion, _input);\n\n        return newAddress;\n    }\n\n    /// @notice Deploys a contract account with similar address derivation rules to the EVM's `CREATE` opcode.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    /// @param _aaVersion The account abstraction version to use.\n    /// @dev This method also accepts salt as one of its parameters.\n    /// It is not used anywhere and it needed simply for the consistency for the compiler\n    /// @dev In case of a revert, the zero address should be returned.\n    function createAccount(\n        bytes32, // salt\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) public payable override onlySystemCall returns (address) {\n        uint256 senderNonce = NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n        address newAddress = getNewAddressCreate(msg.sender, senderNonce);\n\n        _nonSystemDeployOnAddress(_bytecodeHash, newAddress, _aaVersion, _input);\n\n        return newAddress;\n    }\n\n    /// @notice A struct that describes a forced deployment on an address\n    struct ForceDeployment {\n        // The bytecode hash to put on an address\n        bytes32 bytecodeHash;\n        // The address on which to deploy the bytecodehash to\n        address newAddress;\n        // Whether to run the constructor on the force deployment\n        bool callConstructor;\n        // The value with which to initialize a contract\n        uint256 value;\n        // The constructor calldata\n        bytes input;\n    }\n\n    /// @notice The method that can be used to forcefully deploy a contract.\n    /// @param _deployment Information about the forced deployment.\n    /// @param _sender The `msg.sender` inside the constructor call.\n    function forceDeployOnAddress(ForceDeployment calldata _deployment, address _sender) external payable onlySelf {\n        _ensureBytecodeIsKnown(_deployment.bytecodeHash);\n        _storeConstructingByteCodeHashOnAddress(_deployment.newAddress, _deployment.bytecodeHash);\n\n        AccountInfo memory newAccountInfo;\n        newAccountInfo.supportedAAVersion = AccountAbstractionVersion.None;\n        // Accounts have sequential nonces by default.\n        newAccountInfo.nonceOrdering = AccountNonceOrdering.Sequential;\n        _storeAccountInfo(_deployment.newAddress, newAccountInfo);\n\n        if (_deployment.callConstructor) {\n            _constructContract(_sender, _deployment.newAddress, _deployment.input, false);\n        }\n\n        emit ContractDeployed(_sender, _deployment.bytecodeHash, _deployment.newAddress);\n    }\n\n    /// @notice This method is to be used only during an upgrade to set bytecodes on specific addresses.\n    /// @dev We do not require `onlySystemCall` here, since the method is accessible only\n    /// by `FORCE_DEPLOYER`.\n    function forceDeployOnAddresses(ForceDeployment[] calldata _deployments) external payable {\n        require(msg.sender == FORCE_DEPLOYER, \"Can only be called by FORCE_DEPLOYER_CONTRACT\");\n\n        uint256 deploymentsLength = _deployments.length;\n        // We need to ensure that the `value` provided by the call is enough to provide `value`\n        // for all of the deployments\n        uint256 sumOfValues = 0;\n        for (uint256 i = 0; i < deploymentsLength; ++i) {\n            sumOfValues += _deployments[i].value;\n        }\n        require(msg.value == sumOfValues, \"`value` provided is not equal to the combined `value`s of deployments\");\n\n        for (uint256 i = 0; i < deploymentsLength; ++i) {\n            this.forceDeployOnAddress{value: _deployments[i].value}(_deployments[i], msg.sender);\n        }\n    }\n\n    function _nonSystemDeployOnAddress(\n        bytes32 _bytecodeHash,\n        address _newAddress,\n        AccountAbstractionVersion _aaVersion,\n        bytes calldata _input\n    ) internal {\n        require(_bytecodeHash != bytes32(0x0), \"BytecodeHash can not be zero\");\n        require(uint160(_newAddress) > MAX_SYSTEM_CONTRACT_ADDRESS, \"Can not deploy contracts in kernel space\");\n\n        // We do not allow deploying twice on the same address.\n        require(\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.getCodeHash(uint256(uint160(_newAddress))) == 0x0,\n            \"Code hash is non-zero\"\n        );\n        // Do not allow deploying contracts to default accounts that have already executed transactions.\n        require(NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(_newAddress) == 0x00, \"Account is occupied\");\n\n        _performDeployOnAddress(_bytecodeHash, _newAddress, _aaVersion, _input);\n    }\n\n    /// @notice Deploy a certain bytecode on the address.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _newAddress The address of the contract to be deployed.\n    /// @param _aaVersion The version of the account abstraction protocol to use.\n    /// @param _input The constructor calldata.\n    function _performDeployOnAddress(\n        bytes32 _bytecodeHash,\n        address _newAddress,\n        AccountAbstractionVersion _aaVersion,\n        bytes calldata _input\n    ) internal {\n        _ensureBytecodeIsKnown(_bytecodeHash);\n        _storeConstructingByteCodeHashOnAddress(_newAddress, _bytecodeHash);\n\n        AccountInfo memory newAccountInfo;\n        newAccountInfo.supportedAAVersion = _aaVersion;\n        // Accounts have sequential nonces by default.\n        newAccountInfo.nonceOrdering = AccountNonceOrdering.Sequential;\n        _storeAccountInfo(_newAddress, newAccountInfo);\n\n        _constructContract(msg.sender, _newAddress, _input, false);\n        emit ContractDeployed(msg.sender, _bytecodeHash, _newAddress);\n    }\n\n    /// @notice Check that bytecode hash is marked as known on the `KnownCodeStorage` system contracts\n    function _ensureBytecodeIsKnown(bytes32 _bytecodeHash) internal view {\n        uint256 knownCodeMarker = KNOWN_CODE_STORAGE_CONTRACT.getMarker(_bytecodeHash);\n        require(knownCodeMarker > 0, \"The code hash is not known\");\n    }\n\n    /// @notice Ensures that the _newAddress and assigns a new contract hash to it\n    /// @param _newAddress The address of the deployed contract\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    function _storeConstructingByteCodeHashOnAddress(address _newAddress, bytes32 _bytecodeHash) internal {\n        // Set the \"isConstructor\" flag to the bytecode hash\n        bytes32 constructingBytecodeHash = Utils.constructingBytecodeHash(_bytecodeHash);\n        ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.storeAccountConstructingCodeHash(_newAddress, constructingBytecodeHash);\n    }\n\n    /// @notice Transfers the `msg.value` ETH to the deployed account & invokes its constructor.\n    /// This function must revert in case the deployment fails.\n    /// @param _sender The msg.sender to be used in the constructor\n    /// @param _newAddress The address of the deployed contract\n    /// @param _input The constructor calldata\n    /// @param _isSystem Whether the call should be a system call (could be possibly required in the future).\n    function _constructContract(address _sender, address _newAddress, bytes calldata _input, bool _isSystem) internal {\n        // Transfer the balance to the new address on the constructor call.\n        uint256 value = msg.value;\n        if (value > 0) {\n            ETH_TOKEN_SYSTEM_CONTRACT.transferFromTo(address(this), _newAddress, value);\n            // Safe to cast value, because `msg.value` <= `uint128.max` due to `MessageValueSimulator` invariant\n            SystemContractHelper.setValueForNextFarCall(uint128(value));\n        }\n\n        bytes memory returnData = EfficientCall.mimicCall(gasleft(), _newAddress, _input, _sender, true, _isSystem);\n        ImmutableData[] memory immutables = abi.decode(returnData, (ImmutableData[]));\n        IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT.setImmutables(_newAddress, immutables);\n        ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.markAccountCodeHashAsConstructed(_newAddress);\n    }\n}"
    },
    {
      "filename": "contracts/ContractDeployer.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ImmutableData} from \"./interfaces/IImmutableSimulator.sol\";\nimport \"./interfaces/IContractDeployer.sol\";\nimport {CREATE2_PREFIX, CREATE_PREFIX, NONCE_HOLDER_SYSTEM_CONTRACT, ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT, FORCE_DEPLOYER, MAX_SYSTEM_CONTRACT_ADDRESS, KNOWN_CODE_STORAGE_CONTRACT, ETH_TOKEN_SYSTEM_CONTRACT, IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT} from \"./Constants.sol\";\n\nimport \"./libraries/Utils.sol\";\nimport \"./libraries/EfficientCall.sol\";\nimport {SystemContractHelper, ISystemContract} from \"./libraries/SystemContractHelper.sol\";\n\n/**\n * @author Matter Labs\n * @notice System smart contract that is responsible for deploying other smart contracts on zkSync.\n * @dev The contract is responsible for generating the address of the deployed smart contract,\n * incrementing"
    }
  ]
}