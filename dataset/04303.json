{
  "Title": "[H03] Any governance action could be executed multiple times",
  "Content": "The [`executeProposal` function](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Governor.sol#L120) of the `Governor` contract can execute a transaction listed in an approved proposal. A proposal can contain multiple transactions, each of them expected to be executed a single time in the order they appear listed in the [`Proposal.transactions` array](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Governor.sol#L37).\n\n\nOnce a [transaction is executed successfully](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Governor.sol#L132), the `executeProposal` function [deletes the transaction from the proposal](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Governor.sol#L134-L135) so that it cannot be executed twice. However, the removal is done *after* the external call is made, which fails to follow the [Checks-Effects-Interactions pattern](https://solidity.readthedocs.io/en/v0.6.0/security-considerations.html#use-the-checks-effects-interactions-pattern). This can be leveraged by any contract called by the `Governor` to execute a reentrancy attack, where the callee would reenter the `executeProposal` function and trigger the same transaction multiple times.\n\n\nIt must be noted that while the reentrancy attack is indeed feasible, the likelihood of it actually occurring and having a negative impact in the UMA protocol is diminished by fact that:\n\n\n* A proposal can only be proposed by the account with the trusted `Proposer` role, which will decide the transactions included in the proposal. It is unlikely that the `Proposer` constructs a malicious transaction that invokes a contract that does a reentrancy.\n* Even if the `Proposer` does include a malicious proposal, it would have to be voted by the Governance system before it can be executed. This process should involve reviewing and validating that the proposal does not contain unexpected, potentially malicious transactions that may harm the system.\n\n\nTo ensure a proposalâ€™s transaction cannot be executed multiple times leveraging a reentrancy attack, consider modifying the `executeProposal` function of the `Governor` contract to tightly follow the Checks-Effects-Interactions pattern. In particular, the removal of the executed transaction must occur *before* the external call.\n\n\n**Update:** *Fixed in [PR#1200](https://github.com/UMAprotocol/protocol/pull/1200). The `executeProposal` function now correctly follows the suggested Checks-Effects-Interactions pattern.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "core/contracts/oracle/implementation/Governor.sol",
      "content": "pragma solidity ^0.6.0;\n\npragma experimental ABIEncoderV2;\n\nimport \"../../common/implementation/MultiRole.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../interfaces/FinderInterface.sol\";\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../interfaces/OracleInterface.sol\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n/**\n * @title Takes proposals for certain governance actions and allows UMA token holders to vote on them.\n */\ncontract Governor is MultiRole, Testable {\n    using SafeMath for uint;\n\n    /****************************************\n     *     INTERNAL VARIABLES AND STORAGE   *\n     ****************************************/\n\n    enum Roles {\n        Owner, // Can set the proposer.\n        Proposer // Address that can make proposals.\n    }\n\n    struct Transaction {\n        address to;\n        uint value;\n        bytes data;\n    }\n\n    struct Proposal {\n        Transaction[] transactions;\n        uint requestTime;\n    }\n\n    FinderInterface private finder;\n    Proposal[] public proposals;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    // Emitted when a new proposal is created.\n    event NewProposal(uint indexed id, Transaction[] transactions);\n\n    // Emitted when an existing proposal is executed.\n    event ProposalExecuted(uint indexed id, uint transactionIndex);\n\n    /**\n     * @notice Construct the Governor contract.\n     * @param _finderAddress keeps track of all contracts within the system based on their interfaceName.\n     * @param _isTest whether this contract is being constructed for the purpose of running automated tests.\n     */\n    constructor(address _finderAddress, bool _isTest) public Testable(_isTest) {\n        finder = FinderInterface(_finderAddress);\n        _createExclusiveRole(uint(Roles.Owner), uint(Roles.Owner), msg.sender);\n        _createExclusiveRole(uint(Roles.Proposer), uint(Roles.Owner), msg.sender);\n    }\n\n    /****************************************\n     *          PROPOSAL ACTIONS            *\n     ****************************************/\n\n    /**\n     * @notice Proposes a new governance action. Can only be called by the holder of the Proposer role.\n     * @param transactions the list of transactions that are being proposed.\n     * @dev You can create the data portion of each transaction by doing the following:\n     * ```\n     * const truffleContractInstance = await TruffleContract.deployed()\n     * const data = truffleContractInstance.methods.methodToCall(arg1, arg2).encodeABI()\n     * ```\n     * Note: this method must be public because of a solidity limitation that\n     * disallows structs arrays to be passed to external functions.\n     * @param transactions array of `Transaction` which can be voted on.\n     */\n    function propose(Transaction[] memory transactions) public onlyRoleHolder(uint(Roles.Proposer)) {\n        uint id = proposals.length;\n        uint time = getCurrentTime();\n\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\n        // structs in storage to an an array of structs in memory is currently not implemented in solidity :/.\n\n        // Add a zero-initialized element to the proposals array.\n        proposals.push();\n\n        // Initialize the new proposal.\n        Proposal storage proposal = proposals[id];\n        proposal.requestTime = time;\n\n        // Initialize the transaction array.\n        for (uint i = 0; i < transactions.length; i++) {\n            require(transactions[i].to != address(0), \"The to address cannot be 0x0\");\n            proposal.transactions.push(transactions[i]);\n        }\n\n        bytes32 identifier = _constructIdentifier(id);\n\n        // Request a vote on this proposal in the DVM.\n        OracleInterface oracle = _getOracle();\n        IdentifierWhitelistInterface supportedIdentifiers = _getIdentifierWhitelist();\n        supportedIdentifiers.addSupportedIdentifier(identifier);\n\n        oracle.requestPrice(identifier, time);\n        supportedIdentifiers.removeSupportedIdentifier(identifier);\n\n        emit NewProposal(id, transactions);\n    }\n\n    /**\n     * @notice Executes a proposed governance action that has been approved by voters.\n     * @dev This can be called by any address.\n     * @param id unique id for the executed proposal.\n     * @param transactionIndex unique transaction index for the executed proposal.\n     */\n    function executeProposal(uint id, uint transactionIndex) external {\n        Proposal storage proposal = proposals[id];\n        int price = _getOracle().getPrice(_constructIdentifier(id), proposal.requestTime);\n\n        Transaction storage transaction = proposal.transactions[transactionIndex];\n\n        require(\n            transactionIndex == 0 || proposal.transactions[transactionIndex.sub(1)].to == address(0),\n            \"Previous transaction has not been executed\"\n        );\n        require(transaction.to != address(0), \"Transaction has already been executed\");\n        require(price != 0, \"Cannot execute, proposal was voted down\");\n        require(_executeCall(transaction.to, transaction.value, transaction.data), \"Transaction execution failed\");\n\n        // Delete the transaction.\n        delete proposal.transactions[transactionIndex];\n\n        emit ProposalExecuted(id, transactionIndex);\n    }\n\n    /***************************************\n     *       GOVERNOR STATE GETTERS         *\n     ****************************************/\n\n    /**\n     * @notice Gets the total number of proposals (includes executed and non-executed).\n     * @return uint representing the current number of proposals.\n     */\n    function numProposals() external view returns (uint) {\n        return proposals.length;\n    }\n\n    /**\n     * @notice Gets the proposal data for a particular id.\n     * @dev after a proposal is executed, its data will be zeroed out.\n     * @param id uniquely identify the identity of the proposal.\n     * @return proposal struct containing transactions[] and requestTime.\n     */\n    function getProposal(uint id) external view returns (Proposal memory proposal) {\n        return proposals[id];\n    }\n\n    /****************************************\n     *      PRIVATE GETTERS AND FUNCTIONS   *\n     ****************************************/\n\n    function _executeCall(address to, uint256 value, bytes memory data) private returns (bool success) {\n        // Mostly copied from:\n        // solhint-disable-next-line max-line-length\n        // https://github.com/gnosis/safe-contracts/blob/59cfdaebcd8b87a0a32f87b50fead092c10d3a05/contracts/base/Executor.sol#L23-L31\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n            let inputData := add(data, 0x20)\n            let inputDataSize := mload(data)\n            success := call(gas(), to, value, inputData, inputDataSize, 0, 0)\n        }\n    }\n\n    function _getOracle() private view returns (OracleInterface oracle) {\n        return OracleInterface(finder.getImplementationAddress(\"Oracle\"));\n    }\n\n    function _getIdentifierWhitelist() private view returns (IdentifierWhitelistInterface supportedIdentifiers) {\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(\"IdentifierWhitelist\"));\n    }\n\n    function _constructIdentifier(uint id) private pure returns (bytes32 identifier) {\n        bytes32 bytesId = _uintToBytes(id);\n        return _addPrefix(bytesId, \"Admin \", 6);\n    }\n\n    // This method is based off of this code: https://ethereum.stackexchange.com/a/6613/47801.\n    function _uintToBytes(uint v) private pure returns (bytes32 ret) {\n        if (v == 0) {\n            ret = \"0\";\n        } else {\n            while (v > 0) {\n                ret = ret >> 8;\n                ret |= bytes32((v % 10) + 48) << (31 * 8);\n                v /= 10;\n            }\n        }\n        return ret;\n    }\n\n    function _addPrefix(bytes32 input, bytes32 prefix, uint prefixLength) private pure returns (bytes32 output) {\n        bytes32 shiftedInput = input >> (prefixLength * 8);\n        return shiftedInput | prefix;\n    }\n}"
    },
    {
      "filename": "core/contracts/oracle/implementation/Governor.sol",
      "content": "pragma solidity ^0.6.0;\n\npragma experimental ABIEncoderV2;\n\nimport \"../../common/implementation/MultiRole.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../interfaces/FinderInterface.sol\";\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../interfaces/OracleInterface.sol\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n/**\n * @title Takes proposals for certain governance actions and allows UMA token holders to vote on them.\n */\ncontract Governor is MultiRole, Testable {\n    using SafeMath for uint;\n\n    /****************************************\n     *     INTERNAL VARIABLES AND STORAGE   *\n     ****************************************/\n\n    enum Roles {\n        Owner, // Can set the proposer.\n        Proposer // Address that can make proposals.\n    }\n\n    struct Transaction {\n        address to;\n        uint value;\n        bytes data;\n    }\n\n    struct Proposal {\n        Transaction[] transactions;\n        uint requestTime;\n    }\n\n    FinderInterface private finder;\n    Proposal[] public proposals;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    // Emitted when a new proposal is created.\n    event NewProposal(uint indexed id, Transaction[] transactions);\n\n    // Emitted when an existing proposal is executed.\n    event ProposalExecuted(uint indexed id, uint transactionIndex);\n\n    /**\n     * @notice Construct the Governor contract.\n     * @param _finderAddress keeps track of all contracts within the system based on their interfaceName.\n     * @param _isTest whether this contract is being constructed for the purpose of running automated tests.\n     */\n    constructor(address _finderAddress, bool _isTest) public Testable(_isTest) {\n        finder = FinderInterface(_finderAddress);\n        _createExclusiveRole(uint(Roles.Owner), uint(Roles.Owner), msg.sender);\n        _createExclusiveRole(uint(Roles.Proposer), uint(Roles.Owner), msg.sender);\n    }\n\n    /****************************************\n     *          PROPOSAL ACTIONS            *\n     ****************************************/\n\n    /**\n     * @notice Proposes a new governance action. Can only be called by the holder of the Proposer role.\n     * @param transactions the list of transactions that are being proposed.\n     * @dev You can create the data portion of each transaction by doing the following:\n     * ```\n     * const truffleContractInstance = await TruffleContract.deployed()\n     * const data = truffleContractInstance.methods.methodToCall(arg1, arg2).encodeABI()\n     * ```\n     * Note: this method must be public because of a solidity limitation that\n     * disallows structs arrays to be passed to external functions.\n     * @param transactions array of `Transaction` which can be voted on.\n     */\n    function propose(Transaction[] memory transactions) public onlyRoleHolder(uint(Roles.Proposer)) {\n        uint id = proposals.length;\n        uint time = getCurrentTime();\n\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\n        // structs in storage to an an array of structs in memory is currently not implemented in solidity :/.\n\n        // Add a zero-initialized element to the proposals array.\n        proposals.push();\n\n        // Initialize the new proposal.\n        Proposal storage proposal = proposals[id];\n        proposal.requestTime = time;\n\n        // Initialize the transaction array.\n        for (uint i = 0; i < transactions.length; i++) {\n            require(transactions[i].to != address(0), \"The to address cannot be 0x0\");\n            proposal.transactions.push(transactions[i]);\n        }\n\n        bytes32 identifier = _constructIdentifier(id);\n\n        // Request a vote on this proposal in the DVM.\n        OracleInterface oracle = _getOracle();\n        IdentifierWhitelistInterface supportedIdentifiers = _getIdentifierWhitelist();\n        supportedIdentifiers.addSupportedIdentifier(identifier);\n\n        oracle.requestPrice(identifier, time);\n        supportedIdentifiers.removeSupportedIdentifier(identifier);\n\n        emit NewProposal(id, transactions);\n    }\n\n    /**\n     * @notice Executes a proposed governance action that has been approved by voters.\n     * @dev This can be called by any address.\n     * @param id unique id for the executed proposal.\n     * @param transactionIndex unique transaction index for the executed proposal.\n     */\n    function executeProposal(uint id, uint transactionIndex) external {\n        Proposal storage proposal = proposals[id];\n        int price = _getOracle().getPrice(_constructIdentifier(id), proposal.requestTime);\n\n        Transaction storage transaction = proposal.transactions[transactionIndex];\n\n        require(\n            transactionIndex == 0 || proposal.transactions[transactionIndex.sub(1)].to == address(0),\n            \"Previous transaction has not been executed\"\n        );\n        require(transaction.to != address(0), \"Transaction has already been executed\");\n        require(price != 0, \"Cannot execute, proposal was voted down\");\n        require(_executeCall(transaction.to, transaction.value, transaction.data), \"Transaction execution failed\");\n\n        // Delete the transaction.\n        delete proposal.transactions[transactionIndex];\n\n        emit ProposalExecuted(id, transactionIndex);\n    }\n\n    /***************************************\n     *       GOVERNOR STATE GETTERS         *\n     ****************************************/\n\n    /**\n     * @notice Gets the total number of proposals (includes executed and non-executed).\n     * @return uint representing the current number of proposals.\n     */\n    function numProposals() external view returns (uint) {\n        return proposals.length;\n    }\n\n    /**\n     * @notice Gets the proposal data for a particular id.\n     * @dev after a proposal is executed, its data will be zeroed out.\n     * @param id uniquely identify the identity of the proposal.\n     * @return proposal struct containing transactions[] and requestTime.\n     */\n    function getProposal(uint id) external view returns (Proposal memory proposal) {\n        return proposals[id];\n    }\n\n    /****************************************\n     *      PRIVATE GETTERS AND FUNCTIONS   *\n     ****************************************/\n\n    function _executeCall(address to, uint256 value, bytes memory data) private returns (bool success) {\n        // Mostly copied from:\n        // solhint-disable-next-line max-line-length\n        // https://github.com/gnosis/safe-contracts/blob/59cfdaebcd8b87a0a32f87b50fead092c10d3a05/contracts/base/Executor.sol#L23-L31\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n            let inputData := add(data, 0x20)\n            let inputDataSize := mload(data)\n            success := call(gas(), to, value, inputData, inputDataSize, 0, 0)\n        }\n    }\n\n    function _getOracle() private view returns (OracleInterface oracle) {\n        return OracleInterface(finder.getImplementationAddress(\"Oracle\"));\n    }\n\n    function _getIdentifierWhitelist() private view returns (IdentifierWhitelistInterface supportedIdentifiers) {\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(\"IdentifierWhitelist\"));\n    }\n\n    function _constructIdentifier(uint id) private pure returns (bytes32 identifier) {\n        bytes32 bytesId = _uintToBytes(id);\n        return _addPrefix(bytesId, \"Admin \", 6);\n    }\n\n    // This method is based off of this code: https://ethereum.stackexchange.com/a/6613/47801.\n    function _uintToBytes(uint v) private pure returns (bytes32 ret) {\n        if (v == 0) {\n            ret = \"0\";\n        } else {\n            while (v > 0) {\n                ret = ret >> 8;\n                ret |= bytes32((v % 10) + 48) << (31 * 8);\n                v /= 10;\n            }\n        }\n        return ret;\n    }\n\n    function _addPrefix(bytes32 input, bytes32 prefix, uint prefixLength) private pure returns (bytes32 output) {\n        bytes32 shiftedInput = input >> (prefixLength * 8);\n        return shiftedInput | prefix;\n    }\n}"
    }
  ]
}