{
  "Title": "Lack of incentivization of the battle settlement process",
  "Content": "##### Description\nThere is no specific incentivization of the [`settle()`](https://github.com/DivergenceProtocol/diver-contracts/blob/e5286f94a7ccb9d6279fae51ea66a8833672628a/src/core/Battle.sol#L424) function. Though most of the users are interested in battle finalization, but in order to save gas each user would prefer to avoid making the settlement by themselves. It may make sense for some networks where gas is expensive enough. Consecutively, it is expected behavior that users wouldn't make battle settlements, and the project owner will make it in a centralized manner even if it is unprofitable for them. It causes some centralization and an open attack vector for the griefing attack by spamming the project by battles that the project owner is enforced to finalize even if it is unprofitable for them.\n##### Recommendation\nWe recommend introducing some incentivization of the battle settlement. It can be combined with spam protection.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/core/Battle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { SafeERC20 } from \"@oz/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"@oz/utils/math/SafeCast.sol\";\nimport { FullMath } from \"@uniswap/v3-core/contracts/libraries/FullMath.sol\";\nimport { TickBitmap } from \"@uniswap/v3-core/contracts/libraries/TickBitmap.sol\";\nimport { SqrtPriceMath } from \"@uniswap/v3-core/contracts/libraries/SqrtPriceMath.sol\";\nimport { FixedPoint128 } from \"@uniswap/v3-core/contracts/libraries/FixedPoint128.sol\";\nimport { Errors } from \"./errors/Errors.sol\";\nimport { IBattle } from \"./interfaces/battle/IBattle.sol\";\nimport { IOracle } from \"./interfaces/IOracle.sol\";\nimport { IBattleBase } from \"./interfaces/battle/IBattleActions.sol\";\nimport { IBattleState } from \"./interfaces/battle/IBattleState.sol\";\nimport { IBattleInit } from \"./interfaces/battle/IBattleInit.sol\";\nimport { IMintCallback } from \"./interfaces/callback/IMintCallback.sol\";\nimport { IBattleMintBurn } from \"./interfaces/battle/IBattleActions.sol\";\nimport { ISToken } from \"./interfaces/ISToken.sol\";\nimport { IOwner } from \"./interfaces/IOwner.sol\";\nimport { ITradeCallback } from \"./interfaces/callback/ITradeCallback.sol\";\nimport { IArenaState } from \"./interfaces/IArena.sol\";\nimport { TickMath } from \"./libs/TickMath.sol\";\nimport { Tick } from \"./libs/Tick.sol\";\nimport { UpdatePositionParams } from \"./params/UpdatePositionParams.sol\";\nimport { Position } from \"./libs/Position.sol\";\nimport { DiverSqrtPriceMath } from \"./libs/DiverSqrtPriceMath.sol\";\nimport { TradeMath } from \"./libs/TradeMath.sol\";\nimport { ModifyPositionParams } from \"./params/ModifyPositionParams.sol\";\nimport { BattleMintParams } from \"./params/BattleMintParams.sol\";\nimport { BattleBurnParams } from \"./params/BattleBurnParams.sol\";\nimport { BattleTradeParams } from \"./params/BattleTradeParams.sol\";\nimport { ComputeTradeStepParams } from \"./params/ComputeTradeStepParams.sol\";\nimport { DeploymentParams } from \"./params/DeploymentParams.sol\";\nimport { TradeCache, TradeState, StepComputations } from \"./types/TradeTypes.sol\";\nimport { LiquidityType, BattleKey, Outcome, GrowthX128, TickInfo } from \"./types/common.sol\";\nimport { PositionInfo, Fee, Outcome, GrowthX128, TradeType } from \"./types/common.sol\";\n\n/// @title Battle\ncontract Battle is IBattle {\n    using Tick for mapping(int24 => TickInfo);\n    using TickBitmap for mapping(int16 => uint256);\n    using Position for mapping(bytes32 => PositionInfo);\n    using Position for PositionInfo;\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    struct Slot0 {\n        uint160 sqrtPriceX96;\n        int24 tick;\n        bool unlocked;\n    }\n\n    address public override manager;\n    address public arena;\n    address public oracle;\n    address public override spear;\n    address public override shield;\n\n    uint256 public startTS;\n    uint128 public liquidity;\n    uint128 public maxLiquidityPerTick;\n    uint128 public protocolFeeAmount;\n\n    Fee public fee;\n\n    BattleKey private _bk;\n    GrowthX128 public global;\n    Slot0 public override slot0;\n    Outcome public override battleOutcome;\n\n    mapping(int24 => TickInfo) public ticks;\n    mapping(int16 => uint256) public tickBitmap;\n    mapping(bytes32 => PositionInfo) private _positions;\n\n    modifier lock() {\n        if (!slot0.unlocked) {\n            revert Errors.Locked();\n        }\n        slot0.unlocked = false;\n        _;\n        slot0.unlocked = true;\n    }\n\n    /// @notice init storage state variable, only be caled once\n    function initState(DeploymentParams memory params) external override {\n        if (_bk.expiries != 0) {\n            revert Errors.InitTwice();\n        }\n        _bk = params.battleKey;\n        oracle = params.oracleAddr;\n        startTS = block.timestamp;\n        fee = params.fee;\n        spear = params.spear;\n        shield = params.shield;\n        arena = address(msg.sender);\n    }\n\n    /// @notice init sqrtPriceX96, it will be called once\n    function init(uint160 startSqrtPriceX96) external override {\n        if (slot0.sqrtPriceX96 != 0) {\n            revert Errors.InitTwice();\n        }\n        slot0 = Slot0({ sqrtPriceX96: startSqrtPriceX96, tick: TickMath.getTickAtSqrtRatio(startSqrtPriceX96), unlocked: true });\n        maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(1);\n        manager = address(msg.sender);\n    }\n\n    function _updatePosition(UpdatePositionParams memory params) internal returns (PositionInfo storage position) {\n        position = _positions.get(msg.sender, params.mpParams.tickLower, params.mpParams.tickUpper);\n        GrowthX128 memory _global = global;\n\n        bool flippedLower;\n        bool flippedUpper;\n        if (params.mpParams.liquidityDelta != 0) {\n            flippedLower = ticks.update(params.mpParams.tickLower, params.tick, params.mpParams.liquidityDelta, _global, maxLiquidityPerTick, false);\n\n            flippedUpper = ticks.update(params.mpParams.tickUpper, params.tick, params.mpParams.liquidityDelta, _global, maxLiquidityPerTick, true);\n\n            if (flippedLower) {\n                tickBitmap.flipTick(params.mpParams.tickLower, 1);\n            }\n            if (flippedUpper) {\n                tickBitmap.flipTick(params.mpParams.tickUpper, 1);\n            }\n        }\n        GrowthX128 memory insideLast = ticks.getGrowthInside(params.mpParams.tickLower, params.mpParams.tickUpper, params.tick, _global);\n        position.update(params.mpParams.liquidityDelta, insideLast);\n        if (params.mpParams.liquidityDelta < 0) {\n            if (flippedLower) {\n                ticks.clear(params.mpParams.tickLower);\n            }\n            if (flippedUpper) {\n                ticks.clear(params.mpParams.tickUpper);\n            }\n        }\n    }\n\n    function checkTicks(int24 tickLower, int24 tickUpper) private pure {\n        if (tickLower >= tickUpper) revert Errors.TickInvalid();\n        if (tickLower < TickMath.MIN_TICK) revert Errors.TickInvalid();\n        if (tickUpper > TickMath.MAX_TICK) revert Errors.TickInvalid();\n    }\n\n    function _modifyPosition(ModifyPositionParams memory params) internal returns (PositionInfo storage position, uint256 seed) {\n        checkTicks(params.tickLower, params.tickUpper);\n        position = _updatePosition(UpdatePositionParams(params, slot0.tick));\n        uint256 csp;\n        uint256 csh;\n        //\n        if (params.liquidityDelta > 0) {\n            if (params.liquidityType == LiquidityType.COLLATERAL) {\n                if (slot0.tick < params.tickLower) {\n                    csp = SqrtPriceMath.getAmount0Delta(\n                        TickMath.getSqrtRatioAtTick(params.tickLower),\n                        TickMath.getSqrtRatioAtTick(params.tickUpper),\n                        uint128(params.liquidityDelta),\n                        true\n                    );\n                } else if (slot0.tick < params.tickUpper) {\n                    // current tick is inside the passedÆ’ range\n                    csp = SqrtPriceMath.getAmount0Delta(\n                        slot0.sqrtPriceX96, TickMath.getSqrtRatioAtTick(params.tickUpper), uint128(params.liquidityDelta), false\n                    );\n                    csh = SqrtPriceMath.getAmount1Delta(\n                        TickMath.getSqrtRatioAtTick(params.tickLower), slot0.sqrtPriceX96, uint128(params.liquidityDelta), false\n                    );\n                    liquidity += uint128(params.liquidityDelta);\n                } else {\n                    csh = SqrtPriceMath.getAmount1Delta(\n                        TickMath.getSqrtRatioAtTick(params.tickLower),\n                        TickMath.getSqrtRatioAtTick(params.tickUpper),\n                        uint128(params.liquidityDelta),\n                        true\n                    );\n                }\n                seed = csp + csh;\n            } else if (params.liquidityType == LiquidityType.SPEAR) {\n                seed = DiverSqrtPriceMath.getSTokenDelta(\n                    TickMath.getSqrtRatioAtTick(params.tickLower), TickMath.getSqrtRatioAtTick(params.tickUpper), params.liquidityDelta\n                ).toUint256();\n            } else {\n                seed = DiverSqrtPriceMath.getSTokenDelta(\n                    TickMath.getSqrtRatioAtTick(params.tickLower), TickMath.getSqrtRatioAtTick(params.tickUpper), params.liquidityDelta\n                ).toUint256();\n            }\n        } else if (params.liquidityDelta < 0) {\n            if (slot0.tick >= params.tickLower && slot0.tick < params.tickUpper) {\n                liquidity -= uint128(-params.liquidityDelta);\n            }\n        }\n    }\n\n    /// @inheritdoc IBattleMintBurn\n    function mint(BattleMintParams memory params) external override lock returns (uint256 seed) {\n        if (block.timestamp >= _bk.expiries) {\n            revert Errors.BattleEnd();\n        }\n        // check tick\n        if (params.liquidityType == LiquidityType.SPEAR && params.tickLower >= slot0.tick) {\n            revert Errors.TickInvalid();\n        }\n        if (params.liquidityType == LiquidityType.SHIELD && params.tickUpper <= slot0.tick) {\n            revert Errors.TickInvalid();\n        }\n        if (msg.sender != manager) {\n            revert Errors.CallerNotManager();\n        }\n\n        if (params.amount == 0) {\n            revert Errors.ZeroAmount();\n        }\n\n        PositionInfo storage positionInfo;\n        (positionInfo, seed) = _modifyPosition(\n            ModifyPositionParams({\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                liquidityType: params.liquidityType,\n                liquidityDelta: int128(params.amount)\n            })\n        );\n\n        if (params.liquidityType == LiquidityType.COLLATERAL) {\n            uint256 balanceBefore = IERC20(_bk.collateral).balanceOf(address(this));\n            IMintCallback(msg.sender).mintCallback(seed, params.data);\n            if (IERC20(_bk.collateral).balanceOf(address(this)) < balanceBefore + seed) {\n                revert Errors.InsufficientCollateral();\n            }\n        } else if (params.liquidityType == LiquidityType.SPEAR) {\n            uint256 balanceBefore = IERC20(spear).balanceOf(address(this));\n            IMintCallback(msg.sender).mintCallback(seed, params.data);\n            if (IERC20(spear).balanceOf(address(this)) < balanceBefore + seed) {\n                revert Errors.InsufficientSpear();\n            }\n            ISToken(spear).burn(address(this), seed);\n        } else {\n            uint256 balanceBefore = IERC20(shield).balanceOf(address(this));\n            IMintCallback(msg.sender).mintCallback(seed, params.data);\n            if (IERC20(shield).balanceOf(address(this)) < balanceBefore + seed) {\n                revert Errors.InsufficientShield();\n            }\n            ISToken(shield).burn(address(this), seed);\n        }\n\n        emit Minted(msg.sender, params.liquidityType, params.tickLower, params.tickUpper, params.amount, seed);\n    }\n\n    /// @inheritdoc IBattleMintBurn\n    function burn(BattleBurnParams memory params) external override lock {\n        if (msg.sender != manager) {\n            revert Errors.CallerNotManager();\n        }\n        if (params.tickLower >= params.tickUpper) {\n            revert Errors.TickOrderInvalid();\n        }\n        _modifyPosition(\n            ModifyPositionParams({\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                liquidityType: params.liquidityType,\n                liquidityDelta: -int128(params.liquidityAmount)\n            })\n        );\n        emit Burned(params.recipient, params.tickLower, params.tickUpper, params.liquidityType, params.liquidityAmount);\n    }\n\n    /// comments see IBattleTrade\n    function collect(address recipient, uint256 cAmount, uint256 spAmount, uint256 shAmount) external override {\n        if (msg.sender != manager) {\n            revert Errors.CallerNotManager();\n        }\n        if (cAmount > 0) {\n            IERC20(_bk.collateral).safeTransfer(recipient, cAmount);\n        }\n        if (spAmount > 0) {\n            ISToken(spear).mint(recipient, spAmount);\n        }\n        if (shAmount > 0) {\n            ISToken(shield).mint(recipient, shAmount);\n        }\n    }\n\n    /// comments see IBattleTrade\n    function trade(BattleTradeParams memory params) external returns (uint256 cAmount, uint256 sAmount) {\n        if (block.timestamp >= _bk.expiries) {\n            revert Errors.BattleEnd();\n        }\n        // manager or quoter need call this function\n        // if (msg.sender != s.manager) {\n        //     revert Errors.CallerNotManager();\n        // }\n        if (params.amountSpecified == 0) {\n            revert Errors.ZeroAmount();\n        }\n\n        Slot0 memory slot0Start = slot0;\n\n        if (!slot0Start.unlocked) {\n            revert Errors.Locked();\n        }\n\n        bool isPriceDown = params.tradeType == TradeType.BUY_SPEAR;\n        require(\n            isPriceDown\n                ? params.sqrtPriceLimitX96 < slot0Start.sqrtPriceX96 && params.sqrtPriceLimitX96 > TickMath.MIN_SQRT_RATIO\n                : params.sqrtPriceLimitX96 > slot0Start.sqrtPriceX96 && params.sqrtPriceLimitX96 < TickMath.MAX_SQRT_RATIO,\n            \"PriceInvalid\"\n        );\n        slot0.unlocked = false;\n\n        TradeCache memory cache = TradeCache({ feeProtocol: fee.protocolFee });\n        TradeState memory state = TradeState({\n            amountSpecifiedRemaining: params.amountSpecified,\n            amountCalculated: 0,\n            sqrtPriceX96: slot0Start.sqrtPriceX96,\n            tick: slot0Start.tick,\n            global: global,\n            protocolFee: 0,\n            liquidity: liquidity,\n            transactionFee: 0\n        });\n        while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != params.sqrtPriceLimitX96) {\n            StepComputations memory step;\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\n\n            (step.tickNext, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord(state.tick, 1, isPriceDown);\n            if (step.tickNext < TickMath.MIN_TICK) {\n                step.tickNext = TickMath.MIN_TICK;\n            }\n            if (step.tickNext > TickMath.MAX_TICK) {\n                step.tickNext = TickMath.MAX_TICK;\n            }\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\n            (state.sqrtPriceX96, step.amountIn, step.amountOut) = TradeMath.computeTradeStep(\n                ComputeTradeStepParams({\n                    tradeType: params.tradeType,\n                    sqrtRatioCurrentX96: state.sqrtPriceX96,\n                    sqrtRatioTargetX96: \n                    (isPriceDown ? step.sqrtPriceNextX96 < params.sqrtPriceLimitX96 : step.sqrtPriceNextX96 > params.sqrtPriceLimitX96)\n                        ? params.sqrtPriceLimitX96\n                        : step.sqrtPriceNextX96,\n                    liquidity: state.liquidity,\n                    amountRemaining: state.amountSpecifiedRemaining\n                })\n            );\n\n            state.amountSpecifiedRemaining -= step.amountIn;\n            state.amountCalculated += step.amountOut;\n\n            step.feeAmount = FullMath.mulDiv(step.amountOut, fee.transactionFee, 1e6);\n            if (cache.feeProtocol > 0) {\n                uint256 delta = FullMath.mulDiv(step.feeAmount, cache.feeProtocol, 1e6);\n                step.feeAmount -= delta;\n                state.protocolFee += uint128(delta);\n            }\n\n            if (state.liquidity > 0) {\n                unchecked {\n                    state.global.fee += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);\n                    state.transactionFee += step.feeAmount;\n                    state.global.collateralIn += FullMath.mulDiv(step.amountIn, FixedPoint128.Q128, state.liquidity);\n\n                    if (params.tradeType == TradeType.BUY_SPEAR) {\n                        // buy spear => spearBought and shieldBankOut need be\n                        // considered\n                        // spear bought\n                        state.global.spearOut += FullMath.mulDiv(step.amountOut, FixedPoint128.Q128, state.liquidity);\n                    } else {\n                        // buy shield => shieldBought and spearBankOut need be\n                        // considered\n                        state.global.shieldOut += FullMath.mulDiv(step.amountOut, FixedPoint128.Q128, state.liquidity);\n                    }\n                }\n            }\n\n            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\n                if (step.initialized) {\n                    int128 liquidityNet = ticks.cross(step.tickNext, state.global);\n                    if (isPriceDown) {\n                        liquidityNet = -liquidityNet;\n                    }\n                    state.liquidity = liquidityNet < 0 ? state.liquidity - uint128(-liquidityNet) : state.liquidity + uint128(liquidityNet);\n                }\n                state.tick = isPriceDown ? step.tickNext - 1 : step.tickNext;\n            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\n                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\n            }\n        }\n\n        if (state.tick != slot0Start.tick) {\n            (slot0.sqrtPriceX96, slot0.tick) = (state.sqrtPriceX96, state.tick);\n        } else {\n            slot0.sqrtPriceX96 = state.sqrtPriceX96;\n        }\n        liquidity = state.liquidity;\n        global = state.global;\n        cAmount = params.amountSpecified - state.amountSpecifiedRemaining + state.transactionFee + state.protocolFee;\n        sAmount = state.amountCalculated;\n        if (state.protocolFee > 0) {\n            protocolFeeAmount += state.protocolFee;\n        }\n\n        uint256 colBalanceBefore = collateralBalance();\n        ITradeCallback(msg.sender).tradeCallback(cAmount, sAmount, params.data);\n        if (colBalanceBefore + cAmount > collateralBalance()) {\n            revert Errors.InsufficientCollateral();\n        }\n\n        if (params.tradeType == TradeType.BUY_SPEAR) {\n            // mint spear to user\n            ISToken(spear).mint(params.recipient, sAmount);\n        } else {\n            // mint shield to user\n            ISToken(shield).mint(params.recipient, sAmount);\n        }\n        emit Traded(params.recipient, state.liquidity, cAmount, sAmount, params.tradeType, state.sqrtPriceX96, state.tick);\n        slot0.unlocked = true;\n    }\n\n    /// @inheritdoc IBattleBase\n    function settle() external override {\n        if (block.timestamp < _bk.expiries) {\n            revert Errors.BattleNotEnd();\n        }\n        if (battleOutcome != Outcome.ONGOING) {\n            revert Errors.BattleSettled();\n        }\n        uint256 price = IOracle(oracle).updatePriceByExternal(_bk.underlying, _bk.expiries);\n        if (price == 0) {\n            revert Errors.OraclePriceError();\n        }\n        if (price >= _bk.strikeValue) {\n            battleOutcome = Outcome.SPEAR_WIN;\n        } else {\n            battleOutcome = Outcome.SHIELD_WIN;\n        }\n        emit Settled(msg.sender, battleOutcome);\n    }\n\n    /// @inheritdoc IBattleBase\n    function exercise() external override lock {\n        if (battleOutcome == Outcome.ONGOING) {\n            revert Errors.BattleNotEnd();\n        }\n        uint256 amount;\n        bool wasSpearWon = battleOutcome == Outcome.SPEAR_WIN;\n        if (wasSpearWon) {\n            amount = IERC20(spear).balanceOf(msg.sender);\n        } else {\n            amount = IERC20(shield).balanceOf(msg.sender);\n        }\n        if (amount > 0) {\n            if (wasSpearWon) {\n                ISToken(spear).burn(msg.sender, amount);\n            } else {\n                ISToken(shield).burn(msg.sender, amount);\n            }\n            uint256 exerciseFeeAmount = FullMath.mulDiv(amount, fee.exerciseFee, 1e6);\n            if (exerciseFeeAmount > 0) {\n                amount -= exerciseFeeAmount;\n                protocolFeeAmount += uint128(exerciseFeeAmount);\n            }\n            IERC20(_bk.collateral).safeTransfer(msg.sender, amount);\n            emit Exercised(msg.sender, wasSpearWon, amount);\n        }\n    }\n\n    /// @inheritdoc IBattleBase\n    function withdrawObligation(address recipient, uint256 amount) external override lock {\n        if (battleOutcome == Outcome.ONGOING) {\n            revert Errors.BattleNotEnd();\n        }\n        if (msg.sender != manager) {\n            revert Errors.CallerNotManager();\n        }\n        IERC20(_bk.collateral).safeTransfer(recipient, amount);\n        emit ObligationWithdrawed(recipient, amount);\n    }\n\n    /// comments see IBattleTrade\n    function collectProtocolFee(address recipient) external override lock {\n        require(IOwner(arena).owner() == msg.sender, \"only owner\");\n        uint256 _fee = protocolFeeAmount;\n        protocolFeeAmount = 0;\n        IERC20(_bk.collateral).safeTransfer(recipient, _fee);\n        emit ProtocolFeeCollected(recipient, _fee);\n    }\n\n    function collateralBalance() private view returns (uint256) {\n        return IERC20(_bk.collateral).balanceOf(address(this));\n    }\n\n    function positions(bytes32 positionKeyB32) external view override returns (PositionInfo memory info) {\n        info = _positions[positionKeyB32];\n    }\n\n    function battleKey() external view override returns (BattleKey memory) {\n        return _bk;\n    }\n\n    function startAndEndTS() external view override returns (uint256, uint256) {\n        return (startTS, _bk.expiries);\n    }\n\n    function spearBalanceOf(address account) external view override returns (uint256 amount) {\n        amount = IERC20(spear).balanceOf(account);\n    }\n\n    function shieldBalanceOf(address account) external view override returns (uint256 amount) {\n        amount = IERC20(shield).balanceOf(account);\n    }\n\n    function spearAndShield() external view override returns (address, address) {\n        return (spear, shield);\n    }\n\n    function getInsideLast(int24 tickLower, int24 tickUpper) external view override returns (GrowthX128 memory) {\n        return ticks.getGrowthInside(tickLower, tickUpper, slot0.tick, global);\n    }\n}"
    }
  ]
}