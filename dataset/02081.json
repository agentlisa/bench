{
  "Title": "H-15: Limit orders can be used to get a free look into the future",
  "Content": "# Issue H-15: Limit orders can be used to get a free look into the future \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/130 \n\n## Found by \nIllIllI\n\n## Summary\n\nUsers can continually update their orders to get a free look into prices in future blocks\n\n\n## Vulnerability Detail\n\nOrder execution relies on signed archived prices from off-chain oracles, where each price is stored along with the block range it applies to, and limit orders are only allowed to execute with oracle prices where the block is greater than the block in which the order was last updated. Since prices are required to be future prices, there is a time gap between when the last signed price was archived, and the new price for the next block is stored in the archive, and the order keeper is able to fetch it and submit an execution for it in the next block.\n\nThe example given by the sponsor in discord was:\n```text\nthe oracle process:\n\n1. the oracle node checks the latest price from reference exchanges and stores it with the oracle node's timestamp, e.g. time: 1000\n2. the oracle node checks the latest block of the blockchain, e.g. block 100, it stores this with the oracle node's timestamp as well\n3. the oracle node signs minOracleBlockNumber: 100, maxOracleBlockNumber: 100, timestamp: 1000, price: <price>\n4. the next time the loop runs is at time 1001, if the latest block of the blockchain is block 105, e.g. if 5 blocks were produced in that one second, then the oracle would sign\nminOracleBlockNumber: 101, maxOracleBlockNumber: 105, timestamp: 1001, price: <price>\n```\nhttps://discord.com/channels/812037309376495636/1073619363518758972/1083555347672862820\n\n\n## Impact\n\nIf a user has a pending exit order that was submitted a block N, and the user sees that the price at block N+1 will be more favorable, they can update their exit order, changing the amount by +/- 1 wei, and have the order execution delayed until the next block, at which point they can decided again whether the price and or impact is favorable, and whether to exit. In the sponsor's example, if the order was submitted at block 101, they have until block 105 to decide whether to update their order, since the order execution keeper won't be able to do the execution until block 106. There is a gas cost for doing such updates, but if the position is large enough, or the price is gapping enough, it is worth while to do this, especially if someone comes up with an automated service that does this on your behalf.\n\nThe more favorable price for the attacker is at the expense of the other side of the trade, and is a loss of capital for them.\n\n## Code Snippet\n\nLimit orders are executed by keepers and the keepers are required to provide signed prices _after_ the last order update:\n```solidity\n// File: gmx-synthetics/contracts/order/DecreaseOrderUtils.sol : DecreaseOrderUtils.validateOracleBlockNumbers()   #1\n\n139            if (\n140                orderType == Order.OrderType.LimitDecrease ||\n141                orderType == Order.OrderType.StopLossDecrease\n142            ) {\n143                uint256 latestUpdatedAtBlock = orderUpdatedAtBlock > positionIncreasedAtBlock ? orderUpdatedAtBlock : positionIncreasedAtBlock;\n144 @>             if (!minOracleBlockNumbers.areGreaterThan(latestUpdatedAtBlock)) {\n145                    OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n146                }\n147                return;\n148:           }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/order/DecreaseOrderUtils.sol#L139-L148\n\n```solidity\n// File: gmx-synthetics/contracts/order/DecreaseOrderUtils.sol : DecreaseOrderUtils.validateOracleBlockNumbers()   #2\n\n139            if (\n140                orderType == Order.OrderType.LimitDecrease ||\n141                orderType == Order.OrderType.StopLossDecrease\n142            ) {\n143                uint256 latestUpdatedAtBlock = orderUpdatedAtBlock > positionIncreasedAtBlock ? orderUpdatedAtBlock : positionIncreasedAtBlock;\n144 @>             if (!minOracleBlockNumbers.areGreaterThan(latestUpdatedAtBlock)) {\n145                    OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n146                }\n147                return;\n148:           }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/order/DecreaseOrderUtils.sol#L139-L148\n\n```solidity\n// File: gmx-synthetics/contracts/order/SwapOrderUtils.sol : SwapOrderUtils.validateOracleBlockNumbers()   #3\n\n66            if (orderType == Order.OrderType.LimitSwap) {\n67 @>             if (!minOracleBlockNumbers.areGreaterThan(orderUpdatedAtBlock)) {\n68                    OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, orderUpdatedAtBlock);\n69                }\n70                return;\n71:           }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/order/SwapOrderUtils.sol#L66-L71\n\n\nThe [ExchangeRouter.updateOrder()](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/router/ExchangeRouter.sol#L213-L233) function directly [updates](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/OrderHandler.sol#L82-L98) the storage details of the order (including [touching](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/order/Order.sol#L381-L383) the orderUpdatedAtBlock), without any execution keeper delay, and has no extra fees associated with it.\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nRequire a delay between when the order was last increased/submitted, and when an update is allowed, similar to [REQUEST_EXPIRATION_BLOCK_AGE](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/ExchangeUtils.sol#L24) for the cancellation of market orders\n\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/pull/111\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/order/DecreaseOrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderUtils.sol\";\nimport \"../swap/SwapUtils.sol\";\nimport \"../position/DecreasePositionUtils.sol\";\nimport \"../order/OrderStoreUtils.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\n// @title DecreaseOrderUtils\n// @dev Library for functions to help with processing a decrease order\nlibrary DecreaseOrderUtils {\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    // @dev process a decrease order\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function processOrder(BaseOrderUtils.ExecuteOrderParams memory params) external {\n        Order.Props memory order = params.order;\n        MarketUtils.validateEnabledMarket(params.contracts.dataStore, params.market);\n        MarketUtils.validatePositionMarket(params.market);\n\n        bytes32 positionKey = PositionUtils.getPositionKey(order.account(), order.market(), order.initialCollateralToken(), order.isLong());\n        Position.Props memory position = PositionStoreUtils.get(params.contracts.dataStore, positionKey);\n        PositionUtils.validateNonEmptyPosition(position);\n\n        validateOracleBlockNumbers(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            order.orderType(),\n            order.updatedAtBlock(),\n            position.increasedAtBlock(),\n            position.decreasedAtBlock()\n        );\n\n        DecreasePositionUtils.DecreasePositionResult memory result = DecreasePositionUtils.decreasePosition(\n            PositionUtils.UpdatePositionParams(\n                params.contracts,\n                params.market,\n                order,\n                params.key,\n                position,\n                positionKey\n            )\n        );\n\n        OrderStoreUtils.remove(params.contracts.dataStore, params.key, order.account());\n\n        // if the pnlToken and the collateralToken are different\n        // and if a swap fails or no swap was requested\n        // then it is possible to receive two separate tokens from decreasing\n        // the position\n        // transfer the two tokens to the user in this case and skip processing\n        // the swapPath\n        if (result.secondaryOutputAmount > 0) {\n            MarketToken(payable(order.market())).transferOut(\n                result.outputToken,\n                order.receiver(),\n                result.outputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            MarketToken(payable(order.market())).transferOut(\n                result.secondaryOutputToken,\n                order.receiver(),\n                result.secondaryOutputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            return;\n        }\n\n        if (order.swapPath().length == 0) {\n            MarketToken(payable(order.market())).transferOut(\n                result.outputToken,\n                order.receiver(),\n                result.outputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n        } else {\n            try params.contracts.swapHandler.swap(\n                SwapUtils.SwapParams(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.contracts.oracle,\n                    Bank(payable(order.market())),\n                    result.outputToken,\n                    result.outputAmount,\n                    params.swapPathMarkets,\n                    order.minOutputAmount(),\n                    order.receiver(),\n                    order.shouldUnwrapNativeToken()\n                )\n            ) returns (address /* tokenOut */, uint256 /* swapOutputAmount */) {\n            } catch Error(string memory reason) {\n                _handleSwapError(\n                    order,\n                    result,\n                    reason,\n                    \"\"\n                );\n            } catch (bytes memory reasonBytes) {\n                (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n                _handleSwapError(\n                    order,\n                    result,\n                    reason,\n                    reasonBytes\n                );\n            }\n        }\n    }\n\n    // @dev validate the oracle block numbers used for the prices in the oracle\n    // @param oracleBlockNumbers the oracle block numbers\n    // @param orderType the order type\n    // @param orderUpdatedAtBlock the block at which the order was last updated\n    // @param positionIncreasedAtBlock the block at which the position was last increased\n    // @param positionDecreasedAtBlock the block at which the position was last decreased\n    function validateOracleBlockNumbers(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        Order.OrderType orderType,\n        uint256 orderUpdatedAtBlock,\n        uint256 positionIncreasedAtBlock,\n        uint256 positionDecreasedAtBlock\n    ) internal pure {\n        if (orderType == Order.OrderType.MarketDecrease) {\n            OracleUtils.validateBlockNumberWithinRange(\n                minOracleBlockNumbers,\n                maxOracleBlockNumbers,\n                orderUpdatedAtBlock\n            );\n            return;\n        }\n\n        if (\n            orderType == Order.OrderType.LimitDecrease ||\n            orderType == Order.OrderType.StopLossDecrease\n        ) {\n            uint256 latestUpdatedAtBlock = orderUpdatedAtBlock > positionIncreasedAtBlock ? orderUpdatedAtBlock : positionIncreasedAtBlock;\n            if (!minOracleBlockNumbers.areGreaterThan(latestUpdatedAtBlock)) {\n                OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        if (orderType == Order.OrderType.Liquidation) {\n            uint256 latestUpdatedAtBlock = positionIncreasedAtBlock > positionDecreasedAtBlock ? positionIncreasedAtBlock : positionDecreasedAtBlock;\n\n            if (!minOracleBlockNumbers.areGreaterThan(latestUpdatedAtBlock)) {\n                OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        BaseOrderUtils.revertUnsupportedOrderType();\n    }\n\n    function _handleSwapError(\n        Order.Props memory order,\n        DecreasePositionUtils.DecreasePositionResult memory result,\n        string memory reason,\n        bytes memory reasonBytes\n    ) internal {\n        emit SwapUtils.SwapReverted(reason, reasonBytes);\n\n        MarketToken(payable(order.market())).transferOut(\n            result.outputToken,\n            order.receiver(),\n            result.outputAmount,\n            order.shouldUnwrapNativeToken()\n        );\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/order/DecreaseOrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderUtils.sol\";\nimport \"../swap/SwapUtils.sol\";\nimport \"../position/DecreasePositionUtils.sol\";\nimport \"../order/OrderStoreUtils.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\n// @title DecreaseOrderUtils\n// @dev Library for functions to help with processing a decrease order\nlibrary DecreaseOrderUtils {\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    // @dev process a decrease order\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function processOrder(BaseOrderUtils.ExecuteOrderParams memory params) external {\n        Order.Props memory order = params.order;\n        MarketUtils.validateEnabledMarket(params.contracts.dataStore, params.market);\n        MarketUtils.validatePositionMarket(params.market);\n\n        bytes32 positionKey = PositionUtils.getPositionKey(order.account(), order.market(), order.initialCollateralToken(), order.isLong());\n        Position.Props memory position = PositionStoreUtils.get(params.contracts.dataStore, positionKey);\n        PositionUtils.validateNonEmptyPosition(position);\n\n        validateOracleBlockNumbers(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            order.orderType(),\n            order.updatedAtBlock(),\n            position.increasedAtBlock(),\n            position.decreasedAtBlock()\n        );\n\n        DecreasePositionUtils.DecreasePositionResult memory result = DecreasePositionUtils.decreasePosition(\n            PositionUtils.UpdatePositionParams(\n                params.contracts,\n                params.market,\n                order,\n                params.key,\n                position,\n                positionKey\n            )\n        );\n\n        OrderStoreUtils.remove(params.contracts.dataStore, params.key, order.account());\n\n        // if the pnlToken and the collateralToken are different\n        // and if a swap fails or no swap was requested\n        // then it is possible to receive two separate tokens from decreasing\n        // the position\n        // transfer the two tokens to the user in this case and skip processing\n        // the swapPath\n        if (result.secondaryOutputAmount > 0) {\n            MarketToken(payable(order.market())).transferOut(\n                result.outputToken,\n                order.receiver(),\n                result.outputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            MarketToken(payable(order.market())).transferOut(\n                result.secondaryOutputToken,\n                order.receiver(),\n                result.secondaryOutputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            return;\n        }\n\n        if (order.swapPath().length == 0) {\n            MarketToken(payable(order.market())).transferOut(\n                result.outputToken,\n                order.receiver(),\n                result.outputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n        } else {\n            try params.contracts.swapHandler.swap(\n                SwapUtils.SwapParams(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.contracts.oracle,\n                    Bank(payable(order.market())),\n                    result.outputToken,\n                    result.outputAmount,\n                    params.swapPathMarkets,\n                    order.minOutputAmount(),\n                    order.receiver(),\n                    order.shouldUnwrapNativeToken()\n                )\n            ) returns (address /* tokenOut */, uint256 /* swapOutputAmount */) {\n            } catch Error(string memory reason) {\n                _handleSwapError(\n                    order,\n                    result,\n                    reason,\n                    \"\"\n                );\n            } catch (bytes memory reasonBytes) {\n                (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n                _handleSwapError(\n                    order,\n                    result,\n                    reason,\n                    reasonBytes\n                );\n            }\n        }\n    }\n\n    // @dev validate the oracle block numbers used for the prices in the oracle\n    // @param oracleBlockNumbers the oracle block numbers\n    // @param orderType the order type\n    // @param orderUpdatedAtBlock the block at which the order was last updated\n    // @param positionIncreasedAtBlock the block at which the position was last increased\n    // @param positionDecreasedAtBlock the block at which the position was last decreased\n    function validateOracleBlockNumbers(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        Order.OrderType orderType,\n        uint256 orderUpdatedAtBlock,\n        uint256 positionIncreasedAtBlock,\n        uint256 positionDecreasedAtBlock\n    ) internal pure {\n        if (orderType == Order.OrderType.MarketDecrease) {\n            OracleUtils.validateBlockNumberWithinRange(\n                minOracleBlockNumbers,\n                maxOracleBlockNumbers,\n                orderUpdatedAtBlock\n            );\n            return;\n        }\n\n        if (\n            orderType == Order.OrderType.LimitDecrease ||\n            orderType == Order.OrderType.StopLossDecrease\n        ) {\n            uint256 latestUpdatedAtBlock = orderUpdatedAtBlock > positionIncreasedAtBlock ? orderUpdatedAtBlock : positionIncreasedAtBlock;\n            if (!minOracleBlockNumbers.areGreaterThan(latestUpdatedAtBlock)) {\n                OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        if (orderType == Order.OrderType.Liquidation) {\n            uint256 latestUpdatedAtBlock = positionIncreasedAtBlock > positionDecreasedAtBlock ? positionIncreasedAtBlock : positionDecreasedAtBlock;\n\n            if (!minOracleBlockNumbers.areGreaterThan(latestUpdatedAtBlock)) {\n                OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        BaseOrderUtils.revertUnsupportedOrderType();\n    }\n\n    function _handleSwapError(\n        Order.Props memory order,\n        DecreasePositionUtils.DecreasePositionResult memory result,\n        string memory reason,\n        bytes memory reasonBytes\n    ) internal {\n        emit SwapUtils.SwapReverted(reason, reasonBytes);\n\n        MarketToken(payable(order.market())).transferOut(\n            result.outputToken,\n            order.receiver(),\n            result.outputAmount,\n            order.shouldUnwrapNativeToken()\n        );\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/order/SwapOrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderUtils.sol\";\nimport \"../swap/SwapUtils.sol\";\nimport \"../order/OrderStoreUtils.sol\";\n\n// @title SwapOrderUtils\n// @dev Library for functions to help with processing a swap order\nlibrary SwapOrderUtils {\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    error UnexpectedMarket();\n\n    // @dev process a swap order\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function processOrder(BaseOrderUtils.ExecuteOrderParams memory params) external {\n        if (params.order.market() != address(0)) {\n            revert UnexpectedMarket();\n        }\n\n        validateOracleBlockNumbers(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            params.order.orderType(),\n            params.order.updatedAtBlock()\n        );\n\n        SwapUtils.swap(SwapUtils.SwapParams(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.contracts.oracle,\n            params.contracts.orderVault,\n            params.order.initialCollateralToken(),\n            params.order.initialCollateralDeltaAmount(),\n            params.swapPathMarkets,\n            params.order.minOutputAmount(),\n            params.order.receiver(),\n            params.order.shouldUnwrapNativeToken()\n        ));\n\n        OrderStoreUtils.remove(params.contracts.dataStore, params.key, params.order.account());\n    }\n\n    // @dev validate the oracle block numbers used for the prices in the oracle\n    // @param oracleBlockNumbers the oracle block numbers\n    // @param orderType the order type\n    // @param orderUpdatedAtBlock the block at which the order was last updated\n    function validateOracleBlockNumbers(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        Order.OrderType orderType,\n        uint256 orderUpdatedAtBlock\n    ) internal pure {\n        if (orderType == Order.OrderType.MarketSwap) {\n            OracleUtils.validateBlockNumberWithinRange(\n                minOracleBlockNumbers,\n                maxOracleBlockNumbers,\n                orderUpdatedAtBlock\n            );\n            return;\n        }\n\n        if (orderType == Order.OrderType.LimitSwap) {\n            if (!minOracleBlockNumbers.areGreaterThan(orderUpdatedAtBlock)) {\n                OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, orderUpdatedAtBlock);\n            }\n            return;\n        }\n\n        BaseOrderUtils.revertUnsupportedOrderType();\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/router/ExchangeRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../exchange/DepositHandler.sol\";\nimport \"../exchange/WithdrawalHandler.sol\";\nimport \"../exchange/OrderHandler.sol\";\n\nimport \"../utils/PayableMulticall.sol\";\nimport \"../utils/ReceiverUtils.sol\";\n\nimport \"./Router.sol\";\n\n/**\n * @title ExchangeRouter\n * @dev Router for exchange functions, supports functions which require\n * token transfers from the user\n *\n * IMPORTANT: PayableMulticall uses delegatecall, msg.value will be the same for each delegatecall\n * extra care should be taken when using msg.value in any of the functions in this contract\n *\n * To avoid front-running issues, most actions require two steps to execute:\n *\n * - User sends transaction with request details, e.g. deposit / withdraw liquidity,\n * swap, increase / decrease position\n * - Keepers listen for the transactions, include the prices for the request then\n * send a transaction to execute the request\n *\n * Prices are provided by an off-chain oracle system:\n *\n * - Oracle keepers continually check the latest blocks\n * - When there is a new block, oracle keepers fetch the latest prices from\n * reference exchanges\n * - Oracle keepers then sign the median price for each token together with\n * the block hash\n * - Oracle keepers then send the data and signature to archive nodes\n * - Archive nodes display this information for anyone to query\n *\n * Example:\n *\n * - Block 100 is finalized on the blockchain\n * - Oracle keepers observe this block\n * - Oracle keepers pull the latest prices from reference exchanges,\n * token A: price 20,000, token B: price 80,000\n * - Oracle keepers sign [chainId, blockhash(100), 20,000], [chainId, blockhash(100), 80,000]\n * - If in block 100, there was a market order to open a long position for token A,\n * the market order would have a block number of 100\n * - The prices signed at block 100 can be used to execute this order\n * - Order keepers would bundle the signature and price data for token A\n * then execute the order\n */\ncontract ExchangeRouter is ReentrancyGuard, PayableMulticall, RoleModule {\n    using SafeERC20 for IERC20;\n    using Deposit for Deposit.Props;\n    using Withdrawal for Withdrawal.Props;\n    using Order for Order.Props;\n\n    Router public immutable router;\n    DataStore public immutable dataStore;\n    EventEmitter public immutable eventEmitter;\n    DepositHandler public immutable depositHandler;\n    WithdrawalHandler public immutable withdrawalHandler;\n    OrderHandler public immutable orderHandler;\n\n    error InvalidClaimFundingFeesInput(uint256 marketsLength, uint256 tokensLength);\n    error InvalidClaimCollateralInput(uint256 marketsLength, uint256 tokensLength, uint256 timeKeysLength);\n    error InvalidClaimAffiliateRewardsInput(uint256 marketsLength, uint256 tokensLength);\n\n    // @dev Constructor that initializes the contract with the provided Router, RoleStore, DataStore,\n    // EventEmitter, DepositHandler, WithdrawalHandler, OrderHandler, and OrderStore instances\n    constructor(\n        Router _router,\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        DepositHandler _depositHandler,\n        WithdrawalHandler _withdrawalHandler,\n        OrderHandler _orderHandler\n    ) RoleModule(_roleStore) {\n        router = _router;\n        dataStore = _dataStore;\n        eventEmitter = _eventEmitter;\n\n        depositHandler = _depositHandler;\n        withdrawalHandler = _withdrawalHandler;\n        orderHandler = _orderHandler;\n    }\n\n    // @dev Wraps the specified amount of native tokens into WNT then sends the WNT to the specified address\n    function sendWnt(address receiver, uint256 amount) external payable nonReentrant {\n        ReceiverUtils.validateReceiver(receiver);\n        TokenUtils.depositAndSendWrappedNativeToken(dataStore, receiver, amount);\n    }\n\n    // @dev Sends the given amount of tokens to the given address\n    function sendTokens(address token, address receiver, uint256 amount) external payable nonReentrant {\n        ReceiverUtils.validateReceiver(receiver);\n        address account = msg.sender;\n        router.pluginTransfer(token, account, receiver, amount);\n    }\n\n    /**\n     * @dev Creates a new deposit with the given long token, short token, long token amount, short token\n     * amount, and deposit parameters. The deposit is created by transferring the specified amounts of\n     * long and short tokens from the caller's account to the deposit store, and then calling the\n     * `createDeposit()` function on the deposit handler contract.\n     *\n     * @param params The deposit parameters, as specified in the `DepositUtils.CreateDepositParams` struct\n     * @return The unique ID of the newly created deposit\n     */\n    function createDeposit(\n        DepositUtils.CreateDepositParams calldata params\n    ) external payable nonReentrant returns (bytes32) {\n        address account = msg.sender;\n\n        return depositHandler.createDeposit(\n            account,\n            params\n        );\n    }\n\n    function cancelDeposit(bytes32 key) external payable nonReentrant {\n        Deposit.Props memory deposit = DepositStoreUtils.get(dataStore, key);\n        if (deposit.account() != msg.sender) {\n            revert Unauthorized(msg.sender, \"account for cancelDeposit\");\n        }\n\n        depositHandler.cancelDeposit(key);\n    }\n\n    /**\n     * @dev Creates a new withdrawal with the given withdrawal parameters. The withdrawal is created by\n     * calling the `createWithdrawal()` function on the withdrawal handler contract.\n     *\n     * @param params The withdrawal parameters, as specified in the `WithdrawalUtils.CreateWithdrawalParams` struct\n     * @return The unique ID of the newly created withdrawal\n     */\n    function createWithdrawal(\n        WithdrawalUtils.CreateWithdrawalParams calldata params\n    ) external payable nonReentrant returns (bytes32) {\n        address account = msg.sender;\n\n        return withdrawalHandler.createWithdrawal(\n            account,\n            params\n        );\n    }\n\n    function cancelWithdrawal(bytes32 key) external payable nonReentrant {\n        Withdrawal.Props memory withdrawal = WithdrawalStoreUtils.get(dataStore, key);\n        if (withdrawal.account() != msg.sender) {\n            revert Unauthorized(msg.sender, \"account for cancelWithdrawal\");\n        }\n\n        withdrawalHandler.cancelWithdrawal(key);\n    }\n\n    /**\n     * @dev Creates a new order with the given amount, order parameters. The order is\n     * created by transferring the specified amount of collateral tokens from the caller's account to the\n     * order store, and then calling the `createOrder()` function on the order handler contract. The\n     * referral code is also set on the caller's account using the referral storage contract.\n     */\n    function createOrder(\n        BaseOrderUtils.CreateOrderParams calldata params\n    ) external payable nonReentrant returns (bytes32) {\n        address account = msg.sender;\n\n        return orderHandler.createOrder(\n            account,\n            params\n        );\n    }\n\n    function simulateExecuteDeposit(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory simulatedOracleParams\n    ) external payable nonReentrant {\n        depositHandler.simulateExecuteDeposit(key, simulatedOracleParams);\n    }\n\n    function simulateExecuteWithdrawal(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory simulatedOracleParams\n    ) external payable nonReentrant {\n        withdrawalHandler.simulateExecuteWithdrawal(key, simulatedOracleParams);\n    }\n\n    function simulateExecuteOrder(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory simulatedOracleParams\n    ) external payable nonReentrant {\n        orderHandler.simulateExecuteOrder(key, simulatedOracleParams);\n    }\n\n    /**\n     * @dev Updates the given order with the specified size delta, acceptable price, and trigger price.\n     * The `updateOrder()` feature must be enabled for the given order type. The caller must be the owner\n     * of the order, and the order must not be a market order. The size delta, trigger price, and\n     * acceptable price are updated on the order, and the order is unfrozen. Any additional WNT that is\n     * transferred to the contract is added to the order's execution fee. The updated order is then saved\n     * in the order store, and an `OrderUpdated` event is emitted.\n     *\n     * @param key The unique ID of the order to be updated\n     * @param sizeDeltaUsd The new size delta for the order\n     * @param acceptablePrice The new acceptable price for the order\n     * @param triggerPrice The new trigger price for the order\n     */\n    function updateOrder(\n        bytes32 key,\n        uint256 sizeDeltaUsd,\n        uint256 acceptablePrice,\n        uint256 triggerPrice,\n        uint256 minOutputAmount\n    ) external payable nonReentrant {\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        if (order.account() != msg.sender) {\n            revert Unauthorized(msg.sender, \"account for updateOrder\");\n        }\n\n        orderHandler.updateOrder(\n            key,\n            sizeDeltaUsd,\n            acceptablePrice,\n            triggerPrice,\n            minOutputAmount,\n            order\n        );\n    }\n\n    /**\n     * @dev Cancels the given order. The `cancelOrder()` feature must be enabled for the given order\n     * type. The caller must be the owner of the order, and the order must not be a market order. The\n     * order is cancelled by calling the `cancelOrder()` function in the `OrderUtils` contract. This\n     * function also records the starting gas amount and the reason for cancellation, which is passed to\n     * the `cancelOrder()` function.\n     *\n     * @param key The unique ID of the order to be cancelled\n     */\n    function cancelOrder(bytes32 key) external payable nonReentrant {\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        if (order.account() != msg.sender) {\n            revert Unauthorized(msg.sender, \"account for cancelOrder\");\n        }\n\n        orderHandler.cancelOrder(key);\n    }\n\n    /**\n     * @dev Claims funding fees for the given markets and tokens on behalf of the caller, and sends the\n     * fees to the specified receiver. The length of the `markets` and `tokens` arrays must be the same.\n     * For each market-token pair, the `claimFundingFees()` function in the `MarketUtils` contract is\n     * called to claim the fees for the caller.\n     *\n     * @param markets An array of market addresses\n     * @param tokens An array of token addresses, corresponding to the given markets\n     * @param receiver The address to which the claimed fees should be sent\n     */\n    function claimFundingFees(\n        address[] memory markets,\n        address[] memory tokens,\n        address receiver\n    ) external payable nonReentrant {\n        if (markets.length != tokens.length) {\n            revert InvalidClaimFundingFeesInput(markets.length, tokens.length);\n        }\n\n        ReceiverUtils.validateReceiver(receiver);\n\n        address account = msg.sender;\n\n        for (uint256 i = 0; i < markets.length; i++) {\n            MarketUtils.claimFundingFees(\n                dataStore,\n                eventEmitter,\n                markets[i],\n                tokens[i],\n                account,\n                receiver\n            );\n        }\n    }\n\n    function claimCollateral(\n        address[] memory markets,\n        address[] memory tokens,\n        uint256[] memory timeKeys,\n        address receiver\n    ) external payable nonReentrant {\n        if (markets.length != tokens.length || tokens.length != timeKeys.length) {\n            revert InvalidClaimCollateralInput(markets.length, tokens.length, timeKeys.length);\n        }\n\n        ReceiverUtils.validateReceiver(receiver);\n\n        address account = msg.sender;\n\n        for (uint256 i = 0; i < markets.length; i++) {\n            MarketUtils.claimCollateral(\n                dataStore,\n                eventEmitter,\n                markets[i],\n                tokens[i],\n                timeKeys[i],\n                account,\n                receiver\n            );\n        }\n    }\n\n    /**\n     * @dev Claims affiliate rewards for the given markets and tokens on behalf of the caller, and sends\n     * the rewards to the specified receiver. The length of the `markets` and `tokens` arrays must be\n     * the same. For each market-token pair, the `claimAffiliateReward()` function in the `ReferralUtils`\n     * contract is called to claim the rewards for the caller.\n     *\n     * @param markets An array of market addresses\n     * @param tokens An array of token addresses, corresponding to the given markets\n     * @param receiver The address to which the claimed rewards should be sent\n     */\n    function claimAffiliateRewards(\n        address[] memory markets,\n        address[] memory tokens,\n        address receiver\n    ) external payable nonReentrant {\n        if (markets.length != tokens.length) {\n            revert InvalidClaimAffiliateRewardsInput(markets.length, tokens.length);\n        }\n\n        address account = msg.sender;\n\n        for (uint256 i = 0; i < markets.length; i++) {\n            ReferralUtils.claimAffiliateReward(\n                dataStore,\n                eventEmitter,\n                markets[i],\n                tokens[i],\n                account,\n                receiver\n            );\n        }\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/exchange/ExchangeUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../bank/StrictBank.sol\";\nimport \"../chain/Chain.sol\";\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\n\n// @title ExchangeUtils\n// @dev Library for exchange helper functions\nlibrary ExchangeUtils {\n    error RequestNotYetCancellable(uint256 requestAge, uint256 requestExpirationAge, string requestType);\n\n    // @dev validate that sufficient time has passed for request to be cancelled\n    // @param dataStore DataStore\n    // @param createdAtBlock the block the request was created at\n    // @param requestType the type of the request\n    function validateRequestCancellation(\n        DataStore dataStore,\n        uint256 createdAtBlock,\n        string memory requestType\n    ) internal view {\n        uint256 requestExpirationAge = dataStore.getUint(Keys.REQUEST_EXPIRATION_BLOCK_AGE);\n        uint256 requestAge = Chain.currentBlockNumber() - createdAtBlock;\n        if (requestAge < requestExpirationAge) {\n            revert RequestNotYetCancellable(requestAge, requestExpirationAge, requestType);\n        }\n    }\n}"
    }
  ]
}