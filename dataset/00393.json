{
  "Title": "M-1: OracleMaker's price with spread does not take into account the new position",
  "Content": "# Issue M-1: OracleMaker's price with spread does not take into account the new position \n\nSource: https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/25 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nIllIllI, PUSH0\n## Summary\n\nOracleMaker's `_getBasePriceWithSpread()` does not take into account the opening position's size, but only on the current position of the Maker.\n\nThis means there is no price impact protection against large trades (or any trades at all) for the Oracle Maker. Anyone can then bypass the spread by opening a reverse position before actually opening their intended position.\n\n## Vulnerability Detail\n\nTo reduce risky positions, the Oracle Maker will quote a slightly worse price (for the trader) than the actual Oracle price for any positions that increases risk. This is also mentioned in the [audit docs](https://perp.notion.site/PythOraclePool-e99a88be051f4bc8be0b1310eb982cd4), Dynamic Premium section.\n\nWhen a new position is requested, the Oracle Maker quotes a price that includes this spread:\n\n```solidity\nfunction fillOrder(\n    bool isBaseToQuote,\n    bool isExactInput,\n    uint256 amount,\n    bytes calldata\n) external onlyClearingHouse returns (uint256, bytes memory) {\n    uint256 basePrice = _getPrice();\n    uint256 basePriceWithSpread = _getBasePriceWithSpread(basePrice, isBaseToQuote); // @audit here\n```\n\nThere is no spread when the new position reduces risk (e.g. if the current Maker position is +3 ETH, and the new order implies -1 ETH, then the Maker will quote the oracle price directly).\n\nHowever, `_getBasePriceWithSpread()` never uses the order's amount, therefore large positions will be quoted the same price as small positions, i.e. there is no price impact. This issue also exists if the new position passes the zero mark, where the Maker thinks it's de-risking, while in reality it's being subject to much more risk in the opposite direction.\n- Suppose the Oracle Maker's current total position is 1 ETH long (+1 ETH)\n- Someone opens a 100 ETH long position, the Oracle Maker thinks it's de-risking by being able to open a 100 ETH short, and quotes the oracle price.\n- After the trade, the Maker is actually in a much riskier position of 99 ETH short (-99 ETH)\n\nAnyone can then bypass the spread completely (or partially) by opening a position in the opposite direction before the intended direction:\n- The Oracle Maker's current total position is 1 ETH long (+1 ETH).\n- Alice wants to open a 10 ETH long (+10 ETH) position.\n\nIf Alice sends a 10 ETH long order now, she would have to accept the base price spread and get a slightly worse price than the Pyth oracle price. However Alice can bypass the spread by sending the following two orders in quick succession to the relayer:\n- First order: 1 ETH short (-1 ETH)\n  - The Maker thinks it's de-risking, so it quotes the oracle price directly.\n  - After this order, the Maker has 0 ETH position.\n- Second order: 11 ETH long (+11 ETH)\n  - Since the Maker's position is zero, it quotes the oracle price.\n  - Alice has opened a net total of +10 ETH as intended. However she is not subject to the price spread.\n \nAlice was able to bypass the premium from the spread model, and force the Maker to quote exactly the Pyth oracle price. Note that Alice doesn't have to fully bypass the spread, she could have just opened a -0.5 ETH first and would still largely bypass the spread already. \n\n## Impact\n\n- Dynamic Premiums from the price spread can be bypassed completely, traders can always be quoted the oracle price without spread (or with a heavy reduction of the spread).\n- Maker is exposed to more risk than the intended design.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/OracleMaker.sol#L272\n\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/OracleMaker.sol#L401-L409\n\n## Tool used\n\nManual review\n\n## Recommendation\n\n`_getBasePriceWithSpread()` must take into account the average spread of the Maker's position before and after the trade, not just the position before the trade.\n- See proof [here](https://sips.synthetix.io/sips/sip-279/#technical-specification). Note this formula still works when the new position movement crosses the zero mark, as the integral of a constant zero function is zero.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**santipu_** commented:\n> Medium\n\n\n\n**rc56**\n\n@lnxrp: \n- Won't fix\n- It is true that the trick (reverse position before actually opening their intended position) could bypass OracleMaker's  spread, but the impact is considered a degradation (high risk exposure without proper compensation) of maker performance instead of a critical vulnerability\n- Note the maker has `minMarginRatio` which protects it from taking too much exposure. The parameter had been set conservative (`minMarginRatio = 100%`) from the start so we have extra safety margin to observe its real-world performance and improve it iteratively\n\n**midori-fuse**\n\nEscalate\n\nWe have shown the method to bypass the Oracle Maker's spread, which is meant to be the protection against large exposures. This attack also has no external conditions: With any amount of margin, you can still partially bypass the spread. Larger margin only maximizes the impact, but smaller margin does not prevent it in any way.\n\nThe effect of bypassing the premium is that the Oracle Maker is forced to take positions without spread (or with a heavy reduction). Elaborating on this, this means that the Oracle Maker is forced to take the same position size for a larger (absolute) open notional. This translates to a direct loss should the price moves in any direction:\n- If the price goes in the favor of the Oracle Maker's position, the larger open notional decreases the Maker's profit.\n- If the price goes against the favor of the Oracle Maker's position, the larger open notional increases the Maker's loss.\n\nNote that we are only elaborating what is already written in our report (elaborating the direct effect of the Maker quoting a less favorable price). The elaborated info only arises from the definition of a standard perpetual contract, and we are adding no additional info.\n\nTherefore the impact translates to direct loss under any resulting price movements. Because it also has no external conditions for this trick to be possible, I believe this fits into the criteria of a High risk issue.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> We have shown the method to bypass the Oracle Maker's spread, which is meant to be the protection against large exposures. This attack also has no external conditions: With any amount of margin, you can still partially bypass the spread. Larger margin only maximizes the impact, but smaller margin does not prevent it in any way.\n> \n> The effect of bypassing the premium is that the Oracle Maker is forced to take positions without spread (or with a heavy reduction). Elaborating on this, this means that the Oracle Maker is forced to take the same position size for a larger (absolute) open notional. This translates to a direct loss should the price moves in any direction:\n> - If the price goes in the favor of the Oracle Maker's position, the larger open notional decreases the Maker's profit.\n> - If the price goes against the favor of the Oracle Maker's position, the larger open notional increases the Maker's loss.\n> \n> Note that we are only elaborating what is already written in our report (elaborating the direct effect of the Maker quoting a less favorable price). The elaborated info only arises from the definition of a standard perpetual contract, and we are adding no additional info.\n> \n> Therefore the impact translates to direct loss under any resulting price movements. Because it also has no external conditions for this trick to be possible, I believe this fits into the criteria of a High risk issue.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nirohgo**\n\nEscalate\n\nThis is low/informational\n\n\nThe attack described can not be performed as described. This is because traders can only open positions with the Oracle Maker through the relayer. This means there is no way to know which other orders will be settled before or between the two attack steps (or even their order of execution). The Oracle Maker position direction can change direction in the meantime, making the attacker get a worse price instead of better. Even if the Oracle Maker enabled direct interaction there would still be the risk of other transactions getting in before the attacker and changing the OM position direction.\n\nWithout the attack, this is a design improvement and not a medium severity finding.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This is low/informational\n> \n> \n> The attack described can not be performed as described. This is because traders can only open positions with the Oracle Maker through the relayer. This means there is no way to know which other orders will be settled before or between the two attack steps (or even their order of execution). The Oracle Maker position direction can change direction in the meantime, making the attacker get a worse price instead of better. Even if the Oracle Maker enabled direct interaction there would still be the risk of other transactions getting in before the attacker and changing the OM position direction.\n> \n> Without the attack, this is a design improvement and not a medium severity finding.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\n@nevillehuang what's your response to these escalations? \n\nFrom my understanding, is it possible to execute these two orders in the same block/tx? Or does it depend on external transaction (oracle price update) between the two orders?  \n\n**midori-fuse**\n\nAccording to the contest README:\n\n> The relayer may have some value extraction strategies available (for example by delaying the execution of the orders), and is trusted not to use them.\n\nWhile it is not possible to execute two orders in the same tx, opening two orders in quick succession should still not be difficult (you just literally make actions quickly no?). If the relayer is trusted to resolve orders without utilizing any value-extraction strategies, then it is trusted to resolve orders in a timely manner, in the order it received.\n\nRelayer should update the oracle price before each order anyway (it is stated that the protocol will use `Multicaller`, so it should be assumed that the Oracle Maker's price at the time of order is always fresh). However if you open orders quickly (in, say, a few seconds, or even less than a second if you can make two mouse clicks quickly), then the oracle price change should not be substantially large, and the chances of any order getting in between is extremely low (not mentioning changing maker position directions as a whole).\n\n**nirohgo**\n\nThe arrival of orders sent to an offchain relayer depends on networking, so its not even guaranteed that your orders will get to the relayer at the order you sent them, let alone other orders getting before/in between your orders. If trade volume is high it's even likely. The point is the attacker will be taking a risk that I don't think is justified by the potential gain. \n\n**midori-fuse**\n\nNetwork related factors are dependent on the admin and external admin.\n- Because admins are trusted, whichever endpoint that is used to relay orders are also trusted to be live and relaying the correct information. \n- If your own network has a problem, then it's your problem, and completely out of scope. \n\n**nevillehuang**\n\n@midori-fuse Given this constraint [highlighted here](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/25#issuecomment-2043867651), I believe medium severity is appropriate. Do you agree?\n\n**midori-fuse**\n\nNo, unfortunately I don't agree that the constraint makes sense. \n\nFirst of all, as I have stated, network congestion related factors are related to the external admin and your own network, which has to be assumed to be trusted to provide reliable service.\n\nSecond of all, even given that \"constraint\", you can open orders, say, two seconds apart, for a completely negligible oracle price difference with the same bypassing effect, and the risk that the price moves sharply within those two seconds is epsilon.\n\n**nirohgo**\n\nTo clarify, this in not due to a problem in network congestion, or a problem with the internet on any side (sender or receiver). It's just the way that TCP/IP works. Two messages leaving from point A to B at virtually the same time can and often do take entirely different routes and arrive at different times (and order). Also, because any random order may shift the position direction, orders that interfere include orders that left well before the attacker's.\n\n**midori-fuse**\n\nEven so, it does not change the fact that two orders can still be made one after another, in a reliable fashion by introducing a very small delay between them. \n\nAnd even without the attack, we have shown that large trades has no price impact compared to smaller trades that makes up the same sum. Because this results in both:\n- Exposure to higher risk against the same price sum, equating to a guaranteed loss.\n- Enables a path that bypasses the spread directly, forcing the maker to quote a higher price than design. The mentioned risk can be controlled by choosing the appropriate delay between orders, and literally just by having a stable connection. \n  - Furthermore the Maker has to actually change position from negative to positive and vice-versa in the meantime, which we believe is too high of an assumption to be considered an attack risk.\n\nwe still believe this is a High risk issue.\n\n**Czar102**\n\nI think this report lies on the Med/High borderline, but closer to the Medium severity issue â€“ the loss is only the loss of fees, the attacker has no way of predicting the price anyway.\n\nI don't think the point in @nirohgo's escalation weights a lot into this judgment.\n\nPlanning to reject both escalations and leave the issue as is.\n\n**midori-fuse**\n\nIt is indeed true that the loss is only a loss of fees (even if it can be bypassed completely).\n\nHowever the loss here is directed towards Oracle Maker LPs and not the protocol. Furthermore, the issue isn't about a price-based attack, it's a general trick/exploit path to open better positions than the design for traders. The higher the Maker's position, the higher the fee loss, since the premium there is also larger.\n\nSo I still think it's a High, since I see loss of fees towards LPs equates to loss of funds. \n\nHowever I do believe the context on the issue is clear now, and it's a matter of judgement instead of on further analyzing the issue.\n\n**WangSecurity**\n\nAgree with what Czar said above, the only loss are fees and the attack depends on external factors to be true, since the caller cannot control if their transactions will be executed one right after another.\n\nPlanning to reject the escalation and leave the issue as it is.\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [midori-fuse](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/25/#issuecomment-2037044881): rejected\n- [nirohgo](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/25/#issuecomment-2041346175): rejected\n\n**nirohgo**\n\n@Evert0x my escalation should not be rejected here because it affected the decision on the original escalation (\"the only loss are fees and the attack depends on external factors to be true, since the caller cannot control if their transactions will be executed one right after another.\") my escalation demonstrated that  the caller cannot control if their transactions will be executed one right after another.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/219",
  "Code": [
    {
      "filename": "perp-contract-v3/src/maker/OracleMaker.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { LibFormatter } from \"../common/LibFormatter.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { INTERNAL_DECIMALS, WAD } from \"../common/LibConstant.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { IMaker } from \"./IMaker.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { ContextBase } from \"../common/ContextBase.sol\";\nimport { IPythOracleAdapter } from \"../oracle/pythOracleAdapter/IPythOracleAdapter.sol\";\nimport { IWhitelistLpManager } from \"./IWhitelistLpManager.sol\";\n\n// Price from Pyth is predictable due to the latency between prices arriving at Pyth price service\n// and those prices appearing on-chain.\n// See https://sips.synthetix.io/sips/sip-285/#rationale\n//\n// This predictable price can be exploited by a front-runner, so any trade on OracleMaker must be 2-step, aka \"delayed\",\n// and can only be interacted with through OrderGateway and OrderGatewayV2. This is configurable\n// via OracleMaker.setValidSender().\ncontract OracleMaker is ContextBase, AddressResolverUpgradeable, Ownable2StepUpgradeable, ERC20Upgradeable, IMaker {\n    using SafeERC20 for IERC20Metadata;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using FixedPointMathLib for uint256;\n    using LibFormatter for uint256;\n    using LibFormatter for int256;\n    using LibAddressResolver for IAddressManager;\n\n    //\n    // STRUCT\n    //\n\n    /// @custom:storage-location erc7201:perp.storage.oracleMaker\n    struct OracleMakerStorage {\n        uint256 marketId;\n        bytes32 priceFeedId;\n        /// @notice the minimum margin ratio required for trade or withdrawal\n        uint256 minMarginRatio; // Min. marign ratio required by the maker at all time.\n        /// @notice max spread ratio is the \"given\" in stoikov maker\n        /// @dev price = maxSpreadRatio * positionRate\n        /// @dev when maker has long, positionRate = min(100%, openNotional * minMarginRatio / freeCollateralForOpen)\n        /// @dev when maker has short, positionRate = max(100%, openNotional * minMarginRatio / freeCollateralForOpen)\n        uint256 maxSpreadRatio;\n        mapping(address => bool) validSenderMap;\n    }\n\n    event Deposited(\n        address depositor,\n        uint256 shares, // Amount of share minted\n        uint256 underlying // Amount of underlying token deposited\n    );\n\n    event Withdrawn(\n        address withdrawer,\n        uint256 shares, // Amount of shares burnt\n        uint256 underlying // Amount of underlying tokens withdrawn\n    );\n\n    /// @notice Emitted when an order is being filled by a Pyth Oracle Maker.\n    ///         It reveals all information associated to the trade price.\n    event OMOrderFilled(\n        uint256 marketId,\n        uint256 oraclePrice, // In quote asset as wei, assume price >= 0\n        int256 baseAmount, // Base token amount filled (from taker's perspective)\n        int256 quoteAmount // Quote token amount filled (from taker's perspective)\n    );\n\n    event PriceFeedIdSet(bytes32 newPriceFeedId, bytes32 oldPriceFeedId);\n\n    event MinMarginRatioSet(uint256 newMinMarginRatio, uint256 oldMinMarginRatio);\n    event MaxSpreadRatioSet(uint256 newMaxSpreadRatio, uint256 oldMaxSpreadRatio);\n\n    //\n    // STATE\n    //\n\n    // keccak256(abi.encode(uint256(keccak256(\"perp.storage.oracleMaker\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant _ORACLE_MAKER_STORAGE_LOCATION =\n        0x49404affd0747f1de28f32f44120f8f18db1aa69644f83b133007475ed402e00;\n\n    //\n    // MODIFIER\n    //\n    modifier onlyClearingHouse() {\n        if (msg.sender != address(getAddressManager().getClearingHouse())) revert LibError.Unauthorized();\n        _;\n    }\n\n    modifier onlyWhitelistLp() {\n        IWhitelistLpManager whitelistManager = getAddressManager().getWhitelistLpManager();\n        if (address(whitelistManager) != address(0)) {\n            if (!whitelistManager.isLpWhitelisted(_sender())) revert LibError.Unauthorized();\n        }\n        _;\n    }\n\n    //\n    // EXTERNAL NON-VIEW\n    //\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 marketId_,\n        string memory name_,\n        string memory symbol_,\n        address addressManager_,\n        bytes32 priceFeedId_,\n        uint256 minMarginRatio_\n    ) external initializer {\n        __AddressResolver_init(addressManager_);\n        __Ownable2Step_init();\n        __Ownable_init(msg.sender);\n        __ERC20_init(name_, symbol_);\n\n        if (!getAddressManager().getPythOracleAdapter().priceFeedExists(priceFeedId_))\n            revert LibError.IllegalPriceFeed(priceFeedId_);\n\n        _getOracleMakerStorage().marketId = marketId_;\n        setPriceFeedId(priceFeedId_);\n        setMinMarginRatio(minMarginRatio_);\n    }\n\n    function setPriceFeedId(bytes32 _priceFeedId) public onlyOwner {\n        if (!getAddressManager().getPythOracleAdapter().priceFeedExists(_priceFeedId))\n            revert LibError.IllegalPriceFeed(_priceFeedId);\n\n        bytes32 oldPriceFeedId = _getOracleMakerStorage().priceFeedId;\n        _getOracleMakerStorage().priceFeedId = _priceFeedId;\n\n        emit PriceFeedIdSet(_priceFeedId, oldPriceFeedId);\n    }\n\n    function setMinMarginRatio(uint256 _minMarginRatio) public onlyOwner {\n        if (_minMarginRatio > WAD) {\n            revert LibError.InvalidRatio(_minMarginRatio);\n        }\n        if (_minMarginRatio == 0) {\n            revert LibError.ZeroRatio();\n        }\n        uint256 oldMinMarginRatio = _getOracleMakerStorage().minMarginRatio;\n        _getOracleMakerStorage().minMarginRatio = _minMarginRatio;\n\n        emit MinMarginRatioSet(_minMarginRatio, oldMinMarginRatio);\n    }\n\n    function setMaxSpreadRatio(uint256 _maxSpreadRatio) public onlyOwner {\n        if (_maxSpreadRatio > WAD) {\n            revert LibError.InvalidRatio(_maxSpreadRatio);\n        }\n        uint256 oldMaxSpreadRatio = _getOracleMakerStorage().maxSpreadRatio;\n        _getOracleMakerStorage().maxSpreadRatio = _maxSpreadRatio;\n\n        emit MaxSpreadRatioSet(_maxSpreadRatio, oldMaxSpreadRatio);\n    }\n\n    function setValidSender(address user, bool isValid) public onlyOwner {\n        _getOracleMakerStorage().validSenderMap[user] = isValid;\n    }\n\n    function deposit(uint256 amountXCD) external onlyWhitelistLp returns (uint256) {\n        address depositor = _sender();\n        address maker = address(this);\n\n        if (amountXCD == 0) revert LibError.ZeroAmount();\n\n        IERC20Metadata collateralToken = IERC20Metadata(_getAsset());\n        IAddressManager addressManager = getAddressManager();\n        IVault vault = addressManager.getVault();\n\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = amountXCD;\n        } else {\n            uint256 price = _getPrice();\n\n            // TODO Should consider slippage once maker has spread or other pricing logic.\n            // For now, we will just get account value from ClearingHouse (assume no slippages).\n            // shares per asset = share (share token precision) / accountValue (INTERNAL_DECIMALS)\n            // shares (share token precision) = assets (base token precision) * shares per asset\n\n            // TODO: We should add protections to prevent attackers from manipulating the share price by manipulating oracle reported price.\n            // This is because the attacker could potentially mint large amount of shares by forcing the account value low.\n            // Possible protections like rate limiting share price, or any kind of volatility check.\n\n            uint8 shareDecimals = decimals();\n            uint256 vaultValueXShareDecimals = _getVaultValueSafe(vault, price).formatDecimals(\n                INTERNAL_DECIMALS,\n                shareDecimals\n            );\n            uint256 amountXShareDecimals = amountXCD.formatDecimals(collateralToken.decimals(), shareDecimals);\n            shares = (amountXShareDecimals * totalSupply()) / vaultValueXShareDecimals;\n        }\n\n        uint256 balanceBefore = collateralToken.balanceOf(maker);\n        collateralToken.safeTransferFrom(_sender(), maker, amountXCD);\n        uint256 transferredAmount = collateralToken.balanceOf(maker) - balanceBefore;\n\n        if (transferredAmount != amountXCD) {\n            revert LibError.WrongTransferAmount(transferredAmount, amountXCD);\n        }\n\n        collateralToken.approve(address(vault), amountXCD);\n        vault.deposit(maker, amountXCD);\n        vault.transferFundToMargin(_getOracleMakerStorage().marketId, amountXCD);\n\n        _mint(depositor, shares);\n\n        emit Deposited(depositor, shares, amountXCD);\n\n        return shares;\n    }\n\n    function withdraw(uint256 shares) external onlyWhitelistLp returns (uint256) {\n        address withdrawer = _sender();\n\n        if (shares == 0) revert LibError.ZeroAmount();\n\n        // Must done before burn.\n        uint256 redeemedRatio = shares.divWad(totalSupply());\n\n        // Revert early if shares amount exceeds balance\n        _burn(withdrawer, shares);\n\n        IVault vault = _getVault();\n\n        uint256 price = _getPrice();\n        uint256 vaultValue = _getVaultValueSafe(vault, price);\n        IERC20Metadata collateralToken = IERC20Metadata(_getAsset());\n        uint256 withdrawnAmountXCD = vaultValue.mulWad(redeemedRatio).formatDecimals(\n            INTERNAL_DECIMALS,\n            collateralToken.decimals()\n        );\n\n        // It may not be possible to withdraw the required amount, due to unsettledPnl that cannot be settled totally.\n        vault.transferMarginToFund(_getOracleMakerStorage().marketId, withdrawnAmountXCD);\n        vault.withdraw(withdrawnAmountXCD);\n        collateralToken.safeTransfer(withdrawer, withdrawnAmountXCD);\n\n        _checkMinMarginRatio(price);\n\n        emit Withdrawn(withdrawer, shares, withdrawnAmountXCD);\n\n        return withdrawnAmountXCD;\n    }\n\n    function fillOrderCallback(bytes calldata) external view onlyClearingHouse {\n        _checkMinMarginRatio(_getPrice());\n    }\n\n    function fillOrder(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount,\n        bytes calldata\n    ) external onlyClearingHouse returns (uint256, bytes memory) {\n        uint256 basePrice = _getPrice();\n        uint256 basePriceWithSpread = _getBasePriceWithSpread(basePrice, isBaseToQuote);\n\n        // - `amount` base -> `amount * basePrice` quote\n        //   (isBaseToQuote=true, isExactInput=true, openNotional = `amount * basePrice`)\n        // - `amount` base <- `amount * basePrice` quote\n        //   (isBaseToQuote=false, isExactInput=false, openNotional = -`amount * basePrice`)\n        // - `amount / basePrice` base -> `amount` quote\n        //   (isBaseToQuote=true, isExactInput=false, openNotional = `amount`)\n        // - `amount / basePrice` base <- `amount` quote\n        //   (isBaseToQuote=false, isExactInput=true, openNotional = -`amount`)\n\n        int256 baseAmount;\n        int256 quoteAmount;\n        uint256 oppositeAmount;\n        if (isBaseToQuote) {\n            if (isExactInput) {\n                // TODO: Should use configed decimal number instead of hard-coding\n                oppositeAmount = (amount * basePriceWithSpread) / 1 ether;\n                baseAmount = -amount.toInt256();\n                quoteAmount = oppositeAmount.toInt256();\n            } else {\n                oppositeAmount = (amount * 1 ether) / basePriceWithSpread;\n                baseAmount = -oppositeAmount.toInt256();\n                quoteAmount = amount.toInt256();\n            }\n        } else {\n            if (isExactInput) {\n                oppositeAmount = (amount * 1 ether) / basePriceWithSpread;\n                baseAmount = oppositeAmount.toInt256();\n                quoteAmount = -amount.toInt256();\n            } else {\n                oppositeAmount = (amount * basePriceWithSpread) / 1 ether;\n                baseAmount = amount.toInt256();\n                quoteAmount = -oppositeAmount.toInt256();\n            }\n        }\n        emit OMOrderFilled(_getOracleMakerStorage().marketId, basePrice, baseAmount, quoteAmount);\n        return (oppositeAmount, new bytes(0));\n    }\n\n    //\n    // EXTERNAL VIEW\n    //\n\n    function getUtilRatio() external view returns (uint256, uint256) {\n        if (totalSupply() == 0) {\n            return (0, 0);\n        }\n\n        IVault vault = _getVault();\n        int256 positionSize = vault.getPositionSize(_getOracleMakerStorage().marketId, address(this));\n\n        if (positionSize == 0) {\n            return (0, 0);\n        }\n\n        uint256 price = _getPrice();\n        int256 positionRate = _getPositionRate(price);\n        // position rate > 0, maker has long position, set long util ratio to 0 so taker tends to long\n        // position rate < 0, maker has short position, set short util ratio to 0 so taker tends to short\n        return positionRate > 0 ? (uint256(0), positionRate.toUint256()) : ((-positionRate).toUint256(), uint256(0));\n    }\n\n    function isValidSender(address sender) external view returns (bool) {\n        return _getOracleMakerStorage().validSenderMap[sender];\n    }\n\n    function getAsset() external view returns (address) {\n        return _getAsset();\n    }\n\n    function getTotalAssets(uint256 price) external view returns (int256) {\n        IVault vault = _getVault();\n        IERC20Metadata collateralToken = IERC20Metadata(_getAsset());\n        return _getVaultValue(vault, price).formatDecimals(INTERNAL_DECIMALS, collateralToken.decimals());\n    }\n\n    // For backward-compatibility\n    function marketId() external view returns (uint256) {\n        return _getOracleMakerStorage().marketId;\n    }\n\n    // For backward-compatibility\n    function priceFeedId() external view returns (bytes32) {\n        return _getOracleMakerStorage().priceFeedId;\n    }\n\n    // For backward-compatibility\n    function minMarginRatio() external view returns (uint256) {\n        return _getOracleMakerStorage().minMarginRatio;\n    }\n\n    // For backward-compatibility\n    function maxSpreadRatio() external view returns (uint256) {\n        return _getOracleMakerStorage().maxSpreadRatio;\n    }\n\n    //\n    // INTERNAL VIEW\n    //\n    function _getVault() internal view returns (IVault) {\n        return getAddressManager().getVault();\n    }\n\n    // FIXME: when over minMarginRatio, should allow reduce maker position\n    function _checkMinMarginRatio(uint256 price) internal view {\n        uint256 marketId_ = _getOracleMakerStorage().marketId;\n        int256 marginRatio = _getVault().getMarginRatio(marketId_, address(this), price);\n        int256 minMarginRatio_ = _getOracleMakerStorage().minMarginRatio.toInt256();\n        if (marginRatio < minMarginRatio_) revert LibError.MinMarginRatioExceeded(marginRatio, minMarginRatio_);\n    }\n\n    function _getAsset() internal view returns (address) {\n        return getAddressManager().getVault().getCollateralToken();\n    }\n\n    function _getVaultValue(IVault vault, uint256 price) internal view returns (int256) {\n        uint256 marketId_ = _getOracleMakerStorage().marketId;\n        return vault.getAccountValue(marketId_, address(this), price);\n    }\n\n    function _getVaultValueSafe(IVault vault, uint256 price) internal view returns (uint256) {\n        // Revert early since we don't allow deposit/withdraw when the vault's value is negative or zero.\n        int256 vaultValue = _getVaultValue(vault, price);\n        if (vaultValue <= 0) revert LibError.NegativeOrZeroVaultValueInQuote(vaultValue);\n\n        return vaultValue.toUint256();\n    }\n\n    function _getBasePriceWithSpread(uint256 basePrice, bool isBaseToQuote) internal view returns (uint256) {\n        int256 positionRate = _getPositionRate(basePrice);\n        int256 spreadRatio = (_getOracleMakerStorage().maxSpreadRatio.toInt256() * positionRate) / 1 ether;\n        uint256 reservationPrice = (basePrice * (1 ether - spreadRatio).toUint256()) / 1 ether;\n        return\n            isBaseToQuote\n                ? FixedPointMathLib.min(basePrice, reservationPrice)\n                : FixedPointMathLib.max(basePrice, reservationPrice);\n    }\n\n    function _getPositionRate(uint256 price) internal view returns (int256) {\n        IVault vault = _getVault();\n        uint256 marketId_ = _getOracleMakerStorage().marketId;\n        int256 accountValue = vault.getAccountValue(marketId_, address(this), price);\n        int256 unrealizedPnl = vault.getUnrealizedPnl(marketId_, address(this), price);\n        int256 unsettledMargin = accountValue - unrealizedPnl;\n        int256 collateralForOpen = FixedPointMathLib.min(unsettledMargin, accountValue);\n        // TODO: use positionMarginRequirement\n        //int256 collateralForOpen = positionMarginRequirement + freeCollateralForOpen;\n        if (collateralForOpen <= 0) {\n            revert LibError.NegativeOrZeroMargin();\n        }\n\n        int256 maxPositionNotional = (collateralForOpen * 1 ether) / _getOracleMakerStorage().minMarginRatio.toInt256();\n\n        // if maker has long position, positionRate > 0\n        // if maker has short position, positionRate < 0\n        int256 openNotional = vault.getOpenNotional(marketId_, address(this));\n        int256 uncappedPositionRate = (-openNotional * 1 ether) / maxPositionNotional;\n\n        // util ratio: 0 ~ 1\n        // position rate: -1 ~ 1\n        return\n            uncappedPositionRate > 0\n                ? FixedPointMathLib.min(uncappedPositionRate, 1 ether)\n                : FixedPointMathLib.max(uncappedPositionRate, -1 ether);\n    }\n\n    function _getPrice() internal view returns (uint256) {\n        IPythOracleAdapter pythOracleAdapter = getAddressManager().getPythOracleAdapter();\n        (uint256 price, ) = pythOracleAdapter.getPrice(_getOracleMakerStorage().priceFeedId);\n        return price;\n    }\n\n    //\n    // PRIVATE\n    //\n\n    function _getOracleMakerStorage() private pure returns (OracleMakerStorage storage $) {\n        assembly {\n            $.slot := _ORACLE_MAKER_STORAGE_LOCATION\n        }\n    }\n}"
    },
    {
      "filename": "perp-contract-v3/src/maker/OracleMaker.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { LibFormatter } from \"../common/LibFormatter.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { INTERNAL_DECIMALS, WAD } from \"../common/LibConstant.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { IMaker } from \"./IMaker.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { ContextBase } from \"../common/ContextBase.sol\";\nimport { IPythOracleAdapter } from \"../oracle/pythOracleAdapter/IPythOracleAdapter.sol\";\nimport { IWhitelistLpManager } from \"./IWhitelistLpManager.sol\";\n\n// Price from Pyth is predictable due to the latency between prices arriving at Pyth price service\n// and those prices appearing on-chain.\n// See https://sips.synthetix.io/sips/sip-285/#rationale\n//\n// This predictable price can be exploited by a front-runner, so any trade on OracleMaker must be 2-step, aka \"delayed\",\n// and can only be interacted with through OrderGateway and OrderGatewayV2. This is configurable\n// via OracleMaker.setValidSender().\ncontract OracleMaker is ContextBase, AddressResolverUpgradeable, Ownable2StepUpgradeable, ERC20Upgradeable, IMaker {\n    using SafeERC20 for IERC20Metadata;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using FixedPointMathLib for uint256;\n    using LibFormatter for uint256;\n    using LibFormatter for int256;\n    using LibAddressResolver for IAddressManager;\n\n    //\n    // STRUCT\n    //\n\n    /// @custom:storage-location erc7201:perp.storage.oracleMaker\n    struct OracleMakerStorage {\n        uint256 marketId;\n        bytes32 priceFeedId;\n        /// @notice the minimum margin ratio required for trade or withdrawal\n        uint256 minMarginRatio; // Min. marign ratio required by the maker at all time.\n        /// @notice max spread ratio is the \"given\" in stoikov maker\n        /// @dev price = maxSpreadRatio * positionRate\n        /// @dev when maker has long, positionRate = min(100%, openNotional * minMarginRatio / freeCollateralForOpen)\n        /// @dev when maker has short, positionRate = max(100%, openNotional * minMarginRatio / freeCollateralForOpen)\n        uint256 maxSpreadRatio;\n        mapping(address => bool) validSenderMap;\n    }\n\n    event Deposited(\n        address depositor,\n        uint256 shares, // Amount of share minted\n        uint256 underlying // Amount of underlying token deposited\n    );\n\n    event Withdrawn(\n        address withdrawer,\n        uint256 shares, // Amount of shares burnt\n        uint256 underlying // Amount of underlying tokens withdrawn\n    );\n\n    /// @notice Emitted when an order is being filled by a Pyth Oracle Maker.\n    ///         It reveals all information associated to the trade price.\n    event OMOrderFilled(\n        uint256 marketId,\n        uint256 oraclePrice, // In quote asset as wei, assume price >= 0\n        int256 baseAmount, // Base token amount filled (from taker's perspective)\n        int256 quoteAmount // Quote token amount filled (from taker's perspective)\n    );\n\n    event PriceFeedIdSet(bytes32 newPriceFeedId, bytes32 oldPriceFeedId);\n\n    event MinMarginRatioSet(uint256 newMinMarginRatio, uint256 oldMinMarginRatio);\n    event MaxSpreadRatioSet(uint256 newMaxSpreadRatio, uint256 oldMaxSpreadRatio);\n\n    //\n    // STATE\n    //\n\n    // keccak256(abi.encode(uint256(keccak256(\"perp.storage.oracleMaker\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant _ORACLE_MAKER_STORAGE_LOCATION =\n        0x49404affd0747f1de28f32f44120f8f18db1aa69644f83b133007475ed402e00;\n\n    //\n    // MODIFIER\n    //\n    modifier onlyClearingHouse() {\n        if (msg.sender != address(getAddressManager().getClearingHouse())) revert LibError.Unauthorized();\n        _;\n    }\n\n    modifier onlyWhitelistLp() {\n        IWhitelistLpManager whitelistManager = getAddressManager().getWhitelistLpManager();\n        if (address(whitelistManager) != address(0)) {\n            if (!whitelistManager.isLpWhitelisted(_sender())) revert LibError.Unauthorized();\n        }\n        _;\n    }\n\n    //\n    // EXTERNAL NON-VIEW\n    //\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 marketId_,\n        string memory name_,\n        string memory symbol_,\n        address addressManager_,\n        bytes32 priceFeedId_,\n        uint256 minMarginRatio_\n    ) external initializer {\n        __AddressResolver_init(addressManager_);\n        __Ownable2Step_init();\n        __Ownable_init(msg.sender);\n        __ERC20_init(name_, symbol_);\n\n        if (!getAddressManager().getPythOracleAdapter().priceFeedExists(priceFeedId_))\n            revert LibError.IllegalPriceFeed(priceFeedId_);\n\n        _getOracleMakerStorage().marketId = marketId_;\n        setPriceFeedId(priceFeedId_);\n        setMinMarginRatio(minMarginRatio_);\n    }\n\n    function setPriceFeedId(bytes32 _priceFeedId) public onlyOwner {\n        if (!getAddressManager().getPythOracleAdapter().priceFeedExists(_priceFeedId))\n            revert LibError.IllegalPriceFeed(_priceFeedId);\n\n        bytes32 oldPriceFeedId = _getOracleMakerStorage().priceFeedId;\n        _getOracleMakerStorage().priceFeedId = _priceFeedId;\n\n        emit PriceFeedIdSet(_priceFeedId, oldPriceFeedId);\n    }\n\n    function setMinMarginRatio(uint256 _minMarginRatio) public onlyOwner {\n        if (_minMarginRatio > WAD) {\n            revert LibError.InvalidRatio(_minMarginRatio);\n        }\n        if (_minMarginRatio == 0) {\n            revert LibError.ZeroRatio();\n        }\n        uint256 oldMinMarginRatio = _getOracleMakerStorage().minMarginRatio;\n        _getOracleMakerStorage().minMarginRatio = _minMarginRatio;\n\n        emit MinMarginRatioSet(_minMarginRatio, oldMinMarginRatio);\n    }\n\n    function setMaxSpreadRatio(uint256 _maxSpreadRatio) public onlyOwner {\n        if (_maxSpreadRatio > WAD) {\n            revert LibError.InvalidRatio(_maxSpreadRatio);\n        }\n        uint256 oldMaxSpreadRatio = _getOracleMakerStorage().maxSpreadRatio;\n        _getOracleMakerStorage().maxSpreadRatio = _maxSpreadRatio;\n\n        emit MaxSpreadRatioSet(_maxSpreadRatio, oldMaxSpreadRatio);\n    }\n\n    function setValidSender(address user, bool isValid) public onlyOwner {\n        _getOracleMakerStorage().validSenderMap[user] = isValid;\n    }\n\n    function deposit(uint256 amountXCD) external onlyWhitelistLp returns (uint256) {\n        address depositor = _sender();\n        address maker = address(this);\n\n        if (amountXCD == 0) revert LibError.ZeroAmount();\n\n        IERC20Metadata collateralToken = IERC20Metadata(_getAsset());\n        IAddressManager addressManager = getAddressManager();\n        IVault vault = addressManager.getVault();\n\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = amountXCD;\n        } else {\n            uint256 price = _getPrice();\n\n            // TODO Should consider slippage once maker has spread or other pricing logic.\n            // For now, we will just get account value from ClearingHouse (assume no slippages).\n            // shares per asset = share (share token precision) / accountValue (INTERNAL_DECIMALS)\n            // shares (share token precision) = assets (base token precision) * shares per asset\n\n            // TODO: We should add protections to prevent attackers from manipulating the share price by manipulating oracle reported price.\n            // This is because the attacker could potentially mint large amount of shares by forcing the account value low.\n            // Possible protections like rate limiting share price, or any kind of volatility check.\n\n            uint8 shareDecimals = decimals();\n            uint256 vaultValueXShareDecimals = _getVaultValueSafe(vault, price).formatDecimals(\n                INTERNAL_DECIMALS,\n                shareDecimals\n            );\n            uint256 amountXShareDecimals = amountXCD.formatDecimals(collateralToken.decimals(), shareDecimals);\n            shares = (amountXShareDecimals * totalSupply()) / vaultValueXShareDecimals;\n        }\n\n        uint256 balanceBefore = collateralToken.balanceOf(maker);\n        collateralToken.safeTransferFrom(_sender(), maker, amountXCD);\n        uint256 transferredAmount = collateralToken.balanceOf(maker) - balanceBefore;\n\n        if (transferredAmount != amountXCD) {\n            revert LibError.WrongTransferAmount(transferredAmount, amountXCD);\n        }\n\n        collateralToken.approve(address(vault), amountXCD);\n        vault.deposit(maker, amountXCD);\n        vault.transferFundToMargin(_getOracleMakerStorage().marketId, amountXCD);\n\n        _mint(depositor, shares);\n\n        emit Deposited(depositor, shares, amountXCD);\n\n        return shares;\n    }\n\n    function withdraw(uint256 shares) external onlyWhitelistLp returns (uint256) {\n        address withdrawer = _sender();\n\n        if (shares == 0) revert LibError.ZeroAmount();\n\n        // Must done before burn.\n        uint256 redeemedRatio = shares.divWad(totalSupply());\n\n        // Revert early if shares amount exceeds balance\n        _burn(withdrawer, shares);\n\n        IVault vault = _getVault();\n\n        uint256 price = _getPrice();\n        uint256 vaultValue = _getVaultValueSafe(vault, price);\n        IERC20Metadata collateralToken = IERC20Metadata(_getAsset());\n        uint256 withdrawnAmountXCD = vaultValue.mulWad(redeemedRatio).formatDecimals(\n            INTERNAL_DECIMALS,\n            collateralToken.decimals()\n        );\n\n        // It may not be possible to withdraw the required amount, due to unsettledPnl that cannot be settled totally.\n        vault.transferMarginToFund(_getOracleMakerStorage().marketId, withdrawnAmountXCD);\n        vault.withdraw(withdrawnAmountXCD);\n        collateralToken.safeTransfer(withdrawer, withdrawnAmountXCD);\n\n        _checkMinMarginRatio(price);\n\n        emit Withdrawn(withdrawer, shares, withdrawnAmountXCD);\n\n        return withdrawnAmountXCD;\n    }\n\n    function fillOrderCallback(bytes calldata) external view onlyClearingHouse {\n        _checkMinMarginRatio(_getPrice());\n    }\n\n    function fillOrder(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount,\n        bytes calldata\n    ) external onlyClearingHouse returns (uint256, bytes memory) {\n        uint256 basePrice = _getPrice();\n        uint256 basePriceWithSpread = _getBasePriceWithSpread(basePrice, isBaseToQuote);\n\n        // - `amount` base -> `amount * basePrice` quote\n        //   (isBaseToQuote=true, isExactInput=true, openNotional = `amount * basePrice`)\n        // - `amount` base <- `amount * basePrice` quote\n        //   (isBaseToQuote=false, isExactInput=false, openNotional = -`amount * basePrice`)\n        // - `amount / basePrice` base -> `amount` quote\n        //   (isBaseToQuote=true, isExactInput=false, openNotional = `amount`)\n        // - `amount / basePrice` base <- `amount` quote\n        //   (isBaseToQuote=false, isExactInput=true, openNotional = -`amount`)\n\n        int256 baseAmount;\n        int256 quoteAmount;\n        uint256 oppositeAmount;\n        if (isBaseToQuote) {\n            if (isExactInput) {\n                // TODO: Should use configed decimal number instead of hard-coding\n                oppositeAmount = (amount * basePriceWithSpread) / 1 ether;\n                baseAmount = -amount.toInt256();\n                quoteAmount = oppositeAmount.toInt256();\n            } else {\n                oppositeAmount = (amount * 1 ether) / basePriceWithSpread;\n                baseAmount = -oppositeAmount.toInt256();\n                quoteAmount = amount.toInt256();\n            }\n        } else {\n            if (isExactInput) {\n                oppositeAmount = (amount * 1 ether) / basePriceWithSpread;\n                baseAmount = oppositeAmount.toInt256();\n                quoteAmount = -amount.toInt256();\n            } else {\n                oppositeAmount = (amount * basePriceWithSpread) / 1 ether;\n                baseAmount = amount.toInt256();\n                quoteAmount = -oppositeAmount.toInt256();\n            }\n        }\n        emit OMOrderFilled(_getOracleMakerStorage().marketId, basePrice, baseAmount, quoteAmount);\n        return (oppositeAmount, new bytes(0));\n    }\n\n    //\n    // EXTERNAL VIEW\n    //\n\n    function getUtilRatio() external view returns (uint256, uint256) {\n        if (totalSupply() == 0) {\n            return (0, 0);\n        }\n\n        IVault vault = _getVault();\n        int256 positionSize = vault.getPositionSize(_getOracleMakerStorage().marketId, address(this));\n\n        if (positionSize == 0) {\n            return (0, 0);\n        }\n\n        uint256 price = _getPrice();\n        int256 positionRate = _getPositionRate(price);\n        // position rate > 0, maker has long position, set long util ratio to 0 so taker tends to long\n        // position rate < 0, maker has short position, set short util ratio to 0 so taker tends to short\n        return positionRate > 0 ? (uint256(0), positionRa"
    }
  ]
}