{
  "Title": "M-1: Lack of ERC20 approval on depositing to external money markets Compound V2",
  "Content": "# Issue M-1: Lack of ERC20 approval on depositing to external money markets Compound V2 \n\nSource: https://github.com/sherlock-audit/2023-03-notional-judging/issues/28 \n\n## Found by \nShadowForce, mstpr-brainbot\n## Summary\nNotional's current rebalancing process for depositing prime cash underlyings into Compound V2 generates the mint function without approval.\n## Vulnerability Detail\nGovernance rebalances the prime cash underlyings by depositing them into various external money market platforms. Currently, Notional only supports Compound V2, for which an oracle and rebalancing strategy have been developed. When Compound V2 deposit call data is generated in the oracle, it only generates the cTokens' mint function without approval. However, it should first approve and then call the mint, as cToken takes the underlying from the Notional proxy and mints the cToken to the Notional proxy.\n\nUpon careful examination of the v2 code, this finding passes tests because the old Notional V2 proxy already has approval for some Compound V2 cTokens. Since the Notional V2 code is not in scope for this contest and the approval situation is not mentioned in the protocol documentation, this finding should be considered valid. Furthermore, if the protocol wants to launch new cTokens for which V2 does not already have approval, the process will fail due to the lack of approval.\n## Impact\nThis finding should be considered valid for several reasons:\n\nThe issue is not mentioned in the documentation provided by the protocol team. It is crucial for the documentation to be comprehensive, as it serves as a guide for developers and users to understand the intricacies of the protocol.\nThe Notional V2 code is out of scope for the contest. Therefore, the fact that the old Notional V2 proxy already has approval for some Compound V2 cTokens should not be considered a mitigating factor, as the focus should be on the current implementation and its potential issues.\nMost importantly, this issue could impact the functionality of Notional when attempting to launch new cTokens for Compound V2 that do not already have an allowance in the proxy. The lack of approval would cause the process to fail, effectively limiting the growth and adaptability of the protocol.\nIn summary, this finding is valid due to its absence in the provided documentation, its relevance to the current implementation rather than the out-of-scope Notional V2 code, and its potential to limit the protocol's functionality when dealing with new cTokens for Compound V2. I'll call it as medium severity after all considerations.\n\nIt is important to note that this finding may not be applicable to non-implemented protocol oracles such as AAVE-Euler. In these cases, there is a possibility to create multiple call data deposits, allowing for a more flexible approach. Governance can first generate one call data to approve the required allowances and then generate a subsequent call data to initiate the deposit process.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/external/pCash/adapters/CompoundV2AssetAdapter.sol#L45-L48\n\n## Tool used\n\nManual Review\n\n## Recommendation\nput a check on allowance before deposit something like this:\n\n```solidity\nif (IERC20.allowance(address(NotionalProxy), address(cToken))) {\n      callData[0] = abi.encodeWithSelector(\n        IERC20.approve.selector,\n        address(NotionalProxy),\n        address(cToken)\n      );\n    }\n``` \n\n\n\n## Discussion\n\n**jeffywu**\n\nCompound V2 will not be used for rebalancing, however, even if that were not the case this issue would be invalid. Notional currently already has an approval with all listed cTokens and that would still stand after the migration.\n\n**mstpr**\n\nEscalate for 10 USDC\n\nCurrent code scope is only covering CompoundV2 and there are rebalancing, deposit and redeeming functions already coded up. It is certain that this code scope is intended to work with only CompoundV2 since it has full functionality. Protocol team states that CompoundV2 will not be used for rebalancing but there are functions for it and there are not alternative money markets built in aswell so one can easily say that there is only CompoundV2 to interact with prime cash at the current scope. \n\nApprovals from NotionalV2 handles the lack of approval here however, as stated in the contest here:\n<img width=\"588\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-03-notional-judging/assets/120012681/ed1ece0e-b88a-44c9-9298-efedebb1ae7a\">\nUSDT can be used in NotionalV3 which was not existed in NotionalV2 hence, there are no approvals. If USDT would be integrated to the NotionalV3 current code would fail since there is no approval for USDT from NotionalV3 to CompoundV2.\n\nIf CompoundV2 will not be used for rebalancing, then why there are rebalancing functions for only CompoundV2 and not others? I think protocol team should've stated that.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Current code scope is only covering CompoundV2 and there are rebalancing, deposit and redeeming functions already coded up. It is certain that this code scope is intended to work with only CompoundV2 since it has full functionality. Protocol team states that CompoundV2 will not be used for rebalancing but there are functions for it and there are not alternative money markets built in aswell so one can easily say that there is only CompoundV2 to interact with prime cash at the current scope. \n> \n> Approvals from NotionalV2 handles the lack of approval here however, as stated in the contest here:\n> <img width=\"588\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-03-notional-judging/assets/120012681/ed1ece0e-b88a-44c9-9298-efedebb1ae7a\">\n> USDT can be used in NotionalV3 which was not existed in NotionalV2 hence, there are no approvals. If USDT would be integrated to the NotionalV3 current code would fail since there is no approval for USDT from NotionalV3 to CompoundV2.\n> \n> If CompoundV2 will not be used for rebalancing, then why there are rebalancing functions for only CompoundV2 and not others? I think protocol team should've stated that.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Jiaren-tang**\n\nEscalate for 10 USDC. I agree with mstpr that this issue should be a valid issue\n\nadding any token or external market would break the rebalance flow because of lack of token approval \n\n**sherlock-admin**\n\n > Escalate for 10 USDC. I agree with mstpr that this issue should be a valid issue\n> \n> adding any token or external market would break the rebalance flow because of lack of token approval \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nConsidering this issue as a valid medium based on the information provided in the readme makes this issue possible when the additional token is added.\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [mstpr](https://github.com/sherlock-audit/2023-03-notional-judging/issues/28/#issuecomment-1568143583): accepted\n- [ShadowForce](https://github.com/sherlock-audit/2023-03-notional-judging/issues/28/#issuecomment-1570483665): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/59",
  "Code": [
    {
      "filename": "contracts-v2/contracts/external/pCash/adapters/CompoundV2AssetAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.8.17;\n\nimport {CErc20Interface} from \"../../../../interfaces/compound/CErc20Interface.sol\";\nimport {CEtherInterface} from \"../../../../interfaces/compound/CEtherInterface.sol\";\nimport {CTokenInterface} from \"../../../../interfaces/compound/CTokenInterface.sol\";\nimport {AssetRateAdapter} from \"../../../../interfaces/notional/AssetRateAdapter.sol\";\nimport {DepositData, RedeemData} from \"../../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\";\n\nlibrary CompoundV2AssetAdapter {\n    function getRedemptionCalldata(\n        address from,\n        address assetToken,\n        address assetRateAdapter,\n        uint256 rateAdapterPrecision,\n        uint256 redeemUnderlyingAmount\n    ) internal view returns (RedeemData[] memory data) {\n        address[] memory targets = new address[](1);\n        bytes[] memory callData = new bytes[](1);\n        targets[0] = assetToken;\n        callData[0] = abi.encodeWithSelector(CErc20Interface.redeemUnderlying.selector, redeemUnderlyingAmount);\n\n        data = new RedeemData[](1);\n        data[0] = RedeemData(targets, callData, redeemUnderlyingAmount, assetToken);\n    }\n\n    function getRedemptionLength() internal view returns (uint256) {\n        return 1;\n    }\n\n    function getDepositCalldata(\n        address from,\n        address assetToken,\n        address assetRateAdapter,\n        uint256 rateAdapterPrecision,\n        uint256 depositUnderlyingAmount,\n        bool underlyingIsETH\n    ) internal view returns (DepositData[] memory data) {\n        address[] memory targets = new address[](1);\n        bytes[] memory callData = new bytes[](1);\n        uint256[] memory msgValue = new uint256[](1);\n\n        targets[0] = assetToken;\n        msgValue[0] = underlyingIsETH ? depositUnderlyingAmount : 0;\n        callData[0] = abi.encodeWithSelector(\n            underlyingIsETH ? CEtherInterface.mint.selector : CErc20Interface.mint.selector, \n            depositUnderlyingAmount\n        );\n\n        data = new DepositData[](1);\n        data[0] = DepositData(targets, callData, msgValue, depositUnderlyingAmount, assetToken);\n    }\n\n    function getUnderlyingValue(\n        address assetRateAdapter, \n        uint256 rateAdapterPrecision, \n        uint256 assetBalance\n    ) internal view returns (uint256) {\n        return assetBalance * _toUint(AssetRateAdapter(assetRateAdapter).getExchangeRateView()) / rateAdapterPrecision;\n    }\n    \n    function _toUint(int256 x) private pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n}"
    }
  ]
}