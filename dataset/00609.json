{
  "Title": "Delegation Can Be Misconfigured",
  "Content": "The `WorldRegistrationSystem` allows users to [register a delegation](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/modules/core/implementations/WorldRegistrationSystem.sol#L241). This will enable the delegatee to [make a call on behalf of the delegator](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/World.sol#L361), provided it meets the delegator's criteria.\n\n\nWhen setting up delegation control with a system, it is possible to register an invalid delegation control without it being immediately noticeable. This would be the case when [`initCallData` is not required](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/modules/core/implementations/WorldRegistrationSystem.sol#L250) (has length zero), which causes the registration function to skip the interface conformance check of the delegation control system. An attacker can take advantage of this mistake, if the delegation is not account-specific, by registering this non-existent system ID to thereby gain control over the system.\n\n\nConsider performing the interface checks on the delegation control system in all cases, whether or not `initCallData` is required. It should be noted that this would prevent clearing the delegation (i.e., resetting the `delegationControlId` to zero). Thus, consider introducing a new function to unregister delegations.\n\n\n***Update:** Resolved in [pull request #2096](https://github.com/latticexyz/mud/pull/2096).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/world/src/modules/core/implementations/WorldRegistrationSystem.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { Hook, HookLib } from \"@latticexyz/store/src/Hook.sol\";\nimport { ResourceId, ResourceIdInstance } from \"@latticexyz/store/src/ResourceId.sol\";\nimport { ResourceIds } from \"@latticexyz/store/src/codegen/tables/ResourceIds.sol\";\n\nimport { System } from \"../../../System.sol\";\nimport { WorldContextConsumer, WORLD_CONTEXT_CONSUMER_INTERFACE_ID } from \"../../../WorldContext.sol\";\nimport { WorldResourceIdLib, WorldResourceIdInstance } from \"../../../WorldResourceId.sol\";\nimport { SystemCall } from \"../../../SystemCall.sol\";\nimport { ROOT_NAMESPACE_ID, ROOT_NAME } from \"../../../constants.sol\";\nimport { RESOURCE_NAMESPACE, RESOURCE_SYSTEM } from \"../../../worldResourceTypes.sol\";\nimport { AccessControl } from \"../../../AccessControl.sol\";\nimport { Delegation } from \"../../../Delegation.sol\";\nimport { requireInterface } from \"../../../requireInterface.sol\";\nimport { NamespaceOwner } from \"../../../codegen/tables/NamespaceOwner.sol\";\nimport { ResourceAccess } from \"../../../codegen/tables/ResourceAccess.sol\";\nimport { UserDelegationControl } from \"../../../codegen/tables/UserDelegationControl.sol\";\nimport { NamespaceDelegationControl } from \"../../../codegen/tables/NamespaceDelegationControl.sol\";\nimport { ISystemHook, SYSTEM_HOOK_INTERFACE_ID } from \"../../../ISystemHook.sol\";\nimport { IWorldErrors } from \"../../../IWorldErrors.sol\";\nimport { IDelegationControl, DELEGATION_CONTROL_INTERFACE_ID } from \"../../../IDelegationControl.sol\";\n\nimport { SystemHooks, SystemHooksTableId } from \"../../../codegen/tables/SystemHooks.sol\";\nimport { SystemRegistry } from \"../../../codegen/tables/SystemRegistry.sol\";\nimport { Systems } from \"../../../codegen/tables/Systems.sol\";\nimport { FunctionSelectors } from \"../../../codegen/tables/FunctionSelectors.sol\";\nimport { FunctionSignatures } from \"../../../codegen/tables/FunctionSignatures.sol\";\n\n/**\n * @title WorldRegistrationSystem\n * @dev This contract provides functions related to registering resources other than tables in the World.\n */\ncontract WorldRegistrationSystem is System, IWorldErrors {\n  using ResourceIdInstance for ResourceId;\n  using WorldResourceIdInstance for ResourceId;\n\n  /**\n   * @notice Registers a new namespace\n   * @dev Creates a new namespace resource with the given ID\n   * @param namespaceId The unique identifier for the new namespace\n   */\n  function registerNamespace(ResourceId namespaceId) public virtual {\n    // Require the provided namespace ID to have type RESOURCE_NAMESPACE\n    if (namespaceId.getType() != RESOURCE_NAMESPACE) {\n      revert World_InvalidResourceType(RESOURCE_NAMESPACE, namespaceId, namespaceId.toString());\n    }\n\n    // Require namespace to not exist yet\n    if (ResourceIds._getExists(namespaceId)) {\n      revert World_ResourceAlreadyExists(namespaceId, namespaceId.toString());\n    }\n\n    // Register namespace resource ID\n    ResourceIds._setExists(namespaceId, true);\n\n    // Register caller as the namespace owner\n    NamespaceOwner._set(namespaceId, _msgSender());\n\n    // Give caller access to the new namespace\n    ResourceAccess._set(namespaceId, _msgSender(), true);\n  }\n\n  /**\n   * @notice Registers a new system hook\n   * @dev Adds a new hook for the system at the provided system ID\n   * @param systemId The ID of the system\n   * @param hookAddress The address of the hook being registered\n   * @param enabledHooksBitmap Bitmap indicating which hooks are enabled\n   */\n  function registerSystemHook(ResourceId systemId, ISystemHook hookAddress, uint8 enabledHooksBitmap) public virtual {\n    // Require the provided address to implement the ISystemHook interface\n    requireInterface(address(hookAddress), SYSTEM_HOOK_INTERFACE_ID);\n\n    // Require caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Register the hook\n    SystemHooks.push(systemId, Hook.unwrap(HookLib.encode(address(hookAddress), enabledHooksBitmap)));\n  }\n\n  /**\n   * @notice Unregisters a system hook\n   * @dev Removes a hook for the system at the provided system ID\n   * @param systemId The ID of the system\n   * @param hookAddress The address of the hook being unregistered\n   */\n  function unregisterSystemHook(ResourceId systemId, ISystemHook hookAddress) public virtual {\n    // Require caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Remove the hook from the list of hooks for this system in the system hooks table\n    HookLib.filterListByAddress(SystemHooksTableId, systemId, address(hookAddress));\n  }\n\n  /**\n   * @notice Registers a system\n   * @dev Registers or upgrades a system at the given ID\n   * If the namespace doesn't exist yet, it is registered.\n   * The system is granted access to its namespace, so it can write to any\n   * table in the same namespace.\n   * If publicAccess is true, no access control check is performed for calling the system.\n   * This function doesn't check whether a system already exists at the given selector,\n   * making it possible to upgrade systems.\n   * @param systemId The unique identifier for the system\n   * @param system The system being registered\n   * @param publicAccess Flag indicating if access control check is bypassed\n   */\n  function registerSystem(ResourceId systemId, WorldContextConsumer system, bool publicAccess) public virtual {\n    // Require the provided system ID to have type RESOURCE_SYSTEM\n    if (systemId.getType() != RESOURCE_SYSTEM) {\n      revert World_InvalidResourceType(RESOURCE_SYSTEM, systemId, systemId.toString());\n    }\n\n    // Require the provided address to implement the WorldContextConsumer interface\n    requireInterface(address(system), WORLD_CONTEXT_CONSUMER_INTERFACE_ID);\n\n    // Require the name to not be the namespace's root name\n    if (systemId.getName() == ROOT_NAME) revert World_InvalidResourceId(systemId, systemId.toString());\n\n    // Require this system to not be registered at a different system ID yet\n    ResourceId existingSystemId = SystemRegistry._get(address(system));\n    if (\n      ResourceId.unwrap(existingSystemId) != 0 && ResourceId.unwrap(existingSystemId) != ResourceId.unwrap(systemId)\n    ) {\n      revert World_SystemAlreadyExists(address(system));\n    }\n\n    // If the namespace doesn't exist yet, register it\n    ResourceId namespaceId = systemId.getNamespaceId();\n    if (!ResourceIds._getExists(namespaceId)) {\n      registerNamespace(namespaceId);\n    } else {\n      // otherwise require caller to own the namespace\n      AccessControl.requireOwner(namespaceId, _msgSender());\n    }\n\n    // Check if a system already exists at this system ID\n    address existingSystem = Systems._getSystem(systemId);\n\n    // If there is an existing system with this system ID, remove it\n    if (existingSystem != address(0)) {\n      // Remove the existing system from the system registry\n      SystemRegistry._deleteRecord(existingSystem);\n\n      // Remove the existing system's access to its namespace\n      ResourceAccess._deleteRecord(namespaceId, existingSystem);\n    } else {\n      // Otherwise, this is a new system, so register its resource ID\n      ResourceIds._setExists(systemId, true);\n    }\n\n    // Systems = mapping from system ID to system address and public access flag\n    Systems._set(systemId, address(system), publicAccess);\n\n    // SystemRegistry = mapping from system address to system ID\n    SystemRegistry._set(address(system), systemId);\n\n    // Grant the system access to its namespace\n    ResourceAccess._set(namespaceId, address(system), true);\n  }\n\n  /**\n   * @notice Registers a new World function selector\n   * @dev Creates a mapping between a World function and its associated system function\n   * @param systemId The system ID\n   * @param systemFunctionSignature The signature of the system function\n   * @return worldFunctionSelector The selector of the World function\n   */\n  function registerFunctionSelector(\n    ResourceId systemId,\n    string memory systemFunctionSignature\n  ) public returns (bytes4 worldFunctionSelector) {\n    // Require the caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Compute global function selector\n    string memory namespaceString = WorldResourceIdLib.toTrimmedString(systemId.getNamespace());\n    string memory nameString = WorldResourceIdLib.toTrimmedString(systemId.getName());\n    bytes memory worldFunctionSignature = abi.encodePacked(\n      namespaceString,\n      \"_\",\n      nameString,\n      \"_\",\n      systemFunctionSignature\n    );\n    worldFunctionSelector = bytes4(keccak256(worldFunctionSignature));\n\n    // Require the function selector to be globally unique\n    ResourceId existingSystemId = FunctionSelectors._getSystemId(worldFunctionSelector);\n\n    if (ResourceId.unwrap(existingSystemId) != 0) revert World_FunctionSelectorAlreadyExists(worldFunctionSelector);\n\n    // Register the function selector\n    bytes4 systemFunctionSelector = bytes4(keccak256(bytes(systemFunctionSignature)));\n    FunctionSelectors._set(worldFunctionSelector, systemId, systemFunctionSelector);\n\n    // Register the function signature for offchain use\n    FunctionSignatures._set(worldFunctionSelector, string(worldFunctionSignature));\n  }\n\n  /**\n   * @notice Registers a root World function selector\n   * @dev Creates a mapping for a root World function without namespace or name prefix\n   * @param systemId The system ID\n   * @param worldFunctionSignature The signature of the World function\n   * @param systemFunctionSelector The selector of the system function\n   * @return worldFunctionSelector The selector of the World function\n   */\n  function registerRootFunctionSelector(\n    ResourceId systemId,\n    string memory worldFunctionSignature,\n    bytes4 systemFunctionSelector\n  ) public returns (bytes4 worldFunctionSelector) {\n    // Require the caller to own the root namespace\n    AccessControl.requireOwner(ROOT_NAMESPACE_ID, _msgSender());\n\n    // Compute the function selector from the provided signature\n    worldFunctionSelector = bytes4(keccak256(bytes(worldFunctionSignature)));\n\n    // Require the function selector to be globally unique\n    ResourceId existingSystemId = FunctionSelectors._getSystemId(worldFunctionSelector);\n\n    if (ResourceId.unwrap(existingSystemId) != 0) revert World_FunctionSelectorAlreadyExists(worldFunctionSelector);\n\n    // Register the function selector\n    FunctionSelectors._set(worldFunctionSelector, systemId, systemFunctionSelector);\n\n    // Register the function signature for offchain use\n    FunctionSignatures._set(worldFunctionSelector, worldFunctionSignature);\n  }\n\n  /**\n   * @notice Registers a delegation for the caller\n   * @dev Creates a new delegation from the caller to the specified delegatee\n   * @param delegatee The address of the delegatee\n   * @param delegationControlId The ID controlling the delegation\n   * @param initCallData The initialization data for the delegation\n   */\n  function registerDelegation(address delegatee, ResourceId delegationControlId, bytes memory initCallData) public {\n    // Store the delegation control contract address\n    UserDelegationControl._set({\n      delegator: _msgSender(),\n      delegatee: delegatee,\n      delegationControlId: delegationControlId\n    });\n\n    // If the delegation is limited...\n    if (Delegation.isLimited(delegationControlId) && initCallData.length > 0) {\n      // Require the delegationControl contract to implement the IDelegationControl interface\n      (address delegationControl, ) = Systems._get(delegationControlId);\n      requireInterface(delegationControl, DELEGATION_CONTROL_INTERFACE_ID);\n\n      // Call the delegation control contract's init function\n      SystemCall.callWithHooksOrRevert({\n        caller: _msgSender(),\n        systemId: delegationControlId,\n        callData: initCallData,\n        value: 0\n      });\n    }\n  }\n\n  /**\n   * @notice Registers a delegation for a namespace\n   * @dev Sets up a new delegation control for a specific namespace\n   * @param namespaceId The ID of the namespace\n   * @param delegationControlId The ID controlling the delegation\n   * @param initCallData The initialization data for the delegation\n   */\n  function registerNamespaceDelegation(\n    ResourceId namespaceId,\n    ResourceId delegationControlId,\n    bytes memory initCallData\n  ) public {\n    // Require the namespaceId to be a valid namespace ID\n    if (namespaceId.getType() != RESOURCE_NAMESPACE) {\n      revert World_InvalidResourceType(RESOURCE_NAMESPACE, namespaceId, namespaceId.toString());\n    }\n\n    // Require the delegation to not be unlimited\n    if (!Delegation.isLimited(delegationControlId)) {\n      revert World_UnlimitedDelegationNotAllowed();\n    }\n\n    // Require the caller to own the namespace\n    AccessControl.requireOwner(namespaceId, _msgSender());\n\n    // Require the delegationControl contract to implement the IDelegationControl interface\n    (address delegationControl, ) = Systems._get(delegationControlId);\n    requireInterface(delegationControl, DELEGATION_CONTROL_INTERFACE_ID);\n\n    // Register the delegation control\n    NamespaceDelegationControl._set(namespaceId, delegationControlId);\n\n    // Call the delegation control contract's init function\n    if (initCallData.length > 0) {\n      SystemCall.callWithHooksOrRevert({\n        caller: _msgSender(),\n        systemId: delegationControlId,\n        callData: initCallData,\n        value: 0\n      });\n    }\n  }\n}"
    },
    {
      "filename": "packages/world/src/modules/core/implementations/WorldRegistrationSystem.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { Hook, HookLib } from \"@latticexyz/store/src/Hook.sol\";\nimport { ResourceId, ResourceIdInstance } from \"@latticexyz/store/src/ResourceId.sol\";\nimport { ResourceIds } from \"@latticexyz/store/src/codegen/tables/ResourceIds.sol\";\n\nimport { System } from \"../../../System.sol\";\nimport { WorldContextConsumer, WORLD_CONTEXT_CONSUMER_INTERFACE_ID } from \"../../../WorldContext.sol\";\nimport { WorldResourceIdLib, WorldResourceIdInstance } from \"../../../WorldResourceId.sol\";\nimport { SystemCall } from \"../../../SystemCall.sol\";\nimport { ROOT_NAMESPACE_ID, ROOT_NAME } from \"../../../constants.sol\";\nimport { RESOURCE_NAMESPACE, RESOURCE_SYSTEM } from \"../../../worldResourceTypes.sol\";\nimport { AccessControl } from \"../../../AccessControl.sol\";\nimport { Delegation } from \"../../../Delegation.sol\";\nimport { requireInterface } from \"../../../requireInterface.sol\";\nimport { NamespaceOwner } from \"../../../codegen/tables/NamespaceOwner.sol\";\nimport { ResourceAccess } from \"../../../codegen/tables/ResourceAccess.sol\";\nimport { UserDelegationControl } from \"../../../codegen/tables/UserDelegationControl.sol\";\nimport { NamespaceDelegationControl } from \"../../../codegen/tables/NamespaceDelegationControl.sol\";\nimport { ISystemHook, SYSTEM_HOOK_INTERFACE_ID } from \"../../../ISystemHook.sol\";\nimport { IWorldErrors } from \"../../../IWorldErrors.sol\";\nimport { IDelegationControl, DELEGATION_CONTROL_INTERFACE_ID } from \"../../../IDelegationControl.sol\";\n\nimport { SystemHooks, SystemHooksTableId } from \"../../../codegen/tables/SystemHooks.sol\";\nimport { SystemRegistry } from \"../../../codegen/tables/SystemRegistry.sol\";\nimport { Systems } from \"../../../codegen/tables/Systems.sol\";\nimport { FunctionSelectors } from \"../../../codegen/tables/FunctionSelectors.sol\";\nimport { FunctionSignatures } from \"../../../codegen/tables/FunctionSignatures.sol\";\n\n/**\n * @title WorldRegistrationSystem\n * @dev This contract provides functions related to registering resources other than tables in the World.\n */\ncontract WorldRegistrationSystem is System, IWorldErrors {\n  using ResourceIdInstance for ResourceId;\n  using WorldResourceIdInstance for ResourceId;\n\n  /**\n   * @notice Registers a new namespace\n   * @dev Creates a new namespace resource with the given ID\n   * @param namespaceId The unique identifier for the new namespace\n   */\n  function registerNamespace(ResourceId namespaceId) public virtual {\n    // Require the provided namespace ID to have type RESOURCE_NAMESPACE\n    if (namespaceId.getType() != RESOURCE_NAMESPACE) {\n      revert World_InvalidResourceType(RESOURCE_NAMESPACE, namespaceId, namespaceId.toString());\n    }\n\n    // Require namespace to not exist yet\n    if (ResourceIds._getExists(namespaceId)) {\n      revert World_ResourceAlreadyExists(namespaceId, namespaceId.toString());\n    }\n\n    // Register namespace resource ID\n    ResourceIds._setExists(namespaceId, true);\n\n    // Register caller as the namespace owner\n    NamespaceOwner._set(namespaceId, _msgSender());\n\n    // Give caller access to the new namespace\n    ResourceAccess._set(namespaceId, _msgSender(), true);\n  }\n\n  /**\n   * @notice Registers a new system hook\n   * @dev Adds a new hook for the system at the provided system ID\n   * @param systemId The ID of the system\n   * @param hookAddress The address of the hook being registered\n   * @param enabledHooksBitmap Bitmap indicating which hooks are enabled\n   */\n  function registerSystemHook(ResourceId systemId, ISystemHook hookAddress, uint8 enabledHooksBitmap) public virtual {\n    // Require the provided address to implement the ISystemHook interface\n    requireInterface(address(hookAddress), SYSTEM_HOOK_INTERFACE_ID);\n\n    // Require caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Register the hook\n    SystemHooks.push(systemId, Hook.unwrap(HookLib.encode(address(hookAddress), enabledHooksBitmap)));\n  }\n\n  /**\n   * @notice Unregisters a system hook\n   * @dev Removes a hook for the system at the provided system ID\n   * @param systemId The ID of the system\n   * @param hookAddress The address of the hook being unregistered\n   */\n  function unregisterSystemHook(ResourceId systemId, ISystemHook hookAddress) public virtual {\n    // Require caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Remove the hook from the list of hooks for this system in the system hooks table\n    HookLib.filterListByAddress(SystemHooksTableId, systemId, address(hookAddress));\n  }\n\n  /**\n   * @notice Registers a system\n   * @dev Registers or upgrades a system at the given ID\n   * If the namespace doesn't exist yet, it is registered.\n   * The system is granted access to its namespace, so it can write to any\n   * table in the same namespace.\n   * If publicAccess is true, no access control check is performed for calling the system.\n   * This function doesn't check whether a system already exists at the given selector,\n   * making it possible to upgrade systems.\n   * @param systemId The unique identifier for the system\n   * @param system The system being registered\n   * @param publicAccess Flag indicating if access control check is bypassed\n   */\n  function registerSystem(ResourceId systemId, WorldContextConsumer system, bool publicAccess) public virtual {\n    // Require the provided system ID to have type RESOURCE_SYSTEM\n    if (systemId.getType() != RESOURCE_SYSTEM) {\n      revert World_InvalidResourceType(RESOURCE_SYSTEM, systemId, systemId.toString());\n    }\n\n    // Require the provided address to implement the WorldContextConsumer interface\n    requireInterface(address(system), WORLD_CONTEXT_CONSUMER_INTERFACE_ID);\n\n    // Require the name to not be the namespace's root name\n    if (systemId.getName() == ROOT_NAME) revert World_InvalidResourceId(systemId, systemId.toString());\n\n    // Require this system to not be registered at a different system ID yet\n    ResourceId existingSystemId = SystemRegistry._get(address(system));\n    if (\n      ResourceId.unwrap(existingSystemId) != 0 && ResourceId.unwrap(existingSystemId) != ResourceId.unwrap(systemId)\n    ) {\n      revert World_SystemAlreadyExists(address(system));\n    }\n\n    // If the namespace doesn't exist yet, register it\n    ResourceId namespaceId = systemId.getNamespaceId();\n    if (!ResourceIds._getExists(namespaceId)) {\n      registerNamespace(namespaceId);\n    } else {\n      // otherwise require caller to own the namespace\n      AccessControl.requireOwner(namespaceId, _msgSender());\n    }\n\n    // Check if a system already exists at this system ID\n    address existingSystem = Systems._getSystem(systemId);\n\n    // If there is an existing system with this system ID, remove it\n    if (existingSystem != address(0)) {\n      // Remove the existing system from the system registry\n      SystemRegistry._deleteRecord(existingSystem);\n\n      // Remove the existing system's access to its namespace\n      ResourceAccess._deleteRecord(namespaceId, existingSystem);\n    } else {\n      // Otherwise, this is a new system, so register its resource ID\n      ResourceIds._setExists(systemId, true);\n    }\n\n    // Systems = mapping from system ID to system address and public access flag\n    Systems._set(systemId, address(system), publicAccess);\n\n    // SystemRegistry = mapping from system address to system ID\n    SystemRegistry._set(address(system), systemId);\n\n    // Grant the system access to its namespace\n    ResourceAccess._set(namespaceId, address(system), true);\n  }\n\n  /**\n   * @notice Registers a new World function selector\n   * @dev Creates a mapping between a World function and its associated system function\n   * @param systemId The system ID\n   * @param systemFunctionSignature The signature of the system function\n   * @return worldFunctionSelector The selector of the World function\n   */\n  function registerFunctionSelector(\n    ResourceId systemId,\n    string memory systemFunctionSignature\n  ) public returns (bytes4 worldFunctionSelector) {\n    // Require the caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Compute global function selector\n    string memory namespaceString = WorldResourceIdLib.toTrimmedString(systemId.getNamespace());\n    string memory nameString = WorldResourceIdLib.toTrimmedString(systemId.getName());\n    bytes memory worldFunctionSignature = abi.encodePacked(\n      namespaceString,\n      \"_\",\n      nameString,\n      \"_\",\n      systemFunctionSignature\n    );\n    worldFunctionSelector = bytes4(keccak256(worldFunctionSignature));\n\n    // Require the function selector to be globally unique\n    ResourceId existingSystemId = FunctionSelectors._getSystemId(worldFunctionSelector);\n\n    if (ResourceId.unwrap(existingSystemId) != 0) revert World_FunctionSelectorAlreadyExists(worldFunctionSelector);\n\n    // Register the function selector\n    bytes4 systemFunctionSelector = bytes4(keccak256(bytes(systemFunctionSignature)));\n    FunctionSelectors._set(worldFunctionSelector, systemId, systemFunctionSelector);\n\n    // Register the function signature for offchain use\n    FunctionSignatures._set(worldFunctionSelector, string(worldFunctionSignature));\n  }\n\n  /**\n   * @notice Registers a root World function selector\n   * @dev Creates a mapping for a root World function without namespace or name prefix\n   * @param systemId The system ID\n   * @param worldFunctionSignature The signature of the World function\n   * @param systemFunctionSelector The selector of the system function\n   * @return worldFunctionSelector The selector of the World function\n   */\n  function registerRootFunctionSelector(\n    ResourceId systemId,\n    string memory worldFunctionSignature,\n    bytes4 systemFunctionSelector\n  ) public returns (bytes4 worldFunctionSelector) {\n    // Require the caller to own the root namespace\n    AccessControl.requireOwner(ROOT_NAMESPACE_ID, _msgSender());\n\n    // Compute the function selector from the provided signature\n    worldFunctionSelector = bytes4(keccak256(bytes(worldFunctionSignature)));\n\n    // Require the function selector to be globally unique\n    ResourceId existingSystemId = FunctionSelectors._getSystemId(worldFunctionSelector);\n\n    if (ResourceId.unwrap(existingSystemId) != 0) revert World_FunctionSelectorAlreadyExists(worldFunctionSelector);\n\n    // Register the function selector\n    FunctionSelectors._set(worldFunctionSelector, systemId, systemFunctionSelector);\n\n    // Register the function signature for offchain use\n    FunctionSignatures._set(worldFunctionSelector, worldFunctionSignature);\n  }\n\n  /**\n   * @notice Registers a delegation for the caller\n   * @dev Creates a new delegation from the caller to the specified delegatee\n   * @param delegatee The address of the delegatee\n   * @param delegationControlId The ID controlling the delegation\n   * @param initCallData The initialization data for the delegation\n   */\n  function registerDelegation(address delegatee, ResourceId delegationControlId, bytes memory initCallData) public {\n    // Store the delegation control contract address\n    UserDelegationControl._set({\n      delegator: _msgSender(),\n      delegatee: delegatee,\n      delegationControlId: delegationControlId\n    });\n\n    // If the delegation is limited...\n    if (Delegation.isLimited(delegationControlId) && initCallData.length > 0) {\n      // Require the delegationControl contract to implement the IDelegationControl interface\n      (address delegationControl, ) = Systems._get(delegationControlId);\n      requireInterface(delegationControl, DELEGATION_CONTROL_INTERFACE_ID);\n\n      // Call the delegation control contract's init function\n      SystemCall.callWithHooksOrRevert({\n        caller: _msgSender(),\n        systemId: delegationControlId,\n        callData: initCallData,\n        value: 0\n      });\n    }\n  }\n\n  /**\n   * @notice Registers a delegation for a namespace\n   * @dev Sets up a new delegation control for a specific namespace\n   * @param namespaceId The ID of the namespace\n   * @param delegationControlId The ID controlling the delegation\n   * @param initCallData The initialization data for the delegation\n   */\n  function registerNamespaceDelegation(\n    ResourceId namespaceId,\n    ResourceId delegationControlId,\n    bytes memory initCallData\n  ) public {\n    // Require the namespaceId to be a valid namespace ID\n    if (namespaceId.getType() != RESOURCE_NAMESPACE) {\n      revert World_InvalidResourceType(RESOURCE_NAMESPACE, namespaceId, namespaceId.toString());\n    }\n\n    // Require the delegation to not be unlimited\n    if (!Delegation.isLimited(delegationControlId)) {\n      revert World_UnlimitedDelegationNotAllowed();\n    }\n\n    // Require the caller to own the namespace\n    AccessControl.requireOwner(namespaceId, _msgSender());\n\n    // Require the delegationControl contract to implement the IDelegationControl interface\n    (address delegationControl, ) = Systems._get(delegationControlId);\n    requireInterface(delegationControl, DELEGATION_CONTROL_INTERFACE_ID);\n\n    // Register the delegation control\n    NamespaceDelegationControl._set(namespaceId, delegationControlId);\n\n    // Call the delegation control contract's init function\n    if (initCallData.length > 0) {\n      SystemCall.callWithHooksOrRevert({\n        caller: _msgSender(),\n        systemId: delegationControlId,\n        callData: initCallData,\n        value: 0\n      });\n    }\n  }\n}"
    }
  ]
}