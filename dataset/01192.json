{
  "Title": "Unsafe cast in `WellPrice::getDeltaB`",
  "Content": "While not likely to overflow, there is an [unsafe cast](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/contracts/ecosystem/price/WellPrice.sol#L97) in `WellPrice::getDeltaB` which could be replaced with a safe cast.\n\n**Beanstalk Farms:** Fixed in commit [ff742a6](https://github.com/BeanstalkFarms/Beanstalk/pull/655/commits/ff742a6f5b0b166df988a2422e475d314b948fc9).",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/ecosystem/price/WellPrice.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {P} from \"./P.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {Call, IWell, IERC20} from \"../../interfaces/basin/IWell.sol\";\nimport {IBeanstalkWellFunction} from \"../../interfaces/basin/IBeanstalkWellFunction.sol\";\nimport {LibUsdOracle} from \"../../libraries/Oracle/LibUsdOracle.sol\";\nimport {LibWellMinting} from \"../../libraries/Minting/LibWellMinting.sol\";\nimport {LibWell} from \"../../libraries/Well/LibWell.sol\";\nimport {C} from \"../../C.sol\";\n\ninterface IBeanstalk {\n    function bdv(address token, uint256 amount) external view returns (uint256);\n\n    function poolDeltaB(address pool) external view returns (int256);\n}\n\ninterface dec{\n    function decimals() external view returns (uint256);\n}\n\ncontract WellPrice {\n\n    using SafeMath for uint256;\n\n    IBeanstalk private constant BEANSTALK = IBeanstalk(0xC1E088fC1323b20BCBee9bd1B9fC9546db5624C5);\n    uint256 private constant WELL_DECIMALS = 1e18;\n    uint256 private constant PRICE_PRECISION = 1e6;\n\n    struct Pool {\n        address pool;\n        address[2] tokens;\n        uint256[2] balances;\n        uint256 price;\n        uint256 liquidity;\n        int256 deltaB;\n        uint256 lpUsd;\n        uint256 lpBdv;\n    }\n\n    function getConstantProductWell(address wellAddress) public view returns (P.Pool memory pool) {\n        IWell well = IWell(wellAddress);\n        pool.pool = wellAddress;\n        \n        IERC20[] memory wellTokens = well.tokens();\n        pool.tokens = [address(wellTokens[0]), address(wellTokens[1])];\n\n        uint256[] memory wellBalances = well.getReserves();\n        pool.balances = [wellBalances[0], wellBalances[1]];\n\n        uint256 beanIndex = LibWell.getBeanIndex(wellTokens);\n        uint256 tknIndex = beanIndex == 0 ? 1 : 0;\n\n        // swap 1 bean of the opposite asset to get the usd price \n        // price = amtOut/tknOutPrice\n        uint256 assetPrice = LibUsdOracle.getUsdPrice(pool.tokens[tknIndex]);\n        if(assetPrice > 0) {\n            pool.price = \n            well.getSwapOut(wellTokens[beanIndex], wellTokens[tknIndex], 1e6)\n                .mul(PRICE_PRECISION)\n                .div(assetPrice);\n        } else {\n            // cannnot determine a price for bean if the other asset that bean is trading against is 0.\n            pool.price = 0; \n        }\n\n        // liquidity is calculated by getting the usd value of the bean portion of the pool, \n        // and multiplying by 2 to get the total liquidity of the pool.\n        pool.liquidity = \n            pool.balances[beanIndex]\n            .mul(pool.price)\n            .mul(2)\n            .div(PRICE_PRECISION);\n\n        pool.deltaB = getDeltaB(wellAddress, wellTokens, wellBalances);\n        pool.lpUsd = pool.liquidity.mul(WELL_DECIMALS).div(IERC20(wellAddress).totalSupply());\n        try BEANSTALK.bdv(wellAddress, WELL_DECIMALS) returns (uint256 bdv) {\n            pool.lpBdv = bdv;\n        } catch {}\n    }\n\n    function getDeltaB(address well, IERC20[] memory tokens, uint256[] memory reserves) internal view returns (int256 deltaB) {\n        Call memory wellFunction = IWell(well).wellFunction();\n        (uint256[] memory ratios, uint256 beanIndex, bool success) = LibWell.getRatiosAndBeanIndex(tokens);\n        // If the USD Oracle oracle call fails, we can't compute deltaB\n        if(!success) return 0;\n\n        uint256 beansAtPeg = IBeanstalkWellFunction(wellFunction.target).calcReserveAtRatioSwap(\n            reserves,\n            beanIndex,\n            ratios,\n            wellFunction.data\n        );\n\n        deltaB = int256(beansAtPeg) - int256(reserves[beanIndex]);\n    }\n\n}"
    }
  ]
}