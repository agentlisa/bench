{
  "Title": "[M-07] Attacker can steal RToken holders’ funds by performing reentrancy attack during redeem() function token transfers",
  "Content": "# Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439-L514\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L105-L150\n\n\n# Vulnerability details\n\n## Impact\nFunction `redeem()` redeems RToken for basket collateral and it updated `basketsNeeded` and transfers users basket ERC20 from BackingManager to user address. it loops through tokens and transfer them to caller and if one of tokens were ERC777 or any other 3rd party protocol token with hook, attacker can perform reentrancy attack during token transfers. Attacker can cause multiple impacts by choosing the reentrancy function:\n1. attacker can call `redeem()` again and bypass \"bounding each withdrawal by the prorata share when protocol is under-collateralized\" because tokens balance of BackingManager is not updated yet.\n2. attacker can call `BackingManager.manageTokens()` and because `basketsNeeded` gets decreased and basket tokens balances of BasketManager are not updated, code would detect those tokens as excess funds and would distribute them between RSR stakers and RToken holders and some of RToken deposits would get transferred to RSR holders as rewards.\n\n## Proof of Concept\nThis is `redeem()` code:\n```\n    function redeem(uint256 amount) external notFrozen {\n...............\n...............\n        (address[] memory erc20s, uint256[] memory amounts) = basketHandler.quote(baskets, FLOOR);\n\n        uint256 erc20length = erc20s.length;\n\n        uint192 prorate = uint192((FIX_ONE_256 * amount) / supply);\n\n        // Bound each withdrawal by the prorata share, in case we're currently under-collateralized\n        for (uint256 i = 0; i < erc20length; ++i) {\n            uint256 bal = IERC20Upgradeable(erc20s[i]).balanceOf(address(backingManager));\n\n            uint256 prorata = (prorate > 0)\n                ? (prorate * bal) / FIX_ONE // {qTok} = D18{1} * {qTok} / D18\n                : mulDiv256(bal, amount, supply); // {qTok} = {qTok} * {qRTok} / {qRTok}\n\n            if (prorata < amounts[i]) amounts[i] = prorata;\n        }\n\n        basketsNeeded = basketsNeeded_ - baskets;\n        emit BasketsNeededChanged(basketsNeeded_, basketsNeeded);\n\n        // == Interactions ==\n        _burn(redeemer, amount);\n\n        bool allZero = true;\n        for (uint256 i = 0; i < erc20length; ++i) {\n            if (amounts[i] == 0) continue;\n            if (allZero) allZero = false;\n\n            IERC20Upgradeable(erc20s[i]).safeTransferFrom(\n                address(backingManager),\n                redeemer,\n                amounts[i]\n            );\n        }\n\n        if (allZero) revert(\"Empty redemption\");\n    }\n```\nAs you can see code calculates withdrawal amount of each basket erc20 tokens by calling `basketHandler.quote()` and then bounds each withdrawal by the prorata share of token balance, in case protocol is under-collateralized. and then code updates `basketsNeeded` and in the end transfers the tokens.  if one of those tokens were ERC777 then that token would call receiver hook function in token transfer. there may be other 3rd party protocol tokens that calls registered hook functions during the token transfer. as reserve protocol is permission less and tries to work with all tokens so the external call in the token transfer can call hook functions. attacker can use this hook and perform reentrancy attack.\nThis is `fullyCollateralized()` code in BasketHandler:\n```\n    function fullyCollateralized() external view returns (bool) {\n        return basketsHeldBy(address(backingManager)) >= rToken.basketsNeeded();\n    }\n```\nAs you can see it calculates baskets that can be held by backingManager tokens balance and needed baskets by RToken contract and by comparing them determines that if RToken is fully collateralized or not. if RToken is fully collateralized then `BackingManager.manageTokens()` would call `handoutExcessAssets()` and would distributes extra funds between RToken holders and RSR stakers.\nthe root cause of the issue is that during tokens transfers in `redeem()` not all the basket tokens balance of the BackingManager updates once and if one has hook function which calls attacker contract then attacker can use this updated token balance of the contract and perform his reentrancy attack. attacker can call different functions for reentrancy. these are two scenarios:\n** scenario #1: attacker call `redeem()` again and bypass prorata share bound check when protocol is under-collaterialized:\n1. tokens [`SOME_ERC777`, `USDT`] with quantity [1, 1] are in the basket right now and basket nonce is BasketNonce1.\n2. BackingManager has 200K `SOME_ERC777` balance and 100K `USDT` balance. `basketsNeeded` in RToken is 150K and RToken supply is 150K and attacker address Attacker1 has 30k RToken. battery charge allows for attacker to withdraw 30K tokens in one block.\n3. attacker would register a hook for his address in `SOME_ERC777` token to get called during transfers.\n4. attacker would call `redeem()` to redeem 15K RToken and code would updated `basketsNeeded` to 135K and code would bounds withdrawal by prorata shares of balance of the BackingManager because protocol is under-collateralized and code would calculated withdrawal amouns as 15K `SOME_ERC777` tokens and 10K `USDT` tokens (instead of 15K `USDT` tokens) for withdraws.\n5. then contract would transfer 15K `SOME_ERC777` tokens first to attacker address and attacker contract would get called during the hook function and now `basketsNeeded` is 135K and total RTokens is 135K and BackingManager balance is 185K `SOME_ERC777` and 100K `USDT` (`USDT` is not yet transferred). then attacker contract can call `redeem()` again for the remaining 15K RTokens.\n6. because protocol is under-collateralized code would calculated withdrawal amouns as 15K `SOME_ERC777` and 11.1K `USDT` (USDT_balance * rtokenAmount / totalSupply = 100K * 15K / 135K) and it would burn 15K RToken form caller and the new value of totalSupply of RTokens would be 120K and `basketsNeeded` would be 120K too. then code would transfers 15K `SOME_ERC777` and 11.1K `USDT` for attacker address. \n7. attacker's hook function would return and `redeem()` would transfer 10K `USDT` to attacker in the rest of the execution. attacker would receive 30K `SOME_ERC777` and 21.1K `USDT` tokens for 15K redeemed RToken but attacker should have get (`100 * 30K / 150K = 20K`) 20K `USDT` tokens because of the bound each withdrawal by the prorata share, in case we're currently under-collateralized.\n8. so attacker would be able to bypass the bounding check and withdraw more funds and stole other users funds. the attack is more effective if withdrawal battery charge is higher but in general case attacker can perform two withdraw each with about `charge/2` amount of RToken in each block and stole other users funds when protocol is under collaterlized.\n\n** scenario #2: attacker can call `BackingManager.manageTokens()` for reentrancy call:\n1. tokens [`SOME_ERC777`, `USDT`] with quantity [1, 1] are in the basket right now and basket nonce is BasketNonce1.\n2. BackingManager has 200K `SOME_ERC777` balance and 150K `USDT` balance. `basketsNeeded` in RToken is 150K and RToken supply is 150K and attacker address Attacker1 has 30k RToken. battery charge allows for attacker to withdraw 30K tokens in one block.\n3. attacker would register a hook for his address in `SOME_ERC777` token to get called during transfers.\n4. attacker would call `redeem()` to redeem 30K RToken and code would updated `basketsNeeded` to 120K and burn 30K RToken and code would calculated withdrawal amounts as 30K `SOME_ERC777` tokens and 30K `USDT` tokens for withdraws.\n5. then contract would transfer 30K `SOME_ERC777` tokens first to attacker address and attacker contract would get called during the hook function and now `basketsNeeded` is 120K and total RTokens is 120K and BackingManager balance is 170K `SOME_ERC777` and 150K `USDT` (`USDT` is not yet transferred). then attacker contract can call `BackingManager.manageTokens()`.\n6. function `manageTokens()` would calculated baskets can held by BackingManager and it would be higher than 150K and `basketsNeeded` would be 130K and code would consider 60K `SOME_ERC777` and 30K `USDT` tokens as revenue and try to distribute it between RSR stakers and RToken holders. code would mint 30K RTokens and would distribute it.\n7. then attacker hook function would return and `redeem()` would transfer 30K `USDT` to attacker address in rest of the execution.\n8. so attacker would able to make code to calculate RToken holders backed tokens as revenue and distribute it between RSR stakers and RSR stakers would receive RTokens backed tokens as rewards. the attack is more effective is battery charge is high but in general case attacker can call redeem for battery charge amount and cause those funds to be counted and get distributed to the RSR stakers (according to the rewards distribution rate)\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\nprevent reading reentrancy attack by central reentrancy guard or by one main proxy interface contract that has reentrancy guard.\nor create contract state (similar to basket nonce) which changes after each interaction and check for contracts states change during the call. (start and end of the call)\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-reserve-contest",
  "Code": [
    {
      "filename": "contracts/p1/RToken.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\n// solhint-disable-next-line max-line-length\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../interfaces/IRToken.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"../libraries/RedemptionBattery.sol\";\nimport \"./mixins/Component.sol\";\nimport \"./mixins/RewardableLib.sol\";\nimport \"../vendor/ERC20PermitUpgradeable.sol\";\n\n// MIN_BLOCK_ISSUANCE_LIMIT: {rTok/block} 10k whole RTok\nuint192 constant MIN_BLOCK_ISSUANCE_LIMIT = 10_000 * FIX_ONE;\n\n// MAX_ISSUANCE_RATE: 100%\nuint192 constant MAX_ISSUANCE_RATE = FIX_ONE; // {1}\n\n/**\n * @title RTokenP1\n * An ERC20 with an elastic supply and governable exchange rate to basket units.\n */\ncontract RTokenP1 is ComponentP1, ERC20PermitUpgradeable, IRToken {\n    using RedemptionBatteryLib for RedemptionBatteryLib.Battery;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// The mandate describes what goals its governors should try to achieve. By succinctly\n    /// explaining the RToken’s purpose and what the RToken is intended to do, it provides common\n    /// ground for the governors to decide upon priorities and how to weigh tradeoffs.\n    ///\n    /// Example Mandates:\n    ///\n    /// - Capital preservation first. Spending power preservation second. Permissionless\n    ///     access third.\n    /// - Capital preservation above all else. All revenues fund the over-collateralization pool.\n    /// - Risk-neutral pursuit of profit for token holders.\n    ///     Maximize (gross revenue - payments for over-collateralization and governance).\n    /// - This RToken holds only FooCoin, to provide a trade for hedging against its\n    ///     possible collapse.\n    ///\n    /// The mandate may also be a URI to a longer body of text, presumably on IPFS or some other\n    /// immutable data store.\n    string public mandate;\n\n    // ==== Governance Params ====\n\n    // D18{1} fraction of supply that may be issued per block\n    // Always, issuanceRate <= MAX_ISSUANCE_RATE = FIX_ONE\n    uint192 public issuanceRate;\n\n    // the following governance parameters exist inside the Battery struct:\n    //      battery.redemptionRateFloor\n    //      battery.scalingRedemptionRate\n\n    // ==== End Governance Params ====\n\n    // ==== Peer components ====\n    IAssetRegistry private assetRegistry;\n    IBasketHandler private basketHandler;\n    IBackingManager private backingManager;\n    IFurnace private furnace;\n\n    // The number of baskets that backingManager must hold\n    // in order for this RToken to be fully collateralized.\n    // The exchange rate for issuance and redemption is totalSupply()/basketsNeeded {BU}/{qRTok}.\n    uint192 public basketsNeeded; // D18{BU}\n\n    // ==== Slow Issuance State====\n\n    // When all pending issuances will have vested.\n    uint192 private allVestAt; // D18{fractional block number}\n\n    // Enforce a fixed issuanceRate throughout the entire block by caching it.\n    // Both of these MUST only be modified by whenFinished()\n    uint192 private lastIssRate; // D18{rTok/block}\n    uint256 private lastIssRateBlock; // {block number}\n\n    // IssueItem: One edge of an issuance\n    struct IssueItem {\n        uint192 when; // D18{fractional block number}\n        uint256 amtRToken; // {qRTok} Total amount of RTokens that have vested by `when`\n        uint192 amtBaskets; // D18{BU} Total amount of baskets that should back those RTokens\n        uint256[] deposits; // {qTok}, Total amounts of basket collateral deposited for vesting\n    }\n\n    struct IssueQueue {\n        uint256 basketNonce; // The nonce of the basket this queue models deposits against\n        address[] tokens; // Addresses of the erc20 tokens modelled by deposits in this queue\n        uint256 left; // [left, right) is the span of currently-valid items\n        uint256 right; //\n        IssueItem[] items; // The actual items (The issuance \"fenceposts\")\n    }\n\n    mapping(address => IssueQueue) public issueQueues;\n\n    // Redemption throttle\n    RedemptionBatteryLib.Battery private battery;\n\n    // {ERC20: {qTok} owed to Recipients}\n    // During reward sweeping, we sweep token balances - liabilities\n    mapping(IERC20 => uint256) private liabilities;\n\n    // For an initialized IssueQueue queue:\n    //     queue.right >= left\n    //     queue.right == left  iff  there are no more pending issuances in this queue\n    //\n    // The short way to describe this is that IssueQueue stores _cumulative_ issuances, not raw\n    // issuances, and so any particular issuance is actually the _difference_ between two adjaacent\n    // TotalIssue items in an IssueQueue.\n    //\n    // The way to keep an IssueQueue striaght in your head is to think of each TotalIssue item as a\n    // \"fencepost\" in the queue of actual issuances. The true issuances are the spans between the\n    // TotalIssue items. For example, if:\n    //    queue.items[queue.left].amtRToken == 1000 , and\n    //    queue.items[queue.right - 1].amtRToken == 6000,\n    // then the issuance \"between\" them is 5000 RTokens. If we waited long enough and then called\n    // vest() on that account, we'd vest 5000 RTokens *to* that account.\n    //\n    // You can vestUpTo an IssueItem queue[i] if\n    //   left < i <= right, and\n    //   block.number >= queue[i].when.toUint()\n    //\n    // We define a (partial) ordering on IssueItems: item1 < item2 iff the following all hold:\n    //   item1.when < item2.when\n    //   item1.amtRToken < item2.amtRToken\n    //   item1.amtBaskets < item2.amtBaskets\n    //   for all valid indices i, item1.deposits[i] < item2.deposits[i]\n    //\n    // And, in fact, item2 - item1 is then well-defined (and also piecewise).\n    //\n    // We'll also define lastItem(addr) as a function of contract state:\n    //     if queue.right == 0 then IssueItem.zero else queue.items[queue.right]\n    //     where queue = issueQueues[addr]\n    //\n    // ==== Invariants ====\n    // For any queue in value(issueQueues):\n    //   if 0 <= i < j <= queue.right, then item[i] < item[j]\n    //   queue.items[queue.right] <= allVestAt\n    //\n    // If queue.left < queue.right, then:\n    // - all the issue() calls it models happened while basketHandler.nonce() was queue.basketNonce\n    // - queue.tokens = erc20s for each of those issuances, where (erc20s, _) = basket.quote()\n    //     so, queue.tokens was the bskt token list when basketHandler.nonce() was queue.basketNonce\n    // - for each item in queue.items: queue.tokens.length == item.deposits.length\n\n    function init(\n        IMain main_,\n        string calldata name_,\n        string calldata symbol_,\n        string calldata mandate_,\n        uint192 issuanceRate_,\n        uint192 scalingRedemptionRate_,\n        uint256 redemptionRateFloor_\n    ) external initializer {\n        require(bytes(name_).length > 0, \"name empty\");\n        require(bytes(symbol_).length > 0, \"symbol empty\");\n        require(bytes(mandate_).length > 0, \"mandate empty\");\n        __Component_init(main_);\n        __ERC20_init(name_, symbol_);\n        __ERC20Permit_init(name_);\n\n        assetRegistry = main_.assetRegistry();\n        basketHandler = main_.basketHandler();\n        backingManager = main_.backingManager();\n        furnace = main_.furnace();\n\n        mandate = mandate_;\n        setIssuanceRate(issuanceRate_);\n        setScalingRedemptionRate(scalingRedemptionRate_);\n        setRedemptionRateFloor(redemptionRateFloor_);\n    }\n\n    /// Begin a time-delayed issuance of RToken for basket collateral\n    /// @param amtRToken {qTok} The quantity of RToken to issue\n    /// @custom:interaction nearly CEI, but see comments around handling of refunds\n    function issue(uint256 amtRToken) external {\n        issue(_msgSender(), amtRToken);\n    }\n\n    /// Begin a time-delayed issuance of RToken for basket collateral\n    /// @param recipient The address to receive the issued RTokens\n    /// @param amtRToken {qTok} The quantity of RToken to issue\n    /// @return mintedAmount {qTok} The amount of RTokens minted (instantly issued)\n    /// @custom:interaction nearly CEI, but see comments around handling of refunds\n    function issue(address recipient, uint256 amtRToken)\n        public\n        notPausedOrFrozen\n        returns (uint256)\n    {\n        require(amtRToken > 0, \"Cannot issue zero\");\n\n        // == Refresh ==\n        assetRegistry.refresh();\n\n        address issuer = _msgSender(); // OK to save: it can't be changed in reentrant runs\n\n        uint48 basketNonce = basketHandler.nonce();\n        IssueQueue storage queue = issueQueues[recipient];\n\n        // Refund issuances against old baskets\n        if (queue.basketNonce > 0 && queue.basketNonce != basketNonce) {\n            // == Interaction ==\n            // This violates simple CEI, so we have to renew any potential transient state!\n            refundSpan(recipient, queue.left, queue.right);\n\n            // Refresh collateral after interaction\n            assetRegistry.refresh();\n\n            // Refresh local values after potential reentrant changes to contract state.\n            basketNonce = basketHandler.nonce();\n            queue = issueQueues[recipient];\n        }\n\n        // == Checks-effects block ==\n        CollateralStatus status = basketHandler.status();\n        require(status == CollateralStatus.SOUND, \"basket unsound\");\n\n        furnace.melt();\n\n        // AT THIS POINT:\n        //   all contract invariants hold\n        //   furnace melting is up-to-date\n        //   asset states are up-to-date\n        //   queue.basketNonce = basketHandler.nonce()\n\n        // Compute the whole issuance span. We want to accumulate the issuance:\n        // iss = {when: vestingEnd' - vestingEnd, amtRToken, amtBaskets, deposits}\n\n        // amtBaskets: the BU change to be recorded by this issuance\n        // D18{BU} = D18{BU} * {qRTok} / {qRTok}\n        // Downcast is safe because an actual quantity of qBUs fits in uint192\n        uint192 amtBaskets = uint192(\n            totalSupply() > 0 ? mulDiv256(basketsNeeded, amtRToken, totalSupply()) : amtRToken\n        );\n\n        (address[] memory erc20s, uint256[] memory deposits) = basketHandler.quote(\n            amtBaskets,\n            CEIL\n        );\n\n        // Add amtRToken's worth of issuance delay to allVestAt\n        uint192 vestingEnd = whenFinished(amtRToken); // D18{block number}\n\n        // ==== If the issuance can fit in this block, and nothing is blocking it, then\n        // just do a \"quick issuance\" of iss instead of putting the issuance in the queue:\n        // effects and actions if we go this way are the combined actions to create and vest iss:\n        //   basketsNeeded += iss.amtBaskets\n        //   mint(recipient, iss.amtRToken)\n        //   for each token index i, erc20s[i].transferFrom(issuer, backingManager, iss.deposits[i])\n        if (\n            // D18{blocks} <= D18{1} * {blocks}\n            vestingEnd <= FIX_ONE_256 * block.number &&\n            queue.left == queue.right &&\n            status == CollateralStatus.SOUND\n        ) {\n            // Fixlib optimization:\n            // D18{BU} = D18{BU} + D18{BU}; uint192(+) is the same as Fix.plus\n            uint192 newBasketsNeeded = basketsNeeded + amtBaskets;\n            emit BasketsNeededChanged(basketsNeeded, newBasketsNeeded);\n            basketsNeeded = newBasketsNeeded;\n\n            // Note: We don't need to update the prev queue entry because queue.left = queue.right\n            emit Issuance(recipient, amtRToken, amtBaskets);\n\n            // == Interactions then return: transfer tokens ==\n            // Complete issuance\n            _mint(recipient, amtRToken);\n\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                IERC20Upgradeable(erc20s[i]).safeTransferFrom(\n                    issuer,\n                    address(backingManager),\n                    deposits[i]\n                );\n            }\n\n            // All RTokens instantly issued\n            return amtRToken;\n        }\n\n        // ==== Otherwise, we're going to create and enqueue the issuance \"iss\":\n        // effects and actions down this route are:\n        //   lastItem'(recipient) = lastItem(recipient) + iss\n        //   for each token index i, erc20s[i].transferFrom(issuer, this, iss.deposits[i])\n        // Append issuance to queue (whether that needs a new allocation with push() or not)\n        IssueItem storage curr = (queue.right < queue.items.length)\n            ? queue.items[queue.right]\n            : queue.items.push();\n        curr.when = vestingEnd;\n\n        uint256 basketSize = erc20s.length; // gas optimization\n\n        // Accumulate\n        if (queue.right > 0) {\n            IssueItem storage prev = queue.items[queue.right - 1];\n            curr.amtRToken = prev.amtRToken + amtRToken;\n\n            // D18{BU} = D18{BU} + D18{BU}; uint192(+) is the same as Fix.plus\n            curr.amtBaskets = prev.amtBaskets + amtBaskets;\n\n            curr.deposits = new uint256[](deposits.length);\n            for (uint256 i = 0; i < basketSize; ++i) {\n                curr.deposits[i] = prev.deposits[i] + deposits[i];\n            }\n        } else {\n            // queue.right == 0\n            curr.amtRToken = amtRToken;\n            curr.amtBaskets = amtBaskets;\n            curr.deposits = deposits;\n        }\n\n        // overwrite intentionally: we may have stale values in `tokens` and `basketNonce`\n        queue.basketNonce = basketNonce;\n        queue.tokens = erc20s;\n        queue.right++;\n\n        emit IssuanceStarted(\n            recipient,\n            queue.right - 1,\n            amtRToken,\n            amtBaskets,\n            erc20s,\n            deposits,\n            vestingEnd\n        );\n\n        // Increment liabilities\n        for (uint256 i = 0; i < basketSize; ++i) {\n            liabilities[IERC20(erc20s[i])] += deposits[i];\n        }\n\n        // == Interactions: accept collateral ==\n        for (uint256 i = 0; i < basketSize; ++i) {\n            IERC20Upgradeable(erc20s[i]).safeTransferFrom(issuer, address(this), deposits[i]);\n        }\n\n        // No RTokens instantly issued\n        return 0;\n    }\n\n    /// Add amtRToken's worth of issuance delay to allVestAt, and return the resulting finish time.\n    /// @return finished D18{block} The new value of allVestAt\n    function whenFinished(uint256 amtRToken) private returns (uint192 finished) {\n        // Calculate the issuance rate (if this is the first issuance in the block)\n        if (lastIssRateBlock < block.number) {\n            lastIssRateBlock = block.number;\n\n            // D18{rTok/block} = D18{1/block} * D18{rTok} / D18{1}\n            // uint192 downcast is safe, max value representations are 1e18 * 1e48 / 1e18\n            lastIssRate = uint192((issuanceRate * totalSupply()) / FIX_ONE);\n            // uint192(<) is equivalent to Fix.lt\n            if (lastIssRate < MIN_BLOCK_ISSUANCE_LIMIT) lastIssRate = MIN_BLOCK_ISSUANCE_LIMIT;\n        }\n\n        // make `before` be the fractional-block when this issuance should start;\n        // before = max(allVestAt, block.number - 1)\n        uint192 before = allVestAt; // D18{block number}\n        // uint192 downcast is safe: block numbers are smaller than 1e38\n        uint192 nowStart = uint192(FIX_ONE * (block.number - 1)); // D18{block} = D18{1} * {block}\n        if (nowStart > before) before = nowStart;\n\n        // finished: D18{block} = D18{block} + D18{1} * D18{RTok} / D18{rtok/block}\n        // uint192() downcast here is safe because:\n        //   lastIssRate is at least 1e24 (from MIN_ISS_RATE), and\n        //   amtRToken is at most 1e48, so\n        //   what's downcast is at most (1e18 * 1e48 / 1e24) = 1e38 < 2^192-1\n        finished = before + uint192((FIX_ONE_256 * amtRToken + (lastIssRate - 1)) / lastIssRate);\n        allVestAt = finished;\n    }\n\n    /// Vest all available issuance for the account\n    /// Callable by anyone!\n    /// @param account The address of the account to vest issuances for\n    /// @custom:completion\n    /// @custom:interaction CEI\n    // Thin wrapper over refundSpan() and vestUpTo(); see those for correctness analysis\n    function vest(address account, uint256 endId) external notPausedOrFrozen {\n        // == Keepers ==\n        main.assetRegistry().refresh();\n\n        // == Checks ==\n        CollateralStatus status = basketHandler.status();\n        require(status == CollateralStatus.SOUND, \"basket unsound\");\n\n        IssueQueue storage queue = issueQueues[account];\n        uint48 basketNonce = basketHandler.nonce();\n\n        // == Interactions ==\n        // ensure that the queue models issuances against the current basket, not previous baskets;\n        // refund all old issuances if there are any\n        if (queue.basketNonce != basketNonce) {\n            refundSpan(account, queue.left, queue.right);\n        } else {\n            vestUpTo(account, endId);\n        }\n    }\n\n    /// Cancel some vesting issuance(s)\n    /// Only callable by the account owner\n    /// If earliest == true, cancel id if id < endId\n    /// If earliest == false, cancel id if endId <= id\n    /// @param endId The issuance index to cancel through\n    /// @param earliest If true, cancel earliest issuances; else, cancel latest issuances\n    /// @custom:interaction CEI\n    function cancel(uint256 endId, bool earliest) external notFrozen {\n        address account = _msgSender();\n        IssueQueue storage queue = issueQueues[account];\n\n        require(queue.left <= endId && endId <= queue.right, \"out of range\");\n\n        // == Interactions ==\n        if (earliest) {\n            refundSpan(account, queue.left, endId);\n        } else {\n            refundSpan(account, endId, queue.right);\n        }\n    }\n\n    /// Redeem RToken for basket collateral\n    /// @param amount {qTok} The quantity {qRToken} of RToken to redeem\n    /// @custom:action\n    /// @custom:interaction CEI\n    // checks:\n    //   balanceOf(caller) >= amount\n    //   basket is not DISABLED\n    //\n    // effects:\n    //   (so totalSupply -= amount and balanceOf(caller) -= amount)\n    //   basketsNeeded' / totalSupply' >== basketsNeeded / totalSupply\n    //\n    // actions:\n    //   let erc20s = basketHandler.erc20s()\n    //   burn(caller, amount)\n    //   for each token in erc20s:\n    //     let tokenAmt = (amount * basketsNeeded / totalSupply) baskets of support for token\n    //     let prorataAmt = (amount / totalSupply) * token.balanceOf(backingManager)\n    //     do token.transferFrom(backingManager, caller, min(tokenAmt, prorataAmt))\n    function redeem(uint256 amount) external notFrozen {\n        require(amount > 0, \"Cannot redeem zero\");\n\n        // == Refresh ==\n        main.assetRegistry().refresh();\n\n        // == Checks and Effects ==\n        address redeemer = _msgSender();\n        // Allow redemption during IFFY + UNPRICED\n        require(basketHandler.status() != CollateralStatus.DISABLED, \"collateral default\");\n\n        // Failure to melt results in a lower redemption price, so we can allow it when paused\n        // solhint-disable-next-line no-empty-blocks\n        try main.furnace().melt() {} catch {}\n\n        uint192 basketsNeeded_ = basketsNeeded; // gas optimization\n\n        // ==== Get basket redemption ====\n        // i.e, set (erc20s, amounts) = basketHandler.quote(amount * basketsNeeded / totalSupply)\n\n        // D18{BU} = D18{BU} * {qRTok} / {qRTok}\n        // downcast is safe: amount < totalSupply and basketsNeeded_ < 1e57 < 2^190 (just barely)\n        uint256 supply = totalSupply();\n        uint192 baskets = uint192(mulDiv256(basketsNeeded_, amount, supply));\n        emit Redemption(redeemer, amount, baskets);\n\n        (address[] memory erc20s, uint256[] memory amounts) = basketHandler.quote(baskets, FLOOR);\n\n        // ==== Prorate redemption ====\n        // i.e, set amounts = min(amounts, balances * amount / totalSupply)\n        //   where balances[i] = erc20s[i].balanceOf(this)\n\n        uint256 erc20length = erc20s.length;\n\n        // D18{1} = D18 * {qRTok} / {qRTok}\n        // downcast is safe: amount <= balanceOf(redeemer) <= totalSupply(), so prorate < 1e18\n        uint192 prorate = uint192((FIX_ONE_256 * amount) / supply);\n\n        // Bound each withdrawal by the prorata share, in case we're currently under-collateralized\n        for (uint256 i = 0; i < erc20length; ++i) {\n            // {qTok}\n            uint256 bal = IERC20Upgradeable(erc20s[i]).balanceOf(address(backingManager));\n\n            // gas-optimization: only do the full mulDiv256 if prorate is 0\n            uint256 prorata = (prorate > 0)\n                ? (prorate * bal) / FIX_ONE // {qTok} = D18{1} * {qTok} / D18\n                : mulDiv256(bal, amount, supply); // {qTok} = {qTok} * {qRTok} / {qRTok}\n\n            if (prorata < amounts[i]) amounts[i] = prorata;\n        }\n\n        // Revert if redemption exceeds battery capacity\n        battery.discharge(supply, amount); // reverts on over-redemption\n\n        basketsNeeded = basketsNeeded_ - baskets;\n        emit BasketsNeededChanged(basketsNeeded_, basketsNeeded);\n\n        // == Interactions ==\n        // Accept and burn RToken, reverts if not enough balance to burn\n        _burn(redeemer, amount);\n\n        bool allZero = true;\n        for (uint256 i = 0; i < erc20length; ++i) {\n            if (amounts[i] == 0) continue;\n            if (allZero) allZero = false;\n\n            // Send withdrawal\n            IERC20Upgradeable(erc20s[i]).safeTransferFrom(\n                address(backingManager),\n                redeemer,\n                amounts[i]\n            );\n        }\n\n        if (allZero) revert(\"Empty redemption\");\n    }\n\n    // === Rewards ===\n\n    /// Claim rewards for all ERC20s\n    /// @custom:interaction\n    function claimRewards() external {\n        requireNotPausedOrFrozen();\n        RewardableLibP1.claimRewards(assetRegistry);\n    }\n\n    /// Claim rewards for one ERC20\n    /// @custom:interaction\n    function claimRewardsSingle(IERC20 erc20) external {\n        requireNotPausedOrFrozen();\n        RewardableLibP1.claimRewardsSingle(assetRegistry.toAsset(erc20));\n    }\n\n    /// Sweep all token balances in excess of liabilities to the BackingManager\n    /// @custom:interaction\n    function sweepRewards() external {\n        requireNotPausedOrFrozen();\n        RewardableLibP1.sweepRewards(liabilities, assetRegistry, backingManager);\n    }\n\n    /// Sweep an ERC20's rewards in excess of liabilities to the BackingManager\n    /// @custom:interaction\n    function sweepRewardsSingle(IERC20 erc20) external {\n        requireNotPausedOrFrozen();\n        RewardableLibP1.sweepRewardsSingle(liabilities, erc20, assetRegistry, backingManager);\n    }\n\n    // ====\n\n    /// Mint a quantity of RToken to the `recipient`, decreasing the basket rate\n    /// @param recipient The recipient of the newly minted RToken\n    /// @param amtRToken {qRTok} The amtRToken to be minted\n    /// @custom:protected\n    // checks: unpaused; unfrozen; caller is backingManager\n    // effects:\n    //   bal'[recipient] = bal[recipient] + amtRToken\n    //   totalSupply' = totalSupply + amtRToken\n    function mint(address recipient, uint256 amtRToken) external {\n        requireNotPausedOrFrozen();\n        require(_msgSender() == address(backingManager), \"not backing manager\");\n        _mint(recipient, amtRToken);\n        requireValidBUExchangeRate();\n    }\n\n    /// Melt a quantity of RToken from the caller's account, increasing the basket rate\n    /// @param amtRToken {qRTok} The amtRToken to be melted\n    // checks: not paused or frozen\n    // effects:\n    //   bal'[caller] = bal[caller] - amtRToken\n    //   totalSupply' = totalSupply - amtRToken\n    function melt(uint256 amtRToken) external notPausedOrFrozen {\n        _burn(_msgSender(), amtRToken);\n        emit Melted(amtRToken);\n        requireValidBUExchangeRate();\n    }\n\n    /// An affordance of last resort for Main in order to ensure re-capitalization\n    /// @custom:protected\n    // checks: unpaused; unfrozen; caller is backingManager\n    // effects: basketsNeeded' = basketsNeeded_\n    function setBasketsNeeded(uint192 basketsNeeded_) external {\n        requireNotPausedOrFrozen();\n        require(_msgSender() == address(backingManager), \"not backing manager\");\n        emit BasketsNeededChanged(basketsNeeded, basketsNeeded_);\n        basketsNeeded = basketsNeeded_;\n        requireValidBUExchangeRate();\n    }\n\n    /// @param val {1/block}\n    /// @custom:governance\n    function setIssuanceRate(uint192 val) public governance {\n        require(val > 0 && val <= MAX_ISSUANCE_RATE, \"invalid issuanceRate\");\n        emit IssuanceRateSet(issuanceRate, val);\n        issuanceRate = val;\n    }\n\n    /// @return {1/hour} The max redemption charging rate\n    function scalingRedemptionRate() external view returns (uint192) {\n        return battery.scalingRedemptionRate;\n    }\n\n    /// @param val {1/hour}\n    /// @custom:governance\n    function setScalingRedemptionRate(uint192 val) public governance {\n        require(val <= FIX_ONE, \"invalid fraction\");\n        emit ScalingRedemptionRateSet(battery.scalingRedemptionRate, val);\n        battery.scalingRedemptionRate = val;\n    }\n\n    /// @return {qRTok/hour} The min redemption charging rate, in {qRTok}\n    function redemptionRateFloor() external view returns (uint256) {\n        return battery.redemptionRateFloor;\n    }\n\n    /// @param val {qRTok/hour}\n    /// @custom:governance\n    function setRedemptionRateFloor(uint256 val) public governance {\n        emit RedemptionRateFloorSet(battery.redemptionRateFloor, val);\n        battery.redemptionRateFloor = val;\n    }\n\n    /// @dev This function is only here because solidity can't autogenerate our getter\n    function issueItem(address account, uint256 index) external view returns (IssueItem memory) {\n        IssueQueue storage item = issueQueues[account];\n        require(index >= item.left && index < item.right, \"out of range\");\n        return item.items[index];\n    }\n\n    /// @return {qRTok} The maximum redemption that can be performed in the current block\n    function redemptionLimit() external view returns (uint256) {\n        return battery.currentCharge(totalSupply());\n    }\n\n    /// @return left The index of the left sides of the issuance queue for the account\n    /// @return right The index of the right sides of the issuance queue for the account\n    function queueBounds(address account) external view returns (uint256 left, uint256 right) {\n        return (issueQueues[account].left, issueQueues[account].right);\n    }\n\n    // ==== private ====\n    /// Refund all deposits in the span [left, right)\n    /// @custom:interaction\n\n    // Precisely: if right > left, then:\n    //\n    //   let iss = item(right) - item(left)\n    //     where item(0) = the zero item\n    //         | item(n) = issueQueues[account].items[n-1]\n    //\n    //   (effect) ELIMINATE ISSUANCE SPAN: Set queue.left and queue.right so that:\n    //     [queue'.left, queue'.right) intersect [left, right) == empty set\n    //     [queue'.left, queue'.right) union [left, right) == [queue.left, queue.right)\n    //     If [queue'.left, queue'.right) == empty set, then queue'.left == queue'.right == 0\n    //\n    //   (action) REFUND DEPOSITS: For i in [0, iss.deposits.length):\n    //     issueQueues[account].erc20s[i].transfer(account, iss.deposits[i])\n    function refundSpan(\n        address account,\n        uint256 left,\n        uint256 right\n    ) private {\n        if (left >= right) return; // refund an empty span\n\n        IssueQueue storage queue = issueQueues[account];\n\n        // compute total deposits to refund\n        uint256 tokensLen = queue.tokens.length;\n        uint256[] memory amt = new uint256[](tokensLen);\n        uint256 amtRToken; // {qRTok}\n        IssueItem storage rightItem = queue.items[right - 1];\n\n        // compute item(right-1) - item(left-1)\n        // we could dedup this logic for the zero item, but it would take more SLOADS\n        if (left == 0) {\n            amtRToken = rightItem.amtRToken;\n            for (uint256 i = 0; i < tokensLen; ++i) {\n                amt[i] = rightItem.deposits[i];\n\n                // Decrement liabilities\n                liabilities[IERC20(queue.tokens[i])] -= amt[i];\n            }\n        } else {\n            IssueItem storage leftItem = queue.items[left - 1];\n            amtRToken = rightItem.amtRToken - leftItem.amtRToken;\n            for (uint256 i = 0; i < tokensLen; ++i) {\n                amt[i] = rightItem.deposits[i] - leftItem.deposits[i];\n\n                // Decrement liabilities\n                liabilities[IERC20(queue.tokens[i])] -= amt[i];\n            }\n        }\n\n        if (queue.left == left && right == queue.right) {\n            // empty entire queue\n            queue.left = 0;\n            queue.right = 0;\n        } else if (queue.left == left && right < queue.right) {\n            queue.left = right; // remove span from beginning\n        } else if (queue.left < left && right == queue.right) {\n            queue.right = left; // refund span from end\n        } else {\n            // untestable:\n            //      All calls to refundSpan() use valid values for left and right.\n            //      queue.left <= left && right <= queue.right.\n            //      Any call to refundSpan() passes queue.left for left,\n            //      OR passes queue.right for right, OR both.\n            revert(\"Bad refundSpan\");\n        } // error: can't remove [left,right) from the queue, and leave just one interval\n\n        emit IssuancesCanceled(account, left, right, amtRToken);\n\n        // == Interactions ==\n        for (uint256 i = 0; i < queue.tokens.length; ++i) {\n            IERC20Upgradeable(queue.tokens[i]).safeTransfer(account, amt[i]);\n        }\n    }\n\n    /// Vest all RToken issuance in queue = queues[account], from queue.left to < endId\n    /// Fixes up queue.left and queue.right\n    /// @custom:interaction\n    // let iss = item(endId) - item(queue.left)\n    //     where item(0) = the zero item\n    //         | item(n) = issueQueues[account].items[n-1]\n    //\n    // checks:\n    //   queue.left <= endId <= queue.right\n    //   item(endId).when <= block.number + 1\n    //\n    //\n    //   (effect) ELIMINATE ISSUANCE SPAN: Set queue.left so that:\n    //     [queue'.left, queue'.right) intersect [queue.left, endId) == empty set\n    //     [queue'.left, queue'.right) union [queue.left, endId) == [queue.left, queue.right)\n    //     If [queue'.left, queue'.right) == empty set, then queue'.left == queue'.right == 0\n    //\n    //   (effect + action) COMPLETE ISSUANCE of iss:\n    //     for i in [0, iss.deposits.length):\n    //       issueQueues[account].erc20s[i].transfer(backingManager, iss.deposits[i]\n    //     _mint(account, iss.amtRToken)\n    function vestUpTo(address account, uint256 endId) private {\n        IssueQueue storage queue = issueQueues[account];\n        if (queue.left == endId) return;\n\n        require(queue.left <= endId && endId <= queue.right, \"out of range\");\n\n        // Vest the span up to `endId`.\n        uint256 amtRToken;\n        uint192 amtBaskets;\n        IssueItem storage rightItem = queue.items[endId - 1];\n        require(rightItem.when <= FIX_ONE_256 * block.number, \"issuance not ready\");\n\n        uint256 tokensLen = queue.tokens.length;\n        uint256[] memory amtDeposits = new uint256[](tokensLen);\n\n        // compute item(right - 1) - item(left - 1)\n        // we could dedup this logic for the zero item, but it would take more SLOADS\n        if (queue.left == 0) {\n            amtRToken = rightItem.amtRToken;\n            amtBaskets = rightItem.amtBaskets;\n            for (uint256 i = 0; i < tokensLen; ++i) {\n                amtDeposits[i] = rightItem.deposits[i];\n\n                // Decrement liabilities\n                liabilities[IERC20(queue.tokens[i])] -= amtDeposits[i];\n            }\n        } else {\n            IssueItem storage leftItem = queue.items[queue.left - 1];\n            amtRToken = rightItem.amtRToken - leftItem.amtRToken;\n            amtBaskets = rightItem.amtBaskets - leftItem.amtBaskets;\n            for (uint256 i = 0; i < tokensLen; ++i) {\n                amtDeposits[i] = rightItem.deposits[i] - leftItem.deposits[i];\n\n                // Decrement liabilities\n                liabilities[IERC20(queue.tokens[i])] -= amtDeposits[i];\n            }\n        }\n\n        emit BasketsNeededChanged(basketsNeeded, basketsNeeded + amtBaskets);\n        // uint192(+) is safe for Fix.plus()\n        basketsNeeded = basketsNeeded + amtBaskets;\n\n        emit Issuance(account, amtRToken, amtBaskets);\n        emit IssuancesCompleted(account, queue.left, endId, amtRToken);\n\n        if (endId == queue.right) {\n            // empty the queue - left is implicitly queue.left already\n            queue.left ="
    }
  ]
}