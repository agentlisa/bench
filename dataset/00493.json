{
  "Title": "M-6: FeeManager `receiveFee` and `trackVaultFee` functions allow anyone to call it with user-provided dvp/vault address and add any arbitrary feeAmount to any address, breaking fees accounting and temporarily bricking DVP smart contract",
  "Content": "# Issue M-6: FeeManager `receiveFee` and `trackVaultFee` functions allow anyone to call it with user-provided dvp/vault address and add any arbitrary feeAmount to any address, breaking fees accounting and temporarily bricking DVP smart contract \n\nSource: https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/43 \n\n## Found by \n3docSec, FonDevs, HOM1T, KingNFT, bearonbike, ge6a, hals, jennifer37, juan, panprog, santipu\\_\n## Summary\n\n`FeeManager` uses `trackVaultFee` function to account vault fees. The problem is that this function can be called by any smart contract implementing `vault()` function (there are no address or role authentication), thus malicious user can break all vault fees accounting by randomly inflating existing vault's fees, making it hard/impossible for admins to determine the real split of fees between vaults. Moreover, malicious user can provide such `feeAmount` to `trackVaultFee` function, which will increase any vault's fee to `uint256.max` value, meaning all following calls to `trackVaultFee` will revert due to fee addition overflow, temporarily bricking DVP smart contract, which calls `trackVaultFee` on all mints and burns, which will always revert until `FeeManager` smart contract is updated to a new address in `AddressProvider`.\n\nSimilarly, `receiveFee` function is used to account fee amounts received by different addresses (dvp), which can later be withdrawn by admin via `withdrawFee` function. The problem is that any smart contract implementing `baseToken()` function can call it, thus any malicious user can break all accounting by adding arbitrary amounts to their addresses without actually paying anything. Once some addresses fees are inflated, it will be difficult for admins to track fee amounts which are real, and which are from fake `dvp`s and fake tokens.\n\n## Vulnerability Detail\n\n`FeeManager.trackVaultFee` function has no role/address check:\n```solidity\n    function trackVaultFee(address vault, uint256 feeAmount) external {\n        // Check sender:\n        IDVP dvp = IDVP(msg.sender);\n        if (vault != dvp.vault()) {\n            revert WrongVault();\n        }\n\n        vaultFeeAmounts[vault] += feeAmount;\n\n        emit TransferVaultFee(vault, feeAmount);\n    }\n```\n\nAny smart contract implementing `vault()` function can call it. The vault address returned can be any address, thus user can inflate vault fees both for existing real vaults, and for any addresses user chooses. This totally breaks all vault fees accounting.\n\n`FeeManager.receiveFee` function has no role/address check either:\n```solidity\n    function receiveFee(uint256 feeAmount) external {\n        _getBaseTokenInfo(msg.sender).safeTransferFrom(msg.sender, address(this), feeAmount);\n        senders[msg.sender] += feeAmount;\n\n        emit ReceiveFee(msg.sender, feeAmount);\n    }\n...\n    function _getBaseTokenInfo(address sender) internal view returns (IERC20Metadata token) {\n        token = IERC20Metadata(IVaultParams(sender).baseToken());\n    }\n```\n\nAny smart contract crafted by malicious user can call it. It just has to return base token, which can also be token created by the user. After transfering this fake base token, the `receiveFee` function will increase user's fee balance as if it was real token transferred.\n\n## Impact\n\nMalicious users can break all fee and vault fee accounting by inflating existing vaults or user addresses fees earned without actually paying these fees, making it hard/impossible for admins to determine the actual fees earned from each vault or dvp. Moreover, malicious user can temporarily brick DVP smart contract by inflating vault's accounted fees to `uint256.max`, thus making all DVP mints and burns (which call `trackVaultFee`) revert.\n\n## Code Snippet\n\n`FeeManager.trackVaultFee`:\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/FeeManager.sol#L218-L228\n\n`FeeManager.receiveFee`:\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/FeeManager.sol#L210-L215\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding a whitelist of addresses which can call these functions.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid; medium(4)\n\n\n\n**metadato-eth**\n\nMEDIUM\nThe issue is real but does not expose any fund at risk, it only transaltes in DoS, which would be easily solved by deploying a fixed fee manager.\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dverso/smilee-v2-contracts/commit/0ae2a2b82f291e76919168b5bbfdf1d1a8c4f17a.\n\n**panprog**\n\nFix review: Fixed\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/180",
  "Code": [
    {
      "filename": "smilee-v2-contracts/src/FeeManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.15;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IDVP} from \"./interfaces/IDVP.sol\";\nimport {IFeeManager} from \"./interfaces/IFeeManager.sol\";\nimport {IVaultParams} from \"./interfaces/IVaultParams.sol\";\nimport {AmountsMath} from \"./lib/AmountsMath.sol\";\nimport {TimeLock, TimeLockedUInt} from \"./lib/TimeLock.sol\";\n\ncontract FeeManager is IFeeManager, AccessControl {\n    using AmountsMath for uint256;\n    using SafeERC20 for IERC20Metadata;\n    using TimeLock for TimeLockedUInt;\n\n    struct FeeParams {\n        // Seconds remaining until the next epoch to determine which minFee to use.\n        uint256 timeToExpiryThreshold;\n        // Minimum amount of fee paid for any buy trade made before the threshold time (denominated in token decimals of the token used to pay the fee).\n        uint256 minFeeBeforeTimeThreshold;\n        // Minimum amount of fee paid for any buy trade made after the threshold time  (denominated in token decimals of the token used to pay the fee).\n        uint256 minFeeAfterTimeThreshold;\n        // Percentage to be appied to the PNL of the sell.\n        uint256 successFeeTier;\n        // Fee percentage applied for each DVPs in WAD, it's used to calculate fees on notional.\n        uint256 feePercentage;\n        // CAP percentage, works like feePercentage in WAD, but it's used to calculate fees on premium.\n        uint256 capPercentage;\n        // Fee percentage applied for each DVPs in WAD after maturity, it's used to calculate fees on notional.\n        uint256 maturityFeePercentage;\n        // CAP percentage, works like feePercentage in WAD after maturity, but it's used to calculate fees on premium.\n        uint256 maturityCapPercentage;\n    }\n\n    struct TimeLockedFeeParams {\n        // Seconds remaining until the next epoch to determine which minFee to use.\n        TimeLockedUInt timeToExpiryThreshold;\n        // Minimum amount of fee paid for any buy trade made before the threshold time (denominated in token decimals of the token used to pay the fee).\n        TimeLockedUInt minFeeBeforeTimeThreshold;\n        // Minimum amount of fee paid for any buy trade made after the threshold time  (denominated in token decimals of the token used to pay the fee).\n        TimeLockedUInt minFeeAfterTimeThreshold;\n        // Percentage to be appied to the PNL of the sell.\n        TimeLockedUInt successFeeTier;\n        // Fee percentage applied for each DVPs in WAD, it's used to calculate fees on notional.\n        TimeLockedUInt feePercentage;\n        // CAP percentage, works like feePercentage in WAD, but it's used to calculate fees on premium.\n        TimeLockedUInt capPercentage;\n        // Fee percentage applied for each DVPs in WAD after maturity, it's used to calculate fees on notional.\n        TimeLockedUInt maturityFeePercentage;\n        // CAP percentage, works like feePercentage in WAD after maturity, but it's used to calculate fees on premium.\n        TimeLockedUInt maturityCapPercentage;\n    }\n\n    /// @notice Fee for each dvp\n    mapping(address => TimeLockedFeeParams) internal _dvpsFeeParams;\n\n    /// @notice Fee account per sender\n    mapping(address => uint256) public senders;\n\n    /// @notice Fee account per vault\n    mapping(address => uint256) public vaultFeeAmounts;\n\n    /// @notice Timelock delay for changing the parameters of a DVP\n    uint256 public immutable timeLockDelay;\n\n    bytes32 public constant ROLE_GOD = keccak256(\"ROLE_GOD\");\n    bytes32 public constant ROLE_ADMIN = keccak256(\"ROLE_ADMIN\");\n\n    event UpdateTimeToExpiryThreshold(address dvp, uint256 timeToExpiryThreshold, uint256 previous);\n    event UpdateMinFeeBeforeTimeThreshold(address dvp, uint256 minFeeBeforeTimeThreshold, uint256 previous);\n    event UpdateMinFeeAfterTimeThreshold(address dvp, uint256 minFeeAfterTimeThreshold, uint256 previous);\n    event UpdateSuccessFeeTier(address dvp, uint256 minFeeAfterTimeThreshold, uint256 previous);\n    event UpdateFeePercentage(address dvp, uint256 fee, uint256 previous);\n    event UpdateCapPercentage(address dvp, uint256 fee, uint256 previous);\n    event UpdateMaturityFeePercentage(address dvp, uint256 fee, uint256 previous);\n    event UpdateMaturityCapPercentage(address dvp, uint256 fee, uint256 previous);\n    event ReceiveFee(address sender, uint256 amount);\n    event WithdrawFee(address receiver, address sender, uint256 amount);\n    event TransferVaultFee(address vault, uint256 feeAmount);\n\n    error NoEnoughFundsFromSender();\n    error OutOfAllowedRange();\n    error WrongVault();\n\n    constructor(uint256 timeLockDelay_) AccessControl() {\n        timeLockDelay = timeLockDelay_;\n\n        _setRoleAdmin(ROLE_GOD, ROLE_GOD);\n        _setRoleAdmin(ROLE_ADMIN, ROLE_GOD);\n\n        _grantRole(ROLE_GOD, msg.sender);\n    }\n\n    function dvpsFeeParams(address dvp) external view returns (\n        uint256 timeToExpiryThreshold,\n        uint256 minFeeBeforeTimeThreshold,\n        uint256 minFeeAfterTimeThreshold,\n        uint256 successFeeTier,\n        uint256 feePercentage,\n        uint256 capPercentage,\n        uint256 maturityFeePercentage,\n        uint256 maturityCapPercentage\n    ) {\n        timeToExpiryThreshold = _dvpsFeeParams[dvp].timeToExpiryThreshold.get();\n        minFeeBeforeTimeThreshold = _dvpsFeeParams[dvp].minFeeBeforeTimeThreshold.get();\n        minFeeAfterTimeThreshold = _dvpsFeeParams[dvp].minFeeAfterTimeThreshold.get();\n        successFeeTier = _dvpsFeeParams[dvp].successFeeTier.get();\n        feePercentage = _dvpsFeeParams[dvp].feePercentage.get();\n        capPercentage = _dvpsFeeParams[dvp].capPercentage.get();\n        maturityFeePercentage = _dvpsFeeParams[dvp].maturityFeePercentage.get();\n        maturityCapPercentage = _dvpsFeeParams[dvp].maturityCapPercentage.get();\n    }\n\n    /**\n        Set fee params for the given dvp.\n        @param dvp The address of the DVP\n        @param params The Fee Params to be set\n     */\n    function setDVPFee(address dvp, FeeParams calldata params) external {\n        _checkRole(ROLE_ADMIN);\n\n        _setTimeToExpiryThreshold(dvp, params.timeToExpiryThreshold);\n        _setMinFeeBeforeTimeThreshold(dvp, params.minFeeBeforeTimeThreshold);\n        _setMinFeeAfterTimeThreshold(dvp, params.minFeeAfterTimeThreshold);\n        _setSuccessFeeTier(dvp, params.successFeeTier);\n        _setFeePercentage(dvp, params.feePercentage);\n        _setCapPercentage(dvp, params.capPercentage);\n        _setMaturityFeePercentage(dvp, params.maturityFeePercentage);\n        _setMaturityCapPercentage(dvp, params.maturityCapPercentage);\n    }\n\n    /// @inheritdoc IFeeManager\n    function tradeBuyFee(\n        address dvp,\n        uint256 expiry,\n        uint256 notional,\n        uint256 premium,\n        uint8 tokenDecimals\n    ) external view returns (uint256 fee, uint256 minFee) {\n        minFee = _minFee(dvp, expiry);\n        fee = minFee + _getFeeFromNotionalAndPremium(dvp, notional, premium, tokenDecimals, false);\n    }\n\n    /// @inheritdoc IFeeManager\n    function tradeSellFee(\n        address dvp,\n        uint256 expiry,\n        uint256 notional,\n        uint256 currPremium,\n        uint256 entryPremium,\n        uint8 tokenDecimals\n    ) external view returns (uint256 fee, uint256 minFee) {\n        fee = _getFeeFromNotionalAndPremium(dvp, notional, currPremium, tokenDecimals, block.timestamp > expiry);\n\n        if (currPremium > entryPremium) {\n            uint256 pnl = currPremium - entryPremium;\n            pnl = AmountsMath.wrapDecimals(pnl, tokenDecimals);\n            uint256 successFee = pnl.wmul(_dvpsFeeParams[dvp].successFeeTier.get());\n            successFee = AmountsMath.unwrapDecimals(successFee, tokenDecimals);\n\n            fee += successFee;\n        }\n\n        minFee = _minFee(dvp, expiry);\n        fee += minFee;\n    }\n\n    /**\n        @notice Gives minimum fee given current remaining time to expiry\n        @param dvp Address of the DVP\n        @param expiry current expiry timestamp of th egiven DVP\n     */\n    function _minFee(address dvp, uint256 expiry) internal view returns (uint256) {\n        if (block.timestamp > expiry) {\n            return 0;\n        }\n        return\n            expiry - block.timestamp > _dvpsFeeParams[dvp].timeToExpiryThreshold.get()\n                ? _dvpsFeeParams[dvp].minFeeBeforeTimeThreshold.get()\n                : _dvpsFeeParams[dvp].minFeeAfterTimeThreshold.get();\n    }\n\n    function _getFeeFromNotionalAndPremium(\n        address dvp,\n        uint256 notional,\n        uint256 premium,\n        uint8 tokenDecimals,\n        bool expired\n    ) internal view returns (uint256 fee) {\n        uint256 feeFromNotional;\n        uint256 feeFromPremiumCap;\n        notional = AmountsMath.wrapDecimals(notional, tokenDecimals);\n        premium = AmountsMath.wrapDecimals(premium, tokenDecimals);\n\n        if (expired) {\n            feeFromNotional = notional.wmul(_dvpsFeeParams[dvp].maturityFeePercentage.get());\n            feeFromPremiumCap = premium.wmul(_dvpsFeeParams[dvp].maturityCapPercentage.get());\n        } else {\n            feeFromNotional = notional.wmul(_dvpsFeeParams[dvp].feePercentage.get());\n            feeFromPremiumCap = premium.wmul(_dvpsFeeParams[dvp].capPercentage.get());\n        }\n\n        fee = (feeFromNotional < feeFromPremiumCap) ? feeFromNotional : feeFromPremiumCap;\n        fee = AmountsMath.unwrapDecimals(fee, tokenDecimals);\n    }\n\n    /// @inheritdoc IFeeManager\n    function receiveFee(uint256 feeAmount) external {\n        _getBaseTokenInfo(msg.sender).safeTransferFrom(msg.sender, address(this), feeAmount);\n        senders[msg.sender] += feeAmount;\n\n        emit ReceiveFee(msg.sender, feeAmount);\n    }\n\n    /// @inheritdoc IFeeManager\n    function trackVaultFee(address vault, uint256 feeAmount) external {\n        // Check sender:\n        IDVP dvp = IDVP(msg.sender);\n        if (vault != dvp.vault()) {\n            revert WrongVault();\n        }\n\n        vaultFeeAmounts[vault] += feeAmount;\n\n        emit TransferVaultFee(vault, feeAmount);\n    }\n\n    /// @inheritdoc IFeeManager\n    function withdrawFee(address receiver, address sender, uint256 feeAmount) external {\n        _checkRole(ROLE_ADMIN);\n        if (senders[sender] < feeAmount) {\n            revert NoEnoughFundsFromSender();\n        }\n\n        senders[sender] -= feeAmount;\n        _getBaseTokenInfo(sender).safeTransfer(receiver, feeAmount);\n\n        emit WithdrawFee(receiver, sender, feeAmount);\n    }\n\n    /// @notice Update time to expiry threshold value\n    function _setTimeToExpiryThreshold(address dvp, uint256 timeToExpiryThreshold) internal {\n        if (timeToExpiryThreshold == 0) {\n            // TODO: review\n            revert OutOfAllowedRange();\n        }\n\n        uint256 previousTimeToExpiryThreshold = _dvpsFeeParams[dvp].timeToExpiryThreshold.proposed;\n        _dvpsFeeParams[dvp].timeToExpiryThreshold.set(timeToExpiryThreshold, timeLockDelay);\n\n        emit UpdateTimeToExpiryThreshold(dvp, timeToExpiryThreshold, previousTimeToExpiryThreshold);\n    }\n\n    /// @notice Update fee percentage value\n    function _setMinFeeBeforeTimeThreshold(address dvp, uint256 minFee) internal {\n        uint8 tokenDecimals = _getBaseTokenInfo(dvp).decimals();\n        if (minFee > 100 * 10 ** tokenDecimals) {\n            revert OutOfAllowedRange();\n        }\n\n        uint256 previousMinFee = _dvpsFeeParams[dvp].minFeeBeforeTimeThreshold.proposed;\n        _dvpsFeeParams[dvp].minFeeBeforeTimeThreshold.set(minFee, timeLockDelay);\n\n        emit UpdateMinFeeBeforeTimeThreshold(dvp, minFee, previousMinFee);\n    }\n\n    /// @notice Update fee percentage value\n    function _setMinFeeAfterTimeThreshold(address dvp, uint256 minFee) internal {\n        uint8 tokenDecimals = _getBaseTokenInfo(dvp).decimals();\n        if (minFee > 100 * 10 ** tokenDecimals) {\n            revert OutOfAllowedRange();\n        }\n\n        uint256 previousMinFee = _dvpsFeeParams[dvp].minFeeAfterTimeThreshold.proposed;\n        _dvpsFeeParams[dvp].minFeeAfterTimeThreshold.set(minFee, timeLockDelay);\n\n        emit UpdateMinFeeAfterTimeThreshold(dvp, minFee, previousMinFee);\n    }\n\n    /// @notice Update fee percentage value\n    function _setSuccessFeeTier(address dvp, uint256 successFeeTier) internal {\n        if (successFeeTier > 1e18) {\n            revert OutOfAllowedRange();\n        }\n\n        uint256 previousSuccessFeeTier = _dvpsFeeParams[dvp].successFeeTier.proposed;\n        _dvpsFeeParams[dvp].successFeeTier.set(successFeeTier, timeLockDelay);\n\n        emit UpdateSuccessFeeTier(dvp, successFeeTier, previousSuccessFeeTier);\n    }\n\n    /// @notice Update fee percentage value\n    function _setFeePercentage(address dvp, uint256 feePercentage_) internal {\n        if (feePercentage_ > 0.5e18) {\n            revert OutOfAllowedRange();\n        }\n\n        uint256 previousFeePercentage = _dvpsFeeParams[dvp].feePercentage.proposed;\n        _dvpsFeeParams[dvp].feePercentage.set(feePercentage_, timeLockDelay);\n\n        emit UpdateFeePercentage(dvp, feePercentage_, previousFeePercentage);\n    }\n\n    /// @notice Update cap percentage value\n    function _setCapPercentage(address dvp, uint256 capPercentage_) internal {\n        if (capPercentage_ > 0.5e18) {\n            revert OutOfAllowedRange();\n        }\n\n        uint256 previousCapPercentage = _dvpsFeeParams[dvp].capPercentage.proposed;\n        _dvpsFeeParams[dvp].capPercentage.set(capPercentage_, timeLockDelay);\n\n        emit UpdateCapPercentage(dvp, capPercentage_, previousCapPercentage);\n    }\n\n    /// @notice Update fee percentage value at maturity\n    function _setMaturityFeePercentage(address dvp, uint256 maturityFeePercentage_) internal {\n        if (maturityFeePercentage_ > 0.5e18) {\n            revert OutOfAllowedRange();\n        }\n\n        uint256 previousMaturityFeePercentage = _dvpsFeeParams[dvp].maturityFeePercentage.proposed;\n        _dvpsFeeParams[dvp].maturityFeePercentage.set(maturityFeePercentage_, timeLockDelay);\n\n        emit UpdateMaturityFeePercentage(dvp, maturityFeePercentage_, previousMaturityFeePercentage);\n    }\n\n    /// @notice Update cap percentage value at maturity\n    function _setMaturityCapPercentage(address dvp, uint256 maturityCapPercentage_) internal {\n        if (maturityCapPercentage_ > 0.5e18) {\n            revert OutOfAllowedRange();\n        }\n\n        uint256 previousMaturityCapPercentage = _dvpsFeeParams[dvp].maturityCapPercentage.proposed;\n        _dvpsFeeParams[dvp].maturityCapPercentage.set(maturityCapPercentage_, timeLockDelay);\n\n        emit UpdateMaturityCapPercentage(dvp, maturityCapPercentage_, previousMaturityCapPercentage);\n    }\n\n    /// @dev Get IERC20Metadata of baseToken of given sender\n    function _getBaseTokenInfo(address sender) internal view returns (IERC20Metadata token) {\n        token = IERC20Metadata(IVaultParams(sender).baseToken());\n    }\n}"
    },
    {
      "filename": "smilee-v2-contracts/src/FeeManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.15;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IDVP} from \"./interfaces/IDVP.sol\";\nimport {IFeeManager} from \"./interfaces/IFeeManager.sol\";\nimport {IVaultParams} from \"./interfaces/IVaultParams.sol\";\nimport {AmountsMath} from \"./lib/AmountsMath.sol\";\nimport {TimeLock, TimeLockedUInt} from \"./lib/TimeLock.sol\";\n\ncontract FeeManager is IFeeManager, AccessControl {\n    using AmountsMath for uint256;\n    using SafeERC20 for IERC20Metadata;\n    using TimeLock for TimeLockedUInt;\n\n    struct FeeParams {\n        // Seconds remaining until the next epoch to determine which minFee to use.\n        uint256 timeToExpiryThreshold;\n        // Minimum amount of fee paid for any buy trade made before the threshold time (denominated in token decimals of the token used to pay the fee).\n        uint256 minFeeBeforeTimeThreshold;\n        // Minimum amount of fee paid for any buy trade made after the threshold time  (denominated in token decimals of the token used to pay the fee).\n        uint256 minFeeAfterTimeThreshold;\n        // Percentage to be appied to the PNL of the sell.\n        uint256 successFeeTier;\n        // Fee percentage applied for each DVPs in WAD, it's used to calculate fees on notional.\n        uint256 feePercentage;\n        // CAP percentage, works like feePercentage in WAD, but it's used to calculate fees on premium.\n        uint256 capPercentage;\n        // Fee percentage applied for each DVPs in WAD after maturity, it's used to calculate fees on notional.\n        uint256 maturityFeePercentage;\n        // CAP percentage, works like feePercentage in WAD after maturity, but it's used to calculate fees on premium.\n        uint256 maturityCapPercentage;\n    }\n\n    struct TimeLockedFeeParams {\n        // Seconds remaining until the next epoch to determine which minFee to use.\n        TimeLockedUInt timeToExpiryThreshold;\n        // Minimum amount of fee paid for any buy trade made before the threshold time (denominated in token decimals of the token used to pay the fee).\n        TimeLockedUInt minFeeBeforeTimeThreshold;\n        // Minimum amount of fee paid for any buy trade made after the threshold time  (denominated in token decimals of the token used to pay the fee).\n        TimeLockedUInt minFeeAfterTimeThreshold;\n        // Percentage to be appied to the PNL of the sell.\n        TimeLockedUInt successFeeTier;\n        // Fee percentage applied for each DVPs in WAD, it's used to calculate fees on notional.\n        TimeLockedUInt feePercentage;\n        // CAP percentage, works like feePercentage in WAD, but it's used to calculate fees on premium.\n        TimeLockedUInt capPercentage;\n        // Fee percentage applied for each DVPs in WAD after maturity, it's used to calculate fees on notional.\n        TimeLockedUInt maturityFeePercentage;\n        // CAP percentage, works like feePercentage in WAD after maturity, but it's used to calculate fees on premium.\n        TimeLockedUInt maturityCapPercentage;\n    }\n\n    /// @notice Fee for each dvp\n    mapping(address => TimeLockedFeeParams) internal _dvpsFeeParams;\n\n    /// @notice Fee account per sender\n    mapping(address => uint256) public senders;\n\n    /// @notice Fee account per vault\n    mapping(address => uint256) public vaultFeeAmounts;\n\n    /// @notice Timelock delay for changing the parameters of a DVP\n    uint256 public immutable timeLockDelay;\n\n    bytes32 public constant ROLE_GOD = keccak256(\"ROLE_GOD\");\n    bytes32 public constant ROLE_ADMIN = keccak256(\"ROLE_ADMIN\");\n\n    event UpdateTimeToExpiryThreshold(address dvp, uint256 timeToExpiryThreshold, uint256 previous);\n    event UpdateMinFeeBeforeTimeThreshold(address dvp, uint256 minFeeBeforeTimeThreshold, uint256 previous);\n    event UpdateMinFeeAfterTimeThreshold(address dvp, uint256 minFeeAfterTimeThreshold, uint256 previous);\n    event UpdateSuccessFeeTier(address dvp, uint256 minFeeAfterTimeThreshold, uint256 previous);\n    event UpdateFeePercentage(address dvp, uint256 fee, uint256 previous);\n    event UpdateCapPercentage(address dvp, uint256 fee, uint256 previous);\n    event UpdateMaturityFeePercentage(address dvp, uint256 fee, uint256 previous);\n    event UpdateMaturityCapPercentage(address dvp, uint256 fee, uint256 previous);\n    event ReceiveFee(address sender, uint256 amount);\n    event WithdrawFee(address receiver, address sender, uint256 amount);\n    event TransferVaultFee(address vault, uint256 feeAmount);\n\n    error NoEnoughFundsFromSender();\n    error OutOfAllowedRange();\n    error WrongVault();\n\n    constructor(uint256 timeLockDelay_) AccessControl() {\n        timeLockDelay = timeLockDelay_;\n\n        _setRoleAdmin(ROLE_GOD, ROLE_GOD);\n        _setRoleAdmin(ROLE_ADMIN, ROLE_GOD);\n\n        _grantRole(ROLE_GOD, msg.sender);\n    }\n\n    function dvpsFeeParams(address dvp) external view returns (\n        uint256 timeToExpiryThreshold,\n        uint256 minFeeBeforeTimeThreshold,\n        uint256 minFeeAfterTimeThreshold,\n        uint256 successFeeTier,\n        uint256 feePercentage,\n        uint256 capPercentage,\n        uint256 maturityFeePercentage,\n        uint256 maturityCapPercentage\n    ) {\n        timeToExpiryThreshold = _dvpsFeeParams[dvp].timeToExpiryThreshold.get();\n        minFeeBeforeTimeThreshold = _dvpsFeeParams[dvp].minFeeBeforeTimeThreshold.get();\n        minFeeAfterTimeThreshold = _dvpsFeeParams[dvp].minFeeAfterTimeThreshold.get();\n        successFeeTier = _dvpsFeeParams[dvp].successFeeTier.get();\n        feePercentage = _dvpsFeeParams[dvp].feePercentage.get();\n        capPercentage = _dvpsFeeParams[dvp].capPercentage.get();\n        maturityFeePercentage = _dvpsFeeParams[dvp].maturityFeePercentage.get();\n        maturityCapPercentage = _dvpsFeeParams[dvp].maturityCapPercentage.get();\n    }\n\n    /**\n        Set fee params for the given dvp.\n        @param dvp The address of the DVP\n        @param params The Fee Params to be set\n     */\n    function setDVPFee(address dvp, FeeParams calldata params) external {\n        _checkRole(ROLE_ADMIN);\n\n        _setTimeToExpiryThreshold(dvp, params.timeToExpiryThreshold);\n        _setMinFeeBeforeTimeThreshold(dvp, params.minFeeBeforeTimeThreshold);\n        _setMinFeeAfterTimeThreshold(dvp, params.minFeeAfterTimeThreshold);\n        _setSuccessFeeTier(dvp, params.successFeeTier);\n        _setFeePercentage(dvp, params.feePercentage);\n        _setCapPercentage(dvp, params.capPercentage);\n        _setMaturityFeePercentage(dvp, params.maturityFeePercentage);\n        _setMaturityCapPercentage(dvp, params.maturityCapPercentage);\n    }\n\n    /// @inheritdoc IFeeManager\n    function tradeBuyFee(\n        address dvp,\n        uint256 expiry,\n        uint256 notional,\n        uint256 premium,\n        uint8 tokenDecimals\n    ) external view returns (uint256 fee, uint256 minFee) {\n        minFee = _minFee(dvp, expiry);\n        fee = minFee + _getFeeFromNotionalAndPremium(dvp, notional, premium, tokenDecimals, false);\n    }\n\n    /// @inheritdoc IFeeManager\n    function tradeSellFee(\n        address dvp,\n        uint256 expiry,\n        uint256 notional,\n        uint256 currPremium,\n        uint256 entryPremium,\n        uint8 tokenDecimals\n    ) external view returns (uint256 fee, uint256 minFee) {\n        fee = _getFeeFromNotionalAndPremium(dvp, notional, currPremium, tokenDecimals, block.timestamp > expiry);\n\n        if (currPremium > entryPremium) {\n            uint256 pnl = currPremium - entryPremium;\n            pnl = AmountsMath.wrapDecimals(pnl, tokenDecimals);\n            uint256 successFee = pnl.wmul(_dvpsFeeParams[dvp].successFeeTier.get());\n            successFee = AmountsMath.unwrapDecimals(successFee, tokenDecimals);\n\n            fee += successFee;\n        }\n\n        minFee = _minFee(dvp, expiry);\n        fee += minFee;\n    }\n\n    /**\n        @notice Gives minimum fee given current remaining time to expiry\n        @param dvp Address of the DVP\n        @param expiry current expiry timestamp of th egiven DVP\n     */\n    function _minFee(address dvp, uint256 expiry) internal view returns (uint256) {\n        if (block.timestamp > expiry) {\n            return 0;\n        }\n        return\n            expiry - block.timestamp > _dvpsFeeParams[dvp].timeToExpiryThreshold.get()\n                ? _dvpsFeeParams[dvp].minFeeBeforeTimeThreshold.get()\n                : _dvpsFeeParams[dvp].minFeeAfterTimeThreshold.get();\n    }\n\n    function _getFeeFromNotionalAndPremium(\n        address dvp,\n        uint256 notional,\n        uint256 premium,\n        uint8 tokenDecimals,\n        bool expired\n    ) internal view returns (uint256 fee) {\n        uint256 feeFromNotional;\n        uint256 feeFromPremiumCap;\n        notional = AmountsMath.wrapDecimals(notional, tokenDecimals);\n        premium = AmountsMath.wrapDecimals(premium, tokenDecimals);\n\n        if (expired) {\n            feeFromNotional = notional.wmul(_dvpsFeeParams[dvp].maturityFeePercentage.get());\n            feeFromPremiumCap = premium.wmul(_dvpsFeeParams[dvp].maturityCapPercentage.get());\n        } else {\n            feeFromNotional = notional.wmul(_dvpsFeeParams[dvp].feePercentage.get());\n            feeFromPremiumCap = premium.wmul(_dvpsFeeParams[dvp].capPercentage.get());\n        }\n\n        fee = (feeFromNotional < feeFromPremiumCap) ? feeFromNotional : feeFromPremiumCap;\n        fee = AmountsMath.unwrapDecimals(fee, tokenDecimals);\n    }\n\n    /// @inheritdoc IFeeManager\n    function receiveFee(uint256 feeAmount) external {\n        _getBaseTokenInfo(msg.sender).safeTransferFrom(msg.sender, address(this), feeAmount);\n        senders[msg.sender] += feeAmount;\n\n        emit ReceiveFee(msg.sender, feeAmount);\n    }\n\n    /// @inheritdoc IFeeManager\n    function trackVaultFee(address vault, uint256 feeAmount) external {\n        // Check sender:\n        IDVP dvp = IDVP(msg.sender);\n        if (vault != dvp.vault()) {\n            revert WrongVault();\n        }\n\n        vaultFeeAmounts[vault] += feeAmount;\n\n        emit TransferVaultFee(vault, feeAmount);\n    }\n\n    /// @inheritdoc IFeeManager\n    function withdrawFee(address receiver, address sender, uint256 feeAmount) external {\n        _checkRole(ROLE_ADMIN);\n        if (senders[sender] < feeAmount) {\n            revert NoEnoughFundsFromSender();\n        }\n\n        senders[sender] -= feeAmount;\n        _getBaseTokenInfo(sender).safeTransfer(receiver, feeAmount);\n\n        emit WithdrawFee(receiver, sender, feeAmount);\n    }\n\n    /// @notice Update time to expiry threshold value\n    function _setTimeToExpiryThreshold(address dvp, uint256 timeToExpiryThreshold) internal {\n        if (timeToExpiryThreshold == 0) {\n            // TODO: review\n            revert OutOfAllowedRange();\n        }\n\n        uint256 previousTimeToExpiryThreshold = _dvpsFeeParams[dvp].timeToExpiryThreshold.proposed;\n        _dvpsFeeParams[dvp].timeToExpiryThreshold.set(timeToExpiryThreshold, timeLockDelay);\n\n        emit UpdateTimeToExpiryThreshold(dvp, timeToExpiryThreshold, previousTimeToExpiryThreshold);\n    }\n\n    /// @notice Update fee percentage value\n    function _setMinFeeBeforeTimeThreshold(address dvp, uint256 minFee) internal {\n        uint8 tokenDecimals = _getBaseTokenInfo(dvp).decimals();\n        if (minFee > 100 * 10 ** tokenDecimals) {\n            revert OutOfAllowedRange();\n        }\n\n        uint256 previousMinFee = _dvpsFeeParams[dvp].minFeeBeforeTimeThreshold.proposed;\n        _dvpsFeeParams[dvp].minFeeBeforeTimeThreshold.set(minFee, timeLockDelay);\n\n        emit UpdateMinFeeBeforeTimeThreshold(dvp, minFee, previousMinFee);\n    }\n\n    /// @notice Update fee percentage value\n    function _setMinFeeAfterTimeThreshold(address dvp, uint256 minFee) internal {\n        uint8 tokenDecimals = _getBaseTokenInfo(dvp).decimals();\n        if (minFee > 100 * 10 ** tokenDecimals) {\n            revert OutOfAllowedRange();\n        }\n\n        uint256 previousMinFee = _dvpsFeeParams[dvp].minFeeAfterTimeThreshold.proposed;\n        _dvpsFeeParams[dvp].minFeeAfterTimeThreshold.set(minFee, timeLockDelay);\n\n        emit UpdateMinFeeAfterTimeThreshold(dvp, minFee, previousMinFee);\n    }\n\n    /// @notice Update fee percentage value\n    function _setSuccessFeeTier(address dvp, uint256 successFeeTier) internal {\n        if (successFeeTier > 1e18) {\n            revert OutOfAllowedRange();\n        }\n\n        uint256 previousSuccessFeeTier = _dvpsFeeParams[dvp].successFeeTier.proposed;\n        _dvpsFeeParams[dvp].successFeeTier.set(successFeeTier, timeLockDelay);\n\n        emit UpdateSuccessFeeTier(dvp, successFeeTier, previousSuccessFeeTier);\n    }\n\n    /// @notice Update fee percentage value\n    function _setFeePercentage(address dvp, uint256 feePercentage_) internal {\n        if (feePercentage_ > 0.5e18) {\n            revert OutOfAllowedRange();\n        }\n\n        uint256 previousFeePercentage = _dvpsFeeParams[dvp].feePercentage.proposed;\n        _dvpsFeeParams[dvp].feePercentage.set(feePercentage_, timeLockDelay);\n\n        emit UpdateFeePercentage(dvp, feePercentage_, previousFeePercentage);\n    }\n\n    /// @notice Update cap percentage value\n    function _setCapPercentage(address dvp, uint256 capPercentage_) internal {\n        if (capPercentage_ > 0.5e18) {\n            revert OutOfAllowedRange();\n        }\n\n        uint256 previousCapPercentage = _dvpsFeeParams[dvp].capPercentage.proposed;\n        _dvpsFeeParams[dvp].capPercentage.set(capPercentage_, timeLockDelay);\n\n        emit UpdateCapPercentage(dvp, capPercentage_, previousCapPercentage);\n    }\n\n    /// @notice Update fee percentage value at maturity\n    function _setMaturityFeePercentage(address dvp, uint256 maturityFeePercentage_) internal {\n        if (maturityFeePercentage_ > 0.5e18) {\n            revert OutOfAllowedRange();\n        }\n\n        uint256 previousMaturityFeePercentage = _dvpsFeeParams[dvp].maturityFeePercentage.proposed;\n        _dvpsFeeParams[dvp].maturityFeePercentage.set(maturityFeePercentage_, timeLockDelay);\n\n        emit UpdateMaturityFeePercentage(dvp, maturityFeePercentage_, previousMaturityFeePercentage);\n    }\n\n    /// @notice Update cap percentage value at maturity\n    function _setMaturityCapPercentage(address dvp, uint256 maturityCapPercentage_) internal {\n        if (maturityCapPercentage_ > 0.5e18) {\n            revert OutOfAllowedRange();\n        }\n\n        uint256 previousMaturityCapPercentage = _dvpsFeeParams[dvp].maturityCapPercentage.proposed;\n        _dvpsFeeParams[dvp].maturityCapPercentage.set(maturityCapPercentage_, timeLockDelay);\n\n        emit UpdateMaturityCapPercentage(dvp, maturityCapPercentage_, previousMaturityCapPercentage);\n    }\n\n    /// @dev Get IERC20Metadata of baseToken of given sender\n    function _getBaseTokenInfo(address sender) internal view returns (IERC20Metadata token) {\n        token = IERC20Metadata(IVaultParams(sender).baseToken());\n    }\n}"
    }
  ]
}