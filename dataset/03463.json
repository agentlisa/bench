{
  "Title": "[H02] Bridging parameter bounds don’t match",
  "Content": "The [`deposit` function](https://github.com/UMAprotocol/protocol/blob/f24ad501c8e813cf685f72217e7f13c8f3c366df/packages/core/contracts-ovm/insured-bridge/implementation/BridgeDepositBox.sol#L169) of the `BridgeDepositBox` contract, deployed on layer 2 chains, is used to bridge funds between the L2 and L1. In particular, relayers are incentivized to [relay](https://github.com/UMAprotocol/protocol/blob/f24ad501c8e813cf685f72217e7f13c8f3c366df/packages/core/contracts/insured-bridge/BridgePool.sol#L238) the transaction details on the associated L1 `BridgePool`. However, the deposit box uses [inclusive bounds](https://github.com/UMAprotocol/protocol/blob/f24ad501c8e813cf685f72217e7f13c8f3c366df/packages/core/contracts-ovm/insured-bridge/implementation/BridgeDepositBox.sol#L181) to restrict the relay fees, while the bridge pool uses [exclusive bounds](https://github.com/UMAprotocol/protocol/blob/f24ad501c8e813cf685f72217e7f13c8f3c366df/packages/core/contracts/insured-bridge/BridgePool.sol#L244-L248). This means that some deposits (with 25% relay fees) cannot be relayed, and the funds will be inaccessible on both layers.\n\n\nConsider synchronizing the validations on both layers to ensure all valid deposits can be relayed.\n\n\n**Update:** *Fixed in commit [`2345966b3a2ace0159379b3a13256cc1a4c5d52f`](https://github.com/UMAprotocol/protocol/pull/3494/commits/2345966b3a2ace0159379b3a13256cc1a4c5d52f) of [PR3494](https://github.com/UMAprotocol/protocol/pull/3494). This was originally classified as Critical severity but was downgraded when the UMA team pointed out the funds would not be strictly trapped and could be released if the DVM voters agreed to accept a modified relay description for affected deposits.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts-ovm/insured-bridge/implementation/BridgeDepositBox.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.6;\n\nimport \"../external/Legacy_Testable.sol\"; //TODO: replace this with the normal UMA Testable once we can use 0.8 solidity.\nimport \"../external/Legacy_Lockable.sol\"; //TODO: replace this with the normal UMA Lockable once we can use 0.8 solidity.\n\n// Define some interfaces and helper libraries. This is temporary until we can bump the solidity version in these\n// contracts to 0.8.x and import the rest of these libs from other UMA contracts in the repo.\nlibrary TokenHelper {\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TokenHelper::transferFrom: transferFrom failed\"\n        );\n    }\n}\n\ninterface TokenLike {\n    function balanceOf(address guy) external returns (uint256 wad);\n}\n\n/**\n * @title OVM Bridge Deposit Box.\n * @notice Accepts deposits on Optimism L2 to relay to Ethereum L1 as part of the UMA insured bridge system.\n */\n\nabstract contract BridgeDepositBox is Legacy_Testable, Legacy_Lockable {\n    /*************************************\n     *  OVM DEPOSIT BOX DATA STRUCTURES  *\n     *************************************/\n\n    // ChainID of the L2 this deposit box is deployed on.\n    uint256 public chainId;\n\n    // Address of WETH on L1. If the deposited token maps to this L1 token then wrap ETH to WETH on the users behalf.\n    address public l1Weth;\n\n    // Track the total number of deposits. Used as a unique identifier for bridged transfers.\n    uint256 public numberOfDeposits;\n\n    struct L2TokenRelationships {\n        address l1Token;\n        address l1BridgePool;\n        uint64 lastBridgeTime;\n        bool depositsEnabled;\n    }\n\n    // Mapping of whitelisted L2Token to L2TokenRelationships. Contains L1 TokenAddress and the last time this token\n    // type was bridged. Used to rate limit bridging actions to rate limit withdraws to L1.\n    mapping(address => L2TokenRelationships) public whitelistedTokens;\n\n    // Minimum time that must elapse between bridging actions for a given token. Used to rate limit bridging back to L1.\n    uint64 public minimumBridgingDelay;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event SetMinimumBridgingDelay(uint64 newMinimumBridgingDelay);\n    event WhitelistToken(address l1Token, address l2Token, uint64 lastBridgeTime, address bridgePool);\n    event DepositsEnabled(address l2Token, bool depositsEnabled);\n    event FundsDeposited(\n        uint256 chainId,\n        uint256 depositId,\n        address l1Recipient,\n        address l2Sender,\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        uint64 slowRelayFeePct,\n        uint64 instantRelayFeePct,\n        uint64 quoteTimestamp\n    );\n    event TokensBridged(address l2Token, uint256 numberOfTokensBridged, uint256 l1Gas, address caller);\n\n    /****************************************\n     *               MODIFIERS              *\n     ****************************************/\n\n    modifier onlyIfDepositsEnabled(address l2Token) {\n        require(whitelistedTokens[l2Token].depositsEnabled, \"Contract is disabled\");\n        _;\n    }\n\n    /**\n     * @notice Construct the Bridge Deposit Box\n     * @param _minimumBridgingDelay Minimum second that must elapse between L2 -> L1 token transfer to prevent dos.\n     * @param _chainId Chain identifier for the Bridge deposit box.\n     * @param timerAddress Timer used to synchronize contract time in testing. Set to 0x000... in production.\n     */\n    constructor(\n        uint64 _minimumBridgingDelay,\n        uint256 _chainId,\n        address _l1Weth,\n        address timerAddress\n    ) Legacy_Testable(timerAddress) {\n        _setMinimumBridgingDelay(_minimumBridgingDelay);\n        chainId = _chainId;\n        l1Weth = _l1Weth;\n    }\n\n    /**************************************\n     *          ADMIN FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Changes the minimum time in seconds that must elapse between withdraws from L2 -> L1.\n     * @param newMinimumBridgingDelay the new minimum delay.\n     */\n    function _setMinimumBridgingDelay(uint64 newMinimumBridgingDelay) internal {\n        minimumBridgingDelay = newMinimumBridgingDelay;\n        emit SetMinimumBridgingDelay(minimumBridgingDelay);\n    }\n\n    /**\n     * @notice Enables L1 owner to whitelist a L1 Token <-> L2 Token pair for bridging.\n     * @param l1Token Address of the canonical L1 token. This is the token users will receive on Ethereum.\n     * @param l2Token Address of the L2 token representation. This is the token users would deposit on optimism.\n     * @param l1BridgePool Address of the L1 withdrawal pool linked to this L2+L1 token.\n     */\n    function _whitelistToken(\n        address l1Token,\n        address l2Token,\n        address l1BridgePool\n    ) internal {\n        whitelistedTokens[l2Token] = L2TokenRelationships({\n            l1Token: l1Token,\n            l1BridgePool: l1BridgePool,\n            lastBridgeTime: uint64(getCurrentTime()),\n            depositsEnabled: true\n        });\n\n        emit WhitelistToken(l1Token, l2Token, uint64(getCurrentTime()), l1BridgePool);\n    }\n\n    /**\n     * @notice L1 owner can enable/disable deposits for a whitelisted tokens.\n     * @param l2Token address of L2 token to enable/disable deposits for.\n     * @param depositsEnabled bool to set if the deposit box should accept/reject deposits.\n     */\n    function _setEnableDeposits(address l2Token, bool depositsEnabled) internal {\n        whitelistedTokens[l2Token].depositsEnabled = depositsEnabled;\n        emit DepositsEnabled(l2Token, depositsEnabled);\n    }\n\n    /**************************************\n     *         DEPOSITOR FUNCTIONS        *\n     **************************************/\n\n    /**\n     * @notice Called by L2 user to bridge funds between L2 and L1.\n     * @dev Emits the `FundsDeposited` event which relayers listen for as part of the bridging action.\n     * @dev The caller must first approve this contract to spend `amount` of `l2Token`.\n     * @param l1Recipient L1 address that should receive the tokens.\n     * @param l2Token L2 token to deposit.\n     * @param amount How many L2 tokens should be deposited.\n     * @param slowRelayFeePct Max fraction of `amount` that the depositor is willing to pay as a slow relay fee.\n     * @param instantRelayFeePct Fraction of `amount` that the depositor is willing to pay as a instant relay fee.\n     * @param quoteTimestamp Timestamp, at which the depositor will be quoted for L1 liquidity. This enables the\n     *    depositor to know the L1 fees before submitting their deposit. Must be within 10 mins of the current time.\n     */\n    function deposit(\n        address l1Recipient,\n        address l2Token,\n        uint256 amount,\n        uint64 slowRelayFeePct,\n        uint64 instantRelayFeePct,\n        uint64 quoteTimestamp\n    ) public payable onlyIfDepositsEnabled(l2Token) nonReentrant() {\n        require(isWhitelistToken(l2Token), \"deposit token not whitelisted\");\n        // We limit the sum of slow and instant relay fees to 50% to prevent the user spending all their funds on fees.\n        // The realizedLPFeePct on L1 is limited to 50% so the total spent on fees does not ever exceed 100%.\n        require(slowRelayFeePct <= 0.25e18, \"slowRelayFeePct must be <= 25%\");\n        require(instantRelayFeePct <= 0.25e18, \"instantRelayFeePct must be <= 25%\");\n\n        // Note that the OVM's notion of `block.timestamp` is different to the main ethereum L1 EVM. The OVM timestamp\n        // corresponds to the L1 timestamp of the last confirmed L1 ⇒ L2 transaction. The quoteTime must be within 10\n        // mins of the current time to allow for this variance.\n        require(\n            getCurrentTime() >= quoteTimestamp - 10 minutes && getCurrentTime() <= quoteTimestamp + 10 minutes,\n            \"deposit mined after deadline\"\n        );\n        // If the address of the L1 token is the l1Weth and there is a msg.value with the transaction then the user\n        // is sending ETH. In this case, the ETH should be deposited to WETH, which is then bridged to L1.\n        if (whitelistedTokens[l2Token].l1Token == l1Weth && msg.value > 0) {\n            require(msg.value == amount, \"msg.value must match amount\");\n            l2Token.call{ value: msg.value }(abi.encodeWithSignature(\"deposit()\"));\n        }\n        // Else, it is a normal ERC20. In this case pull the token from the users wallet as per normal.\n        // Note: this includes the case where the L2 user has WETH (already wrapped ETH) and wants to bridge them. In\n        // this case the msg.value will be set to 0, indicating a \"normal\" ERC20 bridging action.\n        else TokenHelper.safeTransferFrom(l2Token, msg.sender, address(this), amount);\n\n        emit FundsDeposited(\n            chainId,\n            numberOfDeposits, // depositId: the current number of deposits acts as a deposit ID (nonce).\n            l1Recipient,\n            msg.sender,\n            whitelistedTokens[l2Token].l1Token,\n            l2Token,\n            amount,\n            slowRelayFeePct,\n            instantRelayFeePct,\n            quoteTimestamp\n        );\n\n        numberOfDeposits += 1;\n    }\n\n    /**************************************\n     *           VIEW FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Checks if a given L2 token is whitelisted.\n     * @param l2Token L2 token to check against the whitelist.\n     */\n    function isWhitelistToken(address l2Token) public view returns (bool) {\n        return whitelistedTokens[l2Token].l1Token != address(0);\n    }\n\n    /**\n     * @notice Checks if enough time has elapsed from the previous bridge transfer to execute another bridge transfer.\n     * @param l2Token L2 token to check against last bridge time delay.\n     */\n    function hasEnoughTimeElapsedToBridge(address l2Token) public view returns (bool) {\n        return getCurrentTime() > whitelistedTokens[l2Token].lastBridgeTime + minimumBridgingDelay;\n    }\n}"
    }
  ]
}