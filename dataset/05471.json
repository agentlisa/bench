{
  "Title": "[M-02] Users will lose rewards when buying new tokens if they already own some tokens",
  "Content": "\nWhen users purchase new tokens, the old tokens they already own do not receive the fees from this purchase, resulting in a loss of funds for the users.\n\n### Proof of Concept\n\nAccording to the explanation by the sponsor (Roman), when users buy new tokens, the recently purchased token is not eligible for a fee. However, the \"old shares\" that users already own should be eligible.\n\nRoman:\n\n> Hey, just a design decision, the idea behind it is that the user does not own the new shares yet when he buys, so he should not get any fees for it. Whereas he still owns it when he sells (it is basically the last sale).\n\nKrace:\n\n> So the new shares should not get fee. If the user owns some \"old shares\", is it eligible for a fee when the user buying?\n\nRoman:\n\n> Yes, in that case, these shares are in the \"owner pool\" at the time of purchase and should be eligible\n\nHowever, the [`buy`](https://github.com/code-423n4/2023-11-canto/blob/b78bfdbf329ba9055ba24bd710c7e1c60251039a/1155tech-contracts/src/Market.sol#L150) function will completely disregard the rewards associated with the buyer's \"old shares\" for these fees.\n\nLet's analyze the `buy` function:\n\n- **Step 1:** It retrieves the rewards for the buyer before the purchase. These rewards are not linked to the purchase because they use the old token amounts, and the fees from this purchase are not factored in.\n- **Step 2:** It splits the fees for this purchase. `_splitFees` increases the value of `shareHolderRewardsPerTokenScaled` based on the fees from this purchase.\n- **Step 3:** It updates the `rewardsLastClaimedValue` of the buyer to the latest `shareHolderRewardsPerTokenScaled`, which was increased in `_splitFees` just now.\n\nThe question arises: the fees from this purchase are not rewarded to the buyer's old tokens between Step 2 and Step 3, yet the buyer's `rewardsLastClaimedValue` is updated to the newest value. This results in the permanent loss of these rewards for the buyer.\n\n```solidity\n    function buy(uint256 _id, uint256 _amount) external {\n        require(shareData[_id].creator != msg.sender, \"Creator cannot buy\");\n        (uint256 price, uint256 fee) = getBuyPrice(_id, _amount); // Reverts for non-existing ID\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), price + fee);\n        // The reward calculation has to use the old rewards value (pre fee-split) to not include the fees of this buy\n        // The rewardsLastClaimedValue then needs to be updated with the new value such that the user cannot claim fees of this buy\n//@audit it will get the rewards first        \n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        // Split the fee among holder, creator and platform\n//@audit then split the fees of this buying        \n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n//@audit and update sender's rewardsLastClaimedValue to the newest one, which is updated by `splitFees`\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n\n        shareData[_id].tokenCount += _amount;\n        shareData[_id].tokensInCirculation += _amount;\n        tokensByAddress[_id][msg.sender] += _amount;\n\n        if (rewardsSinceLastClaim > 0) {\n            SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim);\n        }\n        emit SharesBought(_id, msg.sender, _amount, price, fee);\n    }\n```\n\n```solidity\n    function _splitFees(\n        uint256 _id,\n        uint256 _fee,\n        uint256 _tokenCount\n    ) internal {\n        uint256 shareHolderFee = (_fee * HOLDER_CUT_BPS) / 10_000;\n        uint256 shareCreatorFee = (_fee * CREATOR_CUT_BPS) / 10_000;\n        uint256 platformFee = _fee - shareHolderFee - shareCreatorFee;\n        shareData[_id].shareCreatorPool += shareCreatorFee;\n        if (_tokenCount > 0) {\n//@audit shareHolderRewardsPerTokenScaled will be increased if tokenCount>0\n            shareData[_id].shareHolderRewardsPerTokenScaled += (shareHolderFee * 1e18) / _tokenCount;\n        } else {\n            // If there are no tokens in circulation, the fee goes to the platform\n            platformFee += shareHolderFee;\n        }\n        platformPool += platformFee;\n    }\n```\n\n### Test\n\nThe following POC shows the case mentioned. Add it to `1155tech-contracts/src/Market.t.sol` and run it with `forge test --match-test testBuyNoReward -vv`.\n\n        function testBuyNoReward() public {\n            // Bob create share with id 1\n            market.changeBondingCurveAllowed(address(bondingCurve), true);\n            market.restrictShareCreation(false);\n            vm.prank(bob);\n            market.createNewShare(\"Test Share\", address(bondingCurve), \"metadataURI\");\n            assertEq(market.shareIDs(\"Test Share\"), 1);\n\n            token.transfer(alice, 1e17);\n\n            // alice buy 1 token in share1 ==> token1\n            vm.startPrank(alice);\n            uint256 aliceBalanceBefore = token.balanceOf(alice);\n            token.approve(address(market), 1e18);\n            console.log(\" alice balance \", aliceBalanceBefore);\n            market.buy(1, 1);\n            uint256 aliceBalanceAfter = token.balanceOf(alice);\n            console.log(\" alice balance after buy \",  aliceBalanceAfter);\n            console.log(\" alice cost after buy \",  aliceBalanceBefore - aliceBalanceAfter);\n\n            // alice buy another 1 token in share1 ==> token2\n            market.buy(1,1);\n            uint256 aliceBalanceAfterSecondBuy = token.balanceOf(alice);\n            console.log(\" alice balance after second buy \",  aliceBalanceAfterSecondBuy);\n            // alice get no reward for her token1\n            console.log(\" alice cost after second buy \",  aliceBalanceAfter - aliceBalanceAfterSecondBuy);\n\n            vm.stopPrank();\n        }\n\nThe result is shown below; Alice gets no rewards for `token1`:\n\n    [PASS] testBuyNoReward() (gas: 443199)\n    Logs:\n       alice balance  100000000000000000\n       alice balance after buy  98900000000000000\n       alice cost after buy  1100000000000000\n       alice balance after second buy  96700000000000000\n       alice cost after second buy  2200000000000000\n\nAfter my suggested patch, Alice can get the rewards for `token1`: `2200000000000000` - `2134000000000000` = `66000000000000`.\n\n    [PASS] testBuyNoReward() (gas: 447144)\n    Logs:\n       alice balance  100000000000000000\n       alice balance after buy  98900000000000000\n       alice cost after buy  1100000000000000\n       alice balance after second buy  96766000000000000\n       alice cost after second buy  2134000000000000\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nSplit the fees before getting the rewards in `buy`:\n\n```diff\ndiff --git a/1155tech-contracts/src/Market.sol b/1155tech-contracts/src/Market.sol\nindex 59c5c96..85d91a5 100644\n--- a/1155tech-contracts/src/Market.sol\n+++ b/1155tech-contracts/src/Market.sol\n@@ -151,11 +151,11 @@ contract Market is ERC1155, Ownable2Step {\n         require(shareData[_id].creator != msg.sender, \"Creator cannot buy\");\n         (uint256 price, uint256 fee) = getBuyPrice(_id, _amount); // Reverts for non-existing ID\n         SafeERC20.safeTransferFrom(token, msg.sender, address(this), price + fee);\n+        // Split the fee among holder, creator and platform\n+        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n         // The reward calculation has to use the old rewards value (pre fee-split) to not include the fees of this buy\n         // The rewardsLastClaimedValue then needs to be updated with the new value such that the user cannot claim fees of this buy\n         uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n-        // Split the fee among holder, creator and platform\n-        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n         rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n\n         shareData[_id].tokenCount += _amount;\n```\n\n### Assessed type\n\nContext\n\n**[OpenCoreCH (Canto) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-11-canto-findings/issues/9#issuecomment-1828482474):**\n > These fees are not lost, the impact is just that for this particular `buys`; the other users get more rewards and the user that buys less (but the same also applies for other users, so it might even cancel out for long-term holders). So I think high is definitely over-inflated for that.\n> \n> However, I agree that the current logic is a bit weird, but changing it such that they just receive rewards for the other shares would also be a bit weird (would incentivize to split up a buy into multiple ones). We discussed this internally and will change the logic such that users always receive fees for their `buys`, no matter if it is the first or subsequent ones.\n\n**[0xTheC0der (judge) decreased severity to Medium](https://github.com/code-423n4/2023-11-canto-findings/issues/9#issuecomment-1830951178)**\n\n**[OpenCoreCH (Canto) commented](https://github.com/code-423n4/2023-11-canto-findings/issues/9#issuecomment-1833716107):**\n > Fixed.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-11-canto-findings/issues/9).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-11-canto",
  "Code": [
    {
      "filename": "1155tech-contracts/src/Market.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.19;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable, Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {IBondingCurve} from \"../interface/IBondingCurve.sol\";\nimport {Turnstile} from \"../interface/Turnstile.sol\";\n\ncontract Market is ERC1155, Ownable2Step {\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n    uint256 public constant NFT_FEE_BPS = 1_000; // 10%\n    uint256 public constant HOLDER_CUT_BPS = 3_300; // 33%\n    uint256 public constant CREATOR_CUT_BPS = 3_300; // 33%\n    // Platform cut: 100% - HOLDER_CUT_BPS - CREATOR_CUT_BPS\n\n    /// @notice Payment token\n    IERC20 public immutable token;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of shares created\n    uint256 public shareCount;\n\n    /// @notice Stores the share ID of a given share name\n    mapping(string => uint256) public shareIDs;\n\n    struct ShareData {\n        uint256 tokenCount; // Number of outstanding tokens\n        uint256 tokensInCirculation; // Number of outstanding tokens - tokens that are minted as NFT, i.e. the number of tokens that receive fees\n        uint256 shareHolderRewardsPerTokenScaled; // Accrued funds for the share holder per token, multiplied by 1e18 to avoid precision loss\n        uint256 shareCreatorPool; // Unclaimed funds for the share creators\n        address bondingCurve; // Bonding curve used for this share\n        address creator; // Creator of the share\n        string metadataURI; // URI of the metadata\n    }\n\n    /// @notice Stores the data for a given share ID\n    mapping(uint256 => ShareData) public shareData;\n\n    /// @notice Stores the bonding curve per share\n    mapping(uint256 => address) public shareBondingCurves;\n\n    /// @notice Bonding curves that can be used for shares\n    mapping(address => bool) public whitelistedBondingCurves;\n\n    /// @notice Stores the number of outstanding tokens per share and address\n    mapping(uint256 => mapping(address => uint256)) public tokensByAddress;\n\n    /// @notice Value of ShareData.shareHolderRewardsPerTokenScaled at the last time a user claimed their rewards\n    mapping(uint256 => mapping(address => uint256)) public rewardsLastClaimedValue;\n\n    /// @notice Unclaimed funds for the platform\n    uint256 public platformPool;\n\n    /// @notice If true, only the whitelisted addresses can create shares\n    bool public shareCreationRestricted = true;\n\n    /// @notice List of addresses that can add new shares when shareCreationRestricted is true\n    mapping(address => bool) public whitelistedShareCreators;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event BondingCurveStateChange(address indexed curve, bool isWhitelisted);\n    event ShareCreated(uint256 indexed id, string name, address indexed bondingCurve, address indexed creator);\n    event SharesBought(uint256 indexed id, address indexed buyer, uint256 amount, uint256 price, uint256 fee);\n    event SharesSold(uint256 indexed id, address indexed seller, uint256 amount, uint256 price, uint256 fee);\n    event NFTsCreated(uint256 indexed id, address indexed creator, uint256 amount, uint256 fee);\n    event NFTsBurned(uint256 indexed id, address indexed burner, uint256 amount, uint256 fee);\n    event PlatformFeeClaimed(address indexed claimer, uint256 amount);\n    event CreatorFeeClaimed(address indexed claimer, uint256 indexed id, uint256 amount);\n    event HolderFeeClaimed(address indexed claimer, uint256 indexed id, uint256 amount);\n    event ShareCreationRestricted(bool isRestricted);\n\n    modifier onlyShareCreator() {\n        require(\n            !shareCreationRestricted || whitelistedShareCreators[msg.sender] || msg.sender == owner(),\n            \"Not allowed\"\n        );\n        _;\n    }\n\n    /// @notice Initiates CSR on main- and testnet\n    /// @param _uri ERC1155 Base URI\n    /// @param _paymentToken Address of the payment token\n    constructor(string memory _uri, address _paymentToken) ERC1155(_uri) Ownable() {\n        token = IERC20(_paymentToken);\n        if (block.chainid == 7700 || block.chainid == 7701) {\n            // Register CSR on Canto main- and testnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Whitelist or remove whitelist for a bonding curve.\n    /// @dev Whitelisting status is only checked when adding a share\n    /// @param _bondingCurve Address of the bonding curve\n    /// @param _newState True if whitelisted, false if not\n    function changeBondingCurveAllowed(address _bondingCurve, bool _newState) external onlyOwner {\n        require(whitelistedBondingCurves[_bondingCurve] != _newState, \"State already set\");\n        whitelistedBondingCurves[_bondingCurve] = _newState;\n        emit BondingCurveStateChange(_bondingCurve, _newState);\n    }\n\n    /// @notice Creates a new share\n    /// @param _shareName Name of the share\n    /// @param _bondingCurve Address of the bonding curve, has to be whitelisted\n    /// @param _metadataURI URI of the metadata\n    function createNewShare(\n        string memory _shareName,\n        address _bondingCurve,\n        string memory _metadataURI\n    ) external onlyShareCreator returns (uint256 id) {\n        require(whitelistedBondingCurves[_bondingCurve], \"Bonding curve not whitelisted\");\n        require(shareIDs[_shareName] == 0, \"Share already exists\");\n        id = ++shareCount;\n        shareIDs[_shareName] = id;\n        shareData[id].bondingCurve = _bondingCurve;\n        shareData[id].creator = msg.sender;\n        shareData[id].metadataURI = _metadataURI;\n        emit ShareCreated(id, _shareName, _bondingCurve, msg.sender);\n    }\n\n    /// @notice Returns the price and fee for buying a given number of shares.\n    /// @param _id The ID of the share\n    /// @param _amount The number of shares to buy.\n    function getBuyPrice(uint256 _id, uint256 _amount) public view returns (uint256 price, uint256 fee) {\n        // If id does not exist, this will return address(0), causing a revert in the next line\n        address bondingCurve = shareData[_id].bondingCurve;\n        (price, fee) = IBondingCurve(bondingCurve).getPriceAndFee(shareData[_id].tokenCount + 1, _amount);\n    }\n\n    /// @notice Returns the price and fee for selling a given number of shares.\n    /// @param _id The ID of the share\n    /// @param _amount The number of shares to sell.\n    function getSellPrice(uint256 _id, uint256 _amount) public view returns (uint256 price, uint256 fee) {\n        // If id does not exist, this will return address(0), causing a revert in the next line\n        address bondingCurve = shareData[_id].bondingCurve;\n        (price, fee) = IBondingCurve(bondingCurve).getPriceAndFee(shareData[_id].tokenCount - _amount + 1, _amount);\n    }\n\n    /// @notice Buy amount of tokens for a given share ID\n    /// @param _id ID of the share\n    /// @param _amount Amount of shares to buy\n    function buy(uint256 _id, uint256 _amount) external {\n        require(shareData[_id].creator != msg.sender, \"Creator cannot buy\");\n        (uint256 price, uint256 fee) = getBuyPrice(_id, _amount); // Reverts for non-existing ID\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), price + fee);\n        // The reward calculation has to use the old rewards value (pre fee-split) to not include the fees of this buy\n        // The rewardsLastClaimedValue then needs to be updated with the new value such that the user cannot claim fees of this buy\n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        // Split the fee among holder, creator and platform\n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n\n        shareData[_id].tokenCount += _amount;\n        shareData[_id].tokensInCirculation += _amount;\n        tokensByAddress[_id][msg.sender] += _amount;\n\n        if (rewardsSinceLastClaim > 0) {\n            SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim);\n        }\n        emit SharesBought(_id, msg.sender, _amount, price, fee);\n    }\n\n    /// @notice Sell amount of tokens for a given share ID\n    /// @param _id ID of the share\n    /// @param _amount Amount of shares to sell\n    function sell(uint256 _id, uint256 _amount) external {\n        (uint256 price, uint256 fee) = getSellPrice(_id, _amount);\n        // Split the fee among holder, creator and platform\n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n        // The user also gets the rewards of his own sale (which is not the case for buys)\n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n\n        shareData[_id].tokenCount -= _amount;\n        shareData[_id].tokensInCirculation -= _amount;\n        tokensByAddress[_id][msg.sender] -= _amount; // Would underflow if user did not have enough tokens\n\n        // Send the funds to the user\n        SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim + price - fee);\n        emit SharesSold(_id, msg.sender, _amount, price, fee);\n    }\n\n    /// @notice Returns the price and fee for minting a given number of NFTs.\n    /// @param _id The ID of the share\n    /// @param _amount The number of NFTs to mint.\n    function getNFTMintingPrice(uint256 _id, uint256 _amount) public view returns (uint256 fee) {\n        address bondingCurve = shareData[_id].bondingCurve;\n        (uint256 priceForOne, ) = IBondingCurve(bondingCurve).getPriceAndFee(shareData[_id].tokenCount, 1);\n        fee = (priceForOne * _amount * NFT_FEE_BPS) / 10_000;\n    }\n\n    /// @notice Convert amount of tokens to NFTs for a given share ID\n    /// @param _id ID of the share\n    /// @param _amount Amount of tokens to convert. User needs to have this many tokens.\n    function mintNFT(uint256 _id, uint256 _amount) external {\n        uint256 fee = getNFTMintingPrice(_id, _amount);\n\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), fee);\n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n        // The user also gets the proportional rewards for the minting\n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n        tokensByAddress[_id][msg.sender] -= _amount;\n        shareData[_id].tokensInCirculation -= _amount;\n\n        _mint(msg.sender, _id, _amount, \"\");\n\n        if (rewardsSinceLastClaim > 0) {\n            SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim);\n        }\n        // ERC1155 already logs, but we add this to have the price information\n        emit NFTsCreated(_id, msg.sender, _amount, fee);\n    }\n\n    /// @notice Burn amount of NFTs for a given share ID to get back tokens\n    /// @param _id ID of the share\n    /// @param _amount Amount of NFTs to burn\n    function burnNFT(uint256 _id, uint256 _amount) external {\n        uint256 fee = getNFTMintingPrice(_id, _amount);\n\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), fee);\n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n        // The user does not get the proportional rewards for the burning (unless they have additional tokens that are not in the NFT)\n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n        tokensByAddress[_id][msg.sender] += _amount;\n        shareData[_id].tokensInCirculation += _amount;\n        _burn(msg.sender, _id, _amount);\n\n        SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim);\n        // ERC1155 already logs, but we add this to have the price information\n        emit NFTsBurned(_id, msg.sender, _amount, fee);\n    }\n\n    /// @notice Withdraws the accrued platform fee\n    function claimPlatformFee() external onlyOwner {\n        uint256 amount = platformPool;\n        platformPool = 0;\n        SafeERC20.safeTransfer(token, msg.sender, amount);\n        emit PlatformFeeClaimed(msg.sender, amount);\n    }\n\n    /// @notice Withdraws the accrued share creator fee\n    /// @param _id ID of the share\n    function claimCreatorFee(uint256 _id) external {\n        require(shareData[_id].creator == msg.sender, \"Not creator\");\n        uint256 amount = shareData[_id].shareCreatorPool;\n        shareData[_id].shareCreatorPool = 0;\n        SafeERC20.safeTransfer(token, msg.sender, amount);\n        emit CreatorFeeClaimed(msg.sender, _id, amount);\n    }\n\n    /// @notice Withdraws the accrued share holder fee\n    /// @param _id ID of the share\n    function claimHolderFee(uint256 _id) external {\n        uint256 amount = _getRewardsSinceLastClaim(_id);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n        if (amount > 0) {\n            SafeERC20.safeTransfer(token, msg.sender, amount);\n        }\n        emit HolderFeeClaimed(msg.sender, _id, amount);\n    }\n\n    function _getRewardsSinceLastClaim(uint256 _id) internal view returns (uint256 amount) {\n        uint256 lastClaimedValue = rewardsLastClaimedValue[_id][msg.sender];\n        amount =\n            ((shareData[_id].shareHolderRewardsPerTokenScaled - lastClaimedValue) * tokensByAddress[_id][msg.sender]) /\n            1e18;\n    }\n\n    /// @notice Splits the fee among the share holder, creator and platform\n    function _splitFees(\n        uint256 _id,\n        uint256 _fee,\n        uint256 _tokenCount\n    ) internal {\n        uint256 shareHolderFee = (_fee * HOLDER_CUT_BPS) / 10_000;\n        uint256 shareCreatorFee = (_fee * CREATOR_CUT_BPS) / 10_000;\n        uint256 platformFee = _fee - shareHolderFee - shareCreatorFee;\n        shareData[_id].shareCreatorPool += shareCreatorFee;\n        if (_tokenCount > 0) {\n            shareData[_id].shareHolderRewardsPerTokenScaled += (shareHolderFee * 1e18) / _tokenCount;\n        } else {\n            // If there are no tokens in circulation, the fee goes to the platform\n            platformFee += shareHolderFee;\n        }\n        platformPool += platformFee;\n    }\n\n    /// @notice Restricts or unrestricts share creation\n    /// @param _isRestricted True if restricted, false if not\n    function restrictShareCreation(bool _isRestricted) external onlyOwner {\n        require(shareCreationRestricted != _isRestricted, \"State already set\");\n        shareCreationRestricted = _isRestricted;\n        emit ShareCreationRestricted(_isRestricted);\n    }\n\n    /// @notice Adds or removes an address from the whitelist of share creators\n    /// @param _address Address to add or remove\n    /// @param _isWhitelisted True if whitelisted, false if not\n    function changeShareCreatorWhitelist(address _address, bool _isWhitelisted) external onlyOwner {\n        require(whitelistedShareCreators[_address] != _isWhitelisted, \"State already set\");\n        whitelistedShareCreators[_address] = _isWhitelisted;\n    }\n}"
    }
  ]
}