{
  "Title": "[M-02] Previously nominated delegate can reset the delegation",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L167-L171\n\n\n# Vulnerability details\n\n   \n\nburn() allows for previously recorded delegate to set himself to be contributor's delegate even if another one was already chosen.\n\nThis can be quite material as owner choice for the whole voting power is being reset this way to favor the old delegate.\n\n## Proof of Concept\n\n_burn() can be invoked by anyone on the behalf of any `contributor`:\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L167-L171\n\n```solidity\n    function burn(address payable contributor)\n        public\n    {\n        return _burn(contributor, getCrowdfundLifecycle(), party);\n    }\n```\n\nIt mints the governance NFT for the contributor whenever he has voting power:\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L471-L485\n\n```solidity\n        if (votingPower > 0) {\n            // Get the address to delegate voting power to. If null, delegate to self.\n            address delegate = delegationsByContributor[contributor];\n            if (delegate == address(0)) {\n                // Delegate can be unset for the split recipient if they never\n                // contribute. Self-delegate if this occurs.\n                delegate = contributor;\n            }\n            // Mint governance NFT for the contributor.\n            party_.mint(\n                contributor,\n                votingPower,\n                delegate\n            );\n        }\n```\n\nNow mint() calls _adjustVotingPower() with a new delegate, redirecting all the intristic power, not just one for that id, ignoring the delegation the `owner` might already have:\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L120-L133\n\n```solidity\n    function mint(\n        address owner,\n        uint256 votingPower,\n        address delegate\n    )\n        external\n        onlyMinter\n        onlyDelegateCall\n    {\n        uint256 tokenId = ++tokenCount;\n        votingPowerByTokenId[tokenId] = votingPower;\n        _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate);\n        _mint(owner, tokenId);\n    }\n```\n\nI.e. Bob the contributor can take part in the crowdfunding with contribute() with small `0.01 ETH` stake, stating Mike as the delegate of his choice with `contribute(Mike, ...)`:\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L189-L208\n\n```solidity\n    /// @param delegate The address to delegate to for the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    function contribute(address delegate, bytes memory gateData)\n        public\n        payable\n    {\n        _contribute(\n            msg.sender,\n            msg.value.safeCastUint256ToUint96(),\n            delegate,\n            // We cannot use `address(this).balance - msg.value` as the previous\n            // total contributions in case someone forces (suicides) ETH into this\n            // contract. This wouldn't be such a big deal for open crowdfunds\n            // but private ones (protected by a gatekeeper) could be griefed\n            // because it would ultimately result in governance power that\n            // is unattributed/unclaimable, meaning that party will never be\n            // able to reach 100% consensus.\n            totalContributions,\n            gateData\n        );\n```\n\nThen crowdfund was a success, party was created, and Melany, who also participated, per off-chain arrangement has transferred to Bob a `tokenId` with big voting power (say it is `100 ETH` and the majority of voting power):\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L146-L155\n\n```solidity\n    /// @inheritdoc ERC721\n    function safeTransferFrom(address owner, address to, uint256 tokenId)\n        public\n        override\n        onlyDelegateCall\n    {\n        // Transfer voting along with token.\n        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);\n        super.safeTransferFrom(owner, to, tokenId);\n    }\n```\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L879-L887\n\n```solidity\n    // Transfers some voting power of `from` to `to`. The total voting power of\n    // their respective delegates will be updated as well.\n    function _transferVotingPower(address from, address to, uint256 power)\n        internal\n    {\n        int192 powerI192 = power.safeCastUint256ToInt192();\n        _adjustVotingPower(from, -powerI192, address(0));\n        _adjustVotingPower(to, powerI192, address(0));\n    }\n```\n\nBob don't care about his early small contribution and focuses on managing the one that Melany transferred instead as he simply don't need the voting power from the initial `0.01 ETH` contribution anymore.\n\nThe actual delegate for Bob at the moment is Linda, while his business with Mike is over. So Bob sets her address there, calling `delegateVotingPower(Linda)`:\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L448-L454\n\n```solidity\n    /// @notice Pledge your intrinsic voting power to a new delegate, removing it from\n    ///         the old one (if any).\n    /// @param delegate The address to delegating voting power to.\n    function delegateVotingPower(address delegate) external onlyDelegateCall {\n        _adjustVotingPower(msg.sender, 0, delegate);\n        emit VotingPowerDelegated(msg.sender, delegate);\n    }\n```\n\nNow, Mike can unilaterally delegate to himself the whole voting power with `burn(Bob)` as mint() just resets the delegation with the previously recorded value with `_adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate)`.\n\n## Recommended Mitigation Steps\n\nThe issue is that mint() always assumes that it is the first operation for the `owner`, which might not always be the case.\n\nConsider not changing the delegate on `mint` if one is set already:\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L120-L133\n\n```solidity\n    function mint(\n        address owner,\n        uint256 votingPower,\n        address delegate\n    )\n        external\n        onlyMinter\n        onlyDelegateCall\n    {\n        uint256 tokenId = ++tokenCount;\n        votingPowerByTokenId[tokenId] = votingPower;\n+       address actualDelegate = <get_current_delegate>;\n+       if (actualDelegate == address(0)) actualDelegate = delegate;\n-       _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate);\n+       _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), actualDelegate);\n        _mint(owner, tokenId);\n    }\n```\n\nMore complicated version might be the one with tracking the most recent request via contribute()/delegateVotingPower() calls timestamps. Here we assume that the delegateVotingPower() holds more information as in the majority of practical cases it occurs after initial contribute() and it is a direct voluntary call from the owner. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/crowdfund/Crowdfund.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../party/Party.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\nimport \"./CrowdfundNFT.sol\";\n\n// Base contract for AuctionCrowdfund/BuyCrowdfund.\n// Holds post-win/loss logic. E.g., burning contribution NFTs and creating a\n// party after winning.\nabstract contract Crowdfund is ERC721Receiver, CrowdfundNFT {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    enum CrowdfundLifecycle {\n        Invalid,\n        Active,\n        Expired,\n        Busy, // Temporary. mid-settlement state\n        Lost,\n        Won\n    }\n\n    // PartyGovernance options that must be known and fixed at crowdfund creation.\n    // This is a subset of PartyGovernance.GovernanceOpts.\n    struct FixedGovernanceOpts {\n        // Address of initial party hosts.\n        address[] hosts;\n        // How long people can vote on a proposal.\n        uint40 voteDuration;\n        // How long to wait after a proposal passes before it can be\n        // executed.\n        uint40 executionDelay;\n        // Minimum ratio of accept votes to consider a proposal passed,\n        // in bps, where 10,000 == 100%.\n        uint16 passThresholdBps;\n        // Fee bps for governance distributions.\n        uint16 feeBps;\n        // Fee recipeint for governance distributions.\n        address payable feeRecipient;\n    }\n\n    // Options to be passed into `_initialize()` when the crowdfund is created.\n    struct CrowdfundOptions {\n        string name;\n        string symbol;\n        address payable splitRecipient;\n        uint16 splitBps;\n        address initialContributor;\n        address initialDelegate;\n        IGateKeeper gateKeeper;\n        bytes12 gateKeeperId;\n        FixedGovernanceOpts governanceOpts;\n    }\n\n    // A record of a single contribution made by a user.\n    // Stored in `_contributionsByContributor`.\n    struct Contribution {\n        // The value of `Crowdfund.totalContributions` when this contribution was made.\n        uint96 previousTotalContributions;\n        // How much was this contribution.\n        uint96 amount;\n    }\n\n    error PartyAlreadyExistsError(Party party);\n    error WrongLifecycleError(CrowdfundLifecycle lc);\n    error InvalidGovernanceOptionsError(bytes32 actualHash, bytes32 expectedHash);\n    error InvalidDelegateError();\n    error NoPartyError();\n    error OnlyContributorAllowedError();\n    error NotAllowedByGateKeeperError(address contributor, IGateKeeper gateKeeper, bytes12 gateKeeperId, bytes gateData);\n    error SplitRecipientAlreadyBurnedError();\n    error InvalidBpsError(uint16 bps);\n\n    event Burned(address contributor, uint256 ethUsed, uint256 ethOwed, uint256 votingPower);\n    event Contributed(address contributor, uint256 amount, address delegate, uint256 previousTotalContributions);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and itâ€™s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The party instance created by `_createParty()`, if any after a\n    ///         successful crowdfund.\n    Party public party;\n    /// @notice The total (recorded) ETH contributed to this crowdfund.\n    uint96 public totalContributions;\n    /// @notice The gatekeeper contract to use (if non-null) to restrict who can\n    ///         contribute to the party.\n    IGateKeeper public gateKeeper;\n    /// @notice The ID of the gatekeeper strategy to use.\n    bytes12 public gateKeeperId;\n    /// @notice Who will receive a reserved portion of governance power when\n    ///         the governance party is created.\n    address payable public splitRecipient;\n    /// @notice How much governance power to reserve for `splitRecipient`,\n    ///         in bps, where 10,000 = 100%.\n    uint16 public splitBps;\n    // Whether the share for split recipient has been claimed through `burn()`.\n    bool private _splitRecipientHasBurned;\n    /// @notice Hash of party governance options passed into `initialize()`.\n    ///         Used to check whether the `GovernanceOpts` passed into\n    ///         `_createParty()` matches.\n    bytes32 public governanceOptsHash;\n    /// @notice Who a contributor last delegated to.\n    mapping(address => address) public delegationsByContributor;\n    // Array of contributions by a contributor.\n    // One is created for every nonzero contribution made.\n    mapping (address => Contribution[]) private _contributionsByContributor;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) CrowdfundNFT(globals) {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts, credit initial contribution (if\n    // any), and setup gatekeeper.\n    function _initialize(CrowdfundOptions memory opts)\n        internal\n    {\n        CrowdfundNFT._initialize(opts.name, opts.symbol);\n        // Check that BPS values do not exceed the max.\n        if (opts.governanceOpts.feeBps > 1e4) {\n            revert InvalidBpsError(opts.governanceOpts.feeBps);\n        }\n        if (opts.governanceOpts.passThresholdBps > 1e4) {\n            revert InvalidBpsError(opts.governanceOpts.passThresholdBps);\n        }\n        if (opts.splitBps > 1e4) {\n            revert InvalidBpsError(opts.splitBps);\n        }\n        governanceOptsHash = _hashFixedGovernanceOpts(opts.governanceOpts);\n        splitRecipient = opts.splitRecipient;\n        splitBps = opts.splitBps;\n        // If the deployer passed in some ETH during deployment, credit them\n        // for the initial contribution.\n        uint96 initialBalance = address(this).balance.safeCastUint256ToUint96();\n        if (initialBalance > 0) {\n            // If this contract has ETH, either passed in during deployment or\n            // pre-existing, credit it to the `initialContributor`.\n            _contribute(opts.initialContributor, initialBalance, opts.initialDelegate, 0, \"\");\n        }\n        // Set up gatekeeper after initial contribution (initial always gets in).\n        gateKeeper = opts.gateKeeper;\n        gateKeeperId = opts.gateKeeperId;\n    }\n\n    /// @notice Burn the participation NFT for `contributor`, potentially\n    ///         minting voting power and/or refunding unused ETH. `contributor`\n    ///         may also be the split recipient, regardless of whether they are\n    ///         also a contributor or not. This can be called by anyone on a\n    ///         contributor's behalf to unlock their voting power in the\n    ///         governance stage ensuring delegates receive their voting\n    ///         power and governance is not stalled.\n    /// @dev If the party has won, someone needs to call `_createParty()` first. After\n    ///      which, `burn()` will refund unused ETH and mint governance tokens for the\n    ///      given `contributor`.\n    ///      If the party has lost, this will only refund unused ETH (all of it) for\n    ///      the given `contributor`.\n    /// @param contributor The contributor whose NFT to burn for.\n    function burn(address payable contributor)\n        public\n    {\n        return _burn(contributor, getCrowdfundLifecycle(), party);\n    }\n\n    /// @notice `burn()` in batch form.\n    /// @param contributors The contributors whose NFT to burn for.\n    function batchBurn(address payable[] calldata contributors)\n        external\n    {\n        Party party_ = party;\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        for (uint256 i = 0; i < contributors.length; ++i) {\n            _burn(contributors[i], lc, party_);\n        }\n    }\n\n    /// @notice Contribute to this crowdfund and/or update your delegation for the\n    ///         governance phase should the crowdfund succeed.\n    ///         For restricted crowdfunds, `gateData` can be provided to prove\n    ///         membership to the gatekeeper.\n    /// @param delegate The address to delegate to for the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    function contribute(address delegate, bytes memory gateData)\n        public\n        payable\n    {\n        _contribute(\n            msg.sender,\n            msg.value.safeCastUint256ToUint96(),\n            delegate,\n            // We cannot use `address(this).balance - msg.value` as the previous\n            // total contributions in case someone forces (suicides) ETH into this\n            // contract. This wouldn't be such a big deal for open crowdfunds\n            // but private ones (protected by a gatekeeper) could be griefed\n            // because it would ultimately result in governance power that\n            // is unattributed/unclaimable, meaning that party will never be\n            // able to reach 100% consensus.\n            totalContributions,\n            gateData\n        );\n    }\n\n    /// @inheritdoc EIP165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        override(ERC721Receiver, CrowdfundNFT)\n        pure\n        returns (bool)\n    {\n        return ERC721Receiver.supportsInterface(interfaceId) ||\n            CrowdfundNFT.supportsInterface(interfaceId);\n    }\n\n    /// @notice Retrieve info about a participant's contributions.\n    /// @dev This will only be called off-chain so doesn't have to be optimal.\n    /// @param contributor The contributor to retrieve contributions for.\n    /// @return ethContributed The total ETH contributed by `contributor`.\n    /// @return ethUsed The total ETH used by `contributor` to acquire the NFT.\n    /// @return ethOwed The total ETH refunded back to `contributor`.\n    /// @return votingPower The total voting power minted to `contributor`.\n    function getContributorInfo(address contributor)\n        external\n        view\n        returns (\n            uint256 ethContributed,\n            uint256 ethUsed,\n            uint256 ethOwed,\n            uint256 votingPower\n        )\n    {\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        Contribution[] storage contributions = _contributionsByContributor[contributor];\n        uint256 numContributions = contributions.length;\n        for (uint256 i = 0; i < numContributions; ++i) {\n            ethContributed += contributions[i].amount;\n        }\n        if (lc == CrowdfundLifecycle.Won || lc == CrowdfundLifecycle.Lost) {\n            (ethUsed, ethOwed, votingPower) = _getFinalContribution(contributor);\n        }\n    }\n\n    /// @notice Get the current lifecycle of the crowdfund.\n    function getCrowdfundLifecycle() public virtual view returns (CrowdfundLifecycle);\n\n    // Get the final sale price of the bought assets. This will also be the total\n    // voting power of the governance party.\n    function _getFinalPrice() internal virtual view returns (uint256);\n\n    // Can be called after a party has won.\n    // Deploys and initializes a a `Party` instance via the `PartyFactory`\n    // and transfers the bought NFT to it.\n    // After calling this, anyone can burn CF tokens on a contributor's behalf\n    // with the `burn()` function.\n    function _createParty(\n        IPartyFactory partyFactory,\n        FixedGovernanceOpts memory governanceOpts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    )\n        internal\n        returns (Party party_)\n    {\n        if (party != Party(payable(0))) {\n            revert PartyAlreadyExistsError(party);\n        }\n        {\n            bytes16 governanceOptsHash_ = _hashFixedGovernanceOpts(governanceOpts);\n            if (governanceOptsHash_ != governanceOptsHash) {\n                revert InvalidGovernanceOptionsError(governanceOptsHash_, governanceOptsHash);\n            }\n        }\n        party = party_ = partyFactory\n            .createParty(\n                address(this),\n                Party.PartyOptions({\n                    name: name,\n                    symbol: symbol,\n                    governance: PartyGovernance.GovernanceOpts({\n                        hosts: governanceOpts.hosts,\n                        voteDuration: governanceOpts.voteDuration,\n                        executionDelay: governanceOpts.executionDelay,\n                        passThresholdBps: governanceOpts.passThresholdBps,\n                        totalVotingPower: _getFinalPrice().safeCastUint256ToUint96(),\n                        feeBps: governanceOpts.feeBps,\n                        feeRecipient: governanceOpts.feeRecipient\n                    })\n                }),\n                preciousTokens,\n                preciousTokenIds\n            );\n        // Transfer the acquired NFTs to the new party.\n        for (uint256 i = 0; i < preciousTokens.length; ++i) {\n            preciousTokens[i].transferFrom(address(this), address(party_), preciousTokenIds[i]);\n        }\n    }\n\n    // Overloaded single token wrapper for _createParty()\n    function _createParty(\n        IPartyFactory partyFactory,\n        FixedGovernanceOpts memory governanceOpts,\n        IERC721 preciousToken,\n        uint256 preciousTokenId\n    )\n        internal\n        returns (Party party_)\n    {\n        IERC721[] memory tokens = new IERC721[](1);\n        tokens[0] = preciousToken;\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = preciousTokenId;\n        return _createParty(partyFactory, governanceOpts, tokens, tokenIds);\n    }\n\n    function _hashFixedGovernanceOpts(FixedGovernanceOpts memory opts)\n        internal\n        pure\n        returns (bytes16 h)\n    {\n        // Hash in place.\n        assembly {\n            // Replace the address[] hosts field with its hash temporarily.\n            let oldHostsFieldValue := mload(opts)\n            mstore(opts, keccak256(add(mload(opts), 0x20), mul(mload(mload(opts)), 32)))\n            // Hash the entire struct.\n            h := keccak256(opts, 0xC0)\n            // Restore old hosts field value.\n            mstore(opts, oldHostsFieldValue)\n        }\n    }\n\n    function _getFinalContribution(address contributor)\n        internal\n        view\n        returns (uint256 ethUsed, uint256 ethOwed, uint256 votingPower)\n    {\n        uint256 totalEthUsed = _getFinalPrice();\n        {\n            Contribution[] storage contributions = _contributionsByContributor[contributor];\n            uint256 numContributions = contributions.length;\n            for (uint256 i = 0; i < numContributions; ++i) {\n                Contribution memory c = contributions[i];\n                if (c.previousTotalContributions >= totalEthUsed) {\n                    // This entire contribution was not used.\n                    ethOwed += c.amount;\n                } else if (c.previousTotalContributions + c.amount <= totalEthUsed) {\n                    // This entire contribution was used.\n                    ethUsed += c.amount;\n                } else {\n                    // This contribution was partially used.\n                    uint256 partialEthUsed = totalEthUsed - c.previousTotalContributions;\n                    ethUsed += partialEthUsed;\n                    ethOwed = c.amount - partialEthUsed;\n                }\n            }\n        }\n        // one SLOAD with optimizer on\n        address splitRecipient_ = splitRecipient;\n        uint256 splitBps_ = splitBps;\n        if (splitRecipient_ == address(0)) {\n            splitBps_ = 0;\n        }\n        votingPower = ((1e4 - splitBps_) * ethUsed) / 1e4;\n        if (splitRecipient_ == contributor) {\n            // Split recipient is also the contributor so just add the split\n            // voting power.\n            votingPower += (splitBps_ * totalEthUsed + (1e4 - 1)) / 1e4; // round up\n        }\n    }\n\n    function _contribute(\n        address contributor,\n        uint96 amount,\n        address delegate,\n        uint96 previousTotalContributions,\n        bytes memory gateData\n    )\n        internal\n    {\n        // Require a non-null delegate.\n        if (delegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n        // Must not be blocked by gatekeeper.\n        if (gateKeeper != IGateKeeper(address(0))) {\n            if (!gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n                revert NotAllowedByGateKeeperError(\n                    contributor,\n                    gateKeeper,\n                    gateKeeperId,\n                    gateData\n                );\n            }\n        }\n\n        // Update delegate.\n        // OK if this happens out of cycle.\n        delegationsByContributor[contributor] = delegate;\n        emit Contributed(contributor, amount, delegate, previousTotalContributions);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount != 0) {\n            // Increase total contributions.\n            totalContributions += amount;\n\n            // Only allow contributions while the crowdfund is active.\n            {\n                CrowdfundLifecycle lc = getCrowdfundLifecycle();\n                if (lc != CrowdfundLifecycle.Active) {\n                    revert WrongLifecycleError(lc);\n                }\n            }\n            // Create contributions entry for this contributor.\n            Contribution[] storage contributions = _contributionsByContributor[contributor];\n            uint256 numContributions = contributions.length;\n            if (numContributions >= 1) {\n                Contribution memory lastContribution = contributions[numContributions - 1];\n                if (lastContribution.previousTotalContributions == previousTotalContributions) {\n                    // No one else has contributed since so just reuse the last entry.\n                    lastContribution.amount += amount;\n                    contributions[numContributions - 1] = lastContribution;\n                    return;\n                }\n            }\n            // Add a new contribution entry.\n            contributions.push(Contribution({\n                previousTotalContributions: previousTotalContributions,\n                amount: amount\n            }));\n            // Mint a participation NFT if this is their first contribution.\n            if (numContributions == 0) {\n                _mint(contributor);\n            }\n        }\n    }\n\n    function _burn(address payable contributor, CrowdfundLifecycle lc, Party party_)\n        private\n    {\n        // If the CF has won, a party must have been created prior.\n        if (lc == CrowdfundLifecycle.Won) {\n            if (party_ == Party(payable(0))) {\n                revert NoPartyError();\n            }\n        } else if (lc != CrowdfundLifecycle.Lost) {\n            // Otherwise it must have lost.\n            revert WrongLifecycleError(lc);\n        }\n        // Split recipient can burn even if they don't have a token.\n        if (contributor == splitRecipient) {\n            if (_splitRecipientHasBurned) {\n                revert SplitRecipientAlreadyBurnedError();\n            }\n            _splitRecipientHasBurned = true;\n        }\n        // Revert if already burned or does not exist.\n        if (splitRecipient != contributor || _doesTokenExistFor(contributor)) {\n            CrowdfundNFT._burn(contributor);\n        }\n        // Compute the contributions used and owed to the contributor, along\n        // with the voting power they'll have in the governance stage.\n        (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) =\n            _getFinalContribution(contributor);\n        if (votingPower > 0) {\n            // Get the address to delegate voting power to. If null, delegate to self.\n            address delegate = delegationsByContributor[contributor];\n            if (delegate == address(0)) {\n                // Delegate can be unset for the split recipient if they never\n                // contribute. Self-delegate if this occurs.\n                delegate = contributor;\n            }\n            // Mint governance NFT for the contributor.\n            party_.mint(\n                contributor,\n                votingPower,\n                delegate\n            );\n        }\n        // Refund any ETH owed back to the contributor.\n        contributor.transferEth(ethOwed);\n        emit Burned(contributor, ethUsed, ethOwed, votingPower);\n    }\n\n    function _getPartyFactory() internal view returns (IPartyFactory) {\n        return IPartyFactory(_GLOBALS.getAddress(LibGlobals.GLOBAL_PARTY_FACTORY));\n    }\n}"
    }
  ]
}