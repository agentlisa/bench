{
  "Title": "[M-02] A malicious strategy can permanently DoS all currently pending withdrawals that contain it",
  "Content": "\nIn order to withdraw funds from the project a user has to:\n\n1.  queue a withdrawal (via `queueWithdrawal`).\n2.  complete a withdrawal (via `completeQueuedWithdrawal(s)`).\n\nQueuing a withdrawal, via `queueWithdrawal` modifies all internal accounting to reflect this:\n\n<https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L345-L346>\n\n```Solidity\n        // modify delegated shares accordingly, if applicable\n        delegation.decreaseDelegatedShares(msg.sender, strategies, shares);\n```\n<https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L370>\n\n```Solidity\n    if (_removeShares(msg.sender, strategyIndexes[strategyIndexIndex], strategies[i], shares[i])) {\n```\n\nand saves the withdrawal hash in order to be used in `completeQueuedWithdrawal(s)`.\n\n<https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L400-L415>\n\n```Solidity\n            queuedWithdrawal = QueuedWithdrawal({\n                strategies: strategies,\n                shares: shares,\n                depositor: msg.sender,\n                withdrawerAndNonce: withdrawerAndNonce,\n                withdrawalStartBlock: uint32(block.number),\n                delegatedAddress: delegatedAddress\n            });\n\n\n        }\n\n\n        // calculate the withdrawal root\n        bytes32 withdrawalRoot = calculateWithdrawalRoot(queuedWithdrawal);\n\n\n        // mark withdrawal as pending\n        withdrawalRootPending[withdrawalRoot] = true;\n```\n\nIn other words, it is final (as there is no `cancelWithdrawl` mechanism implemented). When executing `completeQueuedWithdrawal(s)`, the `withdraw` function of the strategy is called (if `receiveAsTokens` is set to true).\n\n<https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L786-L789>\n\n```Solidity\n    // tell the strategy to send the appropriate amount of funds to the depositor\n    queuedWithdrawal.strategies[i].withdraw(\n        msg.sender, tokens[i], queuedWithdrawal.shares[i]\n    );\n```\n\nIn this case, a malicious strategy can always revert, blocking the user from retrieving his tokens. If a user sets `receiveAsTokens` to `false`, the other case, then the tokens will be added as shares to the delegation contract\n\n<https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L797-L800>\n\n```Solidity\n    for (uint256 i = 0; i < strategiesLength;) {\n        _addShares(msg.sender, queuedWithdrawal.strategies[i], queuedWithdrawal.shares[i]);\n        unchecked {\n            ++i;\n```\n\n<https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L646-L647>\n\n```Solidity\n        // if applicable, increase delegated shares accordingly\n        delegation.increaseDelegatedShares(depositor, strategy, shares);\n```\n\nThis still poses a problem because the `increaseDelegatedShares` function's counterpart, `decreaseDelegatedShares`, is only callable by the strategy manager (for users to indirectly get their rewards worth back, via this workaround).\n\n<https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/DelegationManager.sol#L168-L179>\n\n```Solidity\n    /**\n     * @notice Decreases the `staker`'s delegated shares in each entry of `strategies` by its respective `shares[i]`, typically called when the staker withdraws from EigenLayer\n     * @dev Callable only by the StrategyManager\n     */\n    function decreaseDelegatedShares(\n        address staker,\n        IStrategy[] calldata strategies,\n        uint256[] calldata shares\n    )\n        external\n        onlyStrategyManager\n    {\n```\n\nBut in `StrategyManager`, there are only 3 cases where this is called, none of which is beneficial for the user:\n\n*   [`recordOvercommittedBeaconChainETH`](https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L205) - slashes user rewards in certain conditions\n*   [`queueWithdrawal`](https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L346) - accounting side effects have already been done, will fail in `_removeShares`\n*   [`slashShares`](https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L346) - slashes user rewards in certain conditions\n\nIn other words, the workaround (of setting `receiveAsTokens` to `false` in `completeQueuedWithdrawal(s)`) just leaves the funds accounted and stuck in `DelegationManager`.\n\nIn both cases, all shares/tokens associated with other strategies in the pending withdrawal are permanently blocked.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L786-L789>\n\n### Recommended Mitigation Steps\n\nAdd a `cancelQueuedWithdrawl` function that will undo the accounting and cancel out any dependency on the malicious strategy. Although this solution may create a front-running opportunity for when their withdrawal will be slashed via `slashQueuedWithdrawal`, there may exist workarounds to this.\n\nAnother possibility is to implement a similar mechanism to how `slashQueuedWithdrawal` treats malicious strategies: adding a list of strategy indices to skip.\n\n<https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L532-L535> <br><https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L560-L566>\n\n```Solidity\n     * @param indicesToSkip Optional input parameter -- indices in the `strategies` array to skip (i.e. not call the 'withdraw' function on). This input exists\n     * so that, e.g., if the slashed QueuedWithdrawal contains a malicious strategy in the `strategies` array which always reverts on calls to its 'withdraw' function,\n     * then the malicious strategy can be skipped (with the shares in effect \"burned\"), while the non-malicious strategies are still called as normal.\n     */\n     \n     ...\n\n        for (uint256 i = 0; i < strategiesLength;) {\n            // check if the index i matches one of the indices specified in the `indicesToSkip` array\n            if (indicesToSkipIndex < indicesToSkip.length && indicesToSkip[indicesToSkipIndex] == i) {\n                unchecked {\n                    ++indicesToSkipIndex;\n                }\n            } else {     \n```\n\n### Assessed type\n\nDoS\n\n**[Sidu28 (EigenLayer) disagreed with severity and commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/132#issuecomment-1544939500):**\n > The description of lack of check here is accurate. There is zero actual impact; we think this is informational severity.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/132#issuecomment-1566237843):**\n > @Sidu28 - if we assumed the Strategy not to be malicious, but to revert for some reason (e.g. lack of liquidity, smart contract bug, etc...)\n> \n> Would you consider the finding as valid since the user cannot withdrawal from all others due to having one withdraw, or is there some other reason why you believe the finding to be Informational?\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/132#issuecomment-1570697598):**\n > The Warden has shown how, any revert in a strategy (for example it being paused), will make queued withdrawals revert, even if the withdrawal should work for other strategies.\n> \n> This falls into the category of DOS and I believe is more appropriately judged as Medium.\n\n**[ChaoticWalrus (EigenLayer) commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/132#issuecomment-1575599410):**\n >@Alex the Entreprenerd - Even if a malicious strategy exists, there is no permanent delay here.\n> \n> Users can mark the `receiveAsTokens` input to `completeQueuedWithdrawal` as false [here](https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L437-L442) and then the shares will be transferred to the 'withdrawing' user [here](https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L795-L803) who can then *queue a new withdrawal not containing the malicious strategy*.\n> \n> The description provided by the warden of the `DelegationManager`'s behavior is inaccurate -- the funds do not end up 'stuck in the `DelegationManager`' -- they will be withdrawable as part of a new queued withdrawal, which excludes the malicious strategy.\n\n**[ABA (warden) commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/132#issuecomment-1576429085):** \n> Hey, \n> https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L795-L803 does not do:\n> >  shares will be transferred to the 'withdrawing' user\n> \n> It simply increments internal accounting and delegated shares associated to the user in the delegation contract. But these are not withdrawn without a `queueWithdrawal` call.\n> \n> https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L647\n> \n> > *queue a new withdrawal not containing the malicious strategy*.\n> \n> A new queue can not reuse the already used balance, as it was already accounted for [here](https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L345-L346).\n>\n> Maybe I am missing something of course. Regardless, awaiting judge feedback.\n\n**[ChaoticWalrus (EigenLayer) commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/132#issuecomment-1576956558):**\n > > It simply increments internal accounting and delegated shares associated to the user in the delegation contract. But these are not withdrawn without a `queueWithdrawal` call\n> \n> Yes, this is what I would describe as transferring the shares, similar to how the 'transfer in' portion of an ERC20 transfer works. But this is a semantic argument; I agree with the substance of your description.\n> \n> > A new queue can not reuse the already used balance as it was already accounted for [here](https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L345-L346)\n> > \n> > Maybe I am missing something of course. Regardless, awaiting judge feedback.\n> \n> I think perhaps you are missing that the internal `_addShares` function calls the `DelegationManager` as well. See [here](https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/core/StrategyManager.sol#L646-L647)\n> \n> If the user marks `receiveAsTokens` as false, then [this line](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/core/StrategyManager.sol#L798) will be triggered, \n> which calls into the internal `_addShares` function and 're-adds' these delegated shares, so they can indeed be queued in a new withdrawal. \n> \n> I can provide an example if it will help.\n\n**[ChaoticWalrus (EigenLayer) commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/132#issuecomment-1576959743):**\n > Basically, the 're-adding' reverses the accounting taken in the initial `queueWithdrawal` action, to clarify. This then allows the accounting done in the `queueWithdrawal` action to be performed once again when a new withdrawal is queued.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/132#issuecomment-1578925785):**\n > @ChaoticWalrus - It seems like the worst case scenario would be having to re-queue without the missing strategy, which would require waiting for the withdrawal to unlock.\n> \n> So the question left to answer is whether an additional wait period is acceptable.\n> \n> NOTE: I edited this comment because as you pointed out, the shares accounting is internal and doesn't trigger an interaction with the strategy.\n\n**[ChaoticWalrus (EigenLayer) commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/132#issuecomment-1579189255):**\n > > It seems like the worst case scenario would be having to re-queue without the missing strategy which would require waiting for the withdrawal to unlock\n> \n> Yes, agreed this is the impact + worst-case scenario. The existing functionality was designed, in part at least, to address concerns about malicious Strategies.\n> \n> > So the question left to answer is whether an additional wait period is acceptable\n> \n> I suppose so, yes. We have deemed this acceptable ourselves, but I could see it being viewed differently. Regardless, the impact here is orders of magnitude less than the original claimed impact.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/132#issuecomment-1582291971):**\n > The Warden has shown how, due to the possibility of queueing a withdrawal with multiple strategies, in the case in which one of the strategies stops working (reverts, paused, malicious), the withdrawal would be denied.\n> \n> As the sponsor said, in those scenarios, the withdrawer would have to perform a second withdrawal, which would have to be re-queued.\n> \n> Intuitively, a withdrawer that always withdraws a separate strategy would also never see their withdrawal denied (except for the malicious strategy).\n> \n> As we can see, there are plenty of side steps to the risk shown. However, the functionality of the function is denied, even if temporarily, leading to it not working as intended, and for this reason I believe Medium Severity to be the most appropriate.\n> \n> As shown above, the finding could be fixed. However, it seems to me like most users would want to plan around the scenarios described in this finding and its duplicates.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-eigenlayer",
  "Code": [
    {
      "filename": "src/contracts/core/StrategyManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.12;\n\nimport \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin-upgrades/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin-upgrades/contracts/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../interfaces/IEigenPodManager.sol\";\nimport \"../permissions/Pausable.sol\";\nimport \"./StrategyManagerStorage.sol\";\n\n/**\n * @title The primary entry- and exit-point for funds into and out of EigenLayer.\n * @author Layr Labs, Inc.\n * @notice This contract is for managing deposits in different strategies. The main\n * functionalities are:\n * - adding and removing strategies that any delegator can deposit into\n * - enabling deposit of assets into specified strategy(s)\n * - enabling withdrawal of assets from specified strategy(s)\n * - recording deposit of ETH into settlement layer\n * - slashing of assets for permissioned strategies\n */\ncontract StrategyManager is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    Pausable,\n    StrategyManagerStorage\n{\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant GWEI_TO_WEI = 1e9;\n\n    // index for flag that pauses deposits when set\n    uint8 internal constant PAUSED_DEPOSITS = 0;\n    // index for flag that pauses withdrawals when set\n    uint8 internal constant PAUSED_WITHDRAWALS = 1;\n\n    uint256 immutable ORIGINAL_CHAIN_ID;\n\n    // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\n\n    /**\n     * @notice Emitted when a new deposit occurs on behalf of `depositor`.\n     * @param depositor Is the staker who is depositing funds into EigenLayer.\n     * @param strategy Is the strategy that `depositor` has deposited into.\n     * @param token Is the token that `depositor` deposited.\n     * @param shares Is the number of shares `depositor` has in `strategy`.\n     */\n    event Deposit(\n        address depositor, IERC20 token, IStrategy strategy, uint256 shares\n    );\n\n    /**\n     * @notice Emitted when a new withdrawal occurs on behalf of `depositor`.\n     * @param depositor Is the staker who is queuing a withdrawal from EigenLayer.\n     * @param nonce Is the withdrawal's unique identifier (to the depositor).\n     * @param strategy Is the strategy that `depositor` has queued to withdraw from.\n     * @param shares Is the number of shares `depositor` has queued to withdraw.\n     */\n    event ShareWithdrawalQueued(\n        address depositor, uint96 nonce, IStrategy strategy, uint256 shares\n    );\n\n    /**\n     * @notice Emitted when a new withdrawal is queued by `depositor`.\n     * @param depositor Is the staker who is withdrawing funds from EigenLayer.\n     * @param nonce Is the withdrawal's unique identifier (to the depositor).\n     * @param withdrawer Is the party specified by `staker` who will be able to complete the queued withdrawal and receive the withdrawn funds.\n     * @param delegatedAddress Is the party who the `staker` was delegated to at the time of creating the queued withdrawal\n     * @param withdrawalRoot Is a hash of the input data for the withdrawal.\n     */\n    event WithdrawalQueued(\n        address depositor, uint96 nonce, address withdrawer, address delegatedAddress, bytes32 withdrawalRoot\n    );\n\n    /// @notice Emitted when a queued withdrawal is completed\n    event WithdrawalCompleted(address indexed depositor, uint96 nonce, address indexed withdrawer, bytes32 withdrawalRoot);\n\n    /// @notice Emitted when the `strategyWhitelister` is changed\n    event StrategyWhitelisterChanged(address previousAddress, address newAddress);\n\n    /// @notice Emitted when a strategy is added to the approved list of strategies for deposit\n    event StrategyAddedToDepositWhitelist(IStrategy strategy);\n\n    /// @notice Emitted when a strategy is removed from the approved list of strategies for deposit\n    event StrategyRemovedFromDepositWhitelist(IStrategy strategy);\n\n    /// @notice Emitted when the `withdrawalDelayBlocks` variable is modified from `previousValue` to `newValue`.\n    event WithdrawalDelayBlocksSet(uint256 previousValue, uint256 newValue);\n\n    modifier onlyNotFrozen(address staker) {\n        require(\n            !slasher.isFrozen(staker),\n            \"StrategyManager.onlyNotFrozen: staker has been frozen and may be subject to slashing\"\n        );\n        _;\n    }\n\n    modifier onlyFrozen(address staker) {\n        require(slasher.isFrozen(staker), \"StrategyManager.onlyFrozen: staker has not been frozen\");\n        _;\n    }\n\n    modifier onlyEigenPodManager {\n        require(address(eigenPodManager) == msg.sender, \"StrategyManager.onlyEigenPodManager: not the eigenPodManager\");\n        _;\n    }\n\n    modifier onlyStrategyWhitelister {\n        require(msg.sender == strategyWhitelister, \"StrategyManager.onlyStrategyWhitelister: not the strategyWhitelister\");\n        _;\n    }\n\n    modifier onlyStrategiesWhitelistedForDeposit(IStrategy strategy) {\n        require(strategyIsWhitelistedForDeposit[strategy], \"StrategyManager.onlyStrategiesWhitelistedForDeposit: strategy not whitelisted\");\n        _;\n    }\n\n    /**\n     * @param _delegation The delegation contract of EigenLayer.\n     * @param _slasher The primary slashing contract of EigenLayer.\n     * @param _eigenPodManager The contract that keeps track of EigenPod stakes for restaking beacon chain ether.\n     */\n    constructor(IDelegationManager _delegation, IEigenPodManager _eigenPodManager, ISlasher _slasher)\n        StrategyManagerStorage(_delegation, _eigenPodManager, _slasher)\n    {\n        _disableInitializers();\n        ORIGINAL_CHAIN_ID = block.chainid;\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /**\n     * @notice Initializes the strategy manager contract. Sets the `pauserRegistry` (currently **not** modifiable after being set),\n     * and transfers contract ownership to the specified `initialOwner`.\n     * @param _pauserRegistry Used for access control of pausing.\n     * @param initialOwner Ownership of this contract is transferred to this address.\n     * @param initialStrategyWhitelister The initial value of `strategyWhitelister` to set. \n     * @param _withdrawalDelayBlocks The initial value of `withdrawalDelayBlocks` to set.\n     */\n    function initialize(address initialOwner, address initialStrategyWhitelister, IPauserRegistry _pauserRegistry, uint256 initialPausedStatus, uint256 _withdrawalDelayBlocks)\n        external\n        initializer\n    {\n        DOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"EigenLayer\")), ORIGINAL_CHAIN_ID, address(this)));\n        _initializePauser(_pauserRegistry, initialPausedStatus);\n        _transferOwnership(initialOwner);\n        _setStrategyWhitelister(initialStrategyWhitelister);\n        _setWithdrawalDelayBlocks(_withdrawalDelayBlocks);\n    }\n\n    /**\n     * @notice Deposits `amount` of beaconchain ETH into this contract on behalf of `staker`\n     * @param staker is the entity that is restaking in eigenlayer,\n     * @param amount is the amount of beaconchain ETH being restaked,\n     * @param amount is the amount of token to be deposited in the strategy by the depositor\n     * @dev Only callable by EigenPodManager.\n     */\n    function depositBeaconChainETH(address staker, uint256 amount)\n        external\n        onlyEigenPodManager\n        onlyWhenNotPaused(PAUSED_DEPOSITS)\n        onlyNotFrozen(staker)\n        nonReentrant\n    {\n        // add shares for the enshrined beacon chain ETH strategy\n        _addShares(staker, beaconChainETHStrategy, amount);\n    }\n\n    /**\n     * @notice Records an overcommitment event on behalf of a staker. The staker's beaconChainETH shares are decremented by `amount`.\n     * @param overcommittedPodOwner is the pod owner to be slashed\n     * @param beaconChainETHStrategyIndex is the index of the beaconChainETHStrategy in case it must be removed,\n     * @param amount is the amount to decrement the slashedAddress's beaconChainETHStrategy shares\n     * @dev Only callable by EigenPodManager.\n     */\n    function recordOvercommittedBeaconChainETH(address overcommittedPodOwner, uint256 beaconChainETHStrategyIndex, uint256 amount)\n        external\n        onlyEigenPodManager\n        nonReentrant\n    {\n        // get `overcommittedPodOwner`'s shares in the enshrined beacon chain ETH strategy\n        uint256 userShares = stakerStrategyShares[overcommittedPodOwner][beaconChainETHStrategy];\n        // if the amount exceeds the user's shares, then record it as an amount to be \"paid off\" when the user completes a withdrawal\n        if (amount > userShares) {\n            uint256 debt = amount - userShares;\n            beaconChainETHSharesToDecrementOnWithdrawal[overcommittedPodOwner] += debt;\n            amount -= debt;\n        }\n        // removes shares for the enshrined beacon chain ETH strategy\n        if (amount != 0) {\n            _removeShares(overcommittedPodOwner, beaconChainETHStrategyIndex, beaconChainETHStrategy, amount);            \n        }\n        // create array wrappers for call to DelegationManager\n        IStrategy[] memory strategies = new IStrategy[](1);\n        strategies[0] = beaconChainETHStrategy;\n        uint256[] memory shareAmounts = new uint256[](1);\n        shareAmounts[0] = amount;\n        // modify delegated shares accordingly, if applicable\n        delegation.decreaseDelegatedShares(overcommittedPodOwner, strategies, shareAmounts);\n    }\n\n    /**\n     * @notice Deposits `amount` of `token` into the specified `strategy`, with the resultant shares credited to `depositor`\n     * @param strategy is the specified strategy where deposit is to be made,\n     * @param token is the denomination in which the deposit is to be made,\n     * @param amount is the amount of token to be deposited in the strategy by the depositor\n     * @dev The `msg.sender` must have previously approved this contract to transfer at least `amount` of `token` on their behalf.\n     * @dev Cannot be called by an address that is 'frozen' (this function will revert if the `msg.sender` is frozen).\n     * \n     * WARNING: Depositing tokens that allow reentrancy (eg. ERC-777) into a strategy is not recommended.  This can lead to attack vectors\n     *          where the token balance and corresponding strategy shares are not in syncupon reentrancy.\n     */\n\n    function depositIntoStrategy(IStrategy strategy, IERC20 token, uint256 amount)\n        external\n        onlyWhenNotPaused(PAUSED_DEPOSITS)\n        onlyNotFrozen(msg.sender)\n        nonReentrant\n        returns (uint256 shares)\n    {\n        shares = _depositIntoStrategy(msg.sender, strategy, token, amount);\n    }\n\n    /**\n     * @notice Used for depositing an asset into the specified strategy with the resultant shared created to `staker`,\n     * who must sign off on the action\n     * @param strategy is the specified strategy where deposit is to be made,\n     * @param token is the denomination in which the deposit is to be made,\n     * @param amount is the amount of token to be deposited in the strategy by the depositor\n     * @param staker the staker that the assets will be deposited on behalf of\n     * @param expiry the timestamp at which the signature expires\n     * @param signature is a valid signature from the `staker`. either an ECDSA signature if the `staker` is an EOA, or data to forward\n     * following EIP-1271 if the `staker` is a contract\n     * @dev The `msg.sender` must have previously approved this contract to transfer at least `amount` of `token` on their behalf.\n     * @dev A signature is required for this function to eliminate the possibility of griefing attacks, specifically those\n     * targetting stakers who may be attempting to undelegate.\n     * @dev Cannot be called on behalf of a staker that is 'frozen' (this function will revert if the `staker` is frozen).\n     * \n     *  WARNING: Depositing tokens that allow reentrancy (eg. ERC-777) into a strategy is not recommended.  This can lead to attack vectors\n     *          where the token balance and corresponding strategy shares are not in syncupon reentrancy\n     */\n    function depositIntoStrategyWithSignature(\n        IStrategy strategy,\n        IERC20 token,\n        uint256 amount,\n        address staker,\n        uint256 expiry,\n        bytes memory signature\n    )\n        external\n        onlyWhenNotPaused(PAUSED_DEPOSITS)\n        onlyNotFrozen(staker)\n        nonReentrant\n        returns (uint256 shares)\n    {\n        require(\n            expiry >= block.timestamp,\n            \"StrategyManager.depositIntoStrategyWithSignature: signature expired\"\n        );\n        // calculate struct hash, then increment `staker`'s nonce\n        uint256 nonce = nonces[staker];\n        bytes32 structHash = keccak256(abi.encode(DEPOSIT_TYPEHASH, strategy, token, amount, nonce, expiry));\n        unchecked {\n            nonces[staker] = nonce + 1;\n        }\n\n        bytes32 digestHash;\n        //if chainid has changed, we must re-compute the domain separator\n        if (block.chainid != ORIGINAL_CHAIN_ID) {\n            bytes32 domain_separator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"EigenLayer\")), block.chainid, address(this)));\n            digestHash = keccak256(abi.encodePacked(\"\\x19\\x01\", domain_separator, structHash));\n        } else {\n            digestHash = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, structHash));\n        }\n\n\n        /**\n         * check validity of signature:\n         * 1) if `staker` is an EOA, then `signature` must be a valid ECSDA signature from `staker`,\n         * indicating their intention for this action\n         * 2) if `staker` is a contract, then `signature` must will be checked according to EIP-1271\n         */\n        if (Address.isContract(staker)) {\n            require(IERC1271(staker).isValidSignature(digestHash, signature) == ERC1271_MAGICVALUE,\n                \"StrategyManager.depositIntoStrategyWithSignature: ERC1271 signature verification failed\");\n        } else {\n            require(ECDSA.recover(digestHash, signature) == staker,\n                \"StrategyManager.depositIntoStrategyWithSignature: signature not from staker\");\n        }\n\n        shares = _depositIntoStrategy(staker, strategy, token, amount);\n    }\n\n    /**\n     * @notice Called by a staker to undelegate entirely from EigenLayer. The staker must first withdraw all of their existing deposits\n     * (through use of the `queueWithdrawal` function), or else otherwise have never deposited in EigenLayer prior to delegating.\n     */\n    function undelegate() external {\n        _undelegate(msg.sender);\n    }\n\n    /**\n     * @notice Called by a staker to queue a withdrawal of the given amount of `shares` from each of the respective given `strategies`.\n     * @dev Stakers will complete their withdrawal by calling the 'completeQueuedWithdrawal' function.\n     * User shares are decreased in this function, but the total number of shares in each strategy remains the same.\n     * The total number of shares is decremented in the 'completeQueuedWithdrawal' function instead, which is where\n     * the funds are actually sent to the user through use of the strategies' 'withdrawal' function. This ensures\n     * that the value per share reported by each strategy will remain consistent, and that the shares will continue\n     * to accrue gains during the enforced WITHDRAWAL_WAITING_PERIOD.\n     * @param strategyIndexes is a list of the indices in `stakerStrategyList[msg.sender]` that correspond to the strategies\n     * for which `msg.sender` is withdrawing 100% of their shares\n     * @param strategies The Strategies to withdraw from\n     * @param shares The amount of shares to withdraw from each of the respective Strategies in the `strategies` array\n     * @dev Strategies are removed from `stakerStrategyList` by swapping the last entry with the entry to be removed, then\n     * popping off the last entry in `stakerStrategyList`. The simplest way to calculate the correct `strategyIndexes` to input\n     * is to order the strategies *for which `msg.sender` is withdrawing 100% of their shares* from highest index in\n     * `stakerStrategyList` to lowest index\n     * @dev Note that if the withdrawal includes shares in the enshrined 'beaconChainETH' strategy, then it must *only* include shares in this strategy, and\n     * `withdrawer` must match the caller's address. The first condition is because slashing of queued withdrawals cannot be guaranteed \n     * for Beacon Chain ETH (since we cannot trigger a withdrawal from the beacon chain through a smart contract) and the second condition is because shares in\n     * the enshrined 'beaconChainETH' strategy technically represent non-fungible positions (deposits to the Beacon Chain, each pointed at a specific EigenPod).\n     */\n    function queueWithdrawal(\n        uint256[] calldata strategyIndexes,\n        IStrategy[] calldata strategies,\n        uint256[] calldata shares,\n        address withdrawer,\n        bool undelegateIfPossible\n    )\n        external\n        onlyWhenNotPaused(PAUSED_WITHDRAWALS)\n        onlyNotFrozen(msg.sender)\n        nonReentrant\n        returns (bytes32)\n    {\n        require(strategies.length == shares.length, \"StrategyManager.queueWithdrawal: input length mismatch\");\n        require(withdrawer != address(0), \"StrategyManager.queueWithdrawal: cannot withdraw to zero address\");\n    \n        // modify delegated shares accordingly, if applicable\n        delegation.decreaseDelegatedShares(msg.sender, strategies, shares);\n\n        uint96 nonce = uint96(numWithdrawalsQueued[msg.sender]);\n        \n        // keeps track of the current index in the `strategyIndexes` array\n        uint256 strategyIndexIndex;\n\n        /**\n         * Ensure that if the withdrawal includes beacon chain ETH, the specified 'withdrawer' is not different than the caller.\n         * This is because shares in the enshrined `beaconChainETHStrategy` ultimately represent tokens in **non-fungible** EigenPods,\n         * while other share in all other strategies represent purely fungible positions.\n         */\n        for (uint256 i = 0; i < strategies.length;) {\n            if (strategies[i] == beaconChainETHStrategy) {\n                require(withdrawer == msg.sender,\n                    \"StrategyManager.queueWithdrawal: cannot queue a withdrawal of Beacon Chain ETH to a different address\");\n                require(strategies.length == 1,\n                    \"StrategyManager.queueWithdrawal: cannot queue a withdrawal including Beacon Chain ETH and other tokens\");\n                require(shares[i] % GWEI_TO_WEI == 0,\n                    \"StrategyManager.queueWithdrawal: cannot queue a withdrawal of Beacon Chain ETH for an non-whole amount of gwei\");\n            }   \n\n            // the internal function will return 'true' in the event the strategy was\n            // removed from the depositor's array of strategies -- i.e. stakerStrategyList[depositor]\n            if (_removeShares(msg.sender, strategyIndexes[strategyIndexIndex], strategies[i], shares[i])) {\n                unchecked {\n                    ++strategyIndexIndex;\n                }\n            }\n\n            emit ShareWithdrawalQueued(msg.sender, nonce, strategies[i], shares[i]);\n\n            //increment the loop\n            unchecked {\n                ++i;\n            }\n        }\n\n        // fetch the address that the `msg.sender` is delegated to\n        address delegatedAddress = delegation.delegatedTo(msg.sender);\n\n        QueuedWithdrawal memory queuedWithdrawal;\n\n        {\n            WithdrawerAndNonce memory withdrawerAndNonce = WithdrawerAndNonce({\n                withdrawer: withdrawer,\n                nonce: nonce\n            });\n            // increment the numWithdrawalsQueued of the sender\n            unchecked {\n                numWithdrawalsQueued[msg.sender] = nonce + 1;\n            }\n\n            // copy arguments into struct and pull delegation info\n            queuedWithdrawal = QueuedWithdrawal({\n                strategies: strategies,\n                shares: shares,\n                depositor: msg.sender,\n                withdrawerAndNonce: withdrawerAndNonce,\n                withdrawalStartBlock: uint32(block.number),\n                delegatedAddress: delegatedAddress\n            });\n\n        }\n\n        // calculate the withdrawal root\n        bytes32 withdrawalRoot = calculateWithdrawalRoot(queuedWithdrawal);\n\n        // mark withdrawal as pending\n        withdrawalRootPending[withdrawalRoot] = true;\n\n        // If the `msg.sender` has withdrawn all of their funds from EigenLayer in this transaction, then they can choose to also undelegate\n        /**\n         * Checking that `stakerStrategyList[msg.sender].length == 0` is not strictly necessary here, but prevents reverting very late in logic,\n         * in the case that 'undelegate' is set to true but the `msg.sender` still has active deposits in EigenLayer.\n         */\n        if (undelegateIfPossible && stakerStrategyList[msg.sender].length == 0) {\n            _undelegate(msg.sender);\n        }\n\n        emit WithdrawalQueued(msg.sender, nonce, withdrawer, delegatedAddress, withdrawalRoot);\n\n        return withdrawalRoot;\n    }\n\n    /**\n     * @notice Used to complete the specified `queuedWithdrawal`. The function caller must match `queuedWithdrawal.withdrawer`\n     * @param queuedWithdrawal The QueuedWithdrawal to complete.\n     * @param tokens Array in which the i-th entry specifies the `token` input to the 'withdraw' function of the i-th Strategy in the `strategies` array\n     * of the `queuedWithdrawal`. This input can be provided with zero length if `receiveAsTokens` is set to 'false' (since in that case, this input will be unused)\n     * @param middlewareTimesIndex is the index in the operator that the staker who triggered the withdrawal was delegated to's middleware times array\n     * @param receiveAsTokens If true, the shares specified in the queued withdrawal will be withdrawn from the specified strategies themselves\n     * and sent to the caller, through calls to `queuedWithdrawal.strategies[i].withdraw`. If false, then the shares in the specified strategies\n     * will simply be transferred to the caller directly.\n     * @dev middlewareTimesIndex should be calculated off chain before calling this function by finding the first index that satisfies `slasher.canWithdraw`\n     */\n    function completeQueuedWithdrawal(QueuedWithdrawal calldata queuedWithdrawal, IERC20[] calldata tokens, uint256 middlewareTimesIndex, bool receiveAsTokens)\n        external\n        onlyWhenNotPaused(PAUSED_WITHDRAWALS)\n        // check that the address that the staker *was delegated to* – at the time that they queued the withdrawal – is not frozen\n        nonReentrant\n    {\n        _completeQueuedWithdrawal(queuedWithdrawal, tokens, middlewareTimesIndex, receiveAsTokens);\n    }\n\n    /**\n     * @notice Used to complete the specified `queuedWithdrawals`. The function caller must match `queuedWithdrawals[...].withdrawer`\n     * @dev Array-ified version of `completeQueuedWithdrawal`\n     * @dev middlewareTimesIndex should be calculated off chain before calling this function by finding the first index that satisfies `slasher.canWithdraw`\n     */\n    function completeQueuedWithdrawals(\n        QueuedWithdrawal[] calldata queuedWithdrawals,\n        IERC20[][] calldata tokens,\n        uint256[] calldata middlewareTimesIndexes,\n        bool[] calldata receiveAsTokens\n    ) external\n        onlyWhenNotPaused(PAUSED_WITHDRAWALS)\n        // check that the address that the staker *was delegated to* – at the time that they queued the withdrawal – is not frozen\n        nonReentrant\n    {\n        for(uint256 i = 0; i < queuedWithdrawals.length; i++) {\n            _completeQueuedWithdrawal(queuedWithdrawals[i], tokens[i], middlewareTimesIndexes[i], receiveAsTokens[i]);\n        }\n    }\n\n    /**\n     * @notice Slashes the shares of a 'frozen' operator (or a staker delegated to one)\n     * @param slashedAddress is the frozen address that is having its shares slashed\n     * @param strategyIndexes is a list of the indices in `stakerStrategyList[msg.sender]` that correspond to the strategies\n     * for which `msg.sender` is withdrawing 100% of their shares\n     * @param recipient The slashed funds are withdrawn as tokens to this address.\n     * @dev strategies are removed from `stakerStrategyList` by swapping the last entry with the entry to be removed, then\n     * popping off the last entry in `stakerStrategyList`. The simplest way to calculate the correct `strategyIndexes` to input\n     * is to order the strategies *for which `msg.sender` is withdrawing 100% of their shares* from highest index in\n     * `stakerStrategyList` to lowest index\n     */\n    function slashShares(\n        address slashedAddress,\n        address recipient,\n        IStrategy[] calldata strategies,\n        IERC20[] calldata tokens,\n        uint256[] calldata strategyIndexes,\n        uint256[] calldata shareAmounts\n    )\n        external\n        onlyOwner\n        onlyFrozen(slashedAddress)\n        nonReentrant\n    {\n        require(tokens.length == strategies.length, \"StrategyManager.slashShares: input length mismatch\");\n        uint256 strategyIndexIndex;\n        uint256 strategiesLength = strategies.length;\n        for (uint256 i = 0; i < strategiesLength;) {\n            // the internal function will return 'true' in the event the strategy was\n            // removed from the slashedAddress's array of strategies -- i.e. stakerStrategyList[slashedAddress]\n            if (_removeShares(slashedAddress, strategyIndexes[strategyIndexIndex], strategies[i], shareAmounts[i])) {\n                unchecked {\n                    ++strategyIndexIndex;\n                }\n            }\n\n            if (strategies[i] == beaconChainETHStrategy) {\n                 //withdraw the beaconChainETH to the recipient\n                _withdrawBeaconChainETH(slashedAddress, recipient, shareAmounts[i]);\n            }\n            else {\n                // withdraw the shares and send funds to the recipient\n                strategies[i].withdraw(recipient, tokens[i], shareAmounts[i]);\n            }\n\n            // increment the loop\n            unchecked {\n                ++i;\n            }\n        }\n\n        // modify delegated shares accordingly, if applicable\n        delegation.decreaseDelegatedShares(slashedAddress, strategies, shareAmounts);\n    }\n    \n    /**\n     * @notice Slashes an existing queued withdrawal that was created by a 'frozen' operator (or a staker delegated to one)\n     * @param recipient The funds in the slashed withdrawal are withdrawn as tokens to this address.\n     * @param queuedWithdrawal The previously queued withdrawal to be slashed\n     * @param tokens Array in which the i-th entry specifies the `token` input to the 'withdraw' function of the i-th Strategy in the `strategies`\n     * array of the `queuedWithdrawal`.\n     * @param indicesToSkip Optional input parameter -- indices in the `strategies` array to skip (i.e. not call the 'withdraw' function on). This input exists\n     * so that, e.g., if the slashed QueuedWithdrawal contains a malicious strategy in the `strategies` array which always reverts on calls to its 'withdraw' function,\n     * then the malicious strategy can be skipped (with the shares in effect \"burned\"), while the non-malicious strategies are still called as normal.\n     */\n    function slashQueuedWithdrawal(address recipient, QueuedWithdrawal calldata queuedWithdrawal, IERC20[] calldata tokens, uint256[] calldata indicesToSkip)\n        external\n        onlyOwner\n        onlyFrozen(queuedWithdrawal.delegatedAddress)\n        nonReentrant\n    {\n        require(tokens.length == queuedWithdrawal.strategies.length, \"StrategyManager.slashQueuedWithdrawal: input length mismatch\");\n\n        // find the withdrawalRoot\n        bytes32 withdrawalRoot = calculateWithdrawalRoot(queuedWithdrawal);\n\n        // verify that the queued withdrawal is pending\n        require(\n            withdrawalRootPending[withdrawalRoot],\n            \"StrategyManager.slashQueuedWithdrawal: withdrawal is not pending\"\n        );\n\n        // reset the storage slot in mapping of queued withdrawals\n        withdrawalRootPending[withdrawalRoot] = false;\n\n        // keeps track of the index in the `indicesToSkip` array\n        uint256 indicesToSkipIndex = 0;\n\n        uint256 strategiesLength = queuedWithdrawal.strategies.length;\n        for (uint256 i = 0; i < strategiesLength;) {\n            // check if the index i matches one of the indices specified in the `indicesToSkip` array\n            if (indicesToSkipIndex < indicesToSkip.length && indicesToSkip[indicesToSkipIndex] == i) {\n                unchecked {\n                    ++indicesToSkipIndex;\n                }\n            } else {\n                if (queuedWithdrawal.strategies[i] == beaconChainETHStrategy){\n                     //withdraw the beaconChainETH to the recipient\n                    _withdrawBeaconChainETH(queuedWithdrawal.depositor, recipient, queuedWithdrawal.shares[i]);\n                } else {\n                    // tell the strategy to send the appropriate amount of funds to the recipient\n                    queuedWithdrawal.strategies[i].withdraw(recipient, tokens[i], queuedWithdrawal.shares[i]);\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n\n    /// @notice Owner-only function for modifying the value of the `withdrawalDelayBlocks` variable.\n    function setWithdrawalDelayBlocks(uint256 _withdrawalDelayBlocks) external onlyOwner {\n        _setWithdrawalDelayBlocks(_withdrawalDelayBlocks);\n    }\n\n    /// @notice Owner-only function to change the `strategyWhitelister` address.\n    function setStrategyWhitelister(address newStrategyWhitelister) external onlyOwner {\n        _setStrategyWhitelister(newStrategyWhitelister);\n    }\n\n    /// @notice Owner-only function that adds the provided Strategies to the 'whitelist' of strategies that stakers can deposit into\n    function addStrategiesToDepositWhitelist(IStrategy[] calldata strategiesToWhitelist) external onlyStrategyWhitelister {\n        uint256 strategiesToWhitelistLength = strategiesToWhitelist.length;\n        for (uint256 i = 0; i < strategiesToWhitelistLength;) {\n            // change storage and emit event only if strategy is not already in whitelist\n            if (!strategyIsWhitelistedForDeposit[strategiesToWhitelist[i]]) {\n                strategyIsWhitelistedForDeposit[strategiesToWhitelist[i]] = true;\n                emit StrategyAddedToDepositWhitelist(strategiesToWhitelist[i]);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    } \n\n    /// @notice Owner-only function that removes the provided Strategies from the 'whitelist' of strategies that stakers can deposit into\n    function removeStrategiesFromDepositWhitelist(IStrategy[] calldata strategiesToRemoveFromWhitelist) external onlyStrategyWhitelister {\n        uint256 strategiesToRemoveFromWhitelistLength = strategiesToRemoveFromWhitelist.length;\n        for (uint256 i = 0; i < strategiesToRemoveFromWhitelistLength;) {\n            // change storage and emit event only if strategy is already in whitelist\n            if (strategyIsWhitelistedForDeposit[strategiesToRemoveFromWhitelist[i]]) {\n                strategyIsWhitelistedForDeposit[strategiesToRemoveFromWhitelist[i]] = false;\n                emit StrategyRemovedFromDepositWhitelist(strategiesToRemoveFromWhitelist[i]);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    } \n\n    // INTERNAL FUNCTIONS\n\n    /**\n     * @notice This function adds `shares` for a given `strategy` to the `depositor` and runs through the necessary update logic.\n     * @dev In particular, this function calls `delegation.increaseDelegatedShares(depositor, strategy, shares)` to ensure that all\n     * delegated shares are tracked, increases the stored share amount in `stakerStrategyShares[depositor][strategy]`, and adds `strategy`\n     * to the `depositor`'s list of strategies, if it is not in the list already.\n     */\n    function _addShares(address depositor, IStrategy strategy, uint256 shares) internal {\n        // sanity checks on inputs\n        require(depositor != address(0), \"StrategyManager._addShares: depositor cannot be zero address\");\n        require(shares != 0, \"StrategyManager._addShares: shares should not be zero!\");"
    }
  ]
}