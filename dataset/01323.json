{
  "Title": "Silent failure can occur in `Pipeline` function calls if the target has no code",
  "Content": "**Description:** In the case of a `Pipeline` function call to a target address with no code, the call will silently fail. Scenarios where this may occur include calls to non-contract addresses or on a contract where its self-destruction occurs beforehand. This is most relevant when considering [`Pipeline::advancedPipe`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/pipeline/Pipeline.sol#L91) given that the next call uses as input the return from the previous call which may lead to an undesired final result or revert. Pipeline can be used standalone but it is also wrapped by Beanstalk for use within the protocol by the [DepotFacet](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/DepotFacet.sol#L15-L16).\n\n**Impact:** Silent failure of a call to an address with no code produces a silent failure within Pipeline, which can lead to undesired final outcomes. According to the [Pipeline Whitepaper](https://evmpipeline.org/pipeline.pdf):\n>The combination of Pipeline, Depot and Clipboard allows EVM users to perform arbitrary validations, through arbitrarily many protocols, in a single transaction.\n\nThis implies that Pipeline should be able to be used with any protocol; therefore, the edge case must be considered where a call to a contract that has just been self-destructed should revert. Considering the low likelihood, this issue is determined to be of **LOW** severity.\n\n**Recommended Mitigation:** If `Pipeline` is intended to support calls to EOA, and to prevent silent failure to this kind of address, an extra attribute `isContractCall` can be added to `PipeCall` and `AdvancedPipeCall` - if the call return data size is zero, and this value is true, then it should be checked whether the call was performed on a target contract, and if not then revert.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/pipeline/Pipeline.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/IPipeline.sol\";\nimport \"../libraries/LibFunction.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721Holder.sol\";\n\n/**\n * @title Pipeline\n * @author Publius\n * @notice Pipeline creates a sandbox to execute any series of function calls on any series of protocols through Pipe functions.\n * Any assets left in Pipeline between transactions can be transferred out by any account.\n * Users Pipe a series of PipeCalls that each execute a function call to another protocol through Pipeline.\n * https://evmpipeline.org\n **/\n\ncontract Pipeline is IPipeline, ERC1155Holder, ERC721Holder {\n    /**\n     * @notice Execute a single PipeCall.\n     * Supports sending Ether through msg.value\n     * @param p PipeCall to execute\n     * @return result return value of PipeCall\n    **/\n    function pipe(PipeCall calldata p)\n        external\n        payable\n        override\n        returns (bytes memory result)\n    {\n        result = _pipe(p.target, p.data, msg.value);\n    }\n    \n    /**\n     * @notice Execute a list of executes a list of PipeCalls.\n     * @param pipes list of PipeCalls to execute\n     * @return results list of return values for each PipeCall\n    **/\n    function multiPipe(PipeCall[] calldata pipes)\n        external\n        payable\n        override\n        returns (bytes[] memory results)\n    {\n        results = new bytes[](pipes.length);\n        for (uint256 i = 0; i < pipes.length; i++) {\n            results[i] = _pipe(pipes[i].target, pipes[i].data, 0);\n        }\n    }\n\n    /**\n     * @notice Execute a list of AdvancedPipeCalls.\n     * @param pipes list of AdvancedPipeCalls to execute\n     * @return results list of return values for each AdvancedPipeCalls\n    **/\n    function advancedPipe(AdvancedPipeCall[] calldata pipes)\n        external\n        payable\n        override\n        returns (bytes[] memory results) {\n            results = new bytes[](pipes.length);\n            for (uint256 i = 0; i < pipes.length; ++i) {\n                results[i] = _advancedPipe(pipes[i], results);\n            }\n        }\n\n    // Execute function call using calldata\n    function _pipe(\n        address target,\n        bytes calldata data,\n        uint256 value\n    ) private returns (bytes memory result) {\n        bool success;\n        (success, result) = target.call{value: value}(data);\n        LibFunction.checkReturn(success, result);\n    }\n\n    // Execute function call using memory\n    function _pipeMem(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) private returns (bytes memory result) {\n        bool success;\n        (success, result) = target.call{value: value}(data);\n        LibFunction.checkReturn(success, result);\n    }\n\n    // Execute an AdvancedPipeCall\n    function _advancedPipe(\n        AdvancedPipeCall calldata p,\n        bytes[] memory returnData\n    ) private returns (bytes memory result) {\n        uint256 value = getEthValue(p.clipboard);\n        // 0x00 -> Normal pipe: Standard function call\n        // else > Advanced pipe: Copy return data into function call through buildAdvancedCalldata\n        if (p.clipboard[0] == 0x00) {\n            result = _pipe(p.target, p.callData, value);\n        } else {\n            result = LibFunction.useClipboard(p.callData, p.clipboard, returnData);\n            result = _pipeMem(p.target, result, value);\n        }\n    }\n\n    // Extracts Ether value from a Clipboard\n    // clipboard[1] indicates whether there is an Ether value in the advanced data\n    // if 0x00 -> No Ether value, return 0\n    // else -> return the last 32 bytes of clipboard\n    function getEthValue(bytes calldata clipboard) private pure returns (uint256 value) {\n        if (clipboard[1] == 0x00) return 0;\n        assembly { value := calldataload(sub(add(clipboard.offset, clipboard.length), 32))}\n    }\n}"
    }
  ]
}