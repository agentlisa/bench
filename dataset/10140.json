{
  "Title": "[H-03] Last person to withdraw his tokens might not be able to do this, in Crowdsale (edge case)",
  "Content": "_Submitted by gpersoon_.\n\n#### Impact\n\nSuppose a Crowdsale is successful and enough commitments are made before the `marketInfo.endTime`.\nSuppose marketStatus.commitmentsTotal  == marketInfo.totalTokens -1      // note this is an edge case, but can be constructed by an attacker\nThen the function `auctionEnded()` returns true\nAssume `auctionSuccessful()` is also true (might depend on the config of `marketPrice.goal` and `marketInfo.totalTokens`)\nThen an admin can call `finalize()` to finalize the Crowdsale.\nThe function finalize distributes the funds and the unsold tokens and sets `status.finalized = true` so that finalized cannot be called again.\nNow we have \"marketInfo.totalTokens -1\" tokens left in the contract\n\nHowever `commitEth()` or `commitTokens()` can still be called (they give no error message that the auction has ended)\nThen functions call `calculateCommitment`, which luckily prevent from buying too much, however 1 token can still be bought\nThese functions also call `\\_addCommitment()`, which only checks for `marketInfo.endTime`, which hasn't passed yet.\n\nNow an extra token is sold and the contract has 1 token short. So the last person to withdraw his tokens cannot withdraw them (because you cannot specify how much you want to withdraw)\n\nAlso the revenues for the last token cannot be retrieved as `finalize()` cannot be called again.\n\n#### Proof of Concept\n\n<https://github.com/sushiswap/miso/blob/master/contracts/Auctions/Crowdsale.sol#L374>\n\n```js\n function finalize() public nonReentrant {\n        require(hasAdminRole(msg.sender) || wallet == msg.sender || hasSmartContractRole(msg.sender) || finalizeTimeExpired(),\"Crowdsale: sender must be an admin\"); // can be called by admin\n        MarketStatus storage status = marketStatus;\n        require(!status.finalized, \"Crowdsale: already finalized\");\n        MarketInfo storage info = marketInfo;\n        require(auctionEnded(), \"Crowdsale: Has not finished yet\");    // is true if enough sold, even if this is before marketInfo.endTime\n\n        if (auctionSuccessful()) {          \n            /// @dev Transfer contributed tokens to wallet.\n            /// @dev Transfer unsold tokens to wallet.\n        } else {\n            /// @dev Return auction tokens back to wallet.\n        }\n        status.finalized = true;\n\nfunction auctionEnded() public view returns (bool) {\n        return block.timestamp > uint256(marketInfo.endTime) || \n        _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) >= uint256(marketInfo.totalTokens); // is true if enough sold, even if this is before marketInfo.endTime\n    }\n\nfunction auctionSuccessful() public view returns (bool) {\n        return uint256(marketStatus.commitmentsTotal) >= uint256(marketPrice.goal);\n}\n\nfunction commitEth(address payable _beneficiary, bool readAndAgreedToMarketParticipationAgreement ) public payable nonReentrant  {\n       ...\n        uint256 ethToTransfer = calculateCommitment(msg.value);\n       ...\n       _addCommitment(_beneficiary, ethToTransfer);\n   \n function calculateCommitment(uint256 _commitment) public view returns (uint256 committed) { // this prevents buying too much\n        uint256 tokens = _getTokenAmount(_commitment);\n        uint256 tokensCommited =_getTokenAmount(uint256(marketStatus.commitmentsTotal));\n        if ( tokensCommited.add(tokens) > uint256(marketInfo.totalTokens)) {\n            return _getTokenPrice(uint256(marketInfo.totalTokens).sub(tokensCommited));\n        }\n        return _commitment;\n    }\n\nfunction _addCommitment(address _addr, uint256 _commitment) internal {\n        require(block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), \"Crowdsale: outside auction hours\"); // doesn't check auctionEnded() nor status.finalized\n        ...\n        uint256 newCommitment = commitments[_addr].add(_commitment);\n        ...\n        commitments[_addr] = newCommitment;\n\nfunction withdrawTokens(address payable beneficiary) public   nonReentrant  {    \n        if (auctionSuccessful()) {\n            ...\n            uint256 tokensToClaim = tokensClaimable(beneficiary);\n            ...\n            claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);\n            _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);    // will fail is last token is missing\n        } else {\n\n\n\n## Tools Used\n\n## Recommended Mitigation Steps\nIn the function _addCommitment, add a check on auctionEnded() or status.finalized\n```\n\n**[Clearwood (Sushi Miso) confirmed and patched](https://github.com/code-423n4/2021-09-sushimiso-findings/issues/15#issuecomment-934641167):**\n > https://github.com/sushiswap/miso/pull/20\n\n\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-09-sushimiso",
  "Code": [
    {
      "filename": "contracts/Auctions/Crowdsale.sol",
      "content": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n//----------------------------------------------------------------------------------\n//    I n s t a n t\n//\n//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  \n//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.\n//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:\n//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'\n//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  \n//\n//----------------------------------------------------------------------------------\n//\n// Chef Gonpachi's Crowdsale\n//\n// A fixed price token swap contract. \n//\n// Inspired by the Open Zeppelin crowsdale and delta.financial\n// https://github.com/OpenZeppelin/openzeppelin-contracts\n// \n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// The above copyright notice and this permission notice shall be included \n// in all copies or substantial portions of the Software.\n//\n// Made for Sushi.com \n// \n// Enjoy. (c) Chef Gonpachi, Kusatoshi, SSMikazu 2021 \n// <https://github.com/chefgonpachi/MISO/>\n//\n// ---------------------------------------------------------------------\n// SPDX-License-Identifier: GPL-3.0                        \n// ---------------------------------------------------------------------\n\nimport \"../OpenZeppelin/utils/ReentrancyGuard.sol\";\nimport \"../Access/MISOAccessControls.sol\";\nimport \"../Utils/SafeTransfer.sol\";\nimport \"../Utils/BoringBatchable.sol\";\nimport \"../Utils/BoringERC20.sol\";\nimport \"../Utils/BoringMath.sol\";\nimport \"../Utils/Documents.sol\";\nimport \"../interfaces/IPointList.sol\";\nimport \"../interfaces/IMisoMarket.sol\";\n\n\ncontract Crowdsale is IMisoMarket, MISOAccessControls, BoringBatchable, SafeTransfer, Documents , ReentrancyGuard  {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringMath64 for uint64;\n    using BoringERC20 for IERC20;\n\n    /// @notice MISOMarket template id for the factory contract.\n    /// @dev For different marketplace types, this must be incremented.\n    uint256 public constant override marketTemplate = 1;\n\n    /// @notice The placeholder ETH address.\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice The decimals of the auction token.\n    uint256 private constant AUCTION_TOKEN_DECIMAL_PLACES = 18;\n    uint256 private constant AUCTION_TOKEN_DECIMALS = 10 ** AUCTION_TOKEN_DECIMAL_PLACES;\n\n    /** \n    * @notice rate - How many token units a buyer gets per token or wei.\n    * The rate is the conversion between wei and the smallest and indivisible token unit.\n    * So, if you are using a rate of 1 with a ERC20Detailed token with 3 decimals called TOK\n    * 1 wei will give you 1 unit, or 0.001 TOK.\n    */\n    /// @notice goal - Minimum amount of funds to be raised in weis or tokens.\n    struct MarketPrice {\n        uint128 rate;\n        uint128 goal; \n    }\n    MarketPrice public marketPrice;\n\n    /// @notice Starting time of crowdsale.\n    /// @notice Ending time of crowdsale.\n    /// @notice Total number of tokens to sell.\n    struct MarketInfo {\n        uint64 startTime;\n        uint64 endTime; \n        uint128 totalTokens;\n    }\n    MarketInfo public marketInfo;\n\n    /// @notice Amount of wei raised.\n    /// @notice Whether crowdsale has been initialized or not.\n    /// @notice Whether crowdsale has been finalized or not.\n    struct MarketStatus {\n        uint128 commitmentsTotal;\n        bool finalized;\n        bool usePointList;\n    }\n    MarketStatus public marketStatus;\n\n    /// @notice The token being sold.\n    address public auctionToken;\n    /// @notice Address where funds are collected.\n    address payable public wallet;\n    /// @notice The currency the crowdsale accepts for payment. Can be ETH or token address.\n    address public paymentCurrency;\n    /// @notice Address that manages auction approvals.\n    address public pointList;\n\n    /// @notice The commited amount of accounts.\n    mapping(address => uint256) public commitments;\n    /// @notice Amount of tokens to claim per address.\n    mapping(address => uint256) public claimed;\n\n    /// @notice Event for updating auction times.  Needs to be before auction starts.\n    event AuctionTimeUpdated(uint256 startTime, uint256 endTime); \n    /// @notice Event for updating auction prices. Needs to be before auction starts.\n    event AuctionPriceUpdated(uint256 rate, uint256 goal); \n    /// @notice Event for updating auction wallet. Needs to be before auction starts.\n    event AuctionWalletUpdated(address wallet); \n\n    /// @notice Event for adding a commitment.\n    event AddedCommitment(address addr, uint256 commitment);\n    \n    /// @notice Event for finalization of the crowdsale\n    event AuctionFinalized();\n    /// @notice Event for cancellation of the auction.\n    event AuctionCancelled();\n\n    /**\n     * @notice Initializes main contract variables and transfers funds for the sale.\n     * @dev Init function.\n     * @param _funder The address that funds the token for crowdsale.\n     * @param _token Address of the token being sold.\n     * @param _paymentCurrency The currency the crowdsale accepts for payment. Can be ETH or token address.\n     * @param _totalTokens The total number of tokens to sell in crowdsale.\n     * @param _startTime Crowdsale start time.\n     * @param _endTime Crowdsale end time.\n     * @param _rate Number of token units a buyer gets per wei or token.\n     * @param _goal Minimum amount of funds to be raised in weis or tokens.\n     * @param _admin Address that can finalize auction.\n     * @param _pointList Address that will manage auction approvals.\n     * @param _wallet Address where collected funds will be forwarded to.\n     */\n    function initCrowdsale(\n        address _funder,\n        address _token,\n        address _paymentCurrency,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _rate,\n        uint256 _goal,\n        address _admin,\n        address _pointList,\n        address payable _wallet\n    ) public {\n        require(_endTime < 10000000000, \"Crowdsale: enter an unix timestamp in seconds, not miliseconds\");\n        require(_startTime >= block.timestamp, \"Crowdsale: start time is before current time\");\n        require(_endTime > _startTime, \"Crowdsale: start time is not before end time\");\n        require(_rate > 0, \"Crowdsale: rate is 0\");\n        require(_wallet != address(0), \"Crowdsale: wallet is the zero address\");\n        require(_admin != address(0), \"Crowdsale: admin is the zero address\");\n        require(_totalTokens > 0, \"Crowdsale: total tokens is 0\");\n        require(_goal > 0, \"Crowdsale: goal is 0\");\n        require(IERC20(_token).decimals() == AUCTION_TOKEN_DECIMAL_PLACES, \"Crowdsale: Token does not have 18 decimals\");\n        if (_paymentCurrency != ETH_ADDRESS) {\n            require(IERC20(_paymentCurrency).decimals() > 0, \"Crowdsale: Payment currency is not ERC20\");\n        }\n\n        marketPrice.rate = BoringMath.to128(_rate);\n        marketPrice.goal = BoringMath.to128(_goal);\n\n        marketInfo.startTime = BoringMath.to64(_startTime);\n        marketInfo.endTime = BoringMath.to64(_endTime);\n        marketInfo.totalTokens = BoringMath.to128(_totalTokens);\n\n        auctionToken = _token;\n        paymentCurrency = _paymentCurrency;\n        wallet = _wallet;\n\n        initAccessControls(_admin);\n\n        _setList(_pointList);\n        \n        require(_getTokenAmount(_goal) <= _totalTokens, \"Crowdsale: goal should be equal to or lower than total tokens\");\n\n        _safeTransferFrom(_token, _funder, _totalTokens);\n    }\n\n\n    ///--------------------------------------------------------\n    /// Commit to buying tokens!\n    ///--------------------------------------------------------\n\n    receive() external payable {\n        revertBecauseUserDidNotProvideAgreement();\n    }\n\n    /** \n     * @dev Attribution to the awesome delta.financial contracts\n    */  \n    function marketParticipationAgreement() public pure returns (string memory) {\n        return \"I understand that I am interacting with a smart contract. I understand that tokens commited are subject to the token issuer and local laws where applicable. I reviewed code of the smart contract and understand it fully. I agree to not hold developers or other people associated with the project liable for any losses or misunderstandings\";\n    }\n    /** \n     * @dev Not using modifiers is a purposeful choice for code readability.\n    */ \n    function revertBecauseUserDidNotProvideAgreement() internal pure {\n        revert(\"No agreement provided, please review the smart contract before interacting with it\");\n    }\n\n    /**\n     * @notice Checks the amount of ETH to commit and adds the commitment. Refunds the buyer if commit is too high.\n     * @dev low level token purchase with ETH ***DO NOT OVERRIDE***\n     * This function has a non-reentrancy guard, so it should not be called by\n     * another `nonReentrant` function.\n     * @param _beneficiary Recipient of the token purchase.\n     */\n    function commitEth(\n        address payable _beneficiary,\n        bool readAndAgreedToMarketParticipationAgreement\n    ) \n        public payable   nonReentrant    \n    {\n        require(paymentCurrency == ETH_ADDRESS, \"Crowdsale: Payment currency is not ETH\"); \n        if(readAndAgreedToMarketParticipationAgreement == false) {\n            revertBecauseUserDidNotProvideAgreement();\n        }\n\n        /// @dev Get ETH able to be committed.\n        uint256 ethToTransfer = calculateCommitment(msg.value);\n\n        /// @dev Accept ETH Payments.\n        uint256 ethToRefund = msg.value.sub(ethToTransfer);\n        if (ethToTransfer > 0) {\n            _addCommitment(_beneficiary, ethToTransfer);\n        }\n\n        /// @dev Return any ETH to be refunded.\n        if (ethToRefund > 0) {\n            _beneficiary.transfer(ethToRefund);\n        }\n\n        /// @notice Revert if commitmentsTotal exceeds the balance\n        require(marketStatus.commitmentsTotal <= address(this).balance, \"CrowdSale: The committed ETH exceeds the balance\");\n    }\n\n    /**\n     * @notice Buy Tokens by commiting approved ERC20 tokens to this contract address.\n     * @param _amount Amount of tokens to commit.\n     */\n    function commitTokens(uint256 _amount, bool readAndAgreedToMarketParticipationAgreement) public {\n        commitTokensFrom(msg.sender, _amount, readAndAgreedToMarketParticipationAgreement);\n    }\n\n    /**\n     * @notice Checks how much is user able to commit and processes that commitment.\n     * @dev Users must approve contract prior to committing tokens to auction.\n     * @param _from User ERC20 address.\n     * @param _amount Amount of approved ERC20 tokens.\n     */\n    function commitTokensFrom(\n        address _from,\n        uint256 _amount,\n        bool readAndAgreedToMarketParticipationAgreement\n    ) \n        public   nonReentrant  \n    {\n        require(address(paymentCurrency) != ETH_ADDRESS, \"Crowdsale: Payment currency is not a token\");\n        if(readAndAgreedToMarketParticipationAgreement == false) {\n            revertBecauseUserDidNotProvideAgreement();\n        }\n        uint256 tokensToTransfer = calculateCommitment(_amount);\n        if (tokensToTransfer > 0) {\n            _safeTransferFrom(paymentCurrency, msg.sender, tokensToTransfer);\n            _addCommitment(_from, tokensToTransfer);\n        }\n    }\n\n    /**\n     * @notice Checks if the commitment does not exceed the goal of this sale.\n     * @param _commitment Number of tokens to be commited.\n     * @return committed The amount able to be purchased during a sale.\n     */\n    function calculateCommitment(uint256 _commitment)\n        public\n        view\n        returns (uint256 committed)\n    {\n        uint256 tokens = _getTokenAmount(_commitment);\n        uint256 tokensCommited =_getTokenAmount(uint256(marketStatus.commitmentsTotal));\n        if ( tokensCommited.add(tokens) > uint256(marketInfo.totalTokens)) {\n            return _getTokenPrice(uint256(marketInfo.totalTokens).sub(tokensCommited));\n        }\n        return _commitment;\n    }\n\n    /**\n     * @notice Updates commitment of the buyer and the amount raised, emits an event.\n     * @param _addr Recipient of the token purchase.\n     * @param _commitment Value in wei or token involved in the purchase.\n     */\n    function _addCommitment(address _addr, uint256 _commitment) internal {\n        require(block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), \"Crowdsale: outside auction hours\");\n        require(_addr != address(0), \"Crowdsale: beneficiary is the zero address\");\n        require(!marketStatus.finalized, \"CrowdSale: Auction is finalized\");\n        uint256 newCommitment = commitments[_addr].add(_commitment);\n        if (marketStatus.usePointList) {\n            require(IPointList(pointList).hasPoints(_addr, newCommitment));\n        }\n\n        commitments[_addr] = newCommitment;\n\n        /// @dev Update state.\n        marketStatus.commitmentsTotal = BoringMath.to128(uint256(marketStatus.commitmentsTotal).add(_commitment));\n\n        emit AddedCommitment(_addr, _commitment);\n    }\n\n    function withdrawTokens() public  {\n        withdrawTokens(msg.sender);\n    }\n\n    /**\n     * @notice Withdraws bought tokens, or returns commitment if the sale is unsuccessful.\n     * @dev Withdraw tokens only after crowdsale ends.\n     * @param beneficiary Whose tokens will be withdrawn.\n     */\n    function withdrawTokens(address payable beneficiary) public   nonReentrant  {    \n        if (auctionSuccessful()) {\n            require(marketStatus.finalized, \"Crowdsale: not finalized\");\n            /// @dev Successful auction! Transfer claimed tokens.\n            uint256 tokensToClaim = tokensClaimable(beneficiary);\n            require(tokensToClaim > 0, \"Crowdsale: no tokens to claim\"); \n            claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);\n            _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);\n        } else {\n            /// @dev Auction did not meet reserve price.\n            /// @dev Return committed funds back to user.\n            require(block.timestamp > uint256(marketInfo.endTime), \"Crowdsale: auction has not finished yet\");\n            uint256 accountBalance = commitments[beneficiary];\n            commitments[beneficiary] = 0; // Stop multiple withdrawals and free some gas\n            _safeTokenPayment(paymentCurrency, beneficiary, accountBalance);\n        }\n    }\n\n    /**\n     * @notice Adjusts users commitment depending on amount already claimed and unclaimed tokens left.\n     * @return claimerCommitment How many tokens the user is able to claim.\n     */\n    function tokensClaimable(address _user) public view returns (uint256 claimerCommitment) {\n        uint256 unclaimedTokens = IERC20(auctionToken).balanceOf(address(this));\n        claimerCommitment = _getTokenAmount(commitments[_user]);\n        claimerCommitment = claimerCommitment.sub(claimed[_user]);\n\n        if(claimerCommitment > unclaimedTokens){\n            claimerCommitment = unclaimedTokens;\n        }\n    }\n    \n    //--------------------------------------------------------\n    // Finalize Auction\n    //--------------------------------------------------------\n    \n    /**\n     * @notice Manually finalizes the Crowdsale.\n     * @dev Must be called after crowdsale ends, to do some extra finalization work.\n     * Calls the contracts finalization function.\n     */\n    function finalize() public nonReentrant {\n        require(            \n            hasAdminRole(msg.sender) \n            || wallet == msg.sender\n            || hasSmartContractRole(msg.sender) \n            || finalizeTimeExpired(),\n            \"Crowdsale: sender must be an admin\"\n        );\n        MarketStatus storage status = marketStatus;\n        require(!status.finalized, \"Crowdsale: already finalized\");\n        MarketInfo storage info = marketInfo;\n        require(info.totalTokens > 0, \"Not initialized\");\n        require(auctionEnded(), \"Crowdsale: Has not finished yet\"); \n\n        if (auctionSuccessful()) {\n            /// @dev Successful auction\n            /// @dev Transfer contributed tokens to wallet.\n            _safeTokenPayment(paymentCurrency, wallet, uint256(status.commitmentsTotal));\n            /// @dev Transfer unsold tokens to wallet.\n            uint256 soldTokens = _getTokenAmount(uint256(status.commitmentsTotal));\n            uint256 unsoldTokens = uint256(info.totalTokens).sub(soldTokens);\n            if(unsoldTokens > 0) {\n                _safeTokenPayment(auctionToken, wallet, unsoldTokens);\n            }\n        } else {\n            /// @dev Failed auction\n            /// @dev Return auction tokens back to wallet.\n            _safeTokenPayment(auctionToken, wallet, uint256(info.totalTokens));\n        }\n\n        status.finalized = true;\n\n        emit AuctionFinalized();\n    }\n\n    /**\n     * @notice Cancel Auction\n     * @dev Admin can cancel the auction before it starts\n     */\n    function cancelAuction() public   nonReentrant  \n    {\n        require(hasAdminRole(msg.sender));\n        MarketStatus storage status = marketStatus;\n        require(!status.finalized, \"Crowdsale: already finalized\");\n        require( uint256(status.commitmentsTotal) == 0, \"Crowdsale: Funds already raised\" );\n\n        _safeTokenPayment(auctionToken, wallet, uint256(marketInfo.totalTokens));\n\n        status.finalized = true;\n        emit AuctionCancelled();\n    }\n\n    function tokenPrice() public view returns (uint256) {\n        return uint256(marketPrice.rate); \n    }\n\n    function _getTokenPrice(uint256 _amount) internal view returns (uint256) {\n        return _amount.mul(uint256(marketPrice.rate)).div(AUCTION_TOKEN_DECIMALS);   \n    }\n\n    function getTokenAmount(uint256 _amount) public view returns (uint256) {\n        return _getTokenAmount(_amount);\n    }\n\n    /**\n     * @notice Calculates the number of tokens to purchase.\n     * @dev Override to extend the way in which ether is converted to tokens.\n     * @param _amount Value in wei or token to be converted into tokens.\n     * @return tokenAmount Number of tokens that can be purchased with the specified amount.\n     */\n    function _getTokenAmount(uint256 _amount) internal view returns (uint256) {\n        return _amount.mul(AUCTION_TOKEN_DECIMALS).div(uint256(marketPrice.rate));\n    }\n\n    /**\n     * @notice Checks if the sale is open.\n     * @return isOpen True if the crowdsale is open, false otherwise.\n     */\n    function isOpen() public view returns (bool) {\n        return block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime);\n    }\n\n    /**\n     * @notice Checks if the sale minimum amount was raised.\n     * @return auctionSuccessful True if the commitmentsTotal is equal or higher than goal.\n     */\n    function auctionSuccessful() public view returns (bool) {\n        return uint256(marketStatus.commitmentsTotal) >= uint256(marketPrice.goal);\n    }\n\n    /**\n     * @notice Checks if the sale has ended.\n     * @return auctionEnded True if sold out or time has ended.\n     */\n    function auctionEnded() public view returns (bool) {\n        return block.timestamp > uint256(marketInfo.endTime) || \n        _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) >= uint256(marketInfo.totalTokens);\n    }\n\n    /**\n     * @notice Checks if the sale has been finalised.\n     * @return bool True if sale has been finalised.\n     */\n    function finalized() public view returns (bool) {\n        return marketStatus.finalized;\n    }\n\n    /**\n     * @return True if 7 days have passed since the end of the auction\n    */\n    function finalizeTimeExpired() public view returns (bool) {\n        return uint256(marketInfo.endTime) + 7 days < block.timestamp;\n    }\n    \n\n    //--------------------------------------------------------\n    // Documents\n    //--------------------------------------------------------\n\n    function setDocument(string calldata _name, string calldata _data) external {\n        require(hasAdminRole(msg.sender) );\n        _setDocument( _name, _data);\n    }\n\n    function setDocuments(string[] calldata _name, string[] calldata _data) external {\n        require(hasAdminRole(msg.sender) );\n        uint256 numDocs = _name.length;\n        for (uint256 i = 0; i < numDocs; i++) {\n            _setDocument( _name[i], _data[i]);\n        }\n    }\n\n    function removeDocument(string calldata _name) external {\n        require(hasAdminRole(msg.sender));\n        _removeDocument(_name);\n    }\n\n    //--------------------------------------------------------\n    // Point Lists\n    //--------------------------------------------------------\n\n\n    function setList(address _list) external {\n        require(hasAdminRole(msg.sender));\n        _setList(_list);\n    }\n\n    function enableList(bool _status) external {\n        require(hasAdminRole(msg.sender));\n        marketStatus.usePointList = _status;\n    }\n\n    function _setList(address _pointList) private {\n        if (_pointList != address(0)) {\n            pointList = _pointList;\n            marketStatus.usePointList = true;\n        }\n    }\n\n    //--------------------------------------------------------\n    // Setter Functions\n    //--------------------------------------------------------\n\n    /**\n     * @notice Admin can set start and end time through this function.\n     * @param _startTime Auction start time.\n     * @param _endTime Auction end time.\n     */\n    function setAuctionTime(uint256 _startTime, uint256 _endTime) external {\n        require(hasAdminRole(msg.sender));\n        require(_startTime < 10000000000, \"Crowdsale: enter an unix timestamp in seconds, not miliseconds\");\n        require(_endTime < 10000000000, \"Crowdsale: enter an unix timestamp in seconds, not miliseconds\");\n        require(_startTime >= block.timestamp, \"Crowdsale: start time is before current time\");\n        require(_endTime > _startTime, \"Crowdsale: end time must be older than start price\");\n\n        require(marketStatus.commitmentsTotal == 0, \"Crowdsale: auction cannot have already started\");\n\n        marketInfo.startTime = BoringMath.to64(_startTime);\n        marketInfo.endTime = BoringMath.to64(_endTime);\n        \n        emit AuctionTimeUpdated(_startTime,_endTime);\n    }\n\n    /**\n     * @notice Admin can set auction price through this function.\n     * @param _rate Price per token.\n     * @param _goal Minimum amount raised and goal for the auction.\n     */\n    function setAuctionPrice(uint256 _rate, uint256 _goal) external {\n        require(hasAdminRole(msg.sender));\n        require(_goal > 0, \"Crowdsale: goal is 0\");\n        require(_rate > 0, \"Crowdsale: rate is 0\");\n        require(marketStatus.commitmentsTotal == 0, \"Crowdsale: auction cannot have already started\");\n        marketPrice.rate = BoringMath.to128(_rate);\n        marketPrice.goal = BoringMath.to128(_goal);\n        require(_getTokenAmount(_goal) <= uint256(marketInfo.totalTokens), \"Crowdsale: minimum target exceeds hard cap\");\n\n        emit AuctionPriceUpdated(_rate,_goal);\n    }\n\n    /**\n     * @notice Admin can set the auction wallet through this function.\n     * @param _wallet Auction wallet is where funds will be sent.\n     */\n    function setAuctionWallet(address payable _wallet) external {\n        require(hasAdminRole(msg.sender));\n        require(_wallet != address(0), \"Crowdsale: wallet is the zero address\");\n        wallet = _wallet;\n\n        emit AuctionWalletUpdated(_wallet);\n    }\n\n\n    //--------------------------------------------------------\n    // Market Launchers\n    //--------------------------------------------------------\n\n    function init(bytes calldata _data) external override payable {\n\n    }\n\n    /**\n     * @notice Decodes and hands Crowdsale data to the initCrowdsale function.\n     * @param _data Encoded data for initialization.\n     */\n    function initMarket(bytes calldata _data) public override {\n        (\n        address _funder,\n        address _token,\n        address _paymentCurrency,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _rate,\n        uint256 _goal,\n        address _admin,\n        address _pointList,\n        address payable _wallet\n        ) = abi.decode(_data, (\n            address,\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            address,\n            address\n            )\n        );\n    \n        initCrowdsale(_funder, _token, _paymentCurrency, _totalTokens, _startTime, _endTime, _rate, _goal, _admin, _pointList, _wallet);\n    }\n\n    /**\n     * @notice Collects data to initialize the crowd sale.\n     * @param _funder The address that funds the token for crowdsale.\n     * @param _token Address of the token being sold.\n     * @param _paymentCurrency The currency the crowdsale accepts for payment. Can be ETH or token address.\n     * @param _totalTokens The total number of tokens to sell in crowdsale.\n     * @param _startTime Crowdsale start time.\n     * @param _endTime Crowdsale end time.\n     * @param _rate Number of token units a buyer gets per wei or token.\n     * @param _goal Minimum amount of funds to be raised in weis or tokens.\n     * @param _admin Address that can finalize crowdsale.\n     * @param _pointList Address that will manage auction approvals.\n     * @param _wallet Address where collected funds will be forwarded to.\n     * @return _data All the data in bytes format.\n     */\n    function getCrowdsaleInitData(\n        address _funder,\n        address _token,\n        address _paymentCurrency,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _rate,\n        uint256 _goal,\n        address _admin,\n        address _pointList,\n        address payable _wallet\n    )\n        external pure returns (bytes memory _data)\n    {\n        return abi.encode(\n            _funder,\n            _token,\n            _paymentCurrency,\n            _totalTokens,\n            _startTime,\n            _endTime,\n            _rate,\n            _goal,\n            _admin,\n            _pointList,\n            _wallet\n            );\n    }\n    \n    function getBaseInformation() external view returns(\n        address, \n        uint64,\n        uint64,\n        bool \n    ) {\n        return (auctionToken, marketInfo.startTime, marketInfo.endTime, marketStatus.finalized);\n    }\n\n    function getTotalTokens() external view returns(uint256) {\n        return uint256(marketInfo.totalTokens);\n    }\n}"
    }
  ]
}