{
  "Title": "H-1: Lack of segregation between users' assets and collected fees resulting in loss of funds for the users",
  "Content": "# Issue H-1: Lack of segregation between users' assets and collected fees resulting in loss of funds for the users \n\nSource: https://github.com/sherlock-audit/2023-06-gfx-judging/issues/48 \n\n## Found by \nDug, kutugu, mahyar, mstpr-brainbot, trachev, xiaoming90\n## Summary\n\nThe users' assets are wrongly sent to the owner due to a lack of segregation between users' assets and collected fees, which might result in an irreversible loss of assets for the victims.\n\n## Vulnerability Detail\n\nGLX uses the Chainlink Automation to execute the `LimitOrderRegistry.performUpkeep` function when there are orders that need to be fulfilled. The `LimitOrderRegistry` contract must be funded with LINK tokens to keep the operation running.\n\nTo ensure the LINK tokens are continuously replenished and funded, users must pay a fee denominated in Native ETH or ERC20 WETH tokens on orders claiming as shown below. The collected ETH fee will be stored within the `LimitOrderRegistry` contract.\n\nhttps://github.com/sherlock-audit/2023-06-gfx/blob/main/uniswap-v3-limit-orders/src/LimitOrderRegistry.sol#L696\n\n```solidity\nFile: LimitOrderRegistry.sol\n696:     function claimOrder(uint128 batchId, address user) external payable returns (ERC20, uint256) {\n..SNIP..\n723:         // Transfer tokens owed to user.\n724:         tokenOut.safeTransfer(user, owed);\n725: \n726:         // Transfer fee in.\n727:         address sender = _msgSender();\n728:         if (msg.value >= userClaim.feePerUser) {\n729:             // refund if necessary.\n730:             uint256 refund = msg.value - userClaim.feePerUser;\n731:             if (refund > 0) sender.safeTransferETH(refund);\n732:         } else {\n733:             WRAPPED_NATIVE.safeTransferFrom(sender, address(this), userClaim.feePerUser);\n734:             // If value is non zero send it back to caller.\n735:             if (msg.value > 0) sender.safeTransferETH(msg.value);\n736:         }\n..SNIP..\n```\n\nTo retrieve the ETH fee collected, the owner will call the `LimitOrderRegistry.withdrawNative` function that will send all the Native ETH and ERC20 WETH tokens within the `LimitOrderRegistry` contract to the owner's address. After executing this function, the Native ETH and ERC20 WETH tokens on this contract will be zero and wiped out.\n\nhttps://github.com/sherlock-audit/2023-06-gfx/blob/main/uniswap-v3-limit-orders/src/LimitOrderRegistry.sol#L505\n\n```solidity\nFile: LimitOrderRegistry.sol\n505:     function withdrawNative() external onlyOwner {\n506:         uint256 wrappedNativeBalance = WRAPPED_NATIVE.balanceOf(address(this));\n507:         uint256 nativeBalance = address(this).balance;\n508:         // Make sure there is something to withdraw.\n509:         if (wrappedNativeBalance == 0 && nativeBalance == 0) revert LimitOrderRegistry__ZeroNativeBalance();\n510: \n511:         // transfer wrappedNativeBalance if it exists\n512:         if (wrappedNativeBalance > 0) WRAPPED_NATIVE.safeTransfer(owner, wrappedNativeBalance);\n513:         // transfer nativeBalance if it exists\n514:         if (nativeBalance > 0) owner.safeTransferETH(nativeBalance);\n515:     }\n```\n\nMost owners will automate replenishing the `LimitOrderRegistry` contract with LINK tokens to ensure its balance does not fall below zero and for ease of maintenance. For instance, a certain percentage of the collected ETH fee (e.g., 50%) will be swapped immediately to LINK tokens on a DEX upon collection and transferred the swapped LINK tokens back to the `LimitOrderRegistry` contract. The remaining will be spent to cover operation and maintenance costs.\n\nHowever, the issue is that there are many Uniswap V3 pools where their token pair consists of ETH/WETH. In fact, most large pools in Uniswap V3 will consist of ETH/WETH. For instance, the following Uniswap pools consist of ETH/WETH as one of the pool tokens:\n\n- [USDC / ETH (0.05% Fee)](https://info.uniswap.org/#/pools/0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640) (TLV: $284 million)\n- [WBTC / ETH (0.3% Fee)](https://info.uniswap.org/#/pools/0xcbcdf9626bc03e24f779434178a73a0b4bad62ed) (TLV: $227 million)\n- [USDC / ETH (0.3% Fee)](https://info.uniswap.org/#/pools/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) (TLV: $88 million)\n- [DAI / ETH (0.3% Fee)](https://info.uniswap.org/#/pools/0xc2e9f25be6257c210d7adf0d4cd6e3e881ba25f8) (TLV: $14 million)\n\nAssume that the owner has configured and setup the `LimitOrderRegistry` contract to work with the Uniswap DAI/ETH pool, and the current price of the DAI/ETH pool is 1,500 DAI/ETH. \n\nBob submit a new Buy Limit Order swapping DAI to ETH at the price of 1,000 DAI/ETH. Bob would deposit 1,000,000 DAI to the `LimitOrderRegistry` contract.\n\nWhen Bob's Buy Limit Order is ITM and fulfilled, 1000 ETH/WETH will be sent to and stored within the `LimitOrderRegistry` contract.\n\nThe next step that Bob must do to claim the swapped 1000 ETH/WETH is to call the `LimitOrderRegistry.claimOrder` function, which will collect the fee and transfer the swapped 1000 ETH/WETH to Bob.\n\nUnfortunately, before Bob could claim his swapped ETH/WETH, the `LimitOrderRegistry.withdrawNative` function is triggered by the owner or the owner's bots. As noted earlier, when the `LimitOrderRegistry.withdrawNative` function is triggered, all the Native ETH and ERC20 WETH tokens on this contract will be transferred to the owner's address. As a result, Bob's 1000 swapped ETH/WETH stored within the `LimitOrderRegistry` contract are sent to the owner's address, and the balance of ETH/WETH in the `LimitOrderRegistry` contract is zero.\n\nWhen Bob calls the `LimitOrderRegistry.claimOrder` function, the transaction will revert because insufficient ETH/WETH is left in the `LimitOrderRegistry` contract. \n\nUnfortunately for Bob, there is no way to recover back his ETH/WETH that is sent to the owner's address. Following outline some of the possible scenarios where this could happen:\n\n- The owners set up their infrastructure to automatically swap a portion or all the ETH/WETH received to LINK tokens and transfer them to the `LimitOrderRegistry` contract, and there is no way to retrieve the deposited LINK tokens from the `LimitOrderRegistry` contract even if the owner wishes to do so as there is no function within the contract to allow this action.\n- The owners set up their infrastructure to automatically swap a small portion of ETH/WETH received to LINK tokens and send the rest of the ETH/WETH to 100 investors/DAO members' addresses. So, it is no guarantee that the investors/DAO members will return the ETH/WETH to Bob.\n\n## Impact\n\nLoss of assets for the users\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-gfx/blob/main/uniswap-v3-limit-orders/src/LimitOrderRegistry.sol#L505\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider implementing one of the following solutions to mitigate the issue:\n\n#### Solution 1 - Only accept Native ETH as fee\n\nUniswap V3 pool stored ETH as Wrapped ETH (WETH) ERC20 token internally. When the `collect` function is called against the pool, WETH ERC20 tokens are returned to the caller. Thus, the most straightforward way to mitigate this issue is to update the contract to collect the fee in Native ETH only. \n\nIn this case, there will be a clear segregation between users' assets (WETH) and owner's fee (Native ETH)\n\n```diff\nfunction withdrawNative() external onlyOwner {\n-    uint256 wrappedNativeBalance = WRAPPED_NATIVE.balanceOf(address(this));\n    uint256 nativeBalance = address(this).balance;\n    // Make sure there is something to withdraw.\n-    if (wrappedNativeBalance == 0 && nativeBalance == 0) revert LimitOrderRegistry__ZeroNativeBalance();\n+    if (nativeBalance == 0) revert LimitOrderRegistry__ZeroNativeBalance();\n\n-    // transfer wrappedNativeBalance if it exists\n-    if (wrappedNativeBalance > 0) WRAPPED_NATIVE.safeTransfer(owner, wrappedNativeBalance);\n    // transfer nativeBalance if it exists\n    if (nativeBalance > 0) owner.safeTransferETH(nativeBalance);\n}\n```\n\n```diff\nfunction claimOrder(uint128 batchId, address user) external payable returns (ERC20, uint256) {\n..SNIP..\n    // Transfer tokens owed to user.\n    tokenOut.safeTransfer(user, owed);\n\n    // Transfer fee in.\n    address sender = _msgSender();\n    if (msg.value >= userClaim.feePerUser) {\n        // refund if necessary.\n        uint256 refund = msg.value - userClaim.feePerUser;\n        if (refund > 0) sender.safeTransferETH(refund);    \n    } else {\n-       WRAPPED_NATIVE.safeTransferFrom(sender, address(this), userClaim.feePerUser);\n-       // If value is non zero send it back to caller.\n-       if (msg.value > 0) sender.safeTransferETH(msg.value);\n+\t\trevert LimitOrderRegistry__InsufficientFee;\n    }\n..SNIP..\n```\n\n#### Solution 2 - Define state variables to keep track of the collected fee\n\nConsider defining state variables to keep track of the collected fee so that the fee will not mix up with users' assets.\n\n```diff\nfunction claimOrder(uint128 batchId, address user) external payable returns (ERC20, uint256) {\n..SNIP..\n    // Transfer fee in.\n    address sender = _msgSender();\n    if (msg.value >= userClaim.feePerUser) {\n+    \tcollectedNativeETHFee += userClaim.feePerUser\n        // refund if necessary.\n        uint256 refund = msg.value - userClaim.feePerUser;\n        if (refund > 0) sender.safeTransferETH(refund);\n    } else {\n+    \tcollectedWETHFee += userClaim.feePerUser\n        WRAPPED_NATIVE.safeTransferFrom(sender, address(this), userClaim.feePerUser);\n        // If value is non zero send it back to caller.\n        if (msg.value > 0) sender.safeTransferETH(msg.value);\n    }\n..SNIP..\n```\n\n```diff\nfunction withdrawNative() external onlyOwner {\n-   uint256 wrappedNativeBalance = WRAPPED_NATIVE.balanceOf(address(this));\n-   uint256 nativeBalance = address(this).balance;\n+\tuint256 wrappedNativeBalance = collectedWETHFee;\n+\tuint256 nativeBalance = collectedNativeETHFee;\n+\tcollectedWETHFee = 0; // clear the fee\n+\tcollectedNativeETHFee = 0; // clear the fee\n    // Make sure there is something to withdraw.\n    if (wrappedNativeBalance == 0 && nativeBalance == 0) revert LimitOrderRegistry__ZeroNativeBalance();\n\n    // transfer wrappedNativeBalance if it exists\n    if (wrappedNativeBalance > 0) WRAPPED_NATIVE.safeTransfer(owner, wrappedNativeBalance);\n    // transfer nativeBalance if it exists\n    if (nativeBalance > 0) owner.safeTransferETH(nativeBalance);\n}\n```\n\n\n\n## Discussion\n\n**elee1766**\n\nI believe solution 2 is the better option here, but will have to consider more before implementation\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/97",
  "Code": [
    {
      "filename": "uniswap-v3-limit-orders/src/LimitOrderRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// Used to interact with ERC20 tokens\nimport { ERC20 } from \"@solmate/tokens/ERC20.sol\";\n// Used to perform the safeTransfer\nimport { SafeTransferLib } from \"@solmate/utils/SafeTransferLib.sol\";\n// Used for chainlink automation\nimport { AutomationCompatibleInterface } from \"@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol\";\n// used to have an owner for our contract\nimport { Owned } from \"@solmate/auth/Owned.sol\";\n// for interacting with uniswap pools,\nimport { UniswapV3Pool } from \"src/interfaces/uniswapV3/UniswapV3Pool.sol\";\n// for creating uniswap NFT positions\nimport { NonFungiblePositionManager } from \"src/interfaces/uniswapV3/NonFungiblePositionManager.sol\";\n// dealing with NFTs\nimport { ERC721Holder } from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\n// used to maintain upkeep\nimport { LinkTokenInterface } from \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\";\n// keeper for chainlink automation\nimport { IKeeperRegistrar, RegistrationParams } from \"src/interfaces/chainlink/IKeeperRegistrar.sol\";\n// used to define _msgSender() for future metatransaction support\nimport { Context } from \"@openzeppelin/contracts/utils/Context.sol\";\n// used to get the gas price from the chainlink gas oracle\nimport { IChainlinkAggregator } from \"src/interfaces/chainlink/IChainlinkAggregator.sol\";\n\n/**\n * @title Limit Order Registry\n * @notice Allows users to create decentralized limit orders.\n * @dev DO NOT PLACE LIMIT ORDERS FOR STRONGLY CORRELATED ASSETS.\n *      - If a stable coin pair were to temporarily depeg, and a user places a limit order\n *        whose tick range encompasses the normal trading tick, there is NO way to cancel the order\n *        because the order is mixed. The user would have to wait for another depeg event to happen\n *        so that the order can be fulfilled, or the order can be cancelled.\n * @author crispymangoes\n */\ncontract LimitOrderRegistry is Owned, AutomationCompatibleInterface, ERC721Holder, Context {\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                             STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Stores linked list center values, and frequently used pool values.\n     * @param centerHead Linked list center value closer to head of the list\n     * @param centerTail Linked list center value closer to tail of the list\n     * @param token0 ERC20 token0 of the pool\n     * @param token1 ERC20 token1 of the pool\n     * @param fee Uniswap V3 pool fee\n     */\n    struct PoolData {\n        uint256 centerHead;\n        uint256 centerTail;\n        ERC20 token0;\n        ERC20 token1;\n        uint24 fee;\n    }\n\n    /**\n     * @notice Stores information about batches of orders.\n     * @dev User orders can be batched together if they share the same target price.\n     * @param direction Determines what direction the tick must move in order for the order to be filled\n     *        - true, pool tick must INCREASE to fill this order\n     *        - false, pool tick must DECREASE to fill this order\n     * @param tickUpper The upper tick of the underlying LP position\n     * @param tickLower The lower tick of the underlying LP position\n     * @param userCount The number of users in this batch order\n     * @param batchId Unique id used to distinguish this batch order from another batch order in the past that used the same LP position\n     * @param token0Amount The amount of token0 in this order\n     * @param token1Amount The amount of token1 in this order\n     * @param head The next node in the linked list when moving toward the head\n     * @param tail The next node in the linked list when moving toward the tail\n     */\n    struct BatchOrder {\n        bool direction;\n        int24 tickUpper;\n        int24 tickLower;\n        uint64 userCount;\n        uint128 batchId;\n        uint128 token0Amount;\n        uint128 token1Amount;\n        uint256 head;\n        uint256 tail;\n    }\n\n    /**\n     * @notice Stores information needed for users to make claims.\n     * @param pool The Uniswap V3 pool the batch order was in\n     * @param token0Amount The amount of token0 in the order\n     * @param token1Amount The amount of token1 in the order\n     * @param feePerUser The native token fee that must be paid on order claiming\n     * @param direction The underlying order direction, used to determine input/output token of the order\n     * @param isReadyForClaim Explicit bool indicating whether or not this order is ready to be claimed\n     */\n    struct Claim {\n        UniswapV3Pool pool;\n        uint128 token0Amount; //Can either be the deposit amount or the amount got out of liquidity changing to the other token\n        uint128 token1Amount;\n        uint128 feePerUser; // Fee in terms of network native asset.\n        bool direction; //Determines the token out\n        bool isReadyForClaim;\n    }\n\n    /**\n     * @notice Struct used to store variables needed during order creation.\n     * @param tick The target tick of the order\n     * @param upper The upper tick of the underlying LP position\n     * @param lower The lower tick of the underlying LP position\n     * @param userTotal The total amount of assets the user has in the order\n     * @param positionId The underling LP position token id this order is adding liquidity to\n     * @param amount0 Can be the amount of assets user added to the order, based off orders direction\n     * @param amount1 Can be the amount of assets user added to the order, based off orders direction\n     */\n    struct OrderDetails {\n        int24 tick;\n        int24 upper;\n        int24 lower;\n        uint128 userTotal;\n        uint256 positionId;\n        uint128 amount0;\n        uint128 amount1;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             GLOBAL STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Stores swap fees earned from limit order where the input token earns swap fees.\n     */\n    mapping(address => uint256) public tokenToSwapFees;\n\n    /**\n     * @notice Used to store claim information needed when users are claiming their orders.\n     */\n    mapping(uint128 => Claim) public claim;\n\n    /**\n     * @notice Stores the pools center head/tail, as well as frequently read values.\n     */\n    mapping(UniswapV3Pool => PoolData) public poolToData;\n\n    /**\n     * @notice Maps tick ranges to LP positions owned by this contract.\n     * @dev  maps pool -> direction -> lower -> upper -> positionId\n     */\n    mapping(UniswapV3Pool => mapping(bool => mapping(int24 => mapping(int24 => uint256)))) public getPositionFromTicks;\n\n    /**\n     * @notice The minimum amount of assets required to create a `newOrder`.\n     * @dev Changeable by owner.\n     */\n    mapping(ERC20 => uint256) public minimumAssets;\n\n    /**\n     * @notice Approximated amount of gas needed to fulfill 1 BatchOrder.\n     * @dev Changeable by owner.\n     */\n    uint32 public upkeepGasLimit = 300_000;\n\n    /**\n     * @notice Approximated gas price used to fulfill orders.\n     * @dev Changeable by owner.\n     */\n    uint32 public upkeepGasPrice = 30;\n\n    /**\n     * @notice Max number of orders that can be filled in 1 upkeep call.\n     * @dev Changeable by owner.\n     */\n    uint16 public maxFillsPerUpkeep = 10;\n\n    /**\n     * @notice Value is incremented whenever a new BatchOrder is added to the `orderBook`.\n     * @dev Zero is reserved.\n     */\n    uint128 public batchCount = 1;\n\n    /**\n     * @notice Mapping is used to store user deposit amounts in each BatchOrder.\n     */\n    mapping(uint128 => mapping(address => uint128)) public batchIdToUserDepositAmount;\n\n    /**\n     * @notice The `orderBook` maps Uniswap V3 token ids to BatchOrder information.\n     * @dev Each BatchOrder contains a head and tail value which effectively,\n     *      which means BatchOrders are connected using a doubly linked list.\n     */\n    mapping(uint256 => BatchOrder) public orderBook;\n\n    /**\n     * @notice Chainlink Automation Registrar contract.\n     */\n    IKeeperRegistrar public registrar;\n\n    /**\n     * @notice Whether or not the contract is shutdown in case of an emergency.\n     */\n    bool public isShutdown;\n\n    /**\n     * @notice Chainlink Fast Gas Feed.\n     * @dev Feed for ETH Mainnet 0x169E633A2D1E6c10dD91238Ba11c4A708dfEF37C.\n     */\n    address public fastGasFeed;\n\n    /**\n     * @notice The max possible gas the owner can set for the gas limit.\n     */\n    uint32 public constant MAX_GAS_LIMIT = 750_000;\n\n    /**\n     * @notice The max possible gas price the owner can set for the gas price.\n     * @dev In units of gwei.\n     */\n    uint32 public constant MAX_GAS_PRICE = 1_000;\n\n    /**\n     * @notice The max number of orders that can be fulfilled in a single upkeep TX.\n     */\n    uint16 public constant MAX_FILLS_PER_UPKEEP = 20;\n\n    /**\n     * @notice The ETH Fast Gas Feed heartbeat.\n     * @dev If answer is stale, owner set gas price is used.\n     */\n    uint256 public constant FAST_GAS_HEARTBEAT = 7200;\n\n    /**\n     * @notice Function signature used to create V1 Upkeep versions.\n     */\n    string private constant FUNC_SIGNATURE = \"register(string,bytes,address,uint32,address,bytes,uint96,uint8,address)\";\n\n    /**\n     * @notice Function selector used to create V1 Upkeep versions.\n     */\n    bytes4 private constant FUNC_SELECTOR =  bytes4(keccak256(bytes(FUNC_SIGNATURE)));\n\n    /*//////////////////////////////////////////////////////////////\n                                 MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Prevent a function from being called during a shutdown.\n     */\n    modifier whenNotShutdown() {\n        if (isShutdown) revert LimitOrderRegistry__ContractShutdown();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    // On new limit order created\n    event NewOrder(address user, address pool, uint128 amount, uint128 userTotal, BatchOrder affectedOrder);\n    // On limit order claimed\n    event ClaimOrder(address user, uint128 batchId, uint256 amount);\n    // On limit order cancelled\n    event CancelOrder(address user, uint128 amount0, uint128 amount1, BatchOrder affectedOrder);\n    // On limit order filled\n    event OrderFilled(uint256 batchId, address pool);\n    // On change of shutdown condition\n    event ShutdownChanged(bool isShutdown);\n    // On setup of limit order for the pool\n    event LimitOrderSetup(address pool);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    // @notice When attempting to submit an order that is ITM\n    error LimitOrderRegistry__OrderITM(int24 currentTick, int24 targetTick, bool direction);\n    // @notice When attempting to setup a pool that is already setup\n    error LimitOrderRegistry__PoolAlreadySetup(address pool);\n    // @notice When pool is not setup and one tries to make an order\n    error LimitOrderRegistry__PoolNotSetup(address pool);\n    // @notice When an invalid target tick is provided for creating an order\n    error LimitOrderRegistry__InvalidTargetTick(int24 targetTick, int24 tickSpacing);\n    // @notice When the user for the batchid is not found\n    error LimitOrderRegistry__UserNotFound(address user, uint256 batchId);\n    // @notice When the position id is invalid\n    error LimitOrderRegistry__InvalidPositionId();\n    // @notice When there is no liquidity in the order\n    error LimitOrderRegistry__NoLiquidityInOrder();\n    // @notice When there are no orders to fulfill\n    error LimitOrderRegistry__NoOrdersToFulfill();\n    // @notice When the center is ITM\n    error LimitOrderRegistry__CenterITM();\n    // @notice When the order does not appear in the linked list\n    error LimitOrderRegistry__OrderNotInList(uint256 tokenId);\n    // @notice When the minimum for the asset is not set\n    error LimitOrderRegistry__MinimumNotSet(address asset);\n    // @notice When the minimum for the asset is not met\n    error LimitOrderRegistry__MinimumNotMet(address asset, uint256 minimum, uint256 amount);\n    // @notice When the tick range specified is incorrect\n    error LimitOrderRegistry__InvalidTickRange(int24 upper, int24 lower);\n    // @notice When there are no fees to withdraw\n    error LimitOrderRegistry__ZeroFeesToWithdraw(address token);\n    // @notice When there is no native balance to withdraw\n    error LimitOrderRegistry__ZeroNativeBalance();\n    // @notice When an invalid batch id is provided\n    error LimitOrderRegistry__InvalidBatchId();\n    // @notice When the order is not yet ready to claim\n    error LimitOrderRegistry__OrderNotReadyToClaim(uint128 batchId);\n    // @notice When the contract is shutdown and actions are performed\n    error LimitOrderRegistry__ContractShutdown();\n    // @notice When the contract is not shutdown and shutdown is attempted to be ended\n    error LimitOrderRegistry__ContractNotShutdown();\n    // @notice When an invalid gas limit, above the max, is provided\n    error LimitOrderRegistry__InvalidGasLimit();\n    // @notice When an invalid gas price, above the max, is provided\n    error LimitOrderRegistry__InvalidGasPrice();\n    // @notice When the fills for the upkeep are invalid\n    error LimitOrderRegistry__InvalidFillsPerUpkeep();\n    // @notice When amounts should be 0 but is not\n    error LimitOrderRegistry__AmountShouldBeZero();\n    // @notice When direction for the order doesn't match what state has.\n    error LimitOrderRegistry__DirectionMisMatch();\n\n    /*//////////////////////////////////////////////////////////////\n                                 ENUMS\n    //////////////////////////////////////////////////////////////*/\n\n    // @notice  OrderStatus is used to show the status of an order\n    enum OrderStatus {\n        // When the order is through the book, it is considered ITM. this means that either the order was filled, or it should not exist.\n        ITM,\n        // When an order is not yet filled, it is considered OTM.\n        OTM,\n        // When the current tick is within the ticks of the limit order, it is considered MIXED.\n        MIXED\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    // @notice the token addres of the wrapped native token\n    ERC20 public immutable WRAPPED_NATIVE; // Mainnet 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n\n    // @notice the address of the position manager\n    NonFungiblePositionManager public immutable POSITION_MANAGER; // Mainnet 0xC36442b4a4522E871399CD717aBDD847Ab11FE88\n\n    // @notice the address of the link token\n    LinkTokenInterface public immutable LINK; // Mainnet 0x514910771AF9Ca656af840dff83E8264EcF986CA\n\n    constructor(\n        address _owner,\n        NonFungiblePositionManager _positionManager,\n        ERC20 wrappedNative,\n        LinkTokenInterface link,\n        IKeeperRegistrar _registrar,\n        address _fastGasFeed\n    ) Owned(_owner) {\n        POSITION_MANAGER = _positionManager;\n        WRAPPED_NATIVE = wrappedNative;\n        LINK = link;\n        registrar = _registrar;\n        fastGasFeed = _fastGasFeed;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              OWNER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice No input validation is done because it is in the owners best interest to choose a valid registrar.\n     */\n    function setRegistrar(IKeeperRegistrar _registrar) external onlyOwner {\n        registrar = _registrar;\n    }\n\n    /**\n     * @notice Allows owner to set the fills per upkeep.\n     */\n    function setMaxFillsPerUpkeep(uint16 newVal) external onlyOwner {\n        if (newVal == 0 || newVal > MAX_FILLS_PER_UPKEEP) revert LimitOrderRegistry__InvalidFillsPerUpkeep();\n        maxFillsPerUpkeep = newVal;\n    }\n\n    /**\n     * @notice Allows owner to setup a new limit order for a new pool.\n     * @param pool The uniswap v3 pool to setup limit orders for\n     * @param initialUpkeepFunds the amount of initial upkeep funds to provide for the pool\n     * @dev New Limit orders, should have a keeper to fulfill orders.\n     * @dev If `initialUpkeepFunds` is zero, upkeep creation is skipped.\n     */\n    function setupLimitOrder(UniswapV3Pool pool, uint256 initialUpkeepFunds) external onlyOwner {\n        // Check if Limit Order is already setup for `pool`.\n        if (address(poolToData[pool].token0) != address(0)) revert LimitOrderRegistry__PoolAlreadySetup(address(pool));\n\n        // Create Upkeep, transfering funds only if initialUpkeepFunds is above 0.\n        if (initialUpkeepFunds > 0) {\n            // Owner wants to automatically create an upkeep for new pool.\n            ERC20(address(LINK)).safeTransferFrom(owner, address(this), initialUpkeepFunds);\n            // check the upkeep registration version\n            if (bytes(registrar.typeAndVersion())[16] == bytes(\"1\")[0]) {\n                // Use V1 Upkeep Registration.\n                bytes memory data = abi.encodeWithSelector(\n                    FUNC_SELECTOR,\n                    \"Limit Order Registry\",\n                    abi.encode(0),\n                    address(this),\n                    uint32(maxFillsPerUpkeep * upkeepGasLimit),\n                    owner,\n                    abi.encode(pool),\n                    uint96(initialUpkeepFunds),\n                    77,\n                    address(this)\n                );\n                LINK.transferAndCall(address(registrar), initialUpkeepFunds, data);\n            } else {\n                // Use V2 Upkeep Registration.\n                ERC20(address(LINK)).safeApprove(address(registrar), initialUpkeepFunds);\n                RegistrationParams memory params = RegistrationParams({\n                    name: \"Limit Order Registry\",\n                    encryptedEmail: abi.encode(0),\n                    upkeepContract: address(this),\n                    gasLimit: uint32(maxFillsPerUpkeep * upkeepGasLimit),\n                    adminAddress: owner,\n                    checkData: abi.encode(pool),\n                    offchainConfig: abi.encode(0),\n                    amount: uint96(initialUpkeepFunds)\n                });\n                registrar.registerUpkeep(params);\n            }\n        }\n\n        // initialize the data for the pool. the center and tail of the linked list are 0, while the tokens and fees are set to the correct\n        // ones for the pool\n        poolToData[pool] = PoolData({\n            centerHead: 0,\n            centerTail: 0,\n            token0: ERC20(pool.token0()),\n            token1: ERC20(pool.token1()),\n            fee: pool.fee()\n        });\n\n        emit LimitOrderSetup(address(pool));\n    }\n\n    /**\n     * @notice Allows owner to set the minimum assets used to create `newOrder`s.\n     * @param amount the amount to set minimum assets for the token to\n     * @param asset the erc20 token address to set minimum assets for\n     * @dev This value can be zero, but then this contract can be griefed by an attacker spamming low liquidity orders.\n     */\n    function setMinimumAssets(uint256 amount, ERC20 asset) external onlyOwner {\n        minimumAssets[asset] = amount;\n    }\n\n    /**\n     * @notice Allows owner to change the gas limit value used to determine the Native asset fee needed to claim orders.\n     * @param gasLimit the gas limit that the upkeepGasLimit will be set to\n     * @dev premium should be factored into this value.\n     */\n    function setUpkeepGasLimit(uint32 gasLimit) external onlyOwner {\n        // should revert if the gas limit provided is greater than the provided max gas limit.\n        if (gasLimit > MAX_GAS_LIMIT) revert LimitOrderRegistry__InvalidGasLimit();\n        upkeepGasLimit = gasLimit;\n    }\n\n    /**\n     * @notice Allows owner to change the gas price used to determine the Native asset fee needed to claim orders.\n     * @param gasPrice the gas limit that the upkeepGasPrice will be set to\n     * @dev `gasPrice` uses units of gwei.\n     */\n    function setUpkeepGasPrice(uint32 gasPrice) external onlyOwner {\n        // should revert if the gas price provided is greater than the provided max gas price.\n        if (gasPrice > MAX_GAS_PRICE) revert LimitOrderRegistry__InvalidGasPrice();\n        upkeepGasPrice = gasPrice;\n    }\n\n    /**\n     * @notice Allows owner to set the fast gas feed.\n     * @param feed the address of the chainlink-compatible gas oracle\n     * @dev The feed should be a chainlink-compatible gas oracle\n     */\n    function setFastGasFeed(address feed) external onlyOwner {\n        fastGasFeed = feed;\n    }\n\n    /**\n     * @notice Allows owner to withdraw swap fees earned from the input token of orders.\n     * @param tokenFeeIsIn the address of the token fee.\n     */\n    function withdrawSwapFees(address tokenFeeIsIn) external onlyOwner {\n        uint256 fee = tokenToSwapFees[tokenFeeIsIn];\n\n        // Make sure there are actually fees to withdraw;\n        if (fee == 0) revert LimitOrderRegistry__ZeroFeesToWithdraw(tokenFeeIsIn);\n\n        // set fees to 0\n        tokenToSwapFees[tokenFeeIsIn] = 0;\n        // transfer fees to the user\n        ERC20(tokenFeeIsIn).safeTransfer(owner, fee);\n    }\n\n    /**\n     * @notice Allows owner to withdraw wrapped native and native assets from this contract.\n     */\n    function withdrawNative() external onlyOwner {\n        uint256 wrappedNativeBalance = WRAPPED_NATIVE.balanceOf(address(this));\n        uint256 nativeBalance = address(this).balance;\n        // Make sure there is something to withdraw.\n        if (wrappedNativeBalance == 0 && nativeBalance == 0) revert LimitOrderRegistry__ZeroNativeBalance();\n\n        // transfer wrappedNativeBalance if it exists\n        if (wrappedNativeBalance > 0) WRAPPED_NATIVE.safeTransfer(owner, wrappedNativeBalance);\n        // transfer nativeBalance if it exists\n        if (nativeBalance > 0) owner.safeTransferETH(nativeBalance);\n    }\n\n    /**\n     * @notice Shutdown the registry. Used in an emergency or if the registry has been deprecated.\n     */\n    function initiateShutdown() external whenNotShutdown onlyOwner {\n        isShutdown = true;\n\n        emit ShutdownChanged(true);\n    }\n\n    /**\n     * @notice Restart the registry.\n     */\n    function liftShutdown() external onlyOwner {\n        if (!isShutdown) revert LimitOrderRegistry__ContractNotShutdown();\n        isShutdown = false;\n\n        emit ShutdownChanged(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        USER ORDER MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Creates a new limit order for a specific pool.\n     * @dev Limit orders can be created to buy either token0, or token1 of the pool.\n     * @param pool the Uniswap V3 pool to create a limit order on.\n     * @param targetTick the tick, that when `pool`'s tick passes, the order will be completely fulfilled\n     * @param amount the amount of the input token to sell for the desired token out\n     * @param direction bool indicating what the desired token out is\n     *                  - true  token in = token0 ; token out = token1\n     *                  - false token in = token1 ; token out = token0\n     * @param startingNode an NFT position id indicating where this contract should start searching for a spot in the list\n     *                     - can be zero which defaults to starting the search at center of list\n     * @dev reverts if\n     *      - pool is not setup\n     *      - targetTick is not divisible by the pools tick spacing\n     *      - the new order would be ITM, or in a MIXED state\n     *      - the new order does not meet minimum liquidity requirements\n     *      - transferFrom fails\n\n     * @dev Emits a `NewOrder` event which contains meta data about the order including the orders `batchId`(which is used for claiming/cancelling).\n     */\n    function newOrder(\n        UniswapV3Pool pool,\n        int24 targetTick,\n        uint128 amount,\n        bool direction,\n        uint256 startingNode,\n        uint256 deadline\n    ) external whenNotShutdown returns (uint128) {\n        if (address(poolToData[pool].token0) == address(0)) revert LimitOrderRegistry__PoolNotSetup(address(pool));\n\n        address sender = _msgSender();\n\n        // Transfer assets into contract before setting/checking any state.\n        {\n            // if direction is true, it means that assetIn is token0\n            ERC20 assetIn = direction ? poolToData[pool].token0 : poolToData[pool].token1;\n            // we make sure that there is enough amount of the assetIn\n            _enforceMinimumLiquidity(amount, assetIn);\n            // and transfer\n            assetIn.safeTransferFrom(sender, address(this), amount);\n        }\n\n        OrderDetails memory details;\n\n        // initialize the order =details tick with the pool slot0 value\n        (, details.tick, , , , , ) = pool.slot0();\n\n        // Determine upper and lower ticks.\n        {\n            // we need to grab the tickspace from the pool because we must send our order so that it aligns to ticks.\n            int24 tickSpacing = pool.tickSpacing();\n            // Make sure targetTick is divisible by spacing.\n            if (targetTick % tickSpacing != 0) revert LimitOrderRegistry__InvalidTargetTick(targetTick, tickSpacing);\n            if (direction) {\n                // if assetIn is token0, then the limit goes from targetTick to targetTick-tickSpacing\n                details.upper = targetTick;\n                details.lower = targetTick - tickSpacing;\n            } else {\n                // if assetIn is token1, then the limit goes from targetTick to targetTick+tickSpacing\n                details.upper = targetTick + tickSpacing;\n                details.lower = targetTick;\n            }\n        }\n        // Validate lower, upper,and direction.\n        {\n            OrderStatus status = _getOrderStatus(details.tick, details.lower, details.upper, direction);\n            // forbid orders that are \"ITM\". basically, if your order is through the market, then instead of limit order, you should swap\n            if (status != OrderStatus.OTM) revert LimitOrderRegistry__OrderITM(details.tick, targetTick, direction);\n        }\n\n        // Get the position id. this is the underlying position that we are managing\n        details.positionId = getPositionFromTicks[pool][direction][details.lower][details.upper];\n\n        // the amount should match with the tokenIn, so if tokenIn is token0, then set amount0, else set amount1\n        if (direction) details.amount0 = amount;\n        else details.amount1 = amount;\n\n        // check if the position exists in the nft contract\n        if (details.positionId == 0) {\n            // Create new LP position(which adds liquidity)\n            PoolData memory data = poolToData[pool];\n            details.positionId = _mintPosition(\n                data,\n                details.upper,\n                details.lower,\n                details.amount0,\n                details.amount1,\n                direction,\n                deadline\n            );\n\n            // Add it to the list.\n            _addPositionToList(data, startingNode, targetTick, details.positionId, direction);\n\n            // Set new orders upper and lower tick.\n            orderBook[details.positionId].tickLower = details.lower;\n            orderBook[details.positionId].tickUpper = details.upper;\n\n            // Setup BatchOrder, setting batchId, direction.\n            _setupOrder(direction, details.positionId);\n\n            // Update token0Amount, token1Amount, batchIdToUserDepositAmount mapping.\n            details.userTotal = _updateOrder(details.positionId, sender, amount);\n\n            // Update the center values if need be.\n            _updateCenter(pool, details.positionId, details.tick, details.upper, details.lower);\n\n            // Update getPositionFromTicks since we have a new LP position.\n            getPositionFromTicks[pool][direction][details.lower][details.upper] = details.positionId;\n        } else {\n            // Check if the position id is already being used in List.\n            BatchOrder memory order = orderBook[details.positionId];\n            if (order.token0Amount > 0 || order.token1Amount > 0) {\n                // Check that supplied direction and order.direction are the same.\n                if (direction != order.direction) revert LimitOrderRegistry__DirectionMisMatch();\n                // Need to add liquidity.\n                PoolData memory data = poolToData[pool];\n                _addToPosition(data, details.positionId, details.amount0, details.amount1, direction, deadline);\n\n                // Update token0Amount, token1Amount, batchIdToUserDepositAmount mapping.\n                details.userTotal = _updateOrder(details.positionId, sender, amount);\n            } else {\n                // We already have an LP position with given tick ranges, but it is not in linked list.\n                PoolData memory data = poolToData[pool];\n\n                // Add it to the list.\n                _addPositionToList(data, startingNode, targetTick, details.positionId, direction);\n\n                // Setup BatchOrder, setting batchId, direction.\n                _setupOrder(direction, details.positionId);\n\n                // Need to add liquidity.\n                _addToPosition(data, details.positionId, details.amount0, details.amount1, direction, deadline);\n\n                // Update token0Amount, token1Amount, batchIdToUserDepositAmount mapping.\n                details.userTotal = _updateOrder(details.positionId, sender, amount);\n\n                // Update the center values if need be.\n                _updateCenter(pool, details.positionId, details.tick, details.upper, details.lower);\n            }\n        }\n        // emit the event\n        emit NewOrder(sender, address(pool), amount, details.userTotal, orderBook[details.positionId]);\n        // return the batch id of the position\n        return orderBook[details.positionId].batchId;\n    }\n\n    /**\n     * @notice Users can claim fulfilled orders by passing in the `batchId` corresponding to the order they want to claim.\n     * @param batchId the batchId corresponding to a fulfilled order to claim\n     * @param user the address of the user in the order to claim for\n     * @return address erc20 address\n     * @return uint256 amount claimed\n     * @dev Caller must either approve this contract to spend their Wrapped Native token, and have at least `getFeePerUser` tokens in their wallet.\n     *      Or caller must send `getFeePerUser` value with this call.\n     */\n    function claimOrder(uint128 batchId, address user) external payable returns (ERC20, uint256) {\n        Claim storage userClaim = claim[batchId];\n        if (!userClaim.isReadyForClaim) revert LimitOrderRegistry__OrderNotReadyToClaim(batchId);\n        uint256 depositAmount = batchIdToUserDepositAmount[batchId][user];\n        if (depositAmount == 0) revert LimitOrderRegistry__UserNotFound(user, batchId);\n\n        // Zero out user balance.\n        delete batchIdToUserDepositAmount[batchId][user];\n\n        // Calculate owed amount.\n        uint256 totalTokenDeposited;\n        uint256 totalTokenOut;\n        ERC20 tokenOut;\n\n        // again, remembering that direction == true means that the input token is token0.\n        if (userClaim.direction) {\n            totalTokenDeposited = userClaim.token0Amount;\n            totalTokenOut = userClaim.token1Amount;\n            tokenOut = poolToData[userClaim.pool].token1;\n        } else {\n            totalTokenDeposited = userClaim.token1Amount;\n            totalTokenOut = userClaim.token0Amount;\n            tokenOut = poolToData[userClaim.pool].token0;\n        }\n\n        uint256 owed = (totalTokenOut * depositAmount) / totalTokenDeposited;\n\n        // Transfer tokens owed to user.\n        tokenOut.safeTransfer(user, owed);\n\n        // Transfer fee in.\n        address sender = _msgSender();\n        if (msg.value >= userClaim.feePerUser) {\n            // refund if necessary.\n            uint256 refund = msg.value - userClaim.feePerUser;\n            if (refund > 0) sender.safeTransferETH(refund);\n        } else {\n            WRAPPED_NATIVE.safeT"
    }
  ]
}