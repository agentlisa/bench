{
  "Title": "Gas overflow during iteration (DoS)",
  "Content": "##### Description\nEach iteration of the cycle requires a gas flow.\nA moment may come when more gas is required than it is allocated to record one block. In this case, all iterations of the loop will fail.\n\nAt the lines \nhttps://github.com/yearn/yearn-vaults/blob/e390c2a6b2ba6e2ecc8f3a72a1ea4adfabd17544/contracts/yToken.sol#L107\nhttps://github.com/yearn/yearn-vaults/blob/e390c2a6b2ba6e2ecc8f3a72a1ea4adfabd17544/contracts/yToken.sol#L154\nhttps://github.com/yearn/yearn-vaults/blob/e390c2a6b2ba6e2ecc8f3a72a1ea4adfabd17544/contracts/BaseWrapper.sol#L151\n\nfor the `vaults` address array is not checked for its length. In iterations, data is written to the blockchain, which requires gas consumption. The contract has logic for adding new elements to the `vaults` array, but no logic for removing them.\n\n##### Recommendation\nIt is recommended adding a check for the maximum possible number of elements of the arrays.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/yToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport {VaultAPI, BaseWrapper} from \"./BaseWrapper.sol\";\n\ncontract yToken is IERC20, BaseWrapper {\n    using SafeMath for uint256;\n\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    constructor(address _token, address _registry) public BaseWrapper(_token, _registry) {}\n\n    function name() external view returns (string memory) {\n        VaultAPI _bestVault = bestVault();\n        return _bestVault.name();\n    }\n\n    function symbol() external view returns (string memory) {\n        VaultAPI _bestVault = bestVault();\n        return _bestVault.symbol();\n    }\n\n    function decimals() external view returns (uint256) {\n        VaultAPI _bestVault = bestVault();\n        return _bestVault.decimals();\n    }\n\n    function totalSupply() external override view returns (uint256 total) {\n        return totalAssets();\n    }\n\n    function balanceOf(address account) external override view returns (uint256 balance) {\n        return totalVaultBalance(account);\n    }\n\n    function _transfer(\n        address sender,\n        address receiver,\n        uint256 amount\n    ) internal {\n        require(receiver != address(0), \"ERC20: transfer to the zero address\");\n        require(amount == _withdraw(sender, receiver, amount, true)); // `true` means use `bestVault`\n        emit Transfer(sender, receiver, amount);\n    }\n\n    function transfer(address receiver, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, receiver, amount);\n        return true;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address receiver,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, receiver, amount);\n        _approve(sender, msg.sender, allowance[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    function deposit(uint256 amount) external returns (uint256) {\n        return _deposit(msg.sender, msg.sender, amount, true); // `true` = pull from sender\n    }\n\n    function withdraw(uint256 amount) external returns (uint256) {\n        return _withdraw(msg.sender, msg.sender, amount, true); // `true` = withdraw from `bestVault`\n    }\n\n    function _permitAll(\n        address user,\n        VaultAPI[] calldata vaults,\n        bytes[] calldata signatures\n    ) internal {\n        require(vaults.length == signatures.length);\n        for (uint256 i = 0; i < vaults.length; i++) {\n            require(vaults[i].permit(user, address(this), uint256(-1), 0, signatures[i]));\n        }\n    }\n\n    function permitAll(VaultAPI[] calldata vaults, bytes[] calldata signatures) public {\n        _permitAll(msg.sender, vaults, signatures);\n    }\n\n    function migrate() external returns (uint256) {\n        return _migrate(msg.sender);\n    }\n\n    function migrate(uint256 amount) external returns (uint256) {\n        return _migrate(msg.sender, amount);\n    }\n\n    function migrate(uint256 amount, uint256 maxMigrationLoss) external returns (uint256) {\n        return _migrate(msg.sender, amount, maxMigrationLoss);\n    }\n\n    function migrate(VaultAPI[] calldata vaults, bytes[] calldata signatures) external returns (uint256) {\n        _permitAll(msg.sender, vaults, signatures);\n        return _migrate(msg.sender);\n    }\n\n    function migrate(\n        VaultAPI[] calldata vaults,\n        bytes[] calldata signatures,\n        uint256 amount\n    ) external returns (uint256) {\n        _permitAll(msg.sender, vaults, signatures);\n        return _migrate(msg.sender, amount);\n    }\n\n    function migrate(\n        VaultAPI[] calldata vaults,\n        bytes[] calldata signatures,\n        address user,\n        uint256 amount\n    ) external returns (uint256) {\n        _permitAll(user, vaults, signatures);\n        return _migrate(user, amount);\n    }\n\n    function revokeAll(VaultAPI[] calldata vaults, bytes[] calldata signatures) external {\n        require(vaults.length == signatures.length);\n        for (uint256 i = 0; i < vaults.length; i++) {\n            require(vaults[i].permit(msg.sender, address(this), 0, 0, signatures[i]));\n        }\n    }\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\ncontract yWETH is yToken {\n    using Address for address payable;\n\n    constructor(address _weth, address _registry) public yToken(_weth, _registry) {}\n\n    function depositETH() public payable returns (uint256) {\n        uint256 amount = msg.value;\n        // NOTE: `BaseWrapper.token` is WETH\n        IWETH(address(token)).deposit{value: amount}();\n        // NOTE: Deposit handles approvals\n        // NOTE: Need to use different method to deposit than `yToken`\n        return _deposit(address(this), msg.sender, amount, false); // `false` = pull from `this`\n    }\n\n    function withdrawETH(uint256 amount) external returns (uint256 withdrawn) {\n        // NOTE: Need to use different method to withdraw than `yToken`\n        withdrawn = _withdraw(msg.sender, address(this), amount, true); // `true` = withdraw from `bestVault`\n        // NOTE: `BaseWrapper.token` is WETH\n        IWETH(address(token)).withdraw(withdrawn);\n        // NOTE: Any unintentionally\n        msg.sender.sendValue(address(this).balance);\n    }\n\n    receive() external payable {\n        if (msg.sender != address(token)) {\n            depositETH();\n        } // else: WETH is sending us back ETH, so don't do anything (to avoid recursion)\n    }\n}"
    },
    {
      "filename": "contracts/yToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport {VaultAPI, BaseWrapper} from \"./BaseWrapper.sol\";\n\ncontract yToken is IERC20, BaseWrapper {\n    using SafeMath for uint256;\n\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    constructor(address _token, address _registry) public BaseWrapper(_token, _registry) {}\n\n    function name() external view returns (string memory) {\n        VaultAPI _bestVault = bestVault();\n        return _bestVault.name();\n    }\n\n    function symbol() external view returns (string memory) {\n        VaultAPI _bestVault = bestVault();\n        return _bestVault.symbol();\n    }\n\n    function decimals() external view returns (uint256) {\n        VaultAPI _bestVault = bestVault();\n        return _bestVault.decimals();\n    }\n\n    function totalSupply() external override view returns (uint256 total) {\n        return totalAssets();\n    }\n\n    function balanceOf(address account) external override view returns (uint256 balance) {\n        return totalVaultBalance(account);\n    }\n\n    function _transfer(\n        address sender,\n        address receiver,\n        uint256 amount\n    ) internal {\n        require(receiver != address(0), \"ERC20: transfer to the zero address\");\n        require(amount == _withdraw(sender, receiver, amount, true)); // `true` means use `bestVault`\n        emit Transfer(sender, receiver, amount);\n    }\n\n    function transfer(address receiver, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, receiver, amount);\n        return true;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address receiver,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, receiver, amount);\n        _approve(sender, msg.sender, allowance[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    function deposit(uint256 amount) external returns (uint256) {\n        return _deposit(msg.sender, msg.sender, amount, true); // `true` = pull from sender\n    }\n\n    function withdraw(uint256 amount) external returns (uint256) {\n        return _withdraw(msg.sender, msg.sender, amount, true); // `true` = withdraw from `bestVault`\n    }\n\n    function _permitAll(\n        address user,\n        VaultAPI[] calldata vaults,\n        bytes[] calldata signatures\n    ) internal {\n        require(vaults.length == signatures.length);\n        for (uint256 i = 0; i < vaults.length; i++) {\n            require(vaults[i].permit(user, address(this), uint256(-1), 0, signatures[i]));\n        }\n    }\n\n    function permitAll(VaultAPI[] calldata vaults, bytes[] calldata signatures) public {\n        _permitAll(msg.sender, vaults, signatures);\n    }\n\n    function migrate() external returns (uint256) {\n        return _migrate(msg.sender);\n    }\n\n    function migrate(uint256 amount) external returns (uint256) {\n        return _migrate(msg.sender, amount);\n    }\n\n    function migrate(uint256 amount, uint256 maxMigrationLoss) external returns (uint256) {\n        return _migrate(msg.sender, amount, maxMigrationLoss);\n    }\n\n    function migrate(VaultAPI[] calldata vaults, bytes[] calldata signatures) external returns (uint256) {\n        _permitAll(msg.sender, vaults, signatures);\n        return _migrate(msg.sender);\n    }\n\n    function migrate(\n        VaultAPI[] calldata vaults,\n        bytes[] calldata signatures,\n        uint256 amount\n    ) external returns (uint256) {\n        _permitAll(msg.sender, vaults, signatures);\n        return _migrate(msg.sender, amount);\n    }\n\n    function migrate(\n        VaultAPI[] calldata vaults,\n        bytes[] calldata signatures,\n        address user,\n        uint256 amount\n    ) external returns (uint256) {\n        _permitAll(user, vaults, signatures);\n        return _migrate(user, amount);\n    }\n\n    function revokeAll(VaultAPI[] calldata vaults, bytes[] calldata signatures) external {\n        require(vaults.length == signatures.length);\n        for (uint256 i = 0; i < vaults.length; i++) {\n            require(vaults[i].permit(msg.sender, address(this), 0, 0, signatures[i]));\n        }\n    }\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\ncontract yWETH is yToken {\n    using Address for address payable;\n\n    constructor(address _weth, address _registry) public yToken(_weth, _registry) {}\n\n    function depositETH() public payable returns (uint256) {\n        uint256 amount = msg.value;\n        // NOTE: `BaseWrapper.token` is WETH\n        IWETH(address(token)).deposit{value: amount}();\n        // NOTE: Deposit handles approvals\n        // NOTE: Need to use different method to deposit than `yToken`\n        return _deposit(address(this), msg.sender, amount, false); // `false` = pull from `this`\n    }\n\n    function withdrawETH(uint256 amount) external returns (uint256 withdrawn) {\n        // NOTE: Need to use different method to withdraw than `yToken`\n        withdrawn = _withdraw(msg.sender, address(this), amount, true); // `true` = withdraw from `bestVault`\n        // NOTE: `BaseWrapper.token` is WETH\n        IWETH(address(token)).withdraw(withdrawn);\n        // NOTE: Any unintentionally\n        msg.sender.sendValue(address(this).balance);\n    }\n\n    receive() external payable {\n        if (msg.sender != address(token)) {\n            depositETH();\n        } // else: WETH is sending us back ETH, so don't do anything (to avoid recursion)\n    }\n}"
    },
    {
      "filename": "contracts/BaseWrapper.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/math/Math.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport {VaultAPI} from \"./BaseStrategy.sol\";\n\ninterface RegistryAPI {\n    function governance() external view returns (address);\n\n    function latestVault(address token) external view returns (address);\n\n    function numVaults(address token) external view returns (uint256);\n\n    function vaults(address token, uint256 deploymentId) external view returns (address);\n}\n\nabstract contract BaseWrapper {\n    using Math for uint256;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public token;\n\n    // Reduce number of external calls (SLOADs stay the same)\n    VaultAPI[] private _cachedVaults;\n\n    RegistryAPI public registry;\n\n    // ERC20 Unlimited Approvals (short-circuits VaultAPI.transferFrom)\n    uint256 constant UNLIMITED_APPROVAL = type(uint256).max;\n    // Sentinal values used to save gas on deposit/withdraw/migrate\n    // NOTE: DEPOSIT_EVERYTHING == WITHDRAW_EVERYTHING == MIGRATE_EVERYTHING\n    uint256 constant DEPOSIT_EVERYTHING = type(uint256).max;\n    uint256 constant WITHDRAW_EVERYTHING = type(uint256).max;\n    uint256 constant MIGRATE_EVERYTHING = type(uint256).max;\n    // VaultsAPI.depositLimit is unlimited\n    uint256 constant UNCAPPED_DEPOSITS = type(uint256).max;\n\n    constructor(address _token, address _registry) public {\n        token = IERC20(_token);\n        // v2.registry.ychad.eth\n        registry = RegistryAPI(_registry);\n    }\n\n    function setRegistry(address _registry) external {\n        require(msg.sender == registry.governance());\n        // In case you want to override the registry instead of re-deploying\n        registry = RegistryAPI(_registry);\n    }\n\n    function bestVault() public virtual view returns (VaultAPI) {\n        return VaultAPI(registry.latestVault(address(token)));\n    }\n\n    function allVaults() public virtual view returns (VaultAPI[] memory) {\n        uint256 cache_length = _cachedVaults.length;\n        uint256 num_vaults = registry.numVaults(address(token));\n\n        // Use cached\n        if (cache_length == num_vaults) {\n            return _cachedVaults;\n        }\n\n        VaultAPI[] memory vaults = new VaultAPI[](num_vaults);\n\n        for (uint256 vault_id = 0; vault_id < cache_length; vault_id++) {\n            vaults[vault_id] = _cachedVaults[vault_id];\n        }\n\n        for (uint256 vault_id = cache_length; vault_id < num_vaults; vault_id++) {\n            vaults[vault_id] = VaultAPI(registry.vaults(address(token), vault_id));\n        }\n\n        return vaults;\n    }\n\n    function _updateVaultCache(VaultAPI[] memory vaults) internal {\n        if (vaults.length > _cachedVaults.length) {\n            _cachedVaults = vaults;\n        }\n    }\n\n    function totalVaultBalance(address account) public view returns (uint256 balance) {\n        VaultAPI[] memory vaults = allVaults();\n\n        for (uint256 id = 0; id < vaults.length; id++) {\n            balance = balance.add(vaults[id].balanceOf(account).mul(vaults[id].pricePerShare()).div(10**uint256(vaults[id].decimals())));\n        }\n    }\n\n    function totalAssets() public view returns (uint256 assets) {\n        VaultAPI[] memory vaults = allVaults();\n\n        for (uint256 id = 0; id < vaults.length; id++) {\n            assets = assets.add(vaults[id].totalAssets());\n        }\n    }\n\n    function _deposit(\n        address depositor,\n        address receiver,\n        uint256 amount, // if `MAX_UINT256`, just deposit everything\n        bool pullFunds // If true, funds need to be pulled from `depositor` via `transferFrom`\n    ) internal returns (uint256 deposited) {\n        VaultAPI _bestVault = bestVault();\n\n        if (pullFunds) {\n            token.safeTransferFrom(depositor, address(this), amount);\n        }\n\n        if (token.allowance(address(this), address(_bestVault)) < amount) {\n            token.safeApprove(address(_bestVault), UNLIMITED_APPROVAL); // Vaults are trusted\n        }\n\n        // Depositing returns number of shares deposited\n        // NOTE: Shortcut here is assuming the number of tokens deposited is equal to the\n        //       number of shares credited, which helps avoid an occasional multiplication\n        //       overflow if trying to adjust the number of shares by the share price.\n        uint256 beforeBal = token.balanceOf(address(this));\n        if (receiver != address(this)) {\n            _bestVault.deposit(amount, receiver);\n        } else if (amount != DEPOSIT_EVERYTHING) {\n            _bestVault.deposit(amount);\n        } else {\n            _bestVault.deposit();\n        }\n\n        uint256 afterBal = token.balanceOf(address(this));\n        deposited = beforeBal.sub(afterBal);\n        // `receiver` now has shares of `_bestVault` as balance, converted to `token` here\n        // Issue a refund if not everything was deposited\n        if (depositor != address(this) && afterBal > 0) token.transfer(depositor, afterBal);\n    }\n\n    function _withdraw(\n        address sender,\n        address receiver,\n        uint256 amount, // if `MAX_UINT256`, just withdraw everything\n        bool withdrawFromBest // If true, also withdraw from `_bestVault`\n    ) internal returns (uint256 withdrawn) {\n        VaultAPI _bestVault = bestVault();\n\n        VaultAPI[] memory vaults = allVaults();\n        _updateVaultCache(vaults);\n\n        for (uint256 id = 0; id < vaults.length; id++) {\n            if (!withdrawFromBest && vaults[id] == _bestVault) {\n                continue; // Don't withdraw from the best\n            }\n\n            // Start with the total shares that `sender` has\n            uint256 availableShares = vaults[id].balanceOf(sender);\n\n            // Restrict by the allowance that `sender` has to this contract\n            // NOTE: No need for allowance check if `sender` is this contract\n            if (sender != address(this)) {\n                availableShares = Math.min(availableShares, vaults[id].allowance(sender, address(this)));\n            }\n\n            // Limit by maximum withdrawal size from each vault\n            availableShares = Math.min(availableShares, vaults[id].maxAvailableShares());\n\n            if (availableShares > 0) {\n                // Intermediate step to move shares to this contract before withdrawing\n                // NOTE: No need for share transfer if this contract is `sender`\n                if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares);\n\n                if (amount != WITHDRAW_EVERYTHING) {\n                    // Compute amount to withdraw fully to satisfy the request\n                    uint256 estimatedShares = amount\n                        .sub(withdrawn) // NOTE: Changes every iteration\n                        .mul(10**uint256(vaults[id].decimals()))\n                        .div(vaults[id].pricePerShare()); // NOTE: Every Vault is different\n\n                    // Limit amount to withdraw to the maximum made available to this contract\n                    uint256 shares = Math.min(estimatedShares, availableShares);\n                    withdrawn = withdrawn.add(vaults[id].withdraw(shares));\n                } else {\n                    withdrawn = withdrawn.add(vaults[id].withdraw());\n                }\n\n                // Check if we have fully satisfied the request\n                // NOTE: use `amount = WITHDRAW_EVERYTHING` for withdrawing everything\n                if (amount <= withdrawn) break; // withdrawn as much as we needed\n            }\n        }\n\n        // If we have extra, deposit back into `_bestVault` for `sender`\n        // NOTE: Invariant is `withdrawn <= amount`\n        if (withdrawn > amount) {\n            // Don't forget to approve the deposit\n            if (token.allowance(address(this), address(_bestVault)) < withdrawn.sub(amount)) {\n                token.safeApprove(address(_bestVault), UNLIMITED_APPROVAL); // Vaults are trusted\n            }\n\n            _bestVault.deposit(withdrawn.sub(amount), sender);\n            withdrawn = amount;\n        }\n\n        // `receiver` now has `withdrawn` tokens as balance\n        if (receiver != address(this)) token.safeTransfer(receiver, withdrawn);\n    }\n\n    function _migrate(address account) internal returns (uint256) {\n        return _migrate(account, MIGRATE_EVERYTHING);\n    }\n\n    function _migrate(address account, uint256 amount) internal returns (uint256) {\n        // NOTE: In practice, it was discovered that <50 was the maximum we've see for this variance\n        return _migrate(account, amount, 0);\n    }\n\n    function _migrate(\n        address account,\n        uint256 amount,\n        uint256 maxMigrationLoss\n    ) internal returns (uint256 migrated) {\n        VaultAPI _bestVault = bestVault();\n\n        // NOTE: Only override if we aren't migrating everything\n        uint256 _depositLimit = _bestVault.depositLimit();\n        uint256 _totalAssets = _bestVault.totalAssets();\n        if (_depositLimit <= _totalAssets) return 0; // Nothing to migrate (not a failure)\n\n        uint256 _amount = amount;\n        if (_depositLimit < UNCAPPED_DEPOSITS && _amount < WITHDRAW_EVERYTHING) {\n            // Can only deposit up to this amount\n            uint256 _depositLeft = _depositLimit.sub(_totalAssets);\n            if (_amount > _depositLeft) _amount = _depositLeft;\n        }\n\n        if (_amount > 0) {\n            // NOTE: `false` = don't withdraw from `_bestVault`\n            uint256 withdrawn = _withdraw(account, address(this), _amount, false);\n            if (withdrawn == 0) return 0; // Nothing to migrate (not a failure)\n\n            // NOTE: `false` = don't do `transferFrom` because it's already local\n            migrated = _deposit(address(this), account, withdrawn, false);\n            // NOTE: Due to the precision loss of certain calculations, there is a small inefficency\n            //       on how migrations are calculated, and this could lead to a DoS issue. Hence, this\n            //       value is made to be configurable to allow the user to specify how much is acceptable\n            require(withdrawn.sub(migrated) <= maxMigrationLoss);\n        } // else: nothing to migrate! (not a failure)\n    }\n}"
    }
  ]
}