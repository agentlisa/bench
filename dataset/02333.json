{
  "Title": "M-5: Operator can cause fee shares to be minted to address(0)",
  "Content": "# Issue M-5: Operator can cause fee shares to be minted to address(0) \n\nSource: https://github.com/sherlock-audit/2023-02-surge-judging/issues/124 \n\n## Found by \nGimelSec, Dug, Aymen0909, bin2chen, slvDev, ast3ros, 0x52, BTK, 0xAgro, SovaSlava, favelanky, gogo, ctf\\_sec\n\n## Summary\n\nWhen setting the fee rate it is required that the fee recipient is NOT address(0). An operator can bypass this check by changing the fee recipient to address(0) after setting fee.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-02-surge/blob/main/surge-protocol-v1/src/Factory.sol#L60-L65\n\nWhen setting the fee it is required that if the fee != 0 then the fee recipient != address(0)\n\nhttps://github.com/sherlock-audit/2023-02-surge/blob/main/surge-protocol-v1/src/Factory.sol#L52-L55\n\nWhen setting the fee recipient there is no similar check. This means that an operator can bypass the check in setFeeMantissa by setting the fee recipient to address(0) after setting a nonzero fee value.\n\n## Impact\n\nOperator can bypass fee recipient check\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-surge/blob/main/surge-protocol-v1/src/Factory.sol#L52-L55\n\n## Tool used\n\n[Solidity YouTube Tutorial](https://www.youtube.com/watch?v=dQw4w9WgXcQ)\n\n## Recommendation\n\nImplement a check similar to the one in setFeeMantissa that doesn't allow a nonzero fee when fee recipient = address(0)\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/51",
  "Code": [
    {
      "filename": "surge-protocol-v1/src/Factory.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport \"./Pool.sol\";\n\n/// @title Factory\n/// @author Moaz Mohsen & Nour Haridy\n/// @notice This contract is responsible for deploying new pools and providing them with the current fee and fee recipient\ncontract Factory {\n\n    address public operator;\n    address public pendingOperator;\n    address public feeRecipient;\n    uint public feeMantissa;\n    uint public constant MAX_FEE_MANTISSA = 0.2e18;\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    bytes32 public immutable POOL_SYMBOL_PREFIX;\n    mapping (Pool => bool) public isPool;\n    Pool[] public pools;\n\n    constructor(address _operator, string memory _poolSymbolPrefix) {\n        operator = _operator;\n        POOL_SYMBOL_PREFIX = pack(_poolSymbolPrefix);\n    }\n\n    function pack(string memory unpacked) internal pure returns (bytes32 packed) {\n        require (bytes(unpacked).length < 32);\n        assembly {\n            packed := mload (add (unpacked, 31))\n        }\n    }\n\n    function unpack(bytes32 packed) internal pure returns (string memory unpacked) {\n        uint l = uint (packed >> 248);\n        require (l < 32);\n        unpacked = string (new bytes (l));\n        assembly {\n            mstore (add (unpacked, 31), packed) // Potentially writes into unallocated memory, which is fine\n        }\n    }\n\n    /// @notice Get the number of deployed pools\n    /// @return uint number of deployed pools\n    /// @dev Useful for iterating on all pools\n    function getPoolsLength() external view returns (uint) {\n        return pools.length;\n    }\n\n    /// @notice Set the fee recipient for all pools\n    /// @param _feeRecipient address of the new fee recipient\n    /// @dev Only callable by the operator\n    function setFeeRecipient(address _feeRecipient) external {\n        require(msg.sender == operator, \"Factory: not operator\");\n        feeRecipient = _feeRecipient;\n    }\n\n    /// @notice Set the fee for all pools\n    /// @param _feeMantissa the new fee amount in Mantissa (scaled by 1e18)\n    /// @dev Only callable by the operator\n    function setFeeMantissa(uint _feeMantissa) external {\n        require(msg.sender == operator, \"Factory: not operator\");\n        require(_feeMantissa <= MAX_FEE_MANTISSA, \"Factory: fee too high\");\n        if(_feeMantissa > 0) require(feeRecipient != address(0), \"Factory: fee recipient is zero address\");\n        feeMantissa = _feeMantissa;\n    }\n\n    /// @notice Set a pending operator for the factory\n    /// @param _pendingOperator address of the new pending operator\n    /// @dev Only callable by the operator\n    function setPendingOperator(address _pendingOperator) external {\n        require(msg.sender == operator, \"Factory: not operator\");\n        pendingOperator = _pendingOperator;\n    }\n\n    /// @notice Accept the pending operator\n    /// @dev Only callable by the pending operator\n    function acceptOperator() external {\n        require(msg.sender == pendingOperator, \"Factory: not pending operator\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n    }\n\n    /// @notice Get the fee and fee recipient for all pools\n    /// @return address of the fee recipient and the fee amount in Mantissa (scaled by 1e18)\n    /// @dev Used by pools to access the current fee and fee recipient\n    function getFee() external view returns (address, uint) {\n        uint _feeMantissa = feeMantissa;\n        if(_feeMantissa == 0) return (address(0), 0);\n        return (feeRecipient, _feeMantissa);\n    }\n\n    /// @dev Return the log in base 10, rounded down, of a positive value. Returns 0 if given 0.\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }    \n\n\n    /// @dev Converts a `uint256` to its ASCII `string` decimal representation.\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /// @notice Deploy a new Surge pool\n    /// @param _collateralToken address of the collateral token\n    /// @param _loanToken address of the loan token\n    /// @param _maxCollateralRatioMantissa the maximum collateral ratio in Mantissa (scaled by 1e18)\n    /// @param _surgeMantissa the surge utilization threshold in Mantissa (scaled by 1e18)\n    /// @param _collateralRatioFallDuration the duration of the collateral ratio fall in seconds\n    /// @param _collateralRatioRecoveryDuration the duration of the collateral ratio recovery in seconds\n    /// @param _minRateMantissa the minimum interest rate in Mantissa (scaled by 1e18)\n    /// @param _surgeRateMantissa the interest rate at the surge threshold in Mantissa (scaled by 1e18)\n    /// @param _maxRateMantissa the maximum interest rate in Mantissa (scaled by 1e18)\n    /// @return Pool the address of the deployed pool\n    function deploySurgePool(\n        IERC20 _collateralToken,\n        IERC20 _loanToken,\n        uint _maxCollateralRatioMantissa,\n        uint _surgeMantissa,\n        uint _collateralRatioFallDuration,\n        uint _collateralRatioRecoveryDuration,\n        uint _minRateMantissa,\n        uint _surgeRateMantissa,\n        uint _maxRateMantissa\n    ) external returns (Pool) {\n        string memory poolNumberString = toString(pools.length);\n        string memory prefix = unpack(POOL_SYMBOL_PREFIX);\n        Pool pool = new Pool(\n            string(abi.encodePacked(prefix, poolNumberString)),\n            string(abi.encodePacked(\"Surge \", prefix, poolNumberString, \" Pool\")),\n            _collateralToken,\n            _loanToken,\n            _maxCollateralRatioMantissa,\n            _surgeMantissa,\n            _collateralRatioFallDuration,\n            _collateralRatioRecoveryDuration,\n            _minRateMantissa,\n            _surgeRateMantissa,\n            _maxRateMantissa\n        );\n        isPool[pool] = true;\n        emit PoolDeployed(pools.length, address(pool), address(_collateralToken), address(_loanToken), _maxCollateralRatioMantissa, _surgeMantissa, _collateralRatioFallDuration, _collateralRatioRecoveryDuration, _minRateMantissa, _surgeRateMantissa, _maxRateMantissa);\n        pools.push(pool);\n        return pool;\n    }\n    event PoolDeployed(uint poolId, address pool, address indexed collateralToken, address indexed loanToken, uint indexed maxCollateralRatioMantissa, uint surgeMantissa, uint collateralRatioFallDuration, uint collateralRatioRecoveryDuration, uint minRateMantissa, uint surgeRateMantissa, uint maxRateMantissa);\n}"
    },
    {
      "filename": "surge-protocol-v1/src/Factory.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport \"./Pool.sol\";\n\n/// @title Factory\n/// @author Moaz Mohsen & Nour Haridy\n/// @notice This contract is responsible for deploying new pools and providing them with the current fee and fee recipient\ncontract Factory {\n\n    address public operator;\n    address public pendingOperator;\n    address public feeRecipient;\n    uint public feeMantissa;\n    uint public constant MAX_FEE_MANTISSA = 0.2e18;\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    bytes32 public immutable POOL_SYMBOL_PREFIX;\n    mapping (Pool => bool) public isPool;\n    Pool[] public pools;\n\n    constructor(address _operator, string memory _poolSymbolPrefix) {\n        operator = _operator;\n        POOL_SYMBOL_PREFIX = pack(_poolSymbolPrefix);\n    }\n\n    function pack(string memory unpacked) internal pure returns (bytes32 packed) {\n        require (bytes(unpacked).length < 32);\n        assembly {\n            packed := mload (add (unpacked, 31))\n        }\n    }\n\n    function unpack(bytes32 packed) internal pure returns (string memory unpacked) {\n        uint l = uint (packed >> 248);\n        require (l < 32);\n        unpacked = string (new bytes (l));\n        assembly {\n            mstore (add (unpacked, 31), packed) // Potentially writes into unallocated memory, which is fine\n        }\n    }\n\n    /// @notice Get the number of deployed pools\n    /// @return uint number of deployed pools\n    /// @dev Useful for iterating on all pools\n    function getPoolsLength() external view returns (uint) {\n        return pools.length;\n    }\n\n    /// @notice Set the fee recipient for all pools\n    /// @param _feeRecipient address of the new fee recipient\n    /// @dev Only callable by the operator\n    function setFeeRecipient(address _feeRecipient) external {\n        require(msg.sender == operator, \"Factory: not operator\");\n        feeRecipient = _feeRecipient;\n    }\n\n    /// @notice Set the fee for all pools\n    /// @param _feeMantissa the new fee amount in Mantissa (scaled by 1e18)\n    /// @dev Only callable by the operator\n    function setFeeMantissa(uint _feeMantissa) external {\n        require(msg.sender == operator, \"Factory: not operator\");\n        require(_feeMantissa <= MAX_FEE_MANTISSA, \"Factory: fee too high\");\n        if(_feeMantissa > 0) require(feeRecipient != address(0), \"Factory: fee recipient is zero address\");\n        feeMantissa = _feeMantissa;\n    }\n\n    /// @notice Set a pending operator for the factory\n    /// @param _pendingOperator address of the new pending operator\n    /// @dev Only callable by the operator\n    function setPendingOperator(address _pendingOperator) external {\n        require(msg.sender == operator, \"Factory: not operator\");\n        pendingOperator = _pendingOperator;\n    }\n\n    /// @notice Accept the pending operator\n    /// @dev Only callable by the pending operator\n    function acceptOperator() external {\n        require(msg.sender == pendingOperator, \"Factory: not pending operator\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n    }\n\n    /// @notice Get the fee and fee recipient for all pools\n    /// @return address of the fee recipient and the fee amount in Mantissa (scaled by 1e18)\n    /// @dev Used by pools to access the current fee and fee recipient\n    function getFee() external view returns (address, uint) {\n        uint _feeMantissa = feeMantissa;\n        if(_feeMantissa == 0) return (address(0), 0);\n        return (feeRecipient, _feeMantissa);\n    }\n\n    /// @dev Return the log in base 10, rounded down, of a positive value. Returns 0 if given 0.\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }    \n\n\n    /// @dev Converts a `uint256` to its ASCII `string` decimal representation.\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /// @notice Deploy a new Surge pool\n    /// @param _collateralToken address of the collateral token\n    /// @param _loanToken address of the loan token\n    /// @param _maxCollateralRatioMantissa the maximum collateral ratio in Mantissa (scaled by 1e18)\n    /// @param _surgeMantissa the surge utilization threshold in Mantissa (scaled by 1e18)\n    /// @param _collateralRatioFallDuration the duration of the collateral ratio fall in seconds\n    /// @param _collateralRatioRecoveryDuration the duration of the collateral ratio recovery in seconds\n    /// @param _minRateMantissa the minimum interest rate in Mantissa (scaled by 1e18)\n    /// @param _surgeRateMantissa the interest rate at the surge threshold in Mantissa (scaled by 1e18)\n    /// @param _maxRateMantissa the maximum interest rate in Mantissa (scaled by 1e18)\n    /// @return Pool the address of the deployed pool\n    function deploySurgePool(\n        IERC20 _collateralToken,\n        IERC20 _loanToken,\n        uint _maxCollateralRatioMantissa,\n        uint _surgeMantissa,\n        uint _collateralRatioFallDuration,\n        uint _collateralRatioRecoveryDuration,\n        uint _minRateMantissa,\n        uint _surgeRateMantissa,\n        uint _maxRateMantissa\n    ) external returns (Pool) {\n        string memory poolNumberString = toString(pools.length);\n        string memory prefix = unpack(POOL_SYMBOL_PREFIX);\n        Pool pool = new Pool(\n            string(abi.encodePacked(prefix, poolNumberString)),\n            string(abi.encodePacked(\"Surge \", prefix, poolNumberString, \" Pool\")),\n            _collateralToken,\n            _loanToken,\n            _maxCollateralRatioMantissa,\n            _surgeMantissa,\n            _collateralRatioFallDuration,\n            _collateralRatioRecoveryDuration,\n            _minRateMantissa,\n            _surgeRateMantissa,\n            _maxRateMantissa\n        );\n        isPool[pool] = true;\n        emit PoolDeployed(pools.length, address(pool), address(_collateralToken), address(_loanToken), _maxCollateralRatioMantissa, _surgeMantissa, _collateralRatioFallDuration, _collateralRatioRecoveryDuration, _minRateMantissa, _surgeRateMantissa, _maxRateMantissa);\n        pools.push(pool);\n        return pool;\n    }\n    event PoolDeployed(uint poolId, address pool, address indexed collateralToken, address indexed loanToken, uint indexed maxCollateralRatioMantissa, uint surgeMantissa, uint collateralRatioFallDuration, uint collateralRatioRecoveryDuration, uint minRateMantissa, uint surgeRateMantissa, uint maxRateMantissa);\n}"
    },
    {
      "filename": "surge-protocol-v1/src/Factory.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport \"./Pool.sol\";\n\n/// @title Factory\n/// @author Moaz Mohsen & Nour Haridy\n/// @notice This contract is responsible for deploying new pools and providing them with the current fee and fee recipient\ncontract Factory {\n\n    address public operator;\n    address public pendingOperator;\n    address public feeRecipient;\n    uint public feeMantissa;\n    uint public constant MAX_FEE_MANTISSA = 0.2e18;\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    bytes32 public immutable POOL_SYMBOL_PREFIX;\n    mapping (Pool => bool) public isPool;\n    Pool[] public pools;\n\n    constructor(address _operator, string memory _poolSymbolPrefix) {\n        operator = _operator;\n        POOL_SYMBOL_PREFIX = pack(_poolSymbolPrefix);\n    }\n\n    function pack(string memory unpacked) internal pure returns (bytes32 packed) {\n        require (bytes(unpacked).length < 32);\n        assembly {\n            packed := mload (add (unpacked, 31))\n        }\n    }\n\n    function unpack(bytes32 packed) internal pure returns (string memory unpacked) {\n        uint l = uint (packed >> 248);\n        require (l < 32);\n        unpacked = string (new bytes (l));\n        assembly {\n            mstore (add (unpacked, 31), packed) // Potentially writes into unallocated memory, which is fine\n        }\n    }\n\n    /// @notice Get the number of deployed pools\n    /// @return uint number of deployed pools\n    /// @dev Useful for iterating on all pools\n    function getPoolsLength() external view returns (uint) {\n        return pools.length;\n    }\n\n    /// @notice Set the fee recipient for all pools\n    /// @param _feeRecipient address of the new fee recipient\n    /// @dev Only callable by the operator\n    function setFeeRecipient(address _feeRecipient) external {\n        require(msg.sender == operator, \"Factory: not operator\");\n        feeRecipient = _feeRecipient;\n    }\n\n    /// @notice Set the fee for all pools\n    /// @param _feeMantissa the new fee amount in Mantissa (scaled by 1e18)\n    /// @dev Only callable by the operator\n    function setFeeMantissa(uint _feeMantissa) external {\n        require(msg.sender == operator, \"Factory: not operator\");\n        require(_feeMantissa <= MAX_FEE_MANTISSA, \"Factory: fee too high\");\n        if(_feeMantissa > 0) require(feeRecipient != address(0), \"Factory: fee recipient is zero address\");\n        feeMantissa = _feeMantissa;\n    }\n\n    /// @notice Set a pending operator for the factory\n    /// @param _pendingOperator address of the new pending operator\n    /// @dev Only callable by the operator\n    function setPendingOperator(address _pendingOperator) external {\n        require(msg.sender == operator, \"Factory: not operator\");\n        pendingOperator = _pendingOperator;\n    }\n\n    /// @notice Accept the pending operator\n    /// @dev Only callable by the pending operator\n    function acceptOperator() external {\n        require(msg.sender == pendingOperator, \"Factory: not pending operator\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n    }\n\n    /// @notice Get the fee and fee recipient for all pools\n    /// @return address of the fee recipient and the fee amount in Mantissa (scaled by 1e18)\n    /// @dev Used by pools to access the current fee and fee recipient\n    function getFee() external view returns (address, uint) {\n        uint _feeMantissa = feeMantissa;\n        if(_feeMantissa == 0) return (address(0), 0);\n        return (feeRecipient, _feeMantissa);\n    }\n\n    /// @dev Return the log in base 10, rounded down, of a positive value. Returns 0 if given 0.\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }    \n\n\n    /// @dev Converts a `uint256` to its ASCII `string` decimal representation.\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /// @notice Deploy a new Surge pool\n    /// @param _collateralToken address of the collateral token\n    /// @param _loanToken address of the loan token\n    /// @param _maxCollateralRatioMantissa the maximum collateral ratio in Mantissa (scaled by 1e18)\n    /// @param _surgeMantissa the surge utilization threshold in Mantissa (scaled by 1e18)\n    /// @param _collateralRatioFallDuration the duration of the collateral ratio fall in seconds\n    /// @param _collateralRatioRecoveryDuration the duration of the collateral ratio recovery in seconds\n    /// @param _minRateMantissa the minimum interest rate in Mantissa (scaled by 1e18)\n    /// @param _surgeRateMantissa the interest rate at the surge threshold in Mantissa (scaled by 1e18)\n    /// @param _maxRateMantissa the maximum interest rate in Mantissa (scaled by 1e18)\n    /// @return Pool the address of the deployed pool\n    function deploySurgePool(\n        IERC20 _collateralToken,\n        IERC20 _loanToken,\n        uint _maxCollateralRatioMantissa,\n        uint _surgeMantissa,\n        uint _collateralRatioFallDuration,\n        uint _collateralRatioRecoveryDuration,\n        uint _minRateMantissa,\n        uint _surgeRateMantissa,\n        uint _maxRateMantissa\n    ) external returns (Pool) {\n        string memory poolNumberString = toString(pools.length);\n        string memory prefix = unpack(POOL_SYMBOL_PREFIX);\n        Pool pool = new Pool(\n            string(abi.encodePacked(prefix, poolNumberString)),\n            string(abi.encodePacked(\"Surge \", prefix, poolNumberString, \" Pool\")),\n            _collateralToken,\n            _loanToken,\n            _maxCollateralRatioMantissa,\n            _surgeMantissa,\n            _collateralRatioFallDuration,\n            _collateralRatioRecoveryDuration,\n            _minRateMantissa,\n            _surgeRateMantissa,\n            _maxRateMantissa\n        );\n        isPool[pool] = true;\n        emit PoolDeployed(pools.length, address(pool), address(_collateralToken), address(_loanToken), _maxCollateralRatioMantissa, _surgeMantissa, _collateralRatioFallDuration, _collateralRatioRecoveryDuration, _minRateMantissa, _surgeRateMantissa, _maxRateMantissa);\n        pools.push(pool);\n        return pool;\n    }\n    event PoolDeployed(uint poolId, address pool, address indexed collateralToken, address indexed loanToken, uint indexed maxCollateralRatioMantissa, uint surgeMantissa, uint collateralRatioFallDuration, uint collateralRatioRecoveryDuration, uint minRateMantissa, uint surgeRateMantissa, uint maxRateMantissa);\n}"
    }
  ]
}