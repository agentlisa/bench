{
  "Title": "[M-22] RecollateralizationLib: Dust loss for an asset should be capped at itâ€™s low value",
  "Content": "# Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L275\n\n\n# Vulnerability details\n\n## Impact\nThe `RecollateralizationLib.basketRange` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L152-L202](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L152-L202)) internally calls the `RecollateralizationLib.totalAssetValue` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L226-L281](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L226-L281)).  \n\nI will show in this report that the `RecollateralizationLib.totalAssetValue` function returns a value for `assetsLow` that is too low.  \n\nThis in turn causes the `range.bottom` value ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L201](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L201)) that the `RecollateralizationLib.basketRange` function returns to be too low.  \n\nBefore showing why the `assetsLow` value is underestimated however I will explain the impact of the `range.bottom` variable being too low.  \n\nThere are two places where this value is used:  \n\n### 1. `RecollateralizationLib.prepareRecollateralizationTrade` function \nThis function passes the `range` to the `RecollateralizationLib.nextTradePair` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L88-L91](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L88-L91))\n\nSince `range.bottom` is too low, the `needed` amount is too low ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L380](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L380)).  \n\nThis causes the `if` statement to not be executed in some cases when it otherwise would be executed ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L381-L396](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L381-L396)).  \n\nAnd the `amtShort` is smaller than it should be ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L391](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L391)).  \n\nIn the end this causes recollateralization trades to not buy as much assets as they could buy. This is because the amount of assets is underestimated so the protocol can actually hold more baskets than it thinks it can.  \n\nTherefore underestimating `assetsLow` causes a direct loss to RToken holders because the protocol will not recollateralize the RToken to the level that it can and should.  \n\n### 2. Price calculations of `RTokenAsset`\nA `RTokenAsset` uses the `RecollateralizationLib.basketRange` function to calculate its value:  \n\n[https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L156](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L156)  \n\nThe `RTokenAsset` therefore underestimates its `low` and `lotLow` prices:  \n\n[https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L58](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L58)  \n\n[https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L99](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L99)   \n\nThis then can lead to issues in any places where the prices of `RTokenAsset`s are used.  \n\n## Proof of Concept\nHere is the affected line:  \n\n[https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L275](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L275)  \n\n```solidity\npotentialDustLoss = potentialDustLoss.plus(rules.minTradeVolume);\n```\n\nThis line is executed for every asset in the `AssetRegistry` ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L242](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L242)).  \n\nSo for every asset in the `AssetRegistry` a potential dust loss of `minTradeVolume` is added.  \n\nThe following scenario shows why this is wrong:  \n\n```\nassume minTradeVolume = $50\n\nassume further the following:\nasset1 with low value $1\nasset2 with low value $1\nasset3 with low value $1\nasset4 with low value $200\n\nCurrently potentialDustLoss will be 4*minTradeVolume = $200.\nSo assetsLow = $203 - $200 = $3.\n\nDust loss should not be calculated with $50 for the first 3 assets.\nDust loss for an asset should be capped at its low value.\nSo dust loss alltogether should be $1 + $1 + $1 + $50 = $53.\n\nSo assetsLow should be $1+$1+$1+$200 - $53 = $150.\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nI suggest that an asset can only incur as much dust loss as its balance is.  \nIf the protocol only holds `$5` of asset A then this should not cause a dust loss of say `$10`.  \n\nThe fix first saves the `assetLow` value which should be saved to memory because it is now needed two times then it caps the dust loss of an asset at its low value:  \n\n```\ndiff --git a/contracts/p1/mixins/RecollateralizationLib.sol b/contracts/p1/mixins/RecollateralizationLib.sol\nindex 648d1813..b5b86cac 100644\n--- a/contracts/p1/mixins/RecollateralizationLib.sol\n+++ b/contracts/p1/mixins/RecollateralizationLib.sol\n@@ -261,7 +261,8 @@ library RecollateralizationLibP1 {\n \n             // Intentionally include value of IFFY/DISABLED collateral when low is nonzero\n             // {UoA} = {UoA} + {UoA/tok} * {tok}\n-            assetsLow += low.mul(bal, FLOOR);\n+            uint192 assetLow = low.mul(bal,FLOOR);\n+            assetsLow += assetLow;\n             // += is same as Fix.plus\n \n             // assetsHigh += high.mul(bal, CEIL), where assetsHigh is [0, FIX_MAX]\n@@ -272,7 +273,7 @@ library RecollateralizationLibP1 {\n             // += is same as Fix.plus\n \n             // Accumulate potential losses to dust\n-            potentialDustLoss = potentialDustLoss.plus(rules.minTradeVolume);\n+            potentialDustLoss = potentialDustLoss.plus(fixMin(rules.minTradeVolume, assetLow));\n         }\n \n         // Account for all the places dust could get stuck\n```\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-reserve-contest",
  "Code": [
    {
      "filename": "contracts/p1/mixins/RecollateralizationLib.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/IAsset.sol\";\nimport \"../../interfaces/IAssetRegistry.sol\";\nimport \"../../interfaces/IBackingManager.sol\";\nimport \"../../libraries/Fixed.sol\";\nimport \"./TradeLib.sol\";\n\n/// Struct purposes:\n///   1. Stay under stack limit with fewer vars\n///   2. Cache information such as component addresses + trading rules to save on gas\n\nstruct ComponentCache {\n    IBackingManager bm;\n    IBasketHandler bh;\n    IAssetRegistry reg;\n    IStRSR stRSR;\n    IERC20 rsr;\n    IRToken rToken;\n}\n\nstruct TradingRules {\n    uint192 minTradeVolume; // {UoA}\n    uint192 maxTradeSlippage; // {1}\n}\n\nstruct TradeInfo {\n    IAsset sell;\n    IAsset buy;\n    uint192 sellAmount; // {sellTok}\n    uint192 buyAmount; // {buyTok}\n    uint192 sellPrice; // {UoA/sellTok} can be 0\n    uint192 buyPrice; // {UoA/buyTok}\n}\n\n/**\n * @title RecollateralizationLibP1\n * @notice An informal extension of the Trading mixin that provides trade preparation views\n *   Users:\n *     - BackingManager\n *     - RTokenAsset\n *\n * Interface:\n *  1. prepareRecollateralizationTrade (external)\n *  2. basketRange (internal)\n */\nlibrary RecollateralizationLibP1 {\n    using FixLib for uint192;\n    using TradeLib for TradeInfo;\n    using TradeLib for IBackingManager;\n\n    /// Select and prepare a trade that moves us closer to capitalization, using the\n    /// basket range to avoid overeager/duplicate trading.\n    // This is the \"main loop\" for recollateralization trading:\n    // actions:\n    //   let range = basketRange(all erc20s)\n    //   let trade = nextTradePair(...)\n    //   if trade.sell is not a defaulted collateral, prepareTradeToCoverDeficit(...)\n    //   otherwise, prepareTradeSell(trade) with a 0 minBuyAmount\n    function prepareRecollateralizationTrade(IBackingManager bm)\n        external\n        view\n        returns (bool doTrade, TradeRequest memory req)\n    {\n        // === Prepare cached values ===\n\n        IMain main = bm.main();\n        ComponentCache memory components = ComponentCache({\n            bm: bm,\n            bh: main.basketHandler(),\n            reg: main.assetRegistry(),\n            stRSR: main.stRSR(),\n            rsr: main.rsr(),\n            rToken: main.rToken()\n        });\n        TradingRules memory rules = TradingRules({\n            minTradeVolume: bm.minTradeVolume(),\n            maxTradeSlippage: bm.maxTradeSlippage()\n        });\n\n        Registry memory reg = components.reg.getRegistry();\n\n        // ============================\n\n        // Compute basket range -  {BU}\n        BasketRange memory range = basketRange(components, rules, reg);\n\n        // Select a pair to trade next, if one exists\n        TradeInfo memory trade = nextTradePair(components, rules, reg, range);\n\n        // Don't trade if no pair is selected\n        if (address(trade.sell) == address(0) || address(trade.buy) == address(0)) {\n            return (false, req);\n        }\n\n        // If we are selling an unpriced asset or UNSOUND collateral, do not try to cover deficit\n        if (\n            trade.sellPrice == 0 ||\n            (trade.sell.isCollateral() &&\n                ICollateral(address(trade.sell)).status() != CollateralStatus.SOUND)\n        ) {\n            (doTrade, req) = trade.prepareTradeSell(rules);\n        } else {\n            (doTrade, req) = trade.prepareTradeToCoverDeficit(rules);\n        }\n\n        // At this point doTrade _must_ be true, otherwise nextTradePair assumptions are broken\n        assert(doTrade);\n\n        return (doTrade, req);\n    }\n\n    // Used to avoid stack-too-deep errors in basketRange\n    struct BasketRange {\n        uint192 top; // {BU}\n        uint192 bottom; // {BU}\n    }\n\n    // It's a precondition for all below internal helpers that their `erc20s` argument contains at\n    // least all basket collateral, plus any registered assets for which the BackingManager has a\n    // nonzero balance. Any user of these functions should just pass in assetRegistry().erc20s(). We\n    // would prefer to look it up from inside each function, and avoid the extra parameter to get\n    // wrong, but the erc20s() call is pretty expensive.\n\n    // This function returns a \"plausible range of BUs\" assuming that the trading process follows\n    //     the following rules:\n    //\n    // - We will not aim to hold more than rToken.basketsNeeded() BUs\n    // - No double trades: if we buy B in one trade, we won't sell B in another trade\n    //       Caveat: Unless the asset we're selling is IFFY/DISABLED\n    // - The best amount of an asset we can sell is our balance minus any backing requirements;\n    //       the worst is (our balance) - (backing requirement) - (its dust amount)\n    // - The best price we might get for a trade is at the high sell price and low buy price\n    // - The worst price we might get for a trade between assets is at the low sell price and\n    //     the high buy price, multiplied by ( 1 - maxTradeSlippage )\n    // - Given all that, we're aiming to hold as many BUs as possible using the assets we own.\n    //\n    // Given these assumptions, the following hold:\n    //\n    // range.top = min(rToken.basketsNeeded, totalAssetValue(erc20s).high / basket.price().low)\n    //   because (totalAssetValue(erc20s).high / basket.price().low) is how many BUs we can hold\n    //   given \"best plausible\" prices, and we shouldn't hold more than rToken(bm).basketsNeeded\n    //\n    // range.bottom = max(0, min(lowBUs, range.top)), where:\n    //   lowBUs = (assetsLow - maxTradeSlippage * buShortfall(range.top)) / basket.price().high\n    //     is the number of BUs that we are *sure* we have the assets to collateralize, and\n    //   buShortfall(range.top) = the total value of the assets we'd need to buy in order\n    //     in order to fully collateralize `range.top` BUs,\n    //\n    function basketRange(\n        ComponentCache memory components,\n        TradingRules memory rules,\n        Registry memory reg\n    ) internal view returns (BasketRange memory range) {\n        // basketPrice: The current UoA value of one basket.\n        (uint192 basketPriceLow, uint192 basketPriceHigh) = components.bh.price();\n\n        // assetsHigh: The most value we could get from the assets in erc20,\n        //             assuming frictionless trades at currently-estimated prices.\n        // assetsLow: The least value we might get from the assets in erc20,\n        //            assuming frictionless trades, zero value from unreliable prices, and\n        //            dustAmount of assets left in each Asset.\n        // {UoA}\n        (uint192 assetsLow, uint192 assetsHigh) = totalAssetValue(components, rules, reg);\n\n        // ==== Calculate range.top ====\n\n        // basketsHigh: The most amount of BUs we could possibly get from `assetsHigh`\n        // {BU} = {1} * {UoA} / {UoA/BU}\n        uint192 basketsHigh = components.bm.safeMulDivCeil(FIX_ONE, assetsHigh, basketPriceLow);\n\n        // range.top: The most amount of BUs we should possibly aim to hold\n        range.top = fixMin(basketsHigh, components.rToken.basketsNeeded());\n\n        // ==== Calculate range.bottom ====\n\n        // shortfall: The total value of collateral in shortfall of `range.top`. Specifically:\n        //   sum( shortfall(c, range.top) for each erc20 c in the basket)\n        //   where shortfall(c, BUs) == (BUs * bh.quantity(c) - c.bal(bm)) * c.price().high\n        //         (that is, shortfall(c, BUs) is the market value of the c that `this` would\n        //          need to be given in order to have enough of c to cover `range.top` BUs)\n        // {UoA}\n        uint192 shortfall = collateralShortfall(components, range.top);\n\n        // shortfallSlippage: The total amount of slippage we'd see if we took max slippage\n        //                    while trading `shortfall` value\n        // {UoA} = {1} * {UoA} / {1}\n        uint192 shortfallSlippage = rules.maxTradeSlippage.mulDiv(\n            shortfall,\n            FIX_ONE.minus(rules.maxTradeSlippage),\n            CEIL\n        );\n\n        // Take shortfallSlippage out of assetsLow\n        assetsLow = assetsLow.gt(shortfallSlippage) ? assetsLow.minus(shortfallSlippage) : 0;\n\n        // range.bottom: The least amount of BUs we could possibly end up holding after trading\n        // {BU} = {UoA} / {UoA/BU}\n        range.bottom = fixMin(assetsLow.div(basketPriceHigh, CEIL), range.top);\n    }\n\n    // ===========================================================================================\n\n    // === Private ===\n\n    /// Total value of the erc20s under management by BackingManager\n    /// This may include BackingManager's balances _and_ staked RSR held by stRSR\n    /// @param reg ERC20/Asset registry \"under management\" by BackingManager in this computation\n    /// @return assetsLow {UoA} The low estimate of the total value of assets under management\n    /// @return assetsHigh {UoA} The high estimate of the total value of assets under management\n\n    // preconditions:\n    //   components.bm is backingManager\n    //   erc20s has no duplicates\n    // checks:\n    //   for e in erc20s, e has a registered asset in the assetRegistry\n    // return values:\n    // assetsHigh: The most value we could get from the assets in erc20,\n    //             assuming frictionless trades at best-case prices.\n    // assetsLow: The least value we might get from the assets in erc20,\n    //            assuming frictionless trades at worst-case prices,\n    //            zero value from unpriceable assets, and\n    //            dustAmount of assets left behind for each Asset.\n    function totalAssetValue(\n        ComponentCache memory components,\n        TradingRules memory rules,\n        Registry memory reg\n    ) private view returns (uint192 assetsLow, uint192 assetsHigh) {\n        // The low estimate is lower than the high estimate due to:\n        // - Using worst-case prices rather than best-case (price().low instead of price().high)\n        // - Discounting assets with unbounded worst-case price\n        // - Discounting dust amounts for collateral in the basket + non-dust assets\n\n        uint192 potentialDustLoss; // {UoA}\n\n        // Accumulate:\n        // - assetsHigh: sum(bal(e)*price(e).high for e ... )\n        // - potentialDustLoss: sum(minTradeVolume(e) for e ... )\n        // - assetsLow: sum(bal(e)*price(e).low for e ... )\n        for (uint256 i = 0; i < reg.erc20s.length; ++i) {\n            // Exclude RToken balances to avoid double counting value\n            if (reg.erc20s[i] == IERC20(address(components.rToken))) continue;\n\n            uint192 bal = reg.assets[i].bal(address(components.bm)); // {tok}\n\n            // For RSR, include the staking balance\n            if (reg.erc20s[i] == components.rsr) {\n                bal = bal.plus(reg.assets[i].bal(address(components.stRSR)));\n            }\n\n            (uint192 low, uint192 high) = reg.assets[i].price(); // {UoA/tok}\n            (uint192 lotLow, ) = reg.assets[i].lotPrice(); // {UoA/tok}\n\n            // Ignore dust amounts for assets not in the basket; their value is inaccessible\n            if (\n                components.bh.quantity(reg.erc20s[i]) == 0 &&\n                !TradeLib.isEnoughToSell(reg.assets[i], bal, lotLow, rules.minTradeVolume)\n            ) continue;\n\n            // Intentionally include value of IFFY/DISABLED collateral when low is nonzero\n            // {UoA} = {UoA} + {UoA/tok} * {tok}\n            assetsLow += low.mul(bal, FLOOR);\n            // += is same as Fix.plus\n\n            // assetsHigh += high.mul(bal, CEIL), where assetsHigh is [0, FIX_MAX]\n            // {UoA} = {UoA/tok} * {tok}\n            uint192 val = components.bm.safeMulDivCeil(high, bal, FIX_ONE);\n            if (uint256(assetsHigh) + val >= FIX_MAX) assetsHigh = FIX_MAX;\n            else assetsHigh += val;\n            // += is same as Fix.plus\n\n            // Accumulate potential losses to dust\n            potentialDustLoss = potentialDustLoss.plus(rules.minTradeVolume);\n        }\n\n        // Account for all the places dust could get stuck\n        // assetsLow' = max(assetsLow-potentialDustLoss, 0)\n        assetsLow = assetsLow.gt(potentialDustLoss) ? assetsLow.minus(potentialDustLoss) : FIX_ZERO;\n    }\n\n    // Used in memory in `nextTradePair` to duck the stack limit\n    struct MaxSurplusDeficit {\n        CollateralStatus surplusStatus; // starts SOUND\n        uint192 surplus; // {UoA}\n        uint192 deficit; // {UoA}\n    }\n\n    // Choose next sell/buy pair to trade, with reference to the basket range\n    // Skip over trading surplus dust amounts\n    /// @return trade\n    ///   sell: Surplus collateral OR address(0)\n    ///   deficit Deficit collateral OR address(0)\n    ///   sellAmount {sellTok} Surplus amount (whole tokens)\n    ///   buyAmount {buyTok} Deficit amount (whole tokens)\n    ///   sellPrice {UoA/sellTok} The worst-case price of the sell token on secondary markets\n    ///   buyPrice {UoA/sellTok} The worst-case price of the buy token on secondary markets\n    ///\n    // Defining \"sell\" and \"buy\":\n    // If bal(e) > (quantity(e) * range.top), then e is in surplus by the difference\n    // If bal(e) < (quantity(e) * range.bottom), then e is in deficit by the difference\n    //\n    // First, ignoring RSR:\n    //   `trade.sell` is the token from erc20s with the greatest surplus value (in UoA),\n    //   and sellAmount is the quantity of that token that it's in surplus (in qTok).\n    //   if `trade.sell` == 0, then no token is in surplus by at least minTradeSize,\n    //        and `trade.sellAmount` and `trade.sellPrice` are unset.\n    //\n    //   `trade.buy` is the token from erc20s with the greatest deficit value (in UoA),\n    //   and buyAmount is the quantity of that token that it's in deficit (in qTok).\n    //   if `trade.buy` == 0, then no token is in deficit at all,\n    //        and `trade.buyAmount` and `trade.buyPrice` are unset.\n    //\n    // Then, just if we have a buy asset and no sell asset, consider selling available RSR.\n    //\n    // Prefer selling assets in this order: DISABLED -> SOUND -> IFFY.\n    // All collateral in the basket have already been guaranteed to be SOUND by upstream checks.\n    function nextTradePair(\n        ComponentCache memory components,\n        TradingRules memory rules,\n        Registry memory reg,\n        BasketRange memory range\n    ) private view returns (TradeInfo memory trade) {\n        MaxSurplusDeficit memory maxes;\n        maxes.surplusStatus = CollateralStatus.IFFY; // least-desirable sell status\n\n        // No space on the stack to cache erc20s.length\n        for (uint256 i = 0; i < reg.erc20s.length; ++i) {\n            if (reg.erc20s[i] == components.rsr) continue;\n\n            uint192 bal = reg.assets[i].bal(address(components.bm)); // {tok}\n\n            // {tok} = {BU} * {tok/BU}\n            // needed(Top): token balance needed for range.top baskets: quantity(e) * range.top\n            uint192 needed = range.top.mul(components.bh.quantity(reg.erc20s[i]), CEIL); // {tok}\n            if (bal.gt(needed)) {\n                uint192 low; // {UoA/sellTok}\n\n                // this wonky block is just for getting around the stack limit\n                {\n                    uint192 high; // {UoA/sellTok}\n                    (low, high) = reg.assets[i].price(); // {UoA/sellTok}\n\n                    // Skip worthless assets\n                    if (high == 0) continue;\n                }\n\n                (uint192 lotLow, ) = reg.assets[i].lotPrice(); // {UoA/sellTok}\n\n                // {UoA} = {sellTok} * {UoA/sellTok}\n                uint192 delta = bal.minus(needed).mul(lotLow, FLOOR);\n\n                // status = asset.status() if asset.isCollateral() else SOUND\n                CollateralStatus status; // starts SOUND\n                if (reg.assets[i].isCollateral()) {\n                    status = ICollateral(address(reg.assets[i])).status();\n                }\n\n                // Select the most-in-surplus \"best\" asset still enough to sell,\n                // as defined by a (status, surplusAmt) ordering\n                if (\n                    isBetterSurplus(maxes, status, delta) &&\n                    TradeLib.isEnoughToSell(\n                        reg.assets[i],\n                        bal.minus(needed),\n                        lotLow,\n                        rules.minTradeVolume\n                    )\n                ) {\n                    trade.sell = reg.assets[i];\n                    trade.sellAmount = bal.minus(needed);\n                    trade.sellPrice = low;\n\n                    maxes.surplusStatus = status;\n                    maxes.surplus = delta;\n                }\n            } else {\n                // needed(Bottom): token balance needed at bottom of the basket range\n                needed = range.bottom.mul(components.bh.quantity(reg.erc20s[i]), CEIL); // {buyTok};\n                if (bal.lt(needed)) {\n                    uint192 amtShort = needed.minus(bal); // {buyTok}\n                    (, uint192 high) = reg.assets[i].price(); // {UoA/buyTok}\n\n                    // {UoA} = {buyTok} * {UoA/buyTok}\n                    uint192 delta = amtShort.mul(high, CEIL);\n\n                    // The best asset to buy is whichever asset has the largest deficit\n                    if (delta.gt(maxes.deficit)) {\n                        trade.buy = ICollateral(address(reg.assets[i]));\n                        trade.buyAmount = amtShort;\n                        trade.buyPrice = high;\n\n                        maxes.deficit = delta;\n                    }\n                }\n            }\n        }\n\n        // Use RSR if needed\n        if (address(trade.sell) == address(0) && address(trade.buy) != address(0)) {\n            IAsset rsrAsset = components.reg.toAsset(components.rsr);\n\n            uint192 rsrAvailable = rsrAsset.bal(address(components.bm)).plus(\n                rsrAsset.bal(address(components.stRSR))\n            );\n            (uint192 low, uint192 high) = rsrAsset.price(); // {UoA/tok}\n            (uint192 lotLow, ) = rsrAsset.lotPrice(); // {UoA/tok}\n\n            if (\n                high > 0 &&\n                TradeLib.isEnoughToSell(rsrAsset, rsrAvailable, lotLow, rules.minTradeVolume)\n            ) {\n                trade.sell = rsrAsset;\n                trade.sellAmount = rsrAvailable;\n                trade.sellPrice = low;\n            }\n        }\n    }\n\n    /// @param basketsTop {BU} The top end of the basket range estimate\n    /// @return shortfall {UoA} The missing re-collateralization in UoA terms\n    // Specifically, returns:\n    //   sum( shortfall(c, basketsLow) for each backing erc20 c in the basket)\n    //   where shortfall(c,numBUs) == (numBus * bh.quantity(c) - c.balanceOf(bm)) * c.price().high\n    //         (that is, shortfall(c, numBUs) is the market value of the c that `this` would\n    //          need to be given in order to have enough of c to cover `basketsTop` BUs)\n    function collateralShortfall(ComponentCache memory components, uint192 basketsTop)\n        private\n        view\n        returns (uint192 shortfall)\n    {\n        IERC20[] memory basketERC20s = components.bh.basketTokens();\n        uint256 len = basketERC20s.length;\n\n        // accumulate shortfall\n        for (uint256 i = 0; i < len; ++i) {\n            ICollateral coll = components.reg.toColl(basketERC20s[i]);\n\n            // {tok} = {BU} * {tok/BU}\n            // needed: quantity of erc20 needed for `basketsTop` BUs\n            uint192 needed = basketsTop.mul(components.bh.quantity(basketERC20s[i]), CEIL); // {tok}\n\n            // held: quantity of erc20 owned by the bm (BackingManager)\n            uint192 held = coll.bal(address(components.bm)); // {tok}\n\n            if (held.lt(needed)) {\n                // use the high estimate because it is the worst-case cost of acquisition\n                (, uint192 priceHigh) = coll.price(); // {UoA/tok}\n\n                // {UoA} = {UoA} + ({tok} - {tok}) * {UoA/tok}\n                shortfall = shortfall.plus(needed.minus(held).mul(priceHigh, CEIL));\n            }\n        }\n    }\n\n    /// @param curr The current MaxSurplusDeficit containing the best surplus so far\n    /// @param other The collateral status of the asset in consideration\n    /// @param surplusAmt {UoA} The amount by which the asset in consideration is in surplus\n    function isBetterSurplus(\n        MaxSurplusDeficit memory curr,\n        CollateralStatus other,\n        uint192 surplusAmt\n    ) private pure returns (bool) {\n        // NOTE: If the CollateralStatus enum changes then this has to change!\n        if (curr.surplusStatus == CollateralStatus.DISABLED) {\n            return other == CollateralStatus.DISABLED && surplusAmt.gt(curr.surplus);\n        } else if (curr.surplusStatus == CollateralStatus.SOUND) {\n            return\n                other == CollateralStatus.DISABLED ||\n                (other == CollateralStatus.SOUND && surplusAmt.gt(curr.surplus));\n        } else {\n            // curr is IFFY\n            return other != CollateralStatus.IFFY || surplusAmt.gt(curr.surplus);\n        }\n    }\n}"
    }
  ]
}