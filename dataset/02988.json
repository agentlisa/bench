{
  "Title": "M-8: Malicious Users Can Deny Notional Treasury From Receiving Fee",
  "Content": "# Issue M-8: Malicious Users Can Deny Notional Treasury From Receiving Fee \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/82 \n\n## Found by \nxiaoming90\n\n## Summary\n\nMalicious users can deny Notional Treasury from receiving fees when rewards are reinvested.\n\n## Vulnerability Detail\n\nThe `claimRewardTokens` function will harvest the reward tokens from the Aura Pool, and the reward tokens will be transferred to the Balancer Vault. At lines 77-78, a portion of the reward tokens would be sent to the `FEE_RECEIVER`. After clarifying with the sponsor, it was understood that the `FEE_RECEIVER` would be set to Notional Treasury so that it would receive some of the accrued reward tokens.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/AuraStakingMixin.sol#L61\n\n```solidity\nFile: AuraStakingMixin.sol\n61:     function claimRewardTokens() external returns (uint256[] memory claimedBalances) {\n62:         uint16 feePercentage = BalancerVaultStorage.getStrategyVaultSettings().feePercentage;\n63:         IERC20[] memory rewardTokens = _rewardTokens();\n64: \n65:         uint256 numRewardTokens = rewardTokens.length;\n66: \n67:         claimedBalances = new uint256[](numRewardTokens);\n68:         for (uint256 i; i < numRewardTokens; i++) {\n69:             claimedBalances[i] = rewardTokens[i].balanceOf(address(this));\n70:         }\n71: \n72:         AURA_REWARD_POOL.getReward(address(this), true);\n73:         for (uint256 i; i < numRewardTokens; i++) {\n74:             claimedBalances[i] = rewardTokens[i].balanceOf(address(this)) - claimedBalances[i];\n75: \n76:             if (claimedBalances[i] > 0 && feePercentage != 0 && FEE_RECEIVER != address(0)) {\n77:                 uint256 feeAmount = claimedBalances[i] * feePercentage / BalancerConstants.VAULT_PERCENT_BASIS;\n78:                 rewardTokens[i].checkTransfer(FEE_RECEIVER, feeAmount);\n79:                 claimedBalances[i] -= feeAmount;\n80:             }\n81:         }\n82: \n83:         emit BalancerEvents.ClaimedRewardTokens(rewardTokens, claimedBalances);\n84:     }\n```\n\nWithin the `claimRewardTokens` function, it will call the ` AURA_REWARD_POOL.getReward` to harvest the reward tokens. Within the `claimRewardTokens` function, it also uses the pre-balance and post-balance of the reward tokens to check the actual amount of reward tokens that are transferred into the vault.\n\nHowever, the issue is that anyone can claim reward tokens from Aura Pool on behalf of any address. Following is the implementation of the `getReward` function taken from Aura's BaseRewardPool4626 contract called by the vault for reference. \n\nhttps://etherscan.io/address/0xdcee1c640cc270121faf145f231fd8ff1d8d5cd4\n\n```solidity\n/**\n * @dev Gives a staker their rewards, with the option of claiming extra rewards\n * @param _account     Account for which to claim\n * @param _claimExtras Get the child rewards too?\n */\nfunction getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){\n    uint256 reward = earned(_account);\n    if (reward > 0) {\n        rewards[_account] = 0;\n        rewardToken.safeTransfer(_account, reward);\n        IDeposit(operator).rewardClaimed(pid, _account, reward);\n        emit RewardPaid(_account, reward);\n    }\n\n    //also get rewards from linked rewards\n    if(_claimExtras){\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).getReward(_account);\n        }\n    }\n    return true;\n}\n\nmodifier updateReward(address account) {\n    rewardPerTokenStored = rewardPerToken();\n    lastUpdateTime = lastTimeRewardApplicable();\n    if (account != address(0)) {\n        rewards[account] = earned(account);\n        userRewardPerTokenPaid[account] = rewardPerTokenStored;\n    }\n    _;\n}\n\nfunction earned(address account) public view returns (uint256) {\n    return\n        balanceOf(account)\n            .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n            .div(1e18)\n            .add(rewards[account]);\n}\n```\n\nAssume that a malicious user front runs a call to claim rewards tokens. When a keeper calls the ` AURA_REWARD_POOL.getReward` to harvest the reward tokens, it will return no reward tokens, and therefore the difference between the pre-balance and post-balance of the reward tokens will amount to zero. Therefore, no reward tokens will be sent to the `FEE_RECEIVER` (Notional Treasury) as a fee.\n\n#### Proof-of-Concept\n\nThe `test_claim_rewards_success` test case shows that under normal circumstances, the Notional treasury will receive a portion of the accrued BAL and AURA as fees.\n\nThe `test_claim_rewards_success_frontrun` test case shows that if the `getReward` is front-run by an attacker, the Notional treasury will receive nothing.\n\nThe following is the test script and its result. \n\n```python\nimport pytest\nfrom brownie import ZERO_ADDRESS, Wei, accounts, interface\nfrom tests.fixtures import *\nfrom tests.balancer.helpers import enterMaturity, get_metastable_amounts\nfrom scripts.common import get_univ3_single_data, get_univ3_batch_data, DEX_ID, TRADE_TYPE\n\nchain = Chain()\n\ndef test_claim_rewards_success(StratStableETHstETH):\n    (env, vault) = StratStableETHstETH\n    primaryBorrowAmount = 100e8\n    depositAmount = 50e18\n    enterMaturity(env, vault, 1, 0, depositAmount, primaryBorrowAmount, accounts[0])\n    chain.sleep(3600 * 24 * 365)\n    chain.mine()\n    feeReceiver = vault.getStrategyContext()[\"baseStrategy\"][\"feeReceiver\"]\n    feePercentage = vault.getStrategyContext()[\"baseStrategy\"][\"vaultSettings\"][\"feePercentage\"] / 1e2\n    assert env.tokens[\"BAL\"].balanceOf(vault.address) == 0\n    assert env.tokens[\"AURA\"].balanceOf(vault.address) == 0\n    assert env.tokens[\"BAL\"].balanceOf(feeReceiver) == 0\n    assert env.tokens[\"AURA\"].balanceOf(feeReceiver) == 0\n\n    vault.claimRewardTokens({\"from\": accounts[1]})\n\n    # Test that the fee receiver received portion of the rewards as fee\n    assert env.tokens[\"BAL\"].balanceOf(feeReceiver) > 0\n    assert env.tokens[\"AURA\"].balanceOf(feeReceiver) > 0\n\ndef test_claim_rewards_success_frontrun(StratStableETHstETH):\n    (env, vault) = StratStableETHstETH\n    primaryBorrowAmount = 100e8\n    depositAmount = 50e18\n    enterMaturity(env, vault, 1, 0, depositAmount, primaryBorrowAmount, accounts[0])\n    chain.sleep(3600 * 24 * 365)\n    chain.mine()\n    feeReceiver = vault.getStrategyContext()[\"baseStrategy\"][\"feeReceiver\"]\n    feePercentage = vault.getStrategyContext()[\"baseStrategy\"][\"vaultSettings\"][\"feePercentage\"] / 1e2\n    assert env.tokens[\"BAL\"].balanceOf(vault.address) == 0\n    assert env.tokens[\"AURA\"].balanceOf(vault.address) == 0\n    assert env.tokens[\"BAL\"].balanceOf(feeReceiver) == 0\n    assert env.tokens[\"AURA\"].balanceOf(feeReceiver) == 0\n\n    auraPool = interface.IAuraRewardPool(vault.getStrategyContext()[\"stakingContext\"][\"auraRewardPool\"])\n    auraPool.getReward(vault.address, True, {\"from\": accounts[5]}) # Attacker frontrun the getReward\n    vault.claimRewardTokens({\"from\": accounts[1]})\n\n    # Test that the fee receiver received nothing due the frontrunning\n    assert env.tokens[\"BAL\"].balanceOf(feeReceiver) == 0\n    assert env.tokens[\"AURA\"].balanceOf(feeReceiver) == 0\n```\n\n```bash\n‚ùØ brownie test tests/balancer/rewards/test_rewards_stable_eth_steth.py --network mainnet-fork\nBrownie v1.18.1 - Python development framework for Ethereum\n\n=============================================================================================== test session starts ===============================================================================================\nplatform linux -- Python 3.8.10, pytest-6.2.5, py-1.11.0, pluggy-1.0.0\nplugins: eth-brownie-1.18.1, hypothesis-6.27.3, forked-1.4.0, xdist-1.34.0, web3-5.27.0\ncollected 2 items                                                                                                                                                                                                 \nAttached to local RPC client listening at '127.0.0.1:8545'...\n\ntests/balancer/rewards/test_rewards_stable_eth_steth.py ..                                                                                                                                                  [100%]\n\n========================================================================================== 2 passed, 1 warning in 5.72s ===========================================================================================\n```\n\n## Impact\n\nNotional Treasury will not receive a portion of the accrued reward tokens as fees. Loss of assets for Notional protocol and its governance token holders.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/AuraStakingMixin.sol#L61\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is recommended not to use the pre-balance and post-balance of the reward tokens when claiming reward tokens. A more robust internal accounting scheme needs to be implemented to keep track of actual reward tokens received from the pool so that the appropriate amount of the accrued reward tokens can be sent to the Notional Treasury.\n\n#### Reference\n\nA similar high-risk issue was found in the past audit report\n\n- https://code4rena.com/reports/2022-01-notional/#h-01-treasury-cannot-claim-comp-tokens--comp-tokens-are-stuck\n\n## Discussion\n\n**jeffywu**\n\n@weitianjie2000 having some internal accounting seems reasonable here.\n\n**T-Woodward**\n\nThink low severity is reasonable here\n\n**Evert0x**\n\n@T-Woodward why is this a low? Seems like a loss for Notional Treasury and NOTE token holders\n\n**T-Woodward**\n\nYeah I mean I just don't see it as such a big deal. No loss to user funds. If it started to happen we could just upgrade it out\n\n**jeffywu**\n\nI think given that the CodeArena issue was graded a High, I think Medium is ok as a severity here. I couldn't find the severity guidelines as a reference. The net effect here would be a small loss for the Notional Treasury and NOTE token.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/mixins/AuraStakingMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {AuraStakingContext} from \"../BalancerVaultTypes.sol\";\nimport {ILiquidityGauge} from \"../../../../interfaces/balancer/ILiquidityGauge.sol\";\nimport {IAuraBooster} from \"../../../../interfaces/aura/IAuraBooster.sol\";\nimport {IAuraRewardPool} from \"../../../../interfaces/aura/IAuraRewardPool.sol\";\nimport {IAuraStakingProxy} from \"../../../../interfaces/aura/IAuraStakingProxy.sol\";\nimport {TokenUtils, IERC20} from \"../../../utils/TokenUtils.sol\";\nimport {StrategyVaultSettings, BalancerVaultStorage} from \"../internal/BalancerVaultStorage.sol\";\nimport {BalancerConstants} from \"../internal/BalancerConstants.sol\";\nimport {BalancerEvents} from \"../BalancerEvents.sol\";\n\nabstract contract AuraStakingMixin {\n    using TokenUtils for IERC20;\n\n    /// @notice Balancer liquidity gauge used to get a list of reward tokens\n    ILiquidityGauge internal immutable LIQUIDITY_GAUGE;\n    /// @notice Aura booster contract used for staking BPT\n    IAuraBooster internal immutable AURA_BOOSTER;\n    /// @notice Aura reward pool contract used for unstaking and claiming reward tokens\n    IAuraRewardPool internal immutable AURA_REWARD_POOL;\n    uint256 internal immutable AURA_POOL_ID;\n    /// @notice The address used to receive a portion of the reward tokens\n    address internal immutable FEE_RECEIVER;\n    IERC20 internal immutable BAL_TOKEN;\n    IERC20 internal immutable AURA_TOKEN;\n\n    constructor(ILiquidityGauge liquidityGauge, IAuraRewardPool auraRewardPool, address feeReceiver) {\n        LIQUIDITY_GAUGE = liquidityGauge;\n        AURA_REWARD_POOL = auraRewardPool;\n        FEE_RECEIVER = feeReceiver;\n        AURA_BOOSTER = IAuraBooster(AURA_REWARD_POOL.operator());\n        AURA_POOL_ID = AURA_REWARD_POOL.pid();\n\n        IAuraStakingProxy stakingProxy = IAuraStakingProxy(AURA_BOOSTER.stakerRewards());\n        BAL_TOKEN = IERC20(stakingProxy.crv());\n        AURA_TOKEN = IERC20(stakingProxy.cvx());\n    }\n\n    function _rewardTokens() private view returns (IERC20[] memory tokens) {\n        uint256 rewardTokenCount = LIQUIDITY_GAUGE.reward_count() + 2;\n        tokens = new IERC20[](rewardTokenCount);\n        tokens[0] = BAL_TOKEN;\n        tokens[1] = AURA_TOKEN;\n        for (uint256 i = 2; i < rewardTokenCount; i++) {\n            tokens[i] = IERC20(LIQUIDITY_GAUGE.reward_tokens(i - 2));\n        }\n    }\n\n    function _auraStakingContext() internal view returns (AuraStakingContext memory) {\n        return AuraStakingContext({\n            liquidityGauge: LIQUIDITY_GAUGE,\n            auraBooster: AURA_BOOSTER,\n            auraRewardPool: AURA_REWARD_POOL,\n            auraPoolId: AURA_POOL_ID,\n            rewardTokens: _rewardTokens()\n        });\n    }\n\n    function claimRewardTokens() external returns (uint256[] memory claimedBalances) {\n        uint16 feePercentage = BalancerVaultStorage.getStrategyVaultSettings().feePercentage;\n        IERC20[] memory rewardTokens = _rewardTokens();\n\n        uint256 numRewardTokens = rewardTokens.length;\n\n        claimedBalances = new uint256[](numRewardTokens);\n        for (uint256 i; i < numRewardTokens; i++) {\n            claimedBalances[i] = rewardTokens[i].balanceOf(address(this));\n        }\n\n        AURA_REWARD_POOL.getReward(address(this), true);\n        for (uint256 i; i < numRewardTokens; i++) {\n            claimedBalances[i] = rewardTokens[i].balanceOf(address(this)) - claimedBalances[i];\n\n            if (claimedBalances[i] > 0 && feePercentage != 0 && FEE_RECEIVER != address(0)) {\n                uint256 feeAmount = claimedBalances[i] * feePercentage / BalancerConstants.VAULT_PERCENT_BASIS;\n                rewardTokens[i].checkTransfer(FEE_RECEIVER, feeAmount);\n                claimedBalances[i] -= feeAmount;\n            }\n        }\n\n        emit BalancerEvents.ClaimedRewardTokens(rewardTokens, claimedBalances);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/mixins/AuraStakingMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {AuraStakingContext} from \"../BalancerVaultTypes.sol\";\nimport {ILiquidityGauge} from \"../../../../interfaces/balancer/ILiquidityGauge.sol\";\nimport {IAuraBooster} from \"../../../../interfaces/aura/IAuraBooster.sol\";\nimport {IAuraRewardPool} from \"../../../../interfaces/aura/IAuraRewardPool.sol\";\nimport {IAuraStakingProxy} from \"../../../../interfaces/aura/IAuraStakingProxy.sol\";\nimport {TokenUtils, IERC20} from \"../../../utils/TokenUtils.sol\";\nimport {StrategyVaultSettings, BalancerVaultStorage} from \"../internal/BalancerVaultStorage.sol\";\nimport {BalancerConstants} from \"../internal/BalancerConstants.sol\";\nimport {BalancerEvents} from \"../BalancerEvents.sol\";\n\nabstract contract AuraStakingMixin {\n    using TokenUtils for IERC20;\n\n    /// @notice Balancer liquidity gauge used to get a list of reward tokens\n    ILiquidityGauge internal immutable LIQUIDITY_GAUGE;\n    /// @notice Aura booster contract used for staking BPT\n    IAuraBooster internal immutable AURA_BOOSTER;\n    /// @notice Aura reward pool contract used for unstaking and claiming reward tokens\n    IAuraRewardPool internal immutable AURA_REWARD_POOL;\n    uint256 internal immutable AURA_POOL_ID;\n    /// @notice The address used to receive a portion of the reward tokens\n    address internal immutable FEE_RECEIVER;\n    IERC20 internal immutable BAL_TOKEN;\n    IERC20 internal immutable AURA_TOKEN;\n\n    constructor(ILiquidityGauge liquidityGauge, IAuraRewardPool auraRewardPool, address feeReceiver) {\n        LIQUIDITY_GAUGE = liquidityGauge;\n        AURA_REWARD_POOL = auraRewardPool;\n        FEE_RECEIVER = feeReceiver;\n        AURA_BOOSTER = IAuraBooster(AURA_REWARD_POOL.operator());\n        AURA_POOL_ID = AURA_REWARD_POOL.pid();\n\n        IAuraStakingProxy stakingProxy = IAuraStakingProxy(AURA_BOOSTER.stakerRewards());\n        BAL_TOKEN = IERC20(stakingProxy.crv());\n        AURA_TOKEN = IERC20(stakingProxy.cvx());\n    }\n\n    function _rewardTokens() private view returns (IERC20[] memory tokens) {\n        uint256 rewardTokenCount = LIQUIDITY_GAUGE.reward_count() + 2;\n        tokens = new IERC20[](rewardTokenCount);\n        tokens[0] = BAL_TOKEN;\n        tokens[1] = AURA_TOKEN;\n        for (uint256 i = 2; i < rewardTokenCount; i++) {\n            tokens[i] = IERC20(LIQUIDITY_GAUGE.reward_tokens(i - 2));\n        }\n    }\n\n    function _auraStakingContext() internal view returns (AuraStakingContext memory) {\n        return AuraStakingContext({\n            liquidityGauge: LIQUIDITY_GAUGE,\n            auraBooster: AURA_BOOSTER,\n            auraRewardPool: AURA_REWARD_POOL,\n            auraPoolId: AURA_POOL_ID,\n            rewardTokens: _rewardTokens()\n        });\n    }\n\n    function claimRewardTokens() external returns (uint256[] memory claimedBalances) {\n        uint16 feePercentage = BalancerVaultStorage.getStrategyVaultSettings().feePercentage;\n        IERC20[] memory rewardTokens = _rewardTokens();\n\n        uint256 numRewardTokens = rewardTokens.length;\n\n        claimedBalances = new uint256[](numRewardTokens);\n        for (uint256 i; i < numRewardTokens; i++) {\n            claimedBalances[i] = rewardTokens[i].balanceOf(address(this));\n        }\n\n        AURA_REWARD_POOL.getReward(address(this), true);\n        for (uint256 i; i < numRewardTokens; i++) {\n            claimedBalances[i] = rewardTokens[i].balanceOf(address(this)) - claimedBalances[i];\n\n            if (claimedBalances[i] > 0 && feePercentage != 0 && FEE_RECEIVER != address(0)) {\n                uint256 feeAmount = claimedBalances[i] * feePercentage / BalancerConstants.VAULT_PERCENT_BASIS;\n                rewardTokens[i].checkTransfer(FEE_RECEIVER, feeAmount);\n                claimedBalances[i] -= feeAmount;\n            }\n        }\n\n        emit BalancerEvents.ClaimedRewardTokens(rewardTokens, claimedBalances);\n    }\n}"
    }
  ]
}