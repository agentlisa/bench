{
  "Title": "[G-04] Shift right or left instead of dividing or multiply by 2",
  "Content": "\nShifting one to the right will calculate a division by two.\n\nhe `SHR` opcode only requires 3 gas, compared to the `DIV` opcode's consumption of 5. Additionally, shifting is used to get around Solidity's division operation's division-by-0 prohibition.\n\n**Proof of concept (*without optimizations*):**\n\n```javascript\npragma solidity 0.8.16;\n\ncontract TesterA {\nfunction testDiv(uint a) public returns (uint) { return a / 2; }\n}\n\ncontract TesterB {\nfunction testShift(uint a) public returns (uint) { return a >> 1; }\n}\n```\n\nGas saving executing: **172 per entry**\n\n    TesterA.testDiv:    21965 \n    TesterB.testShift:  21793   \n\nThe same optimization can be used to multiply by 2, using the left shift.\n\n```javascript\npragma solidity 0.8.16;\n\ncontract TesterA {\nfunction testMul(uint a) public returns (uint) { return a * 2; }\n}\n\ncontract TesterB {\nfunction testShift(uint a) public returns (uint) { return a << 1; }\n}\n```\n\nGas saving executing: **201 per entry**\n\n    TesterA.testMul:    21994\n    TesterB.testShift:  21793    \n\n**Affected source code:**\n\n`/`:\n\n*   [Merkle.sol:34](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/libraries/Merkle.sol#L34)\n\n### Total gas saved: **(172 &ast; 1) = 172**\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-10-zksync-v2-contest",
  "Code": [
    {
      "filename": "ethereum/contracts/zksync/libraries/Merkle.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"../../common/libraries/UncheckedMath.sol\";\n\n/// @author Matter Labs\nlibrary Merkle {\n    using UncheckedMath for uint256;\n\n    /// @dev Calculate Merkle root by the provided Merkle proof.\n    /// NOTE: When using this function, check that the _path length is equal to the tree height to prevent shorter/longer paths attack\n    /// @param _path Merkle path from the leaf to the root\n    /// @param _index Leaf index in the tree\n    /// @param _itemHash Hash of leaf content\n    /// @return The Merkle root\n    function calculateRoot(\n        bytes32[] calldata _path,\n        uint256 _index,\n        bytes32 _itemHash\n    ) internal pure returns (bytes32) {\n        uint256 pathLength = _path.length;\n        require(pathLength > 0, \"xc\");\n        require(pathLength < 256, \"bt\");\n        require(_index < 2**pathLength, \"pz\");\n\n        bytes32 currentHash = _itemHash;\n        for (uint256 i = 0; i < pathLength; i = i.uncheckedInc()) {\n            if (_index % 2 == 0) {\n                currentHash = keccak256(abi.encode(currentHash, _path[i]));\n            } else {\n                currentHash = keccak256(abi.encode(_path[i], currentHash));\n            }\n            _index /= 2;\n        }\n\n        return currentHash;\n    }\n}"
    }
  ]
}