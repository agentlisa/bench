{
  "Title": "[L08] Unclear comments and naming",
  "Content": "Throughout the codebase, there are many spots in which variable names or comments are unclear. The examples we identified are:\n\n\n* The [constant `DENOMINATORS` and the mappings `multipliers`, `poolCaps`, and `accountLimits`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Allowlist.sol#L16-L20) within the [`Allowlist` contract](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Allowlist.sol) have no comments explaining their intended use.\n* The [variables `swapStorage`, `allowlist`, and `isGuarded` and the mapping `tokenIndexes`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L35-L38) within the [`Swap` contract](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol) have no comments explaining their intended use.\n* The acronym `TVL` on [line 84](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Allowlist.sol#L84) and [line 86](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Allowlist.sol#L86) of the [`Allowlist` contract](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Allowlist.sol) is not explicitly stated.\n* On lines [193](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L193) and [196](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L196) of the `SwapUtils` contract, `dy` is mentioned but isn’t explained.\n* The variables `xp`, `A`, `nA`, `D`, `dP`, `b`, `c`, `y`, `xpi`, `D0`, `D1`, `v`, `A0`, `A1`, `t0`, `t1`, `dx`, and `dy` within the [`SwapUtils` contract](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol) are used frequently, but are not descriptive in their naming. Consider renaming such variables to be more descriptive, or highlighting their analog values in Curve.\n* The choice of value `0x54dd1e` in [`Allowlist`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Allowlist.sol#L32-L33) and [`Swap`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L133) is arbitrary, and comments or documentation should exist to indicate this so that it is clear the value has no particular meaning.\n* The [comments before `getYD`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L258-L260) mention precision-adjusted balances duplicately. Consider removing one mention of precision-adjusted balances in this comment.\n\n\nConsider adding comments throughout your codebase to ensure the purpose of every aspect is clear, including clarifying the above examples. Doing so will aid future development efforts and reduce the surface for error.\n\n\n***Update:** partially fixed in [pull request 202](https://github.com/saddle-finance/saddle-contract/pull/202/files). The variables `xp`, `A`, and others identified in the 5th bullet have not been renamed. Saddle’s statement for this issue:*\n\n\n\n> \n>  External document/wiki will include information about which function is analogous to those in curve’s\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Allowlist.sol",
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/IAllowlist.sol\";\n\n/**\n * @title Allowlist\n * @notice This contract is a registry holding information about how much each swap contract should\n * contain upto. Swap.sol will rely on this contract to determine whether the pool cap is reached and\n * also whether a user's deposit limit is reached.\n */\ncontract Allowlist is Ownable, IAllowlist {\n    using SafeMath for uint256;\n\n    uint256 public constant DENOMINATOR = 1e3;\n\n    mapping(address => uint256) private multipliers;\n    mapping(address => uint256) private poolCaps;\n    mapping(address => uint256) private accountLimits;\n\n    event SetMultipliers(address[] addressArray, uint256[] multiplierArray);\n    event PoolCap(address indexed poolAddress, uint256 poolCap);\n    event PoolAccountLimit(address indexed poolAddress, uint256 accountLimit);\n\n    /**\n     * @notice Creates this contract and sets PoolCap of 0x0 with uint256(0x54dd1e) for\n     * crude checking whether an address holds this contract\n     */\n    constructor() public {\n        // This value will be used as a way of crude checking whether an address holds this Allowlist contract\n        poolCaps[address(0x0)] = uint256(0x54dd1e);\n        emit PoolCap(address(0x0), uint256(0x54dd1e));\n    }\n\n    /**\n     * @notice Returns stored allowed amount for the user at the given pool address.\n     * @param poolAddress address of the pool\n     * @param user address of the user\n     */\n    function getAllowedAmount(address poolAddress, address user) external view returns (uint256) {\n        return accountLimits[poolAddress].mul(multipliers[user]).div(DENOMINATOR);\n    }\n\n    /**\n     * @notice Returns the TVL cap for given pool address.\n     * @param poolAddress address of the pool\n     */\n    function getPoolCap(address poolAddress) external view returns (uint256) {\n        return poolCaps[poolAddress];\n    }\n\n    // ADMIN FUNCTIONS\n\n    /**\n     * @notice Set multipliers for given addresses\n     * @param addressArray array of addresses\n     * @param multiplierArray array of multipliers for respective addresses\n     *        (multiplier set to 1000 equals 1.000x)\n     */\n    function setMultipliers(address[] calldata addressArray, uint256[] calldata multiplierArray) external onlyOwner {\n\n        require(addressArray.length == multiplierArray.length, \"Array lengths are different\");\n\n        for (uint256 i = 0; i < multiplierArray.length; i++) {\n            multipliers[addressArray[i]] = multiplierArray[i];\n        }\n\n        emit SetMultipliers(addressArray, multiplierArray);\n    }\n\n    /**\n     * @notice Set account limit of allowed deposit amounts for the given pool\n     * @param poolAddress address of the pool\n     * @param accountLimit base amount to be used for calculating allowed amounts of each user\n     */\n    function setPoolAccountLimit(address poolAddress, uint256 accountLimit) external onlyOwner {\n        require(poolAddress != address(0x0), \"0x0 is not a pool address\");\n        accountLimits[poolAddress] = accountLimit;\n        emit PoolAccountLimit(poolAddress, accountLimit);\n    }\n\n    /**\n     * @notice Set the TVL cap for given pool address\n     * @param poolAddress address of the pool\n     * @param poolCap TVL cap amount - limits the totalSupply of the pool token\n     */\n    function setPoolCap(address poolAddress, uint256 poolCap) external onlyOwner {\n        require(poolAddress != address(0x0), \"0x0 is not a pool address\");\n        poolCaps[poolAddress] = poolCap;\n        emit PoolCap(poolAddress, poolCap);\n    }\n}"
    },
    {
      "filename": "contracts/Swap.sol",
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./OwnerPausable.sol\";\nimport \"./SwapUtils.sol\";\nimport \"./MathUtils.sol\";\nimport \"./Allowlist.sol\";\n\n/**\n * @title Swap - A StableSwap implementation in solidity.\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * Users can burn pool tokens and withdraw their share of token(s).\n *\n * Each time a swap between the pooled tokens happen, a set fee incurs which effectively get\n * distributed to the LPs.\n *\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * stops the ratio of the tokens in the pool from changing.\n * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\n * deployment size.\n */\ncontract Swap is OwnerPausable, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using MathUtils for uint256;\n    using SwapUtils for SwapUtils.Swap;\n\n    SwapUtils.Swap public swapStorage;\n    IAllowlist public allowlist;\n    bool public isGuarded = true;\n    mapping(address => uint8) private tokenIndexes;\n\n    /*** EVENTS ***/\n\n    // events replicated fromm SwapUtils to make the ABI easier for dumb\n    // clients\n    event TokenSwap(address indexed buyer, uint256 tokensSold,\n        uint256 tokensBought, uint128 soldId, uint128 boughtId\n    );\n    event AddLiquidity(address indexed provider, uint256[] tokenAmounts,\n        uint256[] fees, uint256 invariant, uint256 lpTokenSupply\n    );\n    event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidityOne(address indexed provider, uint256 lpTokenAmount,\n        uint256 lpTokenSupply, uint256 boughtId, uint256 tokensBought\n    );\n    event RemoveLiquidityImbalance(address indexed provider,\n        uint256[] tokenAmounts, uint256[] fees, uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n    event NewWithdrawFee(uint256 newWithdrawFee);\n    event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n    event StopRampA(uint256 A, uint256 time);\n\n    /**\n     * @notice Deploys this Swap contract with given parameters as default\n     * values. This will also deploy a LPToken that represents users\n     * LP position. The owner of LPToken will be this contract - which means\n     * only this contract is allowed to mint new tokens.\n     *\n     * @param _pooledTokens an array of ERC20s this pool will accept\n     * @param precisions the precision to use for each pooled token,\n     * eg 10 ** 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n     * @param lpTokenName the long-form name of the token to be deployed\n     * @param lpTokenSymbol the short symbol for the token to be deployed\n     * @param _A the amplification coefficient * n * (n - 1). See the\n     * StableSwap paper for details\n     * @param _fee default swap fee to be initialized with\n     * @param _adminFee default adminFee to be initialized with\n     * @param _withdrawFee default withdrawFee to be initliazed with\n     * @param _allowlist address of allowlist contract for guarded launch\n     */\n    constructor(\n        IERC20[] memory _pooledTokens, uint256[] memory precisions,\n        string memory lpTokenName, string memory lpTokenSymbol, uint256 _A,\n        uint256 _fee, uint256 _adminFee, uint256 _withdrawFee, IAllowlist _allowlist\n    ) public OwnerPausable() ReentrancyGuard() {\n        require(\n            _pooledTokens.length > 1,\n            \"Pools must contain more than 1 token\"\n        );\n        require(\n            _pooledTokens.length <= 32,\n            \"Pools with over 32 tokens aren't supported\"\n        );\n        require(\n            _pooledTokens.length == precisions.length,\n            \"Each pooled token needs a specified precision\"\n        );\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                require(tokenIndexes[address(_pooledTokens[i])] == 0, \"Pools cannot have duplicate tokens\");\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                precisions[i] <= 10 ** uint256(SwapUtils.getPoolPrecisionDecimals()),\n                \"Token precision can't be higher than the pool precision\"\n            );\n            precisions[i] = (10 ** uint256(SwapUtils.getPoolPrecisionDecimals())).div(precisions[i]);\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        swapStorage = SwapUtils.Swap({\n            lpToken: new LPToken(lpTokenName, lpTokenSymbol, SwapUtils.getPoolPrecisionDecimals()),\n            pooledTokens: _pooledTokens,\n            tokenPrecisionMultipliers: precisions,\n            balances: new uint256[](_pooledTokens.length),\n            initialA: _A.mul(SwapUtils.getAPrecision()),\n            futureA: _A.mul(SwapUtils.getAPrecision()),\n            initialATime: 0,\n            futureATime: 0,\n            swapFee: _fee,\n            adminFee: _adminFee,\n            defaultWithdrawFee: _withdrawFee\n        });\n\n        allowlist = _allowlist;\n        require(allowlist.getPoolCap(address(0x0)) == uint256(0x54dd1e), \"Allowlist check failed\");\n        isGuarded = true;\n    }\n\n    /*** MODIFIERS ***/\n\n    /**\n     * @notice Modifier to check deadline against current timestamp\n     * @param deadline latest timestamp to accept this transaction\n     */\n    modifier deadlineCheck(uint256 deadline) {\n        require(block.timestamp <= deadline, \"Deadline not met\");\n        _;\n    }\n\n    /*** VIEW FUNCTIONS ***/\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @return A parameter\n     */\n    function getA() external view returns (uint256) {\n        return swapStorage.getA();\n    }\n\n    /**\n     * @notice Return A in its raw precision form\n     * @dev See the StableSwap paper for details\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise() external view returns (uint256) {\n        return swapStorage.getAPrecise();\n    }\n\n    /**\n     * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\n     * @param index the index of the token\n     * @return address of the token at given index\n     */\n    function getToken(uint8 index) public view returns (IERC20) {\n        require(index < swapStorage.pooledTokens.length, \"Out of range\");\n        return swapStorage.pooledTokens[index];\n    }\n\n    /**\n     * @notice Return the index of the given token address. Reverts if no matching\n     * token is found.\n     * @param tokenAddress address of the token\n     * @return the index of the given token address\n     */\n    function getTokenIndex(address tokenAddress) external view returns (uint8) {\n        uint8 index = tokenIndexes[tokenAddress];\n        require(address(getToken(index)) == tokenAddress, \"Token does not exist\");\n        return index;\n    }\n\n    /**\n     * @notice Return timestamp of last deposit of given address\n     * @return timestamp of the last deposit made by the given address\n     */\n    function getDepositTimestamp(address user) external view returns (uint256) {\n        return swapStorage.getDepositTimestamp(user);\n    }\n\n    /**\n     * @notice Return current balance of the pooled token at given index\n     * @param index the index of the token\n     * @return current balance of the pooled token at given index with token's native precision\n     */\n    function getTokenBalance(uint8 index) external view returns (uint256) {\n        require(index < swapStorage.pooledTokens.length, \"Index out of range\");\n        return swapStorage.balances[index];\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice() external view returns (uint256) {\n        return swapStorage.getVirtualPrice();\n    }\n\n    /**\n     * @notice calculate amount of tokens you receive on swap\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell\n     * @return amount of tokens the user will receive\n     */\n    function calculateSwap(uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 dx\n    ) external view returns(uint256) {\n        return swapStorage.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return token amount the user will receive\n     */\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\n    external view returns(uint256) {\n        return swapStorage.calculateTokenAmount(amounts, deposit);\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of LP tokens\n     * @param amount the amount of LP tokens that would be burned on withdrawal\n     * @return array of balances of tokens that user will receive\n     */\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory) {\n        return swapStorage.calculateRemoveLiquidity(amount);\n    }\n\n    /**\n     * @notice Calculate the amount of underlying token available to withdraw\n     * when withdrawing via only single token\n     * @param tokenAmount the amount of LP token to burn\n     * @param tokenIndex index of which token will be withdrawn\n     * @return availableTokenAmount calculated amount of underlying token\n     * available to withdraw\n     */\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount) {\n        (availableTokenAmount, ) = swapStorage.calculateWithdrawOneToken(tokenAmount, tokenIndex);\n    }\n\n    /**\n     * @notice Calculate the fee that is applied when the given user withdraws. The withdraw fee\n     * decays linearly over period of 4 weeks. For example, depositing and withdrawing right away\n     * will charge you the full amount of withdraw fee. But withdrawing after 4 weeks will charge you\n     * no additional fees.\n     * @dev returned value should be divided by FEE_DENOMINATOR to convert to correct decimals\n     * @param user address you want to calculate withdraw fee of\n     * @return current withdraw fee of the user\n     */\n    function calculateCurrentWithdrawFee(address user) external view returns (uint256) {\n        return swapStorage.calculateCurrentWithdrawFee(user);\n    }\n\n    /**\n     * @notice This function reads the accumulated amount of admin fees of the token with given index\n     * @param index Index of the pooled token\n     * @return admin's token balance in the token's precision\n     */\n    function getAdminBalance(uint256 index) external view returns (uint256) {\n        return swapStorage.getAdminBalance(index);\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice Swap two tokens using this pool\n     * @param tokenIndexFrom the token the user wants to swap from\n     * @param tokenIndexTo the token the user wants to swap to\n     * @param dx the amount of tokens the user wants to swap from\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function swap(\n        uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 dx, uint256 minDy, uint256 deadline\n    ) external nonReentrant onlyUnpaused deadlineCheck(deadline) {\n        return swapStorage.swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\n    }\n\n    /**\n     * @notice Add liquidity to the pool with given amounts\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function addLiquidity(uint256[] calldata amounts, uint256 minToMint, uint256 deadline)\n        external nonReentrant onlyUnpaused deadlineCheck(deadline) {\n        swapStorage.addLiquidity(amounts, minToMint);\n\n        if (isGuarded) {\n            // Check per user deposit limit\n            require(\n                allowlist.getAllowedAmount(address(this), msg.sender) >= swapStorage.lpToken.balanceOf(msg.sender),\n                \"Deposit limit reached\"\n            );\n            // Check pool's TVL cap limit via totalSupply of the pool token\n            require(\n                allowlist.getPoolCap(address(this)) >= swapStorage.lpToken.totalSupply(),\n                \"Pool TVL cap reached\"\n            );\n        }\n    }\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param amount the amount of LP tokens to burn\n     * @param minAmounts the minimum amounts of each token in the pool\n     *        acceptable for this burn. Useful as a front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function removeLiquidity(uint256 amount, uint256[] calldata minAmounts, uint256 deadline)\n        external nonReentrant deadlineCheck(deadline) {\n        return swapStorage.removeLiquidity(amount, minAmounts);\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param tokenAmount the amount of the token you want to receive\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function removeLiquidityOneToken(\n        uint256 tokenAmount, uint8 tokenIndex, uint256 minAmount, uint256 deadline\n    ) external nonReentrant onlyUnpaused deadlineCheck(deadline) {\n        return swapStorage.removeLiquidityOneToken(tokenAmount, tokenIndex, minAmount);\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts, uint256 maxBurnAmount, uint256 deadline\n    ) external nonReentrant onlyUnpaused deadlineCheck(deadline) {\n        return swapStorage.removeLiquidityImbalance(amounts, maxBurnAmount);\n    }\n\n    /*** ADMIN FUNCTIONS ***/\n\n    /**\n     * @notice Updates the user withdraw fee. This function can only be called by\n     * the pool token. Should be used to update the withdraw fee on transfer of pool tokens.\n     * Transferring your pool token will reset the 4 weeks period. If the recipient is already\n     * holding some pool tokens, the withdraw fee will be discounted in respective amounts.\n     * @param recipient address of the recipient of pool token\n     * @param transferAmount amount of pool token to transfer\n     */\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount) external {\n        require(msg.sender == address(swapStorage.lpToken), \"Only token transfers can update withdraw fee\");\n        swapStorage.updateUserWithdrawFee(recipient, transferAmount);\n    }\n\n    /**\n     * @notice Withdraw all admin fees to the contract owner\n     */\n    function withdrawAdminFees() external onlyOwner {\n        swapStorage.withdrawAdminFees(owner());\n    }\n\n    /**\n     * @notice Update the admin fee. Admin fee takes portion of the swap fee.\n     * @param newAdminFee new admin fee to be applied on future transactions\n     */\n    function setAdminFee(uint256 newAdminFee) external onlyOwner {\n        swapStorage.setAdminFee(newAdminFee);\n    }\n\n    /**\n     * @notice Update the swap fee to be applied on swaps\n     * @param newSwapFee new swap fee to be applied on future transactions\n     */\n    function setSwapFee(uint256 newSwapFee) external onlyOwner {\n        swapStorage.setSwapFee(newSwapFee);\n    }\n\n    /**\n     * @notice Update the withdraw fee. This fee decays linearly over 4 weeks since\n     * user's last deposit.\n     * @param newWithdrawFee new withdraw fee to be applied on future deposits\n     */\n    function setDefaultWithdrawFee(uint256 newWithdrawFee) external onlyOwner {\n        swapStorage.setDefaultWithdrawFee(newWithdrawFee);\n    }\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA and futureTime\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param futureA the new A to ramp towards\n     * @param futureTime timestamp when the new A should be reached\n     */\n    function rampA(uint256 futureA, uint256 futureTime) external onlyOwner {\n        swapStorage.rampA(futureA, futureTime);\n    }\n\n    /**\n     * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\n     */\n    function stopRampA() external onlyOwner {\n        swapStorage.stopRampA();\n    }\n\n    /**\n     * @notice Update the guarded status of the pool deposits\n     * @param isGuarded_ boolean value indicating whether the deposits should be guarded\n     */\n    function setIsGuarded(bool isGuarded_) external onlyOwner {\n        isGuarded = isGuarded_;\n    }\n}"
    },
    {
      "filename": "contracts/Allowlist.sol",
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/IAllowlist.sol\";\n\n/**\n * @title Allowlist\n * @notice This contract is a registry holding information about how much each swap contract should\n * contain upto. Swap.sol will rely on this contract to determine whether the pool cap is reached and\n * also whether a user's deposit limit is reached.\n */\ncontract Allowlist is Ownable, IAllowlist {\n    using SafeMath for uint256;\n\n    uint256 public constant DENOMINATOR = 1e3;\n\n    mapping(address => uint256) private multipliers;\n    mapping(address => uint256) private poolCaps;\n    mapping(address => uint256) private accountLimits;\n\n    event SetMultipliers(address[] addressArray, uint256[] multiplierArray);\n    event PoolCap(address indexed poolAddress, uint256 poolCap);\n    event PoolAccountLimit(address indexed poolAddress, uint256 accountLimit);\n\n    /**\n     * @notice Creates this contract and sets PoolCap of 0x0 with uint256(0x54dd1e) for\n     * crude checking whether an address holds this contract\n     */\n    constructor() public {\n        // This value will be used as a way of crude checking whether an address holds this Allowlist contract\n        poolCaps[address(0x0)] = uint256(0x54dd1e);\n        emit PoolCap(address(0x0), uint256(0x54dd1e));\n    }\n\n    /**\n     * @notice Returns stored allowed amount for the user at the given pool address.\n     * @param poolAddress address of the pool\n     * @param user address of the user\n     */\n    function getAllowedAmount(address poolAddress, address user) external view returns (uint256) {\n        return accountLimits[poolAddress].mul(multipliers[user]).div(DENOMINATOR);\n    }\n\n    /**\n     * @notice Returns the TVL cap for given pool address.\n     * @param poolAddress address of the pool\n     */\n    function getPoolCap(address poolAddress) external view returns (uint256) {\n        return poolCaps[poolAddress];\n    }\n\n    // ADMIN FUNCTIONS\n\n    /**\n     * @notice Set multipliers for given addresses\n     * @param addressArray array of addresses\n     * @param multiplierArray array of multipliers for respective addresses\n     *        (multiplier set to 1000 equals 1.000x)\n     */\n    function setMultipliers(address[] calldata addressArray, uint256[] calldata multiplierArray) external onlyOwner {\n\n        require(addressArray.length == multiplierArray.length, \"Array lengths are different\");\n\n        for (uint256 i = 0; i < multiplierArray.length; i++) {\n            multipliers[addressArray[i]] = multiplierArray[i];\n        }\n\n        emit SetMultipliers(addressArray, multiplierArray);\n    }\n\n    /**\n     * @notice Set account limit of allowed deposit amounts for the given pool\n     * @param poolAddress address of the pool\n     * @param accountLimit base amount to be used for calculating allowed amounts of each user\n     */\n    function setPoolAccountLimit(address poolAddress, uint256 accountLimit) external onlyOwner {\n        require(poolAddress != address(0x0), \"0x0 is not a pool address\");\n        accountLimits[poolAddress] = accountLimit;\n        emit PoolAccountLimit(poolAddress, accountLimit);\n    }\n\n    /**\n     * @notice Set the TVL cap for given pool address\n     * @param poolAddress address of the pool\n     * @param poolCap TVL cap amount - limits the totalSupply of the pool token\n     */\n    function setPoolCap(address poolAddress, uint256 poolCap) external onlyOwner {\n        require(poolAddress != address(0x0), \"0x0 is not a pool address\");\n        poolCaps[poolAddress] = poolCap;\n        emit PoolCap(poolAddress, poolCap);\n    }\n}"
    },
    {
      "filename": "contracts/SwapUtils.sol",
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./LPToken.sol\";\nimport \"./MathUtils.sol\";\n\n/**\n * @title SwapUtils library\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\n * Admin functions should be protected within contracts using this library.\n */\nlibrary SwapUtils {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using MathUtils for uint256;\n\n    /*** EVENTS ***/\n\n    event TokenSwap(address indexed buyer, uint256 tokensSold,\n        uint256 tokensBought, uint128 soldId, uint128 boughtId\n    );\n    event AddLiquidity(address indexed provider, uint256[] tokenAmounts,\n        uint256[] fees, uint256 invariant, uint256 lpTokenSupply\n    );\n    event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidityOne(address indexed provider, uint256 lpTokenAmount,\n        uint256 lpTokenSupply, uint256 boughtId, uint256 tokensBought\n    );\n    event RemoveLiquidityImbalance(address indexed provider,\n        uint256[] tokenAmounts, uint256[] fees, uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n    event NewWithdrawFee(uint256 newWithdrawFee);\n    event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n    event StopRampA(uint256 A, uint256 time);\n\n    struct Swap {\n        // variables around the ramp management of A,\n        // the amplification coefficient * n * (n - 1)\n        // see https://www.curve.fi/stableswap-paper.pdf for details\n        uint256 initialA;\n        uint256 futureA;\n        uint256 initialATime;\n        uint256 futureATime;\n\n        // fee calculation\n        uint256 swapFee;\n        uint256 adminFee;\n        uint256 defaultWithdrawFee;\n\n        LPToken lpToken;\n\n        // contract references for all tokens being pooled\n        IERC20[] pooledTokens;\n\n        // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\n        // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\n        // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\n        uint256[] tokenPrecisionMultipliers;\n\n        // the pool balance of each token, in the token's precision\n        // the contract's actual token balance might differ\n        uint256[] balances;\n\n        mapping(address => uint256) depositTimestamp;\n        mapping(address => uint256) withdrawFeeMultiplier;\n    }\n\n    // Struct storing variables used in calculation in calculateWithdrawOneTokenDY function\n    // to avoid stack too deep error\n    struct CalculateWithdrawOneTokenDYInfo {\n        uint256 D0;\n        uint256 D1;\n        uint256 newY;\n        uint256 feePerToken;\n    }\n\n    // the precision all pools tokens will be converted to\n    uint8 private constant POOL_PRECISION_DECIMALS = 18;\n\n    // the denominator used to calculate admin and LP fees. For example, an\n    // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\n    uint256 private constant FEE_DENOMINATOR = 10 ** 10;\n\n    // Max swap fee is 1% or 100bps of each swap\n    uint256 private constant MAX_SWAP_FEE = 10 ** 8;\n\n    // Max adminFee is 100% of the swapFee\n    // adminFee does not add additional fee on top of swapFee\n    // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\n    // users but only on the earnings of LPs\n    uint256 private constant MAX_ADMIN_FEE = 10 ** 10;\n\n    // Max withdrawFee is 1% of the value withdrawn\n    // Fee will be redistributed to the LPs in the pool, rewarding\n    // long term providers.\n    uint256 private constant MAX_WITHDRAW_FEE = 10 ** 8;\n\n    // Constant value used as max loop limit\n    uint256 private constant MAX_LOOP_LIMIT = 256;\n\n    // Constant values used in ramping A calculations\n    uint256 private constant A_PRECISION = 100;\n    uint256 private constant MAX_A = 10 ** 6;\n    uint256 private constant MAX_A_CHANGE = 2;\n    uint256 private constant MIN_RAMP_TIME = 14 days;\n\n    /*** VIEW & PURE FUNCTIONS ***/\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @return A parameter\n     */\n    function getA(Swap storage self) external view returns (uint256) {\n        return _getA(self);\n    }\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @return A parameter\n     */\n    function _getA(Swap storage self) internal view returns (uint256) {\n        return _getAPrecise(self).div(A_PRECISION);\n    }\n\n    /**\n     * @notice Return A in its raw precision\n     * @dev See the StableSwap paper for details\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise(Swap storage self) external view returns (uint256) {\n        return _getAPrecise(self);\n    }\n\n    /**\n     * @notice Calculates and returns A based on the ramp settings\n     * @dev See the StableSwap paper for details\n     * @return A parameter in its raw precision form\n     */\n    function _getAPrecise(Swap storage self) internal view returns (uint256) {\n        uint256 t1 = self.futureATime;\n        uint256 A1 = self.futureA;\n\n        if (block.timestamp < t1) {\n            uint256 t0 = self.initialATime;\n            uint256 A0 = self.initialA;\n            if (A1 > A0) {\n                // A0 + (A1 - A0) * (block.timestamp - t0) / (t1 - t0)\n                return A0.add(A1.sub(A0).mul(block.timestamp.sub(t0)).div(t1.sub(t0)));\n            } else {\n                // A0 - (A0 - A1) * (block.timestamp - t0) / (t1 - t0)\n                return A0.sub(A0.sub(A1).mul(block.timestamp.sub(t0)).div(t1.sub(t0)));\n            }\n        } else {\n            return A1;\n        }\n    }\n\n    /**\n     * @notice Returns POOL_PRECISION_DECIMALS, the decimals of all underlying tokens to scaled to\n     * @return precision decimals of all pool tokens to be converted to\n     */\n    function getPoolPrecisionDecimal"
    }
  ]
}