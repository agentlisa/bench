{
  "Title": "M-1: Wfcash deposit might give incorrect amount of shares (wfcash) in some cases.",
  "Content": "# Issue M-1: Wfcash deposit might give incorrect amount of shares (wfcash) in some cases. \n\nSource: https://github.com/sherlock-audit/2023-12-notional-update-5-judging/issues/14 \n\n## Found by \ntvdung94\n## Summary\nWfcash deposit might not give correct amount of wfcash when there is no fcash available on the markets.\n## Vulnerability Detail\nThe preview function, which calculates the amount of share  for minting, does not take the edge case, when there is not available fcash on the markets, into account. In this case, amount of shares should be equivalent to the amount of asset (ratio 1:1). However, the code will get amount of share on notionalv2 instead, which is incorrect.\n## Impact\nUsers will get less/ incorrect amount of shares when using this deposit function.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/wrapped-fcash/contracts/wfCashERC4626.sol#L89-L106\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider adding code to handle the case when there is not enough available fcash on the markets.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid because { invalid as using NotionalV2 is the right and intended behavior}\n\n\n\n**T-Woodward**\n\n_previewDeposit logic is not consistent with _mintInternal logic\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/142",
  "Code": [
    {
      "filename": "wrapped-fcash/contracts/wfCashERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./wfCashLogic.sol\";\nimport \"../interfaces/IERC4626.sol\";\n\ncontract wfCashERC4626 is IERC4626, wfCashLogic {\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashLogic(_notional, _weth) {}\n\n    /** @dev See {IERC4626-asset} */\n    function asset() public view override returns (address) {\n        (IERC20 underlyingToken, bool isETH) = getToken(true);\n        return isETH ? address(WETH) : address(underlyingToken);\n    }\n\n    /** \n     * @notice Although not explicitly required by ERC4626 standards, this totalAssets method\n     * is expected to be manipulation resistant because it queries an internal Notional V2 TWAP\n     * of the fCash interest rate. This means that the value here along with `convertToAssets`\n     * and `convertToShares` can be used as an on-chain price oracle.\n     *\n     * If the wrapper is holding a cash balance prior to maturity, the total value of assets held\n     * by the contract will exceed what is returned by this function. The value of the excess value\n     * should never be accessible by Wrapped fCash holders due to the redemption mechanism, therefore\n     * the lower reported value is correct.\n     *\n     * @dev See {IERC4626-totalAssets}\n     */\n    function totalAssets() public view override returns (uint256) {\n        if (hasMatured()) {\n            // We calculate the matured cash value of the total supply of fCash. This is\n            // not always equal to the cash balance held by the wrapper contract.\n            uint256 primeCashValue = _getMaturedCashValue(totalSupply());\n            require(primeCashValue < uint256(type(int256).max));\n            int256 externalValue = NotionalV2.convertCashBalanceToExternal(\n                getCurrencyId(), int256(primeCashValue), true\n            );\n            return externalValue >= 0 ? uint256(externalValue) : 0;\n        } else {\n            (/* */, uint256 pvExternal) = _getPresentCashValue(totalSupply());\n            return pvExternal;\n        }\n    }\n\n    /** @dev See {IERC4626-convertToShares} */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Scales assets by the value of a single unit of fCash\n            (/* */, uint256 unitfCashValue) = _getPresentCashValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));\n            return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;\n        }\n\n        return (assets * supply) / totalAssets();\n    }\n\n    /** @dev See {IERC4626-convertToAssets} */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Catch the edge case where totalSupply causes a divide by zero error\n            (/* */, assets) = _getPresentCashValue(shares);\n        } else {\n            assets = (shares * totalAssets()) / supply;\n        }\n    }\n\n    /** @dev See {IERC4626-maxDeposit} */\n    function maxDeposit(address) external view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint} */\n    function maxMint(address) external view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint88).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw} */\n    function maxWithdraw(address owner) external view override returns (uint256) {\n        return previewRedeem(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4626-maxRedeem} */\n    function maxRedeem(address owner) external view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit} */\n    function _previewDeposit(uint256 assets) internal view returns (uint256 shares, uint256 maxFCash) {\n        if (hasMatured()) return (0, 0);\n        // This is how much fCash received from depositing assets\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        (/* */, maxFCash) = getTotalFCashAvailable();\n\n        try NotionalV2.getfCashLendFromDeposit(\n            currencyId,\n            assets,\n            maturity,\n            0,\n            block.timestamp,\n            true\n        ) returns (uint88 s, uint8, bytes32) {\n            shares = s;\n        } catch {\n            shares = maxFCash;\n        }\n    }\n\n    function previewDeposit(uint256 assets) public view override returns (uint256 shares) {\n        (shares, /* */) = _previewDeposit(assets);\n    }\n\n    /** @dev See {IERC4626-previewMint} */\n    function _previewMint(uint256 shares) internal view returns (uint256 assets, uint256 maxFCash) {\n        if (hasMatured()) return (0, 0);\n\n        // This is how much fCash received from depositing assets\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        (/* */, maxFCash) = getTotalFCashAvailable();\n        if (maxFCash < shares) {\n            (/* */, int256 precision) = getUnderlyingToken();\n            require(precision > 0);\n            // Lending at zero interest means that 1 fCash unit is equivalent to 1 asset unit\n            assets = shares * uint256(precision) / uint256(Constants.INTERNAL_TOKEN_PRECISION);\n        } else {\n            // This method will round up when calculating the depositAmountUnderlying (happens inside\n            // CalculationViews._convertToAmountExternal).\n            (assets, /* */, /* */, /* */) = NotionalV2.getDepositFromfCashLend(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n        }\n    }\n\n    function previewMint(uint256 shares) public view override returns (uint256 assets) {\n        (assets, /* */) = _previewMint(shares);\n    }\n\n    /** @dev See {IERC4626-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        if (assets == 0) return 0;\n\n        // Although the ERC4626 standard suggests that shares is rounded up in this calculation,\n        // it would not have much of an effect for wrapped fCash in practice. The actual amount\n        // of assets returned to the user is not dictated by the `assets` parameter supplied here\n        // but is actually calculated inside _burnInternal (rounding against the user) when fCash\n        // has matured or inside the NotionalV2 AMM when withdrawing fCash early. In either case,\n        // the number of shares returned here will be burned exactly and the user will receive close\n        // to the assets input, but not exactly.\n        if (hasMatured()) {\n            shares = convertToShares(assets);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-previewRedeem} */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        if (shares == 0) return 0;\n\n        if (hasMatured()) {\n            assets = convertToAssets(shares);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (assets, /* */, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-deposit} */\n    function deposit(uint256 assets, address receiver) external override returns (uint256) {\n        (uint256 shares, uint256 maxFCash) = _previewDeposit(assets);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, maxFCash);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint} */\n    function mint(uint256 shares, address receiver) external override returns (uint256) {\n        (uint256 assets, uint256 maxFCash) = _previewMint(shares);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, maxFCash);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw} */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external override returns (uint256) {\n        // This is a noop if the account has already been settled, cheaper to call this than cache\n        // it locally in storage.\n        NotionalV2.settleAccount(address(this));\n\n        uint256 shares = previewWithdraw(assets);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem} */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external override returns (uint256) {\n        // It is more accurate and gas efficient to check the balance of the\n        // receiver here than rely on the previewRedeem method.\n        IERC20 token = IERC20(asset());\n        uint256 balanceBefore = token.balanceOf(receiver);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        uint256 balanceAfter = token.balanceOf(receiver);\n        uint256 assets = balanceAfter - balanceBefore;\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n        return assets;\n    }\n\n    function _redeemInternal(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) private {\n        _burnInternal(\n            owner,\n            shares,\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: 0\n            })\n        );\n    }\n}"
    }
  ]
}