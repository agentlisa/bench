{
  "Title": "[N-07] Simplify unpacking expression in `fixedReward`",
  "Content": "\nhttps://github.com/code-423n4/2023-03-wenwin/blob/main/src/LotterySetup.sol#L126-L127\n\nThe following calculation:\n\n```solidity\nuint256 mask = uint256(type(uint16).max) << (winTier * 16);\nuint256 extracted = (nonJackpotFixedRewards & mask) >> (winTier * 16);\n```\n\nCan be simplified using a single shift as:\n\n```solidity\nuint256 extracted = (nonJackpotFixedRewards >> (winTier * 16)) & type(uint16).max;\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-03-wenwin",
  "Code": [
    {
      "filename": "src/LotterySetup.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"src/PercentageMath.sol\";\nimport \"src/LotteryToken.sol\";\nimport \"src/interfaces/ILotterySetup.sol\";\nimport \"src/Ticket.sol\";\n\ncontract LotterySetup is ILotterySetup {\n    using PercentageMath for uint256;\n\n    uint256 public immutable override minInitialPot;\n    uint256 public immutable override jackpotBound;\n\n    IERC20 public immutable override rewardToken;\n    IERC20 public immutable override nativeToken;\n\n    uint256 public immutable override ticketPrice;\n\n    uint256 public override initialPot;\n\n    uint256 public immutable override initialPotDeadline;\n    uint256 internal immutable firstDrawSchedule;\n    uint256 public immutable override drawPeriod;\n    uint256 public immutable override drawCoolDownPeriod;\n\n    uint8 public immutable override selectionSize;\n    uint8 public immutable override selectionMax;\n    uint256 public immutable override expectedPayout;\n\n    uint256 private immutable nonJackpotFixedRewards;\n\n    uint256 private constant BASE_JACKPOT_PERCENTAGE = 30_030; // 30.03%\n\n    /// @dev Constructs a new lottery contract\n    /// @param lotterySetupParams Setup parameter for the lottery\n    // solhint-disable-next-line code-complexity\n    constructor(LotterySetupParams memory lotterySetupParams) {\n        if (address(lotterySetupParams.token) == address(0)) {\n            revert RewardTokenZero();\n        }\n        if (lotterySetupParams.ticketPrice == uint256(0)) {\n            revert TicketPriceZero();\n        }\n        if (lotterySetupParams.selectionSize == 0) {\n            revert SelectionSizeZero();\n        }\n        if (lotterySetupParams.selectionMax >= 120) {\n            revert SelectionSizeMaxTooBig();\n        }\n        if (\n            lotterySetupParams.expectedPayout < lotterySetupParams.ticketPrice / 100\n                || lotterySetupParams.expectedPayout >= lotterySetupParams.ticketPrice\n        ) {\n            revert InvalidExpectedPayout();\n        }\n        if (\n            lotterySetupParams.selectionSize > 16 || lotterySetupParams.selectionSize >= lotterySetupParams.selectionMax\n        ) {\n            revert SelectionSizeTooBig();\n        }\n        if (\n            lotterySetupParams.drawSchedule.drawCoolDownPeriod >= lotterySetupParams.drawSchedule.drawPeriod\n                || lotterySetupParams.drawSchedule.firstDrawScheduledAt < lotterySetupParams.drawSchedule.drawPeriod\n        ) {\n            revert DrawPeriodInvalidSetup();\n        }\n        initialPotDeadline =\n            lotterySetupParams.drawSchedule.firstDrawScheduledAt - lotterySetupParams.drawSchedule.drawPeriod;\n        // slither-disable-next-line timestamp\n        if (initialPotDeadline < (block.timestamp + lotterySetupParams.drawSchedule.drawPeriod)) {\n            revert InitialPotPeriodTooShort();\n        }\n\n        nativeToken = new LotteryToken();\n        uint256 tokenUnit = 10 ** IERC20Metadata(address(lotterySetupParams.token)).decimals();\n        minInitialPot = 4 * tokenUnit;\n        jackpotBound = 2_000_000 * tokenUnit;\n        rewardToken = lotterySetupParams.token;\n        firstDrawSchedule = lotterySetupParams.drawSchedule.firstDrawScheduledAt;\n        drawPeriod = lotterySetupParams.drawSchedule.drawPeriod;\n        drawCoolDownPeriod = lotterySetupParams.drawSchedule.drawCoolDownPeriod;\n        ticketPrice = lotterySetupParams.ticketPrice;\n        selectionSize = lotterySetupParams.selectionSize;\n        selectionMax = lotterySetupParams.selectionMax;\n        expectedPayout = lotterySetupParams.expectedPayout;\n\n        nonJackpotFixedRewards = packFixedRewards(lotterySetupParams.fixedRewards);\n\n        emit LotteryDeployed(\n            lotterySetupParams.token,\n            lotterySetupParams.drawSchedule,\n            lotterySetupParams.ticketPrice,\n            lotterySetupParams.selectionSize,\n            lotterySetupParams.selectionMax,\n            lotterySetupParams.expectedPayout,\n            lotterySetupParams.fixedRewards\n        );\n    }\n\n    modifier requireJackpotInitialized() {\n        // slither-disable-next-line incorrect-equality\n        if (initialPot == 0) {\n            revert JackpotNotInitialized();\n        }\n        _;\n    }\n\n    modifier beforeTicketRegistrationDeadline(uint128 drawId) {\n        // slither-disable-next-line timestamp\n        if (block.timestamp > ticketRegistrationDeadline(drawId)) {\n            revert TicketRegistrationClosed(drawId);\n        }\n        _;\n    }\n\n    function fixedReward(uint8 winTier) public view override returns (uint256 amount) {\n        if (winTier == selectionSize) {\n            return _baseJackpot(initialPot);\n        } else if (winTier == 0 || winTier > selectionSize) {\n            return 0;\n        } else {\n            uint256 mask = uint256(type(uint16).max) << (winTier * 16);\n            uint256 extracted = (nonJackpotFixedRewards & mask) >> (winTier * 16);\n            return extracted * (10 ** (IERC20Metadata(address(rewardToken)).decimals() - 1));\n        }\n    }\n\n    function finalizeInitialPotRaise() external override {\n        if (initialPot > 0) {\n            revert JackpotAlreadyInitialized();\n        }\n        // slither-disable-next-line timestamp\n        if (block.timestamp <= initialPotDeadline) {\n            revert FinalizingInitialPotBeforeDeadline();\n        }\n        uint256 raised = rewardToken.balanceOf(address(this));\n        if (raised < minInitialPot) {\n            revert RaisedInsufficientFunds(raised);\n        }\n        initialPot = raised;\n\n        // must hold after this call, this will be used as a check that jackpot is initialized\n        assert(initialPot > 0);\n\n        emit InitialPotPeriodFinalized(raised);\n    }\n\n    function drawScheduledAt(uint128 drawId) public view override returns (uint256 time) {\n        time = firstDrawSchedule + (drawId * drawPeriod);\n    }\n\n    function ticketRegistrationDeadline(uint128 drawId) public view override returns (uint256 time) {\n        time = drawScheduledAt(drawId) - drawCoolDownPeriod;\n    }\n\n    function _baseJackpot(uint256 _initialPot) internal view returns (uint256) {\n        return Math.min(_initialPot.getPercentage(BASE_JACKPOT_PERCENTAGE), jackpotBound);\n    }\n\n    function packFixedRewards(uint256[] memory rewards) private view returns (uint256 packed) {\n        if (rewards.length != (selectionSize) || rewards[0] != 0) {\n            revert InvalidFixedRewardSetup();\n        }\n        uint256 divisor = 10 ** (IERC20Metadata(address(rewardToken)).decimals() - 1);\n        for (uint8 winTier = 1; winTier < selectionSize; ++winTier) {\n            uint16 reward = uint16(rewards[winTier] / divisor);\n            if ((rewards[winTier] % divisor) != 0) {\n                revert InvalidFixedRewardSetup();\n            }\n            packed |= uint256(reward) << (winTier * 16);\n        }\n    }\n}"
    }
  ]
}