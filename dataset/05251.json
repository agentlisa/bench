{
  "Title": "[M-20] Some rewards from POL will not be send to team wallet nor burned",
  "Content": "\nThe rewards earned from the DAOs POL are distributed among the team wallet, then part of the remaining rewards are burned and the rest are kept as DAOs balance.\n\nThe issue, is that is possible for the DAO to claim SALT rewards without sending the team's share to the team wallet and without burning the amount that should be burned.\n\n### Proof of Concept\n\nThe first step during the `upkeep` functionality is to perform the upkeep on the `liquidizer` contract.\n\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/Upkeep.sol#L107>\n\nDuring that, if the amount of USDS to be burned is greater than the current balance of the `liquidizer` contract, then the code will withdraw some POL from the usds/dai and usds/salt pools:\n\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/stable/Liquidizer.sol#L123-L124>\n\nWhen removing liquidity, the code will decrease the dao's share and in doing so it will send to it some rewards proportional to the amount of shares decreased:\n\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/StakingRewards.sol#L136-L137>\n\nIt is important note that pool rewards do not necessary comes from the emitter, but they can be added by third party protocols via the `addRewards` function in the `StakingRewards` contract:\n\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/StakingRewards.sol#L182>\n\n### Recommended Mitigation Steps\n\nTwo options:\n\n*   Save the amount of rewards received when withdrawing some POL, so they can be distributed and burned.\n\n*   Make the call to claim all the rewards at the beginning of `upkeep`.\n\n**[Picodes (Judge) commented](https://github.com/code-423n4/2024-01-salty-findings/issues/333#issuecomment-1956687912):**\n > This report shows how in some cases some rewards may end up being stuck when withdrawing PoL.\n\n**[othernet-global (Salty.IO) acknowledged and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/333#issuecomment-1960694018):**\n > POL has been removed from the protocol:\n> \n> [eaf40ef0fa27314c6e674db6830990df68e5d70e](https://github.com/othernet-global/salty-io/commit/eaf40ef0fa27314c6e674db6830990df68e5d70e)\n> https://github.com/othernet-global/salty-io/commit/8e3231d3f444e9851881d642d6dd03021fade5ed\n> \n\n**Status:** Mitigation confirmed. Full details in reports from [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/59), [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/103), and [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/83).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/Upkeep.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/finance/VestingWallet.sol\";\nimport \"./price_feed/interfaces/IPriceAggregator.sol\";\nimport \"./stable/interfaces/IStableConfig.sol\";\nimport \"./rewards/interfaces/IEmissions.sol\";\nimport \"./pools/interfaces/IPoolsConfig.sol\";\nimport \"./interfaces/IExchangeConfig.sol\";\nimport \"./dao/interfaces/IDAOConfig.sol\";\nimport \"./pools/interfaces/IPools.sol\";\nimport \"./dao/interfaces/IDAO.sol\";\n\n\n// Performs the following upkeep for each call to performUpkeep():\n// (Uses a maximum of 2.3 million gas with 100 whitelisted pools according to UpkeepGasUsage.t.sol)\n\n// 1. Swaps tokens previously sent to the Liquidizer contract for USDS and burns specified amounts of USDS.\n\n// 2. Withdraws existing WETH arbitrage profits from the Pools contract and rewards the caller of performUpkeep() with default 5% of the withdrawn amount.\n// 3. Converts a default 5% of the remaining WETH to USDS/DAI Protocol Owned Liquidity.\n// 4. Converts a default 20% of the remaining WETH to SALT/USDS Protocol Owned Liquidity.\n// 5. Converts remaining WETH to SALT and sends it to SaltRewards.\n\n// 6. Sends SALT Emissions to the SaltRewards contract.\n// 7. Distributes SALT from SaltRewards to the stakingRewardsEmitter and liquidityRewardsEmitter.\n// 8. Distributes SALT rewards from the stakingRewardsEmitter and liquidityRewardsEmitter.\n\n// 9. Collects SALT rewards from the DAO's Protocol Owned Liquidity (SALT/USDS from formed POL), sends 10% to the initial dev team and burns a default 50% of the remaining - the rest stays in the DAO.\n// 10. Sends SALT from the DAO vesting wallet to the DAO (linear distribution over 10 years).\n// 11. Sends SALT from the team vesting wallet to the team (linear distribution over 10 years).\n\n// WETH arbitrage profits are converted directly via depositSwapWithdraw - as performUpkeep is called often and the generated arbitrage profits should be manageable compared to the size of the reserves.\n// Additionally, simulations show that the impact from sandwich attacks on swap transactions (even without specifying slippage) is limited due to the atomic arbitrage process.\n// See PoolUtils.__placeInternalSwap and Sandwich.t.sol for more details.\n\ncontract Upkeep is IUpkeep, ReentrancyGuard\n    {\n\tusing SafeERC20 for ISalt;\n\tusing SafeERC20 for IUSDS;\n\tusing SafeERC20 for IERC20;\n\n    event UpkeepError(string description, bytes error);\n\n\tIPools immutable public pools;\n\tIExchangeConfig  immutable public exchangeConfig;\n\tIPoolsConfig immutable public poolsConfig;\n\tIDAOConfig immutable public daoConfig;\n\tIStableConfig immutable public stableConfig;\n\tIPriceAggregator immutable public priceAggregator;\n\tISaltRewards immutable public saltRewards;\n\tICollateralAndLiquidity immutable public collateralAndLiquidity;\n\tIEmissions immutable public emissions;\n\tIDAO immutable public dao;\n\n\tIERC20  immutable public weth;\n\tISalt  immutable public salt;\n\tIUSDS  immutable public usds;\n\tIERC20  immutable public dai;\n\n\tuint256 public lastUpkeepTimeEmissions;\n\tuint256 public lastUpkeepTimeRewardsEmitters;\n\n\n    constructor( IPools _pools, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IDAOConfig _daoConfig, IStableConfig _stableConfig, IPriceAggregator _priceAggregator, ISaltRewards _saltRewards, ICollateralAndLiquidity _collateralAndLiquidity, IEmissions _emissions, IDAO _dao )\n\t\t{\n\t\tpools = _pools;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\tdaoConfig = _daoConfig;\n\t\tstableConfig = _stableConfig;\n\t\tpriceAggregator = _priceAggregator;\n\t\tsaltRewards = _saltRewards;\n\t\tcollateralAndLiquidity = _collateralAndLiquidity;\n\t\temissions = _emissions;\n\t\tdao = _dao;\n\n\t\t// Cached for efficiency\n\t\tweth = _exchangeConfig.weth();\n\t\tsalt = _exchangeConfig.salt();\n\t\tusds = _exchangeConfig.usds();\n\t\tdai = _exchangeConfig.dai();\n\n\t\tlastUpkeepTimeEmissions = block.timestamp;\n\t\tlastUpkeepTimeRewardsEmitters = block.timestamp;\n\n\t\t// Approve for future WETH swaps.\n\t\t// This contract only has a temporary WETH balance within the performUpkeep() function itself.\n\t\tweth.approve( address(pools), type(uint256).max );\n\t\t}\n\n\n\tmodifier onlySameContract()\n\t\t{\n    \trequire(msg.sender == address(this), \"Only callable from within the same contract\");\n    \t_;\n\t\t}\n\n\n\t// Note - while the following steps are public so that they can be wrapped in a try/catch, they are all still only callable from this same contract.\n\n\t// 1. Swap tokens previously sent to the Liquidizer contract for USDS and burn specified amounts of USDS.\n\tfunction step1() public onlySameContract\n\t\t{\n\t\tcollateralAndLiquidity.liquidizer().performUpkeep();\n\t\t}\n\n\n\t// 2. Withdraw existing WETH arbitrage profits from the Pools contract and reward the caller of performUpkeep() with default 5% of the withdrawn amount.\n\tfunction step2(address receiver) public onlySameContract\n\t\t{\n\t\tuint256 withdrawnAmount = exchangeConfig.dao().withdrawArbitrageProfits(weth);\n\t\tif ( withdrawnAmount == 0 )\n\t\t\treturn;\n\n\t\t// Default 5% of the arbitrage profits for the caller of performUpkeep()\n\t\tuint256 rewardAmount = withdrawnAmount * daoConfig.upkeepRewardPercent() / 100;\n\n\t\t// Send the reward\n\t\tweth.safeTransfer(receiver, rewardAmount);\n\t\t}\n\n\n\t// Have the DAO form the specified Protocol Owned Liquidity with the given amount of WETH\n\tfunction _formPOL( IERC20 tokenA, IERC20 tokenB, uint256 amountWETH) internal\n\t\t{\n\t\tuint256 wethAmountPerToken = amountWETH >> 1;\n\n\t\t// Swap WETH for the specified tokens\n\t\tuint256 amountA = pools.depositSwapWithdraw( weth, tokenA, wethAmountPerToken, 0, block.timestamp );\n\t\tuint256 amountB = pools.depositSwapWithdraw( weth, tokenB, wethAmountPerToken, 0, block.timestamp );\n\n\t\t// Transfer the tokens to the DAO\n\t\ttokenA.safeTransfer( address(dao), amountA );\n\t\ttokenB.safeTransfer( address(dao), amountB );\n\n\t\t// Have the DAO form POL\n\t\tdao.formPOL(tokenA, tokenB, amountA, amountB);\n\t\t}\n\n\n\t// 3. Convert a default 5% of the remaining WETH to USDS/DAI Protocol Owned Liquidity.\n\tfunction step3() public onlySameContract\n\t\t{\n\t\tuint256 wethBalance = weth.balanceOf( address(this) );\n\t\tif ( wethBalance == 0 )\n\t\t\treturn;\n\n\t\t// A default 5% of the remaining WETH will be swapped for USDS/DAI POL.\n\t\tuint256 amountOfWETH = wethBalance * stableConfig.percentArbitrageProfitsForStablePOL() / 100;\n\t\t_formPOL(usds, dai, amountOfWETH);\n\t\t}\n\n\n\t// 4. Convert a default 20% of the remaining WETH to SALT/USDS Protocol Owned Liquidity.\n\tfunction step4() public onlySameContract\n\t\t{\n\t\tuint256 wethBalance = weth.balanceOf( address(this) );\n\t\tif ( wethBalance == 0 )\n\t\t\treturn;\n\n\t\t// A default 20% of the remaining WETH will be swapped for SALT/USDS POL.\n\t\tuint256 amountOfWETH = wethBalance * daoConfig.arbitrageProfitsPercentPOL() / 100;\n\t\t_formPOL(salt, usds, amountOfWETH);\n\t\t}\n\n\n\t// 5. Convert remaining WETH to SALT and sends it to SaltRewards.\n\tfunction step5() public onlySameContract\n\t\t{\n\t\tuint256 wethBalance = weth.balanceOf( address(this) );\n\t\tif ( wethBalance == 0 )\n\t\t\treturn;\n\n\t\t// Convert remaining WETH to SALT and send it to SaltRewards\n\t\tuint256 amountSALT = pools.depositSwapWithdraw( weth, salt, wethBalance, 0, block.timestamp );\n\t\tsalt.safeTransfer(address(saltRewards), amountSALT);\n\t\t}\n\n\n\t// 6. Send SALT Emissions to the SaltRewards contract.\n\tfunction step6() public onlySameContract\n\t\t{\n\t\tuint256 timeSinceLastUpkeep = block.timestamp - lastUpkeepTimeEmissions;\n\t\temissions.performUpkeep(timeSinceLastUpkeep);\n\n\t\tlastUpkeepTimeEmissions = block.timestamp;\n\t\t}\n\n\n\t// 7. Distribute SALT from SaltRewards to the stakingRewardsEmitter and liquidityRewardsEmitter.\n\tfunction step7() public onlySameContract\n\t\t{\n\t\tuint256[] memory profitsForPools = pools.profitsForWhitelistedPools();\n\n\t\tbytes32[] memory poolIDs = poolsConfig.whitelistedPools();\n\t\tsaltRewards.performUpkeep(poolIDs, profitsForPools );\n\t\tpools.clearProfitsForPools();\n\t\t}\n\n\n\t// 8. Distribute SALT rewards from the stakingRewardsEmitter and liquidityRewardsEmitter.\n\tfunction step8() public onlySameContract\n\t\t{\n\t\tuint256 timeSinceLastUpkeep = block.timestamp - lastUpkeepTimeRewardsEmitters;\n\n\t\tsaltRewards.stakingRewardsEmitter().performUpkeep(timeSinceLastUpkeep);\n\t\tsaltRewards.liquidityRewardsEmitter().performUpkeep(timeSinceLastUpkeep);\n\n\t\tlastUpkeepTimeRewardsEmitters = block.timestamp;\n\t\t}\n\n\n\t// 9. Collect SALT rewards from the DAO's Protocol Owned Liquidity (SALT/USDS from formed POL), send 10% to the initial dev team and burn a default 50% of the remaining - the rest stays in the DAO.\n\tfunction step9() public onlySameContract\n\t\t{\n\t\tdao.processRewardsFromPOL();\n\t\t}\n\n\n\t// 10. Send SALT from the DAO vesting wallet to the DAO (linear distribution over 10 years).\n\tfunction step10() public onlySameContract\n\t\t{\n\t\tVestingWallet(payable(exchangeConfig.daoVestingWallet())).release(address(salt));\n\t\t}\n\n\n\t// 11. Sends SALT from the team vesting wallet to the team (linear distribution over 10 years).\n\tfunction step11() public onlySameContract\n\t\t{\n\t\tuint256 releaseableAmount = VestingWallet(payable(exchangeConfig.teamVestingWallet())).releasable(address(salt));\n\n\t\t// teamVestingWallet actually sends the vested SALT to this contract - which will then need to be sent to the active teamWallet\n\t\tVestingWallet(payable(exchangeConfig.teamVestingWallet())).release(address(salt));\n\n\t\tsalt.safeTransfer( exchangeConfig.managedTeamWallet().mainWallet(), releaseableAmount );\n\t\t}\n\n\n\t// Perform the various steps of performUpkeep as outlined at the top of the contract.\n\t// Each step is wrapped in a try/catch to prevent reversions from cascading through the performUpkeep.\n\tfunction performUpkeep() public nonReentrant\n\t\t{\n\t\t// Perform the multiple steps of performUpkeep()\n \t\ttry this.step1() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 1\", error); }\n\n \t\ttry this.step2(msg.sender) {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 2\", error); }\n\n \t\ttry this.step3() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 3\", error); }\n\n \t\ttry this.step4() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 4\", error); }\n\n \t\ttry this.step5() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 5\", error); }\n\n \t\ttry this.step6() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 6\", error); }\n\n \t\ttry this.step7() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 7\", error); }\n\n \t\ttry this.step8() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 8\", error); }\n\n \t\ttry this.step9() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 9\", error); }\n\n \t\ttry this.step10() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 10\", error); }\n\n \t\ttry this.step11() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 11\", error); }\n\t\t}\n\n\n\t// ==== VIEWS ====\n\t// Returns the amount of WETH that will currently be rewarded for calling performUpkeep().\n\t// Useful for potential callers to know if calling the function will be profitable in comparison to current gas costs.\n\tfunction currentRewardsForCallingPerformUpkeep() public view returns (uint256)\n\t\t{\n\t\tuint256 daoWETH = pools.depositedUserBalance( address(dao), weth );\n\n\t\treturn daoWETH * daoConfig.upkeepRewardPercent() / 100;\n\t\t}\n\t}"
    },
    {
      "filename": "src/stable/Liquidizer.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"../stable/interfaces/ICollateralAndLiquidity.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"../pools/interfaces/IPools.sol\";\nimport \"./interfaces/ILiquidizer.sol\";\nimport \"./interfaces/IUSDS.sol\";\nimport \"../pools/PoolUtils.sol\";\n\n// Swaps tokens sent to this contract from collateral liquidiation and Protocol Owned Liquidity withdrawal to USDS - which is then burned.\n\n// Extra USDS (beyond usdsThatShouldBeBurned) remains in this contract as a burnable buffer in the event of undercollateralized liquidation.\n// Undercollateralized liquidation can happen if WBTC/WETH collateral drops rapidly in value so that collateral positions fall below a 100% collateral ratio before they can be liquidated.\n\n// When there is insufficient USDS to burn, Protocol Owned Liquidity from the DAO is withdrawn, and converted to USDS.\ncontract Liquidizer is ILiquidizer, Ownable\n    {\n    event incrementedBurnableUSDS(uint256 newTotal);\n\n\tusing SafeERC20 for ISalt;\n\tusing SafeERC20 for IUSDS;\n\n\t// The percent of Protocol Owned Liquidity to withdraw when there is insufficient USDS to burn\n    uint256 constant PERCENT_POL_TO_WITHDRAW = 1;\n\n    IERC20 immutable public wbtc;\n    IERC20 immutable public weth;\n    IUSDS immutable public usds;\n    ISalt immutable public salt;\n    IERC20 immutable public dai;\n\n    IExchangeConfig public exchangeConfig;\n    IPoolsConfig immutable  public poolsConfig;\n    ICollateralAndLiquidity public collateralAndLiquidity;\n    IPools public pools;\n    IDAO public dao;\n\n\t// This corresponds to USDS that was borrowed by users who had their collateral liquidated.\n\t// Because liquidated collateral no longer exists, the borrowed USDS needs to be burned in order to \"undo\" the collateralized position\n\t// and return state back to where it was before the liquidated user deposited collateral and borrowed USDS.\n\tuint256 public usdsThatShouldBeBurned;\n\n\n\tconstructor( IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig  )\n\t\t{\n\t\tpoolsConfig = _poolsConfig;\n\t\texchangeConfig = _exchangeConfig;\n\n\t\twbtc = _exchangeConfig.wbtc();\n\t\tweth = _exchangeConfig.weth();\n\t\tusds = _exchangeConfig.usds();\n\t\tsalt = _exchangeConfig.salt();\n\t\tdai = _exchangeConfig.dai();\n        }\n\n\n\t// This will be called only once - at deployment time\n\tfunction setContracts( ICollateralAndLiquidity _collateralAndLiquidity, IPools _pools, IDAO _dao) external onlyOwner\n\t\t{\n\t\tcollateralAndLiquidity = _collateralAndLiquidity;\n\t\tpools = _pools;\n\t\tdao = _dao;\n\n\t\t// Gas saving approve for future swaps.\n\t\t// Normally, this contract will have zero balances of these tokens.\n\t\twbtc.approve( address(pools), type(uint256).max );\n\t\tweth.approve( address(pools), type(uint256).max );\n\t\tdai.approve( address(pools), type(uint256).max );\n\n\t\t// setContracts can only be called once\n\t\trenounceOwnership();\n\t\t}\n\n\n\t// Called when a user's collateral position has been liquidated - to indicate that the borrowed USDS from that position needs to be burned.\n\tfunction incrementBurnableUSDS( uint256 usdsToBurn ) external\n\t\t{\n\t\trequire( msg.sender == address(collateralAndLiquidity), \"Liquidizer.incrementBurnableUSDS is only callable from the CollateralAndLiquidity contract\" );\n\n\t\tusdsThatShouldBeBurned += usdsToBurn;\n\n\t\temit incrementedBurnableUSDS(usdsThatShouldBeBurned);\n\t\t}\n\n\n\t// Burn the specified amount of USDS\n\tfunction _burnUSDS(uint256 amountToBurn) internal\n\t\t{\n\t\tusds.safeTransfer( address(usds), amountToBurn );\n\t\tusds.burnTokensInContract();\n\t\t}\n\n\n\t// Burn up to usdsThatShouldBeBurned worth of USDS.\n\t// If there is a shortfall (as could be the case for undercollateralized liquidations), then withdraw a small percent of Protocol Owned Liquidity and convert it to USDS for burning.\n\tfunction _possiblyBurnUSDS() internal\n\t\t{\n\t\t// Check if there is USDS to burn\n\t\tif ( usdsThatShouldBeBurned == 0 )\n\t\t\treturn;\n\n\t\tuint256 usdsBalance = usds.balanceOf(address(this));\n\t\tif ( usdsBalance >= usdsThatShouldBeBurned )\n\t\t\t{\n\t\t\t// Burn only up to usdsThatShouldBeBurned.\n\t\t\t// Leftover USDS will be kept in this contract in case it needs to be burned later.\n\t\t\t_burnUSDS( usdsThatShouldBeBurned );\n    \t\tusdsThatShouldBeBurned = 0;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t// The entire usdsBalance will be burned - but there will still be an outstanding balance to burn later\n\t\t\t_burnUSDS( usdsBalance );\n\t\t\tusdsThatShouldBeBurned -= usdsBalance;\n\n\t\t\t// As there is a shortfall in the amount of USDS that can be burned, liquidate some Protocol Owned Liquidity and\n\t\t\t// send the underlying tokens here to be swapped to USDS\n\t\t\tdao.withdrawPOL(salt, usds, PERCENT_POL_TO_WITHDRAW);\n\t\t\tdao.withdrawPOL(dai, usds, PERCENT_POL_TO_WITHDRAW);\n\t\t\t}\n\t\t}\n\n\n\t// Swap WBTC, WETH and DAI in this contract to USDS (so that it can be burned).\n\t// Extra USDS will remain in the contract as a burnable buffer in the event of undercollateralized liquidation.\n\t// In the event insufficient USDS to burn, a small percent of Protocol Liquidity will be withdrawn from the DAO and converted to USDS for burning.\n\tfunction performUpkeep() external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"Liquidizer.performUpkeep is only callable from the Upkeep contract\" );\n\n\t\tuint256 maximumInternalSwapPercentTimes1000 = poolsConfig.maximumInternalSwapPercentTimes1000();\n\n\t\t// Swap tokens that have previously been sent to this contract for USDS\n\t\tPoolUtils._placeInternalSwap(pools, wbtc, usds, wbtc.balanceOf(address(this)), maximumInternalSwapPercentTimes1000 );\n\t\tPoolUtils._placeInternalSwap(pools, weth, usds, weth.balanceOf(address(this)), maximumInternalSwapPercentTimes1000 );\n\t\tPoolUtils._placeInternalSwap(pools, dai, usds, dai.balanceOf(address(this)), maximumInternalSwapPercentTimes1000 );\n\n\t\t// Any SALT balance seen here should just be burned so as to not put negative price pressure on SALT by swapping it to USDS\n\t\tuint256 saltBalance = salt.balanceOf(address(this));\n\t\tif ( saltBalance > 0 )\n\t\t\t{\n\t\t\tsalt.safeTransfer(address(salt), saltBalance);\n\t\t\tsalt.burnTokensInContract();\n\t\t\t}\n\n\t\t_possiblyBurnUSDS();\n\t\t}\n\t}"
    },
    {
      "filename": "src/staking/StakingRewards.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./interfaces/IStakingConfig.sol\";\nimport \"../interfaces/ISalt.sol\";\n\n// This contract allows users to receive rewards (as SALT tokens) for staking SALT or liquidity shares.\n// A user's reward is proportional to their share of the stake and is based on their share at the time that rewards are added.\n//\n// What staked shares represent is specific to the contracts that derive from StakingRewards.\n//\n// 1. Staking.sol: shares represent the amount of SALT staked (staked to the STAKED_SALT pool)\n// 2. Liquidity.sol: shares represent the amount of liquidity deposited and staked to specific pools\n\nabstract contract StakingRewards is IStakingRewards, ReentrancyGuard\n    {\n\tevent UserShareIncreased(address indexed wallet, bytes32 indexed poolID, uint256 amountIncreased);\n\tevent UserShareDecreased(address indexed wallet, bytes32 indexed poolID, uint256 amountDecreased, uint256 claimedRewards);\n\tevent RewardsClaimed(address indexed wallet, uint256 claimedRewards);\n\tevent SaltRewardsAdded(bytes32 indexed poolID, uint256 amountAdded);\n\n\tusing SafeERC20 for ISalt;\n\n\tISalt immutable public salt;\n\tIExchangeConfig immutable public exchangeConfig;\n    IStakingConfig immutable public stakingConfig;\n    IPoolsConfig immutable public poolsConfig;\n\n\t// A nested mapping that stores the UserShareInfo data for each user and each poolID.\n\tmapping(address=>mapping(bytes32=>UserShareInfo)) private _userShareInfo;\n\n    // A mapping that stores the total pending SALT rewards for each poolID.\n    mapping(bytes32=>uint256) public totalRewards;\n\n    // A mapping that stores the total shares for each poolID.\n    mapping(bytes32=>uint256) public totalShares;\n\n\n\t// Constructs a new StakingRewards contract with providing configs\n \tconstructor( IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig )\n\t\t{\n\t\texchangeConfig = _exchangeConfig;\n    \tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\n\t\tsalt = _exchangeConfig.salt(); // cached for efficiency\n        }\n\n\n\t// Increase a user's share for the given whitelisted pool.\n\tfunction _increaseUserShare( address wallet, bytes32 poolID, uint256 increaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\t\trequire( increaseShareAmount != 0, \"Cannot increase zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\tuint256 existingTotalShares = totalShares[poolID];\n\n\t\t// Determine the amount of virtualRewards to add based on the current ratio of rewards/shares.\n\t\t// The ratio of virtualRewards/increaseShareAmount is the same as totalRewards/totalShares for the pool.\n\t\t// The virtual rewards will be deducted later when calculating the user's owed rewards.\n        if ( existingTotalShares != 0 ) // prevent / 0\n        \t{\n\t\t\t// Round up in favor of the protocol.\n\t\t\tuint256 virtualRewardsToAdd = Math.ceilDiv( totalRewards[poolID] * increaseShareAmount, existingTotalShares );\n\n\t\t\tuser.virtualRewards += uint128(virtualRewardsToAdd);\n\t        totalRewards[poolID] += uint128(virtualRewardsToAdd);\n\t        }\n\n\t\t// Update the deposit balances\n\t\tuser.userShare += uint128(increaseShareAmount);\n\t\ttotalShares[poolID] = existingTotalShares + increaseShareAmount;\n\n\t\temit UserShareIncreased(wallet, poolID, increaseShareAmount);\n\t\t}\n\n\n\t// Decrease a user's share for the pool and have any pending rewards sent to them.\n\t// Does not require the pool to be valid (in case the pool was recently unwhitelisted).\n\tfunction _decreaseUserShare( address wallet, bytes32 poolID, uint256 decreaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( decreaseShareAmount != 0, \"Cannot decrease zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\t\trequire( decreaseShareAmount <= user.userShare, \"Cannot decrease more than existing user share\" );\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\t// Determine the share of the rewards for the amountToDecrease (will include previously added virtual rewards)\n\t\tuint256 rewardsForAmount = ( totalRewards[poolID] * decreaseShareAmount ) / totalShares[poolID];\n\n\t\t// For the amountToDecrease determine the proportion of virtualRewards (proportional to all virtualRewards for the user)\n\t\t// Round virtualRewards down in favor of the protocol\n\t\tuint256 virtualRewardsToRemove = (user.virtualRewards * decreaseShareAmount) / user.userShare;\n\n\t\t// Update totals\n\t\ttotalRewards[poolID] -= rewardsForAmount;\n\t\ttotalShares[poolID] -= decreaseShareAmount;\n\n\t\t// Update the user's share and virtual rewards\n\t\tuser.userShare -= uint128(decreaseShareAmount);\n\t\tuser.virtualRewards -= uint128(virtualRewardsToRemove);\n\n\t\tuint256 claimableRewards = 0;\n\n\t\t// Some of the rewardsForAmount are actually virtualRewards and can't be claimed.\n\t\t// In the event that virtualRewards are greater than actual rewards - claimableRewards will stay zero.\n\t\tif ( virtualRewardsToRemove < rewardsForAmount )\n\t\t\tclaimableRewards = rewardsForAmount - virtualRewardsToRemove;\n\n\t\t// Send the claimable rewards\n\t\tif ( claimableRewards != 0 )\n\t\t\tsalt.safeTransfer( wallet, claimableRewards );\n\n\t\temit UserShareDecreased(wallet, poolID, decreaseShareAmount, claimableRewards);\n\t\t}\n\n\n\t// ===== PUBLIC FUNCTIONS =====\n\n\t// Claim all available SALT rewards from multiple pools for the user.\n\t// The claimed rewards are added to the user's virtual rewards balance - so that they can't be claimed again later.\n     function claimAllRewards( bytes32[] calldata poolIDs ) external nonReentrant returns (uint256 claimableRewards)\n    \t{\n\t\tmapping(bytes32=>UserShareInfo) storage userInfo = _userShareInfo[msg.sender];\n\n\t\tclaimableRewards = 0;\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\tbytes32 poolID = poolIDs[i];\n\n\t\t\tuint256 pendingRewards = userRewardForPool( msg.sender, poolID );\n\n\t\t\t// Increase the virtualRewards balance for the user to account for them receiving the rewards without withdrawing\n\t\t\tuserInfo[poolID].virtualRewards += uint128(pendingRewards);\n\n\t\t\tclaimableRewards += pendingRewards;\n\t\t\t}\n\n\t\tif ( claimableRewards > 0 )\n\t\t\t{\n\t\t\t// Send the actual rewards\n\t\t\tsalt.safeTransfer( msg.sender, claimableRewards );\n\n\t\t\temit RewardsClaimed(msg.sender, claimableRewards);\n\t\t\t}\n    \t}\n\n\n\t// Adds SALT rewards for specific whitelisted pools.\n\t// There is some risk of addSALTRewards being frontrun to hunt rewards, but there are multiple mechanisms in place to prevent this from being effective.\n\t// 1. There is a cooldown period of default one hour before shares can be withdrawn once deposited.\n\t// 2. Staked SALT has a default unstake period of 52 weeks.\n\t// 3. Rewards are first placed into a RewardsEmitter which deposits rewards via addSALTRewards at the default rate of 1% per day.\n\t// 4. Rewards are deposited fairly often, with outstanding rewards being transferred with a frequency proportional to the activity of the exchange.\n\t// Example: if $100k rewards were being deposited in a bulk transaction, it would only equate to $1000 (1%) the first day,\n\t// or $10 in claimable rewards during a 15 minute upkeep period.\n \tfunction addSALTRewards( AddedReward[] calldata addedRewards ) external nonReentrant\n\t\t{\n\t\tuint256 sum = 0;\n\t\tfor( uint256 i = 0; i < addedRewards.length; i++ )\n\t\t\t{\n\t\t\tAddedReward memory addedReward = addedRewards[i];\n\n\t\t\tbytes32 poolID = addedReward.poolID;\n\t\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\n\t\t\tuint256 amountToAdd = addedReward.amountToAdd;\n\n\t\t\ttotalRewards[ poolID ] += amountToAdd;\n\t\t\tsum = sum + amountToAdd;\n\n\t\t\temit SaltRewardsAdded(poolID, amountToAdd);\n\t\t\t}\n\n\t\t// Transfer in the SALT for all the specified rewards\n\t\tif ( sum > 0 )\n\t\t\t{\n\t\t\t// Transfer the SALT rewards from the sender\n\t\t\tsalt.safeTransferFrom( msg.sender, address(this), sum );\n\t\t\t}\n\t\t}\n\n\n\t// === VIEWS ===\n\n\t// Returns the total shares for specified pools.\n\tfunction totalSharesForPools( bytes32[] calldata poolIDs ) external view returns (uint256[] memory shares)\n\t\t{\n\t\tshares = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < shares.length; i++ )\n\t\t\tshares[i] = totalShares[ poolIDs[i] ];\n\t\t}\n\n\n\t// Returns the total rewards for specified pools.\n\tfunction totalRewardsForPools( bytes32[] calldata poolIDs ) external view returns (uint256[] memory rewards)\n\t\t{\n\t\trewards = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = totalRewards[ poolIDs[i] ];\n\t\t}\n\n\n\t// Returns the user's pending rewards for a specified pool.\n\tfunction userRewardForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\t// If there are no shares for the pool, the user can't have any shares either and there can't be any rewards\n\t\tif ( totalShares[poolID] == 0 )\n\t\t\treturn 0;\n\n\t\tUserShareInfo memory user = _userShareInfo[wallet][poolID];\n\t\tif ( user.userShare == 0 )\n\t\t\treturn 0;\n\n\t\t// Determine the share of the rewards for the user based on their deposited share\n\t\tuint256 rewardsShare = ( totalRewards[poolID] * user.userShare ) / totalShares[poolID];\n\n\t\t// Reduce by the virtualRewards - as they were only added to keep the share / rewards ratio the same when the used added their share\n\n\t\t// In the event that virtualRewards exceeds rewardsShare due to precision loss - just return zero\n\t\tif ( user.virtualRewards > rewardsShare )\n\t\t\treturn 0;\n\n\t\treturn rewardsShare - user.virtualRewards;\n\t\t}\n\n\n\t// Returns the user's pending rewards for specified pools.\n\tfunction userRewardsForPools( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory rewards)\n\t\t{\n\t\trewards = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = userRewardForPool( wallet, poolIDs[i] );\n\t\t}\n\n\n\t// Get the user's shares for a specified pool.\n\tfunction userShareForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\treturn _userShareInfo[wallet][poolID].userShare;\n\t\t}\n\n\n\t// Get the user's shares for specified pools.\n\tfunction userShareForPools( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory shares)\n\t\t{\n\t\tshares = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < shares.length; i++ )\n\t\t\tshares[i] = _userShareInfo[wallet][ poolIDs[i] ].userShare;\n\t\t}\n\n\n\t// Get the user's virtual rewards for a specified pool.\n\tfunction userVirtualRewardsForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\treturn _userShareInfo[wallet][poolID].virtualRewards;\n\t\t}\n\n\n\t// Get the cooldown time remaining for the user for specified pools.\n\tfunction userCooldowns( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory cooldowns)\n\t\t{\n\t\tcooldowns = new uint256[]( poolIDs.length );\n\n\t\tmapping(bytes32=>UserShareInfo) storage userInfo = _userShareInfo[wallet];\n\n\t\tfor( uint256 i = 0; i < cooldowns.length; i++ )\n\t\t\t{\n\t\t\tuint256 cooldownExpiration = userInfo[ poolIDs[i] ].cooldownExpiration;\n\n\t\t\tif ( block.timestamp >= cooldownExpiration )\n\t\t\t\tcooldowns[i] = 0;\n\t\t\telse\n\t\t\t\tcooldowns[i] = cooldownExpiration - block.timestamp;\n\t\t\t}\n\t\t}\n\t}"
    },
    {
      "filename": "src/staking/StakingRewards.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./interfaces/IStakingConfig.sol\";\nimport \"../interfaces/ISalt.sol\";\n\n// This contract allows users to receive rewards (as SALT tokens) for staking SALT or liquidity shares.\n// A user's reward is proportional to their share of the stake and is based on their share at the time that rewards are added.\n//\n// What staked shares represent is specific to the contracts that derive from StakingRewards.\n//\n// 1. Staking.sol: shares represent the amount of SALT staked (staked to the STAKED_SALT pool)\n// 2. Liquidity.sol: shares represent the amount of liquidity deposited and staked to specific pools\n\nabstract contract StakingRewards is IStakingRewards, ReentrancyGuard\n    {\n\tevent UserShareIncreased(address indexed wallet, bytes32 indexed poolID, uint256 amountIncreased);\n\tevent UserShareDecreased(address indexed wallet, bytes32 indexed poolID, uint256 amountDecreased, uint256 claimedRewards);\n\tevent RewardsClaimed(address indexed wallet, uint256 claimedRewards);\n\tevent SaltRewardsAdded(bytes32 indexed poolID, uint256 amountAdded);\n\n\tusing SafeERC20 for ISalt;\n\n\tISalt immutable public salt;\n\tIExchangeConfig immutable public exchangeConfig;\n    IStakingConfig immutable public stakingConfig;\n    IPoolsConfig immutable public poolsConfig;\n\n\t// A nested mapping that stores the UserShareInfo data for each user and each poolID.\n\tmapping(address=>mapping(bytes32=>UserShareInfo)) private _userShareInfo;\n\n    // A mapping that stores the total pending SALT rewards for each poolID.\n    mapping(bytes32=>uint256) public totalRewards;\n\n    // A mapping that stores the total shares for each poolID.\n    mapping(bytes32=>uint256) public totalShares;\n\n\n\t// Constructs a new StakingRewards contract with providing configs\n \tconstructor( IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig )\n\t\t{\n\t\texchangeConfig = _exchangeConfig;\n    \tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\n\t\tsalt = _exchangeConfig.salt(); // cached for efficiency\n        }\n\n\n\t// Increase a user's share for the given whitelisted pool.\n\tfunction _increaseUserShare( address wallet, bytes32 poolID, uint256 increaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\t\trequire( increaseShareAmount != 0, \"Cannot increase zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) //"
    }
  ]
}