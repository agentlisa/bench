{
  "Title": "H-1: BalancedVault.sol: loss of funds + global settlement flywheel / user settlement flywheels getting out of sync",
  "Content": "# Issue H-1: BalancedVault.sol: loss of funds + global settlement flywheel / user settlement flywheels getting out of sync \n\nSource: https://github.com/sherlock-audit/2023-05-perennial-judging/issues/45 \n\n## Found by \n0xGoodess, cergyk, roguereddwarf\n## Summary\nWhen an epoch has become \"stale\", the `BalancedVault` will treat any new deposits and redemptions in this epoch as \"pending\".\nThis means they won't get processed by the global settlement flywheel in the next epoch but one epoch later than that.\n\nDue to the fact that anyone can push a pending deposit or redemption of a user further ahead by making an arbitrarily small deposit in the \"intermediate epoch\" (i.e. the epoch between when the user creates the pending deposit / redemption and the epoch when it is scheduled to be processed by the global settlement flywheel), the user can experience a DOS.\n\nWorse than that, by pushing the pending deposit / pending redemption further ahead, the global settlement flywheel and the user settlement flywheel get out of sync.\n\nAlso users can experience a loss of funds.\n\n## Vulnerability Detail\nLet's assume we are currently in epoch `1` and it is `stale`.\nUser1 calls the `deposit` function and we set `_pendingEpochs[user1] = context.epoch + 1 = 2`\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-vaults/contracts/balanced/BalancedVault.sol#L160-L164\n\nWe move one epoch ahead and are in epoch `2` now.\nBy looking at the global settlement flywheel we see that `_deposit = _pendingDeposit` and `_redemption = _pendingRedemption` which means that the deposit we made will be processed in the global settlement flywheel in the next epoch (epoch `3`).\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-vaults/contracts/balanced/BalancedVault.sol#L378-L403\n\nBy looking into the user settlement flywheel we see that the `if (accountContext.epoch > _pendingEpochs[account])` condition to process the pending deposit is not fulfilled yet (`2 !> 2`). It will be fulfilled in epoch `3`.\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-vaults/contracts/balanced/BalancedVault.sol#L413-L422\n\nSo far so good. The global settlement flywheel and the user settlement flywheel are in sync and will process the pending deposit in epoch `3`.\n\nNow here's the issue.\nA malicious user2 or user1 unknowingly (depending on the specific scenario) calls `deposit` for user1 again in the current epoch `2` once it has become `stale` (it's possible to deposit an arbitrarily small amount).\nBy doing so we set `_pendingEpochs[user1] = context.epoch + 1 = 3`, thereby pushing the processing of the deposit in the user settlement flywheel one epoch ahead.\n\nIt's important to understand that the initial deposit will still be processed in epoch `3` in the global settlement flywheel, it's just being pushed ahead in the user settlement flywheel.\n\nThereby the global settlement flywheel and user settlement flywheel are out of sync now.\n\nThe total supply will be increased by an amount calculated based on the epoch `3` context:\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-vaults/contracts/balanced/BalancedVault.sol#L379\n\nThe user balance will be increased by an amount calculated based on the epoch `4` context:\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-vaults/contracts/balanced/BalancedVault.sol#L407\n\nAn example for a loss of funds that can occur as a result of this issue is when the PnL from epoch `3` to epoch `4` is positive. Thereby the user1 will get less shares than he is entitled to.\n\nSimilarly it is possible to push pending redemptions ahead, thereby the `_totalUnclaimed` amount would be increased by an amount that is different from the amount that `_unclaimed[account]` is increased by.\n\nComing back to the case with the pending deposit, I wrote a test that you can add to `BalancedVaultMulti.test.ts`:\n```javascript\nit('pending deposit pushed by 1 epoch causing shares difference', async () => {\n      const smallDeposit = utils.parseEther('1000')\n      const smallestDeposit = utils.parseEther('0.000001')\n\n      await updateOracleEth() // epoch now stale\n      // make a pending deposit\n      await vault.connect(user).deposit(smallDeposit, user.address)\n      await updateOracleBtc()\n      await vault.sync()\n\n      await updateOracleEth() // epoch now stale\n      /* \n      user2 deposits for user1, thereby pushing the pending deposit ahead and causing the \n      global settlement flywheel and user settlement flywheel to get out of sync\n      */\n      await vault.connect(user2).deposit(smallestDeposit, user.address)\n      await updateOracleBtc()\n      await vault.sync()\n\n      await updateOracle()\n      // pending deposit for user1 is now processed in the user settlement flywheel\n      await vault.syncAccount(user.address)\n\n      const totalSupply = await vault.totalSupply()\n      const balanceUser1 = await vault.balanceOf(user.address)\n      const balanceUser2 = await vault.balanceOf(user2.address)\n\n      /*\n      totalSupply is bigger than the amount of shares of both users together\n      this is because user1 loses out on some shares that he is entitled to\n      -> loss of funds\n      */\n      console.log(totalSupply);\n      console.log(balanceUser1.add(balanceUser2));\n\n})\n```\n\nThe impact that is generated by having one pending deposit that is off by one epoch is small.\nHowever over time this would evolve into a chaotic situation, where the state of the Vault is significantly corrupted.\n\n## Impact\nThe biggest impact comes from the global settlement flywheel and user settlement flywheel getting out of sync.\nAs shown above, this can lead to a direct loss of funds for the user (e.g. the amount of shares he gets for a deposit are calculated with the wrong context).\n\nApart from the direct impact for a single user, there is a subtler impact which can be more severe in the long term.\nImportant invariants are violated:\n* Sum of user balances is equal to the total supply\n* Sum of unclaimed user assets is equal to total unclaimed assets\n\nThereby the impact is not limited to a single user but affects the calculations for all users.\n\nLess important but still noteworthy is that users that deposit into the Vault are partially exposed to PnL in the underlying products. The Vault does not employ a fully delta-neutral strategy. Therefore by experiencing a larger delay until the pending deposit / redemption is processed, users incur the risk of negative PnL.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-vaults/contracts/balanced/BalancedVault.sol#L156-L175\n\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-vaults/contracts/balanced/BalancedVault.sol#L184-L205\n\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-vaults/contracts/balanced/BalancedVault.sol#L375-L424\n\n## Tool used\nManual Review\n\n## Recommendation\nMy recommendation is to implement a queue for pending deposits / pending redemptions of a user.\nPending deposits / redemptions can then be processed independently (without new pending deposits / redemptions affecting when existing ones are processed).\n\nPossibly there is a simpler solution which might involve restricting the ability to make deposits to the user himself and only allowing one pending deposit / redemption to exist at a time.\n\nThe solution to implement depends on how flexible the sponsor wants the deposit / redemption functionality to be.\n\n\n\n## Discussion\n\n**KenzoAgada**\n\nAlso note duplicate issue #74 which mentions how a user can redeem more assets than he's entitled to.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/79",
  "Code": [
    {
      "filename": "perennial-mono/packages/perennial-vaults/contracts/balanced/BalancedVault.sol",
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\nimport \"../interfaces/IBalancedVault.sol\";\nimport \"@equilibria/root/control/unstructured/UInitializable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./BalancedVaultDefinition.sol\";\n\n/**\n * @title BalancedVault\n * @notice ERC4626 vault that manages a 50-50 position between long-short markets of the same payoff on Perennial.\n * @dev Vault deploys and rebalances collateral between the corresponding long and short markets, while attempting to\n *      maintain `targetLeverage` with its open positions at any given time. Deposits are only gated in so much as to cap\n *      the maximum amount of assets in the vault. The long and short markets are expected to have the same oracle and\n *      opposing payoff functions.\n *\n *      The vault has a \"delayed mint\" mechanism for shares on deposit. After depositing to the vault, a user must wait\n *      until the next settlement of the underlying products in order for shares to be reflected in the getters.\n *      The shares will be fully reflected in contract state when the next settlement occurs on the vault itself.\n *      Similarly, when redeeming shares, underlying assets are not claimable until a settlement occurs.\n *      Each state changing interaction triggers the `settle` flywheel in order to bring the vault to the\n *      desired state.\n *      In the event that there is not a settlement for a long period of time, keepers can call the `sync` method to\n *      force settlement and rebalancing. This is most useful to prevent vault liquidation due to PnL changes\n *      causing the vault to be in an unhealthy state (far away from target leverage)\n *\n *      This implementation is designed to be upgrade-compatible with instances of the previous single-payoff\n *      BalancedVault, here: https://github.com/equilibria-xyz/perennial-mono/blob/d970debe95e41598228e8c4ae52fb816797820fb/packages/perennial-vaults/contracts/BalancedVault.sol.\n */\ncontract BalancedVault is IBalancedVault, BalancedVaultDefinition, UInitializable {\n    UFixed18 constant private TWO = UFixed18.wrap(2e18);\n\n    /// @dev The name of the vault\n    string public name;\n\n    /// @dev Deprecated storage variable. Formerly `symbol`\n    string private __unused0;\n\n    /// @dev Mapping of allowance across all users\n    mapping(address => mapping(address => UFixed18)) public allowance;\n\n    /// @dev Mapping of shares of the vault per user\n    mapping(address => UFixed18) private _balanceOf;\n\n    /// @dev Total number of shares across all users\n    UFixed18 private _totalSupply;\n\n    /// @dev Mapping of unclaimed underlying of the vault per user\n    mapping(address => UFixed18) private _unclaimed;\n\n    /// @dev Total unclaimed underlying of the vault across all users\n    UFixed18 private _totalUnclaimed;\n\n    /// @dev Deposits that have not been settled, or have been settled but not yet processed by this contract\n    UFixed18 private _deposit;\n\n    /// @dev Redemptions that have not been settled, or have been settled but not yet processed by this contract\n    UFixed18 private _redemption;\n\n    /// @dev The latest epoch that a pending deposit or redemption has been placed\n    uint256 private _latestEpoch;\n\n    /// @dev Mapping of pending (not yet converted to shares) per user\n    mapping(address => UFixed18) private _deposits;\n\n    /// @dev Mapping of pending (not yet withdrawn) per user\n    mapping(address => UFixed18) private _redemptions;\n\n    /// @dev Mapping of the latest epoch that a pending deposit or redemption has been placed per user\n    mapping(address => uint256) private _latestEpochs;\n\n    /// @dev Per-asset accounting state variables (reserve space for maximum 50 assets due to storage pattern)\n    MarketAccount[50] private _marketAccounts;\n\n    /// @dev Deposits that are queued for the following epoch due to the current epoch being stale\n    UFixed18 private _pendingDeposit;\n\n    /// @dev Redemptions that are queued for the following epoch due to the current epoch being stale\n    UFixed18 private _pendingRedemption;\n\n    /// @dev Mapping of queued deposits (due to stale epoch) per user\n    mapping(address => UFixed18) private _pendingDeposits;\n\n    /// @dev Mapping of queued redemptions (due to stale epoch) per user\n    mapping(address => UFixed18) private _pendingRedemptions;\n\n    /// @dev Mapping of the latest epoch for any queued deposit / redemption per user\n    mapping(address => uint256) private _pendingEpochs;\n\n    /**\n     * @notice Constructor for BalancedVaultDefinition\n     * @dev previousImplementation_ is an optional feature that gives extra protections against parameter errors during the upgrade process\n     * @param controller_ The controller contract\n     * @param targetLeverage_ The target leverage for the vault\n     * @param maxCollateral_ The maximum amount of collateral that can be held in the vault\n     * @param marketDefinitions_ The market definitions for the vault\n     * @param previousImplementation_ The previous implementation of the vault. Set to address(0) if there is none\n     */\n    constructor(\n        IController controller_,\n        UFixed18 targetLeverage_,\n        UFixed18 maxCollateral_,\n        MarketDefinition[] memory marketDefinitions_,\n        IBalancedVaultDefinition previousImplementation_\n    )\n    BalancedVaultDefinition(controller_, targetLeverage_, maxCollateral_, marketDefinitions_, previousImplementation_)\n    { }\n\n    /**\n     * @notice Initializes the contract state\n     * @param name_ ERC20 asset name\n     */\n    function initialize(string memory name_) external initializer(2) {\n        name = name_;   // allow `name` to be reset\n        __unused0 = \"\"; // deprecate `symbol`\n\n        // set or reset allowance compliant with both an initial deployment or an upgrade\n        asset.approve(address(collateral), UFixed18Lib.ZERO);\n        asset.approve(address(collateral));\n\n        // settle the state of the vault\n        /// @dev records the market data for all markets up to the latest epoch\n        (EpochContext memory context, )  = _settle(address(0));\n\n        // stamp latest epoch data for new markets\n        /// @dev required to register new markets in the case of an upgrade when the vault was already fully settled\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            if (_marketAccounts[marketId].versionOf[context.epoch] == 0)\n                _marketAccounts[marketId].versionOf[context.epoch] = markets(marketId).long.latestVersion();\n        }\n    }\n\n    /**\n     * @notice Rebalances the collateral and position of the vault without a deposit or withdraw\n     * @dev Should be called by a keeper when a new epoch is available, and there are pending deposits / redemptions\n     */\n    function sync() external {\n        syncAccount(address(0));\n    }\n\n    /**\n     * @notice Syncs `account`'s state up to current\n     * @dev Also rebalances the collateral and position of the vault without a deposit or withdraw\n     * @param account The account that should be synced\n     */\n    function syncAccount(address account) public {\n        (EpochContext memory context, ) = _settle(account);\n        _rebalance(context, UFixed18Lib.ZERO);\n    }\n\n    /**\n     * @notice Deposits `assets` assets into the vault, returning shares to `account` after the deposit settles.\n     * @param assets The amount of assets to deposit\n     * @param account The account to deposit on behalf of\n     */\n    function deposit(UFixed18 assets, address account) external {\n        (EpochContext memory context, ) = _settle(account);\n        if (assets.gt(_maxDepositAtEpoch(context))) revert BalancedVaultDepositLimitExceeded();\n\n        if (currentEpochStale()) {\n            _pendingDeposit = _pendingDeposit.add(assets);\n            _pendingDeposits[account] = _pendingDeposits[account].add(assets);\n            _pendingEpochs[account] = context.epoch + 1;\n            emit Deposit(msg.sender, account, context.epoch + 1, assets);\n        } else {\n            _deposit = _deposit.add(assets);\n            _deposits[account] = _deposits[account].add(assets);\n            _latestEpochs[account] = context.epoch;\n            emit Deposit(msg.sender, account, context.epoch, assets);\n        }\n\n        asset.pull(msg.sender, assets);\n\n        _rebalance(context, UFixed18Lib.ZERO);\n    }\n\n    /**\n     * @notice Redeems `shares` shares from the vault\n     * @dev Does not return any assets to the user due to delayed settlement. Use `claim` to claim assets\n     *      If account is not msg.sender, requires prior spending approval\n     * @param shares The amount of shares to redeem\n     * @param account The account to redeem on behalf of\n     */\n    function redeem(UFixed18 shares, address account) external {\n        if (msg.sender != account) _consumeAllowance(account, msg.sender, shares);\n\n        (EpochContext memory context, EpochContext memory accountContext) = _settle(account);\n        if (shares.gt(_maxRedeemAtEpoch(context, accountContext, account))) revert BalancedVaultRedemptionLimitExceeded();\n\n        if (currentEpochStale()) {\n            _pendingRedemption = _pendingRedemption.add(shares);\n            _pendingRedemptions[account] = _pendingRedemptions[account].add(shares);\n            _pendingEpochs[account] = context.epoch + 1;\n            emit Redemption(msg.sender, account, context.epoch + 1, shares);\n        } else {\n            _redemption = _redemption.add(shares);\n            _redemptions[account] = _redemptions[account].add(shares);\n            _latestEpochs[account] = context.epoch;\n            emit Redemption(msg.sender, account, context.epoch, shares);\n        }\n\n        _burn(account, shares);\n\n        _rebalance(context, UFixed18Lib.ZERO);\n    }\n\n    /**\n     * @notice Claims all claimable assets for account, sending assets to account\n     * @param account The account to claim for\n     */\n    function claim(address account) external {\n        (EpochContext memory context, ) = _settle(account);\n\n        UFixed18 unclaimedAmount = _unclaimed[account];\n        UFixed18 unclaimedTotal = _totalUnclaimed;\n        _unclaimed[account] = UFixed18Lib.ZERO;\n        _totalUnclaimed = unclaimedTotal.sub(unclaimedAmount);\n        emit Claim(msg.sender, account, unclaimedAmount);\n\n        // pro-rate if vault has less collateral than unclaimed\n        UFixed18 claimAmount = unclaimedAmount;\n        UFixed18 totalCollateral = _assets();\n        if (totalCollateral.lt(unclaimedTotal)) claimAmount = claimAmount.muldiv(totalCollateral, unclaimedTotal);\n\n        _rebalance(context, claimAmount);\n\n        asset.push(account, claimAmount);\n    }\n\n    /**\n     * @notice Sets `amount` as the allowance of `spender` over the caller's shares\n     * @param spender Address which can spend operate on shares\n     * @param amount Amount of shares that spender can operate on\n     * @return bool true if the approval was successful, otherwise reverts\n     */\n    function approve(address spender, UFixed18 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice The maximum available deposit amount\n     * @dev Only exact when vault is synced, otherwise approximate\n     * @return Maximum available deposit amount\n     */\n    function maxDeposit(address) external view returns (UFixed18) {\n        (EpochContext memory context, ) = _loadContextForRead(address(0));\n        return _maxDepositAtEpoch(context);\n    }\n\n    /**\n     * @notice The maximum available redeemable amount\n     * @dev Only exact when vault is synced, otherwise approximate\n     * @param account The account to redeem for\n     * @return Maximum available redeemable amount\n     */\n    function maxRedeem(address account) external view returns (UFixed18) {\n        (EpochContext memory context, EpochContext memory accountContext) = _loadContextForRead(account);\n        return _maxRedeemAtEpoch(context, accountContext, account);\n    }\n\n    /**\n     * @notice The total amount of assets currently held by the vault\n     * @return Amount of assets held by the vault\n     */\n    function totalAssets() external view returns (UFixed18) {\n        (EpochContext memory context, ) = _loadContextForRead(address(0));\n        return _totalAssetsAtEpoch(context);\n    }\n\n    /**\n     * @notice The total amount of shares currently issued\n     * @return Amount of shares currently issued\n     */\n    function totalSupply() external view returns (UFixed18) {\n        (EpochContext memory context, ) = _loadContextForRead(address(0));\n        return _totalSupplyAtEpoch(context);\n    }\n\n    /**\n     * @notice Number of shares held by `account`\n     * @param account Account to query balance of\n     * @return Number of shares held by `account`\n     */\n    function balanceOf(address account) external view returns (UFixed18) {\n        (, EpochContext memory accountContext) = _loadContextForRead(account);\n        return _balanceOfAtEpoch(accountContext, account);\n    }\n\n    /**\n     * @notice Total unclaimed assets in vault\n     * @return Total unclaimed assets in vault\n     */\n    function totalUnclaimed() external view returns (UFixed18) {\n        (EpochContext memory context, ) = _loadContextForRead(address(0));\n        return _totalUnclaimedAtEpoch(context);\n    }\n\n    /**\n     * @notice `account`'s unclaimed assets\n     * @param account Account to query unclaimed balance of\n     * @return `account`'s unclaimed assets\n     */\n    function unclaimed(address account) external view returns (UFixed18) {\n        (, EpochContext memory accountContext) = _loadContextForRead(account);\n        return _unclaimedAtEpoch(accountContext, account);\n    }\n\n    /**\n     * @notice Converts a given amount of assets to shares\n     * @param assets Number of assets to convert to shares\n     * @return Amount of shares for the given assets\n     */\n    function convertToShares(UFixed18 assets) external view returns (UFixed18) {\n        (EpochContext memory context, ) = _loadContextForRead(address(0));\n        return _convertToSharesAtEpoch(context, assets);\n    }\n\n    /**\n     * @notice Converts a given amount of shares to assets\n     * @param shares Number of shares to convert to assets\n     * @return Amount of assets for the given shares\n     */\n    function convertToAssets(UFixed18 shares) external view returns (UFixed18) {\n        (EpochContext memory context, ) = _loadContextForRead(address(0));\n        return _convertToAssetsAtEpoch(context, shares);\n    }\n\n    /**\n     * @notice Returns the current epoch\n     * @return The current epoch\n     */\n    function currentEpoch() public view returns (uint256) {\n        return currentEpochComplete() ? _latestEpoch + 1 : _latestEpoch;\n    }\n\n    /**\n     * @notice Returns the whether the current epoch is currently complete\n     * @dev An epoch is \"complete\" when all of the underlying oracles have advanced a version\n     * @return Whether the current epoch is complete\n     */\n    function currentEpochComplete() public view returns (bool) {\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            if (\n                Math.min(markets(marketId).long.latestVersion(), markets(marketId).short.latestVersion()) ==\n                _versionAtEpoch(marketId, _latestEpoch)\n            ) return false;\n        }\n        return true;\n    }\n\n    /**\n     * @notice Returns the whether the current epoch is currently stale\n     * @dev An epoch is \"stale\" when any one of the underlying oracles have advanced a version\n     * @return Whether the current epoch is stale\n     */\n    function currentEpochStale() public view returns (bool) {\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            if (\n                Math.max(markets(marketId).long.latestVersion(), markets(marketId).short.latestVersion()) >\n                _versionAtEpoch(marketId, _latestEpoch)\n            ) return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Hook that is called before every stateful operation\n     * @dev Settles the vault's account on both the long and short product, along with any global or user-specific deposits/redemptions\n     * @param account The account that called the operation, or 0 if called by a keeper.\n     * @return context The current epoch contexts for each market\n     * @return accountContext The current epoch contexts for each market for the given account\n     */\n    function _settle(address account) private returns (EpochContext memory context, EpochContext memory accountContext) {\n        (context, accountContext) = _loadContextForWrite(account);\n\n        if (context.epoch > _latestEpoch) {\n            _delayedMint(_totalSupplyAtEpoch(context).sub(_totalSupply.add(_pendingRedemption)));\n            _totalUnclaimed = _totalUnclaimedAtEpoch(context);\n            _deposit = UFixed18Lib.ZERO;\n            _redemption = UFixed18Lib.ZERO;\n            _latestEpoch = context.epoch;\n\n            for (uint256 marketId; marketId < totalMarkets; marketId++) {\n                MarketEpoch storage marketEpoch = _marketAccounts[marketId].epochs[context.epoch];\n\n                marketEpoch.longPosition = markets(marketId).long.position(address(this)).maker;\n                marketEpoch.shortPosition = markets(marketId).short.position(address(this)).maker;\n                marketEpoch.longAssets = collateral.collateral(address(this), markets(marketId).long);\n                marketEpoch.shortAssets = collateral.collateral(address(this), markets(marketId).short);\n\n                _marketAccounts[marketId].versionOf[context.epoch] = markets(marketId).long.latestVersion();\n            }\n            _marketAccounts[0].epochs[context.epoch].totalShares = _totalSupplyAtEpoch(context);\n            _marketAccounts[0].epochs[context.epoch].totalAssets = _totalAssetsAtEpoch(context);\n\n            // process pending deposit / redemption after new epoch is settled\n            _deposit = _pendingDeposit;\n            _redemption = _pendingRedemption;\n            _pendingDeposit = UFixed18Lib.ZERO;\n            _pendingRedemption = UFixed18Lib.ZERO;\n        }\n\n        if (account != address(0)) {\n            if (accountContext.epoch > _latestEpochs[account]) {\n                _delayedMintAccount(account, _balanceOfAtEpoch(accountContext, account).sub(_balanceOf[account].add(_pendingRedemptions[account])));\n                _unclaimed[account] = _unclaimedAtEpoch(accountContext, account);\n                _deposits[account] = UFixed18Lib.ZERO;\n                _redemptions[account] = UFixed18Lib.ZERO;\n                _latestEpochs[account] = accountContext.epoch;\n            }\n            if (accountContext.epoch > _pendingEpochs[account]) {\n                _deposits[account] = _pendingDeposits[account];\n                _redemptions[account] = _pendingRedemptions[account];\n                _latestEpochs[account] = _pendingEpochs[account];\n                _pendingDeposits[account] = UFixed18Lib.ZERO;\n                _pendingRedemptions[account] = UFixed18Lib.ZERO;\n                _pendingEpochs[account] = accountContext.epoch;\n\n                (context, accountContext) = _settle(account); // run settle again after moving pending deposits and redemptions into current\n            }\n        }\n    }\n\n    /**\n     * @notice Rebalances the collateral and position of the vault\n     * @dev Rebalance is executed on best-effort, any failing legs of the strategy will not cause a revert\n     * @param claimAmount The amount of assets that will be withdrawn from the vault at the end of the operation\n     */\n    function _rebalance(EpochContext memory context, UFixed18 claimAmount) private {\n        _rebalanceCollateral(claimAmount);\n        _rebalancePosition(context, claimAmount);\n    }\n\n    /**\n     * @notice Rebalances the collateral of the vault\n     * @param claimAmount The amount of assets that will be withdrawn from the vault at the end of the operation\n     */\n    function _rebalanceCollateral(UFixed18 claimAmount) private {\n        // Compute target collateral\n        UFixed18 targetCollateral = _assets().sub(claimAmount).div(TWO);\n        if (targetCollateral.muldiv(minWeight, totalWeight).lt(controller.minCollateral()))\n            targetCollateral = UFixed18Lib.ZERO;\n\n        // Remove collateral from markets above target\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            UFixed18 marketCollateral = targetCollateral.muldiv(markets(marketId).weight, totalWeight);\n\n            if (collateral.collateral(address(this), markets(marketId).long).gt(marketCollateral))\n                _updateCollateral(markets(marketId).long, marketCollateral);\n            if (collateral.collateral(address(this), markets(marketId).short).gt(marketCollateral))\n                _updateCollateral(markets(marketId).short, marketCollateral);\n        }\n\n        // Deposit collateral to markets below target\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            UFixed18 marketCollateral = targetCollateral.muldiv(markets(marketId).weight, totalWeight);\n\n            if (collateral.collateral(address(this), markets(marketId).long).lt(marketCollateral))\n                _updateCollateral(markets(marketId).long, marketCollateral);\n            if (collateral.collateral(address(this), markets(marketId).short).lt(marketCollateral))\n                _updateCollateral(markets(marketId).short, marketCollateral);\n        }\n    }\n\n    /**\n     * @notice Rebalances the position of the vault\n     * @param context Epoch context to use in calculation\n     * @param claimAmount The amount of assets that will be withdrawn from the vault at the end of the operation\n     */\n    function _rebalancePosition(EpochContext memory context, UFixed18 claimAmount) private {\n        // Compute target collateral\n        UFixed18 targetCollateral = _totalAssetsAtEpoch(context).sub(claimAmount)\n            .mul(_totalSupplyAtEpoch(context).unsafeDiv(_totalSupplyAtEpoch(context).add(_redemption)))\n            .add(_deposit)\n            .div(TWO);\n        if (targetCollateral.muldiv(minWeight, totalWeight).lt(controller.minCollateral()))\n            targetCollateral = UFixed18Lib.ZERO;\n\n        // Target new maker position per market price and weight\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            UFixed18 marketCollateral = targetCollateral.muldiv(markets(marketId).weight, totalWeight);\n            if (markets(marketId).long.closed() || markets(marketId).short.closed()) marketCollateral = UFixed18Lib.ZERO;\n\n            UFixed18 currentPrice = markets(marketId).long.atVersion(markets(marketId).long.latestVersion()).price.abs();\n            UFixed18 targetPosition = marketCollateral.mul(targetLeverage).div(currentPrice);\n\n            _updateMakerPosition(markets(marketId).long, targetPosition);\n            _updateMakerPosition(markets(marketId).short, targetPosition);\n        }\n    }\n\n    /**\n     * @notice Adjusts the position on `product` to `targetPosition`\n     * @param product The product to adjust the vault's position on\n     * @param targetPosition The new position to target\n     */\n    function _updateMakerPosition(IProduct product, UFixed18 targetPosition) private {\n        UFixed18 accountPosition = product.position(address(this)).next(product.pre(address(this))).maker;\n\n        if (targetPosition.lt(accountPosition)) {\n            // compute headroom until hitting taker amount\n            Position memory position = product.positionAtVersion(product.latestVersion()).next(product.pre());\n            UFixed18 makerAvailable = position.maker.gt(position.taker) ?\n                position.maker.sub(position.taker) : UFixed18Lib.ZERO;\n\n            product.closeMake(accountPosition.sub(targetPosition).min(makerAvailable));\n        }\n\n        if (targetPosition.gt(accountPosition)) {\n            // compute headroom until hitting makerLimit\n            UFixed18 currentMaker = product.positionAtVersion(product.latestVersion()).next(product.pre()).maker;\n            UFixed18 makerLimit = product.makerLimit();\n            UFixed18 makerAvailable = makerLimit.gt(currentMaker) ? makerLimit.sub(currentMaker) : UFixed18Lib.ZERO;\n\n            product.openMake(targetPosition.sub(accountPosition).min(makerAvailable));\n        }\n    }\n\n    /**\n     * @notice Adjusts the collateral on `product` to `targetCollateral`\n     * @param product The product to adjust the vault's collateral on\n     * @param targetCollateral The new collateral to target\n     */\n    function _updateCollateral(IProduct product, UFixed18 targetCollateral) private {\n        UFixed18 currentCollateral = collateral.collateral(address(this), product);\n\n        if (currentCollateral.gt(targetCollateral))\n            collateral.withdrawTo(address(this), product, currentCollateral.sub(targetCollateral));\n        if (currentCollateral.lt(targetCollateral))\n            collateral.depositTo(address(this), product, targetCollateral.sub(currentCollateral));\n    }\n\n    /**\n     * @notice Burns `amount` shares from `from`, adjusting totalSupply\n     * @param from Address to burn shares from\n     * @param amount Amount of shares to burn\n     */\n    function _burn(address from, UFixed18 amount) private {\n        _balanceOf[from] = _balanceOf[from].sub(amount);\n        _totalSupply = _totalSupply.sub(amount);\n        emit Burn(from, amount);\n    }\n\n    /**\n     * @notice Mints `amount` shares, adjusting totalSupply\n     * @param amount Amount of shares to mint\n     */\n    function _delayedMint(UFixed18 amount) private {\n        _totalSupply = _totalSupply.add(amount);\n    }\n\n    /**\n     * @notice Mints `amount` shares to `to`\n     * @param to Address to mint shares to\n     * @param amount Amount of shares to mint\n     */\n    function _delayedMintAccount(address to, UFixed18 amount) private {\n        _balanceOf[to] = _balanceOf[to].add(amount);\n        emit Mint(to, amount);\n    }\n\n    /**\n     * @notice Decrements `spender`s allowance for `account` by `amount`\n     * @dev Does not decrement if approval is for -1\n     * @param account Address of allower\n     * @param spender Address of spender\n     * @param amount Amount to decrease allowance by\n     */\n    function _consumeAllowance(address account, address spender, UFixed18 amount) private {\n        if (allowance[account][spender].eq(UFixed18Lib.MAX)) return;\n        allowance[account][spender] = allowance[account][spender].sub(amount);\n    }\n\n    /**\n     * @notice Loads the context for the given `account`, settling the vault first\n     * @param account Account to load the context for\n     * @return global epoch context\n     * @return account epoch context\n     */\n    function _loadContextForWrite(address account) private returns (EpochContext memory, EpochContext memory) {\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            markets(marketId).long.settleAccount(address(this));\n            markets(marketId).short.settleAccount(address(this));\n        }\n\n        return _loadContextForRead(account);\n    }\n\n    /**\n     * @notice Loads the context for the given `account`\n     * @param account Account to load the context for\n     * @return global epoch context\n     * @return account epoch context\n     */\n    function _loadContextForRead(address account) private view returns (EpochContext memory, EpochContext memory) {\n        uint256 _currentEpoch = currentEpoch();\n        return (\n            EpochContext(_currentEpoch, _assetsAtEpoch(_latestEpoch), _sharesAtEpoch(_latestEpoch)),\n            EpochContext(_currentEpoch, _assetsAtEpoch(_latestEpochs[account]), _sharesAtEpoch(_latestEpochs[account]))\n        );\n    }\n\n    /**\n     * @notice Calculates whether or not the vault is in an unhealthy state at the provided epoch\n     * @param context Epoch context to calculate health\n     * @return bool true if unhealthy, false if healthy\n     */\n    function _unhealthyAtEpoch(EpochContext memory context) private view returns (bool) {\n        if (!context.latestShares.isZero() && context.latestAssets.isZero()) return true;\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            if (_unhealthy(markets(marketId))) return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Determines whether the market pair is currently in an unhealthy state\n     * @dev market is unhealthy if either the long or short markets are liquidating or liquidatable\n     * @param marketDefinition The configuration of the market\n     * @return bool true if unhealthy, false if healthy\n     */\n    function _unhealthy(MarketDefinition memory marketDefinition) internal view returns (bool) {\n        return collateral.liquidatable(address(this), marketDefinition.long)\n            || collateral.liquidatable(address(this), marketDefinition.short)\n            || marketDefinition.long.isLiquidating(address(this))\n            || marketDefinition.short.isLiquidating(address(this));\n    }\n\n    /**\n     * @notice The maximum available deposit amount at the given epoch\n     * @param context Epoch context to use in calculation\n     * @return Maximum available deposit amount at epoch\n     */\n    function _maxDepositAtEpoch(EpochContext memory context) private view returns (UFixed18) {\n        if (_unhealthyAtEpoch(context)) return UFixed18Lib.ZERO;\n        UFixed18 currentCollateral = _totalAssetsAtEpoch(context).add(_deposit).add(_pendingDeposit);\n        return maxCollateral.gt(currentCollateral) ? maxCollateral.sub(currentCollateral) : UFixed18Lib.ZERO;\n    }\n\n    /**\n     * @notice The maximum available redeemable amount at the given epoch for `account`\n     * @param context Epoch context to use in calculation\n     * @param accountContext Account epoch context to use in calculation\n     * @param account Account to calculate redeemable amount\n     * @return Maximum available redeemable amount at epoch\n     */\n    function _maxRedeemAtEpoch(\n        EpochContext memory context,\n        EpochContext memory accountContext,\n        address account\n    ) private view returns (UFixed18) {\n        if (_unhealthyAtEpoch(context)) return UFixed18Lib.ZERO;\n        UFixed18 maxAmount = _balanceOfAtEpoch(accountContext, account);\n\n        // Calculate the maximum amount we can take out of any supported market by finding the minimum amount we can close\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            MarketDefinition memory marketDefinition = markets(marketId);\n\n            uint256 longLatestVersion = marketDefinition.long.latestVersion();\n            uint256 shortLatestVersion = marketDefinition.short.latestVersion();\n\n            UFixed18 currentPrice = marketDefinition.long.atVersion(Math.min(longLatestVersion, shortLatestVersion)).price.abs();\n\n            Position memory longGlobalPosition = marketDefinition.long.positionAtVersion(longLatestVersion).next(marketDefinition.long.pre());\n            Position memory shortGlobalPosition = marketDefinition.short.positionAtVersion(shortLatestVersion).next(marketDefinition.short.pre());\n\n            UFixed18 longAvailable = longGlobalPosition.maker.sub(longGlobalPosition.taker.min(longGlobalPosition.maker));\n            UFixed18 shortAvailable = shortGlobalPosition.maker.sub(shortGlobalPosition.taker.min(shortGlobalPosition.maker));\n\n            UFixed18 collateral = longAvailable.min(shortAvailable).muldiv(currentPrice, targetLeverage);\n            collateral = collateral.mul(TWO).muldiv(totalWeight, marketDefinition.weight);\n            maxAmount = maxAmount.min(_convertToSharesAtEpoch(context, collateral));\n        }\n        return maxAmount;\n    }\n\n    /**\n     * @notice The total assets at the given epoch\n     * @param context Epoch context to use in calculation\n     * @return Total assets amount at epoch\n     */\n    function _totalAssetsAtEpoch(EpochContext memory context) private view returns (UFixed18) {\n        (UFixed18 totalCollateral, UFixed18 totalDebt) = (\n            _assets(),\n            _totalUnclaimedAtEpoch(context).add(_deposit).add(_pendingDeposit)\n        );\n        return totalCollateral.gt(totalDebt) ? totalCollateral.sub(totalDebt) : UFixed18Lib.ZERO;\n    }\n\n    /**\n     * @notice The total supply at the given epoch\n     * @param context Epoch context to use in calculation\n     * @return Total supply amount at epoch\n     */\n    function _totalSupplyAtEpoch(EpochContext memory context) private view returns (UFixed18) {\n        if (context.epoch == _latestEpoch) return _totalSupply.add(_pendingRedemption);\n        return _totalSupply.add(_pendin"
    }
  ]
}