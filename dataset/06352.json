{
  "Title": "[H-01] There is a vulnerability in the `executeFlashloan` function of the `PeUSDMainnet` contract. Hackers can use this vulnerability to burn other people's eUSD token balance without permission",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/PeUSDMainnetStableVision.sol#L129-L139>\n\n<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/EUSD.sol#L228-L230>\n\n### Impact\n\nThe `executeFlashloan` function of the `PeUSDMainnet` contract is used to provide users with the flash loan function. There is a loophole in the logic and hackers can use this loophole to burn other people's eUSD token balance without permission.\n\n### Proof of Concept\n\nSince the parameter `FlashBorrower receiver` of the `executeFlashloan` function can be designated as anyone, the flash loan system will charge a certain percentage of the loan fee (up to 10%) to `receiver` for each flash loan. The code is as follows:\n\n    EUSD.burnShares(address(receiver), burnShare);\n\nWhen a hacker maliciously initiates a flash loan for a `receiver` contract, and the value of the `eusdAmount` parameter passed in is large enough, the `receiver` will be deducted a large amount of loan fees; the hacker can burn a large amount of other people's eUSD without permissioning the amount.\n\nLet us analyze the design logic of the system itself step by step for discussion:\n\n1.  The flashloan fee of the `PeUSDMainnet` contract is collected by calling the `burnShares` function of the `EUSD` contract. Continue to read the code to find that the `burnShares` function of the `EUSD` contract has a very critical `modifier onlyMintVault` condition Judgment, so it is obvious that the `PeUSDMainnet` contract is the minter role of the `EUSD` contract (otherwise it will not be able to charge the flashloan fee).\n\n2.  Usually, when the `transferFrom` function is called, the ERC20 token needs to be approved by the spender before it can be used. But the `transferFrom` function in the `EUSD` contract is implemented like this:\n\n<!---->\n\n    function transferFrom(address from, address to, uint256 amount) public returns (bool) {\n         address spender = _msgSender();\n         if (!configurator. mintVault(spender)) {\n             _spendAllowance(from, spender, amount);\n         }\n         _transfer(from, to, amount);\n         return true;\n    }\n\nThe above code indicates that the miner of EUSD can call `transferFrom` arbitrarily, without the user calling `increaseAllowance` for approval. The `PeUSDMainnet` contract is the minter of the `EUSD` contract, so line 133 of the `PeUSDMainnet` contract code:\n`bool success = EUSD.transferFrom(address(receiver), address(this), EUSD.getMintedEUSDByShares(shareAmount));` can be executed without user approval.\n\n3.  In line 132 of the `executeFlashloan` function of the `PeUSDMainnet` contract: `receiver.onFlashLoan(shareAmount, data);`, if the `receiver` does not implement the `onFlashLoan` method, the EVM will revert and the hacker will not be able to maliciously execute the attack. However, if the receiver contract simply declares the `fallback()` function, or its `fallback()` logic does not have a very robust judgment, then line 132 of the code can be easily bypassed. So is there really such a contract that just satisfies this condition? The answer is yes, for example this address: `0x32034276343de43844993979e5384d4b7e030934` (etherscan: <https://etherscan.io/address/0x32034276343de43844993979e5384d4b7e030934#code>), has 200,000 eUSD tokens and declared the `fallback` function, its source code excerpts are as follows:\n\n```solidity\ncontract GnosisSafeProxy {\n    // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\n    address internal singleton;\n\n    /// @dev Constructor function sets address of singleton contract.\n    /// @param _singleton Singleton address.\n    constructor(address _singleton) {\n        require(_singleton != address(0), \"Invalid singleton address provided\");\n        singleton = _singleton;\n    }\n\n    /// @dev Fallback function forwards all transactions and returns all received return data.\n    fallback() external payable {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, _singleton)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}\n```\n\n4.  Assuming that the `PeUSDMainnet` contract flash loan fee rate is 5% at this time, the hacker maliciously calls the `executeFlashloan` function to initiate a flash loan with the address: `0x32034276343de43844993979e5384d4b7e030934`, the function parameter `uint256 eusdAmount = 4_000_000`, and the calculated loan fee  is`  4_000_000 * 5% = 200_000 `, the 200\\_000 eUSD balance of the address `0x32034276343de43844993979e5384d4b7e030934` will be maliciously burned by hackers!\n\nThe following is the forge test situation I simulated locally:\n\n    [PASS] testGnosisSafeProxy() (gas: 10044)\n    Traces:\n      [10044] AttackTest::testGnosisSafeProxy() \n        â”œâ”€ [4844] GnosisSafeProxy::onFlashLoan() \n        â”‚   â”œâ”€ [0] 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552::onFlashLoan() [delegatecall]\n        â”‚   â”‚   â””â”€ â† ()\n        â”‚   â””â”€ â† ()\n        â””â”€ â† ()\n\n    Test result: ok. 1 passed; 0 failed; finished in 972.63Âµs\n\nThe `fallback` function of the `GnosisSafeProxy` contract is allowed to be called without revert.\n\n### Tools Used\n\nVisual Studio Code\nFoundry\n\n### Recommended Mitigation Steps\n\nOptimize the flash loan logic of the `executeFlashloan` function of the `PeUSDMainnet` contract, remove the `FlashBorrower receiver` parameter, and set `receiver` to `msg.sender`; which means that a user can only initiate a flash loan for themselves.\n\n**[LybraFinance confirmed](https://github.com/code-423n4/2023-06-lybra-findings/issues/769#issuecomment-1656674715)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/token/PeUSDMainnetStableVision.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/**\n * @title PeUSD Token\n * @dev PeUSD is a stable, interest-free ERC20-like token minted through eUSD in the Lybra protocol.\n * It is pegged to 1 USD and does not undergo rebasing.\n * PeUSD can be minted and burned through non-rebasing asset pools.\n * Additionally, PeUSD can be minted in equivalent amounts by depositing eUSD.\n * The contract keeps track of the totalShares of eUSD deposited by users and the totalMinted PeUSD.\n * When users redeem PeUSD, they can retrieve the corresponding proportion of eUSD.\n * As a result, users can utilize PeUSD without sacrificing the yield on their eUSD holdings.\n */\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../OFT/BaseOFTV2.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"../interfaces/IEUSD.sol\";\n\ninterface FlashBorrower {\n    /// @notice Flash loan callback\n    /// @param amount The amount of tokens received\n    /// @param data Forwarded data from the flash loan request\n    /// @dev Called after receiving the requested flash loan, should return tokens + any fees before the end of the transaction\n    function onFlashLoan(uint256 amount, bytes calldata data) external;\n}\n\ncontract PeUSDMainnet is BaseOFTV2, ERC20 {\n    IEUSD public immutable EUSD;\n    Iconfigurator public immutable configurator;\n    uint internal immutable ld2sdRatio;\n    mapping(address => ConvertInfo) public userConvertInfo;\n\n    struct ConvertInfo {\n        uint256 depositedEUSDShares;\n        uint256 mintedPeUSD;\n    }\n\n    event Flashloaned(FlashBorrower indexed receiver, uint256 borrowShares, uint256 burnAmount);\n\n    modifier onlyMintVault() {\n        require(configurator.mintVault(msg.sender), \"RCP\");\n        _;\n    }\n    modifier MintPaused() {\n        require(!configurator.vaultMintPaused(msg.sender), \"MPP\");\n        _;\n    }\n    modifier BurnPaused() {\n        require(!configurator.vaultBurnPaused(msg.sender), \"BPP\");\n        _;\n    }\n\n    constructor(address _config, uint8 _sharedDecimals, address _lzEndpoint) ERC20(\"peg-eUSD\", \"PeUSD\") BaseOFTV2(_sharedDecimals, _lzEndpoint) {\n        configurator = Iconfigurator(_config);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        uint8 decimals = decimals();\n        require(_sharedDecimals <= decimals, \"OFT: sharedDecimals must be <= decimals\");\n        ld2sdRatio = 10 ** (decimals - _sharedDecimals);\n    }\n\n    function mint(address to, uint256 amount) external onlyMintVault MintPaused returns (bool) {\n        require(to != address(0), \"TZA\");\n        _mint(to, amount);\n        return true;\n    }\n\n    function burn(address account, uint256 amount) external onlyMintVault BurnPaused returns (bool) {\n        _burn(account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Allows the user to deposit eUSD and mint PeUSD tokens.\n     * @param user The address of the user who wants to deposit eUSD and mint PeUSD. It can only be the contract itself or the msg.sender.\n     * @param eusdAmount The amount of eUSD to deposit and mint PeUSD tokens.\n     */\n    function convertToPeUSD(address user, uint256 eusdAmount) public {\n        require(_msgSender() == user || _msgSender() == address(this), \"MDM\");\n        require(EUSD.balanceOf(address(this)) + eusdAmount <= configurator.getEUSDMaxLocked(),\"ESL\");\n        bool success = EUSD.transferFrom(user, address(this), eusdAmount);\n        require(success, \"TF\");\n        uint256 share = EUSD.getSharesByMintedEUSD(eusdAmount);\n        userConvertInfo[user].depositedEUSDShares += share;\n        userConvertInfo[user].mintedPeUSD += eusdAmount;\n        _mint(user, eusdAmount);\n    }\n\n    /**\n     * @dev Allows users to deposit eUSD and mint PeUSD tokens, which can be directly bridged to other networks.\n     * @param eusdAmount The amount of eUSD to deposit and mint PeUSD tokens.\n     * @param dstChainId The chain ID of the target network.\n     * @param toAddress The receiving address after cross-chain transfer.\n     * @param callParams Additional parameters.\n     */\n    function convertToPeUSDAndCrossChain(\n        uint256 eusdAmount,\n        uint16 dstChainId,\n        bytes32 toAddress,\n        LzCallParams calldata callParams\n    ) external payable {\n        convertToPeUSD(_msgSender(), eusdAmount);\n        sendFrom(_msgSender(), dstChainId, toAddress, eusdAmount, callParams);\n    }\n\n    /**\n     * @dev Allows users to repay PeUSD tokens and retrieve eUSD.\n     * @param peusdAmount The amount of PeUSD tokens to burn and retrieve eUSD. The user's balance of PeUSD tokens must be greater than or equal to this amount.\n     * Requirements:\n     * `peusdAmount` must be greater than 0.\n     * The user's `mintedPeUSD` must be greater than or equal to `peusdAmount`.\n     */\n    function convertToEUSD(uint256 peusdAmount) external {\n        require(peusdAmount <= userConvertInfo[msg.sender].mintedPeUSD &&peusdAmount > 0, \"PCE\");\n        _burn(msg.sender, peusdAmount);\n        uint256 share = (userConvertInfo[msg.sender].depositedEUSDShares * peusdAmount) / userConvertInfo[msg.sender].mintedPeUSD;\n        userConvertInfo[msg.sender].mintedPeUSD -= peusdAmount;\n        userConvertInfo[msg.sender].depositedEUSDShares -= share;\n        EUSD.transferShares(msg.sender, share);\n    }\n\n    /**\n     * @dev Allows users to lend out any amount of eUSD for flash loan calls.\n     * @param receiver The address of the contract that will receive the borrowed eUSD.\n     * @param eusdAmount The amount of eUSD to lend out.\n     * @param data The data to be passed to the receiver contract for execution.\n     */\n    function executeFlashloan(FlashBorrower receiver, uint256 eusdAmount, bytes calldata data) public payable {\n        uint256 shareAmount = EUSD.getSharesByMintedEUSD(eusdAmount);\n        EUSD.transferShares(address(receiver), shareAmount);\n        receiver.onFlashLoan(shareAmount, data);\n        bool success = EUSD.transferFrom(address(receiver), address(this), EUSD.getMintedEUSDByShares(shareAmount));\n        require(success, \"TF\");\n\n        uint256 burnShare = getFee(shareAmount);\n        EUSD.burnShares(address(receiver), burnShare);\n        emit Flashloaned(receiver, eusdAmount, burnShare);\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\n        address spender = _msgSender();\n        if (!configurator.mintVault(spender)) {\n            _spendAllowance(from, spender, amount);\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /************************************************************************\n     * view functions\n     ************************************************************************/\n\n    /// @notice Calculate the fee owed for the loaned tokens\n    /// @return The amount of shares you need to pay as a fee\n    function getFee(uint256 share) public view returns (uint256) {\n        return (share * configurator.flashloanFee()) / 10_000;\n    }\n\n    /**\n     * @dev Returns the interest of eUSD locked by the user.\n     * @param user The address of the user.\n     * @return eusdAmount The interest earned by the user.\n     */\n    function getAccruedEUSDInterest(\n        address user\n    ) public view returns (uint256 eusdAmount) {\n        return EUSD.getMintedEUSDByShares(userConvertInfo[user].depositedEUSDShares) - userConvertInfo[user].mintedPeUSD;\n    }\n\n    function circulatingSupply() public view virtual override returns (uint) {\n        return totalSupply();\n    }\n\n    function token() public view virtual override returns (address) {\n        return address(this);\n    }\n\n    /************************************************************************\n     * internal functions\n     * @dev The following functions are internal functions of Layer Zero OFT, used for internal calls during cross-chain operations.\n     ************************************************************************/\n\n    function _debitFrom(address _from, uint16, bytes32, uint _amount) internal virtual override returns (uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _burn(_from, _amount);\n        return _amount;\n    }\n\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns (uint) {\n        _mint(_toAddress, _amount);\n        return _amount;\n    }\n\n    function _transferFrom(address _from, address _to, uint _amount) internal virtual override returns (uint) {\n        address spender = _msgSender();\n        // if transfer from this contract, no need to check allowance\n        if (_from != address(this) && _from != spender)\n            _spendAllowance(_from, spender, _amount);\n        _transfer(_from, _to, _amount);\n        return _amount;\n    }\n\n    function _ld2sdRatio() internal view virtual override returns (uint) {\n        return ld2sdRatio;\n    }\n}"
    },
    {
      "filename": "contracts/lybra/token/EUSD.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\n\n/**\n * @title Interest-bearing ERC20-like token for Lybra protocol.\n *\n * EUSD balances are dynamic and represent the holder's share in the total amount\n * of Ether controlled by the protocol. Account shares aren't normalized, so the\n * contract also stores the sum of all shares to calculate each account's token balance\n * which equals to:\n *\n *   shares[account] * totalSupply / _totalShares\n *\n * For example, assume that we have:\n *\n *   _getTotalMintedEUSD() -> 1000 EUSD\n *   sharesOf(user1) -> 100\n *   sharesOf(user2) -> 400\n *\n * Therefore:\n *\n *   balanceOf(user1) -> 2 tokens which corresponds 200 EUSD\n *   balanceOf(user2) -> 8 tokens which corresponds 800 EUSD\n *\n * Since balances of all token holders change when the amount of total shares\n * changes, this token cannot fully implement ERC20 standard: it only emits `Transfer`\n * events upon explicit transfer between holders. In contrast, when total amount of\n * pooled Ether increases, no `Transfer` events are generated: doing so would require\n * emitting an event for each token holder and thus running an unbounded loop.\n */\ncontract EUSD is IERC20, Context {\n    using SafeMath for uint256;\n    Iconfigurator public immutable configurator;\n    uint256 private _totalShares;\n    uint256 private _totalSupply;\n\n    /**\n     * @dev EUSD balances are dynamic and are calculated based on the accounts' shares\n     * and the total supply by the protocol. Account shares aren't\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account's token balance which equals to:\n     *\n     *   shares[account] * _getTotalMintedEUSD() / _getTotalShares()\n     */\n    mapping(address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping(address => mapping(address => uint256)) private allowances;\n\n    /**\n     * @notice An executed shares transfer from `sender` to `recipient`.\n     *\n     * @dev emitted in pair with an ERC20-defined `Transfer` event.\n     */\n    event TransferShares(address indexed from, address indexed to, uint256 sharesValue);\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding EUSD amount.\n     * The EUSD amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of EUSD the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of EUSD the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(address indexed account, uint256 preRebaseTokenAmount, uint256 postRebaseTokenAmount, uint256 sharesAmount);\n\n    modifier onlyMintVault() {\n        require(configurator.mintVault(msg.sender), \"RCP\");\n        _;\n    }\n    modifier MintPaused() {\n        require(!configurator.vaultMintPaused(msg.sender), \"MPP\");\n        _;\n    }\n    modifier BurnPaused() {\n        require(!configurator.vaultBurnPaused(msg.sender), \"BPP\");\n        _;\n    }\n\n    constructor(address _config) {\n        configurator = Iconfigurator(_config);\n    }\n\n    /**\n     * @return the name of the token.\n     */\n    function name() public pure returns (string memory) {\n        return \"eUSD\";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public pure returns (string memory) {\n        return \"eUSD\";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of EUSD in existence.\n     *\n     * @dev Always equals to `_getTotalMintedEUSD()` since token amount\n     * is pegged to the total amount of EUSD controlled by the protocol.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) public view returns (uint256) {\n        return getMintedEUSDByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller's account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) public returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller's tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) public returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller's\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address from, address to, uint256 amount) public returns (bool) {\n        address spender = _msgSender();\n        if (!configurator.mintVault(spender)) {\n            _spendAllowance(from, spender, amount);\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     * - the contract must not be paused.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, _spender, allowances[owner][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     * - the contract must not be paused.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account's relative share.\n     */\n    function getTotalShares() public view returns (uint256) {\n        return _totalShares;\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) public view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_EUSDAmount` protocol-supplied EUSD.\n     */\n    function getSharesByMintedEUSD(uint256 _EUSDAmount) public view returns (uint256) {\n        uint256 totalMintedEUSD = _totalSupply;\n        if (totalMintedEUSD == 0) {\n            return 0;\n        } else {\n            return _EUSDAmount.mul(_totalShares).div(totalMintedEUSD);\n        }\n    }\n\n    /**\n     * @return the amount of EUSD that corresponds to `_sharesAmount` token shares.\n     */\n    function getMintedEUSDByShares(uint256 _sharesAmount) public view returns (uint256) {\n        if (_totalShares == 0) {\n            return 0;\n        } else {\n            return _sharesAmount.mul(_totalSupply).div(_totalShares);\n        }\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller's account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) public returns (uint256) {\n        address owner = _msgSender();\n        _transferShares(owner, _recipient, _sharesAmount);\n        emit TransferShares(owner, _recipient, _sharesAmount);\n        uint256 tokensAmount = getMintedEUSDByShares(_sharesAmount);\n        emit Transfer(owner, _recipient, tokensAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByMintedEUSD(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        emit Transfer(_sender, _recipient, _amount);\n        emit TransferShares(_sender, _recipient, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), \"APPROVE_FROM_ZERO_ADDRESS\");\n        require(_spender != address(0), \"APPROVE_TO_ZERO_ADDRESS\");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address.\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), \"TRANSFER_FROM_THE_ZERO_ADDRESS\");\n        require(_recipient != address(0), \"TRANSFER_TO_THE_ZERO_ADDRESS\");\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, \"TRANSFER_AMOUNT_EXCEEDS_BALANCE\");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This operation also increases the total supply of tokens.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function mint(address _recipient, uint256 _mintAmount) external onlyMintVault MintPaused returns (uint256 newTotalShares) {\n        require(_recipient != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n\n        uint256 sharesAmount = getSharesByMintedEUSD(_mintAmount);\n        if (sharesAmount == 0) {\n            //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1\n            sharesAmount = _mintAmount;\n        }\n\n        newTotalShares = _totalShares.add(sharesAmount);\n        _totalShares = newTotalShares;\n\n        shares[_recipient] = shares[_recipient].add(sharesAmount);\n\n        _totalSupply += _mintAmount;\n\n        emit Transfer(address(0), _recipient, _mintAmount);\n    }\n\n    /**\n     * @notice Destroys `sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\n     * @dev This operation also decrease the total supply of tokens.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function burn(address _account, uint256 _burnAmount) external onlyMintVault BurnPaused returns (uint256 newTotalShares) {\n        require(_account != address(0), \"BURN_FROM_THE_ZERO_ADDRESS\");\n        uint256 sharesAmount = getSharesByMintedEUSD(_burnAmount);\n        newTotalShares = _onlyBurnShares(_account, sharesAmount);\n        _totalSupply -= _burnAmount;\n\n        emit Transfer(_account, address(0), _burnAmount);\n    }\n\n    /**\n     * @notice Destroys `sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\n     * @dev This doesn't decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function burnShares(address _account, uint256 _sharesAmount) external onlyMintVault BurnPaused returns (uint256 newTotalShares) {\n        require(_account != address(0), \"BURN_FROM_THE_ZERO_ADDRESS\");\n        newTotalShares = _onlyBurnShares(_account, _sharesAmount);\n    }\n\n    function _onlyBurnShares(address _account, uint256 _sharesAmount) private returns (uint256 newTotalShares) {\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, \"BURN_AMOUNT_EXCEEDS_BALANCE\");\n\n        uint256 preRebaseTokenAmount = getMintedEUSDByShares(_sharesAmount);\n\n        newTotalShares = _totalShares.sub(_sharesAmount);\n        _totalShares = newTotalShares;\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getMintedEUSDByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we're not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn't change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We're emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n}"
    }
  ]
}