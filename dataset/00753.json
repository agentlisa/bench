{
  "Title": "Functions Return Inaccurate Values Without Interest Accrual",
  "Content": "Several `view` functions in the `IonPool` and `RewardModule` contracts return inaccurate values as they do not accrue interest prior to being called.\n\n\n* The [`balanceOf` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/reward/RewardModule.sol#L252)\n* The [`totalSupply` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/reward/RewardModule.sol#L293)\n* The [`supplyFactor` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/reward/RewardModule.sol#L316)\n* The [`rate` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L918)\n* The [`debt` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L1018)\n* The [`getCurrentBorrowRate` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L1058)\n* The [`normalizedTotalSupply` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/reward/RewardModule.sol#L308)\n\n\nThis can lead to difficulties for users who are interacting with the protocol. In particular, if a user wants to withdraw their entire underlying balance, they would expect that calling `withdraw(msg.sender, balanceOf(msg.sender))` would withdraw their entire balance but it would not.\n\n\nIn addition, if a user wants to borrow a fixed amount of WETH (`amountOfWETH`), they would expect that calling `borrow(ilkIndex, msg.sender, msg.sender, amountOfWETH / rate(), proof)` would result in borrowing exactly `amountOfWETH` WETH but due to an out-of-date `rate` value they would receive less WETH than expected.\n\n\nMoreover, if a user wants to repay their debt and only wants to approve the exact amount of WETH to be transferred from their wallet, the approved amount would be less than what would be required after accruing interest.\n\n\nConsider implementing functions that will return the correct up-to-date state of the contract for the aforementioned `view` functions such that their resulting output will be accurate. These functions may be called something like `getAccrued...` in order to allow the previous functions to remain useful for internal integrations without breaking functionality. We also suggest carefully checking all calls to each of these functions to determine if they should be swapped out for an up-to-date version.\n\n\n***Update:** Resolved in [pull request #30](https://github.com/Ion-Protocol/ion-protocol/pull/30).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/reward/RewardModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport { WadRayMath, RAY } from \"src/libraries/math/WadRayMath.sol\";\n\nimport { ContextUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport { AccessControlDefaultAdminRulesUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlDefaultAdminRulesUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title RewardModule\n */\nabstract contract RewardModule is ContextUpgradeable, AccessControlDefaultAdminRulesUpgradeable {\n    using WadRayMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @dev Cannot burn amount whose normalized value is less than zero.\n     */\n    error InvalidBurnAmount();\n\n    /**\n     * @dev Cannot mint amount whose normalized value is less than zero.\n     */\n    error InvalidMintAmount();\n\n    error InvalidUnderlyingAddress();\n    error InvalidTreasuryAddress();\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event MintToTreasury(address indexed treasury, uint256 amount, uint256 supplyFactor);\n\n    event TreasuryUpdate(address treasury);\n\n    struct RewardModuleStorage {\n        IERC20 underlying;\n        uint8 decimals;\n        // A user's true balance at any point will be the value in this mapping times the supplyFactor\n        string name;\n        string symbol;\n        address treasury;\n        uint256 normalizedTotalSupply; // [WAD]\n        uint256 supplyFactor; // [RAY]\n        mapping(address account => uint256) _normalizedBalances; // [WAD]\n    }\n\n    bytes32 public constant ION = keccak256(\"ION\");\n\n    // keccak256(abi.encode(uint256(keccak256(\"ion.storage.RewardModule\")) - 1)) & ~bytes32(uint256(0xff))\n    // solhint-disable-next-line\n    bytes32 private constant RewardModuleStorageLocation =\n        0xdb3a0d63a7808d7d0422c40bb62354f42bff7602a547c329c1453dbcbeef4900;\n\n    function _getRewardModuleStorage() private pure returns (RewardModuleStorage storage $) {\n        assembly {\n            $.slot := RewardModuleStorageLocation\n        }\n    }\n\n    function _initialize(\n        address _underlying,\n        address _treasury,\n        uint8 decimals_,\n        string memory name_,\n        string memory symbol_\n    )\n        internal\n        onlyInitializing\n    {\n        if (_underlying == address(0)) revert InvalidUnderlyingAddress();\n        if (_treasury == address(0)) revert InvalidTreasuryAddress();\n\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        $.underlying = IERC20(_underlying);\n        $.treasury = _treasury;\n        $.decimals = decimals_;\n        $.name = name_;\n        $.symbol = symbol_;\n        $.supplyFactor = RAY;\n\n        emit TreasuryUpdate(_treasury);\n    }\n\n    /**\n     *\n     * @param user to burn tokens from\n     * @param receiverOfUnderlying to send underlying tokens to\n     * @param amount to burn\n     */\n    function _burn(address user, address receiverOfUnderlying, uint256 amount) internal returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        uint256 _supplyFactor = $.supplyFactor;\n        uint256 amountScaled = amount.rayDivUp(_supplyFactor);\n\n        if (amountScaled == 0) revert InvalidBurnAmount();\n        _burnNormalized(user, amountScaled);\n\n        $.underlying.safeTransfer(receiverOfUnderlying, amount);\n\n        emit Transfer(user, address(0), amount);\n\n        return _supplyFactor;\n    }\n\n    /**\n     *\n     * @param account to decrease balance of\n     * @param amount of normalized tokens to burn\n     */\n    function _burnNormalized(address account, uint256 amount) private {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        if (account == address(0)) revert InvalidSender(address(0));\n\n        uint256 oldAccountBalance = $._normalizedBalances[account];\n        if (oldAccountBalance < amount) revert InsufficientBalance(account, oldAccountBalance, amount);\n        // Underflow impossible\n        unchecked {\n            $._normalizedBalances[account] = oldAccountBalance - amount;\n        }\n\n        $.normalizedTotalSupply -= amount;\n    }\n\n    /**\n     *\n     * @param user to mint tokens to\n     * @param senderOfUnderlying address to transfer underlying tokens from\n     * @param amount of reward tokens to mint\n     */\n    function _mint(address user, address senderOfUnderlying, uint256 amount) internal returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        uint256 _supplyFactor = $.supplyFactor;\n        uint256 amountScaled = amount.rayDivDown(_supplyFactor); // [WAD] * [RAY] / [RAY] = [WAD]\n        if (amountScaled == 0) revert InvalidMintAmount();\n        _mintNormalized(user, amountScaled);\n\n        $.underlying.safeTransferFrom(senderOfUnderlying, address(this), amount);\n\n        emit Transfer(address(0), user, amount);\n\n        return _supplyFactor;\n    }\n\n    /**\n     *\n     * @param account to increase balance of\n     * @param amount of normalized tokens to mint\n     */\n    function _mintNormalized(address account, uint256 amount) private {\n        if (account == address(0)) revert InvalidReceiver(address(0));\n\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        $.normalizedTotalSupply += amount;\n\n        $._normalizedBalances[account] += amount;\n    }\n\n    /**\n     * @dev This function does not perform any rounding checks.\n     * @param amount of tokens to mint to treasury\n     */\n    function _mintToTreasury(uint256 amount) internal {\n        if (amount == 0) return;\n\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        uint256 _supplyFactor = $.supplyFactor;\n        address _treasury = $.treasury;\n\n        // Compared to the normal mint, we don't check for rounding errors.\n        // The amount to mint can easily be very small since it is a fraction of the interest accrued.\n        // In that case, the treasury will experience a (very small) loss, but it\n        // wont cause potentially valid transactions to fail.\n        _mintNormalized(_treasury, amount.rayDivDown(_supplyFactor));\n\n        emit Transfer(address(0), _treasury, amount);\n        emit MintToTreasury(_treasury, amount, _supplyFactor);\n    }\n\n    function _setSupplyFactor(uint256 newSupplyFactor) internal {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        $.supplyFactor = newSupplyFactor;\n    }\n\n    /**\n     * @dev Updates the treasury address\n     * @param newTreasury address of new treasury\n     */\n    function updateTreasury(address newTreasury) external onlyRole(ION) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        $.treasury = newTreasury;\n\n        emit TreasuryUpdate(newTreasury);\n    }\n\n    // --- Getters ---\n\n    /**\n     * @dev Address of underlying asset\n     */\n    function underlying() public view returns (IERC20) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.underlying;\n    }\n\n    /**\n     * @dev Decimals of the position asset\n     */\n    function decimals() public view returns (uint8) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.decimals;\n    }\n\n    /**\n     * @dev Current token balance\n     * @param user to get balance of\n     */\n    function balanceOf(address user) public view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $._normalizedBalances[user].rayMulDown($.supplyFactor);\n    }\n\n    /**\n     * @dev Accounting is done in normalized balances\n     * @param user to get normalized balance of\n     */\n    function normalizedBalanceOf(address user) external view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $._normalizedBalances[user];\n    }\n\n    /**\n     * @dev Name of the position asset\n     */\n    function name() public view returns (string memory) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.name;\n    }\n\n    /**\n     * @dev Symbol of the position asset\n     */\n    function symbol() public view returns (string memory) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.symbol;\n    }\n\n    /**\n     * @dev Current treasury address\n     */\n    function treasury() public view returns (address) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.treasury;\n    }\n\n    /**\n     * @dev Current total supply\n     */\n    function totalSupply() public view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        uint256 _normalizedTotalSupply = $.normalizedTotalSupply;\n\n        if (_normalizedTotalSupply == 0) {\n            return 0;\n        }\n\n        return _normalizedTotalSupply.rayMulDown($.supplyFactor);\n    }\n\n    /**\n     * @dev Current normalized total supply\n     */\n    function normalizedTotalSupply() public view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.normalizedTotalSupply;\n    }\n\n    /**\n     * @dev Current supply factor\n     */\n    function supplyFactor() public view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.supplyFactor;\n    }\n}"
    },
    {
      "filename": "src/reward/RewardModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport { WadRayMath, RAY } from \"src/libraries/math/WadRayMath.sol\";\n\nimport { ContextUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport { AccessControlDefaultAdminRulesUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlDefaultAdminRulesUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title RewardModule\n */\nabstract contract RewardModule is ContextUpgradeable, AccessControlDefaultAdminRulesUpgradeable {\n    using WadRayMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @dev Cannot burn amount whose normalized value is less than zero.\n     */\n    error InvalidBurnAmount();\n\n    /**\n     * @dev Cannot mint amount whose normalized value is less than zero.\n     */\n    error InvalidMintAmount();\n\n    error InvalidUnderlyingAddress();\n    error InvalidTreasuryAddress();\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event MintToTreasury(address indexed treasury, uint256 amount, uint256 supplyFactor);\n\n    event TreasuryUpdate(address treasury);\n\n    struct RewardModuleStorage {\n        IERC20 underlying;\n        uint8 decimals;\n        // A user's true balance at any point will be the value in this mapping times the supplyFactor\n        string name;\n        string symbol;\n        address treasury;\n        uint256 normalizedTotalSupply; // [WAD]\n        uint256 supplyFactor; // [RAY]\n        mapping(address account => uint256) _normalizedBalances; // [WAD]\n    }\n\n    bytes32 public constant ION = keccak256(\"ION\");\n\n    // keccak256(abi.encode(uint256(keccak256(\"ion.storage.RewardModule\")) - 1)) & ~bytes32(uint256(0xff))\n    // solhint-disable-next-line\n    bytes32 private constant RewardModuleStorageLocation =\n        0xdb3a0d63a7808d7d0422c40bb62354f42bff7602a547c329c1453dbcbeef4900;\n\n    function _getRewardModuleStorage() private pure returns (RewardModuleStorage storage $) {\n        assembly {\n            $.slot := RewardModuleStorageLocation\n        }\n    }\n\n    function _initialize(\n        address _underlying,\n        address _treasury,\n        uint8 decimals_,\n        string memory name_,\n        string memory symbol_\n    )\n        internal\n        onlyInitializing\n    {\n        if (_underlying == address(0)) revert InvalidUnderlyingAddress();\n        if (_treasury == address(0)) revert InvalidTreasuryAddress();\n\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        $.underlying = IERC20(_underlying);\n        $.treasury = _treasury;\n        $.decimals = decimals_;\n        $.name = name_;\n        $.symbol = symbol_;\n        $.supplyFactor = RAY;\n\n        emit TreasuryUpdate(_treasury);\n    }\n\n    /**\n     *\n     * @param user to burn tokens from\n     * @param receiverOfUnderlying to send underlying tokens to\n     * @param amount to burn\n     */\n    function _burn(address user, address receiverOfUnderlying, uint256 amount) internal returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        uint256 _supplyFactor = $.supplyFactor;\n        uint256 amountScaled = amount.rayDivUp(_supplyFactor);\n\n        if (amountScaled == 0) revert InvalidBurnAmount();\n        _burnNormalized(user, amountScaled);\n\n        $.underlying.safeTransfer(receiverOfUnderlying, amount);\n\n        emit Transfer(user, address(0), amount);\n\n        return _supplyFactor;\n    }\n\n    /**\n     *\n     * @param account to decrease balance of\n     * @param amount of normalized tokens to burn\n     */\n    function _burnNormalized(address account, uint256 amount) private {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        if (account == address(0)) revert InvalidSender(address(0));\n\n        uint256 oldAccountBalance = $._normalizedBalances[account];\n        if (oldAccountBalance < amount) revert InsufficientBalance(account, oldAccountBalance, amount);\n        // Underflow impossible\n        unchecked {\n            $._normalizedBalances[account] = oldAccountBalance - amount;\n        }\n\n        $.normalizedTotalSupply -= amount;\n    }\n\n    /**\n     *\n     * @param user to mint tokens to\n     * @param senderOfUnderlying address to transfer underlying tokens from\n     * @param amount of reward tokens to mint\n     */\n    function _mint(address user, address senderOfUnderlying, uint256 amount) internal returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        uint256 _supplyFactor = $.supplyFactor;\n        uint256 amountScaled = amount.rayDivDown(_supplyFactor); // [WAD] * [RAY] / [RAY] = [WAD]\n        if (amountScaled == 0) revert InvalidMintAmount();\n        _mintNormalized(user, amountScaled);\n\n        $.underlying.safeTransferFrom(senderOfUnderlying, address(this), amount);\n\n        emit Transfer(address(0), user, amount);\n\n        return _supplyFactor;\n    }\n\n    /**\n     *\n     * @param account to increase balance of\n     * @param amount of normalized tokens to mint\n     */\n    function _mintNormalized(address account, uint256 amount) private {\n        if (account == address(0)) revert InvalidReceiver(address(0));\n\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        $.normalizedTotalSupply += amount;\n\n        $._normalizedBalances[account] += amount;\n    }\n\n    /**\n     * @dev This function does not perform any rounding checks.\n     * @param amount of tokens to mint to treasury\n     */\n    function _mintToTreasury(uint256 amount) internal {\n        if (amount == 0) return;\n\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        uint256 _supplyFactor = $.supplyFactor;\n        address _treasury = $.treasury;\n\n        // Compared to the normal mint, we don't check for rounding errors.\n        // The amount to mint can easily be very small since it is a fraction of the interest accrued.\n        // In that case, the treasury will experience a (very small) loss, but it\n        // wont cause potentially valid transactions to fail.\n        _mintNormalized(_treasury, amount.rayDivDown(_supplyFactor));\n\n        emit Transfer(address(0), _treasury, amount);\n        emit MintToTreasury(_treasury, amount, _supplyFactor);\n    }\n\n    function _setSupplyFactor(uint256 newSupplyFactor) internal {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        $.supplyFactor = newSupplyFactor;\n    }\n\n    /**\n     * @dev Updates the treasury address\n     * @param newTreasury address of new treasury\n     */\n    function updateTreasury(address newTreasury) external onlyRole(ION) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        $.treasury = newTreasury;\n\n        emit TreasuryUpdate(newTreasury);\n    }\n\n    // --- Getters ---\n\n    /**\n     * @dev Address of underlying asset\n     */\n    function underlying() public view returns (IERC20) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.underlying;\n    }\n\n    /**\n     * @dev Decimals of the position asset\n     */\n    function decimals() public view returns (uint8) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.decimals;\n    }\n\n    /**\n     * @dev Current token balance\n     * @param user to get balance of\n     */\n    function balanceOf(address user) public view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $._normalizedBalances[user].rayMulDown($.supplyFactor);\n    }\n\n    /**\n     * @dev Accounting is done in normalized balances\n     * @param user to get normalized balance of\n     */\n    function normalizedBalanceOf(address user) external view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $._normalizedBalances[user];\n    }\n\n    /**\n     * @dev Name of the position asset\n     */\n    function name() public view returns (string memory) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.name;\n    }\n\n    /**\n     * @dev Symbol of the position asset\n     */\n    function symbol() public view returns (string memory) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.symbol;\n    }\n\n    /**\n     * @dev Current treasury address\n     */\n    function treasury() public view returns (address) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.treasury;\n    }\n\n    /**\n     * @dev Current total supply\n     */\n    function totalSupply() public view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        uint256 _normalizedTotalSupply = $.normalizedTotalSupply;\n\n        if (_normalizedTotalSupply == 0) {\n            return 0;\n        }\n\n        return _normalizedTotalSupply.rayMulDown($.supplyFactor);\n    }\n\n    /**\n     * @dev Current normalized total supply\n     */\n    function normalizedTotalSupply() public view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.normalizedTotalSupply;\n    }\n\n    /**\n     * @dev Current supply factor\n     */\n    function supplyFactor() public view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.supplyFactor;\n    }\n}"
    },
    {
      "filename": "src/reward/RewardModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport { WadRayMath, RAY } from \"src/libraries/math/WadRayMath.sol\";\n\nimport { ContextUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport { AccessControlDefaultAdminRulesUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlDefaultAdminRulesUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title RewardModule\n */\nabstract contract RewardModule is ContextUpgradeable, AccessControlDefaultAdminRulesUpgradeable {\n    using WadRayMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @dev Cannot burn amount whose normalized value is less than zero.\n     */\n    error InvalidBurnAmount();\n\n    /**\n     * @dev Cannot mint amount whose normalized value is less than zero.\n     */\n    error InvalidMintAmount();\n\n    error InvalidUnderlyingAddress();\n    error InvalidTreasuryAddress();\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event MintToTreasury(address indexed treasury, uint256 amount, uint256 supplyFactor);\n\n    event TreasuryUpdate(address treasury);\n\n    struct RewardModuleStorage {\n        IERC20 underlying;\n        uint8 decimals;\n        // A user's true balance at any point will be the value in this mapping times the supplyFactor\n        string name;\n        string symbol;\n        address treasury;\n        uint256 normalizedTotalSupply; // [WAD]\n        uint256 supplyFactor; // [RAY]\n        mapping(address account => uint256) _normalizedBalances; // [WAD]\n    }\n\n    bytes32 public constant ION = keccak256(\"ION\");\n\n    // keccak256(abi.encode(uint256(keccak256(\"ion.storage.RewardModule\")) - 1)) & ~bytes32(uint256(0xff))\n    // solhint-disable-next-line\n    bytes32 private constant RewardModuleStorageLocation =\n        0xdb3a0d63a7808d7d0422c40bb62354f42bff7602a547c329c1453dbcbeef4900;\n\n    function _getRewardModuleStorage() private pure returns (RewardModuleStorage storage $) {\n        assembly {\n            $.slot := RewardModuleStorageLocation\n        }\n    }\n\n    function _initialize(\n        address _underlying,\n        address _treasury,\n        uint8 decimals_,\n        string memory name_,\n        string memory symbol_\n    )\n        internal\n        onlyInitializing\n    {\n        if (_underlying == address(0)) revert InvalidUnderlyingAddress();\n        if (_treasury == address(0)) revert InvalidTreasuryAddress();\n\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        $.underlying = IERC20(_underlying);\n        $.treasury = _treasury;\n        $.decimals = decimals_;\n        $.name = name_;\n        $.symbol = symbol_;\n        $.supplyFactor = RAY;\n\n        emit TreasuryUpdate(_treasury);\n    }\n\n    /**\n     *\n     * @param user to burn tokens from\n     * @param receiverOfUnderlying to send underlying tokens to\n     * @param amount to burn\n     */\n    function _burn(address user, address receiverOfUnderlying, uint256 amount) internal returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        uint256 _supplyFactor = $.supplyFactor;\n        uint256 amountScaled = amount.rayDivUp(_supplyFactor);\n\n        if (amountScaled == 0) revert InvalidBurnAmount();\n        _burnNormalized(user, amountScaled);\n\n        $.underlying.safeTransfer(receiverOfUnderlying, amount);\n\n        emit Transfer(user, address(0), amount);\n\n        return _supplyFactor;\n    }\n\n    /**\n     *\n     * @param account to decrease balance of\n     * @param amount of normalized tokens to burn\n     */\n    function _burnNormalized(address account, uint256 amount) private {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        if (account == address(0)) revert InvalidSender(address(0));\n\n        uint256 oldAccountBalance = $._normalizedBalances[account];\n        if (oldAccountBalance < amount) revert InsufficientBalance(account, oldAccountBalance, amount);\n        // Underflow impossible\n        unchecked {\n            $._normalizedBalances[account] = oldAccountBalance - amount;\n        }\n\n        $.normalizedTotalSupply -= amount;\n    }\n\n    /**\n     *\n     * @param user to mint tokens to\n     * @param senderOfUnderlying address to transfer underlying tokens from\n     * @param amount of reward tokens to mint\n     */\n    function _mint(address user, address senderOfUnderlying, uint256 amount) internal returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        uint256 _supplyFactor = $.supplyFactor;\n        uint256 amountScaled = amount.rayDivDown(_supplyFactor); // [WAD] * [RAY] / [RAY] = [WAD]\n        if (amountScaled == 0) revert InvalidMintAmount();\n        _mintNormalized(user, amountScaled);\n\n        $.underlying.safeTransferFrom(senderOfUnderlying, address(this), amount);\n\n        emit Transfer(address(0), user, amount);\n\n        return _supplyFactor;\n    }\n\n    /**\n     *\n     * @param account to increase balance of\n     * @param amount of normalized tokens to mint\n     */\n    function _mintNormalized(address account, uint256 amount) private {\n        if (account == address(0)) revert InvalidReceiver(address(0));\n\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        $.normalizedTotalSupply += amount;\n\n        $._normalizedBalances[account] += amount;\n    }\n\n    /**\n     * @dev This function does not perform any rounding checks.\n     * @param amount of tokens to mint to treasury\n     */\n    function _mintToTreasury(uint256 amount) internal {\n        if (amount == 0) return;\n\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        uint256 _supplyFactor = $.supplyFactor;\n        address _treasury = $.treasury;\n\n        // Compared to the normal mint, we don't check for rounding errors.\n        // The amount to mint can easily be very small since it is a fraction of the interest accrued.\n        // In that case, the treasury will experience a (very small) loss, but it\n        // wont cause potentially valid transactions to fail.\n        _mintNormalized(_treasury, amount.rayDivDown(_supplyFactor));\n\n        emit Transfer(address(0), _treasury, amount);\n        emit MintToTreasury(_treasury, amount, _supplyFactor);\n    }\n\n    function _setSupplyFactor(uint256 newSupplyFactor) internal {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        $.supplyFactor = newSupplyFactor;\n    }\n\n    /**\n     * @dev Updates the treasury address\n     * @param newTreasury address of new treasury\n     */\n    function updateTreasury(address newTreasury) external onlyRole(ION) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        $.treasury = newTreasury;\n\n        emit TreasuryUpdate(newTreasury);\n    }\n\n    // --- Getters ---\n\n    /**\n     * @dev Address of underlying asset\n     */\n    function underlying() public view returns (IERC20) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.underlying;\n    }\n\n    /**\n     * @dev Decimals of the position asset\n     */\n    function decimals() public view returns (uint8) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.decimals;\n    }\n\n    /**\n     * @dev Current token balance\n     * @param user to get balance of\n     */\n    function balanceOf(address user) public view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $._normalizedBalances[user].rayMulDown($.supplyFactor);\n    }\n\n    /**\n     * @dev Accounting is done in normalized balances\n     * @param user to get normalized balance of\n     */\n    function normalizedBalanceOf(address user) external view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $._normalizedBalances[user];\n    }\n\n    /**\n     * @dev Name of the position asset\n     */\n    function name() public view returns (string memory) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.name;\n    }\n\n    /**\n     * @dev Symbol of the position asset\n     */\n    function symbol() public view returns (string memory) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.symbol;\n    }\n\n    /**\n     * @dev Current treasury address\n     */\n    function treasury() public view returns (address) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.treasury;\n    }\n\n    /**\n     * @dev Current total supply\n     */\n    function totalSupply() public view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        uint256 _normalizedTotalSupply = $.normalizedTotalSupply;\n\n        if (_normalizedTotalSupply == 0) {\n            return 0;\n        }\n\n        return _normalizedTotalSupply.rayMulDown($.supplyFactor);\n    }\n\n    /**\n     * @dev Current normalized total supply\n     */\n    function normalizedTotalSupply() public view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.normalizedTotalSupply;\n    }\n\n    /**\n     * @dev Current supply factor\n     */\n    function supplyFactor() public view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.supplyFactor;\n    }\n}"
    },
    {
      "filename": "src/IonPool.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport { Whitelist } from \"src/Whitelist.sol\";\nimport { SpotOracle } from \"src/oracles/spot/SpotOracle.sol\";\nimport { RewardModule } from \"src/reward/RewardModule.sol\";\nimport { InterestRate } from \"src/InterestRate.sol\";\nimport { WadRayMath, RAY } from \"src/libraries/math/WadRayMath.sol\";\nimport { IonPausableUpgradeable } from \"src/admin/IonPausableUpgradeable.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\ncontract IonPool is IonPausableUpgradeable, RewardModule {\n    using SafeERC20 for IERC20;\n    using SafeCast for *;\n    using WadRayMath for *;\n    using Math for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // --- Errors ---\n    error CeilingExceeded(uint256 newDebt, uint256 debtCeiling);\n    error UnsafePositionChange(uint256 newTotalDebtInVault, uint256 collateral, uint256 spot);\n    error UnsafePositionChangeWithoutConsent(uint8 ilkIndex, address user, address unconsentedOperator);\n    error GemTrans"
    }
  ]
}