{
  "Title": "[L-04] Rounding down in \\_exitCollateral() function can cause loss of precision leading to loss of funds for users",
  "Content": "\nThere is 1 instance of this issue:\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/actions/CommonActions.sol#L118\n\nIn the function [_exitCollateral()](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/actions/CommonActions.sol#L118), users can experience loss of funds if the wad amount is smaller than the decimals representation in the denominator.\n\nThe below code snippet is from the CommonActions.sol contract is inherited in the BasicActions.sol contract. This _exitCollateral() function is called when the freeTokenCollateral() function in the BasicActions.sol contract is called. This function does the operation below based on the decimals of the ERC20 token being used. In case the numerator i.e. the _wad amount is smaller than the denominator, the final _weiAmount rounds down to zero. This can lead to loss of funds for the user who tries to exit with his collateral.\n```solidity\nFile: CommonActions.sol\n118:     uint256 _weiAmount = _wad / 10 ** (18 - _decimals);\n119:     __collateralJoin.exit(msg.sender, _weiAmount);\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-opendollar",
  "Code": [
    {
      "filename": "src/contracts/proxies/actions/CommonActions.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\nimport {ICoinJoin} from '@interfaces/utils/ICoinJoin.sol';\nimport {ICollateralJoin} from '@interfaces/utils/ICollateralJoin.sol';\nimport {ICommonActions} from '@interfaces/proxies/actions/ICommonActions.sol';\n\nimport {RAY} from '@libraries/Math.sol';\n\n/**\n * @title  CommonActions\n * @notice This abstract contract defines common actions to be used by the proxy actions contracts\n */\nabstract contract CommonActions is ICommonActions {\n  /// @notice Address of the inheriting contract, used to check if the call is being made through a delegate call\n  // solhint-disable-next-line var-name-mixedcase\n  address internal immutable _THIS = address(this);\n\n  // --- Methods ---\n\n  /// @inheritdoc ICommonActions\n  function joinSystemCoins(address _coinJoin, address _dst, uint256 _wad) external delegateCall {\n    _joinSystemCoins(_coinJoin, _dst, _wad);\n  }\n\n  /// @inheritdoc ICommonActions\n  function exitSystemCoins(address _coinJoin, uint256 _coinsToExit) external delegateCall {\n    _exitSystemCoins(_coinJoin, _coinsToExit);\n  }\n\n  /// @inheritdoc ICommonActions\n  function exitAllSystemCoins(address _coinJoin) external delegateCall {\n    uint256 _coinsToExit = ICoinJoin(_coinJoin).safeEngine().coinBalance(address(this));\n    _exitSystemCoins(_coinJoin, _coinsToExit);\n  }\n\n  /// @inheritdoc ICommonActions\n  function exitCollateral(address _collateralJoin, uint256 _wad) external delegateCall {\n    _exitCollateral(_collateralJoin, _wad);\n  }\n\n  // --- Internal functions ---\n\n  /**\n   * @notice Joins system coins into the safeEngine\n   * @dev    Transfers ERC20 coins from the user to the proxy, then joins them through the CoinJoin contract into the destination SAFE\n   */\n  function _joinSystemCoins(address _coinJoin, address _dst, uint256 _wad) internal {\n    if (_wad == 0) return;\n\n    // NOTE: assumes systemCoin uses 18 decimals\n    IERC20Metadata _systemCoin = ICoinJoin(_coinJoin).systemCoin();\n    // Transfers coins from the user to the proxy\n    _systemCoin.transferFrom(msg.sender, address(this), _wad);\n    // Approves adapter to take the COIN amount\n    _systemCoin.approve(_coinJoin, _wad);\n    // Joins COIN into the safeEngine\n    ICoinJoin(_coinJoin).join(_dst, _wad);\n  }\n\n  /**\n   * @notice Exits system coins from the safeEngine\n   * @dev    Exits system coins through the CoinJoin contract, transferring the ERC20 coins to the user\n   */\n  function _exitSystemCoins(address _coinJoin, uint256 _coinsToExit) internal virtual {\n    if (_coinsToExit == 0) return;\n\n    ICoinJoin __coinJoin = ICoinJoin(_coinJoin);\n    ISAFEEngine __safeEngine = __coinJoin.safeEngine();\n\n    if (!__safeEngine.canModifySAFE(address(this), _coinJoin)) {\n      __safeEngine.approveSAFEModification(_coinJoin);\n    }\n\n    // transfer all coins to msg.sender (proxy shouldn't hold any system coins)\n    __coinJoin.exit(msg.sender, _coinsToExit / RAY);\n  }\n\n  /**\n   * @notice Joins collateral tokens into the safeEngine\n   * @dev    Transfers ERC20 tokens from the user to the proxy, then joins them through the CollateralJoin contract into the destination SAFE\n   */\n  function _joinCollateral(address _collateralJoin, address _safe, uint256 _wad) internal {\n    ICollateralJoin __collateralJoin = ICollateralJoin(_collateralJoin);\n    IERC20Metadata _token = __collateralJoin.collateral();\n\n    // Transforms the token amount into ERC20 native decimals\n    uint256 _decimals = _token.decimals();\n    uint256 _wei = _wad / 10 ** (18 - _decimals);\n    if (_wei == 0) return;\n\n    // Gets token from the user's wallet\n    _token.transferFrom(msg.sender, address(this), _wei);\n    // Approves adapter to take the token amount\n    _token.approve(_collateralJoin, _wei);\n    // Joins token collateral into the safeEngine\n    __collateralJoin.join(_safe, _wei);\n  }\n\n  /**\n   * @notice Exits collateral tokens from the safeEngine\n   * @dev    Exits collateral tokens through the CollateralJoin contract, transferring the ERC20 tokens to the user\n   * @dev    The exited tokens will be rounded down to collateral decimals precision\n   */\n  function _exitCollateral(address _collateralJoin, uint256 _wad) internal {\n    if (_wad == 0) return;\n\n    ICollateralJoin __collateralJoin = ICollateralJoin(_collateralJoin);\n    ISAFEEngine _safeEngine = __collateralJoin.safeEngine();\n\n    if (!_safeEngine.canModifySAFE(address(this), _collateralJoin)) {\n      _safeEngine.approveSAFEModification(_collateralJoin);\n    }\n\n    uint256 _decimals = __collateralJoin.decimals();\n    uint256 _weiAmount = _wad / 10 ** (18 - _decimals);\n    __collateralJoin.exit(msg.sender, _weiAmount);\n  }\n\n  // --- Modifiers ---\n\n  /// @notice Checks if the call is being made through a delegate call\n  modifier delegateCall() {\n    if (address(this) == _THIS) revert OnlyDelegateCalls();\n    _;\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/actions/CommonActions.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\nimport {ICoinJoin} from '@interfaces/utils/ICoinJoin.sol';\nimport {ICollateralJoin} from '@interfaces/utils/ICollateralJoin.sol';\nimport {ICommonActions} from '@interfaces/proxies/actions/ICommonActions.sol';\n\nimport {RAY} from '@libraries/Math.sol';\n\n/**\n * @title  CommonActions\n * @notice This abstract contract defines common actions to be used by the proxy actions contracts\n */\nabstract contract CommonActions is ICommonActions {\n  /// @notice Address of the inheriting contract, used to check if the call is being made through a delegate call\n  // solhint-disable-next-line var-name-mixedcase\n  address internal immutable _THIS = address(this);\n\n  // --- Methods ---\n\n  /// @inheritdoc ICommonActions\n  function joinSystemCoins(address _coinJoin, address _dst, uint256 _wad) external delegateCall {\n    _joinSystemCoins(_coinJoin, _dst, _wad);\n  }\n\n  /// @inheritdoc ICommonActions\n  function exitSystemCoins(address _coinJoin, uint256 _coinsToExit) external delegateCall {\n    _exitSystemCoins(_coinJoin, _coinsToExit);\n  }\n\n  /// @inheritdoc ICommonActions\n  function exitAllSystemCoins(address _coinJoin) external delegateCall {\n    uint256 _coinsToExit = ICoinJoin(_coinJoin).safeEngine().coinBalance(address(this));\n    _exitSystemCoins(_coinJoin, _coinsToExit);\n  }\n\n  /// @inheritdoc ICommonActions\n  function exitCollateral(address _collateralJoin, uint256 _wad) external delegateCall {\n    _exitCollateral(_collateralJoin, _wad);\n  }\n\n  // --- Internal functions ---\n\n  /**\n   * @notice Joins system coins into the safeEngine\n   * @dev    Transfers ERC20 coins from the user to the proxy, then joins them through the CoinJoin contract into the destination SAFE\n   */\n  function _joinSystemCoins(address _coinJoin, address _dst, uint256 _wad) internal {\n    if (_wad == 0) return;\n\n    // NOTE: assumes systemCoin uses 18 decimals\n    IERC20Metadata _systemCoin = ICoinJoin(_coinJoin).systemCoin();\n    // Transfers coins from the user to the proxy\n    _systemCoin.transferFrom(msg.sender, address(this), _wad);\n    // Approves adapter to take the COIN amount\n    _systemCoin.approve(_coinJoin, _wad);\n    // Joins COIN into the safeEngine\n    ICoinJoin(_coinJoin).join(_dst, _wad);\n  }\n\n  /**\n   * @notice Exits system coins from the safeEngine\n   * @dev    Exits system coins through the CoinJoin contract, transferring the ERC20 coins to the user\n   */\n  function _exitSystemCoins(address _coinJoin, uint256 _coinsToExit) internal virtual {\n    if (_coinsToExit == 0) return;\n\n    ICoinJoin __coinJoin = ICoinJoin(_coinJoin);\n    ISAFEEngine __safeEngine = __coinJoin.safeEngine();\n\n    if (!__safeEngine.canModifySAFE(address(this), _coinJoin)) {\n      __safeEngine.approveSAFEModification(_coinJoin);\n    }\n\n    // transfer all coins to msg.sender (proxy shouldn't hold any system coins)\n    __coinJoin.exit(msg.sender, _coinsToExit / RAY);\n  }\n\n  /**\n   * @notice Joins collateral tokens into the safeEngine\n   * @dev    Transfers ERC20 tokens from the user to the proxy, then joins them through the CollateralJoin contract into the destination SAFE\n   */\n  function _joinCollateral(address _collateralJoin, address _safe, uint256 _wad) internal {\n    ICollateralJoin __collateralJoin = ICollateralJoin(_collateralJoin);\n    IERC20Metadata _token = __collateralJoin.collateral();\n\n    // Transforms the token amount into ERC20 native decimals\n    uint256 _decimals = _token.decimals();\n    uint256 _wei = _wad / 10 ** (18 - _decimals);\n    if (_wei == 0) return;\n\n    // Gets token from the user's wallet\n    _token.transferFrom(msg.sender, address(this), _wei);\n    // Approves adapter to take the token amount\n    _token.approve(_collateralJoin, _wei);\n    // Joins token collateral into the safeEngine\n    __collateralJoin.join(_safe, _wei);\n  }\n\n  /**\n   * @notice Exits collateral tokens from the safeEngine\n   * @dev    Exits collateral tokens through the CollateralJoin contract, transferring the ERC20 tokens to the user\n   * @dev    The exited tokens will be rounded down to collateral decimals precision\n   */\n  function _exitCollateral(address _collateralJoin, uint256 _wad) internal {\n    if (_wad == 0) return;\n\n    ICollateralJoin __collateralJoin = ICollateralJoin(_collateralJoin);\n    ISAFEEngine _safeEngine = __collateralJoin.safeEngine();\n\n    if (!_safeEngine.canModifySAFE(address(this), _collateralJoin)) {\n      _safeEngine.approveSAFEModification(_collateralJoin);\n    }\n\n    uint256 _decimals = __collateralJoin.decimals();\n    uint256 _weiAmount = _wad / 10 ** (18 - _decimals);\n    __collateralJoin.exit(msg.sender, _weiAmount);\n  }\n\n  // --- Modifiers ---\n\n  /// @notice Checks if the call is being made through a delegate call\n  modifier delegateCall() {\n    if (address(this) == _THIS) revert OnlyDelegateCalls();\n    _;\n  }\n}"
    }
  ]
}