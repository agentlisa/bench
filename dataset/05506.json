{
  "Title": "[05] `OffChainSignatureValidator.isValidSignature` may revert for division by zero for not started parties",
  "Content": "\nhttps://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/signature-validators/OffChainSignatureValidator.sol#L71\n\nWhenever an `OffChainSignatureValidator` is configured with a non-zero signing threshold for the party (`thresholdBps > 0`), but the party has not started yet (`totalVotingPower == 0`), the following calculation in `isValidSignature` may revert for division by zero:\n\n```Solidity\n        // OffChainSignatureValidator.sol:71\n        if (\n            thresholdBps == 0 ||\n            (signerVotingPowerBps > totalVotingPower &&\n                signerVotingPowerBps / totalVotingPower >= thresholdBps)\n        ) {\n            return IERC1271.isValidSignature.selector;\n        }\n```\n\nConsider re-formulating the operation in a way that would always work:\n\n```diff\n        // OffChainSignatureValidator.sol:71\n        if (\n            thresholdBps == 0 ||\n            (signerVotingPowerBps > totalVotingPower &&\n-               signerVotingPowerBps / totalVotingPower >= thresholdBps)\n+               signerVotingPowerBps >= thresholdBps * totalVotingPower)\n        ) {\n            return IERC1271.isValidSignature.selector;\n        }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-party",
  "Code": [
    {
      "filename": "contracts/signature-validators/OffChainSignatureValidator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport { IERC1271 } from \"openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport { Strings } from \"openzeppelin/contracts/utils/Strings.sol\";\nimport { Party } from \"../party/Party.sol\";\n\n/// @notice Contract that by default validates off-chain signatures for parties\ncontract OffChainSignatureValidator is IERC1271 {\n    error NotMemberOfParty();\n    error InsufficientVotingPower();\n    error MessageHashMismatch();\n\n    /// @notice Event emmitted when signing threshold updated\n    event SigningThresholdBpsSet(\n        Party indexed party,\n        uint96 oldThresholdBps,\n        uint96 newThresholdBps\n    );\n\n    /// @notice Mapping of party to signing threshold BPS\n    mapping(Party party => uint96 thresholdBps) public signingThersholdBps;\n\n    /// @notice Validate an off-chain signature\n    /// @dev This function requires `signature` to be a valid EOA signature from a member in the\n    /// party with sufficient voting power. The raw message must be abi encoded and appended to\n    /// the end of the signature. EIP-712 typed signatures are not supported.\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        assembly {\n            // First word of signature after size contains r\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            // v is one byte which starts after s. type is uint8 so extra data will be ignored\n            v := mload(add(signature, 0x41))\n        }\n\n        bytes memory message;\n        assembly {\n            // Raw message data begins after v. Overwriting part of s and v with size of `message`\n            message := add(signature, 0x41)\n            mstore(message, sub(mload(signature), 0x41))\n        }\n\n        // Recreate the message pre-hash from the raw data\n        bytes memory encodedPacket = abi.encodePacked(\n            \"\\x19Ethereum Signed Message:\\n\",\n            Strings.toString(message.length),\n            message\n        );\n        if (keccak256(encodedPacket) != hash) {\n            revert MessageHashMismatch();\n        }\n\n        Party party = Party(payable(msg.sender));\n        address signer = ecrecover(hash, v, r, s);\n        uint96 signerVotingPowerBps = party.getVotingPowerAt(signer, uint40(block.timestamp)) *\n            10000;\n\n        if (signerVotingPowerBps == 0 && party.balanceOf(signer) == 0) {\n            // Must own a party card or be delegatated voting power\n            revert NotMemberOfParty();\n        }\n\n        uint96 totalVotingPower = party.getGovernanceValues().totalVotingPower;\n        uint96 thresholdBps = signingThersholdBps[party];\n\n        // Either threshold is 0 or signer votes above threshold\n        if (\n            thresholdBps == 0 ||\n            (signerVotingPowerBps > totalVotingPower &&\n                signerVotingPowerBps / totalVotingPower >= thresholdBps)\n        ) {\n            return IERC1271.isValidSignature.selector;\n        }\n\n        revert InsufficientVotingPower();\n    }\n\n    /// @notice Set the signing threshold BPS for the party to validate off-chain signatures\n    /// @param thresholdBps The new threshold BPS\n    function setSigningThresholdBps(uint96 thresholdBps) external {\n        Party party = Party(payable(msg.sender));\n        emit SigningThresholdBpsSet(party, signingThersholdBps[party], thresholdBps);\n        signingThersholdBps[party] = thresholdBps;\n    }\n}"
    }
  ]
}