{
  "Title": "[M03] Undocumented decimal assumptions",
  "Content": "The [`LimitOrderProtocol`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/LimitOrderProtocol.sol) contract inherits the [`ChainlinkCalculator`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol) contract through the [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol) contract. This contract exposes two functions to enable the usage of Chainlink oracles during the [predicates check](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L218) and the lookup of the [maker amount](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L315)/[taker amount](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L326).\n\n\nHowever, the contract makes undocumented assumptions about the number of decimals that the Chainlink oracles should report in, as well as the number of decimals that the function parameters should contain. In certain scenarios, this could lead to unexpected behaviors, including the mis-pricing of assets and the unintentional loss of funds.\n\n\nMore specifically, throughout the contract the implicit assumption is that the Chainlink oracles will report with 18 decimals of precision. However, not [all Chainlink oracles](https://docs.chain.link/docs/ethereum-addresses/) report with this number of decimals. In fact, if the oracle reports a token pair that is in terms of a currency (USD, for instance), it will only have 8 decimals of precision. Since there are no restrictions on *which* oracles can be used, implicit assumptions should not be made about the number of decimals they will report with.\n\n\nRelatedly, there is an implicit assumption that the `amount` parameter for the `ChainlinkCalculator` functions will use 18 decimals, together with the misleading explicit declaration that the [`singlePrice`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol#L21) function [`Calculates price of token relative to ETH scaled by 1e18`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol#L14). In reality, even with an oracle that *does* report with 18 decimals, the return value of the `singlePrice` function would be scaled by the number of decimals of the `amount` parameter, which may not necessarily be 18 decimals.\n\n\nSimilarly, the [`doublePrice`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol#L35) function assumes that two Chainlink oracles will report with the same number of decimals, causing the result of the function to deviate from expectations.\n\n\nConsider explicitly documenting assumptions regarding the number of decimals that parameters and return values should be in terms of. Furthermore, consider either limiting calculations that depend on oracles that break those assumptions, or having the relevant calculations take the actual number of decimals into account.\n\n\n***Update:** Fixed in [pull request #75](https://github.com/1inch/limit-order-protocol/pull/75).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/helpers/ChainlinkCalculator.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v1;\n\nimport \"../interfaces/AggregatorInterface.sol\";\n\n/// @title A helper contract for interactions with https://docs.chain.link\ncontract ChainlinkCalculator {\n    uint256 private constant _SPREAD_DENOMINATOR = 1e9;\n    uint256 private constant _ORACLE_EXPIRATION_TIME = 30 minutes;\n    uint256 private constant _INVERSE_MASK = 1 << 255;\n\n    /// @notice Calculates price of token relative to ETH scaled by 1e18\n    /// @param inverseAndSpread concatenated inverse flag and spread.\n    /// Lowest 254 bits specify spread amount. Spread is scaled by 1e9, i.e. 101% = 1.01e9, 99% = 0.99e9.\n    /// Highest bit is set when oracle price should be inverted,\n    /// e.g. for DAI-ETH oracle, inverse=false means that we request DAI price in ETH\n    /// and inverse=true means that we request ETH price in DAI\n    /// @return Result Token price times amount\n    function singlePrice(AggregatorInterface oracle, uint256 inverseAndSpread, uint256 amount) external view returns(uint256) {\n        // solhint-disable-next-line not-rely-on-time\n        require(oracle.latestTimestamp() + _ORACLE_EXPIRATION_TIME > block.timestamp, \"CC: stale data\");\n        bool inverse = inverseAndSpread & _INVERSE_MASK > 0;\n        uint256 spread = inverseAndSpread & (~_INVERSE_MASK);\n        if (inverse) {\n            return amount * spread * 1e18 / uint256(oracle.latestAnswer()) / _SPREAD_DENOMINATOR;\n        } else {\n            return amount * spread * uint256(oracle.latestAnswer()) / 1e18 / _SPREAD_DENOMINATOR;\n        }\n    }\n\n    /// @notice Calculates price of token A relative to token B. Note that order is important\n    /// @return Result Token A relative price times amount\n    function doublePrice(AggregatorInterface oracle1, AggregatorInterface oracle2, uint256 spread, uint256 amount) external view returns(uint256) {\n        // solhint-disable-next-line not-rely-on-time\n        require(oracle1.latestTimestamp() + _ORACLE_EXPIRATION_TIME > block.timestamp, \"CC: stale data O1\");\n        // solhint-disable-next-line not-rely-on-time\n        require(oracle2.latestTimestamp() + _ORACLE_EXPIRATION_TIME > block.timestamp, \"CC: stale data O2\");\n\n        return amount * spread * uint256(oracle1.latestAnswer()) / uint256(oracle2.latestAnswer()) / _SPREAD_DENOMINATOR;\n    }\n}"
    },
    {
      "filename": "contracts/helpers/ChainlinkCalculator.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma abicoder v1;\n\nimport \"../interfaces/AggregatorInterface.sol\";\n\n/// @title A helper contract for interactions with https://docs.chain.link\ncontract ChainlinkCalculator {\n    uint256 private constant _SPREAD_DENOMINATOR = 1e9;\n    uint256 private constant _ORACLE_EXPIRATION_TIME = 30 minutes;\n    uint256 private constant _INVERSE_MASK = 1 << 255;\n\n    /// @notice Calculates price of token relative to ETH scaled by 1e18\n    /// @param inverseAndSpread concatenated inverse flag and spread.\n    /// Lowest 254 bits specify spread amount. Spread is scaled by 1e9, i.e. 101% = 1.01e9, 99% = 0.99e9.\n    /// Highest bit is set when oracle price should be inverted,\n    /// e.g. for DAI-ETH oracle, inverse=false means that we request DAI price in ETH\n    /// and inverse=true means that we request ETH price in DAI\n    /// @return Result Token price times amount\n    function singlePrice(AggregatorInterface oracle, uint256 inverseAndSpread, uint256 amount) external view returns(uint256) {\n        // solhint-disable-next-line not-rely-on-time\n        require(oracle.latestTimestamp() + _ORACLE_EXPIRATION_TIME > block.timestamp, \"CC: stale data\");\n        bool inverse = inverseAndSpread & _INVERSE_MASK > 0;\n        uint256 spread = inverseAndSpread & (~_INVERSE_MASK);\n        if (inverse) {\n            return amount * spread * 1e18 / uint256(oracle.latestAnswer()) / _SPREAD_DENOMINATOR;\n        } else {\n            return amount * spread * uint256(oracle.latestAnswer()) / 1e18 / _SPREAD_DENOMINATOR;\n        }\n    }\n\n    /// @notice Calculates price of token A relative to token B. Note that order is important\n    /// @return Result Token A relative price times amount\n    function doublePrice(AggregatorInterface oracle1, AggregatorInterface oracle2, uint256 spread, uint256 amount) external view returns(uint256) {\n        // solhint-disable-next-line not-rely-on-time\n        require(oracle1.latestTimestamp() + _ORACLE_EXPIRATION_TIME > block.timestamp, \"CC: stale data O1\");\n        // solhint-disable-next-line not-rely-on-time\n        require(oracle2.latestTimestamp() + _ORACLE_EXPIRATION_TIME > block.timestamp, \"CC: stale data O2\");\n\n        return amount * spread * uint256(oracle1.latestAnswer()) / uint256(oracle2.latestAnswer()) / _SPREAD_DENOMINATOR;\n    }\n}"
    }
  ]
}