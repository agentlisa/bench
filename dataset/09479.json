{
  "Title": "[L-04] Missing checks for `address(0x0)` when assigning values to `address` state variables",
  "Content": "\n1.  File: external/StakedCitadelLocker.sol (line [186](https://github.com/Citadel-DAO/staked-citadel-locker/blob/980088335adf7fdc62aa9a0c2556b37c01605dd4/src/StakedCitadelLocker.sol#L186))\n\n```solidity\n        stakingProxy = _staking;\n```\n\n2.  File: src/lib/SettAccessControl.sol (line [39](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/lib/SettAccessControl.sol#L39))\n\n```solidity\n        strategist = _strategist;\n```\n\n3.  File: src/lib/SettAccessControl.sol (line [46](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/lib/SettAccessControl.sol#L46))\n\n```solidity\n        keeper = _keeper;\n```\n\n4.  File: src/lib/SettAccessControl.sol (line [53](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/lib/SettAccessControl.sol#L53))\n\n```solidity\n        governance = _governance;\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-04-badger-citadel-contest",
  "Code": [
    {
      "filename": "src/StakedCitadelLocker.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/MathUtil.sol\";\nimport \"./interfaces/IStakingProxy.sol\";\nimport \"./interfaces/IRewardStaking.sol\";\nimport \"./interfaces/BoringMath.sol\";\nimport \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/math/MathUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/proxy/Initializable.sol\";\n\n\n/*\nCitadel locking contract\n\nAdapted from CvxLockerV2.sol (https://github.com/convex-eth/platform/blob/4a51cf7e411db27fa8fc2244137013f9fbdebb38/contracts/contracts/CvxLockerV2.sol).\n\nChanges:\n- Upgradeability\n- Removed staking\n*/\ncontract StakedCitadelLocker is Initializable, ReentrancyGuardUpgradeable, OwnableUpgradeable {\n\n    using BoringMath for uint256;\n    using BoringMath224 for uint224;\n    using BoringMath112 for uint112;\n    using BoringMath32 for uint32;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /* ========== STATE VARIABLES ========== */\n\n    struct Reward {\n        bool useBoost;\n        uint40 periodFinish;\n        uint208 rewardRate;\n        uint40 lastUpdateTime;\n        uint208 rewardPerTokenStored;\n    }\n    struct Balances {\n        uint112 locked;\n        uint112 boosted;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint112 boosted;\n        uint32 unlockTime;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Epoch {\n        uint224 supply; //epoch boosted supply\n        uint32 date; //epoch start date\n    }\n\n    //token constants\n    IERC20Upgradeable public stakingToken; // xCTDL token\n\n    //rewards\n    address[] public rewardTokens;\n    mapping(address => Reward) public rewardData;\n\n    // Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400; // 1 day\n\n    // Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 7 * 21; // 21 weeks\n\n    // reward token -> distributor -> is approved to add rewards\n    mapping(address => mapping(address => bool)) public rewardDistributors;\n\n    // user -> reward token -> amount\n    mapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;\n    mapping(address => mapping(address => uint256)) public rewards;\n\n    //supplies and epochs\n    uint256 public lockedSupply;\n    uint256 public boostedSupply;\n    Epoch[] public epochs;\n\n    //mappings for balance data\n    mapping(address => Balances) public balances;\n    mapping(address => LockedBalance[]) public userLocks;\n\n    // ========== Not used ==========\n    //boost\n    address public boostPayment = address(0);\n    uint256 public maximumBoostPayment = 0;\n    uint256 public boostRate = 10000;\n    uint256 public nextMaximumBoostPayment = 0;\n    uint256 public nextBoostRate = 10000;\n    uint256 public constant denominator = 10000;\n    // ==============================\n\n    //staking\n    uint256 public minimumStake = 10000;\n    uint256 public maximumStake = 10000;\n    address public stakingProxy = address(0);\n    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing\n\n    //management\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 4;\n\n    //shutdown\n    bool public isShutdown = false;\n\n    //erc20-like interface\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    function initialize(\n        address _stakingToken,\n        string calldata name,\n        string calldata symbol\n    ) public initializer {\n        require(_stakingToken != address(0)); // dev: _stakingToken address should not be zero\n        stakingToken = IERC20Upgradeable(_stakingToken);\n\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(\n            rewardsDuration\n        );\n        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));\n\n        __Ownable_init();\n        __ReentrancyGuard_init();\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n    function version() public view returns(uint256){\n        return 2;\n    }\n\n    /* ========== ADMIN CONFIGURATION ========== */\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(\n        address _rewardsToken,\n        address _distributor,\n        bool _useBoost\n    ) public onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime == 0);\n        // require(_rewardsToken != address(stakingToken));\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);\n        rewardData[_rewardsToken].useBoost = _useBoost;\n        rewardDistributors[_rewardsToken][_distributor] = true;\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime > 0);\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //Set the staking contract for the underlying cvx\n    function setStakingContract(address _staking) external onlyOwner {\n        require(stakingProxy == address(0), \"!assign\");\n\n        stakingProxy = _staking;\n    }\n\n    //set staking limits. will stake the mean of the two once either ratio is crossed\n    function setStakeLimits(uint256 _minimum, uint256 _maximum) external onlyOwner {\n        require(_minimum <= denominator, \"min range\");\n        require(_maximum <= denominator, \"max range\");\n        require(_minimum <= _maximum, \"min range\");\n        minimumStake = _minimum;\n        maximumStake = _maximum;\n        updateStakeRatio(0);\n    }\n\n    //set boost parameters\n    function setBoost(uint256 _max, uint256 _rate, address _receivingAddress) external onlyOwner {\n        require(_max < 1500, \"over max payment\"); //max 15%\n        require(_rate < 30000, \"over max rate\"); //max 3x\n        require(_receivingAddress != address(0), \"invalid address\"); //must point somewhere valid\n        nextMaximumBoostPayment = _max;\n        nextBoostRate = _rate;\n        boostPayment = _receivingAddress;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {\n        require(_rate <= 500, \"over max rate\"); //max 5% per epoch\n        require(_delay >= 2, \"min delay\"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        isShutdown = true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function _rewardPerToken(address _rewardsToken) internal view returns(uint256) {\n        if (boostedSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n        uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(\n            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish).sub(\n                rewardData[_rewardsToken].lastUpdateTime).mul(\n                rewardData[_rewardsToken].rewardRate).mul(1e18).div(rewardData[_rewardsToken].useBoost ? boostedSupply : lockedSupply)\n        );\n    }\n\n    function _earned(\n        address _user,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns(uint256) {\n        return _balance.mul(\n            _rewardPerToken(_rewardsToken).sub(userRewardPerTokenPaid[_user][_rewardsToken])\n        ).div(1e18).add(rewards[_user][_rewardsToken]);\n    }\n\n    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns(uint256){\n        return MathUpgradeable.min(block.timestamp, _finishTime);\n    }\n\n    function lastTimeRewardApplicable(address _rewardsToken) public view returns(uint256) {\n        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardsToken) external view returns(uint256) {\n        return _rewardPerToken(_rewardsToken);\n    }\n\n    function getRewardForDuration(address _rewardsToken) external view returns(uint256) {\n        return uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);\n    }\n\n    // Address and claimable amount of all reward tokens for the given account\n    function claimableRewards(address _account) external view returns(EarnedData[] memory userRewards) {\n        userRewards = new EarnedData[](rewardTokens.length);\n        Balances storage userBalance = balances[_account];\n        uint256 boostedBal = userBalance.boosted;\n        for (uint256 i = 0; i < userRewards.length; i++) {\n            address token = rewardTokens[i];\n            userRewards[i].token = token;\n            userRewards[i].amount = _earned(_account, token, rewardData[token].useBoost ? boostedBal : userBalance.locked);\n        }\n        return userRewards;\n    }\n\n    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens\n    function rewardWeightOf(address _user) view external returns(uint256 amount) {\n        return balances[_user].boosted;\n    }\n\n    // total token balance of an account, including unlocked but not withdrawn tokens\n    function lockedBalanceOf(address _user) view external returns(uint256 amount) {\n        return balances[_user].locked;\n    }\n\n    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch\n    function balanceOf(address _user) view external returns(uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n\n        //start with current boosted amount\n        amount = balances[_user].boosted;\n\n        uint256 locksLength = locks.length;\n        //remove old records only (will be better gas-wise than adding up)\n        for (uint i = nextUnlockIndex; i < locksLength; i++) {\n            if (locks[i].unlockTime <= block.timestamp) {\n                amount = amount.sub(locks[i].boosted);\n            } else {\n                //stop now as no futher checks are needed\n                break;\n            }\n        }\n\n        //also remove amount locked in the next epoch\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        if (locksLength > 0 && uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) > currentEpoch) {\n            amount = amount.sub(locks[locksLength - 1].boosted);\n        }\n\n        return amount;\n    }\n\n    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch\n    function balanceAtEpochOf(uint256 _epoch, address _user) view external returns(uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //get timestamp of given epoch index\n        uint256 epochTime = epochs[_epoch].date;\n        //get timestamp of first non-inclusive epoch\n        uint256 cutoffEpoch = epochTime.sub(lockDuration);\n\n        //need to add up since the range could be in the middle somewhere\n        //traverse inversely to make more current queries more gas efficient\n        for (uint i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n            //lock epoch must be less or equal to the epoch we're basing from.\n            if (lockEpoch <= epochTime) {\n                if (lockEpoch > cutoffEpoch) {\n                    amount = amount.add(locks[i].boosted);\n                } else {\n                    //stop now as no futher checks matter\n                    break;\n                }\n            }\n        }\n\n        return amount;\n    }\n\n    //return currently locked but not active balance\n    function pendingLockOf(address _user) view external returns(uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        uint256 locksLength = locks.length;\n\n        //return amount if latest lock is in the future\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        if (locksLength > 0 && uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) > currentEpoch) {\n            return locks[locksLength - 1].boosted;\n        }\n\n        return 0;\n    }\n\n    function pendingLockAtEpochOf(uint256 _epoch, address _user) view external returns(uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //get next epoch from the given epoch index\n        uint256 nextEpoch = uint256(epochs[_epoch].date).add(rewardsDuration);\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n            \n            //return the next epoch balance\n            if (lockEpoch == nextEpoch) {\n                return locks[i].boosted;\n            }else if(lockEpoch < nextEpoch){\n                //no need to check anymore\n                break;\n            }\n        }\n\n        return 0;\n    }\n\n    //supply of all properly locked BOOSTED balances at most recent eligible epoch\n    function totalSupply() view external returns(uint256 supply) {\n\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);\n        uint256 epochindex = epochs.length;\n\n        //do not include next epoch's supply\n        if ( uint256(epochs[epochindex - 1].date) > currentEpoch ) {\n            epochindex--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint i = epochindex - 1; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) <= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(e.supply);\n        }\n\n        return supply;\n    }\n\n    //supply of all properly locked BOOSTED balances at the given epoch\n    function totalSupplyAtEpoch(uint256 _epoch) view external returns(uint256 supply) {\n\n        uint256 epochStart = uint256(epochs[_epoch].date).div(rewardsDuration).mul(rewardsDuration);\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint i = _epoch; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) <= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(epochs[i].supply);\n        }\n\n        return supply;\n    }\n\n    //find an epoch index based on timestamp\n    function findEpochId(uint256 _time) view external returns(uint256 epoch) {\n        uint256 max = epochs.length - 1;\n        uint256 min = 0;\n\n        //convert to start point\n        _time = _time.div(rewardsDuration).mul(rewardsDuration);\n\n        for (uint256 i = 0; i < 128; i++) {\n            if (min >= max) break;\n\n            uint256 mid = (min + max + 1) / 2;\n            uint256 midEpochBlock = epochs[mid].date;\n            if(midEpochBlock == _time){\n                //found\n                return mid;\n            }else if (midEpochBlock < _time) {\n                min = mid;\n            } else{\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n\n    // Information on a user's locked balances\n    function lockedBalances(\n        address _user\n    ) view external returns(\n        uint256 total,\n        uint256 unlockable,\n        uint256 locked,\n        LockedBalance[] memory lockData\n    ) {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        uint256 idx;\n        for (uint i = nextUnlockIndex; i < locks.length; i++) {\n            if (locks[i].unlockTime > block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance[](locks.length - i);\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (userBalance.locked, unlockable, locked, lockData);\n    }\n\n    //number of epochs\n    function epochCount() external view returns(uint256) {\n        return epochs.length;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        //create new epoch in the future where new non-active locks will lock to\n        uint256 nextEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration).add(rewardsDuration);\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n\n        //check to add\n        if (epochs[epochindex - 1].date < nextEpoch) {\n            //fill any epoch gaps\n            while(epochs[epochs.length-1].date != nextEpoch){\n                uint256 nextEpochDate = uint256(epochs[epochs.length-1].date).add(rewardsDuration);\n                epochs.push(Epoch({\n                    supply: 0,\n                    date: uint32(nextEpochDate)\n                }));\n            }\n\n            //update boost parameters on a new epoch\n            if(boostRate != nextBoostRate){\n                boostRate = nextBoostRate;\n            }\n            if(maximumBoostPayment != nextMaximumBoostPayment){\n                maximumBoostPayment = nextMaximumBoostPayment;\n            }\n        }\n    }\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(address _account, uint256 _amount, uint256 _spendRatio) external nonReentrant updateReward(_account) {\n\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount, _spendRatio, false);\n    }\n\n    //lock tokens\n    function _lock(address _account, uint256 _amount, uint256 _spendRatio, bool _isRelock) internal {\n        require(_amount > 0, \"Cannot stake 0\");\n        require(_spendRatio <= maximumBoostPayment, \"over max spend\");\n        require(!isShutdown, \"shutdown\");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //calc lock and boosted amount\n        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);\n        uint256 boostRatio = boostRate.mul(_spendRatio).div(maximumBoostPayment==0?1:maximumBoostPayment);\n        uint112 lockAmount = _amount.sub(spendAmount).to112();\n        uint112 boostedAmount = _amount.add(_amount.mul(boostRatio).div(denominator)).to112();\n\n        //add user balances\n        bal.locked = bal.locked.add(lockAmount);\n        bal.boosted = bal.boosted.add(boostedAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(lockAmount);\n        boostedSupply = boostedSupply.add(boostedAmount);\n\n        //add user lock records or add to current\n        uint256 lockEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        //if a fresh lock, add on an extra duration period\n        if(!_isRelock){\n            lockEpoch = lockEpoch.add(rewardsDuration);\n        }\n        uint256 unlockTime = lockEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n\n        //if the latest user lock is smaller than this lock, always just add new entry to the end of the list\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {\n            userLocks[_account].push(LockedBalance({\n                amount: lockAmount,\n                boosted: boostedAmount,\n                unlockTime: uint32(unlockTime)\n            }));\n        } else {\n            //else add to a current lock\n\n            //if latest lock is further in the future, lower index\n            //this can only happen if relocking an expired lock after creating a new lock\n            if(userLocks[_account][idx - 1].unlockTime > unlockTime){\n                idx--;\n            }\n\n            //if idx points to the epoch when same unlock time, update\n            //(this is always true with a normal lock but maybe not with relock)\n            if(userLocks[_account][idx - 1].unlockTime == unlockTime){\n                LockedBalance storage userL = userLocks[_account][idx - 1];\n                userL.amount = userL.amount.add(lockAmount);\n                userL.boosted = userL.boosted.add(boostedAmount);\n            }else{\n                //can only enter here if a relock is made after a lock and there's no lock entry\n                //for the current epoch.\n                //ex a list of locks such as \"[...][older][current*][next]\" but without a \"current\" lock\n                //length - 1 is the next epoch\n                //length - 2 is a past epoch\n                //thus need to insert an entry for current epoch at the 2nd to last entry\n                //we will copy and insert the tail entry(next) and then overwrite length-2 entry\n\n                //reset idx\n                idx = userLocks[_account].length;\n\n                //get current last item\n                LockedBalance storage userL = userLocks[_account][idx - 1];\n\n                //add a copy to end of list\n                userLocks[_account].push(LockedBalance({\n                    amount: userL.amount,\n                    boosted: userL.boosted,\n                    unlockTime: userL.unlockTime\n                }));\n\n                //insert current epoch lock entry by overwriting the entry at length-2\n                userL.amount = lockAmount;\n                userL.boosted = boostedAmount;\n                userL.unlockTime = uint32(unlockTime);\n            }\n        }\n\n        \n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        uint256 eIndex = epochs.length - 1;\n        //if relock, epoch should be current and not next, thus need to decrease index to length-2\n        if(_isRelock){\n            eIndex--;\n        }\n        Epoch storage e = epochs[eIndex];\n        e.supply = e.supply.add(uint224(boostedAmount));\n\n        //send boost payment\n        if (spendAmount > 0) {\n            stakingToken.safeTransfer(boostPayment, spendAmount);\n        }\n\n        emit Staked(_account, lockEpoch, _amount, lockAmount, boostedAmount);\n    }\n\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(address _account, bool _relock, uint256 _spendRatio, address _withdrawTo, address _rewardAddress, uint256 _checkDelay) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint112 boostedAmount;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n        \n        if (isShutdown || locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n            boostedAmount = userBalance.boosted;\n\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay > 0) {\n                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);\n                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);\n                uint256 rRate = MathUtil.min(kickRewardPerEpoch.mul(epochsover+1), denominator);\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);\n            }\n        } else {\n\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint i = nextUnlockIndex; i < length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay)) break;\n\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n                boostedAmount = boostedAmount.add(locks[i].boosted);\n\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay > 0) {\n                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);\n                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);\n                    uint256 rRate = MathUtil.min(kickRewardPerEpoch.mul(epochsover+1), denominator);\n                    reward = reward.add( uint256(locks[i].amount).mul(rRate).div(denominator));\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked > 0, \"no exp locks\");\n\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        userBalance.boosted = userBalance.boosted.sub(boostedAmount);\n        lockedSupply = lockedSupply.sub(locked);\n        boostedSupply = boostedSupply.sub(boostedAmount);\n\n        emit Withdrawn(_account, locked, _relock);\n\n        //send process incentive\n        if (reward > 0) {\n            //if theres a reward(kicked), it will always be a withdraw only\n            //preallocate enough cvx from stake contract to pay for both reward and withdraw\n            allocateCVXForTransfer(uint256(locked));\n\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n            \n            //transfer reward\n            transferCVX(_rewardAddress, reward, false);\n\n            emit KickReward(_rewardAddress, _account, reward);\n        }else if(_spendRatio > 0){\n            //preallocate enough cvx to transfer the boost cost\n            allocateCVXForTransfer( uint256(locked).mul(_spendRatio).div(denominator) );\n        }\n\n        //relock or return to user\n        if (_relock) {\n            _lock(_withdrawTo, locked, _spendRatio, true);\n        } else {\n            transferCVX(_withdrawTo, locked, true);\n        }\n    }\n\n    // withdraw expired locks to a different address\n    function withdrawExpiredLocksTo(address _withdrawTo) external nonReentrant {\n        _processExpiredLocks(msg.sender, false, 0, _withdrawTo, msg.sender, 0);\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);\n    }\n\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of 'kickRewardEpochDelay'\n        _processExpiredLocks(_account, false, 0, _account, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));\n    }\n\n    //pull required amount of cvx from staking for an upcoming transfer\n    // dev: no-op\n    function allocateCVXForTransfer(uint256 _amount) internal{\n        uint256 balance = stakingToken.balanceOf(address(this));\n    }\n\n    //transfer helper: pull enough from staking, transfer, updating staking ratio\n    function transferCVX(address _account, uint256 _amount, bool _updateStake) internal {\n        //allocate enough cvx from staking for the transfer\n        allocateCVXForTransfer(_amount);\n        //transfer\n        stakingToken.safeTransfer(_account, _amount);\n    }\n\n    //calculate how much cvx should be staked. update if needed\n    function updateStakeRatio(uint256 _offset) internal {\n        if (isShutdown) return;\n\n        //get balances\n        uint256 local = stakingToken.balanceOf(address(this));\n        uint256 staked = IStakingProxy(stakingProxy).getBalance();\n        uint256 total = local.add(staked);\n        \n        if(total == 0) return;\n\n        //current staked ratio\n        uint256 ratio = staked.mul(denominator).div(total);\n        //mean will be where we reset to if unbalanced\n        uint256 mean = maximumStake.add(minimumStake).div(2);\n        uint256 max = maximumStake.add(_offset);\n        uint256 min = MathUpgradeable.min(minimumStake, minimumStake - _offset);\n        if (ratio > max) {\n            //remove\n            uint256 remove = staked.sub(total.mul(mean).div(denominator));\n            IStakingProxy(stakingProxy).withdraw(remove);\n        } else if (ratio < min) {\n            //add\n            uint256 increase = total.mul(mean).div(denominator).sub(staked);\n            stakingToken.safeTransfer(stakingProxy, increase);\n            IStakingProxy(stakingProxy).stake();\n        }\n    }\n\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {\n        for (uint i; i < rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = rewards[_account][_rewardsToken];\n            if (reward > 0) {\n                rewards[_account][_rewardsToken] = 0;\n                IERC20Upgradeable(_rewardsToken).safeTransfer(_account, reward);\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n\n    // claim all pending rewards\n    function getReward(address _account) external{\n        getReward(_account,false);\n    }\n\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function _notifyReward(address _rewardsToken, uint256 _reward) internal {\n        Reward storage rdata = rewardData[_rewardsToken];\n\n        if (block.timestamp >= rdata.periodFinish) {\n            rdata.rewardRate = _reward.div(rewardsDuration).to208();\n        } else {\n            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);\n            uint256 leftover = remaining.mul(rdata.rewardRate);\n            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to208();\n        }\n\n        rdata.lastUpdateTime = block.timestamp.to40();\n        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();\n    }\n\n    function notifyRewardAmount(address _rewardsToken, uint256 _reward) external updateReward(address(0)) {\n        require(rewardDistributors[_rewardsToken][msg.sender]);\n        require(_reward > 0, \"No reward\");\n\n        _notifyReward(_rewardsToken, _reward);\n\n        // handle the transfer of reward tokens via `transferFrom` to reduce the number\n        // of transactions required and ensure correctness of the _reward amount\n        IERC20Upgradeable(_rewardsToken).safeTransferFrom(msg.sender, address(this), _reward);\n        \n        emit RewardAdded(_rewardsToken, _reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\n        require(_tokenAddress != address(stakingToken), \"Cannot withdraw staking token\");\n        require(rewardData[_tokenAddress].lastUpdateTime == 0, \"Cannot withdraw reward token\");\n        IERC20Upgradeable(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmo"
    }
  ]
}