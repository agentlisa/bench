{
  "Title": "[G-05] Unchecked when clearly safe to do so",
  "Content": "\nUsing `unchecked` blocks saves just a tiny bit of gas, but in instances where its clearly safe already it's possible to avoid this unnecessary check.\n\nIt's becoming a common pattern to use in `for` loops such as [this one in `CidNFT`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L150) where you could consider using:\n\n```solidity\nfor (uint256 i = 0; i < _addList.length; ) {\n    // existing logic\n    unchecked {\n        ++i;\n    }\n}\n```\n\nIn `CidNFT` when calculating fees the math is using a constant, so `cidFee` is always less than `subprotocolFee` making the subtraction always safe when calculating [`subprotocolFee - cidFee`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L193).\n\nIn `CidNFT` [`arrayLength - 1`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L279-L280) is guaranteed to be safe since there is a check [`if (arrayPosition == 0) revert...`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L275) above which handles the potential underflow scenario already.\n\n**[OpenCoreCH (Canto Identity) commented](https://github.com/code-423n4/2023-01-canto-identity-findings/issues/76#issuecomment-1426259866):**\n > This was the most helpful report for me personally. The other reports often contained some generic recommendations that do not directly apply to the protocol (ERC721A instead of ERC721 which only helps with batch minting, changing uint96 which would use an additional storage slot in a struct, marking a string as immutable which is not possible, etc...). This report contains some nice refactoring suggestions that consider the context of the protocol.\n\n\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-canto-identity-protocol-contest",
  "Code": [
    {
      "filename": "src/CidNFT.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"./SubprotocolRegistry.sol\";\n\n/// @title Canto Identity Protocol NFT\n/// @notice CID NFTs are at the heart of the CID protocol. All key/values of subprotocols are associated with them.\ncontract CidNFT is ERC721, ERC721TokenReceiver {\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Fee (in BPS) that is charged for every mint (as a percentage of the mint fee). Fixed at 10%.\n    uint256 public constant CID_FEE_BPS = 1_000;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Wallet that receives CID fees\n    address public immutable cidFeeWallet;\n\n    /// @notice Reference to the NOTE TOKEN\n    ERC20 public immutable note;\n\n    /// @notice Reference to the subprotocol registry\n    SubprotocolRegistry public immutable subprotocolRegistry;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Base URI of the NFT\n    string public baseURI;\n\n    /// @notice Array of uint256 values (NFT IDs) with additional position information NFT ID => (array pos. + 1)\n    struct IndexedArray {\n        uint256[] values;\n        mapping(uint256 => uint256) positions;\n    }\n\n    /// @notice Data that is associated with a CID NFT -> subprotocol combination\n    struct SubprotocolData {\n        /// @notice Mapping for ordered type\n        mapping(uint256 => uint256) ordered;\n        /// @notice Value for primary type\n        uint256 primary;\n        /// @notice List for active type\n        IndexedArray active;\n    }\n\n    /// @notice The different types of associations between CID NFTs and subprotocol NFTs\n    enum AssociationType {\n        /// @notice key => NFT mapping\n        ORDERED,\n        /// @notice Zero or one NFT\n        PRIMARY,\n        /// @notice List of NFTs\n        ACTIVE\n    }\n\n    /// @notice Counter of the minted NFTs\n    /// @dev Used to assign a new unique ID. The first ID that is assigned is 1, ID 0 is never minted.\n    uint256 public numMinted;\n\n    /// @notice Stores the references to subprotocol NFTs. Mapping nftID => subprotocol name => subprotocol data\n    mapping(uint256 => mapping(string => SubprotocolData)) internal cidData;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event OrderedDataAdded(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 indexed key,\n        uint256 subprotocolNFTID\n    );\n    event PrimaryDataAdded(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n    event ActiveDataAdded(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 subprotocolNFTID,\n        uint256 arrayIndex\n    );\n    event OrderedDataRemoved(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 indexed key,\n        uint256 subprotocolNFTID\n    );\n    event PrimaryDataRemoved(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n    event ActiveDataRemoved(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error AddCallAfterMintingFailed(uint256 index);\n    error SubprotocolDoesNotExist(string subprotocolName);\n    error NFTIDZeroDisallowedForSubprotocols();\n    error AssociationTypeNotSupportedForSubprotocol(AssociationType associationType, string subprotocolName);\n    error NotAuthorizedForCIDNFT(address caller, uint256 cidNFTID, address cidNFTOwner);\n    error NotAuthorizedForSubprotocolNFT(address caller, uint256 subprotocolNFTID);\n    error ActiveArrayAlreadyContainsID(uint256 cidNFTID, string subprotocolName, uint256 nftIDToAdd);\n    error OrderedValueNotSet(uint256 cidNFTID, string subprotocolName, uint256 key);\n    error PrimaryValueNotSet(uint256 cidNFTID, string subprotocolName);\n    error ActiveArrayDoesNotContainID(uint256 cidNFTID, string subprotocolName, uint256 nftIDToRemove);\n\n    /// @notice Sets the name, symbol, baseURI, and the address of the auction factory\n    /// @param _name Name of the NFT\n    /// @param _symbol Symbol of the NFT\n    /// @param _baseURI NFT base URI. {id}.json is appended to this URI\n    /// @param _cidFeeWallet Address of the wallet that receives the fees\n    /// @param _noteContract Address of the $NOTE contract\n    /// @param _subprotocolRegistry Address of the subprotocol registry\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _baseURI,\n        address _cidFeeWallet,\n        address _noteContract,\n        address _subprotocolRegistry\n    ) ERC721(_name, _symbol) {\n        baseURI = _baseURI;\n        cidFeeWallet = _cidFeeWallet;\n        note = ERC20(_noteContract);\n        subprotocolRegistry = SubprotocolRegistry(_subprotocolRegistry);\n    }\n\n    /// @notice Get the token URI for the provided ID\n    /// @param _id ID to retrieve the URI for\n    /// @return tokenURI The URI of the queried token (path to a JSON file)\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (ownerOf[_id] == address(0))\n            // According to ERC721, this revert for non-existing tokens is required\n            revert TokenNotMinted(_id);\n        return string(abi.encodePacked(baseURI, _id, \".json\"));\n    }\n\n    /// @notice Mint a new CID NFT\n    /// @dev An address can mint multiple CID NFTs, but it can only set one as associated with it in the AddressRegistry\n    /// @param _addList An optional list of encoded parameters for add to add subprotocol NFTs directly after minting.\n    /// The parameters should not include the function selector itself, the function select for add is always prepended.\n    function mint(bytes[] calldata _addList) external {\n        _mint(msg.sender, ++numMinted); // We do not use _safeMint here on purpose. If a contract calls this method, he expects to get an NFT back\n        bytes4 addSelector = this.add.selector;\n        for (uint256 i = 0; i < _addList.length; ++i) {\n            (\n                bool success, /*bytes memory result*/\n\n            ) = address(this).delegatecall(abi.encodePacked(addSelector, _addList[i]));\n            if (!success) revert AddCallAfterMintingFailed(i);\n        }\n    }\n\n    /// @notice Add a new entry for the given subprotocol to the provided CID NFT\n    /// @param _cidNFTID ID of the CID NFT to add the data to\n    /// @param _subprotocolName Name of the subprotocol where the data will be added. Has to exist.\n    /// @param _key Key to set. This value is only relevant for the AssociationType ORDERED (where a mapping int => nft ID is stored)\n    /// @param _nftIDToAdd The ID of the NFT to add\n    /// @param _type Association type (see AssociationType struct) to use for this data\n    function add(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _key,\n        uint256 _nftIDToAdd,\n        AssociationType _type\n    ) external {\n        SubprotocolRegistry.SubprotocolData memory subprotocolData = subprotocolRegistry.getSubprotocol(\n            _subprotocolName\n        );\n        address subprotocolOwner = subprotocolData.owner;\n        if (subprotocolOwner == address(0)) revert SubprotocolDoesNotExist(_subprotocolName);\n        address cidNFTOwner = ownerOf[_cidNFTID];\n        if (\n            cidNFTOwner != msg.sender &&\n            getApproved[_cidNFTID] != msg.sender &&\n            !isApprovedForAll[cidNFTOwner][msg.sender]\n        ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);\n        if (_nftIDToAdd == 0) revert NFTIDZeroDisallowedForSubprotocols(); // ID 0 is disallowed in subprotocols\n\n        // The CID Protocol safeguards the NFTs of subprotocols. Note that these NFTs are usually pointers to other data / NFTs (e.g., to an image NFT for profile pictures)\n        ERC721 nftToAdd = ERC721(subprotocolData.nftAddress);\n        nftToAdd.safeTransferFrom(msg.sender, address(this), _nftIDToAdd);\n        // Charge fee (subprotocol & CID fee) if configured\n        uint96 subprotocolFee = subprotocolData.fee;\n        if (subprotocolFee != 0) {\n            uint256 cidFee = (subprotocolFee * CID_FEE_BPS) / 10_000;\n            SafeTransferLib.safeTransferFrom(note, msg.sender, cidFeeWallet, cidFee);\n            SafeTransferLib.safeTransferFrom(note, msg.sender, subprotocolOwner, subprotocolFee - cidFee);\n        }\n        if (_type == AssociationType.ORDERED) {\n            if (!subprotocolData.ordered) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            if (cidData[_cidNFTID][_subprotocolName].ordered[_key] != 0) {\n                // Remove to ensure that user gets NFT back\n                remove(_cidNFTID, _subprotocolName, _key, 0, _type);\n            }\n            cidData[_cidNFTID][_subprotocolName].ordered[_key] = _nftIDToAdd;\n            emit OrderedDataAdded(_cidNFTID, _subprotocolName, _key, _nftIDToAdd);\n        } else if (_type == AssociationType.PRIMARY) {\n            if (!subprotocolData.primary) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            if (cidData[_cidNFTID][_subprotocolName].primary != 0) {\n                // Remove to ensure that user gets NFT back\n                remove(_cidNFTID, _subprotocolName, 0, 0, _type);\n            }\n            cidData[_cidNFTID][_subprotocolName].primary = _nftIDToAdd;\n            emit PrimaryDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd);\n        } else if (_type == AssociationType.ACTIVE) {\n            if (!subprotocolData.active) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            IndexedArray storage activeData = cidData[_cidNFTID][_subprotocolName].active;\n            uint256 lengthBeforeAddition = activeData.values.length;\n            if (lengthBeforeAddition == 0) {\n                uint256[] memory nftIDsToAdd = new uint256[](1);\n                nftIDsToAdd[0] = _nftIDToAdd;\n                activeData.values = nftIDsToAdd;\n                activeData.positions[_nftIDToAdd] = 1; // Array index + 1\n            } else {\n                // Check for duplicates\n                if (activeData.positions[_nftIDToAdd] != 0)\n                    revert ActiveArrayAlreadyContainsID(_cidNFTID, _subprotocolName, _nftIDToAdd);\n                activeData.values.push(_nftIDToAdd);\n                activeData.positions[_nftIDToAdd] = lengthBeforeAddition + 1;\n            }\n            emit ActiveDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd, lengthBeforeAddition);\n        }\n    }\n\n    /// @notice Remove / unset a key for the given CID NFT and subprotocol\n    /// @param _cidNFTID ID of the CID NFT to remove the data from\n    /// @param _subprotocolName Name of the subprotocol where the data will be removed. Has to exist.\n    /// @param _key Key to unset. This value is only relevant for the AssociationType ORDERED\n    /// @param _nftIDToRemove The ID of the NFT to remove. Only needed for the AssociationType ACTIVE\n    /// @param _type Association type (see AssociationType struct) to remove this data from\n    function remove(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _key,\n        uint256 _nftIDToRemove,\n        AssociationType _type\n    ) public {\n        SubprotocolRegistry.SubprotocolData memory subprotocolData = subprotocolRegistry.getSubprotocol(\n            _subprotocolName\n        );\n        address subprotocolOwner = subprotocolData.owner;\n        if (subprotocolOwner == address(0)) revert SubprotocolDoesNotExist(_subprotocolName);\n        address cidNFTOwner = ownerOf[_cidNFTID];\n        if (\n            cidNFTOwner != msg.sender &&\n            getApproved[_cidNFTID] != msg.sender &&\n            !isApprovedForAll[cidNFTOwner][msg.sender]\n        ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);\n\n        ERC721 nftToRemove = ERC721(subprotocolData.nftAddress);\n        if (_type == AssociationType.ORDERED) {\n            // We do not have to check if ordered is supported by the subprotocol. If not, the value will not be unset (which is checked below)\n            uint256 currNFTID = cidData[_cidNFTID][_subprotocolName].ordered[_key];\n            if (currNFTID == 0)\n                // This check is technically not necessary (because the NFT transfer would fail), but we include it to have more meaningful errors\n                revert OrderedValueNotSet(_cidNFTID, _subprotocolName, _key);\n            delete cidData[_cidNFTID][_subprotocolName].ordered[_key];\n            nftToRemove.safeTransferFrom(address(this), msg.sender, currNFTID);\n            emit OrderedDataRemoved(_cidNFTID, _subprotocolName, _key, _nftIDToRemove);\n        } else if (_type == AssociationType.PRIMARY) {\n            uint256 currNFTID = cidData[_cidNFTID][_subprotocolName].primary;\n            if (currNFTID == 0) revert PrimaryValueNotSet(_cidNFTID, _subprotocolName);\n            delete cidData[_cidNFTID][_subprotocolName].primary;\n            nftToRemove.safeTransferFrom(address(this), msg.sender, currNFTID);\n            emit PrimaryDataRemoved(_cidNFTID, _subprotocolName, _nftIDToRemove);\n        } else if (_type == AssociationType.ACTIVE) {\n            IndexedArray storage activeData = cidData[_cidNFTID][_subprotocolName].active;\n            uint256 arrayPosition = activeData.positions[_nftIDToRemove]; // Index + 1, 0 if non-existant\n            if (arrayPosition == 0) revert ActiveArrayDoesNotContainID(_cidNFTID, _subprotocolName, _nftIDToRemove);\n            uint256 arrayLength = activeData.values.length;\n            // Swap only necessary if not already the last element\n            if (arrayPosition != arrayLength) {\n                uint256 befSwapLastNFTID = activeData.values[arrayLength - 1];\n                activeData.values[arrayPosition - 1] = befSwapLastNFTID;\n                activeData.positions[befSwapLastNFTID] = arrayPosition;\n            }\n            activeData.values.pop();\n            activeData.positions[_nftIDToRemove] = 0;\n            nftToRemove.safeTransferFrom(address(this), msg.sender, _nftIDToRemove);\n            emit ActiveDataRemoved(_cidNFTID, _subprotocolName, _nftIDToRemove);\n        }\n    }\n\n    /// @notice Get the ordered data that is associated with a CID NFT / Subprotocol\n    /// @param _cidNFTID ID of the CID NFT to query\n    /// @param _subprotocolName Name of the subprotocol to query\n    /// @param _key Key to query\n    /// @return subprotocolNFTID The ID of the NFT at the queried key. 0 if it does not exist\n    function getOrderedData(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _key\n    ) external view returns (uint256 subprotocolNFTID) {\n        subprotocolNFTID = cidData[_cidNFTID][_subprotocolName].ordered[_key];\n    }\n\n    /// @notice Get the primary data that is associated with a CID NFT / Subprotocol\n    /// @param _cidNFTID ID of the CID NFT to query\n    /// @param _subprotocolName Name of the subprotocol to query\n    /// @return subprotocolNFTID The ID of the primary NFT at the queried subprotocl / CID NFT. 0 if it does not exist\n    function getPrimaryData(uint256 _cidNFTID, string calldata _subprotocolName)\n        external\n        view\n        returns (uint256 subprotocolNFTID)\n    {\n        subprotocolNFTID = cidData[_cidNFTID][_subprotocolName].primary;\n    }\n\n    /// @notice Get the active data list that is associated with a CID NFT / Subprotocol\n    /// @param _cidNFTID ID of the CID NFT to query\n    /// @param _subprotocolName Name of the subprotocol to query\n    /// @return subprotocolNFTIDs The ID of the primary NFT at the queried subprotocl / CID NFT. 0 if it does not exist\n    function getActiveData(uint256 _cidNFTID, string calldata _subprotocolName)\n        external\n        view\n        returns (uint256[] memory subprotocolNFTIDs)\n    {\n        subprotocolNFTIDs = cidData[_cidNFTID][_subprotocolName].active.values;\n    }\n\n    /// @notice Check if a provided NFT ID is included in the active data list that is associated with a CID NFT / Subprotocol\n    /// @param _cidNFTID ID of the CID NFT to query\n    /// @param _subprotocolName Name of the subprotocol to query\n    /// @return nftIncluded True if the NFT ID is in the list\n    function activeDataIncludesNFT(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _nftIDToCheck\n    ) external view returns (bool nftIncluded) {\n        nftIncluded = cidData[_cidNFTID][_subprotocolName].active.positions[_nftIDToCheck] != 0;\n    }\n\n    function onERC721Received(\n        address, /*operator*/\n        address, /*from*/\n        uint256, /*id*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}"
    },
    {
      "filename": "src/CidNFT.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"./SubprotocolRegistry.sol\";\n\n/// @title Canto Identity Protocol NFT\n/// @notice CID NFTs are at the heart of the CID protocol. All key/values of subprotocols are associated with them.\ncontract CidNFT is ERC721, ERC721TokenReceiver {\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Fee (in BPS) that is charged for every mint (as a percentage of the mint fee). Fixed at 10%.\n    uint256 public constant CID_FEE_BPS = 1_000;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Wallet that receives CID fees\n    address public immutable cidFeeWallet;\n\n    /// @notice Reference to the NOTE TOKEN\n    ERC20 public immutable note;\n\n    /// @notice Reference to the subprotocol registry\n    SubprotocolRegistry public immutable subprotocolRegistry;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Base URI of the NFT\n    string public baseURI;\n\n    /// @notice Array of uint256 values (NFT IDs) with additional position information NFT ID => (array pos. + 1)\n    struct IndexedArray {\n        uint256[] values;\n        mapping(uint256 => uint256) positions;\n    }\n\n    /// @notice Data that is associated with a CID NFT -> subprotocol combination\n    struct SubprotocolData {\n        /// @notice Mapping for ordered type\n        mapping(uint256 => uint256) ordered;\n        /// @notice Value for primary type\n        uint256 primary;\n        /// @notice List for active type\n        IndexedArray active;\n    }\n\n    /// @notice The different types of associations between CID NFTs and subprotocol NFTs\n    enum AssociationType {\n        /// @notice key => NFT mapping\n        ORDERED,\n        /// @notice Zero or one NFT\n        PRIMARY,\n        /// @notice List of NFTs\n        ACTIVE\n    }\n\n    /// @notice Counter of the minted NFTs\n    /// @dev Used to assign a new unique ID. The first ID that is assigned is 1, ID 0 is never minted.\n    uint256 public numMinted;\n\n    /// @notice Stores the references to subprotocol NFTs. Mapping nftID => subprotocol name => subprotocol data\n    mapping(uint256 => mapping(string => SubprotocolData)) internal cidData;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event OrderedDataAdded(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 indexed key,\n        uint256 subprotocolNFTID\n    );\n    event PrimaryDataAdded(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n    event ActiveDataAdded(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 subprotocolNFTID,\n        uint256 arrayIndex\n    );\n    event OrderedDataRemoved(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 indexed key,\n        uint256 subprotocolNFTID\n    );\n    event PrimaryDataRemoved(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n    event ActiveDataRemoved(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error AddCallAfterMintingFailed(uint256 index);\n    error SubprotocolDoesNotExist(string subprotocolName);\n    error NFTIDZeroDisallowedForSubprotocols();\n    error AssociationTypeNotSupportedForSubprotocol(AssociationType associationType, string subprotocolName);\n    error NotAuthorizedForCIDNFT(address caller, uint256 cidNFTID, address cidNFTOwner);\n    error NotAuthorizedForSubprotocolNFT(address caller, uint256 subprotocolNFTID);\n    error ActiveArrayAlreadyContainsID(uint256 cidNFTID, string subprotocolName, uint256 nftIDToAdd);\n    error OrderedValueNotSet(uint256 cidNFTID, string subprotocolName, uint256 key);\n    error PrimaryValueNotSet(uint256 cidNFTID, string subprotocolName);\n    error ActiveArrayDoesNotContainID(uint256 cidNFTID, string subprotocolName, uint256 nftIDToRemove);\n\n    /// @notice Sets the name, symbol, baseURI, and the address of the auction factory\n    /// @param _name Name of the NFT\n    /// @param _symbol Symbol of the NFT\n    /// @param _baseURI NFT base URI. {id}.json is appended to this URI\n    /// @param _cidFeeWallet Address of the wallet that receives the fees\n    /// @param _noteContract Address of the $NOTE contract\n    /// @param _subprotocolRegistry Address of the subprotocol registry\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _baseURI,\n        address _cidFeeWallet,\n        address _noteContract,\n        address _subprotocolRegistry\n    ) ERC721(_name, _symbol) {\n        baseURI = _baseURI;\n        cidFeeWallet = _cidFeeWallet;\n        note = ERC20(_noteContract);\n        subprotocolRegistry = SubprotocolRegistry(_subprotocolRegistry);\n    }\n\n    /// @notice Get the token URI for the provided ID\n    /// @param _id ID to retrieve the URI for\n    /// @return tokenURI The URI of the queried token (path to a JSON file)\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (ownerOf[_id] == address(0))\n            // According to ERC721, this revert for non-existing tokens is required\n            revert TokenNotMinted(_id);\n        return string(abi.encodePacked(baseURI, _id, \".json\"));\n    }\n\n    /// @notice Mint a new CID NFT\n    /// @dev An address can mint multiple CID NFTs, but it can only set one as associated with it in the AddressRegistry\n    /// @param _addList An optional list of encoded parameters for add to add subprotocol NFTs directly after minting.\n    /// The parameters should not include the function selector itself, the function select for add is always prepended.\n    function mint(bytes[] calldata _addList) external {\n        _mint(msg.sender, ++numMinted); // We do not use _safeMint here on purpose. If a contract calls this method, he expects to get an NFT back\n        bytes4 addSelector = this.add.selector;\n        for (uint256 i = 0; i < _addList.length; ++i) {\n            (\n                bool success, /*bytes memory result*/\n\n            ) = address(this).delegatecall(abi.encodePacked(addSelector, _addList[i]));\n            if (!success) revert AddCallAfterMintingFailed(i);\n        }\n    }\n\n    /// @notice Add a new entry for the given subprotocol to the provided CID NFT\n    /// @param _cidNFTID ID of the CID NFT to add the data to\n    /// @param _subprotocolName Name of the subprotocol where the data will be added. Has to exist.\n    /// @param _key Key to set. This value is only relevant for the AssociationType ORDERED (where a mapping int => nft ID is stored)\n    /// @param _nftIDToAdd The ID of the NFT to add\n    /// @param _type Association type (see AssociationType struct) to use for this data\n    function add(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _key,\n        uint256 _nftIDToAdd,\n        AssociationType _type\n    ) external {\n        SubprotocolRegistry.SubprotocolData memory subprotocolData = subprotocolRegistry.getSubprotocol(\n            _subprotocolName\n        );\n        address subprotocolOwner = subprotocolData.owner;\n        if (subprotocolOwner == address(0)) revert SubprotocolDoesNotExist(_subprotocolName);\n        address cidNFTOwner = ownerOf[_cidNFTID];\n        if (\n            cidNFTOwner != msg.sender &&\n            getApproved[_cidNFTID] != msg.sender &&\n            !isApprovedForAll[cidNFTOwner][msg.sender]\n        ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);\n        if (_nftIDToAdd == 0) revert NFTIDZeroDisallowedForSubprotocols(); // ID 0 is disallowed in subprotocols\n\n        // The CID Protocol safeguards the NFTs of subprotocols. Note that these NFTs are usually pointers to other data / NFTs (e.g., to an image NFT for profile pictures)\n        ERC721 nftToAdd = ERC721(subprotocolData.nftAddress);\n        nftToAdd.safeTransferFrom(msg.sender, address(this), _nftIDToAdd);\n        // Charge fee (subprotocol & CID fee) if configured\n        uint96 subprotocolFee = subprotocolData.fee;\n        if (subprotocolFee != 0) {\n            uint256 cidFee = (subprotocolFee * CID_FEE_BPS) / 10_000;\n            SafeTransferLib.safeTransferFrom(note, msg.sender, cidFeeWallet, cidFee);\n            SafeTransferLib.safeTransferFrom(note, msg.sender, subprotocolOwner, subprotocolFee - cidFee);\n        }\n        if (_type == AssociationType.ORDERED) {\n            if (!subprotocolData.ordered) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            if (cidData[_cidNFTID][_subprotocolName].ordered[_key] != 0) {\n                // Remove to ensure that user gets NFT back\n                remove(_cidNFTID, _subprotocolName, _key, 0, _type);\n            }\n            cidData[_cidNFTID][_subprotocolName].ordered[_key] = _nftIDToAdd;\n            emit OrderedDataAdded(_cidNFTID, _subprotocolName, _key, _nftIDToAdd);\n        } else if (_type == AssociationType.PRIMARY) {\n            if (!subprotocolData.primary) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            if (cidData[_cidNFTID][_subprotocolName].primary != 0) {\n                // Remove to ensure that user gets NFT back\n                remove(_cidNFTID, _subprotocolName, 0, 0, _type);\n            }\n            cidData[_cidNFTID][_subprotocolName].primary = _nftIDToAdd;\n            emit PrimaryDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd);\n        } else if (_type == AssociationType.ACTIVE) {\n            if (!subprotocolData.active) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            IndexedArray storage activeData = cidData[_cidNFTID][_subprotocolName].active;\n            uint256 lengthBeforeAddition = activeData.values.length;\n            if (lengthBeforeAddition == 0) {\n                uint256[] memory nftIDsToAdd = new uint256[](1);\n                nftIDsToAdd[0] = _nftIDToAdd;\n                activeData.values = nftIDsToAdd;\n                activeData.positions[_nftIDToAdd] = 1; // Array index + 1\n            } else {\n                // Check for duplicates\n                if (activeData.positions[_nftIDToAdd] != 0)\n                    revert ActiveArrayAlreadyContainsID(_cidNFTID, _subprotocolName, _nftIDToAdd);\n                activeData.values.push(_nftIDToAdd);\n                activeData.positions[_nftIDToAdd] = lengthBeforeAddition + 1;\n            }\n            emit ActiveDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd, lengthBeforeAddition);\n        }\n    }\n\n    /// @notice Remove / unset a key for the given CID NFT and subprotocol\n    /// @param _cidNFTID ID of the CID NFT to remove the data from\n    /// @param _subprotocolName Name of the subprotocol where the data will be removed. Has to exist.\n    /// @param _key Key to unset. This value is only relevant for the AssociationType ORDERED\n    /// @param _nftIDToRemove The ID of the NFT to remove. Only needed for the AssociationType ACTIVE\n    /// @param _type Association type (see AssociationType struct) to remove this data from\n    function remove(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _key,\n        uint256 _nftIDToRemove,\n        AssociationType _type\n    ) public {\n        SubprotocolRegistry.SubprotocolData memory subprotocolData = subprotocolRegistry.getSubprotocol(\n            _subprotocolName\n        );\n        address subprotocolOwner = subprotocolData.owner;\n        if (subprotocolOwner == address(0)) revert SubprotocolDoesNotExist(_subprotocolName);\n        address cidNFTOwner = ownerOf[_cidNFTID];\n        if (\n            cidNFTOwner != msg.sender &&\n            getApproved[_cidNFTID] != msg.sender &&\n            !isApprovedForAll[cidNFTOwner][msg.sender]\n        ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);\n\n        ERC721 nftToRemove = ERC721(subprotocolData.nftAddress);\n        if (_type == AssociationType.ORDERED) {\n            // We do not have to check if ordered is supported by the subprotocol. If not, the value will not be unset (which is checked below)\n            uint256 currNFTID = cidData[_cidNFTID][_subprotocolName].ordered[_key];\n            if (currNFTID == 0)\n                // This check is technically not necessary (because the NFT transfer would fail), but we include it to have more meaningful errors\n                revert OrderedValueNotSet(_cidNFTID, _subprotocolName, _key);\n            delete cidData[_cidNFTID][_subprotocolName].ordered[_key];\n            nftToRemove.safeTransferFrom(address(this), msg.sender, currNFTID);\n            emit OrderedDataRemoved(_cidNFTID, _subprotocolName, _key, _nftIDToRemove);\n        } else if (_type == AssociationType.PRIMARY) {\n            uint256 currNFTID = cidData[_cidNFTID][_subprotocolName].primary;\n            if (currNFTID == 0) revert PrimaryValueNotSet(_cidNFTID, _subprotocolName);\n            delete cidData[_cidNFTID][_subprotocolName].primary;\n            nftToRemove.safeTransferFrom(address(this), msg.sender, currNFTID);\n            emit PrimaryDataRemoved(_cidNFTID, _subprotocolName, _nftIDToRemove);\n        } else if (_type == AssociationType.ACTIVE) {\n            IndexedArray storage activeData = cidData[_cidNFTID][_subprotocolName].active;\n            uint256 arrayPosition = activeData.positions[_nftIDToRemove]; // Index + 1, 0 if non-existant\n            if (arrayPosition == 0) revert ActiveArrayDoesNotContainID(_cidNFTID, _subprotocolName, _nftIDToRemove);\n            uint256 arrayLength = activeData.values.length;\n            // Swap only necessary if not already the last element\n            if (arrayPosition != arrayLength) {\n                uint256 befSwapLastNFTID = activeData.values[arrayLength - 1];\n                activeData.values[arrayPosition - 1] = befSwapLastNFTID;\n                activeData.positions[befSwapLastNFTID] = arrayPosition;\n            }\n            activeData.values.pop();\n            activeData.positions[_nftIDToRemove] = 0;\n            nftToRemove.safeTransferFrom(address(this), msg.sender, _nftIDToRemove);\n            emit ActiveDataRemoved(_cidNFTID, _subprotocolName, _nftIDToRemove);\n        }\n    }\n\n    /// @notice Get the ordered data that is associated with a CID NFT / Subprotocol\n    /// @param"
    }
  ]
}