{
  "Title": "[G-01] Unnecessary copy of some storage struct members to memory",
  "Content": "\n### 1 Instance\n1. ### Unnecessary copy of `mapUnits[unitId].unitHash` member to memory\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/UnitRegistry.sol#L160-#L165\n\nIn the `getDependencies()` function a complete storage Unit struct is copied into a memory Uint struct on [Line 163](https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/UnitRegistry.sol#L163) but only the `dependencies` member of the storage Unit struct is needed in the function so rather than coping the complete struct from storage we could access and cache the specfic member of the storage Unit struct directly. The diff below shows how the code should be refactored: \n\n<Details>\n\n```solidity\nfile: registries/contracts/UnitRegistry.sol\n\n160:    function getDependencies(uint256 unitId) external view virtual\n161:        returns (uint256 numDependencies, uint32[] memory dependencies)\n162:    {\n163:        Unit memory unit = mapUnits[unitId];\n164:        return (unit.dependencies.length, unit.dependencies);\n165:    }\n```\n\n```diff\ndiff --git a/registries/contracts/UnitRegistry.sol b/registries/contracts/UnitRegistry.sol\nindex 80b3235..9e7d8ba 100644\n--- a/registries/contracts/UnitRegistry.sol\n+++ b/registries/contracts/UnitRegistry.sol\n@@ -160,8 +160,8 @@ abstract contract UnitRegistry is GenericRegistry {\n     function getDependencies(uint256 unitId) external view virtual\n         returns (uint256 numDependencies, uint32[] memory dependencies)\n     {\n-        Unit memory unit = mapUnits[unitId];\n-        return (unit.dependencies.length, unit.dependencies);\n+        dependencies = mapUnits[unitId].dependencies;\n+        numDependencies = dependencies.length;\n     }\n\n     /// @dev Gets updated unit hashes.\n```\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "registries/contracts/UnitRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"./GenericRegistry.sol\";\n\n/// @title Unit Registry - Smart contract for registering generalized units / units\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\nabstract contract UnitRegistry is GenericRegistry {\n    event CreateUnit(uint256 unitId, UnitType uType, bytes32 unitHash);\n    event UpdateUnitHash(uint256 unitId, UnitType uType, bytes32 unitHash);\n\n    enum UnitType {\n        Component,\n        Agent\n    }\n\n    // Unit parameters\n    struct Unit {\n        // Primary IPFS hash of the unit\n        bytes32 unitHash;\n        // Set of component dependencies (agents are also based on components)\n        // We assume that the system is expected to support no more than 2^32-1 components\n        uint32[] dependencies;\n    }\n\n    // Type of the unit: component or unit\n    UnitType public immutable unitType;\n    // Map of unit Id => set of updated IPFS hashes\n    mapping(uint256 => bytes32[]) public mapUnitIdHashes;\n    // Map of unit Id => set of subcomponents (possible to derive from any registry)\n    mapping(uint256 => uint32[]) public mapSubComponents;\n    // Map of unit Id => unit\n    mapping(uint256 => Unit) public mapUnits;\n\n    constructor(UnitType _unitType) {\n        unitType = _unitType;\n    }\n\n    /// @dev Checks the provided component dependencies.\n    /// @param dependencies Set of component dependencies.\n    /// @param maxUnitId Maximum unit Id.\n    function _checkDependencies(uint32[] memory dependencies, uint32 maxUnitId) internal virtual;\n\n    /// @dev Creates unit.\n    /// @param unitOwner Owner of the unit.\n    /// @param unitHash IPFS CID hash of the unit.\n    /// @param dependencies Set of unit dependencies in a sorted ascending order (unit Ids).\n    /// @return unitId The id of a minted unit.\n    function create(address unitOwner, bytes32 unitHash, uint32[] memory dependencies)\n        external virtual returns (uint256 unitId)\n    {\n        // Reentrancy guard\n        if (_locked > 1) {\n            revert ReentrancyGuard();\n        }\n        _locked = 2;\n\n        // Check for the manager privilege for a unit creation\n        if (manager != msg.sender) {\n            revert ManagerOnly(msg.sender, manager);\n        }\n\n        // Checks for a non-zero owner address\n        if(unitOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        // Check for the non-zero hash value\n        if (unitHash == 0) {\n            revert ZeroValue();\n        }\n        \n        // Check for dependencies validity: must be already allocated, must not repeat\n        unitId = totalSupply;\n        _checkDependencies(dependencies, uint32(unitId));\n\n        // Unit with Id = 0 is left empty not to do additional checks for the index zero\n        unitId++;\n\n        // Initialize the unit and mint its token\n        Unit storage unit = mapUnits[unitId];\n        unit.unitHash = unitHash;\n        unit.dependencies = dependencies;\n\n        // Update the map of subcomponents with calculated subcomponents for the new unit Id\n        // In order to get the correct set of subcomponents, we need to differentiate between the callers of this function\n        // Self contract (unit registry) can only call subcomponents calculation from the component level\n        uint32[] memory subComponentIds = _calculateSubComponents(UnitType.Component, dependencies);\n        // We need to add a current component Id to the set of subcomponents if the unit is a component\n        // For example, if component 3 (c3) has dependencies of [c1, c2], then the subcomponents will return [c1, c2].\n        // The resulting set will be [c1, c2, c3]. So we write into the map of component subcomponents: c3=>[c1, c2, c3].\n        // This is done such that the subcomponents start getting explored, and when the agent calls its subcomponents,\n        // it would have [c1, c2, c3] right away instead of adding c3 manually and then (for services) checking\n        // if another agent also has c3 as a component dependency. The latter will consume additional computation.\n        if (unitType == UnitType.Component) {\n            uint256 numSubComponents = subComponentIds.length;\n            uint32[] memory addSubComponentIds = new uint32[](numSubComponents + 1);\n            for (uint256 i = 0; i < numSubComponents; ++i) {\n                addSubComponentIds[i] = subComponentIds[i];\n            }\n            // Adding self component Id\n            addSubComponentIds[numSubComponents] = uint32(unitId);\n            subComponentIds = addSubComponentIds;\n        }\n        mapSubComponents[unitId] = subComponentIds;\n\n        // Set total supply to the unit Id number\n        totalSupply = unitId;\n        // Safe mint is needed since contracts can create units as well\n        _safeMint(unitOwner, unitId);\n\n        emit CreateUnit(unitId, unitType, unitHash);\n        _locked = 1;\n    }\n\n    /// @dev Updates the unit hash.\n    /// @param unitOwner Owner of the unit.\n    /// @param unitId Unit Id.\n    /// @param unitHash Updated IPFS hash of the unit.\n    /// @return success True, if function executed successfully.\n    function updateHash(address unitOwner, uint256 unitId, bytes32 unitHash) external virtual\n        returns (bool success)\n    {\n        // Check the manager privilege for a unit modification\n        if (manager != msg.sender) {\n            revert ManagerOnly(msg.sender, manager);\n        }\n\n        // Checking the unit ownership\n        if (ownerOf(unitId) != unitOwner) {\n            if (unitType == UnitType.Component) {\n                revert ComponentNotFound(unitId);\n            } else {\n                revert AgentNotFound(unitId);\n            }\n        }\n\n        // Check for the hash value\n        if (unitHash == 0) {\n            revert ZeroValue();\n        }\n\n        mapUnitIdHashes[unitId].push(unitHash);\n        success = true;\n\n        emit UpdateUnitHash(unitId, unitType, unitHash);\n    }\n\n    /// @dev Gets the unit instance.\n    /// @param unitId Unit Id.\n    /// @return unit Corresponding Unit struct.\n    function getUnit(uint256 unitId) external view virtual returns (Unit memory unit) {\n        unit = mapUnits[unitId];\n    }\n\n    /// @dev Gets unit dependencies.\n    /// @param unitId Unit Id.\n    /// @return numDependencies The number of units in the dependency list.\n    /// @return dependencies The list of unit dependencies.\n    function getDependencies(uint256 unitId) external view virtual\n        returns (uint256 numDependencies, uint32[] memory dependencies)\n    {\n        Unit memory unit = mapUnits[unitId];\n        return (unit.dependencies.length, unit.dependencies);\n    }\n\n    /// @dev Gets updated unit hashes.\n    /// @param unitId Unit Id.\n    /// @return numHashes Number of hashes.\n    /// @return unitHashes The list of updated unit hashes (without the primary one).\n    function getUpdatedHashes(uint256 unitId) external view virtual\n        returns (uint256 numHashes, bytes32[] memory unitHashes)\n    {\n        unitHashes = mapUnitIdHashes[unitId];\n        return (unitHashes.length, unitHashes);\n    }\n\n    /// @dev Gets the set of subcomponent Ids from a local map of subcomponent.\n    /// @param unitId Component Id.\n    /// @return subComponentIds Set of subcomponent Ids.\n    /// @return numSubComponents Number of subcomponents.\n    function getLocalSubComponents(uint256 unitId) external view\n        returns (uint32[] memory subComponentIds, uint256 numSubComponents)\n    {\n        subComponentIds = mapSubComponents[uint256(unitId)];\n        numSubComponents = subComponentIds.length;\n    }\n\n    /// @dev Gets subcomponents of a provided unit Id.\n    /// @param subcomponentsFromType Type of the unit: component or agent.\n    /// @param unitId Unit Id.\n    /// @return subComponentIds Set of subcomponents.\n    function _getSubComponents(UnitType subcomponentsFromType, uint32 unitId) internal view virtual\n        returns (uint32[] memory subComponentIds);\n\n    /// @dev Calculates the set of subcomponent Ids.\n    /// @param subcomponentsFromType Type of the unit: component or agent.\n    /// @param unitIds Unit Ids.\n    /// @return subComponentIds Subcomponent Ids.\n    function _calculateSubComponents(UnitType subcomponentsFromType, uint32[] memory unitIds) internal view virtual\n        returns (uint32[] memory subComponentIds)\n    {\n        uint32 numUnits = uint32(unitIds.length);\n        // Array of numbers of components per each unit Id\n        uint32[] memory numComponents = new uint32[](numUnits);\n        // 2D array of all the sets of components per each unit Id\n        uint32[][] memory components = new uint32[][](numUnits);\n\n        // Get total possible number of components and lists of components\n        uint32 maxNumComponents;\n        for (uint32 i = 0; i < numUnits; ++i) {\n            // Get subcomponents for each unit Id based on the subcomponentsFromType\n            components[i] = _getSubComponents(subcomponentsFromType, unitIds[i]);\n            numComponents[i] = uint32(components[i].length);\n            maxNumComponents += numComponents[i];\n        }\n\n        // Lists of components are sorted, take unique values in ascending order\n        uint32[] memory allComponents = new uint32[](maxNumComponents);\n        // Processed component counter\n        uint32[] memory processedComponents = new uint32[](numUnits);\n        // Minimal component Id\n        uint32 minComponent;\n        // Overall component counter\n        uint32 counter;\n        // Iterate until we process all components, at the maximum of the sum of all the components in all units\n        for (counter = 0; counter < maxNumComponents; ++counter) {\n            // Index of a minimal component\n            uint32 minIdxComponent;\n            // Amount of components identified as the next minimal component number\n            uint32 numComponentsCheck;\n            uint32 tryMinComponent = type(uint32).max;\n            // Assemble an array of all first components from each component array\n            for (uint32 i = 0; i < numUnits; ++i) {\n                // Either get a component that has a higher id than the last one ore reach the end of the processed Ids\n                for (; processedComponents[i] < numComponents[i]; ++processedComponents[i]) {\n                    if (minComponent < components[i][processedComponents[i]]) {\n                        // Out of those component Ids that are higher than the last one, pick the minimal one\n                        if (components[i][processedComponents[i]] < tryMinComponent) {\n                            tryMinComponent = components[i][processedComponents[i]];\n                            minIdxComponent = i;\n                        }\n                        // If we found a minimal component Id, we increase the counter and break to start the search again\n                        numComponentsCheck++;\n                        break;\n                    }\n                }\n            }\n            minComponent = tryMinComponent;\n\n            // If minimal component Id is greater than the last one, it should be added, otherwise we reached the end\n            if (numComponentsCheck > 0) {\n                allComponents[counter] = minComponent;\n                processedComponents[minIdxComponent]++;\n            } else {\n                break;\n            }\n        }\n\n        // Return the exact set of found subcomponents with the counter length\n        subComponentIds = new uint32[](counter);\n        for (uint32 i = 0; i < counter; ++i) {\n            subComponentIds[i] = allComponents[i];\n        }\n    }\n\n    /// @dev Gets the hash of the unit.\n    /// @param unitId Unit Id.\n    /// @return Unit hash.\n    function _getUnitHash(uint256 unitId) internal view override returns (bytes32) {\n        return mapUnits[unitId].unitHash;\n    }\n}"
    },
    {
      "filename": "registries/contracts/UnitRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"./GenericRegistry.sol\";\n\n/// @title Unit Registry - Smart contract for registering generalized units / units\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\nabstract contract UnitRegistry is GenericRegistry {\n    event CreateUnit(uint256 unitId, UnitType uType, bytes32 unitHash);\n    event UpdateUnitHash(uint256 unitId, UnitType uType, bytes32 unitHash);\n\n    enum UnitType {\n        Component,\n        Agent\n    }\n\n    // Unit parameters\n    struct Unit {\n        // Primary IPFS hash of the unit\n        bytes32 unitHash;\n        // Set of component dependencies (agents are also based on components)\n        // We assume that the system is expected to support no more than 2^32-1 components\n        uint32[] dependencies;\n    }\n\n    // Type of the unit: component or unit\n    UnitType public immutable unitType;\n    // Map of unit Id => set of updated IPFS hashes\n    mapping(uint256 => bytes32[]) public mapUnitIdHashes;\n    // Map of unit Id => set of subcomponents (possible to derive from any registry)\n    mapping(uint256 => uint32[]) public mapSubComponents;\n    // Map of unit Id => unit\n    mapping(uint256 => Unit) public mapUnits;\n\n    constructor(UnitType _unitType) {\n        unitType = _unitType;\n    }\n\n    /// @dev Checks the provided component dependencies.\n    /// @param dependencies Set of component dependencies.\n    /// @param maxUnitId Maximum unit Id.\n    function _checkDependencies(uint32[] memory dependencies, uint32 maxUnitId) internal virtual;\n\n    /// @dev Creates unit.\n    /// @param unitOwner Owner of the unit.\n    /// @param unitHash IPFS CID hash of the unit.\n    /// @param dependencies Set of unit dependencies in a sorted ascending order (unit Ids).\n    /// @return unitId The id of a minted unit.\n    function create(address unitOwner, bytes32 unitHash, uint32[] memory dependencies)\n        external virtual returns (uint256 unitId)\n    {\n        // Reentrancy guard\n        if (_locked > 1) {\n            revert ReentrancyGuard();\n        }\n        _locked = 2;\n\n        // Check for the manager privilege for a unit creation\n        if (manager != msg.sender) {\n            revert ManagerOnly(msg.sender, manager);\n        }\n\n        // Checks for a non-zero owner address\n        if(unitOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        // Check for the non-zero hash value\n        if (unitHash == 0) {\n            revert ZeroValue();\n        }\n        \n        // Check for dependencies validity: must be already allocated, must not repeat\n        unitId = totalSupply;\n        _checkDependencies(dependencies, uint32(unitId));\n\n        // Unit with Id = 0 is left empty not to do additional checks for the index zero\n        unitId++;\n\n        // Initialize the unit and mint its token\n        Unit storage unit = mapUnits[unitId];\n        unit.unitHash = unitHash;\n        unit.dependencies = dependencies;\n\n        // Update the map of subcomponents with calculated subcomponents for the new unit Id\n        // In order to get the correct set of subcomponents, we need to differentiate between the callers of this function\n        // Self contract (unit registry) can only call subcomponents calculation from the component level\n        uint32[] memory subComponentIds = _calculateSubComponents(UnitType.Component, dependencies);\n        // We need to add a current component Id to the set of subcomponents if the unit is a component\n        // For example, if component 3 (c3) has dependencies of [c1, c2], then the subcomponents will return [c1, c2].\n        // The resulting set will be [c1, c2, c3]. So we write into the map of component subcomponents: c3=>[c1, c2, c3].\n        // This is done such that the subcomponents start getting explored, and when the agent calls its subcomponents,\n        // it would have [c1, c2, c3] right away instead of adding c3 manually and then (for services) checking\n        // if another agent also has c3 as a component dependency. The latter will consume additional computation.\n        if (unitType == UnitType.Component) {\n            uint256 numSubComponents = subComponentIds.length;\n            uint32[] memory addSubComponentIds = new uint32[](numSubComponents + 1);\n            for (uint256 i = 0; i < numSubComponents; ++i) {\n                addSubComponentIds[i] = subComponentIds[i];\n            }\n            // Adding self component Id\n            addSubComponentIds[numSubComponents] = uint32(unitId);\n            subComponentIds = addSubComponentIds;\n        }\n        mapSubComponents[unitId] = subComponentIds;\n\n        // Set total supply to the unit Id number\n        totalSupply = unitId;\n        // Safe mint is needed since contracts can create units as well\n        _safeMint(unitOwner, unitId);\n\n        emit CreateUnit(unitId, unitType, unitHash);\n        _locked = 1;\n    }\n\n    /// @dev Updates the unit hash.\n    /// @param unitOwner Owner of the unit.\n    /// @param unitId Unit Id.\n    /// @param unitHash Updated IPFS hash of the unit.\n    /// @return success True, if function executed successfully.\n    function updateHash(address unitOwner, uint256 unitId, bytes32 unitHash) external virtual\n        returns (bool success)\n    {\n        // Check the manager privilege for a unit modification\n        if (manager != msg.sender) {\n            revert ManagerOnly(msg.sender, manager);\n        }\n\n        // Checking the unit ownership\n        if (ownerOf(unitId) != unitOwner) {\n            if (unitType == UnitType.Component) {\n                revert ComponentNotFound(unitId);\n            } else {\n                revert AgentNotFound(unitId);\n            }\n        }\n\n        // Check for the hash value\n        if (unitHash == 0) {\n            revert ZeroValue();\n        }\n\n        mapUnitIdHashes[unitId].push(unitHash);\n        success = true;\n\n        emit UpdateUnitHash(unitId, unitType, unitHash);\n    }\n\n    /// @dev Gets the unit instance.\n    /// @param unitId Unit Id.\n    /// @return unit Corresponding Unit struct.\n    function getUnit(uint256 unitId) external view virtual returns (Unit memory unit) {\n        unit = mapUnits[unitId];\n    }\n\n    /// @dev Gets unit dependencies.\n    /// @param unitId Unit Id.\n    /// @return numDependencies The number of units in the dependency list.\n    /// @return dependencies The list of unit dependencies.\n    function getDependencies(uint256 unitId) external view virtual\n        returns (uint256 numDependencies, uint32[] memory dependencies)\n    {\n        Unit memory unit = mapUnits[unitId];\n        return (unit.dependencies.length, unit.dependencies);\n    }\n\n    /// @dev Gets updated unit hashes.\n    /// @param unitId Unit Id.\n    /// @return numHashes Number of hashes.\n    /// @return unitHashes The list of updated unit hashes (without the primary one).\n    function getUpdatedHashes(uint256 unitId) external view virtual\n        returns (uint256 numHashes, bytes32[] memory unitHashes)\n    {\n        unitHashes = mapUnitIdHashes[unitId];\n        return (unitHashes.length, unitHashes);\n    }\n\n    /// @dev Gets the set of subcomponent Ids from a local map of subcomponent.\n    /// @param unitId Component Id.\n    /// @return subComponentIds Set of subcomponent Ids.\n    /// @return numSubComponents Number of subcomponents.\n    function getLocalSubComponents(uint256 unitId) external view\n        returns (uint32[] memory subComponentIds, uint256 numSubComponents)\n    {\n        subComponentIds = mapSubComponents[uint256(unitId)];\n        numSubComponents = subComponentIds.length;\n    }\n\n    /// @dev Gets subcomponents of a provided unit Id.\n    /// @param subcomponentsFromType Type of the unit: component or agent.\n    /// @param unitId Unit Id.\n    /// @return subComponentIds Set of subcomponents.\n    function _getSubComponents(UnitType subcomponentsFromType, uint32 unitId) internal view virtual\n        returns (uint32[] memory subComponentIds);\n\n    /// @dev Calculates the set of subcomponent Ids.\n    /// @param subcomponentsFromType Type of the unit: component or agent.\n    /// @param unitIds Unit Ids.\n    /// @return subComponentIds Subcomponent Ids.\n    function _calculateSubComponents(UnitType subcomponentsFromType, uint32[] memory unitIds) internal view virtual\n        returns (uint32[] memory subComponentIds)\n    {\n        uint32 numUnits = uint32(unitIds.length);\n        // Array of numbers of components per each unit Id\n        uint32[] memory numComponents = new uint32[](numUnits);\n        // 2D array of all the sets of components per each unit Id\n        uint32[][] memory components = new uint32[][](numUnits);\n\n        // Get total possible number of components and lists of components\n        uint32 maxNumComponents;\n        for (uint32 i = 0; i < numUnits; ++i) {\n            // Get subcomponents for each unit Id based on the subcomponentsFromType\n            components[i] = _getSubComponents(subcomponentsFromType, unitIds[i]);\n            numComponents[i] = uint32(components[i].length);\n            maxNumComponents += numComponents[i];\n        }\n\n        // Lists of components are sorted, take unique values in ascending order\n        uint32[] memory allComponents = new uint32[](maxNumComponents);\n        // Processed component counter\n        uint32[] memory processedComponents = new uint32[](numUnits);\n        // Minimal component Id\n        uint32 minComponent;\n        // Overall component counter\n        uint32 counter;\n        // Iterate until we process all components, at the maximum of the sum of all the components in all units\n        for (counter = 0; counter < maxNumComponents; ++counter) {\n            // Index of a minimal component\n            uint32 minIdxComponent;\n            // Amount of components identified as the next minimal component number\n            uint32 numComponentsCheck;\n            uint32 tryMinComponent = type(uint32).max;\n            // Assemble an array of all first components from each component array\n            for (uint32 i = 0; i < numUnits; ++i) {\n                // Either get a component that has a higher id than the last one ore reach the end of the processed Ids\n                for (; processedComponents[i] < numComponents[i]; ++processedComponents[i]) {\n                    if (minComponent < components[i][processedComponents[i]]) {\n                        // Out of those component Ids that are higher than the last one, pick the minimal one\n                        if (components[i][processedComponents[i]] < tryMinComponent) {\n                            tryMinComponent = components[i][processedComponents[i]];\n                            minIdxComponent = i;\n                        }\n                        // If we found a minimal component Id, we increase the counter and break to start the search again\n                        numComponentsCheck++;\n                        break;\n                    }\n                }\n            }\n            minComponent = tryMinComponent;\n\n            // If minimal component Id is greater than the last one, it should be added, otherwise we reached the end\n            if (numComponentsCheck > 0) {\n                allComponents[counter] = minComponent;\n                processedComponents[minIdxComponent]++;\n            } else {\n                break;\n            }\n        }\n\n        // Return the exact set of found subcomponents with the counter length\n        subComponentIds = new uint32[](counter);\n        for (uint32 i = 0; i < counter; ++i) {\n            subComponentIds[i] = allComponents[i];\n        }\n    }\n\n    /// @dev Gets the hash of the unit.\n    /// @param unitId Unit Id.\n    /// @return Unit hash.\n    function _getUnitHash(uint256 unitId) internal view override returns (bytes32) {\n        return mapUnits[unitId].unitHash;\n    }\n}"
    }
  ]
}