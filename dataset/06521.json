{
  "Title": "[M-02] Rage quitter loses his claimable share of distributed tokens",
  "Content": "\n### Proof of Concept\n\n[`PartyGovernanceNFT.rageQuit()`](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/party/PartyGovernanceNFT.sol#L293-L353) burns a governance NFT and transfers its share of the balance of ETH and tokens:\n\n```solidity\n// Burn caller's party card. This will revert if caller is not the owner\n// of the card.\nburn(tokenId);\n\n// Withdraw fair share of tokens from the party.\nIERC20 prevToken;\nfor (uint256 j; j < withdrawTokens.length; ++j) {\n    IERC20 token = withdrawTokens[j];\n\n    // Prevent null and duplicate transfers.\n    if (prevToken >= token) revert InvalidTokenOrderError();\n\n    prevToken = token;\n\n    // Check if token is ETH.\n    if (address(token) == ETH_ADDRESS) {\n        // Transfer fair share of ETH to receiver.\n        uint256 amount = (address(this).balance * shareOfVotingPower) / 1e18;\n        if (amount != 0) {\n            payable(receiver).transferEth(amount);\n        }\n    } else {\n        // Transfer fair share of tokens to receiver.\n        uint256 amount = (token.balanceOf(address(this)) * shareOfVotingPower) / 1e18;\n        if (amount != 0) {\n            token.compatTransfer(receiver, amount);\n        }\n    }\n}\n```\nThe problem with this is that the governance NFT might also have tokens to [`claim()`](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/distribution/TokenDistributor.sol#L138-L182) in the `TokenDistributor`. These cannot be claimed after the governance NFT has been burned.\n\nThe rage quitter cannot completely protect himself from this by calling `claim()` first, because the tokens might not yet have been distributed to the `TokenDistributor` until in a frontrun call to [`distribute()`](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/party/PartyGovernance.sol#L474-L520) just before his `rageQuit()`. This way the rage quitter might be robbed of his fair share.\n\n### Recommended Mitigation Steps\n\nHave `rageQuit()` call `TokenDistributor.claim()` before the governance NFT is burned.\n\n### Assessed type\n\nContext\n\n**[cccz (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-05-party-findings/issues/22#issuecomment-1569558622):**\n > Similar issues are considered M in C4. Loss of funds requires external requirements (user misses call to claim() or frontrun occurs).<br>\n> Also, since the claim() only allows NFT owner to call, consider transferring the user's NFT to the contract in rageQuit().\n> ```solidity\n>     function claim(\n>         DistributionInfo calldata info,\n>         uint256 partyTokenId\n>     ) public returns (uint128 amountClaimed) {\n>         // Caller must own the party token.\n>         {\n>             address ownerOfPartyToken = info.party.ownerOf(partyTokenId);\n>             if (msg.sender != ownerOfPartyToken) {\n>                 revert MustOwnTokenError(msg.sender, ownerOfPartyToken, partyTokenId);\n>             }\n>         }\n> ```\n\n**[0xble (Party) acknowledged and commented](https://github.com/code-423n4/2023-05-party-findings/issues/22#issuecomment-1572354438):**\n > We will warn users with unclaimed distributions on the frontend but will not make any code changes to enforce this.\n\n**[adriro (warden) commented](https://github.com/code-423n4/2023-05-party-findings/issues/22#issuecomment-1577180233):**\n > @cccz (judge) I think this issue should be more on the QA side as the sponsor clearly stated that rage quit may cause losses due to user inaction or mistake:\n> \n> > If a user intentionally or accidentally excludes a token in their ragequit, they forfeit that token and will not be able to claim it.\n> \n> Similar to the described scenario, if a user forgets to call claim on the distributor before rage quitting, they will lose their share of tokens.\n\n**[cccz (judge) commented](https://github.com/code-423n4/2023-05-party-findings/issues/22#issuecomment-1577900036):**\n > In this issue, even if the user does not make any mistake, they may suffer a loss because there may be a potential frontrun attack.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-party",
  "Code": [
    {
      "filename": "contracts/party/PartyGovernanceNFT.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../utils/ReadOnlyDelegateCall.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../vendor/solmate/ERC721.sol\";\nimport \"./PartyGovernance.sol\";\nimport \"../renderers/RendererStorage.sol\";\n\n/// @notice ERC721 functionality built on top of `PartyGovernance`.\ncontract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\n    using LibSafeCast for uint256;\n    using LibSafeCast for uint96;\n    using LibERC20Compat for IERC20;\n    using LibAddress for address payable;\n\n    error OnlyAuthorityError();\n    error OnlySelfError();\n    error UnauthorizedToBurnError();\n    error FixedRageQuitTimestampError(uint40 rageQuitTimestamp);\n    error CannotRageQuitError(uint40 rageQuitTimestamp);\n    error CannotDisableRageQuitAfterInitializationError();\n    error InvalidTokenOrderError();\n\n    event AuthorityAdded(address indexed authority);\n    event AuthorityRemoved(address indexed authority);\n    event RageQuitSet(uint40 oldRageQuitTimestamp, uint40 newRageQuitTimestamp);\n    event RageQuit(uint256[] indexed tokenIds, IERC20[] withdrawTokens, address receiver);\n\n    uint40 private constant ENABLE_RAGEQUIT_PERMANENTLY = 0x6b5b567bfe; // uint40(uint256(keccak256(\"ENABLE_RAGEQUIT_PERMANENTLY\")))\n    uint40 private constant DISABLE_RAGEQUIT_PERMANENTLY = 0xab2cb21860; // uint40(uint256(keccak256(\"DISABLE_RAGEQUIT_PERMANENTLY\")))\n\n    // Token address used to indicate ETH.\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and its address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The number of tokens that have been minted.\n    uint96 public tokenCount;\n    /// @notice The total minted voting power.\n    ///         Capped to `_governanceValues.totalVotingPower` unless minting\n    ///         party cards for initial crowdfund.\n    uint96 public mintedVotingPower;\n    /// @notice The timestamp until which ragequit is enabled. Can be set to the\n    ///         `ENABLE_RAGEQUIT_PERMANENTLY`/`DISABLE_RAGEQUIT_PERMANENTLY`\n    ///         values to enable/disable ragequit permanently.\n    ///         `DISABLE_RAGEQUIT_PERMANENTLY` can only be set during\n    ///         initialization.\n    uint40 public rageQuitTimestamp;\n    /// @notice The voting power of `tokenId`.\n    mapping(uint256 => uint256) public votingPowerByTokenId;\n    /// @notice Address with authority to mint cards and update voting power for the party.\n    mapping(address => bool) public isAuthority;\n\n    modifier onlyAuthority() {\n        if (!isAuthority[msg.sender]) {\n            revert OnlyAuthorityError();\n        }\n        _;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) {\n            revert OnlySelfError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract. The name or symbol of ERC721 does not matter;\n    // it will be set in `_initialize()`.\n    constructor(IGlobals globals) payable PartyGovernance(globals) ERC721(\"\", \"\") {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts.\n    function _initialize(\n        string memory name_,\n        string memory symbol_,\n        uint256 customizationPresetId,\n        PartyGovernance.GovernanceOpts memory governanceOpts,\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        address[] memory authorities,\n        uint40 rageQuitTimestamp_\n    ) internal {\n        PartyGovernance._initialize(\n            governanceOpts,\n            proposalEngineOpts,\n            preciousTokens,\n            preciousTokenIds\n        );\n        name = name_;\n        symbol = symbol_;\n        rageQuitTimestamp = rageQuitTimestamp_;\n        unchecked {\n            for (uint256 i; i < authorities.length; ++i) {\n                isAuthority[authorities[i]] = true;\n            }\n        }\n        if (customizationPresetId != 0) {\n            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))\n                .useCustomizationPreset(customizationPresetId);\n        }\n    }\n\n    /// @inheritdoc ERC721\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(ERC721, ITokenDistributorParty) returns (address owner) {\n        return ERC721.ownerOf(tokenId);\n    }\n\n    /// @inheritdoc EIP165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public pure override(PartyGovernance, ERC721, IERC165) returns (bool) {\n        return\n            PartyGovernance.supportsInterface(interfaceId) ||\n            ERC721.supportsInterface(interfaceId) ||\n            interfaceId == type(IERC2981).interfaceId;\n    }\n\n    /// @inheritdoc ERC721\n    function tokenURI(uint256) public view override returns (string memory) {\n        _delegateToRenderer();\n        return \"\"; // Just to make the compiler happy.\n    }\n\n    /// @notice Returns a URI for the storefront-level metadata for your contract.\n    function contractURI() external view returns (string memory) {\n        _delegateToRenderer();\n        return \"\"; // Just to make the compiler happy.\n    }\n\n    /// @notice Called with the sale price to determine how much royalty\n    //          is owed and to whom.\n    function royaltyInfo(uint256, uint256) external view returns (address, uint256) {\n        _delegateToRenderer();\n        return (address(0), 0); // Just to make the compiler happy.\n    }\n\n    /// @inheritdoc ITokenDistributorParty\n    function getDistributionShareOf(uint256 tokenId) public view returns (uint256) {\n        uint256 totalVotingPower = _governanceValues.totalVotingPower;\n\n        if (totalVotingPower == 0) {\n            return 0;\n        } else {\n            return (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;\n        }\n    }\n\n    /// @notice Mint a governance NFT for `owner` with `votingPower` and\n    ///         immediately delegate voting power to `delegate.` Only callable\n    ///         by an authority.\n    /// @param owner The owner of the NFT.\n    /// @param votingPower The voting power of the NFT.\n    /// @param delegate The address to delegate voting power to.\n    function mint(\n        address owner,\n        uint256 votingPower,\n        address delegate\n    ) external onlyAuthority onlyDelegateCall returns (uint256 tokenId) {\n        uint96 mintedVotingPower_ = mintedVotingPower;\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\n\n        // Cap voting power to remaining unminted voting power supply.\n        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();\n        // Allow minting past total voting power if minting party cards for\n        // initial crowdfund when there is no total voting power.\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {\n            votingPower_ = totalVotingPower - mintedVotingPower_;\n        }\n\n        // Update state.\n        unchecked {\n            tokenId = ++tokenCount;\n        }\n        mintedVotingPower += votingPower_;\n        votingPowerByTokenId[tokenId] = votingPower_;\n\n        // Use delegate from party over the one set during crowdfund.\n        address delegate_ = delegationsByVoter[owner];\n        if (delegate_ != address(0)) {\n            delegate = delegate_;\n        }\n\n        _adjustVotingPower(owner, votingPower_.safeCastUint96ToInt192(), delegate);\n        _safeMint(owner, tokenId);\n    }\n\n    /// @notice Add voting power to an existing NFT. Only callable by an\n    ///         authority.\n    /// @param tokenId The ID of the NFT to add voting power to.\n    /// @param votingPower The amount of voting power to add.\n    function addVotingPower(\n        uint256 tokenId,\n        uint256 votingPower\n    ) external onlyAuthority onlyDelegateCall {\n        uint96 mintedVotingPower_ = mintedVotingPower;\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\n        // Cap voting power to remaining unminted voting power supply.\n        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();\n        // Allow minting past total voting power if minting party cards for\n        // initial crowdfund when there is no total voting power.\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {\n            votingPower_ = totalVotingPower - mintedVotingPower_;\n        }\n\n        // Update state.\n        mintedVotingPower += votingPower_;\n        votingPowerByTokenId[tokenId] += votingPower_;\n\n        _adjustVotingPower(ownerOf(tokenId), votingPower_.safeCastUint96ToInt192(), address(0));\n    }\n\n    /// @notice Update the total voting power of the party. Only callable by\n    ///         an authority.\n    /// @param newVotingPower The new total voting power to add.\n    function increaseTotalVotingPower(\n        uint96 newVotingPower\n    ) external onlyAuthority onlyDelegateCall {\n        _governanceValues.totalVotingPower += newVotingPower;\n    }\n\n    /// @notice Burn a governance NFT and remove its voting power.\n    /// @param tokenId The ID of the NFT to burn.\n    function burn(uint256 tokenId) public onlyDelegateCall {\n        address owner = ownerOf(tokenId);\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\n        bool authority = isAuthority[msg.sender];\n        if (\n            msg.sender != owner &&\n            getApproved[tokenId] != msg.sender &&\n            !isApprovedForAll[owner][msg.sender]\n        ) {\n            // Allow authority to burn cards if the total voting power has not yet\n            // been set (e.g. for initial crowdfunds) meaning the party has not\n            // yet started.\n            if (totalVotingPower != 0 || !authority) revert UnauthorizedToBurnError();\n        }\n\n        // Update last burn timestamp.\n        lastBurnTimestamp = uint40(block.timestamp);\n\n        uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();\n        mintedVotingPower -= votingPower;\n        delete votingPowerByTokenId[tokenId];\n\n        if (totalVotingPower != 0) {\n            _governanceValues.totalVotingPower = totalVotingPower - votingPower;\n        } else {\n            if (!authority) revert OnlyAuthorityError();\n        }\n\n        _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));\n\n        _burn(tokenId);\n    }\n\n    /// @notice Set the timestamp until which ragequit is enabled.\n    /// @param newRageQuitTimestamp The new ragequit timestamp.\n    function setRageQuit(uint40 newRageQuitTimestamp) external onlyHost {\n        uint40 oldRageQuitTimestamp = rageQuitTimestamp;\n\n        // Prevent disabling ragequit after initialization.\n        if (newRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY) {\n            revert CannotDisableRageQuitAfterInitializationError();\n        }\n\n        // Prevent setting timestamp if it is permanently enabled/disabled.\n        if (\n            oldRageQuitTimestamp == ENABLE_RAGEQUIT_PERMANENTLY ||\n            oldRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY\n        ) {\n            revert FixedRageQuitTimestampError(oldRageQuitTimestamp);\n        }\n\n        emit RageQuitSet(oldRageQuitTimestamp, rageQuitTimestamp = newRageQuitTimestamp);\n    }\n\n    /// @notice Burn a governance NFT and withdraw a fair share of fungible tokens from the party.\n    /// @param tokenIds The IDs of the governance NFTs to burn.\n    /// @param withdrawTokens The fungible tokens to withdraw.\n    /// @param receiver The address to receive the withdrawn tokens.\n    function rageQuit(\n        uint256[] calldata tokenIds,\n        IERC20[] calldata withdrawTokens,\n        address receiver\n    ) external {\n        // Check if ragequit is allowed.\n        uint40 currentRageQuitTimestamp = rageQuitTimestamp;\n        if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {\n            if (\n                currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||\n                currentRageQuitTimestamp < block.timestamp\n            ) {\n                revert CannotRageQuitError(currentRageQuitTimestamp);\n            }\n        }\n\n        // Used as a reentrancy guard. Will be updated back after ragequit.\n        delete rageQuitTimestamp;\n\n        for (uint256 i; i < tokenIds.length; ++i) {\n            uint256 tokenId = tokenIds[i];\n\n            // Must be retrieved before burning the token.\n            uint256 shareOfVotingPower = getDistributionShareOf(tokenId);\n\n            // Burn caller's party card. This will revert if caller is not the owner\n            // of the card.\n            burn(tokenId);\n\n            // Withdraw fair share of tokens from the party.\n            IERC20 prevToken;\n            for (uint256 j; j < withdrawTokens.length; ++j) {\n                IERC20 token = withdrawTokens[j];\n\n                // Prevent null and duplicate transfers.\n                if (prevToken >= token) revert InvalidTokenOrderError();\n\n                prevToken = token;\n\n                // Check if token is ETH.\n                if (address(token) == ETH_ADDRESS) {\n                    // Transfer fair share of ETH to receiver.\n                    uint256 amount = (address(this).balance * shareOfVotingPower) / 1e18;\n                    if (amount != 0) {\n                        payable(receiver).transferEth(amount);\n                    }\n                } else {\n                    // Transfer fair share of tokens to receiver.\n                    uint256 amount = (token.balanceOf(address(this)) * shareOfVotingPower) / 1e18;\n                    if (amount != 0) {\n                        token.compatTransfer(receiver, amount);\n                    }\n                }\n            }\n        }\n\n        // Update ragequit timestamp back to before.\n        rageQuitTimestamp = currentRageQuitTimestamp;\n\n        emit RageQuit(tokenIds, withdrawTokens, receiver);\n    }\n\n    /// @inheritdoc ERC721\n    function transferFrom(\n        address owner,\n        address to,\n        uint256 tokenId\n    ) public override onlyDelegateCall {\n        // Transfer voting along with token.\n        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);\n        super.transferFrom(owner, to, tokenId);\n    }\n\n    /// @inheritdoc ERC721\n    function safeTransferFrom(\n        address owner,\n        address to,\n        uint256 tokenId\n    ) public override onlyDelegateCall {\n        // super.safeTransferFrom() will call transferFrom() first which will\n        // transfer voting power.\n        super.safeTransferFrom(owner, to, tokenId);\n    }\n\n    /// @inheritdoc ERC721\n    function safeTransferFrom(\n        address owner,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override onlyDelegateCall {\n        // super.safeTransferFrom() will call transferFrom() first which will\n        // transfer voting power.\n        super.safeTransferFrom(owner, to, tokenId, data);\n    }\n\n    /// @notice Add a new authority.\n    /// @dev Used in `AddAuthorityProposal`. Only the party itself can add\n    ///      authorities to prevent it from being used anywhere else.\n    function addAuthority(address authority) external onlySelf onlyDelegateCall {\n        isAuthority[authority] = true;\n\n        emit AuthorityAdded(authority);\n    }\n\n    /// @notice Relinquish the authority role.\n    function abdicateAuthority() external onlyAuthority onlyDelegateCall {\n        delete isAuthority[msg.sender];\n\n        emit AuthorityRemoved(msg.sender);\n    }\n\n    function _delegateToRenderer() private view {\n        _readOnlyDelegateCall(\n            // Instance of IERC721Renderer.\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_GOVERNANCE_NFT_RENDER_IMPL),\n            msg.data\n        );\n        assert(false); // Will not be reached.\n    }\n}"
    },
    {
      "filename": "contracts/distribution/TokenDistributor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../tokens/IERC20.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibERC20Compat.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\n\nimport \"./ITokenDistributor.sol\";\n\n/// @notice Creates token distributions for parties (or any contract that\n///         implements `ITokenDistributorParty`).\ncontract TokenDistributor is ITokenDistributor {\n    using LibAddress for address payable;\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n\n    struct DistributionState {\n        // The hash of the `DistributionInfo`.\n        bytes32 distributionHash;\n        // The remaining member supply.\n        uint128 remainingMemberSupply;\n        // Whether the distribution's feeRecipient has claimed its fee.\n        bool wasFeeClaimed;\n        // Whether a governance token has claimed its distribution share.\n        mapping(uint256 => bool) hasPartyTokenClaimed;\n    }\n\n    // Arguments for `_createDistribution()`.\n    struct CreateDistributionArgs {\n        ITokenDistributorParty party;\n        TokenType tokenType;\n        address token;\n        uint256 currentTokenBalance;\n        address payable feeRecipient;\n        uint16 feeBps;\n    }\n\n    event EmergencyExecute(address target, bytes data);\n\n    error OnlyPartyDaoError(address notDao, address partyDao);\n    error InvalidDistributionInfoError(DistributionInfo info);\n    error DistributionAlreadyClaimedByPartyTokenError(uint256 distributionId, uint256 partyTokenId);\n    error DistributionFeeAlreadyClaimedError(uint256 distributionId);\n    error MustOwnTokenError(address sender, address expectedOwner, uint256 partyTokenId);\n    error EmergencyActionsNotAllowedError();\n    error InvalidDistributionSupplyError(uint128 supply);\n    error OnlyFeeRecipientError(address caller, address feeRecipient);\n    error InvalidFeeBpsError(uint16 feeBps);\n\n    // Token address used to indicate a native distribution (i.e. distribution of ETH).\n    address private constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice The `Globals` contract storing global configuration values. This contract\n    ///         is immutable and itâ€™s address will never change.\n    IGlobals public immutable GLOBALS;\n    /// @notice Timestamp when the DAO is no longer allowed to call emergency functions.\n    uint40 public immutable EMERGENCY_DISABLED_TIMESTAMP;\n\n    /// @notice Last distribution ID for a party.\n    mapping(ITokenDistributorParty => uint256) public lastDistributionIdPerParty;\n    /// Last known balance of a token, identified by an ID derived from the token.\n    /// Gets lazily updated when creating and claiming a distribution (transfers).\n    /// Allows one to simply transfer and call `createDistribution()` without\n    /// fussing with allowances.\n    mapping(bytes32 => uint256) private _storedBalances;\n    // tokenDistributorParty => distributionId => DistributionState\n    mapping(ITokenDistributorParty => mapping(uint256 => DistributionState))\n        private _distributionStates;\n\n    // msg.sender == DAO\n    modifier onlyPartyDao() {\n        {\n            address partyDao = GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n            if (msg.sender != partyDao) {\n                revert OnlyPartyDaoError(msg.sender, partyDao);\n            }\n        }\n        _;\n    }\n\n    // emergencyActionsDisabled == false\n    modifier onlyIfEmergencyActionsAllowed() {\n        if (block.timestamp > EMERGENCY_DISABLED_TIMESTAMP) {\n            revert EmergencyActionsNotAllowedError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals, uint40 emergencyDisabledTimestamp) {\n        GLOBALS = globals;\n        EMERGENCY_DISABLED_TIMESTAMP = emergencyDisabledTimestamp;\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function createNativeDistribution(\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    ) external payable returns (DistributionInfo memory info) {\n        info = _createDistribution(\n            CreateDistributionArgs({\n                party: party,\n                tokenType: TokenType.Native,\n                token: NATIVE_TOKEN_ADDRESS,\n                currentTokenBalance: address(this).balance,\n                feeRecipient: feeRecipient,\n                feeBps: feeBps\n            })\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function createErc20Distribution(\n        IERC20 token,\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    ) external returns (DistributionInfo memory info) {\n        info = _createDistribution(\n            CreateDistributionArgs({\n                party: party,\n                tokenType: TokenType.Erc20,\n                token: address(token),\n                currentTokenBalance: token.balanceOf(address(this)),\n                feeRecipient: feeRecipient,\n                feeBps: feeBps\n            })\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function claim(\n        DistributionInfo calldata info,\n        uint256 partyTokenId\n    ) public returns (uint128 amountClaimed) {\n        // Caller must own the party token.\n        {\n            address ownerOfPartyToken = info.party.ownerOf(partyTokenId);\n            if (msg.sender != ownerOfPartyToken) {\n                revert MustOwnTokenError(msg.sender, ownerOfPartyToken, partyTokenId);\n            }\n        }\n        // DistributionInfo must be correct for this distribution ID.\n        DistributionState storage state = _distributionStates[info.party][info.distributionId];\n        if (state.distributionHash != _getDistributionHash(info)) {\n            revert InvalidDistributionInfoError(info);\n        }\n        // The partyTokenId must not have claimed its distribution yet.\n        if (state.hasPartyTokenClaimed[partyTokenId]) {\n            revert DistributionAlreadyClaimedByPartyTokenError(info.distributionId, partyTokenId);\n        }\n        // Mark the partyTokenId as having claimed their distribution.\n        state.hasPartyTokenClaimed[partyTokenId] = true;\n\n        // Compute amount owed to partyTokenId.\n        amountClaimed = getClaimAmount(info.party, info.memberSupply, partyTokenId);\n\n        // Cap at the remaining member supply. Otherwise a malicious\n        // party could drain more than the distribution supply.\n        uint128 remainingMemberSupply = state.remainingMemberSupply;\n        amountClaimed = amountClaimed > remainingMemberSupply\n            ? remainingMemberSupply\n            : amountClaimed;\n        state.remainingMemberSupply = remainingMemberSupply - amountClaimed;\n\n        // Transfer tokens owed.\n        _transfer(info.tokenType, info.token, payable(msg.sender), amountClaimed);\n        emit DistributionClaimedByPartyToken(\n            info.party,\n            partyTokenId,\n            msg.sender,\n            info.tokenType,\n            info.token,\n            amountClaimed\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function claimFee(DistributionInfo calldata info, address payable recipient) public {\n        // DistributionInfo must be correct for this distribution ID.\n        DistributionState storage state = _distributionStates[info.party][info.distributionId];\n        if (state.distributionHash != _getDistributionHash(info)) {\n            revert InvalidDistributionInfoError(info);\n        }\n        // Caller must be the fee recipient.\n        if (info.feeRecipient != msg.sender) {\n            revert OnlyFeeRecipientError(msg.sender, info.feeRecipient);\n        }\n        // Must not have claimed the fee yet.\n        if (state.wasFeeClaimed) {\n            revert DistributionFeeAlreadyClaimedError(info.distributionId);\n        }\n        // Mark the fee as claimed.\n        state.wasFeeClaimed = true;\n        // Transfer the tokens owed.\n        _transfer(info.tokenType, info.token, recipient, info.fee);\n        emit DistributionFeeClaimed(\n            info.party,\n            info.feeRecipient,\n            info.tokenType,\n            info.token,\n            info.fee\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function batchClaim(\n        DistributionInfo[] calldata infos,\n        uint256[] calldata partyTokenIds\n    ) external returns (uint128[] memory amountsClaimed) {\n        amountsClaimed = new uint128[](infos.length);\n        for (uint256 i = 0; i < infos.length; ++i) {\n            amountsClaimed[i] = claim(infos[i], partyTokenIds[i]);\n        }\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function batchClaimFee(\n        DistributionInfo[] calldata infos,\n        address payable[] calldata recipients\n    ) external {\n        for (uint256 i = 0; i < infos.length; ++i) {\n            claimFee(infos[i], recipients[i]);\n        }\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function getClaimAmount(\n        ITokenDistributorParty party,\n        uint256 memberSupply,\n        uint256 partyTokenId\n    ) public view returns (uint128) {\n        // getDistributionShareOf() is the fraction of the memberSupply partyTokenId\n        // is entitled to, scaled by 1e18.\n        // We round up here to prevent dust amounts getting trapped in this contract.\n        return\n            ((uint256(party.getDistributionShareOf(partyTokenId)) * memberSupply + (1e18 - 1)) /\n                1e18).safeCastUint256ToUint128();\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function wasFeeClaimed(\n        ITokenDistributorParty party,\n        uint256 distributionId\n    ) external view returns (bool) {\n        return _distributionStates[party][distributionId].wasFeeClaimed;\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function hasPartyTokenIdClaimed(\n        ITokenDistributorParty party,\n        uint256 partyTokenId,\n        uint256 distributionId\n    ) external view returns (bool) {\n        return _distributionStates[party][distributionId].hasPartyTokenClaimed[partyTokenId];\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function getRemainingMemberSupply(\n        ITokenDistributorParty party,\n        uint256 distributionId\n    ) external view returns (uint128) {\n        return _distributionStates[party][distributionId].remainingMemberSupply;\n    }\n\n    /// @notice As the DAO, execute an arbitrary delegatecall from this contract.\n    /// @dev Emergency actions must not be revoked for this to work.\n    /// @param targetAddress The contract to delegatecall into.\n    /// @param targetCallData The data to pass to the call.\n    function emergencyExecute(\n        address targetAddress,\n        bytes calldata targetCallData\n    ) external onlyPartyDao onlyIfEmergencyActionsAllowed {\n        (bool success, bytes memory res) = targetAddress.delegatecall(targetCallData);\n        if (!success) {\n            res.rawRevert();\n        }\n        emit EmergencyExecute(targetAddress, targetCallData);\n    }\n\n    function _createDistribution(\n        CreateDistributionArgs memory args\n    ) private returns (DistributionInfo memory info) {\n        if (args.feeBps > 1e4) {\n            revert InvalidFeeBpsError(args.feeBps);\n        }\n        uint128 supply;\n        {\n            bytes32 balanceId = _getBalanceId(args.tokenType, args.token);\n            supply = (args.currentTokenBalance - _storedBalances[balanceId])\n                .safeCastUint256ToUint128();\n            // Supply must be nonzero.\n            if (supply == 0) {\n                revert InvalidDistributionSupplyError(supply);\n            }\n            // Update stored balance.\n            _storedBalances[balanceId] = args.currentTokenBalance;\n        }\n\n        // Create a distribution.\n        uint128 fee = (supply * args.feeBps) / 1e4;\n        uint128 memberSupply = supply - fee;\n\n        info = DistributionInfo({\n            tokenType: args.tokenType,\n            distributionId: ++lastDistributionIdPerParty[args.party],\n            token: args.token,\n            party: args.party,\n            memberSupply: memberSupply,\n            feeRecipient: args.feeRecipient,\n            fee: fee\n        });\n        (\n            _distributionStates[args.party][info.distributionId].distributionHash,\n            _distributionStates[args.party][info.distributionId].remainingMemberSupply\n        ) = (_getDistributionHash(info), memberSupply);\n        emit DistributionCreated(args.party, info);\n    }\n\n    function _transfer(\n        TokenType tokenType,\n        address token,\n        address payable recipient,\n        uint256 amount\n    ) private {\n        bytes32 balanceId = _getBalanceId(tokenType, token);\n        // Reduce stored token balance.\n        uint256 storedBalance = _storedBalances[balanceId] - amount;\n        // Temporarily set to max as a reentrancy guard. An interesing attack\n        // could occur if we didn't do this where an attacker could `claim()` and\n        // reenter upon transfer (e.g. in the `tokensToSend` hook of an ERC777) to\n        // `createERC20Distribution()`. Since the `balanceOf(address(this))`\n        // would not of been updated yet, the supply would be miscalculated and\n        // the attacker would create a distribution that essentially steals from\n        // the last distribution they were claiming from. Here, we prevent that\n        // by causing an arithmetic underflow with the supply calculation if\n        // this were to be attempted.\n        _storedBalances[balanceId] = type(uint256).max;\n        if (tokenType == TokenType.Native) {\n            recipient.transferEth(amount);\n        } else {\n            assert(tokenType == TokenType.Erc20);\n            IERC20(token).compatTransfer(recipient, amount);\n        }\n        _storedBalances[balanceId] = storedBalance;\n    }\n\n    function _getDistributionHash(\n        DistributionInfo memory info\n    ) internal pure returns (bytes32 hash) {\n        assembly {\n            hash := keccak256(info, 0xe0)\n        }\n    }\n\n    function _getBalanceId(\n        TokenType tokenType,\n        address token\n    ) private pure returns (bytes32 balanceId) {\n        if (tokenType == TokenType.Native) {\n            return bytes32(uint256(uint160(NATIVE_TOKEN_ADDRESS)));\n        }\n        assert(tokenType == TokenType.Erc20);\n        return bytes32(uint256(uint160(token)));\n    }\n}"
    },
    {
      "filename": "contracts/party/PartyGovernance.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../distribution/ITokenDistributorParty.sol\";\nimport \"../distribution/ITokenDistributor.sol\";\nimport \"../utils/ReadOnlyDelegateCall.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../tokens/IERC20.sol\";\nimport \"../tokens/IERC1155.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../tokens/ERC1155Receiver.sol\";\nimport \"../utils/LibERC20Compat.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../proposals/IProposalExecutionEngine.sol\";\nimport \"../proposals/LibProposal.sol\";\nimport \"../proposals/ProposalStorage.sol\";\n\nimport \"./IPartyFactory.sol\";\n\n/// @notice Base contract for a Party encapsulating all governance functionality.\nabstract contract PartyGovernance is\n    ITokenDistributorParty,\n    ERC721Receiver,\n    ERC1155Receiver,\n    ProposalStorage,\n    Implementation,\n    ReadOnlyDelegateCall\n{\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibSafeCast for int192;\n    using LibSafeCast for uint96;\n\n    // States a proposal can be in.\n    enum ProposalStatus {\n        // The proposal does not exist.\n        Invalid,\n        // The proposal has been proposed (via `propose()`), has not been vetoed\n        // by a party host, and is within the voting window. Members can vote on\n        // the proposal and party hosts can veto the proposal.\n        Voting,\n        // The proposal has either exceeded its voting window without reaching\n        // `passThresholdBps` of votes or was vetoed by a party host.\n        Defeated,\n        // The proposal reached at least `passThresholdBps` of votes but is still\n        // waiting for `executionDelay` to pass before it can be executed. Members\n        // can continue to vote on the proposal and party hosts can veto at this time.\n        Passed,\n        // Same as `Passed` but now `executionDelay` has been satisfied. Any member\n        // may execute the proposal via `execute()`, unless `maxExecutableTime`\n        // has arrived.\n        Ready,\n        // The proposal has been executed at least once but"
    }
  ]
}