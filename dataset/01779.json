{
  "Title": "3S-LENFT-N20 protocol/VotingEscrow.sol: duplicated requirement",
  "Content": "#### Description\nThe current implementation of the VotingEscrow has the [following function](https://github.com/leNFT/contracts/blob/master/contracts/protocol/VotingEscrow.sol#L323-L335):\n\n```solidity\nfunction getLockHistoryPoint(uint256 tokenId,uint256 index) public view returns (DataTypes.Point memory) {\nrequire(index < _lockHistory[tokenId].length, \"VE:GLHP:INDEX_TOO_HIGH\");\nreturn _lockHistory[tokenId][index];\n}\n```\nHere, the ` require(index < _lockHistory[tokenId].length, \"VE:GLHP:INDEX_TOO_HIGH\");` isn't necessary since solidity automatically adds this check by default when accessing an array element (at the moment this check is being run twice)\n\n#### Recommendation\nRemove line 333, `require(index < _lockHistory[tokenId].length, \"VE:GLHP:INDEX_TOO_HIGH\");`",
  "Impact": "GAS",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/protocol/VotingEscrow.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {Base64} from \"@openzeppelin/contracts/utils/Base64.sol\";\nimport {SafeCast} from \"../libraries/utils/SafeCast.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IAddressProvider} from \"../interfaces/IAddressProvider.sol\";\nimport {CountersUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {IGaugeController} from \"../interfaces/IGaugeController.sol\";\nimport {INativeToken} from \"../interfaces/INativeToken.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {ERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport {ERC721EnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport {PercentageMath} from \"../libraries/utils/PercentageMath.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title VotingEscrow\n/// @author leNFT\n/// @notice Manages the locking of LE tokens\n/// @dev Provides functionality for locking LE tokens for a specified period of time and is the center of the epoch logic\ncontract VotingEscrow is\n    IVotingEscrow,\n    ERC165Upgradeable,\n    ERC721EnumerableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    uint256 private constant MINLOCKTIME = 2 weeks;\n    uint256 private constant MAXLOCKTIME = 4 * 52 weeks;\n    uint256 private constant EPOCH_PERIOD = 1 weeks; // TESTNET: 1 day\n\n    IAddressProvider private immutable _addressProvider;\n    uint256 private _deployTimestamp;\n    // Locked balance for each lock\n    mapping(uint256 => DataTypes.LockedBalance) private _lockedBalance;\n    // Next claimable rebate epoch for each lock\n    mapping(uint256 => uint256) private _nextClaimableEpoch;\n    // History of actions for each lock\n    mapping(uint256 => DataTypes.Point[]) private _lockHistory;\n    // Epoch history of total weight\n    uint256[] private _totalWeightHistory;\n    // Epoch history of total token supply (used to compute locked ratio)\n    uint256[] private _totalSupplyHistory;\n    // Epoch history of total locked balance\n    uint256[] private _totalLockedHistory;\n    // Last checkpoint for the total weight\n    DataTypes.Point private _lastWeightCheckpoint;\n    // Total weight slope Changes per timestamp\n    mapping(uint256 => uint256) private _slopeChanges;\n    CountersUpgradeable.Counter private _tokenIdCounter;\n\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    modifier lockExists(uint256 lockId) {\n        _requireLockExists(lockId);\n        _;\n    }\n\n    modifier lockOwner(uint256 lockId) {\n        _requireLockOwner(lockId);\n        _;\n    }\n\n    modifier lockNotExpired(uint256 lockId) {\n        _requireLockNotExpired(lockId);\n        _;\n    }\n\n    modifier noFutureEpoch(uint256 epoch) {\n        _requireNoFutureEpoch(epoch);\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(IAddressProvider addressProvider) {\n        _addressProvider = addressProvider;\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the VotingEscrow contract.\n    function initialize() external initializer {\n        __ERC721_init(\"Vote Escrowed LE\", \"veLE\");\n        __ERC721Enumerable_init();\n        __ERC165_init();\n        __ReentrancyGuard_init();\n        _deployTimestamp = block.timestamp;\n        _totalWeightHistory.push(0);\n        _lastWeightCheckpoint = DataTypes.Point(\n            0,\n            0,\n            SafeCast.toUint40(block.timestamp)\n        );\n        _totalSupplyHistory.push(0);\n        _totalLockedHistory.push(0);\n    }\n\n    /// @notice Returns the length of an epoch period in seconds.\n    /// @return The length of an epoch period in seconds.\n    function getEpochPeriod() external pure override returns (uint256) {\n        return EPOCH_PERIOD;\n    }\n\n    /// @notice Returns the epoch number for a given timestamp.\n    /// @param timestamp The timestamp for which to retrieve the epoch number.\n    /// @return The epoch number.\n    function getEpoch(uint256 timestamp) public view returns (uint256) {\n        uint256 deployTimestamp = _deployTimestamp;\n        require(timestamp > deployTimestamp, \"VE:E:FUTURE_TIMESTAMP\");\n        return (timestamp / EPOCH_PERIOD) - (deployTimestamp / EPOCH_PERIOD);\n    }\n\n    /// @notice Returns the timestamp of the start of an epoch.\n    /// @param _epoch The epoch number for which to retrieve the start timestamp.\n    /// @return The start timestamp of the epoch.\n    function getEpochTimestamp(uint256 _epoch) public view returns (uint256) {\n        return (_deployTimestamp / EPOCH_PERIOD + _epoch) * EPOCH_PERIOD;\n    }\n\n    /// @notice Returns a token's encoded URI\n    /// @param tokenId The token ID for which to retrieve the URI.\n    /// @return The token's encoded URI.\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable)\n        lockExists(tokenId)\n        returns (string memory)\n    {\n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    Base64.encode(\n                        abi.encodePacked(\n                            \"{\",\n                            '\"name\": \"veLE Lock #',\n                            Strings.toString(tokenId),\n                            '\",',\n                            '\"description\": \"Vote Escrowed LE Lock\",',\n                            '\"image\": ',\n                            '\"data:image/svg+xml;base64,',\n                            Base64.encode(svg(tokenId)),\n                            '\",',\n                            '\"attributes\": [',\n                            string(\n                                abi.encodePacked(\n                                    '{ \"trait_type\": \"end\", \"value\": \"',\n                                    Strings.toString(\n                                        _lockedBalance[tokenId].end\n                                    ),\n                                    '\" },',\n                                    '{ \"trait_type\": \"weight\", \"value\": \"',\n                                    Strings.toString(getLockWeight(tokenId)),\n                                    '\" },',\n                                    '{ \"trait_type\": \"amount\", \"value\": \"',\n                                    Strings.toString(\n                                        _lockedBalance[tokenId].amount\n                                    ),\n                                    '\" }'\n                                )\n                            ),\n                            \"]\",\n                            \"}\"\n                        )\n                    )\n                )\n            );\n    }\n\n    /// @notice Returns a token's encoded SVG\n    /// @param tokenId The token ID for which to retrieve the SVG.\n    /// @return The token's encoded SVG.\n    function svg(\n        uint256 tokenId\n    ) public view lockExists(tokenId) returns (bytes memory) {\n        return\n            abi.encodePacked(\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 400 400\" style=\"width:100%;background:#eaeaea;fill:black;font-family:monospace\">',\n                '<text x=\"50%\" y=\"30%\" text-anchor=\"middle\" font-size=\"18\">',\n                \"veLE Lock #\",\n                Strings.toString(tokenId),\n                \"</text>\",\n                '<text x=\"50%\" y=\"50%\" text-anchor=\"middle\" font-size=\"14\">',\n                Strings.toString(_lockedBalance[tokenId].amount),\n                \" LE\",\n                \"</text>\",\n                \"</svg>\"\n            );\n    }\n\n    /// @notice Updates the total weight history array and checkpoint with the current weight.\n    /// @dev This function will break if it is not called for 128 epochs.\n    function writeTotalWeightHistory() public {\n        // Update last saved weight checkpoint and record weight for epochs\n        uint256 epochTimestampPointer = getEpochTimestamp(\n            _totalWeightHistory.length\n        );\n        for (uint256 i = 0; i < 2 ** 7; i++) {\n            if (epochTimestampPointer > block.timestamp) {\n                break;\n            }\n\n            // Save epoch total weight\n            uint256 epochTotalWeight = _lastWeightCheckpoint.bias -\n                _lastWeightCheckpoint.slope *\n                (epochTimestampPointer - _lastWeightCheckpoint.timestamp);\n            _totalWeightHistory.push(epochTotalWeight);\n\n            // Update last weight checkpoint\n            _lastWeightCheckpoint.bias = SafeCast.toUint128(epochTotalWeight);\n            _lastWeightCheckpoint.timestamp = SafeCast.toUint40(\n                epochTimestampPointer\n            );\n            _lastWeightCheckpoint.slope -= SafeCast.toUint128(\n                _slopeChanges[epochTimestampPointer]\n            );\n\n            // Get native token address inside loop because most transactions will break on the first iteration\n            address nativeToken = _addressProvider.getNativeToken();\n            // Update total locked and total supply histories\n            // Will always be accurate since its called eveytime there's a change in total or locked supply\n            _totalLockedHistory.push(\n                IERC20Upgradeable(nativeToken).balanceOf(address(this))\n            );\n            _totalSupplyHistory.push(\n                IERC20Upgradeable(nativeToken).totalSupply()\n            );\n\n            //Increase epoch timestamp\n            epochTimestampPointer += EPOCH_PERIOD;\n        }\n    }\n\n    /// @notice Simulates a lock's weight for a given amount of tokens and unlock time.\n    /// @param amount The amount of tokens to be locked.\n    /// @param end The unlock time for the lock operation.\n    /// @return The weight of the lock.\n    function simulateLock(\n        uint256 amount,\n        uint256 end\n    ) external view returns (uint256) {\n        // Round the locktime to whole epochs\n        uint256 roundedUnlockTime = (end / EPOCH_PERIOD) * EPOCH_PERIOD;\n\n        require(\n            roundedUnlockTime >= MINLOCKTIME + block.timestamp,\n            \"VE:SL:LOCKTIME_TOO_LOW\"\n        );\n        require(\n            roundedUnlockTime <= MAXLOCKTIME + block.timestamp,\n            \"VE:SL:LOCKTIME_TOO_HIGH\"\n        );\n\n        return (amount * (roundedUnlockTime - block.timestamp)) / MAXLOCKTIME;\n    }\n\n    /// @notice Updates the global tracking variables and the user's history of locked balances.\n    /// @param tokenId The veLock token id whose balance is being updated.\n    /// @param oldBalance The user's previous locked balance.\n    /// @param newBalance The user's new locked balance.\n    function _checkpoint(\n        uint256 tokenId,\n        DataTypes.LockedBalance memory oldBalance,\n        DataTypes.LockedBalance memory newBalance\n    ) internal {\n        DataTypes.Point memory oldPoint;\n        DataTypes.Point memory newPoint;\n\n        // Bring epoch records into the present\n        writeTotalWeightHistory();\n\n        // Calculate slopes and bias\n        if (oldBalance.end > block.timestamp && oldBalance.amount > 0) {\n            oldPoint.slope = SafeCast.toUint128(\n                oldBalance.amount / MAXLOCKTIME\n            );\n            oldPoint.bias = SafeCast.toUint128(\n                oldPoint.slope * (oldBalance.end - block.timestamp)\n            );\n        }\n        if (newBalance.end > block.timestamp && newBalance.amount > 0) {\n            newPoint.slope = SafeCast.toUint128(\n                newBalance.amount / MAXLOCKTIME\n            );\n            newPoint.bias = SafeCast.toUint128(\n                newPoint.slope * (newBalance.end - block.timestamp)\n            );\n            newPoint.timestamp = SafeCast.toUint40(block.timestamp);\n        }\n\n        // Update last saved total weight\n        _lastWeightCheckpoint.bias = SafeCast.toUint128(\n            _lastWeightCheckpoint.bias -\n                _lastWeightCheckpoint.slope *\n                (block.timestamp - _lastWeightCheckpoint.timestamp) +\n                newPoint.bias -\n                oldPoint.bias\n        );\n        _lastWeightCheckpoint.slope = SafeCast.toUint128(\n            _lastWeightCheckpoint.slope + newPoint.slope - oldPoint.slope\n        );\n        _lastWeightCheckpoint.timestamp = SafeCast.toUint40(block.timestamp);\n\n        // Read and update slope changes in accordance\n        if (oldBalance.end > block.timestamp) {\n            // Cancel old slope change\n            _slopeChanges[oldBalance.end] -= oldPoint.slope;\n        }\n\n        if (newBalance.end > block.timestamp) {\n            _slopeChanges[newBalance.end] += newPoint.slope;\n        }\n\n        // Update user history\n        _lockHistory[tokenId].push(newPoint);\n    }\n\n    /// @notice Returns the length of the history array for the specified lock.\n    /// @param tokenId The token id of the lock for which to retrieve the history length.\n    /// @return The length of the user's history array.\n    function getLockHistoryLength(\n        uint256 tokenId\n    ) public view override lockExists(tokenId) returns (uint256) {\n        return _lockHistory[tokenId].length;\n    }\n\n    /// @notice Returns the lock's history point at a given index.\n    /// @param tokenId The token id of the lock for which to retrieve the history point.\n    /// @param index The index of the history point to retrieve.\n    /// @return The user's history point at the given index.\n    function getLockHistoryPoint(\n        uint256 tokenId,\n        uint256 index\n    )\n        public\n        view\n        override\n        lockExists(tokenId)\n        returns (DataTypes.Point memory)\n    {\n        return _lockHistory[tokenId][index];\n    }\n\n    /// @notice Returns the ratio of locked tokens for a certain epoch\n    /// @dev Multiplied by 10000 (e.g. 50% = 5000)\n    /// @param _epoch The epoch number for which to retrieve the ratio.\n    /// @return The ratio of locked tokens at the given epoch.\n    function getLockedRatioAt(\n        uint256 _epoch\n    ) external override noFutureEpoch(_epoch) returns (uint256) {\n        // Update total weight history\n        writeTotalWeightHistory();\n\n        if (_totalSupplyHistory[_epoch] == 0) {\n            return 0;\n        }\n\n        return\n            (_totalLockedHistory[_epoch] * PercentageMath.PERCENTAGE_FACTOR) /\n            _totalSupplyHistory[_epoch];\n    }\n\n    /// @notice Returns the total weight of locked tokens at a given epoch.\n    /// @param _epoch The epoch number for which to retrieve the total weight.\n    /// @return The total weight of locked tokens at the given epoch.\n    function getTotalWeightAt(\n        uint256 _epoch\n    ) external noFutureEpoch(_epoch) returns (uint256) {\n        // Update total weight history\n        writeTotalWeightHistory();\n\n        return _totalWeightHistory[_epoch];\n    }\n\n    /// @notice Returns the total weight for all the locks at the current block timestamp\n    /// @return The total weight for all the locks.\n    function getTotalWeight() public returns (uint256) {\n        // Update total weight history\n        writeTotalWeightHistory();\n        return\n            _lastWeightCheckpoint.bias -\n            _lastWeightCheckpoint.slope *\n            (block.timestamp - _lastWeightCheckpoint.timestamp);\n    }\n\n    /// @notice Returns the weight of locked tokens for a given lock.\n    /// @param tokenId The tokenid for which to retrieve the locked balance weight.\n    /// @return The weight of locked tokens for the given account.\n    function getLockWeight(\n        uint256 tokenId\n    ) public view lockExists(tokenId) returns (uint256) {\n        // If the locked token end time has passed\n        if (_lockedBalance[tokenId].end < block.timestamp) {\n            return 0;\n        }\n        DataTypes.Point memory lastLockPoint = _lockHistory[tokenId][\n            _lockHistory[tokenId].length - 1\n        ];\n\n        return\n            lastLockPoint.bias -\n            lastLockPoint.slope *\n            (block.timestamp - lastLockPoint.timestamp);\n    }\n\n    /// @notice Returns the weight of locked tokens for a given account.\n    /// @param user The address for which to retrieve the locked balance weight.\n    /// @return weight The weight of locked tokens for the given account.\n    function getUserWeight(\n        address user\n    ) external view returns (uint256 weight) {\n        uint256 length = balanceOf(user);\n        for (uint256 i = 0; i < length; i++) {\n            weight += getLockWeight(tokenOfOwnerByIndex(user, i));\n        }\n    }\n\n    /// @notice Locks tokens into the voting escrow contract for a specified amount of time.\n    /// @param receiver The address that will receive the locked tokens.\n    /// @param amount The amount of tokens to be locked.\n    /// @param unlockTime The timestamp at which the tokens will be unlocked.\n    /// @dev Calls a checkpoint event\n    function createLock(\n        address receiver,\n        uint256 amount,\n        uint256 unlockTime\n    ) external nonReentrant {\n        // Round the locktime to whole epochs\n        uint256 roundedUnlockTime = (unlockTime / EPOCH_PERIOD) * EPOCH_PERIOD;\n\n        require(amount > 0, \"VE:CL:AMOUNT_ZERO\");\n\n        require(\n            roundedUnlockTime >= MINLOCKTIME + block.timestamp,\n            \"VE:CL:LOCKTIME_TOO_LOW\"\n        );\n        require(\n            roundedUnlockTime <= MAXLOCKTIME + block.timestamp,\n            \"VE:CL:LOCKTIME_TOO_HIGH\"\n        );\n\n        // Mint a veNFT to represent the lock and increase the token id counter\n        uint256 tokenId = _tokenIdCounter.current();\n        _tokenIdCounter.increment();\n\n        // Setup the next claimable rebate epoch\n        _nextClaimableEpoch[tokenId] = getEpoch(block.timestamp) + 1;\n\n        // Init the locked balance state variable\n        _lockedBalance[tokenId] = DataTypes.LockedBalance(\n            SafeCast.toUint128(amount),\n            SafeCast.toUint40(roundedUnlockTime)\n        );\n\n        // Call a checkpoint and update global tracking vars (the old locked balance will be 0 since this is a new lock)\n        _checkpoint(\n            tokenId,\n            DataTypes.LockedBalance(0, 0),\n            DataTypes.LockedBalance(\n                SafeCast.toUint128(amount),\n                SafeCast.toUint40(roundedUnlockTime)\n            )\n        );\n\n        // Transfer the locked tokens from the caller to this contract\n        IERC20Upgradeable(_addressProvider.getNativeToken()).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Mint the veNFT\n        _safeMint(receiver, tokenId);\n\n        emit CreateLock(receiver, tokenId, amount, roundedUnlockTime);\n    }\n\n    /// @notice Increases the locked balance of the caller by the given amount and performs a checkpoint\n    /// @param tokenId The token id of the lock to increase the amount of\n    /// @param amount The amount to increase the locked balance by\n    /// @dev Requires the caller to have an active lock on their balance\n    /// @dev Transfers the native token from the caller to this contract\n    /// @dev Calls a checkpoint event\n    function increaseAmount(\n        uint256 tokenId,\n        uint256 amount\n    ) external nonReentrant lockOwner(tokenId) lockNotExpired(tokenId) {\n        require(amount > 0, \"VE:IA:AMOUNT_ZERO\");\n        // Claim any existing rebates\n        claimRebates(tokenId);\n\n        // Save oldLocked and update the locked balance\n        DataTypes.LockedBalance memory oldLocked = _lockedBalance[tokenId];\n        _lockedBalance[tokenId].amount += SafeCast.toUint128(amount);\n\n        // Call a checkpoint and update global tracking vars\n        _checkpoint(tokenId, oldLocked, _lockedBalance[tokenId]);\n\n        IERC20Upgradeable(_addressProvider.getNativeToken()).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        emit IncreaseAmount(tokenId, amount);\n    }\n\n    /// @notice Increases the unlock time of the caller's lock to the given time and performs a checkpoint\n    /// @param tokenId The token id of the lock to increase the unlock time of\n    /// @param newUnlockTime The new unlock time to set\n    /// @dev Requires the caller to have an active lock on their balance\n    /// @dev Requires the new unlock time to be greater than or equal to the current unlock time\n    /// @dev Requires the new unlock time to be less than or equal to the maximum lock time\n    /// @dev Calls a checkpoint event\n    function increaseUnlockTime(\n        uint256 tokenId,\n        uint256 newUnlockTime\n    ) external nonReentrant lockOwner(tokenId) lockNotExpired(tokenId) {\n        // Round the locktime to whole epochs\n        uint256 roundedUnlocktime = (newUnlockTime / EPOCH_PERIOD) *\n            EPOCH_PERIOD;\n\n        require(\n            roundedUnlocktime > _lockedBalance[tokenId].end,\n            \"VE:IUT:TIME_NOT_INCREASED\"\n        );\n\n        require(\n            roundedUnlocktime <= MAXLOCKTIME + block.timestamp,\n            \"VE:IUT:LOCKTIME_TOO_HIGH\"\n        );\n\n        // Claim any existing rebates so they are not lost\n        claimRebates(tokenId);\n\n        // Cache oldLocked and update the locked balance\n        DataTypes.LockedBalance memory oldLocked = _lockedBalance[tokenId];\n        _lockedBalance[tokenId].end = SafeCast.toUint40(roundedUnlocktime);\n\n        // Call a checkpoint and update global tracking vars\n        _checkpoint(tokenId, oldLocked, _lockedBalance[tokenId]);\n\n        emit IncreaseUnlockTime(tokenId, roundedUnlocktime);\n    }\n\n    /// @notice Withdraws the locked balance of the caller and performs a checkpoint\n    /// @param tokenId The token id of the lock to withdraw from\n    /// @dev Requires the caller to have a non-zero locked balance and an expired lock time\n    /// @dev Requires the caller to have no active votes in the gauge controller\n    /// @dev Transfers the native token from this contract to the caller\n    /// @dev Calls a checkpoint event\n    /// @dev User needs to claim fees before withdrawing or will lose them\n    function withdraw(uint256 tokenId) external lockOwner(tokenId) {\n        require(_lockedBalance[tokenId].amount > 0, \"VE:W:ZERO_BALANCE\");\n        require(\n            block.timestamp > _lockedBalance[tokenId].end,\n            \"VE:W:LOCK_NOT_EXPIRED\"\n        );\n\n        // Make sure the tokenId has no active votes\n        require(\n            IGaugeController(_addressProvider.getGaugeController())\n                .getLockVoteRatio(tokenId) == 0,\n            \"VE:W:HAS_ACTIVE_VOTES\"\n        );\n\n        // Claim any existing rebates so they are not lost\n        claimRebates(tokenId);\n\n        // Save oldLocked and update the locked balance\n        DataTypes.LockedBalance memory oldLocked = _lockedBalance[tokenId];\n        delete _lockedBalance[tokenId];\n\n        // Call a checkpoint and update global tracking vars\n        _checkpoint(tokenId, oldLocked, _lockedBalance[tokenId]);\n\n        // Send locked amount back to user\n        IERC20Upgradeable(_addressProvider.getNativeToken()).safeTransfer(\n            msg.sender,\n            oldLocked.amount\n        );\n\n        // Burn the veNFT\n        _burn(tokenId);\n\n        emit Withdraw(tokenId);\n    }\n\n    /// @notice Claims all available rebates for the given token id\n    /// @param tokenId The token id of the lock to claim rebates for\n    /// @return amountToClaim The amount of rebates claimed\n    function claimRebates(\n        uint256 tokenId\n    ) public lockOwner(tokenId) returns (uint256 amountToClaim) {\n        // Update total weight tracking vars\n        writeTotalWeightHistory();\n\n        // Claim all the available rebates for the lock\n        uint256 maxEpochRebates;\n        uint256 nextClaimableEpoch = _nextClaimableEpoch[tokenId];\n        uint256 currentEpoch = getEpoch(block.timestamp);\n\n        // Claim a maximum of 50 epochs at a time\n        for (uint i = 0; i < 50 && nextClaimableEpoch < currentEpoch; ) {\n            if (\n                getEpochTimestamp(nextClaimableEpoch) >\n                _lockedBalance[tokenId].end\n            ) {\n                break;\n            }\n\n            if (_totalSupplyHistory[nextClaimableEpoch] > 0) {\n                // Get the full amount of rebates to claim for the epoch as if everyone was locked at max locktime\n                maxEpochRebates =\n                    (_totalLockedHistory[nextClaimableEpoch] *\n                        IGaugeController(_addressProvider.getGaugeController())\n                            .getEpochRewards(nextClaimableEpoch)) /\n                    _totalSupplyHistory[nextClaimableEpoch];\n\n                // Get the rebate share for this specific lock\n                // It will depend on the size and duration of the lock\n                amountToClaim +=\n                    (maxEpochRebates *\n                        _lockedBalance[tokenId].amount *\n                        (_lockedBalance[tokenId].end -\n                            getEpochTimestamp(nextClaimableEpoch))) /\n                    (_totalLockedHistory[nextClaimableEpoch] * MAXLOCKTIME);\n            }\n\n            // Increase next claimable epoch\n            nextClaimableEpoch++;\n\n            // Increase the counter\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Update the next claimable epoch\n        _nextClaimableEpoch[tokenId] = nextClaimableEpoch;\n\n        // Mint the rebates to the user's wallet\n        if (amountToClaim > 0) {\n            INativeToken(_addressProvider.getNativeToken()).mintRebates(\n                msg.sender,\n                amountToClaim\n            );\n\n            emit ClaimRebates(msg.sender, tokenId, amountToClaim);\n        }\n    }\n\n    /// @notice Claims all available rebates for the given token ids\n    /// @param tokensIds The token ids of the locks to claim rebates for\n    /// @return amountToClaim The amount of rebates claimed\n    function claimRebatesBatch(\n        uint256[] calldata tokensIds\n    ) external returns (uint256 amountToClaim) {\n        for (uint i = 0; i < tokensIds.length; i++) {\n            amountToClaim += claimRebates(tokensIds[i]);\n        }\n    }\n\n    /// @notice Returns the details for a single lock\n    /// @param tokenId The token id of the lock to get the locked balance of and end time of\n    /// @return The locked object of the user\n    function getLock(\n        uint256 tokenId\n    )\n        external\n        view\n        lockExists(tokenId)\n        returns (DataTypes.LockedBalance memory)\n    {\n        return _lockedBalance[tokenId];\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 batchSize\n    ) internal override(ERC721EnumerableUpgradeable) {\n        ERC721EnumerableUpgradeable._beforeTokenTransfer(\n            from,\n            to,\n            tokenId,\n            batchSize\n        );\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(ERC721EnumerableUpgradeable, ERC165Upgradeable)\n        returns (bool)\n    {\n        return\n            ERC721EnumerableUpgradeable.supportsInterface(interfaceId) ||\n            ERC165Upgradeable.supportsInterface(interfaceId);\n    }\n\n    function _requireLockExists(uint256 tokenId) internal view {\n        require(_exists(tokenId), \"VE:LOCK_NOT_FOUND\");\n    }\n\n    function _requireLockOwner(uint256 tokenId) internal view {\n        require(_ownerOf(tokenId) == msg.sender, \"VE:NOT_OWNER\");\n    }\n\n    function _requireLockNotExpired(uint256 tokenId) internal view {\n        require(\n            _lockedBalance[tokenId].end > block.timestamp,\n            \"VE:LOCK_EXPIRED\"\n        );\n    }\n\n    function _requireNoFutureEpoch(uint256 epoch) internal view {\n        require(epoch <= getEpoch(block.timestamp), \"VE:FUTURE_EPOCH\");\n    }\n}"
    }
  ]
}