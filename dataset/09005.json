{
  "Title": "[H-06] Attacker can block LayerZero channel",
  "Content": "_Submitted by Ruhum_\n\nAccording to the LayerZero docs, the default behavior is that when a transaction on the destination application fails, the channel between the src and dst app is blocked. Before any new transactions can be executed, the failed transaction has to be retried until it succeeds.\n\nSee <https://layerzero.gitbook.io/docs/faq/messaging-properties#message-ordering> & <https://layerzero.gitbook.io/docs/guides/advanced/nonblockinglzapp>\n\nSo an attacker is able to initiate a transaction they know will fail to block the channel between FTM and Optimism. The RedemptionSender & Receiver won't be usable anymore.\n\n### Proof of Concept\n\nThe RedemptionReceiver contract doesn't implement the non-blocking approach as seen here:<br>\n<https://github.com/code-423n4/2022-05-velodrome/blob/main/contracts/contracts/redeem/RedemptionReceiver.sol#L72-L105>\n\nAn example implementation of the non-blocking approach by LayerZero:<br>\n<https://github.com/LayerZero-Labs/solidity-examples/blob/main/contracts/lzApp/NonblockingLzApp.sol>\n\n### Recommended Mitigation Steps\n\nUse the non-blocking approach as described [here](https://layerzero.gitbook.io/docs/guides/advanced/nonblockinglzapp).\n\n**[pooltypes (Velodrome) disagreed with severity](https://github.com/code-423n4/2022-05-velodrome-findings/issues/83)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/83#issuecomment-1169373375):**\n > @pooltypes Can anyone send a message or would they need to be whitelisted?\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/83#issuecomment-1171810267):**\n > If anyone can call and deny, the contract is not suited to handle exceptions and doesn't implement the `forceReceive` function, meaning the channel can be griefed and I don't believe there's a way to remedy.\n> \n> The contract needs to implement [`forceResumeReceive` ](https://github.com/LayerZero-Labs/solidity-examples/blob/d38c679863d84cf58bc7a9761ed300a0be9b3bd1/contracts/lzApp/LzApp.sol#L63) to allow to remove malicious messages that may be received.\n> \n> I still am unsure if anyone can send a malicious message or if they need to be approved. If only the admin can this is a Medium Severity. If anyone can, this is a High Severity finding.\n>\n > From the documentation it seems like anyone can call the function:<br>\n> https://layerzero.gitbook.io/docs/guides/master/how-to-send-a-message\n\n**[Alex the Entreprenerd (judge) increased severity to High and commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/83#issuecomment-1175431598):**\n > With the information I currently have, it seems like the channel can be setup to receive messages only by the specified contract, however for multiple reasons, the message sent can cause a revert, and in lack of a \"nonblocking\" architecture, the messages can get stuck indefinitely.\n> \n> However, the implementation under scope has none of these defenses, it seems like the contact under scope can be denied functionality by any caller that builds their own LZApp.\n> \n> See [example](https://github.com/LayerZero-Labs/solidity-examples/blob/e46a95ce93347aa65680bef288e206af0e5a8917/contracts/lzApp/LzApp.sol#L28) of how to prevent untrusted callers.\n> \n> Because of that, the message queue can be filled with blocking messages that cannot be removed.\n> \n> Because the contract under scope also has no way of re-setting the queue, I have reason to believe that any attack can permanently brick the receiver.\n> \n> For these reasons, I believe High Severity to be more appropriate.\n\n**[ethzoomer (Velodrome) commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/83#issuecomment-1178251450):**\n > At this point in time we've already completed all of the redemptions.\n> \n> Is it possible to send a message from the contract other than what sender sends? lz's msg queues are per src addr. https://layerzero.gitbook.io/docs/faq/messaging-properties\n> \"STORED message will block the delivery of any future message from srcUA to all dstUA on the same destination chain and can be retried until the message becomes SUCCESS\"\n> The only way that can get gummed up is if redemption's over, right?\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/83#issuecomment-1178299835):**\n > My understanding is any sender can block the queue as the receiver will revert.\n> \n> That said if redemption is over, there's no loss beside the risk of burning funds from the FTM side.\n\n\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-05-velodrome",
  "Code": [
    {
      "filename": "contracts/contracts/redeem/RedemptionReceiver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"LayerZero/interfaces/ILayerZeroEndpoint.sol\";\nimport \"LayerZero/interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IVelo.sol\";\n\n/// @notice Part 2 of 2 in the WeVE (FTM) -> USDC + VELO (OP) redemption process\n/// This contract is responsible for receiving the LZ message and distributing USDC + VELO\ncontract RedemptionReceiver is ILayerZeroReceiver {\n    IERC20 public immutable USDC;\n    IVelo public immutable VELO;\n    uint16 public immutable fantomChainId; // 12 for FTM, 10012 for FTM testnet\n    address public immutable endpoint;\n    address public immutable deployer;\n\n    constructor(\n        address _usdc,\n        address _velo,\n        uint16 _fantomChainId,\n        address _endpoint\n    ) {\n        require(_fantomChainId == 12 || _fantomChainId == 10012, \"CHAIN_ID_NOT_FTM\");\n        USDC = IERC20(_usdc);\n        VELO = IVelo(_velo);\n        fantomChainId = _fantomChainId;\n        endpoint = _endpoint;\n        deployer = msg.sender;\n    }\n\n    address public fantomSender;\n    uint256 public eligibleWEVE;\n    uint256 public redeemableUSDC;\n    uint256 public redeemableVELO;\n\n    function initializeReceiverWith(\n        address _fantomSender,\n        uint256 _eligibleWEVE,\n        uint256 _redeemableUSDC,\n        uint256 _redeemableVELO\n    ) external {\n        require(msg.sender == deployer, \"ONLY_DEPLOYER\");\n        require(fantomSender == address(0), \"ALREADY_INITIALIZED\");\n        require(\n            USDC.transferFrom(msg.sender, address(this), _redeemableUSDC),\n            \"USDC_TRANSFER_FAILED\"\n        );\n        require(\n            VELO.mintToRedemptionReceiver(_redeemableVELO),\n            \"VELO_MINT_FAILED\"\n        );\n        fantomSender = _fantomSender;\n        eligibleWEVE = _eligibleWEVE;\n        redeemableUSDC = _redeemableUSDC;\n        redeemableVELO = _redeemableVELO;\n    }\n\n    uint256 public redeemedWEVE;\n\n    function previewRedeem(uint256 amountWEVE)\n        public\n        view\n        returns (uint256 shareOfUSDC, uint256 shareOfVELO)\n    {\n        // pro rata USDC\n        shareOfUSDC = (amountWEVE * redeemableUSDC) / eligibleWEVE;\n        // pro rata VELO\n        shareOfVELO = (amountWEVE * redeemableVELO) / eligibleWEVE;\n    }\n\n    function lzReceive(\n        uint16 srcChainId,\n        bytes memory srcAddress,\n        uint64,\n        bytes memory payload\n    ) external override {\n        require(fantomSender != address(0), \"NOT_INITIALIZED\");\n        require(\n            msg.sender == endpoint &&\n                srcChainId == fantomChainId &&\n                addressFromPackedBytes(srcAddress) == fantomSender,\n            \"UNAUTHORIZED_CALLER\"\n        );\n\n        (address redemptionAddress, uint256 amountWEVE) = abi.decode(\n            payload,\n            (address, uint256)\n        );\n\n        require(\n            (redeemedWEVE += amountWEVE) <= eligibleWEVE,\n            \"cannot redeem more than eligible\"\n        );\n        (uint256 shareOfUSDC, uint256 shareOfVELO) = previewRedeem(amountWEVE);\n\n        require(\n            USDC.transfer(redemptionAddress, shareOfUSDC),\n            \"USDC_TRANSFER_FAILED\"\n        );\n        require(\n            VELO.transfer(redemptionAddress, shareOfVELO),\n            \"VELO_TRANSFER_FAILED\"\n        );\n    }\n\n    function addressFromPackedBytes(bytes memory toAddressBytes)\n        public\n        pure\n        returns (address toAddress)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            toAddress := mload(add(toAddressBytes, 20))\n        }\n    }\n}"
    },
    {
      "filename": "contracts/lzApp/LzApp.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroUserApplicationConfig.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\n\n/*\n * a generic LzReceiver implementation\n */\nabstract contract LzApp is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    ILayerZeroEndpoint public immutable lzEndpoint;\n\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n\n    event SetTrustedRemote(uint16 _srcChainId, bytes _srcAddress);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), \"LzApp: invalid endpoint caller\");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && keccak256(_srcAddress) == keccak256(trustedRemote), \"LzApp: invalid source sending contract\");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, \"LzApp: destination chain is not a trusted source\");\n        lzEndpoint.send{value: msg.value}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // allow owner to set it multiple times.\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}"
    },
    {
      "filename": "contracts/lzApp/LzApp.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroUserApplicationConfig.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\n\n/*\n * a generic LzReceiver implementation\n */\nabstract contract LzApp is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    ILayerZeroEndpoint public immutable lzEndpoint;\n\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n\n    event SetTrustedRemote(uint16 _srcChainId, bytes _srcAddress);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), \"LzApp: invalid endpoint caller\");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && keccak256(_srcAddress) == keccak256(trustedRemote), \"LzApp: invalid source sending contract\");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, \"LzApp: destination chain is not a trusted source\");\n        lzEndpoint.send{value: msg.value}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // allow owner to set it multiple times.\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}"
    }
  ]
}