{
  "Title": "[M-01] TransactionValidator checks intrinsic costs against wrong value",
  "Content": "\nAn incorrect check allows an ``L1->L2`` transaction to be sent that does not cover the sum of overhead and intrinsic costs for the operator.\n\n### Proof of Concept\n\nThe `gasLimit` required for a transaction consists of (see [docs](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/zkSync%20fee%20model.md#determining-base_fee)):\n\n`{totalGasLimit} = {overhead + actualGasLimit} = {overhead + (intrinisicCosts + executionCosts)}`\n\nThe function `TransactionValidator.getMinimalPriorityTransactionGasLimit` calculates the intrinsic costs that will be incurred for the processing of a transaction on L2. The calculated value is checked in `TransactionValidator.validateL1ToL2Transaction` like this:\n\n```js\nrequire(\n    getMinimalPriorityTransactionGasLimit(\n        _encoded.length,\n        _transaction.factoryDeps.length,\n        _transaction.gasPerPubdataByteLimit\n    ) <= _transaction.gasLimit, \n    \"up\"\n);\n```\n\nThe issue is that `_transaction.gasLimit` is the total `gasLimit` including the overhead for the operator. The overhead costs are already checked before that in `TransactionValidator.getTransactionBodyGasLimit`\n\n```js\nfunction getTransactionBodyGasLimit(\n    uint256 _totalGasLimit,\n    uint256 _gasPricePerPubdata,\n    uint256 _encodingLength\n) internal pure returns (uint256 txBodyGasLimit) {\n    uint256 overhead = getOverheadForTransaction(_totalGasLimit, _gasPricePerPubdata, _encodingLength);\n\n    require(_totalGasLimit >= overhead, \"my\"); // provided gas limit doesn't cover transaction overhead\n    unchecked {\n        txBodyGasLimit = _totalGasLimit - overhead;\n    }\n}\n```\n\nThe value returned by this function is the `actualGasLimit` (see formula above) that will be available for the processing of the transaction and which should be used to check if the intrinsic costs are covered.\n\nIn the current implementation the `totalGasLimit` is checked twice if it's greater than overhead and intrinsic costs (separately, not the sum). The bootloader does things correctly by subtracting the overhead from the `totalGasLimit` first and then checking if the rest covers the intrinsic costs (also called \"preparation\" costs):\n\n```js\nfunction processL1Tx(...){\n    ...\n    //gasLimitForTx is total - overhead (and some other intrinsic costs)\n    let gasLimitForTx, reservedGas := getGasLimitForTx(...)\n    ...\n    canonicalL1TxHash, gasUsedOnPreparation := l1TxPreparation(txDataOffset)\n    ...\n}   if gt(gasLimitForTx, gasUsedOnPreparation) {\n        ...\n        potentialRefund, success := getExecuteL1TxAndGetRefund(txDataOffset, sub(gasLimitForTx, gasUsedOnPreparation))\n```\n\nThat means users will not be able to execute transactions for cheap. However, since the ``L1->L2`` transaction have to be processed (due to the way the priority queue works), it would be possible to grief the operator by submitting transactions that only cover the following:\n\n`{max(overhead, intrinsicCosts)}`\n\nThose transactions would not have enough gas to be executed on L2, but the overhead and intrinsic costs would still be incurred.\n\n### Recommended Mitigation Steps\n\nIn `TransactionValidator.validateL1ToL2Transaction` change the check like this:\n\n```js\nuint256 l2GasForTxBody = getTransactionBodyGasLimit(...)\n...\nrequire(\n    getMinimalPriorityTransactionGasLimit(\n        _encoded.length,\n        _transaction.factoryDeps.length,\n        _transaction.gasPerPubdataByteLimit\n    ) <= l2GasForTxBody, // <---\n    \"up\"\n);\n```\n\n`l2GasForTxBody` is what remains after subtracting the overhead from the `totalGasLimit`.\n\n**[miladpiri (zkSync) confirmed and commented via duplicate issue #975](https://github.com/code-423n4/2023-10-zksync-findings/issues/975#issuecomment-1794728882):**\n > While the describe is large & complex, it is about wrong validation of transactions have enough gas.\n>\n> Explanation: `getMinimalPriorityTransactionGasLimit` calculates how much gas the priority tx will minimally consume (intrinsic costs + some other costs like hashing it, etc). However, `_transaction.gasLimit` besides those costs also contains the overhead (for batch verification, etc) costs. Basically this means that if `getMinimalPriorityTransactionGasLimit = _transaction.gasLimit`, then the `_transaction.gasLimit`, once it pays for the overhead, may pay little-to-nothing for the processing of this transaction (it will be marked as failed, but the operator will have to bear the costs anyway as he must process, hash L1 transactions etc).\n\n**[Alex the Entreprenerd (judge) commented via duplicate issue #975](https://github.com/code-423n4/2023-10-zksync-findings/issues/975#issuecomment-1830079718):**\n> From the Zksync side, their job is not to ensure that the tx will not run OOG, as that cannot be guaranteed. Their job is to ensure that the \"cost of processing\" is lower than the \"cost paid\".\n> \n> I believe the check meets those requirements, in that, zkSync is defending itself against spam. This however, seems to create scenarios where a normal user could have a tx validated as functioning which would end up reverting on L2.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "docs/Smart%20contract%20Section/zkSync%20fee%20model.md",
      "content": "# zkSync fee model\n\nThis document will assume that you already know how gas & fees work on Ethereum.\n\nOn Ethereum, all the computational, as well as storage costs, are represented via one unit: gas. Each operation costs a certain amount of gas, which is generally constant (though it may change during [upgrades](https://blog.ethereum.org/2021/03/08/ethereum-berlin-upgrade-announcement)).\n\nzkSync as well as other L2s have the issue which does not allow to adopt the same model as the one for Ethereum so easily: the main reason is the requirement for publishing of the pubdata on Ethereum. This means that prices for L2 transactions will depend on the volatile L1 gas prices and can not be simply hardcoded.\n\n# High-level description\n\nzkSync, being a zkRollup is required to prove every operation with zero knowledge proofs. That comes with a few nuances.\n\n## `gas_per_pubdata_limit`\n\nAs already mentioned, the transactions on zkSync depend on volatile L1 gas costs to publish the pubdata for batch, verify proofs, etc. For this reason, zkSync-specific EIP712 transactions contain the `gas_per_pubdata_limit` field in them, denoting the maximum price in *gas* that the operator **can charge from users for a single byte of pubdata.\n\nFor Ethereum transactions (which do not contain this field), it is enforced that the operator will not use a value larger value than a certain constant.\n\n## Different opcode pricing\n\nThe operations tend to have different “complexity”/”pricing” in zero knowledge proof terms than in standard CPU terms. For instance, `keccak256` which was optimized for CPU performance, will cost more to prove.\n\nThat’s why you will find the prices for operations on zkSync a lot different from the ones on Ethereum.\n\n## Different intrinsic costs\n\nUnlike Ethereum, where the intrinsic cost of transactions (`21000` gas) is used to cover the price of updating the balances of the users, the nonce and signature verification, on zkSync these prices are *not* included in the intrinsic costs for transactions, due to the native support of account abstraction, meaning that each account type may have their own transaction cost. In theory, some may even use more zk-friendly signature schemes or other kinds of optimizations to allow cheaper transactions for their users.\n\nThat being said, zkSync transactions do come with some small intrinsic costs, but they are mostly used to cover costs related to the processing of the transaction by the bootloader which can not be easily measured in code in real-time. These are measured via testing and are hard coded.\n\n## Batch overhead & limited resources of the batch\n\nIn order to process the batch, the zkSync team has to pay for proving of the batch, committing to it, etc. Processing a batch involves some operational costs as well. All of these values we call “Batch overhead”. It consists of two parts:\n\n- The L2 requirements for proving the circuits (denoted in L2 gas).\n- The L1 requirements for the proof verification as well as general batch processing (denoted in L1 gas).\n\nWe generally try to aggregate as many transactions as possible and each transaction pays for the batch overhead proportionally to how close did the transaction bring the batch to being *sealed,* i.e. closed and prepared for proof verification and submission on L1. A transaction gets closer to sealing a batch by using the batch’s *limited resources*.\n\nWhile on Ethereum, the main reason for the existence of batch gas limit is to keep the system decentralized & load low, i.e. assuming the existence of the correct hardware, only time would be a requirement for a batch to adhere to. In the case of zkSync batches, there are some limited resources the batch should manage:\n\n- **Time.** The same as on Ethereum, the batch should generally not take too much time to be closed in order to provide better UX. To represent the time needed we use a batch gas limit, note that it is higher than the gas limit for a single transaction.\n- **Slots for transactions.** The bootloader has a limited number of slots for transactions, i.e. it can not take more than a certain transactions per batch.\n- **The memory of the bootloader.** The bootloader needs to store the transaction’s ABI encoding in its memory & this fills it up. In practical terms, it serves as a penalty for having transactions with large calldata/signatures in case of custom accounts.\n- **Pubdata bytes.** In order to fully appreciate the gains from the storage diffs, i.e. the fact that changes in a single slot happening in the same batch need to be published only once, we need to publish all the batch’s public data only after the transaction has been processed. Right now, we publish all the data with the storage diffs as well as L2→L1 messages, etc in a single transaction at the end of the batch. Most nodes have limit of 128kb per transaction and so this is the limit that each zkSync batch should adhere to.\n\nEach transaction spends the batch overhead proportionally to how close it consumes the resources above.\n\nNote, that before the transaction is executed, the system can not know how many of the limited system resources the transaction will actually take, so we need to charge for the worst case and provide the refund at the end of the transaction.\n\n## How `baseFee` works on zkSync\n\nIn order to protect us from DDoS attacks we need to set a limited `MAX_TRANSACTION_GAS_LIMIT` per transaction. Since the computation costs are relatively constant for us, we *could* use a “fair” `baseFee` equal to the real costs for us to compute the proof for the corresponding 1 erg. Note, that `gas_per_pubdata_limit` should be then set high enough to cover the fees for the L1 gas needed to send a single pubdata byte on Ethereum. Under large L1 gas, `gas_per_pubdata_limit` would also need be large. That means that `MAX_TRANSACTION_GAS_LIMIT/gas_per_pubdata_limit` could become too low to allow for enough pubdata for lots of common use cases.\n\nTo make common transactions always executable, we must enforce that the users are always able to send at least `GUARANTEED_PUBDATA_PER_TX` bytes of pubdata in their transaction. Because of that, the needed `gas_per_pubdata_limit` for transactions should never grow beyond `MAX_TRANSACTION_GAS_LIMIT/GUARANTEED_PUBDATA_PER_TX`. Setting a hard bound on `gas_per_pubdata_limit` also means that with the growth of L1 gas prices, the L2 `baseFee` will have to grow as well (to ensure that `base_fee * gas_per_pubdata_limit = L1_gas_price * l1_gas_per_pubdata)`).\n\nThis does not actually matter a lot for normal transactions, since most of the costs will still go on pubdata for them. However, it may matter for computationally intensive tasks, meaning that for them a big upfront payment will be required, with the refund at the end of the transaction for all the overspent gas.\n\n## Trusted gas limit\n\nWhile it was mentioned above that the `MAX_TRANSACTION_GAS_LIMIT` is needed to protect the operator from users stalling the state keeper by using too much computation, in case the users may need to use a lot of pubdata (for instance to publish the bytecode of a new contract), the required gasLimit may go way beyond the `MAX_TRANSACTION_GAS_LIMIT` (since the contracts can be 10s of kilobytes in size). All the new contracts to be published are included as part of the factory dependencies field of the transaction and so the operator already knows how much pubdata will have to published & how much gas will have to spent on it.\n\nThat’s why, to provide the better UX for users, the operator may provide the [trusted gas limit](https://github.com/code-423n4/2023-10-zksync/blob/ef99273a8fdb19f5912ca38ba46d6bd02071363d/code/system-contracts/bootloader/bootloader.yul#L1137), i.e. the limit which exceeds `MAX_TRANSACTION_GAS_LIMIT` assuming that the operator knows what he is doing (e.g. he is sure that the excess gas will be spent on the pubdata).\n\n## High-level: conclusion\n\nThe zkSync fee model is meant to be the basis of the long-term fee model, which provides both robustness and security. One of the most distinctive parts of it is the existing of the batch overhead, which is proportional for the resources consumed by the transaction.\n\nThe other distinctive feature of the fee model used on zkSync is the abundance of refunds, i.e.:\n\n- For unused limited system resources.\n- For overpaid computation.\n\nThis is needed because of the relatively big upfront payments required in zkSync to provide DDoS security.\n\n# Formalization\n\nAfter determining price for each opcode in gas according to the model above, the following formulas are to be used for calculating `baseFee` and `gasPerPubdata` for a batch.\n\n### System-wide constants\n\nThese constants are to be hardcoded and can only be changed via either system contracts/bootloader or VM upgrade.\n\n`BATCH_OVERHEAD_L1_GAS` (*L*1*O*)— The L1 gas overhead for a batch (proof verification, etc).\n\n`L1_GAS_PER_PUBDATA_BYTE` (*L*1*PUB*) — The number of L1 gas needed for a single pubdata byte. It is slightly higher than 16 gas needed for publishing a non-zero byte of pubdata on-chain (currently the value of 17 is used).\n\n`BATCH_OVERHEAD_L2_GAS` (*EO*)— The constant overhead denominated in gas. This overhead is created to cover the amortized costs of proving.\n\n`BLOCK_GAS_LIMIT` (*B*) — The maximum number of computation gas per batch. This is the maximal number of gas that can be spent within a batch. This constant is rather arbitrary and is needed to prevent transactions from taking too much time from the state keeper. It can not be larger than the hard limit of 2^32 of gas for VM.\n\n`MAX_TRANSACTION_GAS_LIMIT` (*TM*) — The maximal transaction gas limit. For *i*-th single instance circuit, the price of each of its units is $SC_i = \\lceil \\frac{T_M}{CC_i} \\rceil$ to ensure that no transaction can run out of these single instance circuits.\n\n`MAX_TRANSACTIONS_IN_BATCH` (*TXM*) — The maximum number of transactions per batch. A constant in bootloader. Can contain almost any arbitrary value depending on the capacity of batch that we want to have.\n\n`BOOTLOADER_MEMORY_FOR_TXS` (*BM*) — The size of the bootloader memory that is used for transaction encoding (i.e. excluding the constant space, preallocated for other purposes).\n\n`GUARANTEED_PUBDATA_PER_TX` (*PG*) — The guaranteed number of pubdata that should be possible to pay for in one zkSync batch. This is a number that should be enough for most reasonable cases.\n\n### Derived constants\n\nSome of the constants are derived from the system constants above:\n\n`MAX_GAS_PER_PUBDATA` (*EPMax*) — the `gas_price_per_pubdata` that should always be enough to cover for publishing a pubdata byte:\n\n$$\nEP_{Max} = \\lfloor \\frac{T_M}{P_G} \\rfloor\n$$\n\n### Externally-provided batch parameters\n\n`L1_GAS_PRICE` (*L*1*P*) — The price for L1 gas in ETH.\n\n`FAIR_GAS_PRICE` (*Ef*) — The “fair” gas price in ETH, that is, the price of proving one circuit (in Ether) divided by the number we chose as one circuit price in gas.\n\n$$\nE_f = \\frac{Price_C}{E_C}\n$$\n\nwhere *PriceC* is the price for proving a circuit in ETH. Even though this price will generally be volatile (due to the volatility of ETH price), the operator is discouraged to change it often, because it would volatile both volatile gas price and (most importantly) the required `gas_price_per_pubdata` for transactions.\n\nBoth of the values above are currently provided by the operator. Later on, some decentralized/deterministic way to provide these prices will be utilized.\n\n### Determining base_fee\n\nWhen the batch opens, we can calculate the `FAIR_GAS_PER_PUBDATA_BYTE` (*EPf*) — “fair” gas per pubdata byte:\n\n$$\nEP_f = \\lceil \\frac{L1_p * L1_{PUB}}{E_f} \\rceil\n$$\n\nThere are now two situations that can be observed:\n\n1. \n$$\nEP_f > EP_{Max}\n$$\n\nThis means that the L1 gas price is so high that if we treated all the prices fairly, then the number of gas required to publish guaranteed pubdata is too high, i.e. allowing at least *PG* pubdata bytes per transaction would mean that we would to support *tx*.*gasLimit* greater that the maximum gas per transaction *TM*, allowing to run out of other finite resources.\n\nIf $EP_f > EP_{Max}$, then the user needs to artificially increase the provided *Ef* to bring the needed *tx*.*gasPerPubdataByte* to *EPmax*\n\nIn this case we set the EIP1559 `baseFee` (*Base*):\n\n$$\nBase = max(E_f, \\lceil \\frac{L1_P * L1_{PUB}}{EP_{max}} \\rceil)\n$$\n\nOnly transactions that have at least this high gasPrice will be allowed into the batch.\n\n2. Otherwise, we keep $Base* = E_f$\n\nNote, that both cases are covered with the formula in case (1), i.e.:\n\n$$\nBase = max(E_f, \\lceil \\frac{L1_P * L1_{PUB}}{EP_{max}} \\rceil)\n$$\n\nThis is the base fee that will be always returned from the API via `eth_gasGasPrice`.\n\n### Calculating overhead for a transaction\n\nLet’s define by *tx*.*actualGasLimit* as the actual gasLimit that is to be used for processing of the transaction (including the intrinsic costs). In this case, we will use the following formulas for calculating the upfront payment for the overhead:\n\n$$\nS_O = 1/TX_M\n$$\n$$\nM_O(tx) = encLen(tx) / B_M\n$$\n$$\nE_{AO}(tx) = tx.actualGasLimit / T_M\n$$\n$$\nO(tx) = max(S_O, M_O(tx), E_O(tx))\n$$\n\nwhere:\n\n*SO* — is the overhead for taking up 1 slot for a transaction\n\n*MO*(*tx*) — is the overhead for taking up the memory of the bootloader\n\n*encLen*(*tx*) — the length of the ABI encoding of the transaction’s struct.\n\n*EAO*(*tx*) — is the overhead for potentially taking up the gas for single instance circuits.\n\n*O*(*tx*) — is the total share of the overhead that the transaction should pay for.\n\nThen we can calculate the overhead that the transaction should pay as the following one:\n\n$$\nL1_O(tx) = \\lceil \\frac{L1_O}{L1_{PUB}} \\rceil * O(tx) \\\\\nE_O(tx) = E_O * O(tx)\n$$\n\nWhere\n\n*L*1*O*(*tx*) — the number of L1 gas overhead (in pubdata equivalent) the transaction should compensate for gas.\n\n*EO*(*tx*) — the number of L2 gas overhead the transaction should compensate for.\n\nThen:\n\n*overhead*_*gas*(*tx*) = *EO*(*tx*) + *tx*.*gasPerPubdata* ⋅ *L*1*O*(*tx*)\n\nWhen a transaction is being estimated, the server returns the following gasLimit:\n\n*tx*.*gasLimit* = *tx*.*actualGasLimit* + *overhead*_*gas*(*tx*)\n\nNote, that when the operator receives the transaction, it knows only *tx*.*gasLimit*. The operator could derive the *overhead*_*gas*(*tx*) and provide the bootloader with it. The bootloader will then derive *tx*.*actualGasLimit* = *tx*.*gasLimit* − *overhead*_*gas*(*tx*) and use the formulas above to derive the overhead that the user should’ve paid under the derived *tx*.*actualGasLimit* to ensure that the operator does not overcharge the user.\n\n### Note on formulas\n\nFor the ease of integer calculation, we will use the following formulas to derive the *overhead*(*tx*):\n\n$B_O(tx) = E_O + tx.gasPerPubdataByte \\cdot \\lfloor \\frac{L1_O}{L1_{PUB}} \\rfloor$\n\n$B_O$ denotes the overhead for batch in gas that the transaction would have to pay if it consumed the resources for entire batch.\n\nThen, *overhead*_*gas*(*tx*) is the maximum of the following expressions:\n\n1. $S_O = \\lceil \\frac{B_O}{TX_M} \\rceil$\n2. $M_O(tx) = \\lceil \\frac{B_O \\cdot encodingLen(tx)}{B_M} \\rceil$\n3. $E_O(tx) = \\lceil \\frac{B_O \\cdot tx.gasBodyLimit}{T_M} \\rceil$\n\n### Deriving `overhead_gas(tx)` from `tx.gasLimit`\n\nThe task that the operator needs to do is the following:\n\nGiven the tx.gasLimit, it should find the maximal `overhead_gas(tx)`, such that the bootloader will accept such transaction, that is, if we denote by *Oop* the overhead proposed by the operator, the following equation should hold:\n\n$$\nO_{op} ≤ overhead_gas(tx)\n$$\n\nfor the $tx.bodyGasLimit$ we use the $tx.bodyGasLimit$ = $tx.gasLimit − O_{op}$.\n\nThere are a few approaches that could be taken here:\n\n- Binary search. However, we need to be able to use this formula for the L1 transactions too, which would mean that binary search is too costly.\n- The analytical way. This is the way that we will use and it will allow us to find such an overhead in O(1), which is acceptable for L1->L2 transactions.\n\nLet’s rewrite the formula above the following way:\n\n$$\nO_{op} ≤ max(SO, MO(tx), EO(tx))\n$$\n\nSo we need to find the maximal $O_{op}$, such that $O_{op} ≤ max(S_O, M_O(tx), E_O(tx))$. Note, that it means ensuring that at least one of the following is true:\n\n1. $O_{op} ≤ S_O$\n    \n2. $O_{op} ≤ M_O(tx)$\n    \n3. $O_{op} ≤ E_O(tx)$\n\nSo let’s find the largest *Oop* for each of these and select the maximum one.\n\n- Solving for (1)\n    \n$$\nO_{op} = \\lceil \\frac{B_O}{TX_M} \\rceil\n$$\n    \n- Solving for (2)\n    \n$$\nO_{op} = \\lceil \\frac{encLen(tx) \\cdot B_O}{B_M} \\rceil \n$$\n    \n- Solving for (3)\n    \nThis one is somewhat harder than the previous ones. We need to find the largest *O_{op}*, such that:\n    \n$$ \nO_{op} \\le \\lceil \\frac{tx.actualErgsLimit \\cdot B_O}{T_M} \\rceil   \\\\\n$$\n\n$$\nO_{op} \\le \\lceil \\frac{(tx.ergsLimit - O_{op}) \\cdot B_O}{T_M} \\rceil   \\\\\n$$\n\n$$\nO_{op}  ≤ \\lceil \\frac{B_O \\cdot (tx.ergsLimit - O_{op})}{T_M} \\rceil\n$$\n    \nNote, that all numbers here are integers, so we can use the following substitution:\n\n$$\nO_{op} -1 \\lt \\frac{(tx.ergsLimit - O_{op}) \\cdot B_O}{T_M}    \\\\\n$$\n\n$$\n(O_{op} -1)T_M \\lt (tx.ergsLimit - O_{op}) \\cdot B_O    \\\\\n$$\n\n$$\nO_{op} T_M + O_{op} B_O \\lt tx.ergsLimit \\cdot B_O + T_M    \\\\\n$$\n\n$$\nO_{op} \\lt \\frac{tx.ergsLimit \\cdot B_O + T_M}{B_O + T_M}    \\\\\n$$\n\n\nMeaning, in other words:\n\n$$\nO_{op} = \\lfloor \\frac{tx.ergsLimit \\cdot B_O + T_M - 1}{B_O + T_M} \\rfloor\n$$\n    \n\nThen, the operator can safely choose the largest one.\n\n### Discounts by the operator\n\nIt is important to note that the formulas provided above are to withstand the worst-case scenario and these are the formulas used for L1->L2 transactions (since these are forced to be processed by the operator). However, in reality, the operator typically would want to reduce the overhead for users whenever it is possible. For instance, in the server, we underestimate the maximal potential `MAX_GAS_PER_TRANSACTION`, since usually the batches are closed because of either the pubdata limit or the transactions’ slots limit. For this reason, the operator also provides the operator’s proposed overhead. The only thing that the bootloader checks is that this overhead is *not larger* than the maximal required one. But the operator is allowed to provide a lower overhead.\n\n### Refunds\n\nAs you could see above, this fee model introduces quite some places where users may overpay for transactions:\n\n- For the pubdata when L1 gas price is too low\n- For the computation when L1 gas price is too high\n- The overhead, since the transaction may not use the entire batch resources they could.\n\nTo compensate users for this, we will provide refunds for users. For all of the refunds to be provable, the counter counts the number of gas that was spent on pubdata (or the number of pubdata bytes published). We will denote this number by *pubdataused*. For now, this value can be provided by the operator.\n\nThe fair price for a transaction is\n\n$$\nFairFee = E_f \\cdot tx.computationalGas + EP_f \\cdot pubdataused\n$$\n\nWe can derive $tx.computationalGas = gasspent − pubdataused \\cdot tx.gasPricePerPubdata$, where *gasspent* is the number of gas spent for the transaction (can be trivially fetched in Solidity).\n\nAlso, the *FairFee* will include the actual overhead for batch that the users should pay for.\n\nThe fee that the user has actually spent is:\n\n$$\nActualFee = gasspent \\cdot gasPrice\n$$\n\nSo we can derive the overpay as\n\n$$\nActualFee − FairFee\n$$\n\nIn order to keep the invariant of $gasUsed \\cdot gasPrice = fee$ , we will formally refund $\\frac{ActualFee - FairFee}{Base}$ gas.\n\nAt the moment, this counter is not accessible within the VM and so the operator is free to provide any refund it wishes (as long as it is greater than or equal to the actual amount of gasLeft after the transaction execution).\n\n### Refunds for repeated writes\n\nzkSync Era is a statediff-based rollup, i.e. the pubdata is published not for transactions, but for storage changes. This means that whenever a user writes into a storage slot, he incurs certain amount of pubdata. However, not all writes are equal:\n\n- If a slot has been already written to in one of the previous batches, the slot has received a short id, which allows it to require less pubdata in the state diff.\n- Depending on the `value` written into a slot, various compression optimizations could be used and so we should reflect that too.\n- Maybe the slot has been already written to in this batch and so we don’t to charge anything for it.\n\nYou can read more about how we treat the pubdata [here](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/Handling%20pubdata%20in%20Boojum.md).\n\nThe important part here is that while such refunds are inlined (i.e. unlike the refunds for overhead they happen in-place during execution and not after the whole transaction has been processed), they are enforced by the operator. Right now, the operator is the one that decides what refund to provide.\n\n# Improvements in the upcoming releases\n\nThe fee model explained above, while fully functional, has some known issues. These will be tackled with the following upgrades.\n\n## The quadratic overhead for pubdata\n\nNote, that the computational overhead is proportional to the `tx.gasLimit` and the amount of funds the user will have to pay is proportional to the L1 gas price (recall the formula of `B_O`). We can roughly express the transaction overhead from computation as `tx.gasLimit * L1_GAS_PRICE * C` where `C` is just some constant. Note, that since a transaction typically contains some storage writes, and its `tx.gasLimit = gasSpentOnCompute + pubdataPublished * gasPricePerPubdata`, `tx.gasLimit` is roughly proprtional to `gasPricePerPubdata` and so it is also proportional to `L1_GAS_PRICE`.\n\nThis means that formula `tx.gasLimit * L1_GAS_PRICE * C` becomes *quadratic* to the `L1_GAS_PRICE`.\n\n## `gasUsed` depends to `gasLimit`\n\nWhile in general it shouldn’t be the case assuming the correct implementation of [refunds](#refunds), in practice it turned out that the formulas above, while robust, estimate for the worst case which can be very difference from the average one. In order to improve the UX and reduce the overhead, the operator charges less for the execution overhead. However, as a compensation for the risk, it does not fully refund for it.\n\n## L1->L2 transactions do not pay for their execution on L1\n\nThe `executeBatches` operation on L1 is executed in `O(N)` where N is the number of priority ops that we have in the batch. Each executed priority operation will be popped and so it incurs cost for storage modifications. As of now, we do not charge for it.\n\n# zkSync Era Fee Components (Revenue & Costs)\n\n- On-Chain L1 Costs\n    - L1 Commit Batches\n        - The commit batches transaction submits pubdata (which is the list of updated storage slots) to L1. The cost of a commit transaction is calculated as `constant overhead + price of pubdata`. The `constant overhead` cost is evenly distributed among L2 transactions in the L1 commit transaction, but only at higher transaction loads. As for the `price of pubdata`, it is known how much pubdata each L2 transaction consumed, therefore, they are charged directly for that. Multiple L1 batches can be included in a single commit transaction.\n    - L1 Prove Batches\n        - Once the off-chain proof is generated, it is submitted to L1 to make the rollup batch final. Currently, each proof contains only one L1 batch.\n    - L1 Execute Batches\n        - The execute batches transaction processes L2 -> L1 messages and marks executed priority operations as such. Multiple L1 batches can be included in a single execute transaction.\n    - L1 Finalize Withdrawals\n        - While not strictly part of the L1 fees, the cost to finalize L2 → L1 withdrawals are covered by Matter Labs. The finalize withdrawals transaction processes user token withdrawals from zkSync Era to Ethereum. Multiple L2 withdrawal transactions are included in each finalize withdrawal transaction.\n- On-Chain L2 Revenue\n    - L2 Transaction Fee\n        - This fee is what the user pays to complete a transaction on zkSync Era. It is calculated as `gasLimit x baseFeePerGas - refundedGas x baseFeePerGas`, or more simply, `gasUsed x baseFeePerGas`.\n- Profit = L2 Revenue - L1 Costs - Off Chain Infrastructure Costs"
    }
  ]
}