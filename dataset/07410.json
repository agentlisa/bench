{
  "Title": "[H-03] Node operator is getting slashed for full duration even though rewards are distributed based on a 14 day cycle",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/MinipoolManager.sol#L673-L675\n\n\n# Vulnerability details\n\n## Description\nA node operator sends in the amount of duration they want to stake for. Behind the scenes Rialto will stake in 14 day cycles and then distribute rewards.\n\nIf a node operator doesn't have high enough availability and doesn't get any rewards, the protocol will slash their staked `GGP`. For calculating the expected rewards that are missed however, the full duration is used:\n\n```javascript\nFile: MinipoolManager.sol\n\n557:\tfunction getExpectedAVAXRewardsAmt(uint256 duration, uint256 avaxAmt) public view returns (uint256) {\n558:\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n559:\t\tuint256 rate = dao.getExpectedAVAXRewardsRate();\n560:\t\treturn (avaxAmt.mulWadDown(rate) * duration) / 365 days; // full duration used when calculating expected reward\n561:\t}\n\n...\n\n670:\tfunction slash(int256 index) private {\n\n...\n\n673:\t\tuint256 duration = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".duration\")));\n674:\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxLiquidStakerAmt\")));\n675:\t\tuint256 expectedAVAXRewardsAmt = getExpectedAVAXRewardsAmt(duration, avaxLiquidStakerAmt); // full duration\n676:\t\tuint256 slashGGPAmt = calculateGGPSlashAmt(expectedAVAXRewardsAmt);\n```\n\nThis is unfair to the node operator because the expected rewards is from a 14 day cycle.\n\nAlso, If they were to be unavailable again, in a later cycle, they would get slashed for the full duration once again.\n\n## Impact\nA node operator staking for a long time is getting slashed for an unfairly large amount if they aren't available during a 14 day period.\n\nThe protocol also wants node operators to stake in longer periods:\nhttps://multisiglabs.notion.site/Known-Issues-42e2f733daf24893a93ad31100f4cd98\n> Team Comment: \n\n> - This can only be taken advantage of when signing up for 2-4 week validation periods. **Our protocol is incentivizing nodes to sign up for 3-12 month validation periods.** If the team notices this mechanic being abused, Rialto may update its GGP reward calculation to disincentive this behavior.\n\nThis slashing amount calculation incentives the node operator to sign up for the shortest period possible and restake themselves to minimize possible losses. \n\n## Proof of Concept\nTest in `MinipoolManager.t.sol`:\n\n```javascript\n\tfunction testRecordStakingEndWithSlashHighDuration() public {\n\t\tuint256 duration = 365 days;\n\t\tuint256 depositAmt = 1000 ether;\n\t\tuint256 avaxAssignmentRequest = 1000 ether;\n\t\tuint256 validationAmt = depositAmt + avaxAssignmentRequest;\n\t\tuint128 ggpStakeAmt = 200 ether;\n\n\t\tvm.startPrank(nodeOp);\n\t\tggp.approve(address(staking), MAX_AMT);\n\t\tstaking.stakeGGP(ggpStakeAmt);\n\t\tMinipoolManager.Minipool memory mp1 = createMinipool(depositAmt, avaxAssignmentRequest, duration);\n\t\tvm.stopPrank();\n\n\t\taddress liqStaker1 = getActorWithTokens(\"liqStaker1\", MAX_AMT, MAX_AMT);\n\t\tvm.prank(liqStaker1);\n\t\tggAVAX.depositAVAX{value: MAX_AMT}();\n\n\t\tvm.prank(address(rialto));\n\t\tminipoolMgr.claimAndInitiateStaking(mp1.nodeID);\n\n\t\tbytes32 txID = keccak256(\"txid\");\n\t\tvm.prank(address(rialto));\n\t\tminipoolMgr.recordStakingStart(mp1.nodeID, txID, block.timestamp);\n\n\t\tskip(2 weeks); // a two week cycle\n\t\t\n\t\tvm.prank(address(rialto));\n\t\tminipoolMgr.recordStakingEnd{value: validationAmt}(mp1.nodeID, block.timestamp, 0 ether);\n\n\t\tassertEq(vault.balanceOf(\"MinipoolManager\"), depositAmt);\n\n\t\tint256 minipoolIndex = minipoolMgr.getIndexOf(mp1.nodeID);\n\t\tMinipoolManager.Minipool memory mp1Updated = minipoolMgr.getMinipool(minipoolIndex);\n\t\tassertEq(mp1Updated.status, uint256(MinipoolStatus.Withdrawable));\n\t\tassertEq(mp1Updated.avaxTotalRewardAmt, 0);\n\t\tassertTrue(mp1Updated.endTime != 0);\n\n\t\tassertEq(mp1Updated.avaxNodeOpRewardAmt, 0);\n\t\tassertEq(mp1Updated.avaxLiquidStakerRewardAmt, 0);\n\n\t\tassertEq(minipoolMgr.getTotalAVAXLiquidStakerAmt(), 0);\n\n\t\tassertEq(staking.getAVAXAssigned(mp1Updated.owner), 0);\n\t\tassertEq(staking.getMinipoolCount(mp1Updated.owner), 0);\n\n\t\t// log slash amount\n\t\tconsole.log(\"slashedAmount\",mp1Updated.ggpSlashAmt);\n\t}\n```\n\nSlashed amount for a `365 days` duration is `100 eth` (10%). However, where they to stake for the minimum time, `14 days` the slashed amount would be only ~`3.8 eth`.\n\n## Tools Used\nvs code, forge\n\n## Recommended Mitigation Steps\nEither hard code the duration to 14 days for calculating expected rewards or calculate the actual duration using `startTime` and `endTime`. ",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-12-gogopool-contest",
  "Code": [
    {
      "filename": "contracts/contract/MinipoolManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"./Base.sol\";\nimport {IWithdrawer} from \"../interface/IWithdrawer.sol\";\nimport {MinipoolStatus} from \"../types/MinipoolStatus.sol\";\nimport {MultisigManager} from \"./MultisigManager.sol\";\nimport {Oracle} from \"./Oracle.sol\";\nimport {ProtocolDAO} from \"./ProtocolDAO.sol\";\nimport {Staking} from \"./Staking.sol\";\nimport {Storage} from \"./Storage.sol\";\nimport {TokenggAVAX} from \"./tokens/TokenggAVAX.sol\";\nimport {TokenGGP} from \"./tokens/TokenGGP.sol\";\nimport {Vault} from \"./Vault.sol\";\n\nimport {ERC20} from \"@rari-capital/solmate/src/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {ReentrancyGuard} from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n/*\n\tData Storage Schema\n\tNodeIDs are 20 bytes so can use Solidity 'address' as storage type for them\n\tNodeIDs can be added, but never removed. If a nodeID submits another validation request,\n\t\tit will overwrite the old one (only allowed for specific statuses).\n\n\tMinipoolManager.TotalAVAXLiquidStakerAmt = total for all active minipools (Prelaunch/Launched/Staking)\n\n\tminipool.count = Starts at 0 and counts up by 1 after a node is added.\n\n\tminipool.index<nodeID> = <index> of nodeID\n\tminipool.item<index>.nodeID = nodeID used as primary key (NOT the ascii \"Node-123...\" but the actual 20 bytes)\n\tminipool.item<index>.status = enum\n\tminipool.item<index>.duration = requested validation duration in seconds (performed as 14 day cycles)\n\tminipool.item<index>.delegationFee = node operator specified fee (must be between 0 and 1 ether) 2% is 0.2 ether\n\tminipool.item<index>.owner = owner address\n\tminipool.item<index>.multisigAddr = which Rialto multisig is assigned to manage this validation\n\tminipool.item<index>.avaxNodeOpAmt = avax deposited by node operator (for this cycle)\n\tminipool.item<index>.avaxNodeOpInitialAmt = avax deposited by node operator for the **first** validation cycle\n\tminipool.item<index>.avaxLiquidStakerAmt = avax deposited by users and assigned to this nodeID\n\n\t// Submitted by the Rialto oracle\n\tminipool.item<index>.txID = transaction id of the AddValidatorTx\n\tminipool.item<index>.initialStartTime = actual time the **first** validation cycle was started\n\tminipool.item<index>.startTime = actual time validation was started\n\tminipool.item<index>.endTime = actual time validation was finished\n\tminipool.item<index>.avaxTotalRewardAmt = Actual total avax rewards paid by avalanchego to the TSS P-chain addr\n\tminipool.item<index>.errorCode = bytes32 that encodes an error msg if something went wrong during launch of minipool\n\n\t// Calculated in recordStakingEnd()\n\tminipool.item<index>.avaxNodeOpRewardAmt\n\tminipool.item<index>.avaxLiquidStakerRewardAmt\n\tminipool.item<index>.ggpSlashAmt = amt of ggp bond that was slashed if necessary (expected reward amt = avaxLiquidStakerAmt * x%/yr / ggpPriceInAvax)\n*/\n\n/// @title Minipool creation and management\ncontract MinipoolManager is Base, ReentrancyGuard, IWithdrawer {\n\tusing FixedPointMathLib for uint256;\n\tusing SafeTransferLib for address;\n\tusing SafeTransferLib for ERC20;\n\n\terror InsufficientGGPCollateralization();\n\terror InsufficientAVAXForMinipoolCreation();\n\terror InvalidAmount();\n\terror InvalidAVAXAssignmentRequest();\n\terror InvalidStartTime();\n\terror InvalidEndTime();\n\terror InvalidMultisigAddress();\n\terror InvalidNodeID();\n\terror InvalidStateTransition();\n\terror MinipoolNotFound();\n\terror OnlyOwner();\n\terror CancellationTooEarly();\n\n\tevent GGPSlashed(address indexed nodeID, uint256 ggp);\n\tevent MinipoolStatusChanged(address indexed nodeID, MinipoolStatus indexed status);\n\n\tERC20 public immutable ggp;\n\tTokenggAVAX public immutable ggAVAX;\n\n\t/// @dev Not used for storage, just for returning data from view functions\n\tstruct Minipool {\n\t\tint256 index;\n\t\taddress nodeID;\n\t\tuint256 status;\n\t\tuint256 duration;\n\t\tuint256 delegationFee;\n\t\taddress owner;\n\t\taddress multisigAddr;\n\t\tuint256 avaxNodeOpAmt;\n\t\tuint256 avaxNodeOpInitialAmt;\n\t\tuint256 avaxLiquidStakerAmt;\n\t\t// Submitted by the Rialto Oracle\n\t\tbytes32 txID;\n\t\tuint256 initialStartTime;\n\t\tuint256 startTime;\n\t\tuint256 endTime;\n\t\tuint256 avaxTotalRewardAmt;\n\t\tbytes32 errorCode;\n\t\t// Calculated in recordStakingEnd\n\t\tuint256 ggpSlashAmt;\n\t\tuint256 avaxNodeOpRewardAmt;\n\t\tuint256 avaxLiquidStakerRewardAmt;\n\t}\n\n\tfunction receiveWithdrawalAVAX() external payable {}\n\n\t//\n\t// GUARDS\n\t//\n\n\t/// @notice Look up minipool owner by minipool index\n\t/// @param minipoolIndex A valid minipool index\n\t/// @return minipool owner or revert\n\tfunction onlyOwner(int256 minipoolIndex) private view returns (address) {\n\t\taddress owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".owner\")));\n\t\tif (msg.sender != owner) {\n\t\t\trevert OnlyOwner();\n\t\t}\n\t\treturn owner;\n\t}\n\n\t/// @notice Verifies the multisig trying to use the given node ID is valid\n\t/// @dev Look up multisig index by minipool nodeID\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @return minipool index or revert\n\tfunction onlyValidMultisig(address nodeID) private view returns (int256) {\n\t\tint256 minipoolIndex = requireValidMinipool(nodeID);\n\n\t\taddress assignedMultisig = getAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".multisigAddr\")));\n\t\tif (msg.sender != assignedMultisig) {\n\t\t\trevert InvalidMultisigAddress();\n\t\t}\n\t\treturn minipoolIndex;\n\t}\n\n\t/// @notice Look up minipool index by minipool nodeID\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @return minipool index or revert\n\tfunction requireValidMinipool(address nodeID) private view returns (int256) {\n\t\tint256 minipoolIndex = getIndexOf(nodeID);\n\t\tif (minipoolIndex == -1) {\n\t\t\trevert MinipoolNotFound();\n\t\t}\n\n\t\treturn minipoolIndex;\n\t}\n\n\t/// @notice Ensure a minipool is allowed to move to the \"to\" state\n\t/// @param minipoolIndex A valid minipool index\n\t/// @param to New status\n\tfunction requireValidStateTransition(int256 minipoolIndex, MinipoolStatus to) private view {\n\t\tbytes32 statusKey = keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\"));\n\t\tMinipoolStatus currentStatus = MinipoolStatus(getUint(statusKey));\n\t\tbool isValid;\n\n\t\tif (currentStatus == MinipoolStatus.Prelaunch) {\n\t\t\tisValid = (to == MinipoolStatus.Launched || to == MinipoolStatus.Canceled);\n\t\t} else if (currentStatus == MinipoolStatus.Launched) {\n\t\t\tisValid = (to == MinipoolStatus.Staking || to == MinipoolStatus.Error);\n\t\t} else if (currentStatus == MinipoolStatus.Staking) {\n\t\t\tisValid = (to == MinipoolStatus.Withdrawable || to == MinipoolStatus.Error);\n\t\t} else if (currentStatus == MinipoolStatus.Withdrawable || currentStatus == MinipoolStatus.Error) {\n\t\t\tisValid = (to == MinipoolStatus.Finished || to == MinipoolStatus.Prelaunch);\n\t\t} else if (currentStatus == MinipoolStatus.Finished || currentStatus == MinipoolStatus.Canceled) {\n\t\t\t// Once a node is finished/canceled, if they re-validate they go back to beginning state\n\t\t\tisValid = (to == MinipoolStatus.Prelaunch);\n\t\t} else {\n\t\t\tisValid = false;\n\t\t}\n\n\t\tif (!isValid) {\n\t\t\trevert InvalidStateTransition();\n\t\t}\n\t}\n\n\tconstructor(\n\t\tStorage storageAddress,\n\t\tERC20 ggp_,\n\t\tTokenggAVAX ggAVAX_\n\t) Base(storageAddress) {\n\t\tversion = 1;\n\t\tggp = ggp_;\n\t\tggAVAX = ggAVAX_;\n\t}\n\n\t//\n\t// OWNER FUNCTIONS\n\t//\n\n\t/// @notice Accept AVAX deposit from node operator to create a Minipool. Node Operator must be staking GGP. Open to public.\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @param duration Requested validation period in seconds\n\t/// @param delegationFee Percentage delegation fee in units of ether (2% is 0.2 ether)\n\t/// @param avaxAssignmentRequest Amount of requested AVAX to be matched for this Minipool\n\tfunction createMinipool(\n\t\taddress nodeID,\n\t\tuint256 duration,\n\t\tuint256 delegationFee,\n\t\tuint256 avaxAssignmentRequest\n\t) external payable whenNotPaused {\n\t\tif (nodeID == address(0)) {\n\t\t\trevert InvalidNodeID();\n\t\t}\n\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tif (\n\t\t\t// Current rule is matched funds must be 1:1 nodeOp:LiqStaker\n\t\t\tmsg.value != avaxAssignmentRequest ||\n\t\t\tavaxAssignmentRequest > dao.getMinipoolMaxAVAXAssignment() ||\n\t\t\tavaxAssignmentRequest < dao.getMinipoolMinAVAXAssignment()\n\t\t) {\n\t\t\trevert InvalidAVAXAssignmentRequest();\n\t\t}\n\n\t\tif (msg.value + avaxAssignmentRequest < dao.getMinipoolMinAVAXStakingAmt()) {\n\t\t\trevert InsufficientAVAXForMinipoolCreation();\n\t\t}\n\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tstaking.increaseMinipoolCount(msg.sender);\n\t\tstaking.increaseAVAXStake(msg.sender, msg.value);\n\t\tstaking.increaseAVAXAssigned(msg.sender, avaxAssignmentRequest);\n\n\t\tif (staking.getRewardsStartTime(msg.sender) == 0) {\n\t\t\tstaking.setRewardsStartTime(msg.sender, block.timestamp);\n\t\t}\n\n\t\tuint256 ratio = staking.getCollateralizationRatio(msg.sender);\n\t\tif (ratio < dao.getMinCollateralizationRatio()) {\n\t\t\trevert InsufficientGGPCollateralization();\n\t\t}\n\n\t\t// Get a Rialto multisig to assign for this minipool\n\t\tMultisigManager multisigManager = MultisigManager(getContractAddress(\"MultisigManager\"));\n\t\taddress multisig = multisigManager.requireNextActiveMultisig();\n\n\t\t// Create or update a minipool record for nodeID\n\t\t// If nodeID exists, only allow overwriting if node is finished or canceled\n\t\t// \t\t(completed its validation period and all rewards paid and processing is complete)\n\t\tint256 minipoolIndex = getIndexOf(nodeID);\n\t\tif (minipoolIndex != -1) {\n\t\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Prelaunch);\n\t\t\tresetMinipoolData(minipoolIndex);\n\t\t\t// Also reset initialStartTime as we are starting a whole new validation\n\t\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".initialStartTime\")), 0);\n\t\t} else {\n\t\t\tminipoolIndex = int256(getUint(keccak256(\"minipool.count\")));\n\t\t\t// The minipoolIndex is stored 1 greater than actual value. The 1 is subtracted in getIndexOf()\n\t\t\tsetUint(keccak256(abi.encodePacked(\"minipool.index\", nodeID)), uint256(minipoolIndex + 1));\n\t\t\tsetAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".nodeID\")), nodeID);\n\t\t\taddUint(keccak256(\"minipool.count\"), 1);\n\t\t}\n\n\t\t// Save the attrs individually in the k/v store\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Prelaunch));\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".duration\")), duration);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".delegationFee\")), delegationFee);\n\t\tsetAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".owner\")), msg.sender);\n\t\tsetAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".multisigAddr\")), multisig);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpInitialAmt\")), msg.value);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")), msg.value);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")), avaxAssignmentRequest);\n\n\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Prelaunch);\n\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tvault.depositAVAX{value: msg.value}();\n\t}\n\n\t/// @notice Owner of a minipool can cancel the (prelaunch) minipool\n\t/// @param nodeID 20-byte Avalanche node ID the Owner registered with\n\tfunction cancelMinipool(address nodeID) external nonReentrant {\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tint256 index = requireValidMinipool(nodeID);\n\t\tonlyOwner(index);\n\t\t// make sure they meet the wait period requirement\n\t\tif (block.timestamp - staking.getRewardsStartTime(msg.sender) < dao.getMinipoolCancelMoratoriumSeconds()) {\n\t\t\trevert CancellationTooEarly();\n\t\t}\n\t\t_cancelMinipoolAndReturnFunds(nodeID, index);\n\t}\n\n\t/// @notice Withdraw function for a Node Operator to claim all AVAX funds they are due (original AVAX staked, plus any AVAX rewards)\n\t/// @param nodeID 20-byte Avalanche node ID the Node Operator registered with\n\tfunction withdrawMinipoolFunds(address nodeID) external nonReentrant {\n\t\tint256 minipoolIndex = requireValidMinipool(nodeID);\n\t\taddress owner = onlyOwner(minipoolIndex);\n\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Finished);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Finished));\n\n\t\tuint256 avaxNodeOpAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")));\n\t\tuint256 avaxNodeOpRewardAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpRewardAmt\")));\n\t\tuint256 totalAvaxAmt = avaxNodeOpAmt + avaxNodeOpRewardAmt;\n\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tstaking.decreaseAVAXStake(owner, avaxNodeOpAmt);\n\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tvault.withdrawAVAX(totalAvaxAmt);\n\t\towner.safeTransferETH(totalAvaxAmt);\n\t}\n\n\t//\n\t// RIALTO FUNCTIONS\n\t//\n\n\t/// @notice Verifies that the minipool related the the given node ID is able to a validator\n\t/// @dev Rialto calls this to see if a claim would succeed. Does not change state.\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @return boolean representing if the minipool can become a validator\n\tfunction canClaimAndInitiateStaking(address nodeID) external view returns (bool) {\n\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);\n\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Launched);\n\n\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")));\n\t\treturn avaxLiquidStakerAmt <= ggAVAX.amountAvailableForStaking();\n\t}\n\n\t/// @notice Removes the AVAX associated with a minipool from the protocol to stake it on Avalanche and register the node as a validator\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @dev Rialto calls this to initiate registering a minipool for staking and validation of the P-chain.\n\tfunction claimAndInitiateStaking(address nodeID) external {\n\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);\n\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Launched);\n\n\t\tuint256 avaxNodeOpAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")));\n\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")));\n\n\t\t// Transfer funds to this contract and then send to multisig\n\t\tggAVAX.withdrawForStaking(avaxLiquidStakerAmt);\n\t\taddUint(keccak256(\"MinipoolManager.TotalAVAXLiquidStakerAmt\"), avaxLiquidStakerAmt);\n\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Launched));\n\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Launched);\n\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tvault.withdrawAVAX(avaxNodeOpAmt);\n\n\t\tuint256 totalAvaxAmt = avaxNodeOpAmt + avaxLiquidStakerAmt;\n\t\tmsg.sender.safeTransferETH(totalAvaxAmt);\n\t}\n\n\t/// @notice Rialto calls this after successfully registering the minipool as a validator for Avalanche\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @param txID The ID of the transaction that successfully registered the node with Avalanche to become a validater\n\t/// @param startTime Time the node became a validator\n\tfunction recordStakingStart(\n\t\taddress nodeID,\n\t\tbytes32 txID,\n\t\tuint256 startTime\n\t) external {\n\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);\n\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Staking);\n\t\tif (startTime > block.timestamp) {\n\t\t\trevert InvalidStartTime();\n\t\t}\n\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Staking));\n\t\tsetBytes32(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".txID\")), txID);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".startTime\")), startTime);\n\n\t\t// If this is the first of many cycles, set the initialStartTime\n\t\tuint256 initialStartTime = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".initialStartTime\")));\n\t\tif (initialStartTime == 0) {\n\t\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".initialStartTime\")), startTime);\n\t\t}\n\n\t\taddress owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".owner\")));\n\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")));\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tif (staking.getAVAXAssignedHighWater(owner) < staking.getAVAXAssigned(owner)) {\n\t\t\tstaking.increaseAVAXAssignedHighWater(owner, avaxLiquidStakerAmt);\n\t\t}\n\n\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Staking);\n\t}\n\n\t/// @notice Records the nodeID's validation period end\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @param endTime The time the node ID stopped validating Avalanche\n\t/// @param avaxTotalRewardAmt The rewards the node recieved from Avalanche for being a validator\n\t/// @dev Rialto will xfer back all staked avax + avax rewards. Also handles the slashing of node ops GGP bond.\n\tfunction recordStakingEnd(\n\t\taddress nodeID,\n\t\tuint256 endTime,\n\t\tuint256 avaxTotalRewardAmt\n\t) external payable {\n\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);\n\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Withdrawable);\n\n\t\tuint256 startTime = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".startTime\")));\n\t\tif (endTime <= startTime || endTime > block.timestamp) {\n\t\t\trevert InvalidEndTime();\n\t\t}\n\n\t\tuint256 avaxNodeOpAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")));\n\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")));\n\t\tuint256 totalAvaxAmt = avaxNodeOpAmt + avaxLiquidStakerAmt;\n\t\tif (msg.value != totalAvaxAmt + avaxTotalRewardAmt) {\n\t\t\trevert InvalidAmount();\n\t\t}\n\n\t\taddress owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".owner\")));\n\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Withdrawable));\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".endTime\")), endTime);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxTotalRewardAmt\")), avaxTotalRewardAmt);\n\n\t\t// Calculate rewards splits (these will all be zero if no rewards were recvd)\n\t\t// TODO Revisit this logic if we ever allow unequal matched funds\n\t\tuint256 avaxHalfRewards = avaxTotalRewardAmt / 2;\n\n\t\t// Node operators recv an additional commission fee\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 avaxLiquidStakerRewardAmt = avaxHalfRewards - avaxHalfRewards.mulWadDown(dao.getMinipoolNodeCommissionFeePct());\n\t\tuint256 avaxNodeOpRewardAmt = avaxTotalRewardAmt - avaxLiquidStakerRewardAmt;\n\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpRewardAmt\")), avaxNodeOpRewardAmt);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerRewardAmt\")), avaxLiquidStakerRewardAmt);\n\n\t\t// No rewards means validation period failed, must slash node ops GGP.\n\t\tif (avaxTotalRewardAmt == 0) {\n\t\t\tslash(minipoolIndex);\n\t\t}\n\n\t\t// Send the nodeOps AVAX + rewards to vault so they can claim later\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tvault.depositAVAX{value: avaxNodeOpAmt + avaxNodeOpRewardAmt}();\n\t\t// Return Liq stakers funds + rewards\n\t\tggAVAX.depositFromStaking{value: avaxLiquidStakerAmt + avaxLiquidStakerRewardAmt}(avaxLiquidStakerAmt, avaxLiquidStakerRewardAmt);\n\t\tsubUint(keccak256(\"MinipoolManager.TotalAVAXLiquidStakerAmt\"), avaxLiquidStakerAmt);\n\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tstaking.decreaseAVAXAssigned(owner, avaxLiquidStakerAmt);\n\t\tstaking.decreaseMinipoolCount(owner);\n\n\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Withdrawable);\n\t}\n\n\t/// @notice Re-stake a minipool, compounding all rewards recvd\n\t/// @param nodeID 20-byte Avalanche node ID\n\tfunction recreateMinipool(address nodeID) external whenNotPaused {\n\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);\n\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Prelaunch);\n\t\tMinipool memory mp = getMinipool(minipoolIndex);\n\t\t// Compound the avax plus rewards\n\t\t// NOTE Assumes a 1:1 nodeOp:liqStaker funds ratio\n\t\tuint256 compoundedAvaxNodeOpAmt = mp.avaxNodeOpAmt + mp.avaxNodeOpRewardAmt;\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")), compoundedAvaxNodeOpAmt);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")), compoundedAvaxNodeOpAmt);\n\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\t// Only increase AVAX stake by rewards amount we are compounding\n\t\t// since AVAX stake is only decreased by withdrawMinipool()\n\t\tstaking.increaseAVAXStake(mp.owner, mp.avaxNodeOpRewardAmt);\n\t\tstaking.increaseAVAXAssigned(mp.owner, compoundedAvaxNodeOpAmt);\n\t\tstaking.increaseMinipoolCount(mp.owner);\n\n\t\tif (staking.getRewardsStartTime(mp.owner) == 0) {\n\t\t\t// Edge case where calculateAndDistributeRewards has reset their rewards time even though they are still cycling\n\t\t\t// So we re-set it here to their initial start time for this minipool\n\t\t\tstaking.setRewardsStartTime(mp.owner, mp.initialStartTime);\n\t\t}\n\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 ratio = staking.getCollateralizationRatio(mp.owner);\n\t\tif (ratio < dao.getMinCollateralizationRatio()) {\n\t\t\trevert InsufficientGGPCollateralization();\n\t\t}\n\n\t\tresetMinipoolData(minipoolIndex);\n\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Prelaunch));\n\n\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Prelaunch);\n\t}\n\n\t/// @notice A staking error occured while registering the node as a validator\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @param errorCode The code that represents the reason for failure\n\t/// @dev Rialto was unable to start the validation period, so cancel and refund all money\n\tfunction recordStakingError(address nodeID, bytes32 errorCode) external payable {\n\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);\n\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Error);\n\n\t\taddress owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".owner\")));\n\t\tuint256 avaxNodeOpAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")));\n\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")));\n\n\t\tif (msg.value != (avaxNodeOpAmt + avaxLiquidStakerAmt)) {\n\t\t\trevert InvalidAmount();\n\t\t}\n\n\t\tsetBytes32(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".errorCode\")), errorCode);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Error));\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxTotalRewardAmt\")), 0);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpRewardAmt\")), 0);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerRewardAmt\")), 0);\n\n\t\t// Send the nodeOps AVAX to vault so they can claim later\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tvault.depositAVAX{value: avaxNodeOpAmt}();\n\n\t\t// Return Liq stakers funds\n\t\tggAVAX.depositFromStaking{value: avaxLiquidStakerAmt}(avaxLiquidStakerAmt, 0);\n\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tstaking.decreaseAVAXAssigned(owner, avaxLiquidStakerAmt);\n\n\t\tsubUint(keccak256(\"MinipoolManager.TotalAVAXLiquidStakerAmt\"), avaxLiquidStakerAmt);\n\n\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Error);\n\t}\n\n\t/// @notice Multisig can cancel a minipool if a problem was encountered *before* claimAndInitiateStaking() was called\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @param errorCode The code that represents the reason for failure\n\tfunction cancelMinipoolByMultisig(address nodeID, bytes32 errorCode) external {\n\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);\n\t\tsetBytes32(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".errorCode\")), errorCode);\n\t\t_cancelMinipoolAndReturnFunds(nodeID, minipoolIndex);\n\t}\n\n\t/// @notice Multisig can move a minipool from the error state to the finished state, after a human review of the error\n\t/// @param nodeID 20-byte Avalanche node ID\n\tfunction finishFailedMinipoolByMultisig(address nodeID) external {\n\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);\n\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Finished);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Finished));\n\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Finished);\n\t}\n\n\t//\n\t// VIEW FUNCTIONS\n\t//\n\n\t/// @notice Get the total amount of AVAX from liquid stakers that is being used for minipools\n\t/// @dev Get the total AVAX *actually* withdrawn from ggAVAX and sent to Rialto\n\tfunction getTotalAVAXLiquidStakerAmt() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"MinipoolManager.TotalAVAXLiquidStakerAmt\"));\n\t}\n\n\t/// @notice Calculates how much GGP should be slashed given an expected avaxRewardAmt\n\t/// @param avaxRewardAmt The amount of AVAX that should have been awarded to the validator by Avalanche\n\tfunction calculateGGPSlashAmt(uint256 avaxRewardAmt) public view returns (uint256) {\n\t\tOracle oracle = Oracle(getContractAddress(\"Oracle\"));\n\t\t(uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX();\n\t\treturn avaxRewardAmt.divWadDown(ggpPriceInAvax);\n\t}\n\n\t/// @notice Given a duration and an AVAX amt, calculate how much AVAX should be earned via validation rewards\n\t/// @param duration The length of validation in seconds\n\t/// @param avaxAmt The amount of AVAX the node staked for their validation period\n\t/// @return The approximate rewards the node should recieve from Avalanche for beign a validator\n\tfunction getExpectedAVAXRewardsAmt(uint256 duration, uint256 avaxAmt) public view returns (uint256) {\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 rate = dao.getExpectedAVAXRewardsRate();\n\t\treturn (avaxAmt.mulWadDown(rate) * duration) / 365 days;\n\t}\n\n\t/// @notice The index of a minipool. Returns -1 if the minipool is not found\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @return The index for the given minipool\n\tfunction getIndexOf(address nodeID) public view returns (int256) {\n\t\treturn int256(getUint(keccak256(abi.encodePacked(\"minipool.index\", nodeID)))) - 1;\n\t}\n\n\t/// @notice Gets the minipool information from the node ID\n\t/// @param nodeID 20-byte Avalanche node ID\n\tfunction getMinipoolByNodeID(address nodeID) public view returns (Minipool memory mp) {\n\t\tint256 index = getIndexOf(nodeID);\n\t\treturn getMinipool(index);\n\t}\n\n\t/// @notice Gets the minipool information using the minipool's index\n\t/// @param index Index of the minipool\n\t/// @return mp struct containing the minipool's properties\n\tfunction getMinipool(int256 index) public view returns (Minipool memory mp) {\n\t\tmp.index = index;\n\t\tmp.nodeID = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".nodeID\")));\n\t\tmp.status = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".status\")));\n\t\tmp.duration = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".duration\")));\n\t\tmp.delegationFee = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".delegationFee\")));\n\t\tmp.owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".owner\")));\n\t\tmp.multisigAddr = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".multisigAddr\")));\n\t\tmp.avaxNodeOpAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxNodeOpAmt\")));\n\t\tmp.avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxLiquidStakerAmt\")));\n\t\tmp.txID = getBytes32(keccak256(abi.encodePacked(\"minipool.item\", index, \".txID\")));\n\t\tmp.initialStartTime = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".initialStartTime\")));\n\t\tmp.startTime = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".startTime\")));\n\t\tmp.endTime = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".endTime\")));\n\t\tmp.avaxTotalRewardAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxTotalRewardAmt\")));\n\t\tmp.errorCode = getBytes32(keccak256(abi.encodePacked(\"minipool.item\", index, \".errorCode\")));\n\t\tmp.avaxNodeOpInitialAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxNodeOpInitialAmt\")));\n\t\tmp.avaxNodeOpRewardAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxNodeOpRewardAmt\")));\n\t\tmp.avaxLiquidStakerRewardAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxLiquidStakerRewardAmt\")));\n\t\tmp.ggpSlashAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".ggpSlashAmt\")));\n\t}\n\n\t/// @notice Get minipools in a certain status (limit=0 means no pagination)\n\t/// @param status The MinipoolStatus to be used as a filter\n\t/// @param offset The number the result should be offset by\n\t/// @param limit The limit to the amount of minipools that should be returned\n\t/// @return minipools in the protocol that adhear to the paramaters\n\tfunction getMinipools(\n\t\tMinipoolStatus status,\n\t\tuint256 offset,\n\t\tuint256 limit\n\t) public view returns (Minipool[] memory minipools) {\n\t\tuint256 totalMinipools = getUint(keccak256(\"minipool.count\"));\n\t\tuint256 max = offset + limit;\n\t\tif (max > totalMinipools || limit == 0) {\n\t\t\tmax = totalMinipools;\n\t\t}\n\t\tminipools = new Minipool[](max - offset);\n\t\tuint256 total = 0;\n\t\tfor (uint256 i = offset; i < max; i++) {\n\t\t\tMinipool memory mp = getMinipool(int256(i));\n\t\t\tif (mp.status == uint256(status)) {\n\t\t\t\tminipools[total] = mp;\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t}\n\t\t// Dirty hack to cut unused elements off end of return value (from RP)\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tmstore(minipools, total)\n\t\t}\n\t}\n\n\t/// @notice The total count of minipools in the protocol\n\tfunction getMinipoolCount() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"minipool.count\"));\n\t}\n\n\t//\n\t// PRIVATE FUNCTIONS\n\t//\n\n\t/// @notice Cancels the minipool and returns the funds related to it\n\t/// @dev At this point we dont have any liq staker funds withdrawn from ggAVAX so no need to return them\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @param index Index of the minipool\n\tfunction _cancelMinipoolAndReturnFunds(address nodeID, int256 index) private {\n\t\trequireValidStateTransition(index, MinipoolStatus.Canceled);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".status\")), uint256(MinipoolStatus.Canceled));\n\n\t\taddress owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".owner\")));\n\t\tuint256 avaxNodeOpAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxNodeOpAmt\")));\n\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxLiquidStakerAmt\")));\n\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tstaking.decreaseAVAXStake(owner, avaxNodeOpAmt);\n\t\tstaking.decreaseAVAXAssigned(owner, avaxLiquidStakerAmt);\n\n\t\tstaking.decreaseMinipoolCount(owner);\n\n\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Canceled);\n\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tvault.withdrawAVAX(avaxNodeOpAmt);\n\t\towner.safeTransferETH(avaxNodeOpAmt);\n\t}\n\n\t/// @notice Slashes the GPP of the minipool with the given index\n\t/// @dev Extracted this because of \"stack too deep\" errors.\n\t/// @param index Index of the minipool\n\tfunction slash(int256 index) private {\n\t\taddress nodeID = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".nodeID\")));\n\t\taddress owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".owner\")));\n\t\tuint256 duration = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".duration\")));\n\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxLiquidStakerAmt\")));\n\t\tuint256 expectedAVAXRewardsAmt = getExpectedAVAXRewardsAmt(duration, avaxLiquidStakerAmt);\n\t\tuint256 slashGGPAmt = calculateGGPSlashAmt(expectedAVAXRewardsAmt);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".ggpSlashAmt\")), slashGGPAmt);\n\n\t\temit GGPSlashed(nodeID, slashGGPAmt);\n\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tstaking.slashGGP(owner, slashGGPAmt);\n\t}\n\n\t/// @notice Reset all the data for a given minipool (for a previous validation cycle, so do not reset initial"
    }
  ]
}