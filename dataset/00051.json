{
  "Title": "M-8: Adapters revert when 0 shares are minted, making it impossible to deposit under certain conditions",
  "Content": "# Issue M-8: Adapters revert when 0 shares are minted, making it impossible to deposit under certain conditions \n\nSource: https://github.com/sherlock-audit/2024-05-napier-update-judging/issues/64 \n\n## Found by \nno, zzykxx\n## Summary\n\nUsers are unable to deposit into an Adapter in some situations due to the `_stake()` function reverting.\n\n## Vulnerability Detail\n\nThe function `_stake()` in all of the in-scope adapters reverts if the amounts of minted shares of the targeted protocol is `0`.\n\nFunds are deposited in an adapter via the [prefundedDeposit()](https://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L80) function, which internally calls `_stake()` by passing the amount to stake in the protocol, `stakeAmount`:\n\n```solidity\n    ...SNIP...\n    uint256 stakeAmount;\n    unchecked {\n        stakeAmount = availableEth + queueEthCache - targetBufferEth;\n    }\n\n    if (stakeAmount > availableEth) {\n@>      stakeAmount = availableEth;\n    }\n\n    ...SNIP...\n@>   stakeAmount = _stake(stakeAmount); // stake amount can be 0\n    ...SNIP...\n```\n\nThe amount to stake in the protocol, `stakeAmount`, can be restricted to `availableEth`. If `availableEth`/`stakeAmount` is low enough (but not `0`) for the targeted protocol to mint `0` shares all of the adapters in-scope will revert by throwing an `InvariantViolation();` error:\n\n- [UniEthAdapter](https://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-v1/src/adapters/bedrock/UniETHAdapter.sol#L80)\n- [EETHAdapter](https://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-v1/src/adapters/etherfi/EETHAdapter.sol#L87)\n- [RsETHAdapter](https://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-uups-adapters/src/adapters/kelp/RsETHAdapter.sol#L87)\n- [PufETHAdapter](https://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-uups-adapters/src/adapters/puffer/PufETHAdapter.sol#L84)\n- [RenzoAdapter](https://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-uups-adapters/src/adapters/renzo/RenzoAdapter.sol#L67)\n- [RswETHAdapter](https://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-uups-adapters/src/adapters/swell/RswETHAdapter.sol#L68)\n\n## Impact\n\nUsers won't not be able to deposit funds if the `stakeAmount` is not enough to mint at least 1 share. The protocol genrally allows users to deposit both when `stakeAmount` is `0` and when the maximum deposit cap has been reached on the target protocol, which is incosistent with the behaviour outlined in this report.\n\nA [similar finding](https://github.com/sherlock-audit/2024-01-napier-judging/issues/105) was disclosed in the previous Napier contest.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe function `_stake()` in the adapters should ensure that the shares minted are at least `1` before actually depositing the funds. This might introduce a lot of overhead for the calculations, an alternative solution is to have the `_stake()` functions always return `0` if `stakeAmount` is lower than a certain (small) threshold:\n\n```solidity\nfunction _stake(uint256 stakeAmount) internal override returns (uint256) {\n    if (stakeAmount < 1e6) return 0;\n    ...SNIP...\n}\n```\n\nIf going for a different fix please note that the [EETHAdapter](https://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-v1/src/adapters/etherfi/EETHAdapter.sol#L85) will actually revert on the internal call to `deposit()` if `0` shares are minted, instead of in the adapter.\n\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/napierfi/napier-uups-adapters/pull/16\nhttps://github.com/napierfi/napier-v1/pull/220\n\n\n**zzykxx**\n\nAn edge case was found in the proposed fix. `_stake()` could still revert if `RSETH_DEPOSIT_POOL.minAmountToDeposit()` returns `0`. This has been fixed in a new PR: https://github.com/napierfi/napier-uups-adapters/pull/23\n\n**sherlock-admin2**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/369",
  "Code": [
    {
      "filename": "napier-v1/src/adapters/BaseLSTAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\nimport {IWETH9} from \"../interfaces/IWETH9.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\n\nimport {StakeLimitTypes, StakeLimitUtils} from \"../utils/StakeLimitUtils.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {WETH} from \"../Constants.sol\";\n\nimport {BaseAdapter} from \"../BaseAdapter.sol\";\nimport {BaseLSTVault} from \"./BaseLSTVault.sol\";\n\n/// @notice Adapter for Liquid Staking Token (LST)\n/// @dev This adapter facilitates immediate ETH withdrawals without a waiting period.\n/// It maintains an ETH buffer to enable these withdrawals. The size of this buffer is determined\n/// by a specified desired buffer percentage. The maintenance of the buffer\n/// are handled by a designated account.\n/// @dev LST Adapter is NOT compatible with EIP4626 standard. We don't expect it to be used by other contracts other than Tranche.\nabstract contract BaseLSTAdapter is BaseLSTVault, ReentrancyGuard {\n    using SafeCast for uint256;\n    using StakeLimitTypes for StakeLimitTypes.Uint256Data;\n    using StakeLimitTypes for StakeLimitTypes.Data;\n    using StakeLimitUtils for StakeLimitTypes.Data;\n\n    uint256 constant DEFAULT_MAX_STAKE_LIMIT = 10_000 ether;\n    uint256 constant DEFAULT_STAKE_LIMIT_INCREASE_PER_BLOCK = 0.00015 ether; // About 1 ether recovery per 1 day\n\n    /// @notice Total of ETH pending withdrawal request\n    uint128 public totalQueueEth;\n\n    /// @notice Amount of ETH available (Buffer), does not include pending withdrawal. Internal accounting of ETH\n    uint128 public bufferEth;\n\n    /// @notice Mapping of the withdrawal request ID to the amount of ETH\n    mapping(uint256 requestId => uint256 queueEth) public queueWithdrawal;\n\n    /// @notice Packed data for the stake limit state\n    StakeLimitTypes.Uint256Data internal packedStakeLimitData;\n\n    error WithdrawalPending();\n    error InvalidWithdrawalAmount();\n    error NoPendingWithdrawal();\n\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    event StakingPaused();\n    event StakingUnpaused();\n    event ClaimWithdrawal(uint256 requestId, uint256 queueAmount);\n    event RequestWithdrawal(uint256 requestId, uint256 queueAmount);\n\n    /// @dev Adapter itself is the target token\n    constructor(\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) BaseLSTVault(_rebalancer) {\n        rebalancer = _rebalancer;\n        // Set the initial stake limit state\n        StakeLimitTypes.Data memory data = StakeLimitTypes.Data({\n            prevStakeBlockNumber: uint32(block.number),\n            prevStakeLimit: 0,\n            maxStakeLimitGrowthBlocks: 0,\n            maxStakeLimit: 0\n        });\n        packedStakeLimitData.setStorageStakeLimitStruct(\n            data.setStakingLimit(\n                _maxStakeLimit == 0 ? DEFAULT_MAX_STAKE_LIMIT : _maxStakeLimit,\n                _stakeLimitIncreasePerBlock == 0 ? DEFAULT_STAKE_LIMIT_INCREASE_PER_BLOCK : _stakeLimitIncreasePerBlock\n            )\n        );\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADAPTER METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Handles prefunded deposits\n    /// @return The amount of staked ETH\n    /// @return The amount of shares minted\n    function prefundedDeposit() external nonReentrant onlyTranche returns (uint256, uint256) {\n        uint256 bufferEthCache = bufferEth; // cache storage reads\n        uint256 queueEthCache = totalQueueEth; // cache storage reads\n        uint256 assets = IWETH9(WETH).balanceOf(address(this)) - bufferEthCache; // amount of WETH deposited at this time\n        uint256 shares = previewDeposit(assets);\n\n        if (assets == 0) return (0, 0);\n        if (shares == 0) revert ZeroShares();\n\n        // Calculate the target buffer amount considering the user's deposit.\n        // bufferRatio is defined as the ratio of ETH balance to the total assets in the adapter in ETH.\n        // Formula:\n        // desiredBufferRatio = (totalQueueEth + bufferEth + assets - s) / (totalQueueEth + bufferEth + stakedEth + assets)\n        // Where:\n        // assets := Amount of ETH the user is depositing\n        // s := Amount of ETH to stake at this time, s <= bufferEth + assets.\n        //\n        // Thus, the formula can be simplified to:\n        // s = (totalQueueEth + bufferEth + assets) - (totalQueueEth + bufferEth + stakedEth + assets) * desiredBufferRatio\n        //   = (totalQueueEth + bufferEth + assets) - targetBufferEth\n        //\n        // Flow:\n        // If `s` <= 0, don't stake any ETH.\n        // If `s` < bufferEth + assets, stake `s` amount of ETH.\n        // If `s` >= bufferEth + assets, all available ETH can be staked in theory.\n        // However, we cap the stake amount. This is to prevent the buffer from being completely drained.\n        //\n        // Let `a` be the available amount of ETH in the buffer after the deposit. `a` is calculated as:\n        // a = (bufferEth + assets) - s\n        uint256 targetBufferEth = ((totalAssets() + assets) * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        /// WRITE ///\n        _mint(msg.sender, shares);\n\n        uint256 availableEth = bufferEthCache + assets; // non-zero\n\n        // If the buffer is insufficient or staking is paused, doesn't stake any of the deposit\n        StakeLimitTypes.Data memory data = packedStakeLimitData.getStorageStakeLimitStruct();\n        if (targetBufferEth >= availableEth + queueEthCache || data.isStakingPaused()) {\n            /// WRITE ///\n            bufferEth = availableEth.toUint128();\n            return (assets, shares);\n        }\n\n        // Calculate the amount of ETH to stake\n        uint256 stakeAmount; // can be 0\n        unchecked {\n            stakeAmount = availableEth + queueEthCache - targetBufferEth; // non-zero, no underflow\n        }\n        // If the calculated stake amount exceeds the available ETH, simply assign the available ETH to the stake amount.\n        // Possible scenarios:\n        // - Target buffer percentage was changed to a lower value and there is a large withdrawal request pending.\n        // - There is a pending withdrawal request and the available ETH are not left in the buffer.\n        // - There is no pending withdrawal request and the available ETH are not left in the buffer.\n        if (stakeAmount > availableEth) {\n            // Note: Admins should be aware of this situation and take action to refill the buffer.\n            // - Pause staking to prevent further staking until the buffer is refilled\n            // - Update stake limit to a lower value\n            // - Increase the target buffer percentage\n            stakeAmount = availableEth; // All available ETH\n        }\n\n        // If the amount of ETH to stake exceeds the current stake limit, cap the stake amount.\n        // This is to prevent the buffer from being completely drained. This is not a complete solution.\n        uint256 currentStakeLimit = StakeLimitUtils.calculateCurrentStakeLimit(data); // can be 0 if the stake limit is exhausted\n        if (stakeAmount > currentStakeLimit) {\n            stakeAmount = currentStakeLimit;\n        }\n        /// WRITE ///\n        // Update the stake limit state in the storage\n        packedStakeLimitData.setStorageStakeLimitStruct(data.updatePrevStakeLimit(currentStakeLimit - stakeAmount));\n\n        /// INTERACT ///\n        // Deposit into the yield source\n        // Actual amount of ETH spent may be less than the requested amount.\n        stakeAmount = _stake(stakeAmount); // stake amount can be 0\n\n        /// WRITE ///\n        bufferEth = (availableEth - stakeAmount).toUint128(); // no underflow theoretically\n\n        return (assets, shares);\n    }\n\n    /// @notice Handles prefunded redemptions\n    /// @dev Withdraw from the buffer. If the buffer is insufficient, revert with an error\n    /// @param recipient The address to receive the redeemed WETH\n    /// @return The amount of redeemed WETH\n    /// @return The amount of shares burned\n    function prefundedRedeem(address recipient) external virtual onlyTranche returns (uint256, uint256) {\n        uint256 shares = balanceOf(address(this));\n        uint256 assets = previewRedeem(shares);\n\n        if (shares == 0) return (0, 0);\n        if (assets == 0) revert ZeroAssets();\n\n        uint256 bufferEthCache = bufferEth;\n        // If the buffer is insufficient, shares cannot be redeemed immediately\n        // Need to wait for the withdrawal to be completed and the buffer to be refilled.\n        if (assets > bufferEthCache) revert InsufficientBuffer();\n\n        unchecked {\n            /// WRITE ///\n            // Reduce the buffer and burn the shares\n            bufferEth = (bufferEthCache - assets).toUint128(); // no underflow\n            _burn(address(this), shares);\n        }\n\n        /// INTERACT ///\n        IWETH9(WETH).transfer(recipient, assets);\n\n        return (assets, shares);\n    }\n\n    ////////////////////////////////////////////////////////\n    /// VIRTUAL METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Request a withdrawal of ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    /// @dev Reverts if the buffer is sufficient to cover the desired buffer percentage of the total assets\n    function requestWithdrawal() external virtual nonReentrant onlyRebalancer {\n        uint256 targetBufferEth = (totalAssets() * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        // If the buffer exceeds the target buffer, revert.\n        // If the buffer is insufficient, request a withdrawal to refill the buffer.\n        // note: use `>=` instead of `>` to prevent amount of ETH to withdraw to be 0\n        uint256 sum = bufferEth + totalQueueEth;\n        if (sum >= targetBufferEth) revert BufferTooLarge();\n\n        unchecked {\n            uint256 withdrawAmount = targetBufferEth - sum; // no underflow\n\n            /// WRITE & INTERACT ///\n            // Record the pending withdrawal request\n            // Request a withdrawal\n            (uint256 queueAmount, uint256 _requestId) = _requestWithdrawal(withdrawAmount);\n\n            if (queueWithdrawal[_requestId] != 0) revert WithdrawalPending();\n            totalQueueEth += queueAmount.toUint128();\n            queueWithdrawal[_requestId] = queueAmount;\n        }\n    }\n\n    /// @notice Request a withdrawal of all staked ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    function requestWithdrawalAll() external virtual;\n\n    /// @notice Claim the finized withdrawal request\n    /// @param _requestId The request Id of the withdrawal request\n    /// @dev This function is called by anyone\n    /// @dev Reverts if there is no pending withdrawal request\n    function claimWithdrawal(uint256 _requestId) external virtual;\n\n    /// @notice Request a withdrawal of the given amount of ETH from the yield source\n    /// @param withdrawAmount The amount of ETH to withdraw\n    /// @return queueAmount The amount of ETH withdrawn\n    /// @return requestId The request Id of the withdrawal request\n    function _requestWithdrawal(\n        uint256 withdrawAmount\n    ) internal virtual returns (uint256 queueAmount, uint256 requestId);\n\n    ////////////////////////////////////////////////////////\n    /// VIEW METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Returns the present buffer percentage in WAD. e.g) 10% => 0.1 * 1e18\n    function bufferPresentPercentage() external view override returns (uint256) {\n        return ((bufferEth + totalQueueEth) * BUFFER_PERCENTAGE_PRECISION) / totalAssets();\n    }\n\n    /// @notice Check staking state: whether it's paused or not\n    function isStakingPaused() external view returns (bool) {\n        return packedStakeLimitData.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n    /// @notice Returns how much Ether can be staked into a yield source (Lido, RocketPool, etc.)\n    /// @dev Special return values:\n    /// - 0 if staking is paused or if limit is exhausted.\n    function getCurrentStakeLimit() external view returns (uint256) {\n        StakeLimitTypes.Data memory data = packedStakeLimitData.getStorageStakeLimitStruct();\n        if (data.isStakingPaused()) {\n            return 0;\n        }\n        return data.calculateCurrentStakeLimit();\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADMIN METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Sets the staking rate limit\n    ///\n    /// ▲ Stake limit\n    /// │.....  .....   ........ ...            ....     ... Stake limit = max\n    /// │      .       .        .   .   .      .    . . .\n    /// │     .       .              . .  . . .      . .\n    /// │            .                .  . . .\n    /// │──────────────────────────────────────────────────> Time\n    /// │     ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n    ///\n    /// @dev Reverts if:\n    /// - `_maxStakeLimit` == 0\n    /// - `_maxStakeLimit` >= 2^96\n    /// - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n    /// - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n    ///\n    /// Emits `StakingLimitSet` event\n    ///\n    /// @param _maxStakeLimit max stake limit value\n    /// @param _stakeLimitIncreasePerBlock stake limit increase per single block\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external onlyOwner {\n        StakeLimitTypes.Data memory data = packedStakeLimitData.getStorageStakeLimitStruct();\n        /// WRITE ///\n        packedStakeLimitData.setStorageStakeLimitStruct(\n            data.setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    function pauseStaking() external onlyOwner {\n        StakeLimitTypes.Data memory data = packedStakeLimitData.getStorageStakeLimitStruct();\n        /// WRITE ///\n        packedStakeLimitData.setStorageStakeLimitStruct(data.setStakeLimitPauseState(true));\n        emit StakingPaused();\n    }\n\n    function unpauseStaking() external onlyOwner {\n        StakeLimitTypes.Data memory data = packedStakeLimitData.getStorageStakeLimitStruct();\n        /// WRITE ///\n        packedStakeLimitData.setStorageStakeLimitStruct(data.setStakeLimitPauseState(false));\n        emit StakingUnpaused();\n    }\n}"
    },
    {
      "filename": "napier-v1/src/adapters/bedrock/UniETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/utils/SafeERC20.sol\";\nimport {IWETH9} from \"../../interfaces/IWETH9.sol\";\nimport {IStaking} from \"./interfaces/IStaking.sol\";\nimport {IRedeem} from \"./interfaces/IRedeem.sol\";\nimport {UniETHSwapper} from \"./UniETHSwapper.sol\";\n\n// libs\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {ERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/ERC20.sol\";\nimport {BaseLSTAdapter} from \"../BaseLSTAdapter.sol\";\n\n/// @notice UniETHAdapter - euniETH (Napier uniETH Adapter)\n/// @dev uniETH is a Bedrock staking token that represents ETH staked in Bedrock.\n/// @dev This contract doesn't independently keep track of the uniETHn balance, so it is possible\n/// for an attacker to directly transfer uniETH to this contract, increase the share price.\n/// @dev This adapter supports only one withdrawal request at a time.\n/// Bedrock doesn't track how much ETH is claimable per requestId.\n/// So, we can't know a requestId has been redeemed for how much ETH and claim function claims all claimable ETH\n/// regardless of requestId.\n/// For this reason, this adapter doesn't support multiple withdrawal requests.\ncontract UniETHAdapter is BaseLSTAdapter {\n    using SafeCast for uint256;\n\n    /// @notice uniETH\n    IERC20 constant UNIETH = IERC20(Constants.UNIETH);\n\n    /// @notice Bedrock staking contract\n    IStaking constant BEDROCK_STAKING = IStaking(Constants.BEDROCK_STAKING);\n\n    /// @notice Periphery contract for uniETH/WETH swaps\n    UniETHSwapper public swapper;\n\n    error RequestInQueue();\n    error OnlyWETHOrBedrock();\n    error SwapAmountTooLarge();\n    error TransactionTooOld();\n    error RequestNotFinalized();\n    error InvariantViolation();\n\n    receive() external payable {\n        if (\n            msg.sender != Constants.WETH &&\n            msg.sender != address(BEDROCK_STAKING) &&\n            msg.sender != BEDROCK_STAKING.redeemContract()\n        ) {\n            revert OnlyWETHOrBedrock();\n        }\n    }\n\n    constructor(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock,\n        address _swapper\n    )\n        ERC20(\"Napier uniETH Adapter\", \"euniETH\")\n        BaseLSTAdapter(_rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock)\n    {\n        swapper = UniETHSwapper(_swapper);\n        _transferOwnership(_owner);\n\n        UNIETH.approve(address(BEDROCK_STAKING), type(uint256).max);\n    }\n\n    /// @dev No cap on the amount of staking.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _balance = UNIETH.balanceOf(address(this));\n        BEDROCK_STAKING.mint{value: stakeAmount}({minToMint: 0, deadline: block.timestamp + 1});\n        uint256 minted = UNIETH.balanceOf(address(this)) - _balance;\n        if (minted == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Rebalancer functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @notice Claim all claimable ETH\n    /// @dev Ensure requestId has been already finizalized before calling this function.\n    function claimWithdrawal(uint256 _requestId) external override nonReentrant onlyRebalancer {\n        // Check whether the request is from this adapter.\n        if (queueWithdrawal[_requestId] == 0) revert NoPendingWithdrawal(); // Request is not from this adapter, not exist or already claimed\n\n        // Bedrock doesn't support claiming ETH per requestId.\n        // Someone can donate ETH with `redeemContract:pay` and add claimable ETH.\n        // So, here make sure that the debt has been deleted from the queue.\n        (, uint256 debt) = BEDROCK_STAKING.checkDebt(_requestId);\n        if (debt > 0) revert RequestNotFinalized(); // Not finalized yet\n\n        /// INTERACT ///\n        uint256 claimable = IRedeem(BEDROCK_STAKING.redeemContract()).balanceOf(address(this)); // donation + unstaked ETH\n        uint256 balanceBefore = address(this).balance;\n        IRedeem(BEDROCK_STAKING.redeemContract()).claim(claimable);\n        uint256 claimed = address(this).balance - balanceBefore;\n\n        /// WRITE ///\n        delete queueWithdrawal[_requestId];\n        delete totalQueueEth;\n        bufferEth += claimed.toUint128();\n\n        IWETH9(Constants.WETH).deposit{value: claimed}();\n        emit ClaimWithdrawal(_requestId, claimed);\n    }\n\n    /// @dev Escape hatch\n    /// @param withdrawAmount Amount of ETH to withdraw in multiples of 32 ETH\n    /// @param deadline Deadline for the withdrawal\n    function requestWithdrawal(uint256 withdrawAmount, uint256 deadline) external nonReentrant onlyRebalancer {\n        if (block.timestamp > deadline) revert TransactionTooOld();\n        (uint256 queuedEth, uint256 _requestId) = _requestWithdrawal(withdrawAmount);\n        if (queueWithdrawal[_requestId] != 0) revert WithdrawalPending();\n        /// WRITE ///\n        totalQueueEth += queuedEth.toUint128();\n        queueWithdrawal[_requestId] = queuedEth;\n    }\n\n    function requestWithdrawalAll() external override nonReentrant onlyRebalancer {\n        /// INTERACT ///\n        uint256 balance = UNIETH.balanceOf(address(this));\n        uint256 withdrawAmount = (BEDROCK_STAKING.exchangeRatio() * balance) / 1e18;\n\n        (uint256 queuedEth, uint256 _requestId) = _requestWithdrawal(withdrawAmount);\n        if (queueWithdrawal[_requestId] != 0) revert WithdrawalPending();\n        /// WRITE ///\n        totalQueueEth += queuedEth.toUint128();\n        queueWithdrawal[_requestId] = queuedEth;\n    }\n\n    /// @dev No cap on withdrawal\n    function _requestWithdrawal(uint256 withdrawAmount) internal override returns (uint256, uint256) {\n        // Check whether adapter has any pending request. Only one request is allowed at a time.\n        if (totalQueueEth > 0) revert RequestInQueue();\n\n        // They can only allow withdrawal in multiples of 32 eth\n        withdrawAmount -= (withdrawAmount % 32 ether);\n        if (withdrawAmount == 0) revert InvalidWithdrawalAmount();\n        /// INTERACT ///\n        // Bedrock burns some uniETH from the balance of this adapter and tracks the debt.\n        (, uint256 requestId) = BEDROCK_STAKING.getDebtQueue();\n        requestId++; // Next debt index\n        uint256 debtPrior = BEDROCK_STAKING.debtOf(address(this));\n        BEDROCK_STAKING.redeemFromValidators({\n            ethersToRedeem: withdrawAmount,\n            maxToBurn: type(uint256).max,\n            deadline: block.timestamp + 1\n        });\n        if (BEDROCK_STAKING.debtOf(address(this)) != debtPrior + withdrawAmount) revert InvariantViolation();\n\n        emit RequestWithdrawal(requestId, withdrawAmount);\n        return (withdrawAmount, requestId);\n    }\n\n    /// @notice Withdraw ETH from Bedrock instantly through pending ETH in Bedrock staking contract\n    /// @dev Revert if Bedrock staking contract doesn't have enough pending ETH worth of `uniEthAmount` uniETH.\n    /// @param uniEthAmount Amount of uniETH to burn. Limited to pending ETH in Bedrock staking contract.\n    function withdraw(uint256 uniEthAmount) external nonReentrant onlyRebalancer {\n        /// INTERACT ///\n        uint256 balanceBefore = address(this).balance;\n        BEDROCK_STAKING.instantSwap(uniEthAmount);\n        uint256 received = address(this).balance - balanceBefore;\n\n        IWETH9(Constants.WETH).deposit{value: received}();\n\n        /// WRITE ///\n        bufferEth += received.toUint128();\n    }\n\n    /// @notice Swap uniETH for ETH\n    /// @dev This function is only callable by the rebalancer\n    /// @param amount Amount of ETH to swap\n    /// @param deadline Deadline for the swap\n    /// @param minEthOut Minimum amount of ETH to receive\n    /// @param data Data for the swap\n    function swapUniETHForETH(\n        uint256 amount,\n        uint256 deadline,\n        uint256 minEthOut,\n        bytes calldata data\n    ) external nonReentrant onlyRebalancer {\n        if (amount >= 32 ether) revert SwapAmountTooLarge();\n\n        /// INTERACT ///\n        uint256 balanceBefore = IWETH9(Constants.WETH).balanceOf(address(this));\n        SafeERC20.forceApprove(IERC20(Constants.UNIETH), address(swapper), amount + 1); // avoild storage value goes to 0\n        swapper.swap(amount, deadline, minEthOut, data);\n        uint256 received = IWETH9(Constants.WETH).balanceOf(address(this)) - balanceBefore;\n\n        /// WRITE ///\n        bufferEth += SafeCast.toUint128(received);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        uint256 uniEthBalance = UNIETH.balanceOf(address(this));\n        return totalQueueEth + bufferEth + (uniEthBalance * BEDROCK_STAKING.exchangeRatio()) / 1e18;\n    }\n\n    function setSwapper(address _swapper) external onlyOwner {\n        swapper = UniETHSwapper(_swapper);\n    }\n}"
    },
    {
      "filename": "napier-v1/src/adapters/etherfi/EETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts@4.9.3/token/ERC721/IERC721Receiver.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {ERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/ERC20.sol\";\n\nimport {IWithdrawRequestNFT} from \"./interfaces/IWithdrawRequestNFT.sol\";\nimport {ILiquidityPool} from \"./interfaces/ILiquidityPool.sol\";\nimport {IWETH9} from \"../../interfaces/IWETH9.sol\";\nimport {IeETH} from \"./interfaces/IeETH.sol\";\n\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapter} from \"../BaseLSTAdapter.sol\";\n\n/// @title EEtherAdapter - eeETH\n/// @dev Important security note:\n/// 1. The staking rewards are distributed to the eETH holders by the rebasing mechanism\n/// where its balance is updated automatically on all the addresses.\n/// The rebase mechanism is implemented via shares where the share represents the eETH holder's\n/// share in the total amount of ether controlled by the ether.fi protocol.\n///\n/// 2. This contract doesn't independently keep track of the eETH balance, so it is possible\n/// for an attacker to directly transfer eETH to this contract, increase the share price.\ncontract EEtherAdapter is BaseLSTAdapter, IERC721Receiver {\n    using SafeCast for uint256;\n\n    error InvariantViolation();\n    error RequestInQueue();\n    error WithdrawalBelowMinimum();\n\n    /// @notice eETH\n    IeETH constant EETH = IeETH(Constants.EETH);\n\n    /// @dev EtherFi WithdrawRequestNFT\n    IWithdrawRequestNFT constant ETHERFI_WITHDRAW_NFT = IWithdrawRequestNFT(Constants.ETHERFI_WITHDRAW_REQUEST);\n\n    /// @dev EtherFi LiquidityPool\n    ILiquidityPool constant LIQUIDITY_POOL = ILiquidityPool(Constants.ETHERFI_LP);\n\n    receive() external payable {}\n\n    constructor(\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) BaseLSTAdapter(_rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock) ERC20(\"Napier EETH Adapter\", \"eeETH\") {\n        EETH.approve(address(LIQUIDITY_POOL), type(uint256).max);\n    }\n\n    /// @notice Claim withdrawal from etherfi\n    /// @dev Reverts if there is no pending withdrawal\n    /// @dev Reverts if the withdrawal request is in queue by etherfi\n    /// @dev note eeETH scale may be decreased as etherfi has the withdrawal fee.\n    function claimWithdrawal(uint256 _requestId) external override nonReentrant {\n        uint256 queued = queueWithdrawal[_requestId];\n        if (queued == 0) revert NoPendingWithdrawal();\n\n        /// ASSERT ///\n        // EtherFi is completing withdraws internally and its number is set to lastFinalizedRequestId.\n        // If _requstId is finalized on etherfi, it's reverted.\n        if (_requestId < ETHERFI_WITHDRAW_NFT.lastFinalizedRequestId()) revert RequestInQueue();\n\n        /// INTERACT ///\n        // Claimed amount can be less than requested amount due to slashing.\n        uint256 balanceBefore = address(this).balance;\n        ETHERFI_WITHDRAW_NFT.claimWithdraw(_requestId);\n        uint256 claimed = address(this).balance - balanceBefore;\n        /// WRITE ///\n        delete queueWithdrawal[_requestId];\n        totalQueueEth -= queued.toUint128();\n        bufferEth += claimed.toUint128();\n\n        IWETH9(Constants.WETH).deposit{value: claimed}();\n        emit ClaimWithdrawal(_requestId, claimed);\n    }\n\n    /// @notice Stake ether to etherfi liquidity pool\n    /// @dev EtherFi doesn't have stake limit.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _eETHAmt = LIQUIDITY_POOL.deposit{value: stakeAmount}();\n\n        if (_eETHAmt == 0) revert InvariantViolation();\n        return stakeAmount;\n    }\n\n    /// @inheritdoc BaseLSTAdapter\n    function requestWithdrawalAll() external override nonReentrant onlyRebalancer {\n        /// INTERACT ///\n        (uint256 queuedEth, uint256 _requestId) = _requestWithdrawal(EETH.balanceOf(address(this)));\n        if (queueWithdrawal[_requestId] != 0) revert WithdrawalPending();\n        /// WRITE ///\n        totalQueueEth += queuedEth.toUint128();\n        queueWithdrawal[_requestId] = queuedEth;\n    }\n\n    /// @notice Request withdrawal for custom amount\n    function requestWithdrawal(uint256 withdrawAmount) external nonReentrant onlyRebalancer {\n        if (withdrawAmount > EETH.balanceOf(address(this))) revert InvalidWithdrawalAmount();\n        /// INTERACT ///\n        (uint256 queuedEth, uint256 _requestId) = _requestWithdrawal(withdrawAmount);\n        if (queueWithdrawal[_requestId] != 0) revert WithdrawalPending();\n        /// WRITE ///\n        totalQueueEth += queuedEth.toUint128();\n        queueWithdrawal[_requestId] = queuedEth;\n    }\n\n    /// @inheritdoc BaseLSTAdapter\n    function _requestWithdrawal(uint256 withdrawAmount) internal override returns (uint256, uint256) {\n        // The max amount for a request is 500 ether to chunk the large withdrawals into smaller ones.\n        if (withdrawAmount < 100) revert WithdrawalBelowMinimum();\n        if (withdrawAmount > 500 ether) withdrawAmount = 500 ether;\n\n        /// INTERACT ///\n        // The amount of ether that will be withdrawn is limited to\n        // the number of eETH tokens transferred to this contract at the moment of request.\n        // So, we will not receive the rewards for the period of time while these tokens stay in the queue.\n        uint256 _requestId = LIQUIDITY_POOL.requestWithdraw(address(this), withdrawAmount); // Dev: Ensure id is not 0\n        if (_requestId == 0) revert InvariantViolation();\n\n        emit RequestWithdrawal(_requestId, withdrawAmount);\n        return (withdrawAmount, _requestId);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        uint256 eEthBalance = EETH.balanceOf(address(this));\n        return totalQueueEth + bufferEth + eEthBalance;\n    }\n\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return 0x150b7a02; // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n    }\n}"
    },
    {
      "filename": "napier-uups-adapters/src/adapters/kelp/RsETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\nimport {ILRTOracle} from \"./interfaces/ILRTOracle.sol\";\nimport {ILRTDepositPool} from \"./interfaces/ILRTDepositPool.sol\";\n\n// libs\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable@4.9.3/token/ERC20/IERC20Upgradeable.sol\";\nimport {LSTAdapterStorage} from \"../../Structs.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapterUpgradeable} from \"../BaseLSTAdapterUpgradeable.sol\";\n\n/// @notice RsETHAdapter - eRsETH (Napier rsETH Adapter)\n/// @notice rsETH is a Liquid Restaked Token (LRT) issued by Kelp DAO designed\n/// to offer liquidity to illiquid assets deposited into restaking platforms,\n///  such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking\ncontract RsETHAdapter is BaseLSTAdapterUpgradeable {\n    /// @notice LRTDepositPool\n    ILRTDepositPool constant RSETH_DEPOSIT_POOL = ILRTDepositPool(Constants.RSETH_DEPOSIT_POOL);\n\n    /// @notice LRTOracle\n    ILRTOracle constant RSETH_ORACLE = ILRTOracle(Constants.RSETH_ORACLE);\n\n    /// @notice rsETH\n    IERC20Upgradeable constant RSETH = IERC20Upgradeable(Constants.RSETH);\n\n    /// @notice RSETH referral id\n    string constant REFERRAL_ID = \"Napier-RsETHAdapter\";\n\n    error OnlyWETHOrRETH();\n    error InvariantViolation();\n    error MinAmountToDepositError();\n    error ProtocolPaused();\n\n    receive() external payable {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) public initializer {\n        __BaseLSTAdapter_init(_owner, _rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock);\n        __ERC20_init(\"Napier rsETH Adapter\", \"eRsETH\");\n    }\n\n    /// @notice Claim withdrawal from Kelp\n    /// @dev Kelp doesn't have claim functionality yet.\n    function claimWithdrawal(uint256) external pure override {\n        revert NotImplemented();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Rebalancer functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @notice Kelp allows ETH, ETHx, stETH or sfrxETH via LRTDepositPool.\n    /// @dev Kelp has a limit on the amount of ETH"
    }
  ]
}