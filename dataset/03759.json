{
  "Title": "Outdated `_cachedVaults` after `registry` changing",
  "Content": "##### Description\nEach `registry` has own `vaults` variable. It is possible that new `registry` contains different set of Vaults. In `allVaults` function we always copy old `_cachedVaults` https://github.com/yearn/yearn-vaults/blob/e390c2a6b2ba6e2ecc8f3a72a1ea4adfabd17544/contracts/BaseWrapper.sol#L71-73. \n\nThe cache is updated with `allVaults` produce https://github.com/yearn/yearn-vaults/blob/e390c2a6b2ba6e2ecc8f3a72a1ea4adfabd17544/contracts/BaseWrapper.sol#L148-149.\n\nSo we will never update `_cachedVaults` prefix part.\n\n##### Recommendation\nIt is recommended to update all elements of the `_cachedVaults` array in the `setRegistry()` function.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/BaseWrapper.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/math/Math.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport {VaultAPI} from \"./BaseStrategy.sol\";\n\ninterface RegistryAPI {\n    function governance() external view returns (address);\n\n    function latestVault(address token) external view returns (address);\n\n    function numVaults(address token) external view returns (uint256);\n\n    function vaults(address token, uint256 deploymentId) external view returns (address);\n}\n\nabstract contract BaseWrapper {\n    using Math for uint256;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public token;\n\n    // Reduce number of external calls (SLOADs stay the same)\n    VaultAPI[] private _cachedVaults;\n\n    RegistryAPI public registry;\n\n    // ERC20 Unlimited Approvals (short-circuits VaultAPI.transferFrom)\n    uint256 constant UNLIMITED_APPROVAL = type(uint256).max;\n    // Sentinal values used to save gas on deposit/withdraw/migrate\n    // NOTE: DEPOSIT_EVERYTHING == WITHDRAW_EVERYTHING == MIGRATE_EVERYTHING\n    uint256 constant DEPOSIT_EVERYTHING = type(uint256).max;\n    uint256 constant WITHDRAW_EVERYTHING = type(uint256).max;\n    uint256 constant MIGRATE_EVERYTHING = type(uint256).max;\n    // VaultsAPI.depositLimit is unlimited\n    uint256 constant UNCAPPED_DEPOSITS = type(uint256).max;\n\n    constructor(address _token, address _registry) public {\n        token = IERC20(_token);\n        // v2.registry.ychad.eth\n        registry = RegistryAPI(_registry);\n    }\n\n    function setRegistry(address _registry) external {\n        require(msg.sender == registry.governance());\n        // In case you want to override the registry instead of re-deploying\n        registry = RegistryAPI(_registry);\n    }\n\n    function bestVault() public virtual view returns (VaultAPI) {\n        return VaultAPI(registry.latestVault(address(token)));\n    }\n\n    function allVaults() public virtual view returns (VaultAPI[] memory) {\n        uint256 cache_length = _cachedVaults.length;\n        uint256 num_vaults = registry.numVaults(address(token));\n\n        // Use cached\n        if (cache_length == num_vaults) {\n            return _cachedVaults;\n        }\n\n        VaultAPI[] memory vaults = new VaultAPI[](num_vaults);\n\n        for (uint256 vault_id = 0; vault_id < cache_length; vault_id++) {\n            vaults[vault_id] = _cachedVaults[vault_id];\n        }\n\n        for (uint256 vault_id = cache_length; vault_id < num_vaults; vault_id++) {\n            vaults[vault_id] = VaultAPI(registry.vaults(address(token), vault_id));\n        }\n\n        return vaults;\n    }\n\n    function _updateVaultCache(VaultAPI[] memory vaults) internal {\n        if (vaults.length > _cachedVaults.length) {\n            _cachedVaults = vaults;\n        }\n    }\n\n    function totalVaultBalance(address account) public view returns (uint256 balance) {\n        VaultAPI[] memory vaults = allVaults();\n\n        for (uint256 id = 0; id < vaults.length; id++) {\n            balance = balance.add(vaults[id].balanceOf(account).mul(vaults[id].pricePerShare()).div(10**uint256(vaults[id].decimals())));\n        }\n    }\n\n    function totalAssets() public view returns (uint256 assets) {\n        VaultAPI[] memory vaults = allVaults();\n\n        for (uint256 id = 0; id < vaults.length; id++) {\n            assets = assets.add(vaults[id].totalAssets());\n        }\n    }\n\n    function _deposit(\n        address depositor,\n        address receiver,\n        uint256 amount, // if `MAX_UINT256`, just deposit everything\n        bool pullFunds // If true, funds need to be pulled from `depositor` via `transferFrom`\n    ) internal returns (uint256 deposited) {\n        VaultAPI _bestVault = bestVault();\n\n        if (pullFunds) {\n            token.safeTransferFrom(depositor, address(this), amount);\n        }\n\n        if (token.allowance(address(this), address(_bestVault)) < amount) {\n            token.safeApprove(address(_bestVault), UNLIMITED_APPROVAL); // Vaults are trusted\n        }\n\n        // Depositing returns number of shares deposited\n        // NOTE: Shortcut here is assuming the number of tokens deposited is equal to the\n        //       number of shares credited, which helps avoid an occasional multiplication\n        //       overflow if trying to adjust the number of shares by the share price.\n        uint256 beforeBal = token.balanceOf(address(this));\n        if (receiver != address(this)) {\n            _bestVault.deposit(amount, receiver);\n        } else if (amount != DEPOSIT_EVERYTHING) {\n            _bestVault.deposit(amount);\n        } else {\n            _bestVault.deposit();\n        }\n\n        uint256 afterBal = token.balanceOf(address(this));\n        deposited = beforeBal.sub(afterBal);\n        // `receiver` now has shares of `_bestVault` as balance, converted to `token` here\n        // Issue a refund if not everything was deposited\n        if (depositor != address(this) && afterBal > 0) token.transfer(depositor, afterBal);\n    }\n\n    function _withdraw(\n        address sender,\n        address receiver,\n        uint256 amount, // if `MAX_UINT256`, just withdraw everything\n        bool withdrawFromBest // If true, also withdraw from `_bestVault`\n    ) internal returns (uint256 withdrawn) {\n        VaultAPI _bestVault = bestVault();\n\n        VaultAPI[] memory vaults = allVaults();\n        _updateVaultCache(vaults);\n\n        for (uint256 id = 0; id < vaults.length; id++) {\n            if (!withdrawFromBest && vaults[id] == _bestVault) {\n                continue; // Don't withdraw from the best\n            }\n\n            // Start with the total shares that `sender` has\n            uint256 availableShares = vaults[id].balanceOf(sender);\n\n            // Restrict by the allowance that `sender` has to this contract\n            // NOTE: No need for allowance check if `sender` is this contract\n            if (sender != address(this)) {\n                availableShares = Math.min(availableShares, vaults[id].allowance(sender, address(this)));\n            }\n\n            // Limit by maximum withdrawal size from each vault\n            availableShares = Math.min(availableShares, vaults[id].maxAvailableShares());\n\n            if (availableShares > 0) {\n                // Intermediate step to move shares to this contract before withdrawing\n                // NOTE: No need for share transfer if this contract is `sender`\n                if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares);\n\n                if (amount != WITHDRAW_EVERYTHING) {\n                    // Compute amount to withdraw fully to satisfy the request\n                    uint256 estimatedShares = amount\n                        .sub(withdrawn) // NOTE: Changes every iteration\n                        .mul(10**uint256(vaults[id].decimals()))\n                        .div(vaults[id].pricePerShare()); // NOTE: Every Vault is different\n\n                    // Limit amount to withdraw to the maximum made available to this contract\n                    uint256 shares = Math.min(estimatedShares, availableShares);\n                    withdrawn = withdrawn.add(vaults[id].withdraw(shares));\n                } else {\n                    withdrawn = withdrawn.add(vaults[id].withdraw());\n                }\n\n                // Check if we have fully satisfied the request\n                // NOTE: use `amount = WITHDRAW_EVERYTHING` for withdrawing everything\n                if (amount <= withdrawn) break; // withdrawn as much as we needed\n            }\n        }\n\n        // If we have extra, deposit back into `_bestVault` for `sender`\n        // NOTE: Invariant is `withdrawn <= amount`\n        if (withdrawn > amount) {\n            // Don't forget to approve the deposit\n            if (token.allowance(address(this), address(_bestVault)) < withdrawn.sub(amount)) {\n                token.safeApprove(address(_bestVault), UNLIMITED_APPROVAL); // Vaults are trusted\n            }\n\n            _bestVault.deposit(withdrawn.sub(amount), sender);\n            withdrawn = amount;\n        }\n\n        // `receiver` now has `withdrawn` tokens as balance\n        if (receiver != address(this)) token.safeTransfer(receiver, withdrawn);\n    }\n\n    function _migrate(address account) internal returns (uint256) {\n        return _migrate(account, MIGRATE_EVERYTHING);\n    }\n\n    function _migrate(address account, uint256 amount) internal returns (uint256) {\n        // NOTE: In practice, it was discovered that <50 was the maximum we've see for this variance\n        return _migrate(account, amount, 0);\n    }\n\n    function _migrate(\n        address account,\n        uint256 amount,\n        uint256 maxMigrationLoss\n    ) internal returns (uint256 migrated) {\n        VaultAPI _bestVault = bestVault();\n\n        // NOTE: Only override if we aren't migrating everything\n        uint256 _depositLimit = _bestVault.depositLimit();\n        uint256 _totalAssets = _bestVault.totalAssets();\n        if (_depositLimit <= _totalAssets) return 0; // Nothing to migrate (not a failure)\n\n        uint256 _amount = amount;\n        if (_depositLimit < UNCAPPED_DEPOSITS && _amount < WITHDRAW_EVERYTHING) {\n            // Can only deposit up to this amount\n            uint256 _depositLeft = _depositLimit.sub(_totalAssets);\n            if (_amount > _depositLeft) _amount = _depositLeft;\n        }\n\n        if (_amount > 0) {\n            // NOTE: `false` = don't withdraw from `_bestVault`\n            uint256 withdrawn = _withdraw(account, address(this), _amount, false);\n            if (withdrawn == 0) return 0; // Nothing to migrate (not a failure)\n\n            // NOTE: `false` = don't do `transferFrom` because it's already local\n            migrated = _deposit(address(this), account, withdrawn, false);\n            // NOTE: Due to the precision loss of certain calculations, there is a small inefficency\n            //       on how migrations are calculated, and this could lead to a DoS issue. Hence, this\n            //       value is made to be configurable to allow the user to specify how much is acceptable\n            require(withdrawn.sub(migrated) <= maxMigrationLoss);\n        } // else: nothing to migrate! (not a failure)\n    }\n}"
    },
    {
      "filename": "contracts/BaseWrapper.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/math/Math.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport {VaultAPI} from \"./BaseStrategy.sol\";\n\ninterface RegistryAPI {\n    function governance() external view returns (address);\n\n    function latestVault(address token) external view returns (address);\n\n    function numVaults(address token) external view returns (uint256);\n\n    function vaults(address token, uint256 deploymentId) external view returns (address);\n}\n\nabstract contract BaseWrapper {\n    using Math for uint256;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public token;\n\n    // Reduce number of external calls (SLOADs stay the same)\n    VaultAPI[] private _cachedVaults;\n\n    RegistryAPI public registry;\n\n    // ERC20 Unlimited Approvals (short-circuits VaultAPI.transferFrom)\n    uint256 constant UNLIMITED_APPROVAL = type(uint256).max;\n    // Sentinal values used to save gas on deposit/withdraw/migrate\n    // NOTE: DEPOSIT_EVERYTHING == WITHDRAW_EVERYTHING == MIGRATE_EVERYTHING\n    uint256 constant DEPOSIT_EVERYTHING = type(uint256).max;\n    uint256 constant WITHDRAW_EVERYTHING = type(uint256).max;\n    uint256 constant MIGRATE_EVERYTHING = type(uint256).max;\n    // VaultsAPI.depositLimit is unlimited\n    uint256 constant UNCAPPED_DEPOSITS = type(uint256).max;\n\n    constructor(address _token, address _registry) public {\n        token = IERC20(_token);\n        // v2.registry.ychad.eth\n        registry = RegistryAPI(_registry);\n    }\n\n    function setRegistry(address _registry) external {\n        require(msg.sender == registry.governance());\n        // In case you want to override the registry instead of re-deploying\n        registry = RegistryAPI(_registry);\n    }\n\n    function bestVault() public virtual view returns (VaultAPI) {\n        return VaultAPI(registry.latestVault(address(token)));\n    }\n\n    function allVaults() public virtual view returns (VaultAPI[] memory) {\n        uint256 cache_length = _cachedVaults.length;\n        uint256 num_vaults = registry.numVaults(address(token));\n\n        // Use cached\n        if (cache_length == num_vaults) {\n            return _cachedVaults;\n        }\n\n        VaultAPI[] memory vaults = new VaultAPI[](num_vaults);\n\n        for (uint256 vault_id = 0; vault_id < cache_length; vault_id++) {\n            vaults[vault_id] = _cachedVaults[vault_id];\n        }\n\n        for (uint256 vault_id = cache_length; vault_id < num_vaults; vault_id++) {\n            vaults[vault_id] = VaultAPI(registry.vaults(address(token), vault_id));\n        }\n\n        return vaults;\n    }\n\n    function _updateVaultCache(VaultAPI[] memory vaults) internal {\n        if (vaults.length > _cachedVaults.length) {\n            _cachedVaults = vaults;\n        }\n    }\n\n    function totalVaultBalance(address account) public view returns (uint256 balance) {\n        VaultAPI[] memory vaults = allVaults();\n\n        for (uint256 id = 0; id < vaults.length; id++) {\n            balance = balance.add(vaults[id].balanceOf(account).mul(vaults[id].pricePerShare()).div(10**uint256(vaults[id].decimals())));\n        }\n    }\n\n    function totalAssets() public view returns (uint256 assets) {\n        VaultAPI[] memory vaults = allVaults();\n\n        for (uint256 id = 0; id < vaults.length; id++) {\n            assets = assets.add(vaults[id].totalAssets());\n        }\n    }\n\n    function _deposit(\n        address depositor,\n        address receiver,\n        uint256 amount, // if `MAX_UINT256`, just deposit everything\n        bool pullFunds // If true, funds need to be pulled from `depositor` via `transferFrom`\n    ) internal returns (uint256 deposited) {\n        VaultAPI _bestVault = bestVault();\n\n        if (pullFunds) {\n            token.safeTransferFrom(depositor, address(this), amount);\n        }\n\n        if (token.allowance(address(this), address(_bestVault)) < amount) {\n            token.safeApprove(address(_bestVault), UNLIMITED_APPROVAL); // Vaults are trusted\n        }\n\n        // Depositing returns number of shares deposited\n        // NOTE: Shortcut here is assuming the number of tokens deposited is equal to the\n        //       number of shares credited, which helps avoid an occasional multiplication\n        //       overflow if trying to adjust the number of shares by the share price.\n        uint256 beforeBal = token.balanceOf(address(this));\n        if (receiver != address(this)) {\n            _bestVault.deposit(amount, receiver);\n        } else if (amount != DEPOSIT_EVERYTHING) {\n            _bestVault.deposit(amount);\n        } else {\n            _bestVault.deposit();\n        }\n\n        uint256 afterBal = token.balanceOf(address(this));\n        deposited = beforeBal.sub(afterBal);\n        // `receiver` now has shares of `_bestVault` as balance, converted to `token` here\n        // Issue a refund if not everything was deposited\n        if (depositor != address(this) && afterBal > 0) token.transfer(depositor, afterBal);\n    }\n\n    function _withdraw(\n        address sender,\n        address receiver,\n        uint256 amount, // if `MAX_UINT256`, just withdraw everything\n        bool withdrawFromBest // If true, also withdraw from `_bestVault`\n    ) internal returns (uint256 withdrawn) {\n        VaultAPI _bestVault = bestVault();\n\n        VaultAPI[] memory vaults = allVaults();\n        _updateVaultCache(vaults);\n\n        for (uint256 id = 0; id < vaults.length; id++) {\n            if (!withdrawFromBest && vaults[id] == _bestVault) {\n                continue; // Don't withdraw from the best\n            }\n\n            // Start with the total shares that `sender` has\n            uint256 availableShares = vaults[id].balanceOf(sender);\n\n            // Restrict by the allowance that `sender` has to this contract\n            // NOTE: No need for allowance check if `sender` is this contract\n            if (sender != address(this)) {\n                availableShares = Math.min(availableShares, vaults[id].allowance(sender, address(this)));\n            }\n\n            // Limit by maximum withdrawal size from each vault\n            availableShares = Math.min(availableShares, vaults[id].maxAvailableShares());\n\n            if (availableShares > 0) {\n                // Intermediate step to move shares to this contract before withdrawing\n                // NOTE: No need for share transfer if this contract is `sender`\n                if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares);\n\n                if (amount != WITHDRAW_EVERYTHING) {\n                    // Compute amount to withdraw fully to satisfy the request\n                    uint256 estimatedShares = amount\n                        .sub(withdrawn) // NOTE: Changes every iteration\n                        .mul(10**uint256(vaults[id].decimals()))\n                        .div(vaults[id].pricePerShare()); // NOTE: Every Vault is different\n\n                    // Limit amount to withdraw to the maximum made available to this contract\n                    uint256 shares = Math.min(estimatedShares, availableShares);\n                    withdrawn = withdrawn.add(vaults[id].withdraw(shares));\n                } else {\n                    withdrawn = withdrawn.add(vaults[id].withdraw());\n                }\n\n                // Check if we have fully satisfied the request\n                // NOTE: use `amount = WITHDRAW_EVERYTHING` for withdrawing everything\n                if (amount <= withdrawn) break; // withdrawn as much as we needed\n            }\n        }\n\n        // If we have extra, deposit back into `_bestVault` for `sender`\n        // NOTE: Invariant is `withdrawn <= amount`\n        if (withdrawn > amount) {\n            // Don't forget to approve the deposit\n            if (token.allowance(address(this), address(_bestVault)) < withdrawn.sub(amount)) {\n                token.safeApprove(address(_bestVault), UNLIMITED_APPROVAL); // Vaults are trusted\n            }\n\n            _bestVault.deposit(withdrawn.sub(amount), sender);\n            withdrawn = amount;\n        }\n\n        // `receiver` now has `withdrawn` tokens as balance\n        if (receiver != address(this)) token.safeTransfer(receiver, withdrawn);\n    }\n\n    function _migrate(address account) internal returns (uint256) {\n        return _migrate(account, MIGRATE_EVERYTHING);\n    }\n\n    function _migrate(address account, uint256 amount) internal returns (uint256) {\n        // NOTE: In practice, it was discovered that <50 was the maximum we've see for this variance\n        return _migrate(account, amount, 0);\n    }\n\n    function _migrate(\n        address account,\n        uint256 amount,\n        uint256 maxMigrationLoss\n    ) internal returns (uint256 migrated) {\n        VaultAPI _bestVault = bestVault();\n\n        // NOTE: Only override if we aren't migrating everything\n        uint256 _depositLimit = _bestVault.depositLimit();\n        uint256 _totalAssets = _bestVault.totalAssets();\n        if (_depositLimit <= _totalAssets) return 0; // Nothing to migrate (not a failure)\n\n        uint256 _amount = amount;\n        if (_depositLimit < UNCAPPED_DEPOSITS && _amount < WITHDRAW_EVERYTHING) {\n            // Can only deposit up to this amount\n            uint256 _depositLeft = _depositLimit.sub(_totalAssets);\n            if (_amount > _depositLeft) _amount = _depositLeft;\n        }\n\n        if (_amount > 0) {\n            // NOTE: `false` = don't withdraw from `_bestVault`\n            uint256 withdrawn = _withdraw(account, address(this), _amount, false);\n            if (withdrawn == 0) return 0; // Nothing to migrate (not a failure)\n\n            // NOTE: `false` = don't do `transferFrom` because it's already local\n            migrated = _deposit(address(this), account, withdrawn, false);\n            // NOTE: Due to the precision loss of certain calculations, there is a small inefficency\n            //       on how migrations are calculated, and this could lead to a DoS issue. Hence, this\n            //       value is made to be configurable to allow the user to specify how much is acceptable\n            require(withdrawn.sub(migrated) <= maxMigrationLoss);\n        } // else: nothing to migrate! (not a failure)\n    }\n}"
    }
  ]
}