{
  "Title": "[G-05] Place size check at the start of maxHeapify() to save gas on returning case",
  "Content": "\nThe check on Line 107 can be moved to the start of the [maxHeapify()](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/MaxHeap.sol#L94) function. This will save gas when the condition becomes true because the computations from Line 100 to 105 will not be executed for the returning case since we will return early.\n\nInstead of this:\n```solidity\nFile: MaxHeap.sol\n099:     function maxHeapify(uint256 pos) internal {\n100:         uint256 left = 2 * pos + 1; \n101:         uint256 right = 2 * pos + 2; \n102: \n103:         uint256 posValue = valueMapping[heap[pos]];\n104:         uint256 leftValue = valueMapping[heap[left]];\n105:         uint256 rightValue = valueMapping[heap[right]];\n106: \n107:         if (pos >= (size / 2) && pos <= size) return;\n109: \n111:         if (posValue < leftValue || posValue < rightValue) {\n113:             \n114:             if (leftValue > rightValue) { \n115:                 swap(pos, left);\n116:                 maxHeapify(left);\n117:             } else {\n118:                 swap(pos, right);\n119:                 maxHeapify(right);\n120:             }\n121:         }\n122:     }\n```\nUse this (see line 99):\n```solidity\nFile: MaxHeap.sol\n098:     function maxHeapify(uint256 pos) internal {\n099:         if (pos >= (size / 2) && pos <= size) return;\n100:         uint256 left = 2 * pos + 1; \n101:         uint256 right = 2 * pos + 2; \n102: \n103:         uint256 posValue = valueMapping[heap[pos]];\n104:         uint256 leftValue = valueMapping[heap[left]];\n105:         uint256 rightValue = valueMapping[heap[right]];\n106: \n109: \n111:         if (posValue < leftValue || posValue < rightValue) {\n113:             \n114:             if (leftValue > rightValue) { \n115:                 swap(pos, left);\n116:                 maxHeapify(left);\n117:             } else {\n118:                 swap(pos, right);\n119:                 maxHeapify(right);\n120:             }\n121:         }\n122:     }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/revolution/src/MaxHeap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\n/// @title MaxHeap implementation in Solidity\n/// @dev This contract implements a Max Heap data structure with basic operations\n/// @author Written by rocketman and gpt4\ncontract MaxHeap is VersionedContract, UUPS, Ownable2StepUpgradeable, ReentrancyGuardUpgradeable {\n    /// @notice The parent contract that is allowed to update the data store\n    address public admin;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                          MODIFIERS                       ///\n    ///                                                          ///\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Sender is not the admin\");\n        _;\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initializes the maxheap contract\n     * @param _initialOwner The initial owner of the contract\n     * @param _admin The contract that is allowed to update the data store\n     */\n    function initialize(address _initialOwner, address _admin) public initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        admin = _admin;\n\n        __Ownable_init(_initialOwner);\n        __ReentrancyGuard_init();\n    }\n\n    /// @notice Struct to represent an item in the heap by it's ID\n    mapping(uint256 => uint256) public heap;\n\n    uint256 public size = 0;\n\n    /// @notice Mapping to keep track of the value of an item in the heap\n    mapping(uint256 => uint256) public valueMapping;\n\n    /// @notice Mapping to keep track of the position of an item in the heap\n    mapping(uint256 => uint256) public positionMapping;\n\n    /// @notice Get the parent index of a given position\n    /// @param pos The position for which to find the parent\n    /// @return The index of the parent node\n    function parent(uint256 pos) private pure returns (uint256) {\n        require(pos != 0, \"Position should not be zero\");\n        return (pos - 1) / 2;\n    }\n\n    /// @notice Swap two nodes in the heap\n    /// @param fpos The position of the first node\n    /// @param spos The position of the second node\n    function swap(uint256 fpos, uint256 spos) private {\n        (heap[fpos], heap[spos]) = (heap[spos], heap[fpos]);\n        (positionMapping[heap[fpos]], positionMapping[heap[spos]]) = (fpos, spos);\n    }\n\n    /// @notice Reheapify the heap starting at a given position\n    /// @dev This ensures that the heap property is maintained\n    /// @param pos The starting position for the heapify operation\n    function maxHeapify(uint256 pos) internal {\n        uint256 left = 2 * pos + 1;\n        uint256 right = 2 * pos + 2;\n\n        uint256 posValue = valueMapping[heap[pos]];\n        uint256 leftValue = valueMapping[heap[left]];\n        uint256 rightValue = valueMapping[heap[right]];\n\n        if (pos >= (size / 2) && pos <= size) return;\n\n        if (posValue < leftValue || posValue < rightValue) {\n            if (leftValue > rightValue) {\n                swap(pos, left);\n                maxHeapify(left);\n            } else {\n                swap(pos, right);\n                maxHeapify(right);\n            }\n        }\n    }\n\n    /// @notice Insert an element into the heap\n    /// @dev The function will revert if the heap is full\n    /// @param itemId The item ID to insert\n    /// @param value The value to insert\n    function insert(uint256 itemId, uint256 value) public onlyAdmin {\n        heap[size] = itemId;\n        valueMapping[itemId] = value; // Update the value mapping\n        positionMapping[itemId] = size; // Update the position mapping\n\n        uint256 current = size;\n        while (current != 0 && valueMapping[heap[current]] > valueMapping[heap[parent(current)]]) {\n            swap(current, parent(current));\n            current = parent(current);\n        }\n        size++;\n    }\n\n    /// @notice Update the value of an existing item in the heap\n    /// @param itemId The item ID whose vote count needs to be updated\n    /// @param newValue The new value for the item\n    /// @dev This function adjusts the heap to maintain the max-heap property after updating the vote count\n    function updateValue(uint256 itemId, uint256 newValue) public onlyAdmin {\n        uint256 position = positionMapping[itemId];\n        uint256 oldValue = valueMapping[itemId];\n\n        // Update the value in the valueMapping\n        valueMapping[itemId] = newValue;\n\n        // Decide whether to perform upwards or downwards heapify\n        if (newValue > oldValue) {\n            // Upwards heapify\n            while (position != 0 && valueMapping[heap[position]] > valueMapping[heap[parent(position)]]) {\n                swap(position, parent(position));\n                position = parent(position);\n            }\n        } else if (newValue < oldValue) maxHeapify(position); // Downwards heapify\n    }\n\n    /// @notice Extract the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function extractMax() external onlyAdmin returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n\n        uint256 popped = heap[0];\n        heap[0] = heap[--size];\n        maxHeapify(0);\n\n        return (popped, valueMapping[popped]);\n    }\n\n    /// @notice Get the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function getMax() public view returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n        return (heap[0], valueMapping[heap[0]]);\n    }\n\n    ///                                                          ///\n    ///                     MAX HEAP UPGRADE                     ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    }
  ]
}