{
  "Title": "[M-08] Storage can be bloated with low value liquidity positions",
  "Content": "\nWhen using the substrate framework, it is one of the main goals of developers to prevent storage bloat. If storage can easily be bloated by users, this can lead to high costs for the maintainers of the chain and a potential DOS. A more in detail explanation can be found [here](https://docs.substrate.io/build/troubleshoot-your-code/#common-substrate-issues).\n\nThe Omnipool allows users to deposit liquidity to earn fees on swaps. Whenever a user deposits liquidity through `add_liquidity()`, he gets an NFT minted and the details of his deposit are stored in the `Positions` map:\n\n```rust\nlet instance_id = Self::create_and_mint_position_instance(&position_owner)?;\n\n<Positions<T>>::insert(instance_id, lp_position);\n```\n\nTo ensure that this storage is only used for serious deposits, it is ensured to be above `MinimumPoolLiquidity` which is `1,000,000` tokens in the runtime configuration.\n\n```rust\nensure!(\n\tamount >= T::MinimumPoolLiquidity::get() && amount > 0,\n\tError::<T>::MissingBalance\n);\n```\n\nAdditionally, whenever a deposit gets fully withdrawn, the storage entry is removed:\n\n```rust\nif updated_position.shares == Balance::zero() {\n\t// All liquidity removed, remove position and burn NFT instance\n\n\t<Positions<T>>::remove(position_id);\n\tT::NFTHandler::burn(&T::NFTCollectionId::get(), &position_id, Some(&who))?;\n\n\tSelf::deposit_event(Event::PositionDestroyed {\n\t\tposition_id,\n\t\towner: who.clone(),\n\t});\n}\n```\n\nUnfortunately, this implementation does not take into account that a malicious user can add `MinimumPoolLiquidity` tokens, and then instantly withdraw all but 1. In that case, he has incurred almost no cost for bloating the storage (besides the 1 token and gas fees) and can keep on doing this countless times.\n\n### Impact\n\nThe issue allows a malicious attacker to bloat the storage in a cheap way. If done often enough this allows him to DOS the functionality of the HydraDX protocol by bloating the storage significantly until it can't be maintained anymore. If the attacker uses a very low-value token, he only incurs the gas fee for each new entry.\n\nIf we consider that the intended cost for adding a new position entry (to potentially DOS) as defined by the `MinimumPoolLiquidity` should be `1_000_000` tokens, this issue allows an attacker to get the same storage bloat for `1/1_000_000` or 0.0001% of the intended cost.\n\n### Proof of Concept\n\nThe following testcase showcases the issue:\n\n```rust\n#[test]\nfn remove_liquidity_but_one() {\n\tExtBuilder::default()\n\t\t.with_endowed_accounts(vec![\n\t\t\t(Omnipool::protocol_account(), DAI, 1000 * ONE),\n\t\t\t(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),\n\t\t\t(LP2, 1_000, 2000 * ONE),\n\t\t\t(LP1, 1_000, 5000 * ONE),\n\t\t])\n\t\t.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))\n\t\t.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)\n\t\t.build()\n\t\t.execute_with(|| {\n\n\t\t\tlet liq_added = 1_000_000; //Exactly MinimumPoolLiquidity\n\t\t\tlet current_position_id = <NextPositionId<Test>>::get();\n\n\t\t\tassert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));\n\n\t\t\tlet liq_removed = 200 * ONE;\n\t\t\tassert_ok!(Omnipool::remove_liquidity(\n\t\t\t\tRuntimeOrigin::signed(LP1),\n\t\t\t\tcurrent_position_id,\n\t\t\t\t1_000_000-1 //Remove all but one asset\n\t\t\t));\n\n\t\t\tlet position = Positions::<Test>::get(current_position_id).unwrap();\n\t\t\tlet expected = Position::<Balance, AssetId> {\n\t\t\t\tasset_id: 1_000,\n\t\t\t\tamount: 1,\n\t\t\t\tshares: 1,\n\t\t\t\tprice: (1300000000650000, 2000000001000000),\n\t\t\t};\n\n\t\t\t//There now is a position with 1 single Wei bloating the storage\n\t\t\tassert_eq!(position, expected);\n\t\t});\n}\n```\n\nThe testcase can be added to the `pallets/omnipool/src/tests/remove_liquidity.rs` file.\n\n### Recommended Mitigation Steps\n\nThe issue can be mitigated by not letting the amount in an open position fall below `MinimumPoolLiquidity`. This can be enforced as follows in the `remove_liquidity()` function:\n\n```solidity\nensure!(\n\tupdated_position.amount >= T::MinimumPoolLiquidity::get() || updated_position.amount == 0,\n\tError::<T>::InsufficientLiquidity\n);\n```\n\n### Assessed type\n\nDoS\n\n**[enthusiastmartin (HydraDX) disputed and commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/54#issuecomment-1979163692):**\n > This is publicly known issue, raised by our team [here](https://github.com/galacticcouncil/HydraDX-node/issues/674).\n\n\n**[Lambda (judge) commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/54#issuecomment-1985489914):**\n > While the sponsor was already aware of the issue, it was not ruled out as a known issue in the audit description and therefore, cannot be deemed out of scope.\n\n**[QiuhaoLi (warden) commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/54#issuecomment-1996571933):**\n > @Lambda and @enthusiastmartin, thanks for the review. I have a question (not a dispute):\n >\n > Haven't we already limited the storage usage with gas fees (weight) in [omnipool/src/weights.rs](https://github.com/code-423n4/2024-02-hydradx/blob/main/HydraDX-node/pallets/omnipool/src/weights.rs#L95)?:\n> \n> ```rust\n> \t/// Storage: `Omnipool::Positions` (r:0 w:1)  <===\n> \t/// Proof: `Omnipool::Positions` (`max_values`: None, `max_size`: Some(100), added: 2575, mode: `MaxEncodedLen`)\n> \tfn add_liquidity() -> Weight {\n> \t\t// Proof Size summary in bytes:\n> \t\t//  Measured:  `3919`\n> \t\t//  Estimated: `8739`\n> \t\t// Minimum execution time: 220_969_000 picoseconds.\n> \t\tWeight::from_parts(222_574_000, 8739)\n> \t\t\t.saturating_add(T::DbWeight::get().reads(20))\n> \t\t\t.saturating_add(T::DbWeight::get().writes(14)) // <===\n> \t}\n> ```\n> \n> As we can see, the user will be charged the fees of storage writes for minting new positions. So if an attack tries to bloat the storage, it will suffer from the corresponding fees.\n\n**[J4X (warden) commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/54#issuecomment-1996595161):**\n > @QiuhaoLi - The costs for a protocol on Polkadot consist of 2 kinds of costs. The computation costs are forwarded to the user using the weights and the storage costs, which have to be handled by the protocol themselves. \n> \n> The attacker is correctly charged for the storage instruction (computation cost) but is able to force the protocol to incur the constant cost of maintaining the positions (storage cost). This storage cost should only be incurred by the protocol for serious positions, which is why they have set a minimum of 1 million tokens.  From positions of that size, they can recoup their storage cost through other fees. As one can see in the issue this can be circumvented and the protocol will not be able to recoup the storage costs through fees on dust positions leading to a potential DOS. This can happen if the storage is flooded with dust positions, leading to massive storage costs that the protocol can not recoup through fees due to the insufficient size of each position.  \n> \n> As the sponsor has acknowledged this is a valid issue that they are trying to fix internally, so I don't see why this should be invalidated.\n\n**[QiuhaoLi (warden) commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/54#issuecomment-1996610082):**\n > @J4X - thanks a lot for the explanation! I once thought about the cost of positions and decided it has been charged as fees just like Ethereum storage, which seems wrong. As I said this is not a dispute, just a question, nice finding!\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-hydradx",
  "Code": [
    {
      "filename": "HydraDX-node/pallets/omnipool/src/weights.rs",
      "content": "// This file is part of HydraDX.\n\n// Copyright (C) 2020-2023  Intergalactic, Limited (GIB).\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Autogenerated weights for `pallet_omnipool`\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2024-01-09, STEPS: `10`, REPEAT: `30`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `bench-bot`, CPU: `Intel(R) Core(TM) i7-7700K CPU @ 4.20GHz`\n//! WASM-EXECUTION: `Compiled`, CHAIN: `Some(\"dev\")`, DB CACHE: 1024\n\n// Executed Command:\n// target/release/hydradx\n// benchmark\n// pallet\n// --chain=dev\n// --steps=10\n// --repeat=30\n// --wasm-execution=compiled\n// --heap-pages=4096\n// --template=.maintain/pallet-weight-template-no-back.hbs\n// --pallet=pallet-omnipool\n// --output=weights-1.1.0/omnipool.rs\n// --extrinsic=*\n\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n#![allow(clippy::unnecessary_cast)]\n\nuse frame_support::{\n\ttraits::Get,\n\tweights::{constants::RocksDbWeight, Weight},\n};\nuse sp_std::marker::PhantomData;\n\n/// Weight functions needed for pallet_omnipool.\npub trait WeightInfo {\n\tfn add_token() -> Weight;\n\tfn add_liquidity() -> Weight;\n\tfn remove_liquidity() -> Weight;\n\tfn sell() -> Weight;\n\tfn buy() -> Weight;\n\tfn set_asset_tradable_state() -> Weight;\n\tfn refund_refused_asset() -> Weight;\n\tfn sacrifice_position() -> Weight;\n\tfn set_asset_weight_cap() -> Weight;\n\tfn router_execution_sell(c: u32, e: u32) -> Weight;\n\tfn router_execution_buy(c: u32, e: u32) -> Weight;\n\tfn withdraw_protocol_liquidity() -> Weight;\n\tfn remove_token() -> Weight;\n}\n\n/// Weights for pallet_omnipool using the hydraDX node and recommended hardware.\npub struct HydraWeight<T>(PhantomData<T>);\n\nimpl<T: frame_system::Config> WeightInfo for HydraWeight<T> {\n\t/// Storage: `Omnipool::Assets` (r:1 w:1)\n\t/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)\n\t/// Storage: `AssetRegistry::Assets` (r:2 w:0)\n\t/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(87), added: 2562, mode: `MaxEncodedLen`)\n\t/// Storage: `Uniques::Class` (r:1 w:1)\n\t/// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(190), added: 2665, mode: `MaxEncodedLen`)\n\t/// Storage: `Tokens::Accounts` (r:2 w:1)\n\t/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::NextPositionId` (r:1 w:1)\n\t/// Proof: `Omnipool::NextPositionId` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)\n\t/// Storage: `Uniques::Asset` (r:1 w:1)\n\t/// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(146), added: 2621, mode: `MaxEncodedLen`)\n\t/// Storage: `Uniques::CollectionMaxSupply` (r:1 w:0)\n\t/// Proof: `Uniques::CollectionMaxSupply` (`max_values`: None, `max_size`: Some(36), added: 2511, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)\n\t/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)\n\t/// Storage: `Tokens::TotalIssuance` (r:1 w:1)\n\t/// Proof: `Tokens::TotalIssuance` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)\n\t/// Storage: `EmaOracle::Accumulator` (r:1 w:1)\n\t/// Proof: `EmaOracle::Accumulator` (`max_values`: Some(1), `max_size`: Some(5921), added: 6416, mode: `MaxEncodedLen`)\n\t/// Storage: `Uniques::Account` (r:0 w:1)\n\t/// Proof: `Uniques::Account` (`max_values`: None, `max_size`: Some(112), added: 2587, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::Positions` (r:0 w:1)\n\t/// Proof: `Omnipool::Positions` (`max_values`: None, `max_size`: Some(100), added: 2575, mode: `MaxEncodedLen`)\n\tfn add_token() -> Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `3004`\n\t\t//  Estimated: `7406`\n\t\t// Minimum execution time: 141_394_000 picoseconds.\n\t\tWeight::from_parts(142_349_000, 7406)\n\t\t\t.saturating_add(T::DbWeight::get().reads(12))\n\t\t\t.saturating_add(T::DbWeight::get().writes(10))\n\t}\n\t/// Storage: `Tokens::Accounts` (r:3 w:3)\n\t/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::Assets` (r:1 w:1)\n\t/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)\n\t/// Storage: `EmaOracle::Oracles` (r:2 w:0)\n\t/// Proof: `EmaOracle::Oracles` (`max_values`: None, `max_size`: Some(177), added: 2652, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)\n\t/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::NextPositionId` (r:1 w:1)\n\t/// Proof: `Omnipool::NextPositionId` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)\n\t/// Storage: `Uniques::Asset` (r:1 w:1)\n\t/// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(146), added: 2621, mode: `MaxEncodedLen`)\n\t/// Storage: `Uniques::Class` (r:1 w:1)\n\t/// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(190), added: 2665, mode: `MaxEncodedLen`)\n\t/// Storage: `Uniques::CollectionMaxSupply` (r:1 w:0)\n\t/// Proof: `Uniques::CollectionMaxSupply` (`max_values`: None, `max_size`: Some(36), added: 2511, mode: `MaxEncodedLen`)\n\t/// Storage: `AssetRegistry::Assets` (r:2 w:0)\n\t/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(87), added: 2562, mode: `MaxEncodedLen`)\n\t/// Storage: `System::Account` (r:1 w:0)\n\t/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)\n\t/// Storage: `Tokens::TotalIssuance` (r:1 w:1)\n\t/// Proof: `Tokens::TotalIssuance` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)\n\t/// Storage: `EmaOracle::Accumulator` (r:1 w:1)\n\t/// Proof: `EmaOracle::Accumulator` (`max_values`: Some(1), `max_size`: Some(5921), added: 6416, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::LiquidityAddLimitPerAsset` (r:1 w:0)\n\t/// Proof: `CircuitBreaker::LiquidityAddLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (r:1 w:1)\n\t/// Proof: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (r:1 w:0)\n\t/// Proof: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (r:1 w:1)\n\t/// Proof: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `Uniques::Account` (r:0 w:1)\n\t/// Proof: `Uniques::Account` (`max_values`: None, `max_size`: Some(112), added: 2587, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::Positions` (r:0 w:1)\n\t/// Proof: `Omnipool::Positions` (`max_values`: None, `max_size`: Some(100), added: 2575, mode: `MaxEncodedLen`)\n\tfn add_liquidity() -> Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `3919`\n\t\t//  Estimated: `8739`\n\t\t// Minimum execution time: 220_969_000 picoseconds.\n\t\tWeight::from_parts(222_574_000, 8739)\n\t\t\t.saturating_add(T::DbWeight::get().reads(20))\n\t\t\t.saturating_add(T::DbWeight::get().writes(14))\n\t}\n\t/// Storage: `Uniques::Asset` (r:1 w:1)\n\t/// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(146), added: 2621, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::Positions` (r:1 w:1)\n\t/// Proof: `Omnipool::Positions` (`max_values`: None, `max_size`: Some(100), added: 2575, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::Assets` (r:1 w:1)\n\t/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)\n\t/// Storage: `Tokens::Accounts` (r:4 w:4)\n\t/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)\n\t/// Storage: `EmaOracle::Oracles` (r:2 w:0)\n\t/// Proof: `EmaOracle::Oracles` (`max_values`: None, `max_size`: Some(177), added: 2652, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)\n\t/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)\n\t/// Storage: `AssetRegistry::Assets` (r:2 w:0)\n\t/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(87), added: 2562, mode: `MaxEncodedLen`)\n\t/// Storage: `System::Account` (r:2 w:1)\n\t/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)\n\t/// Storage: `Tokens::TotalIssuance` (r:1 w:1)\n\t/// Proof: `Tokens::TotalIssuance` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)\n\t/// Storage: `MultiTransactionPayment::AccountCurrencyMap` (r:1 w:1)\n\t/// Proof: `MultiTransactionPayment::AccountCurrencyMap` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `MultiTransactionPayment::AcceptedCurrencies` (r:1 w:0)\n\t/// Proof: `MultiTransactionPayment::AcceptedCurrencies` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)\n\t/// Storage: `Uniques::Class` (r:1 w:1)\n\t/// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(190), added: 2665, mode: `MaxEncodedLen`)\n\t/// Storage: `EmaOracle::Accumulator` (r:1 w:1)\n\t/// Proof: `EmaOracle::Accumulator` (`max_values`: Some(1), `max_size`: Some(5921), added: 6416, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::LiquidityAddLimitPerAsset` (r:1 w:0)\n\t/// Proof: `CircuitBreaker::LiquidityAddLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (r:1 w:0)\n\t/// Proof: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (r:1 w:0)\n\t/// Proof: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (r:1 w:1)\n\t/// Proof: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `Uniques::Account` (r:0 w:1)\n\t/// Proof: `Uniques::Account` (`max_values`: None, `max_size`: Some(112), added: 2587, mode: `MaxEncodedLen`)\n\t/// Storage: `Uniques::ItemPriceOf` (r:0 w:1)\n\t/// Proof: `Uniques::ItemPriceOf` (`max_values`: None, `max_size`: Some(113), added: 2588, mode: `MaxEncodedLen`)\n\tfn remove_liquidity() -> Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `6903`\n\t\t//  Estimated: `11322`\n\t\t// Minimum execution time: 297_780_000 picoseconds.\n\t\tWeight::from_parts(299_506_000, 11322)\n\t\t\t.saturating_add(T::DbWeight::get().reads(23))\n\t\t\t.saturating_add(T::DbWeight::get().writes(16))\n\t}\n\t/// Storage: `Tokens::Accounts` (r:5 w:5)\n\t/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::Assets` (r:3 w:3)\n\t/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)\n\t/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)\n\t/// Storage: `DynamicFees::AssetFee` (r:2 w:0)\n\t/// Proof: `DynamicFees::AssetFee` (`max_values`: None, `max_size`: Some(24), added: 2499, mode: `MaxEncodedLen`)\n\t/// Storage: `AssetRegistry::Assets` (r:2 w:0)\n\t/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(87), added: 2562, mode: `MaxEncodedLen`)\n\t/// Storage: `System::Account` (r:3 w:2)\n\t/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)\n\t/// Storage: `MultiTransactionPayment::AccountCurrencyMap` (r:2 w:2)\n\t/// Proof: `MultiTransactionPayment::AccountCurrencyMap` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `MultiTransactionPayment::AcceptedCurrencies` (r:1 w:0)\n\t/// Proof: `MultiTransactionPayment::AcceptedCurrencies` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)\n\t/// Storage: `EmaOracle::Accumulator` (r:1 w:1)\n\t/// Proof: `EmaOracle::Accumulator` (`max_values`: Some(1), `max_size`: Some(5921), added: 6416, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::AllowedTradeVolumeLimitPerAsset` (r:2 w:2)\n\t/// Proof: `CircuitBreaker::AllowedTradeVolumeLimitPerAsset` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::LiquidityAddLimitPerAsset` (r:1 w:0)\n\t/// Proof: `CircuitBreaker::LiquidityAddLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (r:1 w:1)\n\t/// Proof: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (r:1 w:0)\n\t/// Proof: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (r:1 w:0)\n\t/// Proof: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::LinkedAccounts` (r:1 w:0)\n\t/// Proof: `Referrals::LinkedAccounts` (`max_values`: None, `max_size`: Some(80), added: 2555, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::Referrer` (r:1 w:0)\n\t/// Proof: `Referrals::Referrer` (`max_values`: None, `max_size`: Some(65), added: 2540, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::AssetRewards` (r:1 w:0)\n\t/// Proof: `Referrals::AssetRewards` (`max_values`: None, `max_size`: Some(49), added: 2524, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::TotalShares` (r:1 w:1)\n\t/// Proof: `Referrals::TotalShares` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::ReferrerShares` (r:1 w:1)\n\t/// Proof: `Referrals::ReferrerShares` (`max_values`: None, `max_size`: Some(64), added: 2539, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::TraderShares` (r:2 w:2)\n\t/// Proof: `Referrals::TraderShares` (`max_values`: None, `max_size`: Some(64), added: 2539, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::PendingConversions` (r:1 w:1)\n\t/// Proof: `Referrals::PendingConversions` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::CounterForPendingConversions` (r:1 w:1)\n\t/// Proof: `Referrals::CounterForPendingConversions` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)\n\tfn sell() -> Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `7179`\n\t\t//  Estimated: `13905`\n\t\t// Minimum execution time: 333_598_000 picoseconds.\n\t\tWeight::from_parts(336_465_000, 13905)\n\t\t\t.saturating_add(T::DbWeight::get().reads(35))\n\t\t\t.saturating_add(T::DbWeight::get().writes(23))\n\t}\n\t/// Storage: `Omnipool::Assets` (r:3 w:3)\n\t/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)\n\t/// Storage: `Tokens::Accounts` (r:5 w:5)\n\t/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)\n\t/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)\n\t/// Storage: `DynamicFees::AssetFee` (r:2 w:0)\n\t/// Proof: `DynamicFees::AssetFee` (`max_values`: None, `max_size`: Some(24), added: 2499, mode: `MaxEncodedLen`)\n\t/// Storage: `AssetRegistry::Assets` (r:2 w:0)\n\t/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(87), added: 2562, mode: `MaxEncodedLen`)\n\t/// Storage: `System::Account` (r:3 w:2)\n\t/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)\n\t/// Storage: `MultiTransactionPayment::AccountCurrencyMap` (r:2 w:2)\n\t/// Proof: `MultiTransactionPayment::AccountCurrencyMap` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `MultiTransactionPayment::AcceptedCurrencies` (r:1 w:0)\n\t/// Proof: `MultiTransactionPayment::AcceptedCurrencies` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)\n\t/// Storage: `EmaOracle::Accumulator` (r:1 w:1)\n\t/// Proof: `EmaOracle::Accumulator` (`max_values`: Some(1), `max_size`: Some(5921), added: 6416, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::AllowedTradeVolumeLimitPerAsset` (r:2 w:2)\n\t/// Proof: `CircuitBreaker::AllowedTradeVolumeLimitPerAsset` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::LiquidityAddLimitPerAsset` (r:1 w:0)\n\t/// Proof: `CircuitBreaker::LiquidityAddLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (r:1 w:1)\n\t/// Proof: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (r:1 w:0)\n\t/// Proof: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (r:1 w:0)\n\t/// Proof: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::LinkedAccounts` (r:1 w:0)\n\t/// Proof: `Referrals::LinkedAccounts` (`max_values`: None, `max_size`: Some(80), added: 2555, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::Referrer` (r:1 w:0)\n\t/// Proof: `Referrals::Referrer` (`max_values`: None, `max_size`: Some(65), added: 2540, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::AssetRewards` (r:1 w:0)\n\t/// Proof: `Referrals::AssetRewards` (`max_values`: None, `max_size`: Some(49), added: 2524, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::TotalShares` (r:1 w:1)\n\t/// Proof: `Referrals::TotalShares` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::ReferrerShares` (r:1 w:1)\n\t/// Proof: `Referrals::ReferrerShares` (`max_values`: None, `max_size`: Some(64), added: 2539, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::TraderShares` (r:2 w:2)\n\t/// Proof: `Referrals::TraderShares` (`max_values`: None, `max_size`: Some(64), added: 2539, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::PendingConversions` (r:1 w:1)\n\t/// Proof: `Referrals::PendingConversions` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::CounterForPendingConversions` (r:1 w:1)\n\t/// Proof: `Referrals::CounterForPendingConversions` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)\n\tfn buy() -> Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `7179`\n\t\t//  Estimated: `13905`\n\t\t// Minimum execution time: 333_688_000 picoseconds.\n\t\tWeight::from_parts(335_133_000, 13905)\n\t\t\t.saturating_add(T::DbWeight::get().reads(35))\n\t\t\t.saturating_add(T::DbWeight::get().writes(23))\n\t}\n\t/// Storage: `Omnipool::Assets` (r:1 w:1)\n\t/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)\n\tfn set_asset_tradable_state() -> Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `1305`\n\t\t//  Estimated: `3550`\n\t\t// Minimum execution time: 32_634_000 picoseconds.\n\t\tWeight::from_parts(33_024_000, 3550)\n\t\t\t.saturating_add(T::DbWeight::get().reads(1))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1))\n\t}\n\t/// Storage: `Omnipool::Assets` (r:1 w:0)\n\t/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)\n\t/// Storage: `Tokens::Accounts` (r:2 w:2)\n\t/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)\n\t/// Storage: `AssetRegistry::Assets` (r:1 w:0)\n\t/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(87), added: 2562, mode: `MaxEncodedLen`)\n\t/// Storage: `System::Account` (r:2 w:2)\n\t/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)\n\t/// Storage: `MultiTransactionPayment::AccountCurrencyMap` (r:1 w:1)\n\t/// Proof: `MultiTransactionPayment::AccountCurrencyMap` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `MultiTransactionPayment::AcceptedCurrencies` (r:1 w:0)\n\t/// Proof: `MultiTransactionPayment::AcceptedCurrencies` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)\n\tfn refund_refused_asset() -> Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `2336`\n\t\t//  Estimated: `6196`\n\t\t// Minimum execution time: 107_435_000 picoseconds.\n\t\tWeight::from_parts(108_211_000, 6196)\n\t\t\t.saturating_add(T::DbWeight::get().reads(8))\n\t\t\t.saturating_add(T::DbWeight::get().writes(5))\n\t}\n\t/// Storage: `Omnipool::Positions` (r:1 w:1)\n\t/// Proof: `Omnipool::Positions` (`max_values`: None, `max_size`: Some(100), added: 2575, mode: `MaxEncodedLen`)\n\t/// Storage: `Uniques::Asset` (r:1 w:1)\n\t/// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(146), added: 2621, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::Assets` (r:1 w:1)\n\t/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)\n\t/// Storage: `Uniques::Class` (r:1 w:1)\n\t/// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(190), added: 2665, mode: `MaxEncodedLen`)\n\t/// Storage: `Uniques::Account` (r:0 w:1)\n\t/// Proof: `Uniques::Account` (`max_values`: None, `max_size`: Some(112), added: 2587, mode: `MaxEncodedLen`)\n\t/// Storage: `Uniques::ItemPriceOf` (r:0 w:1)\n\t/// Proof: `Uniques::ItemPriceOf` (`max_values`: None, `max_size`: Some(113), added: 2588, mode: `MaxEncodedLen`)\n\tfn sacrifice_position() -> Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `2876`\n\t\t//  Estimated: `3655`\n\t\t// Minimum execution time: 75_289_000 picoseconds.\n\t\tWeight::from_parts(76_090_000, 3655)\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(6))\n\t}\n\t/// Storage: `Omnipool::Assets` (r:1 w:1)\n\t/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)\n\tfn set_asset_weight_cap() -> Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `1305`\n\t\t//  Estimated: `3550`\n\t\t// Minimum execution time: 32_857_000 picoseconds.\n\t\tWeight::from_parts(33_349_000, 3550)\n\t\t\t.saturating_add(T::DbWeight::get().reads(1))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1))\n\t}\n\t/// Storage: `Omnipool::Assets` (r:1 w:1)\n\t/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)\n\t/// Storage: `Tokens::Accounts` (r:3 w:3)\n\t/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)\n\t/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)\n\t/// Storage: `AssetRegistry::Assets` (r:2 w:0)\n\t/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(87), added: 2562, mode: `MaxEncodedLen`)\n\t/// Storage: `System::Account` (r:2 w:1)\n\t/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)\n\t/// Storage: `MultiTransactionPayment::AccountCurrencyMap` (r:1 w:0)\n\t/// Proof: `MultiTransactionPayment::AccountCurrencyMap` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `MultiTransactionPayment::AcceptedCurrencies` (r:1 w:0)\n\t/// Proof: `MultiTransactionPayment::AcceptedCurrencies` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)\n\t/// Storage: `Tokens::TotalIssuance` (r:1 w:1)\n\t/// Proof: `Tokens::TotalIssuance` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)\n\t/// Storage: `EmaOracle::Accumulator` (r:1 w:1)\n\t/// Proof: `EmaOracle::Accumulator` (`max_values`: Some(1), `max_size`: Some(5921), added: 6416, mode: `MaxEncodedLen`)\n\tfn withdraw_protocol_liquidity() -> Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `4019`\n\t\t//  Estimated: `8739`\n\t\t// Minimum execution time: 161_313_000 picoseconds.\n\t\tWeight::from_parts(162_354_000, 8739)\n\t\t\t.saturating_add(T::DbWeight::get().reads(13))\n\t\t\t.saturating_add(T::DbWeight::get().writes(8))\n\t}\n\t/// Storage: `Omnipool::Assets` (r:1 w:1)\n\t/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)\n\t/// Storage: `Tokens::Accounts` (r:4 w:3)\n\t/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)\n\t/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)\n\t/// Storage: `AssetRegistry::Assets` (r:2 w:0)\n\t/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(87), added: 2562, mode: `MaxEncodedLen`)\n\t/// Storage: `Tokens::TotalIssuance` (r:1 w:1)\n\t/// Proof: `Tokens::TotalIssuance` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)\n\t/// Storage: `System::Account` (r:2 w:2)\n\t/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)\n\t/// Storage: `MultiTransactionPayment::AccountCurrencyMap` (r:2 w:0)\n\t/// Proof: `MultiTransactionPayment::AccountCurrencyMap` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `MultiTransactionPayment::AcceptedCurrencies` (r:1 w:0)\n\t/// Proof: `MultiTransactionPayment::AcceptedCurrencies` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)\n\tfn remove_token() -> Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `3110`\n\t\t//  Estimated: `11322`\n\t\t// Minimum execution time: 160_104_000 picoseconds.\n\t\tWeight::from_parts(161_947_000, 11322)\n\t\t\t.saturating_add(T::DbWeight::get().reads(14))\n\t\t\t.saturating_add(T::DbWeight::get().writes(8))\n\t}\n\t/// Storage: `Omnipool::Assets` (r:3 w:3)\n\t/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)\n\t/// Storage: `Tokens::Accounts` (r:5 w:5)\n\t/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)\n\t/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)\n\t/// Storage: `DynamicFees::AssetFee` (r:2 w:0)\n\t/// Proof: `DynamicFees::AssetFee` (`max_values`: None, `max_size`: Some(24), added: 2499, mode: `MaxEncodedLen`)\n\t/// Storage: `AssetRegistry::Assets` (r:2 w:0)\n\t/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(87), added: 2562, mode: `MaxEncodedLen`)\n\t/// Storage: `System::Account` (r:3 w:2)\n\t/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)\n\t/// Storage: `MultiTransactionPayment::AccountCurrencyMap` (r:2 w:2)\n\t/// Proof: `MultiTransactionPayment::AccountCurrencyMap` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `MultiTransactionPayment::AcceptedCurrencies` (r:1 w:0)\n\t/// Proof: `MultiTransactionPayment::AcceptedCurrencies` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)\n\t/// Storage: `EmaOracle::Accumulator` (r:1 w:1)\n\t/// Proof: `EmaOracle::Accumulator` (`max_values`: Some(1), `max_size`: Some(5921), added: 6416, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::AllowedTradeVolumeLimitPerAsset` (r:2 w:2)\n\t/// Proof: `CircuitBreaker::AllowedTradeVolumeLimitPerAsset` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::LiquidityAddLimitPerAsset` (r:1 w:0)\n\t/// Proof: `CircuitBreaker::LiquidityAddLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (r:1 w:1)\n\t/// Proof: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (r:1 w:0)\n\t/// Proof: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)\n\t/// Storage: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (r:1 w:0)\n\t/// Proof: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::LinkedAccounts` (r:1 w:0)\n\t/// Proof: `Referrals::LinkedAccounts` (`max_values`: None, `max_size`: Some(80), added: 2555, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::AssetRewards` (r:1 w:0)\n\t/// Proof: `Referrals::AssetRewards` (`max_values`: None, `max_size`: Some(49), added: 2524, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::TotalShares` (r:1 w:1)\n\t/// Proof: `Referrals::TotalShares` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::TraderShares` (r:2 w:2)\n\t/// Proof: `Referrals::TraderShares` (`max_values`: None, `max_size`: Some(64), added: 2539, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::PendingConversions` (r:1 w:1)\n\t/// Proof: `Referrals::PendingConversions` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)\n\t/// Storage: `Referrals::CounterForPendingConversions` (r:1 w:1)\n\t/// Proof: `Referrals::CounterForPendingConversions` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)\n\t/// The range of component `c` is `[1, 2]`.\n\t/// The range of component `e` is `[0, 1]`.\n\tfn router_execution_sell(c: u32, e: u32) -> Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `1974 + e * (4788 ±0)`\n\t\t//  Estimated: `6156 + e * (7749 ±0)`\n\t\t// Minimum execution time: 48_705_000 picoseconds.\n\t\tWeight::from_parts(49_088_855, 6156)\n\t\t\t// Standard Error: 97_412\n\t\t\t.saturating_add(Weight::from_parts(321_546, 0).saturating_mul(c.into()))\n\t\t\t// Standard Error: 97_412\n\t\t\t.saturating_add(Weight::from_parts(291_861_384, 0).saturating_mul(e.into()))\n\t\t\t.saturating_add(T::DbWeight::get().reads(7))\n\t\t\t.saturating_add(T::DbWeight::get().reads((26_u64).saturating_mul(e.into())))\n\t\t\t.saturating_add(T::DbWeight::get().writes((22_u64).saturating_mul(e.into())))\n\t\t\t.saturating_add(Weight::from_parts(0, 7749).saturating_mul(e.into()))\n\t}\n\t/// Storage: `Omnipool::Assets` (r:3 w:3)\n\t/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)\n\t/// Storage: `Tokens::Accounts` (r:5 w:5)\n\t/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)\n\t/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)\n\t/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)\n\t/// Storage: `DynamicFees::AssetFee` (r:2 w:0)\n\t/// Proof: `DynamicFees::AssetFee` (`max_values`: None, `max_size`: Some(24), added: 2499, mode: `MaxEncodedLen`)\n\t/// Storage: `AssetRegistry::Assets` (r:2 w:0)\n\t/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(87), added: 2562, mode: `MaxEncodedLen`)\n\t/// Storage: `System::Account` (r:3 w:2)\n\t/// Proof: `Syste"
    }
  ]
}