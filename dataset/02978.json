{
  "Title": "M-7: processAuction() in VaultAdmin.sol can be called multiple times by keeper if the auction is canceled.",
  "Content": "# Issue M-7: processAuction() in VaultAdmin.sol can be called multiple times by keeper if the auction is canceled. \n\nSource: https://github.com/sherlock-audit/2022-09-knox-judging/issues/26 \n\n## Found by \nctf\\_sec\n\n## Summary\n\nprocessAuction() in VaultAdmin.sol can be called multiple times by keeper if the auction is canceled.\n\n## Vulnerability Detail\n\nprocessAuction() in VaultAdmin.sol can be called multiple times by keeper, the code below would execute more than one times\nif the auction is canceled.\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/vault/VaultAdmin.sol#L259-L280\n\nbecause it is the line of code inside the function processAuction in VaultAdmin.sol below that can change the auction status to PROCESSED. \n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/vault/VaultAdmin.sol#L326\n\nthis code only runs when the auction is finalized, it not finalized, the auction is in Canceled State and \n\n```solidity\n   bool cancelled = l.Auction.isCancelled(lastEpoch);\n        bool finalized = l.Auction.isFinalized(lastEpoch);\n\n        require(\n            (!finalized && cancelled) || (finalized && !cancelled),\n            \"auction is not finalized nor cancelled\"\n        );\n```\n\nwould always pass because the auction is in cancel state.\n\n## Impact\n\nWhy the processAuction should not be called multiple times?\n\nIn the first time it is called, the withdrawal lock is released so user can withdraw fund,\n\n```solidity\n // deactivates withdrawal lock\n  l.auctionProcessed = true;\n```\n\nthen if we called again, the lastTotalAssets can be updated multiple times.\n\n```solidity\n        // stores the last total asset amount, this is effectively the amount of assets held\n        // in the vault at the start of the auction\n        l.lastTotalAssets = _totalAssets();\n```\n\nthe total asset can be lower and lower because people are withdrawing their fund.\n\nthen when _collectPerformanceFee is called, the performance may still be collected\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/vault/VaultInternal.sol#L513-L530\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the project lock the epoch and make it impossible for keeper to call the processAuction again. \n\n## Discussion\n\n**0xCourtney**\n\nThe `Keeper` is an EOA owned/controlled by the protocol team and therefore considered trusted.\n\n**Evert0x**\n\n@0xCourtney as there are require statements based on the auction state, is it a valid use case that `processAuction()` get's called multiple times (by the keeper)? If not I can see the argument for the missing check.\n\n**0xCourtney**\n\nNo, this function should only be called once. We'll add a guard to prevent multiple calls.\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/4",
  "Code": [
    {
      "filename": "knox-contracts/contracts/vault/VaultAdmin.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./VaultInternal.sol\";\n\n/**\n * @title Knox Vault Admin Contract\n * @dev deployed standalone and referenced by VaultDiamond\n */\n\ncontract VaultAdmin is IVaultAdmin, VaultInternal {\n    using ABDKMath64x64 for int128;\n    using OptionMath for uint256;\n    using SafeERC20 for IERC20;\n    using VaultStorage for VaultStorage.Layout;\n\n    int128 private constant ONE_64x64 = 0x10000000000000000;\n\n    constructor(bool isCall, address pool) VaultInternal(isCall, pool) {}\n\n    /************************************************\n     *  ADMIN\n     ***********************************************/\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setAuction(address newAuction) external onlyOwner {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newAuction != address(0), \"address not provided\");\n        require(newAuction != address(l.Auction), \"new address equals old\");\n\n        emit AuctionSet(l.epoch, address(l.Auction), newAuction, msg.sender);\n\n        l.Auction = IAuction(newAuction);\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setAuctionWindowOffsets(\n        uint256 newStartOffset,\n        uint256 newEndOffset\n    ) external onlyOwner {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newEndOffset > newStartOffset, \"start offset > end offset\");\n\n        emit AuctionWindowOffsetsSet(\n            l.epoch,\n            l.startOffset,\n            newStartOffset,\n            l.endOffset,\n            newEndOffset,\n            msg.sender\n        );\n\n        l.startOffset = newStartOffset;\n        l.endOffset = newEndOffset;\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setDelta64x64(int128 newDelta64x64) external onlyOwner {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newDelta64x64 > 0, \"delta <= 0\");\n        require(newDelta64x64 < ONE_64x64, \"delta > 1\");\n\n        emit DeltaSet(l.epoch, l.delta64x64, newDelta64x64, msg.sender);\n\n        l.delta64x64 = newDelta64x64;\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setDeltaOffset64x64(int128 newDeltaOffset64x64)\n        external\n        onlyOwner\n    {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newDeltaOffset64x64 > 0, \"delta <= 0\");\n        require(newDeltaOffset64x64 < ONE_64x64, \"delta > 1\");\n\n        emit DeltaSet(\n            l.epoch,\n            l.deltaOffset64x64,\n            newDeltaOffset64x64,\n            msg.sender\n        );\n\n        l.deltaOffset64x64 = newDeltaOffset64x64;\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setFeeRecipient(address newFeeRecipient) external onlyOwner {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newFeeRecipient != address(0), \"address not provided\");\n        require(newFeeRecipient != l.feeRecipient, \"new address equals old\");\n\n        emit FeeRecipientSet(\n            l.epoch,\n            l.feeRecipient,\n            newFeeRecipient,\n            msg.sender\n        );\n\n        l.feeRecipient = newFeeRecipient;\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setKeeper(address newKeeper) external onlyOwner {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newKeeper != address(0), \"address not provided\");\n        require(newKeeper != address(l.keeper), \"new address equals old\");\n\n        emit KeeperSet(l.epoch, l.keeper, newKeeper, msg.sender);\n\n        l.keeper = newKeeper;\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setPricer(address newPricer) external onlyOwner {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newPricer != address(0), \"address not provided\");\n        require(newPricer != address(l.Pricer), \"new address equals old\");\n\n        emit PricerSet(l.epoch, address(l.Pricer), newPricer, msg.sender);\n\n        l.Pricer = IPricer(newPricer);\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setQueue(address newQueue) external onlyOwner {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newQueue != address(0), \"address not provided\");\n        require(newQueue != address(l.Queue), \"new address equals old\");\n\n        emit QueueSet(l.epoch, address(l.Queue), newQueue, msg.sender);\n\n        l.Queue = IQueue(newQueue);\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setPerformanceFee64x64(int128 newPerformanceFee64x64)\n        external\n        onlyOwner\n    {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newPerformanceFee64x64 < ONE_64x64, \"fee > 1\");\n\n        emit PerformanceFeeSet(\n            l.epoch,\n            l.performanceFee64x64,\n            newPerformanceFee64x64,\n            msg.sender\n        );\n\n        l.performanceFee64x64 = newPerformanceFee64x64;\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setWithdrawalFee64x64(int128 newWithdrawalFee64x64)\n        external\n        onlyOwner\n    {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newWithdrawalFee64x64 < ONE_64x64, \"fee > 1\");\n\n        emit WithdrawalFeeSet(\n            l.epoch,\n            l.withdrawalFee64x64,\n            newWithdrawalFee64x64,\n            msg.sender\n        );\n\n        l.withdrawalFee64x64 = newWithdrawalFee64x64;\n    }\n\n    /************************************************\n     *  INITIALIZE AUCTION\n     ***********************************************/\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function initializeAuction() external onlyKeeper {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        VaultStorage.Option memory option = _setOptionParameters(l);\n\n        // auctions begin on Friday\n        uint256 startTimestamp = _getFriday(block.timestamp);\n\n        // offsets the start and end times by a fixed amount\n        uint256 startTime = startTimestamp + l.startOffset;\n        uint256 endTime = startTimestamp + l.endOffset;\n\n        // resets withdrawal lock, reactivates when auction starts\n        l.startTime = startTime;\n        l.auctionProcessed = false;\n\n        // initializes the auction using the option parameters and start/end times\n        l.Auction.initialize(\n            AuctionStorage.InitAuction(\n                l.epoch,\n                option.expiry,\n                option.strike64x64,\n                option.longTokenId,\n                startTime,\n                endTime\n            )\n        );\n    }\n\n    /************************************************\n     *  INITIALIZE EPOCH\n     ***********************************************/\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function initializeEpoch() external onlyKeeper {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n\n        // skips epoch 0 as there will be no net income, and the lastTotalAsset balance\n        // will not be set\n        if (l.epoch > 0) _collectPerformanceFee(l);\n\n        // when the queue processes its deposits, it will send the enitre balance to\n        // the vault in exchange for a pro-rata share of the vault tokens.\n        l.Queue.processDeposits();\n\n        // increment the epoch id\n        l.epoch = l.epoch + 1;\n\n        // sets the max/min auction prices\n        _setAuctionPrices(l);\n    }\n\n    /************************************************\n     *  PROCESS AUCTION\n     ***********************************************/\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function processAuction() external onlyKeeper {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n\n        // stores the last total asset amount, this is effectively the amount of assets held\n        // in the vault at the start of the auction\n        l.lastTotalAssets = _totalAssets();\n\n        uint64 lastEpoch = _lastEpoch(l);\n        VaultStorage.Option memory lastOption = _lastOption(l);\n\n        uint256 totalCollateralUsed;\n        uint256 totalPremiums;\n\n        bool cancelled = l.Auction.isCancelled(lastEpoch);\n        bool finalized = l.Auction.isFinalized(lastEpoch);\n\n        require(\n            (!finalized && cancelled) || (finalized && !cancelled),\n            \"auction is not finalized nor cancelled\"\n        );\n\n        if (finalized && !cancelled) {\n            // transfers the premiums from the auction contract to the vault\n            totalPremiums = l.Auction.transferPremium(lastEpoch);\n            //fetches the total number of contracts sold during the auction\n            uint256 totalContractsSold =\n                l.Auction.getTotalContractsSold(lastEpoch);\n\n            if (totalContractsSold > 0) {\n                // calculates the total amount of collateral required to underwrite the contracts\n                // sold during the auction\n                totalCollateralUsed = totalContractsSold\n                    .fromContractsToCollateral(\n                    l.isCall,\n                    l.underlyingDecimals,\n                    l.baseDecimals,\n                    lastOption.strike64x64\n                );\n\n                // approves the Premia pool to spend, the collateral amount + the reserves needed\n                // to pay the APY fee\n                ERC20.approve(\n                    address(Pool),\n                    totalCollateralUsed + _totalReserves()\n                );\n\n                // underwrites the contracts sold during the auction, the pool sends the short tokens\n                // to the vault, and long tokens to the auction contract\n                Pool.writeFrom(\n                    address(this),\n                    address(l.Auction),\n                    lastOption.expiry,\n                    lastOption.strike64x64,\n                    totalContractsSold,\n                    l.isCall\n                );\n\n                // the divestment timestamp is the time at which collateral locked in the Premia pool\n                // will be moved into the pools \"reserved liquidity\" queue. if the divestment timestamp\n                // is not set, collateral will remain in the \"free liquidity\" queue and could potentially\n                // be used to underwrite a position without the directive of the vault. note, the minimum\n                // amount of time the divestment timestamp can be set to is 24 hours after the position\n                // has been underwritten.\n                uint64 divestmentTimestamp = uint64(block.timestamp + 24 hours);\n                Pool.setDivestmentTimestamp(divestmentTimestamp, l.isCall);\n            }\n\n            l.Auction.processAuction(lastEpoch);\n        }\n\n        // deactivates withdrawal lock\n        l.auctionProcessed = true;\n\n        emit AuctionProcessed(\n            lastEpoch,\n            totalCollateralUsed,\n            _totalShortAsContracts(),\n            totalPremiums\n        );\n    }\n}"
    },
    {
      "filename": "knox-contracts/contracts/vault/VaultAdmin.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./VaultInternal.sol\";\n\n/**\n * @title Knox Vault Admin Contract\n * @dev deployed standalone and referenced by VaultDiamond\n */\n\ncontract VaultAdmin is IVaultAdmin, VaultInternal {\n    using ABDKMath64x64 for int128;\n    using OptionMath for uint256;\n    using SafeERC20 for IERC20;\n    using VaultStorage for VaultStorage.Layout;\n\n    int128 private constant ONE_64x64 = 0x10000000000000000;\n\n    constructor(bool isCall, address pool) VaultInternal(isCall, pool) {}\n\n    /************************************************\n     *  ADMIN\n     ***********************************************/\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setAuction(address newAuction) external onlyOwner {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newAuction != address(0), \"address not provided\");\n        require(newAuction != address(l.Auction), \"new address equals old\");\n\n        emit AuctionSet(l.epoch, address(l.Auction), newAuction, msg.sender);\n\n        l.Auction = IAuction(newAuction);\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setAuctionWindowOffsets(\n        uint256 newStartOffset,\n        uint256 newEndOffset\n    ) external onlyOwner {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newEndOffset > newStartOffset, \"start offset > end offset\");\n\n        emit AuctionWindowOffsetsSet(\n            l.epoch,\n            l.startOffset,\n            newStartOffset,\n            l.endOffset,\n            newEndOffset,\n            msg.sender\n        );\n\n        l.startOffset = newStartOffset;\n        l.endOffset = newEndOffset;\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setDelta64x64(int128 newDelta64x64) external onlyOwner {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newDelta64x64 > 0, \"delta <= 0\");\n        require(newDelta64x64 < ONE_64x64, \"delta > 1\");\n\n        emit DeltaSet(l.epoch, l.delta64x64, newDelta64x64, msg.sender);\n\n        l.delta64x64 = newDelta64x64;\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setDeltaOffset64x64(int128 newDeltaOffset64x64)\n        external\n        onlyOwner\n    {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newDeltaOffset64x64 > 0, \"delta <= 0\");\n        require(newDeltaOffset64x64 < ONE_64x64, \"delta > 1\");\n\n        emit DeltaSet(\n            l.epoch,\n            l.deltaOffset64x64,\n            newDeltaOffset64x64,\n            msg.sender\n        );\n\n        l.deltaOffset64x64 = newDeltaOffset64x64;\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setFeeRecipient(address newFeeRecipient) external onlyOwner {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newFeeRecipient != address(0), \"address not provided\");\n        require(newFeeRecipient != l.feeRecipient, \"new address equals old\");\n\n        emit FeeRecipientSet(\n            l.epoch,\n            l.feeRecipient,\n            newFeeRecipient,\n            msg.sender\n        );\n\n        l.feeRecipient = newFeeRecipient;\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setKeeper(address newKeeper) external onlyOwner {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newKeeper != address(0), \"address not provided\");\n        require(newKeeper != address(l.keeper), \"new address equals old\");\n\n        emit KeeperSet(l.epoch, l.keeper, newKeeper, msg.sender);\n\n        l.keeper = newKeeper;\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setPricer(address newPricer) external onlyOwner {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newPricer != address(0), \"address not provided\");\n        require(newPricer != address(l.Pricer), \"new address equals old\");\n\n        emit PricerSet(l.epoch, address(l.Pricer), newPricer, msg.sender);\n\n        l.Pricer = IPricer(newPricer);\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setQueue(address newQueue) external onlyOwner {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newQueue != address(0), \"address not provided\");\n        require(newQueue != address(l.Queue), \"new address equals old\");\n\n        emit QueueSet(l.epoch, address(l.Queue), newQueue, msg.sender);\n\n        l.Queue = IQueue(newQueue);\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setPerformanceFee64x64(int128 newPerformanceFee64x64)\n        external\n        onlyOwner\n    {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newPerformanceFee64x64 < ONE_64x64, \"fee > 1\");\n\n        emit PerformanceFeeSet(\n            l.epoch,\n            l.performanceFee64x64,\n            newPerformanceFee64x64,\n            msg.sender\n        );\n\n        l.performanceFee64x64 = newPerformanceFee64x64;\n    }\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function setWithdrawalFee64x64(int128 newWithdrawalFee64x64)\n        external\n        onlyOwner\n    {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(newWithdrawalFee64x64 < ONE_64x64, \"fee > 1\");\n\n        emit WithdrawalFeeSet(\n            l.epoch,\n            l.withdrawalFee64x64,\n            newWithdrawalFee64x64,\n            msg.sender\n        );\n\n        l.withdrawalFee64x64 = newWithdrawalFee64x64;\n    }\n\n    /************************************************\n     *  INITIALIZE AUCTION\n     ***********************************************/\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function initializeAuction() external onlyKeeper {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        VaultStorage.Option memory option = _setOptionParameters(l);\n\n        // auctions begin on Friday\n        uint256 startTimestamp = _getFriday(block.timestamp);\n\n        // offsets the start and end times by a fixed amount\n        uint256 startTime = startTimestamp + l.startOffset;\n        uint256 endTime = startTimestamp + l.endOffset;\n\n        // resets withdrawal lock, reactivates when auction starts\n        l.startTime = startTime;\n        l.auctionProcessed = false;\n\n        // initializes the auction using the option parameters and start/end times\n        l.Auction.initialize(\n            AuctionStorage.InitAuction(\n                l.epoch,\n                option.expiry,\n                option.strike64x64,\n                option.longTokenId,\n                startTime,\n                endTime\n            )\n        );\n    }\n\n    /************************************************\n     *  INITIALIZE EPOCH\n     ***********************************************/\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function initializeEpoch() external onlyKeeper {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n\n        // skips epoch 0 as there will be no net income, and the lastTotalAsset balance\n        // will not be set\n        if (l.epoch > 0) _collectPerformanceFee(l);\n\n        // when the queue processes its deposits, it will send the enitre balance to\n        // the vault in exchange for a pro-rata share of the vault tokens.\n        l.Queue.processDeposits();\n\n        // increment the epoch id\n        l.epoch = l.epoch + 1;\n\n        // sets the max/min auction prices\n        _setAuctionPrices(l);\n    }\n\n    /************************************************\n     *  PROCESS AUCTION\n     ***********************************************/\n\n    /**\n     * @inheritdoc IVaultAdmin\n     */\n    function processAuction() external onlyKeeper {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n\n        // stores the last total asset amount, this is effectively the amount of assets held\n        // in the vault at the start of the auction\n        l.lastTotalAssets = _totalAssets();\n\n        uint64 lastEpoch = _lastEpoch(l);\n        VaultStorage.Option memory lastOption = _lastOption(l);\n\n        uint256 totalCollateralUsed;\n        uint256 totalPremiums;\n\n        bool cancelled = l.Auction.isCancelled(lastEpoch);\n        bool finalized = l.Auction.isFinalized(lastEpoch);\n\n        require(\n            (!finalized && cancelled) || (finalized && !cancelled),\n            \"auction is not finalized nor cancelled\"\n        );\n\n        if (finalized && !cancelled) {\n            // transfers the premiums from the auction contract to the vault\n            totalPremiums = l.Auction.transferPremium(lastEpoch);\n            //fetches the total number of contracts sold during the auction\n            uint256 totalContractsSold =\n                l.Auction.getTotalContractsSold(lastEpoch);\n\n            if (totalContractsSold > 0) {\n                // calculates the total amount of collateral required to underwrite the contracts\n                // sold during the auction\n                totalCollateralUsed = totalContractsSold\n                    .fromContractsToCollateral(\n                    l.isCall,\n                    l.underlyingDecimals,\n                    l.baseDecimals,\n                    lastOption.strike64x64\n                );\n\n                // approves the Premia pool to spend, the collateral amount + the reserves needed\n                // to pay the APY fee\n                ERC20.approve(\n                    address(Pool),\n                    totalCollateralUsed + _totalReserves()\n                );\n\n                // underwrites the contracts sold during the auction, the pool sends the short tokens\n                // to the vault, and long tokens to the auction contract\n                Pool.writeFrom(\n                    address(this),\n                    address(l.Auction),\n                    lastOption.expiry,\n                    lastOption.strike64x64,\n                    totalContractsSold,\n                    l.isCall\n                );\n\n                // the divestment timestamp is the time at which collateral locked in the Premia pool\n                // will be moved into the pools \"reserved liquidity\" queue. if the divestment timestamp\n                // is not set, collateral will remain in the \"free liquidity\" queue and could potentially\n                // be used to underwrite a position without the directive of the vault. note, the minimum\n                // amount of time the divestment timestamp can be set to is 24 hours after the position\n                // has been underwritten.\n                uint64 divestmentTimestamp = uint64(block.timestamp + 24 hours);\n                Pool.setDivestmentTimestamp(divestmentTimestamp, l.isCall);\n            }\n\n            l.Auction.processAuction(lastEpoch);\n        }\n\n        // deactivates withdrawal lock\n        l.auctionProcessed = true;\n\n        emit AuctionProcessed(\n            lastEpoch,\n            totalCollateralUsed,\n            _totalShortAsContracts(),\n            totalPremiums\n        );\n    }\n}"
    },
    {
      "filename": "knox-contracts/contracts/vault/VaultInternal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@solidstate/contracts/access/ownable/OwnableInternal.sol\";\nimport \"@solidstate/contracts/token/ERC4626/base/ERC4626BaseInternal.sol\";\n\nimport \"../libraries/OptionMath.sol\";\n\nimport \"../vendor/IPremiaPool.sol\";\n\nimport \"./IVault.sol\";\nimport \"./IVaultEvents.sol\";\nimport \"./VaultStorage.sol\";\n\n/**\n * @title Knox Vault Internal Contract\n */\n\ncontract VaultInternal is ERC4626BaseInternal, IVaultEvents, OwnableInternal {\n    using ABDKMath64x64 for int128;\n    using ABDKMath64x64 for uint256;\n    using OptionMath for int128;\n    using OptionMath for uint256;\n    using SafeERC20 for IERC20;\n    using VaultStorage for VaultStorage.Layout;\n\n    IERC20 public immutable ERC20;\n    IPremiaPool public immutable Pool;\n\n    constructor(bool isCall, address pool) {\n        Pool = IPremiaPool(pool);\n        IPremiaPool.PoolSettings memory settings = Pool.getPoolSettings();\n        address asset = isCall ? settings.underlying : settings.base;\n        ERC20 = IERC20(asset);\n    }\n\n    /************************************************\n     *  ACCESS CONTROL\n     ***********************************************/\n\n    /**\n     * @dev Throws if called by any account other than the keeper\n     */\n    modifier onlyKeeper() {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(msg.sender == l.keeper, \"!keeper\");\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the queue\n     */\n    modifier onlyQueue() {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(msg.sender == address(l.Queue), \"!queue\");\n        _;\n    }\n\n    /**\n     * @dev Throws if called while withdrawals are locked\n     */\n    modifier withdrawalsLocked() {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n\n        /**\n         * the withdrawal lock is active after the auction has started and deactivated\n         * when the auction is processed.\n         *\n         * when the auction has been processed by the keeper the auctionProcessed flag\n         * is set to true, deactivating the lock.\n         *\n         * when the auction is initialized by the keeper the flag is set to false and\n         * the startTime is updated.\n         *\n         * note, the auction must start for the lock to be reactivated. i.e. if the\n         * flag is false but the auction has not started the lock is deactivated.\n         *\n         *\n         *    Auction       Auction      Auction       Auction\n         *  Initialized     Started     Processed    Initialized\n         *       |             |///Locked///|             |\n         *       |             |////////////|             |\n         * -------------------------Time--------------------------->\n         *\n         *\n         */\n\n        if (block.timestamp >= l.startTime) {\n            require(l.auctionProcessed, \"auction has not been processed\");\n        }\n        _;\n    }\n\n    /************************************************\n     *  VIEW\n     ***********************************************/\n\n    /**\n     * @notice calculates the total active vault collateral\n     * @return total vault collateral excluding the total reserves\n     */\n    function _totalCollateral() internal view returns (uint256) {\n        // total reserves are deducted as they are not considered \"active\" assets\n        return ERC20.balanceOf(address(this)) - _totalReserves();\n    }\n\n    /**\n     * @notice calculates the short position value denominated in the collateral asset\n     * @return total short position in collateral amount\n     */\n    function _totalShortAsCollateral() internal view returns (uint256) {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        VaultStorage.Option memory lastOption = _lastOption(l);\n\n        uint256 totalShortContracts = _totalShortAsContracts();\n\n        // calculates the value of the vaults short position\n        return\n            totalShortContracts.fromContractsToCollateral(\n                l.isCall,\n                l.underlyingDecimals,\n                l.baseDecimals,\n                lastOption.strike64x64\n            );\n    }\n\n    /**\n     * @notice returns the amount in short contracts underwitten by the vault\n     * @return total short contracts\n     */\n    function _totalShortAsContracts() internal view returns (uint256) {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        uint256 shortTokenId = l.options[_lastEpoch(l)].shortTokenId;\n        return Pool.balanceOf(address(this), shortTokenId);\n    }\n\n    /**\n     * @notice calculates the total reserved collateral\n     * @dev collateral is reserved from the auction to ensure the Vault has sufficent funds to\n     * cover the APY fee\n     * @return total reserved collateral\n     */\n    function _totalReserves() internal view returns (uint256) {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        return l.reserveRate64x64.mulu(ERC20.balanceOf(address(this)));\n    }\n\n    /************************************************\n     *  ERC4626 OVERRIDES\n     ***********************************************/\n\n    /**\n     * @notice calculates the total active assets by the vault denominated in the collateral asset\n     * @return total active asset amount\n     */\n    function _totalAssets()\n        internal\n        view\n        override(ERC4626BaseInternal)\n        returns (uint256)\n    {\n        return _totalCollateral() + _totalShortAsCollateral();\n    }\n\n    /**\n     * @notice execute a withdrawal of assets on behalf of given address\n     * @dev owner must approve vault to redeem claim tokens\n     * @dev this function may not be called while the auction is in progress\n     * @param assetAmount quantity of assets to withdraw\n     * @param receiver recipient of assets resulting from withdrawal\n     * @param owner holder of shares to be redeemed\n     * @return shareAmount quantity of shares to redeem\n     */\n    function _withdraw(\n        uint256 assetAmount,\n        address receiver,\n        address owner\n    ) internal virtual override(ERC4626BaseInternal) returns (uint256) {\n        require(\n            assetAmount <= _maxWithdraw(owner),\n            \"ERC4626: maximum amount exceeded\"\n        );\n\n        uint256 shareAmount = _previewWithdraw(assetAmount);\n\n        _withdraw(msg.sender, receiver, owner, assetAmount, shareAmount);\n\n        return shareAmount;\n    }\n\n    /**\n     * @notice execute a redemption of shares on behalf of given address\n     * @dev owner must approve vault to redeem claim tokens\n     * @dev this function may not be called while the auction is in progress\n     * @param shareAmount quantity of shares to redeem\n     * @param receiver recipient of assets resulting from withdrawal\n     * @param owner holder of shares to be redeemed\n     * @return assetAmount quantity of assets to withdraw\n     */\n    function _redeem(\n        uint256 shareAmount,\n        address receiver,\n        address owner\n    ) internal virtual override(ERC4626BaseInternal) returns (uint256) {\n        require(\n            shareAmount <= _maxRedeem(owner),\n            \"ERC4626: maximum amount exceeded\"\n        );\n\n        uint256 assetAmount = _previewRedeem(shareAmount);\n\n        _withdraw(msg.sender, receiver, owner, assetAmount, shareAmount);\n\n        return assetAmount;\n    }\n\n    /**\n     * @notice exchange shares for assets on behalf of given address\n     * @param caller transaction operator for purposes of allowance verification\n     * @param receiver recipient of assets resulting from withdrawal\n     * @param owner holder of shares to be redeemed\n     * @param assetAmount quantity of assets to withdraw\n     * @param shareAmount quantity of shares to redeem\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assetAmount,\n        uint256 shareAmount\n    ) private {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n\n        // prior to withdrawing, the vault will redeem all available claim tokens\n        // in exchange for the pro-rata vault shares\n        l.Queue.redeemMax(receiver, owner);\n\n        require(l.epoch > 0, \"cannot withdraw on epoch 0\");\n\n        if (caller != owner) {\n            // if the owner is not equal to the caller, approve the caller\n            // to spend up to the allowance\n            uint256 allowance = _allowance(owner, caller);\n\n            require(\n                allowance >= shareAmount,\n                \"ERC4626: share amount exceeds allowance\"\n            );\n\n            unchecked {_approve(owner, caller, allowance - shareAmount);}\n        }\n\n        _beforeWithdraw(owner, assetAmount, shareAmount);\n\n        // burns vault shares held by owner\n        _burn(owner, shareAmount);\n\n        // aggregate the total assets withdrawn during the current epoch\n        l.totalWithdrawals += assetAmount;\n\n        // removes any reserved liquidty from pool in the event an option has been exercised\n        _withdrawReservedLiquidity(l);\n\n        // LPs may withdraw funds at any time and receive a proportion of the assets held in\n        // the vault. this means that a withdrawal can be mixture of collateral assets and\n        // short contracts, 100% collateral, or 100% short contracts. if a user wishes to\n        // exit without exposure to a short position, they should wait until the vault holds\n        // no short contracts, or withdraw and reassign their short contracts via Premia's\n        // contracts.\n\n        // calculate the collateral amount and short contract amount distribution\n        (uint256 collateralAmount, uint256 shortContracts) =\n            _calculateDistributions(l, assetAmount);\n\n        // calculates and deducts the withdrawal fee\n        (uint256 collateralAmountSansFee, uint256 shortContractsSansFee) =\n            _collectWithdrawalFee(l, collateralAmount, shortContracts);\n\n        // transfers the collateral and short contracts to the receiver\n        _transferCollateralAndShortAssets(\n            _lastEpoch(l),\n            collateralAmountSansFee,\n            shortContractsSansFee,\n            _lastOption(l).shortTokenId,\n            receiver\n        );\n\n        emit Withdraw(caller, receiver, owner, assetAmount, shareAmount);\n    }\n\n    /************************************************\n     *  WITHDRAW HELPERS\n     ***********************************************/\n\n    /**\n     * @notice calculates the total amount of collateral and short contracts to distribute\n     * @param l vault storage layout\n     * @param assetAmount quantity of assets to withdraw\n     * @return distribution amount in collateral asset\n     * @return distribution amount in the short contrac"
    }
  ]
}