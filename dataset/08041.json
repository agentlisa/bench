{
  "Title": "[M-06] AuctionCrowdfund: If the contract was bid on before the NFT was gifted to the contract, lastBid will not be totalContributions",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L233-L242\n\n\n# Vulnerability details\n\n## Impact\nIn the finalize function of the AuctionCrowdfund contract, when the contract gets NFT and lastBid_ == 0, it is considered that NFT is gifted to the contract and everyone who contributed wins.\n```\n        if (nftContract.safeOwnerOf(nftTokenId) == address(this)) {\n            if (lastBid_ == 0) {\n                // The NFT was gifted to us. Everyone who contributed wins.\n                lastBid_ = totalContributions;\n```\nBut if the contract was bid before the NFT was gifted to the contract, then since lastBid_ ! = 0, only the user who contributed at the beginning will win.\n## Proof of Concept\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L233-L242\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L149-L175\n## Tools Used\nNone\n## Recommended Mitigation Steps\nWhether or not NFT is free to get should be determined using whether the contract balance is greater than totalContributions",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/crowdfund/AuctionCrowdfund.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../tokens/IERC721.sol\";\nimport \"../party/Party.sol\";\nimport \"../utils/Implementation.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\nimport \"../market-wrapper/IMarketWrapper.sol\";\nimport \"./Crowdfund.sol\";\n\n/// @notice A crowdfund that can repeatedly bid on an auction for a specific NFT\n///         (i.e. with a known token ID) until it wins.\ncontract AuctionCrowdfund is Implementation, Crowdfund {\n    using LibSafeERC721 for IERC721;\n    using LibSafeCast for uint256;\n    using LibRawResult for bytes;\n\n    enum AuctionCrowdfundStatus {\n        // The crowdfund has been created and contributions can be made and\n        // acquisition functions may be called.\n        Active,\n        // An temporary state set by the contract during complex operations to\n        // act as a reentrancy guard.\n        Busy,\n        // The crowdfund is over and has either won or lost.\n        Finalized\n    }\n\n    struct AuctionCrowdfundOptions {\n        // The name of the crowdfund.\n        // This will also carry over to the governance party.\n        string name;\n        // The token symbol for both the crowdfund and the governance NFTs.\n        string symbol;\n        // The auction ID (specific to the IMarketWrapper).\n        uint256 auctionId;\n        // IMarketWrapper contract that handles interactions with auction markets.\n        IMarketWrapper market;\n        // The ERC721 contract of the NFT being bought.\n        IERC721 nftContract;\n        // ID of the NFT being bought.\n        uint256 nftTokenId;\n        // How long this crowdfund has to bid on the NFT, in seconds.\n        uint40 duration;\n        // Maximum bid allowed.\n        uint96 maximumBid;\n        // An address that receives a portion of the final voting power\n        // when the party transitions into governance.\n        address payable splitRecipient;\n        // What percentage (in bps) of the final total voting power `splitRecipient`\n        // receives.\n        uint16 splitBps;\n        // If ETH is attached during deployment, it will be interpreted\n        // as a contribution. This is who gets credit for that contribution.\n        address initialContributor;\n        // If there is an initial contribution, this is who they will delegate their\n        // voting power to when the crowdfund transitions to governance.\n        address initialDelegate;\n        // The gatekeeper contract to use (if non-null) to restrict who can\n        // contribute to this crowdfund.\n        IGateKeeper gateKeeper;\n        // The gate ID within the gateKeeper contract to use.\n        bytes12 gateKeeperId;\n        // Fixed governance options (i.e. cannot be changed) that the governance\n        // `Party` will be created with if the crowdfund succeeds.\n        FixedGovernanceOpts governanceOpts;\n    }\n\n    event Bid(uint256 bidAmount);\n    event Won(uint256 bid, Party party);\n    event Lost();\n\n    error InvalidAuctionIdError();\n    error AuctionFinalizedError(uint256 auctionId);\n    error AlreadyHighestBidderError();\n    error ExceedsMaximumBidError(uint256 bidAmount, uint256 maximumBid);\n    error NoContributionsError();\n    error AuctionNotExpiredError();\n\n    /// @notice The NFT contract to buy.\n    IERC721 public nftContract;\n    /// @notice The NFT token ID to buy.\n    uint256 public nftTokenId;\n    /// @notice An adapter for the auction market (Zora, OpenSea, etc).\n    /// @dev This will be delegatecalled into to execute bids.\n    IMarketWrapper public market;\n    /// @notice The auction ID to identify the auction on the `market`.\n    uint256 public auctionId;\n    /// @notice The maximum possible bid this crowdfund can make.\n    uint96 public maximumBid;\n    /// @notice The last successful bid() amount.\n    uint96 public lastBid;\n    /// @notice When this crowdfund expires. If the NFT has not been bought\n    ///         by this time, participants can withdraw their contributions.\n    uint40 public expiry;\n    // Track extra status of the crowdfund specific to bids.\n    AuctionCrowdfundStatus private _bidStatus;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) Crowdfund(globals) {}\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param opts Options used to initialize the crowdfund. These are fixed\n    ///             and cannot be changed later.\n    function initialize(AuctionCrowdfundOptions memory opts)\n        external\n        payable\n        onlyConstructor\n    {\n        nftContract = opts.nftContract;\n        nftTokenId = opts.nftTokenId;\n        market = opts.market;\n        expiry = uint40(opts.duration + block.timestamp);\n        auctionId = opts.auctionId;\n        maximumBid = opts.maximumBid;\n        Crowdfund._initialize(CrowdfundOptions({\n            name: opts.name,\n            symbol: opts.symbol,\n            splitRecipient: opts.splitRecipient,\n            splitBps: opts.splitBps,\n            initialContributor: opts.initialContributor,\n            initialDelegate: opts.initialDelegate,\n            gateKeeper: opts.gateKeeper,\n            gateKeeperId: opts.gateKeeperId,\n            governanceOpts: opts.governanceOpts\n        }));\n\n        // Check that the auction can be bid on and is valid.\n        if (!market.auctionIdMatchesToken(\n            opts.auctionId,\n            address(opts.nftContract),\n            opts.nftTokenId))\n        {\n            revert InvalidAuctionIdError();\n        }\n    }\n\n    /// @notice Accept naked ETH, e.g., if an auction needs to return ETH to us.\n    receive() external payable {}\n\n    /// @notice Place a bid on the NFT using the funds in this crowdfund,\n    ///         placing the minimum possible bid to be the highest bidder, up to\n    ///         `maximumBid`.\n    function bid() external onlyDelegateCall {\n        // Check that the auction is still active.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Active) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n        // Mark as busy to prevent `burn()`, `bid()`, and `contribute()`\n        // getting called because this will result in a `CrowdfundLifecycle.Busy`.\n        _bidStatus = AuctionCrowdfundStatus.Busy;\n        // Make sure the auction is not finalized.\n        uint256 auctionId_ = auctionId;\n        if (market.isFinalized(auctionId_)) {\n            revert AuctionFinalizedError(auctionId_);\n        }\n        // Only bid if we are not already the highest bidder.\n        if (market.getCurrentHighestBidder(auctionId_) == address(this)) {\n            revert AlreadyHighestBidderError();\n        }\n        // Get the minimum necessary bid to be the highest bidder.\n        uint96 bidAmount = market.getMinimumBid(auctionId_).safeCastUint256ToUint96();\n        // Make sure the bid is less than the maximum bid.\n        if (bidAmount > maximumBid) {\n            revert ExceedsMaximumBidError(bidAmount, maximumBid);\n        }\n        lastBid = bidAmount;\n        // No need to check that we have `bidAmount` since this will attempt to\n        // transfer `bidAmount` ETH to the auction platform.\n        (bool s, bytes memory r) = address(market).delegatecall(abi.encodeCall(\n            IMarketWrapper.bid,\n            (auctionId_, bidAmount)\n        ));\n        if (!s) {\n            r.rawRevert();\n        }\n        emit Bid(bidAmount);\n\n        _bidStatus = AuctionCrowdfundStatus.Active;\n    }\n\n    /// @notice Calls finalize() on the market adapter, which will claim the NFT\n    ///         (if necessary) if we won, or recover our bid (if necessary)\n    ///         if we lost. If we won, a governance party will also be created.\n    /// @param governanceOpts The options used to initialize governance in the\n    ///                       `Party` instance created if the crowdfund wins.\n    /// @return party_ Address of the `Party` instance created if successful.\n    function finalize(FixedGovernanceOpts memory governanceOpts)\n        external\n        onlyDelegateCall\n        returns (Party party_)\n    {\n        // Check that the auction is still active and has not passed the `expiry` time.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Active && lc != CrowdfundLifecycle.Expired) {\n            revert WrongLifecycleError(lc);\n        }\n        // Mark as busy to prevent burn(), bid(), and contribute()\n        // getting called because this will result in a `CrowdfundLifecycle.Busy`.\n        _bidStatus = AuctionCrowdfundStatus.Busy;\n\n        uint96 lastBid_ = lastBid;\n        // Only finalize on the market if we placed a bid.\n        if (lastBid_ != 0) {\n            uint256 auctionId_ = auctionId;\n            // Finalize the auction if it isn't finalized.\n            if (!market.isFinalized(auctionId_)) {\n                // Note that even if this crowdfund has expired but the auction is still\n                // ongoing, this call can fail and block finalization until the auction ends.\n                (bool s, bytes memory r) = address(market).call(abi.encodeCall(\n                    IMarketWrapper.finalize,\n                    auctionId_\n                ));\n                if (!s) {\n                    r.rawRevert();\n                }\n            }\n        } else {\n            // If we never placed a bid, the auction must have expired.\n            if (lc != CrowdfundLifecycle.Expired) {\n                revert AuctionNotExpiredError();\n            }\n        }\n        // Are we now in possession of the NFT?\n        if (nftContract.safeOwnerOf(nftTokenId) == address(this)) {\n            if (lastBid_ == 0) {\n                // The NFT was gifted to us. Everyone who contributed wins.\n                lastBid_ = totalContributions;\n                if (lastBid_ == 0) {\n                    // Nobody ever contributed. The NFT is effectively burned.\n                    revert NoContributionsError();\n                }\n                lastBid = lastBid_;\n            }\n            // Create a governance party around the NFT.\n            party_ = _createParty(\n                _getPartyFactory(),\n                governanceOpts,\n                nftContract,\n                nftTokenId\n            );\n            emit Won(lastBid_, party_);\n        } else {\n            // Clear `lastBid` so `_getFinalPrice()` is 0 and people can redeem their\n            // full contributions when they burn their participation NFTs.\n            lastBid = 0;\n            emit Lost();\n        }\n\n        _bidStatus = AuctionCrowdfundStatus.Finalized;\n    }\n\n    /// @inheritdoc Crowdfund\n    function getCrowdfundLifecycle() public override view returns (CrowdfundLifecycle) {\n        // Do not rely on `market.isFinalized()` in case `auctionId` gets reused.\n        AuctionCrowdfundStatus status = _bidStatus;\n        if (status == AuctionCrowdfundStatus.Busy) {\n            // In the midst of finalizing/bidding (trying to reenter).\n            return CrowdfundLifecycle.Busy;\n        }\n        if (status == AuctionCrowdfundStatus.Finalized) {\n            return address(party) != address(0)\n                // If we're fully finalized and we have a party instance then we won.\n                ? CrowdfundLifecycle.Won\n                // Otherwise we lost.\n                : CrowdfundLifecycle.Lost;\n        }\n        if (block.timestamp >= expiry) {\n            // Expired. `finalize()` needs to be called.\n            return CrowdfundLifecycle.Expired;\n        }\n        return CrowdfundLifecycle.Active;\n    }\n\n    function _getFinalPrice()\n        internal\n        override\n        view\n        returns (uint256 price)\n    {\n        return lastBid;\n    }\n}"
    }
  ]
}