{
  "Title": "M-13: approve() call with incorrect function signature will make any SoftVault deployed with USDT as the underlying token unusable",
  "Content": "# Issue M-13: approve() call with incorrect function signature will make any SoftVault deployed with USDT as the underlying token unusable \n\nSource: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/135 \n\n## Found by \nn1punp, trauki\n\nmedium\n\n\n## Summary\nOpen Zeppelin's `safeTransfer()` is used throughout the blueberry contracts, this ensures that calls to contracts without return values don't fail, however, the `EnsureApprove` contract uses a normal IERC20 interface and a normal `approve()` function call. Since USDT doesn't return a boolean as expected by the interface, this would leave the contract unusable. \n\n## Vulnerability Detail\nIf a SoftVault is deployed using USDT as the `uToken`,  the contract's main functions won't work as intended since the `ensureApprove` function call will fail. \n\n[USDT](https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code) approve signature: `function approve(address spender, uint value) public;`\n\n[OpenZeppelin ERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol) approve signature: `function approve(address spender, uint256 value) external returns (bool);`\n## Impact\nThis will cause loss of funds because the cost to deploy the contract will essentially have been wasted. The developers explicitly stated that they intend to use USDT as an underlying token in the `SoftVault`'s NatSpec:\n![image](https://github.com/sherlock-audit/2023-07-blueberry-RohanNero/assets/100052099/9baf59fa-9de8-4406-9499-aaf45489601e)\n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/utils/EnsureApprove.sol#L27\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd support for USDT by importing another interface with ERC20 functions that don't return values.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because the IERC20 interface would fit also USDT as it has an approve function - no function signature is used anywhere\n\n\n\n**Gornutz**\n\nItem discussed in the previous competition full context is given here - https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/15#issuecomment-1542727941 \n\n**Shogoki**\n\n> Item discussed in the previous competition full context is given here - [sherlock-audit/2023-04-blueberry-judging#15 (comment)](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/15#issuecomment-1542727941)\n\nActually i do not understand why the issue was closed in the last contest with the comment: \n\n`USDT only can call approve function when the allowance is zero or to set the allowance to zero first.`\n\nThis is not related to the stated issue, that the approval will revert because the generic IERC20 interface is used, which is expecting a bool return data.\n\n**nevillehuang**\n\nEscalate:\n\nReferring to @Gornutz comment, this was marked as No-Fix and Non-Reward in previous contest, and should be invalid according to sherlock's [rules here](https://docs.sherlock.xyz/audits/judging/judging):\n\n> In an update contest, issues from the previous contest with wont fix labels are not considered valid.\n\nIn addition, `EnsureApprove.sol` uses `_ensureApprove()` directly to approve tokens  (for e.g. USDT) for contracts inheriting it, so the issue above of needing an interface is not a problem.\n\n**sherlock-admin2**\n\n > Escalate:\n> \n> Referring to @Gornutz comment, this was marked as No-Fix and Non-Reward in previous contest, and should be invalid according to sherlock's [rules here](https://docs.sherlock.xyz/audits/judging/judging):\n> \n> > In an update contest, issues from the previous contest with wont fix labels are not considered valid.\n> \n> In addition, `EnsureApprove.sol` uses `_ensureApprove()` directly to approve tokens  (for e.g. USDT) for contracts inheriting it, so the issue above of needing an interface is not a problem.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\n> Escalate:\n> \n> Referring to @Gornutz comment, this was marked as No-Fix and Non-Reward in previous contest, and should be invalid according to sherlock's [rules here](https://docs.sherlock.xyz/audits/judging/judging):\n> \n> > In an update contest, issues from the previous contest with wont fix labels are not considered valid.\n> \n\nHmm, yep that is kind of an interesting case. I agree, that it is probably fair in terms of rewards to consider this invalid.\nHowever as stated in my comment above, i do not understand the reasoning for closing this in the initial contest.\n\n**securitygrid**\n\nThe function signature only needs the function name and parameters, and does not need a return value.\n\n**Shogoki**\n\n> The function signature only needs the function name and parameters, and does not need a return value.\n\nWhile this is true for the call, it is still a problem as the transaction will revert because Solidity checks for the expected return size and compares it to the actual returned data size. \n\n\n**nevillehuang**\n\n> > The function signature only needs the function name and parameters, and does not need a return value.\n> \n> While this is true for the call, it is still a problem as the transaction will revert because Solidity checks for the expected return size and compares it to the actual returned data size.\n\nAs @securitygrid said, there will be no reverts, given allowance is approved to zero first. The interface only requires the function selector to match and call the function in the USDT contract [check this link here](https://medium.com/coinmonks/function-selectors-in-solidity-understanding-and-working-with-them-25e07755e976#:~:text=The%20function%20signature%20is%20derived,myFunction(address%2Cuint256)%20.)\n\n> When a contract is called, the EVM (Ethereum Virtual Machine) reads the first four bytes of the provided data to determine the function selector. The EVM uses this selector to match it with the correct function within the contract. If a match is found, the function is executed. If no match is found, the function call fails.\n\nFor example, function signature of `approve()` here would be `bytes4(keccak256(\"approve(address,uint)\"));`\n\nUnless there are two approve functions with different number of arguments, this submission seems like only a valid QA/low finding since there is only 1 approve function exposed in USDT contract\n\n**securitygrid**\n\n@nevillehuang \nThis problem should be considered from the compiled code:\nThe compiled code of `IERC20(token).approve(spender, 0)` is similar to the following:\n```solidity\n(bool ret, bytes data) = token.call(abi.encodeWithSignature(\"approve(address,uint256)\", spender, 0);\nif (ret) {\n     if (data.length != 1) // since usdt.approve has no return value, so data.length = 0\n     {\n            revert;\n     }\n     return abi.decode(data, (bool));\n} else {\n     revert;\n}\n```\n\n\n**Shogoki**\n\n> @nevillehuang This problem should be considered from the compiled code: The compiled code of `IERC20(token).approve(spender, 0)` is similar to the following:\n> \n> ```solidity\n> (bool ret, bytes data) = token.call(abi.encodeWithSignature(\"approve(address,uint256)\", spender, 0);\n> if (ret) {\n>      if (data.length != 1) // since usdt.approve has no return vault, so data.length = 0\n>      {\n>             revert;\n>      }\n>      return abi.decode(data, (bool));\n> } else {\n>      revert;\n> }\n> ```\n\nThat is correct. \n\nTo demonstrate the issue we can use the following litle PoC.\n\n1. Creating a Contract `EnsureApproveTest.sol` \n\n```solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport {EnsureApprove} from \"./utils/EnsureApprove.sol\" ;\n\ncontract EnsureApproveTest is EnsureApprove {\n\n    function approveMe(address token, uint256 amount) external {\n        _ensureApprove(token, msg.sender, amount);\n    }\n}\n```\n\n2. Creating a Test `ensureApprove.ts` \n\n```typescript\nimport { SignerWithAddress } from \"@nomiclabs/hardhat-ethers/signers\";\nimport { ethers, upgrades } from \"hardhat\";\nimport chai, { expect } from \"chai\";\nimport { EnsureApproveTest, IERC20 } from \"../typechain-types\";\nimport { roughlyNear } from \"./assertions/roughlyNear\";\nimport { near } from \"./assertions/near\";\nimport { Contract } from \"ethers\";\n\nchai.use(roughlyNear);\nchai.use(near);\n\nconst USDT_ADDRESS = \"0xdac17f958d2ee523a2206206994597c13d831ec7\";\nconst USDC_ADDRESS = \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\";\n\ndescribe(\"Ensure Approve\", () => {\n  let admin: SignerWithAddress;\n  let alice: SignerWithAddress;\n  let testContract: EnsureApproveTest;\n  let usdt: Contract;\n  let usdc: Contract;\n\n  before(async () => {\n    [admin, alice] = await ethers.getSigners();\n  });\n\n  beforeEach(async () => {\n    const EnsureApproveTest = await ethers.getContractFactory(\"EnsureApproveTest\");\n    testContract = await EnsureApproveTest.deploy();\n    usdt = await   ethers.getContractAt(\"@openzeppelin/contracts/token/ERC20/IERC20.sol:IERC20\", USDT_ADDRESS);\n    usdc = await   ethers.getContractAt(\"@openzeppelin/contracts/token/ERC20/IERC20.sol:IERC20\", USDC_ADDRESS);\n  });\n  describe(\"IERC20 Interface\", () => {\n    it(\"TEST USDC APPROVAL\", async () => {\n        const approvalBefore = await usdc.allowance(testContract.address, alice.address);\n        console.log(\"Allowance Before\", approvalBefore);\n        await testContract.connect(alice).approveMe(usdc.address, 1000);\n        const approvalAfter = await usdc.allowance(testContract.address, alice.address);\n        console.log(\"Allowance After\", approvalAfter);\n       expect(approvalAfter).to.equal(1000);\n    });\n    \n    it(\"TEST USDT APPROVAL\", async () => {\n        const approvalBefore = await usdt.allowance(testContract.address, alice.address);\n        console.log(\"Allowance Before\", approvalBefore);\n        await testContract.connect(alice).approveMe(usdt.address, 1000);\n        const approvalAfter = await usdt.allowance(testContract.address, alice.address);\n        console.log(\"Allowance After\", approvalAfter);\n        expect(approvalAfter).to.equal(1000);\n    });\n    \n});\n\n});\n```\n\nRunning this will result in the 2nd test to fail, because of the mismatching return data length\n\n```\n1 failing\n\n  1) Ensure Approve\n       IERC20 Interface\n         TEST USDT APPROVAL:\n     Error: Transaction reverted: function returned an unexpected amount of data\n```\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nConsidering this a value medium issue based on the discussions above, this was a valid issue that was not acknowledged in the previous contests, but now with additional information is considered a valid medium. \nI agree the `Wont fix` rule might need to be more clear of the conditions to which they are applied\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [nevillehuang](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/135/#issuecomment-1693509481): accepted\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/104",
  "Code": [
    {
      "filename": "blueberry-core/contracts/utils/EnsureApprove.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\n/// @title EnsureApprove\n/// @notice Helper to ensure approvals are set correctly\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract EnsureApprove {\n    /// @dev Reset approval to zero and then approve spender with amount\n    /// @param token Address of token to approve\n    /// @param spender Address to approve\n    /// @param amount Amount to approve\n    function _ensureApprove(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        IERC20(token).approve(spender, 0);\n        IERC20(token).approve(spender, amount);\n    }\n}"
    }
  ]
}