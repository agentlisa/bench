{
  "Title": "[L-02] Sub-optimal calculations in ",
  "Content": "<h2 id=\"l-02-sub-optimal-calculations-in-getamounttotransfer-results-in-wei-losses\" style=\"position:relative;\"><a href=\"#l-02-sub-optimal-calculations-in-getamounttotransfer-results-in-wei-losses\" aria-label=\"l 02 sub optimal calculations in getamounttotransfer results in wei losses permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-02] Sub-optimal calculations in <code>getAmountToTransfer()</code> results in wei losses</h2>\n<h3 id=\"line-references-1\" style=\"position:relative;\"><a href=\"#line-references-1\" aria-label=\"line references 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Line References</h3>\n<p><a href=\"https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L317-L322\">https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L317-L322</a></p>\n<h3 id=\"description-1\" style=\"position:relative;\"><a href=\"#description-1\" aria-label=\"description 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Description</h3>\n<p>In the scenario where the transfer fee exceeds the equilibrium fee, the excess gets credited to the incentive pool. Disregarding from the fact that a bracket is incorrectly placed causing a massive loss in incentives (raised in separate issue), there are cases where 1 wei is unaccounted for from precision loss in the calculation.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"27\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">lpFee</span><span class=\"mtk1\"> = (</span><span class=\"mtk12\">amount</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">tokenManager</span><span class=\"mtk1\">.</span><span class=\"mtk11\">getTokensInfo</span><span class=\"mtk1\">(</span><span class=\"mtk12\">tokenAddress</span><span class=\"mtk1\">).</span><span class=\"mtk12\">equilibriumFee</span><span class=\"mtk1\">) / </span><span class=\"mtk12\">BASE_DIVISOR</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// altered for bracket positioning</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">incentivePool</span><span class=\"mtk1\">[</span><span class=\"mtk12\">tokenAddress</span><span class=\"mtk1\">] +=</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  (</span><span class=\"mtk12\">amount</span><span class=\"mtk1\"> * (</span><span class=\"mtk12\">transferFeePerc</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">tokenManager</span><span class=\"mtk1\">.</span><span class=\"mtk11\">getTokensInfo</span><span class=\"mtk1\">(</span><span class=\"mtk12\">tokenAddress</span><span class=\"mtk1\">).</span><span class=\"mtk12\">equilibriumFee</span><span class=\"mtk1\">)) /</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">BASE_DIVISOR</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<h3 id=\"proof-of-concept-15\" style=\"position:relative;\"><a href=\"#proof-of-concept-15\" aria-label=\"proof of concept 15 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h3>\n<ul>\n<li><code>amount = 337671308498</code></li>\n<li><code>transferFeePerc = 181480242</code></li>\n<li><code>equilibriumFee = 10000000</code> (0.1%)</li>\n</ul>\n<p>Calculated amounts are</p>\n<ul>\n<li><code>lpFee = 337671308</code></li>\n<li><code>incentive = 337671308498 * (181480242 - 10000000) / BASE_DIVISOR = 5790395769</code></li>\n</ul>\n<p>Total fee calculated = <code>337671308</code> + <code>5790395769</code> = <code>6128067077</code></p>\n<ul>\n<li><code>transferFeeAmount = 337671308498 * 181480242 / BASE_DIVISOR = 6128067078</code></li>\n</ul>\n<p>We therefore see 1 wei being unaccounted for.</p>\n<h3 id=\"recommended-mitigation-steps-24\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-24\" aria-label=\"recommended mitigation steps 24 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"28\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">transferFeeAmount</span><span class=\"mtk1\"> = (</span><span class=\"mtk12\">amount</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">transferFeePerc</span><span class=\"mtk1\">) / </span><span class=\"mtk12\">BASE_DIVISOR</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">lpFee</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">equilibriumFee</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">tokenManager</span><span class=\"mtk1\">.</span><span class=\"mtk11\">getTokensInfo</span><span class=\"mtk1\">(</span><span class=\"mtk12\">tokenAddress</span><span class=\"mtk1\">).</span><span class=\"mtk12\">equilibriumFee</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">transferFeePerc</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk12\">equilibriumFee</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">lpFee</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">amount</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">equilibriumFee</span><span class=\"mtk1\"> / </span><span class=\"mtk12\">BASE_DIVISOR</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">incentivePool</span><span class=\"mtk1\">[</span><span class=\"mtk12\">tokenAddress</span><span class=\"mtk1\">] += </span><span class=\"mtk12\">transferFeeAmount</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">lpFee</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">} </span><span class=\"mtk15\">else</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-03-biconomy-hyphen-20-contest",
  "Code": [
    {
      "filename": "contracts/hyphen/LiquidityPool.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/IExecutorManager.sol\";\nimport \"./interfaces/ILiquidityProviders.sol\";\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"./interfaces/ITokenManager.sol\";\n\ncontract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {\n    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 private constant BASE_DIVISOR = 10000000000; // Basis Points * 100 for better accuracy\n\n    uint256 public baseGas;\n\n    IExecutorManager private executorManager;\n    ITokenManager public tokenManager;\n    ILiquidityProviders public liquidityProviders;\n\n    struct PermitRequest {\n        uint256 nonce;\n        uint256 expiry;\n        bool allowed;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    mapping(bytes32 => bool) public processedHash;\n    mapping(address => uint256) public gasFeeAccumulatedByToken;\n\n    // Gas fee accumulated by token address => executor address\n    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;\n\n    // Incentive Pool amount per token address\n    mapping(address => uint256) public incentivePool;\n\n    event AssetSent(\n        address indexed asset,\n        uint256 indexed amount,\n        uint256 indexed transferredAmount,\n        address target,\n        bytes depositHash,\n        uint256 fromChainId\n    );\n    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);\n    event Received(address indexed from, uint256 indexed amount);\n    event Deposit(\n        address indexed from,\n        address indexed tokenAddress,\n        address indexed receiver,\n        uint256 toChainId,\n        uint256 amount,\n        uint256 reward,\n        string tag\n    );\n    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);\n    event TrustedForwarderChanged(address indexed forwarderAddress);\n    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);\n    event EthReceived(address, uint256);\n\n    // MODIFIERS\n    modifier onlyExecutor() {\n        require(executorManager.getExecutorStatus(_msgSender()), \"Only executor is allowed\");\n        _;\n    }\n\n    modifier onlyLiquidityProviders() {\n        require(_msgSender() == address(liquidityProviders), \"Only liquidityProviders is allowed\");\n        _;\n    }\n\n    modifier tokenChecks(address tokenAddress) {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, \"Token not supported\");\n        _;\n    }\n\n    function initialize(\n        address _executorManagerAddress,\n        address _pauser,\n        address _trustedForwarder,\n        address _tokenManager,\n        address _liquidityProviders\n    ) public initializer {\n        require(_executorManagerAddress != address(0), \"ExecutorManager cannot be 0x0\");\n        require(_trustedForwarder != address(0), \"TrustedForwarder cannot be 0x0\");\n        require(_liquidityProviders != address(0), \"LiquidityProviders cannot be 0x0\");\n        __ERC2771Context_init(_trustedForwarder);\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        executorManager = IExecutorManager(_executorManagerAddress);\n        tokenManager = ITokenManager(_tokenManager);\n        liquidityProviders = ILiquidityProviders(_liquidityProviders);\n        baseGas = 21000;\n    }\n\n    function setTrustedForwarder(address trustedForwarder) public onlyOwner {\n        require(trustedForwarder != address(0), \"TrustedForwarder can't be 0\");\n        _trustedForwarder = trustedForwarder;\n        emit TrustedForwarderChanged(trustedForwarder);\n    }\n\n    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {\n        require(_liquidityProviders != address(0), \"LiquidityProviders can't be 0\");\n        liquidityProviders = ILiquidityProviders(_liquidityProviders);\n        emit LiquidityProvidersChanged(_liquidityProviders);\n    }\n\n    function setBaseGas(uint128 gas) external onlyOwner {\n        baseGas = gas;\n    }\n\n    function getExecutorManager() public view returns (address) {\n        return address(executorManager);\n    }\n\n    function setExecutorManager(address _executorManagerAddress) external onlyOwner {\n        require(_executorManagerAddress != address(0), \"Executor Manager cannot be 0\");\n        executorManager = IExecutorManager(_executorManagerAddress);\n    }\n\n    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {\n        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);\n        \n        currentLiquidity =\n            liquidityPoolBalance -\n            liquidityProviders.totalLPFees(tokenAddress) -\n            gasFeeAccumulatedByToken[tokenAddress] -\n            incentivePool[tokenAddress];\n    }\n\n    /**\n     * @dev Function used to deposit tokens into pool to initiate a cross chain token transfer.\n     * @param toChainId Chain id where funds needs to be transfered\n     * @param tokenAddress ERC20 Token address that needs to be transfered\n     * @param receiver Address on toChainId where tokens needs to be transfered\n     * @param amount Amount of token being transfered\n     */\n    function depositErc20(\n        uint256 toChainId,\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        string memory tag\n    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {\n        require(\n            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&\n                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,\n            \"Deposit amount not in Cap limit\"\n        );\n        require(receiver != address(0), \"Receiver address cannot be 0\");\n        require(amount != 0, \"Amount cannot be 0\");\n        address sender = _msgSender();\n\n        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);\n        if (rewardAmount != 0) {\n            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;\n        }\n        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);\n        // Emit (amount + reward amount) in event\n        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);\n    }\n\n    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {\n        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);\n        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);\n        if (currentLiquidity < providedLiquidity) {\n            uint256 liquidityDifference = providedLiquidity - currentLiquidity;\n            if (amount >= liquidityDifference) {\n                rewardAmount = incentivePool[tokenAddress];\n            } else {\n                // Multiply by 10000000000 to avoid 0 reward amount for small amount and liquidity difference\n                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;\n                rewardAmount = rewardAmount / 10000000000;\n            }\n        }\n    }\n\n    /**\n     * DAI permit and Deposit.\n     */\n    function permitAndDepositErc20(\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        uint256 toChainId,\n        PermitRequest calldata permitOptions,\n        string memory tag\n    ) external {\n        IERC20Permit(tokenAddress).permit(\n            _msgSender(),\n            address(this),\n            permitOptions.nonce,\n            permitOptions.expiry,\n            permitOptions.allowed,\n            permitOptions.v,\n            permitOptions.r,\n            permitOptions.s\n        );\n        depositErc20(toChainId, tokenAddress, receiver, amount, tag);\n    }\n\n    /**\n     * EIP2612 and Deposit.\n     */\n    function permitEIP2612AndDepositErc20(\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        uint256 toChainId,\n        PermitRequest calldata permitOptions,\n        string memory tag\n    ) external {\n        IERC20Permit(tokenAddress).permit(\n            _msgSender(),\n            address(this),\n            amount,\n            permitOptions.expiry,\n            permitOptions.v,\n            permitOptions.r,\n            permitOptions.s\n        );\n        depositErc20(toChainId, tokenAddress, receiver, amount, tag);\n    }\n\n    /**\n     * @dev Function used to deposit native token into pool to initiate a cross chain token transfer.\n     * @param receiver Address on toChainId where tokens needs to be transfered\n     * @param toChainId Chain id where funds needs to be transfered\n     */\n    function depositNative(\n        address receiver,\n        uint256 toChainId,\n        string memory tag\n    ) external payable whenNotPaused nonReentrant {\n        require(\n            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&\n                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,\n            \"Deposit amount not in Cap limit\"\n        );\n        require(receiver != address(0), \"Receiver address cannot be 0\");\n        require(msg.value != 0, \"Amount cannot be 0\");\n\n        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);\n        if (rewardAmount != 0) {\n            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;\n        }\n        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);\n        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);\n    }\n\n    function sendFundsToUser(\n        address tokenAddress,\n        uint256 amount,\n        address payable receiver,\n        bytes memory depositHash,\n        uint256 tokenGasPrice,\n        uint256 fromChainId\n    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {\n        uint256 initialGas = gasleft();\n        require(\n            tokenManager.getTransferConfig(tokenAddress).min <= amount &&\n                tokenManager.getTransferConfig(tokenAddress).max >= amount,\n            \"Withdraw amnt not in Cap limits\"\n        );\n        require(receiver != address(0), \"Bad receiver address\");\n\n        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);\n\n        require(!status, \"Already Processed\");\n        processedHash[hashSendTransaction] = true;\n\n        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);\n        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);\n\n        if (tokenAddress == NATIVE) {\n            require(address(this).balance >= amountToTransfer, \"Not Enough Balance\");\n            (bool success, ) = receiver.call{value: amountToTransfer}(\"\");\n            require(success, \"Native Transfer Failed\");\n        } else {\n            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, \"Not Enough Balance\");\n            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);\n        }\n\n        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);\n    }\n\n    /**\n     * @dev Internal function to calculate amount of token that needs to be transfered afetr deducting all required fees.\n     * Fee to be deducted includes gas fee, lp fee and incentive pool amount if needed.\n     * @param initialGas Gas provided initially before any calculations began\n     * @param tokenAddress Token address for which calculation needs to be done\n     * @param amount Amount of token to be transfered before deducting the fee\n     * @param tokenGasPrice Gas price in the token being transfered to be used to calculate gas fee\n     * @return amountToTransfer Total amount to be transfered after deducting all fees.\n     */\n    function getAmountToTransfer(\n        uint256 initialGas,\n        address tokenAddress,\n        uint256 amount,\n        uint256 tokenGasPrice\n    ) internal returns (uint256 amountToTransfer) {\n        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);\n        uint256 lpFee;\n        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {\n            // Here add some fee to incentive pool also\n            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;\n            incentivePool[tokenAddress] =\n                (incentivePool[tokenAddress] +\n                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /\n                BASE_DIVISOR;\n        } else {\n            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;\n        }\n        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;\n\n        liquidityProviders.addLPFee(tokenAddress, lpFee);\n\n        uint256 totalGasUsed = initialGas - gasleft();\n        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;\n        totalGasUsed = totalGasUsed + baseGas;\n\n        uint256 gasFee = totalGasUsed * tokenGasPrice;\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;\n        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;\n        amountToTransfer = amount - (transferFeeAmount + gasFee);\n\n        emit FeeDetails(lpFee, transferFeeAmount, gasFee);\n    }\n\n    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {\n        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);\n        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);\n\n        uint256 resultingLiquidity = currentLiquidity - amount;\n\n        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;\n        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;\n        // Fee is represented in basis points * 10 for better accuracy\n        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; // F(max) * F(e) * L(e)\n        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; // F(e) * L(e) + (F(max) - F(e)) * L(r)\n\n        if (denominator == 0) {\n            fee = 0;\n        } else {\n            fee = numerator / denominator;\n        }\n    }\n\n    function checkHashStatus(\n        address tokenAddress,\n        uint256 amount,\n        address payable receiver,\n        bytes memory depositHash\n    ) public view returns (bytes32 hashSendTransaction, bool status) {\n        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));\n\n        status = processedHash[hashSendTransaction];\n    }\n\n    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {\n        require(tokenAddress != NATIVE, \"Can't withdraw native token fee\");\n        // uint256 gasFeeAccumulated = gasFeeAccumulatedByToken[tokenAddress];\n        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];\n        require(_gasFeeAccumulated != 0, \"Gas Fee earned is 0\");\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;\n        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;\n        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);\n        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);\n    }\n\n    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {\n        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];\n        require(_gasFeeAccumulated != 0, \"Gas Fee earned is 0\");\n        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;\n        gasFeeAccumulated[NATIVE][_msgSender()] = 0;\n        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}(\"\");\n        require(success, \"Native Transfer Failed\");\n\n        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);\n    }\n\n    function transfer(\n        address _tokenAddress,\n        address receiver,\n        uint256 _tokenAmount\n    ) external whenNotPaused onlyLiquidityProviders nonReentrant {\n        require(receiver != address(0), \"Invalid receiver\");\n        if (_tokenAddress == NATIVE) {\n            require(address(this).balance >= _tokenAmount, \"ERR__INSUFFICIENT_BALANCE\");\n            (bool success, ) = receiver.call{value: _tokenAmount}(\"\");\n            require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        } else {\n            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);\n            require(baseToken.balanceOf(address(this)) >= _tokenAmount, \"ERR__INSUFFICIENT_BALANCE\");\n            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);\n        }\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n\n    receive() external payable {\n        emit EthReceived(_msgSender(), msg.value);\n    }\n}"
    }
  ]
}