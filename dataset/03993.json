{
  "Title": "[L11] Removed account signers cannot be reauthorized",
  "Content": "The functions [`removeVoteSigner`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/Accounts.sol#L280), [`removeValidatorSigner`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/Accounts.sol#L289) and [`removeAttestationSigner`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/Accounts.sol#L298) of the `Accounts` contract remove authorized signers from the sender account, but the signers cannot be authorized again.\n\n\nWhen signers are authorized through any of these functions, a call is made to [the `authorize` function](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/Accounts.sol#L558) and they are [added into the `authorizedBy` mapping](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/Accounts.sol#L568). When signers are removed, they are [removed from the accountâ€™s `signer` structure](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/Accounts.sol#L283), but they are left in the `authorizedBy` mapping. Because during authorization the contract checks that [authorized addresses are not in the `authorizedBy` mapping](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/Accounts.sol#L544), this means that removed accounts cannot be authorized again.\n\n\nIf the remove functions are intended to be the inverse of the authorize functions (which is what might be expected just by reading the signatures and the docstrings), consider updating the `authorizedBy` mapping when an account is removed. If this is by design, consider documenting on the remove functions that removing an account authorization does not mean that it will be able to be authorized again.\n\n\n***Update:** Fixed in [pull request #3128](https://github.com/celo-org/celo-monorepo/pull/3128). The functions now have clear comments about signers not able to be reauthorized.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/Accounts.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is IAccounts, Ownable, ReentrancyGuard, Initializable, UsingRegistry {\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct Account {\n    bool exists;\n    // Each account may authorize signing keys to use for voting, valdiating or attestation.\n    // These keys may not be keys of other accounts, and may not be authorized by any other\n    // account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  mapping(address => Account) private accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender), \"Account exists\");\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.vote = signer;\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.validator = signer;\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.validator = signer;\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.validator = signer;\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.attestation = signer;\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account\n   */\n  function removeVoteSigner() public {\n    Account storage account = accounts[msg.sender];\n    emit VoteSignerRemoved(msg.sender, account.signers.vote);\n    account.signers.vote = address(0);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   */\n  function removeValidatorSigner() public {\n    Account storage account = accounts[msg.sender];\n    emit ValidatorSignerRemoved(msg.sender, account.signers.validator);\n    account.signers.validator = address(0);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   */\n  function removeAttestationSigner() public {\n    Account storage account = accounts[msg.sender];\n    emit AttestationSignerRemoved(msg.sender, account.signers.attestation);\n    account.signers.attestation = address(0);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      require(\n        accounts[authorizingAccount].signers.attestation == signer,\n        \"not active authorized attestation signer\"\n      );\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      require(\n        accounts[authorizingAccount].signers.validator == signer,\n        \"not active authorized validator signer\"\n      );\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      require(\n        accounts[authorizingAccount].signers.vote == signer,\n        \"not active authorized vote signer\"\n      );\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    require(isAccount(account), \"Unknown account\");\n    address signer = accounts[account].signers.vote;\n    return signer == address(0) ? account : signer;\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    require(isAccount(account), \"Unknown account\");\n    address signer = accounts[account].signers.validator;\n    return signer == address(0) ? account : signer;\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    require(isAccount(account), \"Unknown account\");\n    address signer = accounts[account].signers.attestation;\n    return signer == address(0) ? account : signer;\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated vote signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated vote signer.\n   */\n  function hasAuthorizedVoteSigner(address account) external view returns (bool) {\n    require(isAccount(account));\n    address signer = accounts[account].signers.vote;\n    return signer != address(0);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated validator signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated validator signer.\n   */\n  function hasAuthorizedValidatorSigner(address account) external view returns (bool) {\n    require(isAccount(account));\n    address signer = accounts[account].signers.validator;\n    return signer != address(0);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated attestation signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated attestation signer.\n   */\n  function hasAuthorizedAttestationSigner(address account) external view returns (bool) {\n    require(isAccount(account));\n    address signer = accounts[account].signers.attestation;\n    return signer != address(0);\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return (stringLengths[] - the length of each string in bytes\n   *          data - all strings concatenated\n   *         )\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Authorizes some role of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized or is an account.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `current`'s signature on `msg.sender`.\n   */\n  function authorize(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSigner(authorized),\n      \"delegate or account exists\"\n    );\n\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/Accounts.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is IAccounts, Ownable, ReentrancyGuard, Initializable, UsingRegistry {\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct Account {\n    bool exists;\n    // Each account may authorize signing keys to use for voting, valdiating or attestation.\n    // These keys may not be keys of other accounts, and may not be authorized by any other\n    // account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  mapping(address => Account) private accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender), \"Account exists\");\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.vote = signer;\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.validator = signer;\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.validator = signer;\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s c"
    }
  ]
}