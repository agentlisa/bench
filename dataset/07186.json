{
  "Title": "[M-06]",
  "Content": "<h2 id=\"m-06\" style=\"position:relative;\"><a href=\"#m-06\" aria-label=\"m 06 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[M-06]</h2>\r\n<p><em>Submitted by neumo</em></p>\r\n<h3 id=\"summary-2\" style=\"position:relative;\"><a href=\"#summary-2\" aria-label=\"summary 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h3>\r\n<p>Whenever a knot is deregistered, the last value of <code>accumulatedETHPerFreeFloatingShare</code> is stored in the mapping <code>lastAccumulatedETHPerFreeFloatingShare</code>. The accumulated value must be updated always before deregistering the knot, otherwise stakers of the knot could receive less ETH than they should when claiming/unstaking. A rule allowed me to detect two functions that violate this property.</p>\r\n<h3 id=\"explanation\" style=\"position:relative;\"><a href=\"#explanation\" aria-label=\"explanation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Explanation</h3>\r\n<p>Function <code>_deRegisterKnot</code> is in charge of marking a knot as <code>isNoLongerPartOfSyndicate</code>:</p>\r\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">/// @dev Business logic for de-registering a specific knots assuming all accrued ETH has been processed</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">function _deRegisterKnot(bytes memory _blsPublicKey) internal {</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\tif (isKnotRegistered[_blsPublicKey] == false) revert KnotIsNotRegisteredWithSyndicate();</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\tif (isNoLongerPartOfSyndicate[_blsPublicKey] == true) revert KnotHasAlreadyBeenDeRegistered();</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\t// We flag that the knot is no longer part of the syndicate</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\tisNoLongerPartOfSyndicate[_blsPublicKey] = true;</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\t// For the free floating and collateralized SLOT of the knot, snapshot the accumulated ETH per share</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\tlastAccumulatedETHPerFreeFloatingShare[_blsPublicKey] = accumulatedETHPerFreeFloatingShare;</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\t// We need to reduce `totalFreeFloatingShares` in order to avoid further ETH accruing to shares of de-registered knot</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\ttotalFreeFloatingShares -= sETHTotalStakeForKnot[_blsPublicKey];</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\t// Total number of registered knots with the syndicate reduces by one</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\tnumberOfRegisteredKnots -= 1;</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\temit KnotDeRegistered(_blsPublicKey);</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">}</span></span></code></pre>\r\n<p>We can see it snapshots the current value of <code>accumulatedETHPerFreeFloatingShare</code> in the mapping <code>lastAccumulatedETHPerFreeFloatingShare</code>. This is because all claiming/unstaking on an unregistered knot should take into account the accrued ETH up to the time of deregistering. So it means, that <code>accumulatedETHPerFreeFloatingShare</code> must be up to date every time a knot is deregistered.</p>\r\n<p>I wrote the following rule to test if this property holds after every call of the contract:</p>\r\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">rule lastAccumulatedETHPerFreeFloatingShareMustAccountForAccruedETH(method f) filtered {</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    f -&gt; notHarnessCall(f)</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">}{</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    env e;</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    bytes32 blsPubKey;</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    require isKnotRegistered(blsPubKey);</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    require !isNoLongerPartOfSyndicate(blsPubKey);</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    require lastAccumulatedETHPerFreeFloatingShare(blsPubKey) == 0;</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    calldataarg args;</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    f(e, args);</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    require isNoLongerPartOfSyndicate(blsPubKey);</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    updateAccruedETHPerShares(e);</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    assert lastAccumulatedETHPerFreeFloatingShare(blsPubKey) == accumulatedETHPerFreeFloatingShare(), \"Knot deregistered, but lastAccumulatedETHPerFreeFloatingShare has a wrong value\";</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">}</span></span></code></pre>\r\n<p>Basically what it does is:</p>\r\n<ul>\r\n<li>Ensure that the knot with <code>blsPubKey</code> is registered</li>\r\n<li>Ensure that it is part of Syndicate</li>\r\n<li>Ensure that <code>lastAccumulatedETHPerFreeFloatingShare</code> for the knot is zero.</li>\r\n<li>Execute a call to any function of the contract</li>\r\n<li>Ensure that after the call, the knot has been deregistered (<code>isNoLongerPartOfSyndicate = true</code>)</li>\r\n<li>Call update accrued ETH per shares</li>\r\n<li>Assert that <code>lastAccumulatedETHPerFreeFloatingShare</code> of the knot is equal to <code>accumulatedETHPerFreeFloatingShare</code></li>\r\n</ul>\r\n<p>If the rule fails, we can affirm that <code>accumulatedETHPerFreeFloatingShare</code> was not up to date, because the call to <code>updateAccruedETHPerShares</code> should not change its value.</p>\r\n<p>But I found calls to these two functions make the rule fail:</p>\r\n<ul>\r\n<li><code>updateCollateralizedSlotOwnersAccruedETH</code></li>\r\n<li><code>batchUpdateCollateralizedSlotOwnersAccruedETH</code></li>\r\n</ul>\r\n<p>That is because these two functions don’t call <code>updateAccruedETHPerShares</code> and they call <code>_updateCollateralizedSlotOwnersLiabilitySnapshot</code>, which also does not call the update accrued ETH function. But this last function can deregister the knot (if it is not active in Stakehouse, see <a href=\"https://github.com/Certora/2023-01-blockswap-fv/blob/certora/contracts/syndicate/Syndicate.sol#L570-L572\">https://github.com/Certora/2023-01-blockswap-fv/blob/certora/contracts/syndicate/Syndicate.sol#L570-L572</a>).</p>\r\n<p>The impact of this issue is the loss of part of the rewards for the affected stakers, because their share of rewards will be calculated with an old value of the accrued rewards, which is for sure less than it should be (as accumulatedETHPerFreeFloatingShare cannot decrease, as I checked in another rule).</p>\r\n<h3 id=\"impact-1\" style=\"position:relative;\"><a href=\"#impact-1\" aria-label=\"impact 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h3>\r\n<p>High impact, because it implies loss of funds for stakers of the protocol.</p>\r\n<h3 id=\"property-violated-1\" style=\"position:relative;\"><a href=\"#property-violated-1\" aria-label=\"property violated 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Property violated</h3>\r\n<p>After a knot state goes from <code>isNoLongerPartOfSyndicate[blsPubKey] == false</code> to <code>isNoLongerPartOfSyndicate[blsPubKey] == true</code> the value stored at <code>lastAccumulatedETHPerFreeFloatingShare[blsPubKey]</code> should be always equal to the up to date value of <code>accumulatedETHPerFreeFloatingShare</code>.</p>\r\n<h3 id=\"recommendation\" style=\"position:relative;\"><a href=\"#recommendation\" aria-label=\"recommendation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommendation</h3>\r\n<p>Call <code>updateAccruedETHPerShares</code> inside functions <code>updateCollateralizedSlotOwnersAccruedETH</code> and <code>batchUpdateCollateralizedSlotOwnersAccruedETH</code>:</p>\r\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">function updateCollateralizedSlotOwnersAccruedETH(blsKey _blsPubKey) public { // MUNGED internal =&gt; public</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\tupdateAccruedETHPerShares();</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\t_updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKey);</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">}</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">function batchUpdateCollateralizedSlotOwnersAccruedETH(blsKey[] memory _blsPubKeys) public { // MUNGED internal =&gt; public</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\tuint256 numOfKeys = _blsPubKeys.length;</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\tif (numOfKeys == 0) revert EmptyArray();</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\tupdateAccruedETHPerShares();</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\tfor (uint256 i; i &lt; numOfKeys; ++i) {</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\t\t_updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKeys[i]);</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">\t}</span></span>\r\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">}</span></span></code></pre>\r\n<p><strong>vince0656 (Blockswap) commented:</strong><br></p>\r\n<blockquote>\r\n<p>Assessment: Medium</p>\r\n<p>Thank you - we have fixed this issue in the Syndicate contract.</p>\r\n</blockquote>\r\n<p><strong>teryanarmen (Certora) commented:</strong><br></p>\r\n<blockquote>\r\n<p>In the case that a knot successfully validates a block and earns rewards, becomes inactive and is deregistered through <code>updateCollateralizedSlotOwnersAccruedETH</code> or <code>batchupdateCollateralizedSlotOwnersAccruedETH</code>, all without any other interaction with Syndicate which calls <code>updateAccruedETHPerShares</code> method, the the stakers of the knot would not be able to claim these rewards and further those funds will be locked in the contract. Since this vulnerability leads to non-negligible loss of funds I believe it is high severity.</p>\r\n<p>One comment, @neumo why did you choose to add</p>\r\n<p>require <code>lastAccumulatedETHPerFreeFloatingShare(blsPubKey) == 0;</code><br></p>\r\n<p>instead of just storing the output of <code>lastAccumulatedETHPerFreeFloatingShare(blsPubKey)</code> in a variable before the call to <code>updateAccruedETHPerShares</code> and asserting that the variable was equal to <code>accumulatedETHPerFreeFloatingShare()</code>? Seems to unnecessarily limit the scope.</p>\r\n</blockquote>\r\n<p><strong>neumo (warden) commented:</strong></p>\r\n<blockquote>\r\n<p>@teryanarmen - My reasoning was to assure that before calling the function the value of <code>lastAccumulatedETHPerFreeFloatingShare</code> was 0 because that is the value registered knots have. In fact its value is only set in one place (function <code>_deRegisterKnot</code>), so I guessed it was safe (and less computationally intensive for the rule) to assume it to be zero before the call. Your approach is also valid too, of course. And even removing the require should work too because, ultimately, the value before the call does not matter, what is important is that after the call to <code>updateAccruedETHPerShares</code> the assert still holds.</p>\r\n<p>I hope I answered your question!</p>\r\n</blockquote>\r\n<p><strong>teryanarmen (Certora) commented:</strong><br></p>\r\n<blockquote>\r\n<p>I actually think this is a medium severity since assets can’t be lost or stolen directly and have some external dependencies such as validating a block at the right time and no one calling <code>updateAccruedETHPerShares</code>.</p>\r\n</blockquote>",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-blockswap-formal-verification-contest-with-certora",
  "Code": [
    {
      "filename": "contracts/syndicate/Syndicate.sol",
      "content": "pragma solidity 0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ISyndicateInit } from \"../interfaces/ISyndicateInit.sol\";\nimport { ETHTransferHelper } from \"../transfer/ETHTransferHelper.sol\";\nimport {\n    ZeroAddress,\n    EmptyArray,\n    InconsistentArrayLengths,\n    InvalidBLSPubKey,\n    InvalidNumberOfCollateralizedOwners,\n    KnotSlashed,\n    FreeFloatingStakeAmountTooSmall,\n    KnotIsNotRegisteredWithSyndicate,\n    NotPriorityStaker,\n    KnotIsFullyStakedWithFreeFloatingSlotTokens,\n    InvalidStakeAmount,\n    KnotIsNotAssociatedWithAStakeHouse,\n    UnableToStakeFreeFloatingSlot,\n    NothingStaked,\n    TransferFailed,\n    NotCollateralizedOwnerAtIndex,\n    InactiveKnot,\n    DuplicateArrayElements,\n    KnotIsAlreadyRegistered,\n    KnotHasAlreadyBeenDeRegistered\n} from \"./SyndicateErrors.sol\";\n\n/// @notice Syndicate registry and funds splitter for EIP1559 execution layer transaction tips across SLOT shares\n/// @dev This contract can be extended to allow lending and borrowing of time slots for borrower to redeem any revenue generated within the specified window\ncontract Syndicate is ISyndicateInit, Initializable, Ownable, ReentrancyGuard, StakehouseAPI, ETHTransferHelper {\n\n    /// @notice Emitted when the contract is initially deployed\n    event ContractDeployed();\n\n    /// @notice Emitted when accrued ETH per SLOT share type is updated\n    event UpdateAccruedETH(uint256 unprocessed);\n\n    /// @notice Emitted when new collateralized SLOT owners for a knot prompts re-calibration\n    event CollateralizedSLOTReCalibrated(bytes BLSPubKey);\n\n    /// @notice Emitted when a new KNOT is associated with the syndicate contract\n    event KNOTRegistered(bytes BLSPubKey);\n\n    /// @notice Emitted when a KNOT is de-registered from the syndicate\n    event KnotDeRegistered(bytes BLSPubKey);\n\n    /// @notice Emitted when a priority staker is added to the syndicate\n    event PriorityStakerRegistered(address indexed staker);\n\n    /// @notice Emitted when a user stakes free floating sETH tokens\n    event Staked(bytes BLSPubKey, uint256 amount);\n\n    /// @notice Emitted when a user unstakes free floating sETH tokens\n    event UnStaked(bytes BLSPubKey, uint256 amount);\n\n    /// @notice Emitted when either an sETH staker or collateralized SLOT owner claims ETH\n    event ETHClaimed(bytes BLSPubKey, address indexed user, address recipient, uint256 claim, bool indexed isCollateralizedClaim);\n\n    /// @notice Precision used in rewards calculations for scaling up and down\n    uint256 public constant PRECISION = 1e24;\n\n    /// @notice Total accrued ETH per free floating share for new and old stakers\n    uint256 public accumulatedETHPerFreeFloatingShare;\n\n    /// @notice Total accrued ETH for all collateralized SLOT holders per knot which is then distributed based on individual balances\n    uint256 public accumulatedETHPerCollateralizedSlotPerKnot;\n\n    /// @notice Last cached highest seen balance for all collateralized shares\n    uint256 public lastSeenETHPerCollateralizedSlotPerKnot;\n\n    /// @notice Last cached highest seen balance for all free floating shares\n    uint256 public lastSeenETHPerFreeFloating;\n\n    /// @notice Total number of sETH token shares staked across all houses\n    uint256 public totalFreeFloatingShares;\n\n    /// @notice Total amount of ETH drawn down by syndicate beneficiaries regardless of SLOT type\n    uint256 public totalClaimed;\n\n    /// @notice Number of knots registered with the syndicate which can be across any house\n    uint256 public numberOfRegisteredKnots;\n\n    /// @notice Informational - is the knot registered to this syndicate or not - the node should point to this contract\n    mapping(bytes => bool) public isKnotRegistered;\n\n    /// @notice Block number after which if there are sETH staking slots available, it can be supplied by anyone on the market\n    uint256 public priorityStakingEndBlock;\n\n    /// @notice Syndicate deployer can highlight addresses that get priority for staking free floating house sETH up to a certain block before anyone can do it\n    mapping(address => bool) public isPriorityStaker;\n\n    /// @notice Total amount of free floating sETH staked\n    mapping(bytes => uint256) public sETHTotalStakeForKnot;\n\n    /// @notice Amount of sETH staked by user against a knot\n    mapping(bytes => mapping(address => uint256)) public sETHStakedBalanceForKnot;\n\n    /// @notice Amount of ETH claimed by user from sETH staking\n    mapping(bytes => mapping(address => uint256)) public sETHUserClaimForKnot;\n\n    /// @notice Total amount of ETH that has been allocated to the collateralized SLOT owners of a KNOT\n    mapping(bytes => uint256) public totalETHProcessedPerCollateralizedKnot;\n\n    /// @notice Total amount of ETH accrued for the collateralized SLOT owner of a KNOT\n    mapping(bytes => mapping(address => uint256)) public accruedEarningPerCollateralizedSlotOwnerOfKnot;\n\n    /// @notice Total amount of ETH claimed by the collateralized SLOT owner of a KNOT\n    mapping(bytes => mapping(address => uint256)) public claimedPerCollateralizedSlotOwnerOfKnot;\n\n    /// @notice Whether a BLS public key, that has been previously registered, is no longer part of the syndicate and its shares (free floating or SLOT) cannot earn any more rewards\n    mapping(bytes => bool) public isNoLongerPartOfSyndicate;\n\n    /// @notice Once a BLS public key is no longer part of the syndicate, the accumulated ETH per free floating SLOT share is snapshotted so historical earnings can be drawn down correctly\n    mapping(bytes => uint256) public lastAccumulatedETHPerFreeFloatingShare;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @param _contractOwner Ethereum public key that will receive management rights of the contract\n    /// @param _priorityStakingEndBlock Block number when priority sETH staking ends and anyone can stake\n    /// @param _priorityStakers Optional list of addresses that will have priority for staking sETH against each knot registered\n    /// @param _blsPubKeysForSyndicateKnots List of BLS public keys of Stakehouse protocol registered KNOTs participating in syndicate\n    function initialize(\n        address _contractOwner,\n        uint256 _priorityStakingEndBlock,\n        address[] memory _priorityStakers,\n        bytes[] memory _blsPubKeysForSyndicateKnots\n    ) external virtual override initializer {\n        _initialize(\n            _contractOwner,\n            _priorityStakingEndBlock,\n            _priorityStakers,\n            _blsPubKeysForSyndicateKnots\n        );\n    }\n\n    /// @notice Allows the contract owner to append to the list of knots that are part of the syndicate\n    /// @param _newBLSPublicKeyBeingRegistered List of BLS public keys being added to the syndicate\n    function registerKnotsToSyndicate(\n        bytes[] calldata _newBLSPublicKeyBeingRegistered\n    ) external onlyOwner {\n        // update accrued ETH per SLOT type\n        updateAccruedETHPerShares();\n        _registerKnotsToSyndicate(_newBLSPublicKeyBeingRegistered);\n    }\n\n    /// @notice Make knot shares of a registered list of BLS public keys inactive - the action cannot be undone and no further ETH accrued\n    function deRegisterKnots(bytes[] calldata _blsPublicKeys) external onlyOwner {\n        updateAccruedETHPerShares();\n        _deRegisterKnots(_blsPublicKeys);\n    }\n\n    /// @notice Allows the contract owner to append to the list of priority sETH stakers\n    /// @param _priorityStakers List of staker addresses eligible for sETH staking\n    function addPriorityStakers(address[] calldata _priorityStakers) external onlyOwner {\n        updateAccruedETHPerShares();\n        _addPriorityStakers(_priorityStakers);\n    }\n\n    /// @notice Should this block be in the future, it means only those listed in the priority staker list can stake sETH\n    /// @param _endBlock Arbitrary block number after which anyone can stake up to 4 SLOT in sETH per KNOT\n    function updatePriorityStakingBlock(uint256 _endBlock) external onlyOwner {\n        updateAccruedETHPerShares();\n        priorityStakingEndBlock = _endBlock;\n    }\n\n    /// @notice Update accrued ETH per SLOT share without distributing ETH as users of the syndicate individually pull funds\n    function updateAccruedETHPerShares() public {\n        // Ensure there are registered KNOTs. Syndicates are deployed with at least 1 registered but this can fall to zero.\n        // Fee recipient should be re-assigned in the event that happens as any further ETH can be collected by owner\n        if (numberOfRegisteredKnots > 0) {\n            // All time, total ETH that was earned per slot type (free floating or collateralized)\n            uint256 totalEthPerSlotType = calculateETHForFreeFloatingOrCollateralizedHolders();\n\n            // Process free floating if there are staked shares\n            uint256 freeFloatingUnprocessed;\n            if (totalFreeFloatingShares > 0) {\n                freeFloatingUnprocessed = getUnprocessedETHForAllFreeFloatingSlot();\n                accumulatedETHPerFreeFloatingShare += _calculateNewAccumulatedETHPerFreeFloatingShare(freeFloatingUnprocessed);\n                lastSeenETHPerFreeFloating = totalEthPerSlotType;\n            }\n\n            uint256 collateralizedUnprocessed = ((totalEthPerSlotType - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n            accumulatedETHPerCollateralizedSlotPerKnot += collateralizedUnprocessed;\n            lastSeenETHPerCollateralizedSlotPerKnot = totalEthPerSlotType;\n\n            emit UpdateAccruedETH(freeFloatingUnprocessed + collateralizedUnprocessed);\n        }\n    }\n\n    /// @notice Stake up to 4 collateralized SLOT worth of sETH per KNOT to get a portion of syndicate rewards\n    /// @param _blsPubKeys List of BLS public keys for KNOTs registered with the syndicate\n    /// @param _sETHAmounts Per BLS public key, the total amount of sETH that will be staked (up to 4 collateralized SLOT per KNOT)\n    /// @param _onBehalfOf Allows a caller to specify an address that will be assigned stake ownership and rights to claim\n    function stake(bytes[] calldata _blsPubKeys, uint256[] calldata _sETHAmounts, address _onBehalfOf) external {\n        uint256 numOfKeys = _blsPubKeys.length;\n        if (numOfKeys == 0) revert EmptyArray();\n        if (numOfKeys != _sETHAmounts.length) revert InconsistentArrayLengths();\n        if (_onBehalfOf == address(0)) revert ZeroAddress();\n\n        // Make sure we have the latest accrued information\n        updateAccruedETHPerShares();\n\n        for (uint256 i; i < numOfKeys; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            uint256 _sETHAmount = _sETHAmounts[i];\n\n            if (_sETHAmount < 1 gwei) revert FreeFloatingStakeAmountTooSmall();\n            if (!isKnotRegistered[_blsPubKey] || isNoLongerPartOfSyndicate[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();\n\n            if (block.number < priorityStakingEndBlock && !isPriorityStaker[_onBehalfOf]) revert NotPriorityStaker();\n\n            uint256 totalStaked = sETHTotalStakeForKnot[_blsPubKey];\n            if (totalStaked == 12 ether) revert KnotIsFullyStakedWithFreeFloatingSlotTokens();\n\n            if (_sETHAmount + totalStaked > 12 ether) revert InvalidStakeAmount();\n\n            totalFreeFloatingShares += _sETHAmount;\n            sETHTotalStakeForKnot[_blsPubKey] += _sETHAmount;\n            sETHStakedBalanceForKnot[_blsPubKey][_onBehalfOf] += _sETHAmount;\n            sETHUserClaimForKnot[_blsPubKey][_onBehalfOf] += (_sETHAmount * accumulatedETHPerFreeFloatingShare) / PRECISION;\n\n            (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n            if (stakeHouse == address(0)) revert KnotIsNotAssociatedWithAStakeHouse();\n            IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakeHouse));\n            bool transferResult = sETH.transferFrom(msg.sender, address(this), _sETHAmount);\n            if (!transferResult) revert UnableToStakeFreeFloatingSlot();\n\n            emit Staked(_blsPubKey, _sETHAmount);\n        }\n    }\n\n    /// @notice Unstake an sETH position against a particular KNOT and claim ETH on exit\n    /// @param _unclaimedETHRecipient The address that will receive any unclaimed ETH received to the syndicate\n    /// @param _sETHRecipient The address that will receive the sETH that is being unstaked\n    /// @param _blsPubKeys List of BLS public keys for KNOTs registered with the syndicate\n    /// @param _sETHAmounts Per BLS public key, the total amount of sETH that will be unstaked\n    function unstake(\n        address _unclaimedETHRecipient,\n        address _sETHRecipient,\n        bytes[] calldata _blsPubKeys,\n        uint256[] calldata _sETHAmounts\n    ) external nonReentrant {\n        uint256 numOfKeys = _blsPubKeys.length;\n        if (numOfKeys == 0) revert EmptyArray();\n        if (numOfKeys != _sETHAmounts.length) revert InconsistentArrayLengths();\n        if (_unclaimedETHRecipient == address(0)) revert ZeroAddress();\n        if (_sETHRecipient == address(0)) revert ZeroAddress();\n\n        // Claim all ETH owed before unstaking but even if nothing is owed `updateAccruedETHPerShares` will be called\n        _claimAsStaker(_unclaimedETHRecipient, _blsPubKeys);\n\n        for (uint256 i; i < numOfKeys; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            uint256 _sETHAmount = _sETHAmounts[i];\n            if (sETHStakedBalanceForKnot[_blsPubKey][msg.sender] < _sETHAmount) revert NothingStaked();\n\n            (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n            IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakeHouse));\n\n            // Only decrease totalFreeFloatingShares in the event that the knot is still active in the syndicate\n            if (!isNoLongerPartOfSyndicate[_blsPubKey]) {\n                totalFreeFloatingShares -= _sETHAmount;\n            }\n\n            sETHTotalStakeForKnot[_blsPubKey] -= _sETHAmount;\n            sETHStakedBalanceForKnot[_blsPubKey][msg.sender] -= _sETHAmount;\n\n            uint256 accumulatedETHPerShare = _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(_blsPubKey);\n            sETHUserClaimForKnot[_blsPubKey][msg.sender] =\n                (accumulatedETHPerShare * sETHStakedBalanceForKnot[_blsPubKey][msg.sender]) / PRECISION;\n\n            bool transferResult = sETH.transfer(_sETHRecipient, _sETHAmount);\n            if (!transferResult) revert TransferFailed();\n\n            emit UnStaked(_blsPubKey, _sETHAmount);\n        }\n    }\n\n    /// @notice Claim ETH cashflow from the syndicate as an sETH staker proportional to how much the user has staked\n    /// @param _recipient Address that will receive the share of ETH funds\n    /// @param _blsPubKeys List of BLS public keys that the caller has staked against\n    function claimAsStaker(address _recipient, bytes[] calldata _blsPubKeys) public nonReentrant {\n        _claimAsStaker(_recipient, _blsPubKeys);\n    }\n\n    /// @param _blsPubKeys List of BLS public keys that the caller has staked against\n    function claimAsCollateralizedSLOTOwner(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        uint256 numOfKeys = _blsPubKeys.length;\n        if (numOfKeys == 0) revert EmptyArray();\n        if (_recipient == address(0)) revert ZeroAddress();\n        if (_recipient == address(this)) revert ZeroAddress();\n\n        // Make sure we have the latest accrued information for all shares\n        updateAccruedETHPerShares();\n\n        uint256 totalToTransfer;\n        for (uint256 i; i < numOfKeys; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            if (!isKnotRegistered[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();\n\n            // process newly accrued ETH and distribute it to collateralized SLOT owners for the given knot\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKey);\n\n            // Calculate total amount of unclaimed ETH\n            uint256 userShare = accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender];\n\n            // This is designed to cope with falling SLOT balances i.e. when collateralized SLOT is burnt after applying penalties\n            uint256 unclaimedUserShare = userShare - claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender];\n\n            // Send ETH to the user if there is an unclaimed amount\n            if (unclaimedUserShare > 0) {\n                // Increase total claimed and claimed at the user level\n                totalClaimed += unclaimedUserShare;\n                claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender] = userShare;\n\n                // Send ETH to user\n                totalToTransfer += unclaimedUserShare;\n\n                emit ETHClaimed(\n                    _blsPubKey,\n                    msg.sender,\n                    _recipient,\n                    unclaimedUserShare,\n                    true\n                );\n            }\n        }\n\n        _transferETH(_recipient, totalToTransfer);\n    }\n\n    /// @notice For any new ETH received by the syndicate, at the knot level allocate ETH owed to each collateralized owner\n    /// @param _blsPubKey BLS public key relating to the collateralized owners that need updating\n    function updateCollateralizedSlotOwnersAccruedETH(bytes memory _blsPubKey) external {\n        _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKey);\n    }\n\n    /// @notice For any new ETH received by the syndicate, at the knot level allocate ETH owed to each collateralized owner and do it for a batch of knots\n    /// @param _blsPubKeys List of BLS public keys related to the collateralized owners that need updating\n    function batchUpdateCollateralizedSlotOwnersAccruedETH(bytes[] memory _blsPubKeys) external {\n        uint256 numOfKeys = _blsPubKeys.length;\n        if (numOfKeys == 0) revert EmptyArray();\n        for (uint256 i; i < numOfKeys; ++i) {\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKeys[i]);\n        }\n    }\n\n    /// @notice Syndicate contract can receive ETH\n    receive() external payable {\n        // No logic here because one cannot assume that more than 21K GAS limit is forwarded\n    }\n\n    /// @notice Calculate the amount of unclaimed ETH for a given BLS publice key + free floating SLOT staker without factoring in unprocessed rewards\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    /// @param _user The address of a user that has staked sETH against the BLS public key\n    function calculateUnclaimedFreeFloatingETHShare(bytes memory _blsPubKey, address _user) public view returns (uint256) {\n        // Check the user has staked sETH for the KNOT\n        uint256 stakedBal = sETHStakedBalanceForKnot[_blsPubKey][_user];\n        if (stakedBal < 1 gwei) return 0;\n\n        // Get the amount of ETH eligible for the user based on their staking amount\n        uint256 accumulatedETHPerShare = _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(_blsPubKey);\n        uint256 userShare = (accumulatedETHPerShare * stakedBal) / PRECISION;\n\n        // Calculate how much their unclaimed share of ETH is based on total ETH claimed so far\n        return userShare - sETHUserClaimForKnot[_blsPubKey][_user];\n    }\n\n    /// @notice Using `highestSeenBalance`, this is the amount that is separately allocated to either free floating or collateralized SLOT holders\n    function calculateETHForFreeFloatingOrCollateralizedHolders() public view returns (uint256) {\n        // Get total amount of ETH that can be drawn down by all SLOT holders associated with a knot\n        uint256 ethPerKnot = totalETHReceived();\n\n        // Get the amount of ETH eligible for free floating sETH or collateralized SLOT stakers\n        return ethPerKnot / 2;\n    }\n\n    /// @notice Calculate the total unclaimed ETH across an array of BLS public keys for a free floating staker\n    function batchPreviewUnclaimedETHAsFreeFloatingStaker(\n        address _staker,\n        bytes[] calldata _blsPubKeys\n    ) external view returns (uint256) {\n        uint256 accumulated;\n        uint256 numOfKeys = _blsPubKeys.length;\n        for (uint256 i; i < numOfKeys; ++i) {\n            accumulated += previewUnclaimedETHAsFreeFloatingStaker(_staker, _blsPubKeys[i]);\n        }\n\n        return accumulated;\n    }\n\n    /// @notice Preview the amount of unclaimed ETH available for an sETH staker against a KNOT which factors in unprocessed rewards from new ETH sent to contract\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    /// @param _staker The address of a user that has staked sETH against the BLS public key\n    function previewUnclaimedETHAsFreeFloatingStaker(\n        address _staker,\n        bytes calldata _blsPubKey\n    ) public view returns (uint256) {\n        uint256 currentAccumulatedETHPerFreeFloatingShare = accumulatedETHPerFreeFloatingShare;\n        uint256 updatedAccumulatedETHPerFreeFloatingShare =\n                            currentAccumulatedETHPerFreeFloatingShare + calculateNewAccumulatedETHPerFreeFloatingShare();\n\n        uint256 stakedBal = sETHStakedBalanceForKnot[_blsPubKey][_staker];\n        uint256 userShare = (updatedAccumulatedETHPerFreeFloatingShare * stakedBal) / PRECISION;\n\n        return userShare - sETHUserClaimForKnot[_blsPubKey][_staker];\n    }\n\n    /// @notice Calculate the total unclaimed ETH across an array of BLS public keys for a collateralized SLOT staker\n    function batchPreviewUnclaimedETHAsCollateralizedSlotOwner(\n        address _staker,\n        bytes[] calldata _blsPubKeys\n    ) external view returns (uint256) {\n        uint256 accumulated;\n        uint256 numOfKeys = _blsPubKeys.length;\n        for (uint256 i; i < numOfKeys; ++i) {\n            accumulated += previewUnclaimedETHAsCollateralizedSlotOwner(_staker, _blsPubKeys[i]);\n        }\n\n        return accumulated;\n    }\n\n    /// @notice Preview the amount of unclaimed ETH available for a collatearlized SLOT staker against a KNOT which factors in unprocessed rewards from new ETH sent to contract\n    /// @param _staker Address of a collateralized SLOT owner for a KNOT\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    function previewUnclaimedETHAsCollateralizedSlotOwner(\n        address _staker,\n        bytes calldata _blsPubKey\n    ) public view returns (uint256) {\n        // Per collateralized SLOT per KNOT before distributing to individual collateralized owners\n        uint256 accumulatedSoFar = accumulatedETHPerCollateralizedSlotPerKnot\n                    + ((calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n\n        uint256 unprocessedForKnot = accumulatedSoFar - totalETHProcessedPerCollateralizedKnot[_blsPubKey];\n\n        // Fetch information on what has been processed so far against the ECDSA address of the collateralized SLOT owner\n        uint256 currentAccrued = accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][_staker];\n\n        // Fetch information about the knot including total slashed amount\n        uint256 currentSlashedAmount = getSlotRegistry().currentSlashedAmountOfSLOTForKnot(_blsPubKey);\n        uint256 numberOfCollateralisedSlotOwnersForKnot = getSlotRegistry().numberOfCollateralisedSlotOwnersForKnot(_blsPubKey);\n        (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n\n        // Find the collateralized SLOT owner and work out how much they're owed\n        for (uint256 i; i < numberOfCollateralisedSlotOwnersForKnot; ++i) {\n            address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, i);\n            if (collateralizedOwnerAtIndex == _staker) {\n                uint256 balance = getSlotRegistry().totalUserCollateralisedSLOTBalanceForKnot(\n                    stakeHouse,\n                    collateralizedOwnerAtIndex,\n                    _blsPubKey\n                );\n\n                if (currentSlashedAmount < 4 ether) {\n                    currentAccrued +=\n                    numberOfCollateralisedSlotOwnersForKnot > 1 ? balance * unprocessedForKnot / (4 ether - currentSlashedAmount)\n                    : unprocessedForKnot;\n                }\n                break;\n            }\n        }\n\n        return currentAccrued - claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][_staker];\n    }\n\n    /// @notice Amount of ETH per free floating share that hasn't yet been allocated to each share\n    function getUnprocessedETHForAllFreeFloatingSlot() public view returns (uint256) {\n        return calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerFreeFloating;\n    }\n\n    /// @notice Amount of ETH per collateralized share that hasn't yet been allocated to each share\n    function getUnprocessedETHForAllCollateralizedSlot() public view returns (uint256) {\n        return ((calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n    }\n\n    /// @notice New accumulated ETH per free floating share that hasn't yet been applied\n    /// @dev The return value is scaled by 1e24\n    function calculateNewAccumulatedETHPerFreeFloatingShare() public view returns (uint256) {\n        uint256 ethSinceLastUpdate = getUnprocessedETHForAllFreeFloatingSlot();\n        return _calculateNewAccumulatedETHPerFreeFloatingShare(ethSinceLastUpdate);\n    }\n\n    /// @notice New accumulated ETH per collateralized share per knot that hasn't yet been applied\n    function calculateNewAccumulatedETHPerCollateralizedSharePerKnot() public view returns (uint256) {\n        uint256 ethSinceLastUpdate = getUnprocessedETHForAllCollateralizedSlot();\n        return accumulatedETHPerCollateralizedSlotPerKnot + ethSinceLastUpdate;\n    }\n\n    /// @notice Total amount of ETH received by the contract\n    function totalETHReceived() public view returns (uint256) {\n        return address(this).balance + totalClaimed;\n    }\n\n    /// @dev Internal logic for initializing the syndicate contract\n    function _initialize(\n        address _contractOwner,\n        uint256 _priorityStakingEndBlock,\n        address[] memory _priorityStakers,\n        bytes[] memory _blsPubKeysForSyndicateKnots\n    ) internal {\n        // Transfer ownership from the deployer to the address specified as the owner\n        _transferOwnership(_contractOwner);\n\n        // Add the initial set of knots to the syndicate\n        _registerKnotsToSyndicate(_blsPubKeysForSyndicateKnots);\n\n        // Optionally process priority staking if the required params and array is configured\n        if (_priorityStakingEndBlock > block.number) {\n            priorityStakingEndBlock = _priorityStakingEndBlock;\n            _addPriorityStakers(_priorityStakers);\n        }\n\n        emit ContractDeployed();\n    }\n\n    /// Given an amount of ETH allocated to the collateralized SLOT owners of a KNOT, distribute this amongs the current set of collateralized owners (a dynamic set of addresses and balances)\n    function _updateCollateralizedSlotOwnersLiabilitySnapshot(bytes memory _blsPubKey) internal {\n        // Establish how much new ETH is for the new KNOT\n        uint256 unprocessedETHForCurrentKnot =\n                    accumulatedETHPerCollateralizedSlotPerKnot - totalETHProcessedPerCollateralizedKnot[_blsPubKey];\n\n        // Get information about the knot i.e. associated house and whether its active\n        (address stakeHouse,,,,,bool isActive) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n\n        // Assuming that there is unprocessed ETH and the knot is still part of the syndicate\n        if (unprocessedETHForCurrentKnot > 0 && !isNoLongerPartOfSyndicate[_blsPubKey]) {\n            uint256 currentSlashedAmount = getSlotRegistry().currentSlashedAmountOfSLOTForKnot(_blsPubKey);\n\n            // Don't allocate ETH when the current slashed amount is four. Syndicate will wait until ETH is topped up to claim revenue\n            if (currentSlashedAmount < 4 ether) {\n                // This copes with increasing numbers of collateralized slot owners and also copes with SLOT that has been slashed but not topped up\n                uint256 numberOfCollateralisedSlotOwnersForKnot = getSlotRegistry().numberOfCollateralisedSlotOwnersForKnot(_blsPubKey);\n\n                if (numberOfCollateralisedSlotOwnersForKnot == 1) {\n                    // For only 1 collateralized SLOT owner, they get the full amount of unprocessed ETH for the knot\n                    address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, 0);\n                    accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][collateralizedOwnerAtIndex] += unprocessedETHForCurrentKnot;\n                } else {\n                    for (uint256 i; i < numberOfCollateralisedSlotOwnersForKnot; ++i) {\n                        address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, i);\n                        uint256 balance = getSlotRegistry().totalUserCollateralisedSLOTBalanceForKnot(\n                            stakeHouse,\n                            collateralizedOwnerAtIndex,\n                            _blsPubKey\n                        );\n\n                        accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][collateralizedOwnerAtIndex] +=\n                            balance * unprocessedETHForCurrentKnot / (4 ether - currentSlashedAmount);\n                    }\n                }\n\n                // record so unprocessed goes to zero\n                totalETHProcessedPerCollateralizedKnot[_blsPubKey] = accumulatedETHPerCollateralizedSlotPerKnot;\n            }\n        }\n\n        // if the knot is no longer active, no further accrual of rewards are possible snapshots are possible but ETH accrued up to that point\n        // Basically, under a rage quit or voluntary withdrawal from the beacon chain, the knot kick is auto-propagated to syndicate\n        if (!isActive && !isNoLongerPartOfSyndicate[_blsPubKey]) {\n            _deRegisterKnot(_blsPubKey);\n        }\n    }\n\n    function _calculateCollateralizedETHOwedPerKnot() internal view returns (uint256) {\n        uint256 collateralizedSLOTShareOfETH = calculateETHForFreeFloatingOrCollateralizedHolders();\n        uint256 collateralizedSLOTShareOfETHPerKnot = (collateralizedSLOTShareOfETH / numberOfRegisteredKnots);\n        return collateralizedSLOTShareOfETHPerKnot;\n    }\n\n    /// @dev Business logic for calculating per collateralized share how much ETH from 1559 rewards is owed\n    function _calculateNewAccumulatedETHPerCollateralizedShare(uint256 _ethSinceLastUpdate) internal view returns (uint256) {\n        return (_ethSinceLastUpdate * PRECISION) / (numberOfRegisteredKnots * 4 ether);\n    }\n\n    /// @dev Business logic for calculating per free floating share how much ETH from 1559 rewards is owed\n    function _calculateNewAccumulatedETHPerFreeFloatingShare(uint256 _ethSinceLastUpdate) internal view returns (uint256) {\n        return totalFreeFloatingShares > 0 ? (_ethSinceLastUpdate * PRECISION) / totalFreeFloatingShares : 0;\n    }\n\n    /// @dev Business logic for adding a new set of knots to the syndicate for collecting revenue\n    function _registerKnotsToSyndicate(bytes[] memory _blsPubKeysForSyndicateKnots) internal {\n        uint256 knotsToRegister = _blsPubKeysForSyndicateKnots.length;\n        if (knotsToRegister == 0) revert EmptyArray();\n        numberOfRegisteredKnots += knotsToRegister;\n\n        for (uint256 i; i < knotsToRegister; ++i) {\n            bytes memory blsPubKey = _blsPubKeysForSyndicateKnots[i];\n\n            if (isKnotRegistered[blsPubKey]) revert KnotIsAlreadyRegistered();\n\n            // incomming knot collateralized SLOT holders do not get historical earnings\n            totalETHProcessedPerCollateralizedKnot[blsPubKey] = accumulatedETHPerCollateralizedSlotPerKnot;\n\n            // Health check - if knot is inactive or slashed, should it really be part of the syndicate?\n            // KNOTs closer to 32 effective at all times is the target\n            (,,,,,bool isActive) = getStakeHouseUniverse().stakeHouseKnotInfo(blsPubKey"
    }
  ]
}