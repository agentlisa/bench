{
  "Title": "[M-14] Merkle-tree-related contracts vulnerable to cross-chain-replay attacks",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleDropFactory.sol#L94\n\n\n# Vulnerability details\n\n> Bank is a token vesting, airdrop and payroll tool. It uses merkle trees to massively scale token distributions with integrated vesting (time locks). The idea of this tool is that it allows DAOs to vest pre-sale participants, and future allocations of tokens (such as DAO treasury allocations) far into the future. These are important contracts since they need longevity and will secure large allocations of tokens. \n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/README.md?plain=1#L28\n\nSince these trees are long-lived, they need to be able to handle forks correctly. If someone generates an exchange address for their drops, that address may only be valid for that chain (e.g. exchange supports BTC but not BSV), and any funds sent to the unsupported chain are lost.\n\n## Impact\nIf there's a fork, since anyone can call `withdraw()`, an attacker can monitor the blockchain for calls to `withdraw()`, and then make the same call with the same arguments on the other chain, which will send funds to the unsupported address.\n\n## Proof of Concept\nThere are no EIP-712 protections in the encoding:\n```solidity\nFile: contracts/MerkleDropFactory.sol   #1\n\n94           bytes32 leaf = keccak256(abi.encode(destination, value));\n```\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleDropFactory.sol#L94\n\n```solidity\nFile: contracts/MerkleVesting.sol   #2\n\n109           bytes32 leaf = keccak256(abi.encode(destination, totalCoins, startTime, endTime, lockPeriodEndTime));\n```\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleVesting.sol#L109\n\nand anyone can trigger a withdrawal:\n```solidity\nFile: contracts/MerkleDropFactory.sol   #3\n\n82       /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n83       /// @dev who provides the proof and pays the gas, msg.sender is not used in this function\n```\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleDropFactory.sol#L82-L83\n\n## Tools Used\nCode inspection\n\n## Recommended Mitigation Steps\nAdd EIP-712 protections and add a mechanism to allow tokens to be transferred to a different address using EIP-2612 `permit()`\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-factorydao-contest",
  "Code": [
    {
      "filename": "contracts/MerkleDropFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./MerkleLib.sol\";\n\n/// @title A factory pattern for merkledrops, that is, airdrops using merkleproofs to compute eligibility\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissionless and public facing. Any fees must be included in the data of the merkle tree.\n/// @dev The contract cannot introspect into the contents of the merkle tree, except when provided a merkle proof,\n/// @dev therefore the total liabilities of the merkle tree are untrusted and tree balances must be managed separately\ncontract MerkleDropFactory {\n    using MerkleLib for bytes32;\n\n    // the number of airdrops in this contract\n    uint public numTrees = 0;\n\n    // this represents a single airdrop\n    struct MerkleTree {\n        bytes32 merkleRoot;  // merkleroot of tree whose leaves are (address,uint) pairs representing amount owed to user\n        bytes32 ipfsHash; // ipfs hash of entire dataset, as backup in case our servers turn off...\n        address tokenAddress; // address of token that is being airdropped\n        uint tokenBalance; // amount of tokens allocated for this tree\n        uint spentTokens; // amount of tokens dispensed from this tree\n    }\n\n    // withdrawn[recipient][treeIndex] = hasUserWithdrawnAirdrop\n    mapping (address => mapping (uint => bool)) public withdrawn;\n\n    // array-like map for all ze merkle trees (airdrops)\n    mapping (uint => MerkleTree) public merkleTrees;\n\n    // every time there's a withdraw\n    event WithdrawalOccurred(uint indexed treeIndex, address indexed destination, uint value);\n\n    // every time a tree is added\n    event MerkleTreeAdded(uint indexed treeIndex, address indexed tokenAddress, bytes32 newRoot, bytes32 ipfsHash);\n\n    // every time a tree is topped up\n    event TokensDeposited(uint indexed treeIndex, address indexed tokenAddress, uint amount);\n\n    /// @notice Add a new merkle tree to the contract, creating a new merkle-drop\n    /// @dev Anyone may call this function, therefore we must make sure trees cannot affect each other\n    /// @param newRoot root hash of merkle tree representing liabilities == (destination, value) pairs\n    /// @param ipfsHash the ipfs hash of the entire dataset, used for redundance so that creator can ensure merkleproof are always computable\n    /// @param tokenAddress the address of the token contract that is being distributed\n    /// @param tokenBalance the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function addMerkleTree(bytes32 newRoot, bytes32 ipfsHash, address tokenAddress, uint tokenBalance) public {\n        // prefix operator ++ increments then evaluates\n        merkleTrees[++numTrees] = MerkleTree(\n            newRoot,\n            ipfsHash,\n            tokenAddress,\n            0,  // ain't no tokens in here yet\n            0   // ain't nobody claimed no tokens yet either\n        );\n        // you don't get to add a tree without funding it\n        depositTokens(numTrees, tokenBalance);\n        // I guess we should tell people (interfaces) what happened\n        emit MerkleTreeAdded(numTrees, tokenAddress, newRoot, ipfsHash);\n    }\n\n    /// @notice Add funds to an existing merkle-drop\n    /// @dev Anyone may call this function, the only risk here is that the token contract is malicious, rendering the tree malicious\n    /// @param treeIndex index into array-like map of merkleTrees\n    /// @param value the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function depositTokens(uint treeIndex, uint value) public {\n        // storage since we are editing\n        MerkleTree storage merkleTree = merkleTrees[treeIndex];\n\n        // bookkeeping to make sure trees don't share tokens\n        merkleTree.tokenBalance += value;\n\n        // transfer tokens, if this is a malicious token, then this whole tree is malicious\n        // but it does not effect the other trees\n        require(IERC20(merkleTree.tokenAddress).transferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");\n        emit TokensDeposited(treeIndex, merkleTree.tokenAddress, value);\n    }\n\n    /// @notice Claim funds as a recipient in the merkle-drop\n    /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n    /// @dev who provides the proof and pays the gas, msg.sender is not used in this function\n    /// @param treeIndex index into array-like map of merkleTrees, which tree should we apply the proof to?\n    /// @param destination recipient of tokens\n    /// @param value amount of tokens that will be sent to destination\n    /// @param proof array of hashes bridging from leaf (hash of destination | value) to merkle root\n    function withdraw(uint treeIndex, address destination, uint value, bytes32[] memory proof) public {\n        // no withdrawing from uninitialized merkle trees\n        require(treeIndex <= numTrees, \"Provided merkle index doesn't exist\");\n        // no withdrawing same airdrop twice\n        require(!withdrawn[destination][treeIndex], \"You have already withdrawn your entitled token.\");\n        // compute merkle leaf, this is first element of proof\n        bytes32 leaf = keccak256(abi.encode(destination, value));\n        // storage because we edit\n        MerkleTree storage tree = merkleTrees[treeIndex];\n        // this calls to MerkleLib, will return false if recursive hashes do not end in merkle root\n        require(tree.merkleRoot.verifyProof(leaf, proof), \"The proof could not be verified.\");\n        // close re-entrance gate, prevent double claims\n        withdrawn[destination][treeIndex] = true;\n        // update struct\n        tree.tokenBalance -= value;\n        tree.spentTokens += value;\n        // transfer the tokens\n        // NOTE: if the token contract is malicious this call could re-enter this function\n        // which will fail because withdrawn will be set to true\n        require(IERC20(tree.tokenAddress).transfer(destination, value), \"ERC20 transfer failed\");\n        emit WithdrawalOccurred(treeIndex, destination, value);\n    }\n\n}"
    }
  ]
}