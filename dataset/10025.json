{
  "Title": "[M-01] L1Migrator.migrateLPT` can be used to take away protocol's access to LPT tokens in BridgeMinter",
  "Content": "_Submitted by Ruhum, also found by gzeon and harleythedog_.\n\nSame thing as the ETH issue I reported earlier. I wasn't sure if those are supposed to be a single issue or not. The concept is the same. But, now you lose LPT tokens.\n\nThe `L1Migrator.migrateLPT()` function can be called by **anyone**. It pulls all the LPT from the `BridgeMinter` contract and starts the process of moving the funds to L2. First of all, this function is only executable once. The RetryableTicket created with the first call is the only chance of moving the funds to L2.\n\nThe attacker can call the function with [parameters](https://developer.offchainlabs.com/docs/l1\\_l2\\_messages#parameters) that make the creation of the RetryableTicket on L2 fail. Thus, the LPT sits in the L1Migrator contract with no way of moving it to L2 or anywhere else. Effectively, the funds are lost.\n\n#### Proof of Concept\n\nThe function is only executable once because it uses the `amount` returned by `IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator()` to specify the amount of LPT to be sent to L2: <https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L342>\n\nAfter the first call to `migrateLPT()` that function will always return 0 since the `BridgeMinter` won't have any more LPT: <https://github.com/livepeer/protocol/blob/streamflow/contracts/token/BridgeMinter.sol#L107>\n\nSo after the attacker called `migrateLPT()` with insufficient funds to create a RetryableTicket on L2 we have the following state:\n\n*   BridgeMinter has 0 LPT\n*   L1Migrator has X amount of LPT that is not accessible. There are no functions to get the LPT out of there.\n*   1 failed RetryTicket\n\nThe same thing can also be triggered by a non-malicious caller by simply providing insufficient funds. The whole design of only being able to try once is the issue here.\n\n#### Recommended Mitigation Steps\n\nInstead of using the `amount` returned by `IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator()` you should use the balance of the `L1Migrator` contract.\n\nIt might also make sense to **not** allow anybody to call the function. I don't see the benefit of that.\n\nActually, the funds aren't lost. The funds are sent to the Escrow contract which can be used to transfer the funds back to the BridgeMinter contract. Thus, you could reset the whole thing to its initial state and call `L1Migrator.migrateLPT()` again. But, a really persistent attacker has the ability to DoS the function by frontrunning any call to it which results in the RetryableTicket failing again. Thus, you'd have to transfer the funds from the Escrow contract to the BrigeMinter again and so on.\n\nSo the same scenario I've outlined earlier is still viable. It's just a bit more difficult now since it has a higher cost for the attacker now. Because of that I think it's an medium issue instead of high.\n\nAlso, the mitigation steps I've given aren't valid. You can't use the `L1Migrator` contract's balance since it will always be 0 (the funds are sent to the Escrow contract). Thus the best solution would be to just limit the access to the function.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-livepeer-findings/issues/97#issuecomment-1025008823):**\n > Nice find! The warden has outlined a potential DOS attack which can lead to funds lost which are only recoverable by the transferring the funds in the escrow contract back to the bridge minter contract.\n\n**[yondonfu (Livepeer) confirmed and resolved](https://github.com/code-423n4/2022-01-livepeer-findings/issues/97#issuecomment-1026222409):**\n > Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/commit/5b6a349ad8f4e53c01d2e43eda36bbbf3037a3c9\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-01-livepeer",
  "Code": [
    {
      "filename": "contracts/L1/gateway/L1Migrator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport {L1ArbitrumMessenger} from \"./L1ArbitrumMessenger.sol\";\nimport {IL1LPTGateway} from \"./IL1LPTGateway.sol\";\nimport {IMigrator} from \"../../interfaces/IMigrator.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ninterface IBondingManager {\n    function isRegisteredTranscoder(address _addr) external view returns (bool);\n\n    function pendingStake(address _addr, uint256 _endRound)\n        external\n        view\n        returns (uint256);\n\n    function pendingFees(address _addr, uint256 _endRound)\n        external\n        view\n        returns (uint256);\n\n    function getDelegator(address _addr)\n        external\n        view\n        returns (\n            uint256 bondedAmount,\n            uint256 fees,\n            address delegateAddress,\n            uint256 delegatedAmount,\n            uint256 startRound,\n            uint256 lastClaimRound,\n            uint256 nextUnbondingLockId\n        );\n\n    function getDelegatorUnbondingLock(address _addr, uint256 _unbondingLockId)\n        external\n        view\n        returns (uint256 amount, uint256 withdrawRound);\n}\n\ninterface ITicketBroker {\n    struct Sender {\n        uint256 deposit;\n        uint256 withdrawRound;\n    }\n\n    struct ReserveInfo {\n        uint256 fundsRemaining;\n        uint256 claimedInCurrentRound;\n    }\n\n    function getSenderInfo(address _addr)\n        external\n        view\n        returns (Sender memory sender, ReserveInfo memory reserve);\n}\n\ninterface IBridgeMinter {\n    function withdrawETHToL1Migrator() external returns (uint256);\n\n    function withdrawLPTToL1Migrator() external returns (uint256);\n}\n\ninterface ApproveLike {\n    function approve(address _addr, uint256 _amount) external;\n}\n\ninterface IL2Migrator is IMigrator {\n    function finalizeMigrateDelegator(MigrateDelegatorParams memory _params)\n        external;\n\n    function finalizeMigrateUnbondingLocks(\n        MigrateUnbondingLocksParams memory _params\n    ) external;\n\n    function finalizeMigrateSender(MigrateSenderParams memory _params) external;\n}\n\ncontract L1Migrator is\n    L1ArbitrumMessenger,\n    IMigrator,\n    EIP712,\n    AccessControl,\n    Pausable\n{\n    address public immutable bondingManagerAddr;\n    address public immutable ticketBrokerAddr;\n    address public immutable tokenAddr;\n    address public immutable l1LPTGatewayAddr;\n    address public bridgeMinterAddr;\n    address public l2MigratorAddr;\n\n    event MigrateDelegatorInitiated(\n        uint256 indexed seqNo,\n        MigrateDelegatorParams params\n    );\n\n    event MigrateUnbondingLocksInitiated(\n        uint256 indexed seqNo,\n        MigrateUnbondingLocksParams params\n    );\n\n    event MigrateSenderInitiated(\n        uint256 indexed seqNo,\n        MigrateSenderParams params\n    );\n\n    event L2MigratorUpdate(address l2Migrator);\n    event BridgeMinterUpdate(address bridgeMinter);\n\n    bytes32 private immutable MIGRATE_DELEGATOR_TYPE_HASH =\n        keccak256(\"MigrateDelegator(address l1Addr,address l2Addr)\");\n\n    bytes32 private immutable MIGRATE_UNBONDING_LOCKS_TYPE_HASH =\n        keccak256(\n            \"MigrateUnbondingLocks(address l1Addr,address l2Addr,uint256[] unbondingLockIds)\"\n        );\n\n    bytes32 private immutable MIGRATE_SENDER_TYPE_HASH =\n        keccak256(\"MigrateSender(address l1Addr,address l2Addr)\");\n\n    constructor(\n        address _inbox,\n        address _bondingManagerAddr,\n        address _ticketBrokerAddr,\n        address _tokenAddr,\n        address _l1LPTGatewayAddr,\n        address _l2MigratorAddr\n    ) L1ArbitrumMessenger(_inbox) EIP712(\"Livepeer L1Migrator\", \"1\") {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        bondingManagerAddr = _bondingManagerAddr;\n        ticketBrokerAddr = _ticketBrokerAddr;\n        tokenAddr = _tokenAddr;\n        l1LPTGatewayAddr = _l1LPTGatewayAddr;\n        l2MigratorAddr = _l2MigratorAddr;\n\n        _pause();\n    }\n\n    /**\n     * @notice Sets L2Migrator\n     * @param _l2MigratorAddr L2Migrator address\n     */\n    function setL2Migrator(address _l2MigratorAddr)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        l2MigratorAddr = _l2MigratorAddr;\n        emit L2MigratorUpdate(_l2MigratorAddr);\n    }\n\n    /**\n     * @notice Sets BridgeMinter\n     * @param _bridgeMinterAddr BridgeMinter address\n     */\n    function setBridgeMinter(address _bridgeMinterAddr)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        bridgeMinterAddr = _bridgeMinterAddr;\n        emit BridgeMinterUpdate(_bridgeMinterAddr);\n    }\n\n    /**\n     * @notice Receive ETH when there is no msg.data\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Executes a L2 call to L2Migrator to migrate transcoder/delegator state from the L1 BondingManager.\n     * @dev The term \"delegator\" here can refer to both a transcoder (self-delegated delegator) and delegator.\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @param _sig Optional EIP-712 signature over a payload that includes _l1Addr and _l2Addr\n     * @param _maxGas Gas limit for L2 execution\n     * @param _gasPriceBid Gas price bid for L2 execution\n     * @param _maxSubmissionCost Max ETH to pay for retryable ticket base submission fee\n     */\n    function migrateDelegator(\n        address _l1Addr,\n        address _l2Addr,\n        bytes calldata _sig,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable whenNotPaused {\n        // Authorization\n        // Either msg.sender == _l1Addr OR signer for _sig == _l1Addr\n        requireValidMigration(\n            _l1Addr,\n            _l2Addr,\n            keccak256(\n                abi.encode(MIGRATE_DELEGATOR_TYPE_HASH, _l1Addr, _l2Addr)\n            ),\n            _sig\n        );\n\n        (\n            bytes memory data,\n            MigrateDelegatorParams memory params\n        ) = getMigrateDelegatorParams(_l1Addr, _l2Addr);\n\n        // We do not prevent migration replays here to minimize L1 gas costs\n        // The L2Migrator is responsible for rejecting migration replays\n\n        uint256 seqNo = sendTxToL2(\n            l2MigratorAddr,\n            _l2Addr, // Refunds to the L2 address\n            _maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            data\n        );\n\n        emit MigrateDelegatorInitiated(seqNo, params);\n    }\n\n    /**\n     * @notice Executes a L2 call to L2Migrator to migrate unbonding locks state from the L1 BondingManager.\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @param _unbondingLockIds IDs of unbonding locks in the L1 BondingManager to migrate\n     * @param _sig Optional EIP-712 signature over a payload that includes _l1Addr, _l2Addr and _unbondingLockIds\n     * @param _maxGas Gas limit for L2 execution\n     * @param _gasPriceBid Gas price bid for L2 execution\n     * @param _maxSubmissionCost Max ETH to pay for retryable ticket base submission fee\n     */\n    function migrateUnbondingLocks(\n        address _l1Addr,\n        address _l2Addr,\n        uint256[] calldata _unbondingLockIds,\n        bytes calldata _sig,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable whenNotPaused {\n        // Authorization\n        // Either msg.sender == _l1Addr OR signer for _sig == _l1Addr\n        requireValidMigration(\n            _l1Addr,\n            _l2Addr,\n            keccak256(\n                abi.encode(\n                    MIGRATE_UNBONDING_LOCKS_TYPE_HASH,\n                    _l1Addr,\n                    _l2Addr,\n                    keccak256(abi.encodePacked(_unbondingLockIds))\n                )\n            ),\n            _sig\n        );\n\n        (\n            bytes memory data,\n            MigrateUnbondingLocksParams memory params\n        ) = getMigrateUnbondingLocksParams(_l1Addr, _l2Addr, _unbondingLockIds);\n\n        // We do not prevent migration replays here to minimize L1 gas costs\n        // The L2Migrator is responsible for rejecting migration replays\n\n        uint256 seqNo = sendTxToL2(\n            l2MigratorAddr,\n            _l2Addr, // Refund to the L2 address\n            _maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            data\n        );\n\n        emit MigrateUnbondingLocksInitiated(seqNo, params);\n    }\n\n    /**\n     * @notice Executes a L2 call to L2Migrator to migrate sender deposit/reserve state from the L1 TicketBroker.\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @param _sig Optional EIP-712 signature over a payload that includes _l1Addr and _l2Addr\n     * @param _maxGas Gas limit for L2 execution\n     * @param _gasPriceBid Gas price bid for L2 execution\n     * @param _maxSubmissionCost Max ETH to pay for retryable ticket base submission fee\n     */\n    function migrateSender(\n        address _l1Addr,\n        address _l2Addr,\n        bytes calldata _sig,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable whenNotPaused {\n        // Authorization\n        // Either msg.sender == _l1Addr OR signer for _sig == _l1Addr\n        requireValidMigration(\n            _l1Addr,\n            _l2Addr,\n            keccak256(abi.encode(MIGRATE_SENDER_TYPE_HASH, _l1Addr, _l2Addr)),\n            _sig\n        );\n\n        (\n            bytes memory data,\n            MigrateSenderParams memory params\n        ) = getMigrateSenderParams(_l1Addr, _l2Addr);\n\n        // We do not prevent migration replays here to minimize L1 gas costs\n        // The L2Migrator is responsible for rejecting migration replays\n\n        uint256 seqNo = sendTxToL2(\n            l2MigratorAddr,\n            _l2Addr, // Refund to the L2 address\n            _maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            data\n        );\n\n        emit MigrateSenderInitiated(seqNo, params);\n    }\n\n    /**\n     * @notice Executes a L2 call to send ETH from the L1BridgeMinter to the L2Migrator.\n     * @dev Anyone can call this function.\n     * @param _maxGas Gas limit for L2 execution\n     * @param _gasPriceBid Gas price bid for L2 execution\n     * @param _maxSubmissionCost Max ETH to pay for retryable ticket base submission fee\n     */\n    function migrateETH(\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable whenNotPaused {\n        uint256 amount = IBridgeMinter(bridgeMinterAddr)\n            .withdrawETHToL1Migrator();\n\n        // Any ETH refunded to the L2 alias of this contract can be used for\n        // other cross-chain txs sent by this contract.\n        // The retryable ticket created will not be cancellable since this contract\n        // currently does not support cross-chain txs to call ArbRetryableTx.cancel().\n        // Regarding the comment below on this contract receiving refunds:\n        // msg.sender also cannot be the address to receive refunds as beneficiary because otherwise\n        // msg.sender could cancel the ticket before it is executed on L2 to receive the L2 call value.\n        sendTxToL2(\n            l2MigratorAddr,\n            address(this), // L2 alias of this contract will receive refunds\n            msg.value + amount,\n            amount,\n            _maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Executes a L2 call to send LPT from the L1BridgeMinter to the L2Migrator.\n     * @dev Anyone can call this function.\n     * @param _maxGas Gas limit for L2 execution\n     * @param _gasPriceBid Gas price bid for L2 execution\n     * @param _maxSubmissionCost Max ETH to pay for retryable ticket base submission fee\n     */\n    function migrateLPT(\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable whenNotPaused onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 amount = IBridgeMinter(bridgeMinterAddr)\n            .withdrawLPTToL1Migrator();\n\n        // Approve L1LPTGateway to pull tokens\n        ApproveLike(tokenAddr).approve(l1LPTGatewayAddr, amount);\n        // Trigger cross-chain transfer with L1LPTGateway which will pull and escrow tokens\n        // Forward msg.value to outboundTransfer() to be used for cross-chain tx\n        IL1LPTGateway(l1LPTGatewayAddr).outboundTransfer{value: msg.value}(\n            tokenAddr,\n            l2MigratorAddr,\n            amount,\n            _maxGas,\n            _gasPriceBid,\n            abi.encode(_maxSubmissionCost, \"\")\n        );\n    }\n\n    /**\n     * @notice Pause the contract\n     * @dev Only callable by addresses with governor role\n     */\n    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the contract\n     * @dev Only callable by addresses with governor role\n     */\n    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    /**\n     * @notice Return L2 calldata and MigrateDelegatorParams to use for a L2 call on L2Migrator\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @return data L2 calldata for finalizeMigrateDelegator() in L2Migrator\n     * @return params MigrateDelegatorParams to use for finalizeMigrateDelegator() in L2Migrator\n     */\n    function getMigrateDelegatorParams(address _l1Addr, address _l2Addr)\n        public\n        view\n        returns (bytes memory data, MigrateDelegatorParams memory params)\n    {\n        IBondingManager bondingManager = IBondingManager(bondingManagerAddr);\n\n        // pendingStake() will use current round if _endRound >= LIP-36 round\n        // Using max uint256 guarantees that\n        uint256 stake = bondingManager.pendingStake(_l1Addr, type(uint256).max);\n        // pendingFees() will use current round if _endRound >= LIP-36 round\n        // Using max uint256 guarantees that\n        uint256 fees = bondingManager.pendingFees(_l1Addr, type(uint256).max);\n        (\n            ,\n            ,\n            address delegateAddress,\n            uint256 delegatedAmount,\n            ,\n            ,\n\n        ) = bondingManager.getDelegator(_l1Addr);\n\n        // Construct params and L2 calldata for finalizeMigrateDelegator() on L2Migrator\n        params = MigrateDelegatorParams({\n            l1Addr: _l1Addr,\n            l2Addr: _l2Addr,\n            stake: stake,\n            delegatedStake: delegatedAmount,\n            fees: fees,\n            delegate: delegateAddress\n        });\n\n        data = abi.encodeWithSelector(\n            IL2Migrator.finalizeMigrateDelegator.selector,\n            params\n        );\n    }\n\n    /**\n     * @notice Return L2 calldata and MigrateSenderParams to use for a L2 call on L2Migrator\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @return data L2 calldata for finalizeMigrateSender() in L2Migrator\n     * @return params MigrateSenderParams to use for finalizeMigrateSender() in L2Migrator\n     */\n    function getMigrateSenderParams(address _l1Addr, address _l2Addr)\n        public\n        view\n        returns (bytes memory data, MigrateSenderParams memory params)\n    {\n        ITicketBroker ticketBroker = ITicketBroker(ticketBrokerAddr);\n\n        (\n            ITicketBroker.Sender memory sender,\n            ITicketBroker.ReserveInfo memory reserveInfo\n        ) = ticketBroker.getSenderInfo(_l1Addr);\n\n        // Construct params and L2 calldata for finalizeMigrateSender() on L2Migrator\n        params = MigrateSenderParams({\n            l1Addr: _l1Addr,\n            l2Addr: _l2Addr,\n            deposit: sender.deposit,\n            reserve: reserveInfo.fundsRemaining\n        });\n\n        data = abi.encodeWithSelector(\n            IL2Migrator.finalizeMigrateSender.selector,\n            params\n        );\n    }\n\n    /**\n     * @notice Return L2 calldata and MigrateUnbondingLocksParams to use for a L2 call on L2Migrator\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @param _unbondingLockIds IDs of unbonding locks in L1 BondingManager to migrate\n     * @return data L2 calldata for finalizeMigrateUnbondingLocks() in L2Migrator\n     * @return params MigrateUnbondingLocksParams to use for finalizeMigrateUnbondingLocks() in L2Migrator\n     */\n    function getMigrateUnbondingLocksParams(\n        address _l1Addr,\n        address _l2Addr,\n        uint256[] memory _unbondingLockIds\n    )\n        public\n        view\n        returns (bytes memory data, MigrateUnbondingLocksParams memory params)\n    {\n        IBondingManager bondingManager = IBondingManager(bondingManagerAddr);\n\n        uint256 total;\n        uint256 unbondingLockIdsLen = _unbondingLockIds.length;\n        for (uint256 i; i < unbondingLockIdsLen; i++) {\n            (uint256 amount, ) = bondingManager.getDelegatorUnbondingLock(\n                _l1Addr,\n                _unbondingLockIds[i]\n            );\n\n            total += amount;\n        }\n\n        (, , address delegateAddress, , , , ) = bondingManager.getDelegator(\n            _l1Addr\n        );\n\n        // Construct params and L2 calldata for finalizeMigrateUnbondingLocks() on L2Migrator\n        params = MigrateUnbondingLocksParams({\n            l1Addr: _l1Addr,\n            l2Addr: _l2Addr,\n            total: total,\n            unbondingLockIds: _unbondingLockIds,\n            delegate: delegateAddress\n        });\n\n        data = abi.encodeWithSelector(\n            IL2Migrator.finalizeMigrateUnbondingLocks.selector,\n            params\n        );\n    }\n\n    function requireValidMigration(\n        address _l1Addr,\n        address _l2Addr,\n        bytes32 _structHash,\n        bytes memory _sig\n    ) private view {\n        require(_l2Addr != address(0), \"INVALID_L2_ADDR\");\n        require(\n            msg.sender == _l1Addr ||\n                recoverSigner(_structHash, _sig) == _l1Addr,\n            \"FAIL_AUTH\"\n        );\n    }\n\n    function recoverSigner(bytes32 _structHash, bytes memory _sig)\n        private\n        view\n        returns (address)\n    {\n        bytes32 hash = _hashTypedDataV4(_structHash);\n        return ECDSA.recover(hash, _sig);\n    }\n}"
    },
    {
      "filename": "contracts/token/BridgeMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line\npragma solidity 0.8.9;\n\nimport \"../solc-0.8.9/Manager.sol\";\n\ninterface IBridgeMinterToken {\n    function transfer(address _to, uint256 _amount) external;\n\n    function mint(address _to, uint256 _amount) external;\n\n    function transferOwnership(address _owner) external;\n\n    function balanceOf(address _addr) external view returns (uint256);\n}\n\ncontract BridgeMinter is Manager {\n    address public l1MigratorAddr;\n    address public l1LPTGatewayAddr;\n\n    event L1MigratorUpdate(address l1MigratorAddr);\n    event L1LPTGatewayUpdate(address l1LPTGatewayAddr);\n\n    modifier onlyL1Migrator() {\n        require(msg.sender == l1MigratorAddr, \"NOT_L1_MIGRATOR\");\n        _;\n    }\n\n    modifier onlyL1LPTGateway() {\n        require(msg.sender == l1LPTGatewayAddr, \"NOT_L1_LPT_GATEWAY\");\n        _;\n    }\n\n    constructor(\n        address _controller,\n        address _l1MigratorAddr,\n        address _l1LPTGatewayAddr\n    ) Manager(_controller) {\n        l1MigratorAddr = _l1MigratorAddr;\n        l1LPTGatewayAddr = _l1LPTGatewayAddr;\n    }\n\n    /**\n     * @notice Set L1Migrator address. Only callable by Controller owner\n     * @param _l1MigratorAddr L1Migrator address\n     */\n    function setL1Migrator(address _l1MigratorAddr) external onlyControllerOwner {\n        l1MigratorAddr = _l1MigratorAddr;\n\n        emit L1MigratorUpdate(_l1MigratorAddr);\n    }\n\n    /**\n     * @notice Set L1LPTGateway address. Only callable by Controller owner\n     * @param _l1LPTGatewayAddr L1LPTGateway address\n     */\n    function setL1LPTGateway(address _l1LPTGatewayAddr) external onlyControllerOwner {\n        l1LPTGatewayAddr = _l1LPTGatewayAddr;\n\n        emit L1LPTGatewayUpdate(_l1LPTGatewayAddr);\n    }\n\n    /**\n     * @notice Migrate to a new Minter. Only callable by Controller owner\n     * @param _newMinterAddr New Minter address\n     */\n    function migrateToNewMinter(address _newMinterAddr) external onlyControllerOwner {\n        require(\n            _newMinterAddr != address(this) && _newMinterAddr != address(0),\n            \"BridgeMinter#migrateToNewMinter: INVALID_MINTER\"\n        );\n\n        IBridgeMinterToken token = livepeerToken();\n        // Transfer ownership of token to new Minter\n        token.transferOwnership(_newMinterAddr);\n        // Transfer current Minter's LPT balance to new Minter\n        token.transfer(_newMinterAddr, token.balanceOf(address(this)));\n        // Transfer current Minter's ETH balance to new Minter\n        // call() should be safe from re-entrancy here because the Controller owner and _newMinterAddr are trusted\n        (bool ok, ) = _newMinterAddr.call{ value: address(this).balance }(\"\");\n        require(ok, \"BridgeMinter#migrateToNewMinter: FAIL_CALL\");\n    }\n\n    /**\n     * @notice Send contract's ETH to L1Migrator. Only callable by L1Migrator\n     * @return Amount of ETH sent\n     */\n    function withdrawETHToL1Migrator() external onlyL1Migrator returns (uint256) {\n        uint256 balance = address(this).balance;\n\n        // call() should be safe from re-entrancy here because the L1Migrator and l1MigratorAddr are trusted\n        (bool ok, ) = l1MigratorAddr.call{ value: balance }(\"\");\n        require(ok, \"BridgeMinter#withdrawETHToL1Migrator: FAIL_CALL\");\n\n        return balance;\n    }\n\n    /**\n     * @notice Send contract's LPT to L1Migrator. Only callable by L1Migrator\n     * @return Amount of LPT sent\n     */\n    function withdrawLPTToL1Migrator() external onlyL1Migrator returns (uint256) {\n        IBridgeMinterToken token = livepeerToken();\n\n        uint256 balance = token.balanceOf(address(this));\n\n        token.transfer(l1MigratorAddr, balance);\n\n        return balance;\n    }\n\n    /**\n     * @notice Mint LPT to address. Only callable by L1LPTGateway\n     * @dev Relies on L1LPTGateway for minting rules\n     * @param _to Address to receive LPT\n     * @param _amount Amount of LPT to mint\n     */\n    function bridgeMint(address _to, uint256 _amount) external onlyL1LPTGateway {\n        livepeerToken().mint(_to, _amount);\n    }\n\n    /**\n     * @notice Deposit ETH. Required for migrateToNewMinter() from older Minter implementation\n     */\n    function depositETH() external payable returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Returns Controller address. Required for migrateToNewMinter() from older Minter implementation\n     * @return Controller address\n     */\n    function getController() public view returns (address) {\n        return address(controller);\n    }\n\n    /**\n     * @dev Returns IBridgeMinterToken interface\n     */\n    function livepeerToken() private view returns (IBridgeMinterToken) {\n        return IBridgeMinterToken(controller.getContract(keccak256(\"LivepeerToken\")));\n    }\n}"
    }
  ]
}