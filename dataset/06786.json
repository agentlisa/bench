{
  "Title": "[M-06] `PartyGovernanceNFT.sol`: burn function does not reduce `totalVotingPower` making it impossible to reach unanimous votes",
  "Content": "\nWith the new version of the Party protocol the [`PartyGovernanceNFT.burn`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernanceNFT.sol#L201-L224) function has been introduced.\n\nThis function is used to burn party cards.\n\nAccording to the sponsor the initial purpose of this function was to enable the [`InitialETHCrowdfund`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol) contract (the `burn` function is needed for refunds).\n\nLater on they decided to allow any user to call this function and to burn their party cards.\n\nThe second use case when a regular user burns his party card is when the issue occurs.\n\nThe `PartyGovernanceNFT.burn` function does not decrease `totalVotingPower` which makes it impossible to reach an unanimous vote after a call to this function and it makes remaining votes of existing users less valuable than they should be.\n\n### Proof of Concept\n\nLet's look at the `PartyGovernanceNFT.burn` function:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernanceNFT.sol#L201-L224)\n\n```solidity\nfunction burn(uint256 tokenId) external onlyDelegateCall {\n    address owner = ownerOf(tokenId);\n    if (\n        msg.sender != owner &&\n        getApproved[tokenId] != msg.sender &&\n        !isApprovedForAll[owner][msg.sender]\n    ) {\n        // Allow minter to burn cards if the total voting power has not yet\n        // been set (e.g. for initial crowdfunds) meaning the party has not\n        // yet started.\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\n        if (totalVotingPower != 0 || !isAuthority[msg.sender]) {\n            revert UnauthorizedToBurnError();\n        }\n    }\n\n\n    uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();\n    mintedVotingPower -= votingPower;\n    delete votingPowerByTokenId[tokenId];\n\n\n    _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));\n\n\n    _burn(tokenId);\n}\n```\n\nIt burns the party card specified by the `tokenId` parameter and makes the appropriate changes to the voting power of the owner (by calling `_adjustVotingPower`) and to `mintedVotingPower`.\n\nBut it does not reduce `totalVotingPower` which remains untouched by this function.\n\nIn case this function is called by `InitialETHCrowdfund` it is intended that `totalVotingPower` is not reduced. In this case the `burn` function is only called when the initial crowdfund is lost and `totalVotingPower` hasn't even been increased so it is still `0` (the initial value).\n\nBut why is it an issue when a regular user calls this function?\n\nLet's consider the following scenario:\n\n    Alice: 100 Votes\n    Bob: 100 Votes\n    Chris: 100 Votes\n\n    totalVotingPower = 300 Votes\n\nNow Alice decides to burn half of her voting power:\n\n    Alice: 50 Votes\n    Bob: 100 Votes\n    Chris: 100 Votes\n\n    totalVotingPower = 300 Votes\n\nNow it is easy to see why it is a problem that `totalVotingPower` is not reduced.\n\nIt is impossible to reach an unanimous vote because even if all users vote there is only a `(250/300) = ~83%` agreement.\n\nOne vote only represents `1/300 = ~ 0.33%` of all votes even though it should represent `1/250 = 0.4%` of all votes. And thereby votes are less valuable than they should be.\n\nYou can see in the following test that `totalVotingPower` stays unaffected even though `voter1` burns his party card which represents a third of all votes.\n\n(Add the test to the `PartyGovernanceNFTUnit.sol` test file and add this import: `import \"../../contracts/party/PartyGovernance.sol\";` to access the `GovernanceValues` struct ).\n\n```solidity\nfunction test_canntReachUnanimousVoteAfterBurning() external {\n    _initGovernance();\n    address voter1 = _randomAddress();\n    address voter2 = _randomAddress();\n    address voter3 = _randomAddress();\n    uint256 vp = defaultGovernanceOpts.totalVotingPower / 3;\n    uint256 token1 = nft.mint(voter1, vp, voter1);\n    uint256 token2 = nft.mint(voter2, vp, voter2);\n    uint256 token3 = nft.mint(voter3, vp, voter3);\n\n    assertEq(nft.mintedVotingPower(), vp*3);\n    assertEq(nft.getCurrentVotingPower(voter1), vp);\n\n    PartyGovernance.GovernanceValues memory gv = nft.getGovernanceValues();\n    console.log(gv.totalVotingPower);\n\n    vm.prank(voter1);\n    nft.burn(token1);\n    gv = nft.getGovernanceValues();\n    // totalVotingPower stays the same\n    console.log(gv.totalVotingPower);\n}\n```\n\nThe remaining two voters will not be able to reach unanimous vote since the `_isUnanimousVotes` function is called with `totalVotingPower` as the total votes with which to calculate the percentage.\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L988)\n\n```solidity\nif (_isUnanimousVotes(pv.votes, _governanceValues.totalVotingPower)) {\n```\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L1024)\n\n```solidity\nif (_isUnanimousVotes(pv.votes, gv.totalVotingPower)) {\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nIt is important to understand that when `InitialETHCrowdfund` calls the `burn` function it is intended that `totalVotingPower` is not reduced.\n\nSo we need to differentiate these two cases.\n\nFix:\n\n```diff\ndiff --git a/contracts/party/PartyGovernanceNFT.sol b/contracts/party/PartyGovernanceNFT.sol\nindex 9ccfa1f..d382d0e 100644\n--- a/contracts/party/PartyGovernanceNFT.sol\n+++ b/contracts/party/PartyGovernanceNFT.sol\n@@ -200,6 +200,7 @@ contract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\n     /// @param tokenId The ID of the NFT to burn.\n     function burn(uint256 tokenId) external onlyDelegateCall {\n         address owner = ownerOf(tokenId);\n+        uint96 totalVotingPower = _governanceValues.totalVotingPower;\n         if (\n             msg.sender != owner &&\n             getApproved[tokenId] != msg.sender &&\n@@ -208,7 +209,6 @@ contract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\n             // Allow minter to burn cards if the total voting power has not yet\n             // been set (e.g. for initial crowdfunds) meaning the party has not\n             // yet started.\n-            uint96 totalVotingPower = _governanceValues.totalVotingPower;\n             if (totalVotingPower != 0 || !isAuthority[msg.sender]) {\n                 revert UnauthorizedToBurnError();\n             }\n@@ -218,6 +218,10 @@ contract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\n         mintedVotingPower -= votingPower;\n         delete votingPowerByTokenId[tokenId];\n \n+        if (totalVotingPower != 0 || !isAuthority[msg.sender]) {\n+            _governanceValues.totalVotingPower = totalVotingPower - votingPower;\n+        }\n+\n         _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));\n \n         _burn(tokenId);\n```\n\nAlso note that the `|| !isAuthority[msg.sender]` part of the condition is important.\n\nIt ensures that if we are not yet in the governance phase, i.e. `totalVotingPower == 0` and a user calls the `burn` function he cannot burn his party card. This is because the `totalVotingPower - votingPower` subtraction results in an underflow.\n\nThis ensures that in the pre-governance phase a user cannot accidentally burn his party card. He can only burn it via the `InitialETHCrowdfund` contract which ensures the user gets his ETH refund.\n\n**[0xble (Party) commented](https://github.com/code-423n4/2023-04-party-findings/issues/10#issuecomment-1512060843):**\n > @HollaDieWaldfee - I like the recommended mitigation. Had a question, if there were snapshots of `totalVotingPower` for each proposal is it fine that those are not updated? It is the same as if that an inactive user did not vote on a proposal, which can happen already. My concerns with updating it is that it seems like a riskier mitigation to implement that may cause unintended side-effects (if not now, later down the line). I also don't want to add more storage to the contract to fix this (it is already at with the contract size limit with `--via-ir` enabled).\n\n**[HollaDieWaldfee (warden) commented](https://github.com/code-423n4/2023-04-party-findings/issues/10#issuecomment-1512065324):**\n > @0xble - Yes I think it is ok to not update the snapshots. I have the same reasoning as you that it's basically just an inactive user.\n> \n> And I agree that updating instead is wrong because it gives remaining users higher voting power.\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-04-party-findings/issues/10#issuecomment-1512082911)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-party",
  "Code": [
    {
      "filename": "contracts/party/PartyGovernanceNFT.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../utils/ReadOnlyDelegateCall.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../vendor/solmate/ERC721.sol\";\nimport \"./PartyGovernance.sol\";\nimport \"../renderers/RendererStorage.sol\";\n\n/// @notice ERC721 functionality built on top of `PartyGovernance`.\ncontract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\n    using LibSafeCast for uint256;\n    using LibSafeCast for uint96;\n\n    error OnlyAuthorityError();\n    error OnlySelfError();\n    error UnauthorizedToBurnError();\n\n    event AuthorityAdded(address indexed authority);\n    event AuthorityRemoved(address indexed authority);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice Address with authority to mint cards and update voting power for the party.\n    mapping(address => bool) public isAuthority;\n    /// @notice The number of tokens that have been minted.\n    uint96 public tokenCount;\n    /// @notice The total minted voting power.\n    ///         Capped to `_governanceValues.totalVotingPower` unless minting\n    ///         party cards for initial crowdfund.\n    uint96 public mintedVotingPower;\n    /// @notice The voting power of `tokenId`.\n    mapping(uint256 => uint256) public votingPowerByTokenId;\n\n    modifier onlyAuthority() {\n        if (!isAuthority[msg.sender]) {\n            revert OnlyAuthorityError();\n        }\n        _;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) {\n            revert OnlySelfError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract. The name of symbol of ERC721 does not matter;\n    // it will be set in `_initialize()`.\n    constructor(IGlobals globals) PartyGovernance(globals) ERC721(\"\", \"\") {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts.\n    function _initialize(\n        string memory name_,\n        string memory symbol_,\n        uint256 customizationPresetId,\n        PartyGovernance.GovernanceOpts memory governanceOpts,\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        address[] memory authorities\n    ) internal {\n        PartyGovernance._initialize(\n            governanceOpts,\n            proposalEngineOpts,\n            preciousTokens,\n            preciousTokenIds\n        );\n        name = name_;\n        symbol = symbol_;\n        for (uint256 i; i < authorities.length; ++i) {\n            isAuthority[authorities[i]] = true;\n        }\n        if (customizationPresetId != 0) {\n            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))\n                .useCustomizationPreset(customizationPresetId);\n        }\n    }\n\n    /// @inheritdoc ERC721\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(ERC721, ITokenDistributorParty) returns (address owner) {\n        return ERC721.ownerOf(tokenId);\n    }\n\n    /// @inheritdoc EIP165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public pure override(PartyGovernance, ERC721, IERC165) returns (bool) {\n        return\n            PartyGovernance.supportsInterface(interfaceId) ||\n            ERC721.supportsInterface(interfaceId) ||\n            interfaceId == type(IERC2981).interfaceId;\n    }\n\n    /// @inheritdoc ERC721\n    function tokenURI(uint256) public view override returns (string memory) {\n        _delegateToRenderer();\n        return \"\"; // Just to make the compiler happy.\n    }\n\n    /// @notice Returns a URI for the storefront-level metadata for your contract.\n    function contractURI() external view returns (string memory) {\n        _delegateToRenderer();\n        return \"\"; // Just to make the compiler happy.\n    }\n\n    /// @notice Called with the sale price to determine how much royalty\n    //          is owed and to whom.\n    function royaltyInfo(uint256, uint256) external view returns (address, uint256) {\n        _delegateToRenderer();\n        return (address(0), 0); // Just to make the compiler happy.\n    }\n\n    /// @inheritdoc ITokenDistributorParty\n    function getDistributionShareOf(uint256 tokenId) external view returns (uint256) {\n        return (votingPowerByTokenId[tokenId] * 1e18) / _getTotalVotingPower();\n    }\n\n    /// @notice Mint a governance NFT for `owner` with `votingPower` and\n    ///         immediately delegate voting power to `delegate.` Only callable\n    ///         by an authority.\n    /// @param owner The owner of the NFT.\n    /// @param votingPower The voting power of the NFT.\n    /// @param delegate The address to delegate voting power to.\n    function mint(\n        address owner,\n        uint256 votingPower,\n        address delegate\n    ) external onlyAuthority onlyDelegateCall returns (uint256 tokenId) {\n        (uint96 tokenCount_, uint96 mintedVotingPower_) = (tokenCount, mintedVotingPower);\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\n        // Cap voting power to remaining unminted voting power supply.\n        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();\n        // Allow minting past total voting power if minting party cards for\n        // initial crowdfund when there is no total voting power.\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {\n            votingPower_ = totalVotingPower - mintedVotingPower_;\n        }\n\n        // Update state.\n        tokenId = tokenCount = tokenCount_ + 1;\n        mintedVotingPower += votingPower_;\n        votingPowerByTokenId[tokenId] = votingPower_;\n\n        // Use delegate from party over the one set during crowdfund.\n        address delegate_ = delegationsByVoter[owner];\n        if (delegate_ != address(0)) {\n            delegate = delegate_;\n        }\n\n        _adjustVotingPower(owner, votingPower_.safeCastUint96ToInt192(), delegate);\n        _safeMint(owner, tokenId);\n    }\n\n    /// @notice Add voting power to an existing NFT. Only callable by an\n    ///         authority.\n    /// @param tokenId The ID of the NFT to add voting power to.\n    /// @param votingPower The amount of voting power to add.\n    function addVotingPower(\n        uint256 tokenId,\n        uint256 votingPower\n    ) external onlyAuthority onlyDelegateCall {\n        uint96 mintedVotingPower_ = mintedVotingPower;\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\n        // Cap voting power to remaining unminted voting power supply.\n        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();\n        // Allow minting past total voting power if minting party cards for\n        // initial crowdfund when there is no total voting power.\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {\n            votingPower_ = totalVotingPower - mintedVotingPower_;\n        }\n\n        // Update state.\n        mintedVotingPower += votingPower_;\n        votingPowerByTokenId[tokenId] += votingPower_;\n\n        _adjustVotingPower(ownerOf(tokenId), votingPower_.safeCastUint96ToInt192(), address(0));\n    }\n\n    /// @notice Update the total voting power of the party. Only callable by\n    ///         an authority.\n    /// @param newVotingPower The new total voting power to add.\n    function increaseTotalVotingPower(\n        uint96 newVotingPower\n    ) external onlyAuthority onlyDelegateCall {\n        _governanceValues.totalVotingPower += newVotingPower;\n    }\n\n    /// @notice Burn a NFT and remove its voting power.\n    /// @param tokenId The ID of the NFT to burn.\n    function burn(uint256 tokenId) external onlyDelegateCall {\n        address owner = ownerOf(tokenId);\n        if (\n            msg.sender != owner &&\n            getApproved[tokenId] != msg.sender &&\n            !isApprovedForAll[owner][msg.sender]\n        ) {\n            // Allow minter to burn cards if the total voting power has not yet\n            // been set (e.g. for initial crowdfunds) meaning the party has not\n            // yet started.\n            uint96 totalVotingPower = _governanceValues.totalVotingPower;\n            if (totalVotingPower != 0 || !isAuthority[msg.sender]) {\n                revert UnauthorizedToBurnError();\n            }\n        }\n\n        uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();\n        mintedVotingPower -= votingPower;\n        delete votingPowerByTokenId[tokenId];\n\n        _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));\n\n        _burn(tokenId);\n    }\n\n    /// @inheritdoc ERC721\n    function transferFrom(\n        address owner,\n        address to,\n        uint256 tokenId\n    ) public override onlyDelegateCall {\n        // Transfer voting along with token.\n        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);\n        super.transferFrom(owner, to, tokenId);\n    }\n\n    /// @inheritdoc ERC721\n    function safeTransferFrom(\n        address owner,\n        address to,\n        uint256 tokenId\n    ) public override onlyDelegateCall {\n        // super.safeTransferFrom() will call transferFrom() first which will\n        // transfer voting power.\n        super.safeTransferFrom(owner, to, tokenId);\n    }\n\n    /// @inheritdoc ERC721\n    function safeTransferFrom(\n        address owner,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override onlyDelegateCall {\n        // super.safeTransferFrom() will call transferFrom() first which will\n        // transfer voting power.\n        super.safeTransferFrom(owner, to, tokenId, data);\n    }\n\n    /// @notice Add a new authority.\n    /// @dev Used in `AddAuthorityProposal`. Only the party itself can add\n    ///      authorities to prevent it from being used anywhere else.\n    function addAuthority(address authority) external onlySelf onlyDelegateCall {\n        isAuthority[authority] = true;\n\n        emit AuthorityAdded(authority);\n    }\n\n    /// @notice Relinquish the authority role.\n    function abdicateAuthority() external onlyAuthority onlyDelegateCall {\n        delete isAuthority[msg.sender];\n\n        emit AuthorityRemoved(msg.sender);\n    }\n\n    function _delegateToRenderer() private view {\n        _readOnlyDelegateCall(\n            // Instance of IERC721Renderer.\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_GOVERNANCE_NFT_RENDER_IMPL),\n            msg.data\n        );\n        assert(false); // Will not be reached.\n    }\n}"
    },
    {
      "filename": "contracts/party/PartyGovernanceNFT.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../utils/ReadOnlyDelegateCall.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../vendor/solmate/ERC721.sol\";\nimport \"./PartyGovernance.sol\";\nimport \"../renderers/RendererStorage.sol\";\n\n/// @notice ERC721 functionality built on top of `PartyGovernance`.\ncontract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\n    using LibSafeCast for uint256;\n    using LibSafeCast for uint96;\n\n    error OnlyAuthorityError();\n    error OnlySelfError();\n    error UnauthorizedToBurnError();\n\n    event AuthorityAdded(address indexed authority);\n    event AuthorityRemoved(address indexed authority);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice Address with authority to mint cards and update voting power for the party.\n    mapping(address => bool) public isAuthority;\n    /// @notice The number of tokens that have been minted.\n    uint96 public tokenCount;\n    /// @notice The total minted voting power.\n    ///         Capped to `_governanceValues.totalVotingPower` unless minting\n    ///         party cards for initial crowdfund.\n    uint96 public mintedVotingPower;\n    /// @notice The voting power of `tokenId`.\n    mapping(uint256 => uint256) public votingPowerByTokenId;\n\n    modifier onlyAuthority() {\n        if (!isAuthority[msg.sender]) {\n            revert OnlyAuthorityError();\n        }\n        _;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) {\n            revert OnlySelfError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract. The name of symbol of ERC721 does not matter;\n    // it will be set in `_initialize()`.\n    constructor(IGlobals globals) PartyGovernance(globals) ERC721(\"\", \"\") {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts.\n    function _initialize(\n        string memory name_,\n        string memory symbol_,\n        uint256 customizationPresetId,\n        PartyGovernance.GovernanceOpts memory governanceOpts,\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        address[] memory authorities\n    ) internal {\n        PartyGovernance._initialize(\n            governanceOpts,\n            proposalEngineOpts,\n            preciousTokens,\n            preciousTokenIds\n        );\n        name = name_;\n        symbol = symbol_;\n        for (uint256 i; i < authorities.length; ++i) {\n            isAuthority[authorities[i]] = true;\n        }\n        if (customizationPresetId != 0) {\n            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))\n                .useCustomizationPreset(customizationPresetId);\n        }\n    }\n\n    /// @inheritdoc ERC721\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(ERC721, ITokenDistributorParty) returns (address owner) {\n        return ERC721.ownerOf(tokenId);\n    }\n\n    /// @inheritdoc EIP165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public pure override(PartyGovernance, ERC721, IERC165) returns (bool) {\n        return\n            PartyGovernance.supportsInterface(interfaceId) ||\n            ERC721.supportsInterface(interfaceId) ||\n            interfaceId == type(IERC2981).interfaceId;\n    }\n\n    /// @inheritdoc ERC721\n    function tokenURI(uint256) public view override returns (string memory) {\n        _delegateToRenderer();\n        return \"\"; // Just to make the compiler happy.\n    }\n\n    /// @notice Returns a URI for the storefront-level metadata for your contract.\n    function contractURI() external view returns (string memory) {\n        _delegateToRenderer();\n        return \"\"; // Just to make the compiler happy.\n    }\n\n    /// @notice Called with the sale price to determine how much royalty\n    //          is owed and to whom.\n    function royaltyInfo(uint256, uint256) external view returns (address, uint256) {\n        _delegateToRenderer();\n        return (address(0), 0); // Just to make the compiler happy.\n    }\n\n    /// @inheritdoc ITokenDistributorParty\n    function getDistributionShareOf(uint256 tokenId) external view returns (uint256) {\n        return (votingPowerByTokenId[tokenId] * 1e18) / _getTotalVotingPower();\n    }\n\n    /// @notice Mint a governance NFT for `owner` with `votingPower` and\n    ///         immediately delegate voting power to `delegate.` Only callable\n    ///         by an authority.\n    /// @param owner The owner of the NFT.\n    /// @param votingPower The voting power of the NFT.\n    /// @param delegate The address to delegate voting power to.\n    function mint(\n        address owner,\n        uint256 votingPower,\n        address delegate\n    ) external onlyAuthority onlyDelegateCall returns (uint256 tokenId) {\n        (uint96 tokenCount_, uint96 mintedVotingPower_) = (tokenCount, mintedVotingPower);\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\n        // Cap voting power to remaining unminted voting power supply.\n        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();\n        // Allow minting past total voting power if minting party cards for\n        // initial crowdfund when there is no total voting power.\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {\n            votingPower_ = totalVotingPower - mintedVotingPower_;\n        }\n\n        // Update state.\n        tokenId = tokenCount = tokenCount_ + 1;\n        mintedVotingPower += votingPower_;\n        votingPowerByTokenId[tokenId] = votingPower_;\n\n        // Use delegate from party over the one set during crowdfund.\n        address delegate_ = delegationsByVoter[owner];\n        if (delegate_ != address(0)) {\n            delegate = delegate_;\n        }\n\n        _adjustVotingPower(owner, votingPower_.safeCastUint96ToInt192(), delegate);\n        _safeMint(owner, tokenId);\n    }\n\n    /// @notice Add voting power to an existing NFT. Only callable by an\n    ///         authority.\n    /// @param tokenId The ID of the NFT to add voting power to.\n    /// @param votingPower The amount of voting power to add.\n    function addVotingPower(\n        uint256 tokenId,\n        uint256 votingPower\n    ) external onlyAuthority onlyDelegateCall {\n        uint96 mintedVotingPower_ = mintedVotingPower;\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\n        // Cap voting power to remaining unminted voting power supply.\n        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();\n        // Allow minting past total voting power if minting party cards for\n        // initial crowdfund when there is no total voting power.\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {\n            votingPower_ = totalVotingPower - mintedVotingPower_;\n        }\n\n        // Update state.\n        mintedVotingPower += votingPower_;\n        votingPowerByTokenId[tokenId] += votingPower_;\n\n        _adjustVotingPower(ownerOf(tokenId), votingPower_.safeCastUint96ToInt192(), address(0));\n    }\n\n    /// @notice Update the total voting power of the party. Only callable by\n    ///         an authority.\n    /// @param newVotingPower The new total voting power to add.\n    function increaseTotalVotingPower(\n        uint96 newVotingPower\n    ) external onlyAuthority onlyDelegateCall {\n        _governanceValues.totalVotingPower += newVotingPower;\n    }\n\n    /// @notice Burn a NFT and remove its voting power.\n    /// @param tokenId The ID of the NFT to burn.\n    function burn(uint256 tokenId) external onlyDelegateCall {\n        address owner = ownerOf(tokenId);\n        if (\n            msg.sender != owner &&\n            getApproved[tokenId] != msg.sender &&\n            !isApprovedForAll[owner][msg.sender]\n        ) {\n            // Allow minter to burn cards if the total voting power has not yet\n            // been set (e.g. for initial crowdfunds) meaning the party has not\n            // yet started.\n            uint96 totalVotingPower = _governanceValues.totalVotingPower;\n            if (totalVotingPower != 0 || !isAuthority[msg.sender]) {\n                revert UnauthorizedToBurnError();\n            }\n        }\n\n        uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();\n        mintedVotingPower -= votingPower;\n        delete votingPowerByTokenId[tokenId];\n\n        _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));\n\n        _burn(tokenId);\n    }\n\n    /// @inheritdoc ERC721\n    function transferFrom(\n        address owner,\n        address to,\n        uint256 tokenId\n    ) public override onlyDelegateCall {\n        // Transfer voting along with token.\n        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);\n        super.transferFrom(owner, to, tokenId);\n    }\n\n    /// @inheritdoc ERC721\n    function safeTransferFrom(\n        address owner,\n        address to,\n        uint256 tokenId\n    ) public override onlyDelegateCall {\n        // super.safeTransferFrom() will call transferFrom() first which will\n        // transfer voting power.\n        super.safeTransferFrom(owner, to, tokenId);\n    }\n\n    /// @inheritdoc ERC721\n    function safeTransferFrom(\n        address owner,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override onlyDelegateCall {\n        // super.safeTransferFrom() will call transferFrom() first which will\n        // transfer voting power.\n        super.safeTransferFrom(owner, to, tokenId, data);\n    }\n\n    /// @notice Add a new authority.\n    /// @dev Used in `AddAuthorityProposal`. Only the party itself can add\n    ///      authorities to prevent it from being used anywhere else.\n    function addAuthority(address authority) external onlySelf onlyDelegateCall {\n        isAuthority[authority] = true;\n\n        emit AuthorityAdded(authority);\n    }\n\n    /// @notice Relinquish the authority role.\n    function abdicateAuthority() external onlyAuthority onlyDelegateCall {\n        delete isAuthority[msg.sender];\n\n        emit AuthorityRemoved(msg.sender);\n    }\n\n    function _delegateToRenderer() private view {\n        _readOnlyDelegateCall(\n            // Instance of IERC721Renderer.\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_GOVERNANCE_NFT_RENDER_IMPL),\n            msg.data\n        );\n        assert(false); // Will not be reached.\n    }\n}"
    },
    {
      "filename": "contracts/party/PartyGovernance.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../distribution/ITokenDistributorParty.sol\";\nimport \"../distribution/ITokenDistributor.sol\";\nimport \"../utils/ReadOnlyDelegateCall.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../tokens/IERC20.sol\";\nimport \"../tokens/IERC1155.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../tokens/ERC1155Receiver.sol\";\nimport \"../utils/LibERC20Compat.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../proposals/IProposalExecutionEngine.sol\";\nimport \"../proposals/LibProposal.sol\";\nimport \"../proposals/ProposalStorage.sol\";\n\nimport \"./IPartyFactory.sol\";\n\n/// @notice Base contract for a Party encapsulating all governance functionality.\nabstract contract PartyGovernance is\n    ITokenDistributorParty,\n    ERC721Receiver,\n    ERC1155Receiver,\n    ProposalStorage,\n    Implementation,\n    ReadOnlyDelegateCall\n{\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibSafeCast for int192;\n    using LibSafeCast for uint96;\n\n    // States a proposal can be in.\n    enum ProposalStatus {\n        // The proposal does not exist.\n        Invalid,\n        // The proposal has been proposed (via `propose()`), has not been vetoed\n        // by a party host, and is within the voting window. Members can vote on\n        // the proposal and party hosts can veto the proposal.\n        Voting,\n        // The proposal has either exceeded its voting window without reaching\n        // `passThresholdBps` of votes or was vetoed by a party host.\n        Defeated,\n        // The proposal reached at least `passThresholdBps` of votes but is still\n        // waiting for `executionDelay` to pass before it can be executed. Members\n        // can continue to vote on the proposal and party hosts can veto at this time.\n        Passed,\n        // Same as `Passed` but now `executionDelay` has been satisfied. Any member\n        // may execute the proposal via `execute()`, unless `maxExecutableTime`\n        // has arrived.\n        Ready,\n        // The proposal has been executed at least once but has further steps to\n        // complete so it needs to be executed again. No other proposals may be\n        // executed while a proposal is in the `InProgress` state. No voting or\n        // vetoing of the proposal is allowed, however it may be forcibly cancelled\n        // via `cancel()` if the `cancelDelay` has passed since being first executed.\n        InProgress,\n        // The proposal was executed and completed all its steps. No voting or\n        // vetoing can occur and it cannot be cancelled nor executed again.\n        Complete,\n        // The proposal was executed at least once but did not complete before\n        // `cancelDelay` seconds passed since the first execute and was forcibly cancelled.\n        Cancelled\n    }\n\n    struct GovernanceOpts {\n        // Address of initial party hosts.\n        address[] hosts;\n        // How long people can vote on a proposal.\n        uint40 voteDuration;\n        // How long to wait after a proposal passes before it can be\n        // executed.\n        uint40 executionDelay;\n        // Minimum ratio of accept votes to consider a proposal passed,\n        // in bps, where 10,000 == 100%.\n        uint16 passThresholdBps;\n        // Total voting power of governance NFTs.\n        uint96 totalVotingPower;\n        // Fee bps for distributions.\n        uint16 feeBps;\n        // Fee recipeint for distributions.\n        address payable feeRecipient;\n    }\n\n    // Subset of `GovernanceOpts` that are commonly read together for\n    // efficiency.\n    struct GovernanceValues {\n        uint40 voteDuration;\n        uint40 executionDelay;\n        uint16 passThresholdBps;\n        uint96 totalVotingPower;\n    }\n\n    // A snapshot of voting power for a member.\n    struct VotingPowerSnapshot {\n        // The timestamp when the snapshot was taken.\n        uint40 timestamp;\n        // Voting power that was delegated to this user by others.\n        uint96 delegatedVotingPower;\n        // The intrinsic (not delegated from someone else) voting power of this user.\n        uint96 intrinsicVotingPower;\n        // Whether the user was delegated to another at this snapshot.\n        bool isDelegated;\n    }\n\n    // Proposal details chosen by proposer.\n    struct Proposal {\n        // Time beyond which the proposal can no longer be executed.\n        // If the proposal has already been executed, and is still InProgress,\n        // this value is ignored.\n        uint40 maxExecutableTime;\n        // The minimum seconds this proposal can remain in the InProgress status\n        // before it can be cancelled.\n        uint40 cancelDelay;\n        // Encoded proposal data. The first 4 bytes are the proposal type, followed\n        // by encoded proposal args specific to the proposal type. See\n        // ProposalExecutionEngine for details.\n        bytes proposalData;\n    }\n\n    // Accounting and state tracking values for a proposal.\n    // Fits in a word.\n    struct ProposalStateValues {\n        // When the proposal was proposed.\n        uint40 proposedTime;\n        // When the proposal passed the vote.\n        uint40 passedTime;\n        // When the proposal was first executed.\n        uint40 executedTime;\n        // When the proposal completed.\n        uint40 completedTime;\n        // Number of accept votes.\n        uint96 votes; // -1 == vetoed\n    }\n\n    // Storage states for a proposal.\n    struct ProposalState {\n        // Accounting and state tracking values.\n        ProposalStateValues values;\n        // Hash of the proposal.\n        bytes32 hash;\n        // Whether a member has voted for (accepted) this proposal already.\n        mapping(address => bool) hasVoted;\n    }\n\n    event Proposed(uint256 proposalId, address proposer, Proposal proposal);\n    event ProposalAccepted(uint256 proposalId, address voter, uint256 weight);\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\n\n    event ProposalPassed(uint256 indexed proposalId);\n    event ProposalVetoed(uint256 indexed proposalId, address host);\n    event ProposalExecuted(uint256 indexed proposalId, address executor, bytes nextProgressData);\n    event ProposalCancelled(uint256 indexed proposalId);\n    event DistributionCreated(\n        ITokenDistributor.TokenType tokenType,\n        address token,\n        uint256 tokenId\n    );\n    event VotingPowerDelegated(address indexed owner, address indexed delegate);\n    event HostStatusTransferred(address oldHost, address newHost);\n    event EmergencyExecuteDisabled();\n\n    error MismatchedPreciousListLengths();\n    error BadProposalStatusError(ProposalStatus status);\n    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);\n    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);\n    error OnlyPartyHostError();\n    error OnlyActiveMemberError();\n    error InvalidDelegateError();\n    error BadPreciousListError();\n    error OnlyPartyDaoError(address notDao, address partyDao);\n    error OnlyPartyDaoOrHostError(address notDao, address partyDao);\n    error OnlyWhenEmergencyActionsAllowedError();\n    error OnlyWhenEnabledError();\n    error AlreadyVotedError(address voter);\n    error InvalidNewHostError();\n    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);\n    error InvalidBpsError(uint16 bps);\n    error DistributionsRequireVoteError();\n    error PartyNotStartedError();\n\n    uint256 private constant UINT40_HIGH_BIT = 1 << 39;\n    uint96 private constant VETO_VALUE = type(uint96).max;\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice Whether the DAO has emergency powers for this party.\n    bool public emergencyExecuteDisabled;\n    /// @notice Distribution fee bps.\n    uint16 public feeBps;\n    /// @notice Distribution fee recipient.\n    address payable public feeRecipient;\n    /// @notice The hash of the list of precious NFTs guarded by the party.\n    bytes32 public preciousListHash;\n    /// @notice The last proposal ID that was used. 0 means no proposals have been made.\n    uint256 public lastProposalId;\n    /// @notice Whether an address is a party host.\n    mapping(address => bool) public isHost;\n    /// @notice The last person a voter delegated its voting power to.\n    mapping(address => address) public delegationsByVoter;\n    // Governance parameters for this party.\n    GovernanceValues internal _governanceValues;\n    // ProposalState by proposal ID.\n    mapping(uint256 => ProposalState) private _proposalStateByProposalId;\n    // Snapshots of voting power per user, each sorted by increasing time.\n    mapping(address => VotingPowerSnapshot[]) private _votingPowerSnapshotsByVoter;\n\n    modifier onlyHost() {\n        if (!isHost[msg.sender]) {\n            revert OnlyPartyHostError();\n        }\n        _;\n    }\n\n    // Caller must have voting power at the current time.\n    modifier onlyActiveMember() {\n        {\n            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);\n            // Must have either delegated voting power or intrinsic voting power.\n            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\n                revert OnlyActiveMemberError();\n            }\n        }\n        _;\n    }\n\n    // Only the party DAO multisig can call.\n    modifier onlyPartyDao() {\n        {\n            address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n            if (msg.sender != partyDao) {\n                revert OnlyPartyDaoError(msg.sender, partyDao);\n            }\n        }\n        _;\n    }\n\n    // Only the party DAO multisig or a party host can call.\n    modifier onlyPartyDaoOrHost() {\n        address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n        if (msg.sender != partyDao && !isHost[msg.sender]) {\n            revert OnlyPartyDaoOrHostError(msg.sender, partyDao);\n        }\n        _;\n    }\n\n    // Only if `emergencyExecuteDisabled` is not true.\n    modifier onlyWhenEmergencyExecuteAllowed() {\n        if (emergencyExecuteDisabled) {\n            revert OnlyWhenEmergencyActionsAllowedError();\n        }\n        _;\n    }\n\n    modifier onlyWhenNotGloballyDisabled() {\n        if (_GLOBALS.getBool(LibGlobals.GLOBAL_DISABLE_PARTY_ACTIONS)) {\n            revert OnlyWhenEnabledError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts and initialize the proposal execution engine.\n    function _initialize(\n        GovernanceOpts memory govOpts,\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    ) internal virtual {\n        // Check BPS are valid.\n        if (govOpts.feeBps > 1e4) {\n            revert InvalidBpsError(govOpts.feeBps);\n        }\n        if (govOpts.passThresholdBps > 1e4) {\n            revert InvalidBpsError(govOpts.passThresholdBps);\n        }\n        // Initialize the propos"
    }
  ]
}