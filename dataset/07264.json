{
  "Title": "[H-18] `PublicVault.processEpoch` calculates `withdrawReserve` incorrectly; Users can lose funds",
  "Content": "\nPublicVault.processEpoch calculates withdrawReserve incorrectly. As result user can receive less funds when totalAssets() <= expected from auction.\n\n### Proof of Concept\n\nWhen users wants to withdraw from `PublicVault` then `WithdrawProxy` is deployed and `PublicVault.processEpoch` function is responsible to calculate `s.withdrawReserve`.\nThis amount depends on how many shares should be redeemed and if there is auction for the epoch.\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L275-L343>\n\n    solidity\n      function processEpoch() public {\n        // check to make sure epoch is over\n        if (timeToEpochEnd() > 0) {\n          revert InvalidState(InvalidStates.EPOCH_NOT_OVER);\n        }\n        VaultData storage s = _loadStorageSlot();\n\n\n        if (s.withdrawReserve > 0) {\n          revert InvalidState(InvalidStates.WITHDRAW_RESERVE_NOT_ZERO);\n        }\n\n\n        WithdrawProxy currentWithdrawProxy = WithdrawProxy(\n          s.epochData[s.currentEpoch].withdrawProxy\n        );\n\n\n        // split funds from previous WithdrawProxy with PublicVault if hasn't been already\n        if (s.currentEpoch != 0) {\n          WithdrawProxy previousWithdrawProxy = WithdrawProxy(\n            s.epochData[s.currentEpoch - 1].withdrawProxy\n          );\n          if (\n            address(previousWithdrawProxy) != address(0) &&\n            previousWithdrawProxy.getFinalAuctionEnd() != 0\n          ) {\n            previousWithdrawProxy.claim();\n          }\n        }\n\n\n        if (s.epochData[s.currentEpoch].liensOpenForEpoch > 0) {\n          revert InvalidState(InvalidStates.LIENS_OPEN_FOR_EPOCH_NOT_ZERO);\n        }\n\n\n        // reset liquidationWithdrawRatio to prepare for re calcualtion\n        s.liquidationWithdrawRatio = 0;\n\n\n        // check if there are LPs withdrawing this epoch\n        if ((address(currentWithdrawProxy) != address(0))) {\n          uint256 proxySupply = currentWithdrawProxy.totalSupply();\n\n\n          s.liquidationWithdrawRatio = proxySupply\n            .mulDivDown(1e18, totalSupply())\n            .safeCastTo88();\n\n\n          currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio);\n          uint256 expected = currentWithdrawProxy.getExpected();\n\n\n          unchecked {\n            if (totalAssets() > expected) {\n              s.withdrawReserve = (totalAssets() - expected)\n                .mulWadDown(s.liquidationWithdrawRatio)\n                .safeCastTo88();\n            } else {\n              s.withdrawReserve = 0;\n            }\n          }\n          _setYIntercept(\n            s,\n            s.yIntercept -\n              totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)\n          );\n          // burn the tokens of the LPs withdrawing\n          _burn(address(this), proxySupply);\n        }\n\n\n        // increment epoch\n        unchecked {\n          s.currentEpoch++;\n        }\n      }\n\n`  s.liquidationWithdrawRatio ` depends on how many shares exists inside WithdrawProxy. In case if amount of shares inside `WithdrawProxy` equal to amount of shares inside `PublicVault` that means that withdraw ratio is 100% and all funds from Vault should be sent to `WithdrawProxy`.\n\nIn case if auction is in progress then `WithdrawProxy.getExpected` is not 0 and some amount of funds is expected from auction.\n\n```solidity\nunchecked {\n        if (totalAssets() > expected) {\n          s.withdrawReserve = (totalAssets() - expected)\n            .mulWadDown(s.liquidationWithdrawRatio)\n            .safeCastTo88();\n        } else {\n          s.withdrawReserve = 0;\n        }\n      }\n```\n\nThis is `s.withdrawReserve` calculation. As you can see in case if `totalAssets() <= expected` then `s.withdrawReserve` is set to 0 and no funds will be sent to proxy. This is incorrect though.\n\nFor example in the case when withdraw ratio is 100% all funds should be sent to the withdraw proxy, but because of that check, some part of funds will be still inside the vault and depositors will lose their funds. If for example totalAssets is 5eth and expected is 5 eth, then depositors will lose all 5 eth.\n\nThis check is done in such way, because of [calculations inside `WithdrawProxy`](https://github.com/code-423n4/2023-01-astaria/blob/main/src/WithdrawProxy.sol#L258-L266). But it's not correct.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nYou need to check this logic again. Maybe you need to always send `s.withdrawReserve = totalAssets().mulWadDown(s.liquidationWithdrawRatio).safeCastTo88()` amount to the withdraw proxy. But then you need to rethink, how WithdrawProxy will handle yIntercept increase/decrease.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/PublicVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {ERC4626Cloned} from \"gpl/ERC4626-Cloned.sol\";\nimport {IERC4626} from \"core/interfaces/IERC4626.sol\";\nimport {IERC20} from \"core/interfaces/IERC20.sol\";\nimport {IERC20Metadata} from \"core/interfaces/IERC20Metadata.sol\";\nimport {ERC20Cloned} from \"gpl/ERC20-Cloned.sol\";\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\n\nimport {VaultImplementation} from \"core/VaultImplementation.sol\";\nimport {WithdrawProxy} from \"core/WithdrawProxy.sol\";\n\nimport {Math} from \"core/utils/Math.sol\";\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {IAstariaVaultBase} from \"core/interfaces/IAstariaVaultBase.sol\";\nimport {AstariaVaultBase} from \"core/AstariaVaultBase.sol\";\n\n/*\n * @title PublicVault\n * @author androolloyd\n * @notice\n */\ncontract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n  using FixedPointMathLib for uint256;\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n\n  uint256 private constant PUBLIC_VAULT_SLOT =\n    uint256(keccak256(\"xyz.astaria.PublicVault.storage.location\")) - 1;\n\n  function asset()\n    public\n    pure\n    virtual\n    override(IAstariaVaultBase, AstariaVaultBase, ERC4626Cloned)\n    returns (address)\n  {\n    return super.asset();\n  }\n\n  function decimals()\n    public\n    pure\n    virtual\n    override(IERC20Metadata)\n    returns (uint8)\n  {\n    return 18;\n  }\n\n  function name()\n    public\n    view\n    virtual\n    override(IERC20Metadata, VaultImplementation)\n    returns (string memory)\n  {\n    return string(abi.encodePacked(\"AST-Vault-\", ERC20(asset()).symbol()));\n  }\n\n  function symbol()\n    public\n    view\n    virtual\n    override(IERC20Metadata, VaultImplementation)\n    returns (string memory)\n  {\n    return string(abi.encodePacked(\"AST-V-\", ERC20(asset()).symbol()));\n  }\n\n  function minDepositAmount()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n  {\n    if (ERC20(asset()).decimals() == uint8(18)) {\n      return 100 gwei;\n    } else {\n      return 10**(ERC20(asset()).decimals() - 1);\n    }\n  }\n\n  /**\n   * @notice Signal a withdrawal of funds (redeeming for underlying asset) in the next epoch.\n   * @param shares The number of VaultToken shares to redeem.\n   * @param receiver The receiver of the WithdrawTokens (and eventual underlying asset)\n   * @param owner The owner of the VaultTokens.\n   * @return assets The amount of the underlying asset redeemed.\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public virtual override(ERC4626Cloned) returns (uint256 assets) {\n    VaultData storage s = _loadStorageSlot();\n    assets = _redeemFutureEpoch(s, shares, receiver, owner, s.currentEpoch);\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) public virtual override(ERC4626Cloned) returns (uint256 shares) {\n    shares = previewWithdraw(assets);\n\n    VaultData storage s = _loadStorageSlot();\n\n    _redeemFutureEpoch(s, shares, receiver, owner, s.currentEpoch);\n  }\n\n  function redeemFutureEpoch(\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n  ) public virtual returns (uint256 assets) {\n    return\n      _redeemFutureEpoch(_loadStorageSlot(), shares, receiver, owner, epoch);\n  }\n\n  function _redeemFutureEpoch(\n    VaultData storage s,\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n  ) internal virtual returns (uint256 assets) {\n    // check to ensure that the requested epoch is not in the past\n\n    ERC20Data storage es = _loadERC20Slot();\n\n    if (msg.sender != owner) {\n      uint256 allowed = es.allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        es.allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n\n    if (epoch < s.currentEpoch) {\n      revert InvalidState(InvalidStates.EPOCH_TOO_LOW);\n    }\n    require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n    // check for rounding error since we round down in previewRedeem.\n\n    //this will underflow if not enough balance\n    es.balanceOf[owner] -= shares;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      es.balanceOf[address(this)] += shares;\n    }\n\n    emit Transfer(owner, address(this), shares);\n    // Deploy WithdrawProxy if no WithdrawProxy exists for the specified epoch\n    _deployWithdrawProxyIfNotDeployed(s, epoch);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    // WithdrawProxy shares are minted 1:1 with PublicVault shares\n    WithdrawProxy(s.epochData[epoch].withdrawProxy).mint(shares, receiver);\n  }\n\n  function getWithdrawProxy(uint64 epoch) public view returns (WithdrawProxy) {\n    return WithdrawProxy(_loadStorageSlot().epochData[epoch].withdrawProxy);\n  }\n\n  function getCurrentEpoch() public view returns (uint64) {\n    return _loadStorageSlot().currentEpoch;\n  }\n\n  function getSlope() public view returns (uint256) {\n    return uint256(_loadStorageSlot().slope);\n  }\n\n  function getWithdrawReserve() public view returns (uint256) {\n    return uint256(_loadStorageSlot().withdrawReserve);\n  }\n\n  function getLiquidationWithdrawRatio() public view returns (uint256) {\n    return uint256(_loadStorageSlot().liquidationWithdrawRatio);\n  }\n\n  function getYIntercept() public view returns (uint256) {\n    return uint256(_loadStorageSlot().yIntercept);\n  }\n\n  function _deployWithdrawProxyIfNotDeployed(VaultData storage s, uint64 epoch)\n    internal\n  {\n    if (s.epochData[epoch].withdrawProxy == address(0)) {\n      s.epochData[epoch].withdrawProxy = ClonesWithImmutableArgs.clone(\n        IAstariaRouter(ROUTER()).BEACON_PROXY_IMPLEMENTATION(),\n        abi.encodePacked(\n          address(ROUTER()), // router is the beacon\n          uint8(IAstariaRouter.ImplementationType.WithdrawProxy),\n          asset(), // token\n          address(this), // vault\n          epoch + 1 // claimable epoch\n        )\n      );\n    }\n  }\n\n  function mint(uint256 shares, address receiver)\n    public\n    override(ERC4626Cloned)\n    whenNotPaused\n    returns (uint256)\n  {\n    VIData storage s = _loadVISlot();\n    if (s.allowListEnabled) {\n      require(s.allowList[receiver]);\n    }\n    return super.mint(shares, receiver);\n  }\n\n  /**\n   * @notice Deposit funds into the PublicVault.\n   * @param amount The amount of funds to deposit.\n   * @param receiver The receiver of the resulting VaultToken shares.\n   */\n  function deposit(uint256 amount, address receiver)\n    public\n    override(ERC4626Cloned)\n    whenNotPaused\n    returns (uint256)\n  {\n    VIData storage s = _loadVISlot();\n    if (s.allowListEnabled) {\n      require(s.allowList[receiver]);\n    }\n\n    uint256 assets = totalAssets();\n\n    return super.deposit(amount, receiver);\n  }\n\n  /**\n   * @notice Retrieve the domain separator.\n   * @return The domain separator.\n   */\n  function computeDomainSeparator() internal view override returns (bytes32) {\n    return super.domainSeparator();\n  }\n\n  function processEpoch() public {\n    // check to make sure epoch is over\n    if (timeToEpochEnd() > 0) {\n      revert InvalidState(InvalidStates.EPOCH_NOT_OVER);\n    }\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.withdrawReserve > 0) {\n      revert InvalidState(InvalidStates.WITHDRAW_RESERVE_NOT_ZERO);\n    }\n\n    WithdrawProxy currentWithdrawProxy = WithdrawProxy(\n      s.epochData[s.currentEpoch].withdrawProxy\n    );\n\n    // split funds from previous WithdrawProxy with PublicVault if hasn't been already\n    if (s.currentEpoch != 0) {\n      WithdrawProxy previousWithdrawProxy = WithdrawProxy(\n        s.epochData[s.currentEpoch - 1].withdrawProxy\n      );\n      if (\n        address(previousWithdrawProxy) != address(0) &&\n        previousWithdrawProxy.getFinalAuctionEnd() != 0\n      ) {\n        previousWithdrawProxy.claim();\n      }\n    }\n\n    if (s.epochData[s.currentEpoch].liensOpenForEpoch > 0) {\n      revert InvalidState(InvalidStates.LIENS_OPEN_FOR_EPOCH_NOT_ZERO);\n    }\n\n    // reset liquidationWithdrawRatio to prepare for re calcualtion\n    s.liquidationWithdrawRatio = 0;\n\n    // check if there are LPs withdrawing this epoch\n    if ((address(currentWithdrawProxy) != address(0))) {\n      uint256 proxySupply = currentWithdrawProxy.totalSupply();\n\n      s.liquidationWithdrawRatio = proxySupply\n        .mulDivDown(1e18, totalSupply())\n        .safeCastTo88();\n\n      currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio);\n      uint256 expected = currentWithdrawProxy.getExpected();\n\n      unchecked {\n        if (totalAssets() > expected) {\n          s.withdrawReserve = (totalAssets() - expected)\n            .mulWadDown(s.liquidationWithdrawRatio)\n            .safeCastTo88();\n        } else {\n          s.withdrawReserve = 0;\n        }\n      }\n      _setYIntercept(\n        s,\n        s.yIntercept -\n          totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)\n      );\n      // burn the tokens of the LPs withdrawing\n      _burn(address(this), proxySupply);\n    }\n\n    // increment epoch\n    unchecked {\n      s.currentEpoch++;\n    }\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    pure\n    override(IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(IPublicVault).interfaceId ||\n      interfaceId == type(ERC4626Cloned).interfaceId ||\n      interfaceId == type(ERC4626).interfaceId ||\n      interfaceId == type(ERC20).interfaceId ||\n      interfaceId == type(IERC165).interfaceId;\n  }\n\n  function transferWithdrawReserve() public {\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.currentEpoch == uint64(0)) {\n      return;\n    }\n\n    address currentWithdrawProxy = s\n      .epochData[s.currentEpoch - 1]\n      .withdrawProxy;\n    // prevents transfer to a non-existent WithdrawProxy\n    // withdrawProxies are indexed by the epoch where they're deployed\n    if (currentWithdrawProxy != address(0)) {\n      uint256 withdrawBalance = ERC20(asset()).balanceOf(address(this));\n\n      // prevent transfer of more assets then are available\n      if (s.withdrawReserve <= withdrawBalance) {\n        withdrawBalance = s.withdrawReserve;\n        s.withdrawReserve = 0;\n      } else {\n        unchecked {\n          s.withdrawReserve -= withdrawBalance.safeCastTo88();\n        }\n      }\n\n      ERC20(asset()).safeTransfer(currentWithdrawProxy, withdrawBalance);\n      WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(\n        withdrawBalance\n      );\n      emit WithdrawReserveTransferred(withdrawBalance);\n    }\n\n    address withdrawProxy = s.epochData[s.currentEpoch].withdrawProxy;\n    if (\n      s.withdrawReserve > 0 &&\n      timeToEpochEnd() == 0 &&\n      withdrawProxy != address(0)\n    ) {\n      address currentWithdrawProxy = s\n        .epochData[s.currentEpoch - 1]\n        .withdrawProxy;\n      uint256 drainBalance = WithdrawProxy(withdrawProxy).drain(\n        s.withdrawReserve,\n        s.epochData[s.currentEpoch - 1].withdrawProxy\n      );\n      unchecked {\n        s.withdrawReserve -= drainBalance.safeCastTo88();\n      }\n      WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(\n        drainBalance\n      );\n    }\n  }\n\n  function _beforeCommitToLien(IAstariaRouter.Commitment calldata params)\n    internal\n    virtual\n    override(VaultImplementation)\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.withdrawReserve > uint256(0)) {\n      transferWithdrawReserve();\n    }\n    if (timeToEpochEnd() == uint256(0)) {\n      processEpoch();\n    }\n  }\n\n  function _loadStorageSlot() internal pure returns (VaultData storage s) {\n    uint256 slot = PUBLIC_VAULT_SLOT;\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  /**\n   * @dev Hook for updating the slope of the PublicVault after a LienToken is issued.\n   * @param lienId The ID of the lien.\n   */\n  function _afterCommitToLien(\n    uint40 lienEnd,\n    uint256 lienId,\n    uint256 lienSlope\n  ) internal virtual override {\n    VaultData storage s = _loadStorageSlot();\n\n    // increment slope for the new lien\n    _accrue(s);\n    unchecked {\n      uint48 newSlope = s.slope + lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n    }\n\n    uint64 epoch = getLienEpoch(lienEnd);\n\n    _increaseOpenLiens(s, epoch);\n    emit LienOpen(lienId, epoch);\n  }\n\n  event SlopeUpdated(uint48 newSlope);\n\n  function accrue() public returns (uint256) {\n    return _accrue(_loadStorageSlot());\n  }\n\n  function _accrue(VaultData storage s) internal returns (uint256) {\n    unchecked {\n      s.yIntercept = (_totalAssets(s)).safeCastTo88();\n      s.last = block.timestamp.safeCastTo40();\n    }\n    emit YInterceptChanged(s.yIntercept);\n\n    return s.yIntercept;\n  }\n\n  /**\n   * @notice Computes the implied value of this PublicVault. This includes interest payments that have not yet been made.\n   * @return The implied value for this PublicVault.\n   */\n  function totalAssets()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n  {\n    VaultData storage s = _loadStorageSlot();\n    return _totalAssets(s);\n  }\n\n  function _totalAssets(VaultData storage s) internal view returns (uint256) {\n    uint256 delta_t = block.timestamp - s.last;\n    return uint256(s.slope).mulDivDown(delta_t, 1) + uint256(s.yIntercept);\n  }\n\n  function totalSupply()\n    public\n    view\n    virtual\n    override(IERC20, ERC20Cloned)\n    returns (uint256)\n  {\n    return\n      _loadERC20Slot()._totalSupply +\n      _loadStorageSlot().strategistUnclaimedShares;\n  }\n\n  function claim() external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    VaultData storage s = _loadStorageSlot();\n    uint256 unclaimed = s.strategistUnclaimedShares;\n    s.strategistUnclaimedShares = 0;\n    _mint(msg.sender, unclaimed);\n  }\n\n  function beforePayment(BeforePaymentParams calldata params)\n    external\n    onlyLienToken\n  {\n    VaultData storage s = _loadStorageSlot();\n    _accrue(s);\n\n    unchecked {\n      uint48 newSlope = s.slope - params.lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n    }\n    _handleStrategistInterestReward(s, params.interestOwed, params.amount);\n  }\n\n  function _setSlope(VaultData storage s, uint48 newSlope) internal {\n    s.slope = newSlope;\n    emit SlopeUpdated(newSlope);\n  }\n\n  function decreaseEpochLienCount(uint64 epoch) public onlyLienToken {\n    _decreaseEpochLienCount(_loadStorageSlot(), epoch);\n  }\n\n  function _decreaseEpochLienCount(VaultData storage s, uint64 epoch) internal {\n    s.epochData[epoch].liensOpenForEpoch--;\n    emit LiensOpenForEpochRemaining(\n      epoch,\n      s.epochData[epoch].liensOpenForEpoch\n    );\n  }\n\n  function getLienEpoch(uint64 end) public pure returns (uint64) {\n    return\n      uint256(Math.ceilDiv(end - uint64(START()), EPOCH_LENGTH()) - 1)\n        .safeCastTo64();\n  }\n\n  function getEpochEnd(uint256 epoch) public pure returns (uint64) {\n    return uint256(START() + (epoch + 1) * EPOCH_LENGTH()).safeCastTo64();\n  }\n\n  function _increaseOpenLiens(VaultData storage s, uint64 epoch) internal {\n    unchecked {\n      s.epochData[epoch].liensOpenForEpoch++;\n    }\n  }\n\n  function afterPayment(uint256 computedSlope) public onlyLienToken {\n    VaultData storage s = _loadStorageSlot();\n    unchecked {\n      s.slope += computedSlope.safeCastTo48();\n    }\n    emit SlopeUpdated(s.slope);\n  }\n\n  /**\n   * @notice After-deposit hook to update the yIntercept of the PublicVault to reflect a capital contribution.\n   * @param assets The amount of assets deposited to the PublicVault.\n   * @param shares The resulting amount of VaultToken shares that were issued.\n   */\n  function afterDeposit(uint256 assets, uint256 shares)\n    internal\n    virtual\n    override\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    unchecked {\n      s.yIntercept += assets.safeCastTo88();\n    }\n    VIData storage v = _loadVISlot();\n    if (v.depositCap != 0 && totalAssets() >= v.depositCap) {\n      revert InvalidState(InvalidStates.DEPOSIT_CAP_EXCEEDED);\n    }\n    emit YInterceptChanged(s.yIntercept);\n  }\n\n  /**\n   * @dev Handles the dilutive fees (on lien repayments) for strategists in VaultTokens.\n   * @param interestOwing the owingInterest for the lien\n   * @param amount The amount that was paid.\n   */\n  function _handleStrategistInterestReward(\n    VaultData storage s,\n    uint256 interestOwing,\n    uint256 amount\n  ) internal virtual {\n    if (VAULT_FEE() != uint256(0)) {\n      uint256 x = (amount > interestOwing) ? interestOwing : amount;\n      uint256 fee = x.mulDivDown(VAULT_FEE(), 10000);\n      uint88 feeInShares = convertToShares(fee).safeCastTo88();\n      s.strategistUnclaimedShares += feeInShares;\n      emit StrategistFee(feeInShares);\n    }\n  }\n\n  function LIEN_TOKEN() public view returns (ILienToken) {\n    return ROUTER().LIEN_TOKEN();\n  }\n\n  function handleBuyoutLien(BuyoutLienParams calldata params)\n    public\n    onlyLienToken\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    unchecked {\n      uint48 newSlope = s.slope - params.lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n      s.yIntercept += params.increaseYIntercept.safeCastTo88();\n      s.last = block.timestamp.safeCastTo40();\n    }\n\n    _decreaseEpochLienCount(s, getLienEpoch(params.lienEnd.safeCastTo64()));\n    emit YInterceptChanged(s.yIntercept);\n  }\n\n  function updateAfterLiquidationPayment(\n    LiquidationPaymentParams calldata params\n  ) external onlyLienToken {\n    VaultData storage s = _loadStorageSlot();\n    if (params.remaining > 0)\n      _setYIntercept(s, s.yIntercept - params.remaining);\n  }\n\n  function updateVaultAfterLiquidation(\n    uint256 maxAuctionWindow,\n    AfterLiquidationParams calldata params\n  ) public onlyLienToken returns (address withdrawProxyIfNearBoundary) {\n    VaultData storage s = _loadStorageSlot();\n\n    _accrue(s);\n    unchecked {\n      _setSlope(s, s.slope - params.lienSlope.safeCastTo48());\n    }\n\n    if (s.currentEpoch != 0) {\n      transferWithdrawReserve();\n    }\n    uint64 lienEpoch = getLienEpoch(params.lienEnd);\n    _decreaseEpochLienCount(s, lienEpoch);\n\n    uint256 timeToEnd = timeToEpochEnd(lienEpoch);\n    if (timeToEnd < maxAuctionWindow) {\n      _deployWithdrawProxyIfNotDeployed(s, lienEpoch);\n      withdrawProxyIfNearBoundary = s.epochData[lienEpoch].withdrawProxy;\n\n      WithdrawProxy(withdrawProxyIfNearBoundary).handleNewLiquidation(\n        params.newAmount,\n        maxAuctionWindow\n      );\n    }\n  }\n\n  function increaseYIntercept(uint256 amount) public {\n    VaultData storage s = _loadStorageSlot();\n    uint64 currentEpoch = s.currentEpoch;\n    require(\n      currentEpoch != 0 &&\n        msg.sender == s.epochData[currentEpoch - 1].withdrawProxy\n    );\n    _setYIntercept(s, s.yIntercept + amount);\n  }\n\n  modifier onlyLienToken() {\n    require(msg.sender == address(LIEN_TOKEN()));\n    _;\n  }\n\n  function decreaseYIntercept(uint256 amount) public {\n    VaultData storage s = _loadStorageSlot();\n    uint64 currentEpoch = s.currentEpoch;\n    require(\n      currentEpoch != 0 &&\n        msg.sender == s.epochData[currentEpoch - 1].withdrawProxy\n    );\n    _setYIntercept(s, s.yIntercept - amount);\n  }\n\n  function _setYIntercept(VaultData storage s, uint256 newYIntercept) internal {\n    s.yIntercept = newYIntercept.safeCastTo88();\n    emit YInterceptChanged(s.yIntercept);\n  }\n\n  function timeToEpochEnd() public view returns (uint256) {\n    return timeToEpochEnd(_loadStorageSlot().currentEpoch);\n  }\n\n  function timeToEpochEnd(uint256 epoch) public view returns (uint256) {\n    uint256 epochEnd = START() + ((epoch + 1) * EPOCH_LENGTH());\n\n    if (block.timestamp >= epochEnd) {\n      return uint256(0);\n    }\n\n    return epochEnd - block.timestamp;\n  }\n\n  function _timeToSecondEndIfPublic()\n    internal\n    view\n    override\n    returns (uint256 timeToSecondEpochEnd)\n  {\n    return timeToEpochEnd() + EPOCH_LENGTH();\n  }\n\n  function timeToSecondEpochEnd() public view returns (uint256) {\n    return _timeToSecondEndIfPublic();\n  }\n}"
    },
    {
      "filename": "src/WithdrawProxy.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**                                                     \n*  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗ \n* ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n* ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n* ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n* ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n* ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n*\n* Astaria Labs, Inc\n*/\n\npragma solidity =0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\nimport {ERC4626Cloned} from \"gpl/ERC4626-Cloned.sol\";\nimport {WithdrawVaultBase} from \"core/WithdrawVaultBase.sol\";\nimport {IWithdrawProxy} from \"core/interfaces/IWithdrawProxy.sol\";\nimport {PublicVault} from \"core/PublicVault.sol\";\nimport {IERC20Metadata} from \"core/interfaces/IERC20Metadata.sol\";\nimport {IERC4626} from \"core/interfaces/IERC4626.sol\";\n\n/**\n * @title WithdrawProxy\n * @notice This contract collects funds for liquidity providers who are exiting. When a liquidity provider is the first\n * in an epoch to mark that they would like to withdraw their funds, a WithdrawProxy for the liquidity provider's\n * PublicVault is deployed to collect loan repayments until the end of the next epoch. Users are minted WithdrawTokens\n * according to their balance in the protocol which are redeemable 1:1 for the underlying PublicVault asset by the end\n * of the next epoch.\n *\n */\n\ncontract WithdrawProxy is ERC4626Cloned, WithdrawVaultBase {\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n  using SafeCastLib for uint256;\n\n  event Claimed(\n    address withdrawProxy,\n    uint256 withdrawProxyAmount,\n    address publicVault,\n    uint256 publicVaultAmount\n  );\n\n  uint256 private constant WITHDRAW_PROXY_SLOT =\n    uint256(keccak256(\"xyz.astaria.WithdrawProxy.storage.location\")) - 1;\n\n  struct WPStorage {\n    uint88 withdrawRatio;\n    uint88 expected; // The sum of the remaining debt (amountOwed) accrued against the NFT at the timestamp when it is liquidated. yIntercept (virtual assets) of a PublicVault are not modified on liquidation, only once an auction is completed.\n    uint40 finalAuctionEnd; // when this is deleted, we know the final auction is over\n    uint256 withdrawReserveReceived; // amount received from PublicVault. The WETH balance of this contract - withdrawReserveReceived = amount received from liquidations.\n  }\n\n  enum InvalidStates {\n    PROCESS_EPOCH_NOT_COMPLETE,\n    FINAL_AUCTION_NOT_OVER,\n    NOT_CLAIMED,\n    CANT_CLAIM\n  }\n  error InvalidState(InvalidStates);\n\n  function minDepositAmount()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n  {\n    return 0;\n  }\n\n  function decimals() public pure override returns (uint8) {\n    return 18;\n  }\n\n  function asset()\n    public\n    pure\n    override(ERC4626Cloned, WithdrawVaultBase)\n    returns (address)\n  {\n    return super.asset();\n  }\n\n  function totalAssets()\n    public\n    view\n    override(ERC4626Cloned, IERC4626)\n    returns (uint256)\n  {\n    return ERC20(asset()).balanceOf(address(this));\n  }\n\n  /**\n   * @notice Public view function to return the name of this WithdrawProxy.\n   * @return The name of this WithdrawProxy.\n   */\n  function name()\n    public\n    view\n    override(IERC20Metadata, WithdrawVaultBase)\n    returns (string memory)\n  {\n    return\n      string(abi.encodePacked(\"AST-WithdrawVault-\", ERC20(asset()).symbol()));\n  }\n\n  /**\n   * @notice Public view function to return the symbol of this WithdrawProxy.\n   * @return The symbol of this WithdrawProxy.\n   */\n  function symbol()\n    public\n    view\n    override(IERC20Metadata, WithdrawVaultBase)\n    returns (string memory)\n  {\n    return\n      string(abi.encodePacked(\"AST-W\", VAULT(), \"-\", ERC20(asset()).symbol()));\n  }\n\n  /**\n   * @notice Mints WithdrawTokens for withdrawing liquidity providers, redeemable by the end of the next epoch.\n   * @param receiver The receiver of the Withdraw Tokens.\n   * @param shares The number of shares to mint.\n   */\n  function mint(uint256 shares, address receiver)\n    public\n    virtual\n    override(ERC4626Cloned, IERC4626)\n    returns (uint256 assets)\n  {\n    require(msg.sender == VAULT(), \"only vault can mint\");\n    _mint(receiver, shares);\n    return shares;\n  }\n\n  function deposit(uint256 assets, address receiver)\n    public\n    virtual\n    override(ERC4626Cloned, IERC4626)\n    returns (uint256 shares)\n  {\n    revert NotSupported();\n  }\n\n  modifier onlyWhenNoActiveAuction() {\n    WPStorage storage s = _loadSlot();\n    // If auction funds have been collected to the WithdrawProxy\n    // but the PublicVault hasn't claimed its share, too much money will be sent to LPs\n    if (s.finalAuctionEnd != 0) {\n      // if finalAuctionEnd is 0, no auctions were added\n      revert InvalidState(InvalidStates.NOT_CLAIMED);\n    }\n    _;\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  )\n    public\n    virtual\n    override(ERC4626Cloned, IERC4626)\n    onlyWhenNoActiveAuction\n    returns (uint256 shares)\n  {\n    return super.withdraw(assets, receiver, owner);\n  }\n\n  /**\n   * @notice Redeem funds collected in the WithdrawProxy.\n   * @param shares The number of WithdrawToken shares to redeem.\n   * @param receiver The receiver of the underlying asset.\n   * @param owner The owner of the WithdrawTokens.\n   * @return assets The amount of the underlying asset redeemed.\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  )\n    public\n    virtual\n    override(ERC4626Cloned, IERC4626)\n    onlyWhenNoActiveAuction\n    returns (uint256 assets)\n  {\n    return super.redeem(shares, receiver, owner);\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    virtual\n    returns (bool)\n  {\n    return interfaceId == type(IWithdrawProxy).interfaceId;\n  }\n\n  function _loadSlot() internal pure returns (WPStorage storage s) {\n    uint256 slot = WITHDRAW_PROXY_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function getFinalAuctionEnd() public view returns (uint256) {\n    WPStorage storage s = _loadSlot();\n    return s.finalAuctionEnd;\n  }\n\n  function getWithdrawRatio() public view returns (uint256) {\n    WPStorage storage s = _loadSlot();\n    return s.withdrawRatio;\n  }\n\n  function getExpected() public view returns (uint256) {\n    WPStorage storage s = _loadSlot();\n    return s.expected;\n  }\n\n  modifier onlyVault() {\n    require(msg.sender == VAULT(), \"only vault can call\");\n    _;\n  }\n\n  function increaseWithdrawReserveReceived(uint256 amount) external onlyVault {\n    WPStorage storage s = _loadSlot();\n    s.withdrawReserveReceived += amount;\n  }\n\n  function claim() public {\n    WPStorage storage s = _loadSlot();\n\n    if (s.finalAuctionEnd == 0) {\n      revert InvalidState(InvalidStates.CANT_CLAIM);\n    }\n\n    if (PublicVault(VAULT()).getCurrentEpoch() < CLAIMABLE_EPOCH()) {\n      revert InvalidState(InvalidStates.PROCESS_EPOCH_NOT_COMPLETE);\n    }\n    if (block.timestamp < s.finalAuctionEnd) {\n      revert InvalidState(InvalidStates.FINAL_AUCTION_NOT_OVER);\n    }\n\n    uint256 transferAmount = 0;\n    uint256 balance = ERC20(asset()).balanceOf(address(this)) -\n      s.withdrawReserveReceived; // will never underflow because withdrawReserveReceived is always increased by the transfer amount from the PublicVault\n\n    if (balance < s.expected) {\n      PublicVault(VAULT()).decreaseYIntercept(\n        (s.expected - balance).mulWadDown(1e18 - s.withdrawRatio)\n      );\n    } else {\n      PublicVault(VAULT()).increaseYIntercept(\n        (balance - s.expected).mulWadDown(1e18 - s.withdrawRatio)\n      );\n    }\n\n    if (s.withdrawRatio == uint256(0)) {\n      ERC20(asset()).safeTransfer(VAULT(), balance);\n    } else {\n      transferAmount = uint256(s.withdrawRatio).mulDivDown(\n        balance,\n        10**ERC20(asset()).decimals()\n      );\n\n      unchecked {\n        balance -= transferAmount;\n      }\n\n      if (balance > 0) {\n        ERC20(asset()).safeTransfer(VAULT(), balance);\n      }\n    }\n    s.finalAuctionEnd = 0;\n\n    emit Claimed(address(this), transferAmount, VAULT(), balance);\n  }\n\n  function drain(uint256 amount, address withdrawProxy)\n    public\n    onlyVault\n    returns (uint256)\n  {\n    uint256 balance = ERC20(asset()).balanceOf(address(this));\n    if (amount > balance) {\n      amount = balance;\n    }\n    ERC20(asset()).safeTransfer(withdrawProxy, amount);\n    return amount;\n  }\n\n  function setWithdrawRatio(uint256 liquidationWithdrawRatio) public onlyVault {\n    _loadSlot().withdrawRatio = liquidationWithdrawRatio.safeCastTo88();\n  }\n\n  function handleNewLiquidation(\n    uint256 newLienExpectedValue,\n    uint256 finalAuctionDelta\n  ) public onlyVault {\n    WPStorage storage s = _loadSlot();\n\n    unchecked {\n      s.expected += newLienExpectedValue.safeCastTo88();\n      uint40 auctionEnd = (block.timestamp + finalAuctionDelta).safeCastTo40();\n      if (auctionEnd > s.finalAuctionEnd) s.finalAuctionEnd = auctionEnd;\n    }\n  }\n}"
    }
  ]
}