{
  "Title": "H-2: Legacy withdrawals can be relayed twice, causing double spending of bridged assets",
  "Content": "# Issue H-2: Legacy withdrawals can be relayed twice, causing double spending of bridged assets \n\nSource: https://github.com/sherlock-audit/2023-03-optimism-judging/issues/87 \n\n## Found by \nJeiwan\n\n## Summary\n`L2CrossDomainMessenger.relayMessage` checks that legacy messages have not been relayed by reading from the `successfulMessages` state variable, however the contract's storage will wiped during the migration to Bedrock and `successfulMessages` will be empty after the deployment of the contract. The check will always pass, even if a legacy message have already been relayed using its v0 hash. As a result, random withdrawal messages, as well as messages from malicious actors, can be relayed multiple times during the migration: first, as legacy v0 messages (before the migration); then, as Bedrock v1 messages (during the migration).\n## Vulnerability Detail\n[L2CrossDomainMessenger](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/L2/L2CrossDomainMessenger.sol#L18) inherits from [CrossDomainMessenger](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L114), which inherits from `CrossDomainMessengerLegacySpacer0`, `CrossDomainMessengerLegacySpacer1`, assuming that the contract will be deployed at an address with existing state–the two spacer contracts are needed to \"skip\" the slots occupied by previous implementations of the contract.\n\nDuring the migration, legacy (i.e. pre-Bedrock) withdrawal messages will be [converted](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/op-chain-ops/crossdomain/migrate.go#L55) to Bedrock messages–they're [expected to call the `relayMessage` function](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/op-chain-ops/crossdomain/migrate.go#L74-L80) of `L2CrossDomainMessenger`. The `L2CrossDomainMessenger.relayMessage` function [checks that the relayed legacy message haven't been relayed already](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L305-L313):\n```solidity\n// If the message is version 0, then it's a migrated legacy withdrawal. We therefore need\n// to check that the legacy version of the message has not already been relayed.\nif (version == 0) {\n    bytes32 oldHash = Hashing.hashCrossDomainMessageV0(_target, _sender, _message, _nonce);\n    require(\n        successfulMessages[oldHash] == false,\n        \"CrossDomainMessenger: legacy withdrawal already relayed\"\n    );\n}\n```\n\nIt reads a V0 message hash from the `successfulMessages` state variable, assuming that the content of the variable is preserved during the migration. However, the [state and storage of all predeployed contracts is wiped during the migration](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/op-chain-ops/genesis/db_migration.go#L150-L157):\n```go\n// We need to wipe the storage of every predeployed contract EXCEPT for the GovernanceToken,\n// WETH9, the DeployerWhitelist, the LegacyMessagePasser, and LegacyERC20ETH. We have verified\n// that none of the legacy storage (other than the aforementioned contracts) is accessible and\n// therefore can be safely removed from the database. Storage must be wiped before anything\n// else or the ERC-1967 proxy storage slots will be removed.\nif err := WipePredeployStorage(db); err != nil {\n    return nil, fmt.Errorf(\"cannot wipe storage: %w\", err)\n}\n```\n\nAlso notice that [withdrawals are migrated *after* predeploys were wiped and deployed](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/op-chain-ops/genesis/db_migration.go#L150-L192)–predeploys will have empty storage at the time withdrawals are migrated.\n\nMoreover, if we check the [code at the `L2CrossDomainMessenger` address](https://optimistic.etherscan.io/address/0x4200000000000000000000000000000000000007#code) of the current version of Optimism, we'll see that the contract's storage layout is different from the layout of the `CrossDomainMessengerLegacySpacer0` and `CrossDomainMessengerLegacySpacer1` contracts: there are no gaps and other spacer slots; `successfulMessages` is the second slot of the contract. Thus, even if there were no wiping, the `successfulMessages` mapping of the new `L2CrossDomainMessenger` contract would still be empty.\n## Impact\nWithdrawal messages can be relayed twice: once right before and once during the migration. ETH and ERC20 tokens can be withdrawn twice, which is basically double spending of bridged assets.\n## Code Snippet\n1. `L2CrossDomainMessenger` is `CrossDomainMessenger`:\nhttps://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/L2/L2CrossDomainMessenger.sol#L18\n1. `CrossDomainMessenger` inherits from `CrossDomainMessengerLegacySpacer0` and `CrossDomainMessengerLegacySpacer1` to preserve the storage layout:\nhttps://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L114-L117\n1. `CrossDomainMessenger.relayMessage` reads from `successfulMessages` to ensure that legacy withdrawals haven't been relayed already:\nhttps://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L307-L313\n1. All predeploys are wiped during the migration, thus `L2CrossDomainMessenger.successfulMessages` will not contain the hashes of legacy withdrawals:\nhttps://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/op-chain-ops/genesis/db_migration.go#L150-L157\n## Tool used\nManual Review\n## Recommendation\n1. Consider cleaning up the storage layout of `L1CrossDomainMessenger`, `L2CrossDomainMessenger` and other proxied contracts.\n1. In the [PreCheckWithdrawals](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/op-chain-ops/crossdomain/precheck.go#L21) function, consider reading withdrawal hashes from the `successfulMessages` mapping of the old `L2CrossDomainMessenger` contract and checking if the values are set. Successful withdrawals should be skipped at this point to filter out legacy withdrawals that have already been relayed.\n1. Consider removing the [check](https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L307-L313) from the `relayMessage` function, since the check will be useless due to the empty state of the contract.\n\n\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment:\nThis report is valid. The storage layout of the new `CrossDomainMessenger` contract is different from the old `CrossDomainMessenger`, which allows for replaying old cross domain messages- this would be catastrophic for the network.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/63",
  "Code": [
    {
      "filename": "packages/contracts-bedrock/contracts/L2/L2CrossDomainMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { L2ToL1MessagePasser } from \"./L2ToL1MessagePasser.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000007\n * @title L2CrossDomainMessenger\n * @notice The L2CrossDomainMessenger is a high-level interface for message passing between L1 and\n *         L2 on the L2 side. Users are generally encouraged to use this contract instead of lower\n *         level message passing contracts.\n */\ncontract L2CrossDomainMessenger is CrossDomainMessenger, Semver {\n    /**\n     * @custom:semver 1.1.0\n     *\n     * @param _l1CrossDomainMessenger Address of the L1CrossDomainMessenger contract.\n     */\n    constructor(address _l1CrossDomainMessenger)\n        Semver(1, 1, 0)\n        CrossDomainMessenger(_l1CrossDomainMessenger)\n    {\n        initialize();\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize() public initializer {\n        __CrossDomainMessenger_init();\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy getter for the remote messenger. Use otherMessenger going forward.\n     *\n     * @return Address of the L1CrossDomainMessenger contract.\n     */\n    function l1CrossDomainMessenger() public view returns (address) {\n        return OTHER_MESSENGER;\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal override {\n        L2ToL1MessagePasser(payable(Predeploys.L2_TO_L1_MESSAGE_PASSER)).initiateWithdrawal{\n            value: _value\n        }(_to, _gasLimit, _data);\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isOtherMessenger() internal view override returns (bool) {\n        return AddressAliasHelper.undoL1ToL2Alias(msg.sender) == OTHER_MESSENGER;\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isUnsafeTarget(address _target) internal view override returns (bool) {\n        return _target == address(this) || _target == address(Predeploys.L2_TO_L1_MESSAGE_PASSER);\n    }\n}"
    },
    {
      "filename": "op-chain-ops/crossdomain/migrate.go",
      "content": "package crossdomain\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\n\t\"github.com/ethereum-optimism/optimism/op-bindings/bindings\"\n\t\"github.com/ethereum-optimism/optimism/op-bindings/predeploys\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/core/vm\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/params\"\n)\n\nvar (\n\tabiTrue                      = common.Hash{31: 0x01}\n\terrLegacyStorageSlotNotFound = errors.New(\"cannot find storage slot\")\n)\n\n// MigrateWithdrawals will migrate a list of pending withdrawals given a StateDB.\nfunc MigrateWithdrawals(withdrawals SafeFilteredWithdrawals, db vm.StateDB, l1CrossDomainMessenger *common.Address, noCheck bool) error {\n\tfor i, legacy := range withdrawals {\n\t\tlegacySlot, err := legacy.StorageSlot()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !noCheck {\n\t\t\tlegacyValue := db.GetState(predeploys.LegacyMessagePasserAddr, legacySlot)\n\t\t\tif legacyValue != abiTrue {\n\t\t\t\treturn fmt.Errorf(\"%w: %s\", errLegacyStorageSlotNotFound, legacySlot)\n\t\t\t}\n\t\t}\n\n\t\twithdrawal, err := MigrateWithdrawal(legacy, l1CrossDomainMessenger)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tslot, err := withdrawal.StorageSlot()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot compute withdrawal storage slot: %w\", err)\n\t\t}\n\n\t\tdb.SetState(predeploys.L2ToL1MessagePasserAddr, slot, abiTrue)\n\t\tlog.Info(\"Migrated withdrawal\", \"number\", i, \"slot\", slot)\n\t}\n\treturn nil\n}\n\n// MigrateWithdrawal will turn a LegacyWithdrawal into a bedrock\n// style Withdrawal.\nfunc MigrateWithdrawal(withdrawal *LegacyWithdrawal, l1CrossDomainMessenger *common.Address) (*Withdrawal, error) {\n\t// Attempt to parse the value\n\tvalue, err := withdrawal.Value()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot migrate withdrawal: %w\", err)\n\t}\n\n\tabi, err := bindings.L1CrossDomainMessengerMetaData.GetAbi()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Migrated withdrawals are specified as version 0. Both the\n\t// L2ToL1MessagePasser and the CrossDomainMessenger use the same\n\t// versioning scheme. Both should be set to version 0\n\tversionedNonce := EncodeVersionedNonce(withdrawal.XDomainNonce, new(big.Int))\n\t// Encode the call to `relayMessage` on the `CrossDomainMessenger`.\n\t// The minGasLimit can safely be 0 here.\n\tdata, err := abi.Pack(\n\t\t\"relayMessage\",\n\t\tversionedNonce,\n\t\twithdrawal.XDomainSender,\n\t\twithdrawal.XDomainTarget,\n\t\tvalue,\n\t\tnew(big.Int),\n\t\t[]byte(withdrawal.XDomainData),\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot abi encode relayMessage: %w\", err)\n\t}\n\n\tgasLimit := MigrateWithdrawalGasLimit(data)\n\n\tw := NewWithdrawal(\n\t\tversionedNonce,\n\t\t&predeploys.L2CrossDomainMessengerAddr,\n\t\tl1CrossDomainMessenger,\n\t\tvalue,\n\t\tnew(big.Int).SetUint64(gasLimit),\n\t\tdata,\n\t)\n\treturn w, nil\n}\n\nfunc MigrateWithdrawalGasLimit(data []byte) uint64 {\n\t// Compute the cost of the calldata\n\tdataCost := uint64(0)\n\tfor _, b := range data {\n\t\tif b == 0 {\n\t\t\tdataCost += params.TxDataZeroGas\n\t\t} else {\n\t\t\tdataCost += params.TxDataNonZeroGasEIP2028\n\t\t}\n\t}\n\n\t// Set the outer gas limit. This cannot be zero\n\tgasLimit := dataCost + 200_000\n\t// Cap the gas limit to be 25 million to prevent creating withdrawals\n\t// that go over the block gas limit.\n\tif gasLimit > 25_000_000 {\n\t\tgasLimit = 25_000_000\n\t}\n\n\treturn gasLimit\n}"
    },
    {
      "filename": "op-chain-ops/genesis/db_migration.go",
      "content": "package genesis\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math/big\"\n\n\t\"github.com/ethereum-optimism/optimism/op-bindings/predeploys\"\n\t\"github.com/ethereum-optimism/optimism/op-chain-ops/crossdomain\"\n\t\"github.com/ethereum-optimism/optimism/op-chain-ops/ether\"\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/core/rawdb\"\n\t\"github.com/ethereum/go-ethereum/core/state\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/ethdb\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/params\"\n\t\"github.com/ethereum/go-ethereum/trie\"\n)\n\nvar (\n\tabiTrue  = common.Hash{31: 0x01}\n\tabiFalse = common.Hash{}\n\t// BedrockTransitionBlockExtraData represents the extradata\n\t// set in the very first bedrock block. This value must be\n\t// less than 32 bytes long or it will create an invalid block.\n\tBedrockTransitionBlockExtraData = []byte(\"BEDROCK\")\n)\n\ntype MigrationResult struct {\n\tTransitionHeight    uint64\n\tTransitionTimestamp uint64\n\tTransitionBlockHash common.Hash\n}\n\n// MigrateDB will migrate an l2geth legacy Optimism database to a Bedrock database.\nfunc MigrateDB(ldb ethdb.Database, config *DeployConfig, l1Block *types.Block, migrationData *crossdomain.MigrationData, commit, noCheck bool) (*MigrationResult, error) {\n\t// Grab the hash of the tip of the legacy chain.\n\thash := rawdb.ReadHeadHeaderHash(ldb)\n\tlog.Info(\"Reading chain tip from database\", \"hash\", hash)\n\n\t// Grab the header number.\n\tnum := rawdb.ReadHeaderNumber(ldb, hash)\n\tif num == nil {\n\t\treturn nil, fmt.Errorf(\"cannot find header number for %s\", hash)\n\t}\n\n\t// Grab the full header.\n\theader := rawdb.ReadHeader(ldb, hash, *num)\n\tlog.Info(\"Read header from database\", \"number\", *num)\n\n\t// Ensure that the extradata is valid.\n\tif size := len(BedrockTransitionBlockExtraData); size > 32 {\n\t\treturn nil, fmt.Errorf(\"transition block extradata too long: %d\", size)\n\t}\n\n\t// We write special extra data into the Bedrock transition block to indicate that the migration\n\t// has already happened. If we detect this extra data, we can skip the migration.\n\tif bytes.Equal(header.Extra, BedrockTransitionBlockExtraData) {\n\t\tlog.Info(\"Detected migration already happened\", \"root\", header.Root, \"blockhash\", header.Hash())\n\n\t\treturn &MigrationResult{\n\t\t\tTransitionHeight:    *num,\n\t\t\tTransitionTimestamp: header.Time,\n\t\t\tTransitionBlockHash: hash,\n\t\t}, nil\n\t}\n\n\t// Ensure that the timestamp for the Bedrock transition block is greater than the timestamp of\n\t// the last legacy block.\n\tif uint64(config.L2OutputOracleStartingTimestamp) <= header.Time {\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"output oracle starting timestamp (%d) is less than the header timestamp (%d)\", config.L2OutputOracleStartingTimestamp, header.Time,\n\t\t)\n\t}\n\n\t// Ensure that the timestamp for the Bedrock transition block is greater than 0, not implicitly\n\t// guaranteed by the above check because the above converted the timestamp to a uint64.\n\tif config.L2OutputOracleStartingTimestamp <= 0 {\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"output oracle starting timestamp (%d) cannot be <= 0\", config.L2OutputOracleStartingTimestamp,\n\t\t)\n\t}\n\n\tdbFactory := func() (*state.StateDB, error) {\n\t\t// Set up the backing store.\n\t\tunderlyingDB := state.NewDatabaseWithConfig(ldb, &trie.Config{\n\t\t\tPreimages: true,\n\t\t\tCache:     1024,\n\t\t})\n\n\t\t// Open up the state database.\n\t\tdb, err := state.New(header.Root, underlyingDB, nil)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot open StateDB: %w\", err)\n\t\t}\n\n\t\treturn db, nil\n\t}\n\n\tdb, err := dbFactory()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot create StateDB: %w\", err)\n\t}\n\n\t// Before we do anything else, we need to ensure that all of the input configuration is correct\n\t// and nothing is missing. We'll first verify the contract configuration, then we'll verify the\n\t// witness data for the migration. We operate under the assumption that the witness data is\n\t// untrusted and must be verified explicitly before we can use it.\n\n\t// Generate and verify the configuration for storage variables to be set on L2.\n\tstorage, err := NewL2StorageConfig(config, l1Block)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot create storage config: %w\", err)\n\t}\n\n\t// Generate and verify the configuration for immutable variables to be set on L2.\n\timmutable, err := NewL2ImmutableConfig(config, l1Block)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot create immutable config: %w\", err)\n\t}\n\n\t// Convert all input messages into legacy messages. Note that this list is not yet filtered and\n\t// may be missing some messages or have some extra messages.\n\tunfilteredWithdrawals, invalidMessages, err := migrationData.ToWithdrawals()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot serialize withdrawals: %w\", err)\n\t}\n\n\tlog.Info(\"Read withdrawals from witness data\", \"unfiltered\", len(unfilteredWithdrawals), \"invalid\", len(invalidMessages))\n\n\t// We now need to check that we have all of the withdrawals that we expect to have. An error\n\t// will be thrown if there are any missing messages, and any extra messages will be removed.\n\tvar filteredWithdrawals crossdomain.SafeFilteredWithdrawals\n\tif !noCheck {\n\t\tlog.Info(\"Checking withdrawals...\")\n\t\tfilteredWithdrawals, err = crossdomain.PreCheckWithdrawals(db, unfilteredWithdrawals, invalidMessages)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"withdrawals mismatch: %w\", err)\n\t\t}\n\t} else {\n\t\tlog.Info(\"Skipping checking withdrawals\")\n\t\tfilteredWithdrawals = crossdomain.SafeFilteredWithdrawals(unfilteredWithdrawals)\n\t}\n\n\t// At this point we've fully verified the witness data for the migration, so we can begin the\n\t// actual migration process. This involves modifying parts of the legacy database and inserting\n\t// a transition block.\n\n\t// We need to wipe the storage of every predeployed contract EXCEPT for the GovernanceToken,\n\t// WETH9, the DeployerWhitelist, the LegacyMessagePasser, and LegacyERC20ETH. We have verified\n\t// that none of the legacy storage (other than the aforementioned contracts) is accessible and\n\t// therefore can be safely removed from the database. Storage must be wiped before anything\n\t// else or the ERC-1967 proxy storage slots will be removed.\n\tif err := WipePredeployStorage(db); err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot wipe storage: %w\", err)\n\t}\n\n\t// Next order of business is to convert all predeployed smart contracts into proxies so they\n\t// can be easily upgraded later on. In the legacy system, all upgrades to predeployed contracts\n\t// required hard forks which was a huge pain. Note that we do NOT put the GovernanceToken or\n\t// WETH9 contracts behind proxies because we do not want to make these easily upgradable.\n\tlog.Info(\"Converting predeployed contracts to proxies\")\n\tif err := SetL2Proxies(db); err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot set L2Proxies: %w\", err)\n\t}\n\n\t// Here we update the storage of each predeploy with the new storage variables that we want to\n\t// set on L2 and update the implementations for all predeployed contracts that are behind\n\t// proxies (NOT the GovernanceToken or WETH9).\n\tlog.Info(\"Updating implementations for predeployed contracts\")\n\tif err := SetImplementations(db, storage, immutable); err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot set implementations: %w\", err)\n\t}\n\n\t// We need to update the code for LegacyERC20ETH. This is NOT a standard predeploy because it's\n\t// deployed at the 0xdeaddeaddead... address and therefore won't be updated by the previous\n\t// function call to SetImplementations.\n\tlog.Info(\"Updating code for LegacyERC20ETH\")\n\tif err := SetLegacyETH(db, storage, immutable); err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot set legacy ETH: %w\", err)\n\t}\n\n\t// Now we migrate legacy withdrawals from the LegacyMessagePasser contract to their new format\n\t// in the Bedrock L2ToL1MessagePasser contract. Note that we do NOT delete the withdrawals from\n\t// the LegacyMessagePasser contract. Here we operate on the list of withdrawals that we\n\t// previously filtered and verified.\n\tlog.Info(\"Starting to migrate withdrawals\", \"no-check\", noCheck)\n\terr = crossdomain.MigrateWithdrawals(filteredWithdrawals, db, &config.L1CrossDomainMessengerProxy, noCheck)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot migrate withdrawals: %w\", err)\n\t}\n\n\t// Finally we migrate the balances held inside the LegacyERC20ETH contract into the state trie.\n\t// We also delete the balances from the LegacyERC20ETH contract. Unlike the steps above, this step\n\t// combines the check and mutation steps into one in order to reduce migration time.\n\tlog.Info(\"Starting to migrate ERC20 ETH\")\n\terr = ether.MigrateBalances(db, dbFactory, migrationData.Addresses(), migrationData.OvmAllowances, int(config.L1ChainID), noCheck)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to migrate OVM_ETH: %w\", err)\n\t}\n\n\t// We're done messing around with the database, so we can now commit the changes to the DB.\n\t// Note that this doesn't actually write the changes to disk.\n\tlog.Info(\"Committing state DB\")\n\tnewRoot, err := db.Commit(true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create the header for the Bedrock transition block.\n\tbedrockHeader := &types.Header{\n\t\tParentHash:  header.Hash(),\n\t\tUncleHash:   types.EmptyUncleHash,\n\t\tCoinbase:    predeploys.SequencerFeeVaultAddr,\n\t\tRoot:        newRoot,\n\t\tTxHash:      types.EmptyRootHash,\n\t\tReceiptHash: types.EmptyRootHash,\n\t\tBloom:       types.Bloom{},\n\t\tDifficulty:  common.Big0,\n\t\tNumber:      new(big.Int).Add(header.Number, common.Big1),\n\t\tGasLimit:    (uint64)(config.L2GenesisBlockGasLimit),\n\t\tGasUsed:     0,\n\t\tTime:        uint64(config.L2OutputOracleStartingTimestamp),\n\t\tExtra:       BedrockTransitionBlockExtraData,\n\t\tMixDigest:   common.Hash{},\n\t\tNonce:       types.BlockNonce{},\n\t\tBaseFee:     big.NewInt(params.InitialBaseFee),\n\t}\n\n\t// Create the Bedrock transition block from the header. Note that there are no transactions,\n\t// uncle blocks, or receipts in the Bedrock transition block.\n\tbedrockBlock := types.NewBlock(bedrockHeader, nil, nil, nil, trie.NewStackTrie(nil))\n\n\t// We did it!\n\tlog.Info(\n\t\t\"Built Bedrock transition\",\n\t\t\"hash\", bedrockBlock.Hash(),\n\t\t\"root\", bedrockBlock.Root(),\n\t\t\"number\", bedrockBlock.NumberU64(),\n\t\t\"gas-used\", bedrockBlock.GasUsed(),\n\t\t\"gas-limit\", bedrockBlock.GasLimit(),\n\t)\n\n\t// Create the result of the migration.\n\tres := &MigrationResult{\n\t\tTransitionHeight:    bedrockBlock.NumberU64(),\n\t\tTransitionTimestamp: bedrockBlock.Time(),\n\t\tTransitionBlockHash: bedrockBlock.Hash(),\n\t}\n\n\t// If we're not actually writing this to disk, then we're done.\n\tif !commit {\n\t\tlog.Info(\"Dry run complete\")\n\t\treturn res, nil\n\t}\n\n\t// Otherwise we need to write the changes to disk. First we commit the state changes.\n\tlog.Info(\"Committing trie DB\")\n\tif err := db.Database().TrieDB().Commit(newRoot, true); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Next we write the Bedrock transition block to the database.\n\trawdb.WriteTd(ldb, bedrockBlock.Hash(), bedrockBlock.NumberU64(), bedrockBlock.Difficulty())\n\trawdb.WriteBlock(ldb, bedrockBlock)\n\trawdb.WriteReceipts(ldb, bedrockBlock.Hash(), bedrockBlock.NumberU64(), nil)\n\trawdb.WriteCanonicalHash(ldb, bedrockBlock.Hash(), bedrockBlock.NumberU64())\n\trawdb.WriteHeadBlockHash(ldb, bedrockBlock.Hash())\n\trawdb.WriteHeadFastBlockHash(ldb, bedrockBlock.Hash())\n\trawdb.WriteHeadHeaderHash(ldb, bedrockBlock.Hash())\n\n\t// Make the first Bedrock block a finalized block.\n\trawdb.WriteFinalizedBlockHash(ldb, bedrockBlock.Hash())\n\n\t// We need to update the chain config to set the correct hardforks.\n\tgenesisHash := rawdb.ReadCanonicalHash(ldb, 0)\n\tcfg := rawdb.ReadChainConfig(ldb, genesisHash)\n\tif cfg == nil {\n\t\tlog.Crit(\"chain config not found\")\n\t}\n\n\t// Set the standard options.\n\tcfg.LondonBlock = bedrockBlock.Number()\n\tcfg.ArrowGlacierBlock = bedrockBlock.Number()\n\tcfg.GrayGlacierBlock = bedrockBlock.Number()\n\tcfg.MergeNetsplitBlock = bedrockBlock.Number()\n\tcfg.TerminalTotalDifficulty = big.NewInt(0)\n\tcfg.TerminalTotalDifficultyPassed = true\n\n\t// Set the Optimism options.\n\tcfg.BedrockBlock = bedrockBlock.Number()\n\t// Enable Regolith from the start of Bedrock\n\tcfg.RegolithTime = new(uint64)\n\tcfg.Optimism = &params.OptimismConfig{\n\t\tEIP1559Denominator: config.EIP1559Denominator,\n\t\tEIP1559Elasticity:  config.EIP1559Elasticity,\n\t}\n\n\t// Write the chain config to disk.\n\trawdb.WriteChainConfig(ldb, genesisHash, cfg)\n\n\t// Yay!\n\tlog.Info(\n\t\t\"wrote chain config\",\n\t\t\"1559-denominator\", config.EIP1559Denominator,\n\t\t\"1559-elasticity\", config.EIP1559Elasticity,\n\t)\n\n\t// We're done!\n\tlog.Info(\n\t\t\"wrote Bedrock transition block\",\n\t\t\"height\", bedrockHeader.Number,\n\t\t\"root\", bedrockHeader.Root.String(),\n\t\t\"hash\", bedrockHeader.Hash().String(),\n\t\t\"timestamp\", bedrockHeader.Time,\n\t)\n\n\t// Return the result and have a nice day.\n\treturn res, nil\n}"
    },
    {
      "filename": "op-chain-ops/genesis/db_migration.go",
      "content": "package genesis\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math/big\"\n\n\t\"github.com/ethereum-optimism/optimism/op-bindings/predeploys\"\n\t\"github.com/ethereum-optimism/optimism/op-chain-ops/crossdomain\"\n\t\"github.com/ethereum-optimism/optimism/op-chain-ops/ether\"\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/core/rawdb\"\n\t\"github.com/ethereum/go-ethereum/core/state\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/ethdb\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/params\"\n\t\"github.com/ethereum/go-ethereum/trie\"\n)\n\nvar (\n\tabiTrue  = common.Hash{31: 0x01}\n\tabiFalse = common.Hash{}\n\t// BedrockTransitionBlockExtraData represents the extradata\n\t// set in the very first bedrock block. This value must be\n\t// less than 32 bytes long or it will create an invalid block.\n\tBedrockTransitionBlockExtraData = []byte(\"BEDROCK\")\n)\n\ntype MigrationResult struct {\n\tTransitionHeight    uint64\n\tTransitionTimestamp uint64\n\tTransitionBlockHash common.Hash\n}\n\n// MigrateDB will migrate an l2geth legacy Optimism database to a Bedrock database.\nfunc MigrateDB(ldb ethdb.Database, config *DeployConfig, l1Block *types.Block, migrationData *crossdomain.MigrationData, commit, noCheck bool) (*MigrationResult, error) {\n\t// Grab the hash of the tip of the legacy chain.\n\thash := rawdb.ReadHeadHeaderHash(ldb)\n\tlog.Info(\"Reading chain tip from database\", \"hash\", hash)\n\n\t// Grab the header number.\n\tnum := rawdb.ReadHeaderNumber(ldb, hash)\n\tif num == nil {\n\t\treturn nil, fmt.Errorf(\"cannot find header number for %s\", hash)\n\t}\n\n\t// Grab the full header.\n\theader := rawdb.ReadHeader(ldb, hash, *num)\n\tlog.Info(\"Read header from database\", \"number\", *num)\n\n\t// Ensure that the extradata is valid.\n\tif size := len(BedrockTransitionBlockExtraData); size > 32 {\n\t\treturn nil, fmt.Errorf(\"transition block extradata too long: %d\", size)\n\t}\n\n\t// We write special extra data into the Bedrock transition block to indicate that the migration\n\t// has already happened. If we detect this extra data, we can skip the migration.\n\tif bytes.Equal(header.Extra, BedrockTransitionBlockExtraData) {\n\t\tlog.Info(\"Detected migration already happened\", \"root\", header.Root, \"blockhash\", header.Hash())\n\n\t\treturn &MigrationResult{\n\t\t\tTransitionHeight:    *num,\n\t\t\tTransitionTimestamp: header.Time,\n\t\t\tTransitionBlockHash: hash,\n\t\t}, nil\n\t}\n\n\t// Ensure that the timestamp for the Bedrock transition block is greater than the timestamp of\n\t// the last legacy block.\n\tif uint64(config.L2OutputOracleStartingTimestamp) <= header.Time {\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"output oracle starting timestamp (%d) is less than the header timestamp (%d)\", config.L2OutputOracleStartingTimestamp, header.Time,\n\t\t)\n\t}\n\n\t// Ensure that the timestamp for the Bedrock transition block is greater than 0, not implicitly\n\t// guaranteed by the above check because the above converted the timestamp to a uint64.\n\tif config.L2OutputOracleStartingTimestamp <= 0 {\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"output oracle starting timestamp (%d) cannot be <= 0\", config.L2OutputOracleStartingTimestamp,\n\t\t)\n\t}\n\n\tdbFactory := func() (*state.StateDB, error) {\n\t\t// Set up the backing store.\n\t\tunderlyingDB := state.NewDatabaseWithConfig(ldb, &trie.Config{\n\t\t\tPreimages: true,\n\t\t\tCache:     1024,\n\t\t})\n\n\t\t// Open up the state database.\n\t\tdb, err := state.New(header.Root, underlyingDB, nil)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot open StateDB: %w\", err)\n\t\t}\n\n\t\treturn db, nil\n\t}\n\n\tdb, err := dbFactory()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot create StateDB: %w\", err)\n\t}\n\n\t// Before we do anything else, we need to ensure that all of the input configuration is correct\n\t// and nothing is missing. We'll first verify the contract configuration, then we'll verify the\n\t// witness data for the migration. We operate under the assumption that the witness data is\n\t// untrusted and must be verified explicitly before we can use it.\n\n\t// Generate and verify the configuration for storage variables to be set on L2.\n\tstorage, err := NewL2StorageConfig(config, l1Block)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot create storage config: %w\", err)\n\t}\n\n\t// Generate and verify the configuration for immutable variables to be set on L2.\n\timmutable, err := NewL2ImmutableConfig(config, l1Block)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot create immutable config: %w\", err)\n\t}\n\n\t// Convert all input messages into legacy messages. Note that this list is not yet filtered and\n\t// may be missing some messages or have some extra messages.\n\tunfilteredWithdrawals, invalidMessages, err := migrationData.ToWithdrawals()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot serialize withdrawals: %w\", err)\n\t}\n\n\tlog.Info(\"Read withdrawals from witness data\", \"unfiltered\", len(unfilteredWithdrawals), \"invalid\", len(invalidMessages))\n\n\t// We now need to check that we have all of the withdrawals that we expect to have. An error\n\t// will be thrown if there are any missing messages, and any extra messages will be removed.\n\tvar filteredWithdrawals crossdomain.SafeFilteredWithdrawals\n\tif !noCheck {\n\t\tlog.Info(\"Checking withdrawals...\")\n\t\tfilteredWithdrawals, err = crossdomain.PreCheckWithdrawals(db, unfilteredWithdrawals, invalidMessages)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"withdrawals mismatch: %w\", err)\n\t\t}\n\t} else {\n\t\tlog.Info(\"Skipping checking withdrawals\")\n\t\tfilteredWithdrawals = crossdomain.SafeFilteredWithdrawals(unfilteredWithdrawals)\n\t}\n\n\t// At this point we've fully verified the witness data for the migration, so we can begin the\n\t// actual migration process. This involves modifying parts of the legacy database and inserting\n\t// a transition block.\n\n\t// We need to wipe the storage of every predeployed contract EXCEPT for the GovernanceToken,\n\t// WETH9, the DeployerWhitelist, the LegacyMessagePasser, and LegacyERC20ETH. We have verified\n\t// that none of the legacy storage (other than the aforementioned contracts) is accessible and\n\t// therefore can be safely removed from the database. Storage must be wiped before anything\n\t// else or the ERC-1967 proxy storage slots will be removed.\n\tif err := WipePredeployStorage(db); err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot wipe storage: %w\", err)\n\t}\n\n\t// Next order of business is to convert all predeployed smart contracts into proxies so they\n\t// can be easily upgraded later on. In the legacy system, all upgrades to predeployed contracts\n\t// required hard forks which was a huge pain. Note that we do NOT put the GovernanceToken or\n\t// WETH9 contracts behind proxies because we do not want to make these easily upgradable.\n\tlog.Info(\"Converting predeployed contracts to proxies\")\n\tif err := SetL2Proxies(db); err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot set L2Proxies: %w\", err)\n\t}\n\n\t// Here we update the storage of each predeploy with the new storage variables that we want to\n\t// set on L2 and update the implementations for all predeployed contracts that are behind\n\t// proxies (NOT the GovernanceToken or WETH9).\n\tlog.Info(\"Updating implementations for predeployed contracts\")\n\tif err := SetImplementations(db, storage, immutable); err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot set implementations: %w\", err)\n\t}\n\n\t// We need to update the code for LegacyERC20ETH. This is NOT a standard predeploy because it's\n\t// deployed at the 0xdeaddeaddead... address and therefore won't be updated by the previous\n\t// function call to SetImplementations.\n\tlog.Info(\"Updating code for LegacyERC20ETH\")\n\tif err := SetLegacyETH(db, storage, immutable); err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot set legacy ETH: %w\", err)\n\t}\n\n\t// Now we migrate legacy withdrawals from the LegacyMessagePasser contract to their new format\n\t// in the Bedrock L2ToL1MessagePasser contract. Note that we do NOT delete the withdrawals from\n\t// the LegacyMessagePasser contract. Here we operate on the list of withdrawals that we\n\t// previously filtered and verified.\n\tlog.Info(\"Starting to migrate withdrawals\", \"no-check\", noCheck)\n\terr = crossdomain.MigrateWithdrawals(filteredWithdrawals, db, &config.L1CrossDomainMessengerProxy, noCheck)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot migrate withdrawals: %w\", err)\n\t}\n\n\t// Finally we migrate the balances held inside the LegacyERC20ETH contract into the state trie.\n\t// We also delete the balances from the LegacyERC20ETH contract. Unlike the steps above, this step\n\t// combines the check and mutation steps into one in order to reduce migration time.\n\tlog.Info(\"Starting to migrate ERC20 ETH\")\n\terr = ether.MigrateBalances(db, dbFactory, migrationData.Addresses(), migrationData.OvmAllowances, int(config.L1ChainID), noCheck)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to migrate OVM_ETH: %w\", err)\n\t}\n\n\t// We're done messing around with the database, so we can now commit the changes to the DB.\n\t// Note that this doesn't actually write the changes to disk.\n\tlog.Info(\"Committing state DB\")\n\tnewRoot, err := db.Commit(true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create the header for the Bedrock transition block.\n\tbedrockHeader := &types.Header{\n\t\tParentHash:  header.Hash(),\n\t\tUncleHash:   types.EmptyUncleHash,\n\t\tCoinbase:    predeploys.SequencerFeeVaultAddr,\n\t\tRoot:        newRoot,\n\t\tTxHash:      types.EmptyRootHash,\n\t\tReceiptHash: types.EmptyRootHash,\n\t\tBloom:       types.Bloom{},\n\t\tDifficulty:  common.Big0,\n\t\tNumber:      new(big.Int).Add(header.Number, common.Big1),\n\t\tGasLimit:    (uint64)(config.L2GenesisBlockGasLimit),\n\t\tGasUsed:     0,\n\t\tTime:        uint64(config.L2OutputOracleStartingTimestamp),\n\t\tExtra:       BedrockTransitionBlockExtraData,\n\t\tMixDigest:   common.Hash{},\n\t\tNonce:       types.BlockNonce{},\n\t\tBaseFee:     big.NewInt(params.InitialBaseFee),\n\t}\n\n\t// Create the Bedrock transition block from the header. Note that there are no transactions,\n\t// uncle blocks, or receipts in the Bedrock transition block.\n\tbedrockBlock := types.NewBlock(bedrockHeader, nil, nil, nil, trie.NewStackTrie(nil))\n\n\t// We did it!\n\tlog.Info(\n\t\t\"Built Bedrock transition\",\n\t\t\"hash\", bedrockBlock.Hash(),\n\t\t\"root\", bedrockBlock.Root(),\n\t\t\"number\", bedrockBlock.NumberU64(),\n\t\t\"gas-used\", bedrockBlock.GasUsed(),\n\t\t\"gas-limit\", bedrockBlock.GasLimit(),\n\t)\n\n\t// Create the result of the migration.\n\tres := &MigrationResult{\n\t\tTransitionHeight:    bedrockBlock.NumberU64(),\n\t\tTransitionTimestamp: bedrockBlock.Time(),\n\t\tTransitionBlockHash: bedrockBlock.Hash(),\n\t}\n\n\t// If we're not actually writing this to disk, then we're done.\n\tif !commit {\n\t\tlog.Info(\"Dry run complete\")\n\t\treturn res, nil\n\t}\n\n\t// Otherwise we need to write the changes to disk. First we commit the state changes.\n\tlog.Info(\"Committing trie DB\")\n\tif err := db.Database().TrieDB().Commit(newRoot, true); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Next we write the Bedrock transition block to the database.\n\trawdb.WriteTd(ldb, bedrockBlock.Hash(), bedrockBlock.NumberU64(), bedrockBlock.Difficulty())\n\trawdb.WriteBlock(ldb, bedrockBlock)\n\trawdb.WriteReceipts(ldb, bedrockBlock.Hash(), bedrockBlock.NumberU64(), nil)\n\trawdb.WriteCanonicalHash(ldb, bedrockBlock.Hash(), bedrockBlock.NumberU64())\n\trawdb.WriteHeadBlockHash(ldb, bedrockBlock.Hash())\n\trawdb.WriteHeadFastBlockHash(ldb, bedrockBlock.Hash())\n\trawdb.WriteHeadHeaderHash(ldb, bedrockBlock.Hash())\n\n\t// Make the first Bedrock block a finalized block.\n\trawdb.WriteFinalizedBlockHash(ldb, bedrockBlock.Hash())\n\n\t// We need to update the chain config to set the correct hardforks.\n\tgenesisHash := rawdb.ReadCanonicalHash(ldb, 0)\n\tcfg := rawdb.ReadChainConfig(ldb, genesisHash)\n\tif cfg == nil {\n\t\tlog.Crit(\"chain config not found\")\n\t}\n\n\t// Set the standard options.\n\tcfg.LondonBlock = bedrockBlock.Number()\n\tcfg.ArrowGlacierBlock = bedrockBlock.Number()\n\tcfg.GrayGlacierBlock = bedrockBlock.Number()\n\tcfg.MergeNetsplitBlock = bedrockBlock.Number()\n\tcfg.TerminalTotalDifficulty = big.NewInt(0)\n\tcfg.TerminalTotalDifficultyPassed = true\n\n\t// Set the Optimism options.\n\tcfg.BedrockBlock = bedrockBlock.Number()\n\t// Enable Regolith from the start of Bedrock\n\tcfg.RegolithTime = new(uint64)\n\tcfg.Optimism = &params.OptimismConfig{\n\t\tEIP1559Denominator: config.EIP1559Denominator,\n\t\tEIP1559Elasticity:  config.EIP1559Elasticity,\n\t}\n\n\t// Write the chain config to disk.\n\trawdb.WriteChainConfig(ldb, genesisHash, cfg)\n\n\t// Yay!\n\tlog.Info(\n\t\t\"wrote chain config\",\n\t\t\"1559-denominator\", config.EIP1559Denominator,\n\t\t\"1559-elasticity\", config.EIP1559Elasticity,\n\t)\n\n\t// We're done!\n\tlog.Info(\n\t\t\"wrote Bedrock transition block\",\n\t\t\"height\", bedrockHeader.Number,\n\t\t\"root\", bedrockHeader.Root.String(),\n\t\t\"hash\", bedrockHeader.Hash().String(),\n\t\t\"timestamp\", bedrockHeader.Time,\n\t)\n\n\t// Return the result and have a nice day.\n\treturn res, nil\n}"
    },
    {
      "filename": "packages/contracts-bedrock/contracts/L2/L2CrossDomainMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { L2ToL1MessagePasser } from \"./L2ToL1MessagePasser.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000007\n * @title L2CrossDomainMessenger\n * @notice The L2CrossDomainMessenger is a high-level interface for message passing between L1 and\n *         L2 on the L2 side. Users are generally encouraged to use this contract instead of lower\n *         level message passing contracts.\n */\ncontract L2CrossDomainMessenger is CrossDomainMessenger, Semver {\n    /**\n     * @custom:semver 1.1.0\n     *\n     * @param _l1CrossDomainMessenger Address of the L1CrossDomainMessenger contract.\n     */\n    constructor(address _l1CrossDomainMessenger)\n        Semver(1, 1, 0)\n        CrossDomainMessenger(_l1CrossDomainMessenger)\n    {\n        initialize();\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize() public initializer {\n        __CrossDomainMessenger_init();\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy getter for the remote messenger. Use otherMessenger going forward.\n     *\n     * @return Address of the L1CrossDomainMessenger contract.\n     */"
    }
  ]
}