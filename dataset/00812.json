{
  "Title": "M-3: Ended locks can be extended",
  "Content": "# Issue M-3: Ended locks can be extended \n\nSource: https://github.com/sherlock-audit/2023-12-truflation-judging/issues/82 \n\n## Found by \nKow, aslanbek, bughuntoor, jerseyjoewalcott, mstpr-brainbot, unforgiven, zzykxx\n## Summary\nWhen a lock period ends, it can be extended. If the new extension 'end' is earlier than the current block.timestamp, the user will have a lock that can be unstaked at any time.\"\n## Vulnerability Detail\nWhen the lock period ends, the owner of the expired lock can extend it to set a new lock end that is earlier than the current block.timestamp. By doing so, the lock owner can create a lock that is unstakeable at any time.\n\nThis is doable because there are no checks in the [extendLock](https://github.com/sherlock-audit/2023-12-truflation/blob/37ddbb69e0c7fb6510f1ec99162fd9172ec44733/truflation-contracts/src/token/VotingEscrowTruf.sol#L333-L366) function that checks whether the lock is already ended or not. \n\nPoC:\n```solidity\nfunction test_ExtendLock_AlreadyEnded() external {\n        uint256 amount = 100e18;\n        uint256 duration = 5 days;\n\n        _stake(amount, duration, alice, alice);\n\n        // 5 days later, lock is ended for Alice\n        skip(5 days + 1);\n\n        (,, uint128 _ends,,) = veTRUF.lockups(alice, 0);\n\n        // Alice's lock is indeed ended\n        assertTrue(_ends < block.timestamp, \"lock is ended\");\n\n        // 36 days passed  \n        skip(36 days);\n\n        // Alice extends her already finished lock 30 more days\n        vm.prank(alice);\n        veTRUF.extendLock(0, 30 days);\n\n        (,,_ends,,) = veTRUF.lockups(alice, 0);\n\n        // Alice's lock can be easily unlocked right away\n        assertTrue(_ends < block.timestamp, \"lock is ended\");\n\n        // Alice unstakes her lock, basically alice can unstake her lock anytime she likes\n        vm.prank(alice);\n        veTRUF.unstake(0);\n    }\n```\n## Impact\nThe owner of the lock will achieve points that he can unlock anytime. This is clearly a gaming of the system and shouldn't be acceptable behaviour. A locker having a \"lock\" that can be unstaked anytime will be unfair for the other lockers. Considering this, I'll label this as high.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-12-truflation/blob/37ddbb69e0c7fb6510f1ec99162fd9172ec44733/truflation-contracts/src/token/VotingEscrowTruf.sol#L333-L366\n## Tool used\n\nManual Review\n\n## Recommendation\nDo not let extension of locks that are already ended.\n\n\n\n## Discussion\n\n**ryuheimat**\n\nhttps://github.com/truflation/truflation-contracts/pull/7\nDisable to extend lock if already expired.\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Shaheen** commented:\n>  Valid issue but Medium. Good Finding\n\n\n\n**securitygrid**\n\nEscalate\nI didn't sumbit this issue because I think this is not an issue: no funds loss, no core function broken.\nThe reason is: Alice is still in the game and has not called `unstake` to exit the game.\n\n\n**nevillehuang**\n\n@ryuheimat I think @securitygrid has a point, and this seems similar to this issue here, might have slipped my judgement\n\nhttps://github.com/sherlock-audit/2023-12-truflation-judging/issues/169\n\nHowever both this and #169 indeed does break the \"locking\" mechanism, given it is expected that funds should be locked within escrows instead of allowing users to simply unlock immediately. I believe both should be at least medium/high severity issues, and could possibly be considered to be duplicates\n\n**sherlock-admin2**\n\n> Escalate\n> I didn't sumbit this issue because I think this is not an issue: no funds loss, no core function broken.\n> The reason is: Alice is still in the game and has not called `unstake` to exit the game.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**detectiveking123**\n\nThis is definitely a valid issue, but it is unclear to me whether it should be labeled as medium or high. \n\n**Czar102**\n\nI believe this is a valid medium. Core functionality – rewarding points for locking tokens – is broken.\n\nFrom my understanding, someone must have locked the tokens in the past and can receive points retroactively, meaning that they effectively can achieve flexible duration locks. This shouldn't be possible and is an important property of the system.\n\n**Czar102**\n\nAlso, I don't think #169 is a duplicate. Can you explain in more detail why would that be the case? @nevillehuang \n\n**nevillehuang**\n\n@Czar102 because they have the same impact, that is there is no “lock” required. I.e. User can gain rewards and retain voting power while still being able to unstake at any time.\n\n**Czar102**\n\nI see now. So effectively, the extension of the lock mentioned here doesn't matter since the identity locking receives points anyway?\n\n**nevillehuang**\n\n@Czar102 yes as long as the lock expires, the user will have no incentive to continue locking, and even if they do, they can unlock the lock at anytime as mentioned here. So I believe they should be duplicated as valid Medium severity.\n\n**Czar102**\n\nPlanning to duplicate these and make the severity Medium.\n\n**aslanbekaibimov**\n\n@Czar102 \n\n> I see now. So effectively, the extension of the lock mentioned here doesn't matter since the identity locking receives points anyway?\n\nIt does matter. #82 describes how the user is able to have voting power **greater** than their original one, while always being able to withdraw. The fix is straightforward - to add a check for the lock's expiration.\n\nOn the other hand, #169 only allows users to **keep** their original voting power from the original lock. The fix of #82 also does not fix #169.\n\n**0xunforgiven**\n\nI don't believe they are duplicates. the only common thing between #82 and #169 is a precondition for the issues. they both happens when a lock expires. but impact and fix and bug place is totally different for them.\n\n#82 explains that after lock expires users can call extend lock and extend their lock. so the issue is in extend function and it can be fixed by simple check in extend function, but this fix won't fix the #169.\n\n#169 explains that after the lock expires users still have voting power and receive rewards. so the issue is in voting mechanism and reward distribution. this issue can't be fixed easily with current design. fixing this will not fix the #82.\n\nmultiple wardens reported these two as separate issues while some wardens missed one of them. issues can't be concluded from each other.\n\n**mstpr**\n\nFix LGTM\n\n**ryuheimat**\n\n> mstpr\n\nMerging...\n\n**Czar102**\n\nRemoving locks after they expire will both remove the voting power (locks don't exist anymore) and make it impossible to retroactively extend the lock (since any ended lock won't exist anymore). This is why I think these are duplicates.\n\n**0xunforgiven**\n\n@Czar102 \nregarding:\n> Removing locks after they expire\n\nin current code only the stacker can remove their own lock. so why should they remove their expired lock? this was their attack to not remove the expired lock and receive the rewards and voting power.\nhe wouldn't remove his own lock(he is the one performing the attack) and as result receive rewards for his expired lock.\n\nthe sponsor in the https://github.com/sherlock-audit/2023-12-truflation-judging/issues/82#issuecomment-1882784243 says that their fix for extending expire lock is this:\n> Disable to extend lock if already expired.\n\nso issue #169 still exists in the code.\n\n\n**Czar102**\n\nI agree it still exists. I still think these issues are duplicates, though instead of fixing the root cause #169, the sponsor decided to mitigate the implication of #169 described here, in #82.\n\nPlease note that the sponsor acknowledged an unfixed duplicate of this issue #169, which has a different impact.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [securitygrid](https://github.com/sherlock-audit/2023-12-truflation-judging/issues/82/#issuecomment-1894969438): accepted\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/151",
  "Code": [
    {
      "filename": "truflation-contracts/src/token/VotingEscrowTruf.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ERC20Votes} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {ERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {RewardsSource} from \"../interfaces/RewardsSource.sol\";\nimport {IVirtualStakingRewards} from \"../interfaces/IVirtualStakingRewards.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\n\n/**\n * @title VotingEscrowTRUF smart contract (modified from Origin Staking for Truflation)\n * @author Ryuhei Matsuda\n * @notice Provides staking, vote power history, vote delegation, and rewards\n * distribution.\n *\n * The balance received for staking (and thus the voting power and rewards\n * distribution) goes up exponentially by the end of the staked period.\n */\n\ncontract VotingEscrowTruf is ERC20Votes, IVotingEscrow {\n    using SafeERC20 for IERC20;\n\n    error ZeroAddress();\n    error ZeroAmount();\n    error Forbidden(address sender);\n    error InvalidAmount();\n    error InvalidAccount();\n    error TransferDisabled();\n    error MaxPointsExceeded();\n    error NoAccess();\n    error LockupAlreadyUnstaked();\n    error LockupNotEnded();\n    error NotIncrease();\n    error NotMigrate();\n    error TooShort();\n    error TooLong();\n\n    // 1. Core Storage\n    /// @dev minimum staking duration in seconds\n    uint256 public immutable minStakeDuration;\n\n    // 2. Staking and Lockup Storage\n    uint256 public constant YEAR_BASE = 18e17;\n\n    /// @dev Maximum duration\n    uint256 public constant MAX_DURATION = 365 days * 3; // 3 years\n\n    /// @dev lockup list per users\n    mapping(address => Lockup[]) public lockups;\n\n    /// @dev TRUF token address\n    IERC20 public immutable trufToken; // Must not allow reentrancy\n\n    /// @dev Virtual staking rewards contract address\n    IVirtualStakingRewards public immutable stakingRewards;\n\n    /// @dev TRUF Vesting contract address\n    address public immutable trufVesting;\n\n    modifier onlyVesting() {\n        if (msg.sender != trufVesting) {\n            revert Forbidden(msg.sender);\n        }\n        _;\n    }\n\n    // 1. Core Functions\n\n    constructor(address _trufToken, address _trufVesting, uint256 _minStakeDuration, address _stakingRewards)\n        ERC20(\"Voting Escrowed TRUF\", \"veTRUF\")\n        ERC20Permit(\"veTRUF\")\n    {\n        trufToken = IERC20(_trufToken);\n        trufVesting = _trufVesting;\n        minStakeDuration = _minStakeDuration;\n        stakingRewards = IVirtualStakingRewards(_stakingRewards);\n    }\n\n    function _transfer(address, address, uint256) internal override {\n        revert TransferDisabled();\n    }\n\n    // 2. Staking and Lockup Functions\n\n    /**\n     * @notice Stake TRUF to an address that may not be the same as the\n     * sender of the funds. This can be used to give staked funds to someone\n     * else.\n     *\n     * @param amount TRUF to lockup in the stake\n     * @param duration in seconds for the stake\n     * @param to address to receive ownership of the stake\n     */\n    function stake(uint256 amount, uint256 duration, address to) external {\n        _stake(amount, duration, to, false);\n    }\n\n    /**\n     * @notice Stake TRUF from vesting\n     * @param amount TRUF to lockup in the stake\n     * @param duration in seconds for the stake\n     * @param to address to receive ownership of the stake\n     * @return lockupId Lockup id\n     */\n    function stakeVesting(uint256 amount, uint256 duration, address to)\n        external\n        onlyVesting\n        returns (uint256 lockupId)\n    {\n        if (to == trufVesting) {\n            revert InvalidAccount();\n        }\n        lockupId = _stake(amount, duration, to, true);\n    }\n\n    /**\n     * @notice Stake TRUF\n     *\n     * @param amount TRUF to lockup in the stake\n     * @param duration in seconds for the stake\n     * @return lockupId Lockup id\n     */\n    function stake(uint256 amount, uint256 duration) external returns (uint256 lockupId) {\n        lockupId = _stake(amount, duration, msg.sender, false);\n    }\n\n    /**\n     * @dev Internal method used for public staking\n     * @param amount TRUF to lockup in the stake\n     * @param duration in seconds for the stake\n     * @param to address to receive ownership of the stake\n     * @param isVesting flag to stake with vested tokens or not\n     * @return lockupId Lockup id\n     */\n    function _stake(uint256 amount, uint256 duration, address to, bool isVesting) internal returns (uint256 lockupId) {\n        if (to == address(0)) {\n            revert ZeroAddress();\n        }\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n        if (amount > type(uint128).max) {\n            revert InvalidAmount();\n        }\n\n        // duration checked inside previewPoints\n        (uint256 points, uint256 end) = previewPoints(amount, duration);\n        if (points + totalSupply() > type(uint192).max) {\n            revert MaxPointsExceeded();\n        }\n\n        lockups[to].push(\n            Lockup({\n                amount: uint128(amount), // max checked in require above\n                duration: uint128(duration),\n                end: uint128(end),\n                points: points,\n                isVesting: isVesting\n            })\n        );\n\n        trufToken.safeTransferFrom(msg.sender, address(this), amount); // Important that it's sender\n\n        stakingRewards.stake(to, points);\n        _mint(to, points);\n\n        if (delegates(to) == address(0)) {\n            // Delegate voting power to the receiver, if unregistered\n            _delegate(to, to);\n        }\n\n        lockupId = lockups[to].length - 1;\n        emit Stake(to, isVesting, lockupId, amount, end, points);\n    }\n\n    /**\n     * @notice Collect staked TRUF for a lockup.\n     * @param lockupId the id of the lockup to unstake\n     * @return amount TRUF amount returned\n     */\n    function unstake(uint256 lockupId) external returns (uint256 amount) {\n        amount = _unstake(msg.sender, lockupId, false, false);\n    }\n\n    /**\n     * @notice Collect staked TRUF for a vesting lockup.\n     * @param user User address\n     * @param lockupId the id of the lockup to unstake\n     * @param force True to unstake before maturity (Used to cancel vesting)\n     * @return amount TRUF amount returned\n     */\n    function unstakeVesting(address user, uint256 lockupId, bool force) external onlyVesting returns (uint256 amount) {\n        amount = _unstake(user, lockupId, true, force);\n    }\n\n    /**\n     * @notice Extend lock duration\n     *\n     * @param lockupId the id of the old lockup to extend\n     * @param duration number of seconds from now to stake for\n     */\n    function extendLock(uint256 lockupId, uint256 duration) external {\n        _extendLock(msg.sender, lockupId, duration, false);\n    }\n\n    /**\n     * @notice Extend lock duration for vesting\n     *\n     * @param duration number of seconds from now to stake for\n     */\n    function extendVestingLock(address user, uint256 lockupId, uint256 duration) external onlyVesting {\n        _extendLock(user, lockupId, duration, true);\n    }\n\n    /**\n     * @notice Migrate lock to another user\n     * @param oldUser Old user address\n     * @param newUser New user address\n     * @param lockupId the id of the old user's lockup to migrate\n     * @return newLockupId the id of new user's migrated lockup\n     */\n    function migrateVestingLock(address oldUser, address newUser, uint256 lockupId)\n        external\n        onlyVesting\n        returns (uint256 newLockupId)\n    {\n        if (oldUser == newUser) {\n            revert NotMigrate();\n        }\n        if (newUser == address(0)) {\n            revert ZeroAddress();\n        }\n        Lockup memory oldLockup = lockups[oldUser][lockupId];\n        if (!oldLockup.isVesting) {\n            revert NoAccess();\n        }\n\n        uint256 points = oldLockup.points;\n        stakingRewards.withdraw(oldUser, points);\n        _burn(oldUser, points);\n\n        newLockupId = lockups[newUser].length;\n        lockups[newUser].push(oldLockup);\n        _mint(newUser, points);\n        stakingRewards.stake(newUser, points);\n\n        delete lockups[oldUser][lockupId];\n\n        emit Migrated(oldUser, newUser, lockupId, newLockupId);\n    }\n\n    /**\n     * @notice Claim TRUF staking rewards\n     */\n    function claimReward() external {\n        stakingRewards.getReward(msg.sender);\n    }\n\n    /**\n     * @notice Preview the number of points that would be returned for the\n     * given amount and duration.\n     *\n     * @param amount TRUF to be staked\n     * @param duration number of seconds to stake for\n     * @return points staking points that would be returned\n     * @return end staking period end date\n     */\n    function previewPoints(uint256 amount, uint256 duration) public view returns (uint256 points, uint256 end) {\n        if (duration < minStakeDuration) {\n            revert TooShort();\n        }\n        if (duration > MAX_DURATION) {\n            revert TooLong();\n        }\n\n        points = amount * duration / MAX_DURATION;\n        end = block.timestamp + duration;\n    }\n\n    /**\n     * @notice Interal function to unstake\n     * @param user User address\n     * @param lockupId the id of the lockup to unstake\n     * @param isVesting flag to stake with vested tokens or not\n     * @param force unstake before end period (used to force unstake for vesting lock)\n     */\n    function _unstake(address user, uint256 lockupId, bool isVesting, bool force) internal returns (uint256 amount) {\n        Lockup memory lockup = lockups[user][lockupId];\n        if (lockup.isVesting != isVesting) {\n            revert NoAccess();\n        }\n        amount = lockup.amount;\n        uint256 end = lockup.end;\n        uint256 points = lockup.points;\n        if (end == 0) {\n            revert LockupAlreadyUnstaked();\n        }\n        if (!force && block.timestamp < end) {\n            revert LockupNotEnded();\n        }\n        delete lockups[user][lockupId]; // Keeps empty in array, so indexes are stable\n\n        stakingRewards.withdraw(user, points);\n        _burn(user, points);\n        trufToken.safeTransfer(msg.sender, amount); // Sender is msg.sender\n\n        emit Unstake(user, isVesting, lockupId, amount, end, points);\n\n        if (block.timestamp < end) {\n            emit Cancelled(user, lockupId, amount, points);\n        }\n    }\n\n    /**\n     * @notice Extend lock duration\n     *\n     * The stake end time is computed from the current time + duration, just\n     * like it is for new stakes. So a new stake for seven days duration and\n     * an old stake extended with a seven days duration would have the same\n     * end.\n     *\n     * If an extend is made before the start of staking, the start time for\n     * the new stake is shifted forwards to the start of staking, which also\n     * shifts forward the end date.\n     *\n     * @param user user address\n     * @param lockupId the id of the old lockup to extend\n     * @param duration number of seconds from now to stake for\n     * @param isVesting true if called from vesting\n     */\n    function _extendLock(address user, uint256 lockupId, uint256 duration, bool isVesting) internal {\n        // duration checked inside previewPoints\n        Lockup memory lockup = lockups[user][lockupId];\n        if (lockup.isVesting != isVesting) {\n            revert NoAccess();\n        }\n\n        uint256 amount = lockup.amount;\n        uint256 oldEnd = lockup.end;\n        uint256 oldPoints = lockup.points;\n        uint256 newDuration = lockup.duration + duration;\n\n        (uint256 newPoints,) = previewPoints(amount, newDuration);\n\n        if (newPoints <= oldPoints) {\n            revert NotIncrease();\n        }\n\n        uint256 newEnd = oldEnd + duration;\n\n        uint256 mintAmount = newPoints - oldPoints;\n\n        lockup.end = uint128(newEnd);\n        lockup.duration = uint128(newDuration);\n        lockup.points = newPoints;\n\n        lockups[user][lockupId] = lockup;\n\n        stakingRewards.stake(user, mintAmount);\n        _mint(user, mintAmount);\n\n        emit Unstake(user, isVesting, lockupId, amount, oldEnd, oldPoints);\n        emit Stake(user, isVesting, lockupId, amount, newEnd, newPoints);\n    }\n}"
    },
    {
      "filename": "truflation-contracts/src/token/VotingEscrowTruf.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {ERC20Votes} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {ERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {RewardsSource} from \"../interfaces/RewardsSource.sol\";\nimport {IVirtualStakingRewards} from \"../interfaces/IVirtualStakingRewards.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\n\n/**\n * @title VotingEscrowTRUF smart contract (modified from Origin Staking for Truflation)\n * @author Ryuhei Matsuda\n * @notice Provides staking, vote power history, vote delegation, and rewards\n * distribution.\n *\n * The balance received for staking (and thus the voting power and rewards\n * distribution) goes up exponentially by the end of the staked period.\n */\n\ncontract VotingEscrowTruf is ERC20Votes, IVotingEscrow {\n    using SafeERC20 for IERC20;\n\n    error ZeroAddress();\n    error ZeroAmount();\n    error Forbidden(address sender);\n    error InvalidAmount();\n    error InvalidAccount();\n    error TransferDisabled();\n    error MaxPointsExceeded();\n    error NoAccess();\n    error LockupAlreadyUnstaked();\n    error LockupNotEnded();\n    error NotIncrease();\n    error NotMigrate();\n    error TooShort();\n    error TooLong();\n\n    // 1. Core Storage\n    /// @dev minimum staking duration in seconds\n    uint256 public immutable minStakeDuration;\n\n    // 2. Staking and Lockup Storage\n    uint256 public constant YEAR_BASE = 18e17;\n\n    /// @dev Maximum duration\n    uint256 public constant MAX_DURATION = 365 days * 3; // 3 years\n\n    /// @dev lockup list per users\n    mapping(address => Lockup[]) public lockups;\n\n    /// @dev TRUF token address\n    IERC20 public immutable trufToken; // Must not allow reentrancy\n\n    /// @dev Virtual staking rewards contract address\n    IVirtualStakingRewards public immutable stakingRewards;\n\n    /// @dev TRUF Vesting contract address\n    address public immutable trufVesting;\n\n    modifier onlyVesting() {\n        if (msg.sender != trufVesting) {\n            revert Forbidden(msg.sender);\n        }\n        _;\n    }\n\n    // 1. Core Functions\n\n    constructor(address _trufToken, address _trufVesting, uint256 _minStakeDuration, address _stakingRewards)\n        ERC20(\"Voting Escrowed TRUF\", \"veTRUF\")\n        ERC20Permit(\"veTRUF\")\n    {\n        trufToken = IERC20(_trufToken);\n        trufVesting = _trufVesting;\n        minStakeDuration = _minStakeDuration;\n        stakingRewards = IVirtualStakingRewards(_stakingRewards);\n    }\n\n    function _transfer(address, address, uint256) internal override {\n        revert TransferDisabled();\n    }\n\n    // 2. Staking and Lockup Functions\n\n    /**\n     * @notice Stake TRUF to an address that may not be the same as the\n     * sender of the funds. This can be used to give staked funds to someone\n     * else.\n     *\n     * @param amount TRUF to lockup in the stake\n     * @param duration in seconds for the stake\n     * @param to address to receive ownership of the stake\n     */\n    function stake(uint256 amount, uint256 duration, address to) external {\n        _stake(amount, duration, to, false);\n    }\n\n    /**\n     * @notice Stake TRUF from vesting\n     * @param amount TRUF to lockup in the stake\n     * @param duration in seconds for the stake\n     * @param to address to receive ownership of the stake\n     * @return lockupId Lockup id\n     */\n    function stakeVesting(uint256 amount, uint256 duration, address to)\n        external\n        onlyVesting\n        returns (uint256 lockupId)\n    {\n        if (to == trufVesting) {\n            revert InvalidAccount();\n        }\n        lockupId = _stake(amount, duration, to, true);\n    }\n\n    /**\n     * @notice Stake TRUF\n     *\n     * @param amount TRUF to lockup in the stake\n     * @param duration in seconds for the stake\n     * @return lockupId Lockup id\n     */\n    function stake(uint256 amount, uint256 duration) external returns (uint256 lockupId) {\n        lockupId = _stake(amount, duration, msg.sender, false);\n    }\n\n    /**\n     * @dev Internal method used for public staking\n     * @param amount TRUF to lockup in the stake\n     * @param duration in seconds for the stake\n     * @param to address to receive ownership of the stake\n     * @param isVesting flag to stake with vested tokens or not\n     * @return lockupId Lockup id\n     */\n    function _stake(uint256 amount, uint256 duration, address to, bool isVesting) internal returns (uint256 lockupId) {\n        if (to == address(0)) {\n            revert ZeroAddress();\n        }\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n        if (amount > type(uint128).max) {\n            revert InvalidAmount();\n        }\n\n        // duration checked inside previewPoints\n        (uint256 points, uint256 end) = previewPoints(amount, duration);\n        if (points + totalSupply() > type(uint192).max) {\n            revert MaxPointsExceeded();\n        }\n\n        lockups[to].push(\n            Lockup({\n                amount: uint128(amount), // max checked in require above\n                duration: uint128(duration),\n                end: uint128(end),\n                points: points,\n                isVesting: isVesting\n            })\n        );\n\n        trufToken.safeTransferFrom(msg.sender, address(this), amount); // Important that it's sender\n\n        stakingRewards.stake(to, points);\n        _mint(to, points);\n\n        if (delegates(to) == address(0)) {\n            // Delegate voting power to the receiver, if unregistered\n            _delegate(to, to);\n        }\n\n        lockupId = lockups[to].length - 1;\n        emit Stake(to, isVesting, lockupId, amount, end, points);\n    }\n\n    /**\n     * @notice Collect staked TRUF for a lockup.\n     * @param lockupId the id of the lockup to unstake\n     * @return amount TRUF amount returned\n     */\n    function unstake(uint256 lockupId) external returns (uint256 amount) {\n        amount = _unstake(msg.sender, lockupId, false, false);\n    }\n\n    /**\n     * @notice Collect staked TRUF for a vesting lockup.\n     * @param user User address\n     * @param lockupId the id of the lockup to unstake\n     * @param force True to unstake before maturity (Used to cancel vesting)\n     * @return amount TRUF amount returned\n     */\n    function unstakeVesting(address user, uint256 lockupId, bool force) external onlyVesting returns (uint256 amount) {\n        amount = _unstake(user, lockupId, true, force);\n    }\n\n    /**\n     * @notice Extend lock duration\n     *\n     * @param lockupId the id of the old lockup to extend\n     * @param duration number of seconds from now to stake for\n     */\n    function extendLock(uint256 lockupId, uint256 duration) external {\n        _extendLock(msg.sender, lockupId, duration, false);\n    }\n\n    /**\n     * @notice Extend lock duration for vesting\n     *\n     * @param duration number of seconds from now to stake for\n     */\n    function extendVestingLock(address user, uint256 lockupId, uint256 duration) external onlyVesting {\n        _extendLock(user, lockupId, duration, true);\n    }\n\n    /**\n     * @notice Migrate lock to another user\n     * @param oldUser Old user address\n     * @param newUser New user address\n     * @param lockupId the id of the old user's lockup to migrate\n     * @return newLockupId the id of new user's migrated lockup\n     */\n    function migrateVestingLock(address oldUser, address newUser, uint256 lockupId)\n        external\n        onlyVesting\n        returns (uint256 newLockupId)\n    {\n        if (oldUser == newUser) {\n            revert NotMigrate();\n        }\n        if (newUser == address(0)) {\n            revert ZeroAddress();\n        }\n        Lockup memory oldLockup = lockups[oldUser][lockupId];\n        if (!oldLockup.isVesting) {\n            revert NoAccess();\n        }\n\n        uint256 points = oldLockup.points;\n        stakingRewards.withdraw(oldUser, points);\n        _burn(oldUser, points);\n\n        newLockupId = lockups[newUser].length;\n        lockups[newUser].push(oldLockup);\n        _mint(newUser, points);\n        stakingRewards.stake(newUser, points);\n\n        delete lockups[oldUser][lockupId];\n\n        emit Migrated(oldUser, newUser, lockupId, newLockupId);\n    }\n\n    /**\n     * @notice Claim TRUF staking rewards\n     */\n    function claimReward() external {\n        stakingRewards.getReward(msg.sender);\n    }\n\n    /**\n     * @notice Preview the number of points that would be returned for the\n     * given amount and duration.\n     *\n     * @param amount TRUF to be staked\n     * @param duration number of seconds to stake for\n     * @return points staking points that would be returned\n     * @return end staking period end date\n     */\n    function previewPoints(uint256 amount, uint256 duration) public view returns (uint256 points, uint256 end) {\n        if (duration < minStakeDuration) {\n            revert TooShort();\n        }\n        if (duration > MAX_DURATION) {\n            revert TooLong();\n        }\n\n        points = amount * duration / MAX_DURATION;\n        end = block.timestamp + duration;\n    }\n\n    /**\n     * @notice Interal function to unstake\n     * @param user User address\n     * @param lockupId the id of the lockup to unstake\n     * @param isVesting flag to stake with vested tokens or not\n     * @param force unstake before end period (used to force unstake for vesting lock)\n     */\n    function _unstake(address user, uint256 lockupId, bool isVesting, bool force) internal returns (uint256 amount) {\n        Lockup memory lockup = lockups[user][lockupId];\n        if (lockup.isVesting != isVesting) {\n            revert NoAccess();\n        }\n        amount = lockup.amount;\n        uint256 end = lockup.end;\n        uint256 points = lockup.points;\n        if (end == 0) {\n            revert LockupAlreadyUnstaked();\n        }\n        if (!force && block.timestamp < end) {\n            revert LockupNotEnded();\n        }\n        delete lockups[user][lockupId]; // Keeps empty in array, so indexes are stable\n\n        stakingRewards.withdraw(user, points);\n        _burn(user, points);\n        trufToken.safeTransfer(msg.sender, amount); // Sender is msg.sender\n\n        emit Unstake(user, isVesting, lockupId, amount, end, points);\n\n        if (block.timestamp < end) {\n            emit Cancelled(user, lockupId, amount, points);\n        }\n    }\n\n    /**\n     * @notice Extend lock duration\n     *\n     * The stake end time is computed from the current time + duration, just\n     * like it is for new stakes. So a new stake for seven days duration and\n     * an old stake extended with a seven days duration would have the same\n     * end.\n     *\n     * If an extend is made before the start of staking, the start time for\n     * the new stake is shifted forwards to the start of staking, which also\n     * shifts forward the end date.\n     *\n     * @param user user address\n     * @param lockupId the id of the old lockup to extend\n     * @param duration number of seconds from now to stake for\n     * @param isVesting true if called from vesting\n     */\n    function _extendLock(address user, uint256 lockupId, uint256 duration, bool isVesting) internal {\n        // duration checked inside previewPoints\n        Lockup memory lockup = lockups[user][lockupId];\n        if (lockup.isVesting != isVesting) {\n            revert NoAccess();\n        }\n\n        uint256 amount = lockup.amount;\n        uint256 oldEnd = lockup.end;\n        uint256 oldPoints = lockup.points;\n        uint256 newDuration = lockup.duration + duration;\n\n        (uint256 newPoints,) = previewPoints(amount, newDuration);\n\n        if (newPoints <= oldPoints) {\n            revert NotIncrease();\n        }\n\n        uint256 newEnd = oldEnd + duration;\n\n        uint256 mintAmount = newPoints - oldPoints;\n\n        lockup.end = uint128(newEnd);\n        lockup.duration = uint128(newDuration);\n        lockup.points = newPoints;\n\n        lockups[user][lockupId] = lockup;\n\n        stakingRewards.stake(user, mintAmount);\n        _mint(user, mintAmount);\n\n        emit Unstake(user, isVesting, lockupId, amount, oldEnd, oldPoints);\n        emit Stake(user, isVesting, lockupId, amount, newEnd, newPoints);\n    }\n}"
    }
  ]
}