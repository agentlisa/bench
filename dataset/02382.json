{
  "Title": "H-7: Sybil on withdrawal requests can allow leverage factor manipulation with flashloans",
  "Content": "# Issue H-7: Sybil on withdrawal requests can allow leverage factor manipulation with flashloans \n\nSource: https://github.com/sherlock-audit/2023-02-carapace-judging/issues/116 \n\n## Found by \nlibratus, ck, clems4ever, 0x52, mahdikarimi\n\n## Summary\nTo be able to withdraw, a user has to request a withdraw first. The only requirement to be able to request a withdraw is to have a balance of SToken upon requesting. By requesting withdraws with the same tokens but from different addresses, a malicious user can create the option to withdraw during one cycle more than what is deposited in the protocol. They cannot drain the protocol since they only have a limited amount of SToken to burn (required to call `withdraw()`), but they acquire the ability to deposit new funds and withdraw them in the same block, thus manipulating premium prices.\n\n## Vulnerability Detail\nConsider the following scenario:\nA malicious user wants to manipulate `leverageRatio` (to get a cheaper premium for example).\n\nThey deposit 10k USDC into the protocol, and get 10k STokens.\nThey request immediately a withdraw, and transfer STokens to another address and request a withdraw there, repeating the process 10 times.\n\nThis works since balance is checked on requesting withdrawal but not locked or committed:\nhttps://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/pool/ProtectionPool.sol#L992-L995\n\n2 cycles later (actually ~1 cycle if the timing is optimized), they have the ability to take a flashloan for 100k USDC, deposit through the 10 addresses used, enjoy the cheaper premium as a protection buyer due to `leverageFactor` being high and withdraw all in the same transaction. \n\nThey can safely repay the flash loan.\n\n## Impact\nProtection buyers can use this to: \n- game premium prices, meaning that protection sellers get rugged.\n- overprotect their lending positions (used in conjunction with HIGH-02, it can drain the whole protection pool if lending pool defaults).\n- DOS the protocol by sending the leverage factor very high.\n\n## Code Snippet\n\n## Tool used\nManual Review\n\n## Recommendation\nFreeze STokens for a depositor once they requested a withdrawal.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/40",
  "Code": [
    {
      "filename": "contracts/core/pool/ProtectionPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {EnumerableSetUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport {IERC20MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {UUPSUpgradeableBase} from \"../../UUPSUpgradeableBase.sol\";\nimport {SToken} from \"./SToken.sol\";\nimport {IPremiumCalculator} from \"../../interfaces/IPremiumCalculator.sol\";\nimport {IReferenceLendingPools, LendingPoolStatus, ProtectionPurchaseParams} from \"../../interfaces/IReferenceLendingPools.sol\";\nimport {IProtectionPoolCycleManager, ProtectionPoolCycleState} from \"../../interfaces/IProtectionPoolCycleManager.sol\";\nimport {IProtectionPool, ProtectionPoolParams, ProtectionPoolInfo, ProtectionInfo, LendingPoolDetail, WithdrawalCycleDetail, ProtectionBuyerAccount, ProtectionPoolPhase} from \"../../interfaces/IProtectionPool.sol\";\nimport {IDefaultStateManager} from \"../../interfaces/IDefaultStateManager.sol\";\n\nimport \"../../libraries/AccruedPremiumCalculator.sol\";\nimport \"../../libraries/Constants.sol\";\nimport \"../../libraries/ProtectionPoolHelper.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title ProtectionPool\n * @author Carapace Finance\n * @notice ProtectionPool is the core contract of the protocol.\n * Each protection pool is a market where protection sellers\n * and buyers can swap credit default risks of designated/referenced underlying loans.\n * Protection buyers purchase protections by paying a premium in underlying tokens to the pool.\n * Protection sellers deposit underlying tokens into the pool and receives proportionate shares of STokens.\n * Protection sellers can withdraw their underlying tokens from the pool after requesting a withdrawal\n * and only during the open period following the next pool cycle's end.\n *\n * This contract is upgradeable using the UUPS pattern.\n */\ncontract ProtectionPool is\n  UUPSUpgradeableBase,\n  ReentrancyGuardUpgradeable,\n  IProtectionPool,\n  SToken\n{\n  /*** libraries ***/\n  using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n  using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n  //////////////////////////////////////////////////////\n  ///             STORAGE- START                   ///\n  /////////////////////////////////////////////////////\n  /**\n   * @dev DO NOT CHANGE THE ORDER OF THESE VARIABLES ONCE DEPLOYED\n   */\n\n  /// @notice Reference to the PremiumPricing contract\n  IPremiumCalculator private premiumCalculator;\n\n  /// @notice Reference to the ProtectionPoolCycleManager contract\n  IProtectionPoolCycleManager private poolCycleManager;\n\n  /// @notice Reference to default state manager contract\n  IDefaultStateManager private defaultStateManager;\n\n  /// @notice information about this protection pool\n  ProtectionPoolInfo private poolInfo;\n\n  /// @notice The total underlying amount of premium paid to the pool by protection buyers\n  uint256 private totalPremium;\n\n  /// @notice The total underlying amount of protection bought from this pool by protection buyers\n  uint256 private totalProtection;\n\n  /// @notice The total premium accrued in underlying token up to the last premium accrual timestamp\n  uint256 private totalPremiumAccrued;\n\n  /**\n   * @notice The total underlying amount in the pool backing the value of STokens.\n   * @notice This is the total capital deposited by sellers + accrued premiums from buyers - locked capital - default payouts.\n   */\n  uint256 private totalSTokenUnderlying;\n\n  /// @notice The array to track all protections bought from this pool\n  /// @dev This array has dummy element at index 0 to validate the index of the protection\n  ProtectionInfo[] private protectionInfos;\n\n  /// @notice The mapping to track pool cycle index at which actual withdrawal will happen to withdrawal details\n  mapping(uint256 => WithdrawalCycleDetail) private withdrawalCycleDetails;\n\n  /// @notice The mapping to track all lending pool details by address\n  mapping(address => LendingPoolDetail) private lendingPoolDetails;\n\n  /// @notice The mapping to track all protection buyer accounts by address\n  mapping(address => ProtectionBuyerAccount) private protectionBuyerAccounts;\n\n  //////////////////////////////////////////////////////\n  ///             STORAGE - END                     ///\n  /////////////////////////////////////////////////////\n\n  /*** modifiers ***/\n\n  /// @notice Checks whether pool cycle is in open state. If not, reverts.\n  /// @dev This modifier is used to restrict certain functions to be called only during the open period of a pool cycle.\n  /// @dev This modifier also updates the pool cycle state before verifying the state.\n  modifier whenPoolIsOpen() {\n    /// Update the pool cycle state\n    ProtectionPoolCycleState cycleState = poolCycleManager\n      .calculateAndSetPoolCycleState(address(this));\n\n    if (cycleState != ProtectionPoolCycleState.Open) {\n      revert ProtectionPoolIsNotOpen();\n    }\n    _;\n  }\n\n  /// @notice Checks caller is DefaultStateManager contract. If not, reverts.\n  /// @dev This modifier is used to restrict certain functions to be called only by the DefaultStateManager contract.\n  modifier onlyDefaultStateManager() {\n    if (msg.sender != address(defaultStateManager)) {\n      revert OnlyDefaultStateManager(msg.sender);\n    }\n    _;\n  }\n\n  /*** initializer ***/\n\n  /// @inheritdoc IProtectionPool\n  function initialize(\n    address _owner,\n    ProtectionPoolInfo calldata _poolInfo,\n    IPremiumCalculator _premiumCalculator,\n    IProtectionPoolCycleManager _poolCycleManager,\n    IDefaultStateManager _defaultStateManager,\n    string calldata _name,\n    string calldata _symbol\n  ) external override initializer {\n    /// initialize parent contracts in same order as they are inherited to mimic the behavior of a constructor\n    __UUPSUpgradeableBase_init();\n    __ReentrancyGuard_init();\n    __sToken_init(_name, _symbol);\n\n    /// set the storage variables\n    poolInfo = _poolInfo;\n    premiumCalculator = _premiumCalculator;\n    poolCycleManager = _poolCycleManager;\n    defaultStateManager = _defaultStateManager;\n\n    emit ProtectionPoolInitialized(\n      _name,\n      _symbol,\n      poolInfo.underlyingToken,\n      poolInfo.referenceLendingPools\n    );\n\n    /// Transfer the ownership of this pool to the specified owner\n    _transferOwnership(_owner);\n\n    /// Add dummy protection info to make index 0 invalid\n    protectionInfos.push();\n  }\n\n  /*** state-changing functions ***/\n\n  /// @inheritdoc IProtectionPool\n  function buyProtection(\n    ProtectionPurchaseParams calldata _protectionPurchaseParams,\n    uint256 _maxPremiumAmount\n  ) external override whenNotPaused nonReentrant {\n    /// Verify that user can buy protection and then create protection\n    _verifyAndCreateProtection(\n      block.timestamp,\n      _protectionPurchaseParams,\n      _maxPremiumAmount,\n      false\n    );\n  }\n\n  /// @inheritdoc IProtectionPool\n  function renewProtection(\n    ProtectionPurchaseParams calldata _protectionPurchaseParams,\n    uint256 _maxPremiumAmount\n  ) external override whenNotPaused nonReentrant {\n    /// Verify that user can renew protection\n    ProtectionPoolHelper.verifyBuyerCanRenewProtection(\n      protectionBuyerAccounts,\n      protectionInfos,\n      _protectionPurchaseParams,\n      poolInfo.params.protectionRenewalGracePeriodInSeconds\n    );\n\n    /// Verify that user can buy protection and then create a new protection for renewal\n    _verifyAndCreateProtection(\n      block.timestamp,\n      _protectionPurchaseParams,\n      _maxPremiumAmount,\n      true\n    );\n  }\n\n  /// @inheritdoc IProtectionPool\n  function deposit(uint256 _underlyingAmount, address _receiver)\n    external\n    override\n    whenNotPaused\n    nonReentrant\n  {\n    _deposit(_underlyingAmount, _receiver);\n  }\n\n  /// @inheritdoc IProtectionPool\n  function requestWithdrawal(uint256 _sTokenAmount)\n    external\n    override\n    whenNotPaused\n  {\n    _requestWithdrawal(_sTokenAmount);\n  }\n\n  /// @inheritdoc IProtectionPool\n  function depositAndRequestWithdrawal(\n    uint256 _underlyingAmountToDeposit,\n    uint256 _sTokenAmountToWithdraw\n  ) external virtual override whenNotPaused nonReentrant {\n    _deposit(_underlyingAmountToDeposit, msg.sender);\n    _requestWithdrawal(_sTokenAmountToWithdraw);\n  }\n\n  /// @inheritdoc IProtectionPool\n  function withdraw(uint256 _sTokenWithdrawalAmount, address _receiver)\n    external\n    override\n    whenPoolIsOpen\n    whenNotPaused\n    nonReentrant\n  {\n    /// Step 1: Retrieve withdrawal details for current pool cycle index\n    uint256 _currentCycleIndex = poolCycleManager.getCurrentCycleIndex(\n      address(this)\n    );\n    WithdrawalCycleDetail storage withdrawalCycle = withdrawalCycleDetails[\n      _currentCycleIndex\n    ];\n\n    /// Step 2: Verify withdrawal request exists in this withdrawal cycle for the user\n    uint256 _sTokenRequested = withdrawalCycle.withdrawalRequests[msg.sender];\n    if (_sTokenRequested == 0) {\n      revert NoWithdrawalRequested(msg.sender, _currentCycleIndex);\n    }\n\n    /// Step 3: Verify that withdrawal amount is not more than the requested amount.\n    if (_sTokenWithdrawalAmount > _sTokenRequested) {\n      revert WithdrawalHigherThanRequested(msg.sender, _sTokenRequested);\n    }\n\n    /// Step 4: calculate underlying amount to transfer based on sToken withdrawal amount\n    uint256 _underlyingAmountToTransfer = convertToUnderlying(\n      _sTokenWithdrawalAmount\n    );\n\n    /// Step 5: burn sTokens shares.\n    /// This step must be done after calculating underlying amount to be transferred\n    _burn(msg.sender, _sTokenWithdrawalAmount);\n\n    /// Step 6: Update total sToken underlying amount\n    totalSTokenUnderlying -= _underlyingAmountToTransfer;\n\n    /// Step 7: update seller's withdrawal amount and total requested withdrawal amount\n    withdrawalCycle.withdrawalRequests[msg.sender] -= _sTokenWithdrawalAmount;\n    withdrawalCycle.totalSTokenRequested -= _sTokenWithdrawalAmount;\n\n    /// Step 8: transfer underlying token to receiver\n    poolInfo.underlyingToken.safeTransfer(\n      _receiver,\n      _underlyingAmountToTransfer\n    );\n\n    emit WithdrawalMade(msg.sender, _sTokenWithdrawalAmount, _receiver);\n  }\n\n  /// @inheritdoc IProtectionPool\n  /// @dev Can't use 'calldata` for _lendingPools parameter because of potential re-assignment in the function\n  function accruePremiumAndExpireProtections(address[] memory _lendingPools)\n    external\n    override\n  {\n    /// When no lending pools are passed, accrue premium for all lending pools\n    if (_lendingPools.length == 0) {\n      _lendingPools = poolInfo.referenceLendingPools.getLendingPools();\n    }\n\n    /// Track total premium accrued and protection removed for all lending pools\n    uint256 _totalPremiumAccrued;\n    uint256 _totalProtectionRemoved;\n\n    /// Iterate all lending pools of this protection pool to check if there is new payment after last premium accrual\n    uint256 length = _lendingPools.length;\n    for (uint256 _lendingPoolIndex; _lendingPoolIndex < length; ) {\n      /// Retrieve lending pool detail from the storage\n      address _lendingPool = _lendingPools[_lendingPoolIndex];\n      LendingPoolDetail storage lendingPoolDetail = lendingPoolDetails[\n        _lendingPool\n      ];\n\n      /// Get the latest payment timestamp for the lending pool\n      uint256 _latestPaymentTimestamp = poolInfo\n        .referenceLendingPools\n        .getLatestPaymentTimestamp(_lendingPool);\n\n      /// Get the last premium accrual timestamp for the lending pool from the storage\n      uint256 _lastPremiumAccrualTimestamp = lendingPoolDetail\n        .lastPremiumAccrualTimestamp;\n\n      console.log(\n        \"lendingPool: %s, lastPremiumAccrualTimestamp: %s, latestPaymentTimestamp: %s\",\n        _lendingPool,\n        _lastPremiumAccrualTimestamp,\n        _latestPaymentTimestamp\n      );\n\n      /// Iterate all active protections for this lending pool and\n      /// accrue premium and expire protections if there is new payment\n      (\n        uint256 _accruedPremiumForLendingPool,\n        uint256 _totalProtectionRemovedForLendingPool\n      ) = _accruePremiumAndExpireProtections(\n          lendingPoolDetail,\n          _lastPremiumAccrualTimestamp,\n          _latestPaymentTimestamp\n        );\n      _totalPremiumAccrued += _accruedPremiumForLendingPool;\n      _totalProtectionRemoved += _totalProtectionRemovedForLendingPool;\n\n      /// Persist the last premium accrual of the lending pool in the storage,\n      /// only if there was premium accrued\n      if (_accruedPremiumForLendingPool > 0) {\n        lendingPoolDetail.lastPremiumAccrualTimestamp = _latestPaymentTimestamp;\n\n        emit PremiumAccrued(_lendingPool, _latestPaymentTimestamp);\n      }\n\n      unchecked {\n        ++_lendingPoolIndex;\n      }\n    }\n\n    /// Gas optimization: only update storage vars if there was premium accrued\n    if (_totalPremiumAccrued > 0) {\n      totalPremiumAccrued += _totalPremiumAccrued;\n      totalSTokenUnderlying += _totalPremiumAccrued;\n    }\n\n    /// Reduce the total protection amount of this protection pool\n    /// by the total protection amount of the expired protections\n    if (_totalProtectionRemoved > 0) {\n      totalProtection -= _totalProtectionRemoved;\n    }\n  }\n\n  /// @inheritdoc IProtectionPool\n  function lockCapital(address _lendingPoolAddress)\n    external\n    payable\n    override\n    onlyDefaultStateManager\n    whenNotPaused\n    returns (uint256 _lockedAmount, uint256 _snapshotId)\n  {\n    /// step 1: Capture protection pool's current investors by creating a snapshot of the token balance by using ERC20Snapshot in SToken\n    _snapshotId = _snapshot();\n\n    /// step 2: calculate total capital to be locked\n    LendingPoolDetail storage lendingPoolDetail = lendingPoolDetails[\n      _lendingPoolAddress\n    ];\n\n    /// Get indexes of active protection for a lending pool from the storage\n    EnumerableSetUpgradeable.UintSet\n      storage activeProtectionIndexes = lendingPoolDetail\n        .activeProtectionIndexes;\n\n    /// Iterate all active protections and calculate total locked amount for this lending pool\n    /// 1. calculate remaining principal amount for each loan protection in the lending pool.\n    /// 2. for each loan protection, lockedAmt = min(protectionAmt, remainingPrincipal)\n    /// 3. total locked amount = sum of lockedAmt for all loan protections\n    uint256 _length = activeProtectionIndexes.length();\n    for (uint256 i; i < _length; ) {\n      /// Get protection info from the storage\n      uint256 _protectionIndex = activeProtectionIndexes.at(i);\n      ProtectionInfo storage protectionInfo = protectionInfos[_protectionIndex];\n\n      /// Calculate remaining principal amount for a loan protection in the lending pool\n      uint256 _remainingPrincipal = poolInfo\n        .referenceLendingPools\n        .calculateRemainingPrincipal(\n          _lendingPoolAddress,\n          protectionInfo.buyer,\n          protectionInfo.purchaseParams.nftLpTokenId\n        );\n\n      /// Locked amount is minimum of protection amount and remaining principal\n      uint256 _protectionAmount = protectionInfo\n        .purchaseParams\n        .protectionAmount;\n      uint256 _lockedAmountPerProtection = _protectionAmount <\n        _remainingPrincipal\n        ? _protectionAmount\n        : _remainingPrincipal;\n\n      _lockedAmount += _lockedAmountPerProtection;\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    unchecked {\n      /// step 3: Update total locked & available capital in storage\n      if (totalSTokenUnderlying < _lockedAmount) {\n        /// If totalSTokenUnderlying < _lockedAmount, then lock all available capital\n        _lockedAmount = totalSTokenUnderlying;\n        totalSTokenUnderlying = 0;\n      } else {\n        /// Reduce the total sToken underlying amount by the locked amount\n        totalSTokenUnderlying -= _lockedAmount;\n      }\n    }\n  }\n\n  /// @inheritdoc IProtectionPool\n  function claimUnlockedCapital(address _receiver)\n    external\n    override\n    whenNotPaused\n  {\n    /// Investors can claim their total share of released/unlocked capital across all lending pools\n    uint256 _claimableAmount = defaultStateManager\n      .calculateAndClaimUnlockedCapital(msg.sender);\n\n    if (_claimableAmount > 0) {\n      console.log(\n        \"Total sToken underlying: %s, claimableAmount: %s\",\n        totalSTokenUnderlying,\n        _claimableAmount\n      );\n      /// transfer the share of unlocked capital to the receiver\n      poolInfo.underlyingToken.safeTransfer(_receiver, _claimableAmount);\n    }\n  }\n\n  /** admin functions */\n\n  /// @notice allows the owner to pause the contract\n  /// @dev This function is marked as payable for gas optimization.\n  function pause() external payable onlyOwner {\n    _pause();\n  }\n\n  /// @notice allows the owner to unpause the contract\n  /// @dev This function is marked as payable for gas optimization.\n  function unpause() external payable onlyOwner {\n    _unpause();\n  }\n\n  /**\n   * @notice Updates the leverage ratio parameters: floor, ceiling, and buffer.\n   * @notice Only callable by the owner.\n   * @dev This function is marked as payable for gas optimization.\n   * @param _leverageRatioFloor the new floor for the leverage ratio scaled by 18 decimals. i.e. 0.5 is 5 * 10^17\n   * @param _leverageRatioCeiling the new ceiling for the leverage ratio scaled by 18 decimals. i.e. 1.5 is 1.5 * 10^18\n   * @param _leverageRatioBuffer the new buffer for the leverage ratio scaled by 18 decimals. i.e. 0.05 is 5 * 10^16\n   */\n  function updateLeverageRatioParams(\n    uint256 _leverageRatioFloor,\n    uint256 _leverageRatioCeiling,\n    uint256 _leverageRatioBuffer\n  ) external payable onlyOwner {\n    poolInfo.params.leverageRatioFloor = _leverageRatioFloor;\n    poolInfo.params.leverageRatioCeiling = _leverageRatioCeiling;\n    poolInfo.params.leverageRatioBuffer = _leverageRatioBuffer;\n  }\n\n  /**\n   * @notice Updates risk premium calculation params: curvature, minCarapaceRiskPremiumPercent & underlyingRiskPremiumPercent\n   * @notice Only callable by the owner.\n   * @dev This function is marked as payable for gas optimization.\n   * @param _curvature the new curvature parameter scaled by 18 decimals. i.e. 0.05 curvature is 5 * 10^16\n   * @param _minCarapaceRiskPremiumPercent the new minCarapaceRiskPremiumPercent parameter scaled by 18 decimals. i.e. 0.03 is 3 * 10^16\n   * @param _underlyingRiskPremiumPercent the new underlyingRiskPremiumPercent parameter scaled by 18 decimals. i.e. 0.10 is 1 * 10^17\n   */\n  function updateRiskPremiumParams(\n    uint256 _curvature,\n    uint256 _minCarapaceRiskPremiumPercent,\n    uint256 _underlyingRiskPremiumPercent\n  ) external payable onlyOwner {\n    poolInfo.params.curvature = _curvature;\n    poolInfo\n      .params\n      .minCarapaceRiskPremiumPercent = _minCarapaceRiskPremiumPercent;\n    poolInfo\n      .params\n      .underlyingRiskPremiumPercent = _underlyingRiskPremiumPercent;\n  }\n\n  /**\n   * @notice Updates the minimum required capital for the protection pool\n   * @notice Only callable by the owner.\n   * @dev This function is marked as payable for gas optimization.\n   * @param _minRequiredCapital the new minimum required capital for the protection pool in underlying token\n   */\n  function updateMinRequiredCapital(uint256 _minRequiredCapital)\n    external\n    payable\n    onlyOwner\n  {\n    poolInfo.params.minRequiredCapital = _minRequiredCapital;\n  }\n\n  /**\n   * @notice Allows the owner to move pool phase after verification\n   * @notice Only callable by the owner.\n   * @dev This function is marked as payable for gas optimization.\n   * @return _newPhase the new phase of the pool, if the phase is updated\n   */\n  function movePoolPhase()\n    external\n    payable\n    onlyOwner\n    returns (ProtectionPoolPhase _newPhase)\n  {\n    ProtectionPoolPhase _currentPhase = poolInfo.currentPhase;\n\n    /// Pool starts in OpenToSellers phase.\n    /// Once the pool has enough capital, it can be moved to OpenToBuyers phase\n    if (\n      _currentPhase == ProtectionPoolPhase.OpenToSellers &&\n      _hasMinRequiredCapital()\n    ) {\n      poolInfo.currentPhase = _newPhase = ProtectionPoolPhase.OpenToBuyers;\n      emit ProtectionPoolPhaseUpdated(_newPhase);\n    } else if (_currentPhase == ProtectionPoolPhase.OpenToBuyers) {\n      /// when the pool is in OpenToBuyers phase, it can be moved to Open phase,\n      /// if the leverage ratio is below the ceiling\n      if (calculateLeverageRatio() <= poolInfo.params.leverageRatioCeiling) {\n        poolInfo.currentPhase = _newPhase = ProtectionPoolPhase.Open;\n        emit ProtectionPoolPhaseUpdated(_newPhase);\n      }\n    }\n\n    /// Once the pool is in Open phase, phase can not be updated\n  }\n\n  /** view functions */\n\n  /// @inheritdoc IProtectionPool\n  function getPoolInfo()\n    external\n    view\n    override\n    returns (ProtectionPoolInfo memory)\n  {\n    return poolInfo;\n  }\n\n  /// @inheritdoc IProtectionPool\n  function getAllProtections()\n    external\n    view\n    override\n    returns (ProtectionInfo[] memory _protections)\n  {\n    uint256 _length = protectionInfos.length;\n    _protections = new ProtectionInfo[](_length - 1);\n    uint256 _index;\n\n    /// skip the first element in the array, as it is dummy/empty protection info\n    for (uint256 i = 1; i < _length; ) {\n      _protections[_index] = protectionInfos[i];\n\n      unchecked {\n        ++i;\n        ++_index;\n      }\n    }\n  }\n\n  /// @inheritdoc IProtectionPool\n  function calculateLeverageRatio() public view override returns (uint256) {\n    return _calculateLeverageRatio(totalSTokenUnderlying);\n  }\n\n  /// @inheritdoc IProtectionPool\n  function convertToSToken(uint256 _underlyingAmount)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    uint256 _scaledUnderlyingAmt = ProtectionPoolHelper\n      .scaleUnderlyingAmtTo18Decimals(\n        _underlyingAmount,\n        poolInfo.underlyingToken.decimals()\n      );\n\n    /// if there are no sTokens in the pool, return the underlying amount\n    if (totalSupply() == 0) return _scaledUnderlyingAmt;\n\n    return\n      (_scaledUnderlyingAmt * Constants.SCALE_18_DECIMALS) / _getExchangeRate();\n  }\n\n  /// @inheritdoc IProtectionPool\n  function convertToUnderlying(uint256 _sTokenShares)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return\n      ProtectionPoolHelper.scale18DecimalsAmtToUnderlyingDecimals(\n        ((_sTokenShares * _getExchangeRate()) / Constants.SCALE_18_DECIMALS), /// underlying amount in 18 decimals\n        poolInfo.underlyingToken.decimals()\n      );\n  }\n\n  /// @inheritdoc IProtectionPool\n  function getRequestedWithdrawalAmount(uint256 _withdrawalCycleIndex)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return _getRequestedWithdrawalAmount(_withdrawalCycleIndex);\n  }\n\n  /// @inheritdoc IProtectionPool\n  function getCurrentRequestedWithdrawalAmount()\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _getRequestedWithdrawalAmount(\n        poolCycleManager.getCurrentCycleIndex(address(this))\n      );\n  }\n\n  /// @inheritdoc IProtectionPool\n  function getTotalRequestedWithdrawalAmount(uint256 _withdrawalCycleIndex)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return withdrawalCycleDetails[_withdrawalCycleIndex].totalSTokenRequested;\n  }\n\n  /// @inheritdoc IProtectionPool\n  function getLendingPoolDetail(address _lendingPoolAddress)\n    external\n    view\n    override\n    returns (\n      uint256 _lastPremiumAccrualTimestamp,\n      uint256 _totalPremium,\n      uint256 _totalProtection\n    )\n  {\n    LendingPoolDetail storage lendingPoolDetail = lendingPoolDetails[\n      _lendingPoolAddress\n    ];\n    _lastPremiumAccrualTimestamp = lendingPoolDetail\n      .lastPremiumAccrualTimestamp;\n    _totalPremium = lendingPoolDetail.totalPremium;\n    _totalProtection = lendingPoolDetail.totalProtection;\n  }\n\n  /// @inheritdoc IProtectionPool\n  function getActiveProtections(address _buyer)\n    external\n    view\n    override\n    returns (ProtectionInfo[] memory _protectionInfos)\n  {\n    /// Retrieve the active protection indexes for the buyer\n    EnumerableSetUpgradeable.UintSet\n      storage activeProtectionIndexes = protectionBuyerAccounts[_buyer]\n        .activeProtectionIndexes;\n    uint256 _length = activeProtectionIndexes.length();\n    _protectionInfos = new ProtectionInfo[](_length);\n\n    /// Retrieve the protection info for each active protection index\n    /// and set it in the return array\n    for (uint256 i; i < _length; ) {\n      uint256 _protectionIndex = activeProtectionIndexes.at(i);\n      _protectionInfos[i] = protectionInfos[_protectionIndex];\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /// @inheritdoc IProtectionPool\n  function getTotalPremiumPaidForLendingPool(\n    address _buyer,\n    address _lendingPoolAddress\n  ) external view override returns (uint256) {\n    return\n      protectionBuyerAccounts[_buyer].lendingPoolToPremium[_lendingPoolAddress];\n  }\n\n  /// @inheritdoc IProtectionPool\n  function calculateProtectionPremium(\n    ProtectionPurchaseParams calldata _protectionPurchaseParams\n  )\n    external\n    view\n    override\n    returns (uint256 _premiumAmount, bool _isMinPremium)\n  {\n    uint256 _leverageRatio = calculateLeverageRatio();\n\n    (, _premiumAmount, _isMinPremium) = ProtectionPoolHelper\n      .calculateProtectionPremium(\n        premiumCalculator,\n        poolInfo,\n        _protectionPurchaseParams,\n        totalSTokenUnderlying,\n        _leverageRatio\n      );\n  }\n\n  /// @inheritdoc IProtectionPool\n  function calculateMaxAllowedProtectionAmount(\n    address _lendingPool,\n    uint256 _nftLpTokenId\n  ) external view override returns (uint256 _maxAllowedProtectionAmount) {\n    /// Users can not purchase protection for more than the remaining principal\n    return\n      poolInfo.referenceLendingPools.calculateRemainingPrincipal(\n        _lendingPool,\n        msg.sender,\n        _nftLpTokenId\n      );\n  }\n\n  /// @inheritdoc IProtectionPool\n  function calculateMaxAllowedProtectionDuration()\n    external\n    view\n    override\n    returns (uint256 _maxAllowedProtectionDurationInSeconds)\n  {\n    /// Users can not purchase protection for more than the duration remaining till end of next cycle\n    _maxAllowedProtectionDurationInSeconds =\n      poolCycleManager.getNextCycleEndTimestamp(address(this)) -\n      block.timestamp;\n  }\n\n  /// @inheritdoc IProtectionPool\n  function getPoolDetails()\n    external\n    view\n    override\n    returns (\n      uint256 _totalSTokenUnderlying,\n      uint256 _totalProtection,\n      uint256 _totalPremium,\n      uint256 _totalPremiumAccrued\n    )\n  {\n    _totalSTokenUnderlying = totalSTokenUnderlying;\n    _totalProtection = totalProtection;\n    _totalPremium = totalPremium;\n    _totalPremiumAccrued = totalPremiumAccrued;\n  }\n\n  /// @inheritdoc IProtectionPool\n  function getUnderlyingBalance(address _user)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return convertToUnderlying(balanceOf(_user));\n  }\n\n  /*** internal functions */\n\n  /**\n   * @dev Verify protection purchase and create a protection if it is valid\n   * @param _protectionStartTimestamp The timestamp at which protection starts\n   * @param _protectionPurchaseParams The protection purchase params\n   * @param _maxPremiumAmount The maximum premium amount that the user is willing to pay\n   * @param _isRenewal Whether the protection is being renewed or not\n   */\n  function _verifyAndCreateProtection(\n    uint256 _protectionStartTimestamp,\n    ProtectionPurchaseParams calldata _protectionPurchaseParams,\n    uint256 _maxPremiumAmount,\n    bool _isRenewal\n  ) internal {\n    /// Verify that user can buy protection\n    ProtectionPoolHelper.verifyProtection(\n      poolCycleManager,\n      defaultStateManager,\n      address(this),\n      poolInfo,\n      _protectionStartTimestamp,\n      _protectionPurchaseParams,\n      _isRenewal\n    );\n\n    /// Step 1: Calculate & check the leverage ratio\n    /// Ensure that leverage ratio floor is never breached\n    totalProtection += _protectionPurchaseParams.protectionAmount;\n    uint256 _leverageRatio = calculateLeverageRatio();\n    if (_leverageRatio < poolInfo.params.leverageRatioFloor) {\n      revert ProtectionPoolLeverageRatioTooLow(_leverageRatio);\n    }\n\n    /// Retrieve the lending pool detail and\n    /// update the total protection of the lending pool by the protection amount\n    LendingPoolDetail storage lendingPoolDetail = lendingPoolDetails[\n      _protectionPurchaseParams.lendingPoolAddress\n    ];\n    lendingPoolDetail.totalProtection += _protectionPurchaseParams\n      .protectionAmount;\n\n    /// Step 2: Calculate the protection premium amount scaled to 18 decimals and\n    /// scale it down to the underlying token decimals.\n    (\n      uint256 _premiumAmountIn18Decimals,\n      uint256 _premiumAmount,\n      bool _isMinPremium\n    ) = ProtectionPoolHelper.calculateAndTrackPremium(\n        premiumCalculator,\n        protectionBuyerAccounts,\n        poolInfo,\n        lendingPoolDetail,\n        _protectionPurchaseParams,\n        _maxPremiumAmount,\n        totalSTokenUnderlying,\n        _leverageRatio\n      );\n    totalPremium += _premiumAmount;\n\n    /// Step 3: Calculate protection in days and scale it to 18 decimals.\n    uint256 _protectionDurationInDaysScaled = ((\n      _protectionPurchaseParams.protectionDurationInSeconds\n    ) * Constants.SCALE_18_DECIMALS) / uint256(Constants.SECONDS_IN_DAY);\n\n    console.log(\n      \"protectionDurationInDays: %s, protectionPremium: %s, leverageRatio: \",\n      _protectionDurationInDaysScaled,\n      _premiumAmount,\n      _leverageRatio\n    );\n\n    /// Step 4: Capture loan protection data for premium accrual calculation\n    // solhint-disable-next-line\n    (int256 _k, int256 _lambda) = AccruedPremiumCalculator.calculateKAndLambda(\n      _premiumAmountIn18Decimals,\n      _protectionDurationInDaysScaled,\n      _leverageRatio,\n      poolInfo.params.leverageRatioFloor,\n      poolInfo.params.leverageRatioCeiling,\n      poolInfo.params.leverageRatioBuffer,\n      poolInfo.params.curvature,\n      _isMinPremium ? poolInfo.params.minCarapaceRiskPremiumPercent : 0\n    );\n\n    /// Step 5: Add protection to the pool\n    protectionInfos.push(\n      ProtectionInfo({\n        buyer: msg.sender,\n        protectionPremium: _premiumAmount,\n        startTimestamp: _protectionStartTimestamp,\n        K: _k,\n        lambda: _lambda,\n        expired: false,\n        purchaseParams: _protectionPurchaseParams\n      })\n    );\n\n    /// Step 6: Track all loan protections for a lending pool to calculate\n    // the total locked amount for the lending pool, when/if pool is late for payment\n    uint256 _protectionIndex = protectionInfos.length - 1;\n    lendingPoolDetail.activeProtectionIndexes.add(_protectionIndex);\n    protectionBuyerAccounts[msg.sender].activeProtectionIndexes.add(\n      _protectionIndex\n    );\n\n    emit ProtectionBought(\n      msg.sender,\n      _protectionPurchaseParams.lendingPoolAddress,\n      _protectionPurchaseParams.protectionAmount,\n      _premiumAmount\n    );\n\n    /// Step 7: transfer premium amount from buyer to pool\n    poolInfo.underlyingToken.safeTransferFrom(\n      msg.sender,\n      address(this),\n      _premiumAmount\n    );\n  }\n\n  /**\n   * @dev the exchange rate = total capital / total SToken supply\n   * @dev total capital = total seller deposits + premium accrued - locked capital - default payouts\n   * @dev the rehypothecation and the protocol fees will be added in the upcoming versions\n   * @return the exchange rate scaled to 18 decimals\n   */\n  function _getExchangeRate() internal view returns (uint256) {\n    uint256 _totalScaledCapital = ProtectionPoolHelper\n      .scaleUnderlyingAmtTo18Decimals(\n        totalSTokenUnderlying,\n        poolInfo.underlyingToken.decimals()\n      );\n    uint256 _totalSTokenSupply = totalSupply();\n    uint256 _exchangeRate = (_totalScaledCapital *\n      Constants.SCALE_18_DECIMALS) / _totalSTokenSupply;\n\n    console.log(\n      \"Total capital: %s, Total SToken Supply: %s, exchange rate: %s\",\n      _totalScaledCapital,\n      _totalSTokenSupply,\n      _exchangeRate\n    );\n\n    return _exchangeRate;\n  }\n\n  /**\n   * @dev Calculate the minimum required capital for the pool to be able to enable protection purchases.\n   */\n  function _hasMinRequiredCapital() internal view returns (bool) {\n    return totalSTokenUnderlying >= poolInfo.params.minRequiredCapital;\n  }\n\n  /**\n   * @dev Calculate the leverage ratio for the pool.\n   * @param _totalCapital the total c"
    }
  ]
}