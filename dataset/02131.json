{
  "Title": "M-4: fillQuote uses transfer instead of call which can break with future updates to gas costs",
  "Content": "# Issue M-4: fillQuote uses transfer instead of call which can break with future updates to gas costs \n\nSource: https://github.com/sherlock-audit/2023-03-sense-judging/issues/33 \n\n## Found by \nsayan\\_, Saeedalipoor01988, 0x52, tsvetanovv, martin, 0xAgro, Bauer, Breeje\n\n## Summary\n\nTransfer will always send ETH with a 2300 gas. This can be problematic for interacting smart contracts if gas cost change because their interaction may abruptly break.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nChanging gas costs may break integrations in the future\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-sense/blob/main/sense-v1/pkg/core/src/Periphery.sol#L902-L932\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse call instead of transfer. Reentrancy isn't a concern since the contract should only ever contain the callers funds. \n\n## Discussion\n\n**jparklev**\n\nAccepted: we should use .call instead of transfer when transferring ETH, specifically if the receiver is a contract that is integrating Sense.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/58",
  "Code": [
    {
      "filename": "sense-v1/pkg/core/src/Periphery.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { FixedMath } from \"./external/FixedMath.sol\";\nimport { BalancerVault, IAsset } from \"./external/balancer/Vault.sol\";\nimport { BalancerPool } from \"./external/balancer/Pool.sol\";\nimport { IERC3156FlashBorrower } from \"./external/flashloan/IERC3156FlashBorrower.sol\";\nimport { IPermit2 } from \"@sense-finance/v1-core/external/IPermit2.sol\";\n\n// Internal references\nimport { Errors } from \"@sense-finance/v1-utils/libs/Errors.sol\";\nimport { Levels } from \"@sense-finance/v1-utils/libs/Levels.sol\";\nimport { Trust } from \"@sense-finance/v1-utils/Trust.sol\";\nimport { BaseAdapter as Adapter } from \"./adapters/abstract/BaseAdapter.sol\";\nimport { BaseFactory as AdapterFactory } from \"./adapters/abstract/factories/BaseFactory.sol\";\nimport { Divider } from \"./Divider.sol\";\n\ninterface SpaceFactoryLike {\n    function create(address, uint256) external returns (address);\n\n    function pools(address adapter, uint256 maturity) external view returns (address);\n}\n\n/// @title Periphery\ncontract Periphery is Trust, IERC3156FlashBorrower {\n    using FixedMath for uint256;\n    using SafeTransferLib for ERC20;\n    using Levels for uint256;\n\n    /* ========== PUBLIC CONSTANTS ========== */\n\n    /// @notice Lower bound on the amount of Claim tokens one can swap in for Target\n    uint256 public constant MIN_YT_SWAP_IN = 0.000001e18;\n\n    /// @notice Acceptable error when estimating the tokens resulting from a specific swap\n    uint256 public constant PRICE_ESTIMATE_ACCEPTABLE_ERROR = 0.00000001e18;\n\n    /// @notice ETH address\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /* ========== PUBLIC IMMUTABLES ========== */\n\n    /// @notice Sense core Divider address\n    Divider public immutable divider;\n\n    /// @notice Sense core Divider address\n    BalancerVault public immutable balancerVault;\n\n    /// @notice Permit2 contract\n    IPermit2 public immutable permit2;\n\n    // 0x ExchangeProxy address. See https://docs.0x.org/developer-resources/contract-addresses\n    address public immutable exchangeProxy;\n\n    /* ========== PUBLIC MUTABLE STORAGE ========== */\n\n    /// @notice Sense core Divider address\n    SpaceFactoryLike public spaceFactory;\n\n    /// @notice adapter factories -> is supported\n    mapping(address => bool) public factories;\n\n    /// @notice adapter -> bool\n    mapping(address => bool) public verified;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct PoolLiquidity {\n        ERC20[] tokens;\n        uint256[] amounts;\n        uint256 minBptOut;\n    }\n\n    struct PermitData {\n        IPermit2.PermitTransferFrom msg;\n        bytes sig;\n    }\n\n    struct PermitBatchData {\n        IPermit2.PermitBatchTransferFrom msg;\n        bytes sig;\n    }\n\n    struct SwapQuote {\n        ERC20 sellToken;\n        ERC20 buyToken;\n        address spender;\n        address payable swapTarget;\n        bytes swapCallData;\n    }\n\n    constructor(\n        address _divider,\n        address _spaceFactory,\n        address _balancerVault,\n        address _permit2,\n        address _exchangeProxy\n    ) Trust(msg.sender) {\n        divider = Divider(_divider);\n        spaceFactory = SpaceFactoryLike(_spaceFactory);\n        balancerVault = BalancerVault(_balancerVault);\n        permit2 = IPermit2(_permit2);\n        exchangeProxy = _exchangeProxy;\n    }\n\n    /* ========== SERIES / ADAPTER MANAGEMENT ========== */\n\n    /// @notice Sponsor a new Series in any adapter previously onboarded onto the Divider\n    /// @dev Called by an external address, initializes a new series in the Divider\n    /// @param adapter Adapter to associate with the Series\n    /// @param maturity Maturity date for the Series, in units of unix time\n    /// @param withPool Whether to deploy a Space pool or not (only works for unverified adapters)\n    function sponsorSeries(\n        address adapter,\n        uint256 maturity,\n        bool withPool,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external payable returns (address pt, address yt) {\n        (, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, stake, stakeSize);\n        if (address(quote.sellToken) != stake) _fillQuote(quote);\n\n        // Approve divider to withdraw stake assets\n        ERC20(stake).safeApprove(address(divider), stakeSize);\n\n        (pt, yt) = divider.initSeries(adapter, maturity, msg.sender);\n\n        // Space pool is always created for verified adapters whilst is optional for unverified ones.\n        // Automatically queueing series is only for verified adapters\n        if (verified[adapter]) {\n            spaceFactory.create(adapter, maturity);\n        } else {\n            if (withPool) {\n                spaceFactory.create(adapter, maturity);\n            }\n        }\n\n        // Refund any excess stake assets\n        ERC20(stake).safeTransfer(msg.sender, ERC20(stake).balanceOf(address(this)));\n\n        emit SeriesSponsored(adapter, maturity, msg.sender);\n    }\n\n    /// @notice Deploy and onboard a Adapter\n    /// @dev Called by external address, deploy a new Adapter via an Adapter Factory\n    /// @param f Factory to use\n    /// @param target Target to onboard\n    /// @param data Additional encoded data needed to deploy the adapter\n    function deployAdapter(\n        address f,\n        address target,\n        bytes calldata data\n    ) external returns (address adapter) {\n        if (!factories[f]) revert Errors.FactoryNotSupported();\n        adapter = AdapterFactory(f).deployAdapter(target, data);\n        emit AdapterDeployed(adapter);\n        _verifyAdapter(adapter);\n        _onboardAdapter(adapter, true);\n    }\n\n    /* ========== LIQUIDITY UTILS ========== */\n\n    /// @notice Swap for PTs of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param amt Amount to swap for PTs\n    /// @param minAccepted Min accepted amount of PT\n    /// @param receiver Address to receive the PT\n    /// @param permit Permit to pull the tokens to swap from\n    /// @param quote Quote with swap details\n    /// @dev if quote.sellToken is neither target nor underlying, it will be swapped for underlying\n    /// on 0x and wrapped into the target\n    /// @return ptBal amount of PT received\n    function swapForPTs(\n        address adapter,\n        uint256 maturity,\n        uint256 amt,\n        uint256 minAccepted,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external payable returns (uint256 ptBal) {\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, address(quote.sellToken), amt);\n        return _swapTargetForPTs(adapter, maturity, _toTarget(adapter, amt, quote), minAccepted, receiver);\n    }\n\n    /// @notice Swap to YTs of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param amt Amount to sell\n    /// @param targetToBorrow Amount of Target to borrow\n    /// @param minAccepted Min accepted amount of YT\n    /// @param receiver Address to receive the YT\n    /// @param permit Permit to pull the tokens to swap from\n    /// @param quote Quote with swap details\n    /// @return targetBal amount of Target sent back\n    /// @return ytBal amount of YT received\n    /// @dev if quote.sellToken is neither target nor underlying, it will be swapped for underlying\n    /// on 0x and wrapped into the target\n    function swapForYTs(\n        address adapter,\n        uint256 maturity,\n        uint256 amt,\n        uint256 targetToBorrow,\n        uint256 minAccepted,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external payable returns (uint256 targetBal, uint256 ytBal) {\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, address(quote.sellToken), amt);\n\n        // swap sellToken to target, borrow more target and swap to YTs\n        (targetBal, ytBal) = _flashBorrowAndSwapToYTs(\n            adapter,\n            maturity,\n            _toTarget(adapter, amt, quote),\n            targetToBorrow,\n            minAccepted\n        );\n\n        ERC20(Adapter(adapter).target()).safeTransfer(receiver, targetBal);\n        ERC20(divider.yt(adapter, maturity)).safeTransfer(receiver, ytBal);\n    }\n\n    /// @notice Swap PTs of a particular series\n    /// @param adapter Adapter address for the series\n    /// @param maturity Maturity date for the series\n    /// @param ptBal Balance of PT to sell\n    /// @param minAccepted Min accepted amount of tokens when selling them on Space\n    /// @param receiver Address to receive the tokens\n    /// @param permit Permit to pull PTs\n    /// @param quote Quote with swap details\n    /// @return amt amount of tokens received\n    /// @dev if quote.buyToken is neither target nor underlying, it will unwrap target\n    /// and swap it on 0x\n    function swapPTs(\n        address adapter,\n        uint256 maturity,\n        uint256 ptBal,\n        uint256 minAccepted,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external returns (uint256 amt) {\n        amt = _swapSenseToken(adapter, maturity, ptBal, minAccepted, 0, receiver, permit, quote);\n    }\n\n    /// @notice Swap YTs of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param ytBal Balance of YTs to swap\n    /// @param minAccepted Min accepted amount of tokens when selling them on Space\n    /// @param receiver Address to receive the Target\n    /// @param permit Permit to pull YTs\n    /// @param quote Quote with swap details\n    /// @return amt amount of Target received\n    /// @dev if quote.buyToken is neither target nor underlying, it will unwrap target\n    /// and swap it on 0x\n    function swapYTs(\n        address adapter,\n        uint256 maturity,\n        uint256 ytBal,\n        uint256 minAccepted,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external returns (uint256 amt) {\n        amt = _swapSenseToken(adapter, maturity, ytBal, minAccepted, 1, receiver, permit, quote);\n    }\n\n    function swapYTsForTarget(\n        address adapter,\n        uint256 maturity,\n        uint256 ytBal\n    ) external returns (uint256 amt) {\n        if (msg.sender != adapter) revert Errors.OnlyAdapter();\n        PermitData memory permit = PermitData(\n            IPermit2.PermitTransferFrom(IPermit2.TokenPermissions(ERC20(address(0)), 0), 0, 0),\n            \"0x\"\n        );\n        amt = this._swapYTsForTarget(msg.sender, adapter, maturity, ytBal, permit);\n    }\n\n    function _swapSenseToken(\n        address adapter,\n        uint256 maturity,\n        uint256 sellAmt,\n        uint256 minAccepted,\n        uint8 mode, // 0 = PTs, 1 = YTs\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) private returns (uint256 amt) {\n        amt = (mode == 1)\n            ? _swapYTsForTarget(msg.sender, adapter, maturity, sellAmt, permit)\n            : _swapPTsForTarget(adapter, maturity, sellAmt, permit);\n        amt = _fromTarget(adapter, amt, quote);\n\n        if (amt < minAccepted) revert Errors.UnexpectedSwapAmount();\n        _transfer(quote.buyToken, receiver, amt);\n\n        // transfer any remaining underlying to receiver\n        ERC20 underlying = ERC20(Adapter(adapter).underlying());\n        uint256 remaining = underlying.balanceOf(address(this));\n        if (remaining > 0) underlying.safeTransfer(receiver, remaining);\n    }\n\n    /// @notice Adds liquidity providing any Token\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param amt Amount to provide\n    /// @param mode 0 = issues and sell YT, 1 = issue and hold YT\n    /// @param minAccepted Min accepted amount of Target (from the sell of YTs)\n    /// @param minBptOut Minimum BPT the user will accept out for this transaction\n    /// @param receiver Address to receive the BPT\n    /// @param permit Permit to pull the tokens to swap from\n    /// @param quote Quote with swap details\n    /// @dev see return description of _addLiquidity\n    /// @dev if quote.sellToken is neither target nor underlying, it will be swapped for underlying\n    /// on 0x and wrapped into the target\n    function addLiquidity(\n        address adapter,\n        uint256 maturity,\n        uint256 amt,\n        uint256 minAccepted,\n        uint256 minBptOut,\n        uint8 mode,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    )\n        external\n        payable\n        returns (\n            uint256 tAmount,\n            uint256 issued,\n            uint256 lpShares\n        )\n    {\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, address(quote.sellToken), amt);\n        (tAmount, issued, lpShares) = _addLiquidity(\n            adapter,\n            maturity,\n            _toTarget(adapter, amt, quote),\n            minAccepted,\n            minBptOut,\n            mode,\n            receiver,\n            permit\n        );\n    }\n\n    /// @notice Removes liquidity providing an amount of LP tokens and returns underlying\n    /// @dev More info on `minAmountsOut`: https://github.com/balancer-labs/docs-developers/blob/main/resources/joins-and-exits/pool-exits.md#minamountsout\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param lpBal Balance of LP tokens to provide\n    /// @param minAmountsOut minimum accepted amounts of PTs and Target given the amount of LP shares provided\n    /// @param minAccepted only used when removing liquidity on/after maturity and its the min accepted when swapping PTs to underlying\n    /// @param receiver Address to receive the Underlying\n    /// @param permit Permit to pull the LP tokens\n    /// @param quote Quote with swap details\n    /// @return amt amount of tokens received and ptBal PTs (in case it's called after maturity and redeem is restricted or intoTarget is false)\n    /// @dev if quote.buyToken is neither target nor underlying, it will unwrap target\n    /// and swap it on 0x\n    /// if quote.buyToken is PT, it will return target and PTs\n    function removeLiquidity(\n        address adapter,\n        uint256 maturity,\n        uint256 lpBal,\n        uint256[] memory minAmountsOut,\n        uint256 minAccepted,\n        bool swapPTs,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external returns (uint256 amt, uint256 ptBal) {\n        (amt, ptBal) = _removeLiquidity(\n            adapter,\n            maturity,\n            lpBal,\n            minAmountsOut,\n            minAccepted,\n            swapPTs,\n            receiver,\n            permit\n        );\n        amt = _fromTarget(adapter, amt, quote);\n        _transfer(quote.buyToken, receiver, amt);\n    }\n\n    /* ========== UTILS ========== */\n\n    /// @notice Mint PTs & YTs of a specific Series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series [unix time]\n    /// @param amt Amount to issue with\n    /// @dev The balance of PTs and YTs minted will be the same value in units of underlying (less fees)\n    /// @param receiver Address where the resulting PTs and YTs will be transferred to\n    /// @param permit Permit to pull tokens\n    /// @param quote Quote with swap details\n    /// @return uBal Amount of PTs and YTs minted\n    /// @dev if quote.sellToken is neither target nor underlying, it will swap on 0x and wrap to target\n    /// and swap it on 0x\n    function issue(\n        address adapter,\n        uint256 maturity,\n        uint256 amt,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external returns (uint256 uBal) {\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, address(quote.sellToken), amt);\n        uBal = divider.issue(adapter, maturity, _toTarget(adapter, amt, quote));\n        ERC20(divider.pt(adapter, maturity)).transfer(receiver, uBal); // Send PTs to the receiver\n        ERC20(divider.yt(adapter, maturity)).transfer(receiver, uBal); // Send YT to the receiver\n    }\n\n    /// @notice Reconstitute Target by burning PT and YT\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param uBal Amount of PT and YT to burn\n    /// @param receiver Address where the resulting Target will be transferred\n    /// @param permit Permit to pull PT and YT\n    /// @param quote Quote with swap details\n    /// @return amt Amount of tokens received from reconstituting target\n    /// @dev if quote.buyToken is neither target nor underlying, it will unwrap target\n    /// and swap it on 0x\n    function combine(\n        address adapter,\n        uint256 maturity,\n        uint256 uBal,\n        address receiver,\n        PermitBatchData calldata permit,\n        SwapQuote calldata quote\n    ) external returns (uint256 amt) {\n        IPermit2.SignatureTransferDetails[] memory sigs = new IPermit2.SignatureTransferDetails[](2);\n        sigs[0] = IPermit2.SignatureTransferDetails({ to: address(this), requestedAmount: uBal });\n        sigs[1] = IPermit2.SignatureTransferDetails({ to: address(this), requestedAmount: uBal });\n\n        // pull underlying\n        permit2.permitTransferFrom(permit.msg, sigs, msg.sender, permit.sig);\n        amt = _fromTarget(adapter, divider.combine(adapter, maturity, uBal), quote);\n        _transfer(quote.buyToken, receiver, amt);\n    }\n\n    /* ========== ADMIN ========== */\n\n    /// @notice Enable or disable a factory\n    /// @param f Factory's address\n    /// @param isOn Flag setting this factory to enabled or disabled\n    function setFactory(address f, bool isOn) external requiresTrust {\n        if (factories[f] == isOn) revert Errors.ExistingValue();\n        factories[f] = isOn;\n        emit FactoryChanged(f, isOn);\n    }\n\n    /// @notice Update the address for the Space Factory\n    /// @param newSpaceFactory The Space Factory addresss to set\n    function setSpaceFactory(address newSpaceFactory) external requiresTrust {\n        emit SpaceFactoryChanged(address(spaceFactory), newSpaceFactory);\n        spaceFactory = SpaceFactoryLike(newSpaceFactory);\n    }\n\n    /// @dev Verifies an Adapter\n    /// @param adapter Adapter to verify\n    function verifyAdapter(address adapter) public requiresTrust {\n        _verifyAdapter(adapter);\n    }\n\n    function _verifyAdapter(address adapter) private {\n        verified[adapter] = true;\n        emit AdapterVerified(adapter);\n    }\n\n    /// @notice Onboard a single Adapter w/o needing a factory\n    /// @dev Called by a trusted address, approves Target for issuance, and onboards adapter to the Divider\n    /// @param adapter Adapter to onboard\n    /// @param addAdapter Whether to call divider.addAdapter or not (useful e.g when upgrading Periphery)\n    function onboardAdapter(address adapter, bool addAdapter) public {\n        if (!divider.permissionless() && !isTrusted[msg.sender]) revert Errors.OnlyPermissionless();\n        _onboardAdapter(adapter, addAdapter);\n    }\n\n    function _onboardAdapter(address adapter, bool addAdapter) private {\n        ERC20 target = ERC20(Adapter(adapter).target());\n        target.safeApprove(address(divider), type(uint256).max);\n        target.safeApprove(address(adapter), type(uint256).max);\n        ERC20(Adapter(adapter).underlying()).safeApprove(address(adapter), type(uint256).max);\n        if (addAdapter) divider.addAdapter(adapter);\n        emit AdapterOnboarded(adapter);\n    }\n\n    /* ========== INTERNAL UTILS ========== */\n\n    function _balancerSwap(\n        address assetIn,\n        address assetOut,\n        uint256 amountIn,\n        bytes32 poolId,\n        uint256 minAccepted,\n        address payable receiver\n    ) internal returns (uint256 amountOut) {\n        // approve vault to spend tokenIn\n        ERC20(assetIn).safeApprove(address(balancerVault), amountIn);\n\n        BalancerVault.SingleSwap memory request = BalancerVault.SingleSwap({\n            poolId: poolId,\n            kind: BalancerVault.SwapKind.GIVEN_IN,\n            assetIn: IAsset(assetIn),\n            assetOut: IAsset(assetOut),\n            amount: amountIn,\n            userData: hex\"\"\n        });\n\n        BalancerVault.FundManagement memory funds = BalancerVault.FundManagement({\n            sender: address(this),\n            fromInternalBalance: false,\n            recipient: receiver,\n            toInternalBalance: false\n        });\n\n        amountOut = balancerVault.swap(request, funds, minAccepted, type(uint256).max);\n        emit Swapped(msg.sender, poolId, assetIn, assetOut, amountIn, amountOut, msg.sig);\n    }\n\n    function _swapPTsForTarget(\n        address adapter,\n        uint256 maturity,\n        uint256 ptBal,\n        PermitData calldata permit\n    ) internal returns (uint256 tBal) {\n        _transferFrom(permit, divider.pt(adapter, maturity), ptBal);\n\n        if (divider.mscale(adapter, maturity) > 0) {\n            tBal = divider.redeem(adapter, maturity, ptBal);\n        } else {\n            tBal = _balancerSwap(\n                divider.pt(adapter, maturity),\n                Adapter(adapter).target(),\n                ptBal,\n                BalancerPool(spaceFactory.pools(adapter, maturity)).getPoolId(),\n                0,\n                payable(address(this))\n            );\n        }\n    }\n\n    function _swapTargetForPTs(\n        address adapter,\n        uint256 maturity,\n        uint256 tBal,\n        uint256 minAccepted,\n        address receiver\n    ) internal returns (uint256 ptBal) {\n        address pt = divider.pt(adapter, maturity);\n        BalancerPool pool = BalancerPool(spaceFactory.pools(adapter, maturity));\n        ptBal = _balancerSwap(Adapter(adapter).target(), pt, tBal, pool.getPoolId(), minAccepted, payable(receiver)); // swap target for PTs\n    }\n\n    function _swapYTsForTarget(\n        address sender,\n        address adapter,\n        uint256 maturity,\n        uint256 ytBal,\n        PermitData calldata permit\n    ) public returns (uint256 tBal) {\n        // Because there's some margin of error in the pricing functions here, smaller\n        // swaps will be unreliable. Tokens with more than 18 decimals are not supported.\n        if (ytBal * 10**(18 - ERC20(divider.yt(adapter, maturity)).decimals()) <= MIN_YT_SWAP_IN)\n            revert Errors.SwapTooSmall();\n\n        // Transfer YTs into this contract if needed\n        if (sender != address(this)) _transferFrom(permit, divider.yt(adapter, maturity), ytBal);\n\n        // Calculate target to borrow by calling AMM\n        BalancerPool pool = BalancerPool(spaceFactory.pools(adapter, maturity));\n        bytes32 poolId = pool.getPoolId();\n        (uint256 pti, uint256 targeti) = pool.getIndices();\n        (ERC20[] memory tokens, uint256[] memory balances, ) = balancerVault.getPoolTokens(poolId);\n        // Determine how much Target we'll need in to get `ytBal` balance of PT out\n        // (space doesn't directly use of the fields from `SwapRequest` beyond `poolId`, so the values after are placeholders)\n        uint256 targetToBorrow = BalancerPool(pool).onSwap(\n            BalancerPool.SwapRequest({\n                kind: BalancerVault.SwapKind.GIVEN_OUT,\n                tokenIn: tokens[targeti],\n                tokenOut: tokens[pti],\n                amount: ytBal,\n                poolId: poolId,\n                lastChangeBlock: 0,\n                from: address(0),\n                to: address(0),\n                userData: \"\"\n            }),\n            balances[targeti],\n            balances[pti]\n        );\n\n        // Flash borrow target (following actions in `onFlashLoan`)\n        tBal = _flashBorrowAndSwapFromYTs(adapter, maturity, ytBal, targetToBorrow);\n    }\n\n    /// @return tAmount if mode = 0, target received from selling YTs, otherwise, returns 0\n    /// @return issued returns amount of YTs issued (and received) except first provision which returns 0\n    /// @return lpShares LP Shares received from adding liquidity to a Space\n    function _addLiquidity(\n        address adapter,\n        uint256 maturity,\n        uint256 tBal,\n        uint256 minAccepted,\n        uint256 minBptOut,\n        uint8 mode,\n        address receiver,\n        PermitData calldata permit\n    )\n        internal\n        returns (\n            uint256 tAmount,\n            uint256 issued,\n            uint256 lpShares\n        )\n    {\n        // 1. Compute target, issue PTs & YTs & add liquidity to space\n        (issued, lpShares) = _computeIssueAddLiq(adapter, maturity, tBal, minBptOut, receiver);\n\n        if (issued > 0) {\n            // issue = 0 means that we are on the first pool provision or that the pt:target ratio is 0:target\n            if (mode == 0) {\n                // 2. Sell YTs\n                tAmount = _swapYTsForTarget(\n                    address(this),\n                    adapter,\n                    maturity,\n                    issued,\n                    permit // we send permit thought it won't be used\n                );\n                // Check that we got enough target\n                if (tAmount < minAccepted) revert Errors.UnexpectedSwapAmount();\n\n                // 3. Send remaining Target to the receiver\n                ERC20(Adapter(adapter).target()).safeTransfer(receiver, tAmount);\n            } else {\n                // 2. Send YTs to the receiver\n                ERC20(divider.yt(adapter, maturity)).safeTransfer(receiver, issued);\n            }\n        }\n    }\n\n    /// @dev Calculates amount of PTs in target terms (see description on `_computeTarget`) then issues\n    /// PTs and YTs with the calculated amount and finally adds liquidity to space with the PTs issued\n    /// and the diff between the target initially passed and the calculated amount\n    function _computeIssueAddLiq(\n        address adapter,\n        uint256 maturity,\n        uint256 tBal,\n        uint256 minBptOut,\n        address receiver\n    ) internal returns (uint256 issued, uint256 lpShares) {\n        BalancerPool pool = BalancerPool(spaceFactory.pools(adapter, maturity));\n        // Compute target\n        (ERC20[] memory tokens, uint256[] memory balances, ) = balancerVault.getPoolTokens(pool.getPoolId());\n        (uint256 pti, uint256 targeti) = pool.getIndices(); // Ensure we have the right token Indices\n\n        // We do not add Principal Token liquidity if it haven't been initialized yet\n        bool ptInitialized = balances[pti] != 0;\n        uint256 ptBalInTarget = ptInitialized ? _computeTarget(adapter, balances[pti], balances[targeti], tBal) : 0;\n\n        // Issue PT & YT (skip if first pool provision)\n        issued = ptBalInTarget > 0 ? divider.issue(adapter, maturity, ptBalInTarget) : 0;\n\n        // Add liquidity to Space & send the LP Shares to recipient\n        uint256[] memory amounts = new uint256[](2);\n        amounts[targeti] = tBal - ptBalInTarget;\n        amounts[pti] = issued;\n        lpShares = _addLiquidityToSpace(pool, PoolLiquidity(tokens, amounts, minBptOut), receiver);\n    }\n\n    /// @dev Based on pt:target ratio from current pool reserves and tBal passed\n    /// calculates amount of tBal needed so as to issue PTs that would keep the ratio\n    function _computeTarget(\n        address adapter,\n        uint256 ptiBal,\n        uint256 targetiBal,\n        uint256 tBal\n    ) internal returns (uint256 tBalForIssuance) {\n        return\n            tBal.fmul(\n                ptiBal.fdiv(\n                    Adapter(adapter).scale().fmul(FixedMath.WAD - Adapter(adapter).ifee()).fmul(targetiBal) + ptiBal\n                )\n            );\n    }\n\n    function _removeLiquidity(\n        address adapter,\n        uint256 maturity,\n        uint256 lpBal,\n        uint256[] memory minAmountsOut,\n        uint256 minAccepted,\n        bool swapPTs,\n        address receiver,\n        PermitData calldata permit\n    ) internal returns (uint256 tBal, uint256 ptBal) {\n        BalancerPool pool = BalancerPool(spaceFactory.pools(adapter, maturity));\n        _transferFrom(permit, address(pool), lpBal);\n\n        // 1. Remove liquidity from Space\n        address pt = divider.pt(adapter, maturity);\n        uint256 _ptBal;\n        (tBal, _ptBal) = _removeLiquidityFromSpace(\n            pool.getPoolId(),\n            pt,\n            Adapter(adapter).target(),\n            minAmountsOut,\n            lpBal\n        );\n\n        if (divider.mscale(adapter, maturity) > 0) {\n            if (uint256(Adapter(adapter).level()).redeemRestricted()) {\n                ptBal = _ptBal;\n            } else {\n                // 2. Redeem PTs for Target\n                tBal += divider.redeem(adapter, maturity, _ptBal);\n            }\n        } else {\n            // 2. Sell PTs for Target (if there are)\n            if (_ptBal > 0 && swapPTs) {\n                tBal += _balancerSwap(\n                    pt,\n                    Adapter(adapter).target(),\n                    _ptBal,\n                    pool.getPoolId(),\n                    minAccepted,\n                    payable(address(this))\n                );\n            } else {\n                ptBal = _ptBal;\n            }\n        }\n        if (ptBal > 0) ERC20(pt).transfer(receiver, ptBal);\n    }\n\n    /// @notice Initiates a flash loan of Target, swaps target amount to PTs and combines\n    /// @param adapter adapter\n    /// @param maturity maturity\n    /// @param ytBalIn YT amount the user has sent in\n    /// @param amountToBorrow target amount to borrow\n    /// @return tBal amount of Target obtained from a sale of YTs\n    function _flashBorrowAndSwapFromYTs(\n        address adapter,\n        uint256 maturity,\n        uint256 ytBalIn,\n        uint256 amountToBorrow\n    ) internal returns (uint256 tBal) {\n        ERC20 target = ERC20(Adapter(adapter).target());\n        uint256 decimals = target.decimals();\n        uint256 acceptableError = decimals < 9 ? 1 : PRICE_ESTIMATE_ACCEPTABLE_ERROR / 10**(18 - decimals);\n        bool result = Adapter(adapter).flashLoan(\n            this,\n            address(target),\n            amountToBorrow,\n            abi.encode(adapter, uint256(maturity), ytBalIn, ytBalIn - acceptableError, true)\n        );\n        if (!result) revert Errors.FlashBorrowFailed();\n        tBal = target.balanceOf(address(this));\n    }\n\n    /// @notice Initiates a flash loan of Target, issues PTs/YTs and swaps the PTs to Target\n    /// @param adapter adapter\n    /// @param maturity taturity\n    /// @param targetIn Target amount the user has sent in\n    /// @param amountToBorrow Target amount to borrow\n    /// @param minAccepted minimum amount of Target accepted out for the issued PTs\n    /// @return targetBal amount of Target remaining after the flashloan has been paid back\n    /// @return ytBal amount of YTs issued with the borrowed Target and the Target sent in\n    function _flashBorrowAndSwapToYTs(\n        address adapter,\n        uint256 maturity,\n        uint256 targetIn,\n        uint256 amountToBorrow,\n        uint256 minAccepted\n    ) internal returns (uint256 targetBal, uint256 ytBal) {\n        bool result = Adapter(adapter).flashLoan(\n            this,\n            Adapter(adapter).target(),\n            amountToBorrow,\n            abi.encode(adapter, uint256(maturity), targetIn, minAccepted, false)\n        );\n        if (!result) revert Errors.FlashBorrowFailed();\n\n        targetBal = ERC20(Adapter(adapter).target()).balanceOf(address(this));\n        ytBal = ERC20(divider.yt(adapter, maturity)).balanceOf(address(this));\n        emit YTsPurchased(msg.sender, adapter, maturity, targetIn, targetBal, ytBal);\n    }\n\n    /// @dev ERC-3156 Flash loan callback\n    function onFlashLoan(\n        address initiator,\n        address, /* token */\n        uint256 amountBorrrowed,\n        uint256, /* fee */\n        bytes calldata data\n    ) external returns (bytes32) {\n        (address adapter, uint256 maturity, uint256 amountIn, uint256 minAccepted, bool ytToTarget) = abi.decode(\n            data,\n            (address, uint256, uint256, uint256, bool)\n        );\n\n        if (msg.sender != address(adapter)) revert Errors.FlashUntrustedBorrower();\n        if (initiator != address(this)) revert Errors.FlashUntrustedLoanInitiator();\n\n        BalancerPool pool = BalancerPool(spaceFactory.pools(adapter, maturity));\n        ERC20 target = ERC20(Adapter(adapter).target());"
    }
  ]
}