{
  "Title": "[H-07] Incorrect precision assumed from RdpxPriceOracle creates multiple issues related to value inflation/deflation",
  "Content": "\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV2LiquidityAmo.sol#L372> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV2LiquidityAmo.sol#L381> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L539> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1160>\n\nThe `RdpxEthPriceOracle`, available in the audit repo [here](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol), provides the `RdpxV2Core`, the `UniV2LiquidityAmo` and the `PerpetualAtlanticVault` contracts the necessary values for `rdpx` related price calculations.\n\nThe issue is that these contracts expect the returned values to be in `1e8` precision (as stated in the natspec [here](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1224), [here](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV2LiquidityAmo.sol#L378) and [here](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/IPerpetualAtlanticVault.sol#L20C1-L24C65)). But the returned precision [is actually `1e18`](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol#L243).\n\nThis difference creates multiple issues throughout the below contracts:\n\n| Contract                     | Function               | Effect                                                       |\n| ---------------------------- | ---------------------- | ------------------------------------------------------------ |\n| `rdpxV2Core.sol`             | `getRdpxPrice()`       | Returns an `1e18` value when `1e8` expected                  |\n|                              | `calculateBondCost()`  | Deflates the `rdpxRequired`                                  |\n|                              | `calculateAmounts()`   | Inflates the `rdpxRequiredInWeth`                            |\n|                              | `_transfer()`          | Inflates `rdpxAmountInWeth` and may cause possible underflow |\n| `UniV2LiquidityAmo`          | `getLpPriceInEth()`    | Overestimates the lp value                                   |\n| `ReLp.sol`                   | `reLP()`               | Inflates min token amounts                                   |\n| `PerpetualAtlanticVault.sol` | `getUnderlyingPrice()` | Returns `1e18` instead of `1e8`                              |\n|                              | `calculatePremium()`   | Inflates the premium calculation                             |\n\n### Proof of Concept\n\nThe `RdpxEthPriceOracle.sol` file can be found [here](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol)\n\nIt exposes the following functions used in the audit:\n\n*   [`getLpPriceInEth()`](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol#L200)\n*   [`getRdpxPriceInEth()`](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol#L243)\n\nThese two functions provide the current price denominated in `ETH`, with a precision in `1e18`, as confirmed by their respective natspec comments:\n\n```\n    /// @dev Returns the price of LP in ETH in 1e18 decimals\n    function getLpPriceInEth() external view override returns (uint) {\n    ...\n\n    /// @notice Returns the price of rDPX in ETH\n    /// @return price price of rDPX in ETH in 1e18 decimals\n    function getRdpxPriceInEth() external view override returns (uint price) {\n\n```\n\nBut, in the contracts from the audit repo, the business logic (and even the natspec) assumes the returned precision will be `1e8`. See below:\n\nIn the `RdpxV2Core` contract the assumption that the price returned from the oracle is clearly noted in the [natspec](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1227C1-L1227C1) of the `getRdpxPrice()` function:\n\n      /**\n       * @notice Returns the price of rDPX against ETH\n       * @dev    Price is in 1e8 Precision\n       * @return rdpxPriceInEth rDPX price in ETH\n       **/\n      function getRdpxPrice() public view returns (uint256) {\n        return\n          IRdpxEthOracle(pricingOracleAddresses.rdpxPriceOracle)\n            .getRdpxPriceInEth();\n      }\n\nIn `UniV2LiquidityAmo` the assumption is noted [here](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV2LiquidityAmo.sol#L378):\n\n      /**\n       * @notice Returns the price of a rDPX/ETH Lp token against the alpha token\n       * @dev    Price is in 1e8 Precision\n       * @return uint256 LP price\n       **/\n      function getLpPrice() public view returns (uint256) {\n\nAnd it has business logic implication here:\n\n      function getLpTokenBalanceInWeth() external view returns (uint256) {\n        return (lpTokenBalance * getLpPrice()) / 1e8;\n      }\n\nIn `PerpetualAtlanticVault` it is noted [here](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/IPerpetualAtlanticVault.sol#L21):\n\n      /**\n       * @notice Returns the price of the underlying in ETH in 1e8 precision\n       * @return uint256 the current underlying price\n       **/\n      function getUnderlyingPrice() external view returns (uint256);\n\nAnd the business logic implications in this contract are primarily found in the `calculatePremium` function, where the premium is divided by `1e8`:\n\n      function calculatePremium(\n        uint256 _strike,\n        uint256 _amount,\n        uint256 timeToExpiry,\n        uint256 _price\n      ) public view returns (uint256 premium) {\n        premium = ((IOptionPricing(addresses.optionPricing).getOptionPrice(\n          _strike,\n          _price > 0 ? _price : getUnderlyingPrice(),\n          getVolatility(_strike),\n          timeToExpiry\n        ) * _amount) / 1e8);\n      }\n\nFrom the audit files it's clear that the assumption was that the returned price would be in `1e8`, but this is Dopex's own `RdpxPriceOracle`, so was likely a simple oversight which slipped through testing as a `MockRdpxEthPriceOracle` was implemented to simplify testing, which mocked the values from the oracle, but only to a `1e8` precision.\n\n### Recommended Mitigation Steps\n\nFor price feeds where `WETH` will be token B, it is convention (although not a standard, as far as the reviewer is aware), that the precision returned will be `1e18`. See [here](https://ethereum.stackexchange.com/questions/92508/do-all-chainlink-feeds-return-prices-with-8-decimals-of-precision).\n\nAs the sponsor indicated that the team might move to Chainlink oracles, it is suggested to modify the `RdpxV2Core`, `PerpetualAtlanticVault`, `UniV2Liquidity` and the `ReLp` contracts to work with the returned `1e18` precision, assuming that the keep the token pair as rdpx/WETH.\n\n**[psytama (Dopex) confirmed and commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/549#issuecomment-1733729931):**\n > The issue is in the oracle contract which returns 1e18.\n\n**[Alex the Entreprenerd (Judge) commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/549#issuecomment-1759261378):**\n > Seems like the Warden grouped a bunch of consequences down to the root cause of the oracle precision.\n> \n> I'll need to determine how to group / ungroup findings as there seem to be multple impacts but a single root cause.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-08-dopex",
  "Code": [
    {
      "filename": "contracts/amo/UniV2LiquidityAmo.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\nimport { IUniswapV2Router } from \"../uniswap_V2/IUniswapV2Router.sol\";\nimport { IUniswapV2Pair } from \"../uniswap_V2/IUniswapV2Pair.sol\";\nimport { IRdpxEthOracle } from \"../interfaces/IRdpxEthOracle.sol\";\nimport { IRdpxV2Core } from \"../core/IRdpxV2Core.sol\";\n\n// Libraries\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title UniswapV2LiquidityAmo contract\n/// @author Dopex\n/// @notice The uniswap v2 liquidity amo contract\ncontract UniV2LiquidityAMO is AccessControl {\n  using SafeERC20 for IERC20WithBurn;\n  using SafeMath for uint256;\n\n  // ================================ STATE VARIABLES ================================ //\n  struct Addresses {\n    // token A address\n    address tokenA; // rdpx\n    // token B address\n    address tokenB; // weth\n    // pair address\n    address pair;\n    // rdpxV2Core address\n    address rdpxV2Core;\n    // rdpx price oracle\n    address rdpxOracle;\n    // AMM Factory\n    address ammFactory;\n    // AMM Router\n    address ammRouter;\n  }\n\n  /// @notice  addresses of the contracts\n  Addresses public addresses;\n\n  /// @notice Precision used for prices, percentages and other calculations\n  uint256 public constant DEFAULT_PRECISION = 1e8;\n\n  /// @notice The slippage tolernce in swaps in 1e8 precision\n  uint256 public slippageTolerance = 5e5; // 0.5%\n\n  /// @notice LP token Balance\n  uint256 public lpTokenBalance;\n\n  // ================================ CONSTRUCTOR ================================ //\n  constructor() {\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n  }\n\n  // ================================ ADMIN FUNCTIONS ================================ //\n\n  /**\n   * @notice Set the addresses of the contracts\n   * @dev    Can only be called by admin\n   * @param  _tokenA the token A address\n   * @param  _tokenB the token B address\n   * @param _pair the pair address\n   * @param _rdpxV2Core the rdpxV2Core address\n   * @param _rdpxOracle the rdpx price oracle\n   * @param _ammFactory the AMM Factory\n   * @param _ammRouter the AMM Router\n   **/\n  function setAddresses(\n    address _tokenA,\n    address _tokenB,\n    address _pair,\n    address _rdpxV2Core,\n    address _rdpxOracle,\n    address _ammFactory,\n    address _ammRouter\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(\n      _tokenA != address(0) &&\n        _tokenB != address(0) &&\n        _pair != address(0) &&\n        _rdpxV2Core != address(0) &&\n        _rdpxOracle != address(0) &&\n        _ammFactory != address(0) &&\n        _ammRouter != address(0),\n      \"reLPContract: address cannot be 0\"\n    );\n    addresses = Addresses({\n      tokenA: _tokenA,\n      tokenB: _tokenB,\n      pair: _pair,\n      rdpxV2Core: _rdpxV2Core,\n      rdpxOracle: _rdpxOracle,\n      ammFactory: _ammFactory,\n      ammRouter: _ammRouter\n    });\n  }\n\n  /**\n   * @notice sets the slippage tolerance\n   * @dev    Can only be called by admin\n   * @param  _slippageTolerance the slippage tolerance\n   */\n  function setSlippageTolerance(\n    uint256 _slippageTolerance\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(\n      _slippageTolerance > 0,\n      \"reLPContract: slippage tolerance must be greater than 0\"\n    );\n    slippageTolerance = _slippageTolerance;\n  }\n\n  /**\n   * @notice Approve a contract to spend a certain amount of tokens\n   * @dev    Can only be called by admin\n   * @param  _token the address of the token to approve\n   * @param  _spender the address of the contract to approve\n   * @param  _amount the amount to approve\n   */\n  function approveContractToSpend(\n    address _token,\n    address _spender,\n    uint256 _amount\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(_token != address(0), \"reLPContract: token cannot be 0\");\n    require(_spender != address(0), \"reLPContract: spender cannot be 0\");\n    require(_amount > 0, \"reLPContract: amount must be greater than 0\");\n    IERC20WithBurn(_token).approve(_spender, _amount);\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    emit LogEmergencyWithdraw(msg.sender, tokens);\n  }\n\n  // ================================ INTERNAL FUNCTIONS ================================ //\n\n  /**\n   * @dev sends token A and B to the rdpxV2Core\n   */\n  function _sendTokensToRdpxV2Core() internal {\n    uint256 tokenABalance = IERC20WithBurn(addresses.tokenA).balanceOf(\n      address(this)\n    );\n    uint256 tokenBBalance = IERC20WithBurn(addresses.tokenB).balanceOf(\n      address(this)\n    );\n    // transfer token A and B from this contract to the rdpxV2Core\n    IERC20WithBurn(addresses.tokenA).safeTransfer(\n      addresses.rdpxV2Core,\n      tokenABalance\n    );\n    IERC20WithBurn(addresses.tokenB).safeTransfer(\n      addresses.rdpxV2Core,\n      tokenBBalance\n    );\n\n    emit LogAssetsTransfered(msg.sender, tokenABalance, tokenBBalance);\n  }\n\n  // ================================ AMO FUNCTIONS ================================ //\n\n  /**\n   * @dev adds liquidity to the uni v2 pool\n   * @param tokenAAmount the amount of token A to add\n   * @param tokenBAmount the amount of token B to add\n   * @param tokenAAmountMin the minimum amount of token A to add\n   * @param tokenBAmountMin the minimum amount of token B to add\n   */\n  function addLiquidity(\n    uint256 tokenAAmount,\n    uint256 tokenBAmount,\n    uint256 tokenAAmountMin,\n    uint256 tokenBAmountMin\n  )\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n    returns (uint256 tokenAUsed, uint256 tokenBUsed, uint256 lpReceived)\n  {\n    // approve the AMM Router\n    IERC20WithBurn(addresses.tokenA).safeApprove(\n      addresses.ammRouter,\n      tokenAAmount\n    );\n    IERC20WithBurn(addresses.tokenB).safeApprove(\n      addresses.ammRouter,\n      tokenBAmount\n    );\n\n    // transfer token A and B from the rdpxV2Core to this contract\n    IERC20WithBurn(addresses.tokenA).safeTransferFrom(\n      addresses.rdpxV2Core,\n      address(this),\n      tokenAAmount\n    );\n    IERC20WithBurn(addresses.tokenB).safeTransferFrom(\n      addresses.rdpxV2Core,\n      address(this),\n      tokenBAmount\n    );\n\n    // add Liquidity\n    (tokenAUsed, tokenBUsed, lpReceived) = IUniswapV2Router(addresses.ammRouter)\n      .addLiquidity(\n        addresses.tokenA,\n        addresses.tokenB,\n        tokenAAmount,\n        tokenBAmount,\n        tokenAAmountMin,\n        tokenBAmountMin,\n        address(this),\n        block.timestamp + 1\n      );\n\n    // update LP token Balance\n    lpTokenBalance += lpReceived;\n\n    // send unused token A and token B back to rdpxV2Core\n    _sendTokensToRdpxV2Core();\n\n    emit LogAddLiquidity(\n      msg.sender,\n      tokenAAmount,\n      tokenBAmount,\n      tokenAAmountMin,\n      tokenBAmountMin,\n      tokenAUsed,\n      tokenBUsed,\n      lpReceived\n    );\n  }\n\n  /**\n   * @dev removes liquidity from the uni v2 pool\n   * @param lpAmount the amount of LP tokens to remove\n   * @param tokenAAmountMin the minimum amount of token A to receive\n   * @param tokenBAmountMin the minimum amount of token B to receive\n   */\n  function removeLiquidity(\n    uint256 lpAmount,\n    uint256 tokenAAmountMin,\n    uint256 tokenBAmountMin\n  )\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n    returns (uint256 tokenAReceived, uint256 tokenBReceived)\n  {\n    // approve the AMM Router\n    IERC20WithBurn(addresses.pair).safeApprove(addresses.ammRouter, lpAmount);\n\n    // remove liquidity\n    (tokenAReceived, tokenBReceived) = IUniswapV2Router(addresses.ammRouter)\n      .removeLiquidity(\n        addresses.tokenA,\n        addresses.tokenB,\n        lpAmount,\n        tokenAAmountMin,\n        tokenBAmountMin,\n        address(this),\n        block.timestamp + 1\n      );\n\n    // update LP token Balance\n    lpTokenBalance -= lpAmount;\n\n    // send unused token A and token B back to rdpxV2Core\n    _sendTokensToRdpxV2Core();\n\n    emit LogRemoveLiquidity(\n      msg.sender,\n      lpAmount,\n      tokenAAmountMin,\n      tokenBAmountMin,\n      tokenAReceived,\n      tokenBReceived\n    );\n  }\n\n  /**\n   * @dev swaps token 1 for token 2\n   * @param token1Amount the amount of token A to swap\n   * @param token2AmountOutMin the minimum amount of token B to receive\n   * @param swapTokenAForTokenB whether to swap token A for token B\n   */\n  function swap(\n    uint256 token1Amount,\n    uint256 token2AmountOutMin,\n    bool swapTokenAForTokenB\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256 token2Amount) {\n    address token1;\n    address token2;\n\n    // check to see if we are swapping token A for token B\n    if (swapTokenAForTokenB) {\n      token1 = addresses.tokenA;\n      token2 = addresses.tokenB;\n    } else {\n      token1 = addresses.tokenB;\n      token2 = addresses.tokenA;\n    }\n    // transfer token A from the rdpxV2Core to this contract\n    IERC20WithBurn(token1).safeTransferFrom(\n      addresses.rdpxV2Core,\n      address(this),\n      token1Amount\n    );\n\n    // approve the AMM Router\n    IERC20WithBurn(token1).safeApprove(addresses.ammRouter, token1Amount);\n\n    address[] memory path;\n    path = new address[](2);\n    path[0] = token1;\n    path[1] = token2;\n\n    // swap token A for token B\n    token2Amount = IUniswapV2Router(addresses.ammRouter)\n      .swapExactTokensForTokens(\n        token1Amount,\n        token2AmountOutMin,\n        path,\n        address(this),\n        block.timestamp + 1\n      )[path.length - 1];\n\n    // send tokens back to rdpxV2Core\n    _sendTokensToRdpxV2Core();\n\n    emit LogSwap(\n      msg.sender,\n      token1Amount,\n      token2AmountOutMin,\n      swapTokenAForTokenB,\n      token2Amount\n    );\n  }\n\n  // ================================ EXTERNAL FUNCTIONS ================================ //\n\n  /**\n   * @notice Syncs asset reserves with contract balances\n   **/\n  function sync() external {\n    lpTokenBalance = IERC20WithBurn(addresses.pair).balanceOf(address(this));\n  }\n\n  // ================================ VIEW FUNCTIONS ================================ //\n  /**\n   * @notice Returns the LP token balance in weth\n   * @dev returns LP token balance\n   * @return lpTokenBalanceInWeth the LP token balance in weth\n   */\n  function getLpTokenBalanceInWeth() external view returns (uint256) {\n    return (lpTokenBalance * getLpPrice()) / 1e8;\n  }\n\n  /**\n   * @notice Returns the price of a rDPX/ETH Lp token against the alpha token\n   * @dev    Price is in 1e8 Precision\n   * @return uint256 LP price\n   **/\n  function getLpPrice() public view returns (uint256) {\n    return IRdpxEthOracle(addresses.rdpxOracle).getLpPriceInEth();\n  }\n\n  // ================================ Events FUNCTIONS ================================ //\n\n  event LogAddLiquidity(\n    address indexed sender,\n    uint256 tokenAAmount,\n    uint256 tokenBAmount,\n    uint256 tokenAAmountMin,\n    uint256 tokenBAmountMin,\n    uint256 tokenAUsed,\n    uint256 tokenBUsed,\n    uint256 lpReceived\n  );\n\n  event LogRemoveLiquidity(\n    address indexed sender,\n    uint256 lpAmount,\n    uint256 tokenAAmountMin,\n    uint256 tokenBAmountMin,\n    uint256 tokenAReceived,\n    uint256 tokenBReceived\n  );\n\n  event LogSwap(\n    address indexed sender,\n    uint256 token1Amount,\n    uint256 token2AmountOutMin,\n    bool swapTokenAForTokenB,\n    uint256 token2Amount\n  );\n\n  event LogAssetsTransfered(\n    address indexed sender,\n    uint256 tokenAAmount,\n    uint256 tokenBAmount\n  );\n\n  event LogEmergencyWithdraw(address sender, address[] tokens);\n}"
    },
    {
      "filename": "contracts/amo/UniV2LiquidityAmo.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\nimport { IUniswapV2Router } from \"../uniswap_V2/IUniswapV2Router.sol\";\nimport { IUniswapV2Pair } from \"../uniswap_V2/IUniswapV2Pair.sol\";\nimport { IRdpxEthOracle } from \"../interfaces/IRdpxEthOracle.sol\";\nimport { IRdpxV2Core } from \"../core/IRdpxV2Core.sol\";\n\n// Libraries\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title UniswapV2LiquidityAmo contract\n/// @author Dopex\n/// @notice The uniswap v2 liquidity amo contract\ncontract UniV2LiquidityAMO is AccessControl {\n  using SafeERC20 for IERC20WithBurn;\n  using SafeMath for uint256;\n\n  // ================================ STATE VARIABLES ================================ //\n  struct Addresses {\n    // token A address\n    address tokenA; // rdpx\n    // token B address\n    address tokenB; // weth\n    // pair address\n    address pair;\n    // rdpxV2Core address\n    address rdpxV2Core;\n    // rdpx price oracle\n    address rdpxOracle;\n    // AMM Factory\n    address ammFactory;\n    // AMM Router\n    address ammRouter;\n  }\n\n  /// @notice  addresses of the contracts\n  Addresses public addresses;\n\n  /// @notice Precision used for prices, percentages and other calculations\n  uint256 public constant DEFAULT_PRECISION = 1e8;\n\n  /// @notice The slippage tolernce in swaps in 1e8 precision\n  uint256 public slippageTolerance = 5e5; // 0.5%\n\n  /// @notice LP token Balance\n  uint256 public lpTokenBalance;\n\n  // ================================ CONSTRUCTOR ================================ //\n  constructor() {\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n  }\n\n  // ================================ ADMIN FUNCTIONS ================================ //\n\n  /**\n   * @notice Set the addresses of the contracts\n   * @dev    Can only be called by admin\n   * @param  _tokenA the token A address\n   * @param  _tokenB the token B address\n   * @param _pair the pair address\n   * @param _rdpxV2Core the rdpxV2Core address\n   * @param _rdpxOracle the rdpx price oracle\n   * @param _ammFactory the AMM Factory\n   * @param _ammRouter the AMM Router\n   **/\n  function setAddresses(\n    address _tokenA,\n    address _tokenB,\n    address _pair,\n    address _rdpxV2Core,\n    address _rdpxOracle,\n    address _ammFactory,\n    address _ammRouter\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(\n      _tokenA != address(0) &&\n        _tokenB != address(0) &&\n        _pair != address(0) &&\n        _rdpxV2Core != address(0) &&\n        _rdpxOracle != address(0) &&\n        _ammFactory != address(0) &&\n        _ammRouter != address(0),\n      \"reLPContract: address cannot be 0\"\n    );\n    addresses = Addresses({\n      tokenA: _tokenA,\n      tokenB: _tokenB,\n      pair: _pair,\n      rdpxV2Core: _rdpxV2Core,\n      rdpxOracle: _rdpxOracle,\n      ammFactory: _ammFactory,\n      ammRouter: _ammRouter\n    });\n  }\n\n  /**\n   * @notice sets the slippage tolerance\n   * @dev    Can only be called by admin\n   * @param  _slippageTolerance the slippage tolerance\n   */\n  function setSlippageTolerance(\n    uint256 _slippageTolerance\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(\n      _slippageTolerance > 0,\n      \"reLPContract: slippage tolerance must be greater than 0\"\n    );\n    slippageTolerance = _slippageTolerance;\n  }\n\n  /**\n   * @notice Approve a contract to spend a certain amount of tokens\n   * @dev    Can only be called by admin\n   * @param  _token the address of the token to approve\n   * @param  _spender the address of the contract to approve\n   * @param  _amount the amount to approve\n   */\n  function approveContractToSpend(\n    address _token,\n    address _spender,\n    uint256 _amount\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(_token != address(0), \"reLPContract: token cannot be 0\");\n    require(_spender != address(0), \"reLPContract: spender cannot be 0\");\n    require(_amount > 0, \"reLPContract: amount must be greater than 0\");\n    IERC20WithBurn(_token).approve(_spender, _amount);\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    emit LogEmergencyWithdraw(msg.sender, tokens);\n  }\n\n  // ================================ INTERNAL FUNCTIONS ================================ //\n\n  /**\n   * @dev sends token A and B to the rdpxV2Core\n   */\n  function _sendTokensToRdpxV2Core() internal {\n    uint256 tokenABalance = IERC20WithBurn(addresses.tokenA).balanceOf(\n      address(this)\n    );\n    uint256 tokenBBalance = IERC20WithBurn(addresses.tokenB).balanceOf(\n      address(this)\n    );\n    // transfer token A and B from this contract to the rdpxV2Core\n    IERC20WithBurn(addresses.tokenA).safeTransfer(\n      addresses.rdpxV2Core,\n      tokenABalance\n    );\n    IERC20WithBurn(addresses.tokenB).safeTransfer(\n      addresses.rdpxV2Core,\n      tokenBBalance\n    );\n\n    emit LogAssetsTransfered(msg.sender, tokenABalance, tokenBBalance);\n  }\n\n  // ================================ AMO FUNCTIONS ================================ //\n\n  /**\n   * @dev adds liquidity to the uni v2 pool\n   * @param tokenAAmount the amount of token A to add\n   * @param tokenBAmount the amount of token B to add\n   * @param tokenAAmountMin the minimum amount of token A to add\n   * @param tokenBAmountMin the minimum amount of token B to add\n   */\n  function addLiquidity(\n    uint256 tokenAAmount,\n    uint256 tokenBAmount,\n    uint256 tokenAAmountMin,\n    uint256 tokenBAmountMin\n  )\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n    returns (uint256 tokenAUsed, uint256 tokenBUsed, uint256 lpReceived)\n  {\n    // approve the AMM Router\n    IERC20WithBurn(addresses.tokenA).safeApprove(\n      addresses.ammRouter,\n      tokenAAmount\n    );\n    IERC20WithBurn(addresses.tokenB).safeApprove(\n      addresses.ammRouter,\n      tokenBAmount\n    );\n\n    // transfer token A and B from the rdpxV2Core to this contract\n    IERC20WithBurn(addresses.tokenA).safeTransferFrom(\n      addresses.rdpxV2Core,\n      address(this),\n      tokenAAmount\n    );\n    IERC20WithBurn(addresses.tokenB).safeTransferFrom(\n      addresses.rdpxV2Core,\n      address(this),\n      tokenBAmount\n    );\n\n    // add Liquidity\n    (tokenAUsed, tokenBUsed, lpReceived) = IUniswapV2Router(addresses.ammRouter)\n      .addLiquidity(\n        addresses.tokenA,\n        addresses.tokenB,\n        tokenAAmount,\n        tokenBAmount,\n        tokenAAmountMin,\n        tokenBAmountMin,\n        address(this),\n        block.timestamp + 1\n      );\n\n    // update LP token Balance\n    lpTokenBalance += lpReceived;\n\n    // send unused token A and token B back to rdpxV2Core\n    _sendTokensToRdpxV2Core();\n\n    emit LogAddLiquidity(\n      msg.sender,\n      tokenAAmount,\n      tokenBAmount,\n      tokenAAmountMin,\n      tokenBAmountMin,\n      tokenAUsed,\n      tokenBUsed,\n      lpReceived\n    );\n  }\n\n  /**\n   * @dev removes liquidity from the uni v2 pool\n   * @param lpAmount the amount of LP tokens to remove\n   * @param tokenAAmountMin the minimum amount of token A to receive\n   * @param tokenBAmountMin the minimum amount of token B to receive\n   */\n  function removeLiquidity(\n    uint256 lpAmount,\n    uint256 tokenAAmountMin,\n    uint256 tokenBAmountMin\n  )\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n    returns (uint256 tokenAReceived, uint256 tokenBReceived)\n  {\n    // approve the AMM Router\n    IERC20WithBurn(addresses.pair).safeApprove(addresses.ammRouter, lpAmount);\n\n    // remove liquidity\n    (tokenAReceived, tokenBReceived) = IUniswapV2Router(addresses.ammRouter)\n      .removeLiquidity(\n        addresses.tokenA,\n        addresses.tokenB,\n        lpAmount,\n        tokenAAmountMin,\n        tokenBAmountMin,\n        address(this),\n        block.timestamp + 1\n      );\n\n    // update LP token Balance\n    lpTokenBalance -= lpAmount;\n\n    // send unused token A and token B back to rdpxV2Core\n    _sendTokensToRdpxV2Core();\n\n    emit LogRemoveLiquidity(\n      msg.sender,\n      lpAmount,\n      tokenAAmountMin,\n      tokenBAmountMin,\n      tokenAReceived,\n      tokenBReceived\n    );\n  }\n\n  /**\n   * @dev swaps token 1 for token 2\n   * @param token1Amount the amount of token A to swap\n   * @param token2AmountOutMin the minimum amount of token B to receive\n   * @param swapTokenAForTokenB whether to swap token A for token B\n   */\n  function swap(\n    uint256 token1Amount,\n    uint256 token2AmountOutMin,\n    bool swapTokenAForTokenB\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256 token2Amount) {\n    address token1;\n    address token2;\n\n    // check to see if we are swapping token A for token B\n    if (swapTokenAForTokenB) {\n      token1 = addresses.tokenA;\n      token2 = addresses.tokenB;\n    } else {\n      token1 = addresses.tokenB;\n      token2 = addresses.tokenA;\n    }\n    // transfer token A from the rdpxV2Core to this contract\n    IERC20WithBurn(token1).safeTransferFrom(\n      addresses.rdpxV2Core,\n      address(this),\n      token1Amount\n    );\n\n    // approve the AMM Router\n    IERC20WithBurn(token1).safeApprove(addresses.ammRouter, token1Amount);\n\n    address[] memory path;\n    path = new address[](2);\n    path[0] = token1;\n    path[1] = token2;\n\n    // swap token A for token B\n    token2Amount = IUniswapV2Router(addresses.ammRouter)\n      .swapExactTokensForTokens(\n        token1Amount,\n        token2AmountOutMin,\n        path,\n        address(this),\n        block.timestamp + 1\n      )[path.length - 1];\n\n    // send tokens back to rdpxV2Core\n    _sendTokensToRdpxV2Core();\n\n    emit LogSwap(\n      msg.sender,\n      token1Amount,\n      token2AmountOutMin,\n      swapTokenAForTokenB,\n      token2Amount\n    );\n  }\n\n  // ================================ EXTERNAL FUNCTIONS ================================ //\n\n  /**\n   * @notice Syncs asset reserves with contract balances\n   **/\n  function sync() external {\n    lpTokenBalance = IERC20WithBurn(addresses.pair).balanceOf(address(this));\n  }\n\n  // ================================ VIEW FUNCTIONS ================================ //\n  /**\n   * @notice Returns the LP token balance in weth\n   * @dev returns LP token balance\n   * @return lpTokenBalanceInWeth the LP token balance in weth\n   */\n  function getLpTokenBalanceInWeth() external view returns (uint256) {\n    return (lpTokenBalance * getLpPrice()) / 1e8;\n  }\n\n  /**\n   * @notice Returns the price of a rDPX/ETH Lp token against the alpha token\n   * @dev    Price is in 1e8 Precision\n   * @return uint256 LP price\n   **/\n  function getLpPrice() public view returns (uint256) {\n    return IRdpxEthOracle(addresses.rdpxOracle).getLpPriceInEth();\n  }\n\n  // ================================ Events FUNCTIONS ================================ //\n\n  event LogAddLiquidity(\n    address indexed sender,\n    uint256 tokenAAmount,\n    uint256 tokenBAmount,\n    uint256 tokenAAmountMin,\n    uint256 tokenBAmountMin,\n    uint256 tokenAUsed,\n    uint256 tokenBUsed,\n    uint256 lpReceived\n  );\n\n  event LogRemoveLiquidity(\n    address indexed sender,\n    uint256 lpAmount,\n    uint256 tokenAAmountMin,\n    uint256 tokenBAmountMin,\n    uint256 tokenAReceived,\n    uint256 tokenBReceived\n  );\n\n  event LogSwap(\n    address indexed sender,\n    uint256 token1Amount,\n    uint256 token2AmountOutMin,\n    bool swapTokenAForTokenB,\n    uint256 token2Amount\n  );\n\n  event LogAssetsTransfered(\n    address indexed sender,\n    uint256 tokenAAmount,\n    uint256 tokenBAmount\n  );\n\n  event LogEmergencyWithdraw(address sender, address[] tokens);\n}"
    },
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVault.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Libraries\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contracts\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721Burnable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\nimport { ContractWhitelist } from \"../helper/ContractWhitelist.sol\";\nimport { Pausable } from \"../helper/Pausable.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\nimport { IOptionPricing } from \"../interfaces/IOptionPricing.sol\";\nimport { IRdpxEthOracle } from \"../interfaces/IRdpxEthOracle.sol\";\nimport { IVolatilityOracle } from \"../interfaces/IVolatilityOracle.sol\";\n\n/// @title Contract to offer perpetual atlantic rDPX PUT options to the rdpxV2Core contract\n/// @dev Option tokens are in erc20 18 decimals & Strikes are in 1e8 precision\ncontract PerpetualAtlanticVault is\n  IPerpetualAtlanticVault,\n  ReentrancyGuard,\n  Pausable,\n  ERC721,\n  ERC721Enumerable,\n  ERC721Burnable,\n  AccessControl,\n  ContractWhitelist\n{\n  using SafeERC20 for IERC20WithBurn;\n  using Counters for Counters.Counter;\n\n  /// @dev Token ID counter for write positions\n  Counters.Counter private _tokenIdCounter;\n\n  /// @dev Manager role which handles bootstrapping\n  bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n\n  /// @dev Rdpx v2 core role which can purchase and settle options\n  bytes32 public constant RDPXV2CORE_ROLE = keccak256(\"RDPXV2CORE_ROLE\");\n\n  /// @dev Underlying assets symbol\n  string public underlyingSymbol;\n\n  /// @dev Contract addresses\n  Addresses public addresses;\n\n  /// @dev Collateral Token\n  IERC20WithBurn public collateralToken;\n\n  /// @dev The precision of the collateral token\n  uint256 public collateralPrecision;\n\n  /// @dev tokenId => OptionPosition\n  mapping(uint256 => OptionPosition) public optionPositions;\n\n  /// @dev number of options funding has been accounted for the epoch\n  mapping(uint256 => uint256) public fundingPaymentsAccountedFor;\n\n  /// @dev the funding accounted for the epoch and strike\n  mapping(uint256 => mapping(uint256 => uint256))\n    public fundingPaymentsAccountedForPerStrike;\n\n  /// @dev the total funding for the epoch\n  mapping(uint256 => uint256) public totalFundingForEpoch;\n\n  /// @dev amount of options per strike\n  mapping(uint256 => uint256) public optionsPerStrike;\n\n  /// @dev latest funding update per strike\n  mapping(uint256 => uint256) public latestFundingPerStrike;\n\n  // @dev Funding rate for the epoch\n  mapping(uint256 => uint256) public fundingRates;\n\n  /// @dev the pointer to the lattest funding payment timestamp\n  /// @notice Explain to an end user what this does\n  /// @dev Explain to a developer any extra details\n  /// @return Documents the return variables of a contractâ€™s function state variable\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  uint256 public latestFundingPaymentPointer = 0;\n\n  /// @dev the total number of active options\n  uint256 public totalActiveOptions;\n\n  /// @dev genesis timestamp\n  uint256 public genesis;\n\n  /// @dev the timestamp of the last update where funding was paid for\n  uint256 public lastUpdateTime;\n\n  /// @dev the duration between funding payments\n  uint256 public fundingDuration = 7 days;\n\n  /// @dev the precision to round up to\n  uint256 public roundingPrecision = 1e6;\n\n  // ================================ CONSTRUCTOR ================================ //\n\n  /// @notice Contract constructor\n  /// @param _name ERC721 name\n  /// @param _symbol ERC721 symbol\n  /// @param _collateralToken Collateral token of the perpetual atlantic vault\n  /// @param _gensis Gensis time for funding calculation\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    address _collateralToken,\n    uint256 _gensis\n  ) ERC721(_name, _symbol) {\n    _validate(_collateralToken != address(0), 1);\n\n    collateralToken = IERC20WithBurn(_collateralToken);\n    underlyingSymbol = collateralToken.symbol();\n    collateralPrecision = 10 ** collateralToken.decimals();\n    genesis = _gensis;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _setupRole(MANAGER_ROLE, msg.sender);\n  }\n\n  // ================================ ADMIN FUNCTIONS ================================ //\n\n  /**\n   * @notice Pauses the vault for emergency cases\n   * @dev    Can only be called by the owner\n   **/\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  /**\n   * @notice Unpauses the vault\n   * @dev    Can only be called by the owner\n   **/\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Add a contract to the whitelist\n   * @dev    Can only be called by the owner\n   * @param  _contract Address of the contract that needs to be added to the whitelist\n   **/\n  function addToContractWhitelist(\n    address _contract\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _addToContractWhitelist(_contract);\n  }\n\n  /**\n   * @notice Remove a contract to the whitelist\n   * @dev    Can only be called by the owner\n   * @param  _contract Address of the contract that needs to be removed from the whitelist\n   **/\n  function removeFromContractWhitelist(\n    address _contract\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _removeFromContractWhitelist(_contract);\n  }\n\n  /**\n   * @notice Sets (adds) a list of addresses to the address list\n   * @dev    Can only be called by the owner\n   * @param  _optionPricing Address of the option pricing contract\n   * @param  _assetPriceOracle Address of the asset price oracle contract\n   * @param  _volatilityOracle Address of the volatility oracle contract\n   * @param  _feeDistributor Address of the fee distributor contract\n   * @param  _rdpx Address of the rdpx contract\n   * @param  _perpetualAtlanticVaultLP Address of the perpetual atlantic vault lp contract\n   * @param  _rdpxV2Core Address of the rdpx v2 rdpxV2Core contract\n   **/\n  function setAddresses(\n    address _optionPricing,\n    address _assetPriceOracle,\n    address _volatilityOracle,\n    address _feeDistributor,\n    address _rdpx,\n    address _perpetualAtlanticVaultLP,\n    address _rdpxV2Core\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_optionPricing != address(0), 1);\n    _validate(_assetPriceOracle != address(0), 1);\n    _validate(_volatilityOracle != address(0), 1);\n    _validate(_feeDistributor != address(0), 1);\n    _validate(_rdpx != address(0), 1);\n    _validate(_perpetualAtlanticVaultLP != address(0), 1);\n    _validate(_rdpxV2Core != address(0), 1);\n\n    addresses = Addresses({\n      optionPricing: _optionPricing,\n      assetPriceOracle: _assetPriceOracle,\n      volatilityOracle: _volatilityOracle,\n      feeDistributor: _feeDistributor,\n      rdpx: _rdpx,\n      perpetualAtlanticVaultLP: _perpetualAtlanticVaultLP,\n      rdpxV2Core: _rdpxV2Core\n    });\n    collateralToken.safeApprove(\n      addresses.perpetualAtlanticVaultLP,\n      type(uint256).max\n    );\n    emit AddressesSet(addresses);\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _whenPaused();\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    emit EmergencyWithdraw(msg.sender, tokens);\n  }\n\n  /**\n   * @notice Updates the funding duration\n   * @dev    Can only be called by the owner\n   **/\n  function updateFundingDuration(\n    uint256 _fundingDuration\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    fundingDuration = _fundingDuration;\n  }\n\n  function setLpAllowance(bool increase) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    increase\n      ? collateralToken.approve(\n        ad"
    }
  ]
}