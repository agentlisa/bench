{
  "Title": "[M-09] Non-ideal rETH/WETH pool used pays unnecessary fees",
  "Content": "\nrETH is acquired using the Uniswap rETH/WETH pool. This solution has higher fees and lower liquidity than alternatives, which results in more lost user value than other solutions.\n\nThe Uniswap rETH/WETH pool that is used in Reth.sol to make swaps has a liquidity of `$5 million`. In comparison, the Balancer rETH/WETH pool has a liquidity of `$80 million`. Even the Curve rETH/WETH pool has a liquidity of `$8 million`. The greater liquidity should normally offer lower slippage to users. In addition, the fees to swap with the Balancer pool are only 0.04% compared to Uniswap's 0.05%. Even the Curve pool offers a lower fee than Uniswap with just a 0.037% fee. [This Dune Analytics dashboard](https://dune.com/drworm/rocketpool) shows that Balancer is where the majority of rETH swaps happen by volume.\n\nOne solution to finding the best swap path for rETH is to use RocketPool's [RocketSwapRouter.sol contract `swapTo()` function](https://etherscan.io/address/0x16d5a408e807db8ef7c578279beeee6b228f1c1c#code#F19#L64). When users visit the RocketPool frontend to swap ETH for rETH, this is the function that RocketPool calls for the user. RocketSwapRouter.sol automatically determines the best way to split the swap between Balancer and Uniswap pools.\n\n### Proof of Concept\n\nPools that can be used for rETH/WETH swapping:\n\n*   [Uniswap rETH/WETH pool](https://etherscan.io/address/0xa4e0faA58465A2D369aa21B3e42d43374c6F9613): `$5 million` in liquidity\n*   [Balancer rETH/WETH pool](https://app.balancer.fi/#/ethereum/pool/0x1e19cf2d73a72ef1332c882f20534b6519be0276000200000000000000000112)\n*   [Curve Finance rETH/ETH pool](https://curve.fi/#/ethereum/pools/factory-crypto-210/deposit): `$8 million` in liquidity\n\n[Line where Reth.sol swaps WETH for rETH](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L101) with the Uniswap rETH/WETH pool.\n\n### Tools Used\n\nEtherscan, Dune Analytics\n\n### Recommended Mitigation Steps\n\nThe best solution is to use the same flow as RocketPool's frontend UI and to call `swapTo()` in [RocketSwapRouter.sol](https://etherscan.io/address/0x16d5a408e807db8ef7c578279beeee6b228f1c1c#code#F19#L64). An alternative is to modify Reth.sol to use the Balancer rETH/ETH pool for swapping instead of Uniswap's rETH/WETH pool to better conserve user value by reducing swap fees and reducing slippage costs.\n\n**[elmutt (Asymmetry) confirmed](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/673#issuecomment-1500475916)**\n\n**[d3e4 (warden) commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/673#issuecomment-1522589442):**\n > What is the issue here? This is an improvement proposal (QA). \n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/673#issuecomment-1525233121):**\n > My reasoning was that it's not an improvement proposal but a bug (sub-optimal of the AMM pool), hence it does qualify for Medium for \"leak of value\".\n> \n> I have to admit that I hesitated but I leaned towards Medium because of the label \"sponsor confirmed\" suggesting that this finding provided value for the sponsor.\n\n**Asymmetry mitigated**\n\n**Status:** Mitigation confirmed. Full details in reports from [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/37) and [0x52](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/19).\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-03-asymmetry",
  "Code": [
    {
      "filename": "contracts/SafEth/derivatives/Reth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IDerivative.sol\";\nimport \"../../interfaces/frax/IsFrxEth.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/rocketpool/RocketStorageInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketTokenRETHInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketDepositPoolInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketDAOProtocolSettingsDepositInterface.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../interfaces/uniswap/ISwapRouter.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../interfaces/uniswap/IUniswapV3Factory.sol\";\nimport \"../../interfaces/uniswap/IUniswapV3Pool.sol\";\n\n/// @title Derivative contract for rETH\n/// @author Asymmetry Finance\ncontract Reth is IDerivative, Initializable, OwnableUpgradeable {\n    address public constant ROCKET_STORAGE_ADDRESS =\n        0x1d8f8f00cfa6758d7bE78336684788Fb0ee0Fa46;\n    address public constant W_ETH_ADDRESS =\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant UNISWAP_ROUTER =\n        0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n    address public constant UNI_V3_FACTORY =\n        0x1F98431c8aD98523631AE4a59f267346ea31F984;\n\n    uint256 public maxSlippage;\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _owner - owner of the contract which handles stake/unstake\n    */\n    function initialize(address _owner) external initializer {\n        _transferOwnership(_owner);\n        maxSlippage = (1 * 10 ** 16); // 1%\n    }\n\n    /**\n        @notice - Return derivative name\n    */\n    function name() public pure returns (string memory) {\n        return \"RocketPool\";\n    }\n\n    /**\n        @notice - Owner only function to set max slippage for derivative\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(uint256 _slippage) external onlyOwner {\n        maxSlippage = _slippage;\n    }\n\n    /**\n        @notice - Get rETH address\n        @dev - per RocketPool Docs query addresses each time it is used\n     */\n    function rethAddress() private view returns (address) {\n        return\n            RocketStorageInterface(ROCKET_STORAGE_ADDRESS).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                )\n            );\n    }\n\n    /**\n        @notice - Swap tokens through Uniswap\n        @param _tokenIn - token to swap from\n        @param _tokenOut - token to swap to\n        @param _poolFee - pool fee for particular swap\n        @param _amountIn - amount of token to swap from\n        @param _minOut - minimum amount of token to receive (slippage)\n     */\n    function swapExactInputSingleHop(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _poolFee,\n        uint256 _amountIn,\n        uint256 _minOut\n    ) private returns (uint256 amountOut) {\n        IERC20(_tokenIn).approve(UNISWAP_ROUTER, _amountIn);\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\n            .ExactInputSingleParams({\n                tokenIn: _tokenIn,\n                tokenOut: _tokenOut,\n                fee: _poolFee,\n                recipient: address(this),\n                amountIn: _amountIn,\n                amountOutMinimum: _minOut,\n                sqrtPriceLimitX96: 0\n            });\n        amountOut = ISwapRouter(UNISWAP_ROUTER).exactInputSingle(params);\n    }\n\n    /**\n        @notice - Convert derivative into ETH\n     */\n    function withdraw(uint256 amount) external onlyOwner {\n        RocketTokenRETHInterface(rethAddress()).burn(amount);\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n    }\n\n    /**\n        @notice - Check whether or not rETH deposit pool has room users amount\n        @param _amount - amount that will be deposited\n     */\n    function poolCanDeposit(uint256 _amount) private view returns (bool) {\n        address rocketDepositPoolAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n                )\n            );\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n                rocketDepositPoolAddress\n            );\n\n        address rocketProtocolSettingsAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\n                        \"contract.address\",\n                        \"rocketDAOProtocolSettingsDeposit\"\n                    )\n                )\n            );\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(\n                rocketProtocolSettingsAddress\n            );\n\n        return\n            rocketDepositPool.getBalance() + _amount <=\n            rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize() &&\n            _amount >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit();\n    }\n\n    /**\n        @notice - Deposit into derivative\n        @dev - will either get rETH on exchange or deposit into contract depending on availability\n     */\n    function deposit() external payable onlyOwner returns (uint256) {\n        // Per RocketPool Docs query addresses each time it is used\n        address rocketDepositPoolAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n                )\n            );\n\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n                rocketDepositPoolAddress\n            );\n\n        if (!poolCanDeposit(msg.value)) {\n            uint rethPerEth = (10 ** 36) / poolPrice();\n\n            uint256 minOut = ((((rethPerEth * msg.value) / 10 ** 18) *\n                ((10 ** 18 - maxSlippage))) / 10 ** 18);\n\n            IWETH(W_ETH_ADDRESS).deposit{value: msg.value}();\n            uint256 amountSwapped = swapExactInputSingleHop(\n                W_ETH_ADDRESS,\n                rethAddress(),\n                500,\n                msg.value,\n                minOut\n            );\n\n            return amountSwapped;\n        } else {\n            address rocketTokenRETHAddress = RocketStorageInterface(\n                ROCKET_STORAGE_ADDRESS\n            ).getAddress(\n                    keccak256(\n                        abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                    )\n                );\n            RocketTokenRETHInterface rocketTokenRETH = RocketTokenRETHInterface(\n                rocketTokenRETHAddress\n            );\n            uint256 rethBalance1 = rocketTokenRETH.balanceOf(address(this));\n            rocketDepositPool.deposit{value: msg.value}();\n            uint256 rethBalance2 = rocketTokenRETH.balanceOf(address(this));\n            require(rethBalance2 > rethBalance1, \"No rETH was minted\");\n            uint256 rethMinted = rethBalance2 - rethBalance1;\n            return (rethMinted);\n        }\n    }\n\n    /**\n        @notice - Get price of derivative in terms of ETH\n        @dev - we need to pass amount so that it gets price from the same source that it buys or mints the rEth\n        @param _amount - amount to check for ETH price\n     */\n    function ethPerDerivative(uint256 _amount) public view returns (uint256) {\n        if (poolCanDeposit(_amount))\n            return\n                RocketTokenRETHInterface(rethAddress()).getEthValue(10 ** 18);\n        else return (poolPrice() * 10 ** 18) / (10 ** 18);\n    }\n\n    /**\n        @notice - Total derivative balance\n     */\n    function balance() public view returns (uint256) {\n        return IERC20(rethAddress()).balanceOf(address(this));\n    }\n\n    /**\n        @notice - Price of derivative in liquidity pool\n     */\n    function poolPrice() private view returns (uint256) {\n        address rocketTokenRETHAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                )\n            );\n        IUniswapV3Factory factory = IUniswapV3Factory(UNI_V3_FACTORY);\n        IUniswapV3Pool pool = IUniswapV3Pool(\n            factory.getPool(rocketTokenRETHAddress, W_ETH_ADDRESS, 500)\n        );\n        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n        return (sqrtPriceX96 * (uint(sqrtPriceX96)) * (1e18)) >> (96 * 2);\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}