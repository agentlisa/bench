{
  "Title": "M-11: ETH withdrawers do not earn yield while waiting for a withdrawal",
  "Content": "# Issue M-11: ETH withdrawers do not earn yield while waiting for a withdrawal \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/370 \n\n## Found by \nmonrel, peanuts\n## Summary\n\nIn the [ Rio doc](https://docs.rio.network/rio-architecture/deposits-and-withdraws) we can read the following\n\n\"Users will continue to earn yield as they wait for their withdrawal request to be processed.\"\n\nThis is not true for withdrawals in ETH since they will simply receive an equivalent to the `sharesOWed` calculated when requesting a withdrawal.\n## Vulnerability Detail\n\nWhen `requestWithdrawal()` is called  to withdraw ETH `sharesOwed` is calculated\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol#L101\n\n```solidity\nsharesOwed = convertToSharesFromRestakingTokens(asset, amountIn);\n```\n\nThe total `sharesOwed` in ETH is added to `epcohWithdrawals.assetsReceived` if we settle with `settleCurrentEpoch()` or `settleEpochFromEigenlayer()` \n\nBelow are the places where `assetsReceived` is is set and accumulated\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol#L194\n```solidity\nepochWithdrawals.assetsReceived = SafeCast.toUint120(assetsReceived);\n```\n\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol#L162\n```solidity\nepochWithdrawals.assetsReceived = SafeCast.toUint120(assetsReceived); \n```\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol#L268\n\n```solidity\nepochWithdrawals.assetsReceived += SafeCast.toUint120(assetsReceived);\n```\n\nwhen claiming rewards this is used to calculate users share\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol#L104\n\n```solidity\namountOut = userSummary.sharesOwed.mulDiv(epochWithdrawals.assetsReceived, epochWithdrawals.sharesOwed);\n\n```\n\n\nThe portion of staking rewards accumulated during withdrawal that belongs to LRT holders is never accounted for so withdrawing users do not earn any rewards when waiting for a withdrawal to be completed. \n## Impact\n\nSince a portion of the staking reward belongs to the LRT holders and since the docs mentions that yield is accumulated while in the queue It is fair to assume that withdrawing users have a proportional claim to the yield.\n\nAs shown above this is not true, users withdrawing in ETH do no earn any rewards when withdrawing.\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol#L268\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol#L194\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol#L162\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol#L104\n\n## Tool used\n\nManual Review\n## Recommendation\n\nAccount for the accumulate rewards during the withdrawal period that belongs to the deposit pool. This can be calculated based on data in DelayedWithdrawalRouter on Eigenlayer.\n\n\n\n## Discussion\n\n**0xmonrel**\n\nEscalate\n\nI will argue that this should be a separate High issue\n\nThis is not a duplicate of #109. This is an entirely different issue. What I show here is that ETH is the only asset that does not earn yield during withdrawal. The documentation clearly states that users earn yield when withdrawing:\n\nFrom [Rio doc](https://docs.rio.network/rio-architecture/deposits-and-withdraws) \"Users will continue to earn yield as they wait for their withdrawal request to be processed.\"\n\nWe should also consider that the time to withdrawal ETH can be longer than the EigenLayer withdrawal period depending on how many other validators are exiting.\n\nHere is the time depending on how many validators are exiting \n\n\n![SCR-20240327-qzov](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/assets/123949319/a0a074ef-306e-41ab-bf80-c62abfe77a33)\n[source](https://figment.io/insights/ethereum-withdrawals-a-comprehensive-faq/)\n\nIf there is a large outflow of exiting validators it could take weeks to even receive the withdrawal status.\n\nEvery single user that withdrawals in ETH lose the yield that they are promised and would have received if they had withdrawn in another asset.\n\nI believe this fulfills the following criteria for a High \"Definite loss of funds without (extensive) limitations of external conditions.\"\n\n**sherlock-admin2**\n\n> Escalate\n> \n> I will argue that this should be a separate High issue\n> \n> This is not a duplicate of #109. This is an entirely different issue. What I show here is that ETH is the only asset that does not earn yield during withdrawal. The documentation clearly states that users earn yield when withdrawing:\n> \n> From [Rio doc](https://docs.rio.network/rio-architecture/deposits-and-withdraws) \"Users will continue to earn yield as they wait for their withdrawal request to be processed.\"\n> \n> We should also consider that the time to withdrawal ETH can be longer than the EigenLayer withdrawal period depending on how many other validators are exiting.\n> \n> Here is the time depending on how many validators are exiting \n> \n> \n> ![SCR-20240327-qzov](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/assets/123949319/a0a074ef-306e-41ab-bf80-c62abfe77a33)\n> [source](https://figment.io/insights/ethereum-withdrawals-a-comprehensive-faq/)\n> \n> If there is a large outflow of exiting validators it could take weeks to even receive the withdrawal status.\n> \n> Every single user that withdrawals in ETH lose the yield that they are promised and would have received if they had withdrawn in another asset.\n> \n> I believe this fulfills the following criteria for a High \"Definite loss of funds without (extensive) limitations of external conditions.\"\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**solimander**\n\nTechnically valid, but would argue the loss is highly constrained in that the only loss is yield while withdrawing. I'll update the docs for this issue.\n\n**nevillehuang**\n\nI believe #177 and #367 to be duplicates of this issue\n\n**0xmonrel**\n\n#177  is not a duplicate it is about rebasing tokens.  #367 is definitely a duplicate.\n\n**nevillehuang**\n\n@solimander I am still unsure if this is not a duplicate of #109 and others. Could you elaborate more and is a separate fix required? The following impact highlighted by the watson seems to indicate otherwise. To me it seems like the same accrual inconsistency due to exchange rate used to compute sharesOwed regardless of type of asset.\n\n> The portion of staking rewards accumulated during withdrawal that belongs to LRT holders is never accounted for so withdrawing users do not earn any rewards when waiting for a withdrawal to be completed.\n\n**solimander**\n\n@nevillehuang The issues do seem slightly different, though the fix being considered will fully fix #109 and partially fix this issue.\n\nThe core issue in #109 is that there's a period between the time that the shares owed is locked and the rebalance occurs in which yield to the EigenLayer strategy can cause a rebalance revert.\n\nLocking shares owed at the time of withdrawal request also affects this issue in that it prevents withdrawals from earning yield at the time the withdrawal request is received. Once a rebalance occurs, this issue has a secondary cause that prevents yield from being earned - unlike other strategies, \"shares\" in the beacon chain strategy are just ETH, so no additional yield can be earned once the withdrawal from EigenLayer is queued.\n\nI plan to address both with the above fix and update the docs to inform users that yield will only be earned between the time of withdrawal request and rebalance for ETH withdrawals.\n\n**0xmonrel**\n\n> @solimander I am still unsure if this is not a duplicate of #109 and others. Could you elaborate more and is a separate fix required? The following impact highlighted by the watson seems to indicate otherwise. To me it seems like the same accrual inconsistency due to exchange rate used to compute sharesOwed regardless of type of asset.\n> \n> > The portion of staking rewards accumulated during withdrawal that belongs to LRT holders is never accounted for so withdrawing users do not earn any rewards when waiting for a withdrawal to be completed.\n\nNo, that issue does not fix this one. This issue can be fixed in protocol but it would require quite a bit of added complexity to account for the correct share of yield. Solimander will instead settle on not giving out yield during the withdrawal process, which of course users needs to be aware of.\n\n@solimander have you considered that the withdrawal of ETH could take weeks or months if the POS withdrawal queue is congested? I just want to confirm that we have covered everything here. \n\nMaybe we can add functionality to compensate users that have their assets locked for a long period of time without earning yield. E.g. if POS withdrawal takes 2 week more than the EigenLayer withdrawal the admin can issue 0-5% APY equivalent amount of yield to the cohort from the deposit pool.\n\nJust brainstorming on a fix that does not add a lot of complexity but defends against the worst case scenario..\n\n---\n\nActually, I think there is reasonable fix that solves all this in protocol. It requires that an Oracle is used to update the cumulative yield in a single storage slot when rebalance is called. We also need to add a mapping `epoch->time` and then let ETH withdrawers take their yield directly from the deposit pool at the time of withdrawal.\n\nSolimander, I can provide an MVP for the above if you are interested. \n\n\n\n\n\n\n\n\n\n**nevillehuang**\n\n> Locking shares owed at the time of withdrawal request also affects this issue in that it prevents withdrawals from earning yield at the time the withdrawal request is received. Once a rebalance occurs, this issue has a secondary cause that prevents yield from being earned - unlike other strategies, \"shares\" in the beacon chain strategy are just ETH, so no additional yield can be earned once the withdrawal from EigenLayer is queued.\n\nThe secondary cause seems to not be highlighted in the original submission. I believe they are duplicates because both issues point to locking of assets (albeit different assets) within deposit pools and locking the exchange rate during deposits. I believe if exchange rate accounts for yield accrued that is supposed to be delegated to the user, both issues would be solved.\n\n**0xmonrel**\n\n> > Locking shares owed at the time of withdrawal request also affects this issue in that it prevents withdrawals from earning yield at the time the withdrawal request is received. Once a rebalance occurs, this issue has a secondary cause that prevents yield from being earned - unlike other strategies, \"shares\" in the beacon chain strategy are just ETH, so no additional yield can be earned once the withdrawal from EigenLayer is queued.\n> \n> \n> \n> The secondary cause seems to not be highlighted in the original submission. I believe they are duplicates because both issues point to locking of assets (albeit different assets) within deposit pools and locking the exchange rate during deposits. I believe if exchange rate accounts for yield accrued that is supposed to be delegated to the user, both issues would be solved.\n\n>I believe if exchange rate accounts for yield accrued that is supposed to be delegated to users, both issues would be solved\n\nLST and ETH earn yield differently. This entire issue is on the topic of how ETH yield is not accounted for at all since it is distributed through a separate system that has nothing to do with the exchange rate. The fix to #109 does not lead to users earning yield during the withdrawal period since the yield from rebalance -> completed withdrawal is not accounted for.\n\nI am clearly referring to the secondary issue:\n\n>The portion of staking rewards accumulated during withdrawal that belongs to LRT holders is never accounted for so withdrawing users do not earn any rewards when waiting for a withdrawal to be completed. \n\n\n**Czar102**\n\n@0xmonrel from my understanding, #109 is an issue that makes the LST not earn yield during withdrawals, while this and #367 are documentation issues about the fact that the documentation mentions that the yield is being earned during withdrawal for ETH.\n\nSuch a mechanic for ETH (described in the docs) would be fundamentally flawed, so I'm not sure how to consider this finding, given that the implementation works as it should, though against the specification.\n\n@solimander @0xmonrel @nevillehuang do you agree?\n\n**0xmonrel**\n\n@Czar102 I agree with your statement other than \"such a mechanic for ETH would be fundamentally flawed\". Why would it not be possible to account for the ETH yield earned? It might add complexity but it is possible.\n\nAnd yes, fundamentally the issue is that it is stated that users earn yield during ETH withdrawals but they do not. I am assuming here that users expecting yield based on provided information but not earning any as loss off funds/yield. But its obviously your call to decide if that is a fair assumption.\n\n**nevillehuang**\n\n@Czar102 yea agree with your point for the de-deduplication. Seems like a documentation error if sponsor didn’t fix it, but would be fair to validate it based on information presented at time of audit. I will leave it up to you to decide.\n\n #367 and #177 seems to be talking about LST though not ETH? How is the yield earned from native ETH different from LST? Also don’t users accept the exchange rate when requesting withdrawals?\n\n**Czar102**\n\nI am referencing a fundamental flaw because ETH does not earn rewards when a validator is in the withdrawal queue. This means that Rio is fundamentally unable to provide staking rewards from that period of being locked if the withdrawal is not to impact other users' rewards.\n\n@nevillehuang @0xmonrel does that make sense?\n\nOr is it the same for ETH and other LSTs?\n\n**0xmonrel**\n\n> I am referencing a fundamental flaw because ETH does not earn rewards when a validator is in the withdrawal queue. This means that Rio is fundamentally unable to provide staking rewards from that period of being locked if the withdrawal is not to impact other users' rewards.\n> \n> @nevillehuang @0xmonrel does that make sense?\n> \n> Or is it the same for ETH and other LSTs?\n\nThat is partially correct. Until the validator gets \"withdrawable\" status it will still be earning yield, i posted a picture of the expected time in a picture above.  \n\nAs it stand the users withdrawing are actually paying all other users the yield that the validator is generating. A user solo staking or using EigenLayer would earn yield up until their validator reaches \"withdrawable status\".\n\n**0xmonrel**\n\n> @Czar102 yea agree with your point for the de-deduplication. Seems like a documentation error if sponsor didn’t fix it, but would be fair to validate it based on information presented at time of audit. I will leave it up to you to decide.\n> \n> #367 and #177 seems to be talking about LST though not ETH? How is the yield earned from native ETH different from LST? Also don’t users accept the exchange rate when requesting withdrawals?\n\n#367 Is talking about an LRT (reETH), which is the token received when depositing ETH or an LST into Rio. So the issue is about ETH withdrawals which require users to deposit reETH. It is a little confusing since the name is similar to rETH which is an LST.\n\nEach reETH can have multiple underlying assets that are supported on EigenLayer. EigenLayer distinguishes between LSTs and ETH since ETH has to be staked with an actual validator - the rewards that are generated here is the yield for ETH. These rewards are distributed through the DelayedWithdrawalRouter contract on EigenLayer. Eventually 90% reaches the deposit pool at which point the yield belongs to reETH holders. None of this is accounted for during withdrawals of ETH, that is why ETH withdrawals earn 0 yield.  \n\nFor LSTs (if they are not rebasing) the yield is earned in the increased value of the token based on how much ETH it can be redeemed for which increases as yield is added.\n\n**On users accept an exchange rate:** Users accept the current value of their reETH when requesting a withdrawal but they are also expected to earn yield on top of that during the withdrawal. For non-rebasing LSTs this happens naturally since the yield is baked into the token. Locking in 10 LST today and receiving 10 LST in 1 week will include the yield. This is not true for ETH which is why no yield is earned.\n\n#107 is a separate issue that does not talk about ETH withdrawals, it is not a duplicate.\n\n**Czar102**\n\nI agree. Will make this a separate issue with #367 and #177 as duplicates shortly.\n\n**0xmonrel**\n\n#177 should not be a duplicate? It is only on rebasing tokens not earning yield\n\nExplicitly only talking about non-eth rebasing tokens:\n\nImpact section:\n>Not all depositors will be able to withdraw their assets/principal for non-ETH assets.\n\n**Czar102**\n\nI see. I will leave it a duplicate of #109, as it was, which will not change the reward distribution from the scenario where it was invalidated. cc @nevillehuang\n\nThanks for reminding me to remove #177 from the duplicates @0xmonrel.\n\n**Czar102**\n\nResult:\nMedium\nHas Duplicates\n\nConsidering this a Medium since the loss is constrained to the interest during some of the withdrawal time, which is a small part of the deposits.\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xmonrel](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/370/#issuecomment-2023693079): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IRioLRTWithdrawalQueue} from 'contracts/interfaces/IRioLRTWithdrawalQueue.sol';\nimport {UUPSUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {IRioLRTAssetRegistry} from 'contracts/interfaces/IRioLRTAssetRegistry.sol';\nimport {ETH_ADDRESS, MAX_REBALANCE_DELAY} from 'contracts/utils/Constants.sol';\nimport {IRioLRTCoordinator} from 'contracts/interfaces/IRioLRTCoordinator.sol';\nimport {OperatorOperations} from 'contracts/utils/OperatorOperations.sol';\nimport {RioLRTCore} from 'contracts/restaking/base/RioLRTCore.sol';\nimport {ETH_ADDRESS} from 'contracts/utils/Constants.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\n\ncontract RioLRTCoordinator is IRioLRTCoordinator, OwnableUpgradeable, UUPSUpgradeable, RioLRTCore {\n    using SafeERC20 for *;\n    using Asset for *;\n\n    /// @notice The required delay between rebalances.\n    uint24 public rebalanceDelay;\n\n    /// @notice Tracks the timestamp from which each asset is eligible for rebalancing, inclusive of the defined timestamp.\n    mapping(address asset => uint256 timestamp) public assetNextRebalanceAfter;\n\n    /// @notice Require that the asset is supported, the deposit amount is non-zero, and the\n    /// deposit cap has not been reached.\n    /// @param asset The asset being deposited.\n    /// @param amountIn The amount of the asset being deposited.\n    modifier checkDeposit(address asset, uint256 amountIn) {\n        _checkAssetSupported(asset);\n        _checkAmountGreaterThanZero(amountIn);\n        _checkDepositCapReached(asset, amountIn);\n        _;\n    }\n\n    /// @notice Require that the asset is supported and the withdrawal amount is non-zero.\n    /// @param asset The asset being deposited.\n    /// @param amountIn The amount of the asset being deposited.\n    modifier checkWithdrawal(address asset, uint256 amountIn) {\n        _checkAssetSupported(asset);\n        _checkAmountGreaterThanZero(amountIn);\n        _;\n    }\n\n    /// @notice Require that the rebalance delay has been met.\n    /// @param asset The asset being rebalanced.\n    modifier checkRebalanceDelayMet(address asset) {\n        _checkRebalanceDelayMet(asset);\n        _;\n    }\n\n    /// @param issuer_ The LRT issuer that's authorized to deploy this contract.\n    constructor(address issuer_) RioLRTCore(issuer_) {}\n\n    /// @dev Initializes the contract.\n    /// @param initialOwner The owner of the contract.\n    /// @param token_ The address of the liquid restaking token.\n    function initialize(address initialOwner, address token_) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n        __RioLRTCore_init(token_);\n\n        _setRebalanceDelay(24 hours);\n    }\n\n    /// @notice Returns the total value of all underlying assets in the unit of account.\n    function getTVL() public view returns (uint256 value) {\n        return assetRegistry().getTVL();\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Deposits ERC20 tokens and mints restaking token(s) to the caller.\n    /// @param asset The asset being deposited.\n    /// @param amountIn The amount of the asset being deposited.\n    function deposit(address asset, uint256 amountIn) external checkDeposit(asset, amountIn) returns (uint256 amountOut) {\n        // Convert deposited asset amount to restaking tokens.\n        amountOut = convertFromAssetToRestakingTokens(asset, amountIn);\n\n        // Pull tokens from the sender to the deposit pool.\n        IERC20(asset).safeTransferFrom(msg.sender, address(depositPool()), amountIn);\n\n        // Mint restaking tokens to the caller.\n        token.mint(msg.sender, amountOut);\n\n        emit Deposited(msg.sender, asset, amountIn, amountOut);\n    }\n\n    /// @notice Deposits ETH and mints restaking token(s) to the caller.\n    function depositETH() external payable returns (uint256) {\n        return _depositETH();\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Requests a withdrawal to `asset` for `amountIn` restaking tokens.\n    /// @param asset The asset being withdrawn.\n    /// @param amountIn The amount of restaking tokens being redeemed.\n    function requestWithdrawal(address asset, uint256 amountIn) external checkWithdrawal(asset, amountIn) returns (uint256 sharesOwed) {\n        // Determine the amount of shares owed to the withdrawer using the current exchange rate.\n        sharesOwed = convertToSharesFromRestakingTokens(asset, amountIn);\n\n        // If requesting ETH, reduce the precision of the shares owed to the nearest Gwei,\n        // which is the smallest unit of account supported by EigenLayer.\n        if (asset == ETH_ADDRESS) sharesOwed = sharesOwed.reducePrecisionToGwei();\n\n        // Pull restaking tokens from the sender to the withdrawal queue.\n        token.safeTransferFrom(msg.sender, address(withdrawalQueue()), amountIn);\n\n        // Ensure there are enough shares to cover the withdrawal request, and queue the withdrawal.\n        uint256 availableShares = assetRegistry().convertToSharesFromAsset(asset, assetRegistry().getTotalBalanceForAsset(asset));\n        if (sharesOwed > availableShares - withdrawalQueue().getSharesOwedInCurrentEpoch(asset)) {\n            revert INSUFFICIENT_SHARES_FOR_WITHDRAWAL();\n        }\n        withdrawalQueue().queueWithdrawal(msg.sender, asset, sharesOwed, amountIn);\n    }\n\n    /// @notice Rebalances the provided `asset` by processing outstanding withdrawals and\n    /// depositing remaining assets into EigenLayer.\n    /// @param asset The asset to rebalance.\n    function rebalance(address asset) external checkRebalanceDelayMet(asset) {\n        if (!assetRegistry().isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n        if (msg.sender != tx.origin) revert CALLER_MUST_BE_EOA();\n\n        // Process any outstanding withdrawals using funds from the deposit pool and EigenLayer.\n        uint256 sharesOwed = withdrawalQueue().getSharesOwedInCurrentEpoch(asset);\n        if (sharesOwed > 0) {\n            _processUserWithdrawalsForCurrentEpoch(asset, sharesOwed);\n        }\n\n        // Deposit remaining assets into EigenLayer.\n        (uint256 sharesReceived, bool isDepositCapped) = depositPool().depositBalanceIntoEigenLayer(asset);\n        if (sharesOwed == 0 && sharesReceived == 0) {\n            revert NO_REBALANCE_NEEDED();\n        }\n        if (sharesReceived > 0) {\n            if (asset == ETH_ADDRESS) {\n                assetRegistry().increaseUnverifiedValidatorETHBalance(sharesReceived);\n            } else {\n                assetRegistry().increaseSharesHeldForAsset(asset, sharesReceived);\n            }\n        }\n\n        // When the deposit is not capped, the rebalance is considered complete, and the asset rebalance\n        // timestamp is increased by the specified delay. If capped, the asset may be rebalanced again\n        // immediately as there are more assets to deposit.\n        if (!isDepositCapped) {\n            assetNextRebalanceAfter[asset] = uint40(block.timestamp) + rebalanceDelay;\n        }\n        emit Rebalanced(asset);\n    }\n\n    /// @notice Sets the rebalance delay.\n    /// @param newRebalanceDelay The new rebalance delay, in seconds.\n    function setRebalanceDelay(uint24 newRebalanceDelay) external onlyOwner {\n        _setRebalanceDelay(newRebalanceDelay);\n    }\n\n    /// @notice Converts the unit of account value to its equivalent in restaking tokens.\n    /// The unit of account is the price feed's quote asset.\n    /// @param value The restaking token's value in the unit of account.\n    function convertFromUnitOfAccountToRestakingTokens(uint256 value) public view returns (uint256) {\n        uint256 tvl = getTVL();\n        uint256 supply = token.totalSupply();\n\n        if (supply == 0) {\n            return value;\n        }\n        return value * supply / tvl;\n    }\n\n    /// @notice Converts an amount of restaking tokens to its equivalent value in the unit of account.\n    /// The unit of account is the price feed's quote asset.\n    /// @param amount The amount of restaking tokens to convert.\n    function convertToUnitOfAccountFromRestakingTokens(uint256 amount) public view returns (uint256) {\n        uint256 tvl = getTVL();\n        uint256 supply = token.totalSupply();\n\n        if (supply == 0) {\n            return amount;\n        }\n        return tvl * amount / supply;\n    }\n\n    /// @notice Converts an asset amount to its equivalent value in restaking tokens.\n    /// @param asset The address of the asset to convert.\n    /// @param amount The amount of the asset to convert.\n    function convertFromAssetToRestakingTokens(address asset, uint256 amount) public view returns (uint256) {\n        uint256 value = assetRegistry().convertToUnitOfAccountFromAsset(asset, amount);\n        return convertFromUnitOfAccountToRestakingTokens(value);\n    }\n\n    /// @notice Converts an amount of restaking tokens to the equivalent in the asset.\n    /// @param asset The address of the asset to convert to.\n    /// @param amount The amount of restaking tokens to convert.\n    function convertToAssetFromRestakingTokens(address asset, uint256 amount) public view returns (uint256) {\n        uint256 value = convertToUnitOfAccountFromRestakingTokens(amount);\n        return assetRegistry().convertFromUnitOfAccountToAsset(asset, value);\n    }\n\n    /// @notice Converts an amount of restaking tokens to the equivalent in the provided\n    /// asset's EigenLayer shares.\n    /// @param asset The address of the asset whose EigenLayer shares to convert to.\n    /// @param amount The amount of restaking tokens to convert.\n    function convertToSharesFromRestakingTokens(address asset, uint256 amount) public view returns (uint256 shares) {\n        uint256 assetAmount = convertToAssetFromRestakingTokens(asset, amount);\n        return assetRegistry().convertToSharesFromAsset(asset, assetAmount);\n    }\n\n    /// @notice Deposits ETH and mints restaking token(s) to the caller.\n    receive() external payable {\n        _depositETH();\n    }\n\n    /// @notice Deposits ETH and mints restaking token(s) to the caller.\n    /// @dev This function assumes that the quote asset is ETH.\n    function _depositETH() internal checkDeposit(ETH_ADDRESS, msg.value) returns (uint256 amountOut) {\n        // Convert deposited ETH to restaking tokens and mint to the caller.\n        amountOut = convertFromUnitOfAccountToRestakingTokens(msg.value);\n\n        // Forward ETH to the deposit pool.\n        address(depositPool()).transferETH(msg.value);\n\n        // Mint restaking tokens to the caller.\n        token.mint(msg.sender, amountOut);\n\n        emit Deposited(msg.sender, ETH_ADDRESS, msg.value, amountOut);\n    }\n\n    /// @dev Sets the rebalance delay.\n    /// @param newRebalanceDelay The new rebalance delay, in seconds.\n    function _setRebalanceDelay(uint24 newRebalanceDelay) internal {\n        if (newRebalanceDelay > MAX_REBALANCE_DELAY) revert REBALANCE_DELAY_TOO_LONG();\n        rebalanceDelay = newRebalanceDelay;\n\n        emit RebalanceDelaySet(newRebalanceDelay);\n    }\n\n    // forgefmt: disable-next-item\n    /// @dev Processes user withdrawals for the provided asset by transferring available\n    /// assets from the deposit pool and queueing any remaining amount for withdrawal from\n    /// EigenLayer.\n    /// @param asset The asset being withdrawn.\n    /// @param sharesOwed The amount of shares owed to users.\n    function _processUserWithdrawalsForCurrentEpoch(address asset, uint256 sharesOwed) internal {\n        IRioLRTWithdrawalQueue withdrawalQueue_ = withdrawalQueue();\n        (uint256 assetsSent, uint256 sharesSent) = depositPool().transferMaxAssetsForShares(\n            asset,\n            sharesOwed,\n            address(withdrawalQueue_)\n        );\n        uint256 sharesRemaining = sharesOwed - sharesSent;\n\n        // Exit early if all pending withdrawals were paid from the deposit pool.\n        if (sharesRemaining == 0) {\n            withdrawalQueue_.settleCurrentEpoch(asset, assetsSent, sharesSent);\n            return;\n        }\n\n        address strategy = assetRegistry().getAssetStrategy(asset);\n        bytes32 aggregateRoot = OperatorOperations.queueWithdrawalFromOperatorsForUserSettlement(\n            operatorRegistry(),\n            strategy,\n            sharesRemaining\n        );\n        withdrawalQueue_.queueCurrentEpochSettlement(asset, assetsSent, sharesSent, aggregateRoot);\n    }\n\n    /// @dev Checks if the provided asset is supported.\n    /// @param asset The address of the asset.\n    function _checkAssetSupported(address asset) internal view {\n        if (!assetRegistry().isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n    }\n\n    /// @dev Checks if the provided amount is greater than zero.\n    /// @param amount The amount being checked.\n    function _checkAmountGreaterThanZero(uint256 amount) internal pure {\n        if (amount == 0) revert AMOUNT_MUST_BE_GREATER_THAN_ZERO();\n    }\n\n    /// @dev Checks if the deposit cap for the asset has been reached.\n    /// @param asset The address of the asset.\n    /// @param amountIn The amount of the asset being deposited.\n    function _checkDepositCapReached(address asset, uint256 amountIn) internal view {\n        IRioLRTAssetRegistry assetRegistry_ = assetRegistry();\n\n        uint256 depositCap = assetRegistry_.getAssetDepositCap(asset);\n        if (depositCap > 0) {\n            uint256 existingBalance = assetRegistry_.getTotalBalanceForAsset(asset);\n            if (existingBalance + amountIn > depositCap) {\n                revert DEPOSIT_CAP_REACHED(asset, depositCap);\n            }\n        }\n    }\n\n    /// @dev Reverts if the rebalance delay has not been met.\n    /// @param asset The asset being rebalanced.\n    function _checkRebalanceDelayMet(address asset) internal view {\n        if (block.timestamp < assetNextRebalanceAfter[asset]) revert REBALANCE_DELAY_NOT_MET();\n    }\n\n    /// @dev Allows the owner to upgrade the gateway implementation.\n    /// @param newImplementation The implementation to upgrade to.\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}"
    },
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {UUPSUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {IRioLRTOperatorDelegator} from 'contracts/interfaces/IRioLRTOperatorDelegator.sol';\nimport {IDelegationManager} from 'contracts/interfaces/eigenlayer/IDelegationManager.sol';\nimport {IRioLRTWithdrawalQueue} from 'contracts/interfaces/IRioLRTWithdrawalQueue.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/math/SafeCast.sol';\nimport {FixedPointMathLib} from '@solady/utils/FixedPointMathLib.sol';\nimport {RioLRTCore} from 'contracts/restaking/base/RioLRTCore.sol';\nimport {ETH_ADDRESS} from 'contracts/utils/Constants.sol';\nimport {Array} from 'contracts/utils/Array.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\n\ncontract RioLRTWithdrawalQueue is IRioLRTWithdrawalQueue, OwnableUpgradeable, UUPSUpgradeable, RioLRTCore {\n    using FixedPointMathLib for *;\n    using Asset for address;\n    using Array for *;\n\n    /// @notice The primary delegation contract for EigenLayer.\n    IDelegationManager public immutable delegationManager;\n\n    /// @notice Current asset withdrawal epochs. Incoming withdrawals are included\n    /// in the current epoch, which will be processed by the asset manager.\n    mapping(address asset => uint256 epoch) internal currentEpochsByAsset;\n\n    /// @notice The amount of assets owed to users in a given epoch, as well as the state\n    /// of the epoch's withdrawals.\n    mapping(address asset => mapping(uint256 epoch => EpochWithdrawals withdrawals)) internal epochWithdrawalsByAsset;\n\n    /// @param issuer_ The LRT issuer that's authorized to deploy this contract.\n    /// @param delegationManager_ The EigenLayer delegation manager.\n    constructor(address issuer_, address delegationManager_) RioLRTCore(issuer_) {\n        delegationManager = IDelegationManager(delegationManager_);\n    }\n\n    /// @notice Initializes the contract.\n    /// @param initialOwner The initial owner of the contract.\n    /// @param token_ The address of the liquid restaking token.\n    function initialize(address initialOwner, address token_) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n        __RioLRTCore_init(token_);\n    }\n\n    /// @notice Retrieve the current withdrawal epoch for a given asset.\n    /// @param asset The asset to retrieve the current epoch for.\n    function getCurrentEpoch(address asset) public view returns (uint256) {\n        return currentEpochsByAsset[asset];\n    }\n\n    /// @notice Get the amount of strategy shares owed to withdrawers in the current `epoch` for `asset`.\n    /// @param asset The withdrawal asset.\n    function getSharesOwedInCurrentEpoch(address asset) external view returns (uint256 sharesOwed) {\n        sharesOwed = _getEpochWithdrawals(asset, getCurrentEpoch(asset)).sharesOwed;\n    }\n\n    /// @notice Retrieve withdrawal epoch information for a given asset and epoch.\n    /// @param asset The withdrawal asset.\n    /// @param epoch The epoch for which to retrieve the information.\n    function getEpochWithdrawalSummary(address asset, uint256 epoch)\n        external\n        view\n        returns (EpochWithdrawalSummary memory)\n    {\n        EpochWithdrawals storage withdrawals = _getEpochWithdrawals(asset, epoch);\n        return EpochWithdrawalSummary({\n            settled: withdrawals.settled,\n            assetsReceived: withdrawals.assetsReceived,\n            shareValueOfAssetsReceived: withdrawals.shareValueOfAssetsReceived,\n            sharesOwed: withdrawals.sharesOwed,\n            amountToBurnAtSettlement: withdrawals.amountToBurnAtSettlement,\n            aggregateRoot: withdrawals.aggregateRoot\n        });\n    }\n\n    /// @notice Retrieve a user's withdrawal information for a given asset and epoch.\n    /// @param asset The withdrawal asset.\n    /// @param epoch The epoch for which to retrieve the information.\n    /// @param user The address of the user for which to retrieve the information.\n    function getUserWithdrawalSummary(address asset, uint256 epoch, address user)\n        external\n        view\n        returns (UserWithdrawalSummary memory)\n    {\n        return _getEpochWithdrawals(asset, epoch).users[user];\n    }\n\n    /// @notice Withdraws all `asset` owed to the caller in a given epoch.\n    /// @param request The asset claim request.\n    function claimWithdrawalsForEpoch(ClaimRequest calldata request) public returns (uint256 amountOut) {\n        address withdrawer = msg.sender;\n\n        EpochWithdrawals storage epochWithdrawals = _getEpochWithdrawals(request.asset, request.epoch);\n        if (!epochWithdrawals.settled) revert EPOCH_NOT_SETTLED();\n\n        UserWithdrawalSummary memory userSummary = epochWithdrawals.users[withdrawer];\n        if (userSummary.sharesOwed == 0) revert NO_SHARES_OWED_IN_EPOCH();\n        if (userSummary.claimed) revert WITHDRAWAL_ALREADY_CLAIMED();\n\n        epochWithdrawals.users[withdrawer].claimed = true;\n\n        amountOut = userSummary.sharesOwed.mulDiv(epochWithdrawals.assetsReceived, epochWithdrawals.sharesOwed);\n        request.asset.transferTo(withdrawer, amountOut);\n\n        emit WithdrawalsClaimedForEpoch(request.epoch, request.asset, withdrawer, amountOut);\n    }\n\n    /// @notice Withdraws owed assets owed to the caller from many withdrawal requests.\n    /// @param requests The withdrawal claim request.\n    function claimWithdrawalsForManyEpochs(ClaimRequest[] calldata requests)\n        external\n        returns (uint256[] memory amountsOut)\n    {\n        uint256 requestLength = requests.length;\n\n        amountsOut = new uint256[](requestLength);\n        for (uint256 i; i < requestLength; ++i) {\n            amountsOut[i] = claimWithdrawalsForEpoch(requests[i]);\n        }\n    }\n\n    /// @notice Queue `sharesOwed` of `asset` to `withdrawer` in the current epoch. These owed shares\n    /// can be claimed as the underlying asset by the withdrawer once the current epoch is settled.\n    /// @param withdrawer The address requesting the withdrawal.\n    /// @param asset The address of the asset being withdrawn.\n    /// @param sharesOwed The amount of shares owed to the withdrawer.\n    /// @param amountIn The amount of restaking tokens pulled from the withdrawer.\n    function queueWithdrawal(address withdrawer, address asset, uint256 sharesOwed, uint256 amountIn)\n        external\n        onlyCoordinator\n    {\n        if (sharesOwed == 0) revert NO_SHARES_OWED();\n        uint256 currentEpoch = getCurrentEpoch(asset);\n\n        EpochWithdrawals storage epochWithdrawals = _getEpochWithdrawals(asset, currentEpoch);\n        epochWithdrawals.sharesOwed += SafeCast.toUint120(sharesOwed);\n        epochWithdrawals.amountToBurnAtSettlement += amountIn;\n\n        UserWithdrawalSummary storage userSummary = epochWithdrawals.users[withdrawer];\n        userSummary.sharesOwed += SafeCast.toUint120(sharesOwed);\n\n        emit WithdrawalQueued(currentEpoch, asset, withdrawer, sharesOwed, amountIn);\n    }\n\n    /// @notice Settle the current epoch for `asset` using `assetsReceived` from the deposit pool.\n    /// @param asset The address of the withdrawal asset.\n    /// @param assetsReceived The amount of assets received to settle the epoch.\n    /// @param shareValueOfAssetsReceived The value of the assets received in EigenLayer shares.\n    function settleCurrentEpoch(address asset, uint256 assetsReceived, uint256 shareValueOfAssetsReceived)\n        external\n        onlyCoordinator\n    {\n        uint256 currentEpoch = getCurrentEpoch(asset);\n\n        EpochWithdrawals storage epochWithdrawals = _getEpochWithdrawals(asset, currentEpoch);\n        if (epochWithdrawals.sharesOwed == 0) revert NO_SHARES_OWED_IN_EPOCH();\n        if (epochWithdrawals.settled) revert EPOCH_ALREADY_SETTLED();\n\n        epochWithdrawals.settled = true;\n        epochWithdrawals.assetsReceived = SafeCast.toUint120(assetsReceived);\n        epochWithdrawals.shareValueOfAssetsReceived = SafeCast.toUint120(shareValueOfAssetsReceived);\n\n        token.burn(epochWithdrawals.amountToBurnAtSettlement);\n        currentEpochsByAsset[asset] += 1;\n\n        emit EpochSettledFromDepositPool(currentEpoch, asset, assetsReceived);\n    }\n\n    /// @notice Queues the current epoch for `asset` settlement via EigenLayer and record\n    /// the amount of assets received from the deposit pool.\n    /// @param asset The address of the withdrawal asset.\n    /// @param assetsReceived The amount of assets received from the deposit pool.\n    /// @param shareValueOfAssetsReceived The value of the assets received in EigenLayer shares.\n    /// @param aggregateRoot The aggregate root of the queued EigenLayer withdrawals.\n    function queueCurrentEpochSettlement(\n        address asset,\n        uint256 assetsReceived,\n        uint256 shareValueOfAssetsReceived,\n        bytes32 aggregateRoot\n    ) external onlyCoordinator {\n        if (aggregateRoot == bytes32(0)) revert INVALID_AGGREGATE_WITHDRAWAL_ROOT();\n\n        uint256 currentEpoch = getCurrentEpoch(asset);\n\n        EpochWithdrawals storage epochWithdrawals = _getEpochWithdrawals(asset, currentEpoch);\n        if (epochWithdrawals.aggregateRoot != bytes32(0)) revert WITHDRAWALS_ALREADY_QUEUED_FOR_EPOCH();\n        if (epochWithdrawals.sharesOwed == 0) revert NO_SHARES_OWED_IN_EPOCH();\n        if (epochWithdrawals.settled) revert EPOCH_ALREADY_SETTLED();\n\n        uint256 restakingTokensToBurn;\n        if (assetsReceived > 0) {\n            epochWithdrawals.assetsReceived = SafeCast.toUint120(assetsReceived);\n            epochWithdrawals.shareValueOfAssetsReceived = SafeCast.toUint120(shareValueOfAssetsReceived);\n\n            restakingTokensToBurn = epochWithdrawals.amountToBurnAtSettlement.mulWad(\n                shareValueOfAssetsReceived.divWad(epochWithdrawals.sharesOwed)\n            );\n            token.burn(restakingTokensToBurn);\n\n            epochWithdrawals.amountToBurnAtSettlement -= restakingTokensToBurn;\n        }\n        epochWithdrawals.aggregateRoot = aggregateRoot;\n\n        emit EpochQueuedForSettlementFromEigenLayer(\n            currentEpoch, asset, assetsReceived, shareValueOfAssetsReceived, restakingTokensToBurn, aggregateRoot\n        );\n    }\n\n    /// @notice Settle `epoch` for `asset` using `queuedWithdrawals` from EigenLayer.\n    /// @param asset The address of the withdrawal asset.\n    /// @param epoch The epoch to settle.\n    /// @param queuedWithdrawals The queued withdrawals from EigenLayer.\n    /// @param middlewareTimesIndexes The middleware times indexes for the queued withdrawals.\n    function settleEpochFromEigenLayer(\n        address asset,\n        uint256 epoch,\n        IDelegationManager.Withdrawal[] calldata queuedWithdrawals,\n        uint256[] calldata middlewareTimesIndexes\n    ) external {\n        EpochWithdrawals storage epochWithdrawals = _getEpochWithdrawals(asset, epoch);\n        if (epochWithdrawals.sharesOwed == 0) revert NO_SHARES_OWED_IN_EPOCH();\n        if (epochWithdrawals.settled) revert EPOCH_ALREADY_SETTLED();\n        if (epochWithdrawals.aggregateRoot == bytes32(0)) revert WITHDRAWALS_NOT_QUEUED_FOR_EPOCH();\n\n        uint256 queuedWithdrawalCount = queuedWithdrawals.length;\n        if (queuedWithdrawalCount != middlewareTimesIndexes.length) revert INVALID_MIDDLEWARE_TIMES_INDEXES_LENGTH();\n\n        epochWithdrawals.settled = true;\n\n        // forgefmt: disable-next-item\n        uint256 sharesReceivedDuringSettlement = epochWithdrawals.sharesOwed - epochWithdrawals.shareValueOfAssetsReceived;\n\n        // If not ETH, decrease the shares held for the asset. The decrease in queued ETH is\n        // handled on a per-operator basis below.\n        if (asset != ETH_ADDRESS) {\n            assetRegistry().decreaseSharesHeldForAsset(asset, sharesReceivedDuringSettlement);\n        }\n        token.burn(epochWithdrawals.amountToBurnAtSettlement);\n\n        uint256 balanceBefore = asset.getSelfBalance();\n\n        address[] memory assets = asset.toArray();\n        bytes32[] memory roots = new bytes32[](queuedWithdrawalCount);\n\n        IDelegationManager.Withdrawal memory queuedWithdrawal;\n        for (uint256 i; i < queuedWithdrawalCount; ++i) {\n            queuedWithdrawal = queuedWithdrawals[i];\n\n            roots[i] = _computeWithdrawalRoot(queuedWithdrawal);\n            delegationManager.completeQueuedWithdrawal(queuedWithdrawal, assets, middlewareTimesIndexes[i], true);\n\n            // Decrease the amount of ETH queued for withdrawal. We do not need to validate the staker as\n            // the aggregate root will be validated below.\n            if (asset == ETH_ADDRESS) {\n                IRioLRTOperatorDelegator(queuedWithdrawal.staker).decreaseETHQueuedForUserSettlement(\n                    queuedWithdrawal.shares[0]\n                );\n            }\n        }\n        if (epochWithdrawals.aggregateRoot != keccak256(abi.encode(roots))) {\n            revert INVALID_AGGREGATE_WITHDRAWAL_ROOT();\n        }\n        epochWithdrawals.shareValueOfAssetsReceived = SafeCast.toUint120(epochWithdrawals.sharesOwed);\n\n        uint256 assetsReceived = asset.getSelfBalance() - balanceBefore;\n        epochWithdrawals.assetsReceived += SafeCast.toUint120(assetsReceived);\n\n        emit EpochSettledFromEigenLayer(epoch, asset, assetsReceived);\n    }\n\n    /// @dev Receives ETH for withdrawals.\n    receive() external payable {}\n\n    /// @dev Returns the keccak256 hash of `withdrawal`.\n    /// @param withdrawal The withdrawal.\n    function _computeWithdrawalRoot(IDelegationManager.Withdrawal memory withdrawal) public pure returns (bytes32) {\n        return keccak256(abi.encode(withdrawal));\n    }\n\n    function _getEpochWithdrawals(address asset, uint256 epoch) internal view returns (EpochWithdrawals storage) {\n        return epochWithdrawalsByAsset[asset][epoch];\n    }\n\n    /// @dev Allows the owner to upgrade the withdrawal queue implementation.\n    /// @param newImplementation The implementation to upgrade to.\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}"
    },
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {UUPSUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {IRioLRTOperatorDelegator} from 'contracts/interfaces/IRioLRTOperatorDelegator.sol';\nimport {IDelegationManager} from 'contracts/interfaces/eigenlayer/IDelegationManager.sol';\nimport {IRioLRTWithdrawalQueue} from 'contracts/interfaces/IRioLRTWithdrawalQueue.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/math/SafeCast.sol';\nimport {FixedPointMathLib} from '@solady/utils/FixedPointMathLib.sol';\nimport {RioLRTCore} from 'contracts/restaking/base/RioLRTCore.sol';\nimport {ETH_ADDRESS} from 'contracts/utils/Constants.sol';\nimport {Array} from 'contracts/utils/Array.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\n\ncontract RioLRTWithdrawalQueue is IRioLRTWithdrawalQueue, OwnableUpgradeable, UUPSUpgradeable, RioLRTCore {\n    using FixedPointMathLib for *;\n    using Asset for address;\n    using Array for *;\n\n    /// @notice The primary delegation contract for EigenLayer.\n    IDelegationManager public immutable delegationManager;\n\n    /// @notice Current asset withdrawal epochs. Incoming withdrawals are included\n    /// in the current epoch, which will be processed by the asset manager.\n    mapping(address asset => uint256 epoch) internal currentEpochsByAsset;\n\n    /// @notice The amount of assets owed to users in a given epoch, as well as the state\n    /// of the epoch's withdrawals.\n    mapping(address asset => mapping(uint256 epoch => EpochWithdrawals withdrawals)) internal epochWithdrawalsByAsset;\n\n    /// @param issuer_ The LRT issuer that's authorized to deploy this contract.\n    /// @param delegationManager_ The EigenLayer delegation manager.\n    constructor(address issuer_, address delegationManager_) RioLRTCore(issuer_) {\n        delegationManager = IDelegationManager(delegationManager_);\n    }\n\n    /// @notice Initializes the contract.\n    /// @param initialOwner The initial owner of the contract.\n    /// @param token_ The address of the liquid restaking token.\n    function initialize(address initialOwner, address token_) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n        __RioLRTCore_init(token_);\n    }\n\n    /// @notice Retrieve the current withdrawal epoch for a given asset.\n    /// @param asset The asset to retrieve the current epoch for.\n    function getCurrentEpoch(address asset) public view returns (uint256) {\n        return currentEpochsByAsset[asset];\n    }\n\n    /// @notice Get the amount of strategy shares owed to withdrawers in the current `epoch` for `asset`.\n    /// @param asset The withdrawal asset.\n    function getSharesOwedInCurrentEpoch(address asset) external view returns (uint256 sharesOwed) {\n        sharesOwed = _getEpochWithdrawals(asset, getCurrentEpoch(asset)).sharesOwed;\n    }\n\n    /// @notice Retrieve withdrawal epoch information for a given asset and epoch.\n    /// @param asset The withdrawal asset.\n    /// @param epoch The epoch for which to retrieve the information.\n    function getEpochWithdrawalSummary(address asset, uint256 epoch)\n        external\n        view\n        returns (EpochWithdrawalSummary memory)\n    {\n        EpochWithdrawals storage withdrawals = _getEpochWithdrawals(asset, epoch);\n        return EpochWithdrawalSummary({\n            settled: withdrawals.settled,\n            assetsReceived: withdrawals.assetsReceived,\n            shareValueOfAssetsReceived: withdrawals.shareValueOfAssetsReceived,\n            sharesOwed: withdrawals.sharesOwed,\n            amountToBurnAtSettlement: withdrawals.amountToBurnAtSettlement,\n            aggregateRoot: withdrawals.aggregateRoot\n        });\n    }\n\n    /// @notice Retrieve a user's withdrawal information for a given asset and epoch.\n    /// @param asset The withdrawal asset.\n    /// @param epoch The epoch for which to retrieve the information.\n    /// @par"
    }
  ]
}