{
  "Title": "[G-10] Multiple address/ID mappings can be combined into a single mapping of an address/ID to a struct, where appropriate",
  "Content": "We can combine multiple mappings below into structs. We can then pack the structs by modifying the uint type for the values. This will result in cheaper storage reads since multiple mappings are accessed in functions and those values are now occupying the same storage slot; meaning the slot will become warm after the first SLOAD. In addition, when writing to and reading from the struct values, we will avoid a `Gsset (20000 gas)` and `Gcoldsload (2100 gas)` since multiple struct values are now occupying the same slot.\n\nEstimated Gas Savings: `Gsset (20000 gas) + Gcoldsload (2100 gas) = 22100`\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/ProtocolRewardsPool.sol#L36-L38\n\nCombine `time2fullRedemption` and `lastWithdrawTime` into one mapping of a struct and reduce the `uint` type of each variable (this is possible since they hold timestamps). Doing so will allow us to pack the variables into one slot, which will result in avoiding a `Gsset (20000 gas)` when both values are set in a function call and avoiding a `Gcoldsload (2100 gas)` when both values are accessed in a function call.\n\n*The following functions will benefit from this optimization: [`ProtocolRewardsPool.unstake`](https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/ProtocolRewardsPool.sol#L87), [`ProtocolRewardsPool.withdraw`](https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/ProtocolRewardsPool.sol#L100), and [`ProtocolRewardsPool.unlockPrematurely`](https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/ProtocolRewardsPool.sol#L113).*\n\n*Note: The bot race flagged these instances, but failed to explain the refactoring needed to achieve the optimal gas savings. Simply combining the `time2fullRedemption` and `lastWithdrawTime` mappings will not result in any significant gas savings since those values will still occupy their own slot. The explanation offered above and the complementary refactoring below allows us to understand this optimization in its entirety. For these reasons, this finding is included in this report.*\n```solidity\nFile: contracts/lybra/miner/ProtocolRewardsPool.sol\n36:    mapping(address => uint) public time2fullRedemption;\n37:    mapping(address => uint) public unstakeRatio;\n38:    mapping(address => uint) public lastWithdrawTime;\n```\n```diff\ndiff --git a/lybra/miner/ProtocolRewardsPool.sol b/lybra/miner/ProtocolRewardsPool.sol\nindex 8fc83d6..6768fac 100644\n--- a/lybra/miner/ProtocolRewardsPool.sol\n+++ b/lybra/miner/ProtocolRewardsPool.sol\n@@ -33,12 +33,18 @@ contract ProtocolRewardsPool is Ownable {\n     mapping(address => uint) public userRewardPerTokenPaid;\n     // User address => rewards to be claimed\n     mapping(address => uint) public rewards;\n-    mapping(address => uint) public time2fullRedemption;\n     mapping(address => uint) public unstakeRatio;\n-    mapping(address => uint) public lastWithdrawTime;\n     uint256 immutable exitCycle = 90 days;\n     uint256 public grabableAmount;\n     uint256 public grabFeeRatio = 3000;\n+\n+    struct TimeStruct {\n+        uint128 time2fullRedemption;\n+        uint128 lastWithdrawTime;\n+    }\n+\n+    mapping(address => TimeStruct) timeStruct;\n+\n     event Restake(address indexed user, uint256 amount, uint256 time);\n     event StakeLBR(address indexed user, uint256 amount, uint256 time);\n     event UnstakeLBR(address indexed user, uint256 amount, uint256 time);\n@@ -89,11 +95,12 @@ contract ProtocolRewardsPool is Ownable {\n         esLBR.burn(msg.sender, amount);\n         withdraw(msg.sender);\n         uint256 total = amount;\n-        if (time2fullRedemption[msg.sender] > block.timestamp) {\n-            total += unstakeRatio[msg.sender] * (time2fullRedemption[msg.sender] - block.timestamp);\n+        TimeStruct storage _timeStruct = timeStruct[msg.sender];\n+        if (_timeStruct.time2fullRedemption > block.timestamp) {\n+            total += unstakeRatio[msg.sender] * (_timeStruct.time2fullRedemption - block.timestamp);\n         }\n         unstakeRatio[msg.sender] = total / exitCycle;\n-        time2fullRedemption[msg.sender] = block.timestamp + exitCycle;\n+        _timeStruct.time2fullRedemption = uint128(block.timestamp + exitCycle);\n         emit UnstakeLBR(msg.sender, amount, block.timestamp);\n     }\n\n@@ -102,7 +109,7 @@ contract ProtocolRewardsPool is Ownable {\n         if (amount > 0) {\n             LBR.mint(user, amount);\n         }\n-        lastWithdrawTime[user] = block.timestamp;\n+        timeStruct[user].lastWithdrawTime = uint128(block.timestamp);\n         emit WithdrawLBR(user, amount, block.timestamp);\n     }\n\n@@ -111,14 +118,15 @@ contract ProtocolRewardsPool is Ownable {\n      * with the lost portion being recorded in the contract and available for others to purchase in LBR at a certain ratio.\n      */\n     function unlockPrematurely() external {\n-        require(block.timestamp + exitCycle - 3 days > time2fullRedemption[msg.sender], \"ENW\");\n+        TimeStruct storage _timeStruct = timeStruct[msg.sender];\n+        require(block.timestamp + exitCycle - 3 days > _timeStruct.time2fullRedemption, \"ENW\");\n         uint256 burnAmount = getReservedLBRForVesting(msg.sender) - getPreUnlockableAmount(msg.sender);\n         uint256 amount = getPreUnlockableAmount(msg.sender) + getClaimAbleLBR(msg.sender);\n         if (amount > 0) {\n             LBR.mint(msg.sender, amount);\n         }\n         unstakeRatio[msg.sender] = 0;\n-        time2fullRedemption[msg.sender] = 0;\n+        _timeStruct.time2fullRedemption = 0;\n         grabableAmount += burnAmount;\n     }\n\n@@ -142,25 +150,26 @@ contract ProtocolRewardsPool is Ownable {\n         uint256 amount = getReservedLBRForVesting(msg.sender) + getClaimAbleLBR(msg.sender);\n         esLBR.mint(msg.sender, amount);\n         unstakeRatio[msg.sender] = 0;\n-        time2fullRedemption[msg.sender] = 0;\n+        timeStruct[msg.sender].time2fullRedemption = 0;\n         emit Restake(msg.sender, amount, block.timestamp);\n     }\n\n     function getPreUnlockableAmount(address user) public view returns (uint256 amount) {\n         uint256 a = getReservedLBRForVesting(user);\n         if (a == 0) return 0;\n-        amount = (a * (75e18 - ((time2fullRedemption[user] - block.timestamp) * 70e18) / (exitCycle / 1 days - 3) / 1 days)) / 100e18;\n+        amount = (a * (75e18 - ((timeStruct[user].time2fullRedemption - block.timestamp) * 70e18) / (exitCycle / 1 days - 3) / 1 days)) / 100e18;\n     }\n\n     function getClaimAbleLBR(address user) public view returns (uint256 amount) {\n-        if (time2fullRedemption[user] > lastWithdrawTime[user]) {\n-            amount = block.timestamp > time2fullRedemption[user] ? unstakeRatio[user] * (time2fullRedemption[user] - lastWithdrawTime[user]) : unstakeRatio[user] * (block.timest\namp - lastWithdrawTime[user]);\n+        TimeStruct storage _timeStruct = timeStruct[user];\n+        if (_timeStruct.time2fullRedemption > _timeStruct.lastWithdrawTime) {\n+            amount = block.timestamp > _timeStruct.time2fullRedemption ? unstakeRatio[user] * (_timeStruct.time2fullRedemption - _timeStruct.lastWithdrawTime) : unstakeRatio[use\nr] * (block.timestamp - _timeStruct.lastWithdrawTime);\n         }\n     }\n\n     function getReservedLBRForVesting(address user) public view returns (uint256 amount) {\n-        if (time2fullRedemption[user] > block.timestamp) {\n-            amount = unstakeRatio[user] * (time2fullRedemption[user] - block.timestamp);\n+        if (timeStruct[user].time2fullRedemption > block.timestamp) {\n+            amount = unstakeRatio[user] * (timeStruct[user].time2fullRedemption - block.timestamp);\n         }\n     }\n```\n\n**[LybraFinance acknowledged](https://github.com/code-423n4/2023-06-lybra-findings/issues/898#issuecomment-1656626428)**\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/miner/ProtocolRewardsPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title ProtocolRewardsPool is a derivative version of Synthetix StakingRewards.sol, distributing Protocol revenue to esLBR stakers.\n * Converting esLBR to LBR.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract esLBR.\n * - Get `stakedOf(user)` from balanceOf(user) in contract esLBR.\n * - When an address esLBR balance changes, call the refreshReward method to update rewards to be claimed.\n */\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"../interfaces/IesLBR.sol\";\n\ninterface IesLBRBoost {\n    function getUnlockTime(\n        address user\n    ) external view returns (uint256 unlockTime);\n}\n\ncontract ProtocolRewardsPool is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBR public esLBR;\n    IesLBR public LBR;\n    IesLBRBoost public esLBRBoost;\n\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint) public rewards;\n    mapping(address => uint) public time2fullRedemption;\n    mapping(address => uint) public unstakeRatio;\n    mapping(address => uint) public lastWithdrawTime;\n    uint256 immutable exitCycle = 90 days;\n    uint256 public grabableAmount;\n    uint256 public grabFeeRatio = 3000;\n    event Restake(address indexed user, uint256 amount, uint256 time);\n    event StakeLBR(address indexed user, uint256 amount, uint256 time);\n    event UnstakeLBR(address indexed user, uint256 amount, uint256 time);\n    event WithdrawLBR(address indexed user, uint256 amount, uint256 time);\n    event ClaimReward(address indexed user, uint256 eUSDAmount, address token, uint256 tokenAmount, uint256 time);\n\n    constructor(address _config) {\n        configurator = Iconfigurator(_config);\n    }\n\n    function setTokenAddress(address _eslbr, address _lbr, address _boost) external onlyOwner {\n        esLBR = IesLBR(_eslbr);\n        LBR = IesLBR(_lbr);\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setGrabCost(uint256 _ratio) external onlyOwner {\n        require(_ratio <= 8000, \"BCE\");\n        grabFeeRatio = _ratio;\n    }\n\n    // Total staked\n    function totalStaked() internal view returns (uint256) {\n        return esLBR.totalSupply();\n    }\n\n    // User address => esLBR balance\n    function stakedOf(address staker) internal view returns (uint256) {\n        return esLBR.balanceOf(staker);\n    }\n\n    function stake(uint256 amount) external {\n        LBR.burn(msg.sender, amount);\n        esLBR.mint(msg.sender, amount);\n        emit StakeLBR(msg.sender, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Unlocks esLBR and converts it to LBR.\n     * @param amount The amount to convert.\n     * Requirements:\n     * The current time must be greater than the unlock time retrieved from the boost contract for the user.\n     * Effects:\n     * Resets the user's vesting data, entering a new vesting period, when converting to LBR.\n     */\n    function unstake(uint256 amount) external {\n        require(block.timestamp >= esLBRBoost.getUnlockTime(msg.sender), \"Your lock-in period has not ended. You can't convert your esLBR now.\");\n        esLBR.burn(msg.sender, amount);\n        withdraw(msg.sender);\n        uint256 total = amount;\n        if (time2fullRedemption[msg.sender] > block.timestamp) {\n            total += unstakeRatio[msg.sender] * (time2fullRedemption[msg.sender] - block.timestamp);\n        }\n        unstakeRatio[msg.sender] = total / exitCycle;\n        time2fullRedemption[msg.sender] = block.timestamp + exitCycle;\n        emit UnstakeLBR(msg.sender, amount, block.timestamp);\n    }\n\n    function withdraw(address user) public {\n        uint256 amount = getClaimAbleLBR(user);\n        if (amount > 0) {\n            LBR.mint(user, amount);\n        }\n        lastWithdrawTime[user] = block.timestamp;\n        emit WithdrawLBR(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeems and converts the ESLBR being claimed in advance,\n     * with the lost portion being recorded in the contract and available for others to purchase in LBR at a certain ratio.\n     */\n    function unlockPrematurely() external {\n        require(block.timestamp + exitCycle - 3 days > time2fullRedemption[msg.sender], \"ENW\");\n        uint256 burnAmount = getReservedLBRForVesting(msg.sender) - getPreUnlockableAmount(msg.sender);\n        uint256 amount = getPreUnlockableAmount(msg.sender) + getClaimAbleLBR(msg.sender);\n        if (amount > 0) {\n            LBR.mint(msg.sender, amount);\n        }\n        unstakeRatio[msg.sender] = 0;\n        time2fullRedemption[msg.sender] = 0;\n        grabableAmount += burnAmount;\n    }\n\n    /**\n     * @dev Purchase the accumulated amount of pre-claimed lost ESLBR in the contract using LBR.\n     * @param amount The amount of ESLBR to be purchased.\n     * Requirements:\n     * The amount must be greater than 0.\n     */\n    function grabEsLBR(uint256 amount) external {\n        require(amount > 0, \"QMG\");\n        grabableAmount -= amount;\n        LBR.burn(msg.sender, (amount * grabFeeRatio) / 10000);\n        esLBR.mint(msg.sender, amount);\n    }\n\n    /**\n     * @dev Convert unredeemed and converting ESLBR tokens back to LBR.\n     */\n    function reStake() external {\n        uint256 amount = getReservedLBRForVesting(msg.sender) + getClaimAbleLBR(msg.sender);\n        esLBR.mint(msg.sender, amount);\n        unstakeRatio[msg.sender] = 0;\n        time2fullRedemption[msg.sender] = 0;\n        emit Restake(msg.sender, amount, block.timestamp);\n    }\n\n    function getPreUnlockableAmount(address user) public view returns (uint256 amount) {\n        uint256 a = getReservedLBRForVesting(user);\n        if (a == 0) return 0;\n        amount = (a * (75e18 - ((time2fullRedemption[user] - block.timestamp) * 70e18) / (exitCycle / 1 days - 3) / 1 days)) / 100e18;\n    }\n\n    function getClaimAbleLBR(address user) public view returns (uint256 amount) {\n        if (time2fullRedemption[user] > lastWithdrawTime[user]) {\n            amount = block.timestamp > time2fullRedemption[user] ? unstakeRatio[user] * (time2fullRedemption[user] - lastWithdrawTime[user]) : unstakeRatio[user] * (block.timestamp - lastWithdrawTime[user]);\n        }\n    }\n\n    function getReservedLBRForVesting(address user) public view returns (uint256 amount) {\n        if (time2fullRedemption[user] > block.timestamp) {\n            amount = unstakeRatio[user] * (time2fullRedemption[user] - block.timestamp);\n        }\n    }\n\n    function earned(address _account) public view returns (uint) {\n        return ((stakedOf(_account) * (rewardPerTokenStored - userRewardPerTokenPaid[_account])) / 1e18) + rewards[_account];\n    }\n\n    function getClaimAbleUSD(address user) external view returns (uint256 amount) {\n        amount = IEUSD(configurator.getEUSDAddress()).getMintedEUSDByShares(earned(user));\n    }\n\n    /**\n     * @dev Call this function when deposit or withdraw ETH on Lybra and update the status of corresponding user.\n     */\n    modifier updateReward(address account) {\n        rewards[account] = earned(account);\n        userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        _;\n    }\n\n    function refreshReward(address _account) external updateReward(_account) {}\n\n    /**\n     * @notice When claiming protocol rewards earnings, if there is a sufficient amount of eUSD in the ProtocolRewards Pool,\n     * the eUSD will be prioritized for distribution. Distributes earnings in the order of peUSD and other stablecoins if the eUSD balance is insufficient..\n     */\n    function getReward() external updateReward(msg.sender) {\n        uint reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IEUSD EUSD = IEUSD(configurator.getEUSDAddress());\n            uint256 balance = EUSD.sharesOf(address(this));\n            uint256 eUSDShare = balance >= reward ? reward : reward - balance;\n            EUSD.transferShares(msg.sender, eUSDShare);\n            if(reward > eUSDShare) {\n                ERC20 peUSD = ERC20(configurator.peUSD());\n                uint256 peUSDBalance = peUSD.balanceOf(address(this));\n                if(peUSDBalance >= reward - eUSDShare) {\n                    peUSD.transfer(msg.sender, reward - eUSDShare);\n                    emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(peUSD), reward - eUSDShare, block.timestamp);\n                } else {\n                    if(peUSDBalance > 0) {\n                        peUSD.transfer(msg.sender, peUSDBalance);\n                    }\n                    ERC20 token = ERC20(configurator.stableToken());\n                    uint256 tokenAmount = (reward - eUSDShare - peUSDBalance) * token.decimals() / 1e18;\n                    token.transfer(msg.sender, tokenAmount);\n                    emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(token), reward - eUSDShare, block.timestamp);\n                }\n            } else {\n                emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(0), 0, block.timestamp);\n            }\n           \n        }\n    }\n\n    /**\n     * @dev Receives stablecoin tokens sent by the configurator contract and records the protocol rewards accumulation per esLBR held.\n     * @param amount The amount of rewards to be distributed.\n     * @param tokenType The type of token (0 for eUSD, 1 for other stablecoins, 2 for peUSD).\n     * @dev This function is called by the configurator contract to distribute rewards.\n     * @dev When receiving stablecoin tokens other than eUSD, the decimals of the token are converted to 18 for consistent calculations.\n     */\n    function notifyRewardAmount(uint amount, uint tokenType) external {\n        require(msg.sender == address(configurator));\n        if (totalStaked() == 0) return;\n        require(amount > 0, \"amount = 0\");\n        if(tokenType == 0) {\n            uint256 share = IEUSD(configurator.getEUSDAddress()).getSharesByMintedEUSD(amount);\n            rewardPerTokenStored = rewardPerTokenStored + (share * 1e18) / totalStaked();\n        } else if(tokenType == 1) {\n            ERC20 token = ERC20(configurator.stableToken());\n            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e36 / token.decimals()) / totalStaked();\n        } else {\n            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e18) / totalStaked();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/lybra/miner/ProtocolRewardsPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title ProtocolRewardsPool is a derivative version of Synthetix StakingRewards.sol, distributing Protocol revenue to esLBR stakers.\n * Converting esLBR to LBR.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract esLBR.\n * - Get `stakedOf(user)` from balanceOf(user) in contract esLBR.\n * - When an address esLBR balance changes, call the refreshReward method to update rewards to be claimed.\n */\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"../interfaces/IesLBR.sol\";\n\ninterface IesLBRBoost {\n    function getUnlockTime(\n        address user\n    ) external view returns (uint256 unlockTime);\n}\n\ncontract ProtocolRewardsPool is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBR public esLBR;\n    IesLBR public LBR;\n    IesLBRBoost public esLBRBoost;\n\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint) public rewards;\n    mapping(address => uint) public time2fullRedemption;\n    mapping(address => uint) public unstakeRatio;\n    mapping(address => uint) public lastWithdrawTime;\n    uint256 immutable exitCycle = 90 days;\n    uint256 public grabableAmount;\n    uint256 public grabFeeRatio = 3000;\n    event Restake(address indexed user, uint256 amount, uint256 time);\n    event StakeLBR(address indexed user, uint256 amount, uint256 time);\n    event UnstakeLBR(address indexed user, uint256 amount, uint256 time);\n    event WithdrawLBR(address indexed user, uint256 amount, uint256 time);\n    event ClaimReward(address indexed user, uint256 eUSDAmount, address token, uint256 tokenAmount, uint256 time);\n\n    constructor(address _config) {\n        configurator = Iconfigurator(_config);\n    }\n\n    function setTokenAddress(address _eslbr, address _lbr, address _boost) external onlyOwner {\n        esLBR = IesLBR(_eslbr);\n        LBR = IesLBR(_lbr);\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setGrabCost(uint256 _ratio) external onlyOwner {\n        require(_ratio <= 8000, \"BCE\");\n        grabFeeRatio = _ratio;\n    }\n\n    // Total staked\n    function totalStaked() internal view returns (uint256) {\n        return esLBR.totalSupply();\n    }\n\n    // User address => esLBR balance\n    function stakedOf(address staker) internal view returns (uint256) {\n        return esLBR.balanceOf(staker);\n    }\n\n    function stake(uint256 amount) external {\n        LBR.burn(msg.sender, amount);\n        esLBR.mint(msg.sender, amount);\n        emit StakeLBR(msg.sender, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Unlocks esLBR and converts it to LBR.\n     * @param amount The amount to convert.\n     * Requirements:\n     * The current time must be greater than the unlock time retrieved from the boost contract for the user.\n     * Effects:\n     * Resets the user's vesting data, entering a new vesting period, when converting to LBR.\n     */\n    function unstake(uint256 amount) external {\n        require(block.timestamp >= esLBRBoost.getUnlockTime(msg.sender), \"Your lock-in period has not ended. You can't convert your esLBR now.\");\n        esLBR.burn(msg.sender, amount);\n        withdraw(msg.sender);\n        uint256 total = amount;\n        if (time2fullRedemption[msg.sender] > block.timestamp) {\n            total += unstakeRatio[msg.sender] * (time2fullRedemption[msg.sender] - block.timestamp);\n        }\n        unstakeRatio[msg.sender] = total / exitCycle;\n        time2fullRedemption[msg.sender] = block.timestamp + exitCycle;\n        emit UnstakeLBR(msg.sender, amount, block.timestamp);\n    }\n\n    function withdraw(address user) public {\n        uint256 amount = getClaimAbleLBR(user);\n        if (amount > 0) {\n            LBR.mint(user, amount);\n        }\n        lastWithdrawTime[user] = block.timestamp;\n        emit WithdrawLBR(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeems and converts the ESLBR being claimed in advance,\n     * with the lost portion being recorded in the contract and available for others to purchase in LBR at a certain ratio.\n     */\n    function unlockPrematurely() external {\n        require(block.timestamp + exitCycle - 3 days > time2fullRedemption[msg.sender], \"ENW\");\n        uint256 burnAmount = getReservedLBRForVesting(msg.sender) - getPreUnlockableAmount(msg.sender);\n        uint256 amount = getPreUnlockableAmount(msg.sender) + getClaimAbleLBR(msg.sender);\n        if (amount > 0) {\n            LBR.mint(msg.sender, amount);\n        }\n        unstakeRatio[msg.sender] = 0;\n        time2fullRedemption[msg.sender] = 0;\n        grabableAmount += burnAmount;\n    }\n\n    /**\n     * @dev Purchase the accumulated amount of pre-claimed lost ESLBR in the contract using LBR.\n     * @param amount The amount of ESLBR to be purchased.\n     * Requirements:\n     * The amount must be greater than 0.\n     */\n    function grabEsLBR(uint256 amount) external {\n        require(amount > 0, \"QMG\");\n        grabableAmount -= amount;\n        LBR.burn(msg.sender, (amount * grabFeeRatio) / 10000);\n        esLBR.mint(msg.sender, amount);\n    }\n\n    /**\n     * @dev Convert unredeemed and converting ESLBR tokens back to LBR.\n     */\n    function reStake() external {\n        uint256 amount = getReservedLBRForVesting(msg.sender) + getClaimAbleLBR(msg.sender);\n        esLBR.mint(msg.sender, amount);\n        unstakeRatio[msg.sender] = 0;\n        time2fullRedemption[msg.sender] = 0;\n        emit Restake(msg.sender, amount, block.timestamp);\n    }\n\n    function getPreUnlockableAmount(address user) public view returns (uint256 amount) {\n        uint256 a = getReservedLBRForVesting(user);\n        if (a == 0) return 0;\n        amount = (a * (75e18 - ((time2fullRedemption[user] - block.timestamp) * 70e18) / (exitCycle / 1 days - 3) / 1 days)) / 100e18;\n    }\n\n    function getClaimAbleLBR(address user) public view returns (uint256 amount) {\n        if (time2fullRedemption[user] > lastWithdrawTime[user]) {\n            amount = block.timestamp > time2fullRedemption[user] ? unstakeRatio[user] * (time2fullRedemption[user] - lastWithdrawTime[user]) : unstakeRatio[user] * (block.timestamp - lastWithdrawTime[user]);\n        }\n    }\n\n    function getReservedLBRForVesting(address user) public view returns (uint256 amount) {\n        if (time2fullRedemption[user] > block.timestamp) {\n            amount = unstakeRatio[user] * (time2fullRedemption[user] - block.timestamp);\n        }\n    }\n\n    function earned(address _account) public view returns (uint) {\n        return ((stakedOf(_account) * (rewardPerTokenStored - userRewardPerTokenPaid[_account])) / 1e18) + rewards[_account];\n    }\n\n    function getClaimAbleUSD(address user) external view returns (uint256 amount) {\n        amount = IEUSD(configurator.getEUSDAddress()).getMintedEUSDByShares(earned(user));\n    }\n\n    /**\n     * @dev Call this function when deposit or withdraw ETH on Lybra and update the status of corresponding user.\n     */\n    modifier updateReward(address account) {\n        rewards[account] = earned(account);\n        userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        _;\n    }\n\n    function refreshReward(address _account) external updateReward(_account) {}\n\n    /**\n     * @notice When claiming protocol rewards earnings, if there is a sufficient amount of eUSD in the ProtocolRewards Pool,\n     * the eUSD will be prioritized for distribution. Distributes earnings in the order of peUSD and other stablecoins if the eUSD balance is insufficient..\n     */\n    function getReward() external updateReward(msg.sender) {\n        uint reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IEUSD EUSD = IEUSD(configurator.getEUSDAddress());\n            uint256 balance = EUSD.sharesOf(address(this));\n            uint256 eUSDShare = balance >= reward ? reward : reward - balance;\n            EUSD.transferShares(msg.sender, eUSDShare);\n            if(reward > eUSDShare) {\n                ERC20 peUSD = ERC20(configurator.peUSD());\n                uint256 peUSDBalance = peUSD.balanceOf(address(this));\n                if(peUSDBalance >= reward - eUSDShare) {\n                    peUSD.transfer(msg.sender, reward - eUSDShare);\n                    emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(peUSD), reward - eUSDShare, block.timestamp);\n                } else {\n                    if(peUSDBalance > 0) {\n                        peUSD.transfer(msg.sender, peUSDBalance);\n                    }\n                    ERC20 token = ERC20(configurator.stableToken());\n                    uint256 tokenAmount = (reward - eUSDShare - peUSDBalance) * token.decimals() / 1e18;\n                    token.transfer(msg.sender, tokenAmount);\n                    emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(token), reward - eUSDShare, block.timestamp);\n                }\n            } else {\n                emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(0), 0, block.timestamp);\n            }\n           \n        }\n    }\n\n    /**\n     * @dev Receives stablecoin tokens sent by the configurator contract and records the protocol rewards accumulation per esLBR held.\n     * @param amount The amount of rewards to be distributed.\n     * @param tokenType The type of token (0 for eUSD, 1 for other stablecoins, 2 for peUSD).\n     * @dev This function is called by the configurator contract to distribute rewards.\n     * @dev When receiving stablecoin tokens other than eUSD, the decimals of the token are converted to 18 for consistent calculations.\n     */\n    function notifyRewardAmount(uint amount, uint tokenType) external {\n        require(msg.sender == address(configurator));\n        if (totalStaked() == 0) return;\n        require(amount > 0, \"amount = 0\");\n        if(tokenType == 0) {\n            uint256 share = IEUSD(configurator.getEUSDAddress()).getSharesByMintedEUSD(amount);\n            rewardPerTokenStored = rewardPerTokenStored + (share * 1e18) / totalStaked();\n        } else if(tokenType == 1) {\n            ERC20 token = ERC20(configurator.stableToken());\n            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e36 / token.decimals()) / totalStaked();\n        } else {\n            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e18) / totalStaked();\n        }\n    }\n}"
    }
  ]
}