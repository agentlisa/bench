{
  "Title": "`exchangeRate` can be manipulated",
  "Content": "##### Description\n\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/BaseConicPool.sol#L290\n\nWhen creating a pool, the user has an option to change the `exchangeRate` directly by sending tokens to ConicPool.\n\nTest example:\n\n```\nvm.startPrank(bb8); # hacker is setting `exchangeRate`\nconicPool.deposit(2, 0, false);\nunderlying.transfer(address(conicPool), 2 * 10 ** 18);\nvm.stopPrank();\n\n# now totalSupply = 1, \n# exchangeRate = 2000000000000000001000000000000000000 (~10**36)\n\n# victims try to deposit to ConicPool and will get zero lp tokens\nvm.startPrank(r2); \nunderlying.approve(address(conicPool), 10 ** 18);\nconicPool.deposit(10 ** 18, 0, false);\nvm.stopPrank();\n\nvm.startPrank(bb8); # withdraw all tokens from pool by hacker\nconicPool.withdraw(1, 0);\n```\n\nThis way an attacker can make the use of omnipool unprofitable at the very beginning.\n\n##### Recommendation\n\nThere are different approaches on how to solve the Inflation Attack problem. Some of the approaches along with their pros and cons, can be found in the OpenZeppelin github issue: https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3706.\n\nOne way to resolve the problem is to use virtual dead shares, as implemented in the latest OpenZeppelin ERC-4626 vault:\n* https://github.com/OpenZeppelin/openzeppelin-contracts/blob/51294b7480fd13e716207a621ac1d55a6290d56d/contracts/token/ERC20/extensions/ERC4626.sol#L200\n* https://github.com/OpenZeppelin/openzeppelin-contracts/blob/51294b7480fd13e716207a621ac1d55a6290d56d/contracts/token/ERC20/extensions/ERC4626.sol#L207\n\nIn case this particular fix is chosen, it is recommended to use a virtual offset of 1000 ([which is the same number used in Uniswap V2](https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L120)), as this will make the residual possibility of griefing practically unattainable.\n\nHowever, one of the simplest solutions is making a deposit immediately after the deployment so that the `exchangeRate` is adjusted.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/BaseConicPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../interfaces/pools/IConicPool.sol\";\nimport \"../interfaces/pools/IRewardManager.sol\";\nimport \"../interfaces/pools/IWithdrawalProcessor.sol\";\nimport \"../interfaces/ICurveRegistryCache.sol\";\nimport \"../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../interfaces/tokenomics/ILpTokenStaker.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/vendor/IBaseRewardPool.sol\";\n\nimport \"./LpToken.sol\";\nimport \"./Pausable.sol\";\n\nimport \"../libraries/ScaledMath.sol\";\nimport \"../libraries/ArrayExtensions.sol\";\n\nabstract contract BaseConicPool is IConicPool, Pausable {\n    using ArrayExtensions for uint256[];\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IERC20Metadata;\n    using SafeERC20 for ILpToken;\n    using ScaledMath for uint256;\n    using Address for address;\n    using ERC165Checker for address;\n\n    // Avoid stack depth errors\n    struct DepositVars {\n        uint256 exchangeRate;\n        uint256 underlyingBalanceIncrease;\n        uint256 mintableUnderlyingAmount;\n        uint256 lpReceived;\n        uint256 underlyingBalanceBefore;\n        uint256 allocatedBalanceBefore;\n        uint256[] allocatedPerPoolBefore;\n        uint256 underlyingBalanceAfter;\n        uint256 allocatedBalanceAfter;\n        uint256[] allocatedPerPoolAfter;\n    }\n\n    uint256 internal constant _IDLE_RATIO_UPPER_BOUND = 0.2e18;\n    uint256 internal constant _MIN_DEPEG_THRESHOLD = 0.01e18;\n    uint256 internal constant _MAX_DEPEG_THRESHOLD = 0.1e18;\n    uint256 internal constant _MAX_DEVIATION_UPPER_BOUND = 0.2e18;\n    uint256 internal constant _TOTAL_UNDERLYING_CACHE_EXPIRY = 3 days;\n    uint256 internal constant _MAX_USD_VALUE_FOR_REMOVING_POOL = 100e18;\n\n    IERC20 internal immutable CVX;\n    IERC20 internal immutable CRV;\n    IERC20 internal constant CNC = IERC20(0x9aE380F0272E2162340a5bB646c354271c0F5cFC);\n    address internal constant _WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    IERC20Metadata public immutable override underlying;\n    ILpToken public immutable override lpToken;\n\n    IRewardManager public immutable rewardManager;\n\n    /// @dev once the deviation gets under this threshold, the reward distribution will be paused\n    /// until the next rebalancing. This is expressed as a ratio, scaled with 18 decimals\n    uint256 public maxDeviation = 0.02e18; // 2%\n    uint256 public maxIdleCurveLpRatio = 0.05e18; // triggers Convex staking when exceeded\n    bool public isShutdown;\n    uint256 public depegThreshold = 0.03e18; // 3%\n    uint256 internal _cacheUpdatedTimestamp;\n    uint256 internal _cachedTotalUnderlying;\n\n    /// @dev `true` while the reward distribution is active\n    bool public rebalancingRewardActive;\n\n    EnumerableSet.AddressSet internal _pools;\n    EnumerableMap.AddressToUintMap internal weights; // liquidity allocation weights\n\n    /// @dev the absolute value in terms of USD of the total deviation after\n    /// the weights have been updated\n    uint256 public totalDeviationAfterWeightUpdate;\n\n    mapping(address => uint256) _cachedPrices;\n\n    modifier onlyController() {\n        require(msg.sender == address(controller), \"not authorized\");\n        _;\n    }\n\n    constructor(\n        address _underlying,\n        IRewardManager _rewardManager,\n        address _controller,\n        string memory _lpTokenName,\n        string memory _symbol,\n        address _cvx,\n        address _crv\n    ) Pausable(IController(_controller)) {\n        require(\n            _underlying != _cvx && _underlying != _crv && _underlying != address(CNC),\n            \"invalid underlying\"\n        );\n        underlying = IERC20Metadata(_underlying);\n        uint8 decimals = IERC20Metadata(_underlying).decimals();\n        lpToken = new LpToken(_controller, address(this), decimals, _lpTokenName, _symbol);\n        rewardManager = _rewardManager;\n\n        CVX = IERC20(_cvx);\n        CRV = IERC20(_crv);\n        CVX.safeApprove(address(_rewardManager), type(uint256).max);\n        CRV.safeApprove(address(_rewardManager), type(uint256).max);\n        CNC.safeApprove(address(_rewardManager), type(uint256).max);\n    }\n\n    /// @dev We always delegate-call to the Curve handler, which means\n    /// that we need to be able to receive the ETH to unwrap it and\n    /// send it to the Curve pool, as well as to receive it back from\n    /// the Curve pool when withdrawing\n    receive() external payable {\n        require(address(underlying) == _WETH_ADDRESS, \"not WETH pool\");\n    }\n\n    /// @notice Deposit underlying on behalf of someone\n    /// @param underlyingAmount Amount of underlying to deposit\n    /// @param minLpReceived The minimum amount of LP to accept from the deposit\n    /// @return lpReceived The amount of LP received\n    function depositFor(\n        address account,\n        uint256 underlyingAmount,\n        uint256 minLpReceived,\n        bool stake\n    ) public override notPaused returns (uint256) {\n        _sanityChecks();\n\n        DepositVars memory vars;\n\n        // Preparing deposit\n        require(!isShutdown, \"pool is shutdown\");\n        require(underlyingAmount > 0, \"deposit amount cannot be zero\");\n        uint256 underlyingPrice_ = controller.priceOracle().getUSDPrice(address(underlying));\n        (\n            vars.underlyingBalanceBefore,\n            vars.allocatedBalanceBefore,\n            vars.allocatedPerPoolBefore\n        ) = _getTotalAndPerPoolUnderlying(underlyingPrice_);\n        vars.exchangeRate = _exchangeRate(vars.underlyingBalanceBefore);\n\n        // Executing deposit\n        underlying.safeTransferFrom(msg.sender, address(this), underlyingAmount);\n        _depositToCurve(\n            vars.allocatedBalanceBefore,\n            vars.allocatedPerPoolBefore,\n            underlying.balanceOf(address(this))\n        );\n\n        // Minting LP Tokens\n        (\n            vars.underlyingBalanceAfter,\n            vars.allocatedBalanceAfter,\n            vars.allocatedPerPoolAfter\n        ) = _getTotalAndPerPoolUnderlying(underlyingPrice_);\n        vars.underlyingBalanceIncrease = vars.underlyingBalanceAfter - vars.underlyingBalanceBefore;\n        vars.mintableUnderlyingAmount = _min(underlyingAmount, vars.underlyingBalanceIncrease);\n        vars.lpReceived = vars.mintableUnderlyingAmount.divDown(vars.exchangeRate);\n        require(vars.lpReceived >= minLpReceived, \"too much slippage\");\n\n        if (stake) {\n            lpToken.mint(address(this), vars.lpReceived, account);\n            ILpTokenStaker lpTokenStaker = controller.lpTokenStaker();\n            lpToken.safeApprove(address(lpTokenStaker), vars.lpReceived);\n            lpTokenStaker.stakeFor(vars.lpReceived, address(this), account);\n        } else {\n            lpToken.mint(account, vars.lpReceived, account);\n        }\n\n        _handleRebalancingRewards(\n            account,\n            vars.allocatedBalanceBefore,\n            vars.allocatedPerPoolBefore,\n            vars.allocatedBalanceAfter,\n            vars.allocatedPerPoolAfter\n        );\n\n        _cachedTotalUnderlying = vars.underlyingBalanceAfter;\n        _cacheUpdatedTimestamp = block.timestamp;\n\n        emit Deposit(msg.sender, account, underlyingAmount, vars.lpReceived);\n        return vars.lpReceived;\n    }\n\n    /// @notice Deposit underlying\n    /// @param underlyingAmount Amount of underlying to deposit\n    /// @param minLpReceived The minimum amoun of LP to accept from the deposit\n    /// @return lpReceived The amount of LP received\n    function deposit(\n        uint256 underlyingAmount,\n        uint256 minLpReceived\n    ) external override returns (uint256) {\n        return depositFor(msg.sender, underlyingAmount, minLpReceived, true);\n    }\n\n    /// @notice Deposit underlying\n    /// @param underlyingAmount Amount of underlying to deposit\n    /// @param minLpReceived The minimum amoun of LP to accept from the deposit\n    /// @param stake Whether or not to stake in the LpTokenStaker\n    /// @return lpReceived The amount of LP received\n    function deposit(\n        uint256 underlyingAmount,\n        uint256 minLpReceived,\n        bool stake\n    ) external override returns (uint256) {\n        return depositFor(msg.sender, underlyingAmount, minLpReceived, stake);\n    }\n\n    function _depositToCurve(\n        uint256 totalUnderlying_,\n        uint256[] memory allocatedPerPool,\n        uint256 underlyingAmount_\n    ) internal {\n        uint256 depositsRemaining_ = underlyingAmount_;\n        uint256 totalAfterDeposit_ = totalUnderlying_ + underlyingAmount_;\n\n        // NOTE: avoid modifying `allocatedPerPool`\n        uint256[] memory allocatedPerPoolCopy = allocatedPerPool.copy();\n\n        while (depositsRemaining_ > 0) {\n            (uint256 poolIndex_, uint256 maxDeposit_) = _getDepositPool(\n                totalAfterDeposit_,\n                allocatedPerPoolCopy\n            );\n            // account for rounding errors\n            if (depositsRemaining_ < maxDeposit_ + 1e2) {\n                maxDeposit_ = depositsRemaining_;\n            }\n\n            address pool_ = _pools.at(poolIndex_);\n\n            // Depositing into least balanced pool\n            uint256 toDeposit_ = _min(depositsRemaining_, maxDeposit_);\n            address poolAdapter = address(controller.poolAdapterFor(pool_));\n            poolAdapter.functionDelegateCall(\n                abi.encodeWithSignature(\n                    \"deposit(address,address,uint256)\",\n                    pool_,\n                    address(underlying),\n                    toDeposit_\n                )\n            );\n\n            depositsRemaining_ -= toDeposit_;\n            allocatedPerPoolCopy[poolIndex_] += toDeposit_;\n        }\n    }\n\n    function _getDepositPool(\n        uint256 totalUnderlying_,\n        uint256[] memory allocatedPerPool\n    ) internal view returns (uint256 poolIndex, uint256 maxDepositAmount) {\n        uint256 poolsCount_ = allocatedPerPool.length;\n        int256 iPoolIndex = -1;\n        for (uint256 i; i < poolsCount_; i++) {\n            address pool_ = _pools.at(i);\n            uint256 allocatedUnderlying_ = allocatedPerPool[i];\n            uint256 targetAllocation_ = totalUnderlying_.mulDown(weights.get(pool_));\n            if (allocatedUnderlying_ >= targetAllocation_) continue;\n            uint256 maxBalance_ = targetAllocation_ + targetAllocation_.mulDown(_getMaxDeviation());\n            uint256 maxDepositAmount_ = maxBalance_ - allocatedUnderlying_;\n            if (maxDepositAmount_ <= maxDepositAmount) continue;\n            maxDepositAmount = maxDepositAmount_;\n            iPoolIndex = int256(i);\n        }\n        require(iPoolIndex > -1, \"error retrieving deposit pool\");\n        poolIndex = uint256(iPoolIndex);\n    }\n\n    /// @notice Get current underlying balance of pool\n    function totalUnderlying() public view virtual returns (uint256) {\n        (uint256 totalUnderlying_, , ) = getTotalAndPerPoolUnderlying();\n\n        return totalUnderlying_;\n    }\n\n    function _exchangeRate(uint256 totalUnderlying_) internal view returns (uint256) {\n        uint256 lpSupply = lpToken.totalSupply();\n        if (lpSupply == 0 || totalUnderlying_ == 0) return ScaledMath.ONE;\n\n        return totalUnderlying_.divDown(lpSupply);\n    }\n\n    /// @notice Get current exchange rate for the pool's LP token to the underlying\n    function exchangeRate() public view virtual override returns (uint256) {\n        return _exchangeRate(totalUnderlying());\n    }\n\n    /// @notice Get current exchange rate for the pool's LP token to USD\n    /// @dev This is using the cached total underlying value, so is not precisely accurate.\n    function usdExchangeRate() external view virtual override returns (uint256) {\n        uint256 underlyingPrice = controller.priceOracle().getUSDPrice(address(underlying));\n        return _exchangeRate(_cachedTotalUnderlying).mulDown(underlyingPrice);\n    }\n\n    /// @notice Unstake LP Tokens and withdraw underlying\n    /// @param conicLpAmount Amount of LP tokens to burn\n    /// @param minUnderlyingReceived Minimum amount of underlying to redeem\n    /// This should always be set to a reasonable value (e.g. 2%), otherwise\n    /// the user withdrawing could be forced into paying a withdrawal penalty fee\n    /// by another user\n    /// @return uint256 Total underlying withdrawn\n    function unstakeAndWithdraw(\n        uint256 conicLpAmount,\n        uint256 minUnderlyingReceived,\n        address to\n    ) public override returns (uint256) {\n        controller.lpTokenStaker().unstakeFrom(conicLpAmount, msg.sender);\n        return withdraw(conicLpAmount, minUnderlyingReceived, to);\n    }\n\n    function unstakeAndWithdraw(\n        uint256 conicLpAmount,\n        uint256 minUnderlyingReceived\n    ) external returns (uint256) {\n        return unstakeAndWithdraw(conicLpAmount, minUnderlyingReceived, msg.sender);\n    }\n\n    function withdraw(\n        uint256 conicLpAmount,\n        uint256 minUnderlyingReceived\n    ) public override returns (uint256) {\n        return withdraw(conicLpAmount, minUnderlyingReceived, msg.sender);\n    }\n\n    /// @notice Withdraw underlying\n    /// @param conicLpAmount Amount of LP tokens to burn\n    /// @param minUnderlyingReceived Minimum amount of underlying to redeem\n    /// This should always be set to a reasonable value (e.g. 2%), otherwise\n    /// the user withdrawing could be forced into paying a withdrawal penalty fee\n    /// by another user\n    /// @return uint256 Total underlying withdrawn\n    function withdraw(\n        uint256 conicLpAmount,\n        uint256 minUnderlyingReceived,\n        address to\n    ) public override returns (uint256) {\n        _sanityChecks();\n\n        // Preparing Withdrawals\n        require(lpToken.balanceOf(msg.sender) >= conicLpAmount, \"insufficient balance\");\n        uint256 underlyingBalanceBefore_ = underlying.balanceOf(address(this));\n\n        // Processing Withdrawals\n        (\n            uint256 totalUnderlying_,\n            uint256 allocatedUnderlying_,\n            uint256[] memory allocatedPerPool\n        ) = getTotalAndPerPoolUnderlying();\n        uint256 underlyingToReceive_ = conicLpAmount.mulDown(_exchangeRate(totalUnderlying_));\n        {\n            if (underlyingBalanceBefore_ < underlyingToReceive_) {\n                uint256 underlyingToWithdraw_ = underlyingToReceive_ - underlyingBalanceBefore_;\n                _withdrawFromCurve(allocatedUnderlying_, allocatedPerPool, underlyingToWithdraw_);\n            }\n        }\n\n        // Sending Underlying and burning LP Tokens\n        uint256 underlyingWithdrawn_ = _min(\n            underlying.balanceOf(address(this)),\n            underlyingToReceive_\n        );\n        require(underlyingWithdrawn_ >= minUnderlyingReceived, \"too much slippage\");\n        lpToken.burn(msg.sender, conicLpAmount, msg.sender);\n        underlying.safeTransfer(to, underlyingWithdrawn_);\n\n        _cachedTotalUnderlying = totalUnderlying_ - underlyingWithdrawn_;\n        _cacheUpdatedTimestamp = block.timestamp;\n\n        // state has already been updated, so no need to worry about re-entrancy\n        if (to.supportsInterface(type(IWithdrawalProcessor).interfaceId)) {\n            IWithdrawalProcessor(to).processWithdrawal(msg.sender, underlyingWithdrawn_);\n        }\n\n        emit Withdraw(msg.sender, underlyingWithdrawn_);\n        return underlyingWithdrawn_;\n    }\n\n    function _withdrawFromCurve(\n        uint256 totalUnderlying_,\n        uint256[] memory allocatedPerPool,\n        uint256 amount_\n    ) internal {\n        uint256 withdrawalsRemaining_ = amount_;\n        uint256 totalAfterWithdrawal_ = totalUnderlying_ - amount_;\n\n        // NOTE: avoid modifying `allocatedPerPool`\n        uint256[] memory allocatedPerPoolCopy = allocatedPerPool.copy();\n\n        while (withdrawalsRemaining_ > 0) {\n            (uint256 poolIndex_, uint256 maxWithdrawal_) = _getWithdrawPool(\n                totalAfterWithdrawal_,\n                allocatedPerPoolCopy\n            );\n            address pool_ = _pools.at(poolIndex_);\n\n            // Withdrawing from least balanced pool\n            uint256 toWithdraw_ = _min(withdrawalsRemaining_, maxWithdrawal_);\n\n            address poolAdapter = address(controller.poolAdapterFor(pool_));\n            poolAdapter.functionDelegateCall(\n                abi.encodeWithSignature(\n                    \"withdraw(address,address,uint256)\",\n                    pool_,\n                    underlying,\n                    toWithdraw_\n                )\n            );\n            withdrawalsRemaining_ -= toWithdraw_;\n            allocatedPerPoolCopy[poolIndex_] -= toWithdraw_;\n        }\n    }\n\n    function _getWithdrawPool(\n        uint256 totalUnderlying_,\n        uint256[] memory allocatedPerPool\n    ) internal view returns (uint256 withdrawPoolIndex, uint256 maxWithdrawalAmount) {\n        uint256 poolsCount_ = allocatedPerPool.length;\n        int256 iWithdrawPoolIndex = -1;\n        for (uint256 i; i < poolsCount_; i++) {\n            address curvePool_ = _pools.at(i);\n            uint256 weight_ = weights.get(curvePool_);\n            uint256 allocatedUnderlying_ = allocatedPerPool[i];\n\n            // If a pool has a weight of 0,\n            // withdraw from it if it has more than the max lp value\n            if (weight_ == 0) {\n                uint256 price_ = controller.priceOracle().getUSDPrice(address(underlying));\n                uint256 allocatedUsd = (price_ * allocatedUnderlying_) /\n                    10 ** underlying.decimals();\n                if (allocatedUsd >= _MAX_USD_VALUE_FOR_REMOVING_POOL / 2) {\n                    return (uint256(i), allocatedUnderlying_);\n                }\n            }\n\n            uint256 targetAllocation_ = totalUnderlying_.mulDown(weight_);\n            if (allocatedUnderlying_ <= targetAllocation_) continue;\n            uint256 minBalance_ = targetAllocation_ - targetAllocation_.mulDown(_getMaxDeviation());\n            uint256 maxWithdrawalAmount_ = allocatedUnderlying_ - minBalance_;\n            if (maxWithdrawalAmount_ <= maxWithdrawalAmount) continue;\n            maxWithdrawalAmount = maxWithdrawalAmount_;\n            iWithdrawPoolIndex = int256(i);\n        }\n        require(iWithdrawPoolIndex > -1, \"error retrieving withdraw pool\");\n        withdrawPoolIndex = uint256(iWithdrawPoolIndex);\n    }\n\n    function allPools() external view override returns (address[] memory) {\n        return _pools.values();\n    }\n\n    function poolsCount() external view override returns (uint256) {\n        return _pools.length();\n    }\n\n    function getPoolAtIndex(uint256 _index) external view returns (address) {\n        return _pools.at(_index);\n    }\n\n    function isRegisteredPool(address _pool) public view returns (bool) {\n        return _pools.contains(_pool);\n    }\n\n    function getPoolWeight(address _pool) external view returns (uint256) {\n        (, uint256 _weight) = weights.tryGet(_pool);\n        return _weight;\n    }\n\n    // Controller and Admin functions\n\n    function addPool(address _pool) external override onlyOwner {\n        require(!_pools.contains(_pool), \"pool already added\");\n        IPoolAdapter poolAdapter = controller.poolAdapterFor(_pool);\n        bool supported_ = poolAdapter.supportsAsset(_pool, address(underlying));\n        require(supported_, \"coin not in pool\");\n        address lpToken_ = poolAdapter.lpToken(_pool);\n        require(controller.priceOracle().isTokenSupported(lpToken_), \"cannot price LP Token\");\n\n        address booster = controller.convexBooster();\n        IERC20(lpToken_).safeApprove(booster, type(uint256).max);\n\n        if (!weights.contains(_pool)) weights.set(_pool, 0);\n        require(_pools.add(_pool), \"failed to add pool\");\n        emit CurvePoolAdded(_pool);\n    }\n\n    // This requires that the weight of the pool is first set to 0\n    function removePool(address _pool) external override onlyOwner {\n        require(_pools.contains(_pool), \"pool not added\");\n        require(_pools.length() > 1, \"cannot remove last pool\");\n        IPoolAdapter poolAdapter = controller.poolAdapterFor(_pool);\n        address lpToken_ = poolAdapter.lpToken(_pool);\n        uint256 usdValue = poolAdapter.computePoolValueInUSD(address(this), _pool);\n        require(usdValue < _MAX_USD_VALUE_FOR_REMOVING_POOL, \"pool has allocated funds\");\n        uint256 weight = weights.get(_pool);\n        IERC20(lpToken_).safeApprove(controller.convexBooster(), 0);\n        require(weight == 0, \"pool has weight set\");\n        require(_pools.remove(_pool), \"pool not removed\");\n        require(weights.remove(_pool), \"weight not removed\");\n        emit CurvePoolRemoved(_pool);\n    }\n\n    function updateWeights(PoolWeight[] memory poolWeights) external onlyController {\n        require(poolWeights.length == _pools.length(), \"invalid pool weights\");\n        uint256 total;\n        for (uint256 i; i < poolWeights.length; i++) {\n            address pool = poolWeights[i].poolAddress;\n            require(isRegisteredPool(pool), \"pool is not registered\");\n            uint256 newWeight = poolWeights[i].weight;\n            weights.set(pool, newWeight);\n            emit NewWeight(pool, newWeight);\n            total += newWeight;\n        }\n\n        require(total == ScaledMath.ONE, \"weights do not sum to 1\");\n\n        (\n            uint256 totalUnderlying_,\n            uint256 totalAllocated,\n            uint256[] memory allocatedPerPool\n        ) = getTotalAndPerPoolUnderlying();\n\n        uint256 totalDeviation = _computeTotalDeviation(totalUnderlying_, allocatedPerPool);\n        totalDeviationAfterWeightUpdate = totalDeviation;\n        rebalancingRewardActive = !_isBalanced(allocatedPerPool, totalAllocated);\n\n        // Updating price cache for all pools\n        // Used for seeing if a pool has depegged\n        _updatePriceCache();\n    }\n\n    function shutdownPool() external override onlyController {\n        require(!isShutdown, \"pool already shutdown\");\n        isShutdown = true;\n        emit Shutdown();\n    }\n\n    function updateDepegThreshold(uint256 newDepegThreshold_) external onlyOwner {\n        require(newDepegThreshold_ >= _MIN_DEPEG_THRESHOLD, \"invalid depeg threshold\");\n        require(newDepegThreshold_ <= _MAX_DEPEG_THRESHOLD, \"invalid depeg threshold\");\n        depegThreshold = newDepegThreshold_;\n        emit DepegThresholdUpdated(newDepegThreshold_);\n    }\n\n    /// @notice Called when an underlying of a Curve Pool has depegged and we want to exit the pool.\n    /// Will check if a coin has depegged, and will revert if not.\n    /// Sets the weight of the Curve Pool to 0, and re-enables CNC rewards for deposits.\n    /// @dev Cannot be called if the underlying of this pool itself has depegged.\n    /// @param curvePool_ The Curve Pool to handle.\n    function handleDepeggedCurvePool(address curvePool_) external override {\n        _sanityChecks();\n\n        // Validation\n        require(isRegisteredPool(curvePool_), \"pool is not registered\");\n        require(weights.get(curvePool_) != 0, \"pool weight already 0\");\n        require(!_isDepegged(address(underlying)), \"underlying is depegged\");\n        address lpToken_ = controller.poolAdapterFor(curvePool_).lpToken(curvePool_);\n        require(_isDepegged(lpToken_), \"pool is not depegged\");\n\n        // Set target curve pool weight to 0\n        // Scale up other weights to compensate\n        _setWeightToZero(curvePool_);\n        rebalancingRewardActive = true;\n\n        emit HandledDepeggedCurvePool(curvePool_);\n    }\n\n    function _setWeightToZero(address zeroedPool) internal {\n        uint256 weight_ = weights.get(zeroedPool);\n        if (weight_ == 0) return;\n        require(weight_ != ScaledMath.ONE, \"can't remove last pool\");\n        uint256 scaleUp_ = ScaledMath.ONE.divDown(ScaledMath.ONE - weights.get(zeroedPool));\n        uint256 curvePoolLength_ = _pools.length();\n        for (uint256 i; i < curvePoolLength_; i++) {\n            address pool_ = _pools.at(i);\n            uint256 newWeight_ = pool_ == zeroedPool ? 0 : weights.get(pool_).mulDown(scaleUp_);\n            weights.set(pool_, newWeight_);\n            emit NewWeight(pool_, newWeight_);\n        }\n\n        // Updating total deviation\n        (\n            uint256 totalUnderlying_,\n            ,\n            uint256[] memory allocatedPerPool\n        ) = getTotalAndPerPoolUnderlying();\n        uint256 totalDeviation = _computeTotalDeviation(totalUnderlying_, allocatedPerPool);\n        totalDeviationAfterWeightUpdate = totalDeviation;\n    }\n\n    /**\n     * @notice Allows anyone to set the weight of a Curve pool to 0 if the Convex pool for the\n     * associated PID has been shutdown. This is a very unilkely outcomu and the method does\n     * not reenable rebalancing rewards.\n     * @param curvePool_ Curve pool for which the Convex PID is invalid (has been shut down)\n     */\n    function handleInvalidConvexPid(address curvePool_) external {\n        require(isRegisteredPool(curvePool_), \"curve pool not registered\");\n        ICurveRegistryCache registryCache_ = controller.curveRegistryCache();\n        uint256 pid = registryCache_.getPid(curvePool_);\n        require(registryCache_.isShutdownPid(pid), \"convex pool pid is shutdown\");\n        _setWeightToZero(curvePool_);\n        emit HandledInvalidConvexPid(curvePool_, pid);\n    }\n\n    function setMaxIdleCurveLpRatio(uint256 maxIdleCurveLpRatio_) external onlyOwner {\n        require(maxIdleCurveLpRatio != maxIdleCurveLpRatio_, \"same as current\");\n        require(maxIdleCurveLpRatio_ <= _IDLE_RATIO_UPPER_BOUND, \"ratio exceeds upper bound\");\n        maxIdleCurveLpRatio = maxIdleCurveLpRatio_;\n        emit NewMaxIdleCurveLpRatio(maxIdleCurveLpRatio_);\n    }\n\n    function setMaxDeviation(uint256 maxDeviation_) external onlyOwner {\n        require(maxDeviation != maxDeviation_, \"same as current\");\n        require(maxDeviation_ <= _MAX_DEVIATION_UPPER_BOUND, \"deviation exceeds upper bound\");\n        maxDeviation = maxDeviation_;\n        emit MaxDeviationUpdated(maxDeviation_);\n    }\n\n    function getWeight(address pool) external view returns (uint256) {\n        return weights.get(pool);\n    }\n\n    function getWeights() external view override returns (PoolWeight[] memory) {\n        uint256 length_ = _pools.length();\n        PoolWeight[] memory weights_ = new PoolWeight[](length_);\n        for (uint256 i; i < length_; i++) {\n            (address pool_, uint256 weight_) = weights.at(i);\n            weights_[i] = PoolWeight(pool_, weight_);\n        }\n        return weights_;\n    }\n\n    function getAllocatedUnderlying() external view override returns (PoolWithAmount[] memory) {\n        PoolWithAmount[] memory perPoolAllocated = new PoolWithAmount[](_pools.length());\n        (, , uint256[] memory allocated) = getTotalAndPerPoolUnderlying();\n\n        for (uint256 i; i < perPoolAllocated.length; i++) {\n            perPoolAllocated[i] = PoolWithAmount(_pools.at(i), allocated[i]);\n        }\n        return perPoolAllocated;\n    }\n\n    function computeTotalDeviation() external view override returns (uint256) {\n        (\n            ,\n            uint256 allocatedUnderlying_,\n            uint256[] memory perPoolUnderlying\n        ) = getTotalAndPerPoolUnderlying();\n        return _computeTotalDeviation(allocatedUnderlying_, perPoolUnderlying);\n    }\n\n    function cachedTotalUnderlying() external view virtual override returns (uint256) {\n        if (block.timestamp > _cacheUpdatedTimestamp + _TOTAL_UNDERLYING_CACHE_EXPIRY) {\n            return totalUnderlying();\n        }\n        return _cachedTotalUnderlying;\n    }\n\n    function getTotalAndPerPoolUnderlying()\n        public\n        view\n        returns (\n            uint256 totalUnderlying_,\n            uint256 totalAllocated_,\n            uint256[] memory perPoolUnderlying_\n        )\n    {\n        uint256 underlyingPrice_ = controller.priceOracle().getUSDPrice(address(underlying));\n        return _getTotalAndPerPoolUnderlying(underlyingPrice_);\n    }\n\n    function isBalanced() external view override returns (bool) {\n        (\n            ,\n            uint256 allocatedUnderlying_,\n            uint256[] memory allocatedPerPool_\n        ) = getTotalAndPerPoolUnderlying();\n        return _isBalanced(allocatedPerPool_, allocatedUnderlying_);\n    }\n\n    /**\n     * @notice Returns several values related to the Omnipools's underlying assets.\n     * @param underlyingPrice_ Price of the underlying asset in USD\n     * @return totalUnderlying_ Total underlying value of the Omnipool\n     * @return totalAllocated_ Total underlying value of the Omnipool that is allocated to Curve pools\n     * @return perPoolUnderlying_ Array of underlying values of the Omnipool that is allocated to each Curve pool\n     */\n    function _getTotalAndPerPoolUnderlying(\n        uint256 underlyingPrice_\n    )\n        internal\n        view\n        returns (\n            uint256 totalUnderlying_,\n            uint256 totalAllocated_,\n            uint256[] memory perPoolUnderlying_\n        )\n    {\n        uint256 poolsLength_ = _pools.length();\n        perPoolUnderlying_ = new uint256[](poolsLength_);\n\n        for (uint256 i; i < poolsLength_; i++) {\n            address pool_ = _pools.at(i);\n            uint256 poolUnderlying_ = controller.poolAdapterFor(pool_).computePoolValueInUnderlying(\n                address(this),\n                pool_,\n                address(underlying),\n                underlyingPrice_\n            );\n            perPoolUnderlying_[i] = poolUnderlying_;\n            totalAllocated_ += poolUnderlying_;\n        }\n        totalUnderlying_ = totalAllocated_ + underlying.balanceOf(address(this));\n    }\n\n    function _computeTotalDeviation(\n        uint256 allocatedUnderlying_,\n        uint256[] memory perPoolAllocations_\n    ) internal view returns (uint256) {\n        uint256 totalDeviation;\n        for (uint256 i; i < perPoolAllocations_.length; i++) {\n            uint256 weight = weights.get(_pools.at(i));\n            uint256 targetAmount = allocatedUnderlying_.mulDown(weight);\n            totalDeviation += targetAmount.absSub(perPoolAllocations_[i]);\n        }\n        return totalDeviation;\n    }\n\n    function _handleRebalancingRewards(\n        address account,\n        uint256 allocatedBalanceBefore_,\n        uint256[] memory allocatedPerPoolBefore,\n        uint256 allocatedBalanceAfter_,\n        uint256[] memory allocatedPerPoolAfter\n    ) internal {\n        if (!rebalancingRewardActive) return;\n        uint256 deviationBefore = _computeTotalDeviation(\n            allocatedBalanceBefore_,\n            allocatedPerPoolBefore\n        );\n        uint256 deviationAfter = _computeTotalDeviation(\n            allocatedBalanceAfter_,\n            allocatedPerPoolAfter\n        );\n\n        controller.inflationManager().handleRebalancingRewards(\n            account,\n            deviationBefore,\n            deviationAfter\n        );\n\n        if (_isBalanced(allocatedPerPoolAfter, allocatedBalanceAfter_)) {\n            rebalancingRewardActive = false;\n        }\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function _isBalanced(\n        uint256[] memory allocatedPerPool_,\n        uint256 totalAllocated_\n    ) internal view returns (bool) {\n        if (totalAllocated_ == 0) return true;\n        for (uint256 i; i < allocatedPerPool_.length; i++) {\n            uint256 weight_ = weights.get(_pools.at(i));\n            uint256 currentAllocated_ = allocatedPerPool_[i];\n\n            // If a curve pool has a weight of 0,\n            if (weight_ == 0) {\n                uint256 price_ = controller.priceOracle().getUSDPrice(address(underlying));\n                uint256 allocatedUsd_ = (price_ * currentAllocated_) / 10 ** underlying.decimals();\n                if (allocatedUsd_ >= _MAX_USD_VALUE_FOR_REMOVING_POOL / 2) {\n                    return false;\n                }\n                continue;\n            }\n\n            uint256 targetAmount = totalAllocated_.mulDown(weight_);\n            uint256 deviation = targetAmount.absSub(currentAllocated_);\n            uint256 deviationRatio = deviation.divDown(targetAmount);\n\n            if (deviationRati"
    }
  ]
}