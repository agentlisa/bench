{
  "Title": "M-6: Long traders unable to withdraw their assets",
  "Content": "# Issue M-6: Long traders unable to withdraw their assets \n\nSource: https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/196 \n\n## Found by \nCL001, shaka, xiaoming90\n## Summary\n\nWhenever the protocol reaches a state where the long trader's profit is larger than LP's stable collateral total, the protocol will be bricked. As a result, the margin deposited and gain of the long traders can no longer be withdrawn and the LPs cannot withdraw their collateral, leading to a loss of assets for the  users.\n\n## Vulnerability Detail\n\nPer Line 97 below, if the collateral balance is less than the tracked balance, the `_getCollateralNet` invariant check will revert.\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/misc/InvariantChecks.sol#L97\n\n```solidity\nFile: InvariantChecks.sol\n089:     /// @dev Returns the difference between actual total collateral balance in the vault vs tracked collateral\n090:     ///      Tracked collateral should be updated when depositing to stable LP (stableCollateralTotal) or\n091:     ///      opening leveraged positions (marginDepositedTotal).\n092:     /// TODO: Account for margin of error due to rounding.\n093:     function _getCollateralNet(IFlatcoinVault vault) private view returns (uint256 netCollateral) {\n094:         uint256 collateralBalance = vault.collateral().balanceOf(address(vault));\n095:         uint256 trackedCollateral = vault.stableCollateralTotal() + vault.getGlobalPositions().marginDepositedTotal;\n096: \n097:         if (collateralBalance < trackedCollateral) revert FlatcoinErrors.InvariantViolation(\"collateralNet\");\n098: \n099:         return collateralBalance - trackedCollateral;\n100:     }\n```\n\nAssume that:\n\n- Bob's long position: Margin = 50 ETH\n- Alice's LP: Deposited = 50 ETH\n- Collateral Balance = 100 ETH\n- Tracked Balance = 100 ETH (Stable Collateral Total = 50 ETH, Margin Deposited Total = 50 ETH)\n\nAssume that Bob's long position gains a profit of 51 ETH.\n\nThe following actions will trigger the `updateGlobalPositionData` function internally: executeOpen, executeAdjust, executeClose, and liquidation.\n\nWhen the ` FlatcoinVault.updateGlobalPositionData` function is triggered to update the global position data:\n\n```solidity\nprofitLossTotal = 51 ETH (gain by long)\n\nnewMarginDepositedTotal = marginDepositedTotal + marginDelta + profitLossTotal\nnewMarginDepositedTotal = 50 ETH + 0 + 51 ETH = 101 ETH\n\n_updateStableCollateralTotal(-51 ETH)\nnewStableCollateralTotal = stableCollateralTotal + _stableCollateralAdjustment\nnewStableCollateralTotal = 50 ETH + (-51 ETH) = -1 ETH\nstableCollateralTotal = (newStableCollateralTotal > 0) ? newStableCollateralTotal : 0;\nstableCollateralTotal = 0\n```\n\nIn this case, the state becomes as follows:\n\n- Collateral Balance = 100 ETH\n- Tracked Balance = 101 ETH (Stable Collateral Total = 0 ETH, Margin Deposited Total = 101 ETH)\n\nNotice that the Collateral Balance and Tracked Balance are no longer in sync. As such, the revert will occur when the `_getCollateralNet` invariant checks are performed.\n\nWhenever the protocol reaches a state where the long trader's profit is larger than LP's stable collateral total, this issue will occur, and the protocol will be bricked. The margin deposited and gain of the long traders can no longer be withdrawn from the protocol. The LPs also cannot withdraw their collateral.\n\nThe reason is that the `_getCollateralNet` invariant checks are performed in all functions of the protocol that can be accessed by users (listed below):\n\n- Deposit\n- Withdraw\n- Open Position\n- Adjust Position\n- Close Position\n- Liquidate\n\n## Impact\n\nLoss of assets for the users. Since the protocol is bricked due to revert, the long traders are unable to withdraw their deposited margin and gain and the LPs cannot withdraw their collateral.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/misc/InvariantChecks.sol#L97\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCurrently, when the loss of the LP is more than the existing `stableCollateralTotal`, the loss will be capped at zero, and it will not go negative. In the above example, the `stableCollateralTotal` is 50, and the loss is 51. Thus, the `stableCollateralTotal` is set to zero instead of -1.\n\nThe loss of LP and the gain of the trader should be aligned or symmetric. However, this is not the case in the current implementation. In the above example, the gain of traders is 51, while the loss of LP is 50, which results in a discrepancy here.\n\nTo fix the issue, the loss of LP and the gain of the trader should be aligned. For instance, in the above example, if the loss of LP is capped at 50, then the profit of traders must also be capped at 50.\n\nFollowing is a high-level logic of the fix:\n\n```solidity\nIf (profitLossTotal > stableCollateralTotal): // (51 > 50) => True\n\tprofitLossTotal = stableCollateralTotal // profitLossTotal = 50\n\t\nnewMarginDepositedTotal = marginDepositedTotal + marginDelta + profitLossTotal // 50 + 0 + 50 = 100\n\t\nnewStableCollateralTotal = stableCollateralTotal + (-profitLossTotal) // 50 + (-50) = 0\nstableCollateralTotal = (newStableCollateralTotal > 0) ? newStableCollateralTotal : 0; // stableCollateralTotal = 0\n```\n\nThe comment above verifies that the logic is working as intended.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: high(6)\n\n\n\n**ydspa**\n\nEscalate\n\nThis should be a medium issue, as the likelihood is extreme low due to strict external market conditions\n>Flatcoin can be net short and ETH goes up 5x in a short period of time, potentially leading to UNIT going to 0.\nhttps://audits.sherlock.xyz/contests/132\n\nMeet sherlock's rule for Medium\n>Causes a loss of funds but requires certain external conditions or specific states\n\nBut not meet the rule for High\n>Definite loss of funds without (extensive) limitations of external conditions\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This should be a medium issue, as the likelihood is extreme low due to strict external market conditions\n> >Flatcoin can be net short and ETH goes up 5x in a short period of time, potentially leading to UNIT going to 0.\n> https://audits.sherlock.xyz/contests/132\n> \n> Meet sherlock's rule for Medium\n> >Causes a loss of funds but requires certain external conditions or specific states\n> \n> But not meet the rule for High\n> >Definite loss of funds without (extensive) limitations of external conditions\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**xiaoming9090**\n\nDisagree with the escalation. The following point in the escalation is simply a remark by the protocol team stating that if the ETH goes up 5x, the value of UNIT token will go down to zero\n\n> Flatcoin can be net short and ETH goes up 5x in a short period of time, potentially leading to UNIT going to 0.\n> https://audits.sherlock.xyz/contests/132\n\nIt has nothing to do with preventing the protocol from reaching a state where the long trader's profit is larger than LP's stable collateral total. \n\nOn the other hand, this point made by the protocol team actually reinforces the case I made in the report. The point by the protocol team highlighted the fact that the ETH can go up significantly over a short period of time. When this happens,  the long trader's profit will be large. Thus, it will cause the protocol to reach a state where the long trader's profit is larger than LP's stable collateral total, which triggers this issue. When this happens, the protocol will be bricked, thus justified for a High.\n\nAlso, the requirement for High is \"Definite loss of funds without (extensive) limitations of external conditions\". This issue can occur without extensive external conditions as only one condition, which is the price of the ETH goes up significantly, is needed to trigger the bug. Thus, it meets the requirement of a High issue.\n\n**Czar102**\n\n@xiaoming9090 aren't protocol risk parameters set not to allow the long traders' profits to be larger than LP funds?\n\n**xiaoming9090**\n\n> @xiaoming9090 aren't protocol risk parameters set not to allow the long traders' profits to be larger than LP funds?\n\n@Czar102 The risk parameter I'm aware of is the `skewFractionMax` parameter, which prevents the system from having too many long positions compared to short positions. The maximum ratio of long to short position size is 1.2 (120% long: 100% long) during the audit. The purpose of limiting the number of long positions is to avoid the long side wiping out the value of the short side (LP) too quickly when the ETH price goes up.\n\nHowever, I'm unaware of any restrictions constraining long traders' profits. The long traders' profits will increase along with the increase in ETH price.\n\n**Czar102**\n\nSo, the price needs to go up 5x in order to trigger this issue?\n\n**xiaoming9090**\n\n@Czar102 Depending on the `skewFractionMax` parameter being configured at any single point of time. The owner can change this value via the `setSkewFractionMax` function. The higher the value is, the smaller the price increase needed to trigger the issue.\n\nIf the `skewFractionMax` is set to 20%, 5x will cause the LP's UNIT holding to drop to zero. Thus, slightly more than 5x will trigger this issue.\nSidenote: The 20% is chosen in this report since it was mentioned in the contest's README \n\n**Czar102**\n\nI think this is a fair assumption to have these values set so that other positions will practically never go into negative values – so this bug will practically never be triggered. Hence, the assumptions for this issue to be triggered are quite extensive.\n\nPlanning to accept the escalation and consider this issue a Medium severity one.\n\n**0xjuaan**\n\nSo it seems that in order for this issue to be triggered, ETH has to rise 5x in a short period of time. \n\nHowever in the 'known issues/acceptable risks that should not result in a valid finding' section of the contest README, it says:\n\n> theoretically, if ETH price increases by 5x in a short period of time whilst the flatcoin holders are 20% short, it's possible for flatcoin value to go to 0. This scenario is deemed to be extremely unlikely and the funding rate is able to move quickly enough to bring the flatcoin holders back to delta neutral.\n\nSince that scenario is required to trigger this issue, this issue should not be deemed as valid. \n\n**xiaoming9090**\n\n> So it seems that in order for this issue to be triggered, ETH has to rise 5x in a short period of time.\n> \n> However in the 'known issues/acceptable risks that should not result in a valid finding' section of the contest README, it says:\n> \n> > theoretically, if ETH price increases by 5x in a short period of time whilst the flatcoin holders are 20% short, it's possible for flatcoin value to go to 0. This scenario is deemed to be extremely unlikely and the funding rate is able to move quickly enough to bring the flatcoin holders back to delta neutral.\n> \n> Since that scenario is required to trigger this issue, this issue should not be deemed as valid.\n\nThe README mentioned that the team is aware of a scenario where the price can go up significantly, leading the LP's Flatcoin value to go to 0. However, that does not mean that the team is aware of other potential consequences when this scenario happens.\n\n**0xjuaan**\n\nBut surely if the sponsor deemed that the very rapid 5x price increase of ETH is extremely unlikely, that means that its an acceptable risk that they take on. So any issue which relies on that scenario is a part of that same acceptable risk, so shouldn't be valid right?\n\nThe sponsor clarified why they accept this risk and issues relating to this scenario shouldn't be reported, [in this public discord message](https://discord.com/channels/812037309376495636/1199005620536356874/1202614374703824927)\n\n> Hello everyone. I believe some of you guys might have a doubt whether UNIT going to 0 is an issue or not. I believe it was mentioned that UNIT going to 0 is a known behaviour of the system but the reason might not be clear as to why. If the collateral price increases by let's say 5x (in case the skew limit is 120%), the entire short side (UNIT LPs) will be liquidated (though not liquidated in the same way as how leveraged longs are). The system will most likely not be able to recover as longs can simply close their positions and the take away the collateral. The hope is that this scenario doesn't play out in the future due to informed LPs and funding rate and other incentives but we know this is crypto and anything is possible here. Just wanted to clarify this so that we don't get this as a reported issue.\n\n\n**xiaoming9090**\n\nThe team is aware and has accepted that FlatCoin's value (short-side/LP) will go to zero when the price goes up significantly.\nHowever, that is different from this report where the long traders are unable to withdraw when the price goes up significantly.\n\nThese are two separate issues, and the root causes are different. The reason why the FlatCoin's value can go to zero is due to the design of the protocol where the short side can lose to the long side. However, this report and its duplicated reports highlighted a bug in the existing implementation that could lead to long traders being unable to withdraw.\n\n\n\n**nevillehuang**\n\n> I think this is a fair assumption to have these values set so that other positions will practically never go into negative values – so this bug will practically never be triggered. Hence, the assumptions for this issue to be triggered are quite extensive.\n> \n> Planning to accept the escalation and consider this issue a Medium severity one.\n\nAgree to downgrade to medium severity based on dependency of large price increases.\n\n**Czar102**\n\nBased on https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/196#issuecomment-1970315654, still planning to consider this a valid Medium.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ydspa](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/196/#issuecomment-1955885947): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/132",
  "Code": [
    {
      "filename": "flatcoin-v1/src/misc/InvariantChecks.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {FlatcoinErrors} from \"../libraries/FlatcoinErrors.sol\";\nimport {FlatcoinModuleKeys} from \"../libraries/FlatcoinModuleKeys.sol\";\nimport {IFlatcoinVault} from \"../interfaces/IFlatcoinVault.sol\";\nimport {IStableModule} from \"../interfaces/IStableModule.sol\";\nimport {ILeverageModule} from \"../interfaces/ILeverageModule.sol\";\nimport {ILiquidationModule} from \"../interfaces/ILiquidationModule.sol\";\n\n/// @title InvariantChecks\n/// @author dHEDGE\n/// @notice Contract module for critical invariant checking on the protocol.\nabstract contract InvariantChecks {\n    struct InvariantOrder {\n        uint256 collateralNet;\n        uint256 stableCollateralPerShare;\n    }\n\n    struct InvariantLiquidation {\n        uint256 collateralNet;\n        uint256 stableCollateralPerShare;\n        int256 remainingMargin;\n        uint256 liquidationFee;\n    }\n\n    /// @notice Invariant checks on order execution\n    /// @dev Checks:\n    ///      1. Collateral net: The vault collateral balance relative to tracked collateral on both stable LP and leverage side should not change\n    ///      2. Stable collateral per share: Stable LP value per share should never decrease after order execution. It should only increase due to collected trading fees\n    modifier orderInvariantChecks(IFlatcoinVault vault) {\n        IStableModule stableModule = IStableModule(vault.moduleAddress(FlatcoinModuleKeys._STABLE_MODULE_KEY));\n\n        InvariantOrder memory invariantBefore = InvariantOrder({ // helps with stack too deep\n            collateralNet: _getCollateralNet(vault),\n            stableCollateralPerShare: stableModule.stableCollateralPerShare()\n        });\n\n        _;\n\n        InvariantOrder memory invariantAfter = InvariantOrder({\n            collateralNet: _getCollateralNet(vault),\n            stableCollateralPerShare: stableModule.stableCollateralPerShare()\n        });\n\n        _collateralNetBalanceRemainsUnchanged(invariantBefore.collateralNet, invariantAfter.collateralNet);\n        _stableCollateralPerShareIncreasesOrRemainsUnchanged(\n            stableModule.totalSupply(),\n            invariantBefore.stableCollateralPerShare,\n            invariantAfter.stableCollateralPerShare\n        );\n    }\n\n    /// @notice Invariant checks on order liquidation\n    /// @dev For liquidations, stableCollateralPerShare can decrease if the position is underwater.\n    modifier liquidationInvariantChecks(IFlatcoinVault vault, uint256 tokenId) {\n        IStableModule stableModule = IStableModule(vault.moduleAddress(FlatcoinModuleKeys._STABLE_MODULE_KEY));\n\n        InvariantLiquidation memory invariantBefore = InvariantLiquidation({ // helps with stack too deep\n            collateralNet: _getCollateralNet(vault),\n            stableCollateralPerShare: stableModule.stableCollateralPerShare(),\n            remainingMargin: ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY))\n                .getPositionSummary(tokenId)\n                .marginAfterSettlement,\n            liquidationFee: ILiquidationModule(vault.moduleAddress(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY))\n                .getLiquidationFee(tokenId)\n        });\n\n        _;\n\n        InvariantLiquidation memory invariantAfter = InvariantLiquidation({\n            collateralNet: _getCollateralNet(vault),\n            stableCollateralPerShare: stableModule.stableCollateralPerShare(),\n            remainingMargin: 0, // not used\n            liquidationFee: 0 // not used\n        });\n\n        _stableCollateralPerShareLiquidation(\n            stableModule,\n            invariantBefore.liquidationFee,\n            invariantBefore.remainingMargin,\n            invariantBefore.stableCollateralPerShare,\n            invariantAfter.stableCollateralPerShare\n        );\n\n        _collateralNetBalanceRemainsUnchanged(invariantBefore.collateralNet, invariantAfter.collateralNet);\n    }\n\n    /// @dev Returns the difference between actual total collateral balance in the vault vs tracked collateral\n    ///      Tracked collateral should be updated when depositing to stable LP (stableCollateralTotal) or\n    ///      opening leveraged positions (marginDepositedTotal).\n    /// TODO: Account for margin of error due to rounding.\n    function _getCollateralNet(IFlatcoinVault vault) private view returns (uint256 netCollateral) {\n        uint256 collateralBalance = vault.collateral().balanceOf(address(vault));\n        uint256 trackedCollateral = vault.stableCollateralTotal() + vault.getGlobalPositions().marginDepositedTotal;\n\n        if (collateralBalance < trackedCollateral) revert FlatcoinErrors.InvariantViolation(\"collateralNet\");\n\n        return collateralBalance - trackedCollateral;\n    }\n\n    /// @dev Collateral balance changes should match tracked collateral changes\n    function _collateralNetBalanceRemainsUnchanged(uint256 netBefore, uint256 netAfter) private pure {\n        if (netBefore != netAfter) revert FlatcoinErrors.InvariantViolation(\"collateralNet\");\n    }\n\n    /// @dev Stable LPs should never lose value (can only gain on trading fees)\n    function _stableCollateralPerShareIncreasesOrRemainsUnchanged(\n        uint256 totalSupply,\n        uint256 collateralPerShareBefore,\n        uint256 collateralPerShareAfter\n    ) private pure {\n        if (totalSupply > 0 && collateralPerShareAfter < collateralPerShareBefore)\n            revert FlatcoinErrors.InvariantViolation(\"stableCollateralPerShare\");\n    }\n\n    /// @dev Stable LPs should be adjusted according to the liquidated position remaining margin and liquidation fee\n    function _stableCollateralPerShareLiquidation(\n        IStableModule stableModule,\n        uint256 liquidationFee,\n        int256 remainingMargin,\n        uint256 stableCollateralPerShareBefore,\n        uint256 stableCollateralPerShareAfter\n    ) private view {\n        uint256 totalSupply = stableModule.totalSupply();\n\n        if (totalSupply == 0) return;\n\n        int256 expectedStableCollateralPerShare;\n        if (remainingMargin > 0) {\n            if (remainingMargin > int256(liquidationFee)) {\n                // position is healthy and there is a keeper fee taken from the margin\n                // evaluate exact increase in stable collateral\n                expectedStableCollateralPerShare =\n                    int256(stableCollateralPerShareBefore) +\n                    (((remainingMargin - int256(liquidationFee)) * 1e18) / int256(stableModule.totalSupply()));\n            } else {\n                // position has less or equal margin than liquidation fee\n                // all the margin will go to the keeper and no change in stable collateral\n                if (stableCollateralPerShareBefore != stableCollateralPerShareAfter)\n                    revert FlatcoinErrors.InvariantViolation(\"stableCollateralPerShareLiquidation\");\n\n                return;\n            }\n        } else {\n            // position is underwater and there is no keeper fee\n            // evaluate exact decrease in stable collateral\n            expectedStableCollateralPerShare =\n                int256(stableCollateralPerShareBefore) +\n                ((remainingMargin * 1e18) / int256(stableModule.totalSupply()));\n        }\n        if (\n            expectedStableCollateralPerShare + 1e6 < int256(stableCollateralPerShareAfter) || // rounding error\n            expectedStableCollateralPerShare - 1e6 > int256(stableCollateralPerShareAfter)\n        ) revert FlatcoinErrors.InvariantViolation(\"stableCollateralPerShareLiquidation\");\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/misc/InvariantChecks.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {FlatcoinErrors} from \"../libraries/FlatcoinErrors.sol\";\nimport {FlatcoinModuleKeys} from \"../libraries/FlatcoinModuleKeys.sol\";\nimport {IFlatcoinVault} from \"../interfaces/IFlatcoinVault.sol\";\nimport {IStableModule} from \"../interfaces/IStableModule.sol\";\nimport {ILeverageModule} from \"../interfaces/ILeverageModule.sol\";\nimport {ILiquidationModule} from \"../interfaces/ILiquidationModule.sol\";\n\n/// @title InvariantChecks\n/// @author dHEDGE\n/// @notice Contract module for critical invariant checking on the protocol.\nabstract contract InvariantChecks {\n    struct InvariantOrder {\n        uint256 collateralNet;\n        uint256 stableCollateralPerShare;\n    }\n\n    struct InvariantLiquidation {\n        uint256 collateralNet;\n        uint256 stableCollateralPerShare;\n        int256 remainingMargin;\n        uint256 liquidationFee;\n    }\n\n    /// @notice Invariant checks on order execution\n    /// @dev Checks:\n    ///      1. Collateral net: The vault collateral balance relative to tracked collateral on both stable LP and leverage side should not change\n    ///      2. Stable collateral per share: Stable LP value per share should never decrease after order execution. It should only increase due to collected trading fees\n    modifier orderInvariantChecks(IFlatcoinVault vault) {\n        IStableModule stableModule = IStableModule(vault.moduleAddress(FlatcoinModuleKeys._STABLE_MODULE_KEY));\n\n        InvariantOrder memory invariantBefore = InvariantOrder({ // helps with stack too deep\n            collateralNet: _getCollateralNet(vault),\n            stableCollateralPerShare: stableModule.stableCollateralPerShare()\n        });\n\n        _;\n\n        InvariantOrder memory invariantAfter = InvariantOrder({\n            collateralNet: _getCollateralNet(vault),\n            stableCollateralPerShare: stableModule.stableCollateralPerShare()\n        });\n\n        _collateralNetBalanceRemainsUnchanged(invariantBefore.collateralNet, invariantAfter.collateralNet);\n        _stableCollateralPerShareIncreasesOrRemainsUnchanged(\n            stableModule.totalSupply(),\n            invariantBefore.stableCollateralPerShare,\n            invariantAfter.stableCollateralPerShare\n        );\n    }\n\n    /// @notice Invariant checks on order liquidation\n    /// @dev For liquidations, stableCollateralPerShare can decrease if the position is underwater.\n    modifier liquidationInvariantChecks(IFlatcoinVault vault, uint256 tokenId) {\n        IStableModule stableModule = IStableModule(vault.moduleAddress(FlatcoinModuleKeys._STABLE_MODULE_KEY));\n\n        InvariantLiquidation memory invariantBefore = InvariantLiquidation({ // helps with stack too deep\n            collateralNet: _getCollateralNet(vault),\n            stableCollateralPerShare: stableModule.stableCollateralPerShare(),\n            remainingMargin: ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY))\n                .getPositionSummary(tokenId)\n                .marginAfterSettlement,\n            liquidationFee: ILiquidationModule(vault.moduleAddress(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY))\n                .getLiquidationFee(tokenId)\n        });\n\n        _;\n\n        InvariantLiquidation memory invariantAfter = InvariantLiquidation({\n            collateralNet: _getCollateralNet(vault),\n            stableCollateralPerShare: stableModule.stableCollateralPerShare(),\n            remainingMargin: 0, // not used\n            liquidationFee: 0 // not used\n        });\n\n        _stableCollateralPerShareLiquidation(\n            stableModule,\n            invariantBefore.liquidationFee,\n            invariantBefore.remainingMargin,\n            invariantBefore.stableCollateralPerShare,\n            invariantAfter.stableCollateralPerShare\n        );\n\n        _collateralNetBalanceRemainsUnchanged(invariantBefore.collateralNet, invariantAfter.collateralNet);\n    }\n\n    /// @dev Returns the difference between actual total collateral balance in the vault vs tracked collateral\n    ///      Tracked collateral should be updated when depositing to stable LP (stableCollateralTotal) or\n    ///      opening leveraged positions (marginDepositedTotal).\n    /// TODO: Account for margin of error due to rounding.\n    function _getCollateralNet(IFlatcoinVault vault) private view returns (uint256 netCollateral) {\n        uint256 collateralBalance = vault.collateral().balanceOf(address(vault));\n        uint256 trackedCollateral = vault.stableCollateralTotal() + vault.getGlobalPositions().marginDepositedTotal;\n\n        if (collateralBalance < trackedCollateral) revert FlatcoinErrors.InvariantViolation(\"collateralNet\");\n\n        return collateralBalance - trackedCollateral;\n    }\n\n    /// @dev Collateral balance changes should match tracked collateral changes\n    function _collateralNetBalanceRemainsUnchanged(uint256 netBefore, uint256 netAfter) private pure {\n        if (netBefore != netAfter) revert FlatcoinErrors.InvariantViolation(\"collateralNet\");\n    }\n\n    /// @dev Stable LPs should never lose value (can only gain on trading fees)\n    function _stableCollateralPerShareIncreasesOrRemainsUnchanged(\n        uint256 totalSupply,\n        uint256 collateralPerShareBefore,\n        uint256 collateralPerShareAfter\n    ) private pure {\n        if (totalSupply > 0 && collateralPerShareAfter < collateralPerShareBefore)\n            revert FlatcoinErrors.InvariantViolation(\"stableCollateralPerShare\");\n    }\n\n    /// @dev Stable LPs should be adjusted according to the liquidated position remaining margin and liquidation fee\n    function _stableCollateralPerShareLiquidation(\n        IStableModule stableModule,\n        uint256 liquidationFee,\n        int256 remainingMargin,\n        uint256 stableCollateralPerShareBefore,\n        uint256 stableCollateralPerShareAfter\n    ) private view {\n        uint256 totalSupply = stableModule.totalSupply();\n\n        if (totalSupply == 0) return;\n\n        int256 expectedStableCollateralPerShare;\n        if (remainingMargin > 0) {\n            if (remainingMargin > int256(liquidationFee)) {\n                // position is healthy and there is a keeper fee taken from the margin\n                // evaluate exact increase in stable collateral\n                expectedStableCollateralPerShare =\n                    int256(stableCollateralPerShareBefore) +\n                    (((remainingMargin - int256(liquidationFee)) * 1e18) / int256(stableModule.totalSupply()));\n            } else {\n                // position has less or equal margin than liquidation fee\n                // all the margin will go to the keeper and no change in stable collateral\n                if (stableCollateralPerShareBefore != stableCollateralPerShareAfter)\n                    revert FlatcoinErrors.InvariantViolation(\"stableCollateralPerShareLiquidation\");\n\n                return;\n            }\n        } else {\n            // position is underwater and there is no keeper fee\n            // evaluate exact decrease in stable collateral\n            expectedStableCollateralPerShare =\n                int256(stableCollateralPerShareBefore) +\n                ((remainingMargin * 1e18) / int256(stableModule.totalSupply()));\n        }\n        if (\n            expectedStableCollateralPerShare + 1e6 < int256(stableCollateralPerShareAfter) || // rounding error\n            expectedStableCollateralPerShare - 1e6 > int256(stableCollateralPerShareAfter)\n        ) revert FlatcoinErrors.InvariantViolation(\"stableCollateralPerShareLiquidation\");\n    }\n}"
    }
  ]
}