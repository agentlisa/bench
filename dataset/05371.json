{
  "Title": "[M-11] Since art pieces' size is not limited, attacker may block AuctionHouse from creating and settling auctions",
  "Content": "\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/AuctionHouse.sol#L370-L371> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/AuctionHouse.sol#L385> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/CultureIndex.sol#L209-L238> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/AuctionHouse.sol#L313> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/VerbsToken.sol#L178> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/VerbsToken.sol#L282> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/VerbsToken.sol#L296-L308>\n\n**Note:** *there is another bug (calling `verbs.getArtPieceById` in a loop in `_settleAuction`), but this issue focuses on a different attack vector for creating DoS attack, so in this submission, I assume that the bug is fixed (that is, `verbs.getArtPieceById` is not called in a loop, but cached before it).*\n\n### Brief Description\n\nThis submission shows two implications of the same bug - not limiting length of pieces of art in `CultureIndex::createPiece`:\n\n*   `_settleAuction` may be caused to consume a lot of gas, or even to fail because block gas limit will be reached\n*   `_createAuction` may be caused to revert for some amount of time, blocking the entire `AuctionHouse`\n\n### Detailed description\n\n`CultureIndex::createPiece` allows any user to create art pieces. The only validation regarding art piece size performed there is the validation in `validateMediaType` which only ensures that relevant field in art piece is non-zero.\n\nIf an art piece wins voting, its data is then fetched several times (`3` - see  note at the beginning of this submission) when `verbs.getArtPieceById` is called.\n\nIf malicious creator creates some nice art piece (for instance of type `IMAGE`) and hides a very long string in another, irrelevant field (such as `ArtPieceMetadata.text`) and his piece wins the voting, **it will cost a lot of gas to fetch its data both in `_settleAuction` and `_createAuction`**.\n\nThe following implications may occur:\n\n1.  It may either cause a user who calls `_settleAuction` to pay a lot for gas, or possibly even DoS the entire `AuctionHouse`.\n2.  `_createAuction` may be DoSed, and, as a result, the entire `AuctionHouse` may be DoSed, at least until another piece of art wins voting.\n\n### Impact\n\n1.  Users may pay very high fees for gas (see the exact gas amounts in the PoC section). In the worst case `AuctionHouse` will be DoSed as `_settleAuction` will attempt to consume more than the block gas limit (`30 000 000`). According to the calculations I have made (see PoC), it's currently possible to cause `_settleAuction` to use up to `~22 000 000` gas, which is currently less than the block gas limit of `30 000 000`. However, operations costs were changing in the past - for example the cost of `sload` (that is used when art piece's data is fetched) increased from `50` to `2100` (or `100` in case of warm access) from the frontier hardfork (see [frontier](https://ethereum.github.io/execution-specs/autoapi/ethereum/frontier/vm/gas/index.html?gas-sload#gas-sload) and [shanghai](https://ethereum.github.io/execution-specs/autoapi/ethereum/shanghai/vm/gas/index.html?gas-cold-sload#gas-cold-sload)), so it is possible that after another hardfork, it will be possible to DoS `AuctionHouse` using this exploit. Moreover, it is possible that block gas limit will decrease, which will cause the same effect.\n2.  `_createAuction` will reach block gas limit, which will make creating new auctions impossible, until another art piece wins voting (but the \"malicious\" art piece will still participate in subsequent votings).\n\nBoth exploits require a malicious artwork to win the voting, however, as I have mentioned before, the attacker can hide a very long string in an unrelated field of `ArtPieceMetadata` structure, so that users may not even notice this and will only pay attention for the image contained in that artwork.\n\nAlternatively, attacker can buy some `NontransferableERC20Votes` at the beginning and win the voting by himself, before quorum becomes too big.\n\nThe impact is severe, but the attack is also costly for the attacker, and under normal circumstances, I would submit the issue as Medium. However, the exploit presented in this submission breaks two invariants that, according to the Sponsor \" should NEVER EVER be broken\":\n\n*   Anything uploaded to the CultureIndex should always be mintable by the VerbsToken contract and not disrupt the VerbsToken contract in any way.\n*   CultureIndex and MaxHeap, must be resilient to DoS attacks that could significantly hinder voting, art creation, or auction processes.\n\n### Proof of Concept\n\nThe test I'm showing will simulate a scenario when a malicious user creates a piece of art containing very long data, that piece wins voting and is then sold.\n\n**I assume that the attacker doesn't perform any additional exploits and the bug that I mentioned at the very beginning of this submission is fixed. Moreover, I assume that the attacker specifies only one creator account (if he specified more, he could cause DoS with a less cost - as I have shown in another submission, just by specifying malicious creators he can cause `_settleAuction` to consume additional `~20 000 000` of gas) as I wanted to measure only the impact of a \"heavy\" NFT on the gas cost**.\n\nThe exploit requires a very long string to be passed - for the exploit to be the most destructive, the string would have to be `~1.3MB` long (this will achieve `30 000 000` for the attacker and `~22 000 000` for `_settleAuction`. The string was not explicitly put in the PoC in order to keep this submission smaller - in order to test it, please add a very long string of `\\x00`'s in the place tagged with `<- put here a very long string [...]`. It is necessary for the string to only contain `\\x00`'s since it will significantly reduce cost for the attacker (as `sreset`, that cost `2900` gas will be used instead of `sset`, which costs `20 000`).\n\nThe test will output `3` important values:\n\n*   cost for the attacker\n*   cost of performing `_createAuction`\n*   cost of performing `_settleAuction`\n\nPlease put the following test into `AuctionSettling.t.sol` and run it. Please remember to add a very long string of `\\x00`'s in the relevant place:\n\n<details>\n\n```solidity\n// create an auction and finish it\n    function _createAndFinishAuction() internal returns(uint)\n    {\n        uint nCreators = 1;\n        address[] memory creatorAddresses = new address[](nCreators);\n        uint256[] memory creatorBps = new uint256[](nCreators);\n        uint256 totalBps = 0;\n        address[] memory creators = new address[](nCreators + 1);\n        for (uint i = 0; i < nCreators + 1; i++)\n        {\n            creators[i] = address(uint160(0x1234 + i));\n        }\n\n        for (uint256 i = 0; i < nCreators; i++) {\n            creatorAddresses[i] = address(creators[i]);\n            if (i == nCreators - 1) {\n                creatorBps[i] = 10_000 - totalBps;\n            } else {\n                creatorBps[i] = (10_000) / (nCreators - 1);\n            }\n            totalBps += creatorBps[i];\n        }\n\n        uint gas1 = gasleft();\n        uint256 verbId = createArtPieceMultiCreator(\n            \"Multi Creator Art\",\n            \"An art piece with multiple creators\", \n            ICultureIndex.MediaType.IMAGE,\n            \"ipfs://multi-creator-art\",\n            \"\",\n            \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", // <- put here a very long string (~1.3 MB for _settleAuction to reach 22 000 000 of gas, and ~900 KB for _createAuction to reach block gas limit)\n            creatorAddresses,\n            creatorBps\n        );\n        uint gas2 = gasleft();\n\n        vm.startPrank(auction.owner());\n        uint gas3 = gasleft();\n        auction.unpause();\n        uint gas4 = gasleft();\n        console.log(\"gas used for creating auction:\", gas3 - gas4);\n        vm.stopPrank();\n\n        uint256 bidAmount = auction.reservePrice();\n        vm.deal(address(creators[nCreators]), bidAmount + 1 ether);\n        vm.startPrank(address(creators[nCreators]));\n        auction.createBid{ value: bidAmount }(verbId, address(creators[nCreators]));\n        vm.stopPrank();\n\n        vm.warp(block.timestamp + auction.duration() + 1); // Fast forward time to end the auction\n        \n        // return amount of gas spent by the attacker on creating a piece of art\n        return gas1 - gas2;\n    }\n\n    function testDOS2() public\n    {\n        uint gasConsumption1;\n        uint gasConsumption2;\n        uint gas0;\n        uint gas1;\n\n        vm.startPrank(cultureIndex.owner());\n        cultureIndex._setQuorumVotesBPS(0);\n        vm.stopPrank();\n\n        gasConsumption1 = _createAndFinishAuction();\n\n        gas0 = gasleft();\n        auction.settleCurrentAndCreateNewAuction();\n        gas1 = gasleft();\n\n        gasConsumption2 = gas0 - gas1;\n        console.log(\"gas used by the attacker: \", gasConsumption1);\n        console.log(\"gas used in settleCurrentAndCreateNewAuction:\",gasConsumption2);\n    }\n```\n</details>\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nLimit the length of all fields in `ArtPieceMetadata`.\n\n**[0xTheC0der (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/178#issuecomment-1879685361):**\n > See comment on primary issue: https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/195#issuecomment-1879684718\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/revolution/src/AuctionHouse.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The Verbs DAO auction house\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// AuctionHouse.sol is a modified version of Zora's AuctionHouse.sol:\n// https://github.com/ourzora/auction-house/blob/54a12ec1a6cf562e49f0a4917990474b11350a2d/contracts/AuctionHouse.sol\n//\n// AuctionHouse.sol source code Copyright Zora licensed under the GPL-3.0 license.\n\npragma solidity ^0.8.22;\n\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IAuctionHouse } from \"./interfaces/IAuctionHouse.sol\";\nimport { IVerbsToken } from \"./interfaces/IVerbsToken.sol\";\nimport { IWETH } from \"./interfaces/IWETH.sol\";\nimport { IERC20TokenEmitter } from \"./interfaces/IERC20TokenEmitter.sol\";\nimport { ICultureIndex } from \"./interfaces/ICultureIndex.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\ncontract AuctionHouse is\n    IAuctionHouse,\n    VersionedContract,\n    UUPS,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    Ownable2StepUpgradeable\n{\n    // The Verbs ERC721 token contract\n    IVerbsToken public verbs;\n\n    // The ERC20 governance token\n    IERC20TokenEmitter public erc20TokenEmitter;\n\n    // The address of the WETH contract\n    address public WETH;\n\n    // The minimum amount of time left in an auction after a new bid is created\n    uint256 public timeBuffer;\n\n    // The minimum price accepted in an auction\n    uint256 public reservePrice;\n\n    // The minimum percentage difference between the last bid amount and the current bid\n    uint8 public minBidIncrementPercentage;\n\n    // The split of the winning bid that is reserved for the creator of the Verb in basis points\n    uint256 public creatorRateBps;\n\n    // The all time minimum split of the winning bid that is reserved for the creator of the Verb in basis points\n    uint256 public minCreatorRateBps;\n\n    // The split of (auction proceeds * creatorRate) that is sent to the creator as ether in basis points\n    uint256 public entropyRateBps;\n\n    // The duration of a single auction\n    uint256 public duration;\n\n    // The active auction\n    IAuctionHouse.Auction public auction;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder public immutable manager;\n\n    // TODO investigate this - The minimum gas threshold for creating an auction (minting VerbsToken)\n    uint32 public constant MIN_TOKEN_MINT_GAS_THRESHOLD = 750_000;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initialize the auction house and base contracts,\n     * populate configuration values, and pause the contract.\n     * @dev This function can only be called once.\n     * @param _erc721Token The address of the Verbs ERC721 token contract.\n     * @param _erc20TokenEmitter The address of the ERC-20 token emitter contract.\n     * @param _initialOwner The address of the owner.\n     * @param _weth The address of the WETH contract\n     * @param _auctionParams The auction params for auctions.\n     */\n    function initialize(\n        address _erc721Token,\n        address _erc20TokenEmitter,\n        address _initialOwner,\n        address _weth,\n        IRevolutionBuilder.AuctionParams calldata _auctionParams\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n        require(_weth != address(0), \"WETH cannot be zero address\");\n\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init(_initialOwner);\n\n        _pause();\n\n        require(\n            _auctionParams.creatorRateBps >= _auctionParams.minCreatorRateBps,\n            \"Creator rate must be greater than or equal to the creator rate\"\n        );\n\n        verbs = IVerbsToken(_erc721Token);\n        erc20TokenEmitter = IERC20TokenEmitter(_erc20TokenEmitter);\n        timeBuffer = _auctionParams.timeBuffer;\n        reservePrice = _auctionParams.reservePrice;\n        minBidIncrementPercentage = _auctionParams.minBidIncrementPercentage;\n        duration = _auctionParams.duration;\n        creatorRateBps = _auctionParams.creatorRateBps;\n        entropyRateBps = _auctionParams.entropyRateBps;\n        minCreatorRateBps = _auctionParams.minCreatorRateBps;\n        WETH = _weth;\n    }\n\n    /**\n     * @notice Settle the current auction, mint a new Verb, and put it up for auction.\n     */\n    // Can technically reenter via cross function reentrancies in _createAuction, auction, and pause, but those are only callable by the owner.\n    // @wardens if you can find an exploit here go for it - we might be wrong.\n    // slither-disable-next-line reentrancy-eth\n    function settleCurrentAndCreateNewAuction() external override nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /**\n     * @notice Settle the current auction.\n     * @dev This function can only be called when the contract is paused.\n     */\n    function settleAuction() external override whenPaused nonReentrant {\n        _settleAuction();\n    }\n\n    /**\n     * @notice Create a bid for a Verb, with a given amount.\n     * @dev This contract only accepts payment in ETH.\n     * @param verbId The ID of the Verb to bid on.\n     * @param bidder The address of the bidder.\n     */\n    function createBid(uint256 verbId, address bidder) external payable override nonReentrant {\n        IAuctionHouse.Auction memory _auction = auction;\n\n        //require bidder is valid address\n        require(bidder != address(0), \"Bidder cannot be zero address\");\n        require(_auction.verbId == verbId, \"Verb not up for auction\");\n        //slither-disable-next-line timestamp\n        require(block.timestamp < _auction.endTime, \"Auction expired\");\n        require(msg.value >= reservePrice, \"Must send at least reservePrice\");\n        require(\n            msg.value >= _auction.amount + ((_auction.amount * minBidIncrementPercentage) / 100),\n            \"Must send more than last bid by minBidIncrementPercentage amount\"\n        );\n\n        address payable lastBidder = _auction.bidder;\n\n        auction.amount = msg.value;\n        auction.bidder = payable(bidder);\n\n        // Extend the auction if the bid was received within `timeBuffer` of the auction end time\n        bool extended = _auction.endTime - block.timestamp < timeBuffer;\n        if (extended) auction.endTime = _auction.endTime = block.timestamp + timeBuffer;\n\n        // Refund the last bidder, if applicable\n        if (lastBidder != address(0)) _safeTransferETHWithFallback(lastBidder, _auction.amount);\n\n        emit AuctionBid(_auction.verbId, bidder, msg.sender, msg.value, extended);\n\n        if (extended) emit AuctionExtended(_auction.verbId, _auction.endTime);\n    }\n\n    /**\n     * @notice Pause the Verbs auction house.\n     * @dev This function can only be called by the owner when the\n     * contract is unpaused. While no new auctions can be started when paused,\n     * anyone can settle an ongoing auction.\n     */\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Set the split of the winning bid that is reserved for the creator of the Verb in basis points.\n     * @dev Only callable by the owner.\n     * @param _creatorRateBps New creator rate in basis points.\n     */\n    function setCreatorRateBps(uint256 _creatorRateBps) external onlyOwner {\n        require(\n            _creatorRateBps >= minCreatorRateBps,\n            \"Creator rate must be greater than or equal to minCreatorRateBps\"\n        );\n        require(_creatorRateBps <= 10_000, \"Creator rate must be less than or equal to 10_000\");\n        creatorRateBps = _creatorRateBps;\n\n        emit CreatorRateBpsUpdated(_creatorRateBps);\n    }\n\n    /**\n     * @notice Set the minimum split of the winning bid that is reserved for the creator of the Verb in basis points.\n     * @dev Only callable by the owner.\n     * @param _minCreatorRateBps New minimum creator rate in basis points.\n     */\n    function setMinCreatorRateBps(uint256 _minCreatorRateBps) external onlyOwner {\n        require(_minCreatorRateBps <= creatorRateBps, \"Min creator rate must be less than or equal to creator rate\");\n        require(_minCreatorRateBps <= 10_000, \"Min creator rate must be less than or equal to 10_000\");\n\n        //ensure new min rate cannot be lower than previous min rate\n        require(\n            _minCreatorRateBps > minCreatorRateBps,\n            \"Min creator rate must be greater than previous minCreatorRateBps\"\n        );\n\n        minCreatorRateBps = _minCreatorRateBps;\n\n        emit MinCreatorRateBpsUpdated(_minCreatorRateBps);\n    }\n\n    /**\n     * @notice Set the split of (auction proceeds * creatorRate) that is sent to the creator as ether in basis points.\n     * @dev Only callable by the owner.\n     * @param _entropyRateBps New entropy rate in basis points.\n     */\n    function setEntropyRateBps(uint256 _entropyRateBps) external onlyOwner {\n        require(_entropyRateBps <= 10_000, \"Entropy rate must be less than or equal to 10_000\");\n\n        entropyRateBps = _entropyRateBps;\n        emit EntropyRateBpsUpdated(_entropyRateBps);\n    }\n\n    /**\n     * @notice Unpause the Verbs auction house.\n     * @dev This function can only be called by the owner when the\n     * contract is paused. If required, this function will start a new auction.\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n\n        if (auction.startTime == 0 || auction.settled) {\n            _createAuction();\n        }\n    }\n\n    /**\n     * @notice Set the auction time buffer.\n     * @dev Only callable by the owner.\n     */\n    function setTimeBuffer(uint256 _timeBuffer) external override onlyOwner {\n        timeBuffer = _timeBuffer;\n\n        emit AuctionTimeBufferUpdated(_timeBuffer);\n    }\n\n    /**\n     * @notice Set the auction reserve price.\n     * @dev Only callable by the owner.\n     */\n    function setReservePrice(uint256 _reservePrice) external override onlyOwner {\n        reservePrice = _reservePrice;\n\n        emit AuctionReservePriceUpdated(_reservePrice);\n    }\n\n    /**\n     * @notice Set the auction minimum bid increment percentage.\n     * @dev Only callable by the owner.\n     */\n    function setMinBidIncrementPercentage(uint8 _minBidIncrementPercentage) external override onlyOwner {\n        minBidIncrementPercentage = _minBidIncrementPercentage;\n\n        emit AuctionMinBidIncrementPercentageUpdated(_minBidIncrementPercentage);\n    }\n\n    /**\n     * @notice Create an auction.\n     * @dev Store the auction details in the `auction` state variable and emit an AuctionCreated event.\n     * If the mint reverts, the minter was updated without pausing this contract first. To remedy this,\n     * catch the revert and pause this contract.\n     */\n    function _createAuction() internal {\n        // Check if there's enough gas to safely execute token.mint() and subsequent operations\n        require(gasleft() >= MIN_TOKEN_MINT_GAS_THRESHOLD, \"Insufficient gas for creating auction\");\n\n        try verbs.mint() returns (uint256 verbId) {\n            uint256 startTime = block.timestamp;\n            uint256 endTime = startTime + duration;\n\n            auction = Auction({\n                verbId: verbId,\n                amount: 0,\n                startTime: startTime,\n                endTime: endTime,\n                bidder: payable(0),\n                settled: false\n            });\n\n            emit AuctionCreated(verbId, startTime, endTime);\n        } catch {\n            _pause();\n        }\n    }\n\n    /**\n     * @notice Settle an auction, finalizing the bid and paying out to the owner. Pays out to the creator and the owner based on the creatorRateBps and entropyRateBps.\n     * @dev If there are no bids, the Verb is burned.\n     */\n    function _settleAuction() internal {\n        IAuctionHouse.Auction memory _auction = auction;\n\n        require(_auction.startTime != 0, \"Auction hasn't begun\");\n        require(!_auction.settled, \"Auction has already been settled\");\n        //slither-disable-next-line timestamp\n        require(block.timestamp >= _auction.endTime, \"Auction hasn't completed\");\n\n        auction.settled = true;\n\n        uint256 creatorTokensEmitted = 0;\n        // Check if contract balance is greater than reserve price\n        if (address(this).balance < reservePrice) {\n            // If contract balance is less than reserve price, refund to the last bidder\n            if (_auction.bidder != address(0)) {\n                _safeTransferETHWithFallback(_auction.bidder, _auction.amount);\n            }\n\n            // And then burn the Noun\n            verbs.burn(_auction.verbId);\n        } else {\n            //If no one has bid, burn the Verb\n            if (_auction.bidder == address(0))\n                verbs.burn(_auction.verbId);\n                //If someone has bid, transfer the Verb to the winning bidder\n            else verbs.transferFrom(address(this), _auction.bidder, _auction.verbId);\n\n            if (_auction.amount > 0) {\n                // Ether going to owner of the auction\n                uint256 auctioneerPayment = (_auction.amount * (10_000 - creatorRateBps)) / 10_000;\n\n                //Total amount of ether going to creator\n                uint256 creatorsShare = _auction.amount - auctioneerPayment;\n\n                uint256 numCreators = verbs.getArtPieceById(_auction.verbId).creators.length;\n                address deployer = verbs.getArtPieceById(_auction.verbId).sponsor;\n\n                //Build arrays for erc20TokenEmitter.buyToken\n                uint256[] memory vrgdaSplits = new uint256[](numCreators);\n                address[] memory vrgdaReceivers = new address[](numCreators);\n\n                //Transfer auction amount to the DAO treasury\n                _safeTransferETHWithFallback(owner(), auctioneerPayment);\n\n                uint256 ethPaidToCreators = 0;\n\n                //Transfer creator's share to the creator, for each creator, and build arrays for erc20TokenEmitter.buyToken\n                if (creatorsShare > 0 && entropyRateBps > 0) {\n                    for (uint256 i = 0; i < numCreators; i++) {\n                        ICultureIndex.CreatorBps memory creator = verbs.getArtPieceById(_auction.verbId).creators[i];\n                        vrgdaReceivers[i] = creator.creator;\n                        vrgdaSplits[i] = creator.bps;\n\n                        //Calculate paymentAmount for specific creator based on BPS splits - same as multiplying by creatorDirectPayment\n                        uint256 paymentAmount = (creatorsShare * entropyRateBps * creator.bps) / (10_000 * 10_000);\n                        ethPaidToCreators += paymentAmount;\n\n                        //Transfer creator's share to the creator\n                        _safeTransferETHWithFallback(creator.creator, paymentAmount);\n                    }\n                }\n\n                //Buy token from ERC20TokenEmitter for all the creators\n                if (creatorsShare > ethPaidToCreators) {\n                    creatorTokensEmitted = erc20TokenEmitter.buyToken{ value: creatorsShare - ethPaidToCreators }(\n                        vrgdaReceivers,\n                        vrgdaSplits,\n                        IERC20TokenEmitter.ProtocolRewardAddresses({\n                            builder: address(0),\n                            purchaseReferral: address(0),\n                            deployer: deployer\n                        })\n                    );\n                }\n            }\n        }\n\n        emit AuctionSettled(_auction.verbId, _auction.bidder, _auction.amount, creatorTokensEmitted);\n    }\n\n    /// @notice Transfer ETH/WETH from the contract\n    /// @param _to The recipient address\n    /// @param _amount The amount transferring\n    function _safeTransferETHWithFallback(address _to, uint256 _amount) private {\n        // Ensure the contract has enough ETH to transfer\n        if (address(this).balance < _amount) revert(\"Insufficient balance\");\n\n        // Used to store if the transfer succeeded\n        bool success;\n\n        assembly {\n            // Transfer ETH to the recipient\n            // Limit the call to 50,000 gas\n            success := call(50000, _to, _amount, 0, 0, 0, 0)\n        }\n\n        // If the transfer failed:\n        if (!success) {\n            // Wrap as WETH\n            IWETH(WETH).deposit{ value: _amount }();\n\n            // Transfer WETH instead\n            bool wethSuccess = IWETH(WETH).transfer(_to, _amount);\n\n            // Ensure successful transfer\n            if (!wethSuccess) revert(\"WETH transfer failed\");\n        }\n    }\n\n    ///                                                          ///\n    ///                        AUCTION UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner whenPaused {\n        // Ensure the new implementation is registered by the Builder DAO\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/AuctionHouse.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The Verbs DAO auction house\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// AuctionHouse.sol is a modified version of Zora's AuctionHouse.sol:\n// https://github.com/ourzora/auction-house/blob/54a12ec1a6cf562e49f0a4917990474b11350a2d/contracts/AuctionHouse.sol\n//\n// AuctionHouse.sol source code Copyright Zora licensed under the GPL-3.0 license.\n\npragma solidity ^0.8.22;\n\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IAuctionHouse } from \"./interfaces/IAuctionHouse.sol\";\nimport { IVerbsToken } from \"./interfaces/IVerbsToken.sol\";\nimport { IWETH } from \"./interfaces/IWETH.sol\";\nimport { IERC20TokenEmitter } from \"./interfaces/IERC20TokenEmitter.sol\";\nimport { ICultureIndex } from \"./interfaces/ICultureIndex.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\ncontract AuctionHouse is\n    IAuctionHouse,\n    VersionedContract,\n    UUPS,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    Ownable2StepUpgradeable\n{\n    // The Verbs ERC721 token contract\n    IVerbsToken public verbs;\n\n    // The ERC20 governance token\n    IERC20TokenEmitter public erc20TokenEmitter;\n\n    // The address of the WETH contract\n    address public WETH;\n\n    // The minimum amount of time left in an auction after a new bid is created\n    uint256 public timeBuffer;\n\n    // The minimum price accepted in an auction\n    uint256 public reservePrice;\n\n    // The minimum percentage difference between the last bid amount and the current bid\n    uint8 public minBidIncrementPercentage;\n\n    // The split of the winning bid that is reserved for the creator of the Verb in basis points\n    uint256 public creatorRateBps;\n\n    // The all time minimum split of the winning bid that is reserved for the creator of the Verb in basis points\n    uint256 public minCreatorRateBps;\n\n    // The split of (auction proceeds * creatorRate) that is sent to the creator as ether in basis points\n    uint256 public entropyRateBps;\n\n    // The duration of a single auction\n    uint256 public duration;\n\n    // The active auction\n    IAuctionHouse.Auction public auction;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder public immutable manager;\n\n    // TODO investigate this - The minimum gas threshold for creating an auction (minting VerbsToken)\n    uint32 public constant MIN_TOKEN_MINT_GAS_THRESHOLD = 750_000;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initialize the auction house and base contracts,\n     * populate configuration values, and pause the contract.\n     * @dev This function can only be called once.\n     * @param _erc721Token The address of the Verbs ERC721 token contract.\n     * @param _erc20TokenEmitter The address of the ERC-20 token emitter contract.\n     * @param _initialOwner The address of the owner.\n     * @param _weth The address of the WETH contract\n     * @param _auctionParams The auction params for auctions.\n     */\n    function initialize(\n        address _erc721Token,\n        address _erc20TokenEmitter,\n        address _initialOwner,\n        address _weth,\n        IRevolutionBuilder.AuctionParams calldata _auctionParams\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n        require(_weth != address(0), \"WETH cannot be zero address\");\n\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init(_initialOwner);\n\n        _pause();\n\n        require(\n            _auctionParams.creatorRateBps >= _auctionParams.minCreatorRateBps,\n            \"Creator rate must be greater than or equal to the creator rate\"\n        );\n\n        verbs = IVerbsToken(_erc721Token);\n        erc20TokenEmitter = IERC20TokenEmitter(_erc20TokenEmitter);\n        timeBuffer = _auctionParams.timeBuffer;\n        reservePrice = _auctionParams.reservePrice;\n        minBidIncrementPercentage = _auctionParams.minBidIncrementPercentage;\n        duration = _auctionParams.duration;\n        creatorRateBps = _auctionParams.creatorRateBps;\n        entropyRateBps = _auctionParams.entropyRateBps;\n        minCreatorRateBps = _auctionParams.minCreatorRateBps;\n        WETH = _weth;\n    }\n\n    /**\n     * @notice Settle the current auction, mint a new Verb, and put it up for auction.\n     */\n    // Can technically reenter via cross function reentrancies in _createAuction, auction, and pause, but those are only callable by the owner.\n    // @wardens if you can find an exploit here go for it - we might be wrong.\n    // slither-disable-next-line reentrancy-eth\n    function settleCurrentAndCreateNewAuction() external override nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /**\n     * @notice Settle the current auction.\n     * @dev This function can only be called when the contract is paused.\n     */\n    function settleAuction() external override whenPaused nonReentrant {\n        _settleAuction();\n    }\n\n    /**\n     * @notice Create a bid for a Verb, with a given amount.\n     * @dev This contract only accepts payment in ETH.\n     * @param verbId The ID of the Verb to bid on.\n     * @param bidder The address of the bidder.\n     */\n    function createBid(uint256 verbId, address bidder) external payable override nonReentrant {\n        IAuctionHouse.Auction memory _auction = auction;\n\n        //require bidder is valid address\n        require(bidder != address(0), \"Bidder cannot be zero address\");\n        require(_auction.verbId == verbId, \"Verb not up for auction\");\n        //slither-disable-next-line timestamp\n        require(block.timestamp < _auction.endTime, \"Auction expired\");\n        require(msg.value >= reservePrice, \"Must send at least reservePrice\");\n        require(\n            msg.value >= _auction.amount + ((_auction.amount * minBidIncrementPercentage) / 100),\n            \"Must send more than last bid by minBidIncrementPercentage amount\"\n        );\n\n        address payable lastBidder = _auction.bidder;\n\n        auction.amount = msg.value;\n        auction.bidder = payable(bidder);\n\n        // Extend the auction if the bid was received within `timeBuffer` of the auction end time\n        bool extended = _auction.endTime - block.timestamp < timeBuffer;\n        if (extended) auction.endTime = _auction.endTime = block.timestamp + timeBuffer;\n\n        // Refund the last bidder, if applicable\n        if (lastBidder != address(0)) _safeTransferETHWithFallback(lastBidder, _auction.amount);\n\n        emit AuctionBid(_auction.verbId, bidder, msg.sender, msg.value, extended);\n\n        if (extended) emit AuctionExtended(_auction.verbId, _auction.endTime);\n    }\n\n    /**\n     * @notice Pause the Verbs auction house.\n     * @dev This function can only be called by the owner when the\n     * contract is unpaused. While no new auctions can be started when paused,\n     * anyone can settle an ongoing auction.\n     */\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Set the split of the winning bid that is reserved for the creator of the Verb in basis points.\n     * @dev Only callable by the owner.\n     * @param _creatorRateBps New creator rate in basis points.\n     */\n    function setCreatorRateBps(uint256 _creatorRateBps) external onlyOwner {\n        require(\n            _creatorRateBps >= minCreatorRateBps,\n            \"Creator rate must be greater than or equal to minCreatorRateBps\"\n        );\n        require(_creatorRateBps <= 10_000, \"Creator rate must be less than or equal to 10_000\");\n        creatorRateBps = _creatorRateBps;\n\n        emit CreatorRateBpsUpdated(_creatorRateBps);\n    }\n\n    /**\n     * @notice Set the minimum split of the winning bid that is reserved for the creator of the Verb in basis points.\n     * @dev Only callable by the owner.\n     * @param _minCreatorRateBps New minimum creator rate in basis points.\n     */\n    function setMinCreatorRateBps(uint256 _minCreatorRateBps) external onlyOwner {\n        require(_minCreatorRateBps <= creatorRateBps, \"Min creator rate must be less than or equal to creator rate\");\n        require(_minCreatorRateBps <= 10_000, \"Min creator rate must be less than or equal to 10_000\");\n\n        //ensure new min rate cannot be lower than previous min rate\n        require(\n            _minCreatorRateBps > minCreatorRateBps,\n            \"Min creator rate must be greater than previous minCreatorRateBps\"\n        );\n\n        minCreatorRateBps = _minCreatorRateBps;\n\n        emit MinCreatorRateBpsUpdated(_minCreatorRateBps);\n    }\n\n    /**\n     * @notice Set the split of (auction proceeds * creatorRate) that is sent to the creator as ether in basis points.\n     * @dev Only callable by the owner.\n     * @param _entropyRateBps New entropy rate in basis points.\n     */\n    function setEntropyRateBps(uint256 _entropyRateBps) external onlyOwner {\n        require(_entropyRateBps <= 10_000, \"Entropy rate must be less than or equal to 10_000\");\n\n        entropyRateBps = _entropyRateBps;\n        emit EntropyRateBpsUpdated(_entropyRateBps);\n    }\n\n    /**\n     * @notice Unpause the Verbs auction house.\n     * @dev This function can only be called by the owner when the\n     * contract is paused. If required, this function will start a new auction.\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n\n        if (auction.startTime == 0 || auction.settled) {\n            _createAuction();\n        }\n    }\n\n    /**\n     * @notice Set the auction time buffer.\n     * @dev Only callable by the owner.\n     */\n    function setTimeBuffer(uint256 _timeBuffer) external override onlyOwner {\n        timeBuffer = _timeBuffer;\n\n        emit AuctionTimeBufferUpdated(_timeBuffer);\n    }\n\n    /**\n     * @notice Set the auction reserve price.\n     * @dev Only callable by the owner.\n     */\n    function setReservePrice(uint256 _reservePrice) external override onlyOwner {\n        reservePrice = _reservePrice;\n\n        emit AuctionReservePriceUpdated(_reservePrice);\n    }\n\n    /**\n     * @notice Set the auction minimum bid increment percentage.\n     * @dev Only callable by the owner.\n     */\n    function setMinBidIncrementPercentage(uint8 _minBidIncrementPercentage) external override onlyOwner {\n        minBidIncrementPercentage = _minBidIncrementPercentage;\n\n        emit AuctionMinBidIncrementPercentageUpdated(_minBidIncrementPercentage);\n    }\n\n    /**\n     * @notice Create an auction.\n     * @dev Store the auction details in the `auction` state variable and emit an AuctionCreated event.\n     * If the mint reverts, the minter was updated without pausing this contract first. To remedy this,\n     * catch the revert and pause this contract.\n     */\n    function _createAuction() internal {\n        // Check if there's enough gas to safely execute token.mint() and subsequent operations\n        require(gasleft() >= MIN_TOKEN_MINT_GAS_THRESHOLD, \"Insufficient gas for creating auction\");\n\n        try verbs.mint() returns (uint256 verbId) {\n            uint256 startTime = block.timestamp;\n            uint256 endTime = startTime + duration;\n\n            auction = Auction({\n                verbId: verbId,\n                amount: 0,\n                startTime: startTime,\n                endTime: endTime,\n                bidder: payable(0),\n                settled: false\n            });\n\n            emit AuctionCreated(verbId, startTime, endTime);\n        } catch {\n            _pause();\n        }\n    }\n\n    /**\n     * @notice Settle an auction, finalizing the bid and paying out to the owner. Pays out to the creator and the owner based on the creatorRateBps and entropyRateBps.\n     * @dev If there are no bids, the Verb is burned.\n     */\n    function _settleAuction() internal {\n        IAuctionHouse.Auction memory _auction = auction;\n\n        require(_auction.startTime != 0, \"Auction hasn't begun\");\n        require(!_auction.settled, \"Auction has already been settled\");\n        //slither-disable-next-line timestamp\n        require(block.timestamp >= _auction.endTime, \"Auction hasn't completed\");\n\n        auction.settled = true;\n\n        uint256 creatorTokensEmitted = 0;\n        // Check if contract balance is greater than reserve price\n        if (address(this).balance < reservePrice) {\n            // If contract balance is less than reserve price, refund to the last bidder"
    }
  ]
}