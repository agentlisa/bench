{
  "Title": "`Ownable` can be upgraded to `Ownable2Step`",
  "Content": "##### Description\n`BAMM` uses `Ownable`'s functionality:\nhttps://github.com/Threshold-USD/dev/blob/800c6c19e44628dfda3cecaea6eedcb498bf0bf3/packages/contracts/contracts/B.Protocol/BAMM.sol#L17.\nThe `Ownable` contract can be upgraded to OpenZeppelin's `Ownable2Step`:\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol.\n`Ownable2Step` provides added safety due to its securely designed two-step process.\n##### Recommendation\nWe recommend using `Ownable2Step`.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/contracts/contracts/B.Protocol/BAMM.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport \"./../StabilityPool.sol\";\nimport \"./CropJoinAdapter.sol\";\nimport \"./PriceFormula.sol\";\nimport \"./../Interfaces/IPriceFeed.sol\";\nimport \"./../Dependencies/IERC20.sol\";\nimport \"./../Dependencies/Ownable.sol\";\nimport \"./../Dependencies/AggregatorV3Interface.sol\";\nimport \"./../Dependencies/CheckContract.sol\";\nimport \"./../Dependencies/SendCollateral.sol\";\nimport \"./YieldBoxRebase.sol\";\n\n\ncontract BAMM is CropJoinAdapter, PriceFormula, Ownable, CheckContract, SendCollateral {\n\n    using YieldBoxRebase for uint256;\n\n    AggregatorV3Interface public immutable priceAggregator;\n    AggregatorV3Interface public thusd2UsdPriceAggregator;    \n    IERC20 public immutable thusdToken;\n    StabilityPool immutable public SP;\n    IERC20 public immutable collateralERC20;\n\n    address payable public immutable feePool;\n    uint256 public constant MAX_FEE = 100; // 1%\n    uint256 public fee = 0; // fee in bps\n    uint256 public A = 20;\n    uint256 public constant MIN_A = 20;\n    uint256 public constant MAX_A = 200;    \n\n    uint256 public immutable maxDiscount; // max discount in bips\n\n    uint256 constant public PRECISION = 1e18;\n    \n    address public bProtocolOwner;\n\n    event ParamsSet(uint256 A, uint256 fee);\n    event UserDeposit(address indexed user, uint256 thusdAmount, uint256 numShares);\n    event UserWithdraw(address indexed user, uint256 thusdAmount, uint256 collateralAmount, uint256 numShares);\n    event RebalanceSwap(address indexed user, uint256 thusdAmount, uint256 collateralAmount, uint256 timestamp);\n\n    constructor(\n        address _priceAggregator,\n        address payable _SP,\n        address _thusdToken,\n        address _collateralERC20,\n        uint256 _maxDiscount,\n        address payable _feePool,\n        address _bProtocolOwner\n    )\n        CropJoinAdapter()\n    {\n        checkContract(_priceAggregator);\n        checkContract(_thusdToken);\n        checkContract(_SP);\n        if (_collateralERC20 != address(0)) {\n            checkContract(_collateralERC20);\n        }\n\n        priceAggregator = AggregatorV3Interface(_priceAggregator);\n        thusdToken = IERC20(_thusdToken);\n        SP = StabilityPool(_SP);\n        collateralERC20 = IERC20(_collateralERC20);\n        feePool = _feePool;\n        maxDiscount = _maxDiscount;\n\n        require(_bProtocolOwner != address(0), \"B.Protocol owner must be specified\");\n        bProtocolOwner = _bProtocolOwner;\n    }\n\n    modifier onlyBProtocolOwner() {\n        require(msg.sender == bProtocolOwner, \"Ownable: caller is not the B.Protocol owner\");\n        _;\n    }\n\n    function setTHUSD2UsdPriceAggregator(\n        address _thusd2UsdPriceAggregator\n    ) external onlyOwner {\n        require(address(thusd2UsdPriceAggregator) == address(0), \"set: price aggregator already set\");\n        checkContract(_thusd2UsdPriceAggregator);\n        thusd2UsdPriceAggregator = AggregatorV3Interface(_thusd2UsdPriceAggregator);\n    }\n\n    function setParams(uint256 _A, uint256 _fee) external onlyBProtocolOwner {\n        require(_fee <= MAX_FEE, \"setParams: fee is too big\");\n        require(_A >= MIN_A, \"setParams: A too small\");\n        require(_A <= MAX_A, \"setParams: A too big\");\n\n        fee = _fee;\n        A = _A;\n\n        emit ParamsSet(_A, _fee);\n    }\n\n    function fetchPrice() public view returns(uint256) {\n        uint256 chainlinkDecimals;\n        uint256 chainlinkLatestAnswer;\n        uint256 chainlinkTimestamp;\n\n        // First, try to get current decimal precision:\n        try priceAggregator.decimals() returns (uint8 decimals) {\n            // If call to Chainlink succeeds, record the current decimal precision\n            chainlinkDecimals = decimals;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a zero response with success = false\n            return 0;\n        }\n\n        // Secondly, try to get latest price data:\n        try priceAggregator.latestRoundData() returns\n        (\n            uint80 /* roundId */,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 timestamp,\n            uint80 /* answeredInRound */\n        )\n        {\n            // If call to Chainlink succeeds, return the response and success = true\n            chainlinkLatestAnswer = uint256(answer);\n            chainlinkTimestamp = timestamp;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a zero response with success = false\n            return 0;\n        }\n\n        if(chainlinkTimestamp + 1 hours < block.timestamp) return 0; // price is down\n\n        uint256 chainlinkFactor = 10 ** chainlinkDecimals;\n        return chainlinkLatestAnswer * PRECISION / chainlinkFactor;\n    }\n\n    function getCollateralBalance() public view returns (uint256 collateralValue) {\n        collateralValue = SP.getDepositorCollateralGain(address(this));\n        if (address(collateralERC20) == address(0)) {\n            collateralValue += address(this).balance;\n        } else {\n            collateralValue += collateralERC20.balanceOf(address(this));\n        }\n    }\n\n    function deposit(uint256 thusdAmount) external {        \n        // update share\n        uint256 thusdValue = SP.getCompoundedTHUSDDeposit(address(this));\n        uint256 collateralValue = getCollateralBalance();\n\n        uint256 price = fetchPrice();\n        require(collateralValue == 0 || price > 0, \"deposit: chainlink is down\");\n\n        uint256 totalValue = thusdValue + collateralValue * price / PRECISION;\n\n        // this is in theory not reachable. if it is, better halt deposits\n        // the condition is equivalent to: (totalValue = 0) ==> (total = 0)\n        require(totalValue > 0 || total == 0, \"deposit: system is rekt\");\n\n        uint256 newShare = thusdAmount._toShares(total, totalValue, true);\n\n        // deposit\n        require(thusdToken.transferFrom(msg.sender, address(this), thusdAmount), \"deposit: transferFrom failed\");\n        SP.provideToSP(thusdAmount);\n\n        // update LP token\n        mint(msg.sender, newShare);\n\n        emit UserDeposit(msg.sender, thusdAmount, newShare);        \n    }\n\n    function withdraw(uint256 numShares) external {\n        uint256 thusdValue = SP.getCompoundedTHUSDDeposit(address(this));\n        uint256 collateralValue = getCollateralBalance();\n\n        uint256 thusdAmount = numShares._toAmount(total, thusdValue, true);\n        uint256 collateralAmount = numShares._toAmount(total, collateralValue, false);\n\n        // this withdraws thusdn and collateral\n        SP.withdrawFromSP(thusdAmount);\n\n        // update LP token\n        burn(msg.sender, numShares);\n\n        // send thusd and collateral\n        if(thusdAmount > 0) thusdToken.transfer(msg.sender, thusdAmount);\n        emit UserWithdraw(msg.sender, thusdAmount, collateralAmount, numShares);        \n        if(collateralAmount == 0) {\n            return;\n        }\n\n        sendCollateral(collateralERC20, msg.sender, collateralAmount);\n    }\n\n    function addBps(uint256 n, int bps) internal pure returns(uint) {\n        require(bps <= 10000, \"reduceBps: bps exceeds max\");\n        require(bps >= -10000, \"reduceBps: bps exceeds min\");\n\n        return n * uint256(10000 + bps) / 10000;\n    }\n\n    function compensateForTHUSDDeviation(uint256 collateralAmount) public view returns(uint256 newCollateralAmount) {\n        if (address(thusd2UsdPriceAggregator) == address(0)) {\n            return collateralAmount;\n        }\n\n        uint256 chainlinkDecimals;\n        uint256 chainlinkLatestAnswer;\n\n        // get current decimal precision:\n        chainlinkDecimals = thusd2UsdPriceAggregator.decimals();\n\n        // Secondly, try to get latest price data:\n        (,int256 answer,,,) = thusd2UsdPriceAggregator.latestRoundData();\n        chainlinkLatestAnswer = uint256(answer);\n\n        // adjust only if 1 thUSD > 1 USDC. If thUSD < USD, then we give a discount, and rebalance will happen anw\n        if(chainlinkLatestAnswer > 10 ** chainlinkDecimals ) {\n            newCollateralAmount = collateralAmount * chainlinkLatestAnswer / (10 ** chainlinkDecimals);\n        }\n        else newCollateralAmount = collateralAmount;\n    }\n\n    function getSwapCollateralAmount(uint256 thusdQty) public view returns(uint256 collateralAmount, uint256 feeTHUSDAmount) {\n        uint256 thusdBalance = SP.getCompoundedTHUSDDeposit(address(this));\n        uint256 collateralBalance = getCollateralBalance();\n\n        uint256 collateral2usdPrice = fetchPrice();\n        if(collateral2usdPrice == 0) return (0, 0); // chainlink is down\n\n        uint256 collateralUsdValue = collateralBalance * collateral2usdPrice / PRECISION;\n        uint256 maxReturn = addBps(thusdQty * PRECISION / collateral2usdPrice, int(maxDiscount));\n\n        uint256 xQty = thusdQty;\n        uint256 xBalance = thusdBalance;\n        uint256 yBalance = thusdBalance + (collateralUsdValue * 2);\n        \n        uint256 usdReturn = getReturn(xQty, xBalance, yBalance, A);\n        uint256 basicCollateralReturn = usdReturn * PRECISION / collateral2usdPrice;\n\n        basicCollateralReturn = compensateForTHUSDDeviation(basicCollateralReturn);\n\n        if(collateralBalance < basicCollateralReturn) basicCollateralReturn = collateralBalance; // cannot give more than balance \n        if(maxReturn < basicCollateralReturn) basicCollateralReturn = maxReturn;\n\n        collateralAmount = basicCollateralReturn;\n        feeTHUSDAmount = addBps(thusdQty, int(fee)) - thusdQty;\n    }\n\n    // get collateral in return to THUSD\n    function swap(uint256 thusdAmount, uint256 minCollateralReturn, address payable dest) public returns(uint) {\n        (uint256 collateralAmount, uint256 feeAmount) = getSwapCollateralAmount(thusdAmount);\n\n        require(collateralAmount >= minCollateralReturn, \"swap: low return\");\n\n        thusdToken.transferFrom(msg.sender, address(this), thusdAmount);\n        SP.provideToSP(thusdAmount - feeAmount);\n\n        if(feeAmount > 0) thusdToken.transfer(feePool, feeAmount);\n\n        sendCollateral(collateralERC20, dest, collateralAmount);\n\n        emit RebalanceSwap(msg.sender, thusdAmount, collateralAmount, block.timestamp);\n\n        return collateralAmount;\n    }\n\n    // kyber network reserve compatible function\n    function trade(\n        IERC20 /* srcToken */,\n        uint256 srcAmount,\n        IERC20 /* destToken */,\n        address payable destAddress,\n        uint256 /* conversionRate */,\n        bool /* validate */\n    ) external payable returns (bool) {\n        return swap(srcAmount, 0, destAddress) > 0;\n    }\n\n    function getConversionRate(\n        IERC20 /* src */,\n        IERC20 /* dest */,\n        uint256 srcQty,\n        uint256 /* blockNumber */\n    ) external view returns (uint256) {\n        (uint256 collateralQty, ) = getSwapCollateralAmount(srcQty);\n        return collateralQty * PRECISION / srcQty;\n    }\n\n    receive() external payable {}\n\n    function transferBProtocolOwnership(address newOwner) public onlyBProtocolOwner {\n        require(newOwner != address(0), \"Ownable: new B.Protocol owner is the zero address\");\n        address oldOwner = bProtocolOwner;\n        bProtocolOwner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n}"
    }
  ]
}