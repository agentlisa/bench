{
  "Title": "M-4: `KeeperOracle.request` adds only the first pair of market+account addresses per oracle version to callback list, ignoring all the subsequent ones",
  "Content": "# Issue M-4: `KeeperOracle.request` adds only the first pair of market+account addresses per oracle version to callback list, ignoring all the subsequent ones \n\nSource: https://github.com/sherlock-audit/2023-10-perennial-judging/issues/25 \n\n## Found by \nbin2chen, panprog, rvierdiiev\n## Summary\n\nThe new feature introduced in 2.1 is the callback called for all markets and market+account pairs which requested the oracle version. These callbacks are called once the corresponding oracle settles. For this reason, `KeeperOracle` keeps a list of markets and market+account pairs per oracle version to call market.update on them:\n```solidity\n/// @dev Mapping from version to a set of registered markets for settlement callback\nmapping(uint256 => EnumerableSet.AddressSet) private _globalCallbacks;\n\n/// @dev Mapping from version and market to a set of registered accounts for settlement callback\nmapping(uint256 => mapping(IMarket => EnumerableSet.AddressSet)) private _localCallbacks;\n```\n\nHowever, currently `KeeperOracle` stores only the market+account from the first request call per oracle version, because if the request was already made, it returns from the function before adding to the list:\n```solidity\nfunction request(IMarket market, address account) external onlyAuthorized {\n    uint256 currentTimestamp = current();\n@@@ if (versions[_global.currentIndex] == currentTimestamp) return;\n\n    versions[++_global.currentIndex] = currentTimestamp;\n    emit OracleProviderVersionRequested(currentTimestamp);\n\n    // @audit only the first request per version reaches these lines to add market+account to callback list\n    _globalCallbacks[currentTimestamp].add(address(market));\n    _localCallbacks[currentTimestamp][market].add(account);\n    emit CallbackRequested(SettlementCallback(market, account, currentTimestamp));\n}\n```\n\n## Vulnerability Detail\n\nAccording to docs, the same `KeeperOracle` can be used by multiple markets. And every account requesting in the same oracle version is supposed to be called back (settled) once the oracle version settles.\n\n## Impact\n\nThe new core function of the protocol doesn't work as expected and `KeeperOracle` will fail to call back markets and accounts if there is more than 1 request in the same oracle version (which is very likely).\n\n## Code Snippet\n\n`KeeperOracle.request` will return early if the request for this oracle version was already made:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/keeper/KeeperOracle.sol#L77\n\nThe lines to add market+account to callback list will only be reached once per oracle version:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/keeper/KeeperOracle.sol#L82-L83\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nMove addition to callback list to just before the condition to exit function early:\n```solidity\nfunction request(IMarket market, address account) external onlyAuthorized {\n    uint256 currentTimestamp = current();\n    _globalCallbacks[currentTimestamp].add(address(market));\n    _localCallbacks[currentTimestamp][market].add(account);\n    emit CallbackRequested(SettlementCallback(market, account, currentTimestamp));\n    if (versions[_global.currentIndex] == currentTimestamp) return;\n\n    versions[++_global.currentIndex] = currentTimestamp;\n    emit OracleProviderVersionRequested(currentTimestamp);\n}\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/123",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/keeper/KeeperOracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"../interfaces/IKeeperFactory.sol\";\n\n/// @title KeeperOracle\n/// @notice Generic implementation of the IOracle interface for keeper-based oracles.\n/// @dev One instance per price feed should be deployed. Multiple products may use the same\n///      KeeperOracle instance if their payoff functions are based on the same underlying oracle.\n///      This implementation only supports non-negative prices.\ncontract KeeperOracle is IKeeperOracle, Instance {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev After this amount of time has passed for a version without being committed, the version can be invalidated.\n    uint256 public immutable timeout;\n\n    /// @dev List of all requested oracle versions\n    mapping(uint256 => uint256) public versions;\n\n    /// @dev The global state of the oracle\n    Global private _global;\n\n    /// @dev Mapping from oracle version to oracle version data\n    mapping(uint256 => Fixed6) private _prices;\n\n    /// @dev Mapping from version to a set of registered markets for settlement callback\n    mapping(uint256 => EnumerableSet.AddressSet) private _globalCallbacks;\n\n    /// @dev Mapping from version and market to a set of registered accounts for settlement callback\n    mapping(uint256 => mapping(IMarket => EnumerableSet.AddressSet)) private _localCallbacks;\n\n    /// @notice Constructs the contract\n    /// @param timeout_ The timeout for a version to be committed\n    constructor(uint256 timeout_)  {\n        timeout = timeout_;\n    }\n\n    /// @notice Initializes the contract state\n    function initialize() external initializer(1) {\n        __Instance__initialize();\n    }\n\n    /// @notice Returns the global state of the oracle\n    /// @return The global state of the oracle\n    function global() external view returns (Global memory) { return _global; }\n\n    /// @notice Returns the global oracle callback set for a version\n    /// @param version The version to lookup\n    /// @return The global oracle callback set for the version\n    function globalCallbacks(uint256 version) external view returns (address[] memory) {\n        return _globalCallbacks[version].values();\n    }\n\n    /// @notice Returns the local oracle callback set for a version and market\n    /// @param version The version to lookup\n    /// @param market The market to lookup\n    /// @return The local oracle callback set for the version and market\n    function localCallbacks(uint256 version, IMarket market) external view returns (address[] memory) {\n        return _localCallbacks[version][market].values();\n    }\n\n    /// @notice Returns the next requested oracle version\n    /// @dev Returns 0 if no next version is requested\n    /// @return The next requested oracle version\n    function next() public view returns (uint256) {\n        return versions[_global.latestIndex + 1];\n    }\n\n    /// @notice Records a request for a new oracle version\n    /// @param market The market to callback to\n    /// @param account The account to callback to\n    function request(IMarket market, address account) external onlyAuthorized {\n        uint256 currentTimestamp = current();\n        if (versions[_global.currentIndex] == currentTimestamp) return;\n\n        versions[++_global.currentIndex] = currentTimestamp;\n        emit OracleProviderVersionRequested(currentTimestamp);\n\n        _globalCallbacks[currentTimestamp].add(address(market));\n        _localCallbacks[currentTimestamp][market].add(account);\n        emit CallbackRequested(SettlementCallback(market, account, currentTimestamp));\n    }\n\n    /// @notice Returns the latest synced oracle version and the current oracle version\n    /// @return The latest synced oracle version\n    /// @return The current oracle version collecting new orders\n    function status() external view returns (OracleVersion memory, uint256) {\n        return (latest(), current());\n    }\n\n    /// @notice Returns the latest synced oracle version\n    /// @return Latest oracle version\n    function latest() public view returns (OracleVersion memory) {\n        return at(_global.latestVersion);\n    }\n\n    /// @notice Returns the current oracle version accepting new orders\n    /// @return Current oracle version\n    function current() public view returns (uint256) {\n        return IKeeperFactory(address(factory())).current();\n    }\n\n    /// @notice Returns the oracle version at version `version`\n    /// @param timestamp The timestamp of which to lookup\n    /// @return oracleVersion Oracle version at version `version`\n    function at(uint256 timestamp) public view returns (OracleVersion memory oracleVersion) {\n        (oracleVersion.timestamp, oracleVersion.price) = (timestamp, _prices[timestamp]);\n        oracleVersion.valid = !oracleVersion.price.isZero();\n    }\n\n    /// @notice Commits the price to specified version\n    /// @dev Verification of price happens in the oracle's factory\n    /// @param version The oracle version to commit\n    /// @return requested Whether the commit was requested\n    function commit(OracleVersion memory version) external onlyFactory returns (bool requested) {\n        if (version.timestamp == 0) revert KeeperOracleVersionOutsideRangeError();\n        requested = (version.timestamp == next()) ? _commitRequested(version) : _commitUnrequested(version);\n        _global.latestVersion = uint64(version.timestamp);\n\n        for (uint256 i; i < _globalCallbacks[version.timestamp].length(); i++)\n            _settle(IMarket(_globalCallbacks[version.timestamp].at(i)), address(0));\n\n        emit OracleProviderVersionFulfilled(version);\n    }\n\n    /// @notice Performs an asynchronous local settlement callback\n    /// @dev Distribution of keeper incentive is consolidated in the oracle's factory\n    /// @param market The market to settle\n    /// @param version The version to settle\n    /// @param maxCount The maximum number of settlement callbacks to perform before exiting\n    function settle(IMarket market, uint256 version, uint256 maxCount) external onlyFactory {\n        EnumerableSet.AddressSet storage callbacks = _localCallbacks[version][market];\n\n        if (_global.latestVersion < version) revert KeeperOracleVersionOutsideRangeError();\n        if (maxCount == 0) revert KeeperOracleInvalidCallbackError();\n        if (callbacks.length() == 0) revert KeeperOracleInvalidCallbackError();\n\n        for (uint256 i; i < maxCount && callbacks.length() > 0; i++) {\n            address account = callbacks.at(0);\n            _settle(market, account);\n            callbacks.remove(account);\n            emit CallbackFulfilled(SettlementCallback(market, account, version));\n        }\n    }\n\n    /// @notice Commits the price to a requested version\n    /// @dev This commit function will pay out a keeper reward if the committed version is valid\n    /// @param version The oracle version to commit\n    /// @return Whether the commit was requested\n    function _commitRequested(OracleVersion memory version) private returns (bool) {\n        if (block.timestamp <= (next() + timeout)) {\n            if (!version.valid) revert KeeperOracleInvalidPriceError();\n            _prices[version.timestamp] = version.price;\n        }\n        _global.latestIndex++;\n        return true;\n    }\n\n    /// @notice Commits the price to a non-requested version\n    /// @param version The oracle version to commit\n    /// @return Whether the commit was requested\n    function _commitUnrequested(OracleVersion memory version) private returns (bool) {\n        if (!version.valid) revert KeeperOracleInvalidPriceError();\n        if (version.timestamp <= _global.latestVersion || (next() != 0 && version.timestamp >= next()))\n            revert KeeperOracleVersionOutsideRangeError();\n        _prices[version.timestamp] = version.price;\n        return false;\n    }\n\n    /// @notice Performs a settlement callback for the account on the market\n    /// @param market The market to settle\n    /// @param account The account to settle\n    function _settle(IMarket market, address account) private {\n        market.update(account, UFixed6Lib.MAX, UFixed6Lib.MAX, UFixed6Lib.MAX, Fixed6Lib.ZERO, false);\n    }\n\n    /// @dev Only allow authorized callers\n    modifier onlyAuthorized {\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender)) revert OracleProviderUnauthorizedError();\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/keeper/KeeperOracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"../interfaces/IKeeperFactory.sol\";\n\n/// @title KeeperOracle\n/// @notice Generic implementation of the IOracle interface for keeper-based oracles.\n/// @dev One instance per price feed should be deployed. Multiple products may use the same\n///      KeeperOracle instance if their payoff functions are based on the same underlying oracle.\n///      This implementation only supports non-negative prices.\ncontract KeeperOracle is IKeeperOracle, Instance {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev After this amount of time has passed for a version without being committed, the version can be invalidated.\n    uint256 public immutable timeout;\n\n    /// @dev List of all requested oracle versions\n    mapping(uint256 => uint256) public versions;\n\n    /// @dev The global state of the oracle\n    Global private _global;\n\n    /// @dev Mapping from oracle version to oracle version data\n    mapping(uint256 => Fixed6) private _prices;\n\n    /// @dev Mapping from version to a set of registered markets for settlement callback\n    mapping(uint256 => EnumerableSet.AddressSet) private _globalCallbacks;\n\n    /// @dev Mapping from version and market to a set of registered accounts for settlement callback\n    mapping(uint256 => mapping(IMarket => EnumerableSet.AddressSet)) private _localCallbacks;\n\n    /// @notice Constructs the contract\n    /// @param timeout_ The timeout for a version to be committed\n    constructor(uint256 timeout_)  {\n        timeout = timeout_;\n    }\n\n    /// @notice Initializes the contract state\n    function initialize() external initializer(1) {\n        __Instance__initialize();\n    }\n\n    /// @notice Returns the global state of the oracle\n    /// @return The global state of the oracle\n    function global() external view returns (Global memory) { return _global; }\n\n    /// @notice Returns the global oracle callback set for a version\n    /// @param version The version to lookup\n    /// @return The global oracle callback set for the version\n    function globalCallbacks(uint256 version) external view returns (address[] memory) {\n        return _globalCallbacks[version].values();\n    }\n\n    /// @notice Returns the local oracle callback set for a version and market\n    /// @param version The version to lookup\n    /// @param market The market to lookup\n    /// @return The local oracle callback set for the version and market\n    function localCallbacks(uint256 version, IMarket market) external view returns (address[] memory) {\n        return _localCallbacks[version][market].values();\n    }\n\n    /// @notice Returns the next requested oracle version\n    /// @dev Returns 0 if no next version is requested\n    /// @return The next requested oracle version\n    function next() public view returns (uint256) {\n        return versions[_global.latestIndex + 1];\n    }\n\n    /// @notice Records a request for a new oracle version\n    /// @param market The market to callback to\n    /// @param account The account to callback to\n    function request(IMarket market, address account) external onlyAuthorized {\n        uint256 currentTimestamp = current();\n        if (versions[_global.currentIndex] == currentTimestamp) return;\n\n        versions[++_global.currentIndex] = currentTimestamp;\n        emit OracleProviderVersionRequested(currentTimestamp);\n\n        _globalCallbacks[currentTimestamp].add(address(market));\n        _localCallbacks[currentTimestamp][market].add(account);\n        emit CallbackRequested(SettlementCallback(market, account, currentTimestamp));\n    }\n\n    /// @notice Returns the latest synced oracle version and the current oracle version\n    /// @return The latest synced oracle version\n    /// @return The current oracle version collecting new orders\n    function status() external view returns (OracleVersion memory, uint256) {\n        return (latest(), current());\n    }\n\n    /// @notice Returns the latest synced oracle version\n    /// @return Latest oracle version\n    function latest() public view returns (OracleVersion memory) {\n        return at(_global.latestVersion);\n    }\n\n    /// @notice Returns the current oracle version accepting new orders\n    /// @return Current oracle version\n    function current() public view returns (uint256) {\n        return IKeeperFactory(address(factory())).current();\n    }\n\n    /// @notice Returns the oracle version at version `version`\n    /// @param timestamp The timestamp of which to lookup\n    /// @return oracleVersion Oracle version at version `version`\n    function at(uint256 timestamp) public view returns (OracleVersion memory oracleVersion) {\n        (oracleVersion.timestamp, oracleVersion.price) = (timestamp, _prices[timestamp]);\n        oracleVersion.valid = !oracleVersion.price.isZero();\n    }\n\n    /// @notice Commits the price to specified version\n    /// @dev Verification of price happens in the oracle's factory\n    /// @param version The oracle version to commit\n    /// @return requested Whether the commit was requested\n    function commit(OracleVersion memory version) external onlyFactory returns (bool requested) {\n        if (version.timestamp == 0) revert KeeperOracleVersionOutsideRangeError();\n        requested = (version.timestamp == next()) ? _commitRequested(version) : _commitUnrequested(version);\n        _global.latestVersion = uint64(version.timestamp);\n\n        for (uint256 i; i < _globalCallbacks[version.timestamp].length(); i++)\n            _settle(IMarket(_globalCallbacks[version.timestamp].at(i)), address(0));\n\n        emit OracleProviderVersionFulfilled(version);\n    }\n\n    /// @notice Performs an asynchronous local settlement callback\n    /// @dev Distribution of keeper incentive is consolidated in the oracle's factory\n    /// @param market The market to settle\n    /// @param version The version to settle\n    /// @param maxCount The maximum number of settlement callbacks to perform before exiting\n    function settle(IMarket market, uint256 version, uint256 maxCount) external onlyFactory {\n        EnumerableSet.AddressSet storage callbacks = _localCallbacks[version][market];\n\n        if (_global.latestVersion < version) revert KeeperOracleVersionOutsideRangeError();\n        if (maxCount == 0) revert KeeperOracleInvalidCallbackError();\n        if (callbacks.length() == 0) revert KeeperOracleInvalidCallbackError();\n\n        for (uint256 i; i < maxCount && callbacks.length() > 0; i++) {\n            address account = callbacks.at(0);\n            _settle(market, account);\n            callbacks.remove(account);\n            emit CallbackFulfilled(SettlementCallback(market, account, version));\n        }\n    }\n\n    /// @notice Commits the price to a requested version\n    /// @dev This commit function will pay out a keeper reward if the committed version is valid\n    /// @param version The oracle version to commit\n    /// @return Whether the commit was requested\n    function _commitRequested(OracleVersion memory version) private returns (bool) {\n        if (block.timestamp <= (next() + timeout)) {\n            if (!version.valid) revert KeeperOracleInvalidPriceError();\n            _prices[version.timestamp] = version.price;\n        }\n        _global.latestIndex++;\n        return true;\n    }\n\n    /// @notice Commits the price to a non-requested version\n    /// @param version The oracle version to commit\n    /// @return Whether the commit was requested\n    function _commitUnrequested(OracleVersion memory version) private returns (bool) {\n        if (!version.valid) revert KeeperOracleInvalidPriceError();\n        if (version.timestamp <= _global.latestVersion || (next() != 0 && version.timestamp >= next()))\n            revert KeeperOracleVersionOutsideRangeError();\n        _prices[version.timestamp] = version.price;\n        return false;\n    }\n\n    /// @notice Performs a settlement callback for the account on the market\n    /// @param market The market to settle\n    /// @param account The account to settle\n    function _settle(IMarket market, address account) private {\n        market.update(account, UFixed6Lib.MAX, UFixed6Lib.MAX, UFixed6Lib.MAX, Fixed6Lib.ZERO, false);\n    }\n\n    /// @dev Only allow authorized callers\n    modifier onlyAuthorized {\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender)) revert OracleProviderUnauthorizedError();\n        _;\n    }\n}"
    }
  ]
}