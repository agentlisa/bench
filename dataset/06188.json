{
  "Title": "[H-06] Resetting delegation will result in user funds being lost forever",
  "Content": "\n### Lines of code\n\n<https://github.com/GenerationSoftware/pt-v5-twab-controller/blob/0145eeac23301ee5338c659422dd6d69234f5d50/src/TwabController.sol#L596-L599>\n<https://github.com/GenerationSoftware/pt-v5-twab-controller/blob/0145eeac23301ee5338c659422dd6d69234f5d50/src/TwabController.sol#L648-L664>\n\n### Impact\n\nThe default delegate value for a user is `address(0)`, which maps to the user delegating to themselves. If a user had delegated to another address and wanted to reset their delegated balance back to themselves, they would lose all of their funds contributed to the vault.\n\n### Proof of Concept\n\nAs mentioned above, the default behaviour for a user is that they delegate their balance to themselves, where the actual default value in storage is the `0 address`:\n\n    function _delegateOf(address _vault, address _user) internal view returns (address) {\n        address _userDelegate;\n\n        if (_user != address(0)) {\n          _userDelegate = delegates[_vault][_user];\n\n          // If the user has not delegated, then the user is the delegate\n          if (_userDelegate == address(0)) {\n            _userDelegate = _user;\n          }\n        }\n\n        return _userDelegate;\n      }\n\nWhen a user wants to delegate their balance, they call `delegate` in `TwabController.sol` and specify which vault they want to delegate the balance of and to which address they want to delegate to. This calls `_delegate` under the hood:\n\n    function _delegate(address _vault, address _from, address _to) internal {\n        address _currentDelegate = _delegateOf(_vault, _from);\n        if (_to == _currentDelegate) {\n          revert SameDelegateAlreadySet(_to);\n        }\n\n        delegates[_vault][_from] = _to;\n\n        _transferDelegateBalance(\n          _vault,\n          _currentDelegate,\n          _to,\n          uint96(userObservations[_vault][_from].details.balance)\n        );\n\n        emit Delegated(_vault, _from, _to);\n      }\n\nIf a user wanted to reset the delegation to themselves, they would specify `_to` as `address(0)`. However, the issue with this is that the underlying `_transferDelegateBalance` call will mistakenly move the delegated user funds to the `0 address`.\n\nAt this point, the user might try to call `delegate` again with their actual address; however, now the `(_to == _currentDelegate)` check will be true and revert because of the behaviour specified earlier. The user also can't delegate to any other address because they don't own their own delegate balance anymore. Their funds are officially lost forever.\n\nBelow is a change to the existing test suite that can be executed with `forge test -vvv --match-path test/unit/Vault/Withdraw.t.sol` to demonstrate this issue:\n\n```\ndiff --git a/test/unit/Vault/Withdraw.t.sol b/test/unit/Vault/Withdraw.t.sol\nindex 6a15a59..3cec9e3 100644\n--- a/test/unit/Vault/Withdraw.t.sol\n+++ b/test/unit/Vault/Withdraw.t.sol\n@@ -47,6 +47,36 @@ contract VaultWithdrawTest is UnitBaseSetup {\n     vm.stopPrank();\n   }\n \n+  function testFundsLostForever() external {\n+    vm.startPrank(alice);\n+    uint256 _amount = 1000e18;\n+    underlyingAsset.mint(alice, _amount);\n+\n+    // Alice deposits as usual\n+    _deposit(underlyingAsset, vault, _amount, alice);\n+\n+    // Alice decides she wants to delegate to bob\n+    twabController.delegate(address(vault), bob);\n+\n+    // Alice now tries to reset her delegation\n+    twabController.delegate(address(vault), address(0));\n+\n+    // At this point the funds are lost!! Alice tries to recover her funds in any way...\n+    \n+    // Alice tries to delegate back to herself but can't\n+    vm.expectRevert();\n+    twabController.delegate(address(vault), alice);\n+\n+    // Alice also can't delegate to any other address\n+    vm.expectRevert();\n+    twabController.delegate(address(vault), bob);\n+    \n+    // Alice can't withdraw because her funds have been lost forever :(\n+    // Expecting a revert with \"DelegateBalanceLTAmount(0, 1000000000000000000000)\"\n+    vault.withdraw(vault.maxWithdraw(alice), alice, alice);\n+    vm.stopPrank();\n+  }\n+\n   function testWithdrawMoreThanMax() external {\n     vm.startPrank(alice);\n \n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nThe simplest way to fix this issue is to prevent delegating back to the `0 address`. If a user delegates away from the default, then they can delegate back to themselves by specifying their own address:\n\n```\ndiff --git a/src/TwabController.sol b/src/TwabController.sol\nindex a7e2d51..ae7b9ea 100644\n--- a/src/TwabController.sol\n+++ b/src/TwabController.sol\n@@ -646,6 +646,7 @@ contract TwabController {\n    * @param _to the address to delegate to\n    */\n   function _delegate(address _vault, address _from, address _to) internal {\n+    require(_to != address(0), \"Cannot delegate back to 0 address\");\n     address _currentDelegate = _delegateOf(_vault, _from);\n     if (_to == _currentDelegate) {\n       revert SameDelegateAlreadySet(_to);\n\n```\n\n### Assessed type\n\nInvalid Validation\n\n**[asselstine (PoolTogether) confirmed via duplicate issue #293](https://github.com/code-423n4/2023-07-pooltogether-findings/issues/293#issuecomment-1644540389)**\n\n**[Picodes (judge) commented via duplicate issue #293](https://github.com/code-423n4/2023-07-pooltogether-findings/issues/293#issuecomment-1666956243):**\n> High severity seems justified because of the lines `if (_userDelegate == address(0)) { _userDelegate = _user;}`. It seems likely that some users are tricked into thinking that delegating back to the `0 address` will cancel their delegation.\n\n**[PoolTogether mitigated](https://github.com/code-423n4/2023-08-pooltogether-mitigation#individual-prs):**\n> Added check for zero address.<br>\n> PR: https://github.com/GenerationSoftware/pt-v5-twab-controller/pull/7\n\n**Status**: Mitigation confirmed with comments. Full details in reports from [0xStalin](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/39), [dirk\\_y](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/9) and [rvierdiiev](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/32).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-pooltogether",
  "Code": [
    {
      "filename": "src/TwabController.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport { TwabLib } from \"./libraries/TwabLib.sol\";\nimport { ObservationLib } from \"./libraries/ObservationLib.sol\";\n\n/// @notice Emitted when an account already points to the same delegate address that is being set\nerror SameDelegateAlreadySet(address delegate);\n\n/**\n * @title  Time-Weighted Average Balance Controller\n * @author PoolTogether Inc.\n * @dev    Time-Weighted Average Balance Controller for ERC20 tokens.\n * @notice This TwabController uses the TwabLib to provide token balances and on-chain historical\n            lookups to a user(s) time-weighted average balance. Each user is mapped to an\n            Account struct containing the TWAB history (ring buffer) and ring buffer parameters.\n            Every token.transfer() creates a new TWAB observation. The new TWAB observation is\n            stored in the circular ring buffer as either a new observation or rewriting a\n            previous observation with new parameters. One observation per period is stored.\n            The TwabLib guarantees minimum 1 year of search history if a period is a day.\n */\ncontract TwabController {\n  /// @notice Allows users to revoke their chances to win by delegating to the sponsorship address.\n  address public constant SPONSORSHIP_ADDRESS = address(1);\n\n  /// @notice Sets the minimum period length for Observations. When a period elapses, a new Observation is recorded, otherwise the most recent Observation is updated.\n  uint32 public immutable PERIOD_LENGTH;\n\n  /// @notice Sets the beginning timestamp for the first period. This allows us to maximize storage as well as line up periods with a chosen timestamp.\n  /// @dev Ensure that the PERIOD_OFFSET is in the past.\n  uint32 public immutable PERIOD_OFFSET;\n\n  /* ============ State ============ */\n\n  /// @notice Record of token holders TWABs for each account for each vault.\n  mapping(address => mapping(address => TwabLib.Account)) internal userObservations;\n\n  /// @notice Record of tickets total supply and ring buff parameters used for observation.\n  mapping(address => TwabLib.Account) internal totalSupplyObservations;\n\n  /// @notice vault => user => delegate.\n  mapping(address => mapping(address => address)) internal delegates;\n\n  /* ============ Events ============ */\n\n  /**\n   * @notice Emitted when a balance or delegateBalance is increased.\n   * @param vault the vault for which the balance increased\n   * @param user the users whose balance increased\n   * @param amount the amount the balance increased by\n   * @param delegateAmount the amount the delegateBalance increased by\n   */\n  event IncreasedBalance(\n    address indexed vault,\n    address indexed user,\n    uint96 amount,\n    uint96 delegateAmount\n  );\n\n  /**\n   * @notice Emited when a balance or delegateBalance is decreased.\n   * @param vault the vault for which the balance decreased\n   * @param user the users whose balance decreased\n   * @param amount the amount the balance decreased by\n   * @param delegateAmount the amount the delegateBalance decreased by\n   */\n  event DecreasedBalance(\n    address indexed vault,\n    address indexed user,\n    uint96 amount,\n    uint96 delegateAmount\n  );\n\n  /**\n   * @notice Emited when an Observation is recorded to the Ring Buffer.\n   * @param vault the vault for which the Observation was recorded\n   * @param user the users whose Observation was recorded\n   * @param balance the resulting balance\n   * @param delegateBalance the resulting delegated balance\n   * @param isNew whether the observation is new or not\n   * @param observation the observation that was created or updated\n   */\n  event ObservationRecorded(\n    address indexed vault,\n    address indexed user,\n    uint112 balance,\n    uint112 delegateBalance,\n    bool isNew,\n    ObservationLib.Observation observation\n  );\n\n  /**\n   * @notice Emitted when a user delegates their balance to another address.\n   * @param vault the vault for which the balance was delegated\n   * @param delegator the user who delegated their balance\n   * @param delegate the user who received the delegated balance\n   */\n  event Delegated(address indexed vault, address indexed delegator, address indexed delegate);\n\n  /**\n   * @notice Emitted when the total supply or delegateTotalSupply is increased.\n   * @param vault the vault for which the total supply increased\n   * @param amount the amount the total supply increased by\n   * @param delegateAmount the amount the delegateTotalSupply increased by\n   */\n  event IncreasedTotalSupply(address indexed vault, uint96 amount, uint96 delegateAmount);\n\n  /**\n   * @notice Emitted when the total supply or delegateTotalSupply is decreased.\n   * @param vault the vault for which the total supply decreased\n   * @param amount the amount the total supply decreased by\n   * @param delegateAmount the amount the delegateTotalSupply decreased by\n   */\n  event DecreasedTotalSupply(address indexed vault, uint96 amount, uint96 delegateAmount);\n\n  /**\n   * @notice Emited when a Total Supply Observation is recorded to the Ring Buffer.\n   * @param vault the vault for which the Observation was recorded\n   * @param balance the resulting balance\n   * @param delegateBalance the resulting delegated balance\n   * @param isNew whether the observation is new or not\n   * @param observation the observation that was created or updated\n   */\n  event TotalSupplyObservationRecorded(\n    address indexed vault,\n    uint112 balance,\n    uint112 delegateBalance,\n    bool isNew,\n    ObservationLib.Observation observation\n  );\n\n  /* ============ Constructor ============ */\n\n  /**\n   * @notice Construct a new TwabController.\n   * @dev Ensure the periods offset is in the past, otherwise underflows will occur whilst calculating periods.\n   * @param _periodLength Sets the minimum period length for Observations. When a period elapses, a new Observation\n   *      is recorded, otherwise the most recent Observation is updated.\n   * @param _periodOffset Sets the beginning timestamp for the first period. This allows us to maximize storage as well\n   *      as line up periods with a chosen timestamp.\n   */\n  constructor(uint32 _periodLength, uint32 _periodOffset) {\n    PERIOD_LENGTH = _periodLength;\n    PERIOD_OFFSET = _periodOffset;\n  }\n\n  /* ============ External Read Functions ============ */\n\n  /**\n   * @notice Loads the current TWAB Account data for a specific vault stored for a user.\n   * @dev Note this is a very expensive function\n   * @param vault the vault for which the data is being queried\n   * @param user the user whose data is being queried\n   * @return The current TWAB Account data of the user\n   */\n  function getAccount(address vault, address user) external view returns (TwabLib.Account memory) {\n    return userObservations[vault][user];\n  }\n\n  /**\n   * @notice Loads the current total supply TWAB Account data for a specific vault.\n   * @dev Note this is a very expensive function\n   * @param vault the vault for which the data is being queried\n   * @return The current total supply TWAB Account data\n   */\n  function getTotalSupplyAccount(address vault) external view returns (TwabLib.Account memory) {\n    return totalSupplyObservations[vault];\n  }\n\n  /**\n   * @notice The current token balance of a user for a specific vault.\n   * @param vault the vault for which the balance is being queried\n   * @param user the user whose balance is being queried\n   * @return The current token balance of the user\n   */\n  function balanceOf(address vault, address user) external view returns (uint256) {\n    return userObservations[vault][user].details.balance;\n  }\n\n  /**\n   * @notice The total supply of tokens for a vault.\n   * @param vault the vault for which the total supply is being queried\n   * @return The total supply of tokens for a vault\n   */\n  function totalSupply(address vault) external view returns (uint256) {\n    return totalSupplyObservations[vault].details.balance;\n  }\n\n  /**\n   * @notice The total delegated amount of tokens for a vault.\n   * @dev Delegated balance is not 1:1 with the token total supply. Users may delegate their\n   *      balance to the sponsorship address, which will result in those tokens being subtracted\n   *      from the total.\n   * @param vault the vault for which the total delegated supply is being queried\n   * @return The total delegated amount of tokens for a vault\n   */\n  function totalSupplyDelegateBalance(address vault) external view returns (uint256) {\n    return totalSupplyObservations[vault].details.delegateBalance;\n  }\n\n  /**\n   * @notice The current delegate of a user for a specific vault.\n   * @param vault the vault for which the delegate balance is being queried\n   * @param user the user whose delegate balance is being queried\n   * @return The current delegate balance of the user\n   */\n  function delegateOf(address vault, address user) external view returns (address) {\n    return _delegateOf(vault, user);\n  }\n\n  /**\n   * @notice The current delegateBalance of a user for a specific vault.\n   * @dev the delegateBalance is the sum of delegated balance to this user\n   * @param vault the vault for which the delegateBalance is being queried\n   * @param user the user whose delegateBalance is being queried\n   * @return The current delegateBalance of the user\n   */\n  function delegateBalanceOf(address vault, address user) external view returns (uint256) {\n    return userObservations[vault][user].details.delegateBalance;\n  }\n\n  /**\n   * @notice Looks up a users balance at a specific time in the past.\n   * @param vault the vault for which the balance is being queried\n   * @param user the user whose balance is being queried\n   * @param targetTime the time in the past for which the balance is being queried\n   * @return The balance of the user at the target time\n   */\n  function getBalanceAt(\n    address vault,\n    address user,\n    uint32 targetTime\n  ) external view returns (uint256) {\n    TwabLib.Account storage _account = userObservations[vault][user];\n    return TwabLib.getBalanceAt(PERIOD_OFFSET, _account.observations, _account.details, targetTime);\n  }\n\n  /**\n   * @notice Looks up the total supply at a specific time in the past.\n   * @param vault the vault for which the total supply is being queried\n   * @param targetTime the time in the past for which the total supply is being queried\n   * @return The total supply at the target time\n   */\n  function getTotalSupplyAt(address vault, uint32 targetTime) external view returns (uint256) {\n    TwabLib.Account storage _account = totalSupplyObservations[vault];\n    return TwabLib.getBalanceAt(PERIOD_OFFSET, _account.observations, _account.details, targetTime);\n  }\n\n  /**\n   * @notice Looks up the average balance of a user between two timestamps.\n   * @dev Timestamps are Unix timestamps denominated in seconds\n   * @param vault the vault for which the average balance is being queried\n   * @param user the user whose average balance is being queried\n   * @param startTime the start of the time range for which the average balance is being queried\n   * @param endTime the end of the time range for which the average balance is being queried\n   * @return The average balance of the user between the two timestamps\n   */\n  function getTwabBetween(\n    address vault,\n    address user,\n    uint32 startTime,\n    uint32 endTime\n  ) external view returns (uint256) {\n    TwabLib.Account storage _account = userObservations[vault][user];\n    return\n      TwabLib.getTwabBetween(\n        PERIOD_OFFSET,\n        _account.observations,\n        _account.details,\n        startTime,\n        endTime\n      );\n  }\n\n  /**\n   * @notice Looks up the average total supply between two timestamps.\n   * @dev Timestamps are Unix timestamps denominated in seconds\n   * @param vault the vault for which the average total supply is being queried\n   * @param startTime the start of the time range for which the average total supply is being queried\n   * @param endTime the end of the time range for which the average total supply is being queried\n   * @return The average total supply between the two timestamps\n   */\n  function getTotalSupplyTwabBetween(\n    address vault,\n    uint32 startTime,\n    uint32 endTime\n  ) external view returns (uint256) {\n    TwabLib.Account storage _account = totalSupplyObservations[vault];\n    return\n      TwabLib.getTwabBetween(\n        PERIOD_OFFSET,\n        _account.observations,\n        _account.details,\n        startTime,\n        endTime\n      );\n  }\n\n  /**\n   * @notice Looks up the newest observation  for a user.\n   * @param vault the vault for which the observation is being queried\n   * @param user the user whose observation is being queried\n   * @return index The index of the observation\n   * @return observation The observation of the user\n   */\n  function getNewestObservation(\n    address vault,\n    address user\n  ) external view returns (uint16, ObservationLib.Observation memory) {\n    TwabLib.Account storage _account = userObservations[vault][user];\n    return TwabLib.getNewestObservation(_account.observations, _account.details);\n  }\n\n  /**\n   * @notice Looks up the oldest observation  for a user.\n   * @param vault the vault for which the observation is being queried\n   * @param user the user whose observation is being queried\n   * @return index The index of the observation\n   * @return observation The observation of the user\n   */\n  function getOldestObservation(\n    address vault,\n    address user\n  ) external view returns (uint16, ObservationLib.Observation memory) {\n    TwabLib.Account storage _account = userObservations[vault][user];\n    return TwabLib.getOldestObservation(_account.observations, _account.details);\n  }\n\n  /**\n   * @notice Looks up the newest total supply observation for a vault.\n   * @param vault the vault for which the observation is being queried\n   * @return index The index of the observation\n   * @return observation The total supply observation\n   */\n  function getNewestTotalSupplyObservation(\n    address vault\n  ) external view returns (uint16, ObservationLib.Observation memory) {\n    TwabLib.Account storage _account = totalSupplyObservations[vault];\n    return TwabLib.getNewestObservation(_account.observations, _account.details);\n  }\n\n  /**\n   * @notice Looks up the oldest total supply observation for a vault.\n   * @param vault the vault for which the observation is being queried\n   * @return index The index of the observation\n   * @return observation The total supply observation\n   */\n  function getOldestTotalSupplyObservation(\n    address vault\n  ) external view returns (uint16, ObservationLib.Observation memory) {\n    TwabLib.Account storage _account = totalSupplyObservations[vault];\n    return TwabLib.getOldestObservation(_account.observations, _account.details);\n  }\n\n  /**\n   * @notice Calculates the period a timestamp falls into.\n   * @param time The timestamp to check\n   * @return period The period the timestamp falls into\n   */\n  function getTimestampPeriod(uint32 time) external view returns (uint32) {\n    return TwabLib.getTimestampPeriod(PERIOD_LENGTH, PERIOD_OFFSET, time);\n  }\n\n  /**\n   * @notice Checks if the given timestamp is safe to perform a historic balance lookup on.\n   * @dev A timestamp is safe if it is between (or at) the newest observation in a period and the end of the period.\n   * @dev If the time being queried is in a period that has not yet ended, the output for this function may change.\n   * @param vault The vault to check\n   * @param user The user to check\n   * @param time The timestamp to check\n   * @return isSafe Whether or not the timestamp is safe\n   */\n  function isTimeSafe(address vault, address user, uint32 time) external view returns (bool) {\n    TwabLib.Account storage account = userObservations[vault][user];\n    return\n      TwabLib.isTimeSafe(PERIOD_LENGTH, PERIOD_OFFSET, account.observations, account.details, time);\n  }\n\n  /**\n   * @notice Checks if the given time range is safe to perform a historic balance lookup on.\n   * @dev A timestamp is safe if it is between (or at) the newest observation in a period and the end of the period.\n   * @dev If the endtime being queried is in a period that has not yet ended, the output for this function may change.\n   * @param vault The vault to check\n   * @param user The user to check\n   * @param startTime The start of the timerange to check\n   * @param endTime The end of the timerange to check\n   * @return isSafe Whether or not the time range is safe\n   */\n  function isTimeRangeSafe(\n    address vault,\n    address user,\n    uint32 startTime,\n    uint32 endTime\n  ) external view returns (bool) {\n    TwabLib.Account storage account = userObservations[vault][user];\n    return\n      TwabLib.isTimeRangeSafe(\n        PERIOD_LENGTH,\n        PERIOD_OFFSET,\n        account.observations,\n        account.details,\n        startTime,\n        endTime\n      );\n  }\n\n  /**\n   * @notice Checks if the given timestamp is safe to perform a historic balance lookup on.\n   * @dev A timestamp is safe if it is between (or at) the newest observation in a period and the end of the period.\n   * @dev If the time being queried is in a period that has not yet ended, the output for this function may change.\n   * @param vault The vault to check\n   * @param time The timestamp to check\n   * @return isSafe Whether or not the timestamp is safe\n   */\n  function isTotalSupplyTimeSafe(address vault, uint32 time) external view returns (bool) {\n    TwabLib.Account storage account = totalSupplyObservations[vault];\n    return\n      TwabLib.isTimeSafe(PERIOD_LENGTH, PERIOD_OFFSET, account.observations, account.details, time);\n  }\n\n  /**\n   * @notice Checks if the given time range is safe to perform a historic balance lookup on.\n   * @dev A timestamp is safe if it is between (or at) the newest observation in a period and the end of the period.\n   * @dev If the endtime being queried is in a period that has not yet ended, the output for this function may change.\n   * @param vault The vault to check\n   * @param startTime The start of the timerange to check\n   * @param endTime The end of the timerange to check\n   * @return isSafe Whether or not the time range is safe\n   */\n  function isTotalSupplyTimeRangeSafe(\n    address vault,\n    uint32 startTime,\n    uint32 endTime\n  ) external view returns (bool) {\n    TwabLib.Account storage account = totalSupplyObservations[vault];\n    return\n      TwabLib.isTimeRangeSafe(\n        PERIOD_LENGTH,\n        PERIOD_OFFSET,\n        account.observations,\n        account.details,\n        startTime,\n        endTime\n      );\n  }\n\n  /* ============ External Write Functions ============ */\n\n  /**\n   * @notice Mints new balance and delegateBalance for a given user.\n   * @dev Note that if the provided user to mint to is delegating that the delegate's\n   *      delegateBalance will be updated.\n   * @dev Mint is expected to be called by the Vault.\n   * @param _to The address to mint balance and delegateBalance to\n   * @param _amount The amount to mint\n   */\n  function mint(address _to, uint96 _amount) external {\n    _transferBalance(msg.sender, address(0), _to, _amount);\n  }\n\n  /**\n   * @notice Burns balance and delegateBalance for a given user.\n   * @dev Note that if the provided user to burn from is delegating that the delegate's\n   *      delegateBalance will be updated.\n   * @dev Burn is expected to be called by the Vault.\n   * @param _from The address to burn balance and delegateBalance from\n   * @param _amount The amount to burn\n   */\n  function burn(address _from, uint96 _amount) external {\n    _transferBalance(msg.sender, _from, address(0), _amount);\n  }\n\n  /**\n   * @notice Transfers balance and delegateBalance from a given user.\n   * @dev Note that if the provided user to transfer from is delegating that the delegate's\n   *      delegateBalance will be updated.\n   * @param _from The address to transfer the balance and delegateBalance from\n   * @param _to The address to transfer balance and delegateBalance to\n   * @param _amount The amount to transfer\n   */\n  function transfer(address _from, address _to, uint96 _amount) external {\n    _transferBalance(msg.sender, _from, _to, _amount);\n  }\n\n  /**\n   * @notice Sets a delegate for a user which forwards the delegateBalance tied to the user's\n   *          balance to the delegate's delegateBalance.\n   * @param _vault The vault for which the delegate is being set\n   * @param _to the address to delegate to\n   */\n  function delegate(address _vault, address _to) external {\n    _delegate(_vault, msg.sender, _to);\n  }\n\n  /**\n   * @notice Delegate user balance to the sponsorship address.\n   * @dev Must only be called by the Vault contract.\n   * @param _from Address of the user delegating their balance to the sponsorship address.\n   */\n  function sponsor(address _from) external {\n    _delegate(msg.sender, _from, SPONSORSHIP_ADDRESS);\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /**\n   * @notice Transfers a user's vault balance from one address to another.\n   * @dev If the user is delegating, their delegate's delegateBalance is also updated.\n   * @dev If we are minting or burning tokens then the total supply is also updated.\n   * @param _vault the vault for which the balance is being transferred\n   * @param _from the address from which the balance is being transferred\n   * @param _to the address to which the balance is being transferred\n   * @param _amount the amount of balance being transferred\n   */\n  function _transferBalance(address _vault, address _from, address _to, uint96 _amount) internal {\n    if (_from == _to) {\n      return;\n    }\n\n    // If we are transferring tokens from a delegated account to an undelegated account\n    address _fromDelegate = _delegateOf(_vault, _from);\n    address _toDelegate = _delegateOf(_vault, _to);\n    if (_from != address(0)) {\n      bool _isFromDelegate = _fromDelegate == _from;\n\n      _decreaseBalances(_vault, _from, _amount, _isFromDelegate ? _amount : 0);\n\n      // If the user is not delegating to themself, decrease the delegate's delegateBalance\n      // If the user is delegating to the sponsorship address, don't adjust the delegateBalance\n      if (!_isFromDelegate && _fromDelegate != SPONSORSHIP_ADDRESS) {\n        _decreaseBalances(_vault, _fromDelegate, 0, _amount);\n      }\n\n      // Burn balance if we're transferring to address(0)\n      // Burn delegateBalance if we're transferring to address(0) and burning from an address that is not delegating to the sponsorship address\n      // Burn delegateBalance if we're transferring to an address delegating to the sponsorship address from an address that isn't delegating to the sponsorship address\n      if (\n        _to == address(0) ||\n        (_toDelegate == SPONSORSHIP_ADDRESS && _fromDelegate != SPONSORSHIP_ADDRESS)\n      ) {\n        // If the user is delegating to the sponsorship address, don't adjust the total supply delegateBalance\n        _decreaseTotalSupplyBalances(\n          _vault,\n          _to == address(0) ? _amount : 0,\n          (_to == address(0) && _fromDelegate != SPONSORSHIP_ADDRESS) ||\n            (_toDelegate == SPONSORSHIP_ADDRESS && _fromDelegate != SPONSORSHIP_ADDRESS)\n            ? _amount\n            : 0\n        );\n      }\n    }\n\n    // If we are transferring tokens to an address other than address(0)\n    if (_to != address(0)) {\n      bool _isToDelegate = _toDelegate == _to;\n\n      // If the user is delegating to themself, increase their delegateBalance\n      _increaseBalances(_vault, _to, _amount, _isToDelegate ? _amount : 0);\n\n      // Otherwise, increase their delegates delegateBalance if it is not the sponsorship address\n      if (!_isToDelegate && _toDelegate != SPONSORSHIP_ADDRESS) {\n        _increaseBalances(_vault, _toDelegate, 0, _amount);\n      }\n\n      // Mint balance if we're transferring from address(0)\n      // Mint delegateBalance if we're transferring from address(0) and to an address not delegating to the sponsorship address\n      // Mint delegateBalance if we're transferring from an address delegating to the sponsorship address to an address that isn't delegating to the sponsorship address\n      if (\n        _from == address(0) ||\n        (_fromDelegate == SPONSORSHIP_ADDRESS && _toDelegate != SPONSORSHIP_ADDRESS)\n      ) {\n        _increaseTotalSupplyBalances(\n          _vault,\n          _from == address(0) ? _amount : 0,\n          (_from == address(0) && _toDelegate != SPONSORSHIP_ADDRESS) ||\n            (_fromDelegate == SPONSORSHIP_ADDRESS && _toDelegate != SPONSORSHIP_ADDRESS)\n            ? _amount\n            : 0\n        );\n      }\n    }\n  }\n\n  /**\n   * @notice Looks up the delegate of a user.\n   * @param _vault the vault for which the user's delegate is being queried\n   * @param _user the address to query the delegate of\n   * @return The address of the user's delegate\n   */\n  function _delegateOf(address _vault, address _user) internal view returns (address) {\n    address _userDelegate;\n\n    if (_user != address(0)) {\n      _userDelegate = delegates[_vault][_user];\n\n      // If the user has not delegated, then the user is the delegate\n      if (_userDelegate == address(0)) {\n        _userDelegate = _user;\n      }\n    }\n\n    return _userDelegate;\n  }\n\n  /**\n   * @notice Transfers a user's vault delegateBalance from one address to another.\n   * @param _vault the vault for which the delegateBalance is being transferred\n   * @param _fromDelegate the address from which the delegateBalance is being transferred\n   * @param _toDelegate the address to which the delegateBalance is being transferred\n   * @param _amount the amount of delegateBalance being transferred\n   */\n  function _transferDelegateBalance(\n    address _vault,\n    address _fromDelegate,\n    address _toDelegate,\n    uint96 _amount\n  ) internal {\n    // If we are transferring tokens from a delegated account to an undelegated account\n    if (_fromDelegate != address(0) && _fromDelegate != SPONSORSHIP_ADDRESS) {\n      _decreaseBalances(_vault, _fromDelegate, 0, _amount);\n\n      // If we are delegating to the zero address, decrease total supply\n      // If we are delegating to the sponsorship address, decrease total supply\n      if (_toDelegate == address(0) || _toDelegate == SPONSORSHIP_ADDRESS) {\n        _decreaseTotalSupplyBalances(_vault, 0, _amount);\n      }\n    }\n\n    // If we are transferring tokens from an undelegated account to a delegated account\n    if (_toDelegate != address(0) && _toDelegate != SPONSORSHIP_ADDRESS) {\n      _increaseBalances(_vault, _toDelegate, 0, _amount);\n\n      // If we are removing delegation from the zero address, increase total supply\n      // If we are removing delegation from the sponsorship address, increase total supply\n      if (_fromDelegate == address(0) || _fromDelegate == SPONSORSHIP_ADDRESS) {\n        _increaseTotalSupplyBalances(_vault, 0, _amount);\n      }\n    }\n  }\n\n  /**\n   * @notice Sets a delegate for a user which forwards the delegateBalance tied to the user's\n   *          balance to the delegate's delegateBalance.\n   * @param _vault The vault for which the delegate is being set\n   * @param _from the address to delegate from\n   * @param _to the address to delegate to\n   */\n  function _delegate(address _vault, address _from, address _to) internal {\n    address _currentDelegate = _delegateOf(_vault, _from);\n    if (_to == _currentDelegate) {\n      revert SameDelegateAlreadySet(_to);\n    }\n\n    delegates[_vault][_from] = _to;\n\n    _transferDelegateBalance(\n      _vault,\n      _currentDelegate,\n      _to,\n      uint96(userObservations[_vault][_from].details.balance)\n    );\n\n    emit Delegated(_vault, _from, _to);\n  }\n\n  /**\n   * @notice Increases a user's balance and delegateBalance for a specific vault.\n   * @param _vault the vault for which the balance is being increased\n   * @param _user the address of the user whose balance is being increased\n   * @param _amount the amount of balance being increased\n   * @param _delegateAmount the amount of delegateBalance being increased\n   */\n  function _increaseBalances(\n    address _vault,\n    address _user,\n    uint96 _amount,\n    uint96 _delegateAmount\n  ) internal {\n    TwabLib.Account storage _account = userObservations[_vault][_user];\n\n    (\n      ObservationLib.Observation memory _observation,\n      bool _isNewObservation,\n      bool _isObservationRecorded\n    ) = TwabLib.increaseBalances(PERIOD_LENGTH, PERIOD_OFFSET, _account, _amount, _delegateAmount);\n\n    // Always emit the balance change event\n    emit IncreasedBalance(_vault, _user, _amount, _delegateAmount);\n\n    // Conditionally emit the observation recorded event\n    if (_isObservationRecorded) {\n      emit ObservationRecorded(\n        _vault,\n        _user,\n        _account.details.balance,\n        _account.details.delegateBalance,\n        _isNewObservation,\n        _observation\n      );\n    }\n  }\n\n  /**\n   * @notice Decreases the a user's balance and delegateBalance for a specific vault.\n   * @param _vault the vault for which the totalSupply balance is being decreased\n   * @param _amount the amount of balance being decreased\n   * @param _delegateAmount the amount of delegateBalance being decreased\n   */\n  function _decreaseBalances(\n    address _vault,\n    address _user,\n    uint96 _amount,\n    uint96 _delegateAmount\n  ) internal {\n    TwabLib.Account storage _account = userObservations[_vault][_user];\n\n    (\n      ObservationLib.Observation memory _observation,\n      bool _isNewObservation,\n      bool _isObservationRecorded\n    ) = TwabLib.decreaseBalances(\n        PERIOD_LENGTH,\n        PERIOD_OFFSET,\n        _account,\n        _amount,\n        _delegateAmount,\n        \"TC/observation-burn-lt-delegate-balance\"\n      );\n\n    // Always emit the balance change event\n    emit DecreasedBalance(_vault, _user, _amount, _delegateAmount);\n\n    // Conditionally emit the observation recorded event\n    if (_isObservationRecorded) {\n      emit ObservationRecorded(\n        _vault,\n        _user,\n        _account.details.balance,\n        _account.details.delegateBalance,\n        _isNewObservation,\n        _observation\n      );\n    }\n  }\n\n  /**\n   * @notice Decreases the totalSupply balance and delegateBalance for a specific vault.\n   * @param _vault the vault for which the totalSupply balance is being decreased\n   * @param _amount the amount of balance being decreased\n   * @param _delegateAmount the amount of delegateBalance being decreased\n   */\n  function _decreaseTotalSupplyBalances(\n    address _vault,\n    uint96 _amount,\n    uint96 _delegateAmount\n  ) internal {\n    TwabLib.Account storage _account = totalSupplyObservations[_vault];\n\n    (\n      ObservationLib.Observation memory _observation,\n      bool _isNewObservation,\n      bool _isObservationRecorded\n    ) = TwabLib.decreaseBalances(\n        PERIOD_LENGTH,\n        PERIOD_OFFSET,\n        _account,\n        _amount,\n        _delegateAmount,\n        \"TC/burn-amount-exceeds-total-supply-balance\"\n      );\n\n    // Always emit the balance change event\n    emit DecreasedTotalSupply(_vault, _amount, _delegateAmount);\n\n    // Conditionally emit the observation recorded event\n    if (_isObservationRecorded) {\n      emit TotalSupplyObservationRecorded(\n        _vault,\n        _account.details.balance,\n        _account.details.delegateBalance,\n        _isNewObservation,\n        _observation\n      );\n    }\n  }\n\n  /**\n   * @notice Increases the totalSupply balance and delegateBalance for a specific vault.\n   * @param _vault the vault for which the totalSupply balance is being increased\n   * @param _amount the amount of balance being increased\n   * @param _delegateAmount the amount of delegateBalance being increased\n   */\n  function _increaseTotalSupplyBalances(\n    address _vault,\n    uint96 _amount,\n    uint96 _delegateAmount\n  ) internal {\n    TwabLib.Account storage _account = totalSupplyObservations[_vault];\n\n    (\n      ObservationLib.Observation memory _observation,\n      bool _isNewObservation,\n      bool _isObservationRecorded\n    ) = TwabLib.increaseBalances(PERIOD_LENGTH, PERIOD_OFFSET, _account, _amount, _delegateAmount);\n\n    // Always emit the balance change event\n    emit IncreasedTotalSupply(_vault, _amount, _delegateAmount);\n\n    // Conditionally emit the observation recorded event\n    if (_isObservationRecorded) {\n      emit TotalSupplyObservationRecorded(\n        _vault,\n        _account.details.balance,\n        _account.details.delegateBalance,\n        _isNewObservation,\n        _observation\n      );\n    }\n  }\n}"
    },
    {
      "filename": "src/TwabController.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport { TwabLib } from \"./libraries/TwabLib.sol\";\nimport { ObservationLib } from \"./libraries/ObservationLib.sol\";\n\n/// @notice Emitted when an account already points to the same delegate address t"
    }
  ]
}