{
  "Title": "Ownership renouncement will grant a role to zero address",
  "Content": "##### Description\nAfter the ownership renouncement, the owner will be zero address, and it will be granted with `DEFAULT_ADMIN_ROLE` https://github.com/cryptoalgebra/Algebra/blob/6c22b64977e0b0266aec89470480df74977eb606/src/core/contracts/AlgebraFactory.sol#L165.\n\n##### Recommendation\nWe recommend adding a check that `owner` is not a zero address.\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/core/contracts/AlgebraFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport './libraries/Constants.sol';\n\nimport './interfaces/IAlgebraFactory.sol';\nimport './interfaces/IAlgebraPoolDeployer.sol';\nimport './interfaces/plugin/IAlgebraPluginFactory.sol';\n\nimport './AlgebraCommunityVault.sol';\n\nimport '@openzeppelin/contracts/access/Ownable2Step.sol';\nimport '@openzeppelin/contracts/access/AccessControlEnumerable.sol';\n\n/// @title Algebra factory\n/// @notice Is used to deploy pools and its plugins\n/// @dev Version: Algebra Integral\ncontract AlgebraFactory is IAlgebraFactory, Ownable2Step, AccessControlEnumerable {\n  /// @inheritdoc IAlgebraFactory\n  bytes32 public constant override POOLS_ADMINISTRATOR_ROLE = keccak256('POOLS_ADMINISTRATOR'); // it`s here for the public visibility of the value\n\n  /// @inheritdoc IAlgebraFactory\n  address public immutable override poolDeployer;\n\n  /// @inheritdoc IAlgebraFactory\n  address public immutable override communityVault;\n\n  /// @inheritdoc IAlgebraFactory\n  uint16 public override defaultCommunityFee;\n\n  /// @inheritdoc IAlgebraFactory\n  uint16 public override defaultFee;\n\n  /// @inheritdoc IAlgebraFactory\n  int24 public override defaultTickspacing;\n\n  /// @inheritdoc IAlgebraFactory\n  uint256 public override renounceOwnershipStartTimestamp;\n\n  /// @dev time delay before ownership renouncement can be finished\n  uint256 private constant RENOUNCE_OWNERSHIP_DELAY = 1 days;\n\n  /// @inheritdoc IAlgebraFactory\n  IAlgebraPluginFactory public defaultPluginFactory;\n\n  /// @inheritdoc IAlgebraFactory\n  mapping(address => mapping(address => address)) public override poolByPair;\n\n  /// @dev keccak256 of AlgebraPool init bytecode. Used to compute pool address deterministically\n  bytes32 private constant POOL_INIT_CODE_HASH = 0x6850df26deb431442e7ee6a953ade87dd82a8401a612ea683b545f83cd15e236;\n\n  constructor(address _poolDeployer) {\n    require(_poolDeployer != address(0));\n    poolDeployer = _poolDeployer;\n    communityVault = address(new AlgebraCommunityVault(msg.sender));\n    defaultTickspacing = Constants.INIT_DEFAULT_TICK_SPACING;\n    defaultFee = Constants.INIT_DEFAULT_FEE;\n\n    emit DefaultTickspacing(Constants.INIT_DEFAULT_TICK_SPACING);\n    emit DefaultFee(Constants.INIT_DEFAULT_FEE);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function owner() public view override(IAlgebraFactory, Ownable) returns (address) {\n    return super.owner();\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function hasRoleOrOwner(bytes32 role, address account) public view override returns (bool) {\n    return (owner() == account || super.hasRole(role, account));\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function defaultConfigurationForPool() external view returns (uint16 communityFee, int24 tickSpacing, uint16 fee) {\n    return (defaultCommunityFee, defaultTickspacing, defaultFee);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function computePoolAddress(address token0, address token1) public view override returns (address pool) {\n    pool = address(uint160(uint256(keccak256(abi.encodePacked(hex'ff', poolDeployer, keccak256(abi.encode(token0, token1)), POOL_INIT_CODE_HASH)))));\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function createPool(address tokenA, address tokenB) external override returns (address pool) {\n    require(tokenA != tokenB);\n    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0));\n    require(poolByPair[token0][token1] == address(0));\n\n    address defaultPlugin;\n    if (address(defaultPluginFactory) != address(0)) {\n      defaultPlugin = defaultPluginFactory.createPlugin(computePoolAddress(token0, token1));\n    }\n\n    pool = IAlgebraPoolDeployer(poolDeployer).deploy(address(defaultPlugin), token0, token1);\n\n    poolByPair[token0][token1] = pool; // to avoid future addresses comparison we are populating the mapping twice\n    poolByPair[token1][token0] = pool;\n    emit Pool(token0, token1, pool);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setDefaultCommunityFee(uint16 newDefaultCommunityFee) external override onlyOwner {\n    require(newDefaultCommunityFee <= Constants.MAX_COMMUNITY_FEE);\n    require(defaultCommunityFee != newDefaultCommunityFee);\n    defaultCommunityFee = newDefaultCommunityFee;\n    emit DefaultCommunityFee(newDefaultCommunityFee);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setDefaultFee(uint16 newDefaultFee) external override onlyOwner {\n    require(newDefaultFee <= Constants.MAX_DEFAULT_FEE);\n    require(defaultFee != newDefaultFee);\n    defaultFee = newDefaultFee;\n    emit DefaultFee(newDefaultFee);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setDefaultTickspacing(int24 newDefaultTickspacing) external override onlyOwner {\n    require(newDefaultTickspacing >= Constants.MIN_TICK_SPACING);\n    require(newDefaultTickspacing <= Constants.MAX_TICK_SPACING);\n    require(newDefaultTickspacing != defaultTickspacing);\n    defaultTickspacing = newDefaultTickspacing;\n    emit DefaultTickspacing(newDefaultTickspacing);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setDefaultPluginFactory(address newDefaultPluginFactory) external override onlyOwner {\n    require(newDefaultPluginFactory != address(defaultPluginFactory));\n    defaultPluginFactory = IAlgebraPluginFactory(newDefaultPluginFactory);\n    emit DefaultPluginFactory(newDefaultPluginFactory);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function startRenounceOwnership() external override onlyOwner {\n    require(renounceOwnershipStartTimestamp == 0);\n    renounceOwnershipStartTimestamp = block.timestamp;\n    emit RenounceOwnershipStart(renounceOwnershipStartTimestamp, renounceOwnershipStartTimestamp + RENOUNCE_OWNERSHIP_DELAY);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function stopRenounceOwnership() external override onlyOwner {\n    require(renounceOwnershipStartTimestamp != 0);\n    renounceOwnershipStartTimestamp = 0;\n    emit RenounceOwnershipStop(block.timestamp);\n  }\n\n  /// @dev Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore.\n  /// Can only be called by the current owner if RENOUNCE_OWNERSHIP_DELAY seconds\n  /// have passed since the call to the startRenounceOwnership() function.\n  function renounceOwnership() public override onlyOwner {\n    require(renounceOwnershipStartTimestamp != 0);\n    require(block.timestamp - renounceOwnershipStartTimestamp >= RENOUNCE_OWNERSHIP_DELAY);\n    renounceOwnershipStartTimestamp = 0;\n\n    super.renounceOwnership();\n    emit RenounceOwnershipFinish(block.timestamp);\n  }\n\n  /// @dev Transfers ownership of the contract to a new account (`newOwner`).\n  /// Modified to fit with the role mechanism.\n  function _transferOwnership(address newOwner) internal override {\n    _revokeRole(DEFAULT_ADMIN_ROLE, owner());\n    super._transferOwnership(newOwner);\n    _grantRole(DEFAULT_ADMIN_ROLE, owner());\n  }\n}"
    }
  ]
}