{
  "Title": "[G-07] Division by two should use bit shifting",
  "Content": "\n`<x> / 2` is the same as `<x> >> 1`. The `DIV` opcode costs 5 gas, whereas `SHR` only costs 3 gas.\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol   #1\n\n275:          uint256 halfInvestment = investmentA / 2;\n```\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L275\n\n```solidity\nFile: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol   #2\n\n273:          uint256 halfInvestment = investmentA / 2;\n```\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L273\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-06-nested-finance-contest",
  "Code": [
    {
      "filename": "contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"../BeefyVaultStorage.sol\";\nimport \"./../../../libraries/ExchangeHelpers.sol\";\nimport \"./../../../interfaces/external/IBeefyVaultV6.sol\";\nimport \"./../../../interfaces/external/IBiswapRouter02.sol\";\nimport \"./../../../interfaces/external/IBiswapPair.sol\";\nimport \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title (Zapper) Beefy Biswap LP Vault Operator.\n/// @notice Deposit/Withdraw in a Beefy Biswap LP vault using zapper\n/// Note: \"Zap\" means that the asset is converted for the LP Token by\n///       swapping and adding liquidity.\ncontract BeefyZapBiswapLPVaultOperator {\n    using SafeERC20 for IERC20;\n\n    BeefyVaultStorage public immutable operatorStorage;\n\n    constructor(address[] memory vaults, address[] memory routers) {\n        uint256 vaultsLength = vaults.length;\n        require(vaultsLength == routers.length, \"BLVO: INVALID_VAULTS_LENGTH\");\n\n        operatorStorage = new BeefyVaultStorage();\n\n        for (uint256 i; i < vaultsLength; i++) {\n            operatorStorage.addVault(vaults[i], routers[i]);\n        }\n\n        operatorStorage.transferOwnership(msg.sender);\n    }\n\n    /// @notice Zap one of the paired tokens for the LP Token, deposit the\n    ///         asset in the Beefy vault and receive the vault token (moo).\n    /// @param vault The vault address to deposit into\n    /// @param token The token to zap\n    /// @param amountToDeposit The token amount to deposit\n    /// @param minVaultAmount The minimum vault token amount expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function deposit(\n        address vault,\n        IERC20 token,\n        uint256 amountToDeposit,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amountToDeposit != 0, \"BLVO: INVALID_AMOUNT\");\n        address router = operatorStorage.vaults(vault);\n        require(router != address(0), \"BLVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n\n        _zapAndStakeLp(router, IBeefyVaultV6(vault), address(token), amountToDeposit);\n\n        uint256 vaultAmount = IERC20(vault).balanceOf(address(this)) - vaultBalanceBefore;\n        uint256 depositedAmount = tokenBalanceBefore - token.balanceOf(address(this));\n\n        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BLVO: INVALID_AMOUNT_RECEIVED\");\n        require(depositedAmount != 0 && amountToDeposit >= depositedAmount, \"BLVO: INVALID_AMOUNT_DEPOSITED\");\n\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n\n        // Output amounts\n        amounts[0] = vaultAmount;\n        amounts[1] = depositedAmount;\n\n        // Output token\n        tokens[0] = vault;\n        tokens[1] = address(token);\n    }\n\n    /// @notice Withdraw the vault token (moo) from Beefy and receive\n    ///         one of the paired tokens\n    /// @param vault The vault address to withdraw from\n    /// @param amount The vault token amount to withdraw\n    /// @param token One of the paired token\n    /// @param minTokenAmount The minimum token amount expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw(\n        address vault,\n        uint256 amount,\n        IERC20 token,\n        uint256 minTokenAmount\n    ) external returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"BLVO: INVALID_AMOUNT\");\n        address router = operatorStorage.vaults(vault);\n        require(router != address(0), \"BLVO: INVALID_VAULT\");\n\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n\n        _withdrawAndSwap(router, vault, amount, address(token));\n\n        uint256 tokenAmount = token.balanceOf(address(this)) - tokenBalanceBefore;\n        uint256 vaultAmount = vaultBalanceBefore - IERC20(vault).balanceOf(address(this));\n        require(vaultAmount == amount, \"BLVO: INVALID_AMOUNT_WITHDRAWED\");\n        require(tokenAmount >= minTokenAmount, \"BLVO: INVALID_OUTPUT_AMOUNT\");\n\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n\n        // Output amounts\n        amounts[0] = tokenAmount;\n        amounts[1] = amount;\n\n        // Output token\n        tokens[0] = address(token);\n        tokens[1] = vault;\n    }\n\n    /// @notice Perform a vault token withdraw (moo) from Beefy, and\n    ///         transfer the rest as one of the paired token\n    /// @param router The Uniswap v2 router address to use for swapping and adding liquidity\n    /// @param vault The vault address to withdraw from\n    /// @param amount The vault token amount to withdraw\n    /// @param token One of the paired token\n    function _withdrawAndSwap(\n        address router,\n        address vault,\n        uint256 amount,\n        address token\n    ) private {\n        address pair = IBeefyVaultV6(vault).want();\n\n        uint256 pairBalanceBefore = IERC20(pair).balanceOf(address(this));\n        IBeefyVaultV6(vault).withdraw(amount);\n\n        address token0 = IUniswapV2Pair(pair).token0();\n        address token1 = IUniswapV2Pair(pair).token1();\n        require(token0 == token || token1 == token, \"BLVO: INVALID_TOKEN\");\n\n        // LP Tokens needs to be sent back to the pair address to be burned\n        IERC20(pair).safeTransfer(pair, IERC20(pair).balanceOf(address(this)) - pairBalanceBefore);\n\n        // Remove liquidity by burning the LP Token and not\n        // by calling `removeLiquidity` since we are checking the final\n        // output amount (minTokenAmount).\n        (uint256 amount0, uint256 amount1) = IUniswapV2Pair(pair).burn(address(this));\n        uint256 tokenAmountIn;\n\n        address swapToken;\n        if (token1 == token) {\n            swapToken = token0;\n            tokenAmountIn = amount0;\n        } else {\n            swapToken = token1;\n            tokenAmountIn = amount1;\n        }\n\n        ExchangeHelpers.setMaxAllowance(IERC20(swapToken), router);\n\n        address[] memory path = new address[](2);\n        path[0] = swapToken;\n        path[1] = token;\n\n        // Slippage 100% since we are checking the final amount (minTokenAmount) for the slippage\n        IBiswapRouter02(router).swapExactTokensForTokens(tokenAmountIn, 0, path, address(this), block.timestamp);\n    }\n\n    /// @dev Zap one of the paired tokens for the LP Token, deposit the\n    ///         asset in the Beefy vault and receive the vault token (moo)\n    /// @param router The Uniswap v2 router address to use for swapping and adding liquidity\n    /// @param vault The vault address to deposit into\n    /// @param token The token to zap\n    /// @param amount The token amount to deposit\n    function _zapAndStakeLp(\n        address router,\n        IBeefyVaultV6 vault,\n        address token,\n        uint256 amount\n    ) private {\n        IBiswapRouter02 biswapRouter = IBiswapRouter02(router);\n        IBiswapPair pair = IBiswapPair(vault.want());\n\n        require(pair.factory() == biswapRouter.factory(), \"BLVO: INVALID_VAULT\");\n\n        ExchangeHelpers.setMaxAllowance(IERC20(address(pair)), address(vault));\n\n        address cachedToken0 = pair.token0();\n        address cachedToken1 = pair.token1();\n\n        ExchangeHelpers.setMaxAllowance(IERC20(cachedToken0), router);\n        ExchangeHelpers.setMaxAllowance(IERC20(cachedToken1), router);\n\n        bool isInput0 = cachedToken0 == token;\n        require(isInput0 || cachedToken1 == token, \"BLVO: INVALID_INPUT_TOKEN\");\n\n        address[] memory path = new address[](2);\n        path[0] = token;\n\n        if (isInput0) {\n            path[1] = cachedToken1;\n        } else {\n            path[1] = cachedToken0;\n        }\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        // The amount of input token to swap\n        // to get the same value of output token\n        uint256 swapAmountIn;\n        if (isInput0) {\n            swapAmountIn = _getOptimalSwapAmount(amount, reserve0, reserve1, biswapRouter, pair);\n        } else {\n            swapAmountIn = _getOptimalSwapAmount(amount, reserve1, reserve0, biswapRouter, pair);\n        }\n\n        uint256 lpAmount = _swapAndAddLiquidity(amount, swapAmountIn, path, biswapRouter);\n        vault.deposit(lpAmount);\n    }\n\n    /// @dev Swap input tokenA into TokenB to get the same value in tokenA\n    ///         as in tokenB to then add liquidity and store the obtained LP\n    ///         token in the vault beefy.\n    /// Note : path.length must be equal to 2 with path[0] = tokenA and path[1] = tokenB\n    /// @param amount The amount of tokenA to invest\n    /// @param swapAmountIn The amount of tokenA to swap for tokenB\n    /// @param path An array of the two paired token addresses\n    /// @param biswapRouter The uniswapV2 router to be used for swap and liquidity addition\n    function _swapAndAddLiquidity(\n        uint256 amount,\n        uint256 swapAmountIn,\n        address[] memory path,\n        IBiswapRouter02 biswapRouter\n    ) private returns (uint256 mintedLpAmount) {\n        uint256[] memory swappedAmounts = biswapRouter.swapExactTokensForTokens(\n            swapAmountIn,\n            1,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        (, , mintedLpAmount) = biswapRouter.addLiquidity(\n            path[0],\n            path[1],\n            amount - swappedAmounts[0],\n            swappedAmounts[1],\n            1,\n            1,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    /// @dev Calculate the optimal amount of tokenA to swap to obtain\n    ///         the same market value of tokenB after the trade.\n    ///         This allows to add as many tokensA and tokensB as possible\n    ///         to the liquidity to minimize the remaining amount.\n    /// @param investmentA The total amount of tokenA to invest\n    /// @param pair The IBiswapPair to be used\n    function _getOptimalSwapAmount(\n        uint256 investmentA,\n        uint256 reserveA,\n        uint256 reserveB,\n        IBiswapRouter02 router,\n        IBiswapPair pair\n    ) private view returns (uint256 swapAmount) {\n        require(reserveA > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\");\n        require(reserveB > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\");\n\n        // The initial plan is to swap half of tokenA total amount to add liquidity\n        uint256 halfInvestment = investmentA / 2;\n\n        // Get the tokenB output for swapping tokenA (with the given reserves)\n        uint256 nominator = router.getAmountOut(halfInvestment, reserveA, reserveB, pair.swapFee());\n\n        // Get the amount of reserveB token representing equivalent value after swapping\n        // tokenA for tokenB (previous operation).\n        uint256 denominator = router.quote(halfInvestment, reserveA + halfInvestment, reserveB - nominator);\n\n        // Equivalent of the simplification of a quadratic equation (ax² + bx + c = 0)\n        // See : \"optimal swap amount\" in readme\n        swapAmount = investmentA - Babylonian.sqrt((halfInvestment * halfInvestment * nominator) / denominator);\n    }\n}"
    },
    {
      "filename": "contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"../BeefyVaultStorage.sol\";\nimport \"./../../../libraries/ExchangeHelpers.sol\";\nimport \"./../../../interfaces/external/IBeefyVaultV6.sol\";\nimport \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title (Zapper) Beefy UniswapV2 LP Vault Operator.\n/// @notice Deposit/Withdraw in a Beefy UniswapV2 LP vault using zapper\n/// Note: \"Zap\" means that the asset is converted for the LP Token by\n///       swapping and adding liquidity.\ncontract BeefyZapUniswapLPVaultOperator {\n    using SafeERC20 for IERC20;\n\n    BeefyVaultStorage public immutable operatorStorage;\n\n    constructor(address[] memory vaults, address[] memory routers) {\n        uint256 vaultsLength = vaults.length;\n        require(vaultsLength == routers.length, \"BLVO: INVALID_VAULTS_LENGTH\");\n\n        operatorStorage = new BeefyVaultStorage();\n\n        for (uint256 i; i < vaultsLength; i++) {\n            operatorStorage.addVault(vaults[i], routers[i]);\n        }\n\n        operatorStorage.transferOwnership(msg.sender);\n    }\n\n    /// @notice Zap one of the paired tokens for the LP Token, deposit the\n    ///         asset in the Beefy vault and receive the vault token (moo).\n    /// @param vault The vault address to deposit into\n    /// @param token The token to zap\n    /// @param amountToDeposit The token amount to deposit\n    /// @param minVaultAmount The minimum vault token amount expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function deposit(\n        address vault,\n        IERC20 token,\n        uint256 amountToDeposit,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amountToDeposit != 0, \"BLVO: INVALID_AMOUNT\");\n        address router = operatorStorage.vaults(vault);\n        require(router != address(0), \"BLVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n\n        _zapAndStakeLp(router, IBeefyVaultV6(vault), address(token), amountToDeposit);\n\n        uint256 vaultAmount = IERC20(vault).balanceOf(address(this)) - vaultBalanceBefore;\n        uint256 depositedAmount = tokenBalanceBefore - token.balanceOf(address(this));\n\n        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BLVO: INVALID_AMOUNT_RECEIVED\");\n        require(depositedAmount != 0 && amountToDeposit >= depositedAmount, \"BLVO: INVALID_AMOUNT_DEPOSITED\");\n\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n\n        // Output amounts\n        amounts[0] = vaultAmount;\n        amounts[1] = depositedAmount;\n\n        // Output token\n        tokens[0] = vault;\n        tokens[1] = address(token);\n    }\n\n    /// @notice Withdraw the vault token (moo) from Beefy and receive\n    ///         one of the paired tokens\n    /// @param vault The vault address to withdraw from\n    /// @param amount The vault token amount to withdraw\n    /// @param token One of the paired token\n    /// @param minTokenAmount The minimum token amount expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw(\n        address vault,\n        uint256 amount,\n        IERC20 token,\n        uint256 minTokenAmount\n    ) external returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"BLVO: INVALID_AMOUNT\");\n        address router = operatorStorage.vaults(vault);\n        require(router != address(0), \"BLVO: INVALID_VAULT\");\n\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n\n        _withdrawAndSwap(router, vault, amount, address(token));\n\n        uint256 tokenAmount = token.balanceOf(address(this)) - tokenBalanceBefore;\n        uint256 vaultAmount = vaultBalanceBefore - IERC20(vault).balanceOf(address(this));\n        require(vaultAmount == amount, \"BLVO: INVALID_AMOUNT_WITHDRAWED\");\n        require(tokenAmount >= minTokenAmount, \"BLVO: INVALID_OUTPUT_AMOUNT\");\n\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n\n        // Output amounts\n        amounts[0] = tokenAmount;\n        amounts[1] = amount;\n\n        // Output token\n        tokens[0] = address(token);\n        tokens[1] = vault;\n    }\n\n    /// @notice Perform a vault token withdraw (moo) from Beefy, and\n    ///         transfer the rest as one of the paired token\n    /// @param router The Uniswap v2 router address to use for swapping and adding liquidity\n    /// @param vault The vault address to withdraw from\n    /// @param amount The vault token amount to withdraw\n    /// @param token One of the paired token\n    function _withdrawAndSwap(\n        address router,\n        address vault,\n        uint256 amount,\n        address token\n    ) private {\n        address pair = IBeefyVaultV6(vault).want();\n\n        uint256 pairBalanceBefore = IERC20(pair).balanceOf(address(this));\n        IBeefyVaultV6(vault).withdraw(amount);\n\n        address token0 = IUniswapV2Pair(pair).token0();\n        address token1 = IUniswapV2Pair(pair).token1();\n        require(token0 == token || token1 == token, \"BLVO: INVALID_TOKEN\");\n\n        // LP Tokens needs to be sent back to the pair address to be burned\n        IERC20(pair).safeTransfer(pair, IERC20(pair).balanceOf(address(this)) - pairBalanceBefore);\n\n        // Remove liquidity by burning the LP Token and not\n        // by calling `removeLiquidity` since we are checking the final\n        // output amount (minTokenAmount).\n        (uint256 amount0, uint256 amount1) = IUniswapV2Pair(pair).burn(address(this));\n        uint256 tokenAmountIn;\n\n        address swapToken;\n        if (token1 == token) {\n            swapToken = token0;\n            tokenAmountIn = amount0;\n        } else {\n            swapToken = token1;\n            tokenAmountIn = amount1;\n        }\n\n        ExchangeHelpers.setMaxAllowance(IERC20(swapToken), router);\n\n        address[] memory path = new address[](2);\n        path[0] = swapToken;\n        path[1] = token;\n\n        // Slippage 100% since we are checking the final amount (minTokenAmount) for the slippage\n        IUniswapV2Router02(router).swapExactTokensForTokens(tokenAmountIn, 0, path, address(this), block.timestamp);\n    }\n\n    /// @dev Zap one of the paired tokens for the LP Token, deposit the\n    ///         asset in the Beefy vault and receive the vault token (moo)\n    /// @param router The Uniswap v2 router address to use for swapping and adding liquidity\n    /// @param vault The vault address to deposit into\n    /// @param token The token to zap\n    /// @param amount The token amount to deposit\n    function _zapAndStakeLp(\n        address router,\n        IBeefyVaultV6 vault,\n        address token,\n        uint256 amount\n    ) private {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(router);\n        IUniswapV2Pair pair = IUniswapV2Pair(vault.want());\n\n        require(pair.factory() == uniswapRouter.factory(), \"BLVO: INVALID_VAULT\");\n\n        ExchangeHelpers.setMaxAllowance(IERC20(address(pair)), address(vault));\n\n        address cachedToken0 = pair.token0();\n        address cachedToken1 = pair.token1();\n\n        ExchangeHelpers.setMaxAllowance(IERC20(cachedToken0), router);\n        ExchangeHelpers.setMaxAllowance(IERC20(cachedToken1), router);\n\n        bool isInput0 = cachedToken0 == token;\n        require(isInput0 || cachedToken1 == token, \"BLVO: INVALID_INPUT_TOKEN\");\n\n        address[] memory path = new address[](2);\n        path[0] = token;\n\n        if (isInput0) {\n            path[1] = cachedToken1;\n        } else {\n            path[1] = cachedToken0;\n        }\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        // The amount of input token to swap\n        // to get the same value of output token\n        uint256 swapAmountIn;\n        if (isInput0) {\n            swapAmountIn = _getOptimalSwapAmount(amount, reserve0, reserve1, uniswapRouter);\n        } else {\n            swapAmountIn = _getOptimalSwapAmount(amount, reserve1, reserve0, uniswapRouter);\n        }\n\n        uint256 lpAmount = _swapAndAddLiquidity(amount, swapAmountIn, path, uniswapRouter);\n        vault.deposit(lpAmount);\n    }\n\n    /// @dev Swap input tokenA into TokenB to get the same value in tokenA\n    ///         as in tokenB to then add liquidity and store the obtained LP\n    ///         token in the vault beefy.\n    /// Note : path.length must be equal to 2 with path[0] = tokenA and path[1] = tokenB\n    /// @param amount The amount of tokenA to invest\n    /// @param swapAmountIn The amount of tokenA to swap for tokenB\n    /// @param path An array of the two paired token addresses\n    /// @param uniswapRouter The uniswapV2 router to be used for swap and liquidity addition\n    function _swapAndAddLiquidity(\n        uint256 amount,\n        uint256 swapAmountIn,\n        address[] memory path,\n        IUniswapV2Router02 uniswapRouter\n    ) private returns (uint256 mintedLpAmount) {\n        uint256[] memory swappedAmounts = uniswapRouter.swapExactTokensForTokens(\n            swapAmountIn,\n            1,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        (, , mintedLpAmount) = uniswapRouter.addLiquidity(\n            path[0],\n            path[1],\n            amount - swappedAmounts[0],\n            swappedAmounts[1],\n            1,\n            1,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    /// @dev Calculate the optimal amount of tokenA to swap to obtain\n    ///         the same market value of tokenB after the trade.\n    ///         This allows to add as many tokensA and tokensB as possible\n    ///         to the liquidity to minimize the remaining amount.\n    /// @param investmentA The total amount of tokenA to invest\n    function _getOptimalSwapAmount(\n        uint256 investmentA,\n        uint256 reserveA,\n        uint256 reserveB,\n        IUniswapV2Router02 router\n    ) private pure returns (uint256 swapAmount) {\n        require(reserveA > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\");\n        require(reserveB > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\");\n\n        // The initial plan is to swap half of tokenA total amount to add liquidity\n        uint256 halfInvestment = investmentA / 2;\n\n        // Get the tokenB output for swapping tokenA (with the given reserves)\n        uint256 nominator = router.getAmountOut(halfInvestment, reserveA, reserveB);\n\n        // Get the amount of reserveB token representing equivalent value after swapping\n        // tokenA for tokenB (previous operation).\n        uint256 denominator = router.quote(halfInvestment, reserveA + halfInvestment, reserveB - nominator);\n\n        // Equivalent of the simplification of a quadratic equation (ax² + bx + c = 0)\n        // See : \"optimal swap amount\" in readme\n        swapAmount = investmentA - Babylonian.sqrt((halfInvestment * halfInvestment * nominator) / denominator);\n    }\n}"
    }
  ]
}