{
  "Title": "[H-08] `VetoProposal`: User can veto multiple times so every proposal can be vetoed by any user that has a small amount of votes",
  "Content": "\nThe [`VetoProposal`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L8-L69) contract allows to veto proposals with the [`voteToVeto`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L19-L60) function.\n\nWhen the amount of votes collected to veto a proposal exceeds a certain threshold (the `passThresholdBps`, which is determined upon initialization of the party), the proposal is vetoed, meaning it cannot execute anymore (its status becomes `Defeated`).\n\nThe `passThresholdBps` specifies a percentage of the `totalVotingPower` of the party.\n\nE.g. `passThresholdBps=1000` means that 10% of the `totalVotingPower` must veto a proposal such that the veto goes through.\n\nThe issue is that the contract lacks the obvious check that a user has not vetoed before, thereby a user can veto multiple times.\n\nSo say a user holds 1% of `totalVotingPower` and in order for the veto to go through, 10% of `totalVotingPower` must veto.\n\nThe user can just veto 10 times to reach the 10% requirement.\n\nThe impact is obvious: Any user with a small amount of votes can veto any proposal. This is a critical bug since the party may become unable to perform any actions if there is a user that vetoes all proposals.\n\n### Proof of Concept\n\nAdd the following test to the `VetoProposal.t.sol` test file:\n\n```solidity\nfunction test_VetoMoreThanOnce() public {\n    _assertProposalStatus(PartyGovernance.ProposalStatus.Voting);\n\n    // Vote to veto\n    vm.prank(voter1);\n    vetoProposal.voteToVeto(party, proposalId, 0);\n\n    _assertProposalStatus(PartyGovernance.ProposalStatus.Voting);\n    assertEq(vetoProposal.vetoVotes(party, proposalId), 1e18);\n\n    // Vote to veto (passes threshold)\n    vm.prank(voter1);\n    vetoProposal.voteToVeto(party, proposalId, 0);\n\n    _assertProposalStatus(PartyGovernance.ProposalStatus.Defeated);\n    assertEq(vetoProposal.vetoVotes(party, proposalId), 0); // Cleared after proposal is vetoed\n}\n```\n\nIn the test file, these are the conditions: `totalVotingPower = 3e18`, required votes threshold is 51%, `voter1` has `1e18` votes which is `~33%`. Clearly `voter1` should not be able to veto the proposal on his own.\n\nYou can see in the test that `voter1` can veto 2 times.\n\nAfter the first call to `voteToVeto`, the threshold is not yet reached (the proposal is still in the `Voting` state).\n\nAfter the second call to `voteToVeto` the threshold is reached and the proposal is in the `Defeated` state.\n\n### Tools Used\n\nVSCode, Foundry\n\n### Recommended Mitigation Steps\n\nThe fix is straightforward.\n\nWe introduce a `hasVoted` mapping that tracks for each `(party, proposalId, address)` triplet if it has vetoed already.\n\nFix:\n\n```diff\ndiff --git a/contracts/proposals/VetoProposal.sol b/contracts/proposals/VetoProposal.sol\nindex 780826f..fb1f1ab 100644\n--- a/contracts/proposals/VetoProposal.sol\n+++ b/contracts/proposals/VetoProposal.sol\n@@ -8,9 +8,11 @@ import \"../party/Party.sol\";\n contract VetoProposal {\n     error NotPartyHostError();\n     error ProposalNotActiveError(uint256 proposalId);\n+    error AlreadyVotedError(address caller);\n \n     /// @notice Mapping from party to proposal ID to votes to veto the proposal.\n     mapping(Party => mapping(uint256 => uint96)) public vetoVotes;\n+    mapping(Party => mapping(uint256 => mapping(address => bool))) public hasVoted;\n \n     /// @notice Vote to veto a proposal.\n     /// @param party The party to vote on.\n@@ -33,6 +35,12 @@ contract VetoProposal {\n         if (proposalStatus != PartyGovernance.ProposalStatus.Voting)\n             revert ProposalNotActiveError(proposalId);\n \n+        if (hasVoted[party][proposalId][msg.sender]) {\n+            revert AlreadyVotedError(msg.sender);\n+        }\n+\n+        hasVoted[party][proposalId][msg.sender] = true;\n+\n         // Increase the veto vote count\n         uint96 votingPower = party.getVotingPowerAt(\n             msg.sender,\n```\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-04-party-findings/issues/2#issuecomment-1512069305)**\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-04-party",
  "Code": [
    {
      "filename": "contracts/proposals/VetoProposal.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../party/Party.sol\";\n\n/// @notice A contract that allows members of a party that has this contract as\n///         a host to vote to veto a proposal.\ncontract VetoProposal {\n    error NotPartyHostError();\n    error ProposalNotActiveError(uint256 proposalId);\n\n    /// @notice Mapping from party to proposal ID to votes to veto the proposal.\n    mapping(Party => mapping(uint256 => uint96)) public vetoVotes;\n\n    /// @notice Vote to veto a proposal.\n    /// @param party The party to vote on.\n    /// @param proposalId The ID of the proposal to veto.\n    /// @param snapIndex The index of the snapshot to use for voting power.\n    function voteToVeto(Party party, uint256 proposalId, uint256 snapIndex) external {\n        uint96 votes = vetoVotes[party][proposalId];\n\n        // No need to perform following check more than once for party\n        if (votes == 0) {\n            // Check if this contract is a host of the party\n            if (!party.isHost(address(this))) revert NotPartyHostError();\n        }\n\n        // Check that proposal is active\n        (\n            PartyGovernance.ProposalStatus proposalStatus,\n            PartyGovernance.ProposalStateValues memory proposalValues\n        ) = party.getProposalStateInfo(proposalId);\n        if (proposalStatus != PartyGovernance.ProposalStatus.Voting)\n            revert ProposalNotActiveError(proposalId);\n\n        // Increase the veto vote count\n        uint96 votingPower = party.getVotingPowerAt(\n            msg.sender,\n            proposalValues.proposedTime - 1,\n            snapIndex\n        );\n        uint96 newVotes = votes + votingPower;\n\n        // Check if the vote to veto is passing\n        PartyGovernance.GovernanceValues memory governanceValues = party.getGovernanceValues();\n        if (\n            _areVotesPassing(\n                newVotes,\n                governanceValues.totalVotingPower,\n                governanceValues.passThresholdBps\n            )\n        ) {\n            // If so, veto the proposal and clear the vote count\n            party.veto(proposalId);\n            delete vetoVotes[party][proposalId];\n        } else {\n            // If not, update the vote count\n            vetoVotes[party][proposalId] = newVotes;\n        }\n    }\n\n    function _areVotesPassing(\n        uint96 voteCount,\n        uint96 totalVotingPower,\n        uint16 passThresholdBps\n    ) private pure returns (bool) {\n        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);\n    }\n}"
    }
  ]
}