{
  "Title": "[M-04] `CvxCrvRewardsLocker` implements a swap without a slippage check that can result in a loss of funds through MEV",
  "Content": "_Submitted by Ruhum_\n\nThe CvxCrvRewardsLocker contract swaps tokens through the CRV cvxCRV pool. But, it doesn't use any slippage checks. The swap is at risk of being frontrun / sandwiched which will result in a loss of funds.\n\nSince MEV is very prominent I think the chance of that happening is pretty high.\n\n### Proof of Concept\n\nHere's the swap: [CvxCrvRewardsLocker.sol#L247-L252](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/CvxCrvRewardsLocker.sol#L247-L252).\n\n### Recommended Mitigation Steps\n\nUse a proper value for `minOut` instead of `0`.\n\n**[chase-manning (Backd) confirmed](https://github.com/code-423n4/2022-04-backd-findings/issues/161)**\n\n**[gzeon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-04-backd-findings/issues/161#issuecomment-1120269300):**\n > According to [C4 Judging criteria](https://docs.code4rena.com/roles/judges/how-to-judge-a-contest#notes-on-judging):\n> > Unless there is something uniquely novel created by combining vectors, most submissions regarding vulnerabilities that are inherent to a particular system or the Ethereum network as a whole should be considered QA. Examples of such vulnerabilities include front running, sandwich attacks, and MEV. \n> \n> However since there is a configurable `minOut` that is deliberately set to 0, this seems to be a valid issue. I am judging this as Medium Risk.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-backd-contest",
  "Code": [
    {
      "filename": "backd/contracts/CvxCrvRewardsLocker.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./access/Authorization.sol\";\n\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/vendor/IRewardStaking.sol\";\nimport \"../interfaces/vendor/ICrvDepositor.sol\";\nimport \"../interfaces/vendor/IDelegation.sol\";\nimport \"../interfaces/vendor/IvlCvxExtraRewardDistribution.sol\";\nimport \"../interfaces/vendor/ICurveSwap.sol\";\nimport \"../interfaces/vendor/ICvxLocker.sol\";\nimport \"../interfaces/ICvxCrvRewardsLocker.sol\";\n\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/AddressProviderHelpers.sol\";\n\ncontract CvxCrvRewardsLocker is ICvxCrvRewardsLocker, Authorization {\n    using AddressProviderHelpers for IAddressProvider;\n\n    using SafeERC20 for IERC20;\n\n    // ERC20 tokens\n    address public constant CVX = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    address public constant CVX_CRV = address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n    address public constant CRV = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n\n    address public constant CVX_CRV_CRV_CURVE_POOL =\n        address(0x9D0464996170c6B9e75eED71c68B99dDEDf279e8); // cvxCRV/CRV Curve Pool\n    address public constant CRV_DEPOSITOR = address(0x8014595F2AB54cD7c604B00E9fb932176fDc86Ae); // Lock CRV for cvxCRV\n    address public constant CVX_CRV_STAKING = address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); // Stake cvxCRV and get rewards\n    address public constant CVX_LOCKER = address(0x72a19342e8F1838460eBFCCEf09F6585e32db86E); // CVX Locker\n    address public constant VL_CVX_EXTRA_REWARD_DISTRIBUTION =\n        address(0xDecc7d761496d30F30b92Bdf764fb8803c79360D);\n\n    uint256 public spendRatio;\n    bool public prepareWithdrawal;\n    address public treasury;\n\n    int128 private constant _CRV_INDEX = 0;\n    int128 private constant _CVX_CRV_INDEX = 1;\n\n    event NewSpendRatio(uint256 newSpendRatio);\n    event NewTreasury(address newTreasury);\n\n    constructor(IAddressProvider _addressProvider)\n        Authorization(_addressProvider.getRoleManager())\n    {\n        // Approve for locking CRV for cvxCRV\n        IERC20(CRV).safeApprove(CRV_DEPOSITOR, type(uint256).max);\n\n        // Approve for staking cvxCRV\n        IERC20(CVX_CRV).safeApprove(CVX_CRV_STAKING, type(uint256).max);\n\n        // Approve for cvxCRV/CRV Curve Pool Swaps\n        IERC20(CRV).safeApprove(CVX_CRV_CRV_CURVE_POOL, type(uint256).max);\n\n        // Approve CVX Locker\n        IERC20(CVX).safeApprove(CVX_LOCKER, type(uint256).max);\n\n        treasury = _addressProvider.getTreasury();\n    }\n\n    function lockCvx() external override {\n        _lockCvx();\n    }\n\n    function lockCrv() external override {\n        _lockCrv();\n    }\n\n    /**\n     * @notice Set spend ratio for CVX locking.\n     * @dev Spend ratio is the amount of CVX that should be donated to\n     * the Convex treasury to boost vote power. This needs to be enabled\n     * by Convex.\n     * @param _spendRatio New spend ratio to be used.\n     */\n    function setSpendRatio(uint256 _spendRatio) external onlyGovernance returns (bool) {\n        require(\n            _spendRatio <= ICvxLocker(CVX_LOCKER).maximumBoostPayment(),\n            Error.EXCEEDS_MAX_BOOST\n        );\n        spendRatio = _spendRatio;\n        emit NewSpendRatio(_spendRatio);\n        return true;\n    }\n\n    /**\n     * @notice Claim rewards from Convex.\n     * @dev Rewards to claim are for staked cvxCRV and locked CVX.\n     * @param lockAndStake If true, claimed reward tokens (CRV) will be locked and staked (CRV for cvxCRV and CVX for vlCVX).\n     */\n    function claimRewards(bool lockAndStake) external override returns (bool) {\n        ICvxLocker(CVX_LOCKER).getReward(address(this), false);\n\n        IRewardStaking(CVX_CRV_STAKING).getReward();\n\n        if (lockAndStake) {\n            lockRewards();\n        }\n        return true;\n    }\n\n    /**\n     * @notice Stakes cvxCRV in the cvxCRV rewards contract on Convex.\n     */\n    function stakeCvxCrv() external override returns (bool) {\n        return _stakeCvxCrv();\n    }\n\n    /**\n     * @notice Prepares a withdrawal of funds.\n     * @dev If this is set then no idle funds can get locked or staked.\n     */\n    function setWithdrawalFlag() external onlyGovernance {\n        prepareWithdrawal = true;\n    }\n\n    /**\n     * @notice Resets prepared withdrawal of funds.\n     */\n    function resetWithdrawalFlag() external onlyGovernance {\n        prepareWithdrawal = false;\n    }\n\n    /**\n     * @notice Processes exipred locks.\n     */\n    function processExpiredLocks(bool relock) external override returns (bool) {\n        if (relock) {\n            require(!prepareWithdrawal, Error.PREPARED_WITHDRAWAL);\n        }\n\n        if (relock) {\n            ICvxLocker(CVX_LOCKER).processExpiredLocks(relock);\n        } else {\n            ICvxLocker(CVX_LOCKER).withdrawExpiredLocksTo(treasury);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Set treasury to receive withdrawn funds.\n     */\n    function setTreasury(address _treasury) external onlyGovernance returns (bool) {\n        treasury = _treasury;\n        emit NewTreasury(treasury);\n        return true;\n    }\n\n    /**\n     * @notice Withdraw full amount of a token to the treasury.\n     * @param token Token to withdraw entire balance of.\n     */\n    function withdraw(address token) external onlyGovernance returns (bool) {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(treasury, balance);\n        return true;\n    }\n\n    /**\n     * @notice Withdraw cvxCRV to treasury.\n     * @dev Unstakes cvxCRV if it is staked.\n     */\n    function withdrawCvxCrv(uint256 amount) external onlyGovernance {\n        IRewardStaking(CVX_CRV_STAKING).withdraw(amount, true);\n        uint256 cvxcrvBal = IERC20(CVX_CRV).balanceOf(address(this));\n        if (cvxcrvBal > 0) {\n            IERC20(CVX_CRV).safeTransfer(treasury, cvxcrvBal);\n        }\n    }\n\n    function unstakeCvxCrv() external onlyGovernance {\n        unstakeCvxCrv(false);\n    }\n\n    function unstakeCvxCrv(uint256 amount, bool withdrawal) external onlyGovernance {\n        _unstakeCvxCrv(amount, withdrawal);\n    }\n\n    /**\n     * @notice Set delegate to receive vote weight.\n     */\n    function setDelegate(address delegateContract, address delegate) external onlyGovernance {\n        IDelegation(delegateContract).setDelegate(\"cvx.eth\", delegate);\n    }\n\n    /**\n     * @notice Clears a delegate for the msg.sender and a specific id.\n     */\n    function clearDelegate(address delegateContract) external onlyGovernance {\n        IDelegation(delegateContract).clearDelegate(\"cvx.eth\");\n    }\n\n    function forfeitRewards(address token, uint256 index) external onlyGovernance {\n        IvlCvxExtraRewardDistribution(VL_CVX_EXTRA_REWARD_DISTRIBUTION).forfeitRewards(\n            token,\n            index\n        );\n    }\n\n    /**\n     * @notice Lock CRV and CVX tokens.\n     * @dev CRV get locked for cvxCRV and staked on Convex.\n     */\n    function lockRewards() public returns (bool) {\n        _lockCrv();\n        _lockCvx();\n        return true;\n    }\n\n    /**\n     * @notice Withdraw an amount of a token to the treasury.\n     * @param token Token to withdraw.\n     * @param amount Amount of token to withdraw.\n     */\n    function withdraw(address token, uint256 amount) public onlyGovernance returns (bool) {\n        IERC20(token).safeTransfer(treasury, amount);\n        return true;\n    }\n\n    /**\n     * @notice Unstake cvxCRV from Convex.\n     */\n    function unstakeCvxCrv(bool withdrawal) public onlyGovernance {\n        uint256 staked = IRewardStaking(CVX_CRV_STAKING).balanceOf(address(this));\n        _unstakeCvxCrv(staked, withdrawal);\n    }\n\n    function _lockCrv() internal {\n        if (prepareWithdrawal) return;\n\n        uint256 currentBalance = IERC20(CRV).balanceOf(address(this));\n        if (currentBalance != 0) {\n            // Checks if we can get a better rate on Curve Pool\n            uint256 amountOut = ICurveSwap(CVX_CRV_CRV_CURVE_POOL).get_dy(\n                _CRV_INDEX,\n                _CVX_CRV_INDEX,\n                currentBalance\n            );\n            if (amountOut > currentBalance) {\n                ICurveSwap(CVX_CRV_CRV_CURVE_POOL).exchange(\n                    _CRV_INDEX,\n                    _CVX_CRV_INDEX,\n                    currentBalance,\n                    0\n                );\n            } else {\n                // Swap CRV for cxvCRV and stake\n                ICrvDepositor(CRV_DEPOSITOR).deposit(currentBalance, false, address(0));\n            }\n            IRewardStaking(CVX_CRV_STAKING).stakeAll();\n            return;\n        }\n\n        if (IERC20(CVX_CRV).balanceOf(address(this)) > 0)\n            IRewardStaking(CVX_CRV_STAKING).stakeAll();\n    }\n\n    function _lockCvx() internal {\n        // Locks CVX for vlCVX\n        if (prepareWithdrawal) return;\n        uint256 currentBalance = IERC20(CVX).balanceOf(address(this));\n        if (currentBalance == 0) return;\n        ICvxLocker(CVX_LOCKER).lock(address(this), currentBalance, spendRatio);\n    }\n\n    function _stakeCvxCrv() internal returns (bool) {\n        if (prepareWithdrawal) return false;\n\n        if (IERC20(CVX_CRV).balanceOf(address(this)) == 0) return false;\n        IRewardStaking(CVX_CRV_STAKING).stakeAll();\n        return true;\n    }\n\n    function _unstakeCvxCrv(uint256 amount, bool withdrawal) internal {\n        IRewardStaking(CVX_CRV_STAKING).withdraw(amount, true);\n        if (withdrawal) {\n            IERC20(CVX_CRV).safeTransfer(treasury, amount);\n        }\n    }\n}"
    }
  ]
}