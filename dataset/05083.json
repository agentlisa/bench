{
  "Title": "[G-11] Check `amount` for `zero` before mint/burn (Missed by bot)",
  "Content": "\n**Note: Bot only covers check 0 value transfers in tranfser and transferFrom but not covered when minting and burning 0 amounts.**\n\n0 amount burning and minting doesn't have any effect but just wastes gas when 0 value passed by mistake in mint/burn. Openzeppelin(used here) `mint/burn` will not revert when 0 amount passed. So it is better to revert early when amount is 0 in mint/burn rather than wasting more gas in 0 value minting/burning.\n\n```solidity\nFile : src/tokens/YieldToken.sol\n\n42:    function burnWithoutUpdate(address from, uint256 amount) external override {\n43:        if (msg.sender != pt) {\n44:            revert CallerIsNotPtContract();\n45:        }\n46:        _burn(from, amount); //@audit gas check amount for 0\n47:    }\n\n\n50:    function mint(address to, uint256 amount) external override {\n51:        if (msg.sender != pt) {\n52:            revert CallerIsNotPtContract();\n53:        }\n54:        _mint(to, amount);//@audit gas check amount for 0\n55:    }\n\n\n58:    function burn(uint256 amount) public override {\n59:        IPrincipalToken(pt).updateYield(msg.sender);\n60:        _burn(msg.sender, amount);//@audit gas check amount for 0\n61:    }\n\n```\n(https://github.com/code-423n4/2024-02-spectra/blob/main/src/tokens/YieldToken.sol#L42C1-L47C6), (https://github.com/code-423n4/2024-02-spectra/blob/main/src/tokens/YieldToken.sol#L50C5-L55C6), (https://github.com/code-423n4/2024-02-spectra/blob/main/src/tokens/YieldToken.sol#L58C5-L61C6)    \n\n\n**[jeanchambras (sponsor) acknowledged and commented](https://github.com/code-423n4/2024-02-spectra-findings/issues/300#issuecomment-1981429157):**\n >We dispute G-06 because the way we do it, other modifiers are also impacted by the nonReentrant one which is a good practice.\n >\n > Regarding G-09 and G-11, we acknowledge those, but won't be tackling them since we trust Open Zeppelin contracts.\n\n >Mitigated G-01, G-02, G-04, G-05, G-07, and G-10 [here](https://github.com/perspectivefi/spectra-core/commit/085198ab489842edb34a795017e603ad39c5eee7).\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-spectra",
  "Code": [
    {
      "filename": "src/tokens/YieldToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport \"openzeppelin-math/Math.sol\";\nimport \"openzeppelin-erc20-extensions/ERC20PermitUpgradeable.sol\";\nimport \"openzeppelin-erc20-basic/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/IPrincipalToken.sol\";\nimport \"../interfaces/IYieldToken.sol\";\n\n/**\n * @title Yield Token contract\n * @notice A YieldToken (YT) is a Spectra token that keeps track of users' yield ownership. It is minted at same times and amounts as a PT.\n */\ncontract YieldToken is IYieldToken, ERC20PermitUpgradeable {\n    using Math for uint256;\n\n    address private pt;\n\n    // constructor\n    constructor() {\n        _disableInitializers(); // using this so that the deployed logic contract later cannot be initialized.\n    }\n\n    /**\n     * @notice Initializer of the contract.\n     * @param _name The name of the yt token.\n     * @param _symbol The symbol of the yt token.\n     * @param _pt The address of the pt associated with this yt token.\n     */\n    function initialize(\n        string calldata _name,\n        string calldata _symbol,\n        address _pt\n    ) external initializer {\n        __ERC20_init(_name, _symbol);\n        __ERC20Permit_init(_name);\n        pt = _pt;\n    }\n\n    /** @dev See {IYieldToken-burnWithoutUpdate} */\n    function burnWithoutUpdate(address from, uint256 amount) external override {\n        if (msg.sender != pt) {\n            revert CallerIsNotPtContract();\n        }\n        _burn(from, amount);\n    }\n\n    /** @dev See {IYieldToken-mint} */\n    function mint(address to, uint256 amount) external override {\n        if (msg.sender != pt) {\n            revert CallerIsNotPtContract();\n        }\n        _mint(to, amount);\n    }\n\n    /** @dev See {IYieldToken-burn} */\n    function burn(uint256 amount) public override {\n        IPrincipalToken(pt).updateYield(msg.sender);\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(\n        address to,\n        uint256 amount\n    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {\n        IPrincipalToken(pt).beforeYtTransfer(msg.sender, to);\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {\n        IPrincipalToken(pt).beforeYtTransfer(from, to);\n        return super.transferFrom(from, to, amount);\n    }\n\n    /** @dev See {IERC20Upgradeable-decimals} */\n    function decimals()\n        public\n        view\n        virtual\n        override(IYieldToken, ERC20Upgradeable)\n        returns (uint8)\n    {\n        return IERC20Metadata(pt).decimals();\n    }\n\n    /** @dev See {IYieldToken-getPT} */\n    function getPT() public view virtual override returns (address) {\n        return pt;\n    }\n\n    /** @dev See {IYieldToken-balanceOf} */\n    function balanceOf(\n        address account\n    ) public view override(IYieldToken, ERC20Upgradeable) returns (uint256) {\n        return (block.timestamp < IPrincipalToken(pt).maturity()) ? super.balanceOf(account) : 0;\n    }\n\n    /** @dev See {IYieldToken-actualBalanceOf} */\n    function actualBalanceOf(address account) public view override returns (uint256) {\n        return super.balanceOf(account);\n    }\n}"
    }
  ]
}