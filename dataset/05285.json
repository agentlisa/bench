{
  "Title": "[06] Flash loan interface deviates from ERC-3156 specification",
  "Content": "\nThe current implementation of the [`flash_mint`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/flash_mint.cairo) module only has methods in `snake_case`. However, the [ERC-3156](https://eips.ethereum.org/EIPS/eip-3156) specification requires the lender's and receiver's methods in `camelCase` which could lead to severe interoperability problems.  \n\n### Recommendation\n\nAdditionally, add the `camelCase` implementation which forwards to the original methods. For reference, see the [Shrine's Yin ERC-20 implementation](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/shrine.cairo#L2281-L2296) where `camelCase` support was already implemented.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-opus",
  "Code": [
    {
      "filename": "src/core/shrine.cairo",
      "content": "#[starknet::contract]\nmod shrine {\n    use access_control::access_control_component;\n    use cmp::{max, min};\n    use core::starknet::event::EventEmitter;\n    use integer::{BoundedU256, U256Zeroable, u256_safe_div_rem};\n    use opus::core::roles::shrine_roles;\n    use opus::interfaces::IERC20::{IERC20, IERC20CamelOnly};\n    use opus::interfaces::ISRC5::ISRC5;\n    use opus::interfaces::IShrine::IShrine;\n    use opus::types::{\n        ExceptionalYangRedistribution, Health, Trove, YangBalance, YangRedistribution, YangSuspensionStatus\n    };\n    use opus::utils::exp::{exp, neg_exp};\n    use starknet::contract_address::{ContractAddress, ContractAddressZeroable};\n    use starknet::{get_block_timestamp, get_caller_address};\n    use wadray::{BoundedRay, Ray, RayZeroable, RAY_ONE, SignedWad, Wad, WadZeroable, WAD_DECIMALS, WAD_ONE, WAD_SCALE};\n\n    //\n    // Components\n    //\n\n    component!(path: access_control_component, storage: access_control, event: AccessControlEvent);\n\n    #[abi(embed_v0)]\n    impl AccessControlPublic = access_control_component::AccessControl<ContractState>;\n    impl AccessControlHelpers = access_control_component::AccessControlHelpers<ContractState>;\n\n    //\n    // Constants\n    //\n\n    // Initial multiplier value to ensure `get_recent_multiplier_from` terminates - (ray): RAY_ONE\n    const INITIAL_MULTIPLIER: u128 = 1000000000000000000000000000;\n    const MAX_MULTIPLIER: u128 = 10000000000000000000000000000; // Max of 10x (ray): 10 * RAY_ONE\n\n    const MAX_THRESHOLD: u128 = 1000000000000000000000000000; // (ray): RAY_ONE\n\n    // If a yang is deemed risky, it can be marked as suspended. During the\n    // SUSPENSION_GRACE_PERIOD, this decision can be reverted and the yang's status\n    // can be changed back to normal. If this does not happen, the yang is\n    // suspended permanently, i.e. can't be used in the system ever again.\n    // The start of a Yang's suspension period is tracked in `yang_suspension`\n    const SUSPENSION_GRACE_PERIOD: u64 =\n        consteval_int!((182 * 24 + 12) * 60 * 60); // 182.5 days, half a year, in seconds\n\n    // Length of a time interval in seconds\n    const TIME_INTERVAL: u64 = consteval_int!(30 * 60); // 30 minutes * 60 seconds per minute\n    const TIME_INTERVAL_DIV_YEAR: u128 =\n        57077625570776; // 1 / (48 30-minute intervals per day) / (365 days per year) = 0.000057077625 (wad)\n\n    // Threshold for rounding remaining debt during redistribution (wad): 10**9\n    const ROUNDING_THRESHOLD: u128 = 1000000000;\n\n    // Minimum amount of yang that must be in recipient troves for ordinary\n    // redistribution of yang to occur without overflow (wad): WAD_ONE\n    const MIN_RECIPIENT_POOL_YANG: u128 = 1000000000000000000;\n\n    // Maximum interest rate a yang can have (ray): RAY_ONE\n    const MAX_YANG_RATE: u128 = 1000000000000000000000000000;\n\n    // Flag for setting the yang's new base rate to its previous base rate in `update_rates`\n    // (ray): MAX_YANG_RATE + 1\n    const USE_PREV_BASE_RATE: u128 = 1000000000000000000000000001;\n\n    // Forge fee function parameters\n    const FORGE_FEE_A: u128 = 92103403719761827360719658187; // 92.103403719761827360719658187 (ray)\n    const FORGE_FEE_B: u128 = 55000000000000000; // 0.055 (wad)\n    // The lowest yin spot price where the forge fee will still be zero\n    const MIN_ZERO_FEE_YIN_PRICE: u128 = 995000000000000000; // 0.995 (wad)\n    // The maximum forge fee as a percentage of forge amount\n    const FORGE_FEE_CAP_PCT: u128 = 4000000000000000000; // 400% or 4 (wad)\n    // The maximum deviation before `FORGE_FEE_CAP_PCT` is reached\n    const FORGE_FEE_CAP_PRICE: u128 = 929900000000000000; // 0.9299 (wad)\n\n    // Convenience constant for upward iteration of yangs\n    const START_YANG_IDX: u32 = 1;\n\n    const RECOVERY_MODE_THRESHOLD_MULTIPLIER: u128 = 700000000000000000000000000; // 0.7 (ray)\n\n    // Factor that scales how much thresholds decline during recovery mode\n    const THRESHOLD_DECREASE_FACTOR: u128 = 1000000000000000000000000000; // 1 (ray)\n\n    // SRC5 interface constants\n    const ISRC5_ID: felt252 = 0x3f918d17e5ee77373b56385708f855659a07f75997f365cf87748628532a055;\n    const IERC20_ID: felt252 = 0x10a8f9ff27838cf36e9599878726d548a5c5c1acb0d7e04e99372cbb79f730b;\n    const IERC20_CAMEL_ID: felt252 = 0x2be91edd4cf1388a08c3612416baf85deb00e47d840e6d645f248c8ab64a4ab;\n\n    //\n    // Storage\n    //\n\n    #[storage]\n    struct Storage {\n        // components\n        #[substorage(v0)]\n        access_control: access_control_component::Storage,\n        // A trove can forge debt up to its threshold depending on the yangs deposited.\n        // (trove_id) -> (Trove)\n        troves: LegacyMap::<u64, Trove>,\n        // Stores the amount of the \"yin\" (synthetic) each user owns.\n        // (user_address) -> (Yin)\n        yin: LegacyMap::<ContractAddress, Wad>,\n        // Stores information about the total supply for each yang\n        // (yang_id) -> (Total Supply)\n        yang_total: LegacyMap::<u32, Wad>,\n        // Stores information about the initial yang amount minted to the system\n        initial_yang_amts: LegacyMap::<u32, Wad>,\n        // Number of collateral types accepted by the system.\n        // The return value is also the ID of the last added collateral.\n        yangs_count: u32,\n        // Mapping from yang ContractAddress to yang ID.\n        // Yang ID starts at 1.\n        // (yang_address) -> (yang_id)\n        yang_ids: LegacyMap::<ContractAddress, u32>,\n        // Keeps track of how much of each yang has been deposited into each Trove - Wad\n        // (yang_id, trove_id) -> (Amount Deposited)\n        deposits: LegacyMap::<(u32, u64), Wad>,\n        // Total amount of debt accrued for troves\n        // This includes any debt surplus already accounted for in the budget.\n        total_troves_debt: Wad,\n        // Total amount of synthetic forged and injected\n        total_yin: Wad,\n        // Current budget\n        // - If amount is negative, then there is a deficit i.e. `total_yin` > total debt\n        //   There is more yin in circulation than yin that needs to be repaid.\n        // - If amount is positive, then there is a surplus i.e. total debt > `total_yin`\n        //   There is more yin that needs to be repaid than in circulation.\n        // based on current on-chain conditions\n        budget: SignedWad,\n        // Keeps track of the price history of each Yang\n        // Stores both the actual price and the cumulative price of\n        // the yang at each time interval, both as Wads.\n        // - interval: timestamp divided by TIME_INTERVAL.\n        // (yang_id, interval) -> (price, cumulative_price)\n        yang_prices: LegacyMap::<(u32, u64), (Wad, Wad)>,\n        // Spot price of yin\n        yin_spot_price: Wad,\n        // Minimum value for a trove before a user can forge any debt\n        minimum_trove_value: Wad,\n        // Maximum amount of yin that can be generated. Once this ceiling is exceeded, the\n        // creation of new yin by users should be disallowed.\n        // - If the budget is positive, a user may create new yin only if the resulting total\n        //   yin amount and any debt surpluses is less than or equal to the ceiling.\n        // - If the budget is neutral or negative, a user may create new yin only if the resulting\n        //   total yin amount is less than the ceiling.\n        //\n        // Note that this does not  prevent interest from accruing or the budget from accruing\n        // a surplus, and positive budgets can still be minted as yin. Therefore, it is possible\n        // for the total amount of yin to exceed the debt ceiling.\n        debt_ceiling: Wad,\n        // Global interest rate multiplier\n        // stores both the actual multiplier, and the cumulative multiplier of\n        // the yang at each time interval, both as Rays\n        // (interval) -> (multiplier, cumulative_multiplier)\n        multiplier: LegacyMap::<u64, (Ray, Ray)>,\n        // Keeps track of the most recent rates index.\n        // Rate era starts at 1.\n        // Each index is associated with an update to the interest rates of all yangs.\n        rates_latest_era: u64,\n        // Keeps track of the interval at which the rate update at `era` was made.\n        // (era) -> (interval)\n        rates_intervals: LegacyMap::<u64, u64>,\n        // Keeps track of the interest rate of each yang at each era\n        // (yang_id, era) -> (Interest Rate)\n        yang_rates: LegacyMap::<(u32, u64), Ray>,\n        // Keeps track of when a yang was suspended\n        // 0 means it is not suspended\n        // (yang_id) -> (suspension timestamp)\n        yang_suspension: LegacyMap::<u32, u64>,\n        // Liquidation threshold per yang (as LTV) - Ray\n        // NOTE: don't read the value directly, instead use `get_yang_threshold_helper`\n        //       because a yang might be suspended; the function will return the correct\n        //       threshold value under all circumstances\n        // (yang_id) -> (Liquidation Threshold)\n        thresholds: LegacyMap::<u32, Ray>,\n        // Keeps track of how many redistributions have occurred\n        redistributions_count: u32,\n        // Last redistribution accounted for a trove\n        // (trove_id) -> (Last Redistribution ID)\n        trove_redistribution_id: LegacyMap::<u64, u32>,\n        // Keeps track of whether the redistribution involves at least one yang that\n        // no other troves has deposited.\n        // (redistribution_id) -> (Is exceptional redistribution)\n        is_exceptional_redistribution: LegacyMap::<u32, bool>,\n        // Mapping of yang ID and redistribution ID to\n        // 1. amount of debt in Wad to be redistributed to each Wad unit of yang\n        // 2. amount of debt to be added to the next redistribution to calculate (1)\n        // (yang_id, redistribution_id) -> YangRedistribution{debt_per_wad, debt_to_add_to_next}\n        yang_redistributions: LegacyMap::<(u32, u32), YangRedistribution>,\n        // Mapping of recipient yang ID, redistribution ID and redistributed yang ID to\n        // 1. amount of redistributed yang per Wad unit of recipient yang\n        // 2. amount of debt per Wad unit of recipient yang\n        yang_to_yang_redistribution: LegacyMap::<(u32, u32, u32), ExceptionalYangRedistribution>,\n        // Keeps track of whether shrine is live or killed\n        is_live: bool,\n        // Yin storage\n        yin_name: felt252,\n        yin_symbol: felt252,\n        yin_decimals: u8,\n        // Mapping of user's yin allowance for another user\n        // (user_address, spender_address) -> (Allowance)\n        yin_allowances: LegacyMap::<(ContractAddress, ContractAddress), u256>,\n    }\n\n    //\n    // Events\n    //\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        AccessControlEvent: access_control_component::Event,\n        YangAdded: YangAdded,\n        YangTotalUpdated: YangTotalUpdated,\n        TotalTrovesDebtUpdated: TotalTrovesDebtUpdated,\n        BudgetAdjusted: BudgetAdjusted,\n        MultiplierUpdated: MultiplierUpdated,\n        YangRatesUpdated: YangRatesUpdated,\n        ThresholdUpdated: ThresholdUpdated,\n        ForgeFeePaid: ForgeFeePaid,\n        TroveUpdated: TroveUpdated,\n        TroveRedistributed: TroveRedistributed,\n        DepositUpdated: DepositUpdated,\n        YangPriceUpdated: YangPriceUpdated,\n        YinPriceUpdated: YinPriceUpdated,\n        MinimumTroveValueUpdated: MinimumTroveValueUpdated,\n        DebtCeilingUpdated: DebtCeilingUpdated,\n        YangSuspended: YangSuspended,\n        YangUnsuspended: YangUnsuspended,\n        Killed: Killed,\n        Transfer: Transfer,\n        Approval: Approval,\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangAdded {\n        #[key]\n        yang: ContractAddress,\n        yang_id: u32,\n        start_price: Wad,\n        initial_rate: Ray\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangTotalUpdated {\n        #[key]\n        yang: ContractAddress,\n        total: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct TotalTrovesDebtUpdated {\n        total: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct BudgetAdjusted {\n        amount: SignedWad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct MultiplierUpdated {\n        multiplier: Ray,\n        cumulative_multiplier: Ray,\n        #[key]\n        interval: u64\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangRatesUpdated {\n        #[key]\n        rate_era: u64,\n        current_interval: u64,\n        yangs: Span<ContractAddress>,\n        new_rates: Span<Ray>\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct ThresholdUpdated {\n        #[key]\n        yang: ContractAddress,\n        threshold: Ray\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct ForgeFeePaid {\n        #[key]\n        trove_id: u64,\n        fee: Wad,\n        fee_pct: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct TroveUpdated {\n        #[key]\n        trove_id: u64,\n        trove: Trove\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct TroveRedistributed {\n        #[key]\n        redistribution_id: u32,\n        #[key]\n        trove_id: u64,\n        debt: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct DepositUpdated {\n        #[key]\n        yang: ContractAddress,\n        #[key]\n        trove_id: u64,\n        amount: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangPriceUpdated {\n        #[key]\n        yang: ContractAddress,\n        price: Wad,\n        cumulative_price: Wad,\n        #[key]\n        interval: u64\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YinPriceUpdated {\n        old_price: Wad,\n        new_price: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct MinimumTroveValueUpdated {\n        value: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct DebtCeilingUpdated {\n        ceiling: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangSuspended {\n        #[key]\n        yang: ContractAddress,\n        timestamp: u64\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangUnsuspended {\n        #[key]\n        yang: ContractAddress,\n        timestamp: u64\n    }\n\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Killed {}\n\n    // ERC20 events\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Transfer {\n        #[key]\n        from: ContractAddress,\n        #[key]\n        to: ContractAddress,\n        value: u256\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Approval {\n        #[key]\n        owner: ContractAddress,\n        #[key]\n        spender: ContractAddress,\n        value: u256\n    }\n\n    //\n    // Constructor\n    //\n\n    #[constructor]\n    fn constructor(ref self: ContractState, admin: ContractAddress, name: felt252, symbol: felt252) {\n        self.access_control.initializer(admin, Option::Some(shrine_roles::default_admin_role()));\n\n        self.is_live.write(true);\n\n        // Seeding initial multiplier to the previous interval to ensure `get_recent_multiplier_from` terminates\n        // otherwise, the next multiplier update will run into an endless loop of `get_recent_multiplier_from`\n        // since it wouldn't find the initial multiplier\n        let prev_interval: u64 = now() - 1;\n        let init_multiplier: Ray = INITIAL_MULTIPLIER.into();\n        self.multiplier.write(prev_interval, (init_multiplier, init_multiplier));\n\n        // Setting initial rate era to 1\n        self.rates_latest_era.write(1);\n\n        // Setting initial yin spot price to 1\n        self.yin_spot_price.write(WAD_ONE.into());\n\n        // Emit event\n        self\n            .emit(\n                MultiplierUpdated {\n                    multiplier: init_multiplier, cumulative_multiplier: init_multiplier, interval: prev_interval\n                }\n            );\n\n        // ERC20\n        self.yin_name.write(name);\n        self.yin_symbol.write(symbol);\n        self.yin_decimals.write(WAD_DECIMALS);\n    }\n\n    //\n    // External Shrine functions\n    //\n\n    #[abi(embed_v0)]\n    impl IShrineImpl of IShrine<ContractState> {\n        //\n        // Getters\n        //\n\n        fn get_yin(self: @ContractState, user: ContractAddress) -> Wad {\n            self.yin.read(user)\n        }\n\n        fn get_total_yin(self: @ContractState) -> Wad {\n            self.total_yin.read()\n        }\n\n        // Get yin spot price\n        fn get_yin_spot_price(self: @ContractState) -> Wad {\n            self.yin_spot_price.read()\n        }\n\n        fn get_yang_total(self: @ContractState, yang: ContractAddress) -> Wad {\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n            self.yang_total.read(yang_id)\n        }\n\n        fn get_initial_yang_amt(self: @ContractState, yang: ContractAddress) -> Wad {\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n            self.initial_yang_amts.read(yang_id)\n        }\n\n        fn get_yangs_count(self: @ContractState) -> u32 {\n            self.yangs_count.read()\n        }\n\n        fn get_deposit(self: @ContractState, yang: ContractAddress, trove_id: u64) -> Wad {\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n            self.deposits.read((yang_id, trove_id))\n        }\n\n        fn get_budget(self: @ContractState) -> SignedWad {\n            self.budget.read()\n        }\n\n        fn get_yang_price(self: @ContractState, yang: ContractAddress, interval: u64) -> (Wad, Wad) {\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n            self.yang_prices.read((yang_id, interval))\n        }\n\n        fn get_yang_rate(self: @ContractState, yang: ContractAddress, rate_era: u64) -> Ray {\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n            self.yang_rates.read((yang_id, rate_era))\n        }\n\n        fn get_current_rate_era(self: @ContractState) -> u64 {\n            self.rates_latest_era.read()\n        }\n\n        fn get_minimum_trove_value(self: @ContractState) -> Wad {\n            self.minimum_trove_value.read()\n        }\n\n        fn get_debt_ceiling(self: @ContractState) -> Wad {\n            self.debt_ceiling.read()\n        }\n\n        fn get_multiplier(self: @ContractState, interval: u64) -> (Ray, Ray) {\n            self.multiplier.read(interval)\n        }\n\n        fn get_yang_suspension_status(self: @ContractState, yang: ContractAddress) -> YangSuspensionStatus {\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n            self.get_yang_suspension_status_helper(yang_id)\n        }\n\n        // Returns a tuple of\n        // 1. The \"raw yang threshold\"\n        // 2. The \"scaled yang threshold\" for recovery mode\n        // 1 and 2 will be the same if recovery mode is not in effect\n        fn get_yang_threshold(self: @ContractState, yang: ContractAddress) -> (Ray, Ray) {\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n            let threshold = self.get_yang_threshold_helper(yang_id);\n            (threshold, self.scale_threshold_for_recovery_mode(threshold))\n        }\n\n        // Returns a Health struct comprising the Shrine's threshold, LTV, value and debt;\n        fn get_shrine_health(self: @ContractState) -> Health {\n            let (threshold, value) = self.get_threshold_and_value(self.get_shrine_deposits(), now());\n            let debt: Wad = self.total_troves_debt.read();\n\n            // If no collateral has been deposited, then shrine's LTV is\n            // returned as the maximum possible value.\n            let ltv: Ray = if value.is_zero() {\n                BoundedRay::max()\n            } else {\n                wadray::rdiv_ww(debt, value)\n            };\n\n            Health { threshold, ltv, value, debt }\n        }\n\n        fn get_redistributions_count(self: @ContractState) -> u32 {\n            self.redistributions_count.read()\n        }\n\n        fn get_trove_redistribution_id(self: @ContractState, trove_id: u64) -> u32 {\n            self.trove_redistribution_id.read(trove_id)\n        }\n\n        fn get_redistribution_for_yang(\n            self: @ContractState, yang: ContractAddress, redistribution_id: u32\n        ) -> YangRedistribution {\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n            self.yang_redistributions.read((yang_id, redistribution_id))\n        }\n\n        fn get_exceptional_redistribution_for_yang_to_yang(\n            self: @ContractState,\n            recipient_yang: ContractAddress,\n            redistribution_id: u32,\n            redistributed_yang: ContractAddress\n        ) -> ExceptionalYangRedistribution {\n            let recipient_yang_id: u32 = self.get_valid_yang_id(recipient_yang);\n            let redistributed_yang_id: u32 = self.get_valid_yang_id(redistributed_yang);\n            self.yang_to_yang_redistribution.read((recipient_yang_id, redistribution_id, redistributed_yang_id))\n        }\n\n        fn is_recovery_mode(self: @ContractState) -> bool {\n            let shrine_health: Health = self.get_shrine_health();\n            self.is_recovery_mode_helper(shrine_health)\n        }\n\n        fn get_live(self: @ContractState) -> bool {\n            self.is_live.read()\n        }\n\n        //\n        // Setters - External\n        //\n\n        // `initial_yang_amt` is passed as an argument from upstream to address the issue of\n        // first depositor front-running by requiring an initial deposit when adding the yang\n        // to the Shrine\n        fn add_yang(\n            ref self: ContractState,\n            yang: ContractAddress,\n            threshold: Ray,\n            start_price: Wad,\n            initial_rate: Ray,\n            initial_yang_amt: Wad\n        ) {\n            self.access_control.assert_has_role(shrine_roles::ADD_YANG);\n\n            assert(self.yang_ids.read(yang) == 0, 'SH: Yang already exists');\n\n            assert_rate_is_valid(initial_rate);\n\n            // Assign new ID to yang and add yang struct\n            let yang_id: u32 = self.yangs_count.read() + 1;\n            self.yang_ids.write(yang, yang_id);\n\n            // Update yangs count\n            self.yangs_count.write(yang_id);\n\n            // Set threshold\n            self.set_threshold_helper(yang, threshold);\n\n            // Update initial yang supply\n            // Used upstream to prevent first depositor front running\n            self.yang_total.write(yang_id, initial_yang_amt);\n            self.initial_yang_amts.write(yang_id, initial_yang_amt);\n\n            // Since `start_price` is the first price in the price history, the cumulative price is also set to `start_price`\n\n            let prev_interval: u64 = now() - 1;\n            // seeding initial price to the previous interval to ensure `get_recent_price_from` terminates\n            // new prices are pushed to Shrine from an oracle via `advance` and are always set on the current\n            // interval (`now()`); if we wouldn't set this initial price to `now() - 1` and oracle could\n            // update a price still in the current interval (as oracle update times are independent of\n            // Shrine's intervals, a price can be updated multiple times in a single interval) which would\n            // result in an endless loop of `get_recent_price_from` since it wouldn't find the initial price\n            self.yang_prices.write((yang_id, prev_interval), (start_price, start_price));\n\n            // Setting the base rate for the new yang\n\n            // NOTE: Eras are not incremented when a new yang is added, and the era that is being set\n            // for this base rate will have an interval that is <= now(). This would be a problem\n            // if there could be a trove containing the newly-added with `trove.last_rate_era < latest_era`.\n            // Luckily, this isn't possible because `charge` is called in `deposit`, so a trove's `last_rate_era`\n            // will always be updated to `latest_era` immediately before the newly-added yang is deposited.\n            let latest_era: u64 = self.rates_latest_era.read();\n            self.yang_rates.write((yang_id, latest_era), initial_rate);\n\n            // Event emissions\n            self.emit(YangAdded { yang, yang_id, start_price, initial_rate });\n            self.emit(YangTotalUpdated { yang, total: initial_yang_amt });\n        }\n\n        fn set_threshold(ref self: ContractState, yang: ContractAddress, new_threshold: Ray) {\n            self.access_control.assert_has_role(shrine_roles::SET_THRESHOLD);\n\n            self.set_threshold_helper(yang, new_threshold);\n        }\n\n        fn suspend_yang(ref self: ContractState, yang: ContractAddress) {\n            self.access_control.assert_has_role(shrine_roles::UPDATE_YANG_SUSPENSION);\n\n            assert(self.get_yang_suspension_status(yang) == YangSuspensionStatus::None, 'SH: Already suspended');\n\n            let timestamp: u64 = get_block_timestamp();\n            self.yang_suspension.write(self.get_valid_yang_id(yang), timestamp);\n            self.emit(YangSuspended { yang, timestamp });\n        }\n\n        fn unsuspend_yang(ref self: ContractState, yang: ContractAddress) {\n            self.access_control.assert_has_role(shrine_roles::UPDATE_YANG_SUSPENSION);\n\n            assert(\n                self.get_yang_suspension_status(yang) != YangSuspensionStatus::Permanent, 'SH: Suspension is permanent'\n            );\n\n            self.yang_suspension.write(self.get_valid_yang_id(yang), 0);\n            self.emit(YangUnsuspended { yang, timestamp: get_block_timestamp() });\n        }\n\n        // Update the base rates of all yangs\n        // A base rate of USE_PREV_BASE_RATE means the base rate for the yang stays the same\n        // Takes an array of yangs and their updated rates.\n        // yangs[i]'s base rate will be set to new_rates[i]\n        // yangs's length must equal the number of yangs available.\n        fn update_rates(ref self: ContractState, yangs: Span<ContractAddress>, new_rates: Span<Ray>) {\n            self.access_control.assert_has_role(shrine_roles::UPDATE_RATES);\n\n            let yangs_len = yangs.len();\n            let num_yangs: u32 = self.yangs_count.read();\n\n            assert(yangs_len == num_yangs, 'SH: Too few yangs');\n            assert(yangs_len == new_rates.len(), 'SH: yangs.len != new_rates.len');\n\n            let latest_rate_era: u64 = self.rates_latest_era.read();\n            let latest_rate_era_interval: u64 = self.rates_intervals.read(latest_rate_era);\n            let current_interval: u64 = now();\n\n            // If the interest rates were already updated in the current interval, don't increment the era\n            // Otherwise, increment the era\n            // This way, there is at most one set of base rate updates in every interval\n            let mut rate_era = latest_rate_era;\n\n            if latest_rate_era_interval != current_interval {\n                rate_era += 1;\n                self.rates_latest_era.write(rate_era);\n                self.rates_intervals.write(rate_era, current_interval);\n            }\n\n            // ALL yangs must have a new rate value. A new rate value of `USE_PREV_BASE_RATE` means the\n            // yang's rate isn't being updated, and so we get the previous value.\n            let mut yangs_copy = yangs;\n            let mut new_rates_copy = new_rates;\n            // TODO: temporary workaround for issue with borrowing snapshots in loops\n            let self_snap = @self;\n            loop {\n                match new_rates_copy.pop_front() {\n                    Option::Some(rate) => {\n                        let current_yang_id: u32 = self_snap.get_valid_yang_id(*yangs_copy.pop_front().unwrap());\n                        if *rate.val == USE_PREV_BASE_RATE {\n                            // Setting new era rate to the previous era's rate\n                            self\n                                .yang_rates\n                                .write(\n                                    (current_yang_id, rate_era),\n                                    self_snap.yang_rates.read((current_yang_id, rate_era - 1))\n                                );\n                        } else {\n                            assert_rate_is_valid(*rate);\n                            self.yang_rates.write((current_yang_id, rate_era), *rate);\n                        }\n                    },\n                    Option::None => { break; }\n                };\n            };\n\n            // Verify that all rates were updated correctly\n            // This is necessary because we don't enforce that the `yangs` array really contains\n            // every single yang, only that its length is the same as the number of yangs.\n            // For all we know, `yangs` could contain one yang address 10 times.\n            // Even though this is an admin/governance function, such a mistake could break\n            // interest rate calculations, which is why it's important that we verify that all yangs'\n            // rates were correctly updated.\n            let mut idx: u32 = num_yangs;\n            loop {\n                if idx == 0 {\n                    break ();\n                }\n                assert(self.yang_rates.read((idx, rate_era)).is_non_zero(), 'SH: Incorrect rate update');\n                idx -= 1;\n            };\n\n            self.emit(YangRatesUpdated { rate_era, current_interval, yangs, new_rates });\n        }\n\n        // Set the price of the specified Yang for the current interval interval\n        fn advance(ref self: ContractState, yang: ContractAddress, price: Wad) {\n            self.access_control.assert_has_role(shrine_roles::ADVANCE);\n\n            assert(price.is_non_zero(), 'SH: Price cannot be 0');\n\n            let interval: u64 = now();\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n\n            // Calculating the new cumulative price\n            // To do this, we get the interval of the last price update, find the number of\n            // intervals BETWEEN the current interval and the last_interval (non-inclusive), multiply that by\n            // the last price, and add it to the last cumulative price. Then we add the new price, `price`,\n            // for the current interval.\n            let (last_price, last_cumulative_price, last_interval) = self.get_recent_price_from(yang_id, interval - 1);\n\n            let cumulative_price: Wad = last_cumulative_price\n                + (last_price.val * (interval - last_interval - 1).into()).into()\n                + price;\n\n            self.yang_prices.write((yang_id, interval), (price, cumulative_price));\n            self.emit(YangPriceUpdated { yang, price, cumulative_price, interval });\n        }\n\n        // Sets the multiplier for the current interval\n        fn set_multiplier(ref self: ContractState, multiplier: Ray) {\n            self.access_control.assert_has_role(shrine_roles::SET_MULTIPLIER);\n\n            assert(multiplier.is_non_zero(), 'SH: Multiplier cannot be 0');\n            assert(multiplier.val <= MAX_MULTIPLIER, 'SH: Multiplier exceeds maximum');\n\n            let interval: u64 = now();\n            let (last_multiplier, last_cumulative_multiplier, last_interval) = self\n                .get_recent_multiplier_from(interval - 1);\n\n            let cumulative_multiplier = last_cumulative_multiplier\n                + ((interval - last_interval - 1).into() * last_multiplier.val).into()\n                + multiplier;\n            self.multiplier.write(interval, (multiplier, cumulative_multiplier));\n\n            self.emit(MultiplierUpdated { multiplier, cumulative_multiplier, interval });\n        }\n\n        fn set_minimum_trove_value(ref self: ContractState, value: Wad) {\n            self.access_control.assert_has_role(shrine_roles::SET_MINIMUM_TROVE_VALUE);\n\n            self.minimum_trove_value.write(value);\n\n            // Event emission\n            self.emit(MinimumTroveValueUpdated { value });\n        }\n\n        fn set_debt_ceiling(ref self: ContractState, ceiling: Wad) {\n            self.access_control.assert_has_role(shrine_roles::SET_DEBT_CEILING);\n            self.debt_ceiling.write(ceiling);\n\n            //Event emission\n            self.emit(DebtCeilingUpdated { ceiling });\n        }\n\n        fn adjust_budget(ref self: ContractState, amount: SignedWad) {\n            self.access_control.assert_has_role(shrine_roles::ADJUST_BUDGET);\n\n            self.adjust_budget_helper(amount);\n        }\n\n        // Updates spot price of yin\n        //\n        // Shrine denominates all prices (including that of yin) in yin, meaning yin's peg/target price is 1 (wad).\n        // Therefore, it's expected that the spot price is denominated in yin, in or"
    }
  ]
}