{
  "Title": "[M-02] `tOLP` positions created through `MagnetarAction.Permit` can be stolen",
  "Content": "\n<https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/Magnetar.sol#L199-L212>\n\n<https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/Magnetar.sol#L304-L305>\n\n### Description\n\nThis issue is a combination of three other issues:\n\n- `MagnetarAction.TapToken` integration will leave tokens stuck in `Magnetar` contract.\n- A lot of calls in `MagnetarAction.Permit` enables anyone to steal whitelisted tokens held by `Magnetar`.\n- Anyone can take any whitelisted tokens approved to `Magnetar`.\n\nIn short, the first issue describes that, due to how `MagnetarAction.TapToken` is setup, it will leave the `tOLP` position a user creates through [`TapiocaOptionBroker::participate`](https://github.com/Tapioca-DAO/tap-token/blob/20a83b1d2d5577653610a6c3879dff9df4968345/contracts/options/TapiocaOptionBroker.sol#L301) stuck in the `Magnetar` contract. As it mints the position to `msg.sender` which will be the `Magnetar` contract:\n\n```solidity\nFile: tap-token/contracts/options/TapiocaOptionBroker.sol\n\n301:        oTAPTokenID = oTAP.mint(msg.sender, lockExpiry, uint128(target), _tOLPTokenID);\n```\n\nThe two following ones:\n\nFirstly, describes how anyone can take any tokens that are in the `Magnetar` contract by granting themselves permissions to transfer any whitelisted tokens in using `MagnetarAction.Permit`. Because of how [`MagnetarStorage::_checkSender`](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/MagnetarStorage.sol#L93-L97) validates that the first argument in the calldata to `MagnetarAction.Permit` is the same as `msg.sender`. This together with that a lot of the calls allowed through `MagnetarAction.Permit` (`IYieldBox::setApprovalForAll`, `IYieldBox::setApprovalForAsset`, `IERC20::approve`, and `IERC721::approve`) have `address to`; i.e. the operator/approvee as the first argument. Hence, any user can approve themselves to transfer tokens out of the contract.\n\nSecondly, by using `MagnetarAction.OFT`; which allows anyone to transfer tokens out of `Magnetar` (and steal any approved tokens to `Magnetar`) since there is an unvalidated call done to any whitelisted contract in [`MagnetarAction.OFT`](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/Magnetar.sol#L325-L333).\n\nThe contract is not in itself supposed to hold any tokens; in itself these issues are not that severe by themselves. However, these issues combined allows an attacker to steal the position completely. Since the first one makes the position be stuck in `Magnetar` and the two last ones makes it not actually stuck, but retrievable by anyone.\n\n### Impact\n\nIf a user uses `MagnetarAction.TapToken` to create their position they can have their position and/or rewards stolen.\n\n### Proof of Concept\n\nTest in `tap-token/test/Magnetar.t.sol`, builds on the test described in `MagnetarAction.TapToken` integration will leave tokens stuck in `Magnetar` contract:\n\n```solidity\n    address attacker = makeAddr(\"Attacker\");\n\n    function testStealTokensStuckInMagnetar() public {\n        testMagnetarParticipateOTAPStuckInMagnetar();\n\n        MagnetarCall memory approve = MagnetarCall({\n            id: MagnetarAction.Permit,\n            target: address(oTAP),\n            value: 0,\n            allowFailure: false,\n            call: abi.encodeWithSelector(IERC721.setApprovalForAll.selector, address(attacker), true)\n        });\n\n        MagnetarCall[] memory calls = new MagnetarCall[](1);\n        calls[0] = approve;\n\n        vm.startPrank(attacker);\n        magnetar.burst(calls);\n        oTAP.transferFrom(address(magnetar), address(attacker), 1);\n        vm.stopPrank();\n\n        assertEq(oTAP.ownerOf(1),address(attacker));\n    }\n```\n\nFull test with setup can be found [here](https://gist.github.com/0ximmeas/99606148ff878591c20d5124cab0c617).\n\n### Recommended Mitigation Steps\n\nConsider implementing the mitigations described in the three mentioned referenced issues:\n\n- Adding the ability for the caller to declare a receiver in `TapiocaOptionBroker::participate` and `exerciseOption`. Similar to how it's done in `TapiocaOptionLiquidityProvision::lock`.\n- Rethinking how `MagnetarAction.Permit` should work. As there is support in modules for a lot of the calls it is used for perhaps it is unnecessary to have.\n- Removing the general `MagnetarAction.OFT` call. Most of the interactions with the contracts in the Tapioca ecosystem is already handled in the Magnetar module system which handles approvals and transfers.\n\n### Assessed type\n\nInvalid Validation\n\n**[cryptotechmaker (Tapioca) disagreed with severity and commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/176#issuecomment-2009676677):**\n > The last 2 seems possible only if you approve the attacker, which is valid even for any random ERC20.\n> \n> The first one can be an issue, but I don't think the severity should be H. Maybe Medium or Low. I'll let @0xRektora confirm as well.\n\n**[0xRektora (Tapioca) confirmed and commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/176#issuecomment-2015016770):**\n > While this is a valid finding, the probability of it happening are very low. Will still put it as `medium` due to the nature of the issue.\n> \n> > MagnetarAction.TapToken integration will leave tokens stuck in Magnetar contract. A lot of calls in MagnetarAction. Permit enables anyone to steal whitelisted tokens held by Magnetar.\n> \n> We don't actually use TapToken singular actions, instead we use the `MagnetarOptionModule`. As for permits, we use `TapiocaOmnichainEngine/OFT` for that.\n> \n> The probability are very low because the flow of action taken to the casual user is dictated by a different code. While this is possible to happen it'd have to be an advanced user, who probably will batch the actions together of permitting/locking/sending the token to his address. The Tx will revert if those are not done in the same Tx using Magnetar batching.\n\n**[LSDan (judge) decreased severity to Medium](https://github.com/code-423n4/2024-02-tapioca-findings/issues/176#issuecomment-2034831156)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/Magnetar/Magnetar.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External \nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Tapioca\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {MagnetarAction, MagnetarModule, MagnetarCall} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {IMagnetarModuleExtender} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPermitAll} from \"tapioca-periph/interfaces/common/IPermitAll.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {IPermit} from \"tapioca-periph/interfaces/common/IPermit.sol\";\nimport {IMarket} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {BaseMagnetar} from \"./BaseMagnetar.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Magnetar\n * @author TapiocaDAO\n * @notice Magnetar helper contract\n */\ncontract Magnetar is BaseMagnetar {\n    error Magnetar_ValueMismatch(uint256 expected, uint256 received); // Value mismatch in the total value asked and the msg.value in burst\n    error Magnetar_ActionNotValid(MagnetarAction action, bytes actionCalldata); // Burst did not find what to execute\n\n    constructor(\n        ICluster _cluster,\n        address _owner,\n        address payable _assetModule,\n        address payable _assetXChainModule,\n        address payable _collateralModule,\n        address payable _mintModule,\n        address payable _mintXChainModule,\n        address payable _optionModule,\n        address payable _yieldBoxModule,\n        IPearlmit _pearlmit\n    ) BaseMagnetar(_cluster, _pearlmit, _owner) {\n        modules[MagnetarModule.AssetModule] = _assetModule;\n        modules[MagnetarModule.AssetXChainModule] = _assetXChainModule;\n        modules[MagnetarModule.CollateralModule] = _collateralModule;\n        modules[MagnetarModule.MintModule] = _mintModule;\n        modules[MagnetarModule.MintXChainModule] = _mintXChainModule;\n        modules[MagnetarModule.OptionModule] = _optionModule;\n        modules[MagnetarModule.YieldBoxModule] = _yieldBoxModule;\n    }\n\n    /// =====================\n    /// Public\n    /// =====================\n    /**\n     * @notice Batch multiple calls together\n     * @param calls The list of actions to perform\n     */\n    function burst(MagnetarCall[] calldata calls) external payable {\n        uint256 valAccumulator;\n\n        uint256 length = calls.length;\n\n        for (uint256 i; i < length; i++) {\n            MagnetarCall calldata _action = calls[i];\n            if (!_action.allowFailure) {\n                require(\n                    _action.call.length > 0,\n                    string.concat(\"Magnetar: Missing call for action with index\", string(abi.encode(i)))\n                );\n            }\n            valAccumulator += _action.value;\n\n            /// @dev Permit on YB, or an SGL/BB market\n            if (_action.id == MagnetarAction.Permit) {\n                _processPermitOperation(_action.target, _action.call, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Wrap/unwrap singular operations\n            if (_action.id == MagnetarAction.Wrap) {\n                _processWrapOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Market singular operations\n            if (_action.id == MagnetarAction.Market) {\n                _processMarketOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Tap singular operations\n            if (_action.id == MagnetarAction.TapToken) {\n                _processTapTokenOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.AssetModule) {\n                _executeModule(MagnetarModule.AssetModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.AssetXChainModule) {\n                _executeModule(MagnetarModule.AssetXChainModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.CollateralModule) {\n                _executeModule(MagnetarModule.CollateralModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.MintModule) {\n                _executeModule(MagnetarModule.MintModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.MintXChainModule) {\n                _executeModule(MagnetarModule.MintXChainModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.OptionModule) {\n                _executeModule(MagnetarModule.OptionModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.YieldBoxModule) {\n                _executeModule(MagnetarModule.YieldBoxModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            if (_action.id == MagnetarAction.OFT) {\n                _processOFTOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            // If no valid action was found, use the Magnetar module extender. Only if the action is valid.\n            if (\n                address(magnetarModuleExtender) != address(0)\n                    && magnetarModuleExtender.isValidActionId(uint8(_action.id))\n            ) {\n                bytes memory callData = abi.encodeWithSelector(IMagnetarModuleExtender.handleAction.selector, _action);\n                (bool success, bytes memory returnData) = address(magnetarModuleExtender).delegatecall(callData);\n                if (!success) {\n                    _getRevertMsg(returnData);\n                }\n            } else {\n                // If no valid action was found, revert\n                revert Magnetar_ActionNotValid(_action.id, _action.call);\n            }\n        }\n\n        if (msg.value != valAccumulator) revert Magnetar_ValueMismatch(msg.value, valAccumulator);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    /**\n     * @dev Process a permit operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processPermitOperation(address _target, bytes calldata _actionCalldata, bool _allowFailure) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // permitAction(bytes,uint16)\n        // permit(address owner...)\n        // revoke(address owner...)\n        // permitAll(address from,..)\n        // permit(address from,...)\n        // setApprovalForAll(address from,...)\n        // setApprovalForAsset(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == IPermitAll.permitAll.selector || funcSig == IPermitAll.revokeAll.selector\n                || funcSig == IPermit.permit.selector || funcSig == IPermit.revoke.selector\n                || funcSig == IYieldBox.setApprovalForAll.selector || funcSig == IYieldBox.setApprovalForAsset.selector \n                || funcSig == IERC20.approve.selector || funcSig == IPearlmit.approve.selector\n                || funcSig == IERC721.approve.selector \n        ) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            // No need to send value on permit\n            _executeCall(_target, _actionCalldata, 0, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Permit, _actionCalldata);\n    }\n\n    //TODO: decide\n    /**\n     * @dev Process a TOFT operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processWrapOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // wrap(address from,...)\n        // unwrap(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n\n        if (funcSig == ITOFT.wrap.selector || funcSig == ITOFT.unwrap.selector) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Wrap, _actionCalldata);\n    }\n\n    /**\n     * @dev Process a market operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processMarketOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // addCollateral(address from,...)\n        // borrow(address from,...)\n        // addAsset(address from,...)\n        // repay(address _from,...)\n        // buyCollateral(address from,...)\n        // sellCollateral(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == IMarket.execute.selector || funcSig == ISingularity.addAsset.selector\n                || funcSig == ISingularity.removeAsset.selector\n        ) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Market, _actionCalldata);\n    }\n\n    /**\n     * @dev Process a TapToken operation, will only execute if the selector is allowed.\n     * @dev Different from the others. No need to check for sender.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processTapTokenOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == ITapiocaOptionBroker.exerciseOption.selector\n                || funcSig == ITapiocaOptionBroker.participate.selector\n                || funcSig == ITapiocaOptionBroker.exitPosition.selector\n                || funcSig == ITapiocaOptionLiquidityProvision.lock.selector\n                || funcSig == ITapiocaOptionLiquidityProvision.unlock.selector\n        ) {\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.TapToken, _actionCalldata);\n    }\n\n    /**\n     * @dev Process an OFT operation, will only execute if the selector is allowed.\n     * @dev Different from the others. No need to check for sender. MsgType is sanitized by the OFT\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processOFTOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n        _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n    }\n\n    /**\n     * @dev Executes a call to an address, optionally reverting on failure. Make sure to sanitize prior to calling.\n     */\n    function _executeCall(address _target, bytes calldata _actionCalldata, uint256 _actionValue, bool _allowFailure)\n        private\n    {\n        bool success;\n        bytes memory returnData;\n\n        if (_actionValue > 0) {\n            (success, returnData) = _target.call{value: _actionValue}(_actionCalldata);\n        } else {\n            (success, returnData) = _target.call(_actionCalldata);\n        }\n\n        if (!success && !_allowFailure) {\n            _getRevertMsg(returnData);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/Magnetar/Magnetar.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External \nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Tapioca\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {MagnetarAction, MagnetarModule, MagnetarCall} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {IMagnetarModuleExtender} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPermitAll} from \"tapioca-periph/interfaces/common/IPermitAll.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {IPermit} from \"tapioca-periph/interfaces/common/IPermit.sol\";\nimport {IMarket} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {BaseMagnetar} from \"./BaseMagnetar.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Magnetar\n * @author TapiocaDAO\n * @notice Magnetar helper contract\n */\ncontract Magnetar is BaseMagnetar {\n    error Magnetar_ValueMismatch(uint256 expected, uint256 received); // Value mismatch in the total value asked and the msg.value in burst\n    error Magnetar_ActionNotValid(MagnetarAction action, bytes actionCalldata); // Burst did not find what to execute\n\n    constructor(\n        ICluster _cluster,\n        address _owner,\n        address payable _assetModule,\n        address payable _assetXChainModule,\n        address payable _collateralModule,\n        address payable _mintModule,\n        address payable _mintXChainModule,\n        address payable _optionModule,\n        address payable _yieldBoxModule,\n        IPearlmit _pearlmit\n    ) BaseMagnetar(_cluster, _pearlmit, _owner) {\n        modules[MagnetarModule.AssetModule] = _assetModule;\n        modules[MagnetarModule.AssetXChainModule] = _assetXChainModule;\n        modules[MagnetarModule.CollateralModule] = _collateralModule;\n        modules[MagnetarModule.MintModule] = _mintModule;\n        modules[MagnetarModule.MintXChainModule] = _mintXChainModule;\n        modules[MagnetarModule.OptionModule] = _optionModule;\n        modules[MagnetarModule.YieldBoxModule] = _yieldBoxModule;\n    }\n\n    /// =====================\n    /// Public\n    /// =====================\n    /**\n     * @notice Batch multiple calls together\n     * @param calls The list of actions to perform\n     */\n    function burst(MagnetarCall[] calldata calls) external payable {\n        uint256 valAccumulator;\n\n        uint256 length = calls.length;\n\n        for (uint256 i; i < length; i++) {\n            MagnetarCall calldata _action = calls[i];\n            if (!_action.allowFailure) {\n                require(\n                    _action.call.length > 0,\n                    string.concat(\"Magnetar: Missing call for action with index\", string(abi.encode(i)))\n                );\n            }\n            valAccumulator += _action.value;\n\n            /// @dev Permit on YB, or an SGL/BB market\n            if (_action.id == MagnetarAction.Permit) {\n                _processPermitOperation(_action.target, _action.call, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Wrap/unwrap singular operations\n            if (_action.id == MagnetarAction.Wrap) {\n                _processWrapOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Market singular operations\n            if (_action.id == MagnetarAction.Market) {\n                _processMarketOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Tap singular operations\n            if (_action.id == MagnetarAction.TapToken) {\n                _processTapTokenOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.AssetModule) {\n                _executeModule(MagnetarModule.AssetModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.AssetXChainModule) {\n                _executeModule(MagnetarModule.AssetXChainModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.CollateralModule) {\n                _executeModule(MagnetarModule.CollateralModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.MintModule) {\n                _executeModule(MagnetarModule.MintModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.MintXChainModule) {\n                _executeModule(MagnetarModule.MintXChainModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.OptionModule) {\n                _executeModule(MagnetarModule.OptionModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.YieldBoxModule) {\n                _executeModule(MagnetarModule.YieldBoxModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            if (_action.id == MagnetarAction.OFT) {\n                _processOFTOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            // If no valid action was found, use the Magnetar module extender. Only if the action is valid.\n            if (\n                address(magnetarModuleExtender) != address(0)\n                    && magnetarModuleExtender.isValidActionId(uint8(_action.id))\n            ) {\n                bytes memory callData = abi.encodeWithSelector(IMagnetarModuleExtender.handleAction.selector, _action);\n                (bool success, bytes memory returnData) = address(magnetarModuleExtender).delegatecall(callData);\n                if (!success) {\n                    _getRevertMsg(returnData);\n                }\n            } else {\n                // If no valid action was found, revert\n                revert Magnetar_ActionNotValid(_action.id, _action.call);\n            }\n        }\n\n        if (msg.value != valAccumulator) revert Magnetar_ValueMismatch(msg.value, valAccumulator);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    /**\n     * @dev Process a permit operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processPermitOperation(address _target, bytes calldata _actionCalldata, bool _allowFailure) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // permitAction(bytes,uint16)\n        // permit(address owner...)\n        // revoke(address owner...)\n        // permitAll(address from,..)\n        // permit(address from,...)\n        // setApprovalForAll(address from,...)\n        // setApprovalForAsset(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == IPermitAll.permitAll.selector || funcSig == IPermitAll.revokeAll.selector\n                || funcSig == IPermit.permit.selector || funcSig == IPermit.revoke.selector\n                || funcSig == IYieldBox.setApprovalForAll.selector || funcSig == IYieldBox.setApprovalForAsset.selector \n                || funcSig == IERC20.approve.selector || funcSig == IPearlmit.approve.selector\n                || funcSig == IERC721.approve.selector \n        ) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            // No need to send value on permit\n            _executeCall(_target, _actionCalldata, 0, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Permit, _actionCalldata);\n    }\n\n    //TODO: decide\n    /**\n     * @dev Process a TOFT operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processWrapOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // wrap(address from,...)\n        // unwrap(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n\n        if (funcSig == ITOFT.wrap.selector || funcSig == ITOFT.unwrap.selector) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Wrap, _actionCalldata);\n    }\n\n    /**\n     * @dev Process a market operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processMarketOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // addCollateral(address from,...)\n        // borrow(address from,...)\n        // addAsset(address from,...)\n        // repay(address _from,...)\n        // buyCollateral(address from,...)\n        // sellCollateral(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == IMarket.execute.selector || funcSig == ISingularity.addAsset.selector\n                || funcSig == ISingularity.removeAsset.selector\n        ) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Market, _actionCalldata);\n    }\n\n    /**\n     * @dev Process a TapToken operation, will only execute if the selector is allowed.\n     * @dev Different from the others. No need to check for sender.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processTapTokenOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == ITapiocaOptionBroker.exerciseOption.selector\n                || funcSig == ITapiocaOptionBroker.participate.selector\n                || funcSig == ITapiocaOptionBroker.exitPosition.selector\n                || funcSig == ITapiocaOptionLiquidityProvision.lock.selector\n                || funcSig == ITapiocaOptionLiquidityProvision.unlock.selector\n        ) {\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.TapToken, _actionCalldata);\n    }\n\n    /**\n     * @dev Process an OFT operation, will only execute if the selector is allowed.\n     * @dev Different from the others. No need to check for sender. MsgType is sanitized by the OFT\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processOFTOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n        _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n    }\n\n    /**\n     * @dev Executes a call to an address, optionally reverting on failure. Make sure to sanitize prior to calling.\n     */\n    function _executeCall(address _target, bytes calldata _actionCalldata, uint256 _actionValue, bool _allowFailure)\n        private\n    {\n        bool success;\n        bytes memory returnData;\n\n        if (_actionValue > 0) {\n            (success, returnData) = _target.call{value: _actionValue}(_actionCalldata);\n        } else {\n            (success, returnData) = _target.call(_actionCalldata);\n        }\n\n        if (!success && !_allowFailure) {\n            _getRevertMsg(returnData);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/options/TapiocaOptionBroker.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {TapiocaOptionLiquidityProvision, LockPosition, SingularityPool} from \"./TapiocaOptionLiquidityProvision.sol\";\nimport {IPearlmit, PearlmitHandler} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {TapToken} from \"tap-token/tokens/TapToken.sol\";\nimport {OTAP, TapOption} from \"./oTAP.sol\";\nimport {TWAML} from \"./twAML.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nstruct Participation {\n    bool hasVotingPower;\n    bool divergenceForce; // 0 negative, 1 positive\n    uint256 averageMagnitude;\n}\n\nstruct TWAMLPool {\n    uint256 totalParticipants;\n    uint256 averageMagnitude;\n    uint256 totalDeposited;\n    uint256 cumulative;\n}\n\nstruct PaymentTokenOracle {\n    ITapiocaOracle oracle;\n    bytes oracleData;\n}\n\ncontract TapiocaOptionBroker is Pausable, Ownable, PearlmitHandler, IERC721Receiver, TWAML, Ree"
    }
  ]
}