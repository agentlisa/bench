{
  "Title": "[M-01] Balance check during `MagicSpend` validation cannot ensure that `MagicSpend` has enough balance to cover the requested fund",
  "Content": "\n[Balance check](https://github.com/code-423n4/2024-03-coinbase/blob/e0573369b865d47fed778de00a7b6df65ab1744e/src/MagicSpend/MagicSpend.sol#L130-L135) during `MagicSpend` validation cannot ensure that `MagicSpend` has enough balance to cover the requested fund.\n\n```solidity\n        // Ensure at validation that the contract has enough balance to cover the requested funds.\n        // NOTE: This check is necessary to enforce that the contract will be able to transfer the remaining funds\n        //       when `postOp()` is called back after the `UserOperation` has been executed.\n        if (address(this).balance < withdrawAmount) {\n            revert InsufficientBalance(withdrawAmount, address(this).balance);\n        }\n```\n\n### Proof of Concept\n\n1.  EntryPoint executes userOps by two loops: [validation loop](https://github.com/eth-infinitism/account-abstraction/blob/abff2aca61a8f0934e533d0d352978055fddbd96/contracts/core/EntryPoint.sol#L98-L102) and [execution loop](https://github.com/eth-infinitism/account-abstraction/blob/abff2aca61a8f0934e533d0d352978055fddbd96/contracts/core/EntryPoint.sol#L107-L109).\n2.  Suppose we have two userOps using `MagicSpend`:\n    *   userOp1 with `withdrawAmount` 100\n    *   userOp2 with `withdrawAmount` 150\n\n3.  userOp1 and userOp2 are packed together as `UserOperation[]` [ops](https://github.com/eth-infinitism/account-abstraction/blob/abff2aca61a8f0934e533d0d352978055fddbd96/contracts/core/EntryPoint.sol#L92) and ops will be executed by entryPoint through [the `handleOps` method](https://github.com/eth-infinitism/account-abstraction/blob/abff2aca61a8f0934e533d0d352978055fddbd96/contracts/core/EntryPoint.sol#L92)\n4.  Suppose the balance of MagicSpend is 200.\n5.  During the validation loop:\n    *   `validatePaymasterUserOp` will be called during userOp1 validation and pass for  address(this).balance (=200) is larger than withdrawAmount (=100)\n    *   `validatePaymasterUserOp` will be called during userOp1 validation and pass for  address(this).balance (=200) is larger than withdrawAmount (=150)\n\n```solidity\n        // https://github.com/eth-infinitism/account-abstraction/blob/abff2aca61a8f0934e533d0d352978055fddbd96/contracts/core/EntryPoint.sol#L98C1-L102C10\n        for (uint256 i = 0; i < opslen; i++) {\n            UserOpInfo memory opInfo = opInfos[i];\n            (uint256 validationData, uint256 pmValidationData) = _validatePrepayment(i, ops[i], opInfo);\n            _validateAccountAndPaymasterValidationData(i, validationData, pmValidationData, address(0));\n        }\n```\n\n6.  During the execution loop:\n    *   The balance of MagicSpend is 200\n    *   The request fund of userOp1 and userOp2 is 100+150=250 > 200\n\n```solidity\n        // https://github.com/eth-infinitism/account-abstraction/blob/abff2aca61a8f0934e533d0d352978055fddbd96/contracts/core/EntryPoint.sol#L107-L109\n        for (uint256 i = 0; i < opslen; i++) {\n            collected += _executeUserOp(i, ops[i], opInfos[i]);\n        }\n```\n\n*   After executing `postOp` of userOp1, the balance of MagicSpend is 100.\n\n```solidity\n        // https://github.com/code-423n4/2024-03-coinbase/blob/e0573369b865d47fed778de00a7b6df65ab1744e/src/MagicSpend/MagicSpend.sol#L160C1-L162C10\n        if (withdrawable > 0) {\n            SafeTransferLib.forceSafeTransferETH(account, withdrawable, SafeTransferLib.GAS_STIPEND_NO_STORAGE_WRITES);\n        }\n```\n\n*   When executing `postOp` of userOp2, MagicSpend does not have enough balance to cover the requested fund (=150) of userOp2 and the execution will fail.\n\n```solidity\n        // https://github.com/code-423n4/2024-03-coinbase/blob/e0573369b865d47fed778de00a7b6df65ab1744e/src/MagicSpend/MagicSpend.sol#L160C1-L162C10\n        if (withdrawable > 0) {\n            SafeTransferLib.forceSafeTransferETH(account, withdrawable, SafeTransferLib.GAS_STIPEND_NO_STORAGE_WRITES);\n        }\n```\n\n*   So, a balance check during MagicSpend validation cannot ensure that MagicSpend has enough balance to cover the requested fund.\n\n```solidity\n        // https://github.com/code-423n4/2024-03-coinbase/blob/e0573369b865d47fed778de00a7b6df65ab1744e/src/MagicSpend/MagicSpend.sol#L130-L135\n        // Ensure at validation that the contract has enough balance to cover the requested funds.\n        // NOTE: This check is necessary to enforce that the contract will be able to transfer the remaining funds\n        //       when `postOp()` is called back after the `UserOperation` has been executed.\n        if (address(this).balance < withdrawAmount) {\n            revert InsufficientBalance(withdrawAmount, address(this).balance);\n        }\n```\n\n### Recommended Mitigation Steps\n\nUse a state instead of `address(this).balance` to record the remaining balance.\n\n```solidity\n        if (remain < withdrawAmount) {\n            revert InsufficientBalance(withdrawAmount, address(this).balance);\n        }\n        remain -= withdrawAmount;\n\n```\n\n**[raymondfam (lookout) commented](https://github.com/code-423n4/2024-03-coinbase-findings/issues/110#issuecomment-2015397482):**\n > This would happen only when the entrypoint batches the transactions. Additionally, this is kind of related to the known issue from the readme: When acting as a paymaster, EntryPoint will debit MagicSpend slightly more than actualGasCost, meaning what is withheld on a gas-paying withdrawal will not cover 100\\% of MagicSpend's balance decrease in the EntryPoint.\n\n**[wilsoncusack (Coinbase) confirmed and commented](https://github.com/code-423n4/2024-03-coinbase-findings/issues/110#issuecomment-2020511843):**\n > Ah right I feel like we discussed this @xenoliss and then perhaps forgot in a later conversation. The only way to avoid this would be to have validation keep some tally of all the expected coming withdraws.\n\n**[3docSec (judge) commented](https://github.com/code-423n4/2024-03-coinbase-findings/issues/110#issuecomment-2022193681):**\n > To be fair, one could argue that the bundlers should simulate the execution of their bundles before submission to avoid reverts; however, this is a valid way of grieving the reputation of the MagicSpend contract.\n\n**[wilsoncusack (Coinbase) commented](https://github.com/code-423n4/2024-03-coinbase-findings/issues/110#issuecomment-2022736533):**\n> @3docSec - it is correct that the bundler would be expected to see this and revert the whole bundle. However, the point is valid that the guard is not fully satisfactory as it is written. It should probably be removed or fixed.\n\n**[Coinbase mitigated](https://github.com/code-423n4/2024-04-coinbase-mitigation/blob/main/README.md#scope):**\n> This issue is complex to address. The warden suggested adding a variable to track in flight withdraws, and we [pursued this](https://github.com/coinbase/magic-spend/pull/16). However, we realized that bundlers penalize paymasters when the UserOp behaves differently when simulated in isolation vs. in the bundle, and this would not fix this. Instead, we give the owner a tool to address this probabilistically: the owner can set a `maxWithdrawDenominator` and we enforce that native asset withdraws must be `<= address(this).balance / maxWithdrawDenominator`. For example, if `maxWithdrawDenominator` is set to 20, it would take 20 native asset withdraws (each withdrawing max allowed) + 1 native asset withdraw in the same transaction to cause a revert. It is of course known that this doesn't entirely solve the issue, and the efficacy depends the value chosen and usage. (PR [here](https://github.com/coinbase/magic-spend/pull/17))\n\n**Status:** Mitigation confirmed. Full details in reports from [imare](https://github.com/code-423n4/2024-04-coinbase-mitigation-findings/issues/7) and [McToady](https://github.com/code-423n4/2024-04-coinbase-mitigation-findings/issues/5).\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-coinbase",
  "Code": [
    {
      "filename": "src/MagicSpend/MagicSpend.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SignatureCheckerLib} from \"solady/utils/SignatureCheckerLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {UserOperation} from \"account-abstraction/interfaces/UserOperation.sol\";\nimport {IPaymaster} from \"account-abstraction/interfaces/IPaymaster.sol\";\nimport {IEntryPoint} from \"account-abstraction/interfaces/IEntryPoint.sol\";\n\n/// @title Magic Spend\n///\n/// @author Coinbase (https://github.com/coinbase/magic-spend)\n///\n/// @notice ERC4337 Paymaster implementation compatible with Entrypoint v0.6.\n///\n/// @dev See https://eips.ethereum.org/EIPS/eip-4337#extension-paymasters.\ncontract MagicSpend is Ownable, IPaymaster {\n    /// @notice Signed withdraw request allowing accounts to withdraw funds from this contract.\n    struct WithdrawRequest {\n        /// @dev The signature associated with this withdraw request.\n        bytes signature;\n        /// @dev The asset to withdraw. NOTE: Only ETH (associated with zero address) is supported for now.\n        address asset;\n        /// @dev The requested amount to withdraw.\n        uint256 amount;\n        /// @dev Unique nonce used to prevent replays.\n        uint256 nonce;\n        /// @dev The maximum expiry the withdraw request remains valid for.\n        uint48 expiry;\n    }\n\n    /// @notice Track the ETH available to be withdrawn per user.\n    mapping(address user => uint256 amount) internal _withdrawableETH;\n\n    /// @dev Mappings keeping track of already used nonces per user to prevent replays of withdraw requests.\n    mapping(uint256 nonce => mapping(address user => bool used)) internal _nonceUsed;\n\n    /// @notice Emitted after validating a withdraw request and funds are about to be withdrawn.\n    ///\n    /// @param account The account address.\n    /// @param asset   The asset withdrawn.\n    /// @param amount  The amount withdrawn.\n    /// @param nonce   The request nonce.\n    event MagicSpendWithdrawal(address indexed account, address indexed asset, uint256 amount, uint256 nonce);\n\n    /// @notice Thrown when the withdraw request signature is invalid.\n    ///\n    /// @dev The withdraw request signature MUST be:\n    ///         - an ECDSA signature following EIP-191 (version 0x45)\n    ///         - performed over the content specified in `getHash()`\n    ///         - signed by the current owner of this contract\n    error InvalidSignature();\n\n    /// @notice Thrown when trying to use a withdraw request after its expiry has been reched.\n    error Expired();\n\n    /// @notice Thrown when trying to replay a withdraw request with the same nonce.\n    ///\n    /// @param nonce The already used nonce.\n    error InvalidNonce(uint256 nonce);\n\n    /// @notice Thrown during validation in the context of ERC4337, when the withraw reques amount is insufficient\n    ///         to sponsor the transaction gas.\n    ///\n    /// @param requested The withdraw request amount.\n    /// @param maxCost   The max gas cost required by the Entrypoint.\n    error RequestLessThanGasMaxCost(uint256 requested, uint256 maxCost);\n\n    /// @notice Thrown when the withdraw request asset is not ETH (zero address).\n    ///\n    /// @param asset The requested asset.\n    error UnsupportedPaymasterAsset(address asset);\n\n    /// @notice Thrown during `UserOperation` validation when the current balance is insufficient to cover the\n    ///         requested amount (exluding the `maxGasCost` set by the Entrypoint).\n    ///\n    /// @param requestedAmount The requested amount excluding gas.\n    /// @param balance         The current contract balance.\n    error InsufficientBalance(uint256 requestedAmount, uint256 balance);\n\n    /// @notice Thrown when trying to withdraw funds but nothing is available.\n    error NoExcess();\n\n    /// @notice Thrown in when `postOp()` is called a second time with `PostOpMode.postOpReverted`.\n    ///\n    /// @dev This should only really occur if for unknown reasons the transfer of the withdrwable\n    ///      funds to the user account failed (i.e. this contract's ETH balance is insufficient or\n    ///      the user account refused the funds or ran out of gas on receive).\n    error UnexpectedPostOpRevertedMode();\n\n    /// @dev Requires that the caller is the EntryPoint.\n    modifier onlyEntryPoint() virtual {\n        if (msg.sender != entryPoint()) revert Unauthorized();\n        _;\n    }\n\n    /// @notice Deploy the contract and set its initial owner.\n    ///\n    /// @param _owner The initial owner of this contract.\n    constructor(address _owner) {\n        Ownable._initializeOwner(_owner);\n    }\n\n    /// @notice Receive function allowing ETH to be deposited in this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IPaymaster\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32, uint256 maxCost)\n        external\n        onlyEntryPoint\n        returns (bytes memory context, uint256 validationData)\n    {\n        WithdrawRequest memory withdrawRequest = abi.decode(userOp.paymasterAndData[20:], (WithdrawRequest));\n        uint256 withdrawAmount = withdrawRequest.amount;\n\n        if (withdrawAmount < maxCost) {\n            revert RequestLessThanGasMaxCost(withdrawAmount, maxCost);\n        }\n\n        if (withdrawRequest.asset != address(0)) {\n            revert UnsupportedPaymasterAsset(withdrawRequest.asset);\n        }\n\n        _validateRequest(userOp.sender, withdrawRequest);\n\n        bool sigFailed = !isValidWithdrawSignature(userOp.sender, withdrawRequest);\n        validationData = (sigFailed ? 1 : 0) | (uint256(withdrawRequest.expiry) << 160);\n\n        // Ensure at validation that the contract has enough balance to cover the requested funds.\n        // NOTE: This check is necessary to enforce that the contract will be able to transfer the remaining funds\n        //       when `postOp()` is called back after the `UserOperation` has been executed.\n        if (address(this).balance < withdrawAmount) {\n            revert InsufficientBalance(withdrawAmount, address(this).balance);\n        }\n\n        // NOTE: Do not include the gas part in withdrawable funds as it will be handled in `postOp()`.\n        _withdrawableETH[userOp.sender] += withdrawAmount - maxCost;\n        context = abi.encode(maxCost, userOp.sender);\n    }\n\n    /// @inheritdoc IPaymaster\n    function postOp(IPaymaster.PostOpMode mode, bytes calldata context, uint256 actualGasCost)\n        external\n        onlyEntryPoint\n    {\n        // `PostOpMode.postOpReverted` should be impossible.\n        // Only possible cause would be if this contract does not own enough ETH to transfer\n        // but this is checked at the validation step.\n        assert(mode != PostOpMode.postOpReverted);\n\n        (uint256 maxGasCost, address account) = abi.decode(context, (uint256, address));\n\n        // Compute the total remaining funds available for the user accout.\n        // NOTE: Take into account the user operation gas that was not consummed.\n        uint256 withdrawable = _withdrawableETH[account] + (maxGasCost - actualGasCost);\n\n        // Send the all remaining funds to the user accout.\n        delete _withdrawableETH[account];\n        if (withdrawable > 0) {\n            SafeTransferLib.forceSafeTransferETH(account, withdrawable, SafeTransferLib.GAS_STIPEND_NO_STORAGE_WRITES);\n        }\n    }\n\n    /// @notice Allows the sender to withdraw any available funds associated with him.\n    ///\n    /// @dev Can be called back during the `UserOperation` execution to sponsor funds for non-gas related\n    ///      use cases (e.g., swap or mint).\n    function withdrawGasExcess() external {\n        uint256 amount = _withdrawableETH[msg.sender];\n        // we could allow 0 value transfers, but prefer to be explicit\n        if (amount == 0) revert NoExcess();\n\n        delete _withdrawableETH[msg.sender];\n        _withdraw(address(0), msg.sender, amount);\n    }\n\n    /// @notice Allows caller to withdraw funds by calling with a valid `withdrawRequest`\n    ///\n    /// @param withdrawRequest The withdraw request.\n    function withdraw(WithdrawRequest memory withdrawRequest) external {\n        _validateRequest(msg.sender, withdrawRequest);\n\n        if (!isValidWithdrawSignature(msg.sender, withdrawRequest)) {\n            revert InvalidSignature();\n        }\n\n        if (block.timestamp > withdrawRequest.expiry) {\n            revert Expired();\n        }\n\n        // reserve funds for gas, will credit user with difference in post op\n        _withdraw(withdrawRequest.asset, msg.sender, withdrawRequest.amount);\n    }\n\n    /// @notice Withdraws funds from this contract.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param asset The asset to withdraw.\n    /// @param to The beneficiary address.\n    /// @param amount The amount to withdraw.\n    function ownerWithdraw(address asset, address to, uint256 amount) external onlyOwner {\n        _withdraw(asset, to, amount);\n    }\n\n    /// @notice Deposits ETH from this contract funds into the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param amount The amount to deposit on the the Entrypoint.\n    function entryPointDeposit(uint256 amount) external payable onlyOwner {\n        SafeTransferLib.safeTransferETH(entryPoint(), amount);\n    }\n\n    /// @notice Withdraws ETH from the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param to     The beneficiary address.\n    /// @param amount The amount to withdraw from the Entrypoint.\n    function entryPointWithdraw(address payable to, uint256 amount) external onlyOwner {\n        IEntryPoint(entryPoint()).withdrawTo(to, amount);\n    }\n\n    /// @notice Adds stake to the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param amount              The amount to stake in the Entrypoint.\n    /// @param unstakeDelaySeconds The duration for which the stake cannot be withdrawn.\n    function entryPointAddStake(uint256 amount, uint32 unstakeDelaySeconds) external payable onlyOwner {\n        IEntryPoint(entryPoint()).addStake{value: amount}(unstakeDelaySeconds);\n    }\n\n    /// @notice Unlocks stake in the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    function entryPointUnlockStake() external onlyOwner {\n        IEntryPoint(entryPoint()).unlockStake();\n    }\n\n    /// @notice Withdraws stake from the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param to The beneficiary address.\n    function entryPointWithdrawStake(address payable to) external onlyOwner {\n        IEntryPoint(entryPoint()).withdrawStake(to);\n    }\n\n    /// @notice Returns whether the `withdrawRequest` signature is valid for the given `account`.\n    ///\n    /// @dev Does not validate nonce or expiry.\n    ///\n    /// @param account         The account address.\n    /// @param withdrawRequest The withdraw request.\n    ///\n    /// @return `true` if the signature is valid, else `false`.\n    function isValidWithdrawSignature(address account, WithdrawRequest memory withdrawRequest)\n        public\n        view\n        returns (bool)\n    {\n        return SignatureCheckerLib.isValidSignatureNow(\n            owner(), getHash(account, withdrawRequest), withdrawRequest.signature\n        );\n    }\n\n    /// @notice Returns the hash to be signed for a given `account` and `withdrawRequest` pair.\n    ///\n    /// @dev Returns an EIP-191 compliant Ethereum Signed Message (version 0x45), see\n    ///      https://eips.ethereum.org/EIPS/eip-191.\n    ///\n    /// @param account         The account address.\n    /// @param withdrawRequest The withdraw request.\n    ///\n    /// @return The hash to be signed for the given `account` and `withdrawRequest`.\n    function getHash(address account, WithdrawRequest memory withdrawRequest) public view returns (bytes32) {\n        return SignatureCheckerLib.toEthSignedMessageHash(\n            abi.encode(\n                address(this),\n                account,\n                block.chainid,\n                withdrawRequest.asset,\n                withdrawRequest.amount,\n                withdrawRequest.nonce,\n                withdrawRequest.expiry\n            )\n        );\n    }\n\n    /// @notice Returns whether the `nonce` has been used by the given `account`.\n    ///\n    /// @param account The account address.\n    /// @param nonce   The nonce to check.\n    ///\n    /// @return `true` if the nonce has already been used by the account, else `false`.\n    function nonceUsed(address account, uint256 nonce) external view returns (bool) {\n        return _nonceUsed[nonce][account];\n    }\n\n    /// @notice Returns the canonical ERC-4337 EntryPoint v0.6 contract.\n    function entryPoint() public pure returns (address) {\n        return 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789;\n    }\n\n    /// @notice Validate the `withdrawRequest` against the given `account`.\n    ///\n    /// @dev Runs all non-signature validation checks.\n    /// @dev Reverts if the withdraw request nonce has already been used.\n    ///\n    /// @param account         The account address.\n    /// @param withdrawRequest The withdraw request to validate.\n    function _validateRequest(address account, WithdrawRequest memory withdrawRequest) internal {\n        if (_nonceUsed[withdrawRequest.nonce][account]) {\n            revert InvalidNonce(withdrawRequest.nonce);\n        }\n\n        _nonceUsed[withdrawRequest.nonce][account] = true;\n\n        // This is emitted ahead of fund transfer, but allows a consolidated code path\n        emit MagicSpendWithdrawal(account, withdrawRequest.asset, withdrawRequest.amount, withdrawRequest.nonce);\n    }\n\n    /// @notice Withdraws funds from this contract.\n    ///\n    /// @dev Callers MUST validate that the withdraw is legitimate before calling this method as\n    ///      no validation is performed here.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param to     The beneficiary address.\n    /// @param amount The amount to withdraw.\n    function _withdraw(address asset, address to, uint256 amount) internal {\n        if (asset == address(0)) {\n            SafeTransferLib.safeTransferETH(to, amount);\n        } else {\n            SafeTransferLib.safeTransfer(asset, to, amount);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/core/EntryPoint.sol",
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IPaymaster.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\n\nimport \"../utils/Exec.sol\";\nimport \"./StakeManager.sol\";\nimport \"./SenderCreator.sol\";\nimport \"./Helpers.sol\";\nimport \"./NonceManager.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract EntryPoint is IEntryPoint, StakeManager, NonceManager, ReentrancyGuard {\n\n    using UserOperationLib for UserOperation;\n\n    SenderCreator private immutable senderCreator = new SenderCreator();\n\n    // internal value used during simulation: need to query aggregator.\n    address private constant SIMULATE_FIND_AGGREGATOR = address(1);\n\n    // marker for inner call revert on out of gas\n    bytes32 private constant INNER_OUT_OF_GAS = hex'deaddead';\n\n    uint256 private constant REVERT_REASON_MAX_LEN = 2048;\n\n    /**\n     * for simulation purposes, validateUserOp (and validatePaymasterUserOp) must return this value\n     * in case of signature failure, instead of revert.\n     */\n    uint256 public constant SIG_VALIDATION_FAILED = 1;\n\n    /**\n     * compensate the caller's beneficiary address with the collected fees of all UserOperations.\n     * @param beneficiary the address to receive the fees\n     * @param amount amount to transfer.\n     */\n    function _compensate(address payable beneficiary, uint256 amount) internal {\n        require(beneficiary != address(0), \"AA90 invalid beneficiary\");\n        (bool success,) = beneficiary.call{value : amount}(\"\");\n        require(success, \"AA91 failed send to beneficiary\");\n    }\n\n    /**\n     * execute a user op\n     * @param opIndex index into the opInfo array\n     * @param userOp the userOp to execute\n     * @param opInfo the opInfo filled by validatePrepayment for this userOp.\n     * @return collected the total amount this userOp paid.\n     */\n    function _executeUserOp(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory opInfo) private returns (uint256 collected) {\n        uint256 preGas = gasleft();\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\n\n        try this.innerHandleOp(userOp.callData, opInfo, context) returns (uint256 _actualGasCost) {\n            collected = _actualGasCost;\n        } catch {\n            bytes32 innerRevertCode;\n            assembly {\n                returndatacopy(0, 0, 32)\n                innerRevertCode := mload(0)\n            }\n            // handleOps was called with gas limit too low. abort entire bundle.\n            if (innerRevertCode == INNER_OUT_OF_GAS) {\n                //report paymaster, since if it is not deliberately caused by the bundler,\n                // it must be a revert caused by paymaster.\n                revert FailedOp(opIndex, \"AA95 out of gas\");\n            }\n\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n            collected = _handlePostOp(opIndex, IPaymaster.PostOpMode.postOpReverted, opInfo, context, actualGas);\n        }\n    }\n\n    /**\n     * Execute a batch of UserOperations.\n     * no signature aggregator is used.\n     * if any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) public nonReentrant {\n\n        uint256 opslen = ops.length;\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\n    unchecked {\n        for (uint256 i = 0; i < opslen; i++) {\n            UserOpInfo memory opInfo = opInfos[i];\n            (uint256 validationData, uint256 pmValidationData) = _validatePrepayment(i, ops[i], opInfo);\n            _validateAccountAndPaymasterValidationData(i, validationData, pmValidationData, address(0));\n        }\n\n        uint256 collected = 0;\n        emit BeforeExecution();\n\n        for (uint256 i = 0; i < opslen; i++) {\n            collected += _executeUserOp(i, ops[i], opInfos[i]);\n        }\n\n        _compensate(beneficiary, collected);\n    } //unchecked\n    }\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\n     * @param beneficiary the address to receive the fees\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) public nonReentrant {\n\n        uint256 opasLen = opsPerAggregator.length;\n        uint256 totalOps = 0;\n        for (uint256 i = 0; i < opasLen; i++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[i];\n            UserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n\n            //address(1) is special marker of \"signature error\"\n            require(address(aggregator) != address(1), \"AA96 invalid aggregator\");\n\n            if (address(aggregator) != address(0)) {\n                // solhint-disable-next-line no-empty-blocks\n                try aggregator.validateSignatures(ops, opa.signature) {}\n                catch {\n                    revert SignatureValidationFailed(address(aggregator));\n                }\n            }\n\n            totalOps += ops.length;\n        }\n\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\n\n        emit BeforeExecution();\n\n        uint256 opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            UserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n\n            uint256 opslen = ops.length;\n            for (uint256 i = 0; i < opslen; i++) {\n                UserOpInfo memory opInfo = opInfos[opIndex];\n                (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(opIndex, ops[i], opInfo);\n                _validateAccountAndPaymasterValidationData(i, validationData, paymasterValidationData, address(aggregator));\n                opIndex++;\n            }\n        }\n\n        uint256 collected = 0;\n        opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            emit SignatureAggregatorChanged(address(opa.aggregator));\n            UserOperation[] calldata ops = opa.userOps;\n            uint256 opslen = ops.length;\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\n                opIndex++;\n            }\n        }\n        emit SignatureAggregatorChanged(address(0));\n\n        _compensate(beneficiary, collected);\n    }\n\n    /// @inheritdoc IEntryPoint\n    function simulateHandleOp(UserOperation calldata op, address target, bytes calldata targetCallData) external override {\n\n        UserOpInfo memory opInfo;\n        _simulationOnlyValidations(op);\n        (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(0, op, opInfo);\n        ValidationData memory data = _intersectTimeRange(validationData, paymasterValidationData);\n\n        numberMarker();\n        uint256 paid = _executeUserOp(0, op, opInfo);\n        numberMarker();\n        bool targetSuccess;\n        bytes memory targetResult;\n        if (target != address(0)) {\n            (targetSuccess, targetResult) = target.call(targetCallData);\n        }\n        revert ExecutionResult(opInfo.preOpGas, paid, data.validAfter, data.validUntil, targetSuccess, targetResult);\n    }\n\n\n    // A memory copy of UserOp static fields only.\n    // Excluding: callData, initCode and signature. Replacing paymasterAndData with paymaster.\n    struct MemoryUserOp {\n        address sender;\n        uint256 nonce;\n        uint256 callGasLimit;\n        uint256 verificationGasLimit;\n        uint256 preVerificationGas;\n        address paymaster;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n    }\n\n    struct UserOpInfo {\n        MemoryUserOp mUserOp;\n        bytes32 userOpHash;\n        uint256 prefund;\n        uint256 contextOffset;\n        uint256 preOpGas;\n    }\n\n    /**\n     * inner function to handle a UserOperation.\n     * Must be declared \"external\" to open a call context, but it can only be called by handleOps.\n     */\n    function innerHandleOp(bytes memory callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        require(msg.sender == address(this), \"AA92 internal call only\");\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n        uint callGasLimit = mUserOp.callGasLimit;\n    unchecked {\n        // handleOps was called with gas limit too low. abort entire bundle.\n        if (gasleft() < callGasLimit + mUserOp.verificationGasLimit + 5000) {\n            assembly {\n                mstore(0, INNER_OUT_OF_GAS)\n                revert(0, 32)\n            }\n        }\n    }\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (callData.length > 0) {\n            bool success = Exec.call(mUserOp.sender, 0, callData, callGasLimit);\n            if (!success) {\n                bytes memory result = Exec.getReturnData(REVERT_REASON_MAX_LEN);\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(opInfo.userOpHash, mUserOp.sender, mUserOp.nonce, result);\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n    unchecked {\n        uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n        //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\n        return _handlePostOp(0, mode, opInfo, context, actualGas);\n    }\n    }\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     */\n    function getUserOpHash(UserOperation calldata userOp) public view returns (bytes32) {\n        return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n    }\n\n    /**\n     * copy general fields from userOp into the memory opInfo structure.\n     */\n    function _copyUserOpToMemory(UserOperation calldata userOp, MemoryUserOp memory mUserOp) internal pure {\n        mUserOp.sender = userOp.sender;\n        mUserOp.nonce = userOp.nonce;\n        mUserOp.callGasLimit = userOp.callGasLimit;\n        mUserOp.verificationGasLimit = userOp.verificationGasLimit;\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\n        mUserOp.maxFeePerGas = userOp.maxFeePerGas;\n        mUserOp.maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        if (paymasterAndData.length > 0) {\n            require(paymasterAndData.length >= 20, \"AA93 invalid paymasterAndData\");\n            mUserOp.paymaster = address(bytes20(paymasterAndData[: 20]));\n        } else {\n            mUserOp.paymaster = address(0);\n        }\n    }\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\n     * @param userOp the user operation to validate.\n     */\n    function simulateValidation(UserOperation calldata userOp) external {\n        UserOpInfo memory outOpInfo;\n\n        _simulationOnlyValidations(userOp);\n        (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(0, userOp, outOpInfo);\n        StakeInfo memory paymasterInfo = _getStakeInfo(outOpInfo.mUserOp.paymaster);\n        StakeInfo memory senderInfo = _getStakeInfo(outOpInfo.mUserOp.sender);\n        StakeInfo memory factoryInfo;\n        {\n            bytes calldata initCode = userOp.initCode;\n            address factory = initCode.length >= 20 ? address(bytes20(initCode[0 : 20])) : address(0);\n            factoryInfo = _getStakeInfo(factory);\n        }\n\n        ValidationData memory data = _intersectTimeRange(validationData, paymasterValidationData);\n        address aggregator = data.aggregator;\n        bool sigFailed = aggregator == address(1);\n        ReturnInfo memory returnInfo = ReturnInfo(outOpInfo.preOpGas, outOpInfo.prefund,\n            sigFailed, data.validAfter, data.validUntil, getMemoryBytesFromOffset(outOpInfo.contextOffset));\n\n        if (aggregator != address(0) && aggregator != address(1)) {\n            AggregatorStakeInfo memory aggregatorInfo = AggregatorStakeInfo(aggregator, _getStakeInfo(aggregator));\n            revert ValidationResultWithAggregation(returnInfo, senderInfo, factoryInfo, paymasterInfo, aggregatorInfo);\n        }\n        revert ValidationResult(returnInfo, senderInfo, factoryInfo, paymasterInfo);\n\n    }\n\n    function _getRequiredPrefund(MemoryUserOp memory mUserOp) internal pure returns (uint256 requiredPrefund) {\n    unchecked {\n        //when using a Paymaster, the verificationGasLimit is used also to as a limit for the postOp call.\n        // our security model might call postOp eventually twice\n        uint256 mul = mUserOp.paymaster != address(0) ? 3 : 1;\n        uint256 requiredGas = mUserOp.callGasLimit + mUserOp.verificationGasLimit * mul + mUserOp.preVerificationGas;\n\n        requiredPrefund = requiredGas * mUserOp.maxFeePerGas;\n    }\n    }\n\n    // create the sender's contract if needed.\n    function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {\n        if (initCode.length != 0) {\n            address sender = opInfo.mUserOp.sender;\n            if (sender.code.length != 0) revert FailedOp(opIndex, \"AA10 sender already constructed\");\n            address sender1 = senderCreator.createSender{gas : opInfo.mUserOp.verificationGasLimit}(initCode);\n            if (sender1 == address(0)) revert FailedOp(opIndex, \"AA13 initCode failed or OOG\");\n            if (sender1 != sender) revert FailedOp(opIndex, \"AA14 initCode must return sender\");\n            if (sender1.code.length == 0) revert FailedOp(opIndex, \"AA15 initCode must create sender\");\n            address factory = address(bytes20(initCode[0 : 20]));\n            emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);\n        }\n    }\n\n    /**\n     * Get counterfactual sender address.\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * this method always revert, and returns the address in SenderAddressResult error\n     * @param initCode the constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes calldata initCode) public {\n        address sender = senderCreator.createSender(initCode);\n        revert SenderAddressResult(sender);\n    }\n\n    function _simulationOnlyValidations(UserOperation calldata userOp) internal view {\n        // solhint-disable-next-line no-empty-blocks\n        try this._validateSenderAndPaymaster(userOp.initCode, userOp.sender, userOp.paymasterAndData) {}\n        catch Error(string memory revertReason) {\n            if (bytes(revertReason).length != 0) {\n                revert FailedOp(0, revertReason);\n            }\n        }\n    }\n\n    /**\n    * Called only during simulation.\n    * This function always reverts to prevent warm/cold storage differentiation in simulation vs execution.\n    */\n    function _validateSenderAndPaymaster(bytes calldata initCode, address sender, bytes calldata paymasterAndData) external view {\n        if (initCode.length == 0 && sender.code.length == 0) {\n            // it would revert anyway. but give a meaningful message\n            revert(\"AA20 account not deployed\");\n        }\n        if (paymasterAndData.length >= 20) {\n            address paymaster = address(bytes20(paymasterAndData[0 : 20]));\n            if (paymaster.code.length == 0) {\n                // it would revert anyway. but give a meaningful message\n                revert(\"AA30 paymaster not deployed\");\n            }\n        }\n        // always revert\n        revert(\"\");\n    }\n\n    /**\n     * call account.validateUserOp.\n     * revert (with FailedOp) in case validateUserOp reverts, or account didn't send required prefund.\n     * decrement account's deposit if needed\n     */\n    function _validateAccountPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPrefund)\n    internal returns (uint256 gasUsedByValidateAccountPrepayment, uint256 validationData) {\n    unchecked {\n        uint256 preGas = gasleft();\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n        address sender = mUserOp.sender;\n        _createSenderIfNeeded(opIndex, opInfo, op.initCode);\n        address paymaster = mUserOp.paymaster;\n        numberMarker();\n        uint256 missingAccountFunds = 0;\n        if (paymaster == address(0)) {\n            uint256 bal = balanceOf(sender);\n            missingAccountFunds = bal > requiredPrefund ? 0 : requiredPrefund - bal;\n        }\n        try IAccount(sender).validateUserOp{gas : mUserOp.verificationGasLimit}(op, opInfo.userOpHash, missingAccountFunds)\n        returns (uint256 _validationData) {\n            validationData = _validationData;\n        } catch Error(string memory revertReason) {\n            revert FailedOp(opIndex, string.concat(\"AA23 reverted: \", revertReason));\n        } catch {\n            revert FailedOp(opIndex, \"AA23 reverted (or OOG)\");\n        }\n        if (paymaster == address(0)) {\n            DepositInfo storage senderInfo = deposits[sender];\n            uint256 deposit = senderInfo.deposit;\n            if (requiredPrefund > deposit) {"
    }
  ]
}