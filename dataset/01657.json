{
  "Title": "H-2: ArrakisV2Router#addLiquidityPermit2 will strand ETH",
  "Content": "# Issue H-2: ArrakisV2Router#addLiquidityPermit2 will strand ETH \n\nSource: https://github.com/sherlock-audit/2023-06-arrakis-judging/issues/183 \n\n## Found by \n0x007, 0x52, 0xpinky, BenRai, DadeKuma, Jeiwan, auditor0517, auditsea, branch\\_indigo, elephant\\_coral, kutugu, rvierdiiev, tallo\n## Summary\n\nInside ArrakisV2Router#addLiquidityPermit2, `isToken0Weth` is set incorrectly leading to the wrong amount of ETH being refunded to the user\n\n## Vulnerability Detail\n\n[ArrakisV2Router.sol#L278-L298](https://github.com/sherlock-audit/2023-06-arrakis/blob/main/v2-periphery/contracts/ArrakisV2Router.sol#L278-L298)\n\n        bool isToken0Weth;\n        _permit2Add(params_, amount0, amount1, token0, token1);\n\n        _addLiquidity(\n            params_.addData.vault,\n            amount0,\n            amount1,\n            sharesReceived,\n            params_.addData.gauge,\n            params_.addData.receiver,\n            token0,\n            token1\n        );\n\n        if (msg.value > 0) {\n            if (isToken0Weth && msg.value > amount0) {\n                payable(msg.sender).sendValue(msg.value - amount0);\n            } else if (!isToken0Weth && msg.value > amount1) {\n                payable(msg.sender).sendValue(msg.value - amount1);\n            }\n        }\n\nAbove we see that excess msg.value is returned to the user at the end of the function. This uses the value of isToken0Weth to determine the amount to send back to the user. The issue is that `isToken0Weth` is set incorrectly and will lead to ETH being stranded in the contract. `isToken0Weth` is never set, it will always be `false`. This means that when WETH actually is token0 the incorrect amount of ETH will be sent back to the user. \n\nThis same issue can also be used to steal the ETH left in the contract by a malicious user. To make matters worse, the attacker can manipulate the underlying pools to increase the amount of ETH left in the contract so they can steal even more.\n\n## Impact\n\nETH will be stranded in contract and stolen\n\n## Code Snippet\n\n[ArrakisV2Router.sol#L238-L299](https://github.com/sherlock-audit/2023-06-arrakis/blob/main/v2-periphery/contracts/ArrakisV2Router.sol#L238-L299)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nMove `isToken0Weth` and set it correctly:\n\n    -   bool isToken0Weth;\n        _permit2Add(params_, amount0, amount1, token0, token1);\n\n        _addLiquidity(\n            params_.addData.vault,\n            amount0,\n            amount1,\n            sharesReceived,\n            params_.addData.gauge,\n            params_.addData.receiver,\n            token0,\n            token1\n        );\n\n        if (msg.value > 0) {\n    +       bool isToken0Weth = _isToken0Weth(address(token0), address(token1));\n            if (isToken0Weth && msg.value > amount0) {\n                payable(msg.sender).sendValue(msg.value - amount0);\n            } else if (!isToken0Weth && msg.value > amount1) {\n                payable(msg.sender).sendValue(msg.value - amount1);\n            }\n        }\n\n\n\n## Discussion\n\n**Gevarist**\n\nWe consider the issue as a medium issue, some user fund can be lost. Only the stranded eth can be potentially stolen.\n\n**ctf-sec**\n\nThe finding result in lose of fund, recommend maintaining high severity.\n\n**Gevarist**\n\n@ctf-sec stealing fund is only possible if loss of fund happen before. I would argue that seems like a medium severity issue.\n\n**0xpinky**\n\n@Gevarist stealing also one of the way for losing funds.. but thats not the only way.. any form of loss is loss only.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/86",
  "Code": [
    {
      "filename": "v2-periphery/contracts/ArrakisV2Router.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport {IGauge} from \"./interfaces/IGauge.sol\";\nimport {\n    IERC20,\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {\n    IArrakisV2\n} from \"@arrakisfi/v2-core/contracts/interfaces/IArrakisV2.sol\";\nimport {\n    AddLiquidityData,\n    AddLiquidityPermit2Data,\n    PermitTransferFrom,\n    RemoveLiquidityData,\n    RemoveLiquidityPermit2Data,\n    SwapAndAddData,\n    SwapAndAddPermit2Data\n} from \"./structs/SArrakisV2Router.sol\";\nimport {SignatureTransferDetails} from \"./structs/SPermit2.sol\";\nimport {ArrakisV2RouterStorage} from \"./abstract/ArrakisV2RouterStorage.sol\";\nimport {MintRules} from \"./structs/SArrakisV2Router.sol\";\nimport {\n    EnumerableSet\n} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @title ArrakisV2 Public Vault Router\n/// @notice Smart contract for adding and removing liquidity from Public ArrakisV2 vaults\n/// @author Arrakis Finance\n/// @dev DO NOT ADD STATE VARIABLES - APPEND THEM TO ArrakisV2RouterStorage\ncontract ArrakisV2Router is ArrakisV2RouterStorage {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address payable;\n    using SafeERC20 for IERC20;\n\n    constructor(\n        address weth_,\n        address resolver_,\n        address permit2_\n    ) ArrakisV2RouterStorage(weth_, resolver_, permit2_) {} // solhint-disable-line no-empty-blocks\n\n    /// @notice addLiquidity adds liquidity to ArrakisV2 vault of interest (mints LP tokens)\n    /// @param params_ AddLiquidityData struct containing data for adding liquidity\n    /// @return amount0 amount of token0 transferred from msg.sender to mint `mintAmount`\n    /// @return amount1 amount of token1 transferred from msg.sender to mint `mintAmount`\n    /// @return sharesReceived amount of ArrakisV2 tokens transferred to `receiver`\n    // solhint-disable-next-line code-complexity, function-max-lines\n    function addLiquidity(AddLiquidityData memory params_)\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256 amount0,\n            uint256 amount1,\n            uint256 sharesReceived\n        )\n    {\n        require(\n            params_.amount0Max > 0 || params_.amount1Max > 0,\n            \"Empty max amounts\"\n        );\n        if (params_.gauge != address(0)) {\n            require(\n                params_.vault == IGauge(params_.gauge).staking_token(),\n                \"Incorrect gauge!\"\n            );\n        }\n\n        (amount0, amount1, sharesReceived) = resolver.getMintAmounts(\n            IArrakisV2(params_.vault),\n            params_.amount0Max,\n            params_.amount1Max\n        );\n\n        require(sharesReceived > 0, \"nothing to mint\");\n        require(\n            amount0 >= params_.amount0Min &&\n                amount1 >= params_.amount1Min &&\n                sharesReceived >= params_.amountSharesMin,\n            \"below min amounts\"\n        );\n\n        IERC20 token0 = IArrakisV2(params_.vault).token0();\n        IERC20 token1 = IArrakisV2(params_.vault).token1();\n\n        bool isToken0Weth;\n        if (msg.value > 0) {\n            isToken0Weth = _wrapETH(amount0, amount1, false, token0, token1);\n        }\n\n        if (amount0 > 0 && (msg.value == 0 || !isToken0Weth)) {\n            token0.safeTransferFrom(msg.sender, address(this), amount0);\n        }\n        if (amount1 > 0 && (msg.value == 0 || isToken0Weth)) {\n            token1.safeTransferFrom(msg.sender, address(this), amount1);\n        }\n\n        _addLiquidity(\n            params_.vault,\n            amount0,\n            amount1,\n            sharesReceived,\n            params_.gauge,\n            params_.receiver,\n            token0,\n            token1\n        );\n\n        if (msg.value > 0) {\n            if (isToken0Weth && msg.value > amount0) {\n                payable(msg.sender).sendValue(msg.value - amount0);\n            } else if (!isToken0Weth && msg.value > amount1) {\n                payable(msg.sender).sendValue(msg.value - amount1);\n            }\n        }\n    }\n\n    /// @notice swapAndAddLiquidity transfer tokens to and calls ArrakisV2Router\n    /// @param params_ SwapAndAddData struct containing data for swap\n    /// @return amount0 amount of token0 transferred from msg.sender to mint `mintAmount`\n    /// @return amount1 amount of token1 transferred from msg.sender to mint `mintAmount`\n    /// @return sharesReceived amount of ArrakisV2 tokens transferred to `receiver`\n    /// @return amount0Diff token0 balance difference post swap\n    /// @return amount1Diff token1 balance difference post swap\n    // solhint-disable-next-line code-complexity, function-max-lines\n    function swapAndAddLiquidity(SwapAndAddData memory params_)\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256 amount0,\n            uint256 amount1,\n            uint256 sharesReceived,\n            uint256 amount0Diff,\n            uint256 amount1Diff\n        )\n    {\n        require(\n            params_.addData.amount0Max > 0 || params_.addData.amount1Max > 0,\n            \"Empty max amounts\"\n        );\n        if (params_.addData.gauge != address(0)) {\n            require(\n                params_.addData.vault ==\n                    IGauge(params_.addData.gauge).staking_token(),\n                \"Incorrect gauge!\"\n            );\n        }\n\n        IERC20 token0 = IArrakisV2(params_.addData.vault).token0();\n        IERC20 token1 = IArrakisV2(params_.addData.vault).token1();\n\n        bool isToken0Weth;\n        if (msg.value > 0) {\n            isToken0Weth = _wrapETH(\n                params_.addData.amount0Max,\n                params_.addData.amount1Max,\n                true,\n                token0,\n                token1\n            );\n        }\n\n        if (\n            params_.addData.amount0Max > 0 && (msg.value == 0 || !isToken0Weth)\n        ) {\n            token0.safeTransferFrom(\n                msg.sender,\n                address(this),\n                params_.addData.amount0Max\n            );\n        }\n        if (\n            params_.addData.amount1Max > 0 && (msg.value == 0 || isToken0Weth)\n        ) {\n            token1.safeTransferFrom(\n                msg.sender,\n                address(this),\n                params_.addData.amount1Max\n            );\n        }\n\n        (\n            amount0,\n            amount1,\n            sharesReceived,\n            amount0Diff,\n            amount1Diff\n        ) = _swapAndAddLiquidity(params_, token0, token1);\n    }\n\n    /// @notice removeLiquidity removes liquidity from vault and burns LP tokens\n    /// @param params_ RemoveLiquidityData struct containing data for withdrawals\n    /// @return amount0 actual amount of token0 transferred to receiver for burning `burnAmount`\n    /// @return amount1 actual amount of token1 transferred to receiver for burning `burnAmount`\n    // solhint-disable-next-line code-complexity, function-max-lines\n    function removeLiquidity(RemoveLiquidityData memory params_)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(params_.burnAmount > 0, \"nothing to burn\");\n        if (params_.gauge != address(0)) {\n            require(\n                params_.vault == IGauge(params_.gauge).staking_token(),\n                \"Incorrect gauge!\"\n            );\n            IGauge(params_.gauge).claim_rewards(msg.sender);\n            IERC20(params_.gauge).safeTransferFrom(\n                msg.sender,\n                address(this),\n                params_.burnAmount\n            );\n\n            IGauge(params_.gauge).withdraw(params_.burnAmount);\n        } else {\n            IERC20(params_.vault).safeTransferFrom(\n                msg.sender,\n                address(this),\n                params_.burnAmount\n            );\n        }\n\n        (amount0, amount1) = _removeLiquidity(params_);\n    }\n\n    /// @notice addLiquidityPermit2 adds liquidity to ArrakisV2 vault of interest (mints LP tokens)\n    /// @param params_ AddLiquidityPermit2Data struct containing data for adding liquidity\n    /// @return amount0 amount of token0 transferred from msg.sender to mint `mintAmount`\n    /// @return amount1 amount of token1 transferred from msg.sender to mint `mintAmount`\n    /// @return sharesReceived amount of ArrakisV2 tokens transferred to `receiver`\n    // solhint-disable-next-line code-complexity, function-max-lines\n    function addLiquidityPermit2(AddLiquidityPermit2Data memory params_)\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256 amount0,\n            uint256 amount1,\n            uint256 sharesReceived\n        )\n    {\n        require(\n            params_.addData.amount0Max > 0 || params_.addData.amount1Max > 0,\n            \"Empty max amounts\"\n        );\n        if (params_.addData.gauge != address(0)) {\n            require(\n                params_.addData.vault ==\n                    IGauge(params_.addData.gauge).staking_token(),\n                \"Incorrect gauge!\"\n            );\n        }\n\n        (amount0, amount1, sharesReceived) = resolver.getMintAmounts(\n            IArrakisV2(params_.addData.vault),\n            params_.addData.amount0Max,\n            params_.addData.amount1Max\n        );\n\n        require(sharesReceived > 0, \"nothing to mint\");\n        require(\n            amount0 >= params_.addData.amount0Min &&\n                amount1 >= params_.addData.amount1Min &&\n                sharesReceived >= params_.addData.amountSharesMin,\n            \"below min amounts\"\n        );\n\n        IERC20 token0 = IArrakisV2(params_.addData.vault).token0();\n        IERC20 token1 = IArrakisV2(params_.addData.vault).token1();\n\n        bool isToken0Weth;\n        _permit2Add(params_, amount0, amount1, token0, token1);\n\n        _addLiquidity(\n            params_.addData.vault,\n            amount0,\n            amount1,\n            sharesReceived,\n            params_.addData.gauge,\n            params_.addData.receiver,\n            token0,\n            token1\n        );\n\n        if (msg.value > 0) {\n            if (isToken0Weth && msg.value > amount0) {\n                payable(msg.sender).sendValue(msg.value - amount0);\n            } else if (!isToken0Weth && msg.value > amount1) {\n                payable(msg.sender).sendValue(msg.value - amount1);\n            }\n        }\n    }\n\n    /// @notice swapAndAddLiquidityPermit2 transfer tokens to and calls ArrakisV2Router\n    /// @param params_ SwapAndAddPermit2Data struct containing data for swap\n    /// @return amount0 amount of token0 transferred from msg.sender to mint `mintAmount`\n    /// @return amount1 amount of token1 transferred from msg.sender to mint `mintAmount`\n    /// @return sharesReceived amount of ArrakisV2 tokens transferred to `receiver`\n    /// @return amount0Diff token0 balance difference post swap\n    /// @return amount1Diff token1 balance difference post swap\n    // solhint-disable-next-line code-complexity, function-max-lines\n    function swapAndAddLiquidityPermit2(SwapAndAddPermit2Data memory params_)\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256 amount0,\n            uint256 amount1,\n            uint256 sharesReceived,\n            uint256 amount0Diff,\n            uint256 amount1Diff\n        )\n    {\n        require(\n            params_.swapAndAddData.addData.amount0Max > 0 ||\n                params_.swapAndAddData.addData.amount1Max > 0,\n            \"Empty max amounts\"\n        );\n        if (params_.swapAndAddData.addData.gauge != address(0)) {\n            require(\n                params_.swapAndAddData.addData.vault ==\n                    IGauge(params_.swapAndAddData.addData.gauge)\n                        .staking_token(),\n                \"Incorrect gauge!\"\n            );\n        }\n\n        IERC20 token0 = IArrakisV2(params_.swapAndAddData.addData.vault)\n            .token0();\n        IERC20 token1 = IArrakisV2(params_.swapAndAddData.addData.vault)\n            .token1();\n\n        _permit2SwapAndAdd(params_, token0, token1);\n\n        (\n            amount0,\n            amount1,\n            sharesReceived,\n            amount0Diff,\n            amount1Diff\n        ) = _swapAndAddLiquidity(params_.swapAndAddData, token0, token1);\n    }\n\n    /// @notice removeLiquidityPermit2 removes liquidity from vault and burns LP tokens\n    /// @param params_ RemoveLiquidityPermit2Data struct containing data for withdrawals\n    /// @return amount0 actual amount of token0 transferred to receiver for burning `burnAmount`\n    /// @return amount1 actual amount of token1 transferred to receiver for burning `burnAmount`\n    // solhint-disable-next-line code-complexity, function-max-lines\n    function removeLiquidityPermit2(RemoveLiquidityPermit2Data memory params_)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(params_.removeData.burnAmount > 0, \"nothing to burn\");\n        SignatureTransferDetails\n            memory transferDetails = SignatureTransferDetails({\n                to: address(this),\n                requestedAmount: params_.removeData.burnAmount\n            });\n        if (params_.removeData.gauge != address(0)) {\n            require(\n                params_.removeData.vault ==\n                    IGauge(params_.removeData.gauge).staking_token(),\n                \"Incorrect gauge!\"\n            );\n            IGauge(params_.removeData.gauge).claim_rewards(msg.sender);\n            permit2.permitTransferFrom(\n                params_.permit,\n                transferDetails,\n                msg.sender,\n                params_.signature\n            );\n\n            IGauge(params_.removeData.gauge).withdraw(\n                params_.removeData.burnAmount\n            );\n        } else {\n            permit2.permitTransferFrom(\n                params_.permit,\n                transferDetails,\n                msg.sender,\n                params_.signature\n            );\n        }\n\n        (amount0, amount1) = _removeLiquidity(params_.removeData);\n    }\n\n    // solhint-disable-next-line function-max-lines\n    function _addLiquidity(\n        address vault_,\n        uint256 amount0In_,\n        uint256 amount1In_,\n        uint256 mintAmount_,\n        address gauge_,\n        address receiver_,\n        IERC20 token0_,\n        IERC20 token1_\n    ) internal {\n        token0_.safeIncreaseAllowance(vault_, amount0In_);\n        token1_.safeIncreaseAllowance(vault_, amount1In_);\n\n        {\n            MintRules memory mintRules = mintRestrictedVaults[vault_];\n            if (mintRules.supplyCap > 0) {\n                require(\n                    IArrakisV2(vault_).totalSupply() + mintAmount_ <=\n                        mintRules.supplyCap,\n                    \"above supply cap\"\n                );\n            }\n            if (mintRules.hasWhitelist) {\n                require(\n                    _mintWhitelist[vault_].contains(msg.sender),\n                    \"not whitelisted\"\n                );\n            }\n        }\n\n        uint256 balance0 = token0_.balanceOf(address(this));\n        uint256 balance1 = token1_.balanceOf(address(this));\n        if (gauge_ == address(0)) {\n            IArrakisV2(vault_).mint(mintAmount_, receiver_);\n        } else {\n            IArrakisV2(vault_).mint(mintAmount_, address(this));\n\n            IERC20(vault_).safeIncreaseAllowance(gauge_, mintAmount_);\n            IGauge(gauge_).deposit(mintAmount_, receiver_);\n        }\n\n        require(\n            balance0 - amount0In_ == token0_.balanceOf(address(this)),\n            \"deposit0\"\n        );\n        require(\n            balance1 - amount1In_ == token1_.balanceOf(address(this)),\n            \"deposit1\"\n        );\n    }\n\n    // solhint-disable-next-line function-max-lines, code-complexity\n    function _swapAndAddLiquidity(\n        SwapAndAddData memory params_,\n        IERC20 token0_,\n        IERC20 token1_\n    )\n        internal\n        returns (\n            uint256 amount0,\n            uint256 amount1,\n            uint256 sharesReceived,\n            uint256 amount0Diff,\n            uint256 amount1Diff\n        )\n    {\n        if (params_.swapData.zeroForOne) {\n            token0_.safeTransfer(\n                address(swapper),\n                params_.swapData.amountInSwap\n            );\n        } else {\n            token1_.safeTransfer(\n                address(swapper),\n                params_.swapData.amountInSwap\n            );\n        }\n\n        (amount0Diff, amount1Diff) = swapper.swap(params_);\n\n        emit Swapped(\n            params_.swapData.zeroForOne,\n            amount0Diff,\n            amount1Diff,\n            params_.swapData.amountOutSwap\n        );\n\n        uint256 amount0Use = (params_.swapData.zeroForOne)\n            ? params_.addData.amount0Max - amount0Diff\n            : params_.addData.amount0Max + amount0Diff;\n        uint256 amount1Use = (params_.swapData.zeroForOne)\n            ? params_.addData.amount1Max + amount1Diff\n            : params_.addData.amount1Max - amount1Diff;\n\n        (amount0, amount1, sharesReceived) = resolver.getMintAmounts(\n            IArrakisV2(params_.addData.vault),\n            amount0Use,\n            amount1Use\n        );\n\n        require(sharesReceived > 0, \"nothing to mint\");\n        require(\n            amount0 >= params_.addData.amount0Min &&\n                amount1 >= params_.addData.amount1Min &&\n                sharesReceived >= params_.addData.amountSharesMin,\n            \"below min amounts\"\n        );\n\n        _addLiquidity(\n            params_.addData.vault,\n            amount0,\n            amount1,\n            sharesReceived,\n            params_.addData.gauge,\n            params_.addData.receiver,\n            token0_,\n            token1_\n        );\n\n        bool isToken0Weth;\n        if (msg.value > 0) {\n            isToken0Weth = _isToken0Weth(address(token0_), address(token1_));\n            if (isToken0Weth && amount0Use > amount0) {\n                _unwrapRefundETH(msg.sender, amount0Use - amount0);\n            } else if (!isToken0Weth && amount1Use > amount1) {\n                _unwrapRefundETH(msg.sender, amount1Use - amount1);\n            }\n        }\n\n        if (amount0Use > amount0 && (msg.value == 0 || !isToken0Weth)) {\n            token0_.safeTransfer(msg.sender, amount0Use - amount0);\n        }\n        if (amount1Use > amount1 && (msg.value == 0 || isToken0Weth)) {\n            token1_.safeTransfer(msg.sender, amount1Use - amount1);\n        }\n    }\n\n    function _removeLiquidity(RemoveLiquidityData memory removeData_)\n        internal\n        returns (uint256 amount0, uint256 amount1)\n    {\n        if (removeData_.receiveETH) {\n            (amount0, amount1) = IArrakisV2(removeData_.vault).burn(\n                removeData_.burnAmount,\n                address(this)\n            );\n        } else {\n            (amount0, amount1) = IArrakisV2(removeData_.vault).burn(\n                removeData_.burnAmount,\n                removeData_.receiver\n            );\n        }\n\n        require(\n            amount0 >= removeData_.amount0Min &&\n                amount1 >= removeData_.amount1Min,\n            \"received below minimum\"\n        );\n\n        if (removeData_.receiveETH) {\n            _receiveETH(\n                IArrakisV2(removeData_.vault),\n                amount0,\n                amount1,\n                removeData_.receiver\n            );\n        }\n    }\n\n    // solhint-disable-next-line function-max-lines\n    function _permit2Add(\n        AddLiquidityPermit2Data memory params_,\n        uint256 amount0_,\n        uint256 amount1_,\n        IERC20 token0_,\n        IERC20 token1_\n    ) internal {\n        if (msg.value > 0) {\n            require(params_.permit.permitted.length == 1, \"length mismatch\");\n            bool isToken0Weth = _wrapETH(\n                amount0_,\n                amount1_,\n                false,\n                token0_,\n                token1_\n            );\n            uint256 amount = isToken0Weth ? amount1_ : amount0_;\n            if (amount > 0) {\n                SignatureTransferDetails\n                    memory transferDetails = SignatureTransferDetails({\n                        to: address(this),\n                        requestedAmount: amount\n                    });\n                PermitTransferFrom memory permit = PermitTransferFrom({\n                    permitted: params_.permit.permitted[0],\n                    nonce: params_.permit.nonce,\n                    deadline: params_.permit.deadline\n                });\n                permit2.permitTransferFrom(\n                    permit,\n                    transferDetails,\n                    msg.sender,\n                    params_.signature\n                );\n            }\n        } else {\n            require(params_.permit.permitted.length == 2, \"length mismatch\");\n            SignatureTransferDetails[]\n                memory transfers = new SignatureTransferDetails[](2);\n            transfers[0] = SignatureTransferDetails({\n                to: address(this),\n                requestedAmount: amount0_\n            });\n            transfers[1] = SignatureTransferDetails({\n                to: address(this),\n                requestedAmount: amount1_\n            });\n            permit2.permitTransferFrom(\n                params_.permit,\n                transfers,\n                msg.sender,\n                params_.signature\n            );\n        }\n    }\n\n    // solhint-disable-next-line function-max-lines\n    function _permit2SwapAndAdd(\n        SwapAndAddPermit2Data memory params_,\n        IERC20 token0_,\n        IERC20 token1_\n    ) internal {\n        if (msg.value > 0) {\n            require(params_.permit.permitted.length == 1, \"length mismatch\");\n            bool isToken0Weth = _wrapETH(\n                params_.swapAndAddData.addData.amount0Max,\n                params_.swapAndAddData.addData.amount1Max,\n                true,\n                token0_,\n                token1_\n            );\n            uint256 amount = isToken0Weth\n                ? params_.swapAndAddData.addData.amount1Max\n                : params_.swapAndAddData.addData.amount0Max;\n            if (amount > 0) {\n                SignatureTransferDetails\n                    memory transferDetails = SignatureTransferDetails({\n                        to: address(this),\n                        requestedAmount: amount\n                    });\n                PermitTransferFrom memory permit = PermitTransferFrom({\n                    permitted: params_.permit.permitted[0],\n                    nonce: params_.permit.nonce,\n                    deadline: params_.permit.deadline\n                });\n                permit2.permitTransferFrom(\n                    permit,\n                    transferDetails,\n                    msg.sender,\n                    params_.signature\n                );\n            }\n        } else {\n            require(params_.permit.permitted.length == 2, \"length mismatch\");\n            SignatureTransferDetails[]\n                memory transfers = new SignatureTransferDetails[](2);\n            transfers[0] = SignatureTransferDetails({\n                to: address(this),\n                requestedAmount: params_.swapAndAddData.addData.amount0Max\n            });\n            transfers[1] = SignatureTransferDetails({\n                to: address(this),\n                requestedAmount: params_.swapAndAddData.addData.amount1Max\n            });\n            permit2.permitTransferFrom(\n                params_.permit,\n                transfers,\n                msg.sender,\n                params_.signature\n            );\n        }\n    }\n\n    function _wrapETH(\n        uint256 amount0In_,\n        uint256 amount1In_,\n        bool matchAmount_,\n        IERC20 token0_,\n        IERC20 token1_\n    ) internal returns (bool isToken0Weth) {\n        isToken0Weth = _isToken0Weth(address(token0_), address(token1_));\n        uint256 wethAmount = isToken0Weth ? amount0In_ : amount1In_;\n        if (matchAmount_) {\n            require(wethAmount == msg.value, \"Invalid amount of ETH forwarded\");\n        } else {\n            require(wethAmount <= msg.value, \"Not enough ETH forwarded\");\n        }\n\n        weth.deposit{value: wethAmount}();\n    }\n\n    function _unwrapRefundETH(address refund_, uint256 refundAmount_) internal {\n        weth.withdraw(refundAmount_);\n        payable(refund_).sendValue(refundAmount_);\n    }\n\n    // solhint-disable-next-line code-complexity\n    function _receiveETH(\n        IArrakisV2 vault_,\n        uint256 amount0_,\n        uint256 amount1_,\n        address payable receiver_\n    ) internal {\n        IERC20 token0 = vault_.token0();\n        IERC20 token1 = vault_.token1();\n        bool wethToken0 = _isToken0Weth(address(token0), address(token1));\n        if (wethToken0) {\n            if (amount0_ > 0) {\n                weth.withdraw(amount0_);\n                receiver_.sendValue(amount0_);\n            }\n            if (amount1_ > 0) {\n                token1.safeTransfer(receiver_, amount1_);\n            }\n        } else {\n            if (amount1_ > 0) {\n                weth.withdraw(amount1_);\n                receiver_.sendValue(amount1_);\n            }\n            if (amount0_ > 0) {\n                token0.safeTransfer(receiver_, amount0_);\n            }\n        }\n    }\n\n    function _isToken0Weth(address token0_, address token1_)\n        internal\n        view\n        returns (bool wethToken0)\n    {\n        if (token0_ == address(weth)) {\n            wethToken0 = true;\n        } else if (token1_ == address(weth)) {\n            wethToken0 = false;\n        } else {\n            revert(\"one vault token must be WETH\");\n        }\n    }\n}"
    },
    {
      "filename": "v2-periphery/contracts/ArrakisV2Router.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport {IGauge} from \"./interfaces/IGauge.sol\";\nimport {\n    IERC20,\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {\n    IArrakisV2\n} from \"@arrakisfi/v2-core/contracts/interfaces/IArrakisV2.sol\";\nimport {\n    AddLiquidityData,\n    AddLiquidityPermit2Data,\n    PermitTransferFrom,\n    RemoveLiquidityData,\n    RemoveLiquidityPermit2Data,\n    SwapAndAddData,\n    SwapAndAddPermit2Data\n} from \"./structs/SArrakisV2Router.sol\";\nimport {SignatureTransferDetails} from \"./structs/SPermit2.sol\";\nimport {ArrakisV2RouterStorage} from \"./abstract/ArrakisV2RouterStorage.sol\";\nimport {MintRules} from \"./structs/SArrakisV2Router.sol\";\nimport {\n    EnumerableSet\n} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @title ArrakisV2 Public Vault Router\n/// @notice Smart contract for adding and removing liquidity from Public ArrakisV2 vaults\n/// @author Arrakis Finance\n/// @dev DO NOT ADD STATE VARIABLES - APPEND THEM TO ArrakisV2RouterStorage\ncontract ArrakisV2Router is ArrakisV2RouterStorage {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address payable;\n    using SafeERC20 for IERC20;\n\n    constructor(\n        address weth_,\n        address resolver_,\n        address permit2_\n    ) ArrakisV2RouterStorage(weth_, resolver_, permit2_) {} // solhint-disable-line no-empty-blocks\n\n    /// @notice addLiquidity adds liquidity to ArrakisV2 vault of interest (mints LP tokens)\n    /// @param params_ AddLiquidityData struct containing data for adding liquidity\n    /// @return amount0 amount of token0 transferred from msg.sender to mint `mintAmount`\n    /// @return amount1 amount of token1 transferred from msg.sender to mint `mintAmount`\n    /// @return sharesReceived amount of ArrakisV2 tokens transferred to `receiver`\n    // solhint-disable-next-line code-complexity, function-max-lines\n    function addLiquidity(AddLiquidityData memory params_)\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256 amount0,\n            uint256 amount1,\n            uint256 sharesReceived\n        )\n    {\n        require(\n            params_.amount0Max > 0 || params_.amount1Max > 0,\n            \"Empty max amounts\"\n        );\n        if (params_.gauge != address(0)) {\n            require(\n                params_.vault == IGauge(params_.gauge).staking_token(),\n                \"Incorrect gauge!\"\n            );\n        }\n\n        (amount0, amount1, sharesReceived) = resolver.getMintAmounts(\n            IArrakisV2(params_.vault),\n            params_.amount0Max,\n            params_.amount1Max\n        );\n\n        require(sharesReceived > 0, \"nothing to mint\");\n        require(\n            amount0 >= params_.amount0Min &&\n                amount1 >= params_.amount1Min &&\n                sharesReceived >= params_.amountSharesMin,\n            \"below min amounts\"\n        );\n\n        IERC20 token0 = IArrakisV2(params_.vault).token0();\n        IERC20 token1 = IArrakisV2(params_.vault).token1();\n\n        bool isToken0Weth;\n        if (msg.value > 0) {\n            isToken0Weth = _wrapETH(amount0, amount1, false, token0, token1);\n        }\n\n        if (amount0 > 0 && (msg.value == 0 || !isToken0Weth)) {\n            token0.safeTransferFrom(msg.sender, address(this), amount0);\n        }\n        if (amount1 > 0 && (msg.value == 0 || isToken0Weth)) {\n            token1.safeTransferFrom(msg.sender, address(this), amount1);\n        }\n\n        _addLiquidity(\n            params_.vault,\n            amount0,\n            amount1,\n            sharesReceived,\n            params_.gauge,\n            params_.receiver,\n            token0,\n            token1\n        );\n\n        if (msg.value > 0) {\n            if (isToken0Weth && msg.value > amount0) {\n                payable(msg.sender).sendValue(msg.value - amount0);\n            } else if (!isToken0Weth && msg.value > amount1) {\n                payable(msg.sender).sendValue(msg.value - amount1);\n            }\n        }\n    }\n\n    /// @notice swapAndAddLiquidity transfer tokens to and calls ArrakisV2Router\n    /// @param params_ SwapAndAddData struct containing data for swap\n    /// @return amount0 amount of token0 transferred from msg.sender to mint `mintAmount`\n    /// @return amount1 amount of token1 transferred from msg.sender to mint `mintAmount`\n    /// @return sharesReceived amount of ArrakisV2 tokens transferred to `receiver`\n    /// @return amount0Diff token0 balance difference post swap\n    /// @return amount1Diff token1 balance difference post swap\n    // solhint-disable-next-line code-complexity, function-max-lines\n    function swapAndAddLiquidity(SwapAndAddData memory params_)\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256 amount0,\n            uint256 amount1,\n            uint256 sharesReceived,\n            uint256 amount0Diff,\n            uint256 amount1Diff\n        )\n    {\n        require(\n            params_.addData.amount0Max > 0 || params_.addData.amount1Max > 0,\n            \"Empty max amounts\"\n        );\n        if (params_.addData.gauge != address(0)) {\n            require(\n                params_.addData.vault ==\n                    IGauge(params_.addData.gauge).staking_token(),\n                \"Incorrect gauge!\"\n            );\n        }\n\n        IERC20 token0 = IArrakisV2(params_.addData.vault).token0();\n        IERC20 token1 = IArrakisV2(params_.addData.vault).token1();\n\n        bool isToken0Weth;\n        if (msg.value > 0) {\n            isToken0Weth = _wrapETH(\n                params_.addData.amount0Max,\n                params_.addData.amount1Max,\n                true,\n                token0,\n                token1\n            );\n        }\n\n        if (\n            params_.addData.amount0Max > 0 && (msg.value == 0 || !isToken0Weth)\n        ) {\n            token0.safeTransferFrom(\n                msg.sender,\n                address(this),\n                params_.addData.amount0Max\n            );\n        }\n        if (\n            params_.addData.amount1Max > 0 && (msg.value == 0 || isToken0Weth)\n        ) {\n            token1.safeTransferFrom(\n                msg.sender,\n                address(this),\n                params_.addData.amount1Max\n            );\n        }\n\n        (\n            amount0,\n            amount1,\n            sharesReceived,\n            amount0Diff,\n            amount1Diff\n        ) = _swapAndAddLiquidity(params_, token0, token1);\n    }\n\n    /// @notice removeLiquidity removes liquidity from vault and burns LP tokens\n    /// @param params_ RemoveLiquidityData struct containing data for withdrawals\n    /// @return amount0 actual amount of token0 transferred to receiver for"
    }
  ]
}