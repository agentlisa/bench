{
  "Title": "M-3: Malicious actor can prevent migration by calling a non-existing function in `OVM_L2ToL1MessagePasser` and making `ReadWitnessData` return an error",
  "Content": "# Issue M-3: Malicious actor can prevent migration by calling a non-existing function in `OVM_L2ToL1MessagePasser` and making `ReadWitnessData` return an error \n\nSource: https://github.com/sherlock-audit/2023-03-optimism-judging/issues/67 \n\n## Found by \n0xdeadbeef\n\n## Summary\n\nThere is a mismatch between collected witness data in l2geth to the parsing of the collected data during migration.\nThe mismatch will return an error and halt the migration until the data will be cleaned. \n\n## Vulnerability Detail\n\nWitness data is collected from L2geth using a state dumper that collects any call to `OVM_L2ToL1MessagePasser`.\nThe data is collected regardless of the calldata itself. Any call to `OVM_L2ToL1MessagePasser` will be collected.\nThe data will persist regardless of the status of the transaction.\n\nhttps://github.com/sherlock-audit/2023-03-optimism/blob/main/optimism/l2geth/core/vm/evm.go#L206-L209\n```solidity\n func (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) { \n \tif addr == dump.MessagePasserAddress { \n \t\tstatedumper.WriteMessage(caller.Address(), input) \n \t} \n```\n\nThe data will be stored in a file in the following format:\n\"MSG|\\<source\\>|\\<calldata\\>\"\n\nAt the start of the migration process, in order to unpack the message from the calldata, the code uses the first 4 bytes to lookup the the selector of  `passMessageToL1` from the calldata and unpack the calldata according to the ABI. \n\n`ReadWitnessData`:\nhttps://github.com/sherlock-audit/2023-03-optimism/blob/main/optimism/op-chain-ops/crossdomain/witness.go#L81-L89\n```solidity\n\tmethod, err := abi.MethodById(msgB[:4])\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to get method: %w\", err)\n\t}\n\n\tout, err := method.Inputs.Unpack(msgB[4:])\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to unpack: %w\", err)\n\t}\n```\n\nAs can be seen above, the function will return an error that is bubbled up to stop the migration if:\n1. The calldata first 4 bytes is not a selector of a function from the ABI of `OVM_L2ToL1MessagePasser`\n2. The parameters encoded with the selectors are not unpackable (are not the parameters specified by the ABI)\n\nA malicious actor will call any non-existing function in the address of `OVM_L2ToL1MessagePasser`.\nThe message will be stored in the witness data and cause an error during migration.\n\n`ReadWitnessData` is called to parse they json witness data before any filtering is in place. \n\n## Impact\n\nAn arbitrary user can halt the migration process\n\n## Code Snippet\n\nIn vulnerability section\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInstead of bubbling up an error, simply continue to the next message.\nThis shouldn't cause a problem since in the next stages of the migration there are checks to validate any missing messages from the storage.\n\n\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment:\n Invalid witness data can cause an error during migration by malicious actor call to the OVM_L2ToL1MessagePasser.\n\n**GalloDaSballo**\n\nTemporary DOS, not acceptable risk, agree with Med\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/63",
  "Code": [
    {
      "filename": "optimism/l2geth/core/vm/evm.go",
      "content": "// Copyright 2014 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage vm\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/ethereum-optimism/optimism/l2geth/statedumper\"\n\n\t\"github.com/ethereum-optimism/optimism/l2geth/common\"\n\t\"github.com/ethereum-optimism/optimism/l2geth/crypto\"\n\t\"github.com/ethereum-optimism/optimism/l2geth/params\"\n\t\"github.com/ethereum-optimism/optimism/l2geth/rollup/dump\"\n\t\"github.com/ethereum-optimism/optimism/l2geth/rollup/rcfg\"\n\t\"github.com/ethereum-optimism/optimism/l2geth/rollup/util\"\n\t\"golang.org/x/crypto/sha3\"\n)\n\n// emptyCodeHash is used by create to ensure deployment is disallowed to already\n// deployed contract addresses (relevant after the account abstraction).\nvar emptyCodeHash = crypto.Keccak256Hash(nil)\n\n// mintSigHash is the function signature of mint(address,uint256)\nvar mintSigHash = common.FromHex(\"0x40c10f19\")\n\ntype (\n\t// CanTransferFunc is the signature of a transfer guard function\n\tCanTransferFunc func(StateDB, common.Address, *big.Int) bool\n\t// TransferFunc is the signature of a transfer function\n\tTransferFunc func(StateDB, common.Address, common.Address, *big.Int)\n\t// GetHashFunc returns the n'th block hash in the blockchain\n\t// and is used by the BLOCKHASH EVM op code.\n\tGetHashFunc func(uint64) common.Hash\n)\n\n// run runs the given contract and takes care of running precompiles with a fallback to the byte code interpreter.\nfunc run(evm *EVM, contract *Contract, input []byte, readOnly bool) ([]byte, error) {\n\tif contract.CodeAddr != nil {\n\t\tprecompiles := PrecompiledContractsHomestead\n\t\tif evm.chainRules.IsByzantium {\n\t\t\tprecompiles = PrecompiledContractsByzantium\n\t\t}\n\t\tif evm.chainRules.IsIstanbul {\n\t\t\tprecompiles = PrecompiledContractsIstanbul\n\t\t}\n\t\tif evm.chainRules.IsBerlin {\n\t\t\tprecompiles = PrecompiledContractsBerlin\n\t\t}\n\t\tif p := precompiles[*contract.CodeAddr]; p != nil {\n\t\t\treturn RunPrecompiledContract(p, input, contract)\n\t\t}\n\t}\n\tfor _, interpreter := range evm.interpreters {\n\t\tif interpreter.CanRun(contract.Code) {\n\t\t\tif evm.interpreter != interpreter {\n\t\t\t\t// Ensure that the interpreter pointer is set back\n\t\t\t\t// to its current value upon return.\n\t\t\t\tdefer func(i Interpreter) {\n\t\t\t\t\tevm.interpreter = i\n\t\t\t\t}(evm.interpreter)\n\t\t\t\tevm.interpreter = interpreter\n\t\t\t}\n\t\t\treturn interpreter.Run(contract, input, readOnly)\n\t\t}\n\t}\n\treturn nil, ErrNoCompatibleInterpreter\n}\n\n// Context provides the EVM with auxiliary information. Once provided\n// it shouldn't be modified.\ntype Context struct {\n\t// CanTransfer returns whether the account contains\n\t// sufficient ether to transfer the value\n\tCanTransfer CanTransferFunc\n\t// Transfer transfers ether from one account to the other\n\tTransfer TransferFunc\n\t// GetHash returns the hash corresponding to n\n\tGetHash GetHashFunc\n\n\t// Message information\n\tOrigin   common.Address // Provides information for ORIGIN\n\tGasPrice *big.Int       // Provides information for GASPRICE\n\n\t// Block information\n\tCoinbase    common.Address // Provides information for COINBASE\n\tGasLimit    uint64         // Provides information for GASLIMIT\n\tBlockNumber *big.Int       // Provides information for NUMBER\n\tTime        *big.Int       // Provides information for TIME\n\tDifficulty  *big.Int       // Provides information for DIFFICULTY\n\n\t// OVM information\n\tL1BlockNumber *big.Int // Provides information for L1BLOCKNUMBER\n}\n\n// EVM is the Ethereum Virtual Machine base object and provides\n// the necessary tools to run a contract on the given state with\n// the provided context. It should be noted that any error\n// generated through any of the calls should be considered a\n// revert-state-and-consume-all-gas operation, no checks on\n// specific errors should ever be performed. The interpreter makes\n// sure that any errors generated are to be considered faulty code.\n//\n// The EVM should never be reused and is not thread safe.\ntype EVM struct {\n\t// Context provides auxiliary blockchain related information\n\tContext\n\t// StateDB gives access to the underlying state\n\tStateDB StateDB\n\t// Depth is the current call stack\n\tdepth int\n\n\t// chainConfig contains information about the current chain\n\tchainConfig *params.ChainConfig\n\t// chain rules contains the chain rules for the current epoch\n\tchainRules params.Rules\n\t// virtual machine configuration options used to initialise the\n\t// evm.\n\tvmConfig Config\n\t// global (to this context) ethereum virtual machine\n\t// used throughout the execution of the tx.\n\tinterpreters []Interpreter\n\tinterpreter  Interpreter\n\t// abort is used to abort the EVM calling operations\n\t// NOTE: must be set atomically\n\tabort int32\n\t// callGasTemp holds the gas available for the current call. This is needed because the\n\t// available gas is calculated in gasCall* according to the 63/64 rule and later\n\t// applied in opCall*.\n\tcallGasTemp uint64\n}\n\n// NewEVM returns a new EVM. The returned EVM is not thread safe and should\n// only ever be used *once*.\nfunc NewEVM(ctx Context, statedb StateDB, chainConfig *params.ChainConfig, vmConfig Config) *EVM {\n\tevm := &EVM{\n\t\tContext:      ctx,\n\t\tStateDB:      statedb,\n\t\tvmConfig:     vmConfig,\n\t\tchainConfig:  chainConfig,\n\t\tchainRules:   chainConfig.Rules(ctx.BlockNumber),\n\t\tinterpreters: make([]Interpreter, 0, 1),\n\t}\n\n\tif chainConfig.IsEWASM(ctx.BlockNumber) {\n\t\t// to be implemented by EVM-C and Wagon PRs.\n\t\t// if vmConfig.EWASMInterpreter != \"\" {\n\t\t//  extIntOpts := strings.Split(vmConfig.EWASMInterpreter, \":\")\n\t\t//  path := extIntOpts[0]\n\t\t//  options := []string{}\n\t\t//  if len(extIntOpts) > 1 {\n\t\t//    options = extIntOpts[1..]\n\t\t//  }\n\t\t//  evm.interpreters = append(evm.interpreters, NewEVMVCInterpreter(evm, vmConfig, options))\n\t\t// } else {\n\t\t// \tevm.interpreters = append(evm.interpreters, NewEWASMInterpreter(evm, vmConfig))\n\t\t// }\n\t\tpanic(\"No supported ewasm interpreter yet.\")\n\t}\n\n\t// vmConfig.EVMInterpreter will be used by EVM-C, it won't be checked here\n\t// as we always want to have the built-in EVM as the failover option.\n\tevm.interpreters = append(evm.interpreters, NewEVMInterpreter(evm, vmConfig))\n\tevm.interpreter = evm.interpreters[0]\n\n\treturn evm\n}\n\n// Cancel cancels any running EVM operation. This may be called concurrently and\n// it's safe to be called multiple times.\nfunc (evm *EVM) Cancel() {\n\tatomic.StoreInt32(&evm.abort, 1)\n}\n\n// Cancelled returns true if Cancel has been called\nfunc (evm *EVM) Cancelled() bool {\n\treturn atomic.LoadInt32(&evm.abort) == 1\n}\n\n// Interpreter returns the current interpreter\nfunc (evm *EVM) Interpreter() Interpreter {\n\treturn evm.interpreter\n}\n\n// Call executes the contract associated with the addr with the given input as\n// parameters. It also handles any necessary value transfer required and takes\n// the necessary steps to create accounts and reverses the state in case of an\n// execution error or failed value transfer.\nfunc (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {\n\tif addr == dump.MessagePasserAddress {\n\t\tstatedumper.WriteMessage(caller.Address(), input)\n\t}\n\n\tif addr == dump.OvmEthAddress {\n\t\t// We need at least 4 bytes + 32 bytes for the recipient address, then\n\t\t// address will be found at bytes 16-36. 0x40c10f19 is the function\n\t\t// selector for mint(address,uint256).\n\t\tif len(input) >= 36 && bytes.Equal(input[:4], mintSigHash) {\n\t\t\trecipient := common.BytesToAddress(input[16:36])\n\t\t\tstatedumper.WriteETH(recipient)\n\t\t}\n\t}\n\n\tif evm.vmConfig.NoRecursion && evm.depth > 0 {\n\t\treturn nil, gas, nil\n\t}\n\n\t// Fail if we're trying to execute above the call depth limit\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, gas, ErrDepth\n\t}\n\t// Fail if we're trying to transfer more than the available balance\n\tif !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {\n\t\treturn nil, gas, ErrInsufficientBalance\n\t}\n\n\tvar (\n\t\tto       = AccountRef(addr)\n\t\tsnapshot = evm.StateDB.Snapshot()\n\t)\n\tif !evm.StateDB.Exist(addr) {\n\t\tprecompiles := PrecompiledContractsHomestead\n\t\tif evm.chainRules.IsByzantium {\n\t\t\tprecompiles = PrecompiledContractsByzantium\n\t\t}\n\t\tif evm.chainRules.IsIstanbul {\n\t\t\tprecompiles = PrecompiledContractsIstanbul\n\t\t}\n\t\tif evm.chainRules.IsBerlin {\n\t\t\tprecompiles = PrecompiledContractsBerlin\n\t\t}\n\t\tif precompiles[addr] == nil && evm.chainRules.IsEIP158 && value.Sign() == 0 {\n\t\t\t// Calling a non existing account, don't do anything, but ping the tracer\n\t\t\tif evm.vmConfig.Debug && evm.depth == 0 {\n\t\t\t\tevm.vmConfig.Tracer.CaptureStart(caller.Address(), addr, false, input, gas, value)\n\t\t\t\tevm.vmConfig.Tracer.CaptureEnd(ret, 0, 0, nil)\n\t\t\t}\n\t\t\treturn nil, gas, nil\n\t\t}\n\t\tevm.StateDB.CreateAccount(addr)\n\t}\n\tevm.Transfer(evm.StateDB, caller.Address(), to.Address(), value)\n\t// Initialise a new contract and set the code that is to be used by the EVM.\n\t// The contract is a scoped environment for this execution context only.\n\tcontract := NewContract(caller, to, value, gas)\n\tcontract.SetCallCode(&addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))\n\n\t// Even if the account has no code, we need to continue because it might be a precompile\n\tstart := time.Now()\n\n\t// Capture the tracer start/end events in debug mode\n\tif evm.vmConfig.Debug && evm.depth == 0 {\n\t\tevm.vmConfig.Tracer.CaptureStart(caller.Address(), addr, false, input, gas, value)\n\n\t\tdefer func() { // Lazy evaluation of the parameters\n\t\t\tevm.vmConfig.Tracer.CaptureEnd(ret, gas-contract.Gas, time.Since(start), err)\n\t\t}()\n\t}\n\tret, err = run(evm, contract, input, false)\n\n\t// When an error was returned by the EVM or when setting the creation code\n\t// above we revert to the snapshot and consume any gas remaining. Additionally\n\t// when we're in homestead this also counts for code storage gas errors.\n\tif err != nil {\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != errExecutionReverted {\n\t\t\tcontract.UseGas(contract.Gas)\n\t\t}\n\t}\n\treturn ret, contract.Gas, err\n}\n\n// CallCode executes the contract associated with the addr with the given input\n// as parameters. It also handles any necessary value transfer required and takes\n// the necessary steps to create accounts and reverses the state in case of an\n// execution error or failed value transfer.\n//\n// CallCode differs from Call in the sense that it executes the given address'\n// code with the caller as context.\nfunc (evm *EVM) CallCode(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {\n\tif evm.vmConfig.NoRecursion && evm.depth > 0 {\n\t\treturn nil, gas, nil\n\t}\n\n\t// Fail if we're trying to execute above the call depth limit\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, gas, ErrDepth\n\t}\n\t// Fail if we're trying to transfer more than the available balance\n\tif !evm.CanTransfer(evm.StateDB, caller.Address(), value) {\n\t\treturn nil, gas, ErrInsufficientBalance\n\t}\n\n\tvar (\n\t\tsnapshot = evm.StateDB.Snapshot()\n\t\tto       = AccountRef(caller.Address())\n\t)\n\t// Initialise a new contract and set the code that is to be used by the EVM.\n\t// The contract is a scoped environment for this execution context only.\n\tcontract := NewContract(caller, to, value, gas)\n\tcontract.SetCallCode(&addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))\n\n\tret, err = run(evm, contract, input, false)\n\tif err != nil {\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != errExecutionReverted {\n\t\t\tcontract.UseGas(contract.Gas)\n\t\t}\n\t}\n\treturn ret, contract.Gas, err\n}\n\n// DelegateCall executes the contract associated with the addr with the given input\n// as parameters. It reverses the state in case of an execution error.\n//\n// DelegateCall differs from CallCode in the sense that it executes the given address'\n// code with the caller as context and the caller is set to the caller of the caller.\nfunc (evm *EVM) DelegateCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) {\n\tif evm.vmConfig.NoRecursion && evm.depth > 0 {\n\t\treturn nil, gas, nil\n\t}\n\t// Fail if we're trying to execute above the call depth limit\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, gas, ErrDepth\n\t}\n\n\tvar (\n\t\tsnapshot = evm.StateDB.Snapshot()\n\t\tto       = AccountRef(caller.Address())\n\t)\n\n\t// Initialise a new contract and make initialise the delegate values\n\tcontract := NewContract(caller, to, nil, gas).AsDelegate()\n\tcontract.SetCallCode(&addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))\n\n\tret, err = run(evm, contract, input, false)\n\tif err != nil {\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != errExecutionReverted {\n\t\t\tcontract.UseGas(contract.Gas)\n\t\t}\n\t}\n\treturn ret, contract.Gas, err\n}\n\n// StaticCall executes the contract associated with the addr with the given input\n// as parameters while disallowing any modifications to the state during the call.\n// Opcodes that attempt to perform such modifications will result in exceptions\n// instead of performing the modifications.\nfunc (evm *EVM) StaticCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) {\n\tif evm.vmConfig.NoRecursion && evm.depth > 0 {\n\t\treturn nil, gas, nil\n\t}\n\t// Fail if we're trying to execute above the call depth limit\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, gas, ErrDepth\n\t}\n\n\tvar (\n\t\tto       = AccountRef(addr)\n\t\tsnapshot = evm.StateDB.Snapshot()\n\t)\n\t// Initialise a new contract and set the code that is to be used by the EVM.\n\t// The contract is a scoped environment for this execution context only.\n\tcontract := NewContract(caller, to, new(big.Int), gas)\n\tcontract.SetCallCode(&addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))\n\n\t// We do an AddBalance of zero here, just in order to trigger a touch.\n\t// This doesn't matter on Mainnet, where all empties are gone at the time of Byzantium,\n\t// but is the correct thing to do and matters on other networks, in tests, and potential\n\t// future scenarios\n\tevm.StateDB.AddBalance(addr, bigZero)\n\n\t// When an error was returned by the EVM or when setting the creation code\n\t// above we revert to the snapshot and consume any gas remaining. Additionally\n\t// when we're in Homestead this also counts for code storage gas errors.\n\tret, err = run(evm, contract, input, true)\n\tif err != nil {\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != errExecutionReverted {\n\t\t\tcontract.UseGas(contract.Gas)\n\t\t}\n\t}\n\treturn ret, contract.Gas, err\n}\n\ntype codeAndHash struct {\n\tcode []byte\n\thash common.Hash\n}\n\nfunc (c *codeAndHash) Hash() common.Hash {\n\tif c.hash == (common.Hash{}) {\n\t\tc.hash = crypto.Keccak256Hash(c.code)\n\t}\n\treturn c.hash\n}\n\n// create creates a new contract using code as deployment code.\nfunc (evm *EVM) create(caller ContractRef, codeAndHash *codeAndHash, gas uint64, value *big.Int, address common.Address) ([]byte, common.Address, uint64, error) {\n\t// Depth check execution. Fail if we're trying to execute above the\n\t// limit.\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, common.Address{}, gas, ErrDepth\n\t}\n\tif !evm.CanTransfer(evm.StateDB, caller.Address(), value) {\n\t\treturn nil, common.Address{}, gas, ErrInsufficientBalance\n\t}\n\tif rcfg.UsingOVM {\n\t\t// Make sure the creator address should be able to deploy.\n\t\tif !evm.AddressWhitelisted(caller.Address()) {\n\t\t\t// Try to encode this error as a Solidity error message so it's more clear to end-users\n\t\t\t// what's going on when a contract creation fails.\n\t\t\tsolerr := fmt.Errorf(\"deployer address not whitelisted: %s\", caller.Address().Hex())\n\t\t\tret, err := util.EncodeSolidityError(solerr)\n\t\t\tif err != nil {\n\t\t\t\t// If we're unable to properly encode the error then just return the original message.\n\t\t\t\treturn nil, common.Address{}, gas, solerr\n\t\t\t}\n\t\t\treturn ret, common.Address{}, gas, errExecutionReverted\n\t\t}\n\n\t\t// Get the system address for this caller.\n\t\tsysAddr := rcfg.SystemAddressFor(evm.ChainConfig().ChainID, caller.Address())\n\n\t\t// If there is a configured system address for this caller, and the caller's nonce is zero,\n\t\t// and there is no contract already deployed at this system address, then set the created\n\t\t// address to the system address.\n\t\tif sysAddr != rcfg.ZeroSystemAddress && evm.StateDB.GetNonce(caller.Address()) == 0 {\n\t\t\taddress = sysAddr\n\t\t}\n\t}\n\tnonce := evm.StateDB.GetNonce(caller.Address())\n\tevm.StateDB.SetNonce(caller.Address(), nonce+1)\n\t// We add this to the access list _before_ taking a snapshot. Even if the creation fails,\n\t// the access-list change should not be rolled back\n\tif evm.chainRules.IsBerlin {\n\t\tevm.StateDB.AddAddressToAccessList(address)\n\t}\n\t// Ensure there's no existing contract already at the designated address\n\tcontractHash := evm.StateDB.GetCodeHash(address)\n\tif evm.StateDB.GetNonce(address) != 0 || (contractHash != (common.Hash{}) && contractHash != emptyCodeHash) {\n\t\treturn nil, common.Address{}, 0, ErrContractAddressCollision\n\t}\n\t// Create a new account on the state\n\tsnapshot := evm.StateDB.Snapshot()\n\tevm.StateDB.CreateAccount(address)\n\tif evm.chainRules.IsEIP158 {\n\t\tevm.StateDB.SetNonce(address, 1)\n\t}\n\tevm.Transfer(evm.StateDB, caller.Address(), address, value)\n\n\t// Initialise a new contract and set the code that is to be used by the EVM.\n\t// The contract is a scoped environment for this execution context only.\n\tcontract := NewContract(caller, AccountRef(address), value, gas)\n\tcontract.SetCodeOptionalHash(&address, codeAndHash)\n\n\tif evm.vmConfig.NoRecursion && evm.depth > 0 {\n\t\treturn nil, address, gas, nil\n\t}\n\n\tif evm.vmConfig.Debug && evm.depth == 0 {\n\t\tevm.vmConfig.Tracer.CaptureStart(caller.Address(), address, true, codeAndHash.code, gas, value)\n\t}\n\tstart := time.Now()\n\n\tret, err := run(evm, contract, nil, false)\n\n\t// check whether the max code size has been exceeded\n\tmaxCodeSizeExceeded := evm.chainRules.IsEIP158 && len(ret) > params.MaxCodeSize\n\t// if the contract creation ran successfully and no errors were returned\n\t// calculate the gas required to store the code. If the code could not\n\t// be stored due to not enough gas set an error and let it be handled\n\t// by the error checking condition below.\n\tif err == nil && !maxCodeSizeExceeded {\n\t\tcreateDataGas := uint64(len(ret)) * params.CreateDataGas\n\t\tif contract.UseGas(createDataGas) {\n\t\t\tevm.StateDB.SetCode(address, ret)\n\t\t} else {\n\t\t\terr = ErrCodeStoreOutOfGas\n\t\t}\n\t}\n\n\t// When an error was returned by the EVM or when setting the creation code\n\t// above we revert to the snapshot and consume any gas remaining. Additionally\n\t// when we're in homestead this also counts for code storage gas errors.\n\tif maxCodeSizeExceeded || (err != nil && (evm.chainRules.IsHomestead || err != ErrCodeStoreOutOfGas)) {\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != errExecutionReverted {\n\t\t\tcontract.UseGas(contract.Gas)\n\t\t}\n\t}\n\t// Assign err if contract code size exceeds the max while the err is still empty.\n\tif maxCodeSizeExceeded && err == nil {\n\t\terr = errMaxCodeSizeExceeded\n\t}\n\tif evm.vmConfig.Debug && evm.depth == 0 {\n\t\tevm.vmConfig.Tracer.CaptureEnd(ret, gas-contract.Gas, time.Since(start), err)\n\t}\n\treturn ret, address, contract.Gas, err\n\n}\n\n// Create creates a new contract using code as deployment code.\nfunc (evm *EVM) Create(caller ContractRef, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {\n\tcontractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address()))\n\treturn evm.create(caller, &codeAndHash{code: code}, gas, value, contractAddr)\n}\n\n// Create2 creates a new contract using code as deployment code.\n//\n// The different between Create2 with Create is Create2 uses sha3(0xff ++ msg.sender ++ salt ++ sha3(init_code))[12:]\n// instead of the usual sender-and-nonce-hash as the address where the contract is initialized at.\nfunc (evm *EVM) Create2(caller ContractRef, code []byte, gas uint64, endowment *big.Int, salt *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {\n\tcodeAndHash := &codeAndHash{code: code}\n\tcontractAddr = crypto.CreateAddress2(caller.Address(), common.BigToHash(salt), codeAndHash.Hash().Bytes())\n\treturn evm.create(caller, codeAndHash, gas, endowment, contractAddr)\n}\n\n// ChainConfig returns the environment's chain configuration\nfunc (evm *EVM) ChainConfig() *params.ChainConfig { return evm.chainConfig }\n\nfunc (evm *EVM) AddressWhitelisted(addr common.Address) bool {\n\t// First check if the owner is address(0), which implicitly disables the whitelist.\n\townerKey := common.Hash{}\n\towner := evm.StateDB.GetState(dump.OvmWhitelistAddress, ownerKey)\n\tif (owner == common.Hash{}) {\n\t\treturn true\n\t}\n\n\t// Next check if the user is whitelisted by resolving the position where the\n\t// true/false value would be.\n\tposition := common.Big1\n\thasher := sha3.NewLegacyKeccak256()\n\thasher.Write(common.LeftPadBytes(addr.Bytes(), 32))\n\thasher.Write(common.LeftPadBytes(position.Bytes(), 32))\n\tdigest := hasher.Sum(nil)\n\tkey := common.BytesToHash(digest)\n\tisWhitelisted := evm.StateDB.GetState(dump.OvmWhitelistAddress, key)\n\treturn isWhitelisted != common.Hash{}\n}"
    },
    {
      "filename": "optimism/op-chain-ops/crossdomain/witness.go",
      "content": "package crossdomain\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/ethereum-optimism/optimism/op-bindings/bindings\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/common/hexutil\"\n)\n\n// SentMessage represents an entry in the JSON file that is created by\n// the `migration-data` package. Each entry represents a call to the\n// `LegacyMessagePasser`. The `who` should always be the\n// `L2CrossDomainMessenger` and the `msg` should be an abi encoded\n// `relayMessage(address,address,bytes,uint256)`\ntype SentMessage struct {\n\tWho common.Address `json:\"who\"`\n\tMsg hexutil.Bytes  `json:\"msg\"`\n}\n\n// NewSentMessageFromJSON will read a JSON file from disk given a path to the JSON\n// file. The JSON file this function reads from disk is an output from the\n// `migration-data` package.\nfunc NewSentMessageFromJSON(path string) ([]*SentMessage, error) {\n\tfile, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot find sent message json at %s: %w\", path, err)\n\t}\n\n\tvar j []*SentMessage\n\tif err := json.Unmarshal(file, &j); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn j, nil\n}\n\n// ReadWitnessData will read messages and addresses from a raw l2geth state\n// dump file.\nfunc ReadWitnessData(path string) ([]*SentMessage, OVMETHAddresses, error) {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"cannot open witness data file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\tscan := bufio.NewScanner(f)\n\tvar witnesses []*SentMessage\n\taddresses := make(map[common.Address]bool)\n\tfor scan.Scan() {\n\t\tline := scan.Text()\n\t\tsplits := strings.Split(line, \"|\")\n\t\tif len(splits) < 2 {\n\t\t\treturn nil, nil, fmt.Errorf(\"invalid line: %s\", line)\n\t\t}\n\n\t\tswitch splits[0] {\n\t\tcase \"MSG\":\n\t\t\tif len(splits) != 3 {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"invalid line: %s\", line)\n\t\t\t}\n\n\t\t\tmsg := splits[2]\n\t\t\t// Make sure that the witness data has a 0x prefix\n\t\t\tif !strings.HasPrefix(msg, \"0x\") {\n\t\t\t\tmsg = \"0x\" + msg\n\t\t\t}\n\n\t\t\tabi, err := bindings.LegacyMessagePasserMetaData.GetAbi()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"failed to get abi: %w\", err)\n\t\t\t}\n\n\t\t\tmsgB := hexutil.MustDecode(msg)\n\t\t\tmethod, err := abi.MethodById(msgB[:4])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"failed to get method: %w\", err)\n\t\t\t}\n\n\t\t\tout, err := method.Inputs.Unpack(msgB[4:])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"failed to unpack: %w\", err)\n\t\t\t}\n\n\t\t\tcast, ok := out[0].([]byte)\n\t\t\tif !ok {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"failed to cast to bytes\")\n\t\t\t}\n\n\t\t\twitnesses = append(witnesses, &SentMessage{\n\t\t\t\tWho: common.HexToAddress(splits[1]),\n\t\t\t\tMsg: cast,\n\t\t\t})\n\t\tcase \"ETH\":\n\t\t\taddresses[common.HexToAddress(splits[1])] = true\n\t\tdefault:\n\t\t\treturn nil, nil, fmt.Errorf(\"invalid line: %s\", line)\n\t\t}\n\t}\n\n\treturn witnesses, addresses, nil\n}\n\n// ToLegacyWithdrawal will convert a SentMessageJSON to a LegacyWithdrawal\n// struct. This is useful because the LegacyWithdrawal struct has helper\n// functions on it that can compute the withdrawal hash and the storage slot.\nfunc (s *SentMessage) ToLegacyWithdrawal() (*LegacyWithdrawal, error) {\n\tdata := make([]byte, len(s.Who)+len(s.Msg))\n\tcopy(data, s.Msg)\n\tcopy(data[len(s.Msg):], s.Who[:])\n\n\tvar w LegacyWithdrawal\n\tif err := w.Decode(data); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &w, nil\n}\n\n// OVMETHAddresses represents a list of addresses that interacted with\n// the ERC20 representation of ether in the pre-bedrock system.\ntype OVMETHAddresses map[common.Address]bool\n\n// NewAddresses will read an addresses.json file from the filesystem.\nfunc NewAddresses(path string) (OVMETHAddresses, error) {\n\tfile, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot find addresses json at %s: %w\", path, err)\n\t}\n\n\tvar addresses []common.Address\n\tif err := json.Unmarshal(file, &addresses); err != nil {\n\t\treturn nil, err\n\t}\n\n\tovmeth := make(OVMETHAddresses)\n\tfor _, addr := range addresses {\n\t\tovmeth[addr] = true\n\t}\n\n\treturn ovmeth, nil\n}\n\n// Allowance represents the allowances that were set in the\n// legacy ERC20 representation of ether\ntype Allowance struct {\n\tFrom common.Address `json:\"fr\"`\n\tTo   common.Address `json:\"to\"`\n}\n\n// NewAllowances will read the ovm-allowances.json from the file system.\nfunc NewAllowances(path string) ([]*Allowance, error) {\n\tfile, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot find allowances json at %s: %w\", path, err)\n\t}\n\n\tvar allowances []*Allowance\n\tif err := json.Unmarshal(file, &allowances); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn allowances, nil\n}\n\n// MigrationData represents all of the data required to do a migration\ntype MigrationData struct {\n\t// OvmAddresses represents the set of addresses that interacted with the\n\t// LegacyERC20ETH contract before the evm equivalence upgrade\n\tOvmAddresses OVMETHAddresses\n\t// EvmAddresses represents the set of addresses that interacted with the\n\t// LegacyERC20ETH contract after the evm equivalence upgrade\n\tEvmAddresses OVMETHAddresses\n\t// OvmAllowances represents the set of allowances in the LegacyERC20ETH from\n\t// before the evm equivalence upgrade\n\tOvmAllowances []*Allowance\n\t// OvmMessages represents the set of withdrawals through the\n\t// L2CrossDomainMessenger from before the evm equivalence upgrade\n\tOvmMessages []*SentMessage\n\t// OvmMessages represents the set of withdrawals through the\n\t// L2CrossDomainMessenger from after the evm equivalence upgrade\n\tEvmMessages []*SentMessage\n}\n\nfunc (m *MigrationData) ToWithdrawals() (DangerousUnfilteredWithdrawals, []InvalidMessage, error) {\n\tmessages := make(DangerousUnfilteredWithdrawals, 0)\n\tinvalidMessages := make([]InvalidMessage, 0)\n\tfor _, msg := range m.OvmMessages {\n\t\twd, err := msg.ToLegacyWithdrawal()\n\t\tif err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(\"error serializing OVM message: %w\", err)\n\t\t}\n\t\tmessages = append(messages, wd)\n\t}\n\tfor _, msg := range m.EvmMessages {\n\t\twd, err := msg.ToLegacyWithdrawal()\n\t\tif err != nil {\n\t\t\tlog.Warn(\"Discovered mal-formed withdrawal\", \"who\", msg.Who, \"data\", msg.Msg)\n\t\t\tinvalidMessages = append(invalidMessages, InvalidMessage(*msg))\n\t\t\tcontinue\n\t\t}\n\t\tmessages = append(messages, wd)\n\t}\n\treturn messages, invalidMessages, nil\n}\n\nfunc (m *MigrationData) Addresses() []common.Address {\n\taddresses := make([]common.Address, 0)\n\tfor addr := range m.EvmAddresses {\n\t\taddresses = append(addresses, addr)\n\t}\n\tfor addr := range m.OvmAddresses {\n\t\taddresses = append(addresses, addr)\n\t}\n\treturn addresses\n}"
    }
  ]
}