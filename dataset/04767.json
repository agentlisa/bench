{
  "Title": "[M-12] MagicLpAggregator doesn't consider the dcimal of MagicLP",
  "Content": "\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/mimswap/MagicLP.sol#L163-L165> \n\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/oracles/aggregators/MagicLpAggregator.sol#L37-L46>\n\nWe can know that the `MagicLpAggregator` can serve as the `price source` for `MagicLP shares` when the prices of `base` and `quote` tokens are similar.\n\n    MagicLpAggregator would be used to price MagicLP collateral for Cauldrons. \n    Something to note is that the MagicLP Oracle is only meant for closed-together price pool. \n    It's just that the oracle is not meant to be used for any kind of MagicLP, just for closely priced tokens like MIM/USDB.\n\nThere's no assurance that we can use `MagicLpAggregator` for `base` and `quote` tokens with only `18 decimals`.\nThe `MagicLP` token has the same `decimal` as the `base` token.\nHowever, the `MagicLpAggregator` does not account for this `decimal`, resulting in incorrect `prices` when the `decimal` of the `base` token is not `18`.\n\n### Proof of Concept\n\n<details>\n\nThe `MagicLP` has the same `decimal` as the `base` token.\n\n    function decimals() public view override returns (uint8) {\n        return IERC20Metadata(_BASE_TOKEN_).decimals();\n    }\n\nIn `MagicLpAggregator`, we take into account the `decimals` of the `base oracle`, `quote oracle`, `base tokens`, and `quote tokens`, but we skip the `MagicLP`.\n\n    function latestAnswer() public view override returns (int256) {\n            uint256 baseAnswerNomalized = uint256(baseOracle.latestAnswer()) * (10 ** (WAD - baseOracle.decimals()));\n            uint256 quoteAnswerNormalized = uint256(quoteOracle.latestAnswer()) * (10 ** (WAD - quoteOracle.decimals()));\n            uint256 minAnswer = baseAnswerNomalized < quoteAnswerNormalized ? baseAnswerNomalized : quoteAnswerNormalized;\n\n            (uint256 baseReserve, uint256 quoteReserve) = _getReserves();\n            baseReserve = baseReserve * (10 ** (WAD - baseDecimals));\n            quoteReserve = quoteReserve * (10 ** (WAD - quoteDecimals));\n            return int256(minAnswer * (baseReserve + quoteReserve) / pair.totalSupply());\n    }\n\nAs a result, the above function will yield an incorrect `price` when the `decimal` of the `base` token is not `18`.\n\nLet's consider an example where the `decimal` of the `base` token is `12` and the `decimal` of the `quote` token is `18`.\nAdditionally, the `decimal` of the `base oracle` is `8`, and the `decimal` of the `quote oracle` is `12`.\nWe'll assume that the `price` of both tokens is `4 USD`.\nThe `prices` in `18 decimals` will be as follows:\n\n    base oracle answer           ==>   400000000            (8 decimals)\n    quote roacle answer          ==>   4000000000000        (12 decimals)\n    base oracle answer in WAD    ==>   4000000000000000000  (18 decimals)\n    quote oracle answer in WAD   ==>   4000000000000000000  (18 decimals)\n\nAnd there are `5 base tokens` and `5 quote tokens` in the `pool`.\nThe `reserves` in `18 decimals` will be as follows:\n\n    base reserves                ==>   5000000000000        (12 decimals)\n    quote reserves               ==>   5000000000000000000  (18 decimals)\n    base reserves in WAD         ==>   5000000000000000000  (18 decimals)\n    quote reserves in WAD        ==>   5000000000000000000  (18 decimals)\n\nLet's assume the total `share` of this `pool` is `5`.\n\nGiven that the `price` of the `base` and `quote` tokens is `4 USD`, the total value of all tokens will be `40 USD`.\n\n    total usd                     ==>   40000000 6\n    total supply                  ==>   5000000000000 12\n\nWith `5 shares` representing `40 USD`, the `price` of `one share` should be `8 USD`.\nHowever, the `MagicLpAggregator` returns `8,000,000 USD` because it did not consider the `decimal` of `MagicLP`.\n\n    correct answer               ==>   8000000000000000000        (18 decimals)\n    answer of aggregator         ==>   8000000000000000000000000  (18 decimals)\n\nAdd below two mock files into `test/mocks`.\n\n    pragma solidity ^0.8.13;\n\n    import {IAggregator} from \"interfaces/IAggregator.sol\";\n\n    contract OracleMock is IAggregator {\n      uint8 public decimals_;\n      uint8 public price_;\n\n      constructor(uint8 _decimals, uint8 _price) {\n        decimals_ = _decimals;\n        price_ = _price;\n      }\n\n      function decimals() external view override returns (uint8) {\n        return decimals_;\n      }\n\n      function latestAnswer() public view override returns (int256) {\n        return int256(price_ * 10 ** decimals_);\n      }\n\n      function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {\n        return (0, latestAnswer(), 0, 0, 0);\n      }\n    }\n\n```\n\n    pragma solidity ^0.8.13;\n\n    import { IMagicLP } from \"/mimswap/interfaces/IMagicLP.sol\";\n    import { ERC20Mock } from \"./ERC20Mock.sol\";\n\n    contract MagicLPMock is IMagicLP {\n      address public _BASE_TOKEN_;\n      address public _QUOTE_TOKEN_;\n      uint112 public _BASE_RESERVE_;\n      uint112 public _QUOTE_RESERVE_;\n\n      constructor(ERC20Mock BASE_TOKEN, ERC20Mock QUOTE_TOKEN) {\n        _BASE_TOKEN_ = address(BASE_TOKEN);\n        _QUOTE_TOKEN_ = address(QUOTE_TOKEN);\n        _BASE_RESERVE_ = uint112(5 * 10 ** ERC20Mock(_BASE_TOKEN_).decimals());\n        _QUOTE_RESERVE_ = uint112(5 * 10 ** ERC20Mock(_QUOTE_TOKEN_).decimals());\n      }\n\n      function _BASE_TARGET_() external view returns (uint112) {\n        return _BASE_RESERVE_;\n      }\n\n      function _QUOTE_TARGET_() external view returns (uint112) {\n        return _QUOTE_RESERVE_;\n      }\n\n      function _I_() external view returns (uint256) {\n        return 1 ether;\n      }\n\n      function decimals() public view returns (uint8) {\n        return ERC20Mock(_BASE_TOKEN_).decimals();\n      }\n\n      function getReserves() external view returns (uint256 baseReserve, uint256 quoteReserve) {\n        baseReserve = _BASE_RESERVE_;\n        quoteReserve = _QUOTE_RESERVE_;\n      }\n\n      function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve) {\n        baseReserve = _BASE_RESERVE_;\n        quoteReserve = _QUOTE_RESERVE_;\n      }\n\n      function totalSupply() external view returns (uint256 totalSupply) {\n        totalSupply = 5 * 10 ** decimals();\n      }\n\n      function init(\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 i,\n        uint256 k\n      ) external {}\n\n      function sellBase(address to) external returns (uint256 receiveQuoteAmount) {}\n      function sellQuote(address to) external returns (uint256 receiveBaseAmount) {}\n      function flashLoan(uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes calldata data) external {}\n      function buyShares(address to) external returns (uint256 shares, uint256 baseInput, uint256 quoteInput) {}\n      function sellShares(\n        uint256 shareAmount,\n        address to,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        bytes calldata data,\n        uint256 deadline\n      ) external returns (uint256 baseAmount, uint256 quoteAmount) {}\n      function MIN_LP_FEE_RATE() external view returns (uint256) {}\n      function MAX_LP_FEE_RATE() external view returns (uint256) {}\n    }\n```\n\nFinally please add below test into `MagicLpAggregator.t.sol`\n\n    import \"forge-std/console2.sol\";\n    import { OracleMock } from \"./mocks/OracleMock.sol\";\n    import { ERC20Mock } from \"./mocks/ERC20Mock.sol\";\n    import { MagicLPMock } from \"./mocks/MagicLPMock.sol\";\n\n    function testOracleDecimals() public {\n            IAggregator baseOracle = new OracleMock(8, 4);\n            IAggregator quoteOracle = new OracleMock(12, 4);\n\n            ERC20Mock BASE_TOKEN = new ERC20Mock(\"base\", \"base\");\n            ERC20Mock QUOTE_TOKEN = new ERC20Mock(\"quote\", \"quote\");\n\n            BASE_TOKEN.setDecimals(12);\n\n            MagicLPMock lp = new MagicLPMock(BASE_TOKEN, QUOTE_TOKEN);\n\n            MagicLpAggregatorExt mlAggregator = new MagicLpAggregatorExt(\n                lp,\n                baseOracle,\n                quoteOracle\n            );\n\n            uint256 baseOracleAnswerIn18 = uint256(baseOracle.latestAnswer()) * 10 ** (18 - baseOracle.decimals());\n            uint256 quoteOracleAnswerIn18 = uint256(quoteOracle.latestAnswer()) * 10 ** (18 - quoteOracle.decimals());\n            console2.log('base oracle answer           ==>  ', baseOracle.latestAnswer());\n            console2.log('quote roacle answer          ==>  ', quoteOracle.latestAnswer());\n            console2.log('base oracle answer in WAD    ==>  ', baseOracleAnswerIn18);\n            console2.log('quote oracle answer in WAD   ==>  ', quoteOracleAnswerIn18);\n\n            console2.log(\"\");\n            console2.log(\"**************\");\n            console2.log(\"\");\n            (uint256 baseReserves, uint256 quoteReserves) = lp.getReserves();\n            uint256 baseReservesIn18 = baseReserves * 10 ** (18 - BASE_TOKEN.decimals());\n            uint256 quoteReservesIn18 = quoteReserves * 10 ** (18 - QUOTE_TOKEN.decimals());\n            console2.log('base reserves                ==>  ', baseReserves);\n            console2.log('quote reserves               ==>  ', quoteReserves);\n            console2.log('base reserves in WAD         ==>  ', baseReservesIn18);\n            console2.log('quote reserves in WAD        ==>  ', quoteReservesIn18);\n\n            console2.log(\"\");\n            console2.log(\"**************\");\n            console2.log(\"\");\n            uint8 decimalsOfUsd = 6;\n            uint256 totalInUsd = (baseOracleAnswerIn18 * (baseReservesIn18 + quoteReservesIn18) / (10 ** 18) / (10 ** 18)) * 10 ** 6;\n            console.log('total usd                     ==>  ', totalInUsd, decimalsOfUsd);\n\n            uint256 totalSupply = lp.totalSupply();\n            uint8 decimalsOfLp = lp.decimals();\n            console.log('total supply                  ==>  ', totalSupply, decimalsOfLp);\n\n            console2.log(\"\");\n            console2.log(\"**************\");\n            console2.log(\"\");\n            uint256 correctAnswer = (totalInUsd / (10 ** decimalsOfUsd)) / (totalSupply / (10 ** decimalsOfLp)) * 10 ** 18;\n            console2.log('correct answer               ==>  ', correctAnswer);\n            console2.log('answer of aggregator         ==>  ', uint256(mlAggregator.latestAnswer()));\n    }\n\n</details>\n\n### Recommended Mitigation Steps\n\n    function latestAnswer() public view override returns (int256) {\n            uint256 baseAnswerNomalized = uint256(baseOracle.latestAnswer()) * (10 ** (WAD - baseOracle.decimals()));\n            uint256 quoteAnswerNormalized = uint256(quoteOracle.latestAnswer()) * (10 ** (WAD - quoteOracle.decimals()));\n            uint256 minAnswer = baseAnswerNomalized < quoteAnswerNormalized ? baseAnswerNomalized : quoteAnswerNormalized;\n\n            (uint256 baseReserve, uint256 quoteReserve) = _getReserves();\n            baseReserve = baseReserve * (10 ** (WAD - baseDecimals));\n            quoteReserve = quoteReserve * (10 ** (WAD - quoteDecimals));\n\n    +        uint256 totalSupply = pair.totalSupply() * (10 ** (WAD - baseDecimals));\n\n    -        return int256(minAnswer * (baseReserve + quoteReserve) / \n    pair.totalSupply());\n    +        return int256(minAnswer * (baseReserve + quoteReserve) / \n    totalSupply);\n    }\n\n**[0xCalibur (Abracadabra) disputed](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/90#issuecomment-2025718122)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-abracadabra-money",
  "Code": [
    {
      "filename": "src/mimswap/MagicLP.sol",
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity >=0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {IERC20Metadata} from \"openzeppelin-contracts/interfaces/IERC20Metadata.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solady/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solady/tokens/ERC20.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {DecimalMath} from \"/mimswap/libraries/DecimalMath.sol\";\nimport {Math} from \"/mimswap/libraries/Math.sol\";\nimport {PMMPricing} from \"/mimswap/libraries/PMMPricing.sol\";\nimport {ICallee} from \"/mimswap/interfaces/ICallee.sol\";\nimport {IFeeRateModel} from \"/mimswap/interfaces/IFeeRateModel.sol\";\nimport {IWETH} from \"interfaces/IWETH.sol\";\n\n/// @title MIMSwap MagicLP\n/// @author Adapted from DODOEX DSP https://github.com/DODOEX/contractV2/tree/main/contracts/DODOStablePool\ncontract MagicLP is ERC20, ReentrancyGuard, Owned {\n    using Math for uint256;\n    using SafeCastLib for uint256;\n    using SafeTransferLib for address;\n\n    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);\n    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);\n    event Swap(address fromToken, address toToken, uint256 fromAmount, uint256 toAmount, address trader, address receiver);\n    event FlashLoan(address borrower, address assetTo, uint256 baseAmount, uint256 quoteAmount);\n    event RChange(PMMPricing.RState newRState);\n    event TokenRescue(address indexed token, address to, uint256 amount);\n    event ParametersChanged(uint256 newLpFeeRate, uint256 newI, uint256 newK, uint256 newBaseReserve, uint256 newQuoteReserve);\n\n    error ErrInitialized();\n    error ErrBaseQuoteSame();\n    error ErrInvalidI();\n    error ErrInvalidK();\n    error ErrExpired();\n    error ErrInvalidSignature();\n    error ErrFlashLoanFailed();\n    error ErrNoBaseInput();\n    error ErrZeroAddress();\n    error ErrZeroQuoteAmount();\n    error ErrZeroQuoteTarget();\n    error ErrMintAmountNotEnough();\n    error ErrNotEnough();\n    error ErrWithdrawNotEnough();\n    error ErrSellBackNotAllowed();\n    error ErrInvalidLPFeeRate();\n    error ErrNotImplementationOwner();\n    error ErrNotImplementation();\n    error ErrNotClone();\n    error ErrNotAllowed();\n    error ErrReserveAmountNotEnough();\n    error ErrOverflow();\n\n    MagicLP public immutable implementation;\n\n    uint256 public constant MAX_I = 10 ** 36;\n    uint256 public constant MAX_K = 10 ** 18;\n    uint256 public constant MIN_LP_FEE_RATE = 1e14; // 0.01%\n    uint256 public constant MAX_LP_FEE_RATE = 1e16; // 1%\n\n    bool internal _INITIALIZED_;\n\n    address public _BASE_TOKEN_;\n    address public _QUOTE_TOKEN_;\n    uint112 public _BASE_RESERVE_;\n    uint112 public _QUOTE_RESERVE_;\n    uint32 public _BLOCK_TIMESTAMP_LAST_;\n    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;\n    uint112 public _BASE_TARGET_;\n    uint112 public _QUOTE_TARGET_;\n    uint32 public _RState_;\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\n    uint256 public _LP_FEE_RATE_;\n    uint256 public _K_;\n    uint256 public _I_;\n\n    constructor(address owner_) Owned(owner_) {\n        implementation = this;\n\n        // prevents the implementation contract initialization\n        _INITIALIZED_ = true;\n    }\n\n    function init(\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 i,\n        uint256 k\n    ) external {\n        if (_INITIALIZED_) {\n            revert ErrInitialized();\n        }\n        if (mtFeeRateModel == address(0) || baseTokenAddress == address(0) || quoteTokenAddress == address(0)) {\n            revert ErrZeroAddress();\n        }\n        if (baseTokenAddress == quoteTokenAddress) {\n            revert ErrBaseQuoteSame();\n        }\n        if (i == 0 || i > MAX_I) {\n            revert ErrInvalidI();\n        }\n        if (k > MAX_K) {\n            revert ErrInvalidK();\n        }\n        if (lpFeeRate < MIN_LP_FEE_RATE || lpFeeRate > MAX_LP_FEE_RATE) {\n            revert ErrInvalidLPFeeRate();\n        }\n\n        _INITIALIZED_ = true;\n        _BASE_TOKEN_ = baseTokenAddress;\n        _QUOTE_TOKEN_ = quoteTokenAddress;\n        _I_ = i;\n        _K_ = k;\n        _LP_FEE_RATE_ = lpFeeRate;\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\n        _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2 ** 32);\n\n        _afterInitialized();\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PUBLIC\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function sync() external nonReentrant {\n        _sync();\n    }\n\n    function correctRState() external {\n        if (_RState_ == uint32(PMMPricing.RState.BELOW_ONE) && _BASE_RESERVE_ < _BASE_TARGET_) {\n            _RState_ = uint32(PMMPricing.RState.ONE);\n            _BASE_TARGET_ = _BASE_RESERVE_;\n            _QUOTE_TARGET_ = _QUOTE_RESERVE_;\n        }\n        if (_RState_ == uint32(PMMPricing.RState.ABOVE_ONE) && _QUOTE_RESERVE_ < _QUOTE_TARGET_) {\n            _RState_ = uint32(PMMPricing.RState.ONE);\n            _BASE_TARGET_ = _BASE_RESERVE_;\n            _QUOTE_TARGET_ = _QUOTE_RESERVE_;\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// VIEWS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function name() public view override returns (string memory) {\n        return string(abi.encodePacked(\"MagicLP \", IERC20Metadata(_BASE_TOKEN_).symbol(), \"/\", IERC20Metadata(_QUOTE_TOKEN_).symbol()));\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return \"MagicLP\";\n    }\n\n    function decimals() public view override returns (uint8) {\n        return IERC20Metadata(_BASE_TOKEN_).decimals();\n    }\n\n    function querySellBase(\n        address trader,\n        uint256 payBaseAmount\n    ) public view returns (uint256 receiveQuoteAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newBaseTarget) {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount);\n\n        (uint256 lpFeeRate, uint256 mtFeeRate) = _MT_FEE_RATE_MODEL_.getFeeRate(trader, _LP_FEE_RATE_);\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\n        receiveQuoteAmount = receiveQuoteAmount - DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate) - mtFee;\n        newBaseTarget = state.B0;\n    }\n\n    function querySellQuote(\n        address trader,\n        uint256 payQuoteAmount\n    ) public view returns (uint256 receiveBaseAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newQuoteTarget) {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveBaseAmount, newRState) = PMMPricing.sellQuoteToken(state, payQuoteAmount);\n\n        (uint256 lpFeeRate, uint256 mtFeeRate) = _MT_FEE_RATE_MODEL_.getFeeRate(trader, _LP_FEE_RATE_);\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\n        receiveBaseAmount = receiveBaseAmount - DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate) - mtFee;\n        newQuoteTarget = state.Q0;\n    }\n\n    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\n        state.i = _I_;\n        state.K = _K_;\n        state.B = _BASE_RESERVE_;\n        state.Q = _QUOTE_RESERVE_;\n        state.B0 = _BASE_TARGET_; // will be calculated in adjustedTarget\n        state.Q0 = _QUOTE_TARGET_;\n        state.R = PMMPricing.RState(_RState_);\n        PMMPricing.adjustedTarget(state);\n    }\n\n    function getPMMStateForCall() external view returns (uint256 i, uint256 K, uint256 B, uint256 Q, uint256 B0, uint256 Q0, uint256 R) {\n        PMMPricing.PMMState memory state = getPMMState();\n        i = state.i;\n        K = state.K;\n        B = state.B;\n        Q = state.Q;\n        B0 = state.B0;\n        Q0 = state.Q0;\n        R = uint256(state.R);\n    }\n\n    function getMidPrice() public view returns (uint256 midPrice) {\n        return PMMPricing.getMidPrice(getPMMState());\n    }\n\n    function getReserves() external view returns (uint256 baseReserve, uint256 quoteReserve) {\n        baseReserve = _BASE_RESERVE_;\n        quoteReserve = _QUOTE_RESERVE_;\n    }\n\n    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate) {\n        return _MT_FEE_RATE_MODEL_.getFeeRate(user, _LP_FEE_RATE_);\n    }\n\n    function getBaseInput() public view returns (uint256 input) {\n        return _BASE_TOKEN_.balanceOf(address(this)) - uint256(_BASE_RESERVE_);\n    }\n\n    function getQuoteInput() public view returns (uint256 input) {\n        return _QUOTE_TOKEN_.balanceOf(address(this)) - uint256(_QUOTE_RESERVE_);\n    }\n\n    function version() external pure virtual returns (string memory) {\n        return \"MagicLP 1.0.0\";\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// TRADE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function sellBase(address to) external nonReentrant returns (uint256 receiveQuoteAmount) {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);\n        uint256 mtFee;\n        uint256 newBaseTarget;\n        PMMPricing.RState newRState;\n        (receiveQuoteAmount, mtFee, newRState, newBaseTarget) = querySellBase(tx.origin, baseInput);\n\n        _transferQuoteOut(to, receiveQuoteAmount);\n        _transferQuoteOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            _BASE_TARGET_ = newBaseTarget.toUint112();\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));\n\n        emit Swap(address(_BASE_TOKEN_), address(_QUOTE_TOKEN_), baseInput, receiveQuoteAmount, msg.sender, to);\n    }\n\n    function sellQuote(address to) external nonReentrant returns (uint256 receiveBaseAmount) {\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 quoteInput = quoteBalance - uint256(_QUOTE_RESERVE_);\n        uint256 mtFee;\n        uint256 newQuoteTarget;\n        PMMPricing.RState newRState;\n        (receiveBaseAmount, mtFee, newRState, newQuoteTarget) = querySellQuote(tx.origin, quoteInput);\n\n        _transferBaseOut(to, receiveBaseAmount);\n        _transferBaseOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            _QUOTE_TARGET_ = newQuoteTarget.toUint112();\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);\n\n        emit Swap(address(_QUOTE_TOKEN_), address(_BASE_TOKEN_), quoteInput, receiveBaseAmount, msg.sender, to);\n    }\n\n    function flashLoan(uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes calldata data) external nonReentrant {\n        _transferBaseOut(assetTo, baseAmount);\n        _transferQuoteOut(assetTo, quoteAmount);\n\n        if (data.length > 0) {\n            ICallee(assetTo).FlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\n        }\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        // no input -> pure loss\n        if (baseBalance < _BASE_RESERVE_ && quoteBalance < _QUOTE_RESERVE_) {\n            revert ErrFlashLoanFailed();\n        }\n\n        // sell quote case\n        // quote input + base output\n        if (baseBalance < _BASE_RESERVE_) {\n            uint256 quoteInput = quoteBalance - uint256(_QUOTE_RESERVE_);\n            (uint256 receiveBaseAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newQuoteTarget) = querySellQuote(\n                tx.origin,\n                quoteInput\n            );\n\n            if (uint256(_BASE_RESERVE_) - baseBalance > receiveBaseAmount) {\n                revert ErrFlashLoanFailed();\n            }\n\n            _transferBaseOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);\n            if (_RState_ != uint32(newRState)) {\n                _QUOTE_TARGET_ = newQuoteTarget.toUint112();\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit Swap(address(_QUOTE_TOKEN_), address(_BASE_TOKEN_), quoteInput, receiveBaseAmount, msg.sender, assetTo);\n        }\n\n        // sell base case\n        // base input + quote output\n        if (quoteBalance < _QUOTE_RESERVE_) {\n            uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);\n            (uint256 receiveQuoteAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newBaseTarget) = querySellBase(\n                tx.origin,\n                baseInput\n            );\n\n            if (uint256(_QUOTE_RESERVE_) - quoteBalance > receiveQuoteAmount) {\n                revert ErrFlashLoanFailed();\n            }\n\n            _transferQuoteOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);\n            if (_RState_ != uint32(newRState)) {\n                _BASE_TARGET_ = newBaseTarget.toUint112();\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit Swap(address(_BASE_TOKEN_), address(_QUOTE_TOKEN_), baseInput, receiveQuoteAmount, msg.sender, assetTo);\n        }\n\n        _sync();\n\n        emit FlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// BUY & SELL SHARES\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    // buy shares [round down]\n    function buyShares(address to) external nonReentrant returns (uint256 shares, uint256 baseInput, uint256 quoteInput) {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 baseReserve = _BASE_RESERVE_;\n        uint256 quoteReserve = _QUOTE_RESERVE_;\n\n        baseInput = baseBalance - baseReserve;\n        quoteInput = quoteBalance - quoteReserve;\n\n        if (baseInput == 0) {\n            revert ErrNoBaseInput();\n        }\n\n        // Round down when withdrawing. Therefore, never be a situation occurring balance is 0 but totalsupply is not 0\n        // But May Happenï¼Œreserve >0 But totalSupply = 0\n        if (totalSupply() == 0) {\n            // case 1. initial supply\n            if (quoteBalance == 0) {\n                revert ErrZeroQuoteAmount();\n            }\n\n            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_) ? DecimalMath.divFloor(quoteBalance, _I_) : baseBalance;\n            _BASE_TARGET_ = shares.toUint112();\n            _QUOTE_TARGET_ = DecimalMath.mulFloor(shares, _I_).toUint112();\n\n            if (_QUOTE_TARGET_ == 0) {\n                revert ErrZeroQuoteTarget();\n            }\n\n            if (shares <= 2001) {\n                revert ErrMintAmountNotEnough();\n            }\n\n            _mint(address(0), 1001);\n            shares -= 1001;\n        } else if (baseReserve > 0 && quoteReserve > 0) {\n            // case 2. normal case\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\n            uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;\n            shares = DecimalMath.mulFloor(totalSupply(), mintRatio);\n\n            _BASE_TARGET_ = (uint256(_BASE_TARGET_) + DecimalMath.mulFloor(uint256(_BASE_TARGET_), mintRatio)).toUint112();\n            _QUOTE_TARGET_ = (uint256(_QUOTE_TARGET_) + DecimalMath.mulFloor(uint256(_QUOTE_TARGET_), mintRatio)).toUint112();\n        }\n\n        _mint(to, shares);\n        _setReserve(baseBalance, quoteBalance);\n\n        emit BuyShares(to, shares, balanceOf(to));\n    }\n\n    // sell shares [round down]\n    function sellShares(\n        uint256 shareAmount,\n        address to,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        bytes calldata data,\n        uint256 deadline\n    ) external nonReentrant returns (uint256 baseAmount, uint256 quoteAmount) {\n        if (deadline < block.timestamp) {\n            revert ErrExpired();\n        }\n        if (shareAmount > balanceOf(msg.sender)) {\n            revert ErrNotEnough();\n        }\n        if (to == address(this)) {\n            revert ErrSellBackNotAllowed();\n        }\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 totalShares = totalSupply();\n\n        baseAmount = (baseBalance * shareAmount) / totalShares;\n        quoteAmount = (quoteBalance * shareAmount) / totalShares;\n\n        _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_) - (uint256(_BASE_TARGET_) * shareAmount).divCeil(totalShares));\n        _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_) - (uint256(_QUOTE_TARGET_) * shareAmount).divCeil(totalShares));\n\n        if (baseAmount < baseMinAmount || quoteAmount < quoteMinAmount) {\n            revert ErrWithdrawNotEnough();\n        }\n\n        _burn(msg.sender, shareAmount);\n        _transferBaseOut(to, baseAmount);\n        _transferQuoteOut(to, quoteAmount);\n        _sync();\n\n        if (data.length > 0) {\n            ICallee(to).SellShareCall(msg.sender, shareAmount, baseAmount, quoteAmount, data);\n        }\n\n        emit SellShares(msg.sender, to, shareAmount, balanceOf(msg.sender));\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// ADMIN\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function rescue(address token, address to, uint256 amount) external onlyImplementationOwner {\n        if (token == _BASE_TOKEN_ || token == _QUOTE_TOKEN_) {\n            revert ErrNotAllowed();\n        }\n\n        token.safeTransfer(to, amount);\n        emit TokenRescue(token, to, amount);\n    }\n\n    function setParameters(\n        address assetTo,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) public nonReentrant onlyImplementationOwner {\n        if (_BASE_RESERVE_ < minBaseReserve || _QUOTE_RESERVE_ < minQuoteReserve) {\n            revert ErrReserveAmountNotEnough();\n        }\n        if (newI == 0 || newI > MAX_I) {\n            revert ErrInvalidI();\n        }\n        if (newK > MAX_K) {\n            revert ErrInvalidK();\n        }\n        if (newLpFeeRate < MIN_LP_FEE_RATE || newLpFeeRate > MAX_LP_FEE_RATE) {\n            revert ErrInvalidLPFeeRate();\n        }\n\n        _LP_FEE_RATE_ = uint64(newLpFeeRate);\n        _K_ = uint64(newK);\n        _I_ = uint128(newI);\n\n        _transferBaseOut(assetTo, baseOutAmount);\n        _transferQuoteOut(assetTo, quoteOutAmount);\n        (uint256 newBaseBalance, uint256 newQuoteBalance) = _resetTargetAndReserve();\n\n        emit ParametersChanged(newLpFeeRate, newI, newK, newBaseBalance, newQuoteBalance);\n    }\n\n    function ratioSync() external nonReentrant onlyImplementationOwner {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        if (baseBalance > type(uint112).max || quoteBalance > type(uint112).max) {\n            revert ErrOverflow();\n        }\n\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_TARGET_ = uint112((uint256(_BASE_TARGET_) * baseBalance) / uint256(_BASE_RESERVE_));\n            _BASE_RESERVE_ = uint112(baseBalance);\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_TARGET_ = uint112((uint256(_QUOTE_TARGET_) * quoteBalance) / uint256(_QUOTE_RESERVE_));\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\n        }\n\n        _twapUpdate();\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// INTERNALS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _resetTargetAndReserve() internal returns (uint256 baseBalance, uint256 quoteBalance) {\n        baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        if (baseBalance > type(uint112).max || quoteBalance > type(uint112).max) {\n            revert ErrOverflow();\n        }\n\n        _BASE_RESERVE_ = uint112(baseBalance);\n        _QUOTE_RESERVE_ = uint112(quoteBalance);\n        _BASE_TARGET_ = uint112(baseBalance);\n        _QUOTE_TARGET_ = uint112(quoteBalance);\n        _RState_ = uint32(PMMPricing.RState.ONE);\n\n        _twapUpdate();\n    }\n\n    function _twapUpdate() internal {\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n        uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;\n\n        if (timeElapsed > 0 && _BASE_RESERVE_ != 0 && _QUOTE_RESERVE_ != 0) {\n            /// @dev It is desired and expected for this value to\n            /// overflow once it has hit the max of `type.uint256`.\n            unchecked {\n                _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;\n            }\n        }\n\n        _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;\n    }\n\n    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\n        _BASE_RESERVE_ = baseReserve.toUint112();\n        _QUOTE_RESERVE_ = quoteReserve.toUint112();\n\n        _twapUpdate();\n    }\n\n    function _sync() internal {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_RESERVE_ = baseBalance.toUint112();\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_RESERVE_ = quoteBalance.toUint112();\n        }\n\n        _twapUpdate();\n    }\n\n    function _transferBaseOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _BASE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function _transferQuoteOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function _mint(address to, uint256 amount) internal override {\n        if (amount <= 1000) {\n            revert ErrMintAmountNotEnough();\n        }\n\n        super._mint(to, amount);\n    }\n\n    function _afterInitialized() internal virtual {}\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// MODIFIERS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    modifier onlyImplementationOwner() {\n        if (msg.sender != implementation.owner()) {\n            revert ErrNotImplementationOwner();\n        }\n        _;\n    }\n\n    modifier onlyClones() {\n        if (address(this) == address(implementation)) {\n            revert ErrNotClone();\n        }\n        _;\n    }\n\n    modifier onlyImplementation() {\n        if (address(this) != address(implementation)) {\n            revert ErrNotImplementation();\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/oracles/aggregators/MagicLpAggregator.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {IERC20Metadata} from \"openzeppelin-contracts/interfaces/IERC20Metadata.sol\";\nimport {IAggregator} from \"interfaces/IAggregator.sol\";\nimport {IMagicLP} from \"/mimswap/interfaces/IMagicLP.sol\";\n\ncontract MagicLpAggregator is IAggregator {\n    IMagicLP public immutable pair;\n    IAggregator public immutable baseOracle;\n    IAggregator public immutable quoteOracle;\n    uint8 public immutable baseDecimals;\n    uint8 public immutable quoteDecimals;\n\n    uint256 public constant WAD = 18;\n\n    /// @param pair_ The MagicLP pair address\n    /// @param baseOracle_ The base oracle\n    /// @param quoteOracle_ The quote oracle\n    constructor(IMagicLP pair_, IAggregator baseOracle_, IAggregator quoteOracle_) {\n        pair = pair_;\n        baseOracle = baseOracle_;\n        quoteOracle = quoteOracle_;\n        baseDecimals = IERC20Metadata(pair_._BASE_TOKEN_()).decimals();\n        quoteDecimals = IERC20Metadata(pair_._QUOTE_TOKEN_()).decimals();\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return 18;\n    }\n\n    function _getReserves() internal view virtual returns (uint256, uint256) {\n        (uint256 baseReserve, uint256 quoteReserve) = pair.getReserves();\n    }\n\n    function latestAnswer() public view override returns (int256) {\n        uint256 baseAnswerNomalized = uint256(baseOracle.latestAnswer()) * (10 ** (WAD - baseOracle.decimals()));\n        uint256 quoteAnswerNormalized = uint256(quoteOracle.latestAnswer()) * (10 ** (WAD - quoteOracle.decimals()));\n        uint256 minAnswer = baseAnswerNomalized < quoteAnswerNormalized ? baseAnswerNomalized : quoteAnswerNormalized;\n\n        (uint256 baseReserve, uint256 quoteReserve) = _getReserves();\n        baseReserve = baseReserve * (10 ** (WAD - baseDecimals));\n        quoteReserve = quoteReserve * (10 ** (WAD - quoteDecimals));\n        return int256(minAnswer * (baseReserve + quoteReserve) / pair.totalSupply());\n    }\n\n    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {\n        return (0, latestAnswer(), 0, 0, 0);\n    }\n}"
    }
  ]
}