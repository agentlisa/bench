{
  "Title": "Lack of ERC-20 Approvals Prevents IonZapper Contract From Functioning as Intended",
  "Content": "The [`zapDepositWstEth` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/periphery/IonZapper.sol#L67) in the `IonZapper` contract allows users to add collateral to the `IonPool` contract using stETH tokens from their account. The function is intended to first transfer the specified `amountStEth` amount of tokens from the user's account into the `IonZapper` contract, then wrap these tokens into the wstETH token, and finally call the `GemJoin` contract to deposit these wstETH tokens on behalf of the original caller.\n\n\nHowever, there are two places within this function where the `IonZapper` contract needs to approve external contracts to spend ERC-20 tokens where the approvals do not exist:\n\n\n* When wrapping the stETH token into wstETH, the stETH held by the `IonZapper` contract is [transferred into the wstETH contract](https://etherscan.io/token/0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0#code#L1078) when the [`wrap` function is called](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/periphery/IonZapper.sol#L70). In order for the wstETH contract to make this transfer, the `IonZapper` contract must approve the wstETH contract to spend stETH tokens on its behalf.\n* When [calling the `join` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/periphery/IonZapper.sol#L71) on the `GemJoin` contract, the wstETH held by the `IonZapper` contract is [transferred into the `GemJoin` contract](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/join/GemJoin.sol#L57). In order for the `GemJoin` contract to make this transfer, the `IonZapper` contract must approve the `GemJoin` contract to spend wstETH tokens on its behalf.\n\n\nConsider setting the appropriate token approvals for the appropriate amounts within the `zapDepositWstEth` function to allow it to operate as intended.\n\n\n***Update:** Resolved in [pull request #21](https://github.com/Ion-Protocol/ion-protocol/pull/21).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/periphery/IonZapper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IonPool } from \"src/IonPool.sol\";\nimport { RAY } from \"src/libraries/math/WadRayMath.sol\";\nimport { IWETH9 } from \"src/interfaces/IWETH9.sol\";\nimport { Whitelist } from \"src/Whitelist.sol\";\nimport { IWstEth } from \"src/interfaces/ProviderInterfaces.sol\";\nimport { GemJoin } from \"src/join/GemJoin.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract IonZapper {\n    IonPool public immutable POOL;\n    IWETH9 public immutable WETH;\n\n    IERC20 public immutable STETH;\n    IWstEth public immutable WSTETH;\n    GemJoin public immutable WSTETH_JOIN;\n\n    Whitelist public immutable WHITELIST;\n\n    modifier onlyWhitelistedLenders(bytes32[] memory proof) {\n        WHITELIST.isWhitelistedLender(msg.sender, proof);\n        _;\n    }\n\n    constructor(\n        IonPool _ionPool,\n        IWETH9 _weth,\n        IERC20 _stEth,\n        IWstEth _wstEth,\n        GemJoin _wstEthJoin,\n        Whitelist _whitelist\n    ) {\n        POOL = _ionPool;\n        WETH = _weth;\n\n        STETH = _stEth;\n        WSTETH = _wstEth;\n        WSTETH_JOIN = _wstEthJoin;\n\n        WHITELIST = _whitelist;\n        _weth.approve(address(_ionPool), type(uint256).max);\n    }\n\n    function zapSupply(bytes32[] calldata proof) external payable onlyWhitelistedLenders(proof) {\n        uint256 amount = msg.value;\n\n        WETH.deposit{ value: amount }();\n        POOL.supply(msg.sender, amount, proof);\n    }\n\n    function zapRepay(uint8 ilkIndex) external payable {\n        uint256 amount = msg.value;\n\n        uint256 currentIlkRate = POOL.rate(ilkIndex);\n        (,, uint256 ilkRateIncrease,,) = POOL.calculateRewardAndDebtDistribution(ilkIndex);\n        uint256 newIlkRate = currentIlkRate + ilkRateIncrease;\n\n        uint256 normalizedAmountToRepay = amount * RAY / newIlkRate;\n\n        WETH.deposit{ value: amount }();\n        POOL.repay(ilkIndex, msg.sender, msg.sender, normalizedAmountToRepay);\n    }\n\n    function zapDepositWstEth(uint256 amountStEth) external payable {\n        STETH.transferFrom(msg.sender, address(this), amountStEth);\n\n        uint256 outputWstEthAmount = WSTETH.wrap(amountStEth);\n        WSTETH_JOIN.join(msg.sender, outputWstEthAmount);\n    }\n}"
    },
    {
      "filename": "src/periphery/IonZapper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IonPool } from \"src/IonPool.sol\";\nimport { RAY } from \"src/libraries/math/WadRayMath.sol\";\nimport { IWETH9 } from \"src/interfaces/IWETH9.sol\";\nimport { Whitelist } from \"src/Whitelist.sol\";\nimport { IWstEth } from \"src/interfaces/ProviderInterfaces.sol\";\nimport { GemJoin } from \"src/join/GemJoin.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract IonZapper {\n    IonPool public immutable POOL;\n    IWETH9 public immutable WETH;\n\n    IERC20 public immutable STETH;\n    IWstEth public immutable WSTETH;\n    GemJoin public immutable WSTETH_JOIN;\n\n    Whitelist public immutable WHITELIST;\n\n    modifier onlyWhitelistedLenders(bytes32[] memory proof) {\n        WHITELIST.isWhitelistedLender(msg.sender, proof);\n        _;\n    }\n\n    constructor(\n        IonPool _ionPool,\n        IWETH9 _weth,\n        IERC20 _stEth,\n        IWstEth _wstEth,\n        GemJoin _wstEthJoin,\n        Whitelist _whitelist\n    ) {\n        POOL = _ionPool;\n        WETH = _weth;\n\n        STETH = _stEth;\n        WSTETH = _wstEth;\n        WSTETH_JOIN = _wstEthJoin;\n\n        WHITELIST = _whitelist;\n        _weth.approve(address(_ionPool), type(uint256).max);\n    }\n\n    function zapSupply(bytes32[] calldata proof) external payable onlyWhitelistedLenders(proof) {\n        uint256 amount = msg.value;\n\n        WETH.deposit{ value: amount }();\n        POOL.supply(msg.sender, amount, proof);\n    }\n\n    function zapRepay(uint8 ilkIndex) external payable {\n        uint256 amount = msg.value;\n\n        uint256 currentIlkRate = POOL.rate(ilkIndex);\n        (,, uint256 ilkRateIncrease,,) = POOL.calculateRewardAndDebtDistribution(ilkIndex);\n        uint256 newIlkRate = currentIlkRate + ilkRateIncrease;\n\n        uint256 normalizedAmountToRepay = amount * RAY / newIlkRate;\n\n        WETH.deposit{ value: amount }();\n        POOL.repay(ilkIndex, msg.sender, msg.sender, normalizedAmountToRepay);\n    }\n\n    function zapDepositWstEth(uint256 amountStEth) external payable {\n        STETH.transferFrom(msg.sender, address(this), amountStEth);\n\n        uint256 outputWstEthAmount = WSTETH.wrap(amountStEth);\n        WSTETH_JOIN.join(msg.sender, outputWstEthAmount);\n    }\n}"
    },
    {
      "filename": "src/periphery/IonZapper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IonPool } from \"src/IonPool.sol\";\nimport { RAY } from \"src/libraries/math/WadRayMath.sol\";\nimport { IWETH9 } from \"src/interfaces/IWETH9.sol\";\nimport { Whitelist } from \"src/Whitelist.sol\";\nimport { IWstEth } from \"src/interfaces/ProviderInterfaces.sol\";\nimport { GemJoin } from \"src/join/GemJoin.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract IonZapper {\n    IonPool public immutable POOL;\n    IWETH9 public immutable WETH;\n\n    IERC20 public immutable STETH;\n    IWstEth public immutable WSTETH;\n    GemJoin public immutable WSTETH_JOIN;\n\n    Whitelist public immutable WHITELIST;\n\n    modifier onlyWhitelistedLenders(bytes32[] memory proof) {\n        WHITELIST.isWhitelistedLender(msg.sender, proof);\n        _;\n    }\n\n    constructor(\n        IonPool _ionPool,\n        IWETH9 _weth,\n        IERC20 _stEth,\n        IWstEth _wstEth,\n        GemJoin _wstEthJoin,\n        Whitelist _whitelist\n    ) {\n        POOL = _ionPool;\n        WETH = _weth;\n\n        STETH = _stEth;\n        WSTETH = _wstEth;\n        WSTETH_JOIN = _wstEthJoin;\n\n        WHITELIST = _whitelist;\n        _weth.approve(address(_ionPool), type(uint256).max);\n    }\n\n    function zapSupply(bytes32[] calldata proof) external payable onlyWhitelistedLenders(proof) {\n        uint256 amount = msg.value;\n\n        WETH.deposit{ value: amount }();\n        POOL.supply(msg.sender, amount, proof);\n    }\n\n    function zapRepay(uint8 ilkIndex) external payable {\n        uint256 amount = msg.value;\n\n        uint256 currentIlkRate = POOL.rate(ilkIndex);\n        (,, uint256 ilkRateIncrease,,) = POOL.calculateRewardAndDebtDistribution(ilkIndex);\n        uint256 newIlkRate = currentIlkRate + ilkRateIncrease;\n\n        uint256 normalizedAmountToRepay = amount * RAY / newIlkRate;\n\n        WETH.deposit{ value: amount }();\n        POOL.repay(ilkIndex, msg.sender, msg.sender, normalizedAmountToRepay);\n    }\n\n    function zapDepositWstEth(uint256 amountStEth) external payable {\n        STETH.transferFrom(msg.sender, address(this), amountStEth);\n\n        uint256 outputWstEthAmount = WSTETH.wrap(amountStEth);\n        WSTETH_JOIN.join(msg.sender, outputWstEthAmount);\n    }\n}"
    }
  ]
}