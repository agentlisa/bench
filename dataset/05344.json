{
  "Title": "[G-17]  State variables should be cached in stack variables rather than re-reading them from storage",
  "Content": "The instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (100 gas) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n### Please note these instances were not included in the bot reports.\n\n### 53 Instances\n\n<details>\n\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/OLAS.sol#L45\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/OLAS.sol#L60\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/OLAS.sol#L78\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/bridges/FxGovernorTunnel.sol#L115 \n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/bridges/BridgedERC20.sol#L33\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/bridges/BridgedERC20.sol#L51\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/bridges/BridgedERC20.sol#L62\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericRegistry.sol#L40\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericRegistry.sol#L56\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericRegistry.sol#L81\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/UnitRegistry.sol#L60\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/UnitRegistry.sol#L126\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericManager.sol#L23\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericManager.sol#L39\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericManager.sol#L50\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Depository.sol#L126\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Depository.sol#L146\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Depository.sol#L166\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Depository.sol#L186\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Depository.sol#L227\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Depository.sol#L247\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Dispenser.sol#L49\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Dispenser.sol#L67\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/DonatorBlacklist.sol#L39\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/DonatorBlacklist.sol#L59\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L387\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L407\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L426\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L453\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L477\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L507\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L572\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L612\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L512\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L633\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L796\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L906\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L931\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L1090\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L122\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L140\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L159\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L185\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L215\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L266\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L316\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L397\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L436\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L496\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L478\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L490\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L510\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L534\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L545\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "governance/contracts/OLAS.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../lib/solmate/src/tokens/ERC20.sol\";\n\n/// @dev Only `manager` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param manager Required sender address as a manager.\nerror ManagerOnly(address sender, address manager);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n/// @title OLAS - Smart contract for the OLAS token.\n/// @author AL\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\ncontract OLAS is ERC20 {\n    event MinterUpdated(address indexed minter);\n    event OwnerUpdated(address indexed owner);\n\n    // One year interval\n    uint256 public constant oneYear = 1 days * 365;\n    // Total supply cap for the first ten years (one billion OLAS tokens)\n    uint256 public constant tenYearSupplyCap = 1_000_000_000e18;\n    // Maximum annual inflation after first ten years\n    uint256 public constant maxMintCapFraction = 2;\n    // Initial timestamp of the token deployment\n    uint256 public immutable timeLaunch;\n\n    // Owner address\n    address public owner;\n    // Minter address\n    address public minter;\n\n    constructor() ERC20(\"Autonolas\", \"OLAS\", 18) {\n        owner = msg.sender;\n        minter = msg.sender;\n        timeLaunch = block.timestamp;\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Changes the minter address.\n    /// @param newMinter Address of a new minter.\n    function changeMinter(address newMinter) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newMinter == address(0)) {\n            revert ZeroAddress();\n        }\n\n        minter = newMinter;\n        emit MinterUpdated(newMinter);\n    }\n\n    /// @dev Mints OLAS tokens.\n    /// @notice If the inflation control does not pass, the revert does not take place, as well as no action is performed.\n    /// @param account Account address.\n    /// @param amount OLAS token amount.\n    function mint(address account, uint256 amount) external {\n        // Access control\n        if (msg.sender != minter) {\n            revert ManagerOnly(msg.sender, minter);\n        }\n\n        // Check the inflation schedule and mint\n        if (inflationControl(amount)) {\n            _mint(account, amount);\n        }\n    }\n\n    /// @dev Provides various checks for the inflation control.\n    /// @notice The `<=` check is left as is for a better code readability.\n    /// @param amount Amount of OLAS to mint.\n    /// @return True if the amount request is within inflation boundaries.\n    function inflationControl(uint256 amount) public view returns (bool) {\n        uint256 remainder = inflationRemainder();\n        return (amount <= remainder);\n    }\n\n    /// @dev Gets the reminder of OLAS possible for the mint.\n    /// @return remainder OLAS token remainder.\n    function inflationRemainder() public view returns (uint256 remainder) {\n        uint256 _totalSupply = totalSupply;\n        // Current year\n        uint256 numYears = (block.timestamp - timeLaunch) / oneYear;\n        // Calculate maximum mint amount to date\n        uint256 supplyCap = tenYearSupplyCap;\n        // After 10 years, adjust supplyCap according to the yearly inflation % set in maxMintCapFraction\n        if (numYears > 9) {\n            // Number of years after ten years have passed (including ongoing ones)\n            numYears -= 9;\n            for (uint256 i = 0; i < numYears; ++i) {\n                supplyCap += (supplyCap * maxMintCapFraction) / 100;\n            }\n        }\n        // Check for the requested mint overflow\n        remainder = supplyCap - _totalSupply;\n    }\n\n    /// @dev Burns OLAS tokens.\n    /// @param amount OLAS token amount to burn.\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    /// @dev Decreases the allowance of another account over their tokens.\n    /// @notice This implementation does not decrease spender allowance if the maximum allowance was granted.\n    /// @notice The underflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to decrease approval by.\n    /// @return True if the operation succeeded.\n    function decreaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        if (spenderAllowance != type(uint256).max) {\n            spenderAllowance -= amount;\n            allowance[msg.sender][spender] = spenderAllowance;\n            emit Approval(msg.sender, spender, spenderAllowance);\n        }\n\n        return true;\n    }\n\n    /// @dev Increases the allowance of another account over their tokens.\n    /// @notice The overflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to increase approval by.\n    /// @return True if the operation succeeded.\n    function increaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        spenderAllowance += amount;\n        allowance[msg.sender][spender] = spenderAllowance;\n        emit Approval(msg.sender, spender, spenderAllowance);\n\n        return true;\n    }\n}"
    },
    {
      "filename": "governance/contracts/OLAS.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../lib/solmate/src/tokens/ERC20.sol\";\n\n/// @dev Only `manager` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param manager Required sender address as a manager.\nerror ManagerOnly(address sender, address manager);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n/// @title OLAS - Smart contract for the OLAS token.\n/// @author AL\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\ncontract OLAS is ERC20 {\n    event MinterUpdated(address indexed minter);\n    event OwnerUpdated(address indexed owner);\n\n    // One year interval\n    uint256 public constant oneYear = 1 days * 365;\n    // Total supply cap for the first ten years (one billion OLAS tokens)\n    uint256 public constant tenYearSupplyCap = 1_000_000_000e18;\n    // Maximum annual inflation after first ten years\n    uint256 public constant maxMintCapFraction = 2;\n    // Initial timestamp of the token deployment\n    uint256 public immutable timeLaunch;\n\n    // Owner address\n    address public owner;\n    // Minter address\n    address public minter;\n\n    constructor() ERC20(\"Autonolas\", \"OLAS\", 18) {\n        owner = msg.sender;\n        minter = msg.sender;\n        timeLaunch = block.timestamp;\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Changes the minter address.\n    /// @param newMinter Address of a new minter.\n    function changeMinter(address newMinter) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newMinter == address(0)) {\n            revert ZeroAddress();\n        }\n\n        minter = newMinter;\n        emit MinterUpdated(newMinter);\n    }\n\n    /// @dev Mints OLAS tokens.\n    /// @notice If the inflation control does not pass, the revert does not take place, as well as no action is performed.\n    /// @param account Account address.\n    /// @param amount OLAS token amount.\n    function mint(address account, uint256 amount) external {\n        // Access control\n        if (msg.sender != minter) {\n            revert ManagerOnly(msg.sender, minter);\n        }\n\n        // Check the inflation schedule and mint\n        if (inflationControl(amount)) {\n            _mint(account, amount);\n        }\n    }\n\n    /// @dev Provides various checks for the inflation control.\n    /// @notice The `<=` check is left as is for a better code readability.\n    /// @param amount Amount of OLAS to mint.\n    /// @return True if the amount request is within inflation boundaries.\n    function inflationControl(uint256 amount) public view returns (bool) {\n        uint256 remainder = inflationRemainder();\n        return (amount <= remainder);\n    }\n\n    /// @dev Gets the reminder of OLAS possible for the mint.\n    /// @return remainder OLAS token remainder.\n    function inflationRemainder() public view returns (uint256 remainder) {\n        uint256 _totalSupply = totalSupply;\n        // Current year\n        uint256 numYears = (block.timestamp - timeLaunch) / oneYear;\n        // Calculate maximum mint amount to date\n        uint256 supplyCap = tenYearSupplyCap;\n        // After 10 years, adjust supplyCap according to the yearly inflation % set in maxMintCapFraction\n        if (numYears > 9) {\n            // Number of years after ten years have passed (including ongoing ones)\n            numYears -= 9;\n            for (uint256 i = 0; i < numYears; ++i) {\n                supplyCap += (supplyCap * maxMintCapFraction) / 100;\n            }\n        }\n        // Check for the requested mint overflow\n        remainder = supplyCap - _totalSupply;\n    }\n\n    /// @dev Burns OLAS tokens.\n    /// @param amount OLAS token amount to burn.\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    /// @dev Decreases the allowance of another account over their tokens.\n    /// @notice This implementation does not decrease spender allowance if the maximum allowance was granted.\n    /// @notice The underflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to decrease approval by.\n    /// @return True if the operation succeeded.\n    function decreaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        if (spenderAllowance != type(uint256).max) {\n            spenderAllowance -= amount;\n            allowance[msg.sender][spender] = spenderAllowance;\n            emit Approval(msg.sender, spender, spenderAllowance);\n        }\n\n        return true;\n    }\n\n    /// @dev Increases the allowance of another account over their tokens.\n    /// @notice The overflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to increase approval by.\n    /// @return True if the operation succeeded.\n    function increaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        spenderAllowance += amount;\n        allowance[msg.sender][spender] = spenderAllowance;\n        emit Approval(msg.sender, spender, spenderAllowance);\n\n        return true;\n    }\n}"
    },
    {
      "filename": "governance/contracts/OLAS.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../lib/solmate/src/tokens/ERC20.sol\";\n\n/// @dev Only `manager` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param manager Required sender address as a manager.\nerror ManagerOnly(address sender, address manager);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n/// @title OLAS - Smart contract for the OLAS token.\n/// @author AL\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\ncontract OLAS is ERC20 {\n    event MinterUpdated(address indexed minter);\n    event OwnerUpdated(address indexed owner);\n\n    // One year interval\n    uint256 public constant oneYear = 1 days * 365;\n    // Total supply cap for the first ten years (one billion OLAS tokens)\n    uint256 public constant tenYearSupplyCap = 1_000_000_000e18;\n    // Maximum annual inflation after first ten years\n    uint256 public constant maxMintCapFraction = 2;\n    // Initial timestamp of the token deployment\n    uint256 public immutable timeLaunch;\n\n    // Owner address\n    address public owner;\n    // Minter address\n    address public minter;\n\n    constructor() ERC20(\"Autonolas\", \"OLAS\", 18) {\n        owner = msg.sender;\n        minter = msg.sender;\n        timeLaunch = block.timestamp;\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Changes the minter address.\n    /// @param newMinter Address of a new minter.\n    function changeMinter(address newMinter) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newMinter == address(0)) {\n            revert ZeroAddress();\n        }\n\n        minter = newMinter;\n        emit MinterUpdated(newMinter);\n    }\n\n    /// @dev Mints OLAS tokens.\n    /// @notice If the inflation control does not pass, the revert does not take place, as well as no action is performed.\n    /// @param account Account address.\n    /// @param amount OLAS token amount.\n    function mint(address account, uint256 amount) external {\n        // Access control\n        if (msg.sender != minter) {\n            revert ManagerOnly(msg.sender, minter);\n        }\n\n        // Check the inflation schedule and mint\n        if (inflationControl(amount)) {\n            _mint(account, amount);\n        }\n    }\n\n    /// @dev Provides various checks for the inflation control.\n    /// @notice The `<=` check is left as is for a better code readability.\n    /// @param amount Amount of OLAS to mint.\n    /// @return True if the amount request is within inflation boundaries.\n    function inflationControl(uint256 amount) public view returns (bool) {\n        uint256 remainder = inflationRemainder();\n        return (amount <= remainder);\n    }\n\n    /// @dev Gets the reminder of OLAS possible for the mint.\n    /// @return remainder OLAS token remainder.\n    function inflationRemainder() public view returns (uint256 remainder) {\n        uint256 _totalSupply = totalSupply;\n        // Current year\n        uint256 numYears = (block.timestamp - timeLaunch) / oneYear;\n        // Calculate maximum mint amount to date\n        uint256 supplyCap = tenYearSupplyCap;\n        // After 10 years, adjust supplyCap according to the yearly inflation % set in maxMintCapFraction\n        if (numYears > 9) {\n            // Number of years after ten years have passed (including ongoing ones)\n            numYears -= 9;\n            for (uint256 i = 0; i < numYears; ++i) {\n                supplyCap += (supplyCap * maxMintCapFraction) / 100;\n            }\n        }\n        // Check for the requested mint overflow\n        remainder = supplyCap - _totalSupply;\n    }\n\n    /// @dev Burns OLAS tokens.\n    /// @param amount OLAS token amount to burn.\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    /// @dev Decreases the allowance of another account over their tokens.\n    /// @notice This implementation does not decrease spender allowance if the maximum allowance was granted.\n    /// @notice The underflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to decrease approval by.\n    /// @return True if the operation succeeded.\n    function decreaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        if (spenderAllowance != type(uint256).max) {\n            spenderAllowance -= amount;\n            allowance[msg.sender][spender] = spenderAllowance;\n            emit Approval(msg.sender, spender, spenderAllowance);\n        }\n\n        return true;\n    }\n\n    /// @dev Increases the allowance of another account over their tokens.\n    /// @notice The overflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to increase approval by.\n    /// @return True if the operation succeeded.\n    function increaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        spenderAllowance += amount;\n        allowance[msg.sender][spender] = spenderAllowance;\n        emit Approval(msg.sender, spender, spenderAllowance);\n\n        return true;\n    }\n}"
    },
    {
      "filename": "governance/contracts/bridges/FxGovernorTunnel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @dev Interface to process message across the bridge.\ninterface IFxMessageProcessor {\n    function processMessageFromRoot(uint256 stateId, address rootMessageSender, bytes memory data) external;\n}\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n/// @dev Only self contract is allowed to call the function.\n/// @param sender Sender address.\n/// @param instance Required contract instance address.\nerror SelfCallOnly(address sender, address instance);\n\n/// @dev Only `fxChild` is allowed to call the function.\n/// @param sender Sender address.\n/// @param fxChild Required Fx Child address.\nerror FxChildOnly(address sender, address fxChild);\n\n/// @dev Only on behalf of `rootGovernor` the function is allowed to process the data.\n/// @param sender Sender address.\n/// @param rootGovernor Required Root Governor address.\nerror RootGovernorOnly(address sender, address rootGovernor);\n\n/// @dev Provided incorrect data length.\n/// @param expected Expected minimum data length.\n/// @param provided Provided data length.\nerror IncorrectDataLength(uint256 expected, uint256 provided);\n\n/// @dev Provided value is bigger than the actual balance.\n/// @param value Provided value.\n/// @param balance Actual balance.\nerror InsufficientBalance(uint256 value, uint256 balance);\n\n/// @dev Target execution failed.\n/// @param target Target address.\n/// @param value Provided value.\n/// @param payload Provided payload.\nerror TargetExecFailed(address target, uint256 value, bytes payload);\n\n/// @title FxGovernorTunnel - Smart contract for the governor child tunnel bridge implementation\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\n/// @author AL\ncontract FxGovernorTunnel is IFxMessageProcessor {\n    event FundsReceived(address indexed sender, uint256 value);\n    event RootGovernorUpdated(address indexed rootMessageSender);\n    event MessageReceived(uint256 indexed stateId, address indexed rootMessageSender, bytes data);\n\n    // Default payload data length includes the number of bytes of at least one address (20 bytes or 160 bits),\n    // value (12 bytes or 96 bits) and the payload size (4 bytes or 32 bits)\n    uint256 public constant DEFAULT_DATA_LENGTH = 36;\n    // FX child address on L2 that receives the message across the bridge from the root L1 network\n    address public immutable fxChild;\n    // Root governor address on L1 that is authorized to propagate the transaction execution across the bridge\n    address public rootGovernor;\n\n    /// @dev FxGovernorTunnel constructor.\n    /// @param _fxChild Fx Child address.\n    /// @param _rootGovernor Root Governor address.\n    constructor(address _fxChild, address _rootGovernor) {\n        // Check fo zero addresses\n        if (_fxChild == address(0) || _rootGovernor == address(0)) {\n            revert ZeroAddress();\n        }\n\n        fxChild = _fxChild;\n        rootGovernor = _rootGovernor;\n    }\n\n    /// @dev Receives native network token.\n    receive() external payable {\n        emit FundsReceived(msg.sender, msg.value);\n    }\n\n    /// @dev Changes the Root Governor address (Timelock).\n    /// @notice The only way to change the Root Governor address is by the Timelock on L1 to request that change.\n    ///         This triggers a self-contract transaction of FxGovernorTunnel that changes the Root Governor address.\n    /// @param newRootGovernor New Root Governor address.\n    function changeRootGovernor(address newRootGovernor) external {\n        // Check if the change is authorized by the previous governor itself\n        // This is possible only if all the checks in the message process function pass and the contract calls itself\n        if (msg.sender != address(this)) {\n            revert SelfCallOnly(msg.sender, address(this));\n        }\n\n        // Check for the zero address\n        if (newRootGovernor == address(0)) {\n            revert ZeroAddress();\n        }\n\n        rootGovernor = newRootGovernor;\n        emit RootGovernorUpdated(newRootGovernor);\n    }\n\n    /// @dev Process message received from the Root Tunnel.\n    /// @notice This is called by onStateReceive function. The sender must be the Root Governor address (Timelock).\n    /// @param stateId Unique state id.\n    /// @param rootMessageSender Root message sender.\n    /// @param data Bytes message sent from the Root Tunnel. The data must be encoded as a set of continuous\n    ///        transactions packed into a single buffer, where each transaction is composed as follows:\n    ///        - target address of 20 bytes (160 bits);\n    ///        - value of 12 bytes (96 bits), as a limit for all of Autonolas ecosystem contracts;\n    ///        - payload length of 4 bytes (32 bits), as 2^32 - 1 characters is more than enough to fill a whole block;\n    ///        - payload as bytes, with the length equal to the specified payload length.\n    function processMessageFromRoot(uint256 stateId, address rootMessageSender, bytes memory data) external override {\n        // Check for the Fx Child address\n        if(msg.sender != fxChild) {\n            revert FxChildOnly(msg.sender, fxChild);\n        }\n\n        // Check for the Root Governor address\n        if(rootMessageSender != rootGovernor) {\n            revert RootGovernorOnly(rootMessageSender, rootGovernor);\n        }\n\n        // Check for the correct data length\n        uint256 dataLength = data.length;\n        if (dataLength < DEFAULT_DATA_LENGTH) {\n            revert IncorrectDataLength(DEFAULT_DATA_LENGTH, data.length);\n        }\n\n        // Unpack and process the data\n        for (uint256 i = 0; i < dataLength;) {\n            address target;\n            uint96 value;\n            uint32 payloadLength;\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // First 20 bytes is the address (160 bits)\n                i := add(i, 20)\n                target := mload(add(data, i))\n                // Offset the data by 12 bytes of value (96 bits)\n                i := add(i, 12)\n                value := mload(add(data, i))\n                // Offset the data by 4 bytes of payload length (32 bits)\n                i := add(i, 4)\n                payloadLength := mload(add(data, i))\n            }\n\n            // Check for the zero address\n            if (target == address(0)) {\n                revert ZeroAddress();\n            }\n            // Check for the value compared to the contract's balance\n            if (value > address(this).balance) {\n                revert InsufficientBalance(value, address(this).balance);\n            }\n\n            // Get the payload\n            bytes memory payload = new bytes(payloadLength);\n            for (uint256 j = 0; j < payloadLength; ++j) {\n                payload[j] = data[i + j];\n            }\n            // Offset the data by the payload number of bytes\n            i += payloadLength;\n\n            // Call the target with the provided payload\n            (bool success, ) = target.call{value: value}(payload);\n            if (!success) {\n                revert TargetExecFailed(target, value, payload);\n            }\n        }\n\n        // Emit received message\n        emit MessageReceived(stateId, rootMessageSender, data);\n    }\n}"
    },
    {
      "filename": "governance/contracts/bridges/BridgedERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {ERC20} from \"../../lib/solmate/src/tokens/ERC20.sol\";\n\n/// @dev Only `owner` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param owner Required sender address as an owner.\nerror OwnerOnly(address sender, address owner);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n\n/// @title BridgedERC20 - Smart contract for bridged ERC20 token\n/// @dev Bridged token contract is owned by the bridge mediator contract, and thus the token representation from\n///      another chain must be minted and burned solely by the bridge mediator contract.\ncontract BridgedERC20 is ERC20 {\n    event OwnerUpdated(address indexed owner);\n\n    // Bridged token owner\n    address public owner;\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) ERC20(_name, _symbol, _decimals) {\n        owner = msg.sender;\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        // Only the contract owner is allowed to change the owner\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Zero address check\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Mints bridged tokens.\n    /// @param account Account address.\n    /// @param amount Bridged token amount.\n    function mint(address account, uint256 amount) external {\n        // Only the contract owner is allowed to mint\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n        \n        _mint(account, amount);\n    }\n\n    /// @dev Burns bridged tokens.\n    /// @param amount Bridged token amount to burn.\n    function burn(uint256 amount) external {\n        // Only the contract owner is allowed to burn\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        _burn(msg.sender, amount);\n    }\n}"
    },
    {
      "filename": "governance/contracts/bridges/BridgedERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {ERC20} from \"../../lib/solmate/src/tokens/ERC20.sol\";\n\n/// @dev Only `owner` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param owner Required sender address as an owner.\nerror OwnerOnly(address sender, address owner);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n\n/// @title BridgedERC20 - Smart contract for bridged ERC20 token\n/// @dev Bridged token contract is owned by the bridge mediator contract, and thus the token representation from\n///      another chain must be minted and burned solely by the bridge mediator contract.\ncontract BridgedERC20 is ERC20 {\n    event OwnerUpdated(address indexed owner);\n\n    // Bridged token owner\n    address public owner;\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) ERC20(_name, _symbol, _decimals) {\n        owner = msg.sender;\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        // Only the contract owner is allowed to change the owner\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Zero address check\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Mints bridged tokens.\n    /// @param account Account address.\n    /// @param amount Bridged token amount.\n    function mint(address account, uint256 amount) external {\n        // Only the contract owner is allowed to mint\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n        \n        _mint(account, amount);\n    }\n\n    /// @dev Burns bridged tokens.\n    /// @param amount Bridged token amount to burn.\n    function burn(uint256 amount) external {\n        // Only the contract owner is allowed to burn\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        _burn(msg.sender, amount);\n    }\n}"
    },
    {
      "filename": "governance/contracts/bridges/BridgedERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {ERC20} from \"../../lib/solmate/src/tokens/ERC20.sol\";\n\n/// @dev Only `owner` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param owner Required sender address as an owner.\nerror OwnerOnly(address sender, address owner);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n\n/// @title BridgedERC20 - Smart contract for bridged ERC20 token\n/// @dev Bridged token contract is owned by the bridge mediator contract, and thus the token representation from\n///      another chain must be minted and burned solely by the bridge mediator contract.\ncontract BridgedERC20 is ERC20 {\n    event OwnerUpdated(address indexed owner);\n\n    // Bridged token owner\n    address public owner;\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) ERC20(_name, _symbol, _decimals) {\n        owner = msg.sender;\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        // Only the contract owner is allowed to change the owner\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Zero address check\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Mints bridged tokens.\n    /// @param account Account address.\n    /// @param amount Bridged token amount.\n    function mint(address account, uint256 amount) external {\n        // Only the contract owner is allowed to mint\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n        \n        _mint(account, amount);\n    }\n\n    /// @dev Burns bridged tokens.\n    /// @param amount Bridged token amount to burn.\n    function burn(uint256 amount) external {\n        // Only the contract owner is allowed to burn\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        _burn(msg.sender, amount);\n    }\n}"
    },
    {
      "filename": "registries/contracts/GenericRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../lib/solmate/src/tokens/ERC721.sol\";\nimport \"./interfaces/IErrorsRegistries.sol\";\n\n/// @title Generic Registry - Smart contract for generic registry template\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\nabstract contract GenericRegistry is IErrorsRegistries, ERC721 {\n    event OwnerUpdated(address indexed owner);\n    event ManagerUpdated(address indexed manager);\n    event BaseURIChanged(string baseURI);\n\n    // Owner address\n    address public owner;\n    // Unit manager\n    address public manager;\n    // Base URI\n    string public baseURI;\n    // Unit counter\n    uint256 public totalSupply;\n    // Reentrancy lock\n    uint256 internal _locked = 1;\n    // To better understand the CID anatomy, please refer to: https://proto.school/anatomy-of-a-cid/05\n    // CID = <multibase_encoding>multibase_encoding(<cid-version><multicodec><multihash-algorithm><multihash-length><multihash-hash>)\n    // CID prefix = <multibase_encoding>multibase_encoding(<cid-version><multicodec><multihash-algorithm><multihash-length>)\n    // to complement the multibase_encoding(<multihash-hash>)\n    // multibase_encoding = base16 = \"f\"\n    // cid-version = version 1 = \"0x01\"\n    // multicodec = dag-pb = \"0x70\"\n    // multihash-algorithm = sha2-256 = \"0x12\"\n    // multihash-length = 256 bits = \"0x20\"\n    string public constant CID_PREFIX = \"f01701220\";\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external virtual {\n        // Check for the ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }"
    }
  ]
}