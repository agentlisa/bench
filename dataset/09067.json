{
  "Title": "[20] The gas computation for memory expansion rounds down instead of rounding up",
  "Content": "\n**Context**: [LowLevelHelpers.sol#L54](https://github.com/ProjectOpenSea/seaport/blob/878121af65be408462f3eae04ab81018b4e199da/contracts/lib/LowLevelHelpers.sol#L54)\n\n```solidity\n            if returndatasize() {\n                // Ensure that sufficient gas is available to copy returndata\n                // while expanding memory where necessary. Start by computing\n                // the word size of returndata and allocated memory.\n                let returnDataWords := div(returndatasize(), OneWord)\n```\n\nThis rounds down the number of words (for example, if `returndatasize() = 31` the correct number of words is 1). The number of words is defined rounded up in EVM.\n\nFor a precise calculation, it should be `div(add(returndatasize(), 31), 32)`. A typical routine in internal compiler code. [Here](https://github.com/ethereum/solidity/blob/02567fd3b47cc4ca3c5d2617c4e2033a8ebe1eb8/libsolidity/codegen/YulUtilFunctions.cpp#L595) is how the Solidity compiler does it. \n\n### Proof of Concept\n\nThe above issue can affect the gas computation for `returndata`, although unlikely to the point that it is severe as the computation is still making some assumptions about `msize`.\n\n### Recommended Mitigation Steps\n\nReplace the rounding from down to up.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-opensea-seaport",
  "Code": [
    {
      "filename": "contracts/lib/LowLevelHelpers.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"./ConsiderationConstants.sol\";\n\n/**\n * @title LowLevelHelpers\n * @author 0age\n * @notice LowLevelHelpers contains logic for performing various low-level\n *         operations.\n */\ncontract LowLevelHelpers {\n    /**\n     * @dev Internal view function to staticcall an arbitrary target with given\n     *      calldata. Note that no data is written to memory and no contract\n     *      size check is performed.\n     *\n     * @param target   The account to staticcall.\n     * @param callData The calldata to supply when staticcalling the target.\n     *\n     * @return success The status of the staticcall to the target.\n     */\n    function _staticcall(address target, bytes memory callData)\n        internal\n        view\n        returns (bool success)\n    {\n        assembly {\n            // Perform the staticcall.\n            success := staticcall(\n                gas(),\n                target,\n                add(callData, OneWord),\n                mload(callData),\n                0,\n                0\n            )\n        }\n    }\n\n    /**\n     * @dev Internal view function to revert and pass along the revert reason if\n     *      data was returned by the last call and that the size of that data\n     *      does not exceed the currently allocated memory size.\n     */\n    function _revertWithReasonIfOneIsReturned() internal view {\n        assembly {\n            // If it returned a message, bubble it up as long as sufficient gas\n            // remains to do so:\n            if returndatasize() {\n                // Ensure that sufficient gas is available to copy returndata\n                // while expanding memory where necessary. Start by computing\n                // the word size of returndata and allocated memory.\n                let returnDataWords := div(returndatasize(), OneWord)\n\n                // Note: use the free memory pointer in place of msize() to work\n                // around a Yul warning that prevents accessing msize directly\n                // when the IR pipeline is activated.\n                let msizeWords := div(mload(FreeMemoryPointerSlot), OneWord)\n\n                // Next, compute the cost of the returndatacopy.\n                let cost := mul(CostPerWord, returnDataWords)\n\n                // Then, compute cost of new memory allocation.\n                if gt(returnDataWords, msizeWords) {\n                    cost := add(\n                        cost,\n                        add(\n                            mul(sub(returnDataWords, msizeWords), CostPerWord),\n                            div(\n                                sub(\n                                    mul(returnDataWords, returnDataWords),\n                                    mul(msizeWords, msizeWords)\n                                ),\n                                MemoryExpansionCoefficient\n                            )\n                        )\n                    )\n                }\n\n                // Finally, add a small constant and compare to gas remaining;\n                // bubble up the revert data if enough gas is still available.\n                if lt(add(cost, ExtraGasBuffer), gas()) {\n                    // Copy returndata to memory; overwrite existing memory.\n                    returndatacopy(0, 0, returndatasize())\n\n                    // Revert, specifying memory region with copied returndata.\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to determine if the first word of returndata\n     *      matches an expected magic value.\n     *\n     * @param expected The expected magic value.\n     *\n     * @return A boolean indicating whether the expected value matches the one\n     *         located in the first word of returndata.\n     */\n    function _doesNotMatchMagic(bytes4 expected) internal pure returns (bool) {\n        // Declare a variable for the value held by the return data buffer.\n        bytes4 result;\n\n        // Utilize assembly in order to read directly from returndata buffer.\n        assembly {\n            // Only put result on stack if return data is exactly one word.\n            if eq(returndatasize(), OneWord) {\n                // Copy the word directly from return data into scratch space.\n                returndatacopy(0, 0, OneWord)\n\n                // Take value from scratch space and place it on the stack.\n                result := mload(0)\n            }\n        }\n\n        // Return a boolean indicating whether expected and located value match.\n        return result != expected;\n    }\n}"
    },
    {
      "filename": "libsolidity/codegen/YulUtilFunctions.cpp",
      "content": "/*\n\tThis file is part of solidity.\n\n\tsolidity is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tsolidity is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with solidity.  If not, see <http://www.gnu.org/licenses/>.\n*/\n// SPDX-License-Identifier: GPL-3.0\n/**\n * Component that can generate various useful Yul functions.\n */\n\n#include <libsolidity/codegen/YulUtilFunctions.h>\n\n#include <libsolidity/codegen/MultiUseYulFunctionCollector.h>\n#include <libsolidity/ast/AST.h>\n#include <libsolidity/codegen/CompilerUtils.h>\n\n#include <libsolutil/CommonData.h>\n#include <libsolutil/FunctionSelector.h>\n#include <libsolutil/Whiskers.h>\n#include <libsolutil/StringUtils.h>\n#include <libsolidity/ast/TypeProvider.h>\n\nusing namespace std;\nusing namespace solidity;\nusing namespace solidity::util;\nusing namespace solidity::frontend;\n\nstring YulUtilFunctions::identityFunction()\n{\n\tstring functionName = \"identity\";\n\treturn m_functionCollector.createFunction(\"identity\", [&](vector<string>& _args, vector<string>& _rets) {\n\t\t_args.push_back(\"value\");\n\t\t_rets.push_back(\"ret\");\n\t\treturn \"ret := value\";\n\t});\n}\n\nstring YulUtilFunctions::combineExternalFunctionIdFunction()\n{\n\tstring functionName = \"combine_external_function_id\";\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn Whiskers(R\"(\n\t\t\tfunction <functionName>(addr, selector) -> combined {\n\t\t\t\tcombined := <shl64>(or(<shl32>(addr), and(selector, 0xffffffff)))\n\t\t\t}\n\t\t)\")\n\t\t(\"functionName\", functionName)\n\t\t(\"shl32\", shiftLeftFunction(32))\n\t\t(\"shl64\", shiftLeftFunction(64))\n\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::splitExternalFunctionIdFunction()\n{\n\tstring functionName = \"split_external_function_id\";\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn Whiskers(R\"(\n\t\t\tfunction <functionName>(combined) -> addr, selector {\n\t\t\t\tcombined := <shr64>(combined)\n\t\t\t\tselector := and(combined, 0xffffffff)\n\t\t\t\taddr := <shr32>(combined)\n\t\t\t}\n\t\t)\")\n\t\t(\"functionName\", functionName)\n\t\t(\"shr32\", shiftRightFunction(32))\n\t\t(\"shr64\", shiftRightFunction(64))\n\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::copyToMemoryFunction(bool _fromCalldata)\n{\n\tstring functionName = \"copy_\" + string(_fromCalldata ? \"calldata\" : \"memory\") + \"_to_memory\";\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\tif (_fromCalldata)\n\t\t{\n\t\t\treturn Whiskers(R\"(\n\t\t\t\tfunction <functionName>(src, dst, length) {\n\t\t\t\t\tcalldatacopy(dst, src, length)\n\t\t\t\t\t// clear end\n\t\t\t\t\tmstore(add(dst, length), 0)\n\t\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t.render();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn Whiskers(R\"(\n\t\t\t\tfunction <functionName>(src, dst, length) {\n\t\t\t\t\tlet i := 0\n\t\t\t\t\tfor { } lt(i, length) { i := add(i, 32) }\n\t\t\t\t\t{\n\t\t\t\t\t\tmstore(add(dst, i), mload(add(src, i)))\n\t\t\t\t\t}\n\t\t\t\t\tif gt(i, length)\n\t\t\t\t\t{\n\t\t\t\t\t\t// clear end\n\t\t\t\t\t\tmstore(add(dst, length), 0)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t.render();\n\t\t}\n\t});\n}\n\nstring YulUtilFunctions::copyLiteralToMemoryFunction(string const& _literal)\n{\n\tstring functionName = \"copy_literal_to_memory_\" + util::toHex(util::keccak256(_literal).asBytes());\n\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn Whiskers(R\"(\n\t\t\tfunction <functionName>() -> memPtr {\n\t\t\t\tmemPtr := <arrayAllocationFunction>(<size>)\n\t\t\t\t<storeLiteralInMem>(add(memPtr, 32))\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"arrayAllocationFunction\", allocateMemoryArrayFunction(*TypeProvider::array(DataLocation::Memory, true)))\n\t\t\t(\"size\", to_string(_literal.size()))\n\t\t\t(\"storeLiteralInMem\", storeLiteralInMemoryFunction(_literal))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::storeLiteralInMemoryFunction(string const& _literal)\n{\n\tstring functionName = \"store_literal_in_memory_\" + util::toHex(util::keccak256(_literal).asBytes());\n\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\tsize_t words = (_literal.length() + 31) / 32;\n\t\tvector<map<string, string>> wordParams(words);\n\t\tfor (size_t i = 0; i < words; ++i)\n\t\t{\n\t\t\twordParams[i][\"offset\"] = to_string(i * 32);\n\t\t\twordParams[i][\"wordValue\"] = formatAsStringOrNumber(_literal.substr(32 * i, 32));\n\t\t}\n\n\t\treturn Whiskers(R\"(\n\t\t\tfunction <functionName>(memPtr) {\n\t\t\t\t<#word>\n\t\t\t\t\tmstore(add(memPtr, <offset>), <wordValue>)\n\t\t\t\t</word>\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"word\", wordParams)\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::copyLiteralToStorageFunction(string const& _literal)\n{\n\tstring functionName = \"copy_literal_to_storage_\" + util::toHex(util::keccak256(_literal).asBytes());\n\n\treturn m_functionCollector.createFunction(functionName, [&](vector<string>& _args, vector<string>&) {\n\t\t_args = {\"slot\"};\n\n\t\tif (_literal.size() >= 32)\n\t\t{\n\t\t\tsize_t words = (_literal.length() + 31) / 32;\n\t\t\tvector<map<string, string>> wordParams(words);\n\t\t\tfor (size_t i = 0; i < words; ++i)\n\t\t\t{\n\t\t\t\twordParams[i][\"offset\"] = to_string(i);\n\t\t\t\twordParams[i][\"wordValue\"] = formatAsStringOrNumber(_literal.substr(32 * i, 32));\n\t\t\t}\n\t\t\treturn Whiskers(R\"(\n\t\t\t\tlet oldLen := <byteArrayLength>(sload(slot))\n\t\t\t\t<cleanUpArrayEnd>(slot, oldLen, <length>)\n\t\t\t\tsstore(slot, <encodedLen>)\n\t\t\t\tlet dstPtr := <dataArea>(slot)\n\t\t\t\t<#word>\n\t\t\t\t\tsstore(add(dstPtr, <offset>), <wordValue>)\n\t\t\t\t</word>\n\t\t\t)\")\n\t\t\t(\"byteArrayLength\", extractByteArrayLengthFunction())\n\t\t\t(\"cleanUpArrayEnd\", cleanUpDynamicByteArrayEndSlotsFunction(*TypeProvider::bytesStorage()))\n\t\t\t(\"dataArea\", arrayDataAreaFunction(*TypeProvider::bytesStorage()))\n\t\t\t(\"word\", wordParams)\n\t\t\t(\"length\", to_string(_literal.size()))\n\t\t\t(\"encodedLen\", to_string(2 * _literal.size() + 1))\n\t\t\t.render();\n\t\t}\n\t\telse\n\t\t\treturn Whiskers(R\"(\n\t\t\t\tlet oldLen := <byteArrayLength>(sload(slot))\n\t\t\t\t<cleanUpArrayEnd>(slot, oldLen, <length>)\n\t\t\t\tsstore(slot, add(<wordValue>, <encodedLen>))\n\t\t\t)\")\n\t\t\t(\"byteArrayLength\", extractByteArrayLengthFunction())\n\t\t\t(\"cleanUpArrayEnd\", cleanUpDynamicByteArrayEndSlotsFunction(*TypeProvider::bytesStorage()))\n\t\t\t(\"wordValue\", formatAsStringOrNumber(_literal))\n\t\t\t(\"length\", to_string(_literal.size()))\n\t\t\t(\"encodedLen\", to_string(2 * _literal.size()))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::requireOrAssertFunction(bool _assert, Type const* _messageType)\n{\n\tstring functionName =\n\t\tstring(_assert ? \"assert_helper\" : \"require_helper\") +\n\t\t(_messageType ? (\"_\" + _messageType->identifier()) : \"\");\n\n\tsolAssert(!_assert || !_messageType, \"Asserts can't have messages!\");\n\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\tif (!_messageType)\n\t\t\treturn Whiskers(R\"(\n\t\t\t\tfunction <functionName>(condition) {\n\t\t\t\t\tif iszero(condition) { <error> }\n\t\t\t\t}\n\t\t\t)\")\n\t\t\t(\"error\", _assert ? panicFunction(PanicCode::Assert) + \"()\" : \"revert(0, 0)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t.render();\n\n\t\tint const hashHeaderSize = 4;\n\t\tu256 const errorHash = util::selectorFromSignature(\"Error(string)\");\n\n\t\tstring const encodeFunc = ABIFunctions(m_evmVersion, m_revertStrings, m_functionCollector)\n\t\t\t.tupleEncoder(\n\t\t\t\t{_messageType},\n\t\t\t\t{TypeProvider::stringMemory()}\n\t\t\t);\n\n\t\treturn Whiskers(R\"(\n\t\t\tfunction <functionName>(condition <messageVars>) {\n\t\t\t\tif iszero(condition) {\n\t\t\t\t\tlet memPtr := <allocateUnbounded>()\n\t\t\t\t\tmstore(memPtr, <errorHash>)\n\t\t\t\t\tlet end := <abiEncodeFunc>(add(memPtr, <hashHeaderSize>) <messageVars>)\n\t\t\t\t\trevert(memPtr, sub(end, memPtr))\n\t\t\t\t}\n\t\t\t}\n\t\t)\")\n\t\t(\"functionName\", functionName)\n\t\t(\"allocateUnbounded\", allocateUnboundedFunction())\n\t\t(\"errorHash\", formatNumber(errorHash))\n\t\t(\"abiEncodeFunc\", encodeFunc)\n\t\t(\"hashHeaderSize\", to_string(hashHeaderSize))\n\t\t(\"messageVars\",\n\t\t\t(_messageType->sizeOnStack() > 0 ? \", \" : \"\") +\n\t\t\tsuffixedVariableNameList(\"message_\", 1, 1 + _messageType->sizeOnStack())\n\t\t)\n\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::leftAlignFunction(Type const& _type)\n{\n\tstring functionName = string(\"leftAlign_\") + _type.identifier();\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\tWhiskers templ(R\"(\n\t\t\tfunction <functionName>(value) -> aligned {\n\t\t\t\t<body>\n\t\t\t}\n\t\t)\");\n\t\ttempl(\"functionName\", functionName);\n\t\tswitch (_type.category())\n\t\t{\n\t\tcase Type::Category::Address:\n\t\t\ttempl(\"body\", \"aligned := \" + leftAlignFunction(IntegerType(160)) + \"(value)\");\n\t\t\tbreak;\n\t\tcase Type::Category::Integer:\n\t\t{\n\t\t\tIntegerType const& type = dynamic_cast<IntegerType const&>(_type);\n\t\t\tif (type.numBits() == 256)\n\t\t\t\ttempl(\"body\", \"aligned := value\");\n\t\t\telse\n\t\t\t\ttempl(\"body\", \"aligned := \" + shiftLeftFunction(256 - type.numBits()) + \"(value)\");\n\t\t\tbreak;\n\t\t}\n\t\tcase Type::Category::RationalNumber:\n\t\t\tsolAssert(false, \"Left align requested for rational number.\");\n\t\t\tbreak;\n\t\tcase Type::Category::Bool:\n\t\t\ttempl(\"body\", \"aligned := \" + leftAlignFunction(IntegerType(8)) + \"(value)\");\n\t\t\tbreak;\n\t\tcase Type::Category::FixedPoint:\n\t\t\tsolUnimplemented(\"Fixed point types not implemented.\");\n\t\t\tbreak;\n\t\tcase Type::Category::Array:\n\t\tcase Type::Category::Struct:\n\t\t\tsolAssert(false, \"Left align requested for non-value type.\");\n\t\t\tbreak;\n\t\tcase Type::Category::FixedBytes:\n\t\t\ttempl(\"body\", \"aligned := value\");\n\t\t\tbreak;\n\t\tcase Type::Category::Contract:\n\t\t\ttempl(\"body\", \"aligned := \" + leftAlignFunction(*TypeProvider::address()) + \"(value)\");\n\t\t\tbreak;\n\t\tcase Type::Category::Enum:\n\t\t{\n\t\t\tsolAssert(dynamic_cast<EnumType const&>(_type).storageBytes() == 1, \"\");\n\t\t\ttempl(\"body\", \"aligned := \" + leftAlignFunction(IntegerType(8)) + \"(value)\");\n\t\t\tbreak;\n\t\t}\n\t\tcase Type::Category::InaccessibleDynamic:\n\t\t\tsolAssert(false, \"Left align requested for inaccessible dynamic type.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsolAssert(false, \"Left align of type \" + _type.identifier() + \" requested.\");\n\t\t}\n\n\t\treturn templ.render();\n\t});\n}\n\nstring YulUtilFunctions::shiftLeftFunction(size_t _numBits)\n{\n\tsolAssert(_numBits < 256, \"\");\n\n\tstring functionName = \"shift_left_\" + to_string(_numBits);\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(value) -> newValue {\n\t\t\t\tnewValue :=\n\t\t\t\t<?hasShifts>\n\t\t\t\t\tshl(<numBits>, value)\n\t\t\t\t<!hasShifts>\n\t\t\t\t\tmul(value, <multiplier>)\n\t\t\t\t</hasShifts>\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"numBits\", to_string(_numBits))\n\t\t\t(\"hasShifts\", m_evmVersion.hasBitwiseShifting())\n\t\t\t(\"multiplier\", toCompactHexWithPrefix(u256(1) << _numBits))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::shiftLeftFunctionDynamic()\n{\n\tstring functionName = \"shift_left_dynamic\";\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(bits, value) -> newValue {\n\t\t\t\tnewValue :=\n\t\t\t\t<?hasShifts>\n\t\t\t\t\tshl(bits, value)\n\t\t\t\t<!hasShifts>\n\t\t\t\t\tmul(value, exp(2, bits))\n\t\t\t\t</hasShifts>\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"hasShifts\", m_evmVersion.hasBitwiseShifting())\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::shiftRightFunction(size_t _numBits)\n{\n\tsolAssert(_numBits < 256, \"\");\n\n\t// Note that if this is extended with signed shifts,\n\t// the opcodes SAR and SDIV behave differently with regards to rounding!\n\n\tstring functionName = \"shift_right_\" + to_string(_numBits) + \"_unsigned\";\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(value) -> newValue {\n\t\t\t\tnewValue :=\n\t\t\t\t<?hasShifts>\n\t\t\t\t\tshr(<numBits>, value)\n\t\t\t\t<!hasShifts>\n\t\t\t\t\tdiv(value, <multiplier>)\n\t\t\t\t</hasShifts>\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"hasShifts\", m_evmVersion.hasBitwiseShifting())\n\t\t\t(\"numBits\", to_string(_numBits))\n\t\t\t(\"multiplier\", toCompactHexWithPrefix(u256(1) << _numBits))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::shiftRightFunctionDynamic()\n{\n\tstring const functionName = \"shift_right_unsigned_dynamic\";\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(bits, value) -> newValue {\n\t\t\t\tnewValue :=\n\t\t\t\t<?hasShifts>\n\t\t\t\t\tshr(bits, value)\n\t\t\t\t<!hasShifts>\n\t\t\t\t\tdiv(value, exp(2, bits))\n\t\t\t\t</hasShifts>\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"hasShifts\", m_evmVersion.hasBitwiseShifting())\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::shiftRightSignedFunctionDynamic()\n{\n\tstring const functionName = \"shift_right_signed_dynamic\";\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(bits, value) -> result {\n\t\t\t\t<?hasShifts>\n\t\t\t\t\tresult := sar(bits, value)\n\t\t\t\t<!hasShifts>\n\t\t\t\t\tlet divisor := exp(2, bits)\n\t\t\t\t\tlet xor_mask := sub(0, slt(value, 0))\n\t\t\t\t\tresult := xor(div(xor(value, xor_mask), divisor), xor_mask)\n\t\t\t\t\t// combined version of\n\t\t\t\t\t//   switch slt(value, 0)\n\t\t\t\t\t//   case 0 { result := div(value, divisor) }\n\t\t\t\t\t//   default { result := not(div(not(value), divisor)) }\n\t\t\t\t</hasShifts>\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"hasShifts\", m_evmVersion.hasBitwiseShifting())\n\t\t\t.render();\n\t});\n}\n\n\nstring YulUtilFunctions::typedShiftLeftFunction(Type const& _type, Type const& _amountType)\n{\n\tsolUnimplementedAssert(_type.category() != Type::Category::FixedPoint, \"Not yet implemented - FixedPointType.\");\n\tsolAssert(_type.category() == Type::Category::FixedBytes || _type.category() == Type::Category::Integer, \"\");\n\tsolAssert(_amountType.category() == Type::Category::Integer, \"\");\n\tsolAssert(!dynamic_cast<IntegerType const&>(_amountType).isSigned(), \"\");\n\tstring const functionName = \"shift_left_\" + _type.identifier() + \"_\" + _amountType.identifier();\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(value, bits) -> result {\n\t\t\t\tbits := <cleanAmount>(bits)\n\t\t\t\tresult := <cleanup>(<shift>(bits, <cleanup>(value)))\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"cleanAmount\", cleanupFunction(_amountType))\n\t\t\t(\"shift\", shiftLeftFunctionDynamic())\n\t\t\t(\"cleanup\", cleanupFunction(_type))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::typedShiftRightFunction(Type const& _type, Type const& _amountType)\n{\n\tsolUnimplementedAssert(_type.category() != Type::Category::FixedPoint, \"Not yet implemented - FixedPointType.\");\n\tsolAssert(_type.category() == Type::Category::FixedBytes || _type.category() == Type::Category::Integer, \"\");\n\tsolAssert(_amountType.category() == Type::Category::Integer, \"\");\n\tsolAssert(!dynamic_cast<IntegerType const&>(_amountType).isSigned(), \"\");\n\tIntegerType const* integerType = dynamic_cast<IntegerType const*>(&_type);\n\tbool valueSigned = integerType && integerType->isSigned();\n\n\tstring const functionName = \"shift_right_\" + _type.identifier() + \"_\" + _amountType.identifier();\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(value, bits) -> result {\n\t\t\t\tbits := <cleanAmount>(bits)\n\t\t\t\tresult := <cleanup>(<shift>(bits, <cleanup>(value)))\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"cleanAmount\", cleanupFunction(_amountType))\n\t\t\t(\"shift\", valueSigned ? shiftRightSignedFunctionDynamic() : shiftRightFunctionDynamic())\n\t\t\t(\"cleanup\", cleanupFunction(_type))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::updateByteSliceFunction(size_t _numBytes, size_t _shiftBytes)\n{\n\tsolAssert(_numBytes <= 32, \"\");\n\tsolAssert(_shiftBytes <= 32, \"\");\n\tsize_t numBits = _numBytes * 8;\n\tsize_t shiftBits = _shiftBytes * 8;\n\tstring functionName = \"update_byte_slice_\" + to_string(_numBytes) + \"_shift_\" + to_string(_shiftBytes);\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(value, toInsert) -> result {\n\t\t\t\tlet mask := <mask>\n\t\t\t\ttoInsert := <shl>(toInsert)\n\t\t\t\tvalue := and(value, not(mask))\n\t\t\t\tresult := or(value, and(toInsert, mask))\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"mask\", formatNumber(((bigint(1) << numBits) - 1) << shiftBits))\n\t\t\t(\"shl\", shiftLeftFunction(shiftBits))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::updateByteSliceFunctionDynamic(size_t _numBytes)\n{\n\tsolAssert(_numBytes <= 32, \"\");\n\tsize_t numBits = _numBytes * 8;\n\tstring functionName = \"update_byte_slice_dynamic\" + to_string(_numBytes);\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(value, shiftBytes, toInsert) -> result {\n\t\t\t\tlet shiftBits := mul(shiftBytes, 8)\n\t\t\t\tlet mask := <shl>(shiftBits, <mask>)\n\t\t\t\ttoInsert := <shl>(shiftBits, toInsert)\n\t\t\t\tvalue := and(value, not(mask))\n\t\t\t\tresult := or(value, and(toInsert, mask))\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"mask\", formatNumber((bigint(1) << numBits) - 1))\n\t\t\t(\"shl\", shiftLeftFunctionDynamic())\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::maskBytesFunctionDynamic()\n{\n\tstring functionName = \"mask_bytes_dynamic\";\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn Whiskers(R\"(\n\t\t\tfunction <functionName>(data, bytes) -> result {\n\t\t\t\tlet mask := not(<shr>(mul(8, bytes), not(0)))\n\t\t\t\tresult := and(data, mask)\n\t\t\t})\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"shr\", shiftRightFunctionDynamic())\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::maskLowerOrderBytesFunction(size_t _bytes)\n{\n\tstring functionName = \"mask_lower_order_bytes_\" + to_string(_bytes);\n\tsolAssert(_bytes <= 32, \"\");\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn Whiskers(R\"(\n\t\t\tfunction <functionName>(data) -> result {\n\t\t\t\tresult := and(data, <mask>)\n\t\t\t})\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"mask\", formatNumber((~u256(0)) >> (256 - 8 * _bytes)))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::maskLowerOrderBytesFunctionDynamic()\n{\n\tstring functionName = \"mask_lower_order_bytes_dynamic\";\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn Whiskers(R\"(\n\t\t\tfunction <functionName>(data, bytes) -> result {\n\t\t\t\tlet mask := not(<shl>(mul(8, bytes), not(0)))\n\t\t\t\tresult := and(data, mask)\n\t\t\t})\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"shl\", shiftLeftFunctionDynamic())\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::roundUpFunction()\n{\n\tstring functionName = \"round_up_to_mul_of_32\";\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(value) -> result {\n\t\t\t\tresult := and(add(value, 31), not(31))\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::divide32CeilFunction()\n{\n\treturn m_functionCollector.createFunction(\n\t\t\"divide_by_32_ceil\",\n\t\t[&](vector<string>& _args, vector<string>& _ret) {\n\t\t\t_args = {\"value\"};\n\t\t\t_ret = {\"result\"};\n\t\t\treturn \"result := div(add(value, 31), 32)\";\n\t\t}\n\t);\n}\n\nstring YulUtilFunctions::overflowCheckedIntAddFunction(IntegerType const& _type)\n{\n\tstring functionName = \"checked_add_\" + _type.identifier();\n\t// TODO: Consider to add a special case for unsigned 256-bit integers\n\t//       and use the following instead:\n\t//       sum := add(x, y) if lt(sum, x) { <panic>() }\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(x, y) -> sum {\n\t\t\t\tx := <cleanupFunction>(x)\n\t\t\t\ty := <cleanupFunction>(y)\n\t\t\t\t<?signed>\n\t\t\t\t\t// overflow, if x >= 0 and y > (maxValue - x)\n\t\t\t\t\tif and(iszero(slt(x, 0)), sgt(y, sub(<maxValue>, x))) { <panic>() }\n\t\t\t\t\t// underflow, if x < 0 and y < (minValue - x)\n\t\t\t\t\tif and(slt(x, 0), slt(y, sub(<minValue>, x))) { <panic>() }\n\t\t\t\t<!signed>\n\t\t\t\t\t// overflow, if x > (maxValue - y)\n\t\t\t\t\tif gt(x, sub(<maxValue>, y)) { <panic>() }\n\t\t\t\t</signed>\n\t\t\t\tsum := add(x, y)\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"signed\", _type.isSigned())\n\t\t\t(\"maxValue\", toCompactHexWithPrefix(u256(_type.maxValue())))\n\t\t\t(\"minValue\", toCompactHexWithPrefix(u256(_type.minValue())))\n\t\t\t(\"cleanupFunction\", cleanupFunction(_type))\n\t\t\t(\"panic\", panicFunction(PanicCode::UnderOverflow))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::wrappingIntAddFunction(IntegerType const& _type)\n{\n\tstring functionName = \"wrapping_add_\" + _type.identifier();\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(x, y) -> sum {\n\t\t\t\tsum := <cleanupFunction>(add(x, y))\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"cleanupFunction\", cleanupFunction(_type))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::overflowCheckedIntMulFunction(IntegerType const& _type)\n{\n\tstring functionName = \"checked_mul_\" + _type.identifier();\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\t// Multiplication by zero could be treated separately and directly return zero.\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(x, y) -> product {\n\t\t\t\tx := <cleanupFunction>(x)\n\t\t\t\ty := <cleanupFunction>(y)\n\t\t\t\t<?signed>\n\t\t\t\t\t// overflow, if x > 0, y > 0 and x > (maxValue / y)\n\t\t\t\t\tif and(and(sgt(x, 0), sgt(y, 0)), gt(x, div(<maxValue>, y))) { <panic>() }\n\t\t\t\t\t// underflow, if x > 0, y < 0 and y < (minValue / x)\n\t\t\t\t\tif and(and(sgt(x, 0), slt(y, 0)), slt(y, sdiv(<minValue>, x))) { <panic>() }\n\t\t\t\t\t// underflow, if x < 0, y > 0 and x < (minValue / y)\n\t\t\t\t\tif and(and(slt(x, 0), sgt(y, 0)), slt(x, sdiv(<minValue>, y))) { <panic>() }\n\t\t\t\t\t// overflow, if x < 0, y < 0 and x < (maxValue / y)\n\t\t\t\t\tif and(and(slt(x, 0), slt(y, 0)), slt(x, sdiv(<maxValue>, y))) { <panic>() }\n\t\t\t\t<!signed>\n\t\t\t\t\t// overflow, if x != 0 and y > (maxValue / x)\n\t\t\t\t\tif and(iszero(iszero(x)), gt(y, div(<maxValue>, x))) { <panic>() }\n\t\t\t\t</signed>\n\t\t\t\tproduct := mul(x, y)\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"signed\", _type.isSigned())\n\t\t\t(\"maxValue\", toCompactHexWithPrefix(u256(_type.maxValue())))\n\t\t\t(\"minValue\", toCompactHexWithPrefix(u256(_type.minValue())))\n\t\t\t(\"cleanupFunction\", cleanupFunction(_type))\n\t\t\t(\"panic\", panicFunction(PanicCode::UnderOverflow))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::wrappingIntMulFunction(IntegerType const& _type)\n{\n\tstring functionName = \"wrapping_mul_\" + _type.identifier();\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(x, y) -> product {\n\t\t\t\tproduct := <cleanupFunction>(mul(x, y))\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"cleanupFunction\", cleanupFunction(_type))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::overflowCheckedIntDivFunction(IntegerType const& _type)\n{\n\tstring functionName = \"checked_div_\" + _type.identifier();\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(x, y) -> r {\n\t\t\t\tx := <cleanupFunction>(x)\n\t\t\t\ty := <cleanupFunction>(y)\n\t\t\t\tif iszero(y) { <panicDivZero>() }\n\t\t\t\t<?signed>\n\t\t\t\t// overflow for minVal / -1\n\t\t\t\tif and(\n\t\t\t\t\teq(x, <minVal>),\n\t\t\t\t\teq(y, sub(0, 1))\n\t\t\t\t) { <panicOverflow>() }\n\t\t\t\t</signed>\n\t\t\t\tr := <?signed>s</signed>div(x, y)\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"signed\", _type.isSigned())\n\t\t\t(\"minVal\", toCompactHexWithPrefix(u256(_type.minValue())))\n\t\t\t(\"cleanupFunction\", cleanupFunction(_type))\n\t\t\t(\"panicDivZero\", panicFunction(PanicCode::DivisionByZero))\n\t\t\t(\"panicOverflow\", panicFunction(PanicCode::UnderOverflow))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::wrappingIntDivFunction(IntegerType const& _type)\n{\n\tstring functionName = \"wrapping_div_\" + _type.identifier();\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(x, y) -> r {\n\t\t\t\tx := <cleanupFunction>(x)\n\t\t\t\ty := <cleanupFunction>(y)\n\t\t\t\tif iszero(y) { <error>() }\n\t\t\t\tr := <?signed>s</signed>div(x, y)\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"cleanupFunction\", cleanupFunction(_type))\n\t\t\t(\"signed\", _type.isSigned())\n\t\t\t(\"error\", panicFunction(PanicCode::DivisionByZero))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::intModFunction(IntegerType const& _type)\n{\n\tstring functionName = \"mod_\" + _type.identifier();\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(x, y) -> r {\n\t\t\t\tx := <cleanupFunction>(x)\n\t\t\t\ty := <cleanupFunction>(y)\n\t\t\t\tif iszero(y) { <panic>() }\n\t\t\t\tr := <?signed>s</signed>mod(x, y)\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"signed\", _type.isSigned())\n\t\t\t(\"cleanupFunction\", cleanupFunction(_type))\n\t\t\t(\"panic\", panicFunction(PanicCode::DivisionByZero))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::overflowCheckedIntSubFunction(IntegerType const& _type)\n{\n\tstring functionName = \"checked_sub_\" + _type.identifier();\n\treturn m_functionCollector.createFunction(functionName, [&] {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(x, y) -> diff {\n\t\t\t\tx := <cleanupFunction>(x)\n\t\t\t\ty := <cleanupFunction>(y)\n\t\t\t\t<?signed>\n\t\t\t\t\t// underflow, if y >= 0 and x < (minValue + y)\n\t\t\t\t\tif and(iszero(slt(y, 0)), slt(x, add(<minValue>, y))) { <panic>() }\n\t\t\t\t\t// overflow, if y < 0 and x > (maxValue + y)\n\t\t\t\t\tif and(slt(y, 0), sgt(x, add(<maxValue>, y))) { <panic>() }\n\t\t\t\t<!signed>\n\t\t\t\t\tif lt(x, y) { <panic>() }\n\t\t\t\t</signed>\n\t\t\t\tdiff := sub(x, y)\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"signed\", _type.isSigned())\n\t\t\t(\"maxValue\", toCompactHexWithPrefix(u256(_type.maxValue())))\n\t\t\t(\"minValue\", toCompactHexWithPrefix(u256(_type.minValue())))\n\t\t\t(\"cleanupFunction\", cleanupFunction(_type))\n\t\t\t(\"panic\", panicFunction(PanicCode::UnderOverflow))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::wrappingIntSubFunction(IntegerType const& _type)\n{\n\tstring functionName = \"wrapping_sub_\" + _type.identifier();\n\treturn m_functionCollector.createFunction(functionName, [&] {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(x, y) -> diff {\n\t\t\t\tdiff := <cleanupFunction>(sub(x, y))\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"cleanupFunction\", cleanupFunction(_type))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::overflowCheckedIntExpFunction(\n\tIntegerType const& _type,\n\tIntegerType const& _exponentType\n)\n{\n\tsolAssert(!_exponentType.isSigned(), \"\");\n\n\tstring functionName = \"checked_exp_\" + _type.identifier() + \"_\" + _exponentType.identifier();\n\treturn m_functionCollector.createFunction(functionName, [&]() {\n\t\treturn\n\t\t\tWhiskers(R\"(\n\t\t\tfunction <functionName>(base, exponent) -> power {\n\t\t\t\tbase := <baseCleanupFunction>(base)\n\t\t\t\texponent := <exponentCleanupFunction>(exponent)\n\t\t\t\t<?signed>\n\t\t\t\t\tpower := <exp>(base, exponent, <minValue>, <maxValue>)\n\t\t\t\t<!signed>\n\t\t\t\t\tpower := <exp>(base, exponent, <maxValue>)\n\t\t\t\t</signed>\n\n\t\t\t}\n\t\t\t)\")\n\t\t\t(\"functionName\", functionName)\n\t\t\t(\"signed\", _type.isSigned())\n\t\t\t(\"exp\", _type.isSigned() ? overflowCheckedSignedExpFunction() : overflowCheckedUnsignedExpFunction())\n\t\t\t(\"maxValue\", toCompactHexWithPrefix(_type.max()))\n\t\t\t(\"minValue\", toCompactHexWithPrefix(_type.min()))\n\t\t\t(\"baseCleanupFunction\", cleanupFunction(_type))\n\t\t\t(\"exponentCleanupFunction\", cleanupFunction(_exponentType))\n\t\t\t.render();\n\t});\n}\n\nstring YulUtilFunctions::overflowCheckedIntLiteralExpFunction(\n\tRationalNumberType const& _baseType,\n\tIntegerType const& _exponentType,\n\tIntegerType const& _commonType\n)\n{\n\tsolAssert(!_exponentType.isSigned(), \"\");\n\tsolAssert(_baseType.isNegative() == _commonType.isSigned(), \"\");\n\tsolAssert(_commonType.numBits() == 256, \"\");\n\n\tstring functionName = \"checked_exp_\" + _baseType.richIdentifier() + \"_\" + _exponentType.identifier();\n\n\treturn m_functionCollector.createFunction(functionName, [&]()\n\t{\n\t\t// Converts a bigint number into u256 (negative numbers represented in two's complement form.)\n\t\t// We assume that `_v` fits in 256 bits.\n\t\tauto bigint2u = [&](bigint const& _v) -> u256\n\t\t{\n\t\t\tif (_v < 0)\n\t\t\t\treturn s2u(s256(_v));\n\t\t\treturn u256(_v);\n\t\t};\n\n\t\t// Calculates the upperbound for exponentiation, that is, calculate `b`, such that\n\t\t// _base**b <= _maxValue and _base**(b + 1) > _maxValue\n\t\tauto findExponentUpperbound = [](bigint const _base, bigint const _maxValue) -> unsigned\n\t\t{\n\t\t\t// There is no overflow for these cases\n\t\t\tif (_base == 0 || _base == -1 || _ba"
    }
  ]
}