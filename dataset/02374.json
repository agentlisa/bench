{
  "Title": "M-9: claimFees may cause some external rewards to be locked in the contract",
  "Content": "# Issue M-9: claimFees may cause some external rewards to be locked in the contract \n\nSource: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/100 \n\n## Found by \ncccz\n\n## Summary\nclaimFees will update rewardToken.lastBalance so that if there are unaccrued reward tokens in the contract, users will not be able to claim them.\n## Vulnerability Detail\n_accumulateExternalRewards takes the difference between the contract's reward token balance and lastBalance as the reward.\nand the accumulated reward tokens are updated by _updateExternalRewardState.\n```solidity\n    function _accumulateExternalRewards() internal override returns (uint256[] memory) {\n        uint256 numExternalRewards = externalRewardTokens.length;\n\n        auraPool.rewardsPool.getReward(address(this), true);\n\n        uint256[] memory rewards = new uint256[](numExternalRewards);\n        for (uint256 i; i < numExternalRewards; ) {\n            ExternalRewardToken storage rewardToken = externalRewardTokens[i];\n            uint256 newBalance = ERC20(rewardToken.token).balanceOf(address(this));\n\n            // This shouldn't happen but adding a sanity check in case\n            if (newBalance < rewardToken.lastBalance) {\n                emit LiquidityVault_ExternalAccumulationError(rewardToken.token);\n                continue;\n            }\n\n            rewards[i] = newBalance - rewardToken.lastBalance;\n            rewardToken.lastBalance = newBalance;\n\n            unchecked {\n                ++i;\n            }\n        }\n        return rewards;\n    }\n...\n    function _updateExternalRewardState(uint256 id_, uint256 amountAccumulated_) internal {\n        // This correctly uses 1e18 because the LP tokens of all major DEXs have 18 decimals\n        if (totalLP != 0)\n            externalRewardTokens[id_].accumulatedRewardsPerShare +=\n                (amountAccumulated_ * 1e18) /\n                totalLP;\n    }\n\n```\nauraPool.rewardsPool.getReward can be called by anyone to send the reward tokens to the contract\n```solidity\n    function getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if(_claimExtras){\n            for(uint i=0; i < extraRewards.length; i++){\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n```\nHowever, in claimFees, the rewardToken.lastBalance will be updated to the current contract balance after the admin has claimed the fees.\n```solidity\n    function claimFees() external onlyRole(\"liquidityvault_admin\") {\n        uint256 numInternalRewardTokens = internalRewardTokens.length;\n        uint256 numExternalRewardTokens = externalRewardTokens.length;\n\n        for (uint256 i; i < numInternalRewardTokens; ) {\n            address rewardToken = internalRewardTokens[i].token;\n            uint256 feeToSend = accumulatedFees[rewardToken];\n\n            accumulatedFees[rewardToken] = 0;\n\n            ERC20(rewardToken).safeTransfer(msg.sender, feeToSend);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        for (uint256 i; i < numExternalRewardTokens; ) {\n            ExternalRewardToken storage rewardToken = externalRewardTokens[i];\n            uint256 feeToSend = accumulatedFees[rewardToken.token];\n\n            accumulatedFees[rewardToken.token] = 0;\n\n            ERC20(rewardToken.token).safeTransfer(msg.sender, feeToSend);\n            rewardToken.lastBalance = ERC20(rewardToken.token).balanceOf(address(this));\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n```\nConsider the following scenario.\n1. Start with rewardToken.lastBalance = 200.\n2. After some time, the rewardToken in aura is increased by 100.\n3. Someone calls getReward to claim the reward tokens to the contract, and the 100 reward tokens increased have not yet been accumulated via _accumulateExternalRewards and _updateExternalRewardState.\n4. The admin calls claimFees to update rewardToken.lastBalance to 290(10 as fees).\n5. Users call claimRewards and receives 0 reward tokens. 90 reward tokens will be locked in the contract\n## Impact\nIt will cause some external rewards to be locked in the contract\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/WstethLiquidityVault.sol#L192-L216\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L496-L503\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L736-L766\n## Tool used\n\nManual Review\n\n## Recommendation\nUse _accumulateExternalRewards and _updateExternalRewardState in claimFees to accrue rewards.\n```diff\n    function claimFees() external onlyRole(\"liquidityvault_admin\") {\n        uint256 numInternalRewardTokens = internalRewardTokens.length;\n        uint256 numExternalRewardTokens = externalRewardTokens.length;\n\n        for (uint256 i; i < numInternalRewardTokens; ) {\n            address rewardToken = internalRewardTokens[i].token;\n            uint256 feeToSend = accumulatedFees[rewardToken];\n\n            accumulatedFees[rewardToken] = 0;\n\n            ERC20(rewardToken).safeTransfer(msg.sender, feeToSend);\n\n            unchecked {\n                ++i;\n            }\n        }\n+       uint256[] memory accumulatedExternalRewards = _accumulateExternalRewards();\n        for (uint256 i; i < numExternalRewardTokens; ) {\n+           _updateExternalRewardState(i, accumulatedExternalRewards[i]);\n            ExternalRewardToken storage rewardToken = externalRewardTokens[i];\n            uint256 feeToSend = accumulatedFees[rewardToken.token];\n\n            accumulatedFees[rewardToken.token] = 0;\n\n            ERC20(rewardToken.token).safeTransfer(msg.sender, feeToSend);\n            rewardToken.lastBalance = ERC20(rewardToken.token).balanceOf(address(this));\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n```\n\n## Discussion\n\n**IAm0x52**\n\nEscalate for 25 USDC.\n\nThis should be medium for two reasons:\n\n1) Funds aren't actually lost because they can be rescued\n2) This is an admin only function so unless admin was malicious and called this repeatedly the amount of locked tokens would be small\n\n**sherlock-admin**\n\n > Escalate for 25 USDC.\n> \n> This should be medium for two reasons:\n> \n> 1) Funds aren't actually lost because they can be rescued\n> 2) This is an admin only function so unless admin was malicious and called this repeatedly the amount of locked tokens would be small\n\nYou've created a valid escalation for 25 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**thereksfour**\n\nEscalate for 25 USDC.\nDisagree with @IAm0x52 's comments\n\n> 1.Funds aren't actually lost because they can be rescued\n\nFor users, they have lost the rewards they deserve, and even though they can get a refund afterwards, the reputation of the protocol has been compromised.\n\n> 2.This is an admin only function so unless admin was malicious and called this repeatedly the amount of locked tokens would be small.\n\nUsing minimum impact to downgrade the issue here doesn't hold water.  I could say that a large number of rewards are left in aura due to a long period of no user activity, and when a malicious user observes the owner calling claimFees, he can preempt the call to getReward to make a large number of rewards locked in the contract\n\n**sherlock-admin**\n\n > Escalate for 25 USDC.\n> Disagree with @IAm0x52 's comments\n> \n> > 1.Funds aren't actually lost because they can be rescued\n> \n> For users, they have lost the rewards they deserve, and even though they can get a refund afterwards, the reputation of the protocol has been compromised.\n> \n> > 2.This is an admin only function so unless admin was malicious and called this repeatedly the amount of locked tokens would be small.\n> \n> Using minimum impact to downgrade the issue here doesn't hold water.  I could say that a large number of rewards are left in aura due to a long period of no user activity, and when a malicious user observes the owner calling claimFees, he can preempt the call to getReward to make a large number of rewards locked in the contract\n\nYou've created a valid escalation for 25 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nThis is a valid medium\nThere are multiple reasons why this issue should be medium, \nWhile there is still a dos attack possible, funds are not lost. And can be recovered by admin.\nAlso, the claimFees is an admin function. \nThis does not break the core functionality but a DOS of rewards. Hence medium is fair\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> This is a valid medium\n> There are multiple reasons why this issue should be medium, \n> While there is still a dos attack possible, funds are not lost. And can be recovered by admin.\n> Also, the claimFees is an admin function. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/50",
  "Code": [
    {
      "filename": "src/policies/lending/WstethLiquidityVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system dependencies\nimport \"src/Kernel.sol\";\nimport {SingleSidedLiquidityVault} from \"policies/lending/abstracts/SingleSidedLiquidityVault.sol\";\n\n// Import external dependencies\nimport {AggregatorV3Interface} from \"src/interfaces/AggregatorV2V3Interface.sol\";\nimport {JoinPoolRequest, ExitPoolRequest, IVault, IBasePool, IBalancerHelper} from \"policies/lending/interfaces/IBalancer.sol\";\nimport {IAuraBooster, IAuraRewardPool} from \"policies/lending/interfaces/IAura.sol\";\nimport {IWsteth} from \"policies/lending/interfaces/ILido.sol\";\n\n// Import types\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// @title Olympus wstETH Single-Sided Liquidity Vault\ncontract WstethLiquidityVault is SingleSidedLiquidityVault {\n    // ========= EVENTS ========= //\n\n    event LiquidityVault_ExternalAccumulationError(address token);\n\n    // ========= DATA STRUCTURES ========= //\n\n    struct OracleFeed {\n        AggregatorV3Interface feed;\n        uint48 updateThreshold;\n    }\n\n    struct AuraPool {\n        uint256 pid;\n        IAuraBooster booster;\n        IAuraRewardPool rewardsPool;\n    }\n\n    // ========= STATE ========= //\n\n    // Balancer Contracts\n    IVault public vault;\n    IBalancerHelper public balancerHelper;\n\n    // Aura Pool Info\n    AuraPool public auraPool;\n\n    // Price Feeds\n    OracleFeed public ohmEthPriceFeed;\n    OracleFeed public ethUsdPriceFeed;\n    OracleFeed public stethUsdPriceFeed;\n\n    // Price Feed Decimals\n    uint32 public immutable ohmEthPriceFeedDecimals;\n    uint32 public immutable ethUsdPriceFeedDecimals;\n    uint32 public immutable stethUsdPriceFeedDecimals;\n\n    //============================================================================================//\n    //                                      POLICY SETUP                                          //\n    //============================================================================================//\n\n    constructor(\n        Kernel kernel_,\n        address ohm_,\n        address wsteth_,\n        address vault_,\n        address balancerHelper_,\n        address liquidityPool_,\n        OracleFeed memory ohmEthPriceFeed_,\n        OracleFeed memory ethUsdPriceFeed_,\n        OracleFeed memory stethUsdPriceFeed_,\n        AuraPool memory auraPool_\n    ) SingleSidedLiquidityVault(kernel_, ohm_, wsteth_, liquidityPool_) {\n        // Set Balancer vault\n        vault = IVault(vault_);\n        balancerHelper = IBalancerHelper(balancerHelper_);\n\n        // Set price feeds\n        ohmEthPriceFeed = ohmEthPriceFeed_;\n        ethUsdPriceFeed = ethUsdPriceFeed_;\n        stethUsdPriceFeed = stethUsdPriceFeed_;\n\n        // Set price feed decimals\n        ohmEthPriceFeedDecimals = ohmEthPriceFeed_.feed.decimals();\n        ethUsdPriceFeedDecimals = ethUsdPriceFeed_.feed.decimals();\n        stethUsdPriceFeedDecimals = stethUsdPriceFeed_.feed.decimals();\n\n        // Set Aura pool info\n        auraPool = auraPool_;\n\n        // Set exchange name\n        EXCHANGE = \"Balancer\";\n    }\n\n    //============================================================================================//\n    //                                   BASE OVERRIDE FUNCTIONS                                  //\n    //============================================================================================//\n\n    // ========= CORE FUNCTIONS ========= //\n\n    /// @notice                 Deposits OHM and wstETH into the Balancer pool. Deposits the received BPT into Aura to accrue rewards\n    /// @param ohmAmount_       Amount of OHM to deposit\n    /// @param pairAmount_      Amount of wstETH to deposit\n    /// @param slippageParam_   Minimum amount of BPT to receive (prior to staking into Aura)\n    /// @return uint256         Amount of BPT received\n    function _deposit(\n        uint256 ohmAmount_,\n        uint256 pairAmount_,\n        uint256 slippageParam_\n    ) internal override returns (uint256) {\n        // Cast pool address from abstract to Balancer Base Pool\n        IBasePool pool = IBasePool(liquidityPool);\n\n        // OHM-wstETH BPT before\n        uint256 bptBefore = pool.balanceOf(address(this));\n\n        // Build join pool request\n        address[] memory assets = new address[](2);\n        assets[0] = address(ohm);\n        assets[1] = address(pairToken);\n\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = ohmAmount_;\n        maxAmountsIn[1] = pairAmount_;\n\n        JoinPoolRequest memory joinPoolRequest = JoinPoolRequest({\n            assets: assets,\n            maxAmountsIn: maxAmountsIn,\n            userData: abi.encode(1, maxAmountsIn, slippageParam_),\n            fromInternalBalance: false\n        });\n\n        // Join Balancer pool\n        ohm.approve(address(vault), ohmAmount_);\n        pairToken.approve(address(vault), pairAmount_);\n        vault.joinPool(pool.getPoolId(), address(this), address(this), joinPoolRequest);\n\n        // OHM-PAIR BPT after\n        uint256 lpAmountOut = pool.balanceOf(address(this)) - bptBefore;\n\n        // Stake into Aura\n        pool.approve(address(auraPool.booster), lpAmountOut);\n        auraPool.booster.deposit(auraPool.pid, lpAmountOut, true);\n\n        return lpAmountOut;\n    }\n\n    /// @notice                 Withdraws BPT from Aura. Exchanges BPT for OHM and wstETH to leave the Balancer pool\n    /// @param lpAmount_        Amount of BPT to withdraw\n    /// @param minTokenAmounts_ Minimum amounts of OHM and wstETH to receive ([OHM, wstETH])\n    /// @return uint256         Amount of OHM received\n    /// @return uint256         Amount of wstETH received\n    function _withdraw(uint256 lpAmount_, uint256[] calldata minTokenAmounts_)\n        internal\n        override\n        returns (uint256, uint256)\n    {\n        // Cast pool adress from abstract to Balancer Base Pool\n        IBasePool pool = IBasePool(liquidityPool);\n\n        // OHM and pair token amounts before\n        uint256 ohmBefore = ohm.balanceOf(address(this));\n        uint256 pairTokenBefore = pairToken.balanceOf(address(this));\n\n        // Build exit pool request\n        address[] memory assets = new address[](2);\n        assets[0] = address(ohm);\n        assets[1] = address(pairToken);\n\n        ExitPoolRequest memory exitPoolRequest = ExitPoolRequest({\n            assets: assets,\n            minAmountsOut: minTokenAmounts_,\n            userData: abi.encode(1, lpAmount_),\n            toInternalBalance: false\n        });\n\n        // Unstake from Aura\n        auraPool.rewardsPool.withdrawAndUnwrap(lpAmount_, false);\n\n        // Exit Balancer pool\n        pool.approve(address(vault), lpAmount_);\n        vault.exitPool(pool.getPoolId(), address(this), payable(address(this)), exitPoolRequest);\n\n        // OHM and pair token amounts received\n        uint256 ohmReceived = ohm.balanceOf(address(this)) - ohmBefore;\n        uint256 pairTokenReceived = pairToken.balanceOf(address(this)) - pairTokenBefore;\n\n        return (ohmReceived, pairTokenReceived);\n    }\n\n    // ========= REWARDS FUNCTIONS ========= //\n\n    /// @notice                 Harvests rewards from Aura\n    /// @return uint256[]       Amounts of each reward token harvested\n    function _accumulateExternalRewards() internal override returns (uint256[] memory) {\n        uint256 numExternalRewards = externalRewardTokens.length;\n\n        auraPool.rewardsPool.getReward(address(this), true);\n\n        uint256[] memory rewards = new uint256[](numExternalRewards);\n        for (uint256 i; i < numExternalRewards; ) {\n            ExternalRewardToken storage rewardToken = externalRewardTokens[i];\n            uint256 newBalance = ERC20(rewardToken.token).balanceOf(address(this));\n\n            // This shouldn't happen but adding a sanity check in case\n            if (newBalance < rewardToken.lastBalance) {\n                emit LiquidityVault_ExternalAccumulationError(rewardToken.token);\n                continue;\n            }\n\n            rewards[i] = newBalance - rewardToken.lastBalance;\n            rewardToken.lastBalance = newBalance;\n\n            unchecked {\n                ++i;\n            }\n        }\n        return rewards;\n    }\n\n    // ========= UTILITY FUNCTIONS ========= //\n\n    /// @notice                 Calculates the OHM equivalent quantity for the wstETH deposit\n    /// @param amount_          Amount of wstETH to calculate OHM equivalent for\n    /// @return uint256         OHM equivalent quantity\n    function _valueCollateral(uint256 amount_) public view override returns (uint256) {\n        uint256 stethPerWsteth = IWsteth(address(pairToken)).stEthPerToken();\n\n        // This is returned in 18 decimals and represents ETH per OHM\n        uint256 ohmEth = _validatePrice(\n            address(ohmEthPriceFeed.feed),\n            uint256(ohmEthPriceFeed.updateThreshold)\n        );\n\n        // This is returned in 8 decimals and represents USD per ETH\n        uint256 ethUsd = _validatePrice(\n            address(ethUsdPriceFeed.feed),\n            uint256(ethUsdPriceFeed.updateThreshold)\n        );\n\n        // This is returned in 8 decimals and represents USD per stETH\n        uint256 stethUsd = _validatePrice(\n            address(stethUsdPriceFeed.feed),\n            uint256(stethUsdPriceFeed.updateThreshold)\n        );\n\n        // Amount is 18 decimals in the case of wstETH and OHM has 9 decimals so to get a result with 9\n        // decimals we need to use this decimal adjustment\n        uint8 ohmDecimals = 9;\n        uint256 decimalAdjustment = 10 **\n            (ohmEthPriceFeedDecimals +\n                ethUsdPriceFeedDecimals +\n                ohmDecimals -\n                stethUsdPriceFeedDecimals -\n                pairTokenDecimals);\n\n        return (amount_ * stethPerWsteth * stethUsd * decimalAdjustment) / (ohmEth * ethUsd * 1e18);\n    }\n\n    /// @notice                 Calculates the prevailing OHM/wstETH ratio of the Balancer pool\n    /// @return uint256         OHM/wstETH ratio\n    function _getPoolPrice() internal view override returns (uint256) {\n        (, uint256[] memory balances_, ) = vault.getPoolTokens(\n            IBasePool(liquidityPool).getPoolId()\n        );\n\n        // In Balancer pools the tokens are listed in alphabetical order (numbers before letters)\n        // OHM is listed first, wstETH is listed second so this calculates OHM/wstETH which is then\n        // used to compare against the oracle calculation OHM/wstETH price\n        // Hard coding decimals is fine here because it is a specific implementation and we know the\n        // decimals of the tokens in the pool\n        return (balances_[0] * 1e18) / balances_[1];\n    }\n\n    /// @notice                 Calculates the vault's claim on OHM in the Balancer pool\n    /// @return uint256         OHM claim\n    function _getPoolOhmShare() internal view override returns (uint256) {\n        // Cast pool address from abstract to Balancer Base Pool\n        IBasePool pool = IBasePool(liquidityPool);\n\n        (, uint256[] memory balances_, ) = vault.getPoolTokens(pool.getPoolId());\n        uint256 bptTotalSupply = pool.totalSupply();\n\n        if (totalLP == 0) return 0;\n        else return (balances_[0] * totalLP) / bptTotalSupply;\n    }\n\n    //============================================================================================//\n    //                                      VIEW FUNCTIONS                                        //\n    //============================================================================================//\n\n    /// @notice                 Calculates the expected amount of Balancer Pool Tokens that would be received\n    ///                         for depositing a certain amount of wstETH\n    /// @param amount_          Amount of wstETH to calculate BPT for\n    /// @return bptAmount       Amount of BPT that would be received\n    /// @dev                    This function is not meant to be called within a transaction and it will always revert.\n    ///                         It is meant to be called off-chain (by the frontend) using a call request.\n    function getExpectedLPAmount(uint256 amount_) public override returns (uint256 bptAmount) {\n        // Cast pool address from abstract to Balancer Base pool\n        IBasePool pool = IBasePool(liquidityPool);\n\n        // Get amount of OHM that would be borrowed\n        uint256 ohmAmount = _valueCollateral(amount_);\n\n        // Build join pool request\n        address[] memory assets = new address[](2);\n        assets[0] = address(ohm);\n        assets[1] = address(pairToken);\n\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = ohmAmount;\n        maxAmountsIn[1] = amount_;\n\n        JoinPoolRequest memory joinPoolRequest = JoinPoolRequest({\n            assets: assets,\n            maxAmountsIn: maxAmountsIn,\n            userData: abi.encode(1, maxAmountsIn, 0),\n            fromInternalBalance: false\n        });\n\n        (bptAmount, ) = balancerHelper.queryJoin(\n            pool.getPoolId(),\n            address(this),\n            address(this),\n            joinPoolRequest\n        );\n    }\n\n    function getUserWstethShare(address user_) internal view returns (uint256) {\n        // Cast pool address from abstract to Balancer Base pool\n        IBasePool pool = IBasePool(liquidityPool);\n\n        // Get user's LP balance\n        uint256 userLpBalance = lpPositions[user_];\n\n        (, uint256[] memory balances_, ) = vault.getPoolTokens(pool.getPoolId());\n        uint256 bptTotalSupply = pool.totalSupply();\n        return (balances_[1] * userLpBalance) / bptTotalSupply;\n    }\n\n    //============================================================================================//\n    //                                      ADMIN FUNCTIONS                                       //\n    //============================================================================================//\n\n    /// @notice                 Updates the minimum update frequency for each price feed needed for it to not be considered stale\n    function changeUpdateThresholds(\n        uint48 ohmEthPriceFeedUpdateThreshold_,\n        uint48 ethUsdPriceFeedUpdateThreshold_,\n        uint48 stethUsdPriceFeedUpdateThreshold_\n    ) external onlyRole(\"liquidityvault_admin\") {\n        ohmEthPriceFeed.updateThreshold = ohmEthPriceFeedUpdateThreshold_;\n        ethUsdPriceFeed.updateThreshold = ethUsdPriceFeedUpdateThreshold_;\n        stethUsdPriceFeed.updateThreshold = stethUsdPriceFeedUpdateThreshold_;\n    }\n\n    /// @notice                 Rescue funds from Aura in the event the contract was shut off due to a bug\n    /// @dev                    This function can only be accessed by the liquidityvault_admin role and only when\n    ///                         the vault is deactivated. This acts as an emergency migration function in the event\n    ///                         that the vault is compromised.\n    function rescueFundsFromAura() external onlyRole(\"liquidityvault_admin\") {\n        if (isVaultActive) revert LiquidityVault_StillActive();\n\n        uint256 auraBalance = auraPool.rewardsPool.balanceOf(address(this));\n        auraPool.rewardsPool.withdrawAndUnwrap(auraBalance, false);\n    }\n}"
    },
    {
      "filename": "src/policies/lending/abstracts/SingleSidedLiquidityVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system dependencies\nimport {MINTRv1} from \"src/modules/MINTR/MINTR.v1.sol\";\nimport {LQREGv1} from \"src/modules/LQREG/LQREG.v1.sol\";\nimport {ROLESv1, RolesConsumer} from \"src/modules/ROLES/OlympusRoles.sol\";\nimport \"src/Kernel.sol\";\n\n// Import external dependencies\nimport {AggregatorV3Interface} from \"src/interfaces/AggregatorV2V3Interface.sol\";\n\n// Import internal dependencies\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\n// Import types\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {OlympusERC20Token} from \"src/external/OlympusERC20.sol\";\n\n// Import utilities\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\n\n/// @title  Olympus Base Single Sided Liquidity Vault Contract\n/// @dev    Some caveats around this contract:\n///         - No internal reward token should also be an external reward token\n///         - No pair token should also be an external reward token\n///         - No pair, internal reward, or external reward tokens should be ERC777s or non-standard ERC20s\nabstract contract SingleSidedLiquidityVault is Policy, ReentrancyGuard, RolesConsumer {\n    using TransferHelper for ERC20;\n\n    // ========= ERRORS ========= //\n\n    error LiquidityVault_Inactive();\n    error LiquidityVault_StillActive();\n    error LiquidityVault_LimitViolation();\n    error LiquidityVault_PoolImbalanced();\n    error LiquidityVault_BadPriceFeed();\n    error LiquidityVault_InvalidRemoval();\n    error LiquidityVault_InvalidParams();\n\n    // ========= EVENTS ========= //\n\n    event Deposit(address indexed user, uint256 pairAmount, uint256 ohmMinted);\n    event Withdraw(address indexed user, uint256 pairAmount, uint256 ohmBurned);\n    event RewardsClaimed(address indexed user, address indexed token, uint256 amount);\n\n    // ========= DATA STRUCTURES ========= //\n\n    struct InternalRewardToken {\n        address token;\n        uint256 decimalsAdjustment;\n        uint256 rewardsPerSecond;\n        uint256 lastRewardTime;\n        uint256 accumulatedRewardsPerShare;\n    }\n\n    struct ExternalRewardToken {\n        address token;\n        uint256 decimalsAdjustment;\n        uint256 accumulatedRewardsPerShare;\n        uint256 lastBalance;\n    }\n\n    // ========= STATE ========= //\n\n    // Modules\n    MINTRv1 public MINTR;\n    LQREGv1 public LQREG;\n\n    // Tokens\n    OlympusERC20Token public ohm;\n    ERC20 public pairToken;\n\n    // Token Decimals\n    uint256 public pairTokenDecimals;\n\n    // Pool\n    address public liquidityPool;\n\n    // Aggregate Contract State\n    uint256 public totalLP;\n    uint256 public ohmMinted;\n    uint256 public ohmRemoved;\n    mapping(address => uint256) public accumulatedFees;\n\n    // User State\n    mapping(address => uint256) public pairTokenDeposits;\n    mapping(address => uint256) public lpPositions;\n    mapping(address => mapping(address => uint256)) public userRewardDebts; // Rewards accumulated prior to user's joining (MasterChef V2 math)\n    mapping(address => mapping(address => uint256)) public cachedUserRewards; // Rewards that have been accumulated but not claimed (avoids underflow errors)\n    mapping(address => bool) internal _hasDeposited; // Used to determine if a user has ever deposited\n    address[] public users; // Used to track users that have interacted with this contract (for migration in the event of a bug)\n\n    // Reward Token State\n    /// @notice An internal reward token is a token where the vault is the only source of rewards and the\n    ///         vault handles all accounting around how many reward tokens to distribute over time\n    InternalRewardToken[] public internalRewardTokens;\n\n    /// @notice An external reward token is a token where the primary accrual of reward tokens occurs outside\n    ///         the scope of this contract in a system like Convex or Aura. The vault is responsible for harvesting\n    ///         rewards back to the vault and then distributing them proportionally to users\n    ExternalRewardToken[] public externalRewardTokens;\n\n    // Exchange Name (used by frontend)\n    string public EXCHANGE;\n\n    // Configuration values\n    uint256 public LIMIT;\n    uint256 public THRESHOLD;\n    uint256 public FEE;\n    uint256 public constant PRECISION = 1000;\n    bool public isVaultActive;\n\n    //============================================================================================//\n    //                                      POLICY SETUP                                          //\n    //============================================================================================//\n\n    constructor(\n        Kernel kernel_,\n        address ohm_,\n        address pairToken_,\n        address liquidityPool_\n    ) Policy(kernel_) {\n        // Set tokens\n        ohm = OlympusERC20Token(ohm_);\n        pairToken = ERC20(pairToken_);\n\n        // Set token decimals\n        pairTokenDecimals = pairToken.decimals();\n\n        // Set pool\n        liquidityPool = liquidityPool_;\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](3);\n        dependencies[0] = toKeycode(\"MINTR\");\n        dependencies[1] = toKeycode(\"LQREG\");\n        dependencies[2] = toKeycode(\"ROLES\");\n\n        MINTR = MINTRv1(getModuleAddress(dependencies[0]));\n        LQREG = LQREGv1(getModuleAddress(dependencies[1]));\n        ROLES = ROLESv1(getModuleAddress(dependencies[2]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        Keycode mintrKeycode = MINTR.KEYCODE();\n        Keycode lqregKeycode = LQREG.KEYCODE();\n\n        permissions = new Permissions[](5);\n        permissions[0] = Permissions(mintrKeycode, MINTR.mintOhm.selector);\n        permissions[1] = Permissions(mintrKeycode, MINTR.burnOhm.selector);\n        permissions[2] = Permissions(mintrKeycode, MINTR.increaseMintApproval.selector);\n        permissions[3] = Permissions(lqregKeycode, LQREG.addVault.selector);\n        permissions[4] = Permissions(lqregKeycode, LQREG.removeVault.selector);\n    }\n\n    //============================================================================================//\n    //                                           MODIFIERS                                        //\n    //============================================================================================//\n\n    modifier onlyWhileActive() {\n        if (!isVaultActive) revert LiquidityVault_Inactive();\n        _;\n    }\n\n    //============================================================================================//\n    //                                       CORE FUNCTIONS                                       //\n    //============================================================================================//\n\n    /// @notice                 Deposits pair tokens, mints OHM against the deposited pair tokens, and deposits the\n    ///                         pair token and OHM into a liquidity pool and receives LP tokens in return\n    /// @param  amount_         The amount of pair tokens to deposit\n    /// @param  slippageParam_  Represents the slippage on joining the liquidity pool. Can either be the minimum LP token\n    ///                         amount to receive in the cases of Balancer or Curve, or can be a value (in thousandths) which\n    ///                         will be used to calculate the minimum amount of OHM and pair tokens to use in the case of Uniswap,\n    ///                         Sushiswap, Fraxswap, etc.\n    /// @dev                    This needs to be non-reentrant since the contract only knows the amount of LP tokens it\n    ///                         receives after an external interaction with the liquidity pool\n    function deposit(uint256 amount_, uint256 slippageParam_)\n        external\n        onlyWhileActive\n        nonReentrant\n        returns (uint256 lpAmountOut)\n    {\n        // If this is a new user, add them to the users array in case we need to migrate\n        // their state in the future\n        if (!_hasDeposited[msg.sender]) {\n            _hasDeposited[msg.sender] = true;\n            users.push(msg.sender);\n        }\n\n        // Calculate amount of OHM to borrow\n        uint256 ohmToBorrow = _valueCollateral(amount_);\n\n        // Cache pair token and OHM balance before deposit\n        uint256 pairTokenBalanceBefore = pairToken.balanceOf(address(this));\n        uint256 ohmBalanceBefore = ohm.balanceOf(address(this));\n\n        // The pool being imbalanced is less of a concern here on deposit than on withdrawal,\n        // but in the event the frontend miscalculates the expected LP amount to receive, we want\n        // to reduce the risk of entering a manipulated pool at a bad price\n        if (!_isPoolSafe()) revert LiquidityVault_PoolImbalanced();\n        if (!_canDeposit(ohmToBorrow)) revert LiquidityVault_LimitViolation();\n\n        _depositUpdateRewardState();\n\n        // Gather tokens for deposit\n        pairToken.safeTransferFrom(msg.sender, address(this), amount_);\n        _borrow(ohmToBorrow);\n\n        uint256 lpReceived = _deposit(ohmToBorrow, amount_, slippageParam_);\n\n        // Calculate amount of pair tokens and OHM unused in deposit\n        uint256 unusedPairToken = pairToken.balanceOf(address(this)) - pairTokenBalanceBefore;\n        uint256 unusedOhm = ohm.balanceOf(address(this)) - ohmBalanceBefore;\n\n        // Return unused pair tokens to user\n        if (unusedPairToken > 0) pairToken.safeTransfer(msg.sender, unusedPairToken);\n\n        // Burn unused OHM\n        if (unusedOhm > 0) _repay(unusedOhm);\n\n        uint256 pairTokenUsed = amount_ - unusedPairToken;\n        uint256 ohmUsed = ohmToBorrow - unusedOhm;\n\n        ohmMinted += ohmUsed;\n        totalLP += lpReceived;\n\n        pairTokenDeposits[msg.sender] += pairTokenUsed;\n        lpPositions[msg.sender] += lpReceived;\n\n        // Update user's reward debts\n        _depositUpdateRewardDebts(lpReceived);\n\n        emit Deposit(msg.sender, pairTokenUsed, ohmUsed);\n    }\n\n    /// @notice                     Withdraws pair tokens and OHM from a liquidity pool, returns any received pair tokens to the\n    ///                             user, and burns any received OHM\n    /// @param  lpAmount_           The amount of LP tokens to withdraw\n    /// @param  minTokenAmounts_    The minimum amounts of pair tokens and OHM to receive\n    /// @dev                        This needs to be non-reentrant since the contract only knows the amount of OHM and\n    ///                             pair tokens it receives after an external call to withdraw liquidity\n    function withdraw(\n        uint256 lpAmount_,\n        uint256[] calldata minTokenAmounts_,\n        bool claim_\n    ) external onlyWhileActive nonReentrant returns (uint256) {\n        // Liquidity vaults should always be built around a two token pool so we can assume\n        // the array will always have two elements\n        if (lpAmount_ == 0 || minTokenAmounts_[0] == 0 || minTokenAmounts_[1] == 0)\n            revert LiquidityVault_InvalidParams();\n        if (!_isPoolSafe()) revert LiquidityVault_PoolImbalanced();\n\n        _withdrawUpdateRewardState(lpAmount_, claim_);\n\n        totalLP -= lpAmount_;\n        lpPositions[msg.sender] -= lpAmount_;\n\n        // Withdraw OHM and pairToken from LP\n        (uint256 ohmReceived, uint256 pairTokenReceived) = _withdraw(lpAmount_, minTokenAmounts_);\n\n        // Reduce deposit values\n        uint256 userDeposit = pairTokenDeposits[msg.sender];\n        pairTokenDeposits[msg.sender] -= pairTokenReceived > userDeposit\n            ? userDeposit\n            : pairTokenReceived;\n        ohmMinted -= ohmReceived > ohmMinted ? ohmMinted : ohmReceived;\n        ohmRemoved += ohmReceived > ohmMinted ? ohmReceived - ohmMinted : 0;\n\n        // Return assets\n        _repay(ohmReceived);\n        pairToken.safeTransfer(msg.sender, pairTokenReceived);\n\n        emit Withdraw(msg.sender, pairTokenReceived, ohmReceived);\n        return pairTokenReceived;\n    }\n\n    /// @notice                     Claims user's rewards for all reward tokens\n    function claimRewards() external onlyWhileActive nonReentrant {\n        uint256 numInternalRewardTokens = internalRewardTokens.length;\n        uint256 numExternalRewardTokens = externalRewardTokens.length;\n\n        uint256[] memory accumulatedRewards = _accumulateExternalRewards();\n\n        for (uint256 i; i < numInternalRewardTokens; ) {\n            _claimInternalRewards(i);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        for (uint256 i; i < numExternalRewardTokens; ) {\n            _updateExternalRewardState(i, accumulatedRewards[i]);\n            _claimExternalRewards(i);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    //============================================================================================//\n    //                                       VIEW FUNCTIONS                                       //\n    //============================================================================================//\n\n    /// @notice                         Gets the max amount of pair tokens that can be deposited currently\n    /// @return uint256                 The max amount of pair tokens that can be deposited currently\n    function getMaxDeposit() public view returns (uint256) {\n        uint256 currentPoolOhmShare = _getPoolOhmShare();\n        uint256 emitted;\n\n        // Calculate max OHM mintable amount\n        if (ohmMinted > currentPoolOhmShare) emitted = ohmMinted - currentPoolOhmShare;\n        uint256 maxOhmAmount = LIMIT + ohmRemoved - ohmMinted - emitted;\n\n        // Convert max OHM mintable amount to pair token amount\n        uint256 ohmPerPairToken = _valueCollateral(1e18); // OHM per 1 pairToken\n        uint256 pairTokenDecimalAdjustment = 10**pairToken.decimals();\n        return (maxOhmAmount * pairTokenDecimalAdjustment) / ohmPerPairToken;\n    }\n\n    /// @notice                         Gets all users that have deposited into the vault\n    /// @return address[]               An array of all users that have deposited into the vault\n    function getUsers() public view returns (address[] memory) {\n        return users;\n    }\n\n    /// @notice                         Gets a list of all the internal reward tokens\n    /// @return InternalRewardToken[]   An array of all the internal reward tokens\n    function getInternalRewardTokens() public view returns (InternalRewardToken[] memory) {\n        return internalRewardTokens;\n    }\n\n    /// @notice                         Gets a list of all the external reward tokens\n    /// @return ExternalRewardToken[]   An array of all the external reward tokens\n    function getExternalRewardTokens() public view returns (ExternalRewardToken[] memory) {\n        return externalRewardTokens;\n    }\n\n    /// @notice                         Returns the amount of rewards a user has earned for a given reward token\n    /// @param  id_                     The ID of the reward token\n    /// @param  user_                   The user's address to check rewards for\n    /// @return uint256                 The amount of rewards the user has earned\n    function internalRewardsForToken(uint256 id_, address user_) public view returns (uint256) {\n        InternalRewardToken memory rewardToken = internalRewardTokens[id_];\n        uint256 lastRewardTime = rewardToken.lastRewardTime;\n        uint256 accumulatedRewardsPerShare = rewardToken.accumulatedRewardsPerShare;\n\n        if (block.timestamp > lastRewardTime && totalLP != 0) {\n            uint256 timeDiff = block.timestamp - lastRewardTime;\n            uint256 totalRewards = timeDiff * rewardToken.rewardsPerSecond;\n\n            // This correctly uses 1e18 because the LP tokens of all major DEXs have 18 decimals\n            accumulatedRewardsPerShare += (totalRewards * 1e18) / totalLP;\n        }\n\n        // This correctly uses 1e18 because the LP tokens of all major DEXs have 18 decimals\n        uint256 totalAccumulatedRewards = (lpPositions[user_] * accumulatedRewardsPerShare) -\n            userRewardDebts[user_][rewardToken.token];\n\n        return (cachedUserRewards[user_][rewardToken.token] + totalAccumulatedRewards) / 1e18;\n    }\n\n    /// @notice                         Returns the amount of rewards a user has earned for a given external reward token\n    /// @param  id_                     The ID of the external reward token\n    /// @param  user_                   The user's address to check rewards for\n    /// @return uint256                 The amount of rewards the user has earned\n    function externalRewardsForToken(uint256 id_, address user_) public view returns (uint256) {\n        ExternalRewardToken memory rewardToken = externalRewardTokens[id_];\n\n        // This correctly uses 1e18 because the LP tokens of all major DEXs have 18 decimals\n        uint256 totalAccumulatedRewards = (lpPositions[user_] *\n            rewardToken.accumulatedRewardsPerShare) - userRewardDebts[user_][rewardToken.token];\n\n        return (cachedUserRewards[user_][rewardToken.token] + totalAccumulatedRewards) / 1e18;\n    }\n\n    /// @notice                         Calculates the net amount of OHM that this contract has emitted to or removed from the broader market\n    /// @return emitted                 The amount of OHM that"
    }
  ]
}