{
  "Title": "[L01] Lack of event emission after disputing a redemption",
  "Content": "The `OptimisticRewarderBase` contract defines a [`Disputed` event](https://github.com/UMAprotocol/protocol/blob/0c4cea3c3d5e48da6f8984b8ba3afdfea4ce47cc/packages/core/contracts/financial-templates/optimistic-rewarder/OptimisticRewarderBase.sol#L71) that is intended to be triggered if a redemption is disputed. However, this event is not emitted within or outside of the `OptimisticRewarderBase` contract.\n\n\nConsider emitting the event after sensitive changes take place in the [`dispute` function](https://github.com/UMAprotocol/protocol/blob/0c4cea3c3d5e48da6f8984b8ba3afdfea4ce47cc/packages/core/contracts/financial-templates/optimistic-rewarder/OptimisticRewarderBase.sol#L184), to facilitate tracking and notify off-chain clients following the contractsâ€™ activity.\n\n\n**Update:** *Fixed as of commit [`c275e92`](https://github.com/UMAprotocol/protocol/pull/3695/commits/c275e9296aa91643926d40f918491cc9b8473003) in [PR3695](https://github.com/UMAprotocol/protocol/pull/3695/).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/financial-templates/optimistic-rewarder/OptimisticRewarderBase.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../oracle/interfaces/FinderInterface.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/implementation/MultiCaller.sol\";\nimport \"../../oracle/interfaces/StoreInterface.sol\";\nimport \"../../oracle/interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../../oracle/implementation/Constants.sol\";\nimport \"../../oracle/interfaces/SkinnyOptimisticOracleInterface.sol\";\nimport \"../../common/implementation/AncillaryData.sol\";\nimport \"../../common/interfaces/AddressWhitelistInterface.sol\";\n\n/**\n * @notice The base rewarder contract. This manages depositing rewards and paying them out to tokenholders using values\n * backed by the OptimisticOracle's dispute process.\n */\nabstract contract OptimisticRewarderBase is Lockable, MultiCaller {\n    using SafeERC20 for IERC20;\n\n    struct RedemptionAmount {\n        uint256 amount;\n        IERC20 token;\n    }\n\n    struct Redemption {\n        uint256 finalFee;\n        uint256 expiryTime;\n    }\n\n    // Constants.\n    FinderInterface public finder;\n    bytes public customAncillaryData;\n    IERC20 public bondToken;\n    bytes32 public identifier;\n\n    // Note: setters are intentionally absent for these parameters. If a deployer intends to modify these parameters,\n    // this contract suite offers a simple migration path where a new Rewarder contract is created and the existing\n    // ERC721 token can be passed in and used as the reward token there as well. This would be minimally painful for\n    // users.\n    uint256 public liveness;\n    uint256 public bond;\n\n    // Parameters that can be synced and stored in the contract.\n    uint256 public finalFee;\n    StoreInterface public store;\n    SkinnyOptimisticOracleInterface public optimisticOracle;\n\n    // Mapping to track redemptions.\n    mapping(bytes32 => Redemption) public redemptions;\n\n    // Mapping to track the past total cumulative redemptions for tokenIds.\n    mapping(uint256 => mapping(IERC20 => uint256)) public redeemedAmounts;\n\n    // This allows other contracts to publish reward updates.\n    event UpdateToken(uint256 indexed tokenId, address indexed caller, bytes data);\n\n    event Deposited(address indexed depositor, IERC20 indexed token, uint256 amount);\n\n    // Lifecycle events for redemptions.\n    event Requested(\n        uint256 indexed tokenId,\n        bytes32 indexed redemptionId,\n        RedemptionAmount[] cumulativeRedemptions,\n        uint256 expiryTime\n    );\n    event Canceled(uint256 indexed tokenId, bytes32 indexed redemptionId, uint256 expiryTime);\n    event Disputed(uint256 indexed tokenId, bytes32 indexed redemptionId, uint256 expiryTime);\n    event Redeemed(uint256 indexed tokenId, bytes32 indexed redemptionId, uint256 expiryTime);\n\n    /**\n     * @notice Constructor.\n     * @param _liveness liveness period between submission and verification of a reward.\n     * @param _bondToken ERC20 token that the bond is paid in.\n     * @param _bond size of the bond.\n     * @param _identifier identifier that should be passed to the optimistic oracle on dispute.\n     * @param _customAncillaryData custom ancillary data that should be sent to the optimistic oracle on dispute.\n     * @param _finder finder to look up UMA contract addresses.\n     */\n    constructor(\n        uint256 _liveness,\n        IERC20 _bondToken,\n        uint256 _bond,\n        bytes32 _identifier,\n        bytes memory _customAncillaryData,\n        FinderInterface _finder\n    ) {\n        require(_liveness > 0, \"liveness can't be 0\");\n        liveness = _liveness;\n        finder = _finder;\n        require(_getCollateralWhitelist().isOnWhitelist(address(_bondToken)), \"bond token not supported\");\n        bondToken = _bondToken;\n        bond = _bond;\n        require(_getIdentifierWhitelist().isIdentifierSupported(_identifier), \"identifier not supported\");\n        identifier = _identifier;\n        SkinnyOptimisticOracleInterface skinnyOptimisticOracle = _getOptimisticOracle();\n        require(\n            skinnyOptimisticOracle\n                .stampAncillaryData(\n                AncillaryData.appendKeyValueBytes32(_customAncillaryData, \"redemptionId\", bytes32(0)),\n                address(this)\n            )\n                .length <= skinnyOptimisticOracle.ancillaryBytesLimit(),\n            \"ancillary data too long\"\n        );\n        customAncillaryData = _customAncillaryData;\n        _sync();\n    }\n\n    /**\n     * @notice Allows anyone to deposit reward tokens into the contract. Presumably, this would be the deployer or\n     * protocol that wishes to reward the users interacting with the system.\n     * @dev Once tokens are deposited, they cannot be withdrawn without claiming a reward. If a deployer wants an\n     * \"escape hatch\", they can create a special tokenId for this purpose.\n     * @param token ERC20 token that is being deposited.\n     * @param amount amount of rewards to deposit.\n     */\n    function depositRewards(IERC20 token, uint256 amount) public nonReentrant {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        emit Deposited(msg.sender, token, amount);\n    }\n\n    /**\n     * @notice Allows the caller to mint a token to the receiver and include a reward-relevant update event with it.\n     * This is intended to be used when the user first interacts with a reward-granting protocol.\n     * @dev if the user prefers to only mint a new token, they should call the mintNextToken function.\n     * @param receiver user that will receive the newly minted token.\n     * @param data arbitrary caller-generated data that will be associated with this update.\n     */\n    function mint(address receiver, bytes memory data) public nonReentrant returns (uint256 tokenId) {\n        tokenId = mintNextToken(receiver);\n        emit UpdateToken(tokenId, msg.sender, data);\n    }\n\n    /**\n     * @notice Applies a reward-relevant update to an existing token.\n     * @param tokenId the existing tokenId that the update should be applied to.\n     * @param data arbitrary caller-generated data that will be associated with this update.\n     */\n    function updateToken(uint256 tokenId, bytes memory data) public nonReentrant {\n        emit UpdateToken(tokenId, msg.sender, data);\n    }\n\n    /**\n     * @notice Requests a redemption for any tokenId. This can be called by anyone.\n     * @dev if called by someone who doesn't own the token, they are effectively gifting their bond to the owner.\n     * @param tokenId the tokenId the redemption is for.\n     * @param cumulativeRedemptions the cumulative token addresses and amounts that this tokenId is eligible for\n     * at the current timestap. cumulative redemptions that are too low should be considered to be valid.\n     */\n    function requestRedemption(uint256 tokenId, RedemptionAmount[] memory cumulativeRedemptions)\n        public\n        nonReentrant\n        returns (uint256 totalBond)\n    {\n        bytes32 redemptionId = getRedemptionId(tokenId, cumulativeRedemptions);\n        require(redemptions[redemptionId].expiryTime == 0, \"Redemption already exists\");\n        require(ownerOf(tokenId) != address(0), \"tokenId is invalid\");\n        // Note: it's important to put _some_ limit on the length of data passed in here. Otherwise, it is possible to\n        // create values that are so long that this transaction would fit within the block gas limit, but the dispute\n        // transaction would not.\n        require(cumulativeRedemptions.length <= 100, \"too many token transfers\");\n\n        uint256 time = getCurrentTime();\n\n        totalBond = finalFee + bond;\n        bondToken.safeTransferFrom(msg.sender, address(this), totalBond);\n\n        redemptions[redemptionId] = Redemption({ finalFee: finalFee, expiryTime: time + liveness });\n\n        emit Requested(tokenId, redemptionId, cumulativeRedemptions, time);\n    }\n\n    /**\n     * @notice Disputes a redemption request.\n     * @dev this will cancel a request if the final fee changes or something causes the optimistic oracle proposal to\n     * fail.\n     * @param tokenId the tokenId the redemption is for.\n     * @param cumulativeRedemptions the cumulative redemptions that were provided in the original request.\n     */\n    function dispute(uint256 tokenId, RedemptionAmount[] memory cumulativeRedemptions) public nonReentrant {\n        bytes32 redemptionId = getRedemptionId(tokenId, cumulativeRedemptions);\n\n        // This automatically checks that redemptions[redemptionId] != 0.\n        // Check that it has not passed liveness liveness.\n        Redemption storage redemption = redemptions[redemptionId];\n        require(getCurrentTime() < redemption.expiryTime, \"redemption expired or nonexistent\");\n\n        // Final fees don't match to those in the current store, which means the bond the initial caller provided was\n        // incorrect. Cancel the request to allow the requester to resubmit with the correct params.\n        // Note: we pull the store directly from the finder to avoid any issues with an outdated store causing the\n        // final fee to appear to be correct, but actually be outdated due to the OptimisticOracle pulling from a\n        // newer store deployment.\n        if (redemption.finalFee != _getStore().computeFinalFee(address(bondToken)).rawValue) {\n            _cancelRedemption(tokenId, redemptionId);\n            return;\n        } else {\n            uint256 totalBond = bond + redemption.finalFee;\n            bondToken.safeApprove(address(optimisticOracle), totalBond * 2);\n            bytes memory ancillaryData =\n                AncillaryData.appendKeyValueBytes32(customAncillaryData, \"redemptionId\", redemptionId);\n            uint32 requestTimestamp = uint32(redemption.expiryTime - liveness);\n            address proposer = ownerOf(tokenId);\n\n            try\n                optimisticOracle.requestAndProposePriceFor(\n                    identifier,\n                    requestTimestamp,\n                    ancillaryData,\n                    bondToken,\n                    0, // Reward = 0\n                    bond, // Bond (on top of the final fee) for the proposer and disputer.\n                    liveness,\n                    proposer,\n                    int256(1e18) // Canonical value representing \"True\"; i.e. the proposed redemption is valid.\n                )\n            returns (uint256) {} catch {\n                // There are various cases that can cause an OptimisticOracle proposal to fail. These are unlikely, but\n                // this is intended as a worst-case fallback to avoid undisputable requests.\n                // A few examples:\n                // 1. The token ceases to be approved.\n                // 2. The identifier ceases to be approved.\n                // 3. The request has been submitted before (same identifier, timestap, ancillary data, and requester).\n                //    This should be impossible for this contract.\n                // 4. The money bond + final fee is larger than approved or in the contract's balance. This should also\n                //    be impossible in this contract.\n                _cancelRedemption(tokenId, redemptionId);\n                return;\n            }\n\n            SkinnyOptimisticOracleInterface.Request memory request =\n                SkinnyOptimisticOracleInterface.Request({\n                    proposer: proposer,\n                    disputer: address(0),\n                    currency: bondToken,\n                    settled: false,\n                    proposedPrice: int256(1e18),\n                    resolvedPrice: 0,\n                    expirationTime: redemption.expiryTime,\n                    reward: 0,\n                    finalFee: redemption.finalFee,\n                    bond: bond,\n                    customLiveness: liveness\n                });\n\n            // Note: don't pull funds until here to avoid any transfers that aren't needed.\n            bondToken.safeTransferFrom(msg.sender, address(this), totalBond);\n\n            // Dispute the request that we just sent.\n            optimisticOracle.disputePriceFor(\n                identifier,\n                requestTimestamp,\n                ancillaryData,\n                request,\n                msg.sender,\n                address(this)\n            );\n        }\n\n        delete redemptions[redemptionId];\n    }\n\n    /**\n     * @notice Redeem a redemption request that has passed liveness.\n     * @dev returns the bond that was paid with the initial proposal.\n     * @param tokenId the tokenId the redemption is for.\n     * @param cumulativeRedemptions the cumulative redemptions that were provided in the original request.\n     */\n    function redeem(uint256 tokenId, RedemptionAmount[] memory cumulativeRedemptions) public nonReentrant {\n        bytes32 redemptionId = getRedemptionId(tokenId, cumulativeRedemptions);\n\n        // Can only be redeemed by owner.\n        require(msg.sender == ownerOf(tokenId), \"must be called by token owner\");\n\n        // Check that the redemption is initialized and that it passed liveness.\n        require(\n            redemptions[redemptionId].expiryTime != 0 && getCurrentTime() >= redemptions[redemptionId].expiryTime,\n            \"unexpired or nonexistent\"\n        );\n\n        for (uint256 i = 0; i < cumulativeRedemptions.length; i++) {\n            IERC20 token = cumulativeRedemptions[i].token;\n            uint256 currentRedemptionTotal = redeemedAmounts[tokenId][token];\n            uint256 proposedRedemptionTotal = cumulativeRedemptions[i].amount;\n\n            // Only pay if the cumulative amount specified in the request is larger than the amount paid out already.\n            // Note: disallow payments of the bond token even if it's in the approved request is passed to ensure\n            // rewards don't interfere with bond bookkeeping. This is checked here rather than at the initiation of the\n            // request to avoid the cost of looping over the array twice in the lifecycle.\n            if (proposedRedemptionTotal > currentRedemptionTotal && token != bondToken) {\n                uint256 amountToPay = proposedRedemptionTotal - currentRedemptionTotal;\n                redeemedAmounts[tokenId][token] = proposedRedemptionTotal;\n                token.safeTransfer(msg.sender, amountToPay);\n            }\n        }\n\n        // Return the bond to the owner.\n        bondToken.safeTransfer(msg.sender, bond + redemptions[redemptionId].finalFee);\n\n        delete redemptions[redemptionId];\n\n        emit Redeemed(tokenId, redemptionId, redemptions[redemptionId].expiryTime);\n    }\n\n    /**\n     * @notice Syncs external addresses and parameters into the contract.\n     * @dev These are stored rather than read on each run to avoid expensive external calls in the happy-path.\n     */\n    function sync() public nonReentrant {\n        _sync();\n    }\n\n    /**\n     * @notice gets the current time. Can be overridden for testing.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /**\n     * @notice Abstract function that is called to mint the next ERC721 tokenId.\n     * @param recipient the recipient of the newly minted token.\n     */\n    function mintNextToken(address recipient) public virtual returns (uint256);\n\n    /**\n     * @notice Abstract function that is called to check the owner of the token.\n     * @dev this matches the ERC721 ownerOf interface.\n     * @param tokenId the tokenId to check the owner of.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address);\n\n    /**\n     * @notice Generates a redemption id for the tokenId and the claim amounts.\n     * @param tokenId the tokenId that the claim is for.\n     * @param cumulativeRedemptions the cumulative redemptions that were provided in the request.\n     */\n    function getRedemptionId(uint256 tokenId, RedemptionAmount[] memory cumulativeRedemptions)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(tokenId, cumulativeRedemptions));\n    }\n\n    function _sync() internal {\n        store = _getStore();\n        finalFee = store.computeFinalFee(address(bondToken)).rawValue;\n        optimisticOracle = _getOptimisticOracle();\n    }\n\n    function _getStore() internal view returns (StoreInterface) {\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\n    }\n\n    function _getOptimisticOracle() internal view returns (SkinnyOptimisticOracleInterface) {\n        return\n            SkinnyOptimisticOracleInterface(finder.getImplementationAddress(OracleInterfaces.SkinnyOptimisticOracle));\n    }\n\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\n    }\n\n    function _getCollateralWhitelist() internal view returns (AddressWhitelistInterface) {\n        return AddressWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\n    }\n\n    function _cancelRedemption(uint256 tokenId, bytes32 redemptionId) internal {\n        // On cancellation, perform a sync to ensure the contract has the most up-to-date addresses and params.\n        _sync();\n        Redemption storage redemption = redemptions[redemptionId];\n        bondToken.safeTransfer(ownerOf(tokenId), redemption.finalFee + bond);\n        emit Canceled(tokenId, redemptionId, redemption.expiryTime);\n        delete redemptions[redemptionId];\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/financial-templates/optimistic-rewarder/OptimisticRewarderBase.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../oracle/interfaces/FinderInterface.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/implementation/MultiCaller.sol\";\nimport \"../../oracle/interfaces/StoreInterface.sol\";\nimport \"../../oracle/interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../../oracle/implementation/Constants.sol\";\nimport \"../../oracle/interfaces/SkinnyOptimisticOracleInterface.sol\";\nimport \"../../common/implementation/AncillaryData.sol\";\nimport \"../../common/interfaces/AddressWhitelistInterface.sol\";\n\n/**\n * @notice The base rewarder contract. This manages depositing rewards and paying them out to tokenholders using values\n * backed by the OptimisticOracle's dispute process.\n */\nabstract contract OptimisticRewarderBase is Lockable, MultiCaller {\n    using SafeERC20 for IERC20;\n\n    struct RedemptionAmount {\n        uint256 amount;\n        IERC20 token;\n    }\n\n    struct Redemption {\n        uint256 finalFee;\n        uint256 expiryTime;\n    }\n\n    // Constants.\n    FinderInterface public finder;\n    bytes public customAncillaryData;\n    IERC20 public bondToken;\n    bytes32 public identifier;\n\n    // Note: setters are intentionally absent for these parameters. If a deployer intends to modify these parameters,\n    // this contract suite offers a simple migration path where a new Rewarder contract is created and the existing\n    // ERC721 token can be passed in and used as the reward token there as well. This would be minimally painful for\n    // users.\n    uint256 public liveness;\n    uint256 public bond;\n\n    // Parameters that can be synced and stored in the contract.\n    uint256 public finalFee;\n    StoreInterface public store;\n    SkinnyOptimisticOracleInterface public optimisticOracle;\n\n    // Mapping to track redemptions.\n    mapping(bytes32 => Redemption) public redemptions;\n\n    // Mapping to track the past total cumulative redemptions for tokenIds.\n    mapping(uint256 => mapping(IERC20 => uint256)) public redeemedAmounts;\n\n    // This allows other contracts to publish reward updates.\n    event UpdateToken(uint256 indexed tokenId, address indexed caller, bytes data);\n\n    event Deposited(address indexed depositor, IERC20 indexed token, uint256 amount);\n\n    // Lifecycle events for redemptions.\n    event Requested(\n        uint256 indexed tokenId,\n        bytes32 indexed redemptionId,\n        RedemptionAmount[] cumulativeRedemptions,\n        uint256 expiryTime\n    );\n    event Canceled(uint256 indexed tokenId, bytes32 indexed redemptionId, uint256 expiryTime);\n    event Disputed(uint256 indexed tokenId, bytes32 indexed redemptionId, uint256 expiryTime);\n    event Redeemed(uint256 indexed tokenId, bytes32 indexed redemptionId, uint256 expiryTime);\n\n    /**\n     * @notice Constructor.\n     * @param _liveness liveness period between submission and verification of a reward.\n     * @param _bondToken ERC20 token that the bond is paid in.\n     * @param _bond size of the bond.\n     * @param _identifier identifier that should be passed to the optimistic oracle on dispute.\n     * @param _customAncillaryData custom ancillary data that should be sent to the optimistic oracle on dispute.\n     * @param _finder finder to look up UMA contract addresses.\n     */\n    constructor(\n        uint256 _liveness,\n        IERC20 _bondToken,\n        uint256 _bond,\n        bytes32 _identifier,\n        bytes memory _customAncillaryData,\n        FinderInterface _finder\n    ) {\n        require(_liveness > 0, \"liveness can't be 0\");\n        liveness = _liveness;\n        finder = _finder;\n        require(_getCollateralWhitelist().isOnWhitelist(address(_bondToken)), \"bond token not supported\");\n        bondToken = _bondToken;\n        bond = _bond;\n        require(_getIdentifierWhitelist().isIdentifierSupported(_identifier), \"identifier not supported\");\n        identifier = _identifier;\n        SkinnyOptimisticOracleInterface skinnyOptimisticOracle = _getOptimisticOracle();\n        require(\n            skinnyOptimisticOracle\n                .stampAncillaryData(\n                AncillaryData.appendKeyValueBytes32(_customAncillaryData, \"redemptionId\", bytes32(0)),\n                address(this)\n            )\n                .length <= skinnyOptimisticOracle.ancillaryBytesLimit(),\n            \"ancillary data too long\"\n        );\n        customAncillaryData = _customAncillaryData;\n        _sync();\n    }\n\n    /**\n     * @notice Allows anyone to deposit reward tokens into the contract. Presumably, this would be the deployer or\n     * protocol that wishes to reward the users interacting with the system.\n     * @dev Once tokens are deposited, they cannot be withdrawn without claiming a reward. If a deployer wants an\n     * \"escape hatch\", they can create a special tokenId for this purpose.\n     * @param token ERC20 token that is being deposited.\n     * @param amount amount of rewards to deposit.\n     */\n    function depositRewards(IERC20 token, uint256 amount) public nonReentrant {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        emit Deposited(msg.sender, token, amount);\n    }\n\n    /**\n     * @notice Allows the caller to mint a token to the receiver and include a reward-relevant update event with it.\n     * This is intended to be used when the user first interacts with a reward-granting protocol.\n     * @dev if the user prefers to only mint a new token, they should call the mintNextToken function.\n     * @param receiver user that will receive the newly minted token.\n     * @param data arbitrary caller-generated data that will be associated with this update.\n     */\n    function mint(address receiver, bytes memory data) public nonReentrant returns (uint256 tokenId) {\n        tokenId = mintNextToken(receiver);\n        emit UpdateToken(tokenId, msg.sender, data);\n    }\n\n    /**\n     * @notice Applies a reward-relevant update to an existing token.\n     * @param tokenId the existing tokenId that the update should be applied to.\n     * @param data arbitrary caller-generated data that will be associated with this update.\n     */\n    function updateToken(uint256 tokenId, bytes memory data) public nonReentrant {\n        emit UpdateToken(tokenId, msg.sender, data);\n    }\n\n    /**\n     * @notice Requests a redemption for any tokenId. This can be called by anyone.\n     * @dev if called by someone who doesn't own the token, they are effectively gifting their bond to the owner.\n     * @param tokenId the tokenId the redemption is for.\n     * @param cumulativeRedemptions the cumulative token addresses and amounts that this tokenId is eligible for\n     * at the current timestap. cumulative redemptions that are too low should be considered to be valid.\n     */\n    function requestRedemption(uint256 tokenId, RedemptionAmount[] memory cumulativeRedemptions)\n        public\n        nonReentrant\n        returns (uint256 totalBond)\n    {\n        bytes32 redemptionId = getRedemptionId(tokenId, cumulativeRedemptions);\n        require(redemptions[redemptionId].expiryTime == 0, \"Redemption already exists\");\n        require(ownerOf(tokenId) != address(0), \"tokenId is invalid\");\n        // Note: it's important to put _some_ limit on the length of data passed in here. Otherwise, it is possible to\n        // create values that are so long that this transaction would fit within the block gas limit, but the dispute\n        // transaction would not.\n        require(cumulativeRedemptions.length <= 100, \"too many token transfers\");\n\n        uint256 time = getCurrentTime();\n\n        totalBond = finalFee + bond;\n        bondToken.safeTransferFrom(msg.sender, address(this), totalBond);\n\n        redemptions[redemptionId] = Redemption({ finalFee: finalFee, expiryTime: time + liveness });\n\n        emit Requested(tokenId, redemptionId, cumulativeRedemptions, time);\n    }\n\n    /**\n     * @notice Disputes a redemption request.\n     * @dev this will cancel a request if the final fee changes or something causes the optimistic oracle proposal to\n     * fail.\n     * @param tokenId the tokenId the redemption is for.\n     * @param cumulativeRedemptions the cumulative redemptions that were provided in the original request.\n     */\n    function dispute(uint256 tokenId, RedemptionAmount[] memory cumulativeRedemptions) public nonReentrant {\n        bytes32 redemptionId = getRedemptionId(tokenId, cumulativeRedemptions);\n\n        // This automatically checks that redemptions[redemptionId] != 0.\n        // Check that it has not passed liveness liveness.\n        Redemption storage redemption = redemptions[redemptionId];\n        require(getCurrentTime() < redemption.expiryTime, \"redemption expired or nonexistent\");\n\n        // Final fees don't match to those in the current store, which means the bond the initial caller provided was\n        // incorrect. Cancel the request to allow the requester to resubmit with the correct params.\n        // Note: we pull the store directly from the finder to avoid any issues with an outdated store causing the\n        // final fee to appear to be correct, but actually be outdated due to the OptimisticOracle pulling from a\n        // newer store deployment.\n        if (redemption.finalFee != _getStore().computeFinalFee(address(bondToken)).rawValue) {\n            _cancelRedemption(tokenId, redemptionId);\n            return;\n        } else {\n            uint256 totalBond = bond + redemption.finalFee;\n            bondToken.safeApprove(address(optimisticOracle), totalBond * 2);\n            bytes memory ancillaryData =\n                AncillaryData.appendKeyValueBytes32(customAncillaryData, \"redemptionId\", redemptionId);\n            uint32 requestTimestamp = uint32(redemption.expiryTime - liveness);\n            address proposer = ownerOf(tokenId);\n\n            try\n                optimisticOracle.requestAndProposePriceFor(\n                    identifier,\n                    requestTimestamp,\n                    ancillaryData,\n                    bondToken,\n                    0, // Reward = 0\n                    bond, // Bond (on top of the final fee) for the proposer and disputer.\n                    liveness,\n                    proposer,\n                    int256(1e18) // Canonical value representing \"True\"; i.e. the proposed redemption is valid.\n                )\n            returns (uint256) {} catch {\n                // There are various cases that can cause an OptimisticOracle proposal to fail. These are unlikely, but\n                // this is intended as a worst-case fallback to avoid undisputable requests.\n                // A few examples:\n                // 1. The token ceases to be approved.\n                // 2. The identifier ceases to be approved.\n                // 3. The request has been submitted before (same identifier, timestap, ancillary data, and requester).\n                //    This should be impossible for this contract.\n                // 4. The money bond + final fee is larger than approved or in the contract's balance. This should also\n                //    be impossible in this contract.\n                _cancelRedemption(tokenId, redemptionId);\n                return;\n            }\n\n            SkinnyOptimisticOracleInterface.Request memory request =\n                SkinnyOptimisticOracleInterface.Request({\n                    proposer: proposer,\n                    disputer: address(0),\n                    currency: bondToken,\n                    settled: false,\n                    proposedPrice: int256(1e18),\n                    resolvedPrice: 0,\n                    expirationTime: redemption.expiryTime,\n                    reward: 0,\n                    finalFee: redemption.finalFee,\n                    bond: bond,\n                    customLiveness: liveness\n                });\n\n            // Note: don't pull funds until here to avoid any transfers that aren't needed.\n            bondToken.safeTransferFrom(msg.sender, address(this), totalBond);\n\n            // Dispute the request that we just sent.\n            optimisticOracle.disputePriceFor(\n                identifier,\n                requestTimestamp,\n                ancillaryData,\n                request,\n                msg.sender,\n                address(this)\n            );\n        }\n\n        delete redemptions[redemptionId];\n    }\n\n    /**\n     * @notice Redeem a redemption request that has passed liveness.\n     * @dev returns the bond that was paid with the initial proposal.\n     * @param tokenId the tokenId the redemption is for.\n     * @param cumulativeRedemptions the cumulative redemptions that were provided in the original request.\n     */\n    function redeem(uint256 tokenId, RedemptionAmount[] memory cumulativeRedemptions) public nonReentrant {\n        bytes32 redemptionId = getRedemptionId(tokenId, cumulativeRedemptions);\n\n        // Can only be redeemed by owner.\n        require(msg.sender == ownerOf(tokenId), \"must be called by token owner\");\n\n        // Check that the redemption is initialized and that it passed liveness.\n        require(\n            redemptions[redemptionId].expiryTime != 0 && getCurrentTime() >= redemptions[redemptionId].expiryTime,\n            \"unexpired or nonexistent\"\n        );\n\n        for (uint256 i = 0; i < cumulativeRedemptions.length; i++) {\n            IERC20 token = cumulativeRedemptions[i].token;\n            uint256 currentRedemptionTotal = redeemedAmounts[tokenId][token];\n            uint256 proposedRedemptionTotal = cumulativeRedemptions[i].amount;\n\n            // Only pay if the cumulative amount specified in the request is larger than the amount paid out already.\n            // Note: disallow payments of the bond token even if it's in the approved request is passed to ensure\n            // rewards don't interfere with bond bookkeeping. This is checked here rather than at the initiation of the\n            // request to avoid the cost of looping over the array twice in the lifecycle.\n            if (proposedRedemptionTotal > currentRedemptionTotal && token != bondToken) {\n                uint256 amountToPay = proposedRedemptionTotal - currentRedemptionTotal;\n                redeemedAmounts[tokenId][token] = proposedRedemptionTotal;\n                token.safeTransfer(msg.sender, amountToPay);\n            }\n        }\n\n        // Return the bond to the owner.\n        bondToken.safeTransfer(msg.sender, bond + redemptions[redemptionId].finalFee);\n\n        delete redemptions[redemptionId];\n\n        emit Redeemed(tokenId, redemptionId, redemptions[redemptionId].expiryTime);\n    }\n\n    /**\n     * @notice Syncs external addresses and parameters into the contract.\n     * @dev These are stored rather than read on each run to avoid expensive external calls in the happy-path.\n     */\n    function sync() public nonReentrant {\n        _sync();\n    }\n\n    /**\n     * @notice gets the current ti"
    }
  ]
}