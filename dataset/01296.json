{
  "Title": "M-4: Allo#_fundPool",
  "Content": "# Issue M-4: Allo#_fundPool \n\nSource: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/198 \n\n## Found by \n0xkaden, AsenXDeth, HChang26, Martians, RadCet, SBSecurity, Shubham, alexxander, imare, sashik\\_eth, trachev, vangrim\n## Vulnerability Detail\nLet's see the code of the `_fundPool` function:\n```solidity\nfunction _fundPool(uint256 _amount, uint256 _poolId, IStrategy _strategy) internal {\n        uint256 feeAmount;\n        uint256 amountAfterFee = _amount;\n\n        Pool storage pool = pools[_poolId];\n        address _token = pool.token;\n\n        if (percentFee > 0) {\n            feeAmount = (_amount * percentFee) / getFeeDenominator();\n            amountAfterFee -= feeAmount;\n\n            _transferAmountFrom(_token, TransferData({from: msg.sender, to: treasury, amount: feeAmount}));\n        }\n\n        _transferAmountFrom(_token, TransferData({from: msg.sender, to: address(_strategy), amount: amountAfterFee}));\n        _strategy.increasePoolAmount(amountAfterFee);\n\n        emit PoolFunded(_poolId, amountAfterFee, feeAmount);\n    }\n```\nThe `feeAmount` is calculated as follows:\n```solidity\nfeeAmount = (_amount * percentFee) / getFeeDenominator();\n```\nwhere `getFeeDenominator` returns `1e18` and `percentFee` is represented like that: 1e18 = 100%, 1e17 = 10%, 1e16 = 1%, 1e15 = 0.1% (from the comments when declaring the variable).\n\nLet's say the pool uses a token like [GeminiUSD](https://etherscan.io/token/0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd) which is a token with 300M+ market cap, so it's widely used, and `percentFee` == 1e15 (0.1%)\n\nA user could circumvent the fee by depositing a relatively small amount. In our example, he can deposit 9 GeminiUSD. In that case, the calculation will be:\n`feeAmount = (_amount * percentFee) / getFeeDenominator() = (9e2 * 1e15) / 1e18 = 9e17/1e18 = 9/10 = 0;`\n\nSo the user ends up paying no fee. There is nothing stopping the user from funding his pool by invoking the `fundPool` with such a small amount as many times as he needs to fund the pool with whatever amount he chooses, circumventing the fee. \n\nEspecially with the low gas fees on L2s on which the protocol will be deployed, this will be a viable method to fund a pool without paying any fee to the protocol. \n## Impact\nThe protocol doesn't collect fees from pools with low decimal tokens.\n## Code Snippet\nhttps://github.com/allo-protocol/allo-v2/blob/main/contracts/core/Allo.sol#L502\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd a `minFundAmount` variable and check for it when funding a pool. \n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**n33k** commented:\n> bypassing of fee is an acceptable risk\n\n\n\n**nevillehuang**\n\nEscalate\n\nIn the contest README [here](https://audits.sherlock.xyz/contests/109):\n\n> Fee skirting where pool manager directly fund the pool without paying the fees\n\nFee bypass is only acceptable for pool managers funding pools, NOT just anybody. Some form of check needs to be implemented to check if `msg.sender` is a pool manager to allow fee skirting (if it even is intentional).\n\nSidenote:\n#248, #253, #533, #571, #602, #628, #636, #706 ,#764, #812, #818, #825, #911, #947 are valid duplicates of this issue\n\n**sherlock-admin2**\n\n > Escalate\n> \n> In the contest README [here](https://audits.sherlock.xyz/contests/109):\n> \n> > Fee skirting where pool manager directly fund the pool without paying the fees\n> \n> Fee bypass is only acceptable for pool managers funding pools, NOT just anybody. Some form of check needs to be implemented to check if `msg.sender` is a pool manager to allow fee skirting (if it even is intentional).\n> \n> Sidenote:\n> #248, #253, #533, #571, #602, #628, #636, #706 ,#764, #812, #818, #825, #911, #947 are valid duplicates of this issue\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**neeksec**\n\nSuggest to keep the original judging.\n\n>> Fee skirting where pool manager directly fund the pool without paying the fees\n>\n> Fee bypass is only acceptable for pool managers funding pools, NOT just anybody.\n\nIt's acceptable for anybody. If it's not, pool managers can use another EOA to do the fee skirting which easily voids this contest rule.\n\n**nevillehuang**\n\nWhile i respect your point, based on contest READ.ME, only pool managers can bypass fees. Unless it is intended protocol functionality to allow anyone other than pool manager to bypass fees, some sort of check is required. (I.e. minimum fee amount check)\n\n**Evert0x**\n\nPlanning to accept escalation make issue medium together with listed duplicates.\n\n> It's acceptable for anybody\n\nIt's clear that it is NOT an acceptable risk for anybody. It's only an acceptable risk for the pool manager role.\n\n> **Please list any known issues/acceptable risks that should not result in a valid finding.**\n> Fee skirting where pool manager directly fund the pool without paying the fees\n\nSays pool manager, not anybody.\n\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [nevillehuang](https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/198/#issuecomment-1763182087): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/109",
  "Code": [
    {
      "filename": "contracts/core/Allo.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport \"solady/auth/Ownable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n// Interfaces\nimport \"./interfaces/IAllo.sol\";\n\n// Internal Libraries\nimport {Clone} from \"./libraries/Clone.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\nimport \"./libraries/Native.sol\";\nimport {Transfer} from \"./libraries/Transfer.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Allo\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice This contract is used to create & manage pools as well as manage the protocol.\n/// @dev The contract must be initialized with the 'initialize()' function.\ncontract Allo is\n    IAllo,\n    Native,\n    Transfer,\n    Initializable,\n    Ownable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable,\n    Errors\n{\n    // ==========================\n    // === Storage Variables ====\n    // ==========================\n\n    /// @notice Percentage that is used to calculate the fee Allo takes from each pool when funded\n    ///         and is deducted when a pool is funded. So if you want to fund a round with 1000 DAI and the fee\n    ///         percentage is 1e17 (10%), then 100 DAI will be deducted from the 1000 DAI and the pool will be\n    ///         funded with 900 DAI. The fee is then sent to the treasury address.\n    /// @dev How the percentage is represented in our contracts: 1e18 = 100%, 1e17 = 10%, 1e16 = 1%, 1e15 = 0.1%\n    uint256 private percentFee;\n\n    /// @notice Fee Allo charges for all pools on creation\n    /// @dev This is different from the 'percentFee' in that this is a flat fee and not a percentage. So if you want to create a pool\n    ///      with a base fee of 100 DAI, then you would pass 100 DAI to the 'createPool()' function and the pool would be created\n    ///      with 100 DAI less than the amount you passed to the function. The base fee is sent to the treasury address.\n    uint256 internal baseFee;\n\n    /// @notice Incremental index to track the pools created\n    uint256 private _poolIndex;\n\n    /// @notice Allo treasury\n    address payable private treasury;\n\n    /// @notice Registry contract\n    IRegistry private registry;\n\n    /// @notice Maps the `msg.sender` to a `nonce` to prevent duplicates\n    /// @dev 'msg.sender' -> 'nonce' for cloning strategies\n    mapping(address => uint256) private _nonces;\n\n    /// @notice Maps the pool ID to the pool details\n    /// @dev 'Pool.id' -> 'Pool'\n    mapping(uint256 => Pool) private pools;\n\n    /// @notice Returns a bool for whether a strategy is cloneable or not using the strategy address as the key\n    /// @dev Strategy.address -> bool\n    mapping(address => bool) private cloneableStrategies;\n\n    // ====================================\n    // =========== Initializer =============\n    // ====================================\n\n    /// @notice Initializes the contract after an upgrade\n    /// @dev During upgrade -> a higher version should be passed to reinitializer\n    /// @param _owner The owner of allo\n    /// @param _registry The address of the registry\n    /// @param _treasury The address of the treasury\n    /// @param _percentFee The percentage fee\n    /// @param _baseFee The base fee\n    function initialize(\n        address _owner,\n        address _registry,\n        address payable _treasury,\n        uint256 _percentFee,\n        uint256 _baseFee\n    ) external reinitializer(1) {\n        // Initialize the owner using Solady ownable library\n        _initializeOwner(_owner);\n\n        // Set the address of the registry\n        _updateRegistry(_registry);\n\n        // Set the address of the treasury\n        _updateTreasury(_treasury);\n\n        // Set the fee percentage\n        _updatePercentFee(_percentFee);\n\n        // Set the base fee\n        _updateBaseFee(_baseFee);\n    }\n\n    // ====================================\n    // =========== Modifier ===============\n    // ====================================\n\n    // Both modifiers below are using OpenZeppelin's AccessControl.sol with custom roles under the hood\n\n    /// @notice Reverts UNAUTHORIZED() if the caller is not a pool manager\n    /// @param _poolId The pool id\n    modifier onlyPoolManager(uint256 _poolId) {\n        _checkOnlyPoolManager(_poolId);\n        _;\n    }\n\n    /// @notice Reverts UNAUTHORIZED() if the caller is not a pool admin\n    /// @param _poolId The pool id\n    modifier onlyPoolAdmin(uint256 _poolId) {\n        _checkOnlyPoolAdmin(_poolId);\n        _;\n    }\n\n    //  ====================================\n    //  ==== External/Public Functions =====\n    //  ====================================\n\n    /// @notice Creates a new pool (with a custom strategy)\n    /// @dev 'msg.sender' must be a member or owner of a profile to create a pool with or without a custom strategy, The encoded data\n    ///      will be specific to a given strategy requirements, reference the strategy implementation of 'initialize()'. The strategy\n    ///      address passed must not be a cloneable strategy. The strategy address passed must not be the zero address. 'msg.sender' must\n    ///      be a member or owner of the profile id passed as '_profileId'.\n    /// @param _profileId The 'profileId' of the registry profile, used to check if 'msg.sender' is a member or owner of the profile\n    /// @param _strategy The address of the deployed custom strategy\n    /// @param _initStrategyData The data to initialize the strategy\n    /// @param _token The address of the token you want to use in your pool\n    /// @param _amount The amount of the token you want to deposit into the pool on initialization\n    /// @param _metadata The 'Metadata' of the pool, this uses our 'Meatdata.sol' struct (consistent throughout the protocol)\n    /// @param _managers The managers of the pool, and can be added/removed later by the pool admin\n    /// @return poolId The ID of the pool\n    function createPoolWithCustomStrategy(\n        bytes32 _profileId,\n        address _strategy,\n        bytes memory _initStrategyData,\n        address _token,\n        uint256 _amount,\n        Metadata memory _metadata,\n        address[] memory _managers\n    ) external payable returns (uint256 poolId) {\n        // Revert if the strategy address passed is the zero address with 'ZERO_ADDRESS()'\n        if (_strategy == address(0)) revert ZERO_ADDRESS();\n\n        // Revert if we already have this strategy in our cloneable mapping with 'IS_APPROVED_STRATEGY()' (only non-cloneable strategies can be used)\n        if (_isCloneableStrategy(_strategy)) revert IS_APPROVED_STRATEGY();\n\n        // Call the internal '_createPool()' function and return the pool ID\n        return _createPool(_profileId, IStrategy(_strategy), _initStrategyData, _token, _amount, _metadata, _managers);\n    }\n\n    /// @notice Creates a new pool (by cloning a cloneable strategies).\n    /// @dev 'msg.sender' must be owner or member of the profile id passed as '_profileId'.\n    /// @param _profileId The ID of the registry profile, used to check if 'msg.sender' is a member or owner of the profile\n    /// @param _strategy The address of the strategy contract the pool will use.\n    /// @param _initStrategyData The data to initialize the strategy\n    /// @param _token The address of the token\n    /// @param _amount The amount of the token\n    /// @param _metadata The metadata of the pool\n    /// @param _managers The managers of the pool\n    /// @custom:initstrategydata The encoded data will be specific to a given strategy requirements,\n    ///    reference the strategy implementation of 'initialize()'\n    function createPool(\n        bytes32 _profileId,\n        address _strategy,\n        bytes memory _initStrategyData,\n        address _token,\n        uint256 _amount,\n        Metadata memory _metadata,\n        address[] memory _managers\n    ) external payable nonReentrant returns (uint256 poolId) {\n        if (!_isCloneableStrategy(_strategy)) {\n            revert NOT_APPROVED_STRATEGY();\n        }\n\n        // Returns the created pool ID\n        return _createPool(\n            _profileId,\n            IStrategy(Clone.createClone(_strategy, _nonces[msg.sender]++)),\n            _initStrategyData,\n            _token,\n            _amount,\n            _metadata,\n            _managers\n        );\n    }\n\n    /// @notice Update pool metadata\n    /// @dev 'msg.sender' must be a pool manager. Emits 'PoolMetadataUpdated()' event.\n    /// @param _poolId ID of the pool\n    /// @param _metadata The new metadata of the pool\n    function updatePoolMetadata(uint256 _poolId, Metadata memory _metadata) external onlyPoolManager(_poolId) {\n        Pool storage pool = pools[_poolId];\n        pool.metadata = _metadata;\n\n        emit PoolMetadataUpdated(_poolId, _metadata);\n    }\n\n    /// @notice Updates the registry address.\n    /// @dev Use this to update the registry address. 'msg.sender' must be Allo owner.\n    /// @param _registry The new registry address\n    function updateRegistry(address _registry) external onlyOwner {\n        _updateRegistry(_registry);\n    }\n\n    /// @notice Updates the treasury address.\n    /// @dev Use this to update the treasury address. 'msg.sender' must be Allo owner.\n    /// @param _treasury The new treasury address\n    function updateTreasury(address payable _treasury) external onlyOwner {\n        _updateTreasury(_treasury);\n    }\n\n    /// @notice Updates the fee percentage.\n    /// @dev Use this to update the fee percentage. 'msg.sender' must be Allo owner.\n    /// @param _percentFee The new fee\n    function updatePercentFee(uint256 _percentFee) external onlyOwner {\n        _updatePercentFee(_percentFee);\n    }\n\n    /// @notice Updates the base fee.\n    /// @dev Use this to update the base fee. 'msg.sender' must be Allo owner.\n    /// @param _baseFee The new base fee\n    function updateBaseFee(uint256 _baseFee) external onlyOwner {\n        _updateBaseFee(_baseFee);\n    }\n\n    /// @notice Add a strategy to the allowlist.\n    /// @dev Emits the 'StrategyApproved()' event. 'msg.sender' must be Allo owner.\n    /// @param _strategy The address of the strategy\n    function addToCloneableStrategies(address _strategy) external onlyOwner {\n        if (_strategy == address(0)) revert ZERO_ADDRESS();\n\n        cloneableStrategies[_strategy] = true;\n        emit StrategyApproved(_strategy);\n    }\n\n    /// @notice Remove a strategy from the allowlist\n    /// @dev Emits 'StrategyRemoved()' event. 'msg.sender must be Allo owner.\n    /// @param _strategy The address of the strategy\n    function removeFromCloneableStrategies(address _strategy) external onlyOwner {\n        // Set the strategy to false in the cloneableStrategies mapping\n        cloneableStrategies[_strategy] = false;\n\n        // Emit the StrategyRemoved event\n        emit StrategyRemoved(_strategy);\n    }\n\n    /// @notice Add a pool manager\n    /// @dev Emits 'RoleGranted()' event. 'msg.sender' must be a pool admin.\n    /// @param _poolId ID of the pool\n    /// @param _manager The address to add\n    function addPoolManager(uint256 _poolId, address _manager) external onlyPoolAdmin(_poolId) {\n        // Reverts if the address is the zero address with 'ZERO_ADDRESS()'\n        if (_manager == address(0)) revert ZERO_ADDRESS();\n\n        // Grants the pool manager role to the '_manager' address\n        _grantRole(pools[_poolId].managerRole, _manager);\n    }\n\n    /// @notice Remove a pool manager\n    /// @dev Emits 'RoleRevoked()' event. 'msg.sender' must be a pool admin.\n    /// @param _poolId ID of the pool\n    /// @param _manager The address to remove\n    function removePoolManager(uint256 _poolId, address _manager) external onlyPoolAdmin(_poolId) {\n        _revokeRole(pools[_poolId].managerRole, _manager);\n    }\n\n    /// @notice Transfer the funds recovered  to the recipient\n    /// @dev 'msg.sender' must be Allo owner\n    /// @param _token The token to transfer\n    /// @param _recipient The recipient\n    function recoverFunds(address _token, address _recipient) external onlyOwner {\n        // Get the amount of the token to transfer, which is always the entire balance of the contract address\n        uint256 amount = _token == NATIVE ? address(this).balance : IERC20Upgradeable(_token).balanceOf(address(this));\n\n        // Transfer the amount to the recipient (pool owner)\n        _transferAmount(_token, _recipient, amount);\n    }\n\n    // ====================================\n    // ======= Strategy Functions =========\n    // ====================================\n\n    /// @notice Passes _data through to the strategy for that pool.\n    /// @dev The encoded data will be specific to a given strategy requirements, reference the strategy\n    ///      implementation of registerRecipient().\n    /// @param _poolId ID of the pool\n    /// @param _data Encoded data unique to a strategy that registerRecipient() requires\n    /// @return recipientId The recipient ID that has been registered\n    function registerRecipient(uint256 _poolId, bytes memory _data) external payable nonReentrant returns (address) {\n        // Return the recipientId (address) from the strategy\n        return pools[_poolId].strategy.registerRecipient{value: msg.value}(_data, msg.sender);\n    }\n\n    /// @notice Register multiple recipients to multiple pools.\n    /// @dev Returns the 'recipientIds' from the strategy that have been registered from calling this function.\n    ///      Encoded data unique to a strategy that registerRecipient() requires. Encoded '_data' length must match\n    ///      '_poolIds' length or this will revert with MISMATCH(). Other requirements will be determined by the strategy.\n    /// @param _poolIds ID's of the pools\n    /// @param _data An array of encoded data unique to a strategy that registerRecipient() requires.\n    /// @return recipientIds The recipient IDs that have been registered\n    function batchRegisterRecipient(uint256[] memory _poolIds, bytes[] memory _data)\n        external\n        nonReentrant\n        returns (address[] memory recipientIds)\n    {\n        uint256 poolIdLength = _poolIds.length;\n        recipientIds = new address[](poolIdLength);\n\n        if (poolIdLength != _data.length) revert MISMATCH();\n\n        // Loop through the '_poolIds' & '_data' and call the 'strategy.registerRecipient()' function\n        for (uint256 i; i < poolIdLength;) {\n            recipientIds[i] = pools[_poolIds[i]].strategy.registerRecipient(_data[i], msg.sender);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Return the recipientIds that have been registered\n        return recipientIds;\n    }\n\n    /// @notice Fund a pool.\n    /// @dev Anyone can fund a pool and call this function.\n    /// @param _poolId ID of the pool\n    /// @param _amount The amount to be deposited into the pool\n    function fundPool(uint256 _poolId, uint256 _amount) external payable nonReentrant {\n        // if amount is 0, revert with 'NOT_ENOUGH_FUNDS()' error\n        if (_amount == 0) revert NOT_ENOUGH_FUNDS();\n\n        Pool memory pool = pools[_poolId];\n        if (pool.token == NATIVE && _amount != msg.value) revert NOT_ENOUGH_FUNDS();\n\n        // Call the internal fundPool() function\n        _fundPool(_amount, _poolId, pool.strategy);\n    }\n\n    /// @notice Allocate to a recipient or multiple recipients.\n    /// @dev The encoded data will be specific to a given strategy requirements, reference the strategy\n    ///      implementation of allocate().\n    /// @param _poolId ID of the pool\n    /// @param _data Encoded data unique to the strategy for that pool\n    function allocate(uint256 _poolId, bytes memory _data) external payable nonReentrant {\n        _allocate(_poolId, _data);\n    }\n\n    /// @notice Allocate to multiple pools\n    /// @dev The encoded data will be specific to a given strategy requirements, reference the strategy\n    ///      implementation of allocate(). Please note that this is not a 'payable' function, so if you\n    ///      want to send funds to the strategy, you must send the funds using 'fundPool()'.\n    /// @param _poolIds IDs of the pools\n    /// @param _datas encoded data unique to the strategy for that pool\n    function batchAllocate(uint256[] calldata _poolIds, bytes[] memory _datas) external nonReentrant {\n        uint256 numPools = _poolIds.length;\n\n        // Reverts if the length of _poolIds does not match the length of _datas with 'MISMATCH()' error\n        if (numPools != _datas.length) revert MISMATCH();\n\n        // Loop through the _poolIds & _datas and call the internal _allocate() function\n        for (uint256 i; i < numPools;) {\n            _allocate(_poolIds[i], _datas[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Distribute to a recipient or multiple recipients.\n    /// @dev The encoded data will be specific to a given strategy requirements, reference the strategy\n    ///      implementation of 'strategy.distribute()'.\n    /// @param _poolId ID of the pool\n    /// @param _recipientIds Ids of the recipients of the distribution\n    /// @param _data Encoded data unique to the strategy\n    function distribute(uint256 _poolId, address[] memory _recipientIds, bytes memory _data) external nonReentrant {\n        pools[_poolId].strategy.distribute(_recipientIds, _data, msg.sender);\n    }\n\n    /// ====================================\n    /// ======= Internal Functions =========\n    /// ====================================\n\n    /// @notice Internal function to check is caller is pool manager\n    /// @param _poolId The pool id\n    function _checkOnlyPoolManager(uint256 _poolId) internal view {\n        if (!_isPoolManager(_poolId, msg.sender)) revert UNAUTHORIZED();\n    }\n\n    /// @notice Internal function to check is caller is pool admin\n    /// @param _poolId The pool id\n    function _checkOnlyPoolAdmin(uint256 _poolId) internal view {\n        if (!_isPoolAdmin(_poolId, msg.sender)) revert UNAUTHORIZED();\n    }\n\n    /// @notice Creates a new pool.\n    /// @dev This is an internal function that is called by the 'createPool()' & 'createPoolWithCustomStrategy()' functions\n    ///      It is used to create a new pool and is called by both functions. The 'msg.sender' must be a member or owner of\n    ///      a profile to create a pool.\n    /// @param _profileId The ID of the profile of for pool creator in the registry\n    /// @param _strategy The address of strategy\n    /// @param _initStrategyData The data to initialize the strategy\n    /// @param _token The address of the token that the pool is denominated in\n    /// @param _amount The amount of the token to be deposited into the pool\n    /// @param _metadata The 'Metadata' of the pool\n    /// @param _managers The managers of the pool\n    /// @return poolId The ID of the pool\n    function _createPool(\n        bytes32 _profileId,\n        IStrategy _strategy,\n        bytes memory _initStrategyData,\n        address _token,\n        uint256 _amount,\n        Metadata memory _metadata,\n        address[] memory _managers\n    ) internal returns (uint256 poolId) {\n        if (!registry.isOwnerOrMemberOfProfile(_profileId, msg.sender)) revert UNAUTHORIZED();\n\n        poolId = ++_poolIndex;\n\n        // Generate the manager & admin roles for the pool (this is the way we do this throughout the protocol for consistency)\n        bytes32 POOL_MANAGER_ROLE = bytes32(poolId);\n        bytes32 POOL_ADMIN_ROLE = keccak256(abi.encodePacked(poolId, \"admin\"));\n\n        // Create the Pool instance\n        Pool memory pool = Pool({\n            profileId: _profileId,\n            strategy: _strategy,\n            metadata: _metadata,\n            token: _token,\n            managerRole: POOL_MANAGER_ROLE,\n            adminRole: POOL_ADMIN_ROLE\n        });\n\n        // Add the pool to the mapping of created pools\n        pools[poolId] = pool;\n\n        // Grant admin roles to the pool creator\n        _grantRole(POOL_ADMIN_ROLE, msg.sender);\n\n        // Set admin role for POOL_MANAGER_ROLE\n        _setRoleAdmin(POOL_MANAGER_ROLE, POOL_ADMIN_ROLE);\n\n        // initialize strategies\n        // Initialization is expected to revert when invoked more than once with 'ALREADY_INITIALIZED()' error\n        _strategy.initialize(poolId, _initStrategyData);\n\n        if (_strategy.getPoolId() != poolId || address(_strategy.getAllo()) != address(this)) revert MISMATCH();\n\n        // grant pool managers roles\n        uint256 managersLength = _managers.length;\n        for (uint256 i; i < managersLength;) {\n            address manager = _managers[i];\n            if (manager == address(0)) revert ZERO_ADDRESS();\n\n            _grantRole(POOL_MANAGER_ROLE, manager);\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (baseFee > 0) {\n            // To prevent paying the baseFee from the Allo contract's balance\n            // If _token is NATIVE, then baseFee + _amount should be > than msg.value.\n            // If _token is not NATIVE, then baseFee should be > than msg.value.\n            if ((_token == NATIVE && (baseFee + _amount != msg.value)) || (_token != NATIVE && baseFee != msg.value)) {\n                revert NOT_ENOUGH_FUNDS();\n            }\n            _transferAmount(NATIVE, treasury, baseFee);\n            emit BaseFeePaid(poolId, baseFee);\n        }\n\n        if (_amount > 0) {\n            _fundPool(_amount, poolId, _strategy);\n        }\n\n        emit PoolCreated(poolId, _profileId, _strategy, _token, _amount, _metadata);\n    }\n\n    /// @notice Allocate to recipient(s).\n    /// @dev Passes '_data' & 'msg.sender' through to the strategy for that pool.\n    ///      This is an internal function that is called by the 'allocate()' & 'batchAllocate()' functions.\n    /// @param _poolId ID of the pool\n    /// @param _data Encoded data unique to the strategy for that pool\n    function _allocate(uint256 _poolId, bytes memory _data) internal {\n        pools[_poolId].strategy.allocate{value: msg.value}(_data, msg.sender);\n    }\n\n    /// @notice Fund a pool.\n    /// @dev Deducts the fee and transfers the amount to the distribution strategy.\n    ///      Emits a 'PoolFunded' event.\n    /// @param _amount The amount to transfer\n    /// @param _poolId The 'poolId' for the pool you are funding\n    /// @param _strategy The address of the strategy\n    function _fundPool(uint256 _amount, uint256 _poolId, IStrategy _strategy) internal {\n        uint256 feeAmount;\n        uint256 amountAfterFee = _amount;\n\n        Pool storage pool = pools[_poolId];\n        address _token = pool.token;\n\n        if (percentFee > 0) {\n            feeAmount = (_amount * percentFee) / getFeeDenominator();\n            amountAfterFee -= feeAmount;\n\n            if (feeAmount + amountAfterFee != _amount) revert INVALID();\n\n            if (_token == NATIVE) {\n                _transferAmountFrom(_token, TransferData({from: msg.sender, to: treasury, amount: feeAmount}));\n            } else {\n                uint256 balanceBeforeFee = _getBalance(_token, treasury);\n                _transferAmountFrom(_token, TransferData({from: msg.sender, to: treasury, amount: feeAmount}));\n                uint256 balanceAfterFee = _getBalance(_token, treasury);\n                // Track actual fee paid to account for fee on ERC20 token transfers\n                feeAmount = balanceAfterFee - balanceBeforeFee;\n            }\n        }\n\n        if (_token == NATIVE) {\n            _transferAmountFrom(\n                _token, TransferData({from: msg.sender, to: address(_strategy), amount: amountAfterFee})\n            );\n        } else {\n            uint256 balanceBeforeFundingPool = _getBalance(_token, address(_strategy));\n            _transferAmountFrom(\n                _token, TransferData({from: msg.sender, to: address(_strategy), amount: amountAfterFee})\n            );\n            uint256 balanceAfterFundingPool = _getBalance(_token, address(_strategy));\n            // Track actual fee paid to account for fee on ERC20 token transfers\n            amountAfterFee = balanceAfterFundingPool - balanceBeforeFundingPool;\n        }\n\n        _strategy.increasePoolAmount(amountAfterFee);\n\n        emit PoolFunded(_poolId, amountAfterFee, feeAmount);\n    }\n\n    /// @notice Checks if the strategy is an approved cloneable strategy.\n    /// @dev Internal function used by createPoolwithCustomStrategy and createPool to\n    ///      determine if a strategy is in the cloneable strategy allow list.\n    /// @param _strategy The address of the strategy\n    /// @return This will return 'true' if the strategy is cloneable, otherwise 'false'\n    function _isCloneableStrategy(address _strategy) internal view returns (bool) {\n        return cloneableStrategies[_strategy];\n    }\n\n    /// @notice Checks if the address is a pool admin\n    /// @dev Internal function used to determine if an address is a pool admin\n    /// @param _poolId The ID of the pool\n    /// @param _address The address to check\n    /// @return This will return 'true' if the address is a pool admin, otherwise 'false'\n    function _isPoolAdmin(uint256 _poolId, address _address) internal view returns (bool) {\n        return hasRole(pools[_poolId].adminRole, _address);\n    }\n\n    /// @notice Checks if the address is a pool manager\n    /// @dev Internal function used to determine if an address is a pool manager\n    /// @param _poolId The ID of the pool\n    /// @param _address The address to check\n    /// @return This will return 'true' if the address is a pool manager, otherwise 'false'\n    function _isPoolManager(uint256 _poolId, address _address) internal view returns (bool) {\n        return hasRole(pools[_poolId].managerRole, _address) || _isPoolAdmin(_poolId, _address);\n    }\n\n    /// @notice Updates the registry address\n    /// @dev Internal function used to update the registry address.\n    ///      Emits a RegistryUpdated event.\n    /// @param _registry The new registry address\n    function _updateRegistry(address _registry) internal {\n        if (_registry == address(0)) revert ZERO_ADDRESS();\n\n        registry = IRegistry(_registry);\n        emit RegistryUpdated(_registry);\n    }\n\n    /// @notice Updates the treasury address\n    /// @dev Internal function used to update the treasury address.\n    ///      Emits a TreasuryUpdated event.\n    /// @param _treasury The new treasury address\n    function _updateTreasury(address payable _treasury) internal {\n        if (_treasury == address(0)) revert ZERO_ADDRESS();\n\n        treasury = _treasury;\n        emit TreasuryUpdated(treasury);\n    }\n\n    /// @notice Updates the fee percentage\n    /// @dev Internal function used to update the percentage fee.\n    ///      Emits a PercentFeeUpdated event.\n    /// @param _percentFee The new fee\n    function _updatePercentFee(uint256 _percentFee) internal {\n        if (_percentFee > 1e18) revert INVALID_FEE();\n\n        percentFee = _percentFee;\n\n        emit PercentFeeUpdated(percentFee);\n    }\n\n    /// @notice Updates the base fee\n    /// @dev Internal function used to update the base fee.\n    ///      Emits a BaseFeeUpdated event.\n    /// @param _baseFee The new base fee\n    function _updateBaseFee(uint256 _baseFee) internal {\n        baseFee = _baseFee;\n\n        emit BaseFeeUpdated(baseFee);\n    }\n\n    // =========================\n    // ==== View Functions =====\n    // =========================\n\n    /// @notice Getter for the fee denominator\n    /// @return FEE_DENOMINATOR The fee denominator is (1e18) which represents 100%\n    function getFeeDenominator() public pure returns (uint256 FEE_DENOMINATOR) {\n        return 1e18;\n    }\n\n    /// @notice Checks if the address is a pool admin.\n    /// @param _poolId The ID of the pool\n    /// @param _address The address to check\n    /// @return 'true' if the address is a pool admin, otherwise 'false'\n    function isPoolAdmin(uint256 _poolId, address _address) external view returns (bool) {\n        return _isPoolAdmin(_poolId, _address);\n    }\n\n    /// @notice Checks if the address is a pool manager\n    /// @param _poolId The ID of the pool\n    /// @param _address The address to check\n    /// @return 'true' if the address is a pool manager, otherwise 'false'\n    function isPoolManager(uint256 _poolId, address _address) external view returns (bool) {\n        return _isPoolManager(_poolId, _address);\n    }\n\n    /// @notice Getter for the strategy.\n    /// @param _poolId The ID of the pool\n    /// @return The address of the strategy\n    function getStrategy(uint256 _poolId) external view returns (address) {\n        return address(pools[_poolId].strategy);\n    }\n\n    /// @notice Getter for fee percentage.\n    /// @return The fee percentage (1e18 = 100%)\n    function getPercentFee() external view returns (uint256) {\n        return percentFee;\n    }\n\n    /// @notice Getter for base fee.\n    /// @return The base fee\n    function getBaseFee() external view returns (uint256) {\n        return baseFee;\n    }\n\n    /// @notice Getter for treasury address.\n    /// @return The treasury address\n    function getTreasury() external view returns (address payable) {\n        return treasury;\n    }\n\n    /// @notice Getter for registry.\n    /// @return The registry address\n    function getRegistry() external view returns (IRegistry) {\n        return registry;\n    }\n\n    /// @notice Getter for if strategy is cloneable.\n    /// @param _strategy The address of the strategy\n    /// @return 'true' if the strategy is cloneable, otherwise 'false'\n    function isCloneableStrategy(address _strategy) external view returns (bool) {\n        return _isCloneableStrategy(_strategy);\n    }\n\n    /// @notice Getter for the 'Pool'.\n    /// @param _poolId The ID of the pool\n    /// @return The 'Pool' struct\n    function getPool(uint256 _poolId) external view returns (Pool memory) {\n        return pools[_poolId];\n    }\n}"
    }
  ]
}