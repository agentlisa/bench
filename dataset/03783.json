{
  "Title": "[L04] Implementation functions sparsed into different contracts",
  "Content": "The [`Implementation` contract](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/common/Implementation.sol#L27) declares and implements the logic to [get the respective logic’s implementation and the admin’s address](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/common/Implementation.sol#L47-L85).\n\n\nHowever, there are some function declarations that lack its definition, such as [setting the registry’s address](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/common/Implementation.sol#L82) or [the owner of the contract](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/common/Implementation.sol#L97).\n\n\nThese two functions are declared in the [`StabilizerState`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/stabilizer/StabilizerState.sol#L334) and in the [`ReserveState`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveState.sol#L263) contracts, and both have the same functionality.\n\n\nWhether this is meant to be consistent to keep all state variables in the respective contracts or not, having the implementation of a function in different contracts without a proper reason produces a more complex code and lower its readability.\n\n\nTo improve the code’s readability and factorization, consider defining both functions in the `Implementation` contract.\n\n\n***Update**: Fixed in [pull request 20](https://github.com/emptysetsquad/emptyset/pull/20/commits/eec916285dd8cf3b3376d6efed1376259c840a11). The `IImplementation` interface has been removed, while the `Implementation` contract has been refactored to host definition and implementation of the getters and setters of the `owner`, `registry` and `notEntered` parameters. The `Implementation` contract does that by an unstructured pattern of choosing specific slots to store and set the variables. Since the `ReserveAdmin` and the `StabilizerAdmin` contracts are already extending from the `Implementation`, the `StabilizerAccessors` and `ReserveAccessors` contracts (that extends from those) have been refactored too.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/src/common/Implementation.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces.sol\";\nimport \"./IImplementation.sol\";\n\n/**\n * @title Implementation\n * @notice Common functions and accessors across upgradeable, ownable contracts\n */\ncontract Implementation is IImplementation {\n\n    /**\n     * @dev Storage slot with the address of the current implementation\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n     */\n    bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Storage slot with the admin of the contract\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1\n     */\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    // UPGRADEABILITY\n\n    /**\n     * @notice Returns the current implementation\n     * @return Address of the current implementation\n     */\n    function implementation() external view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @notice Returns the current proxy admin contract\n     * @return Address of the current proxy admin contract\n     */\n    function admin() external view returns (address adm) {\n        bytes32 slot = ADMIN_SLOT;\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    // REGISTRY\n\n    /**\n     * @notice Updates the registry contract\n     * @dev Owner only - governance hook\n     *      If registry is already set, the new registry's timelock must match the current's\n     * @param newRegistry New registry contract\n     */\n    function setRegistry(address newRegistry) external onlyOwner {\n        IRegistry registry = registry();\n\n        require(newRegistry != address(0), \"Implementation: zero address\");\n        require(\n            address(registry) == address(0) || IRegistry(newRegistry).timelock() == registry.timelock(),\n            \"Implementation: timelocks must match\"\n        );\n\n        _setRegistry(newRegistry);\n\n        emit RegistryUpdate(newRegistry);\n    }\n\n    // OWNER\n\n    /**\n     * @notice Takes ownership over a contract if none has been set yet\n     * @dev Needs to be called initialize ownership after deployment\n     *      Ensure that this has been properly set before using the protocol\n     */\n    function takeOwnership() external {\n        require(owner() == address(0), \"Implementation: already initialized\");\n\n        _setOwner(msg.sender);\n\n        emit OwnerUpdate(msg.sender);\n    }\n\n    /**\n     * @notice Updates the owner contract\n     * @dev Owner only - governance hook\n     * @param newOwner New owner contract\n     */\n    function setOwner(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Implementation: zero address\");\n\n        _setOwner(newOwner);\n\n        emit OwnerUpdate(newOwner);\n    }\n\n    /**\n     * @dev Only allow when the caller is the owner address\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner(), \"Implementation: not owner\");\n\n        _;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/src/common/Implementation.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces.sol\";\nimport \"./IImplementation.sol\";\n\n/**\n * @title Implementation\n * @notice Common functions and accessors across upgradeable, ownable contracts\n */\ncontract Implementation is IImplementation {\n\n    /**\n     * @dev Storage slot with the address of the current implementation\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n     */\n    bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Storage slot with the admin of the contract\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1\n     */\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    // UPGRADEABILITY\n\n    /**\n     * @notice Returns the current implementation\n     * @return Address of the current implementation\n     */\n    function implementation() external view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @notice Returns the current proxy admin contract\n     * @return Address of the current proxy admin contract\n     */\n    function admin() external view returns (address adm) {\n        bytes32 slot = ADMIN_SLOT;\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    // REGISTRY\n\n    /**\n     * @notice Updates the registry contract\n     * @dev Owner only - governance hook\n     *      If registry is already set, the new registry's timelock must match the current's\n     * @param newRegistry New registry contract\n     */\n    function setRegistry(address newRegistry) external onlyOwner {\n        IRegistry registry = registry();\n\n        require(newRegistry != address(0), \"Implementation: zero address\");\n        require(\n            address(registry) == address(0) || IRegistry(newRegistry).timelock() == registry.timelock(),\n            \"Implementation: timelocks must match\"\n        );\n\n        _setRegistry(newRegistry);\n\n        emit RegistryUpdate(newRegistry);\n    }\n\n    // OWNER\n\n    /**\n     * @notice Takes ownership over a contract if none has been set yet\n     * @dev Needs to be called initialize ownership after deployment\n     *      Ensure that this has been properly set before using the protocol\n     */\n    function takeOwnership() external {\n        require(owner() == address(0), \"Implementation: already initialized\");\n\n        _setOwner(msg.sender);\n\n        emit OwnerUpdate(msg.sender);\n    }\n\n    /**\n     * @notice Updates the owner contract\n     * @dev Owner only - governance hook\n     * @param newOwner New owner contract\n     */\n    function setOwner(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Implementation: zero address\");\n\n        _setOwner(newOwner);\n\n        emit OwnerUpdate(newOwner);\n    }\n\n    /**\n     * @dev Only allow when the caller is the owner address\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner(), \"Implementation: not owner\");\n\n        _;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/src/stabilizer/StabilizerState.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/Decimal.sol\";\nimport \"../Interfaces.sol\";\nimport \"../common/IImplementation.sol\";\nimport \"../common/Implementation.sol\";\nimport \"../common/Implementation.sol\";\n\n/**\n * @title StabilizerTypes\n * @notice Contains all stabilizer state structs\n */\ncontract StabilizerTypes {\n\n    /**\n     * @notice Stores state for the sESD ERC20 implementation\n     */\n    struct Token {\n        /**\n         * @notice account to sESD balance mapping\n         */\n        mapping (address => uint256) balances;\n\n        /**\n         * @notice sESD allowance data\n         */\n        mapping (address => mapping (address => uint256)) allowances;\n\n        /**\n         * @notice total supply of sESD\n         */\n        uint256 totalSupply;\n    }\n\n    /**\n     * @notice Stores state for the EMA oracle\n     */\n    struct Oracle {\n        /**\n         * @notice Exponential Moving Average ESD price\n         */\n        Decimal.D256 ema;\n        /**\n         * @notice Rate of decay for the EMA algorithm\n         */\n        Decimal.D256 decayRate;\n        /**\n         * @notice Maximum ratio that the EMA is allowed to be updated in a single settlement\n         */\n        Decimal.D256 maxAlpha;\n    }\n\n    /**\n     * @notice Stores state for the entire stabilizer\n     */\n    struct State {\n        /**\n         * @notice Common state for upgradeable, ownable, implementation contracts\n         */\n        IImplementation.ImplementationState implementation;\n\n        /**\n         * @notice State for the sESD ERC20 implementation\n         */\n        StabilizerTypes.Token token;\n\n        /**\n         * @notice State for the EMA oracle\n         */\n        StabilizerTypes.Oracle oracle;\n\n        /**\n         * @notice Parameter determining the rate at which rewards accrue\n         * @dev    Denoted as a % of totalUnderlying per day, assuming 100% off-peg (0.00 price)\n         */\n        Decimal.D256 rewardRate;\n    }\n}\n\n/**\n * @title StabilizerState\n * @notice Stabilizer state\n */\ncontract StabilizerState {\n\n    /**\n     * @notice Entirety of the stabilizer contract state\n     * @dev To upgrade state, append additional state variables at the end of this contract\n     */\n    StabilizerTypes.State internal _state;\n}\n\n/**\n * @title StabilizerAdmin\n * @notice Stabilizer admin state accessor helpers\n */\ncontract StabilizerAdmin is StabilizerState, Implementation {\n\n    /**\n     * @notice Cap decay at a 100% per day rate\n     */\n    uint256 private constant DECAY_RATE_CAP = 1e18;\n\n    /**\n     * @notice Alpha must by capped no higher than a 100% per day rate\n     */\n    uint256 private constant MAX_ALPHA_CAP = 1e18;\n\n    /**\n     * @notice Cap effective rate at (1.00 - price) * 2.5% per day\n     * @dev Corresponds to 31.5% APY at 0.97 price\n     */\n    uint256 private constant REWARD_RATE_CAP = 0.025e18;\n\n    /**\n     * @notice Emitted when {decayRate} is updated with `newDecayRate`\n     */\n    event DecayRateUpdate(uint256 newDecayRate);\n\n    /**\n     * @notice Emitted when {maxAlpha} is updated with `newMaxAlpha`\n     */\n    event MaxAlphaUpdate(uint256 newMaxAlpha);\n\n    /**\n     * @notice Emitted when {rewardRate} is updated with `newRewardRate`\n     */\n    event RewardRateUpdate(uint256 newRewardRate);\n\n    // COMPTROLLER\n\n    /**\n     * @notice Rate of decay for the EMA algorithm\n     * @return Decay rate\n     */\n    function decayRate() public view returns (Decimal.D256 memory) {\n        return _state.oracle.decayRate;\n    }\n\n    /**\n     * @notice Sets the decay rate to `newDecayRate`\n     * @dev Owner only - governance hook\n     * @param newDecayRate New decay rate\n     */\n    function setDecayRate(uint256 newDecayRate) external onlyOwner {\n        require(newDecayRate <= DECAY_RATE_CAP, \"StabilizerAdmin: too large\");\n\n        _state.oracle.decayRate = Decimal.D256({value: newDecayRate});\n\n        emit DecayRateUpdate(newDecayRate);\n    }\n\n    /**\n     * @notice Maximum ratio that the EMA is allowed to be updated in a single settlement\n     * @return Max alpha\n     */\n    function maxAlpha() public view returns (Decimal.D256 memory) {\n        return _state.oracle.maxAlpha;\n    }\n\n    /**\n     * @notice Sets the maximum alpha to `newMaxAlpha`\n     * @dev Owner only - governance hook\n     * @param newMaxAlpha New max alpha\n     */\n    function setMaxAlpha(uint256 newMaxAlpha) external onlyOwner {\n        require(newMaxAlpha <= MAX_ALPHA_CAP, \"StabilizerAdmin: too large\");\n\n        _state.oracle.maxAlpha = Decimal.D256({value: newMaxAlpha});\n\n        emit MaxAlphaUpdate(newMaxAlpha);\n    }\n\n    /**\n     * @notice Parameter determining the rate at which rewards accrue\n     * @dev    Denoted as a % of totalUnderlying per day, assuming 100% off-peg (0.00 price)\n     * @return Reward rate\n     */\n    function rewardRate() public view returns (Decimal.D256 memory) {\n        return _state.rewardRate;\n    }\n\n    /**\n     * @notice Sets the reward rate to `newRewardRate`\n     * @dev Owner only - governance hook\n     * @param newRewardRate New reward rate\n     */\n    function setRewardRate(uint256 newRewardRate) external onlyOwner {\n        require(newRewardRate <= REWARD_RATE_CAP, \"StabilizerAdmin: too large\");\n\n        _state.rewardRate = Decimal.D256({value: newRewardRate});\n\n        emit RewardRateUpdate(newRewardRate);\n    }\n}\n\n/**\n * @title StabilizerAccessors\n * @notice Reserve state accessor helpers\n */\ncontract StabilizerAccessors is IImplementation, StabilizerAdmin {\n    using SafeMath for uint256;\n    using Decimal for Decimal.D256;\n\n    // TOKEN\n\n    /**\n     * @notice Total supply of sESD tokens\n     * @return sESD total supply\n     */\n    function totalSupply() public view returns (uint256) {\n        return _state.token.totalSupply;\n    }\n\n    /**\n     * @notice The sESD balance for `account`\n     * @param account Account to retrieve balance for\n     * @return sESD balance\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _state.token.balances[account];\n    }\n\n    /**\n     * @notice The sESD allowance from `owner` for `spender`\n     * @param owner Account that is allowing\n     * @param spender Account that is being allowed\n     * @return sESD allowance\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _state.token.allowances[owner][spender];\n    }\n\n    /**\n     * @notice Transfers `amount` from `sender` to `recipient`\n     * @dev Internal only - helper\n     *      Reverts with `reason` when insufficient funds\n     * @param sender Account that is sending sESD\n     * @param recipient Account this is receiving sESD\n     * @param amount Amount of sESD that is being transferred\n     * @param reason Revert reason\n     */\n    function _transferBalance(address sender, address recipient, uint256 amount, string memory reason) internal {\n        _state.token.balances[sender] = _state.token.balances[sender].sub(amount, reason);\n        _state.token.balances[recipient] = _state.token.balances[recipient].add(amount);\n    }\n\n    /**\n     * @notice Increments the sESD balance of `account` by `amount`\n     * @dev Internal only - helper\n     * @param account Account that will receive the minted sESD\n     * @param amount Amount of sESD that is being minted\n     */\n    function _incrementBalance(address account, uint256 amount) internal {\n        _state.token.totalSupply = _state.token.totalSupply.add(amount);\n        _state.token.balances[account] = _state.token.balances[account].add(amount);\n    }\n\n    /**\n     * @notice Decrements the sESD balance of `account` by `amount`\n     * @dev Internal only - helper\n     *      Reverts with `reason` when insufficient funds\n     * @param account Account that will lose the burned sESD\n     * @param amount Amount of sESD that is being burned\n     * @param reason Revert reason\n     */\n    function _decrementBalance(address account, uint256 amount, string memory reason) internal {\n        _state.token.balances[account] = _state.token.balances[account].sub(amount, reason);\n        _state.token.totalSupply = _state.token.totalSupply.sub(amount);\n    }\n\n    /**\n     * @notice Updates the allowance from `owner` for `spender` to `amount`\n     * @dev Internal only - helper\n     * @param owner Account that is allowing\n     * @param spender Account that is being allowed\n     * @param amount Amount of sESD that is being allowed\n     */\n    function _updateAllowance(address owner, address spender, uint256 amount) internal {\n        _state.token.allowances[owner][spender] = amount;\n    }\n\n    // COMPTROLLER\n\n    /**\n     * @notice Current EMA oracle price\n     * @return EMA price\n     */\n    function ema() public view returns (Decimal.D256 memory) {\n        return _state.oracle.ema;\n    }\n\n    /**\n     * @notice Updates the EMA price\n     * @dev Internal only - helper\n     * @param newEma New EMA value\n     */\n    function _updateEma(Decimal.D256 memory newEma) internal {\n        _state.oracle.ema = newEma;\n    }\n\n    // IMPLEMENTATION\n\n    /**\n     * @notice Registry containing mappings for all protocol contracts\n     * @return Protocol registry\n     */\n    function registry() public view returns (IRegistry) {\n        return IRegistry(_state.implementation.registry);\n    }\n\n    /**\n     * @notice Updates the registry contract\n     * @dev Internal only\n     * @param newRegistry New registry contract\n     */\n    function _setRegistry(address newRegistry) internal {\n        _state.implementation.registry = newRegistry;\n    }\n\n    /**\n     * @notice Owner contract with admin permission over this contract\n     * @return Owner contract\n     */\n    function owner() public view returns (address) {\n        return _state.implementation.owner;\n    }\n\n    /**\n     * @notice Updates the owner contract\n     * @dev Internal only\n     * @param newOwner New owner contract\n     */\n    function _setOwner(address newOwner) internal {\n        _state.implementation.owner = newOwner;\n    }\n}"
    }
  ]
}