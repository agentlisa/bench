{
  "Title": "[M-22] `LendingTerm` inconsistency between debt ceiling as calculated in `borrow()` and `debtCeiling()`",
  "Content": "\nThere is an inconsistency in the calculation of the `debtCeiling` between the [`borrow()`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L394-L397) function and the [`debtCeiling()`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L270) function. This not only leads to operational discrepancies, but also impacts liquidity utilization. Specifically, the more restrictive `debtCeiling` in the `borrow()` function results in underutilized liquidity, which in turn could lead to missed profit opportunities for lenders.\n\n### Proof of Concept\n\nThere is an inconsistency in the way [`borrow()`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L394-L397) calculates a much smaller value for [`debtCeiling`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L270) than the actual [`debtCeiling()`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L270) function. This renders [this check useless](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L225-L231), since borrow prevents issuance from going even close to the actual debt ceiling.\n\n```solidity\nuint256 debtCeilingAfterDecrement = LendingTerm(gauge).debtCeiling(-int256(weight));\nrequire(issuance <= debtCeilingAfterDecrement, \"GuildToken: debt ceiling used\");\n```\n\nLet's take the parameters below to illustrate the issue and follow along the two calculations:\n\n| **Parameter** | **Value**     |\n| ---------------------- | ------------- |\n| Issuance               | 20,000  |\n| Total Borrowed Credit  | 70,000 (5k when we call borrow + 65k old loans) |\n| Total Weight           | 100,000 |\n| Gauge Weight           | 50,000 |\n| Gauge Weight Tolerance | 60% (1.2e18) |\n\n**1. `borrow()` function's calculation method:**\n\nThis function calculates the `debtCeiling` using a simpler formula:\n\n*Note: For the provided formula, please see the original submission contents [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/308).*\n\n- Applying the provided parameters (Gauge Weight: 50,000, Total Borrowed Credit: 70,000, Total Weight: 100,000, and Weight Tolerance: 1.2), the resulting `debtCeiling` is 42,000.\n\n**2. `debtCeiling()` function's calculation method:**\n\nThe formula used here is more complex so we will it break it down below:\n\n*Note: For the provided formula, please see the original submission contents [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/308).*\n\nThis method involves several intermediate steps to arrive at the `debtCeiling`. The process includes:\n\n- Calculating the tolerated gauge weight.\n- Determining the initial debt ceiling before any new borrowings.\n- Computing the remaining debt ceiling after factoring in current issuance.\n- Establishing the weight of other gauges.\n- Determining the maximum borrowable amount.\n- Adding the current issuance to the maximum borrow to get the final `debtCeiling`.\n\n**[`toleratedGaugeWeight`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L305)**\n\n*Note: For the provided formula, please see the original submission contents [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/308).*\n\n**[`debtCeilingBefore`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L307-L308)**\n\n*Note: For the provided formula, please see the original submission contents [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/308).*\n\n**[`remainingDebtCeiling`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L312)**\n\n*Note: For the provided formula, please see the original submission contents [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/308).*\n\n**[`otherGaugesWeight`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L319)**\n\n*Note: For the provided formula, please see the original submission contents [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/308).*\n\n**[`maxBorrow`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L320-L321)**\n\n*Note: For the provided formula, please see the original submission contents [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/308).*\n\n**[`debtCeiling`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L322)**\n\n*Note: For the provided formula, please see the original submission contents [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/308).*\n\nWith the same parameters, this method results in a `debtCeiling` of 75,000.\n\nThe lower `debtCeiling` set by the `borrow()` function (42,000) significantly restricts the amount that can be borrowed compared to what is actually permissible as per the `debtCeiling()` function (75,000).\n\nThis discrepancy leads to a situation where a portion of the liquidity remains unused. In a lending scenario, unused liquidity equates to lost income opportunities for lenders, as these funds are not being loaned out and thus not generating interest.\n\n### Recommended Mitigation Steps\n\nUnify the `debtCeiling` calculation method which is used across the protocol.\n\n### Assessed type\n\nError\n\n**[eswak (Ethereum Credit Guild) confirmed](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/308#issuecomment-1919016839)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/loan/LendingTerm.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {AuctionHouse} from \"@src/loan/AuctionHouse.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\n/// @notice Lending Term contract of the Ethereum Credit Guild, a base implementation of\n/// smart contract issuing CREDIT debt and escrowing collateral assets.\n/// Note that interest rate is non-compounding and the percentage is expressed per\n/// period of `YEAR` seconds.\ncontract LendingTerm is CoreRef {\n    using SafeERC20 for IERC20;\n\n    // events for the lifecycle of loans that happen in the lending term\n    /// @notice emitted when new loans are opened (mint debt to borrower, pull collateral from borrower).\n    event LoanOpen(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        address indexed borrower,\n        uint256 collateralAmount,\n        uint256 borrowAmount\n    );\n    /// @notice emitted when a loan is called.\n    event LoanCall(uint256 indexed when, bytes32 indexed loanId);\n    /// @notice emitted when a loan is closed (repay, onBid after a call, forgive).\n    enum LoanCloseType {\n        Repay,\n        Call,\n        Forgive\n    }\n    event LoanClose(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        LoanCloseType indexed closeType,\n        uint256 debtRepaid\n    );\n    /// @notice emitted when someone adds collateral to a loan\n    event LoanAddCollateral(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        address indexed borrower,\n        uint256 collateralAmount\n    );\n    /// @notice emitted when someone partially repays a loan\n    event LoanPartialRepay(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        address indexed repayer,\n        uint256 repayAmount\n    );\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @notice reference number of seconds in 1 year\n    uint256 public constant YEAR = 31557600;\n\n    /// @notice timestamp of last partial repayment for a given loanId.\n    /// during borrow(), this is initialized to the borrow timestamp, if\n    /// maxDelayBetweenPartialRepay is != 0\n    mapping(bytes32 => uint256) public lastPartialRepay;\n\n    struct Loan {\n        address borrower; // address of a loan's borrower\n        uint256 borrowTime; // the time the loan was initiated\n        uint256 borrowAmount; // initial CREDIT debt of a loan\n        uint256 borrowCreditMultiplier; // creditMultiplier when loan was opened\n        uint256 collateralAmount; // balance of collateral token provided by the borrower\n        address caller; // a caller of 0 indicates that the loan has not been called\n        uint256 callTime; // a call time of 0 indicates that the loan has not been called\n        uint256 callDebt; // the CREDIT debt when the loan was called\n        uint256 closeTime; // the time the loan was closed (repaid or call+bid or forgive)\n    }\n\n    /// @notice the list of all loans that existed or are still active.\n    /// @dev see public getLoan(loanId) getter.\n    mapping(bytes32 => Loan) internal loans;\n\n    /// @notice current number of CREDIT issued in active loans on this term\n    /// @dev this can be lower than the sum of all loan's CREDIT debts because\n    /// interests accrue and some loans might have been opened before the creditMultiplier\n    /// was last updated, resulting in higher CREDIT debt than what was originally borrowed.\n    uint256 public issuance;\n\n    struct LendingTermReferences {\n        /// @notice reference to the ProfitManager\n        address profitManager;\n        /// @notice reference to the GUILD token\n        address guildToken;\n        /// @notice reference to the auction house contract used to\n        /// sell loan collateral for CREDIT if loans are called.\n        address auctionHouse;\n        /// @notice reference to the credit minter contract\n        address creditMinter;\n        /// @notice reference to the CREDIT token\n        address creditToken;\n    }\n\n    /// @notice References to other protocol contracts (see struct for more details)\n    LendingTermReferences internal refs;\n\n    struct LendingTermParams {\n        /// @notice reference to the collateral token\n        address collateralToken;\n        /// @notice max number of debt tokens issued per collateral token.\n        /// @dev be mindful of the decimals here, because if collateral\n        /// token doesn't have 18 decimals, this variable is used to scale\n        /// the decimals.\n        /// For example, for USDC collateral, this variable should be around\n        /// ~1e30, to allow 1e6 * 1e30 / 1e18 ~= 1e18 CREDIT to be borrowed for\n        /// each 1e6 units (1 USDC) of collateral, if CREDIT is targeted to be\n        /// worth around 1 USDC.\n        uint256 maxDebtPerCollateralToken;\n        /// @notice interest rate paid by the borrower, expressed as an APR\n        /// with 18 decimals (0.01e18 = 1% APR). The base for 1 year is the YEAR constant.\n        uint256 interestRate;\n        /// @notice maximum delay, in seconds, between partial debt repayments.\n        /// if set to 0, no periodic partial repayments are expected.\n        /// if a partial repayment is missed (delay has passed), the loan\n        /// can be called.\n        uint256 maxDelayBetweenPartialRepay;\n        /// @notice minimum percent of the total debt (principal + interests) to\n        /// repay during partial debt repayments.\n        /// percentage is expressed with 18 decimals, e.g. 0.05e18 = 5% debt.\n        uint256 minPartialRepayPercent;\n        /// @notice the opening fee is a percent of interest that instantly accrues\n        /// when the loan is opened.\n        /// The opening fee is expressed as a percentage of the borrowAmount, with 18\n        /// decimals, e.g. 0.05e18 = 5% of the borrowed amount.\n        /// A loan with 2% openingFee and 3% interestRate will owe 102% of the borrowed\n        /// amount just after being open, and after 1 year will owe 105%.\n        uint256 openingFee;\n        /// @notice the absolute maximum amount of debt this lending term can issue\n        /// at any given time, regardless of the gauge allocations.\n        uint256 hardCap;\n    }\n\n    /// @notice Params of the LendingTerm (see struct for more details)\n    LendingTermParams internal params;\n\n    constructor() CoreRef(address(1)) {\n        // core is set to address(1) to prevent implementation from being initialized,\n        // only proxies on the implementation can be initialized.\n    }\n\n    /// @notice initialize storage with references to other protocol contracts\n    /// and the lending term parameters for this instance.\n    function initialize(\n        address _core,\n        LendingTermReferences calldata _refs,\n        LendingTermParams calldata _params\n    ) external {\n        // can initialize only once\n        assert(address(core()) == address(0));\n        assert(_core != address(0));\n\n        // initialize storage\n        _setCore(_core);\n        refs = _refs;\n        params = _params;\n    }\n\n    /// @notice get references of this term to other protocol contracts\n    function getReferences()\n        external\n        view\n        returns (LendingTermReferences memory)\n    {\n        return refs;\n    }\n\n    /// @notice get parameters of this term\n    function getParameters() external view returns (LendingTermParams memory) {\n        return params;\n    }\n\n    /// @notice get parameter 'collateralToken' of this term\n    function collateralToken() external view returns (address) {\n        return params.collateralToken;\n    }\n\n    /// @notice get a loan\n    function getLoan(bytes32 loanId) external view returns (Loan memory) {\n        return loans[loanId];\n    }\n\n    /// @notice outstanding borrowed amount of a loan, including interests\n    function getLoanDebt(bytes32 loanId) public view returns (uint256) {\n        Loan storage loan = loans[loanId];\n        uint256 borrowTime = loan.borrowTime;\n\n        if (borrowTime == 0) {\n            return 0;\n        }\n\n        if (loan.closeTime != 0) {\n            return 0;\n        }\n\n        if (loan.callTime != 0) {\n            return loan.callDebt;\n        }\n\n        // compute interest owed\n        uint256 borrowAmount = loan.borrowAmount;\n        uint256 interest = (borrowAmount *\n            params.interestRate *\n            (block.timestamp - borrowTime)) /\n            YEAR /\n            1e18;\n        uint256 loanDebt = borrowAmount + interest;\n        uint256 _openingFee = params.openingFee;\n        if (_openingFee != 0) {\n            loanDebt += (borrowAmount * _openingFee) / 1e18;\n        }\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        loanDebt = (loanDebt * loan.borrowCreditMultiplier) / creditMultiplier;\n\n        return loanDebt;\n    }\n\n    /// @notice returns true if the term has a maximum delay between partial repays\n    /// and the loan has passed the delay for partial repayments.\n    function partialRepayDelayPassed(\n        bytes32 loanId\n    ) public view returns (bool) {\n        // if no periodic partial repays are expected, always return false\n        if (params.maxDelayBetweenPartialRepay == 0) return false;\n\n        // if loan doesn't exist, return false\n        if (loans[loanId].borrowTime == 0) return false;\n\n        // if loan is closed, return false\n        if (loans[loanId].closeTime != 0) return false;\n\n        // return true if delay is passed\n        return\n            lastPartialRepay[loanId] <\n            block.timestamp - params.maxDelayBetweenPartialRepay;\n    }\n\n    /// @notice returns the maximum amount of debt that can be issued by this term\n    /// according to the current gauge allocations.\n    /// Note that the debt ceiling can be lower than the current issuance under 4 conditions :\n    /// - params.hardCap is lower than since last borrow happened\n    /// - gauge votes are fewer than when last borrow happened\n    /// - profitManager.totalBorrowedCredit() decreased since last borrow\n    /// - creditMinter.buffer() is close to being depleted\n    /// @dev this solves the following equation :\n    /// borrowAmount + issuance <=\n    /// (totalBorrowedCredit + borrowAmount) * gaugeWeight * gaugeWeightTolerance / totalWeight / 1e18\n    /// which is the formula to check debt ceiling in the borrow function.\n    /// This gives the maximum borrowable amount to achieve 100% utilization of the debt\n    /// ceiling, and if we add the current issuance to it, we get the current debt ceiling.\n    /// @param gaugeWeightDelta an hypothetical change in gauge weight\n    /// @return the maximum amount of debt that can be issued by this term\n    function debtCeiling(\n        int256 gaugeWeightDelta\n    ) public view returns (uint256) {\n        address _guildToken = refs.guildToken; // cached SLOAD\n        uint256 gaugeWeight = GuildToken(_guildToken).getGaugeWeight(\n            address(this)\n        );\n        gaugeWeight = uint256(int256(gaugeWeight) + gaugeWeightDelta);\n        uint256 gaugeType = GuildToken(_guildToken).gaugeType(address(this));\n        uint256 totalWeight = GuildToken(_guildToken).totalTypeWeight(\n            gaugeType\n        );\n        uint256 creditMinterBuffer = RateLimitedMinter(refs.creditMinter)\n            .buffer();\n        uint256 _hardCap = params.hardCap; // cached SLOAD\n        if (gaugeWeight == 0) {\n            return 0; // no gauge vote, 0 debt ceiling\n        } else if (gaugeWeight == totalWeight) {\n            // one gauge, unlimited debt ceiling\n            // returns min(hardCap, creditMinterBuffer)\n            return\n                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n        }\n        uint256 _issuance = issuance; // cached SLOAD\n        uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)\n            .totalBorrowedCredit();\n        uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)\n            .gaugeWeightTolerance();\n        if (totalBorrowedCredit == 0 && gaugeWeight != 0) {\n            // first-ever CREDIT mint on a non-zero gauge weight term\n            // does not check the relative debt ceilings\n            // returns min(hardCap, creditMinterBuffer)\n            return\n                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n        }\n        uint256 toleratedGaugeWeight = (gaugeWeight * gaugeWeightTolerance) /\n            1e18;\n        uint256 debtCeilingBefore = (totalBorrowedCredit *\n            toleratedGaugeWeight) / totalWeight;\n        if (_issuance >= debtCeilingBefore) {\n            return debtCeilingBefore; // no more borrows allowed\n        }\n        uint256 remainingDebtCeiling = debtCeilingBefore - _issuance; // always >0\n        if (toleratedGaugeWeight >= totalWeight) {\n            // if the gauge weight is above 100% when we include tolerance,\n            // the gauge relative debt ceilings are not constraining.\n            return\n                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n        }\n        uint256 otherGaugesWeight = totalWeight - toleratedGaugeWeight; // always >0\n        uint256 maxBorrow = (remainingDebtCeiling * totalWeight) /\n            otherGaugesWeight;\n        uint256 _debtCeiling = _issuance + maxBorrow;\n        // return min(creditMinterBuffer, hardCap, debtCeiling)\n        if (creditMinterBuffer < _debtCeiling) {\n            return creditMinterBuffer;\n        }\n        if (_hardCap < _debtCeiling) {\n            return _hardCap;\n        }\n        return _debtCeiling;\n    }\n\n    /// @notice returns the debt ceiling without change to gauge weight\n    function debtCeiling() external view returns (uint256) {\n        return debtCeiling(0);\n    }\n\n    /// @notice initiate a new loan\n    function _borrow(\n        address borrower,\n        uint256 borrowAmount,\n        uint256 collateralAmount\n    ) internal returns (bytes32 loanId) {\n        require(borrowAmount != 0, \"LendingTerm: cannot borrow 0\");\n        require(collateralAmount != 0, \"LendingTerm: cannot stake 0\");\n\n        loanId = keccak256(\n            abi.encode(borrower, address(this), block.timestamp)\n        );\n\n        // check that the loan doesn't already exist\n        require(loans[loanId].borrowTime == 0, \"LendingTerm: loan exists\");\n\n        // check that enough collateral is provided\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 maxBorrow = (collateralAmount *\n            params.maxDebtPerCollateralToken) / creditMultiplier;\n        require(\n            borrowAmount <= maxBorrow,\n            \"LendingTerm: not enough collateral\"\n        );\n\n        // check that enough CREDIT is borrowed\n        require(\n            borrowAmount >= ProfitManager(refs.profitManager).minBorrow(),\n            \"LendingTerm: borrow amount too low\"\n        );\n\n        // check the hardcap\n        uint256 _issuance = issuance;\n        uint256 _postBorrowIssuance = _issuance + borrowAmount;\n        require(\n            _postBorrowIssuance <= params.hardCap,\n            \"LendingTerm: hardcap reached\"\n        );\n\n        // check the debt ceiling\n        uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)\n            .totalBorrowedCredit();\n        uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)\n            .gaugeWeightTolerance();\n        uint256 _debtCeiling = (GuildToken(refs.guildToken)\n            .calculateGaugeAllocation(\n                address(this),\n                totalBorrowedCredit + borrowAmount\n            ) * gaugeWeightTolerance) / 1e18;\n        if (totalBorrowedCredit == 0) {\n            // if the lending term is deprecated, `calculateGaugeAllocation` will return 0, and the borrow\n            // should revert because the debt ceiling is reached (no borrows should be allowed anymore).\n            // first borrow in the system does not check proportions of issuance, just that the term is not deprecated.\n            require(_debtCeiling != 0, \"LendingTerm: debt ceiling reached\");\n        } else {\n            require(\n                _postBorrowIssuance <= _debtCeiling,\n                \"LendingTerm: debt ceiling reached\"\n            );\n        }\n\n        // save loan in state\n        loans[loanId] = Loan({\n            borrower: borrower,\n            borrowTime: block.timestamp,\n            borrowAmount: borrowAmount,\n            borrowCreditMultiplier: creditMultiplier,\n            collateralAmount: collateralAmount,\n            caller: address(0),\n            callTime: 0,\n            callDebt: 0,\n            closeTime: 0\n        });\n        issuance = _postBorrowIssuance;\n        if (params.maxDelayBetweenPartialRepay != 0) {\n            lastPartialRepay[loanId] = block.timestamp;\n        }\n\n        // mint debt to the borrower\n        RateLimitedMinter(refs.creditMinter).mint(borrower, borrowAmount);\n\n        // pull the collateral from the borrower\n        IERC20(params.collateralToken).safeTransferFrom(\n            borrower,\n            address(this),\n            collateralAmount\n        );\n\n        // emit event\n        emit LoanOpen(\n            block.timestamp,\n            loanId,\n            borrower,\n            collateralAmount,\n            borrowAmount\n        );\n    }\n\n    /// @notice initiate a new loan\n    function borrow(\n        uint256 borrowAmount,\n        uint256 collateralAmount\n    ) external whenNotPaused returns (bytes32 loanId) {\n        loanId = _borrow(msg.sender, borrowAmount, collateralAmount);\n    }\n\n    /// @notice add collateral on an open loan.\n    /// a borrower might want to add collateral so that his position does not go underwater due to\n    /// interests growing up over time.\n    function _addCollateral(\n        address borrower,\n        bytes32 loanId,\n        uint256 collateralToAdd\n    ) internal {\n        require(collateralToAdd != 0, \"LendingTerm: cannot add 0\");\n\n        Loan storage loan = loans[loanId];\n\n        // check the loan is open\n        require(loan.borrowTime != 0, \"LendingTerm: loan not found\");\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n        require(loan.callTime == 0, \"LendingTerm: loan called\");\n\n        // update loan in state\n        loans[loanId].collateralAmount += collateralToAdd;\n\n        // pull the collateral from the borrower\n        IERC20(params.collateralToken).safeTransferFrom(\n            borrower,\n            address(this),\n            collateralToAdd\n        );\n\n        // emit event\n        emit LoanAddCollateral(\n            block.timestamp,\n            loanId,\n            borrower,\n            collateralToAdd\n        );\n    }\n\n    /// @notice add collateral on an open loan.\n    function addCollateral(bytes32 loanId, uint256 collateralToAdd) external {\n        _addCollateral(msg.sender, loanId, collateralToAdd);\n    }\n\n    /// @notice partially repay an open loan.\n    /// a borrower might want to partially repay debt so that his position does not go underwater\n    /// due to interests building up.\n    /// some lending terms might also impose periodic partial repayments.\n    function _partialRepay(\n        address repayer,\n        bytes32 loanId,\n        uint256 debtToRepay\n    ) internal {\n        Loan storage loan = loans[loanId];\n\n        // check the loan is open\n        uint256 borrowTime = loan.borrowTime;\n        require(borrowTime != 0, \"LendingTerm: loan not found\");\n        require(\n            borrowTime < block.timestamp,\n            \"LendingTerm: loan opened in same block\"\n        );\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n        require(loan.callTime == 0, \"LendingTerm: loan called\");\n\n        // compute partial repayment\n        uint256 loanDebt = getLoanDebt(loanId);\n        require(debtToRepay < loanDebt, \"LendingTerm: full repayment\");\n        uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; // [0, 1e18[\n        uint256 borrowAmount = loan.borrowAmount;\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /\n            creditMultiplier;\n        uint256 principalRepaid = (principal * percentRepaid) / 1e18;\n        uint256 interestRepaid = debtToRepay - principalRepaid;\n        uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;\n        require(\n            principalRepaid != 0 && interestRepaid != 0,\n            \"LendingTerm: repay too small\"\n        );\n        require(\n            debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,\n            \"LendingTerm: repay below min\"\n        );\n        require(\n            borrowAmount - issuanceDecrease >\n                ProfitManager(refs.profitManager).minBorrow(),\n            \"LendingTerm: below min borrow\"\n        );\n\n        // update loan in state\n        loans[loanId].borrowAmount -= issuanceDecrease;\n        lastPartialRepay[loanId] = block.timestamp;\n        issuance -= issuanceDecrease;\n\n        // pull the debt from the borrower\n        CreditToken(refs.creditToken).transferFrom(\n            repayer,\n            address(this),\n            debtToRepay\n        );\n\n        // forward profit portion to the ProfitManager, burn the rest\n        CreditToken(refs.creditToken).transfer(\n            refs.profitManager,\n            interestRepaid\n        );\n        ProfitManager(refs.profitManager).notifyPnL(\n            address(this),\n            int256(interestRepaid)\n        );\n        CreditToken(refs.creditToken).burn(principalRepaid);\n        RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);\n\n        // emit event\n        emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);\n    }\n\n    /// @notice partially repay an open loan.\n    function partialRepay(bytes32 loanId, uint256 debtToRepay) external {\n        _partialRepay(msg.sender, loanId, debtToRepay);\n    }\n\n    /// @notice repay an open loan\n    function _repay(address repayer, bytes32 loanId) internal {\n        Loan storage loan = loans[loanId];\n\n        // check the loan is open\n        uint256 borrowTime = loan.borrowTime;\n        require(borrowTime != 0, \"LendingTerm: loan not found\");\n        require(\n            borrowTime < block.timestamp,\n            \"LendingTerm: loan opened in same block\"\n        );\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n        require(loan.callTime == 0, \"LendingTerm: loan called\");\n\n        // compute interest owed\n        uint256 loanDebt = getLoanDebt(loanId);\n        uint256 borrowAmount = loan.borrowAmount;\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /\n            creditMultiplier;\n        uint256 interest = loanDebt - principal;\n\n        /// pull debt from the borrower and replenish the buffer of available debt that can be minted.\n        CreditToken(refs.creditToken).transferFrom(\n            repayer,\n            address(this),\n            loanDebt\n        );\n        if (interest != 0) {\n            // forward profit portion to the ProfitManager\n            CreditToken(refs.creditToken).transfer(\n                refs.profitManager,\n                interest\n            );\n\n            // report profit\n            ProfitManager(refs.profitManager).notifyPnL(\n                address(this),\n                int256(interest)\n            );\n        }\n\n        // burn loan principal\n        CreditToken(refs.creditToken).burn(principal);\n        RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);\n\n        // close the loan\n        loan.closeTime = block.timestamp;\n        issuance -= borrowAmount;\n\n        // return the collateral to the borrower\n        IERC20(params.collateralToken).safeTransfer(\n            loan.borrower,\n            loan.collateralAmount\n        );\n\n        // emit event\n        emit LoanClose(block.timestamp, loanId, LoanCloseType.Repay, loanDebt);\n    }\n\n    /// @notice repay an open loan\n    function repay(bytes32 loanId) external {\n        _repay(msg.sender, loanId);\n    }\n\n    /// @notice call a loan, the collateral will be auctioned to repay outstanding debt.\n    /// Loans can be called only if the term has been offboarded or if a loan missed a periodic partialRepay.\n    function _call(\n        address caller,\n        bytes32 loanId,\n        address _auctionHouse\n    ) internal {\n        Loan storage loan = loans[loanId];\n\n        // check that the loan exists\n        uint256 borrowTime = loan.borrowTime;\n        require(loan.borrowTime != 0, \"LendingTerm: loan not found\");\n\n        // check that the loan is not already closed\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n\n        // check that the loan is not already called\n        require(loan.callTime == 0, \"LendingTerm: loan called\");\n\n        // check that the loan can be called\n        require(\n            GuildToken(refs.guildToken).isDeprecatedGauge(address(this)) ||\n                partialRepayDelayPassed(loanId),\n            \"LendingTerm: cannot call\"\n        );\n\n        // check that the loan has been running for at least 1 block\n        require(\n            borrowTime < block.timestamp,\n            \"LendingTerm: loan opened in same block\"\n        );\n\n        // update loan in state\n        uint256 loanDebt = getLoanDebt(loanId);\n        loans[loanId].callTime = block.timestamp;\n        loans[loanId].callDebt = loanDebt;\n        loans[loanId].caller = caller;\n\n        // auction the loan collateral\n        AuctionHouse(_auctionHouse).startAuction(loanId, loanDebt);\n\n        // emit event\n        emit LoanCall(block.timestamp, loanId);\n    }\n\n    /// @notice call a single loan\n    function call(bytes32 loanId) external {\n        _call(msg.sender, loanId, refs.auctionHouse);\n    }\n\n    /// @notice call a list of loans\n    function callMany(bytes32[] memory loanIds) public {\n        address _auctionHouse = refs.auctionHouse;\n        for (uint256 i = 0; i < loanIds.length; i++) {\n            _call(msg.sender, loanIds[i], _auctionHouse);\n        }\n    }\n\n    /// @notice forgive a loan, marking its debt as a total loss to the system.\n    /// The loan is closed (borrower keeps the CREDIT), and the collateral stays on the LendingTerm.\n    /// Governance can later unstuck the collateral through `emergencyAction`.\n    /// This function is made for emergencies where collateral is frozen or other reverting\n    /// conditions on collateral transfers that prevent regular repay() or call() loan closing.\n    function forgive(bytes32 loanId) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        Loan storage loan = loans[loanId];\n\n        // check that the loan exists\n        require(loan.borrowTime != 0, \"LendingTerm: loan not found\");\n\n        // check that the loan is not already closed\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n\n        // close the loan\n        loans[loanId].closeTime = block.timestamp;\n        issuance -= loan.borrowAmount;\n\n        // mark loan as a total loss\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 borrowAmount = loans[loanId].borrowAmount;\n        uint256 principal = (borrowAmount *\n            loans[loanId].borrowCreditMultiplier) / creditMultiplier;\n        int256 pnl = -int256(principal);\n        ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);\n\n        // set hardcap to 0 to prevent new borrows\n        params.hardCap = 0;\n\n        // emit event\n        emit LoanClose(block.timestamp, loanId, LoanCloseType.Forgive, 0);\n    }\n\n    /// @notice callback from the auctionHouse when au auction concludes\n    function onBid(\n        bytes32 loanId,\n        address bidder,\n        uint256 collateralToBorrower,\n        uint256 collateralToBidder,\n        uint256 creditFromBidder\n    ) external {\n        // preliminary checks\n        require(msg.sender == refs.auctionHouse, \"LendingTerm: invalid caller\");\n        require(\n            loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,\n            \"LendingTerm: loan not called\"\n        );\n        require(loans[loanId].closeTime == 0, \"LendingTerm: loan closed\");\n\n        // sanity check on collateral movement\n        // these should never fail for a properly implemented AuctionHouse contract\n        // collateralOut == 0 if forgive() while in auctionHouse\n        uint256 collateralOut = collateralToBorrower + collateralToBidder;\n        require(\n            collateralOut == loans[loanId].collateralAmount ||\n                collateralOut == 0,\n            \"LendingTerm: invalid collateral movements\"\n        );\n\n        // compute pnl\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 borrowAmount = loans[loanId].borrowAmount;\n        uint256 principal = (borrowAmount *\n            loans[loanId].borrowCreditMultiplier) / creditMultiplier;\n        int256 pnl;\n        uint256 interest;\n        if (creditFromBidder >= principal) {\n            interest = creditFromBidder - principal;\n            pnl = int256(interest);\n        } else {\n            pnl = int256(creditFromBidder) - int256(principal);\n            principal = creditFromBidder;\n            require(\n                collateralToBorrower == 0,\n                \"LendingTerm: invalid collateral movement\"\n            );\n        }\n\n        // save loan state\n        loans[loanId].closeTime = block.timestamp;\n\n        // pull credit from bidder\n        if (creditFromBidder != 0) {\n            CreditToken(refs.creditToken).transferFrom(\n                bidder,\n                address(this),\n                creditFromBidder\n            );\n        }\n\n        // burn credit principal, replenish buffer\n        if (principal != 0) {\n            CreditToken(refs.creditToken).burn(principal);\n            RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);\n        }\n\n        // handle profit & losses\n        if (pnl != 0) {\n            // forward profit, if any\n            if (interest != 0) {\n                CreditToken(refs.creditToken).transfer(\n                    refs.profitManager,\n                    interest\n                );\n            }\n            ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);\n        }\n\n        // decrease issuance\n        issuance -= borrowAmount;\n\n        // send collateral to borrower\n        if (collateralToBorrower != 0) {\n            IERC20(params.collateralToken).safeTransfer(\n                loans[loanId].borrower,\n                collateralToBorrower\n            );\n        }\n\n        // send collateral to bidder\n        if (collateralToBidder != 0) {\n            IERC20(params.collateralToken).safeTransfer(\n                bidder,\n                collateralToBidder\n            );\n        }\n\n        emit LoanClose(\n            block.timestamp,\n            loanId,\n            LoanCloseType.Call,\n            creditFromBidder\n        );\n    }\n\n    /// @notice set the address of the auction house.\n    /// governor-only, to allow full governance to update the auction mechanisms.\n    function setAuctionHouse(\n        address _newValue\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        // allow configuration changes only when there are no auctions in progress.\n        // updating the auction house while auctions are in progress could break the loan\n        // lifecycle, as it would prevent the former auctionHouse (that have active auctions)\n        // from reporting the result to the lending term.\n        require(\n            AuctionHouse(refs.auctionHouse).nAuctionsInProgress() == 0,\n            \"LendingTerm: auctions in progress\"\n        );\n\n        refs.auctionHouse = _newValue;\n    }\n\n    /// @notice set the hardcap of CREDIT mintable in this term.\n    /// allows to update a term's arbitrary hardcap without doing a gauge & loans migration.\n    function setHardCap(\n        uint256 _newValue\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        params.hardCap = _newValue;\n    }\n}"
    },
    {
      "filename": "src/loan/LendingTerm.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8"
    }
  ]
}