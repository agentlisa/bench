{
  "Title": "[G-01]  Avoid contract existence checks by using low level calls",
  "Content": "\nPrior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence.\n\n*There are 7 instances of this issue:*\n\n```solidity\nFile: src/libraries/OracleLibrary.sol\n\n/// @audit observe()\n59:           (int56[] memory tickCumulatives,) = IUniswapV3Pool(pool).observe(secondAgos);\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/libraries/OracleLibrary.sol#L59\n\n```solidity\nFile: src/libraries/UniswapHelpers.sol\n\n/// @audit swap()\n40:           (int256 amount0, int256 amount1) = IUniswapV3Pool(pool).swap(\n\n/// @audit slot0()\n83:           (, int24 tick,,,,,) = IUniswapV3Pool(pool).slot0();\n\n/// @audit token0()\n/// @audit token0()\n93:           return IUniswapV3Pool(pool1).token0() == IUniswapV3Pool(pool2).token0()\n\n/// @audit token1()\n/// @audit token1()\n94:               && IUniswapV3Pool(pool1).token1() == IUniswapV3Pool(pool2).token1();\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/libraries/UniswapHelpers.sol#L40\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-12-backed",
  "Code": [
    {
      "filename": "src/libraries/OracleLibrary.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {TickMath} from \"fullrange/libraries/TickMath.sol\";\nimport {FullMath} from \"fullrange/libraries/FullMath.sol\";\n\nlibrary OracleLibrary {\n    /// from https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol#L49\n    function getQuoteAtTick(int24 tick, uint128 baseAmount, address baseToken, address quoteToken)\n        internal\n        pure\n        returns (uint256 quoteAmount)\n    {\n        unchecked {\n            uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n            // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n            if (sqrtRatioX96 <= type(uint128).max) {\n                uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n                quoteAmount = baseToken < quoteToken\n                    ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                    : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n            } else {\n                uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n                quoteAmount = baseToken < quoteToken\n                    ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                    : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n            }\n        }\n    }\n\n    // adapted from https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol#L30-L40\n    function timeWeightedAverageTick(int56 startTick, int56 endTick, int56 twapDuration)\n        internal\n        view\n        returns (int24 twat)\n    {\n        require(twapDuration != 0, \"BP\");\n\n        unchecked {\n            int56 delta = endTick - startTick;\n\n            twat = int24(delta / twapDuration);\n\n            // Always round to negative infinity\n            if (delta < 0 && (delta % (twapDuration) != 0)) {\n                twat--;\n            }\n\n            twat;\n        }\n    }\n\n    // adapted from https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol#L21-L28\n    function latestCumulativeTick(address pool) internal view returns (int56) {\n        uint32[] memory secondAgos = new uint32[](1);\n        secondAgos[0] = 0;\n        (int56[] memory tickCumulatives,) = IUniswapV3Pool(pool).observe(secondAgos);\n        return tickCumulatives[0];\n    }\n}"
    },
    {
      "filename": "src/libraries/UniswapHelpers.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {IUniswapV3Factory} from \"v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport {TickMath} from \"fullrange/libraries/TickMath.sol\";\nimport {FullMath} from \"fullrange/libraries/FullMath.sol\";\nimport {SafeCast} from \"v3-core/contracts/libraries/SafeCast.sol\";\n\nimport {PoolAddress} from \"./PoolAddress.sol\";\n\nlibrary UniswapHelpers {\n    using SafeCast for uint256;\n\n    /// @param minOut The minimum out amount the user wanted\n    /// @param actualOut The actual out amount the user received\n    error TooLittleOut(uint256 minOut, uint256 actualOut);\n\n    IUniswapV3Factory constant FACTORY = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n\n    /// @notice executes a swap on the Uniswap\n    /// @param pool The pool to swap on\n    /// @param recipient The address to send the output to\n    /// @param zeroForOne Whether to swap token0 for token1 or vice versa\n    /// @param amountSpecified The amount of token0 or token1 to swap\n    /// @param minOut The minimum amount of token0 or token1 to receive\n    /// @param sqrtPriceLimitX96 The price limit for the swap\n    /// @param data Any data to pass to the uniswap callback handler\n    /// @return amountOut The amount of token0 or token1 received\n    /// @return amountIn The amount of token0 or token1 sent\n    function swap(\n        address pool,\n        address recipient,\n        bool zeroForOne,\n        uint256 amountSpecified,\n        uint256 minOut,\n        uint160 sqrtPriceLimitX96,\n        bytes memory data\n    ) internal returns (uint256 amountOut, uint256 amountIn) {\n        (int256 amount0, int256 amount1) = IUniswapV3Pool(pool).swap(\n            recipient,\n            zeroForOne,\n            amountSpecified.toInt256(),\n            sqrtPriceLimitX96 == 0\n                ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                : sqrtPriceLimitX96,\n            data\n        );\n\n        if (zeroForOne) {\n            amountOut = uint256(-amount1);\n            amountIn = uint256(amount0);\n        } else {\n            amountOut = uint256(-amount0);\n            amountIn = uint256(amount1);\n        }\n\n        if (amountOut < minOut) {\n            revert TooLittleOut(amountOut, minOut);\n        }\n    }\n\n    /// @notice initializes a UniswapV3 pool with the given sqrt ratio\n    /// @param tokenA the first token in the pool\n    /// @param tokenB the second token in the pool\n    /// @param feeTier the fee tier of the pool\n    /// @param sqrtRatio the sqrt ratio to initialize the pool with\n    /// @return pool the address of the newly created pool\n    function deployAndInitPool(address tokenA, address tokenB, uint24 feeTier, uint160 sqrtRatio)\n        internal\n        returns (address)\n    {\n        IUniswapV3Pool pool = IUniswapV3Pool(FACTORY.createPool(tokenA, tokenB, feeTier));\n        pool.initialize(sqrtRatio);\n\n        return address(pool);\n    }\n\n    /// @notice returns the current price tick of a UniswapV3 pool\n    /// @param pool the address of the pool\n    /// @return tick the current price tick of the pool\n    function poolCurrentTick(address pool) internal returns (int24) {\n        (, int24 tick,,,,,) = IUniswapV3Pool(pool).slot0();\n\n        return tick;\n    }\n\n    /// @notice returns whether or not two pools have the same tokens\n    /// @param pool1 the first pool\n    /// @param pool2 the second pool\n    /// @return same whether or not the two pools have the same tokens\n    function poolsHaveSameTokens(address pool1, address pool2) internal view returns (bool) {\n        return IUniswapV3Pool(pool1).token0() == IUniswapV3Pool(pool2).token0()\n            && IUniswapV3Pool(pool1).token1() == IUniswapV3Pool(pool2).token1();\n    }\n\n    /// @notice returns whether or not a pool is a UniswapV3 pool\n    /// @param pool the address of the pool\n    /// @return isUniswapPool whether or not the pool is a UniswapV3 pool\n    function isUniswapPool(address pool) internal view returns (bool) {\n        IUniswapV3Pool p = IUniswapV3Pool(pool);\n        PoolAddress.PoolKey memory k = PoolAddress.getPoolKey(p.token0(), p.token1(), p.fee());\n        return pool == PoolAddress.computeAddress(address(FACTORY), k);\n    }\n\n    /// @notice returns the sqrt ratio at which token0 and token1 are trading at 1:1\n    /// @param token0ONE 10 ** token0.decimals()\n    /// @param token1ONE 10 ** token1.decimals()\n    /// @return sqrtRatio at which token0 and token1 are trading at 1:1\n    function oneToOneSqrtRatio(uint256 token0ONE, uint256 token1ONE) internal pure returns (uint160) {\n        return TickMath.getSqrtRatioAtTick(TickMath.getTickAtSqrtRatio(uint160((token1ONE << 96) / token0ONE)) / 2);\n    }\n}"
    }
  ]
}