{
  "Title": "[M-08] Adversary can force user to pay large gas fees by transfering them collateral",
  "Content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/SupplyLogic.sol#L462-L512>\n\nAdversary can DOS user and make them pay more gas by sending them collateral.\n\n### Proof of Concept\n\n    if (fromConfig.isUsingAsCollateral(reserveId)) {\n        if (fromConfig.isBorrowingAny()) {\n            ValidationLogic.validateHFAndLtvERC20(\n                reservesData,\n                reservesList,\n                usersConfig[params.from],\n                params.asset,\n                params.from,\n                params.reservesCount,\n                params.oracle\n            );\n        }\n\n        if (params.balanceFromBefore == params.amount) {\n            fromConfig.setUsingAsCollateral(reserveId, false);\n            emit ReserveUsedAsCollateralDisabled(\n                params.asset,\n                params.from\n            );\n        }\n\n        //@audit collateral is automatically turned on for receiver\n        if (params.balanceToBefore == 0) {\n            DataTypes.UserConfigurationMap\n                storage toConfig = usersConfig[params.to];\n\n            toConfig.setUsingAsCollateral(reserveId, true);\n            emit ReserveUsedAsCollateralEnabled(\n                params.asset,\n                params.to\n            );\n        }\n    }\n\nThe above lines are executed when a user transfer collateral to another user. If the sending user currently has the collateral enabled and the receiving user doesn't have a balance already, the collateral will automatically be enabled for the receiver. Since the collateral is enabled, it will now be factored into the health check calculation. This increases gas for the receiver every time the user does anything that requires a health check (which ironically includes turning off a collateral). If enough different kinds of collateral are added to the platform it may even be enough gas to DOS the users.\n\n### Recommended Mitigation Steps\n\nDon't automatically enable the collateral for the receiver.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-paraspace-contest",
  "Code": [
    {
      "filename": "paraspace-core/contracts/protocol/libraries/logic/SupplyLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC20} from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport {IERC721} from \"../../../dependencies/openzeppelin/contracts/IERC721.sol\";\nimport {GPv2SafeERC20} from \"../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport {IPToken} from \"../../../interfaces/IPToken.sol\";\nimport {INonfungiblePositionManager} from \"../../../dependencies/uniswap/INonfungiblePositionManager.sol\";\nimport {INToken} from \"../../../interfaces/INToken.sol\";\nimport {INTokenApeStaking} from \"../../../interfaces/INTokenApeStaking.sol\";\nimport {ICollateralizableERC721} from \"../../../interfaces/ICollateralizableERC721.sol\";\nimport {IAuctionableERC721} from \"../../../interfaces/IAuctionableERC721.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {UserConfiguration} from \"../configuration/UserConfiguration.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {XTokenType} from \"../../../interfaces/IXTokenType.sol\";\nimport {INTokenUniswapV3} from \"../../../interfaces/INTokenUniswapV3.sol\";\n\n/**\n * @title SupplyLogic library\n *\n * @notice Implements the base logic for supply/withdraw\n */\nlibrary SupplyLogic {\n    using ReserveLogic for DataTypes.ReserveData;\n    using GPv2SafeERC20 for IERC20;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n    using WadRayMath for uint256;\n\n    // See `IPool` for descriptions\n    event ReserveUsedAsCollateralEnabled(\n        address indexed reserve,\n        address indexed user\n    );\n    event ReserveUsedAsCollateralDisabled(\n        address indexed reserve,\n        address indexed user\n    );\n    event Supply(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referralCode\n    );\n    event Withdraw(\n        address indexed reserve,\n        address indexed user,\n        address indexed to,\n        uint256 amount\n    );\n    event SupplyERC721(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        DataTypes.ERC721SupplyParams[] tokenData,\n        uint16 indexed referralCode,\n        bool fromNToken\n    );\n\n    event WithdrawERC721(\n        address indexed reserve,\n        address indexed user,\n        address indexed to,\n        uint256[] tokenIds\n    );\n\n    /**\n     * @notice Implements the supply feature. Through `supply()`, users supply assets to the ParaSpace protocol.\n     * @dev Emits the `Supply()` event.\n     * @dev In the first supply action, `ReserveUsedAsCollateralEnabled()` is emitted, if the asset can be enabled as\n     * collateral.\n     * @param reservesData The state of all the reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the supply function\n     */\n    function executeSupply(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteSupplyParams memory params\n    ) external {\n        DataTypes.ReserveData storage reserve = reservesData[params.asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        reserve.updateState(reserveCache);\n\n        ValidationLogic.validateSupply(\n            reserveCache,\n            params.amount,\n            DataTypes.AssetType.ERC20\n        );\n\n        reserve.updateInterestRates(\n            reserveCache,\n            params.asset,\n            params.amount,\n            0\n        );\n\n        IERC20(params.asset).safeTransferFrom(\n            params.payer,\n            reserveCache.xTokenAddress,\n            params.amount\n        );\n\n        bool isFirstSupply = IPToken(reserveCache.xTokenAddress).mint(\n            msg.sender,\n            params.onBehalfOf,\n            params.amount,\n            reserveCache.nextLiquidityIndex\n        );\n\n        if (isFirstSupply) {\n            userConfig.setUsingAsCollateral(reserve.id, true);\n            emit ReserveUsedAsCollateralEnabled(\n                params.asset,\n                params.onBehalfOf\n            );\n        }\n\n        emit Supply(\n            params.asset,\n            msg.sender,\n            params.onBehalfOf,\n            params.amount,\n            params.referralCode\n        );\n    }\n\n    function executeSupplyERC721Base(\n        uint16 reserveId,\n        address nTokenAddress,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteSupplyERC721Params memory params\n    ) internal {\n        //currently don't need to update state for erc721\n        //reserve.updateState(reserveCache);\n\n        (\n            uint64 oldCollateralizedBalance,\n            uint64 newCollateralizedBalance\n        ) = INToken(nTokenAddress).mint(params.onBehalfOf, params.tokenData);\n        bool isFirstSupplyCollateral = (oldCollateralizedBalance == 0 &&\n            newCollateralizedBalance > 0);\n        if (isFirstSupplyCollateral) {\n            userConfig.setUsingAsCollateral(reserveId, true);\n            emit ReserveUsedAsCollateralEnabled(\n                params.asset,\n                params.onBehalfOf\n            );\n        }\n    }\n\n    /**\n     * @notice Implements the supplyERC721 feature.\n     * @dev Emits the `SupplyERC721()` event.\n     * @dev In the first supply action, `ReserveUsedAsCollateralEnabled()` is emitted, if the asset can be enabled as\n     * collateral.\n     * @param reservesData The state of all the reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the supply function\n     */\n    function executeSupplyERC721(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteSupplyERC721Params memory params\n    ) external {\n        DataTypes.ReserveData storage reserve = reservesData[params.asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        ValidationLogic.validateSupply(\n            reserveCache,\n            params.tokenData.length,\n            DataTypes.AssetType.ERC721\n        );\n\n        XTokenType tokenType = INToken(reserveCache.xTokenAddress)\n            .getXTokenType();\n        if (tokenType == XTokenType.NTokenUniswapV3) {\n            for (uint256 index = 0; index < params.tokenData.length; index++) {\n                ValidationLogic.validateForUniswapV3(\n                    reservesData,\n                    params.asset,\n                    params.tokenData[index].tokenId,\n                    true,\n                    true,\n                    true\n                );\n            }\n        }\n        for (uint256 index = 0; index < params.tokenData.length; index++) {\n            IERC721(params.asset).safeTransferFrom(\n                params.payer,\n                reserveCache.xTokenAddress,\n                params.tokenData[index].tokenId\n            );\n        }\n\n        executeSupplyERC721Base(\n            reserve.id,\n            reserveCache.xTokenAddress,\n            userConfig,\n            params\n        );\n\n        emit SupplyERC721(\n            params.asset,\n            msg.sender,\n            params.onBehalfOf,\n            params.tokenData,\n            params.referralCode,\n            false\n        );\n    }\n\n    /**\n     * @notice Implements the executeSupplyERC721FromNToken feature.\n     * @dev Emits the `SupplyERC721()` event with fromNToken as true.\n     * @dev same as `executeSupplyERC721` whereas no need to transfer the underlying nft\n     * @param reservesData The state of all the reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the supply function\n     */\n    function executeSupplyERC721FromNToken(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteSupplyERC721Params memory params\n    ) external {\n        DataTypes.ReserveData storage reserve = reservesData[params.asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        ValidationLogic.validateSupplyFromNToken(\n            reserveCache,\n            params,\n            DataTypes.AssetType.ERC721\n        );\n\n        executeSupplyERC721Base(\n            reserve.id,\n            reserveCache.xTokenAddress,\n            userConfig,\n            params\n        );\n\n        emit SupplyERC721(\n            params.asset,\n            msg.sender,\n            params.onBehalfOf,\n            params.tokenData,\n            params.referralCode,\n            true\n        );\n    }\n\n    /**\n     * @notice Implements the withdraw feature. Through `withdraw()`, users redeem their xTokens for the underlying asset\n     * previously supplied in the ParaSpace protocol.\n     * @dev Emits the `Withdraw()` event.\n     * @dev If the user withdraws everything, `ReserveUsedAsCollateralDisabled()` is emitted.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the withdraw function\n     * @return The actual amount withdrawn\n     */\n    function executeWithdraw(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteWithdrawParams memory params\n    ) external returns (uint256) {\n        DataTypes.ReserveData storage reserve = reservesData[params.asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        reserve.updateState(reserveCache);\n\n        uint256 userBalance = IPToken(reserveCache.xTokenAddress)\n            .scaledBalanceOf(msg.sender)\n            .rayMul(reserveCache.nextLiquidityIndex);\n\n        uint256 amountToWithdraw = params.amount;\n\n        if (params.amount == type(uint256).max) {\n            amountToWithdraw = userBalance;\n        }\n\n        ValidationLogic.validateWithdraw(\n            reserveCache,\n            amountToWithdraw,\n            userBalance\n        );\n\n        reserve.updateInterestRates(\n            reserveCache,\n            params.asset,\n            0,\n            amountToWithdraw\n        );\n\n        IPToken(reserveCache.xTokenAddress).burn(\n            msg.sender,\n            params.to,\n            amountToWithdraw,\n            reserveCache.nextLiquidityIndex\n        );\n\n        if (userConfig.isUsingAsCollateral(reserve.id)) {\n            if (userConfig.isBorrowingAny()) {\n                ValidationLogic.validateHFAndLtvERC20(\n                    reservesData,\n                    reservesList,\n                    userConfig,\n                    params.asset,\n                    msg.sender,\n                    params.reservesCount,\n                    params.oracle\n                );\n            }\n\n            if (amountToWithdraw == userBalance) {\n                userConfig.setUsingAsCollateral(reserve.id, false);\n                emit ReserveUsedAsCollateralDisabled(params.asset, msg.sender);\n            }\n        }\n\n        emit Withdraw(params.asset, msg.sender, params.to, amountToWithdraw);\n\n        return amountToWithdraw;\n    }\n\n    function executeWithdrawERC721(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteWithdrawERC721Params memory params\n    ) external returns (uint256) {\n        DataTypes.ReserveData storage reserve = reservesData[params.asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        //currently don't need to update state for erc721\n        //reserve.updateState(reserveCache);\n\n        ValidationLogic.validateWithdrawERC721(\n            reservesData,\n            reserveCache,\n            params.asset,\n            params.tokenIds\n        );\n        uint256 amountToWithdraw = params.tokenIds.length;\n\n        (\n            uint64 oldCollateralizedBalance,\n            uint64 newCollateralizedBalance\n        ) = INToken(reserveCache.xTokenAddress).burn(\n                msg.sender,\n                params.to,\n                params.tokenIds\n            );\n\n        bool isWithdrawCollateral = (newCollateralizedBalance <\n            oldCollateralizedBalance);\n        if (isWithdrawCollateral) {\n            if (userConfig.isBorrowingAny()) {\n                ValidationLogic.validateHFAndLtvERC721(\n                    reservesData,\n                    reservesList,\n                    userConfig,\n                    params.asset,\n                    params.tokenIds,\n                    msg.sender,\n                    params.reservesCount,\n                    params.oracle\n                );\n            }\n\n            if (newCollateralizedBalance == 0) {\n                userConfig.setUsingAsCollateral(reserve.id, false);\n                emit ReserveUsedAsCollateralDisabled(params.asset, msg.sender);\n            }\n        }\n\n        emit WithdrawERC721(\n            params.asset,\n            msg.sender,\n            params.to,\n            params.tokenIds\n        );\n\n        return amountToWithdraw;\n    }\n\n    function executeDecreaseUniswapV3Liquidity(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteDecreaseUniswapV3LiquidityParams memory params\n    ) external {\n        DataTypes.ReserveData storage reserve = reservesData[params.asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        //currently don't need to update state for erc721\n        //reserve.updateState(reserveCache);\n\n        INToken nToken = INToken(reserveCache.xTokenAddress);\n        require(\n            nToken.getXTokenType() == XTokenType.NTokenUniswapV3,\n            Errors.ONLY_UNIV3_ALLOWED\n        );\n\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = params.tokenId;\n        ValidationLogic.validateWithdrawERC721(\n            reservesData,\n            reserveCache,\n            params.asset,\n            tokenIds\n        );\n\n        INTokenUniswapV3(reserveCache.xTokenAddress).decreaseUniswapV3Liquidity(\n                params.user,\n                params.tokenId,\n                params.liquidityDecrease,\n                params.amount0Min,\n                params.amount1Min,\n                params.receiveEthAsWeth\n            );\n\n        bool isUsedAsCollateral = ICollateralizableERC721(\n            reserveCache.xTokenAddress\n        ).isUsedAsCollateral(params.tokenId);\n        if (isUsedAsCollateral) {\n            if (userConfig.isBorrowingAny()) {\n                ValidationLogic.validateHFAndLtvERC721(\n                    reservesData,\n                    reservesList,\n                    userConfig,\n                    params.asset,\n                    tokenIds,\n                    params.user,\n                    params.reservesCount,\n                    params.oracle\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Validates a transfer of PTokens. The sender is subjected to health factor validation to avoid\n     * collateralization constraints violation.\n     * @dev Emits the `ReserveUsedAsCollateralEnabled()` event for the `to` account, if the asset is being activated as\n     * collateral.\n     * @dev In case the `from` user transfers everything, `ReserveUsedAsCollateralDisabled()` is emitted for `from`.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param usersConfig The users configuration mapping that track the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the finalizeTransfer function\n     */\n    function executeFinalizeTransferERC20(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,\n        DataTypes.FinalizeTransferParams memory params\n    ) external {\n        DataTypes.ReserveData storage reserve = reservesData[params.asset];\n\n        ValidationLogic.validateTransferERC20(reserve);\n\n        uint256 reserveId = reserve.id;\n\n        if (params.from != params.to && params.amount != 0) {\n            DataTypes.UserConfigurationMap storage fromConfig = usersConfig[\n                params.from\n            ];\n\n            if (fromConfig.isUsingAsCollateral(reserveId)) {\n                if (fromConfig.isBorrowingAny()) {\n                    ValidationLogic.validateHFAndLtvERC20(\n                        reservesData,\n                        reservesList,\n                        usersConfig[params.from],\n                        params.asset,\n                        params.from,\n                        params.reservesCount,\n                        params.oracle\n                    );\n                }\n\n                if (params.balanceFromBefore == params.amount) {\n                    fromConfig.setUsingAsCollateral(reserveId, false);\n                    emit ReserveUsedAsCollateralDisabled(\n                        params.asset,\n                        params.from\n                    );\n                }\n\n                if (params.balanceToBefore == 0) {\n                    DataTypes.UserConfigurationMap\n                        storage toConfig = usersConfig[params.to];\n\n                    toConfig.setUsingAsCollateral(reserveId, true);\n                    emit ReserveUsedAsCollateralEnabled(\n                        params.asset,\n                        params.to\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Validates a transfer of NTokens. The sender is subjected to health factor validation to avoid\n     * collateralization constraints violation.\n     * @dev In case the `from` user transfers everything, `ReserveUsedAsCollateralDisabled()` is emitted for `from`.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param usersConfig The users configuration mapping that track the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the finalizeTransfer function\n     */\n    function executeFinalizeTransferERC721(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,\n        DataTypes.FinalizeTransferERC721Params memory params\n    ) external {\n        DataTypes.ReserveData storage reserve = reservesData[params.asset];\n\n        ValidationLogic.validateTransferERC721(\n            reservesData,\n            reserve,\n            params.asset,\n            params.tokenId\n        );\n\n        uint256 reserveId = reserve.id;\n\n        if (params.from != params.to) {\n            DataTypes.UserConfigurationMap storage fromConfig = usersConfig[\n                params.from\n            ];\n\n            if (params.usedAsCollateral) {\n                if (fromConfig.isBorrowingAny()) {\n                    uint256[] memory tokenIds = new uint256[](1);\n                    tokenIds[0] = params.tokenId;\n                    ValidationLogic.validateHFAndLtvERC721(\n                        reservesData,\n                        reservesList,\n                        usersConfig[params.from],\n                        params.asset,\n                        tokenIds,\n                        params.from,\n                        params.reservesCount,\n                        params.oracle\n                    );\n                }\n\n                if (params.balanceFromBefore == 1) {\n                    fromConfig.setUsingAsCollateral(reserveId, false);\n                    emit ReserveUsedAsCollateralDisabled(\n                        params.asset,\n                        params.from\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Executes the 'set as collateral' feature. A user can choose to activate or deactivate an asset as\n     * collateral at any point in time. Deactivating an asset as collateral is subjected to the usual health factor\n     * checks to ensure collateralization.\n     * @dev Emits the `ReserveUsedAsCollateralEnabled()` event if the asset can be activated as collateral.\n     * @dev In case the asset is being deactivated as collateral, `ReserveUsedAsCollateralDisabled()` is emitted.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The users configuration mapping that track the supplied/borrowed assets\n     * @param asset The address of the asset being configured as collateral\n     * @param useAsCollateral True if the user wants to set the asset as collateral, false otherwise\n     * @param reservesCount The number of initialized reserves\n     * @param priceOracle The address of the price oracle\n     */\n    function executeUseERC20AsCollateral(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        address asset,\n        bool useAsCollateral,\n        uint256 reservesCount,\n        address priceOracle\n    ) external {\n        DataTypes.ReserveData storage reserve = reservesData[asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        uint256 userBalance = IERC20(reserveCache.xTokenAddress).balanceOf(\n            msg.sender\n        );\n\n        ValidationLogic.validateSetUseERC20AsCollateral(\n            reserveCache,\n            userBalance\n        );\n\n        if (useAsCollateral == userConfig.isUsingAsCollateral(reserve.id))\n            return;\n\n        if (useAsCollateral) {\n            userConfig.setUsingAsCollateral(reserve.id, true);\n            emit ReserveUsedAsCollateralEnabled(asset, msg.sender);\n        } else {\n            userConfig.setUsingAsCollateral(reserve.id, false);\n            ValidationLogic.validateHFAndLtvERC20(\n                reservesData,\n                reservesList,\n                userConfig,\n                asset,\n                msg.sender,\n                reservesCount,\n                priceOracle\n            );\n\n            emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Executes the 'set as collateral' feature. A user can choose to activate an asset as\n     * collateral at any point in time.\n     * @dev Emits the `ReserveUsedAsCollateralEnabled()` event if the asset can be activated as collateral.\n     * @param reservesData The state of all the reserves\n     * @param userConfig The users configuration mapping that track the supplied/borrowed assets\n     * @param asset The address of the asset being configured as collateral\n     * @param tokenIds The ids of the supplied ERC721 token\n     * @param sender The address of NFT owner\n     */\n    function executeCollateralizeERC721(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.UserConfigurationMap storage userConfig,\n        address asset,\n        uint256[] calldata tokenIds,\n        address sender\n    ) external {\n        DataTypes.ReserveData storage reserve = reservesData[asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        ValidationLogic.validateSetUseERC721AsCollateral(\n            reservesData,\n            reserveCache,\n            asset,\n            tokenIds\n        );\n\n        (\n            uint256 oldCollateralizedBalance,\n            uint256 newCollateralizedBalance\n        ) = ICollateralizableERC721(reserveCache.xTokenAddress)\n                .batchSetIsUsedAsCollateral(tokenIds, true, sender);\n\n        if (oldCollateralizedBalance == 0 && newCollateralizedBalance != 0) {\n            userConfig.setUsingAsCollateral(reserve.id, true);\n            emit ReserveUsedAsCollateralEnabled(asset, sender);\n        }\n    }\n\n    /**\n     * @notice Executes the 'set as collateral' feature. A user can choose to deactivate an asset as\n     * collateral at any point in time. Deactivating an asset as collateral is subjected to the usual health factor\n     * checks to ensure collateralization.\n     * @dev Emits the `ReserveUsedAsCollateralDisabled()` event if the asset can be deactivated as collateral.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The users configuration mapping that track the supplied/borrowed assets\n     * @param asset The address of the asset being configured as collateral\n     * @param tokenIds The ids of the supplied ERC721 token\n     * @param sender The address of NFT owner\n     * @param reservesCount The number of initialized reserves\n     * @param priceOracle The address of the price oracle\n     */\n    function executeUncollateralizeERC721(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        address asset,\n        uint256[] calldata tokenIds,\n        address sender,\n        uint256 reservesCount,\n        address priceOracle\n    ) external {\n        DataTypes.ReserveData storage reserve = reservesData[asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        ValidationLogic.validateSetUseERC721AsCollateral(\n            reservesData,\n            reserveCache,\n            asset,\n            tokenIds\n        );\n\n        (\n            uint256 oldCollateralizedBalance,\n            uint256 newCollateralizedBalance\n        ) = ICollateralizableERC721(reserveCache.xTokenAddress)\n                .batchSetIsUsedAsCollateral(tokenIds, false, sender);\n\n        if (oldCollateralizedBalance == newCollateralizedBalance) {\n            return;\n        }\n\n        if (newCollateralizedBalance == 0) {\n            userConfig.setUsingAsCollateral(reserve.id, false);\n            emit ReserveUsedAsCollateralDisabled(asset, sender);\n        }\n        ValidationLogic.validateHFAndLtvERC721(\n            reservesData,\n            reservesList,\n            userConfig,\n            asset,\n            tokenIds,\n            sender,\n            reservesCount,\n            priceOracle\n        );\n    }\n}"
    }
  ]
}