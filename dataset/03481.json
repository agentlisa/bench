{
  "Title": "[H02] Unhandled transfer failures",
  "Content": "The token bridge contracts synchronize deposits and withdrawals across the two domains. In particular, whenever tokens are [locked on layer 1](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L1TokenGateway.sol#L158-L162), the gateway [initiates a cross-domain message](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L1TokenGateway.sol#L172-L176) to mint equivalent tokens on layer 2. Similarly, when tokens are [burned on layer 2](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L2DepositedToken.sol#L187), the token [initiates a cross-domain message](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L2DepositedToken.sol#L197-L201) to release the funds on layer 1. However, the layer 1 ERC20 gateway does not check the return value of the [deposit](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/OVM_L1ERC20Gateway.sol#L76-L80) or [withdrawal](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/OVM_L1ERC20Gateway.sol#L98) transfers. This breaks the synchronization for ERC20 contracts that do not revert on failure, since failed deposits on layer 1 will be incorrectly credited on layer 2 and burned tokens on layer 2 may not be released on layer 1.\n\n\nConsider checking the return value on all token transfers and revert on failure.\n\n\n***Update**: Fixed in [pull request #988](https://github.com/ethereum-optimism/optimism/pull/988/commits/ce8071bc5ead86b75d5995111597bcdc4dc34385).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L1TokenGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n// @unsupported: ovm \npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Interface Imports */\nimport { iOVM_L1TokenGateway } from \"../../../iOVM/bridge/tokens/iOVM_L1TokenGateway.sol\";\nimport { iOVM_L2DepositedToken } from \"../../../iOVM/bridge/tokens/iOVM_L2DepositedToken.sol\";\n\n/* Library Imports */\nimport { OVM_CrossDomainEnabled } from \"../../../libraries/bridge/OVM_CrossDomainEnabled.sol\";\n\n/**\n * @title Abs_L1TokenGateway\n * @dev An L1 Token Gateway is a contract which stores deposited L1 funds that are in use on L2.\n * It synchronizes a corresponding L2 representation of the \"deposited token\", informing it\n * of new deposits and releasing L1 funds when there are newly finalized withdrawals.\n *\n * NOTE: This abstract contract gives all the core functionality of an L1 token gateway, \n * but provides easy hooks in case developers need extensions in child contracts.\n * In many cases, the default OVM_L1ERC20Gateway will suffice.\n *\n * Compiler used: solc\n * Runtime target: EVM\n */\nabstract contract Abs_L1TokenGateway is iOVM_L1TokenGateway, OVM_CrossDomainEnabled {\n\n    /********************************\n     * External Contract References *\n     ********************************/\n\n    address public l2DepositedToken;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _l2DepositedToken iOVM_L2DepositedToken-compatible address on the chain being deposited into.\n     * @param _l1messenger L1 Messenger address being used for cross-chain communications.\n     */\n    constructor(\n        address _l2DepositedToken,\n        address _l1messenger \n    )\n        OVM_CrossDomainEnabled(_l1messenger)\n    {\n        l2DepositedToken = _l2DepositedToken;\n    }\n\n    /********************************\n     * Overridable Accounting logic *\n     ********************************/\n\n    // Default gas value which can be overridden if more complex logic runs on L2.\n    uint32 public DEFAULT_FINALIZE_DEPOSIT_L2_GAS = 1200000;\n\n    /**\n     * @dev Core logic to be performed when a withdrawal is finalized on L1.\n     * In most cases, this will simply send locked funds to the withdrawer.\n     *\n     * param _to Address being withdrawn to.\n     * param _amount Amount being withdrawn.\n     */\n    function _handleFinalizeWithdrawal(\n        address, // _to,\n        uint256 // _amount\n    )\n        internal\n        virtual\n    {\n        revert(\"Implement me in child contracts\");\n    }\n\n    /**\n     * @dev Core logic to be performed when a deposit is initiated on L1.\n     * In most cases, this will simply send locked funds to the withdrawer.\n     *\n     * param _from Address being deposited from on L1.\n     * param _to Address being deposited into on L2.\n     * param _amount Amount being deposited.\n     */\n    function _handleInitiateDeposit(\n        address, // _from,\n        address, // _to,\n        uint256 // _amount\n    )\n        internal\n        virtual\n    {\n        revert(\"Implement me in child contracts\");\n    }\n\n    /**\n     * @dev Overridable getter for the L2 gas limit, in the case it may be\n     * dynamic, and the above public constant does not suffice.\n     *\n     */\n\n    function getFinalizeDepositL2Gas()\n        public\n        view\n        returns(\n            uint32\n        )\n    {\n        return DEFAULT_FINALIZE_DEPOSIT_L2_GAS;\n    }\n\n    /**************\n     * Depositing *\n     **************/\n\n    /**\n     * @dev deposit an amount of the ERC20 to the caller's balance on L2\n     * @param _amount Amount of the ERC20 to deposit\n     */\n    function deposit(\n        uint _amount\n    )\n        public\n        override\n    {\n        _initiateDeposit(msg.sender, msg.sender, _amount);\n    }\n\n    /**\n     * @dev deposit an amount of ERC20 to a recipients's balance on L2\n     * @param _to L2 address to credit the withdrawal to\n     * @param _amount Amount of the ERC20 to deposit\n     */\n    function depositTo(\n        address _to,\n        uint _amount\n    )\n        public\n        override\n    {\n        _initiateDeposit(msg.sender, _to, _amount);\n    }\n\n    /**\n     * @dev Performs the logic for deposits by informing the L2 Deposited Token\n     * contract of the deposit and calling a handler to lock the L1 funds. (e.g. transferFrom)\n     *\n     * @param _from Account to pull the deposit from on L1\n     * @param _to Account to give the deposit to on L2\n     * @param _amount Amount of the ERC20 to deposit.\n     */\n    function _initiateDeposit(\n        address _from,\n        address _to,\n        uint _amount\n    )\n        internal\n    {\n        // Call our deposit accounting handler implemented by child contracts.\n        _handleInitiateDeposit(\n            _from,\n            _to,\n            _amount\n        );\n\n        // Construct calldata for l2DepositedToken.finalizeDeposit(_to, _amount)\n        bytes memory data = abi.encodeWithSelector(\n            iOVM_L2DepositedToken.finalizeDeposit.selector,\n            _to,\n            _amount\n        );\n\n        // Send calldata into L2\n        sendCrossDomainMessage(\n            l2DepositedToken,\n            data,\n            getFinalizeDepositL2Gas()\n        );\n\n        emit DepositInitiated(_from, _to, _amount);\n    }\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the \n     * L1 ERC20 token. \n     * This call will fail if the initialized withdrawal from L2 has not been finalized. \n     *\n     * @param _to L1 address to credit the withdrawal to\n     * @param _amount Amount of the ERC20 to withdraw\n     */\n    function finalizeWithdrawal(\n        address _to,\n        uint _amount\n    )\n        external\n        override \n        onlyFromCrossDomainAccount(l2DepositedToken)\n    {\n        // Call our withdrawal accounting handler implemented by child contracts.\n        _handleFinalizeWithdrawal(\n            _to,\n            _amount\n        );\n\n        emit WithdrawalFinalized(_to, _amount);\n    }\n}"
    }
  ]
}