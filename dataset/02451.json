{
  "Title": "H-5: Adversary can permanently break reward distribution for percentage tier bounties by funding bounty then refunding after competition closes",
  "Content": "# Issue H-5: Adversary can permanently break reward distribution for percentage tier bounties by funding bounty then refunding after competition closes \n\nSource: https://github.com/sherlock-audit/2023-02-openq-judging/issues/266 \n\n## Found by \nTrungOre, XKET, chainNue, 0xbepresent, unforgiven, yixxas, jkoppel, libratus, Robert, HonorLt, 0x52, ctf\\_sec, Ruhum, ltyu, CodeFoxInc, seyni, cccz, 8olidity, holyhansss\n\n## Summary\n\nWhen closeCompetition is called for TieredPercentageBountyV1 it takes a snapshot of the current token balance. Afterwards it uses this number to calculate the payouts. When a deposit is refunded after the competition is closed then the contract won't have enough funds to pay users.\n\nTo exploit this an adversary can make a deposit for a token that has a current balance of zero using a expiration of 1 second. After the competition closes they refund their deposit. Now when the contract tries to give payouts to the winners it will try to payout a token that it no longer has any of, causing it to revert anytime someone tries to claim a payout.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/TieredPercentageBountyV1.sol#L123-L136\n\nTieredPercentageBountyV1#closeCompetition set the final fundingTotals for each token. \n\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/TieredPercentageBountyV1.sol#L104-L120\n\nFor each token in tokenAddresses it will send the claimedBalance to the claimant. If a deposit is refunded after the competition is closed then the contract won't have enough funds to pay users. \n\nAn adversary can exploit this by making a deposit of 100 for some token with and _expiration of 1 (second). After the competition has been closed they can refund their deposit causing the contract to be short on funds. If the user makes a deposit with an ERC20 token payouts can be re-enabled by donating to make the contract whole. The user can permanently break payouts by using native MATIC as the deposit. All bounty contracts have their receive function disabled which means the contract can't just be funded, which permanently breaks payouts.\n\nSubmitting as high because it can be combined with methods for breaking refunds to lock user funds permanently. \n\n## Impact\n\nAdversary can permanently break TieredPercentageBounty payouts\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSince TieredPercentageBounty is designed to distribute all deposits present at closing, refunds should be disabled after the competition is closed.\n\n## Discussion\n\n**FlacoJones**\n\nValid. Will fix by removing this contract for now.\n\n**FlacoJones**\n\nhttps://github.com/OpenQDev/OpenQ-Contracts/pull/112\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/39",
  "Code": [
    {
      "filename": "contracts/Bounty/Implementations/TieredPercentageBountyV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/TieredPercentageBountyStorage.sol';\n\n/// @title TieredPercentageBountyV1\n/// @notice TieredPercentageBountyV1 is a bounty implementation contract for single contributor, single payout circumstances\n/// @dev TieredPercentageBountyV1 -> TieredPercentageBountyStorageV1 -> TieredBountyCore -> TieredBountyStorageCore -> (BountyCore -> BountyStorageCore) -> (Third Party Deps + Custom )\n/// @dev Do not add any new storage variables here. Put them in a TieredPercentageBountyStorageV# and release new implementation\ncontract TieredPercentageBountyV1 is TieredPercentageBountyStorageV1 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    constructor() {}\n\n    /// @notice Initializes a bounty proxy with initial state\n    /// @param _bountyId The unique bounty identifier\n    /// @param _issuer The sender of the mint bounty transaction\n    /// @param _organization The organization associated with the bounty\n    /// @param _openQ The OpenQProxy address\n    /// @param _claimManager The Claim Manager proxy address\n    /// @param _depositManager The Deposit Manager proxy address\n    /// @param _operation The ABI encoded data determining the type of bounty being initialized and associated data\n    /// @dev see IBountyCore.initialize.(_operation) for _operation ABI encoding schema for TIERED PERCENTAGE\n    function initialize(\n        string memory _bountyId,\n        address _issuer,\n        string memory _organization,\n        address _openQ,\n        address _claimManager,\n        address _depositManager,\n        OpenQDefinitions.InitOperation memory _operation\n    ) external initializer {\n        require(bytes(_bountyId).length != 0, Errors.NO_EMPTY_BOUNTY_ID);\n        require(bytes(_organization).length != 0, Errors.NO_EMPTY_ORGANIZATION);\n\n        __ReentrancyGuard_init();\n\n        __OnlyOpenQ_init(_openQ);\n        __ClaimManagerOwnable_init(_claimManager);\n        __DepositManagerOwnable_init(_depositManager);\n\n        bountyId = _bountyId;\n        issuer = _issuer;\n        organization = _organization;\n        bountyCreatedTime = block.timestamp;\n        nftDepositLimit = 5;\n\n        (\n            uint256[] memory _payoutSchedule,\n            bool _hasFundingGoal,\n            address _fundingToken,\n            uint256 _fundingGoal,\n            bool _invoiceRequired,\n            bool _kycRequired,\n            bool _supportingDocumentsRequired,\n            string memory _issuerExternalUserId,\n            ,\n\n        ) = abi.decode(\n                _operation.data,\n                (\n                    uint256[],\n                    bool,\n                    address,\n                    uint256,\n                    bool,\n                    bool,\n                    bool,\n                    string,\n                    string,\n                    string\n                )\n            );\n\n        uint256 sum;\n        for (uint256 i = 0; i < _payoutSchedule.length; i++) {\n            sum += _payoutSchedule[i];\n        }\n        require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);\n        payoutSchedule = _payoutSchedule;\n\n        bountyType = OpenQDefinitions.TIERED_PERCENTAGE;\n        hasFundingGoal = _hasFundingGoal;\n        fundingToken = _fundingToken;\n        fundingGoal = _fundingGoal;\n        invoiceRequired = _invoiceRequired;\n        kycRequired = _kycRequired;\n        supportingDocumentsRequired = _supportingDocumentsRequired;\n        issuerExternalUserId = _issuerExternalUserId;\n\n        // Initialize metadata arrays to same number of tiers\n        tierWinners = new string[](_payoutSchedule.length);\n        invoiceComplete = new bool[](_payoutSchedule.length);\n        supportingDocumentsComplete = new bool[](_payoutSchedule.length);\n    }\n\n    /// @notice Transfers the tiered percentage of the token balance of _tokenAddress from bounty to _payoutAddress\n    /// @param _payoutAddress The destination address for the fund\n    /// @param _tier The ordinal of the claimant (e.g. 1st place, 2nd place)\n    /// @param _tokenAddress The token address being claimed\n    /// @return Volume of claimed token payout\n    function claimTiered(\n        address _payoutAddress,\n        uint256 _tier,\n        address _tokenAddress\n    ) external onlyClaimManager nonReentrant returns (uint256) {\n        require(\n            bountyType == OpenQDefinitions.TIERED_PERCENTAGE,\n            Errors.NOT_A_TIERED_BOUNTY\n        );\n        require(!tierClaimed[_tier], Errors.TIER_ALREADY_CLAIMED);\n\n        uint256 claimedBalance = (payoutSchedule[_tier] *\n            fundingTotals[_tokenAddress]) / 100;\n\n        _transferToken(_tokenAddress, claimedBalance, _payoutAddress);\n        return claimedBalance;\n    }\n\n    /// @notice Similar to close() for single priced bounties. closeCompetition() freezes the current funds for the competition.\n    function closeCompetition() external onlyClaimManager {\n        require(\n            status == OpenQDefinitions.OPEN,\n            Errors.CONTRACT_ALREADY_CLOSED\n        );\n\n        status = OpenQDefinitions.CLOSED;\n        bountyClosedTime = block.timestamp;\n\n        for (uint256 i = 0; i < getTokenAddresses().length; i++) {\n            address _tokenAddress = getTokenAddresses()[i];\n            fundingTotals[_tokenAddress] = getTokenBalance(_tokenAddress);\n        }\n    }\n\n    /// @notice Sets the payout schedule\n    /// @notice There is no tokenAddress needed here - payouts on percentage tiered bounties is a percentage of whatever is deposited on the contract\n    /// @param _payoutSchedule An array of payout volumes for each tier\n    function setPayoutSchedule(uint256[] calldata _payoutSchedule)\n        external\n        onlyOpenQ\n    {\n        require(\n            bountyType == OpenQDefinitions.TIERED_PERCENTAGE,\n            Errors.NOT_A_TIERED_BOUNTY\n        );\n        uint256 sum;\n        for (uint256 i = 0; i < _payoutSchedule.length; i++) {\n            sum += _payoutSchedule[i];\n        }\n        require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);\n\n        payoutSchedule = _payoutSchedule;\n\n        // Resize metadata arrays and copy current members to new array\n        // NOTE: If resizing to fewer tiers than previously, the final indexes will be removed\n        string[] memory newTierWinners = new string[](payoutSchedule.length);\n        bool[] memory newInvoiceComplete = new bool[](payoutSchedule.length);\n        bool[] memory newSupportingDocumentsCompleted = new bool[](\n            payoutSchedule.length\n        );\n\n        for (uint256 i = 0; i < tierWinners.length; i++) {\n            newTierWinners[i] = tierWinners[i];\n        }\n        tierWinners = newTierWinners;\n\n        for (uint256 i = 0; i < invoiceComplete.length; i++) {\n            newInvoiceComplete[i] = invoiceComplete[i];\n        }\n        invoiceComplete = newInvoiceComplete;\n\n        for (uint256 i = 0; i < supportingDocumentsComplete.length; i++) {\n            newSupportingDocumentsCompleted[i] = supportingDocumentsComplete[i];\n        }\n        supportingDocumentsComplete = newSupportingDocumentsCompleted;\n    }\n\n    /// @notice receive() method to accept protocol tokens\n    receive() external payable {\n        revert(\n            'Cannot send Ether directly to boutny contract. Please use the BountyV1.receiveFunds() method.'\n        );\n    }\n}"
    },
    {
      "filename": "contracts/Bounty/Implementations/TieredPercentageBountyV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/TieredPercentageBountyStorage.sol';\n\n/// @title TieredPercentageBountyV1\n/// @notice TieredPercentageBountyV1 is a bounty implementation contract for single contributor, single payout circumstances\n/// @dev TieredPercentageBountyV1 -> TieredPercentageBountyStorageV1 -> TieredBountyCore -> TieredBountyStorageCore -> (BountyCore -> BountyStorageCore) -> (Third Party Deps + Custom )\n/// @dev Do not add any new storage variables here. Put them in a TieredPercentageBountyStorageV# and release new implementation\ncontract TieredPercentageBountyV1 is TieredPercentageBountyStorageV1 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    constructor() {}\n\n    /// @notice Initializes a bounty proxy with initial state\n    /// @param _bountyId The unique bounty identifier\n    /// @param _issuer The sender of the mint bounty transaction\n    /// @param _organization The organization associated with the bounty\n    /// @param _openQ The OpenQProxy address\n    /// @param _claimManager The Claim Manager proxy address\n    /// @param _depositManager The Deposit Manager proxy address\n    /// @param _operation The ABI encoded data determining the type of bounty being initialized and associated data\n    /// @dev see IBountyCore.initialize.(_operation) for _operation ABI encoding schema for TIERED PERCENTAGE\n    function initialize(\n        string memory _bountyId,\n        address _issuer,\n        string memory _organization,\n        address _openQ,\n        address _claimManager,\n        address _depositManager,\n        OpenQDefinitions.InitOperation memory _operation\n    ) external initializer {\n        require(bytes(_bountyId).length != 0, Errors.NO_EMPTY_BOUNTY_ID);\n        require(bytes(_organization).length != 0, Errors.NO_EMPTY_ORGANIZATION);\n\n        __ReentrancyGuard_init();\n\n        __OnlyOpenQ_init(_openQ);\n        __ClaimManagerOwnable_init(_claimManager);\n        __DepositManagerOwnable_init(_depositManager);\n\n        bountyId = _bountyId;\n        issuer = _issuer;\n        organization = _organization;\n        bountyCreatedTime = block.timestamp;\n        nftDepositLimit = 5;\n\n        (\n            uint256[] memory _payoutSchedule,\n            bool _hasFundingGoal,\n            address _fundingToken,\n            uint256 _fundingGoal,\n            bool _invoiceRequired,\n            bool _kycRequired,\n            bool _supportingDocumentsRequired,\n            string memory _issuerExternalUserId,\n            ,\n\n        ) = abi.decode(\n                _operation.data,\n                (\n                    uint256[],\n                    bool,\n                    address,\n                    uint256,\n                    bool,\n                    bool,\n                    bool,\n                    string,\n                    string,\n                    string\n                )\n            );\n\n        uint256 sum;\n        for (uint256 i = 0; i < _payoutSchedule.length; i++) {\n            sum += _payoutSchedule[i];\n        }\n        require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);\n        payoutSchedule = _payoutSchedule;\n\n        bountyType = OpenQDefinitions.TIERED_PERCENTAGE;\n        hasFundingGoal = _hasFundingGoal;\n        fundingToken = _fundingToken;\n        fundingGoal = _fundingGoal;\n        invoiceRequired = _invoiceRequired;\n        kycRequired = _kycRequired;\n        supportingDocumentsRequired = _supportingDocumentsRequired;\n        issuerExternalUserId = _issuerExternalUserId;\n\n        // Initialize metadata arrays to same number of tiers\n        tierWinners = new string[](_payoutSchedule.length);\n        invoiceComplete = new bool[](_payoutSchedule.length);\n        supportingDocumentsComplete = new bool[](_payoutSchedule.length);\n    }\n\n    /// @notice Transfers the tiered percentage of the token balance of _tokenAddress from bounty to _payoutAddress\n    /// @param _payoutAddress The destination address for the fund\n    /// @param _tier The ordinal of the claimant (e.g. 1st place, 2nd place)\n    /// @param _tokenAddress The token address being claimed\n    /// @return Volume of claimed token payout\n    function claimTiered(\n        address _payoutAddress,\n        uint256 _tier,\n        address _tokenAddress\n    ) external onlyClaimManager nonReentrant returns (uint256) {\n        require(\n            bountyType == OpenQDefinitions.TIERED_PERCENTAGE,\n            Errors.NOT_A_TIERED_BOUNTY\n        );\n        require(!tierClaimed[_tier], Errors.TIER_ALREADY_CLAIMED);\n\n        uint256 claimedBalance = (payoutSchedule[_tier] *\n            fundingTotals[_tokenAddress]) / 100;\n\n        _transferToken(_tokenAddress, claimedBalance, _payoutAddress);\n        return claimedBalance;\n    }\n\n    /// @notice Similar to close() for single priced bounties. closeCompetition() freezes the current funds for the competition.\n    function closeCompetition() external onlyClaimManager {\n        require(\n            status == OpenQDefinitions.OPEN,\n            Errors.CONTRACT_ALREADY_CLOSED\n        );\n\n        status = OpenQDefinitions.CLOSED;\n        bountyClosedTime = block.timestamp;\n\n        for (uint256 i = 0; i < getTokenAddresses().length; i++) {\n            address _tokenAddress = getTokenAddresses()[i];\n            fundingTotals[_tokenAddress] = getTokenBalance(_tokenAddress);\n        }\n    }\n\n    /// @notice Sets the payout schedule\n    /// @notice There is no tokenAddress needed here - payouts on percentage tiered bounties is a percentage of whatever is deposited on the contract\n    /// @param _payoutSchedule An array of payout volumes for each tier\n    function setPayoutSchedule(uint256[] calldata _payoutSchedule)\n        external\n        onlyOpenQ\n    {\n        require(\n            bountyType == OpenQDefinitions.TIERED_PERCENTAGE,\n            Errors.NOT_A_TIERED_BOUNTY\n        );\n        uint256 sum;\n        for (uint256 i = 0; i < _payoutSchedule.length; i++) {\n            sum += _payoutSchedule[i];\n        }\n        require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);\n\n        payoutSchedule = _payoutSchedule;\n\n        // Resize metadata arrays and copy current members to new array\n        // NOTE: If resizing to fewer tiers than previously, the final indexes will be removed\n        string[] memory newTierWinners = new string[](payoutSchedule.length);\n        bool[] memory newInvoiceComplete = new bool[](payoutSchedule.length);\n        bool[] memory newSupportingDocumentsCompleted = new bool[](\n            payoutSchedule.length\n        );\n\n        for (uint256 i = 0; i < tierWinners.length; i++) {\n            newTierWinners[i] = tierWinners[i];\n        }\n        tierWinners = newTierWinners;\n\n        for (uint256 i = 0; i < invoiceComplete.length; i++) {\n            newInvoiceComplete[i] = invoiceComplete[i];\n        }\n        invoiceComplete = newInvoiceComplete;\n\n        for (uint256 i = 0; i < supportingDocumentsComplete.length; i++) {\n            newSupportingDocumentsCompleted[i] = supportingDocumentsComplete[i];\n        }\n        supportingDocumentsComplete = newSupportingDocumentsCompleted;\n    }\n\n    /// @notice receive() method to accept protocol tokens\n    receive() external payable {\n        revert(\n            'Cannot send Ether directly to boutny contract. Please use the BountyV1.receiveFunds() method.'\n        );\n    }\n}"
    }
  ]
}