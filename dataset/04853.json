{
  "Title": "[G-21] Do not assign `offset` in the last call of `UnsafeBytes.readUint256()` in `_parseL2WithdrawalMessage()`",
  "Content": "\n**File:** `L1SharedBridge.sol`\n\nA simple test in Remix IDE has been created, to compare gas usage of assigning more than one value from function call:\n\n```\n  function getUints() public pure returns (uint, uint) {return (1, 2);}\n   function funcA() public view {\n    uint a; uint b; \n    (a, b) = getUints();\n    uint g = gasleft();\n    (a, b) = getUints();\n    console.log(g - gasleft());\n   }\n    function funcB() public view {\n    uint a; uint b; \n    (a, b) = getUints();\n    uint g = gasleft();\n    (a, ) = getUints();\n    console.log(g - gasleft());\n   }\n```\n\n`funcB()` costs 74 gas, while `funcA()` costs 82 gas. This implies, that we shouldn't assign every parameter from function call if it's not needed.\n\n[File: code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L520)\n```solidity\n520:             (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n```\n\nIn the last call of `UnsafeBytes.readUint256(_l2ToL1message, offset)` (line 520), we won't need `offset` anymore, thus we can remove `offset` and change this line to: `(amount, ) = UnsafeBytes.readUint256(_l2ToL1message, offset)`.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IL1ERC20Bridge} from \"./interfaces/IL1ERC20Bridge.sol\";\nimport {IL1SharedBridge} from \"./interfaces/IL1SharedBridge.sol\";\nimport {IL2Bridge} from \"./interfaces/IL2Bridge.sol\";\n\nimport {IMailbox} from \"../state-transition/chain-interfaces/IMailbox.sol\";\nimport {L2Message, TxStatus} from \"../common/Messaging.sol\";\nimport {UnsafeBytes} from \"../common/libraries/UnsafeBytes.sol\";\nimport {ReentrancyGuard} from \"../common/ReentrancyGuard.sol\";\nimport {AddressAliasHelper} from \"../vendor/AddressAliasHelper.sol\";\nimport {ERA_CHAIN_ID, ERA_ERC20_BRIDGE_ADDRESS, ETH_TOKEN_ADDRESS, ERA_DIAMOND_PROXY, TWO_BRIDGES_MAGIC_VALUE} from \"../common/Config.sol\";\nimport {IBridgehub, L2TransactionRequestTwoBridgesInner, L2TransactionRequestDirect} from \"../bridgehub/IBridgehub.sol\";\nimport {IGetters} from \"../state-transition/chain-interfaces/IGetters.sol\";\nimport {L2_BASE_TOKEN_SYSTEM_CONTRACT_ADDR} from \"../common/L2ContractAddresses.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev Bridges assets between L1 and hyperchains, supporting both ETH and ERC20 tokens.\n/// @dev Designed for use with a proxy for upgradability.\ncontract L1SharedBridge is IL1SharedBridge, ReentrancyGuard, Initializable, Ownable2Step {\n    using SafeERC20 for IERC20;\n\n    /// @dev The address of the WETH token on L1.\n    address public immutable override l1WethAddress;\n\n    /// @dev Bridgehub smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication.\n    IBridgehub public immutable override bridgehub;\n\n    /// @dev Legacy bridge smart contract that used to hold ERC20 tokens.\n    IL1ERC20Bridge public immutable override legacyBridge;\n\n    /// @dev Stores the first batch number on the zkSync Era Diamond Proxy that was settled after Shared Bridge upgrade.\n    /// This variable is used to differentiate between pre-upgrade and post-upgrade withdrawals. Withdrawals from batches older\n    /// than this value are considered to have been finalized prior to the upgrade and handled separately.\n    uint256 internal eraFirstPostUpgradeBatch;\n\n    /// @dev A mapping chainId => bridgeProxy. Used to store the bridge proxy's address, and to see if it has been deployed yet.\n    mapping(uint256 chainId => address l2Bridge) public override l2BridgeAddress;\n\n    /// @dev A mapping chainId => L2 deposit transaction hash => keccak256(abi.encode(account, tokenAddress, amount))\n    /// @dev Tracks deposit transactions from L2 to enable users to claim their funds if a deposit fails.\n    mapping(uint256 chainId => mapping(bytes32 l2DepositTxHash => bytes32 depositDataHash))\n        public\n        override depositHappened;\n\n    /// @dev Tracks the processing status of L2 to L1 messages, indicating whether a message has already been finalized.\n    mapping(uint256 chainId => mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized)))\n        public isWithdrawalFinalized;\n\n    /// @dev Indicates whether the hyperbridging is enabled for a given chain.\n    mapping(uint256 chainId => bool enabled) internal hyperbridgingEnabled;\n\n    /// @dev Maps token balances for each chain to prevent unauthorized spending across hyperchains.\n    /// This serves as a security measure until hyperbridging is implemented.\n    mapping(uint256 chainId => mapping(address l1Token => uint256 balance)) internal chainBalance;\n\n    /// @notice Checks that the message sender is the bridgehub.\n    modifier onlyBridgehub() {\n        require(msg.sender == address(bridgehub), \"ShB not BH\");\n        _;\n    }\n\n    /// @notice Checks that the message sender is the bridgehub or zkSync Era Diamond Proxy.\n    modifier onlyBridgehubOrEra(uint256 _chainId) {\n        require(\n            msg.sender == address(bridgehub) || (_chainId == ERA_CHAIN_ID && msg.sender == ERA_DIAMOND_PROXY),\n            \"L1SharedBridge: not bridgehub or era chain\"\n        );\n        _;\n    }\n\n    /// @notice Checks that the message sender is the legacy bridge.\n    modifier onlyLegacyBridge() {\n        require(msg.sender == address(legacyBridge), \"ShB not legacy bridge\");\n        _;\n    }\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(\n        address _l1WethAddress,\n        IBridgehub _bridgehub,\n        IL1ERC20Bridge _legacyBridge\n    ) reentrancyGuardInitializer {\n        _disableInitializers();\n        l1WethAddress = _l1WethAddress;\n        bridgehub = _bridgehub;\n        legacyBridge = _legacyBridge;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @param _owner Address which can change L2 token implementation and upgrade the bridge\n    /// implementation. The owner is the Governor and separate from the ProxyAdmin from now on, so that the Governor can call the bridge.\n    function initialize(\n        address _owner,\n        uint256 _eraFirstPostUpgradeBatch\n    ) external reentrancyGuardInitializer initializer {\n        require(_owner != address(0), \"ShB owner 0\");\n        _transferOwnership(_owner);\n\n        eraFirstPostUpgradeBatch = _eraFirstPostUpgradeBatch;\n        l2BridgeAddress[ERA_CHAIN_ID] = ERA_ERC20_BRIDGE_ADDRESS;\n    }\n\n    /// @dev tranfer tokens from legacy erc20 bridge or mailbox and set chainBalance as part of migration process\n    function transferFundsFromLegacy(address _token, address _target, uint256 _targetChainId) external onlyOwner {\n        if (_token == ETH_TOKEN_ADDRESS) {\n            uint256 balanceBefore = address(this).balance;\n            IMailbox(_target).transferEthToSharedBridge();\n            uint256 balanceAfter = address(this).balance;\n            require(balanceAfter > balanceBefore, \"ShB: 0 eth transferred\");\n            chainBalance[_targetChainId][ETH_TOKEN_ADDRESS] =\n                chainBalance[_targetChainId][ETH_TOKEN_ADDRESS] +\n                balanceAfter -\n                balanceBefore;\n        } else {\n            uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n            uint256 amount = IERC20(_token).balanceOf(address(legacyBridge));\n            require(amount > 0, \"ShB: 0 amount to transfer\");\n            IL1ERC20Bridge(_target).tranferTokenToSharedBridge(_token, amount);\n            uint256 balanceAfter = IERC20(_token).balanceOf(address(this));\n            require(balanceAfter - balanceBefore == amount, \"ShB: wrong amount transferred\");\n            chainBalance[_targetChainId][_token] = chainBalance[_targetChainId][_token] + amount;\n        }\n    }\n\n    function receiveEth(uint256 _chainId) external payable {\n        require(bridgehub.getStateTransition(_chainId) == msg.sender, \"receiveEth not state transition\");\n    }\n\n    /// @dev Initializes the l2Bridge address by governance for a specific chain.\n    function initializeChainGovernance(uint256 _chainId, address _l2BridgeAddress) external onlyOwner {\n        l2BridgeAddress[_chainId] = _l2BridgeAddress;\n    }\n\n    /// @notice Allows bridgehub to acquire mintValue for L1->L2 transactions.\n    /// @dev If the corresponding L2 transaction fails, refunds are issued to a refund recipient on L2.\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable virtual onlyBridgehubOrEra(_chainId) {\n        if (_l1Token == ETH_TOKEN_ADDRESS) {\n            require(msg.value == _amount, \"L1SharedBridge: msg.value not equal to amount\");\n        } else {\n            // The Bridgehub also checks this, but we want to be sure\n            require(msg.value == 0, \"ShB m.v > 0 b d.it\");\n\n            uint256 amount = _depositFunds(_prevMsgSender, IERC20(_l1Token), _amount); // note if _prevMsgSender is this contract, this will return 0. This does not happen.\n            require(amount == _amount, \"3T\"); // The token has non-standard transfer logic\n        }\n\n        if (!hyperbridgingEnabled[_chainId]) {\n            chainBalance[_chainId][_l1Token] += _amount;\n        }\n        // Note that we don't save the deposited amount, as this is for the base token, which gets sent to the refundRecipient if the tx fails\n        emit BridgehubDepositBaseTokenInitiated(_chainId, _prevMsgSender, _l1Token, _amount);\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address.\n    /// @return The difference between the contract balance before and after the transferring of funds.\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @notice Initiates a deposit transaction within Bridgehub, used by `requestL2TransactionTwoBridges`.\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256, // l2Value, needed for Weth deposits in the future\n        bytes calldata _data\n    ) external payable override onlyBridgehub returns (L2TransactionRequestTwoBridgesInner memory request) {\n        require(l2BridgeAddress[_chainId] != address(0), \"ShB l2 bridge not deployed\");\n\n        (address _l1Token, uint256 _depositAmount, address _l2Receiver) = abi.decode(\n            _data,\n            (address, uint256, address)\n        );\n        require(_l1Token != l1WethAddress, \"ShB: WETH deposit not supported\");\n        require(bridgehub.baseToken(_chainId) != _l1Token, \"ShB: baseToken deposit not supported\");\n\n        uint256 amount;\n        if (_l1Token == ETH_TOKEN_ADDRESS) {\n            amount = msg.value;\n            require(_depositAmount == 0, \"ShB wrong withdraw amount\");\n        } else {\n            require(msg.value == 0, \"ShB m.v > 0 for BH d.it 2\");\n            amount = _depositAmount;\n\n            uint256 withdrawAmount = _depositFunds(_prevMsgSender, IERC20(_l1Token), _depositAmount);\n            require(withdrawAmount == _depositAmount, \"5T\"); // The token has non-standard transfer logic\n        }\n        require(amount != 0, \"6T\"); // empty deposit amount\n\n        bytes32 txDataHash = keccak256(abi.encode(_prevMsgSender, _l1Token, amount));\n        if (!hyperbridgingEnabled[_chainId]) {\n            chainBalance[_chainId][_l1Token] += amount;\n        }\n\n        {\n            // Request the finalization of the deposit on the L2 side\n            bytes memory l2TxCalldata = _getDepositL2Calldata(_prevMsgSender, _l2Receiver, _l1Token, amount);\n\n            request = L2TransactionRequestTwoBridgesInner({\n                magicValue: TWO_BRIDGES_MAGIC_VALUE,\n                l2Contract: l2BridgeAddress[_chainId],\n                l2Calldata: l2TxCalldata,\n                factoryDeps: new bytes[](0),\n                txDataHash: txDataHash\n            });\n        }\n        emit BridgehubDepositInitiated(_chainId, txDataHash, _prevMsgSender, _l2Receiver, _l1Token, amount);\n    }\n\n    /// @notice Confirms the acceptance of a transaction by the Mailbox, as part of the L2 transaction process within Bridgehub.\n    /// This function is utilized by `requestL2TransactionTwoBridges` to validate the execution of a transaction.\n    function bridgehubConfirmL2Transaction(\n        uint256 _chainId,\n        bytes32 _txDataHash,\n        bytes32 _txHash\n    ) external override onlyBridgehub {\n        require(depositHappened[_chainId][_txHash] == 0x00, \"ShB tx hap\");\n        depositHappened[_chainId][_txHash] = _txDataHash;\n        emit BridgehubDepositFinalized(_chainId, _txDataHash, _txHash);\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) internal view returns (bytes memory) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        return abi.encodeCall(IL2Bridge.finalizeDeposit, (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData));\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory) {\n        if (_token == ETH_TOKEN_ADDRESS) {\n            bytes memory name = bytes(\"Ether\");\n            bytes memory symbol = bytes(\"ETH\");\n            bytes memory decimals = abi.encode(uint8(18));\n            return abi.encode(name, symbol, decimals); // when depositing eth to a non-eth based chain it is an ERC20\n        }\n\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        return abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _amount The amount of the deposit that failed.\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external override {\n        _claimFailedDeposit(\n            false,\n            _chainId,\n            _depositSender,\n            _l1Token,\n            _amount,\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof\n        );\n    }\n\n    /// @dev Processes claims of failed deposit, whether they originated from the legacy bridge or the current system.\n    function _claimFailedDeposit(\n        bool _checkedInLegacyBridge,\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) internal nonReentrant {\n        {\n            bool proofValid = bridgehub.proveL1ToL2TransactionStatus(\n                _chainId,\n                _l2TxHash,\n                _l2BatchNumber,\n                _l2MessageIndex,\n                _l2TxNumberInBatch,\n                _merkleProof,\n                TxStatus.Failure\n            );\n            require(proofValid, \"yn\");\n        }\n        require(_amount > 0, \"y1\");\n\n        {\n            bool notCheckedInLegacyBridgeOrWeCanCheckDeposit;\n            {\n                // Deposits that happened before the upgrade cannot be checked here, they have to be claimed and checked in the legacyBridge\n                bool weCanCheckDepositHere = !_isEraLegacyWithdrawal(_chainId, _l2BatchNumber);\n                // Double claims are not possible, as we this check except for legacy bridge withdrawals\n                // Funds claimed before the update will still be recorded in the legacy bridge\n                // Note we double check NEW deposits if they are called from the legacy bridge\n                notCheckedInLegacyBridgeOrWeCanCheckDeposit = (!_checkedInLegacyBridge) || weCanCheckDepositHere;\n            }\n            if (notCheckedInLegacyBridgeOrWeCanCheckDeposit) {\n                bytes32 dataHash = depositHappened[_chainId][_l2TxHash];\n                bytes32 txDataHash = keccak256(abi.encode(_depositSender, _l1Token, _amount));\n                require(dataHash == txDataHash, \"ShB: d.it not hap\");\n                delete depositHappened[_chainId][_l2TxHash];\n            }\n        }\n\n        if (!hyperbridgingEnabled[_chainId]) {\n            // check that the chain has sufficient balance\n            require(chainBalance[_chainId][_l1Token] >= _amount, \"ShB n funds\");\n            chainBalance[_chainId][_l1Token] -= _amount;\n        }\n\n        // Withdraw funds\n        if (_l1Token == ETH_TOKEN_ADDRESS) {\n            bool callSuccess;\n            // Low-level assembly call, to avoid any memory copying (save gas)\n            assembly {\n                callSuccess := call(gas(), _depositSender, _amount, 0, 0, 0, 0)\n            }\n            require(callSuccess, \"ShB: claimFailedDeposit failed\");\n        } else {\n            IERC20(_l1Token).safeTransfer(_depositSender, _amount);\n            // Note we don't allow weth deposits anymore, but there might be legacy weth deposits.\n            // until we add Weth bridging capabilities, we don't wrap/unwrap weth to ether.\n        }\n\n        emit ClaimedFailedDepositSharedBridge(_chainId, _depositSender, _l1Token, _amount);\n    }\n\n    /// @dev Determines if a withdrawal was initiated on zkSync Era before the upgrade to the Shared Bridge.\n    /// @param _chainId The chain ID of the transaction to check.\n    /// @param _l2BatchNumber The L2 batch number for the withdrawal.\n    /// @return Whether withdrawal was initiated on zkSync Era before Shared Bridge upgrade.\n    function _isEraLegacyWithdrawal(uint256 _chainId, uint256 _l2BatchNumber) internal view returns (bool) {\n        return (_chainId == ERA_CHAIN_ID) && (_l2BatchNumber < eraFirstPostUpgradeBatch);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _chainId The chain ID of the transaction to check\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external override {\n        // To avoid rewithdrawing txs that have already happened on the legacy bridge.\n        // Note: new withdraws are all recorded here, so double withdrawing them is not possible.\n        if (_isEraLegacyWithdrawal(_chainId, _l2BatchNumber)) {\n            require(!legacyBridge.isWithdrawalFinalized(_l2BatchNumber, _l2MessageIndex), \"ShB: legacy withdrawal\");\n        }\n        _finalizeWithdrawal(_chainId, _l2BatchNumber, _l2MessageIndex, _l2TxNumberInBatch, _message, _merkleProof);\n    }\n\n    struct MessageParams {\n        uint256 l2BatchNumber;\n        uint256 l2MessageIndex;\n        uint16 l2TxNumberInBatch;\n    }\n\n    /// @dev Internal function that handles the logic for finalizing withdrawals,\n    /// serving both the current bridge system and the legacy ERC20 bridge.\n    function _finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) internal nonReentrant returns (address l1Receiver, address l1Token, uint256 amount) {\n        require(!isWithdrawalFinalized[_chainId][_l2BatchNumber][_l2MessageIndex], \"Withdrawal is already finalized\");\n        isWithdrawalFinalized[_chainId][_l2BatchNumber][_l2MessageIndex] = true;\n\n        // Handling special case for withdrawal from zkSync Era initiated before Shared Bridge.\n        if (_isEraLegacyWithdrawal(_chainId, _l2BatchNumber)) {\n            // Checks that the withdrawal wasn't finalized already.\n            bool alreadyFinalized = IGetters(ERA_DIAMOND_PROXY).isEthWithdrawalFinalized(\n                _l2BatchNumber,\n                _l2MessageIndex\n            );\n            require(!alreadyFinalized, \"Withdrawal is already finalized 2\");\n        }\n\n        MessageParams memory messageParams = MessageParams({\n            l2BatchNumber: _l2BatchNumber,\n            l2MessageIndex: _l2MessageIndex,\n            l2TxNumberInBatch: _l2TxNumberInBatch\n        });\n        (l1Receiver, l1Token, amount) = _checkWithdrawal(_chainId, messageParams, _message, _merkleProof);\n\n        if (!hyperbridgingEnabled[_chainId]) {\n            // Check that the chain has sufficient balance\n            require(chainBalance[_chainId][l1Token] >= amount, \"ShB not enough funds 2\"); // not enought funds\n            chainBalance[_chainId][l1Token] -= amount;\n        }\n\n        if (l1Token == ETH_TOKEN_ADDRESS) {\n            bool callSuccess;\n            // Low-level assembly call, to avoid any memory copying (save gas)\n            assembly {\n                callSuccess := call(gas(), l1Receiver, amount, 0, 0, 0, 0)\n            }\n            require(callSuccess, \"ShB: withdraw failed\");\n        } else {\n            // Withdraw funds\n            IERC20(l1Token).safeTransfer(l1Receiver, amount);\n        }\n        emit WithdrawalFinalizedSharedBridge(_chainId, l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Verifies the validity of a withdrawal message from L2 and returns details of the withdrawal.\n    function _checkWithdrawal(\n        uint256 _chainId,\n        MessageParams memory _messageParams,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) internal view returns (address l1Receiver, address l1Token, uint256 amount) {\n        (l1Receiver, l1Token, amount) = _parseL2WithdrawalMessage(_chainId, _message);\n        L2Message memory l2ToL1Message;\n        {\n            bool baseTokenWithdrawal = (l1Token == bridgehub.baseToken(_chainId));\n            address l2Sender = baseTokenWithdrawal ? L2_BASE_TOKEN_SYSTEM_CONTRACT_ADDR : l2BridgeAddress[_chainId];\n\n            l2ToL1Message = L2Message({\n                txNumberInBatch: _messageParams.l2TxNumberInBatch,\n                sender: l2Sender,\n                data: _message\n            });\n        }\n\n        bool success = bridgehub.proveL2MessageInclusion(\n            _chainId,\n            _messageParams.l2BatchNumber,\n            _messageParams.l2MessageIndex,\n            l2ToL1Message,\n            _merkleProof\n        );\n        require(success, \"ShB withd w proof\"); // withdrawal wrong proof\n    }\n\n    function _parseL2WithdrawalMessage(\n        uint256 _chainId,\n        bytes memory _l2ToL1message\n    ) internal view returns (address l1Receiver, address l1Token, uint256 amount) {\n        // We check that the message is long enough to read the data.\n        // Please note that there are two versions of the message:\n        // 1. The message that is sent by `withdraw(address _l1Receiver)`\n        // It should be equal to the length of the bytes4 function signature + address l1Receiver + uint256 amount = 4 + 20 + 32 = 56 (bytes).\n        // 2. The message that is sent by `withdrawWithMessage(address _l1Receiver, bytes calldata _additionalData)`\n        // It should be equal to the length of the following:\n        // bytes4 function signature + address l1Receiver + uint256 amount + address l2Sender + bytes _additionalData =\n        // = 4 + 20 + 32 + 32 + _additionalData.length >= 68 (bytes).\n\n        // So the data is expected to be at least 56 bytes long.\n        require(_l2ToL1message.length >= 56, \"ShB wrong msg len\"); // wrong messsage length\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        if (bytes4(functionSignature) == IMailbox.finalizeEthWithdrawal.selector) {\n            // this message is a base token withdrawal\n            (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n            (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n            l1Token = bridgehub.baseToken(_chainId);\n        } else if (bytes4(functionSignature) == IL1ERC20Bridge.finalizeWithdrawal.selector) {\n            // We use the IL1ERC20Bridge for backward compatibility with old withdrawals.\n\n            // this message is a token withdrawal\n\n            // Check that the message length is correct.\n            // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n            // 76 (bytes).\n            require(_l2ToL1message.length == 76, \"ShB wrong msg len 2\");\n            (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n            (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n            (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n        } else {\n            revert(\"ShB Incorrect message function selector\");\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERA LEGACY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization.\n    function depositLegacyErc20Bridge(\n        address _prevMsgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable override onlyLegacyBridge nonReentrant returns (bytes32 l2TxHash) {\n        require(l2BridgeAddress[ERA_CHAIN_ID] != address(0), \"ShB b. n dep\");\n        require(_l1Token != l1WethAddress, \"ShB: WETH deposit not supported 2\");\n\n        // Note that funds have been transferred to this contract in the legacy ERC20 bridge.\n        if (!hyperbridgingEnabled[ERA_CHAIN_ID]) {\n            chainBalance[ERA_CHAIN_ID][_l1Token] += _amount;\n        }\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(_prevMsgSender, _l2Receiver, _l1Token, _amount);\n\n        {\n            // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n            // Otherwise, the refund will be sent to the specified address.\n            // If the recipient is a contract on L1, the address alias will be applied.\n            address refundRecipient = _refundRecipient;\n            if (_refundRecipient == address(0)) {\n                refundRecipient = _prevMsgSender != tx.origin\n                    ? AddressAliasHelper.applyL1ToL2Alias(_prevMsgSender)\n                    : _prevMsgSender;\n            }\n\n            L2TransactionRequestDirect memory request = L2TransactionRequestDirect({\n                chainId: ERA_CHAIN_ID,\n                l2Contract: l2BridgeAddress[ERA_CHAIN_ID],\n                mintValue: msg.value, // l2 gas + l2 msg.Value the bridgehub will withdraw the mintValue from the base token bridge for gas\n                l2Value: 0, // L2 msg.value, this contract doesn't support base token deposits or wrapping functionality, for direct deposits use bridgehub\n                l2Calldata: l2TxCalldata,\n                l2GasLimit: _l2TxGasLimit,\n                l2GasPerPubdataByteLimit: _l2TxGasPerPubdataByte,\n                factoryDeps: new bytes[](0),\n                refundRecipient: refundRecipient\n            });\n            l2TxHash = bridgehub.requestL2TransactionDirect{value: msg.value}(request);\n        }\n\n        bytes32 txDataHash = keccak256(abi.encode(_prevMsgSender, _l1Token, _amount));\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositHappened[ERA_CHAIN_ID][l2TxHash] = txDataHash;\n\n        emit LegacyDepositInitiated(ERA_CHAIN_ID, l2TxHash, _prevMsgSender, _l2Receiver, _l1Token, _amount);\n    }\n\n    /// @notice Finalizes the withdrawal for transactions initiated via the legacy ERC20 bridge.\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    ///\n    /// @return l1Receiver The address on L1 that will receive the withdrawn funds\n    /// @return l1Token The address of the L1 token being withdrawn\n    /// @return amount The amount of the token being withdrawns\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external override onlyLegacyBridge returns (address l1Receiver, address l1Token, uint256 amount) {\n        (l1Receiver, l1Token, amount) = _finalizeWithdrawal(\n            ERA_CHAIN_ID,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _message,\n            _merkleProof\n        );\n    }\n\n    /// @notice Withdraw funds from the initiated deposit, that failed when finalizing on zkSync Era chain.\n    /// This function is specifically designed for maintaining backward-compatibility with legacy `claimFailedDeposit`\n    /// method in `L1ERC20Bridge`.\n    ///\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _amount The amount of the deposit that failed.\n    /// @pa"
    }
  ]
}