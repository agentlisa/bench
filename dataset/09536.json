{
  "Title": "[M-03] `_execute` can potentially reorder a batch of commands while executing, breaking any assumptions on command orders.",
  "Content": "_Submitted by rayn_\n\n[AxelarGatewayMultisig.sol#L484](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGatewayMultisig.sol#L484)<br>\n[AxelarGatewayMultisig.sol#L490](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGatewayMultisig.sol#L490)<br>\n[AxelarGatewayMultisig.sol#L529](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGatewayMultisig.sol#L529)<br>\n\nSince this is important, we quote it again instead of referring to our other bug report on a different, yet related bug. The context within which a command is executed is extremely important.\n\n> AxelarGatewayMultisig.execute() takes a signed batch of commands. Each command has a corresponding commandID. This is guaranteed to be unique from the Axelar network. execute intentionally allows retrying a commandID if the command failed to be processed; this is because commands are state dependent, and someone might submit command 2 before command 1 causing it to fail.\n\nThus if an attacker manages to rearrange execution order of commands within a batch, it should probably be treated seriously. This is exactly what might happen here due to reentrancy. A malicious player that managed to gain reentrancy over execute can easily execute later commands in a batch before earlier commands are fully executed, effectively breaking all assumptions on command executed context.\n\n### Proof of Concept\n\nThe `_execute` function and its wrapper `execute` are both reentrant.\n\n        function execute(bytes calldata input) external override;\n        function _execute(bytes memory data, bytes[] memory signatures) internal;\n\nThus if an attacker manages to reenter the `_execute` function with the same batch of commands and signatures, previously successfully executed and ongoing commands will be skipped due to premature marking of the success flag.\n\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\n\nThis allows later commands to be executed before the current ongoing command is finished. The reentrant attack can be nested to perform further reordering of commands.\n\nGenerally speaking, other unrelated batches of signed commands can only be executed, but since the assumption of ordering is most likely stronger within a single batch, we focus on illustrating the single batch scenario above.\n\n### Tools Used\n\nvim, ganache-cli\n\n### Recommended Mitigation Steps\n\nMake execute nonReentrant\n\nAdd an ever increasing nonce to signatures to prevent replay\n\n        function execute(bytes calldata input) nonReentrant external override {\n            ...\n        }\n\n**[deluca-mike (Axelar) acknowledged, but disagreed with High severity and commented](https://github.com/code-423n4/2022-04-axelar-findings/issues/17#issuecomment-1103782975):**\n > Axelar and the gateways make no concrete guarantees about command execution order, so the idea of \"reordering\" is moot. Currently, the only commands that call out are:\n> - deploy a token (so its order is irrelevant)\n> - minting a token (and thus a call to the token contract will not re-enter, since it is either one the gateway deployed, or the gateway onboarded a malicious external ERC2, which still has no effect on the other tokens)\n> - burn a token (same as above)\n> \n> As with the other issue, while we do acknowledge that the contestant has correctly pointed out how the gateway handles (and can re-handle) commands, this is a low-risk (or no-risk) issue, since no actual risk has been demonstrated apart from \"maybe, somehow, possibly, it could be abused\". We'd need at least some feasible and concrete hypothetical or example.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-04-axelar-findings/issues/17#issuecomment-1107615612):**\n > I am going to side with the warden on this but downgrade to medium severity.  The transaction ordering is not the high risk issue, but the ability for re-entrancy and thus replay presents a risk that should be mitigated. \n> \n> Looking at other recent hacks ( for example - https://rekt.news/agave-hundred-rekt/ ), new environments pose new risks for re-entrancy to appear and with the point of this protocol being to extend across many chains, added additional measures to avoid re-entrancy and the replay that could occur as a result seems like a very logical choice.<br> \n> `\n> 2 â€” Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-04-axelar",
  "Code": [
    {
      "filename": "src/AxelarGatewayMultisig.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGatewayMultisig } from './interfaces/IAxelarGatewayMultisig.sol';\n\nimport { ECDSA } from './ECDSA.sol';\nimport { AxelarGateway } from './AxelarGateway.sol';\n\ncontract AxelarGatewayMultisig is IAxelarGatewayMultisig, AxelarGateway {\n    error InvalidAddress();\n    error InvalidOwners();\n    error InvalidOwnerThreshold();\n    error DuplicateOwner(address owner);\n    error InvalidOperators();\n    error InvalidOperatorThreshold();\n    error DuplicateOperator(address operator);\n    error NotProxy();\n    error InvalidChainId();\n    error MalformedSigners();\n    error InvalidCommands();\n\n    // AUDIT: slot names should be prefixed with some standard string\n    // AUDIT: constants should be literal and their derivation should be in comments\n    bytes32 internal constant KEY_OWNER_EPOCH = keccak256('owner-epoch');\n\n    bytes32 internal constant PREFIX_OWNER = keccak256('owner');\n    bytes32 internal constant PREFIX_OWNER_COUNT = keccak256('owner-count');\n    bytes32 internal constant PREFIX_OWNER_THRESHOLD = keccak256('owner-threshold');\n    bytes32 internal constant PREFIX_IS_OWNER = keccak256('is-owner');\n\n    bytes32 internal constant KEY_OPERATOR_EPOCH = keccak256('operator-epoch');\n\n    bytes32 internal constant PREFIX_OPERATOR = keccak256('operator');\n    bytes32 internal constant PREFIX_OPERATOR_COUNT = keccak256('operator-count');\n    bytes32 internal constant PREFIX_OPERATOR_THRESHOLD = keccak256('operator-threshold');\n    bytes32 internal constant PREFIX_IS_OPERATOR = keccak256('is-operator');\n\n    constructor(address tokenDeployer) AxelarGateway(tokenDeployer) {}\n\n    function _isSortedAscAndContainsNoDuplicate(address[] memory accounts) internal pure returns (bool) {\n        for (uint256 i; i < accounts.length - 1; ++i) {\n            if (accounts[i] >= accounts[i + 1]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /************************\\\n    |* Owners Functionality *|\n    \\************************/\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getOwnerKey(uint256 epoch, uint256 index) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OWNER, epoch, index));\n    }\n\n    function _getOwnerCountKey(uint256 epoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OWNER_COUNT, epoch));\n    }\n\n    function _getOwnerThresholdKey(uint256 epoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OWNER_THRESHOLD, epoch));\n    }\n\n    function _getIsOwnerKey(uint256 epoch, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_IS_OWNER, epoch, account));\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function _ownerEpoch() internal view returns (uint256) {\n        return getUint(KEY_OWNER_EPOCH);\n    }\n\n    function _getOwner(uint256 epoch, uint256 index) internal view returns (address) {\n        return getAddress(_getOwnerKey(epoch, index));\n    }\n\n    function _getOwnerCount(uint256 epoch) internal view returns (uint256) {\n        return getUint(_getOwnerCountKey(epoch));\n    }\n\n    function _getOwnerThreshold(uint256 epoch) internal view returns (uint256) {\n        return getUint(_getOwnerThresholdKey(epoch));\n    }\n\n    function _isOwner(uint256 epoch, address account) internal view returns (bool) {\n        return getBool(_getIsOwnerKey(epoch, account));\n    }\n\n    /// @dev Returns true if a sufficient quantity of `accounts` are owners within the last `OLD_KEY_RETENTION + 1` owner epochs (excluding the current one).\n    function _areValidPreviousOwners(address[] memory accounts) internal view returns (bool) {\n        uint256 epoch = _ownerEpoch();\n        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);\n        uint256 lowerBoundOwnerEpoch = epoch > recentEpochs ? epoch - recentEpochs : uint256(0);\n\n        --epoch;\n        while (epoch > lowerBoundOwnerEpoch) {\n            if (_areValidOwnersInEpoch(epoch--, accounts)) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev Returns true if a sufficient quantity of `accounts` are owners in the `ownerEpoch`.\n    function _areValidOwnersInEpoch(uint256 epoch, address[] memory accounts) internal view returns (bool) {\n        uint256 threshold = _getOwnerThreshold(epoch);\n        uint256 validSignerCount;\n\n        for (uint256 i; i < accounts.length; i++) {\n            if (_isOwner(epoch, accounts[i]) && ++validSignerCount >= threshold) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev Returns the current `ownerEpoch`.\n    function ownerEpoch() external view override returns (uint256) {\n        return _ownerEpoch();\n    }\n\n    /// @dev Returns the threshold for a given `ownerEpoch`.\n    function ownerThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getOwnerThreshold(epoch);\n    }\n\n    /// @dev Returns the array of owners within a given `ownerEpoch`.\n    function owners(uint256 epoch) public view override returns (address[] memory results) {\n        uint256 ownerCount = _getOwnerCount(epoch);\n        results = new address[](ownerCount);\n\n        for (uint256 i; i < ownerCount; i++) {\n            results[i] = _getOwner(epoch, i);\n        }\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    function _setOwnerEpoch(uint256 epoch) internal {\n        _setUint(KEY_OWNER_EPOCH, epoch);\n    }\n\n    function _setOwner(\n        uint256 epoch,\n        uint256 index,\n        address account\n    ) internal {\n        if (account == address(0)) revert InvalidAddress();\n\n        _setAddress(_getOwnerKey(epoch, index), account);\n    }\n\n    function _setOwnerCount(uint256 epoch, uint256 ownerCount) internal {\n        _setUint(_getOwnerCountKey(epoch), ownerCount);\n    }\n\n    function _setOwners(\n        uint256 epoch,\n        address[] memory accounts,\n        uint256 threshold\n    ) internal {\n        uint256 accountLength = accounts.length;\n\n        if (accountLength < threshold) revert InvalidOwners();\n\n        if (threshold == uint256(0)) revert InvalidOwnerThreshold();\n\n        _setOwnerThreshold(epoch, threshold);\n        _setOwnerCount(epoch, accountLength);\n\n        for (uint256 i; i < accountLength; i++) {\n            address account = accounts[i];\n\n            // Check that the account wasn't already set as an owner for this ownerEpoch.\n            if (_isOwner(epoch, account)) revert DuplicateOwner(account);\n\n            // Set this account as the i-th owner in this ownerEpoch (needed to we can get all the owners for `owners`).\n            _setOwner(epoch, i, account);\n            _setIsOwner(epoch, account, true);\n        }\n    }\n\n    function _setOwnerThreshold(uint256 epoch, uint256 threshold) internal {\n        _setUint(_getOwnerThresholdKey(epoch), threshold);\n    }\n\n    function _setIsOwner(\n        uint256 epoch,\n        address account,\n        bool isOwner\n    ) internal {\n        _setBool(_getIsOwnerKey(epoch, account), isOwner);\n    }\n\n    /**************************\\\n    |* Operator Functionality *|\n    \\**************************/\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getOperatorKey(uint256 epoch, uint256 index) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR, epoch, index));\n    }\n\n    function _getOperatorCountKey(uint256 epoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR_COUNT, epoch));\n    }\n\n    function _getOperatorThresholdKey(uint256 epoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR_THRESHOLD, epoch));\n    }\n\n    function _getIsOperatorKey(uint256 epoch, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_IS_OPERATOR, epoch, account));\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function _operatorEpoch() internal view returns (uint256) {\n        return getUint(KEY_OPERATOR_EPOCH);\n    }\n\n    function _getOperator(uint256 epoch, uint256 index) internal view returns (address) {\n        return getAddress(_getOperatorKey(epoch, index));\n    }\n\n    function _getOperatorCount(uint256 epoch) internal view returns (uint256) {\n        return getUint(_getOperatorCountKey(epoch));\n    }\n\n    function _getOperatorThreshold(uint256 epoch) internal view returns (uint256) {\n        return getUint(_getOperatorThresholdKey(epoch));\n    }\n\n    function _isOperator(uint256 epoch, address account) internal view returns (bool) {\n        return getBool(_getIsOperatorKey(epoch, account));\n    }\n\n    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the same `operatorEpoch`, within the last `OLD_KEY_RETENTION + 1` operator epochs.\n    function _areValidRecentOperators(address[] memory accounts) internal view returns (bool) {\n        uint256 epoch = _operatorEpoch();\n        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);\n        uint256 lowerBoundOperatorEpoch = epoch > recentEpochs ? epoch - recentEpochs : uint256(0);\n\n        while (epoch > lowerBoundOperatorEpoch) {\n            if (_areValidOperatorsInEpoch(epoch--, accounts)) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the `operatorEpoch`.\n    function _areValidOperatorsInEpoch(uint256 epoch, address[] memory accounts) internal view returns (bool) {\n        uint256 threshold = _getOperatorThreshold(epoch);\n        uint256 validSignerCount;\n\n        for (uint256 i; i < accounts.length; i++) {\n            if (_isOperator(epoch, accounts[i]) && ++validSignerCount >= threshold) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev Returns the current `operatorEpoch`.\n    function operatorEpoch() external view override returns (uint256) {\n        return _operatorEpoch();\n    }\n\n    /// @dev Returns the threshold for a given `operatorEpoch`.\n    function operatorThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getOperatorThreshold(epoch);\n    }\n\n    /// @dev Returns the array of operators within a given `operatorEpoch`.\n    function operators(uint256 epoch) public view override returns (address[] memory results) {\n        uint256 operatorCount = _getOperatorCount(epoch);\n        results = new address[](operatorCount);\n\n        for (uint256 i; i < operatorCount; i++) {\n            results[i] = _getOperator(epoch, i);\n        }\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    function _setOperatorEpoch(uint256 epoch) internal {\n        _setUint(KEY_OPERATOR_EPOCH, epoch);\n    }\n\n    function _setOperator(\n        uint256 epoch,\n        uint256 index,\n        address account\n    ) internal {\n        _setAddress(_getOperatorKey(epoch, index), account);\n    }\n\n    function _setOperatorCount(uint256 epoch, uint256 operatorCount) internal {\n        _setUint(_getOperatorCountKey(epoch), operatorCount);\n    }\n\n    function _setOperators(\n        uint256 epoch,\n        address[] memory accounts,\n        uint256 threshold\n    ) internal {\n        uint256 accountLength = accounts.length;\n\n        if (accountLength < threshold) revert InvalidOperators();\n\n        if (threshold == uint256(0)) revert InvalidOperatorThreshold();\n\n        _setOperatorThreshold(epoch, threshold);\n        _setOperatorCount(epoch, accountLength);\n\n        for (uint256 i; i < accountLength; i++) {\n            address account = accounts[i];\n\n            // Check that the account wasn't already set as an operator for this operatorEpoch.\n            if (_isOperator(epoch, account)) revert DuplicateOperator(account);\n\n            if (account == address(0)) revert InvalidAddress();\n\n            // Set this account as the i-th operator in this operatorEpoch (needed to we can get all the operators for `operators`).\n            _setOperator(epoch, i, account);\n            _setIsOperator(epoch, account, true);\n        }\n    }\n\n    function _setOperatorThreshold(uint256 epoch, uint256 threshold) internal {\n        _setUint(_getOperatorThresholdKey(epoch), threshold);\n    }\n\n    function _setIsOperator(\n        uint256 epoch,\n        address account,\n        bool isOperator\n    ) internal {\n        _setBool(_getIsOperatorKey(epoch, account), isOperator);\n    }\n\n    /**********************\\\n    |* Self Functionality *|\n    \\**********************/\n\n    function deployToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddr) = abi.decode(\n            params,\n            (string, string, uint8, uint256, address)\n        );\n\n        _deployToken(name, symbol, decimals, cap, tokenAddr);\n    }\n\n    function mintToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));\n\n        _mintToken(symbol, account, amount);\n    }\n\n    function burnToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));\n\n        _burnToken(symbol, salt);\n    }\n\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));\n\n        _approveContractCall(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            string memory symbol,\n            uint256 amount,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));\n\n        _approveContractCallWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function transferOwnership(bytes calldata params, bytes32) external onlySelf {\n        (address[] memory newOwners, uint256 newThreshold) = abi.decode(params, (address[], uint256));\n\n        uint256 epoch = _ownerEpoch();\n\n        emit OwnershipTransferred(owners(epoch), _getOwnerThreshold(epoch), newOwners, newThreshold);\n\n        _setOwnerEpoch(++epoch);\n        _setOwners(epoch, newOwners, newThreshold);\n    }\n\n    function transferOperatorship(bytes calldata params, bytes32) external onlySelf {\n        (address[] memory newOperators, uint256 newThreshold) = abi.decode(params, (address[], uint256));\n\n        uint256 epoch = _operatorEpoch();\n\n        emit OperatorshipTransferred(operators(epoch), _getOperatorThreshold(epoch), newOperators, newThreshold);\n\n        _setOperatorEpoch(++epoch);\n        _setOperators(epoch, newOperators, newThreshold);\n    }\n\n    /**************************\\\n    |* External Functionality *|\n    \\**************************/\n\n    function setup(bytes calldata params) external override {\n        // Prevent setup from being called on a non-proxy (the implementation).\n        if (implementation() == address(0)) revert NotProxy();\n\n        (\n            address[] memory adminAddresses,\n            uint256 newAdminThreshold,\n            address[] memory ownerAddresses,\n            uint256 newOwnerThreshold,\n            address[] memory operatorAddresses,\n            uint256 newOperatorThreshold\n        ) = abi.decode(params, (address[], uint256, address[], uint256, address[], uint256));\n\n        uint256 newAdminEpoch = _adminEpoch() + uint256(1);\n        _setAdminEpoch(newAdminEpoch);\n        _setAdmins(newAdminEpoch, adminAddresses, newAdminThreshold);\n\n        uint256 newOwnerEpoch = _ownerEpoch() + uint256(1);\n        _setOwnerEpoch(newOwnerEpoch);\n        _setOwners(newOwnerEpoch, ownerAddresses, newOwnerThreshold);\n\n        uint256 newOperatorEpoch = _operatorEpoch() + uint256(1);\n        _setOperatorEpoch(newOperatorEpoch);\n        _setOperators(newOperatorEpoch, operatorAddresses, newOperatorThreshold);\n\n        emit OwnershipTransferred(new address[](uint256(0)), uint256(0), ownerAddresses, newOwnerThreshold);\n        emit OperatorshipTransferred(new address[](uint256(0)), uint256(0), operatorAddresses, newOperatorThreshold);\n    }\n\n    function execute(bytes calldata input) external override {\n        (bytes memory data, bytes[] memory signatures) = abi.decode(input, (bytes, bytes[]));\n\n        _execute(data, signatures);\n    }\n\n    function _execute(bytes memory data, bytes[] memory signatures) internal {\n        uint256 signatureCount = signatures.length;\n\n        address[] memory signers = new address[](signatureCount);\n\n        for (uint256 i; i < signatureCount; i++) {\n            signers[i] = ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(data)), signatures[i]);\n        }\n\n        (\n            uint256 chainId,\n            Role signersRole,\n            bytes32[] memory commandIds,\n            string[] memory commands,\n            bytes[] memory params\n        ) = abi.decode(data, (uint256, Role, bytes32[], string[], bytes[]));\n\n        if (chainId != block.chainid) revert InvalidChainId();\n\n        if (!_isSortedAscAndContainsNoDuplicate(signers)) revert MalformedSigners();\n\n        uint256 commandsLength = commandIds.length;\n\n        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\n\n        bool areValidCurrentOwners;\n        bool areValidRecentOwners;\n        bool areValidRecentOperators;\n\n        if (signersRole == Role.Owner) {\n            areValidCurrentOwners = _areValidOwnersInEpoch(_ownerEpoch(), signers);\n            areValidRecentOwners = areValidCurrentOwners || _areValidPreviousOwners(signers);\n        } else if (signersRole == Role.Operator) {\n            areValidRecentOperators = _areValidRecentOperators(signers);\n        }\n\n        for (uint256 i; i < commandsLength; i++) {\n            bytes32 commandId = commandIds[i];\n\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\n\n            bytes4 commandSelector;\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\n\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\n                if (!areValidRecentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.deployToken.selector;\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.mintToken.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.approveContractCall.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.approveContractCallWithMint.selector;\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.burnToken.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OWNERSHIP) {\n                if (!areValidCurrentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.transferOwnership.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\n                if (!areValidCurrentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.transferOperatorship.selector;\n            } else {\n                continue; /* Ignore if unknown command received */\n            }\n\n            // Prevent a re-entrancy from executing this command before it can be marked as successful.\n            _setCommandExecuted(commandId, true);\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n            _setCommandExecuted(commandId, success);\n\n            if (success) {\n                emit Executed(commandId);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/AxelarGatewayMultisig.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGatewayMultisig } from './interfaces/IAxelarGatewayMultisig.sol';\n\nimport { ECDSA } from './ECDSA.sol';\nimport { AxelarGateway } from './AxelarGateway.sol';\n\ncontract AxelarGatewayMultisig is IAxelarGatewayMultisig, AxelarGateway {\n    error InvalidAddress();\n    error InvalidOwners();\n    error InvalidOwnerThreshold();\n    error DuplicateOwner(address owner);\n    error InvalidOperators();\n    error InvalidOperatorThreshold();\n    error DuplicateOperator(address operator);\n    error NotProxy();\n    error InvalidChainId();\n    error MalformedSigners();\n    error InvalidCommands();\n\n    // AUDIT: slot names should be prefixed with some standard string\n    // AUDIT: constants should be literal and their derivation should be in comments\n    bytes32 internal constant KEY_OWNER_EPOCH = keccak256('owner-epoch');\n\n    bytes32 internal constant PREFIX_OWNER = keccak256('owner');\n    bytes32 internal constant PREFIX_OWNER_COUNT = keccak256('owner-count');\n    bytes32 internal constant PREFIX_OWNER_THRESHOLD = keccak256('owner-threshold');\n    bytes32 internal constant PREFIX_IS_OWNER = keccak256('is-owner');\n\n    bytes32 internal constant KEY_OPERATOR_EPOCH = keccak256('operator-epoch');\n\n    bytes32 internal constant PREFIX_OPERATOR = keccak256('operator');\n    bytes32 internal constant PREFIX_OPERATOR_COUNT = keccak256('operator-count');\n    bytes32 internal constant PREFIX_OPERATOR_THRESHOLD = keccak256('operator-threshold');\n    bytes32 internal constant PREFIX_IS_OPERATOR = keccak256('is-operator');\n\n    constructor(address tokenDeployer) AxelarGateway(tokenDeployer) {}\n\n    function _isSortedAscAndContainsNoDuplicate(address[] memory accounts) internal pure returns (bool) {\n        for (uint256 i; i < accounts.length - 1; ++i) {\n            if (accounts[i] >= accounts[i + 1]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /************************\\\n    |* Owners Functionality *|\n    \\************************/\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getOwnerKey(uint256 epoch, uint256 index) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OWNER, epoch, index));\n    }\n\n    function _getOwnerCountKey(uint256 epoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OWNER_COUNT, epoch));\n    }\n\n    function _getOwnerThresholdKey(uint256 epoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OWNER_THRESHOLD, epoch));\n    }\n\n    function _getIsOwnerKey(uint256 epoch, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_IS_OWNER, epoch, account));\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function _ownerEpoch() internal view returns (uint256) {\n        return getUint(KEY_OWNER_EPOCH);\n    }\n\n    function _getOwner(uint256 epoch, uint256 index) internal view returns (address) {\n        return getAddress(_getOwnerKey(epoch, index));\n    }\n\n    function _getOwnerCount(uint256 epoch) internal view returns (uint256) {\n        return getUint(_getOwnerCountKey(epoch));\n    }\n\n    function _getOwnerThreshold(uint256 epoch) internal view returns (uint256) {\n        return getUint(_getOwnerThresholdKey(epoch));\n    }\n\n    function _isOwner(uint256 epoch, address account) internal view returns (bool) {\n        return getBool(_getIsOwnerKey(epoch, account));\n    }\n\n    /// @dev Returns true if a sufficient quantity of `accounts` are owners within the last `OLD_KEY_RETENTION + 1` owner epochs (excluding the current one).\n    function _areValidPreviousOwners(address[] memory accounts) internal view returns (bool) {\n        uint256 epoch = _ownerEpoch();\n        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);\n        uint256 lowerBoundOwnerEpoch = epoch > recentEpochs ? epoch - recentEpochs : uint256(0);\n\n        --epoch;\n        while (epoch > lowerBoundOwnerEpoch) {\n            if (_areValidOwnersInEpoch(epoch--, accounts)) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev Returns true if a sufficient quantity of `accounts` are owners in the `ownerEpoch`.\n    function _areValidOwnersInEpoch(uint256 epoch, address[] memory accounts) internal view returns (bool) {\n        uint256 threshold = _getOwnerThreshold(epoch);\n        uint256 validSignerCount;\n\n        for (uint256 i; i < accounts.length; i++) {\n            if (_isOwner(epoch, accounts[i]) && ++validSignerCount >= threshold) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev Returns the current `ownerEpoch`.\n    function ownerEpoch() external view override returns (uint256) {\n        return _ownerEpoch();\n    }\n\n    /// @dev Returns the threshold for a given `ownerEpoch`.\n    function ownerThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getOwnerThreshold(epoch);\n    }\n\n    /// @dev Returns the array of owners within a given `ownerEpoch`.\n    function owners(uint256 epoch) public view override returns (address[] memory results) {\n        uint256 ownerCount = _getOwnerCount(epoch);\n        results = new address[](ownerCount);\n\n        for (uint256 i; i < ownerCount; i++) {\n            results[i] = _getOwner(epoch, i);\n        }\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    function _setOwnerEpoch(uint256 epoch) internal {\n        _setUint(KEY_OWNER_EPOCH, epoch);\n    }\n\n    function _setOwner(\n        uint256 epoch,\n        uint256 index,\n        address account\n    ) internal {\n        if (account == address(0)) revert InvalidAddress();\n\n        _setAddress(_getOwnerKey(epoch, index), account);\n    }\n\n    function _setOwnerCount(uint256 epoch, uint256 ownerCount) internal {\n        _setUint(_getOwnerCountKey(epoch), ownerCount);\n    }\n\n    function _setOwners(\n        uint256 epoch,\n        address[] memory accounts,\n        uint256 threshold\n    ) internal {\n        uint256 accountLength = accounts.length;\n\n        if (accountLength < threshold) revert InvalidOwners();\n\n        if (threshold == uint256(0)) revert InvalidOwnerThreshold();\n\n        _setOwnerThreshold(epoch, threshold);\n        _setOwnerCount(epoch, accountLength);\n\n        for (uint256 i; i < accountLength; i++) {\n            address account = accounts[i];\n\n            // Check that the account wasn't already set as an owner for this ownerEpoch.\n            if (_isOwner(epoch, account)) revert DuplicateOwner(account);\n\n            // Set this account as the i-th owner in this ownerEpoch (needed to we can get all the owners for `owners`).\n            _setOwner(epoch, i, account);\n            _setIsOwner(epoch, account, true);\n        }\n    }\n\n    function _setOwnerThreshold(uint256 epoch, uint256 threshold) internal {\n        _setUint(_getOwnerThresholdKey(epoch), threshold);\n    }\n\n    function _setIsOwner(\n        uint256 epoch,\n        address account,\n        bool isOwner\n    ) internal {\n        _setBool(_getIsOwnerKey(epoch, account), isOwner);\n    }\n\n    /**************************\\\n    |* Operator Functionality *|\n    \\**************************/\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getOperatorKey(uint256 epoch, uint256 index) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR, epoch, index));\n    }\n\n    function _getOperatorCountKey(uint256 epoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR_COUNT, epoch));\n    }\n\n    function _getOperatorThresholdKey(uint256 epoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR_THRESHOLD, epoch));\n    }\n\n    function _getIsOperatorKey(uint256 epoch, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_IS_OPERATOR, epoch, account));\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function _operatorEpoch() internal view returns (uint256) {\n        return getUint(KEY_OPERATOR_EPOCH);\n    }\n\n    function _getOperator(uint256 epoch, uint256 index) internal view returns (address) {\n        return getAddress(_getOperatorKey(epoch, index));\n    }\n\n    function _getOperatorCount(uint256 epoch) internal view returns (uint256) {\n        return getUint(_getOperatorCountKey(epoch));\n    }\n\n    function _getOperatorThreshold(uint256 epoch) internal view returns (uint256) {\n        return getUint(_getOperatorThresholdKey(epoch));\n    }\n\n    function _isOperator(uint256 epoch, address account) internal view returns (bool) {\n        return getBool(_getIsOperatorKey(epoch, account));\n    }\n\n    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the same `operatorEpoch`, within the last `OLD_KEY_RETENTION + 1` operator epochs.\n    function _areValidRecentOperators(address[] memory accounts) internal view returns (bool) {\n        uint256 epoch = _operatorEpoch();\n        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);\n        uint256 lowerBoundOperatorEpoch = epoch > recentEpochs ? epoch - recentEpochs : uint256(0);\n\n        while (epoch > lowerBoundOperatorEpoch) {\n            if (_areValidOperatorsInEpoch(epoch--, accounts)) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the `operatorEpoch`.\n    function _areValidOperatorsInEpoch(uint256 epoch, address[] memory accounts) internal view returns (bool) {\n        uint256 threshold = _getOperatorThreshold(epoch);\n        uint256 validSignerCount;\n\n        for (uint256 i; i < accounts.length; i++) {\n            if (_isOperator(epoch, accounts[i]) && ++validSignerCount >= threshold) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev Returns the current `operatorEpoch`.\n    function operatorEpoch() external view override returns (uint256) {\n        return _operatorEpoch();\n    }\n\n    /// @dev Returns the threshold for a given `operatorEpoch`.\n    function operatorThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getOperatorThreshold(epoch);\n    }\n\n    /// @dev Returns the array of operators within a given `operatorEpoch`.\n    function operators(uint256 epoch) public view override returns (address[] memory results) {\n        uint256 operatorCount = _getOperatorCount(epoch);\n        results = new address[](operatorCount);\n\n        for (uint256 i; i < operatorCount; i++) {\n            results[i] = _getOperator(epoch, i);\n        }\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    function _setOperatorEpoch(uint256 epoch) internal {\n        _setUint(KEY_OPERATOR_EPOCH, epoch);\n    }\n\n    function _setOperator(\n        uint256 epoch,\n        uint256 index,\n        address account\n    ) internal {\n        _setAddress(_getOperatorKey(epoch, index), account);\n    }\n\n    function _setOperatorCount(uint256 epoch, uint256 operatorCount) internal {\n        _setUint(_getOperatorCountKey(epoch), operatorCount);\n    }\n\n    function _setOperators(\n        uint256 epoch,\n        address[] memory accounts,\n        uint256 threshold\n    ) internal {\n        uint256 accountLength = accounts.length;\n\n        if (accountLength < threshold) revert InvalidOperators();\n\n        if (threshold == uint256(0)) revert InvalidOperatorThreshold();\n\n        _setOperatorThreshold(epoch, threshold);\n        _setOperatorCount(epoch, accountLength);\n\n        for (uint256 i; i < accountLength; i"
    }
  ]
}