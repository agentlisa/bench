{
  "Title": "M-11: If a hat is owned by address(0), phony signatures will be accepted by the safe",
  "Content": "# Issue M-11: If a hat is owned by address(0), phony signatures will be accepted by the safe \n\nSource: https://github.com/sherlock-audit/2023-02-hats-judging/issues/39 \n\n## Found by \nobront, duc\n\n## Summary\n\nIf a hat is sent to `address(0)`, the multisig will be fooled into accepting phony signatures on its behalf. This will throw off the proper accounting of signatures, allowing non-majority transactions to pass and potentially allowing users to steal funds.\n\n## Vulnerability Detail\n\nIn order to validate that all signers of a transaction are valid signers, `HatsSignerGateBase.sol` implements the `countValidSignatures()` function, which recovers the signer for each signature and checks `isValidSigner()` on them.\n\nThe function uses `ecrecover` to get the signer. However, `ecrecover` is well known to return `address(0)` in the event that a phony signature is passed with a `v` value other than 27 or 28. See [this example](https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d) for how this can be done.\n\nIn the event that this is a base with only a single hat approved for signing, the `isValidSigner()` function will simply check if the owner is the wearer of a hat:\n```solidity\nfunction isValidSigner(address _account) public view override returns (bool valid) {\n    valid = HATS.isWearerOfHat(_account, signersHatId);\n}\n```\nOn the `Hats.sol` contract, this simply checks their balance:\n```solidity\nfunction isWearerOfHat(address _user, uint256 _hatId) public view returns (bool isWearer) {\n    isWearer = (balanceOf(_user, _hatId) > 0);\n}\n```\n... which only checks if it is active or eligible...\n```solidity\nfunction balanceOf(address _wearer, uint256 _hatId)\n    public\n    view\n    override(ERC1155, IHats)\n    returns (uint256 balance)\n{\n    Hat storage hat = _hats[_hatId];\n\n    balance = 0;\n\n    if (_isActive(hat, _hatId) && _isEligible(_wearer, hat, _hatId)) {\n        balance = super.balanceOf(_wearer, _hatId);\n    }\n}\n```\n... which calls out to ERC1155, which just returns the value in storage (without any address(0) check)...\n```solidity\nfunction balanceOf(address owner, uint256 id) public view virtual returns (uint256 balance) {\n    balance = _balanceOf[owner][id];\n}\n```\n\nThe result is that, if a hat ends up owned by `address(0)` for any reason, this will give blanket permission for anyone to create a phony signature that will be accepted by the safe.\n\nYou could imagine a variety of situations where this may apply:\n- An admin minting a mutable hat to address(0) to adjust the supply while waiting for a delegatee to send over their address to transfer the hat to\n- An admin sending a hat to address(0) because there is some reason why they need the supply slightly inflated\n- An admin accidentally sending a hat to address(0) to burn it\n\nNone of these examples are extremely likely, but there would be no reason for the admin to think they were putting their multisig at risk for doing so. However, the result would be a free signer on the multisig, which would have dramatic consequences.\n\n## Impact\n\nIf a hat is sent to `address(0)`, any phony signature can be accepted by the safe, leading to transactions without sufficient support being executed. \n\nThis is particularly dangerous in a 2/3 situation, where this issue would be sufficient for a single party to perform arbitrary transactions.\n\n## Code Snippet\n\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L547-L591\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe easiest option is to add a check in `countValidSignatures()` that confirms that `currentOwner != address(0)` after each iteration.\n\nFor extra security, you may consider implementing a check in `balanceOf()` that errors if we use `address(0)` as the address to check. (This is what OpenZeppelin does in their ERC721 implementation: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7f028d69593342673492b0a0b1679e2a898cf1cf/contracts/token/ERC721/ERC721.sol#L62-L65)\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/48",
  "Code": [
    {
      "filename": "src/HatsSignerGateBase.sol",
      "content": "// SPDX-License-Identifier: CC0\npragma solidity >=0.8.13;\n\nimport { Test, console2 } from \"forge-std/Test.sol\"; // remove after testing\nimport \"./HSGLib.sol\";\nimport { HatsOwnedInitializable } from \"hats-auth/HatsOwnedInitializable.sol\";\nimport { BaseGuard } from \"zodiac/guard/BaseGuard.sol\";\nimport { IAvatar } from \"zodiac/interfaces/IAvatar.sol\";\nimport { StorageAccessible } from \"@gnosis.pm/safe-contracts/contracts/common/StorageAccessible.sol\";\nimport { IGnosisSafe, Enum } from \"./Interfaces/IGnosisSafe.sol\";\nimport { SignatureDecoder } from \"@gnosis.pm/safe-contracts/contracts/common/SignatureDecoder.sol\";\n\nabstract contract HatsSignerGateBase is BaseGuard, SignatureDecoder, HatsOwnedInitializable {\n    /// @notice The multisig to which this contract is attached\n    IGnosisSafe public safe;\n\n    /// @notice The minimum signature threshold for the `safe`\n    uint256 public minThreshold;\n\n    /// @notice The highest level signature threshold for the `safe`\n    uint256 public targetThreshold;\n\n    /// @notice The maximum number of signers allowed for the `safe`\n    uint256 public maxSigners;\n\n    /// @notice The current number of signers on the `safe`\n    uint256 public signerCount;\n\n    /// @notice The version of HatsSignerGate used in this contract\n    string public version;\n\n    /// @notice The number of modules enabled on the `safe`, as enabled via this contract\n    uint256 public enabledModuleCount;\n\n    /// @dev Temporary record of the existing modules on the `safe` when a transaction is submitted\n    bytes32 internal _existingModulesHash;\n    \n    /// @dev A simple re-entrency guard\n    uint256 internal _guardEntries;\n\n    /// @dev The head pointer used in the GnosisSafe owners linked list, as well as the module linked list\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    /// @dev The storage slot used by GnosisSafe to store the guard address\n    ///      keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Makes the singleton unusable by setting its owner to the 1-address\n    constructor() payable initializer {\n        _HatsOwned_init(1, address(0x1));\n    }\n\n    /// @notice Initializes a new instance\n    /// @dev Can only be called once\n    /// @param initializeParams ABI-encoded bytes with initialization parameters\n    function setUp(bytes calldata initializeParams) public payable virtual initializer { }\n\n    /// @notice Internal function to initialize a new instance\n    /// @param _ownerHatId The hat id of the hat that owns this instance of HatsSignerGate\n    /// @param _safe The multisig to which this instance of HatsSignerGate is attached\n    /// @param _hats The Hats Protocol address\n    /// @param _minThreshold The minimum threshold for the `_safe`\n    /// @param _targetThreshold The maxium threshold for the `_safe`\n    /// @param _maxSigners The maximum number of signers allowed on the `_safe`\n    /// @param _version The current version of HatsSignerGate\n    function _setUp(\n        uint256 _ownerHatId,\n        address _safe,\n        address _hats,\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners,\n        string memory _version,\n        uint256 _existingModuleCount\n    ) internal {\n        _HatsOwned_init(_ownerHatId, _hats);\n        maxSigners = _maxSigners;\n        safe = IGnosisSafe(_safe);\n\n        _setTargetThreshold(_targetThreshold);\n        _setMinThreshold(_minThreshold);\n        version = _version;\n        enabledModuleCount = _existingModuleCount + 1; // this contract is enabled as well\n    }\n\n    /// @notice Checks if `_account` is a valid signer\n    /// @dev Must be implemented by all flavors of HatsSignerGate\n    /// @param _account The address to check\n    /// @return valid Whether `_account` is a valid signer\n    function isValidSigner(address _account) public view virtual returns (bool valid) { }\n\n    /// @notice Sets a new target threshold, and changes `safe`'s threshold if appropriate\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_targetThreshold` is greater than `maxSigners`.\n    /// @param _targetThreshold The new target threshold to set\n    function setTargetThreshold(uint256 _targetThreshold) public onlyOwner {\n        if (_targetThreshold != targetThreshold) {\n            _setTargetThreshold(_targetThreshold);\n\n            if (signerCount > 1) _setSafeThreshold(_targetThreshold);\n\n            emit HSGLib.TargetThresholdSet(_targetThreshold);\n        }\n    }\n\n    /// @notice Internal function to set the target threshold\n    /// @dev Reverts if `_targetThreshold` is greater than `maxSigners`\n    /// @param _targetThreshold The new target threshold to set\n    function _setTargetThreshold(uint256 _targetThreshold) internal {\n        if (_targetThreshold > maxSigners) {\n            revert InvalidTargetThreshold();\n        }\n\n        targetThreshold = _targetThreshold;\n    }\n\n    /// @notice Internal function to set the threshold for the `safe`\n    /// @dev Forwards the threshold-setting call to `safe.ExecTransactionFromModule`\n    /// @param _threshold The threshold to set on the `safe`\n    function _setSafeThreshold(uint256 _threshold) internal {\n        uint256 newThreshold = _threshold;\n        uint256 signerCount_ = signerCount; // save an SLOAD\n\n        // ensure that txs can't execute if fewer signers than target threshold\n        if (signerCount_ <= _threshold) {\n            newThreshold = signerCount_;\n        }\n        if (newThreshold != safe.getThreshold()) {\n            bytes memory data = abi.encodeWithSignature(\"changeThreshold(uint256)\", newThreshold);\n\n            bool success = safe.execTransactionFromModule(\n                address(safe), // to\n                0, // value\n                data, // data\n                Enum.Operation.Call // operation\n            );\n\n            if (!success) {\n                revert FailedExecChangeThreshold();\n            }\n        }\n    }\n\n    /// @notice Sets a new minimum threshold\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_minThreshold` is greater than `maxSigners` or `targetThreshold`\n    /// @param _minThreshold The new minimum threshold\n    function setMinThreshold(uint256 _minThreshold) public onlyOwner {\n        _setMinThreshold(_minThreshold);\n        emit HSGLib.MinThresholdSet(_minThreshold);\n    }\n\n    /// @notice Internal function to set a new minimum threshold\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_minThreshold` is greater than `maxSigners` or `targetThreshold`\n    /// @param _minThreshold The new minimum threshold\n    function _setMinThreshold(uint256 _minThreshold) internal {\n        if (_minThreshold > maxSigners || _minThreshold > targetThreshold) {\n            revert InvalidMinThreshold();\n        }\n\n        minThreshold = _minThreshold;\n    }\n\n    /// @notice Allows the owner to enable a new module on the `safe`\n    /// @dev Increments the `enabledModuleCount` to include the new module in the allowed list (see `checkTransaction` and `checkAfterExecution`)\n    /// @param _module The address of the module to enable\n    function enableNewModule(address _module) external onlyOwner {\n        ++enabledModuleCount;\n\n        bytes memory data = abi.encodeWithSignature(\"enableModule(address)\", _module);\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            data, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecEnableModule();\n        }\n    }\n\n    /// @notice Tallies the number of existing `safe` owners that wear a signer hat, sets `signerCount` to that value, and updates the `safe` threshold if necessary\n    /// @dev Does NOT remove invalid `safe` owners\n    function reconcileSignerCount() public {\n        address[] memory owners = safe.getOwners();\n        uint256 validSignerCount = _countValidSigners(owners);\n\n        if (validSignerCount > maxSigners) {\n            revert MaxSignersReached();\n        }\n\n        // update the signer count accordingly\n        signerCount = validSignerCount;\n\n        uint256 currentThreshold = safe.getThreshold();\n        uint256 newThreshold;\n        uint256 target = targetThreshold; // save SLOADs\n\n        if (validSignerCount <= target && validSignerCount != currentThreshold) {\n            newThreshold = validSignerCount;\n        } else if (validSignerCount > target && currentThreshold < target) {\n            newThreshold = target;\n        }\n        if (newThreshold > 0) {\n            bytes memory data = abi.encodeWithSignature(\"changeThreshold(uint256)\", validSignerCount);\n\n            bool success = safe.execTransactionFromModule(\n                address(safe), // to\n                0, // value\n                data, // data\n                Enum.Operation.Call // operation\n            );\n\n            if (!success) {\n                revert FailedExecChangeThreshold();\n            }\n        }\n    }\n\n    /// @notice Internal function to count the number of valid signers in an array of addresses\n    /// @param owners The addresses to check for validity\n    /// @return validSignerCount The number of valid signers in `owners`\n    function _countValidSigners(address[] memory owners) internal view returns (uint256 validSignerCount) {\n        uint256 length = owners.length;\n        // count the existing safe owners that wear the signer hat\n        for (uint256 i; i < length;) {\n            if (isValidSigner(owners[i])) {\n                // shouldn't overflow given reasonable owners array length\n                unchecked {\n                    ++validSignerCount;\n                }\n            }\n            // shouldn't overflow given reasonable owners array length\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Internal function that adds `_signer` as an owner on `safe`, updating the threshold if appropriate\n    /// @dev Unsafe. Does not check if `_signer` is a valid signer\n    /// @param _owners Array of owners on the `safe`\n    /// @param _currentSignerCount The current number of signers\n    /// @param _signer The address to add as a new `safe` owner\n    function _grantSigner(address[] memory _owners, uint256 _currentSignerCount, address _signer) internal {\n        uint256 newSignerCount = _currentSignerCount;\n\n        uint256 currentThreshold = safe.getThreshold(); // view function\n        uint256 newThreshold = currentThreshold;\n\n        bytes memory addOwnerData;\n\n        // if the only owner is a non-signer (ie this module set as an owner on initialization), replace it with _signer\n        if (_owners.length == 1 && _owners[0] == address(this)) {\n            // prevOwner will always be the sentinel when owners.length == 1\n\n            // set up the swapOwner call\n            addOwnerData = abi.encodeWithSignature(\n                \"swapOwner(address,address,address)\",\n                SENTINEL_OWNERS, // prevOwner\n                address(this), // oldOwner\n                _signer // newOwner\n            );\n            unchecked {\n                // shouldn't overflow given MaxSignersReached check higher in call stack\n                ++newSignerCount;\n            }\n        } else {\n            // otherwise, add the claimer as a new owner\n\n            unchecked {\n                // shouldn't overflow given MaxSignersReached check higher in call stack\n                ++newSignerCount;\n            }\n\n            // ensure that txs can't execute if fewer signers than target threshold\n            if (newSignerCount <= targetThreshold) {\n                newThreshold = newSignerCount;\n            }\n\n            // set up the addOwner call\n            addOwnerData = abi.encodeWithSignature(\"addOwnerWithThreshold(address,uint256)\", _signer, newThreshold);\n        }\n\n        // increment signer count\n        signerCount = newSignerCount;\n\n        // execute the call\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            addOwnerData, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecAddSigner();\n        }\n    }\n\n    /// @notice Internal function that adds `_signer` as an owner on `safe` by swapping with an existing (invalid) owner\n    /// @dev Unsafe. Does not check if `_signer` is a valid signer.\n    /// @param _owners Array of owners on the `safe`\n    /// @param _ownerCount The number of owners on the `safe` (length of `_owners` array)\n    /// @param _maxSigners The maximum number of signers allowed\n    /// @param _currentSignerCount The current number of signers\n    /// @param _signer The address to add as a new `safe` owner\n    /// @return success Whether an invalid signer was found and successfully replaced with `_signer`\n    function _swapSigner(\n        address[] memory _owners,\n        uint256 _ownerCount,\n        uint256 _maxSigners,\n        uint256 _currentSignerCount,\n        address _signer\n    ) internal returns (bool success) {\n        address ownerToCheck;\n        bytes memory data;\n\n        for (uint256 i; i < _ownerCount - 1;) {\n            ownerToCheck = _owners[i];\n\n            if (!isValidSigner(ownerToCheck)) {\n                // prep the swap\n                data = abi.encodeWithSignature(\n                    \"swapOwner(address,address,address)\",\n                    _findPrevOwner(_owners, ownerToCheck), // prevOwner\n                    ownerToCheck, // oldOwner\n                    _signer // newOwner\n                );\n\n                // execute the swap, reverting if it fails for some reason\n                success = safe.execTransactionFromModule(\n                    address(safe), // to\n                    0, // value\n                    data, // data\n                    Enum.Operation.Call // operation\n                );\n\n                if (!success) {\n                    revert FailedExecRemoveSigner();\n                }\n\n                // increment the signer count if signerCount was correct, ie `reconcileSignerCount` was called prior\n                if (_currentSignerCount < _maxSigners) ++signerCount;\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Removes an invalid signer from the `safe`, updating the threshold if appropriate\n    /// @param _signer The address to remove if not a valid signer\n    function removeSigner(address _signer) public virtual {\n        if (isValidSigner(_signer)) {\n            revert StillWearsSignerHat(_signer);\n        }\n\n        _removeSigner(_signer);\n    }\n\n    /// @notice Internal function to remove a signer from the `safe`, updating the threshold if appropriate\n    /// @dev Unsafe. Does not check for signer validity before removal\n    /// @param _signer The address to remove\n    function _removeSigner(address _signer) internal {\n        bytes memory removeOwnerData;\n        address[] memory owners = safe.getOwners();\n        uint256 currentSignerCount = signerCount; // save an SLOAD\n        uint256 newSignerCount;\n\n        if (currentSignerCount < 2 && owners.length == 1) {\n            // signerCount could be 0 after reconcileSignerCount\n            // make address(this) the only owner\n            removeOwnerData = abi.encodeWithSignature(\n                \"swapOwner(address,address,address)\",\n                SENTINEL_OWNERS, // prevOwner\n                _signer, // oldOwner\n                address(this) // newOwner\n            );\n\n            // newSignerCount is already 0\n        } else {\n            uint256 currentThreshold = safe.getThreshold();\n            uint256 newThreshold = currentThreshold;\n            uint256 validSignerCount = _countValidSigners(owners);\n\n            if (validSignerCount == currentSignerCount) {\n                newSignerCount = currentSignerCount;\n            } else {\n                newSignerCount = currentSignerCount - 1;\n            }\n\n            // ensure that txs can't execute if fewer signers than target threshold\n            if (newSignerCount <= targetThreshold) {\n                newThreshold = newSignerCount;\n            }\n\n            removeOwnerData = abi.encodeWithSignature(\n                \"removeOwner(address,address,uint256)\", _findPrevOwner(owners, _signer), _signer, newThreshold\n            );\n        }\n\n        // update signerCount\n        signerCount = newSignerCount;\n\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            removeOwnerData, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecRemoveSigner();\n        }\n    }\n\n    /// @notice Internal function to find the previous owner of an `_owner` in an array of `_owners`, ie the pointer to the owner to remove from the `safe` owners linked list\n    /// @param _owners An array of addresses\n    /// @param _owner The address after the one to find\n    /// @return prevOwner The owner previous to `_owner` in the `safe` linked list\n    function _findPrevOwner(address[] memory _owners, address _owner) internal pure returns (address prevOwner) {\n        prevOwner = SENTINEL_OWNERS;\n\n        for (uint256 i; i < _owners.length;) {\n            if (_owners[i] == _owner) {\n                if (i == 0) break;\n                prevOwner = _owners[i - 1];\n            }\n            // shouldn't overflow given reasonable _owners array length\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // solhint-disallow-next-line payable-fallback\n    fallback() external {\n        // We don't revert on fallback to avoid issues in case of a Safe upgrade\n        // E.g. The expected check method might change and then the Safe would be locked.\n    }\n\n    /// @notice Pre-flight check on a `safe` transaction to ensure that it s signers are valid, called from within `safe.execTransactionFromModule()`\n    /// @dev Overrides All params mirror params for `safe.execTransactionFromModule()`\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address // msgSender\n    ) external override {\n        if (msg.sender != address(safe)) revert NotCalledFromSafe();\n\n        uint256 safeOwnerCount = safe.getOwners().length;\n        // uint256 validSignerCount = _countValidSigners(safe.getOwners());\n\n        // ensure that safe threshold is correct\n        reconcileSignerCount();\n\n        if (safeOwnerCount < minThreshold) {\n            revert BelowMinThreshold(minThreshold, safeOwnerCount);\n        }\n\n        // get the tx hash; view function\n        bytes32 txHash = safe.getTransactionHash(\n            // Transaction info\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            // Payment info\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver,\n            // Signature info\n            // We subtract 1 since nonce was just incremented in the parent function call\n            safe.nonce() - 1 // view function\n        );\n\n        uint256 validSigCount = countValidSignatures(txHash, signatures, signatures.length / 65);\n\n        // revert if there aren't enough valid signatures\n        if (validSigCount < safe.getThreshold() || validSigCount < minThreshold) {\n            revert InvalidSigners();\n        }\n\n        // record existing modules for post-flight check\n        // SENTINEL_OWNERS and SENTINEL_MODULES are both address(0x1)\n        (address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount);\n        _existingModulesHash = keccak256(abi.encode(modules));\n\n        unchecked {\n            ++_guardEntries;\n        }\n    }\n\n    /// @notice Post-flight check to prevent `safe` signers from removing this contract guard, changing any modules, or changing the threshold\n    /// @dev Modified from https://github.com/gnosis/zodiac-guard-mod/blob/988ebc7b71e352f121a0be5f6ae37e79e47a4541/contracts/ModGuard.sol#L86\n    function checkAfterExecution(bytes32, bool) external override {\n        if (msg.sender != address(safe)) revert NotCalledFromSafe();\n\n        if (\n            abi.decode(StorageAccessible(address(safe)).getStorageAt(uint256(GUARD_STORAGE_SLOT), 1), (address))\n                != address(this)\n        ) {\n            revert CannotDisableThisGuard(address(this));\n        }\n\n        if (safe.getThreshold() != _getCorrectThreshold()) {\n            revert SignersCannotChangeThreshold();\n        }\n\n        // SENTINEL_OWNERS and SENTINEL_MODULES are both address(0x1)\n        (address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount + 1);\n        if (keccak256(abi.encode(modules)) != _existingModulesHash) {\n            revert SignersCannotChangeModules();\n        }\n\n        // leave checked to catch underflows triggered by re-erntry attempts\n        --_guardEntries;\n    }\n\n    /// @notice Internal function to calculate the threshold that `safe` should have, given the correct `signerCount`, `minThreshold`, and `targetThreshold`\n    /// @return _threshold The correct threshold\n    function _getCorrectThreshold() internal view returns (uint256 _threshold) {\n        uint256 count = _countValidSigners(safe.getOwners());\n        uint256 min = minThreshold;\n        uint256 max = targetThreshold;\n        if (count < min) _threshold = min;\n        else if (count > max) _threshold = max;\n        else _threshold = count;\n    }\n\n    /// @notice Counts the number of hats-valid signatures within a set of `signatures`\n    /// @dev modified from https://github.com/safe-global/safe-contracts/blob/c36bcab46578a442862d043e12a83fec41143dec/contracts/GnosisSafe.sol#L240\n    /// @param dataHash The signed data\n    /// @param signatures The set of signatures to check\n    /// @return validSigCount The number of hats-valid signatures\n    function countValidSignatures(bytes32 dataHash, bytes memory signatures, uint256 sigCount)\n        public\n        view\n        returns (uint256 validSigCount)\n    {\n        // There cannot be an owner with address 0.\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n\n        for (i; i < sigCount;) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner =\n                    ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n\n            if (isValidSigner(currentOwner)) {\n                // shouldn't overflow given reasonable sigCount\n                unchecked {\n                    ++validSigCount;\n                }\n            }\n            // shouldn't overflow given reasonable sigCount\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/token/ERC721/ERC721.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _che"
    }
  ]
}