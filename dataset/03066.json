{
  "Title": "Misconfiguration could lead to blocking bids",
  "Content": "In the [`_processBid` function](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L105) of the [`AuctionBase` contract](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L105) the time details of the auction are checked. These times are:\n\n\n* `extendableUntil` – The time until an auction may be extended through late bids.\n* `expirationTime` – The time until an asset must be transferred. Otherwise, the payment can be refunded by the user afterwards.\n\n\nThe requirement of [line 118](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L118) checks the following:\n\n\n\n\n```\nextendableUntil + _SAFETY_TRANSFER_WINDOW < expirationTime\n\n```\n\n\nHere, the `_SAFETY_TRANSFER_WINDOW` is a constant value of two hours. Therefore, the auction must expire after the longest possible duration, including enough time to transfer the asset. Further, substituting the values of `extendableUntil` and `expirationTime` and simplifying the inequation we receive:\n\n\n\n\n```\nuniverseExtendableBy(bidInput.universeId) + _SAFETY_TRANSFER_WINDOW < _paymentWindow\n\n```\n\n\nBoth values, `universeExtendableBy()` and `_paymentWindow`, are configurable by the contract owner. In the case that the system accidentally is configured to never satisfy the above condition, the requirement would always fail and so would calls to bid. No bids on new auctions would be processed, shutting down all upcoming auctions.\n\n\nConsider moving this requirement and adding additional checks when setting these configurations.\n\n\n***Update**: Fixed with commit `ef597b1` of [PR#16](https://github.com/freeverseio/crypto-payments/pull/16).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/auction/base/AuctionBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\nimport \"./IAuctionBase.sol\";\nimport \"../../buyNow/base/BuyNowBase.sol\";\n\n/**\n * @title Base Escrow Contract for Payments, that adds an Auction mode\n *  to the inherited BuyNowBase, which implements the BuyNow mode.\n * @author Freeverse.io, www.freeverse.io\n * @notice Full contract documentation in IAuctionBase\n */\n\nabstract contract AuctionBase is IAuctionBase, BuyNowBase {\n    // min amount of time that needs to be guaranteed between the maximum\n    // extension of an auction and the expirationTime, beyond which\n    // buyers can be refunded, to leave time for asset transfer.\n    uint256 private constant _SAFETY_TRANSFER_WINDOW = 2 hours;\n\n    // the default config parameters used by Auctions\n    AuctionConfig internal _defaultAuctionConfig;\n\n    // mapping between universeId and their specific auction config parameters\n    mapping(uint256 => AuctionConfig) private _universeAuctionConfig;\n\n    // mapping between universeId and whether a specific auction config exists\n    // for that universe\n    mapping(uint256 => bool) public _universeAuctionConfigExists;\n\n    // mapping between existing paymentsIds for auctions,\n    // and the stored data about these Auctions\n    mapping(bytes32 => ExistingAuction) private _auctions;\n\n    constructor(\n        uint256 minIncreasePercentage,\n        uint256 time2Extend,\n        uint256 extendableBy\n    ) {\n        _defaultAuctionConfig = _createAuctionConfig(\n            minIncreasePercentage,\n            time2Extend,\n            extendableBy\n        );\n        emit DefaultAuctionConfig(minIncreasePercentage, time2Extend, extendableBy);\n    }\n\n    /// @inheritdoc IAuctionBase\n    function setDefaultAuctionConfig(\n        uint256 minIncreasePercentage,\n        uint256 time2Extend,\n        uint256 extendableBy\n    ) external onlyOwner {\n        _defaultAuctionConfig = _createAuctionConfig(\n            minIncreasePercentage,\n            time2Extend,\n            extendableBy\n        );\n        emit DefaultAuctionConfig(minIncreasePercentage, time2Extend, extendableBy);\n    }\n\n    /// @inheritdoc IAuctionBase\n    function setUniverseAuctionConfig(\n        uint256 universeId,\n        uint256 minIncreasePercentage,\n        uint256 time2Extend,\n        uint256 extendableBy\n    ) external onlyOwner {\n        _universeAuctionConfig[universeId] = _createAuctionConfig(\n            minIncreasePercentage,\n            time2Extend,\n            extendableBy\n        );\n        _universeAuctionConfigExists[universeId] = true;\n        emit UniverseAuctionConfig(\n            universeId,\n            minIncreasePercentage,\n            time2Extend,\n            extendableBy\n        );\n    }\n\n    /// @inheritdoc IAuctionBase\n    function removeUniverseAuctionConfig(uint256 universeId)\n        external\n        onlyOwner\n    {\n        delete _universeAuctionConfig[universeId];\n        _universeAuctionConfigExists[universeId] = false;\n        emit RemovedUniverseAuctionConfig(universeId);\n    }\n\n    // PRIVATE & INTERNAL FUNCTIONS\n\n    /**\n     * @dev Checks bid input parameters,\n     *  transfers required funds from external contract (in case of ERC20 Payments),\n     *  reuses buyer's local balance (if any),\n     *  stores the payment and auction data in contract's storage,\n     *  and refunds previous highest bidder (if any).\n     *  - If payment is in NOT_STARTED => it moves to AUCTIONING\n     *  - If payment is in AUCTIONING => it remains in AUCTIONING\n     * @param bidInput The BidInput struct\n     * @param operator The address of the operator of this payment.\n     */\n    function _processBid(address operator, BidInput memory bidInput) internal {\n        State state = assertBidInputsOK(bidInput);\n        assertSeparateRoles(operator, bidInput.bidder, bidInput.seller);\n        (uint256 newFundsNeeded, uint256 localFunds, bool isSameBidder) = splitAuctionFundingSources(bidInput);\n        _updatePayerBalanceOnPaymentReceived(bidInput.bidder, newFundsNeeded, localFunds);\n\n        if (state == State.NotStarted) {\n            // If 1st bid for auction => new auction is to be created:\n            // 1.- revert unless enough time is left between maximum extension and expirationTime,\n            //     so that there is enough time to conduct assetTransfer\n            uint256 extendableUntil = bidInput.endsAt + universeExtendableBy(bidInput.universeId);\n            uint256 expirationTime = bidInput.endsAt + _paymentWindow;\n            require(\n                extendableUntil + _SAFETY_TRANSFER_WINDOW < expirationTime,\n                \"cannot start auction that is extendable too close to expiration time\"\n            );\n            // 2.- store the part of the data common to Auctions and BuyNows;\n            //     maxBidder and maxBid are stored in this struct, and updated on successive bids\n            _payments[bidInput.paymentId] = Payment(\n                State.Auctioning,\n                bidInput.bidder,\n                bidInput.seller,\n                operator,\n                universeFeesCollector(bidInput.universeId),\n                expirationTime,\n                bidInput.feeBPS,\n                bidInput.bidAmount\n            );\n            // 3.- store the part of the data only relevant to Auctions;\n            //     only 'endsAt' may change in this struct (and only on arrival of late bids)\n            _auctions[bidInput.paymentId] = ExistingAuction(\n                bidInput.endsAt,\n                universeMinIncreasePercentage(bidInput.universeId),\n                universeTimeToExtend(bidInput.universeId),\n                extendableUntil\n            );\n        } else {\n            // If an auction already existed:\n            if (!isSameBidder) {\n                // if new bidder is different from previous max bidder:\n                // - and refund previous max bidder\n                _refundPreviousBidder(bidInput);\n\n                // - update max bidder\n                _payments[bidInput.paymentId].buyer = bidInput.bidder;\n\n            }\n\n            // 2.- update the previous highest bid\n            _payments[bidInput.paymentId].amount = bidInput.bidAmount;\n        }\n\n        // extend auction ending time if classified as late bid:\n        uint256 endsAt = _extendAuctionOnLateBid(bidInput);\n\n        emit Bid(bidInput.paymentId, bidInput.bidder, bidInput.seller, bidInput.bidAmount, endsAt);\n    }\n\n    /**\n     * @dev Interface to a method that, on arrival of a bid that outbids a previous one,\n     *  refunds previous bidder, with refund options depedending on implementation\n     *  (refund to local balance, transfer to external contract, etc.)\n     * @param bidInput The struct containing all bid data\n     */\n    function _refundPreviousBidder(BidInput memory bidInput) internal virtual;\n\n    /**\n     * @notice Increments the ending time of an auction on arrival of a 'late bid' during the\n     *  time window [curretEndsAt - timeToExtend, curretEndsAt], by an amount equal to timeToExtend,\n     *  never exceeding the extendableUntil value stored during the creation of that auction.\n     * @param bidInput The struct containing all bid data\n     * @return endsAt On late bid: the incremented ending time of the auction;\n     *  on non-late bid: the previous unmodified ending time.\n     */\n    function _extendAuctionOnLateBid(BidInput memory bidInput)\n        private\n        returns (uint256 endsAt)\n    {\n        endsAt = _auctions[bidInput.paymentId].endsAt;\n\n        // return current endsAt if not within the last minutes:\n        uint256 time2Extend = _auctions[bidInput.paymentId].timeToExtend;\n        if ((block.timestamp + time2Extend) <= endsAt) return endsAt;\n\n        // increment endsAt, but never beyond extension limit\n        endsAt += time2Extend;\n        uint256 extendableUntil = _auctions[bidInput.paymentId].extendableUntil;\n        if (endsAt > extendableUntil) endsAt = extendableUntil;\n\n        // store incremented value:\n        _auctions[bidInput.paymentId].endsAt = endsAt;\n    }\n\n    /**\n     * @notice Checks that minIncreasePercentage is non-zero, and returns an AuctionConfig struct\n     * @param minIncreasePercentage The minimum amount that a new bid needs to increase\n     *  above the previous highest bid, expressed as a percentage in Basis Points (BPS).\n     *  e.g.: minIncreasePercentage = 500 requires new bids to be 5% larger.\n     * @param time2Extend If a bid arrives during the time window [endsAt - timeToExtend, endsAt],\n     *  then endsAt is increased by timeToExtend.\n     * @param extendableBy The maximum value that endsAt can be increased in an auction\n     *  as a result of accumulated late-arriving bids.\n     * @return the AuctionConfig struct\n     */\n    function _createAuctionConfig(\n        uint256 minIncreasePercentage,\n        uint256 time2Extend,\n        uint256 extendableBy\n    ) private pure returns (AuctionConfig memory) {\n        require(\n            minIncreasePercentage > 0,\n            \"minIncreasePercentage must be non-zero\"\n        );\n        return AuctionConfig(minIncreasePercentage, time2Extend, extendableBy);\n    }\n\n    // VIEW FUNCTIONS\n\n    /// @inheritdoc IAuctionBase\n    function assertBidInputsOK(BidInput memory bidInput)\n        public\n        view\n        returns (State state)\n    {\n        state = paymentState(bidInput.paymentId);\n        uint256 currentTime = block.timestamp;\n\n        // requirements independent of current auction state:\n        require(currentTime <= bidInput.deadline, \"payment deadline expired\");\n        if (_isSellerRegistrationRequired) {\n            require(\n                _isRegisteredSeller[bidInput.seller],\n                \"seller not registered\"\n            );\n        }\n\n        // requirements that depend on current auction state:\n        if (state == State.NotStarted) {\n            // if auction does not exist yet, assert values are within obvious limits \n            require(bidInput.endsAt >= currentTime, \"endsAt cannot be in the past\");\n            require(\n                bidInput.feeBPS <= 10000,\n                \"fee cannot be larger than 100 percent\"\n            );\n            require(bidInput.bidAmount > 0, \"bid amount cannot be 0\");\n        } else if (state == State.Auctioning) {\n            // if auction exists already:\n            // - check signed feeBPS is the same as in the ongoing bid\n            require(\n                bidInput.feeBPS == _payments[bidInput.paymentId].feeBPS,\n                \"fee does not match on-going auction fee\"\n            );\n            // - check signed endsAt, even if not identical to starting bid\n            //   (due to possible extensions on late bids), is still within extendableUntil\n            require(\n                bidInput.endsAt <=\n                    _auctions[bidInput.paymentId].extendableUntil,\n                \"endsAt does not correspond to on-going auction data\"\n            );\n            require(\n                bidInput.bidAmount >= minNewBidAmount(bidInput.paymentId),\n                \"bid needs to be larger than previous bid by a certain percentage\"\n            );\n        } else {\n            revert(\"bids are only accepted if state is either NOT_STARTED or AUCTIONING\");\n        }\n    }\n\n    /// @inheritdoc IAuctionBase\n    function splitAuctionFundingSources(BidInput memory bidInput)\n        public\n        view\n        returns (\n            uint256 externalFunds,\n            uint256 localFunds,\n            bool isSameBidder\n        )\n    {\n        isSameBidder = (bidInput.bidder == _payments[bidInput.paymentId].buyer);\n\n        // If new bidder coincides with previous max bidder, only the provision of funds\n        // corresponding to the difference between the two bidAmounts is required\n        uint256 amount = isSameBidder\n            ? bidInput.bidAmount - _payments[bidInput.paymentId].amount\n            : bidInput.bidAmount;\n        (externalFunds, localFunds) = splitFundingSources(\n            bidInput.bidder,\n            amount\n        );\n    }\n\n    /// @inheritdoc IAuctionBase\n    function minNewBidAmount(bytes32 paymentId) public view returns (uint256) {\n        uint256 previousBidAmount = _payments[paymentId].amount;\n        uint256 minNewAmount = (previousBidAmount *\n            (10000 + _auctions[paymentId].minIncreasePercentage)) / 10000;\n        // If previousBidAmount and minIncreasePercentage are small,\n        // it is possible to the int division results in minNewAmount = previousBidAmount.\n        // In that case, return + 1 to avoid accepting bids that do not increment previous amount.\n        return minNewAmount > previousBidAmount ? minNewAmount : previousBidAmount + 1;\n    }\n\n    /// @inheritdoc IAuctionBase\n    function paymentState(bytes32 paymentId)\n        public\n        view\n        virtual\n        override(IAuctionBase, BuyNowBase)\n        returns (State)\n    {\n        State state = _payments[paymentId].state;\n        if (state != State.Auctioning) return state;\n        return\n            (block.timestamp > _auctions[paymentId].endsAt)\n                ? State.AssetTransferring\n                : State.Auctioning;\n    }\n\n    /// @inheritdoc IAuctionBase\n    function universeMinIncreasePercentage(uint256 universeId)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _universeAuctionConfigExists[universeId]\n                ? _universeAuctionConfig[universeId].minIncreasePercentage\n                : _defaultAuctionConfig.minIncreasePercentage;\n    }\n\n    /// @inheritdoc IAuctionBase\n    function universeTimeToExtend(uint256 universeId) public view returns (uint256) {\n        return\n            _universeAuctionConfigExists[universeId]\n                ? _universeAuctionConfig[universeId].timeToExtend\n                : _defaultAuctionConfig.timeToExtend;\n    }\n\n    /// @inheritdoc IAuctionBase\n    function universeExtendableBy(uint256 universeId) public view returns (uint256) {\n        return\n            _universeAuctionConfigExists[universeId]\n                ? _universeAuctionConfig[universeId].extendableBy\n                : _defaultAuctionConfig.extendableBy;\n    }\n\n    /// @inheritdoc IAuctionBase\n    function defaultAuctionConfig() public view returns (AuctionConfig memory) {\n        return _defaultAuctionConfig;\n    }\n\n    /// @inheritdoc IAuctionBase\n    function universeAuctionConfig(uint256 universeId)\n        public\n        view\n        returns (AuctionConfig memory)\n    {\n        return _universeAuctionConfig[universeId];\n    }\n\n    /// @inheritdoc IAuctionBase\n    function existingAuction(bytes32 paymentId)\n        public\n        view\n        returns (ExistingAuction memory)\n    {\n        return _auctions[paymentId];\n    }\n}"
    },
    {
      "filename": "contracts/auction/base/AuctionBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\nimport \"./IAuctionBase.sol\";\nimport \"../../buyNow/base/BuyNowBase.sol\";\n\n/**\n * @title Base Escrow Contract for Payments, that adds an Auction mode\n *  to the inherited BuyNowBase, which implements the BuyNow mode.\n * @author Freeverse.io, www.freeverse.io\n * @notice Full contract documentation in IAuctionBase\n */\n\nabstract contract AuctionBase is IAuctionBase, BuyNowBase {\n    // min amount of time that needs to be guaranteed between the maximum\n    // extension of an auction and the expirationTime, beyond which\n    // buyers can be refunded, to leave time for asset transfer.\n    uint256 private constant _SAFETY_TRANSFER_WINDOW = 2 hours;\n\n    // the default config parameters used by Auctions\n    AuctionConfig internal _defaultAuctionConfig;\n\n    // mapping between universeId and their specific auction config parameters\n    mapping(uint256 => AuctionConfig) private _universeAuctionConfig;\n\n    // mapping between universeId and whether a specific auction config exists\n    // for that universe\n    mapping(uint256 => bool) public _universeAuctionConfigExists;\n\n    // mapping between existing paymentsIds for auctions,\n    // and the stored data about these Auctions\n    mapping(bytes32 => ExistingAuction) private _auctions;\n\n    constructor(\n        uint256 minIncreasePercentage,\n        uint256 time2Extend,\n        uint256 extendableBy\n    ) {\n        _defaultAuctionConfig = _createAuctionConfig(\n            minIncreasePercentage,\n            time2Extend,\n            extendableBy\n        );\n        emit DefaultAuctionConfig(minIncreasePercentage, time2Extend, extendableBy);\n    }\n\n    /// @inheritdoc IAuctionBase\n    function setDefaultAuctionConfig(\n        uint256 minIncreasePercentage,\n        uint256 time2Extend,\n        uint256 extendableBy\n    ) external onlyOwner {\n        _defaultAuctionConfig = _createAuctionConfig(\n            minIncreasePercentage,\n            time2Extend,\n            extendableBy\n        );\n        emit DefaultAuctionConfig(minIncreasePercentage, time2Extend, extendableBy);\n    }\n\n    /// @inheritdoc IAuctionBase\n    function setUniverseAuctionConfig(\n        uint256 universeId,\n        uint256 minIncreasePercentage,\n        uint256 time2Extend,\n        uint256 extendableBy\n    ) external onlyOwner {\n        _universeAuctionConfig[universeId] = _createAuctionConfig(\n            minIncreasePercentage,\n            time2Extend,\n            extendableBy\n        );\n        _universeAuctionConfigExists[universeId] = true;\n        emit UniverseAuctionConfig(\n            universeId,\n            minIncreasePercentage,\n            time2Extend,\n            extendableBy\n        );\n    }\n\n    /// @inheritdoc IAuctionBase\n    function removeUniverseAuctionConfig(uint256 universeId)\n        external\n        onlyOwner\n    {\n        delete _universeAuctionConfig[universeId];\n        _universeAuctionConfigExists[universeId] = false;\n        emit RemovedUniverseAuctionConfig(universeId);\n    }\n\n    // PRIVATE & INTERNAL FUNCTIONS\n\n    /**\n     * @dev Checks bid input parameters,\n     *  transfers required funds from external contract (in case of ERC20 Payments),\n     *  reuses buyer's local balance (if any),\n     *  stores the payment and auction data in contract's storage,\n     *  and refunds previous highest bidder (if any).\n     *  - If payment is in NOT_STARTED => it moves to AUCTIONING\n     *  - If payment is in AUCTIONING => it remains in AUCTIONING\n     * @param bidInput The BidInput struct\n     * @param operator The address of the operator of this payment.\n     */\n    function _processBid(address operator, BidInput memory bidInput) internal {\n        State state = assertBidInputsOK(bidInput);\n        assertSeparateRoles(operator, bidInput.bidder, bidInput.seller);\n        (uint256 newFundsNeeded, uint256 localFunds, bool isSameBidder) = splitAuctionFundingSources(bidInput);\n        _updatePayerBalanceOnPaymentReceived(bidInput.bidder, newFundsNeeded, localFunds);\n\n        if (state == State.NotStarted) {\n            // If 1st bid for auction => new auction is to be created:\n            // 1.- revert unless enough time is left between maximum extension and expirationTime,\n            //     so that there is enough time to conduct assetTransfer\n            uint256 extendableUntil = bidInput.endsAt + universeExtendableBy(bidInput.universeId);\n            uint256 expirationTime = bidInput.endsAt + _paymentWindow;\n            require(\n                extendableUntil + _SAFETY_TRANSFER_WINDOW < expirationTime,\n                \"cannot start auction that is extendable too close to expiration time\"\n            );\n            // 2.- store the part of the data common to Auctions and BuyNows;\n            //     maxBidder and maxBid are stored in this struct, and updated on successive bids\n            _payments[bidInput.paymentId] = Payment(\n                State.Auctioning,\n                bidInput.bidder,\n                bidInput.seller,\n                operator,\n                universeFeesCollector(bidInput.universeId),\n                expirationTime,\n                bidInput.feeBPS,\n                bidInput.bidAmount\n            );\n            // 3.- store the part of the data only relevant to Auctions;\n            //     only 'endsAt' may change in this struct (and only on arrival of late bids)\n            _auctions[bidInput.paymentId] = ExistingAuction(\n                bidInput.endsAt,\n                universeMinIncreasePercentage(bidInput.universeId),\n                universeTimeToExtend(bidInput.universeId),\n                extendableUntil\n            );\n        } else {\n            // If an auction already existed:\n            if (!isSameBidder) {\n                // if new bidder is different from previous max bidder:\n                // - and refund previous max bidder\n                _refundPreviousBidder(bidInput);\n\n                // - update max bidder\n                _payments[bidInput.paymentId].buyer = bidInput.bidder;\n\n            }\n\n            // 2.- update the previous highest bid\n            _payments[bidInput.paymentId].amount = bidInput.bidAmount;\n        }\n\n        // extend auction ending time if classified as late bid:\n        uint256 endsAt = _extendAuctionOnLateBid(bidInput);\n\n        emit Bid(bidInput.paymentId, bidInput.bidder, bidInput.seller, bidInput.bidAmount, endsAt);\n    }\n\n    /**\n     * @dev Interface to a method that, on arrival of a bid that outbids a previous one,\n     *  refunds previous bidder, with refund options depedending on implementation\n     *  (refund to local balance, transfer to external contract, etc.)\n     * @param bidInput The struct containing all bid data\n     */\n    function _refundPreviousBidder(BidInput memory bidInput) internal virtual;\n\n    /**\n     * @notice Increments the ending time of an auction on arrival of a 'late bid' during the\n     *  time window [curretEndsAt - timeToExtend, curretEndsAt], by an amount equal to timeToExtend,\n     *  never exceeding the extendableUntil value stored during the creation of that auction.\n     * @param bidInput The struct containing all bid data\n     * @return endsAt On late bid: the incremented ending time of the auction;\n     *  on non-late bid: the previous unmodified ending time.\n     */\n    function _extendAuctionOnLateBid(BidInput memory bidInput)\n        private\n        returns (uint256 endsAt)\n    {\n        endsAt = _auctions[bidInput.paymentId].endsAt;\n\n        // return current endsAt if not within the last minutes:\n        uint256 time2Extend = _auctions[bidInput.paymentId].timeToExtend;\n        if ((block.timestamp + time2Extend) <= endsAt) return endsAt;\n\n        // increment endsAt, but never beyond extension limit\n        endsAt += time2Extend;\n        uint256 extendableUntil = _auctions[bidInput.paymentId].extendableUntil;\n        if (endsAt > extendableUntil) endsAt = extendableUntil;\n\n        // store incremented value:\n        _auctions[bidInput.paymentId].endsAt = endsAt;\n    }\n\n    /**\n     * @notice Checks that minIncreasePercentage is non-zero, and returns an AuctionConfig struct\n     * @param minIncreasePercentage The minimum amount that a new bid needs to increase\n     *  above the previous highest bid, expressed as a percentage in Basis Points (BPS).\n     *  e.g.: minIncreasePercentage = 500 requires new bids to be 5% larger.\n     * @param time2Extend If a bid arrives during the time window [endsAt - timeToExtend, endsAt],\n     *  then endsAt is increased by timeToExtend.\n     * @param extendableBy The maximum value that endsAt can be increased in an auction\n     *  as a result of accumulated late-arriving bids.\n     * @return the AuctionConfig struct\n     */\n    function _createAuctionConfig(\n        uint256 minIncreasePercentage,\n        uint256 time2Extend,\n        uint256 extendableBy\n    ) private pure returns (AuctionConfig memory) {\n        require(\n            minIncreasePercentage > 0,\n            \"minIncreasePercentage must be non-zero\"\n        );\n        return AuctionConfig(minIncreasePercentage, time2Extend, extendableBy);\n    }\n\n    // VIEW FUNCTIONS\n\n    /// @inheritdoc IAuctionBase\n    function assertBidInputsOK(BidInput memory bidInput)\n        public\n        view\n        returns (State state)\n    {\n        state = paymentState(bidInput.paymentId);\n        uint256 currentTime = block.timestamp;\n\n        // requirements independent of current auction state:\n        require(currentTime <= bidInput.deadline, \"payment deadline expired\");\n        if (_isSellerRegistrationRequired) {\n            require(\n                _isRegisteredSeller[bidInput.seller],\n                \"seller not registered\"\n            );\n        }\n\n        // requirements that depend on current auction state:\n        if (state == State.NotStarted) {\n            // if auction does not exist yet, assert values are within obvious limits \n            require(bidInput.endsAt >= currentTime, \"endsAt cannot be in the past\");\n            require(\n                bidInput.feeBPS <= 10000,\n                \"fee cannot be larger than 100 percent\"\n            );\n            require(bidInput.bidAmount > 0, \"bid amount cannot be 0\");\n        } else if (state == State.Auctioning) {\n            // if auction exists already:\n            // - check signed feeBPS is the same as in the ongoing bid\n            require(\n                bidInput.feeBPS == _payments[bidInput.paymentId].feeBPS,\n                \"fee does not match on-going auction fee\"\n            );\n            // - check signed endsAt, even if not identical to starting bid\n            //   (due to possible extensions on late bids), is still within extendableUntil\n            require(\n                bidInput.endsAt <=\n                    _auctions[bidInput.paymentId].extendableUntil,\n                \"endsAt does not correspond to on-going auction data\"\n            );\n            require(\n                bidInput.bidAmount >= minNewBidAmount(bidInput.paymentId),\n                \"bid needs to be larger than previous bid by a certain percentage\"\n            );\n        } else {\n            revert(\"bids are only accepted if state is either NOT_STARTED or AUCTIONING\");\n        }\n    }\n\n    /// @inheritdoc IAuctionBase\n    function splitAuctionFundingSources(BidInput memory bidInput)\n        public\n        view\n        returns (\n            uint256 externalFunds,\n            uint256 localFunds,\n            bool isSameBidder\n        )\n    {\n        isSameBidder = (bidInput.bidder == _payments[bidInput.paymentId].buyer);\n\n        // If new bidder coincides with previous max bidder, only the provision of funds\n        // corresponding to the difference between the two bidAmounts is required\n        uint256 amount = isSameBidder\n            ? bidInput.bidAmount - _payments[bidInput.paymentId].amount\n            : bidInput.bidAmount;\n        (externalFunds, localFunds) = splitFundingSources(\n            bidInput.bidder,\n            amount\n        );\n    }\n\n    /// @inheritdoc IAuctionBase\n    function minNewBidAmount(bytes32 paymentId) public view returns (uint256) {\n        uint256 previousBidAmount = _payments[paymentId].amount;\n        uint256 minNewAmount = (previousBidAmount *\n            (10000 + _auctions[paymentId].minIncreasePercentage)) / 10000;\n        // If previousBidAmount and minIncreasePercentage are small,\n        // it is possible to the int division results in minNewAmount = previousBidAmount.\n        // In that case, return + 1 to avoid accepting bids that do not increment previous amount.\n        return minNewAmount > previousBidAmount ? minNewAmount : previousBidAmount + 1;\n    }\n\n    /// @inheritdoc IAuctionBase\n    function paymentState(bytes32 paymentId)\n        public\n        view\n        virtual\n        override(IAuctionBase, BuyNowBase)\n        returns (State)\n    {\n        State state = _payments[paymentId].state;\n        if (state != State.Auctioning) return state;\n        return\n            (block.timestamp > _auctions[paymentId].endsAt)\n                ? State.AssetTransferring\n                : State.Auctioning;\n    }\n\n    /// @inheritdoc IAuctionBase\n    function universeMinIncreasePercentage(uint256 universeId)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _universeAuctionConfigExists[universeId]\n                ? _universeAuctionConfig[universeId].minIncreasePercentage\n                : _defaultAuctionConfig.minIncreasePercentage;\n    }\n\n    /// @inheritdoc IAuctionBase\n    function universeTimeToExtend(uint256 universeId) public view returns (uint256) {\n        return\n            _universeAuctionConfigExists[universeId]\n                ? _universeAuctionConfig[universeId].timeToExtend\n                : _defaultAuctionConfig.timeToExtend;\n    }\n\n    /// @inheritdoc IAuctionBase\n    function universeExtendableBy(uint256 universeId) public view returns (uint256) {\n        return\n            _universeAuctionConfigExists[universeId]\n                ? _universeAuctionConfig[universeId].extendableBy\n                : _defaultAuctionConfig.extendableBy;\n    }\n\n    /// @inheritdoc IAuctionBase\n    function defaultAuctionConfig() public view returns (AuctionConfig memory) {\n        return _defaultAuctionConfig;\n    }\n\n    /// @inheritdoc IAuctionBase\n    function universeAuctionConfig(uint256 universeId)\n        public\n        view\n        returns (AuctionConfig memory)\n    {\n        return _universeAuctionConfig[universeId];\n    }\n\n    /// @inheritdoc IAuctionBase\n    function existingAuction(bytes32 paymentId)\n        public\n        view\n        returns (ExistingAuction memory)\n    {\n        return _auctions[paymentId];\n    }\n}"
    }
  ]
}