{
  "Title": "[M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110\nhttps://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215\n\n\n# Vulnerability details\n\n## Impact\nWhen calling `Lock.claimGovFees` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110)), assets that are set to be not allowed or assets that don't have any shares yet in the `BondNFT` contract will cause a silent failure in `BondNFT.distribute` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215)).  \nThe funds from the `GovNFT` contract will get transferred into the `Lock` contract and then will be stuck there. They cannot be recovered.  \n\n## Proof of Concept\n1. An asset is added to the `BondNFT` contract by calling `BondNFT.addAsset` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L349](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L349))\n2. There are no bonds yet for this asset so the amount of shares for the asset is zero\n3. `Lock.claimGovFees` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110)) is called\n4. Funds are transferred from the `GovNFT` contract to the `Lock` contract ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L115](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L115))\n5. The call to `BondNFT.distribute` now fails quietly without reverting the transaction:  \n   ```solidity\n    if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n   ```\n6. The funds are now stuck in the `Lock` contract. They cannot be recovered.\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nA naive solution would be to use `revert` instead of `return` in `BondNFT.distribute` such that funds are either transferred from `GovNFT` to `Lock` and then to `BondNFT` or not at all.  \n\n```solidity\n     ) external {\n-        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n+        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) revert;\n         IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n         unchecked {\n             uint aEpoch = block.timestamp / DAY;\n```\n\nThis however is an incomplete fix because if there is a single \"bad\" asset, rewards for the other assets cannot be distributed either.  \n\nMoreover functions like `Lock.lock` and `Lock.release` rely on `Lock.claimGovFees` to not revert.  \n\nSo you might allow the owner to rescue stuck tokens from the `Lock` contract. Of course only allow rescuing the balance of the `Lock` contract minus the `totalLocked` of the asset in the `Lock` contract such that the locked amount cannot be rescued.  ",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-tigris-trade-contest",
  "Code": [
    {
      "filename": "contracts/Lock.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IBondNFT.sol\";\nimport \"./interfaces/IGovNFT.sol\";\n\ncontract Lock is Ownable{\n\n    uint public constant minPeriod = 7;\n    uint public constant maxPeriod = 365;\n\n    IBondNFT public immutable bondNFT;\n    IGovNFT public immutable govNFT;\n\n    mapping(address => bool) public allowedAssets;\n    mapping(address => uint) public totalLocked;\n\n    constructor(\n        address _bondNFTAddress,\n        address _govNFT\n    ) {\n        bondNFT = IBondNFT(_bondNFTAddress);\n        govNFT = IGovNFT(_govNFT);\n    }\n\n    /**\n     * @notice Claim pending rewards from a bond\n     * @param _id Bond NFT id\n     * @return address claimed tigAsset address\n     */\n    function claim(\n        uint256 _id\n    ) public returns (address) {\n        claimGovFees();\n        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);\n        IERC20(_tigAsset).transfer(msg.sender, _amount);\n        return _tigAsset;\n    }\n\n    /**\n     * @notice Claim pending rewards left over from a bond transfer\n     * @param _tigAsset token address being claimed\n     */\n    function claimDebt(\n        address _tigAsset\n    ) external {\n        claimGovFees();\n        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);\n        IERC20(_tigAsset).transfer(msg.sender, amount);\n    }\n\n    /**\n     * @notice Lock up tokens to create a bond\n     * @param _asset tigAsset being locked\n     * @param _amount tigAsset amount\n     * @param _period number of days to be locked for\n     */\n    function lock(\n        address _asset,\n        uint _amount,\n        uint _period\n    ) public {\n        require(_period <= maxPeriod, \"MAX PERIOD\");\n        require(_period >= minPeriod, \"MIN PERIOD\");\n        require(allowedAssets[_asset], \"!asset\");\n\n        claimGovFees();\n\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        totalLocked[_asset] += _amount;\n        \n        bondNFT.createLock( _asset, _amount, _period, msg.sender);\n    }\n\n    /**\n     * @notice Reset the lock time and extend the period and/or token amount\n     * @param _id Bond id being extended\n     * @param _amount tigAsset amount being added\n     * @param _period number of days being added\n     */\n    function extendLock(\n        uint _id,\n        uint _amount,\n        uint _period\n    ) public {\n        address _asset = claim(_id);\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);\n    }\n\n    /**\n     * @notice Release the bond once it's expired\n     * @param _id Bond id being released\n     */\n    function release(\n        uint _id\n    ) public {\n        claimGovFees();\n        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);\n        totalLocked[asset] -= lockAmount;\n        IERC20(asset).transfer(_owner, amount);\n    }\n\n    /**\n     * @notice Claim rewards from gov nfts and distribute them to bonds\n     */\n    function claimGovFees() public {\n        address[] memory assets = bondNFT.getAssets();\n\n        for (uint i=0; i < assets.length; i++) {\n            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n            IGovNFT(govNFT).claim(assets[i]);\n            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);\n            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);\n        }\n    }\n\n    /**\n     * @notice Whitelist an asset\n     * @param _tigAsset tigAsset token address\n     * @param _isAllowed set tigAsset as allowed\n     */\n    function editAsset(\n        address _tigAsset,\n        bool _isAllowed\n    ) external onlyOwner() {\n        allowedAssets[_tigAsset] = _isAllowed;\n    }\n\n    /**\n     * @notice Owner can retreive Gov NFTs\n     * @param _ids array of gov nft ids\n     */\n    function sendNFTs(\n        uint[] memory _ids\n    ) external onlyOwner() {\n        govNFT.safeTransferMany(msg.sender, _ids);\n    }\n}"
    },
    {
      "filename": "contracts/BondNFT.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BondNFT is ERC721Enumerable, Ownable {\n    \n    uint constant private DAY = 24 * 60 * 60;\n\n    struct Bond {\n        uint id;\n        address owner;\n        address asset;\n        uint amount;\n        uint mintEpoch;\n        uint mintTime;\n        uint expireEpoch;\n        uint pending;\n        uint shares;\n        uint period;\n        bool expired;\n    }\n\n    mapping(address => uint256) public epoch;\n    uint private totalBonds;\n    string public baseURI;\n    address public manager;\n    address[] public assets;\n\n    mapping(address => bool) public allowedAsset;\n    mapping(address => uint) private assetsIndex;\n    mapping(uint256 => mapping(address => uint256)) private bondPaid;\n    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare\n    mapping(uint => Bond) private _idToBond;\n    mapping(address => uint) public totalShares;\n    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount\n\n    constructor(\n        string memory _setBaseURI,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n    }\n\n    /**\n     * @notice Create a bond\n     * @dev Should only be called by a manager contract\n     * @param _asset tigAsset token to lock\n     * @param _amount tigAsset amount\n     * @param _period time to lock for in days\n     * @param _owner address to receive the bond\n     * @return id ID of the minted bond\n     */\n    function createLock(\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _owner\n    ) external onlyManager() returns(uint id) {\n        require(allowedAsset[_asset], \"!Asset\");\n        unchecked {\n            uint shares = _amount * _period / 365;\n            uint expireEpoch = epoch[_asset] + _period;\n            id = ++totalBonds;\n            totalShares[_asset] += shares;\n            Bond memory _bond = Bond(\n                id,             // id\n                address(0),     // owner\n                _asset,         // tigAsset token\n                _amount,        // tigAsset amount\n                epoch[_asset],  // mint epoch\n                block.timestamp,// mint timestamp\n                expireEpoch,    // expire epoch\n                0,              // pending\n                shares,         // linearly scaling share of rewards\n                _period,        // lock period\n                false           // is expired boolean\n            );\n            _idToBond[id] = _bond;\n            _mint(_owner, _bond);\n        }\n        emit Lock(_asset, _amount, _period, _owner, id);\n    }\n\n    /** \n     * @notice Extend the lock period and/or amount of a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _asset tigAsset token address\n     * @param _amount amount of tigAsset being added\n     * @param _period days being added to the bond\n     * @param _sender address extending the bond\n     */\n    function extendLock(\n        uint _id,\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _sender\n    ) external onlyManager() {\n        Bond memory bond = idToBond(_id);\n        Bond storage _bond = _idToBond[_id];\n        require(bond.owner == _sender, \"!owner\");\n        require(!bond.expired, \"Expired\");\n        require(bond.asset == _asset, \"!BondAsset\");\n        require(bond.pending == 0);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(bond.period+_period <= 365, \"MAX PERIOD\");\n        unchecked {\n            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;\n            uint expireEpoch = block.timestamp/DAY + bond.period + _period;\n            totalShares[bond.asset] += shares-bond.shares;\n            _bond.shares = shares;\n            _bond.amount += _amount;\n            _bond.expireEpoch = expireEpoch;\n            _bond.period += _period;\n            _bond.mintTime = block.timestamp;\n            _bond.mintEpoch = epoch[bond.asset];\n            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;\n        }\n        emit ExtendLock(_period, _amount, _sender,  _id);\n    }\n\n    /**\n     * @notice Release a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _releaser address initiating the release of the bond\n     * @return amount amount of tigAsset returned\n     * @return lockAmount amount of tigAsset locked in the bond\n     * @return asset tigAsset token released\n     * @return _owner bond owner\n     */\n    function release(\n        uint _id,\n        address _releaser\n    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {\n        Bond memory bond = idToBond(_id);\n        require(bond.expired, \"!expire\");\n        if (_releaser != bond.owner) {\n            unchecked {\n                require(bond.expireEpoch + 7 < epoch[bond.asset], \"Bond owner priority\");\n            }\n        }\n        amount = bond.amount;\n        unchecked {\n            totalShares[bond.asset] -= bond.shares;\n            (uint256 _claimAmount,) = claim(_id, bond.owner);\n            amount += _claimAmount;\n        }\n        asset = bond.asset;\n        lockAmount = bond.amount;\n        _owner = bond.owner;\n        _burn(_id);\n        emit Release(asset, lockAmount, _owner, _id);\n    }\n    /**\n     * @notice Claim rewards from a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond to claim rewards from\n     * @param _claimer address claiming rewards\n     * @return amount amount of tigAsset claimed\n     * @return tigAsset tigAsset token address\n     */\n    function claim(\n        uint _id,\n        address _claimer\n    ) public onlyManager() returns(uint amount, address tigAsset) {\n        Bond memory bond = idToBond(_id);\n        require(_claimer == bond.owner, \"!owner\");\n        amount = bond.pending;\n        tigAsset = bond.asset;\n        unchecked {\n            if (bond.expired) {\n                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n                if (totalShares[bond.asset] > 0) {\n                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n                }\n            }\n            bondPaid[_id][bond.asset] += amount;\n        }\n        IERC20(tigAsset).transfer(manager, amount);\n        emit ClaimFees(tigAsset, amount, _claimer, _id);\n    }\n\n    /**\n     * @notice Claim user debt left from bond transfer\n     * @dev Should only be called by a manager contract\n     * @param _user user address\n     * @param _tigAsset tigAsset token address\n     * @return amount amount of tigAsset claimed\n     */\n    function claimDebt(\n        address _user,\n        address _tigAsset\n    ) public onlyManager() returns(uint amount) {\n        amount = userDebt[_user][_tigAsset];\n        userDebt[_user][_tigAsset] = 0;\n        IERC20(_tigAsset).transfer(manager, amount);\n        emit ClaimDebt(_tigAsset, amount, _user);\n    }\n\n    /**\n     * @notice Distribute rewards to bonds\n     * @param _tigAsset tigAsset token address\n     * @param _amount tigAsset amount\n     */\n    function distribute(\n        address _tigAsset,\n        uint _amount\n    ) external {\n        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n        unchecked {\n            uint aEpoch = block.timestamp / DAY;\n            if (aEpoch > epoch[_tigAsset]) {\n                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                    epoch[_tigAsset] += 1;\n                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                }\n            }\n            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n        }\n        emit Distribution(_tigAsset, _amount);\n    }\n\n    /**\n     * @notice Get all data for a bond\n     * @param _id ID of the bond\n     * @return bond Bond object\n     */\n    function idToBond(uint256 _id) public view returns (Bond memory bond) {\n        bond = _idToBond[_id];\n        bond.owner = ownerOf(_id);\n        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n        unchecked {\n            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];\n            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];\n        }\n    }\n\n    /*\n     * @notice Get expired boolean for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function isExpired(uint256 _id) public view returns (bool) {\n        Bond memory bond = _idToBond[_id];\n        return bond.expireEpoch <= epoch[bond.asset] ? true : false;\n    }\n\n    /*\n     * @notice Get pending rewards for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function pending(\n        uint256 _id\n    ) public view returns (uint256) {\n        return idToBond(_id).pending;\n    }\n\n    function totalAssets() public view returns (uint256) {\n        return assets.length;\n    }\n\n    /*\n     * @notice Gets an array of all whitelisted token addresses\n     * @return address array of addresses\n     */\n    function getAssets() public view returns (address[] memory) {\n        return assets;\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function safeTransferMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _transfer(_msgSender(), _to, _ids[i]);\n            }\n        }\n    }\n\n    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                safeTransferFrom(_from, _to, _ids[i]);\n            }\n        }\n    }\n\n    function approveMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                approve(_to, _ids[i]);\n            }\n        }\n    }\n\n    function _mint(\n        address to,\n        Bond memory bond\n    ) internal {\n        unchecked {\n            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;\n        }\n        _mint(to, bond.id);\n    }\n\n    function _burn(\n        uint256 _id\n    ) internal override {\n        delete _idToBond[_id];\n        super._burn(_id);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 _id\n    ) internal override {\n        Bond memory bond = idToBond(_id);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(!bond.expired, \"Expired!\");\n        unchecked {\n            require(block.timestamp > bond.mintTime + 300, \"Recent update\");\n            userDebt[from][bond.asset] += bond.pending;\n            bondPaid[_id][bond.asset] += bond.pending;\n        }\n        super._transfer(from, to, _id);\n    }\n\n    function balanceIds(address _user) public view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _ids[i] = tokenOfOwnerByIndex(_user, i);\n            }\n        }\n        return _ids;\n    }\n\n    function addAsset(address _asset) external onlyOwner {\n        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n        assetsIndex[_asset] = assets.length;\n        assets.push(_asset);\n        allowedAsset[_asset] = true;\n        epoch[_asset] = block.timestamp/DAY;\n    }\n\n    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n        require(assets[assetsIndex[_asset]] == _asset, \"Not added\");\n        allowedAsset[_asset] = _bool;\n    }\n\n    function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function setManager(\n        address _manager\n    ) public onlyOwner() {\n        manager = _manager;\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == manager, \"!manager\");\n        _;\n    }\n\n    event Distribution(address _tigAsset, uint256 _amount);\n    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);\n    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);\n    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);\n    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);\n    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);\n}"
    }
  ]
}