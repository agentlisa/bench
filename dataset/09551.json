{
  "Title": "[N-09] Unsafe early return from a modifier",
  "Content": "\nIf the modifier is used with a function that has a named return, the default value will be returned which may lead to confusing behavior. Consider using a function instead of a modifier\n\n1.  File: src/AdminMultisigBase.sol (lines [42-44](https://github.com/code-423n4/2022-04-axelar/blob/dee2f2d352e8f20f20027977d511b19bfcca23a3/src/AdminMultisigBase.sol#L42-L44))\n\n```solidity\n        if (adminVoteCount < _getAdminThreshold(adminEpoch)) return;\n\n        _;\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-04-axelar",
  "Code": [
    {
      "filename": "src/AdminMultisigBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { EternalStorage } from './EternalStorage.sol';\n\ncontract AdminMultisigBase is EternalStorage {\n    error NotAdmin();\n    error AlreadyVoted();\n    error InvalidAdmins();\n    error InvalidAdminThreshold();\n    error DuplicateAdmin(address admin);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    // AUDIT: constants should be literal and their derivation should be in comments\n    bytes32 internal constant KEY_ADMIN_EPOCH = keccak256('admin-epoch');\n\n    bytes32 internal constant PREFIX_ADMIN = keccak256('admin');\n    bytes32 internal constant PREFIX_ADMIN_COUNT = keccak256('admin-count');\n    bytes32 internal constant PREFIX_ADMIN_THRESHOLD = keccak256('admin-threshold');\n    bytes32 internal constant PREFIX_ADMIN_VOTE_COUNTS = keccak256('admin-vote-counts');\n    bytes32 internal constant PREFIX_ADMIN_VOTED = keccak256('admin-voted');\n    bytes32 internal constant PREFIX_IS_ADMIN = keccak256('is-admin');\n\n    modifier onlyAdmin() {\n        uint256 adminEpoch = _adminEpoch();\n\n        if (!_isAdmin(adminEpoch, msg.sender)) revert NotAdmin();\n\n        bytes32 topic = keccak256(msg.data);\n\n        // Check that admin has not voted, then record that they have voted.\n        if (_hasVoted(adminEpoch, topic, msg.sender)) revert AlreadyVoted();\n\n        _setHasVoted(adminEpoch, topic, msg.sender, true);\n\n        // Determine the new vote count and update it.\n        uint256 adminVoteCount = _getVoteCount(adminEpoch, topic) + uint256(1);\n        _setVoteCount(adminEpoch, topic, adminVoteCount);\n\n        // Do not proceed with operation execution if insufficient votes.\n        if (adminVoteCount < _getAdminThreshold(adminEpoch)) return;\n\n        _;\n\n        // Clear vote count and voted booleans.\n        _setVoteCount(adminEpoch, topic, uint256(0));\n\n        uint256 adminCount = _getAdminCount(adminEpoch);\n\n        for (uint256 i; i < adminCount; i++) {\n            _setHasVoted(adminEpoch, topic, _getAdmin(adminEpoch, i), false);\n        }\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getAdminKey(uint256 adminEpoch, uint256 index) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN, adminEpoch, index));\n    }\n\n    function _getAdminCountKey(uint256 adminEpoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_COUNT, adminEpoch));\n    }\n\n    function _getAdminThresholdKey(uint256 adminEpoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_THRESHOLD, adminEpoch));\n    }\n\n    function _getAdminVoteCountsKey(uint256 adminEpoch, bytes32 topic) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTE_COUNTS, adminEpoch, topic));\n    }\n\n    function _getAdminVotedKey(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTED, adminEpoch, topic, account));\n    }\n\n    function _getIsAdminKey(uint256 adminEpoch, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_IS_ADMIN, adminEpoch, account));\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function _adminEpoch() internal view returns (uint256) {\n        return getUint(KEY_ADMIN_EPOCH);\n    }\n\n    function _getAdmin(uint256 adminEpoch, uint256 index) internal view returns (address) {\n        return getAddress(_getAdminKey(adminEpoch, index));\n    }\n\n    function _getAdminCount(uint256 adminEpoch) internal view returns (uint256) {\n        return getUint(_getAdminCountKey(adminEpoch));\n    }\n\n    function _getAdminThreshold(uint256 adminEpoch) internal view returns (uint256) {\n        return getUint(_getAdminThresholdKey(adminEpoch));\n    }\n\n    function _getVoteCount(uint256 adminEpoch, bytes32 topic) internal view returns (uint256) {\n        return getUint(_getAdminVoteCountsKey(adminEpoch, topic));\n    }\n\n    function _hasVoted(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account\n    ) internal view returns (bool) {\n        return getBool(_getAdminVotedKey(adminEpoch, topic, account));\n    }\n\n    function _isAdmin(uint256 adminEpoch, address account) internal view returns (bool) {\n        return getBool(_getIsAdminKey(adminEpoch, account));\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    function _setAdminEpoch(uint256 adminEpoch) internal {\n        _setUint(KEY_ADMIN_EPOCH, adminEpoch);\n    }\n\n    function _setAdmin(\n        uint256 adminEpoch,\n        uint256 index,\n        address account\n    ) internal {\n        _setAddress(_getAdminKey(adminEpoch, index), account);\n    }\n\n    function _setAdminCount(uint256 adminEpoch, uint256 adminCount) internal {\n        _setUint(_getAdminCountKey(adminEpoch), adminCount);\n    }\n\n    function _setAdmins(\n        uint256 adminEpoch,\n        address[] memory accounts,\n        uint256 threshold\n    ) internal {\n        uint256 adminLength = accounts.length;\n\n        if (adminLength < threshold) revert InvalidAdmins();\n\n        if (threshold == uint256(0)) revert InvalidAdminThreshold();\n\n        _setAdminThreshold(adminEpoch, threshold);\n        _setAdminCount(adminEpoch, adminLength);\n\n        for (uint256 i; i < adminLength; i++) {\n            address account = accounts[i];\n\n            // Check that the account wasn't already set as an admin for this epoch.\n            if (_isAdmin(adminEpoch, account)) revert DuplicateAdmin(account);\n\n            // Set this account as the i-th admin in this epoch (needed to we can clear topic votes in `onlyAdmin`).\n            _setAdmin(adminEpoch, i, account);\n            _setIsAdmin(adminEpoch, account, true);\n        }\n    }\n\n    function _setAdminThreshold(uint256 adminEpoch, uint256 adminThreshold) internal {\n        _setUint(_getAdminThresholdKey(adminEpoch), adminThreshold);\n    }\n\n    function _setVoteCount(\n        uint256 adminEpoch,\n        bytes32 topic,\n        uint256 voteCount\n    ) internal {\n        _setUint(_getAdminVoteCountsKey(adminEpoch, topic), voteCount);\n    }\n\n    function _setHasVoted(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account,\n        bool voted\n    ) internal {\n        _setBool(_getAdminVotedKey(adminEpoch, topic, account), voted);\n    }\n\n    function _setIsAdmin(\n        uint256 adminEpoch,\n        address account,\n        bool isAdmin\n    ) internal {\n        _setBool(_getIsAdminKey(adminEpoch, account), isAdmin);\n    }\n}"
    }
  ]
}