{
  "Title": "[L-02] `AaveHandler` does not extend `BaseHandler`",
  "Content": "\nUnlike `CompoundHandler`, `AaveHandler` does not extend `BaseHandler`, which will cause storage problems in future versions\n\n```solidity\nFile: backd/contracts/actions/topup/handlers/AaveHandler.sol   #1\n\n15 contract AaveHandler is ITopUpHandler {\n```\n\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/AaveHandler.sol#L15>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-04-backd-contest",
  "Code": [
    {
      "filename": "backd/contracts/actions/topup/handlers/AaveHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../../libraries/Errors.sol\";\nimport \"../../../../libraries/AccountEncoding.sol\";\n\nimport \"../../../../interfaces/actions/topup/ITopUpHandler.sol\";\nimport \"../../../../interfaces/vendor/ILendingPool.sol\";\nimport \"../../../../interfaces/vendor/IWETH.sol\";\nimport \"../../../../libraries/vendor/DataTypes.sol\";\n\ncontract AaveHandler is ITopUpHandler {\n    using SafeERC20 for IERC20;\n    using AccountEncoding for bytes32;\n\n    uint16 public constant BACKD_REFERRAL_CODE = 62314;\n\n    ILendingPool public immutable lendingPool;\n    IWETH public immutable weth;\n\n    constructor(address lendingPoolAddress, address wethAddress) {\n        lendingPool = ILendingPool(lendingPoolAddress);\n        weth = IWETH(wethAddress);\n    }\n\n    /**\n     * @notice Executes the top-up of a position.\n     * @param account Account holding the position.\n     * @param underlying Underlying for tup-up.\n     * @param amount Amount to top-up by.\n     * @return `true` if successful.\n     */\n    function topUp(\n        bytes32 account,\n        address underlying,\n        uint256 amount,\n        bytes memory extra\n    ) external override returns (bool) {\n        bool repayDebt = abi.decode(extra, (bool));\n        if (underlying == address(0)) {\n            weth.deposit{value: amount}();\n            underlying = address(weth);\n        }\n\n        address addr = account.addr();\n\n        DataTypes.ReserveData memory reserve = lendingPool.getReserveData(underlying);\n        require(reserve.aTokenAddress != address(0), Error.UNDERLYING_NOT_SUPPORTED);\n\n        IERC20(underlying).safeApprove(address(lendingPool), amount);\n\n        if (repayDebt) {\n            uint256 stableDebt = IERC20(reserve.stableDebtTokenAddress).balanceOf(addr);\n            uint256 variableDebt = IERC20(reserve.variableDebtTokenAddress).balanceOf(addr);\n            if (variableDebt + stableDebt > 0) {\n                uint256 rateMode = stableDebt > variableDebt ? 1 : 2;\n                amount -= lendingPool.repay(underlying, amount, rateMode, addr);\n                if (amount == 0) return true;\n            }\n        }\n\n        lendingPool.deposit(underlying, amount, addr, BACKD_REFERRAL_CODE);\n        return true;\n    }\n\n    function getUserFactor(bytes32 account, bytes memory) external view override returns (uint256) {\n        (, , , , , uint256 healthFactor) = lendingPool.getUserAccountData(account.addr());\n        return healthFactor;\n    }\n}"
    }
  ]
}