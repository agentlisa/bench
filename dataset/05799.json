{
  "Title": "[N-06] Setting `deposit.owner = address(0);` is not required",
  "Content": "\n*There is 1 instance of this issue:*\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L444\n\nSetting `deposit.owner` to `address(0)` is not required on Line 444 since we already delete the deposit info for that `_depositNonce` on Line 456.\n\n```solidity\nFile: src/BranchBridgeAgent.sol\n444: deposit.owner = address(0);\n456: delete getDeposit[_depositNonce];\n```\n\n**[alcueca (judge) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/458#issuecomment-1824733167):**\n> I have no corrections to make to the issues included in this QA report.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-09-maia-findings/issues/458).*\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/BranchBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ExcessivelySafeCall} from \"lib/ExcessivelySafeCall.sol\";\n\nimport {IBranchPort as IPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {BridgeAgentConstants} from \"./interfaces/BridgeAgentConstants.sol\";\nimport {\n    Deposit,\n    DepositInput,\n    DepositMultipleInput,\n    GasParams,\n    IBranchBridgeAgent,\n    ILayerZeroReceiver,\n    SettlementMultipleParams\n} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {ILayerZeroEndpoint} from \"./interfaces/ILayerZeroEndpoint.sol\";\n\nimport {BranchBridgeAgentExecutor, DeployBranchBridgeAgentExecutor} from \"./BranchBridgeAgentExecutor.sol\";\n\n/// @title Library for Branch Bridge Agent Deployment\nlibrary DeployBranchBridgeAgent {\n    function deploy(\n        uint16 _rootChainId,\n        uint16 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _lzEndpointAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) external returns (BranchBridgeAgent) {\n        return new BranchBridgeAgent(\n            _rootChainId,\n            _localChainId,\n            _rootBridgeAgentAddress,\n            _lzEndpointAddress,\n            _localRouterAddress,\n            _localPortAddress\n        );\n    }\n}\n\n/// @title Branch Bridge Agent Contract\n/// @author MaiaDAO\ncontract BranchBridgeAgent is IBranchBridgeAgent, BridgeAgentConstants {\n    using ExcessivelySafeCall for address;\n\n    /*///////////////////////////////////////////////////////////////\n                         BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain Id for Root Chain where liquidity is virtualized(e.g. 4).\n    uint16 public immutable rootChainId;\n\n    /// @notice Chain Id for Local Chain.\n    uint16 public immutable localChainId;\n\n    /// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address\n    ///         where cross-chain requests are executed in the Root Chain.\n    address public immutable rootBridgeAgentAddress;\n\n    /// @notice Layer Zero messaging layer path for Root Bridge Agent Address where cross-chain requests\n    ///         are sent to the Root Chain Router.\n    bytes private rootBridgeAgentPath;\n\n    /// @notice Local Layerzero Endpoint Address where cross-chain requests are sent to the Root Chain Router.\n    address public immutable lzEndpointAddress;\n\n    /// @notice Address for Local Router used for custom actions for different hApps.\n    address public immutable localRouterAddress;\n\n    /// @notice Address for Local Port Address\n    ///         where funds deposited from this chain are kept, managed and supplied to different Port Strategies.\n    address public immutable localPortAddress;\n\n    /// @notice Address for Bridge Agent Executor used for executing cross-chain requests.\n    address public immutable bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                            DEPOSITS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying the transaction.\n    uint32 public depositNonce;\n\n    /// @notice Mapping from Pending deposits hash to Deposit Struct.\n    mapping(uint256 depositNonce => Deposit depositInfo) public getDeposit;\n\n    /*///////////////////////////////////////////////////////////////\n                        SETTLEMENT EXECUTION STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, the bridge agent has already served a request with this nonce from a given chain.\n    mapping(uint256 settlementNonce => uint256 state) public executionState;\n\n    /*///////////////////////////////////////////////////////////////\n                           REENTRANCY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Re-entrancy lock modifier state.\n    uint256 internal _unlocked = 1;\n\n    /*///////////////////////////////////////////////////////////////\n                             CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Branch Bridge Agent.\n     * @param _rootChainId Chain Id for Root Chain where liquidity is virtualized and assets are managed.\n     * @param _localChainId Chain Id for Local Chain.\n     * @param _rootBridgeAgentAddress Address for Bridge Agent who processes requests sent to and from the Root Chain.\n     * @param _lzEndpointAddress Local Layerzero Endpoint Address where cross-chain requests are sent to the Root Chain Router.\n     * @param _localRouterAddress Address for Local Router used for custom actions for different Omnichain dApps.\n     * @param _localPortAddress Address for Local Port Address where funds deposited from this chain are kept, managed\n     *                          and supplied to different Port Strategies.\n     */\n    constructor(\n        uint16 _rootChainId,\n        uint16 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _lzEndpointAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) {\n        require(_rootBridgeAgentAddress != address(0), \"Root Bridge Agent Address cannot be the zero address.\");\n        require(\n            _lzEndpointAddress != address(0) || _rootChainId == _localChainId,\n            \"Layerzero Endpoint Address cannot be the zero address.\"\n        );\n        require(_localRouterAddress != address(0), \"Local Router Address cannot be the zero address.\");\n        require(_localPortAddress != address(0), \"Local Port Address cannot be the zero address.\");\n\n        localChainId = _localChainId;\n        rootChainId = _rootChainId;\n        rootBridgeAgentAddress = _rootBridgeAgentAddress;\n        lzEndpointAddress = _lzEndpointAddress;\n        localRouterAddress = _localRouterAddress;\n        localPortAddress = _localPortAddress;\n        bridgeAgentExecutorAddress = DeployBranchBridgeAgentExecutor.deploy();\n        depositNonce = 1;\n\n        rootBridgeAgentPath = abi.encodePacked(_rootBridgeAgentAddress, address(this));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        FALLBACK FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    receive() external payable {}\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function getDepositEntry(uint32 _depositNonce) external view override returns (Deposit memory) {\n        return getDeposit[_depositNonce];\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function getFeeEstimate(uint256 _gasLimit, uint256 _remoteBranchExecutionGas, bytes calldata _payload)\n        external\n        view\n        returns (uint256 _fee)\n    {\n        (_fee,) = ILayerZeroEndpoint(lzEndpointAddress).estimateFees(\n            rootChainId,\n            address(this),\n            _payload,\n            false,\n            abi.encodePacked(uint16(2), _gasLimit, _remoteBranchExecutionGas, rootBridgeAgentAddress)\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    USER / BRANCH ROUTER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSystem(address payable _refundee, bytes calldata _params, GasParams calldata _gParams)\n        external\n        payable\n        override\n        lock\n        requiresRouter\n    {\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(bytes1(0x00), depositNonce++, _params);\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOut(address payable _refundee, bytes calldata _params, GasParams calldata _gParams)\n        external\n        payable\n        override\n        lock\n    {\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(bytes1(0x01), depositNonce++, _params);\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridge(\n        address payable _refundee,\n        bytes calldata _params,\n        DepositInput memory _dParams,\n        GasParams calldata _gParams\n    ) external payable override lock {\n        //Cache Deposit Nonce\n        uint32 _depositNonce = depositNonce;\n\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(\n            bytes1(0x02), _depositNonce, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit, _params\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _createDeposit(_depositNonce, _refundee, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit);\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridgeMultiple(\n        address payable _refundee,\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        GasParams calldata _gParams\n    ) external payable override lock {\n        //Cache Deposit Nonce\n        uint32 _depositNonce = depositNonce;\n\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(\n            bytes1(0x03),\n            uint8(_dParams.hTokens.length),\n            _depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            _params\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _createDepositMultiple(\n            _depositNonce, _refundee, _dParams.hTokens, _dParams.tokens, _dParams.amounts, _dParams.deposits\n        );\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSigned(address payable _refundee, bytes calldata _params, GasParams calldata _gParams)\n        external\n        payable\n        override\n        lock\n    {\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(bytes1(0x04), msg.sender, depositNonce++, _params);\n\n        //Perform Signed Call without deposit\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridge(\n        address payable _refundee,\n        bytes calldata _params,\n        DepositInput memory _dParams,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock {\n        //Cache Deposit Nonce\n        uint32 _depositNonce = depositNonce;\n\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(\n            _hasFallbackToggled ? bytes1(0x85) : bytes1(0x05),\n            msg.sender,\n            _depositNonce,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _dParams.deposit,\n            _params\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _createDeposit(_depositNonce, _refundee, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit);\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridgeMultiple(\n        address payable _refundee,\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock {\n        // Cache Deposit Nonce\n        uint32 _depositNonce = depositNonce;\n\n        // Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(\n            _hasFallbackToggled ? bytes1(0x86) : bytes1(0x06),\n            msg.sender,\n            uint8(_dParams.hTokens.length),\n            _depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            _params\n        );\n\n        // Create a Deposit and Send Cross-Chain request\n        _createDepositMultiple(\n            _depositNonce, _refundee, _dParams.hTokens, _dParams.tokens, _dParams.amounts, _dParams.deposits\n        );\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    DEPOSIT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retryDeposit(\n        bool _isSigned,\n        uint32 _depositNonce,\n        bytes calldata _params,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock {\n        // Get Settlement Reference\n        Deposit storage deposit = getDeposit[_depositNonce];\n\n        //Check if deposit belongs to message sender\n        if (deposit.owner != msg.sender) revert NotDepositOwner();\n\n        //Encode Data for cross-chain call.\n        bytes memory payload;\n\n        if (uint8(deposit.hTokens.length) == 1) {\n            if (_isSigned) {\n                //Pack new Data\n                payload = abi.encodePacked(\n                    _hasFallbackToggled ? bytes1(0x85) : bytes1(0x05),\n                    msg.sender,\n                    _depositNonce,\n                    deposit.hTokens[0],\n                    deposit.tokens[0],\n                    deposit.amounts[0],\n                    deposit.deposits[0],\n                    _params\n                );\n            } else {\n                payload = abi.encodePacked(\n                    bytes1(0x02),\n                    _depositNonce,\n                    deposit.hTokens[0],\n                    deposit.tokens[0],\n                    deposit.amounts[0],\n                    deposit.deposits[0],\n                    _params\n                );\n            }\n        } else if (uint8(deposit.hTokens.length) > 1) {\n            if (_isSigned) {\n                //Pack new Data\n                payload = abi.encodePacked(\n                    _hasFallbackToggled ? bytes1(0x86) : bytes1(0x06),\n                    msg.sender,\n                    uint8(deposit.hTokens.length),\n                    _depositNonce,\n                    deposit.hTokens,\n                    deposit.tokens,\n                    deposit.amounts,\n                    deposit.deposits,\n                    _params\n                );\n            } else {\n                payload = abi.encodePacked(\n                    bytes1(0x03),\n                    uint8(deposit.hTokens.length),\n                    _depositNonce,\n                    deposit.hTokens,\n                    deposit.tokens,\n                    deposit.amounts,\n                    deposit.deposits,\n                    _params\n                );\n            }\n        }\n\n        // Check if payload is empty\n        if (payload.length == 0) revert DepositRetryUnavailableUseCallout();\n\n        // Ensure success Status\n        deposit.status = STATUS_SUCCESS;\n\n        // Perform Call\n        _performCall(payable(msg.sender), payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retrieveDeposit(uint32 _depositNonce, GasParams calldata _gParams) external payable override lock {\n        // Check if the deposit belongs to the message sender\n        if (getDeposit[_depositNonce].owner != msg.sender) revert NotDepositOwner();\n\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(bytes1(0x08), msg.sender, _depositNonce);\n\n        //Update State and Perform Call\n        _performCall(payable(msg.sender), payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function redeemDeposit(uint32 _depositNonce) external override lock {\n        // Get storage reference\n        Deposit storage deposit = getDeposit[_depositNonce];\n\n        // Check Deposit\n        if (deposit.status == STATUS_SUCCESS) revert DepositRedeemUnavailable();\n        if (deposit.owner == address(0)) revert DepositRedeemUnavailable();\n        if (deposit.owner != msg.sender) revert NotDepositOwner();\n\n        // Zero out owner\n        deposit.owner = address(0);\n\n        // Transfer token to depositor / user\n        for (uint256 i = 0; i < deposit.tokens.length;) {\n            _clearToken(msg.sender, deposit.hTokens[i], deposit.tokens[i], deposit.amounts[i], deposit.deposits[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Delete Failed Deposit Token Info\n        delete getDeposit[_depositNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    SETTLEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retrySettlement(\n        uint32 _settlementNonce,\n        bytes calldata _params,\n        GasParams[2] calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable virtual override lock {\n        // Encode Retry Settlement Params\n        bytes memory params = abi.encode(_settlementNonce, msg.sender, _params, _gParams[1]);\n\n        // Prepare payload for cross-chain call.\n        bytes memory payload = abi.encodePacked(_hasFallbackToggled ? bytes1(0x87) : bytes1(0x07), params);\n\n        // Perform Call\n        _performCall(payable(msg.sender), payload, _gParams[0]);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function clearToken(address _recipient, address _hToken, address _token, uint256 _amount, uint256 _deposit)\n        external\n        override\n        requiresAgentExecutor\n    {\n        _clearToken(_recipient, _hToken, _token, _amount, _deposit);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function clearTokens(bytes calldata _sParams, address _recipient)\n        external\n        override\n        requiresAgentExecutor\n        returns (SettlementMultipleParams memory)\n    {\n        // Parse Tokens Length\n        uint8 numOfAssets = uint8(bytes1(_sParams[0]));\n\n        // Parse Nonce\n        uint32 nonce = uint32(bytes4(_sParams[PARAMS_START:PARAMS_TKN_START]));\n\n        // Initialize Arrays\n        address[] memory _hTokens = new address[](numOfAssets);\n        address[] memory _tokens = new address[](numOfAssets);\n        uint256[] memory _amounts = new uint256[](numOfAssets);\n        uint256[] memory _deposits = new uint256[](numOfAssets);\n\n        // Transfer the token to the recipient\n        for (uint256 i = 0; i < numOfAssets;) {\n            // Cache common offset\n            uint256 currentIterationOffset = PARAMS_START + i;\n\n            // Parse Params\n            _hTokens[i] = address(\n                uint160(\n                    bytes20(\n                        bytes32(\n                            _sParams[\n                                PARAMS_TKN_START + (PARAMS_ENTRY_SIZE * i) + ADDRESS_END_OFFSET:\n                                    PARAMS_TKN_START + (PARAMS_ENTRY_SIZE * currentIterationOffset)\n                            ]\n                        )\n                    )\n                )\n            );\n\n            _tokens[i] = address(\n                uint160(\n                    bytes20(\n                        bytes32(\n                            _sParams[\n                                PARAMS_TKN_START + PARAMS_ENTRY_SIZE * (i + numOfAssets) + ADDRESS_END_OFFSET:\n                                    PARAMS_TKN_START + PARAMS_ENTRY_SIZE * (currentIterationOffset + numOfAssets)\n                            ]\n                        )\n                    )\n                )\n            );\n\n            _amounts[i] = uint256(\n                bytes32(\n                    _sParams[\n                        PARAMS_TKN_START + PARAMS_AMT_OFFSET * numOfAssets + PARAMS_ENTRY_SIZE * i:\n                            PARAMS_TKN_START + PARAMS_AMT_OFFSET * numOfAssets + PARAMS_ENTRY_SIZE * currentIterationOffset\n                    ]\n                )\n            );\n\n            _deposits[i] = uint256(\n                bytes32(\n                    _sParams[\n                        PARAMS_TKN_START + PARAMS_DEPOSIT_OFFSET * numOfAssets + PARAMS_ENTRY_SIZE * i:\n                            PARAMS_TKN_START + PARAMS_DEPOSIT_OFFSET * numOfAssets\n                                + PARAMS_ENTRY_SIZE * currentIterationOffset\n                    ]\n                )\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        IPort(localPortAddress).bridgeInMultiple(_recipient, _hTokens, _tokens, _amounts, _deposits);\n\n        return SettlementMultipleParams(numOfAssets, _recipient, nonce, _hTokens, _tokens, _amounts, _deposits);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    LAYER ZERO EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ILayerZeroReceiver\n    function lzReceive(uint16, bytes calldata _srcAddress, uint64, bytes calldata _payload) public override {\n        address(this).excessivelySafeCall(\n            gasleft(),\n            150,\n            abi.encodeWithSelector(this.lzReceiveNonBlocking.selector, msg.sender, _srcAddress, _payload)\n        );\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function lzReceiveNonBlocking(address _endpoint, bytes calldata _srcAddress, bytes calldata _payload)\n        public\n        override\n        requiresEndpoint(_endpoint, _srcAddress)\n    {\n        //Save Action Flag\n        bytes1 flag = _payload[0] & 0x7F;\n\n        // Save settlement nonce\n        uint32 nonce;\n\n        // DEPOSIT FLAG: 0 (No settlement)\n        if (flag == 0x00) {\n            // Get Settlement Nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\n\n            //Check if tx has already been executed\n            if (executionState[nonce] != STATUS_READY) revert AlreadyExecutedTransaction();\n\n            //Try to execute the remote request\n            //Flag 0 - BranchBridgeAgentExecutor(bridgeAgentExecutorAddress).executeNoSettlement(localRouterAddress, _payload)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    BranchBridgeAgentExecutor.executeNoSettlement.selector, localRouterAddress, _payload\n                )\n            );\n\n            // DEPOSIT FLAG: 1 (Single Asset Settlement)\n        } else if (flag == 0x01) {\n            // Parse recipient\n            address payable recipient = payable(address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED]))));\n\n            // Parse Settlement Nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\n\n            //Check if tx has already been executed\n            if (executionState[nonce] != STATUS_READY) revert AlreadyExecutedTransaction();\n\n            //Try to execute the remote request\n            //Flag 1 - BranchBridgeAgentExecutor(bridgeAgentExecutorAddress).executeWithSettlement(recipient, localRouterAddress, _payload)\n            _execute(\n                _payload[0] == 0x81,\n                nonce,\n                recipient,\n                abi.encodeWithSelector(\n                    BranchBridgeAgentExecutor.executeWithSettlement.selector, recipient, localRouterAddress, _payload\n                )\n            );\n\n            // DEPOSIT FLAG: 2 (Multiple Settlement)\n        } else if (flag == 0x02) {\n            // Parse recipient\n            address payable recipient = payable(address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED]))));\n\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[22:26]));\n\n            //Check if tx has already been executed\n            if (executionState[nonce] != STATUS_READY) revert AlreadyExecutedTransaction();\n\n            //Try to execute remote request\n            // Flag 2 - BranchBridgeAgentExecutor(bridgeAgentExecutorAddress).executeWithSettlementMultiple(recipient, localRouterAddress, _payload)\n            _execute(\n                _payload[0] == 0x82,\n                nonce,\n                recipient,\n                abi.encodeWithSelector(\n                    BranchBridgeAgentExecutor.executeWithSettlementMultiple.selector,\n                    recipient,\n                    localRouterAddress,\n                    _payload\n                )\n            );\n\n            //DEPOSIT FLAG: 3 (Retrieve Settlement)\n        } else if (flag == 0x03) {\n            // Parse recipient\n            address payable recipient = payable(address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED]))));\n\n            //Get nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\n\n            //Check if settlement is in retrieve mode\n            if (executionState[nonce] == STATUS_DONE) {\n                revert AlreadyExecutedTransaction();\n            } else {\n                //Set settlement to retrieve mode, if not already set.\n                if (executionState[nonce] == STATUS_READY) executionState[nonce] = STATUS_RETRIEVE;\n                //Trigger fallback/Retry failed fallback\n                _performFallbackCall(recipient, nonce);\n            }\n\n            //DEPOSIT FLAG: 4 (Fallback)\n        } else if (flag == 0x04) {\n            //Get nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\n\n            // Reopen Deposit for redemption\n            getDeposit[nonce].status = STATUS_FAILED;\n\n            // Emit Fallback Event\n            emit LogFallback(nonce);\n\n            // Return to prevent unnecessary logic/emits\n            return;\n\n            //Unrecognized Function Selector\n        } else {\n            revert UnknownFlag();\n        }\n\n        // Emit Execution Event\n        emit LogExecute(nonce);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    SETTLEMENT EXECUTION INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function requests execution from Branch Bridge Agent Executor Contract.\n     *   @param _settlementNonce Identifier for nonce being executed.\n     *   @param _calldata Calldata to be executed by the Branch Bridge Agent Executor Contract.\n     */\n    function _execute(uint256 _settlementNonce, bytes memory _calldata) private {\n        //Update tx state as executed\n        executionState[_settlementNonce] = STATUS_DONE;\n\n        //Try to execute the remote request\n        (bool success,) = bridgeAgentExecutorAddress.call{value: address(this).balance}(_calldata);\n\n        //  No fallback is requested revert allowing for settlement retry.\n        if (!success) revert ExecutionFailure();\n    }\n\n    /**\n     * @notice Internal function requests execution from Branch Bridge Agent Executor Contract.\n     *   @param _hasFallbackToggled if true, fallback on execution failure is toggled on.\n     *   @param _settlementNonce Identifier for nonce being executed.\n     *   @param _refundee address to refund gas to in case of fallback being triggered.\n     *   @param _calldata Calldata to be executed by the Branch Bridge Agent Executor Contract.\n     */\n    function _execute(bool _hasFallbackToggled, uint32 _settlementNonce, address _refundee, bytes memory _calldata)\n        private\n    {\n        //Update tx state as executed\n        executionState[_settlementNonce] = STATUS_DONE;\n\n        //Try to execute the remote request\n        (bool success,) = bridgeAgentExecutorAddress.call{value: address(this).balance}(_calldata);\n\n        //Update tx state if execution failed\n        if (!success) {\n            //Read the fallback flag and perform the fallback call if necessary. If not, allow for retrying deposit.\n            if (_hasFallbackToggled) {\n                // Update tx state as retrieve only\n                executionState[_settlementNonce] = STATUS_RETRIEVE;\n\n                // Perform fallback call\n                _performFallbackCall(payable(_refundee), _settlementNonce);\n            } else {\n                // If no fallback is requested revert allowing for settlement retry.\n                revert ExecutionFailure();\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    LAYER ZERO INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function performs the call to LayerZero messaging layer Endpoint for cross-chain messaging.\n     *   @param _refundee address to refund excess gas to.\n     *   @param _payload params for root bridge agent execution.\n     *   @param _gParams LayerZero gas information. (_gasLimit,_remoteBranchExecutionGas,_nativeTokenRecipientOnDstChain)\n     */\n    function _performCall(address payable _refundee, bytes memory _payload, GasParams calldata _gParams)\n        internal\n        virtual\n    {\n        //Sends message to LayerZero messaging layer\n        ILayerZeroEndpoint(lzEndpointAddress).send{value: msg.value}(\n            rootChainId,\n            rootBridgeAgentPath,\n            _payload,\n            payable(_refundee),\n            address(0),\n            abi.encodePacked(uint16(2), _gParams.gasLimit, _gParams.remoteBranchExecutionGas, rootBridgeAgentAddress)\n        );\n    }\n\n    /**\n     * @notice Internal function performs the call to Layerzero Endpoint Contract for cross-chain messaging.\n     *   @param _refundee address to refund gas to.\n     *   @param _settlementNonce root settlement nonce to fallback.\n     */\n    function _performFallbackCall(address payable _refundee, uint32 _settlementNonce) internal virtual {\n        //Sends message to LayerZero messaging layer\n        ILayerZeroEndpoint(lzEndpointAddress).send{value: address(this).balance}(\n            rootChainId,\n            rootBridgeAgentPath,\n            abi.encodePacked(bytes1(0x09), _settlementNonce),\n            _refundee,\n            address(0),\n            \"\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                LOCAL USER DEPOSIT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function to move assets from branch chain to root omnichain environment.\n     *         Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositNonce Identifier for user deposit.\n     *   @param _refundee address to return excess gas deposited in `msg.value` to.\n     *   @param _hToken Local Input hToken Address.\n     *   @param _token Native/Underlying Token Address.\n     *   @param _amount Amount of Local hTokens deposited for trade.\n     *   @param _deposit Amount of native tokens deposited for trade.\n     *\n     */\n    function _createDeposit(\n        uint32 _depositNonce,\n        address payable _refundee,\n        address _hToken,\n        address _token,\n        uint256 _amount,\n        uint256 _deposit\n    ) internal {\n        // Update Deposit Nonce\n        depositNonce = _depositNonce + 1;\n\n        // Deposit / Lock Tokens into Port\n        IPort(localPortAddress).bridgeOut(msg.sender, _hToken, _token, _amount, _deposit);\n\n        // Cast to Dynamic\n        address[] memory addressArray = new address[](1);\n        uint256[] memory uintArray = new uint256[](1);\n\n        // Save deposit to storage\n        Deposit storage deposit = getDeposit[_depositNonce];\n        deposit.owner = _refundee;\n\n        addressArray[0] = _hToken;\n        deposit.hTokens = addressArray;\n\n        addressArray[0] = _token;\n        deposit.tokens = addressArray;\n\n        uintArray[0] = _amount;\n        deposit.amounts = uintArray;\n\n        uintArray[0] = _deposit;\n        deposit.deposits = uintArray;\n\n        deposit.status = STATUS_SUCCESS;\n    }\n\n    /**\n     * @dev Internal function to move assets from branch chain to root omnichain environment.\n     *      Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositNonce Identifier for user deposit.\n     *   @param _refundee address to return excess gas deposited in `msg.value` to.\n     *   @param _hTokens Local Input hToken Address.\n     *   @param _tokens Native/Underlying Token"
    }
  ]
}