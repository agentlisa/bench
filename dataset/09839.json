{
  "Title": "[L-01] CrossAnchorBridge: Decide if whitelisting feature is to be kept or removed",
  "Content": "\n### Line References\n\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/cross-chain-contracts/ethereum/CrossAnchorBridge.sol#L125-L130>\n\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/cross-chain-contracts/ethereum/CrossAnchorBridge.sol#L147-L151>\n\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/cross-chain-contracts/ethereum/CrossAnchorBridge.sol#L172-L173>\n\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/cross-chain-contracts/ethereum/CrossAnchorBridge.sol#L251>\n\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/cross-chain-contracts/ethereum/CrossAnchorBridge.sol#L256>\n\n### Description\n\nThe whitelisted mappings are defined and set to `true` for certain token addresses, but the lines of code where they are used are commented out.\n\n### Recommended Mitigation Steps\n\nDecide whether to keep the whitelisting requirement. Either comment out the remaining lines / remove them entirely, or uncomment the lines where they are used.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-02-anchor-contest",
  "Code": [
    {
      "filename": "contracts/cross-chain-contracts/ethereum/CrossAnchorBridge.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"ethereum/BytesLib.sol\";\n\ninterface WormholeCoreBridge {\n    function publishMessage(\n        uint32 nonce,\n        bytes memory payload,\n        uint8 consistencyLevel\n    ) external payable returns (uint64 sequence);\n\n    struct Signature {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        uint8 guardianIndex;\n    }\n\n    struct VM {\n        uint8 version;\n        uint32 timestamp;\n        uint32 nonce;\n        uint16 emitterChainId;\n        bytes32 emitterAddress;\n        uint64 sequence;\n        uint8 consistencyLevel;\n        bytes payload;\n        uint32 guardianSetIndex;\n        Signature[] signatures;\n        bytes32 hash;\n    }\n\n    function parseAndVerifyVM(bytes calldata encodedVM)\n        external\n        view\n        returns (\n            VM memory vm,\n            bool valid,\n            string memory reason\n        );\n}\n\ninterface WormholeTokenBridge {\n    function transferTokens(\n        address token,\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        uint256 arbiterFee,\n        uint32 nonce\n    ) external payable returns (uint64 sequence);\n\n    struct Transfer {\n        // PayloadID uint8 = 1\n        uint8 payloadID;\n        // Amount being transferred (big-endian uint256)\n        uint256 amount;\n        // Address of the token. Left-zero-padded if shorter than 32 bytes\n        bytes32 tokenAddress;\n        // Chain ID of the token\n        uint16 tokenChain;\n        // Address of the recipient. Left-zero-padded if shorter than 32 bytes\n        bytes32 to;\n        // Chain ID of the recipient\n        uint16 toChain;\n        // Amount of tokens (big-endian uint256) that the user is willing to pay as relayer fee. Must be <= Amount.\n        uint256 fee;\n    }\n\n    function parseTransfer(bytes memory encoded)\n        external\n        pure\n        returns (Transfer memory transfer);\n\n    function isTransferCompleted(bytes32 hash) external view returns (bool);\n\n    function completeTransfer(bytes memory encodedVm) external;\n\n    function wrappedAsset(uint16 tokenChainId, bytes32 tokenAddress)\n        external\n        view\n        returns (address);\n\n    function chainId() external view returns (uint16);\n}\n\ncontract CrossAnchorBridge is\n    Initializable,\n    UUPSUpgradeable,\n    OwnableUpgradeable\n{\n    uint16 private constant TERRA_CHAIN_ID = 3;\n\n    uint8 private constant FLAG_INCOMING_TRANSFER = 0x80; // 1000 0000\n    uint8 private constant FLAG_OUTGOING_TRANSFER = 0x40; // 0100 0000\n    uint8 private constant FLAG_BOTH_TRANSFERS = 0xC0; // 1100 0000\n    uint8 private constant FLAG_NO_ASSC_TRANSFER = 0x00; // 0000 0000\n\n    uint8 private constant OP_CODE_DEPOSIT_STABLE = 0 | FLAG_BOTH_TRANSFERS;\n    uint8 private constant OP_CODE_REDEEM_STABLE = 1 | FLAG_BOTH_TRANSFERS;\n\n    uint8 private constant OP_CODE_REPAY_STABLE = 0 | FLAG_INCOMING_TRANSFER;\n    uint8 private constant OP_CODE_LOCK_COLLATERAL = 1 | FLAG_INCOMING_TRANSFER;\n\n    uint8 private constant OP_CODE_UNLOCK_COLLATERAL =\n        0 | FLAG_OUTGOING_TRANSFER;\n    uint8 private constant OP_CODE_BORROW_STABLE = 1 | FLAG_OUTGOING_TRANSFER;\n    uint8 private constant OP_CODE_CLAIM_REWARDS = 2 | FLAG_OUTGOING_TRANSFER;\n\n    uint32 private constant INSTRUCTION_NONCE = 1324532;\n    uint32 private constant TOKEN_TRANSFER_NONCE = 15971121;\n\n    uint8 private CONSISTENCY_LEVEL;\n    address private WORMHOLE_CORE_BRIDGE;\n    address private WORMHOLE_TOKEN_BRIDGE;\n    bytes32 private TERRA_ANCHOR_BRIDGE_ADDRESS;\n\n    // Wormhole-wrapped Terra stablecoin tokens that are whitelisted in Terra Anchor Market. Example: UST.\n    mapping(address => bool) public whitelistedStableTokens;\n    // Wormhole-wrapped Terra Anchor yield-generating tokens that can be redeemed for Terra stablecoins. Example: aUST.\n    mapping(address => bool) public whitelistedAnchorStableTokens;\n    // Wormhole-wrapped Terra cw20 tokens that can be used as collateral in Anchor. Examples: bLUNA, bETH.\n    mapping(address => bool) public whitelistedCollateralTokens;\n\n    // Stores hashes of completed incoming token transfer.\n    mapping(bytes32 => bool) public completedTokenTransfers;\n\n    function initialize(\n        uint8 _consistencyLevel,\n        address _wust,\n        address _aust,\n        address[] memory _collateralTokens,\n        address _wormholeCoreBridge,\n        address _wormholeTokenBridge,\n        bytes32 _terraAnchorBridgeAddress\n    ) public initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        CONSISTENCY_LEVEL = _consistencyLevel;\n        whitelistedStableTokens[_wust] = true;\n        whitelistedAnchorStableTokens[_aust] = true;\n        for (uint8 i = 0; i < _collateralTokens.length; i++) {\n            whitelistedCollateralTokens[_collateralTokens[i]] = true;\n        }\n        WORMHOLE_CORE_BRIDGE = _wormholeCoreBridge;\n        WORMHOLE_TOKEN_BRIDGE = _wormholeTokenBridge;\n        TERRA_ANCHOR_BRIDGE_ADDRESS = _terraAnchorBridgeAddress;\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    function encodeAddress(address addr)\n        internal\n        pure\n        returns (bytes32 encodedAddress)\n    {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function handleStableToken(\n        address token,\n        uint256 amount,\n        uint8 opCode\n    ) internal {\n        // Check that `token` is a whitelisted stablecoin token.\n        // require(whitelistedStableTokens[token]);\n        handleToken(token, amount, opCode);\n    }\n\n    function handleToken(\n        address token,\n        uint256 amount,\n        uint8 opCode\n    ) internal {\n        // Transfer ERC-20 token from message sender to this contract.\n        SafeERC20.safeTransferFrom(\n            IERC20(token),\n            msg.sender,\n            address(this),\n            amount\n        );\n        // Allow wormhole to spend USTw from this contract.\n        SafeERC20.safeApprove(IERC20(token), WORMHOLE_TOKEN_BRIDGE, amount);\n        // Initiate token transfer.\n        uint64 tokenTransferSequence = WormholeTokenBridge(\n            WORMHOLE_TOKEN_BRIDGE\n        ).transferTokens(\n                token,\n                amount,\n                TERRA_CHAIN_ID,\n                TERRA_ANCHOR_BRIDGE_ADDRESS,\n                0,\n                TOKEN_TRANSFER_NONCE\n            );\n        // Send instruction message to Terra manager.\n        WormholeCoreBridge(WORMHOLE_CORE_BRIDGE).publishMessage(\n            INSTRUCTION_NONCE,\n            abi.encodePacked(\n                opCode,\n                encodeAddress(msg.sender),\n                tokenTransferSequence\n            ),\n            CONSISTENCY_LEVEL\n        );\n    }\n\n    function depositStable(address token, uint256 amount) external {\n        handleStableToken(token, amount, OP_CODE_DEPOSIT_STABLE);\n    }\n\n    function repayStable(address token, uint256 amount) external {\n        handleStableToken(token, amount, OP_CODE_REPAY_STABLE);\n    }\n\n    function unlockCollateral(\n        bytes32 collateralTokenTerraAddress,\n        uint128 amount\n    ) external {\n        WormholeCoreBridge(WORMHOLE_CORE_BRIDGE).publishMessage(\n            INSTRUCTION_NONCE,\n            abi.encodePacked(\n                OP_CODE_UNLOCK_COLLATERAL,\n                encodeAddress(msg.sender),\n                collateralTokenTerraAddress,\n                amount\n            ),\n            CONSISTENCY_LEVEL\n        );\n    }\n\n    function borrowStable(uint256 amount) external {\n        WormholeCoreBridge(WORMHOLE_CORE_BRIDGE).publishMessage(\n            INSTRUCTION_NONCE,\n            abi.encodePacked(\n                OP_CODE_BORROW_STABLE,\n                encodeAddress(msg.sender),\n                amount\n            ),\n            CONSISTENCY_LEVEL\n        );\n    }\n\n    function redeemStable(address token, uint256 amount) external {\n        // require(whitelistedAnchorStableTokens[token]);\n        handleToken(token, amount, OP_CODE_REDEEM_STABLE);\n    }\n\n    function lockCollateral(address token, uint256 amount) external {\n        // require(whitelistedCollateralTokens[token]);\n        handleToken(token, amount, OP_CODE_LOCK_COLLATERAL);\n    }\n\n    struct IncomingTokenTransferInfo {\n        uint16 chainId;\n        bytes32 tokenRecipientAddress;\n        uint64 tokenTransferSequence;\n        uint64 instructionSequence;\n    }\n\n    using BytesLib for bytes;\n\n    function parseIncomingTokenTransferInfo(bytes memory encoded)\n        public\n        pure\n        returns (IncomingTokenTransferInfo memory incomingTokenTransferInfo)\n    {\n        uint256 index = 0;\n\n        incomingTokenTransferInfo.chainId = encoded.toUint16(index);\n        index += 2;\n\n        incomingTokenTransferInfo.tokenRecipientAddress = encoded.toBytes32(\n            index\n        );\n        index += 32;\n\n        incomingTokenTransferInfo.tokenTransferSequence = encoded.toUint64(\n            index\n        );\n        index += 8;\n\n        incomingTokenTransferInfo.instructionSequence = encoded.toUint64(index);\n        index += 8;\n\n        require(\n            encoded.length == index,\n            \"invalid IncomingTokenTransferInfo encoded length\"\n        );\n    }\n\n    // operations are bundled into two messages:\n    // - a token transfer message from the token bridge\n    // - a generic message providing context to the token transfer\n    function processTokenTransferInstruction(\n        bytes memory encodedIncomingTokenTransferInfo,\n        bytes memory encodedTokenTransfer\n    ) external {\n        WormholeTokenBridge wormholeTokenBridge = WormholeTokenBridge(\n            WORMHOLE_TOKEN_BRIDGE\n        );\n        WormholeCoreBridge wormholeCoreBridge = WormholeCoreBridge(\n            WORMHOLE_CORE_BRIDGE\n        );\n\n        (\n            WormholeCoreBridge.VM memory incomingTokenTransferInfoVM,\n            bool validIncomingTokenTransferInfo,\n            string memory reasonIncomingTokenTransferInfo\n        ) = wormholeCoreBridge.parseAndVerifyVM(\n                encodedIncomingTokenTransferInfo\n            );\n        require(\n            validIncomingTokenTransferInfo,\n            reasonIncomingTokenTransferInfo\n        );\n        require(\n            incomingTokenTransferInfoVM.emitterChainId == TERRA_CHAIN_ID,\n            \"message does not come from terra\"\n        );\n        require(\n            incomingTokenTransferInfoVM.emitterAddress ==\n                TERRA_ANCHOR_BRIDGE_ADDRESS,\n            \"message does not come from terra anchor bridge\"\n        );\n        require(\n            !completedTokenTransfers[incomingTokenTransferInfoVM.hash],\n            \"transfer info already processed\"\n        );\n\n        // block replay attacks\n        completedTokenTransfers[incomingTokenTransferInfoVM.hash] = true;\n        IncomingTokenTransferInfo\n            memory incomingTokenTransferInfo = parseIncomingTokenTransferInfo(\n                incomingTokenTransferInfoVM.payload\n            );\n\n        (\n            WormholeCoreBridge.VM memory tokenTransferVM,\n            bool valid,\n            string memory reason\n        ) = wormholeCoreBridge.parseAndVerifyVM(encodedTokenTransfer);\n        require(valid, reason);\n        require(\n            tokenTransferVM.emitterChainId == TERRA_CHAIN_ID,\n            \"chain id mismatch\"\n        );\n        // No need to check emitter address; this is checked by completeTransfer.\n        // ensure that the provided transfer vaa is the one referenced by the transfer info\n        require(\n            tokenTransferVM.sequence ==\n                incomingTokenTransferInfo.tokenTransferSequence,\n            \"sequence mismatch\"\n        );\n\n        WormholeTokenBridge.Transfer memory transfer = wormholeTokenBridge\n            .parseTransfer(tokenTransferVM.payload);\n        // No need to check that recipient chain matches this chain; this is checked by completeTransfer.\n        require(\n            transfer.to == encodeAddress(address(this)),\n            \"transfer is not to this address\"\n        );\n        require(\n            transfer.toChain == incomingTokenTransferInfo.chainId,\n            \"transfer is to the wrong chain\"\n        );\n\n        if (!wormholeTokenBridge.isTransferCompleted(tokenTransferVM.hash)) {\n            wormholeTokenBridge.completeTransfer(encodedTokenTransfer);\n        }\n\n        address tokenAddress;\n\n        if (transfer.tokenChain == wormholeTokenBridge.chainId()) {\n            tokenAddress = address(uint160(uint256(transfer.tokenAddress)));\n        } else {\n            tokenAddress = wormholeTokenBridge.wrappedAsset(\n                transfer.tokenChain,\n                transfer.tokenAddress\n            );\n        }\n        // forward the tokens to the appropriate recipient\n        SafeERC20.safeTransfer(\n            IERC20(tokenAddress),\n            address(\n                uint160(\n                    uint256(incomingTokenTransferInfo.tokenRecipientAddress)\n                )\n            ),\n            transfer.amount\n        );\n    }\n}"
    },
    {
      "filename": "contracts/cross-chain-contracts/ethereum/CrossAnchorBridge.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"ethereum/BytesLib.sol\";\n\ninterface WormholeCoreBridge {\n    function publishMessage(\n        uint32 nonce,\n        bytes memory payload,\n        uint8 consistencyLevel\n    ) external payable returns (uint64 sequence);\n\n    struct Signature {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        uint8 guardianIndex;\n    }\n\n    struct VM {\n        uint8 version;\n        uint32 timestamp;\n        uint32 nonce;\n        uint16 emitterChainId;\n        bytes32 emitterAddress;\n        uint64 sequence;\n        uint8 consistencyLevel;\n        bytes payload;\n        uint32 guardianSetIndex;\n        Signature[] signatures;\n        bytes32 hash;\n    }\n\n    function parseAndVerifyVM(bytes calldata encodedVM)\n        external\n        view\n        returns (\n            VM memory vm,\n            bool valid,\n            string memory reason\n        );\n}\n\ninterface WormholeTokenBridge {\n    function transferTokens(\n        address token,\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        uint256 arbiterFee,\n        uint32 nonce\n    ) external payable returns (uint64 sequence);\n\n    struct Transfer {\n        // PayloadID uint8 = 1\n        uint8 payloadID;\n        // Amount being transferred (big-endian uint256)\n        uint256 amount;\n        // Address of the token. Left-zero-padded if shorter than 32 bytes\n        bytes32 tokenAddress;\n        // Chain ID of the token\n        uint16 tokenChain;\n        // Address of the recipient. Left-zero-padded if shorter than 32 bytes\n        bytes32 to;\n        // Chain ID of the recipient\n        uint16 toChain;\n        // Amount of tokens (big-endian uint256) that the user is willing to pay as relayer fee. Must be <= Amount.\n        uint256 fee;\n    }\n\n    function parseTransfer(bytes memory encoded)\n        external\n        pure\n        returns (Transfer memory transfer);\n\n    function isTransferCompleted(bytes32 hash) external view returns (bool);\n\n    function completeTransfer(bytes memory encodedVm) external;\n\n    function wrappedAsset(uint16 tokenChainId, bytes32 tokenAddress)\n        external\n        view\n        returns (address);\n\n    function chainId() external view returns (uint16);\n}\n\ncontract CrossAnchorBridge is\n    Initializable,\n    UUPSUpgradeable,\n    OwnableUpgradeable\n{\n    uint16 private constant TERRA_CHAIN_ID = 3;\n\n    uint8 private constant FLAG_INCOMING_TRANSFER = 0x80; // 1000 0000\n    uint8 private constant FLAG_OUTGOING_TRANSFER = 0x40; // 0100 0000\n    uint8 private constant FLAG_BOTH_TRANSFERS = 0xC0; // 1100 0000\n    uint8 private constant FLAG_NO_ASSC_TRANSFER = 0x00; // 0000 0000\n\n    uint8 private constant OP_CODE_DEPOSIT_STABLE = 0 | FLAG_BOTH_TRANSFERS;\n    uint8 private constant OP_CODE_REDEEM_STABLE = 1 | FLAG_BOTH_TRANSFERS;\n\n    uint8 private constant OP_CODE_REPAY_STABLE = 0 | FLAG_INCOMING_TRANSFER;\n    uint8 private constant OP_CODE_LOCK_COLLATERAL = 1 | FLAG_INCOMING_TRANSFER;\n\n    uint8 private constant OP_CODE_UNLOCK_COLLATERAL =\n        0 | FLAG_OUTGOING_TRANSFER;\n    uint8 private constant OP_CODE_BORROW_STABLE = 1 | FLAG_OUTGOING_TRANSFER;\n    uint8 private constant OP_CODE_CLAIM_REWARDS = 2 | FLAG_OUTGOING_TRANSFER;\n\n    uint32 private constant INSTRUCTION_NONCE = 1324532;\n    uint32 private constant TOKEN_TRANSFER_NONCE = 15971121;\n\n    uint8 private CONSISTENCY_LEVEL;\n    address private WORMHOLE_CORE_BRIDGE;\n    address private WORMHOLE_TOKEN_BRIDGE;\n    bytes32 private TERRA_ANCHOR_BRIDGE_ADDRESS;\n\n    // Wormhole-wrapped Terra stablecoin tokens that are whitelisted in Terra Anchor Market. Example: UST.\n    mapping(address => bool) public whitelistedStableTokens;\n    // Wormhole-wrapped Terra Anchor yield-generating tokens that can be redeemed for Terra stablecoins. Example: aUST.\n    mapping(address => bool) public whitelistedAnchorStableTokens;\n    // Wormhole-wrapped Terra cw20 tokens that can be used as collateral in Anchor. Examples: bLUNA, bETH.\n    mapping(address => bool) public whitelistedCollateralTokens;\n\n    // Stores hashes of completed incoming token transfer.\n    mapping(bytes32 => bool) public completedTokenTransfers;\n\n    function initialize(\n        uint8 _consistencyLevel,\n        address _wust,\n        address _aust,\n        address[] memory _collateralTokens,\n        address _wormholeCoreBridge,\n        address _wormholeTokenBridge,\n        bytes32 _terraAnchorBridgeAddress\n    ) public initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        CONSISTENCY_LEVEL = _consistencyLevel;\n        whitelistedStableTokens[_wust] = true;\n        whitelistedAnchorStableTokens[_aust] = true;\n        for (uint8 i = 0; i < _collateralTokens.length; i++) {\n            whitelistedCollateralTokens[_collateralTokens[i]] = true;\n        }\n        WORMHOLE_CORE_BRIDGE = _wormholeCoreBridge;\n        WORMHOLE_TOKEN_BRIDGE = _wormholeTokenBridge;\n        TERRA_ANCHOR_BRIDGE_ADDRESS = _terraAnchorBridgeAddress;\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    function encodeAddress(address addr)\n        internal\n        pure\n        returns (bytes32 encodedAddress)\n    {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function handleStableToken(\n        address token,\n        uint256 amount,\n        uint8 opCode\n    ) internal {\n        // Check that `token` is a whitelisted stablecoin token.\n        // require(whitelistedStableTokens[token]);\n        handleToken(token, amount, opCode);\n    }\n\n    function handleToken(\n        address token,\n        uint256 amount,\n        uint8 opCode\n    ) internal {\n        // Transfer ERC-20 token from message sender to this contract.\n        SafeERC20.safeTransferFrom(\n            IERC20(token),\n            msg.sender,\n            address(this),\n            amount\n        );\n        // Allow wormhole to spend USTw from this contract.\n        SafeERC20.safeApprove(IERC20(token), WORMHOLE_TOKEN_BRIDGE, amount);\n        // Initiate token transfer.\n        uint64 tokenTransferSequence = WormholeTokenBridge(\n            WORMHOLE_TOKEN_BRIDGE\n        ).transferTokens(\n                token,\n                amount,\n                TERRA_CHAIN_ID,\n                TERRA_ANCHOR_BRIDGE_ADDRESS,\n                0,\n                TOKEN_TRANSFER_NONCE\n            );\n        // Send instruction message to Terra manager.\n        WormholeCoreBridge(WORMHOLE_CORE_BRIDGE).publishMessage(\n            INSTRUCTION_NONCE,\n            abi.encodePacked(\n                opCode,\n                encodeAddress(msg.sender),\n                tokenTransferSequence\n            ),\n            CONSISTENCY_LEVEL\n        );\n    }\n\n    function depositStable(address token, uint256 amount) external {\n        handleStableToken(token, amount, OP_CODE_DEPOSIT_STABLE);\n    }\n\n    function repayStable(address token, uint256 amount) external {\n        handleStableToken(token, amount, OP_CODE_REPAY_STABLE);\n    }\n\n    function unlockCollateral(\n        bytes32 collateralTokenTerraAddress,\n        uint128 amount\n    ) external {\n        WormholeCoreBridge(WORMHOLE_CORE_BRIDGE).publishMessage(\n            INSTRUCTION_NONCE,\n            abi.encodePacked(\n                OP_CODE_UNLOCK_COLLATERAL,\n                encodeAddress(msg.sender),\n                collateralTokenTerraAddress,\n                amount\n            ),\n            CONSISTENCY_LEVEL\n        );\n    }\n\n    function borrowStable(uint256 amount) external {\n        WormholeCoreBridge(WORMHOLE_CORE_BRIDGE).publishMessage(\n            INSTRUCTION_NONCE,\n            abi.encodePacked(\n                OP_CODE_BORROW_STABLE,\n                encodeAddress(msg.sender),\n                amount\n            ),\n            CONSISTENCY_LEVEL\n        );\n    }\n\n    function redeemStable(address token, uint256 amount) external {\n        // require(whitelistedAnchorStableTokens[token]);\n        handleToken(token, amount, OP_CODE_REDEEM_STABLE);\n    }\n\n    function lockCollateral(address token, uint256 amount) external {\n        // require(whitelistedCollateralTokens[token]);\n        handleToken(token, amount, OP_CODE_LOCK_COLLATERAL);\n    }\n\n    struct IncomingTokenTransferInfo {\n        uint16 chainId;\n        bytes32 tokenRecipientAddress;\n        uint64 tokenTransferSequence;\n        uint64 instructionSequence;\n    }\n\n    using BytesLib for bytes;\n\n    function parseIncomingTokenTransferInfo(bytes memory encoded)\n        public\n        pure\n        returns (IncomingTokenTransferInfo memory incomingTokenTransferInfo)\n    {\n        uint256 index = 0;\n\n        incomingTokenTransferInfo.chainId = encoded.toUint16(index);\n        index += 2;\n\n        incomingTokenTransferInfo.tokenRecipientAddress = encoded.toBytes32(\n            index\n        );\n        index += 32;\n\n        incomingTokenTransferInfo.tokenTransferSequence = encoded.toUint64(\n            index\n        );\n        index += 8;\n\n        incomingTokenTransferInfo.instructionSequence = encoded.toUint64(index);\n        index += 8;\n\n        require(\n            encoded.length == index,\n            \"invalid IncomingTokenTransferInfo encoded length\"\n        );\n    }\n\n    // operations are bundled into two messages:\n    // - a token transfer message from the token bridge\n    // - a generic message providing context to the token transfer\n    function processTokenTransferInstruction(\n        bytes memory encodedIncomingTokenTransferInfo,\n        bytes memory encodedTokenTransfer\n    ) external {\n        WormholeTokenBridge wormholeTokenBridge = WormholeTokenBridge(\n            WORMHOLE_TOKEN_BRIDGE\n        );\n        WormholeCoreBridge wormholeCoreBridge = WormholeCoreBridge(\n            WORMHOLE_CORE_BRIDGE\n        );\n\n        (\n            WormholeCoreBridge.VM memory incomingTokenTransferInfoVM,\n            bool validIncomingTokenTransferInfo,\n            string memory reasonIncomingTokenTransferInfo\n        ) = wormholeCoreBridge.parseAndVerifyVM(\n                encodedIncomingTokenTransferInfo\n            );\n        require(\n            validIncomingTokenTransferInfo,\n            reasonIncomingTokenTransferInfo\n        );\n        require(\n            incomingTokenTransferInfoVM.emitterChainId == TERRA_CHAIN_ID,\n            \"message does not come from terra\"\n        );\n        require(\n            incomingTokenTransferInfoVM.emitterAddress ==\n                TERRA_ANCHOR_BRIDGE_ADDRESS,\n            \"message does not come from terra anchor bridge\"\n        );\n        require(\n            !completedTokenTransfers[incomingTokenTransferInfoVM.hash],\n            \"transfer info already processed\"\n        );\n\n        // block replay attacks\n        completedTokenTransfers[incomingTokenTransferInfoVM.hash] = true;\n        IncomingTokenTransferInfo\n            memory incomingTokenTransferInfo = parseIncomingTokenTransferInfo(\n                incomingTokenTransferInfoVM.payload\n            );\n\n        (\n            WormholeCoreBridge.VM memory tokenTransferVM,\n            bool valid,\n            string memory reason\n        ) = wormholeCoreBridge.parseAndVerifyVM(encodedTokenTransfer);\n        require(valid, reason);\n        require(\n            tokenTransferVM.emitterChainId == TERRA_CHAIN_ID,\n            \"chain id mismatch\"\n        );\n        // No need to check emitter address; this is checked by completeTransfer.\n        // ensure that the provided transfer vaa is the one referenced by the transfer info\n        require(\n            tokenTransferVM.sequence ==\n                incomingTokenTransferInfo.tokenTransferSequence,\n            \"sequence mismatch\"\n        );\n\n        WormholeTokenBridge.Transfer memory transfer = wormholeTokenBridge\n            .parseTransfer(tokenTransferVM.payload);\n        // No need to check that recipient chain matches this chain; this is checked by completeTransfer.\n        require(\n            transfer.to == encodeAddress(address(this)),\n            \"transfer is not to this address\"\n        );\n        require(\n            transfer.toChain == incomingTokenTransferInfo.chainId,\n            \"transfer is to the wrong chain\"\n        );\n\n        if (!wormholeTokenBridge.isTransferCompleted(tokenTransferVM.hash)) {\n            wormholeTokenBridge.completeTransfer(encodedTokenTransfer);\n        }\n\n        address tokenAddress;\n\n        if (transfer.tokenChain == wormholeTokenBridge.chainId()) {\n            tokenAddress = address(uint160(uint256(transfer.tokenAddress)));\n        } else {\n            tokenAddress = wormholeTokenBridge.wrappedAsset(\n                transfer.tokenChain,\n                transfer.tokenAddress\n            );\n        }\n        // forward the tokens to the appropriate recipient\n        SafeERC20.safeTransfer(\n            IERC20(tokenAddress),\n            address(\n                uint160(\n                    uint256(incomingTokenTransferInfo.tokenRecipientAddress)\n                )\n            ),\n            transfer.amount\n        );\n    }\n}"
    },
    {
      "filename": "contracts/cross-chain-contracts/ethereum/CrossAnchorBridge.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"ethereum/BytesLib.sol\";\n\ninterface WormholeCoreBridge {\n    function publishMessage(\n        uint32 nonce,\n        bytes memory payload,\n        uint8 consistencyLevel\n    ) external payable returns (uint64 sequence);\n\n    struct Signature {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        uint8 guardianIndex;\n    }\n\n    struct VM {\n        uint8 version;\n        uint32 timestamp;\n        uint32 nonce;\n        uint16 emitterChainId;\n        bytes32 emitterAddress;\n        uint64 sequence;\n        uint8 consistencyLevel;\n        bytes payload;\n        uint32 guardianSetIndex;\n        Signature[] signatures;\n        bytes32 hash;\n    }\n\n    function parseAndVerifyVM(bytes calldata encodedVM)\n        external\n        view\n        returns (\n            VM memory vm,\n            bool valid,\n            string memory reason\n        );\n}\n\ninterface WormholeTokenBridge {\n    function transferTokens(\n        address token,\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        uint256 arbiterFee,\n        uint32 nonce\n    ) external payable returns (uint64 sequence);\n\n    struct Transfer {\n        // PayloadID uint8 = 1\n        uint8 payloadID;\n        // Amount being transferred (big-endian uint256)\n        uint256 amount;\n        // Address of the token. Left-zero-padded if shorter than 32 bytes\n        bytes32 tokenAddress;\n        // Chain ID of the token\n        uint16 tokenChain;\n        // Address of the recipient. Left-zero-padded if shorter than 32 bytes\n        bytes32 to;\n        // Chain ID of the recipient\n        uint16 toChain;\n        // Amount of tokens (big-endian uint256) that the user is willing to pay as relayer fee. Must be <= Amount.\n        uint256 fee;\n    }\n\n    function parseTransfer(bytes memory encoded)\n        external\n        pure\n        returns (Transfer memory transfer);\n\n    function isTransferCompleted(bytes32 hash) external view returns (bool);\n\n    function completeTransfer(bytes memory encodedVm) external;\n\n    function wrappedAsset(uint16 tokenChainId, bytes32 tokenAddress)\n        external\n        view\n        returns (address);\n\n    function chainId() external view returns (uint16);\n}\n\ncontract CrossAnchorBridge is\n    Initializable,\n    UUPSUpgradeable,\n    OwnableUpgradeable\n{\n    uint16 private constant TERRA_CHAIN_ID = 3;\n\n    uint8 private constant FLAG_INCOMING_TRANSFER = 0x80; // 1000 0000\n    uint8 private constant FLAG_OUTGOING_TRANSFER = 0x40; // 0100 0000\n    uint8 private constant FLAG_BOTH_TRANSFERS = 0xC0; // 1100 0000\n    uint8 private constant FLAG_NO_ASSC_TRANSFER = 0x00; // 0000 0000\n\n    uint8 private constant OP_CODE_DEPOSIT_STABLE = 0 | FLAG_BOTH_TRANSFERS;\n    uint8 private constant OP_CODE_REDEEM_STABLE = 1 | FLAG_BOTH_TRANSFERS;\n\n    uint8 private constant OP_CODE_REPAY_STABLE = 0 | FLAG_INCOMING_TRANSFER;\n    uint8 private constant OP_CODE_LOCK_COLLATERAL = 1 | FLAG_INCOMING_TRANSFER;\n\n    uint8 private constant OP_CODE_UNLOCK_COLLATERAL =\n        0 | FLAG_OUTGOING_TRANSFER;\n    uint8 private constant OP_CODE_BORROW_STABLE = 1 | FLAG_OUTGOING_TRANSFER;\n    uint8 private constant OP_CODE_CLAIM_REWARDS = 2 | FLAG_OUTGOING_TRANSFER;\n\n    uint32 private constant INSTRUCTION_NONCE = 1324532;\n    uint32 private constant TOKEN_TRANSFER_NONCE = 15971121;\n\n    uint8 private CONSISTENCY_LEVEL;\n    address private WORMHOLE_CORE_BRIDGE;\n    address private WORMHOLE_TOKEN_BRIDGE;\n    bytes32 private TERRA_ANCHOR_BRIDGE_ADDRESS;\n\n    // Wormhole-wrapped Terra stablecoin tokens that are whitelisted in Terra Anchor Market. Example: UST.\n    mapping(address => bool) public whitelistedStableTokens;\n    // Wormhole-wrapped Terra Anchor yield-generating tokens that can be redeemed for Terra stablecoins. Example: aUST.\n    mapping(address => bool) public whitelistedAnchorStableTokens;\n    // Wormhole-wrapped Terra cw20 tokens that can be used as collateral in Anchor. Examples: bLUNA, bETH.\n    mapping(address => bool) public whitelistedCollateralTokens;\n\n    // Stores hashes of completed incoming token transfer.\n    mapping(bytes32 => bool) public completedTokenTransfers;\n\n    function initialize(\n        uint8 _consistencyLevel,\n        address _wust,\n        address _aust,\n        address[] memory _collateralTokens,\n        address _wormholeCoreBridge,\n        address _wormholeTokenBridge,\n        bytes32 _terraAnchorBridgeAddress\n    ) public initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        CONSISTENCY_LEVEL = _consistencyLevel;\n        whitelistedStableTokens[_wust] = true;\n        whitelistedAnchorStableTokens[_aust] = true;\n        for (uint8 i = 0; i < _collateralTokens.length; i++) {\n            whitelistedCollateralTokens[_collateralTokens[i]] = true;\n        }\n        WORMHOLE_CORE_BRIDGE = _wormholeCoreBridge;\n        WORMHOLE_TOKEN_BRIDGE = _wormholeTokenBridge;\n        TERRA_ANCHOR_BRIDGE_ADDRESS = _terraAnchorBridgeAddress;\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    function encodeAddress(address addr)\n        internal\n        pure\n        returns (bytes32 encodedAddress)\n    {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function handleStableToken(\n        address token,\n        uint256 amount,\n        uint8 opCode\n    ) internal {\n        // Check that `token` is a whitelisted stablecoin token.\n        // require(whitelistedStableTokens[token]);\n        handleToken(token, amount"
    }
  ]
}