{
  "Title": "[N-04] `unfollow()` should be allowed for burnt profiles",
  "Content": "\nIn the `LensHub` contract, `unfollow()` will revert if the profile to unfollow is burnt, due to the following check:\n\n[FollowLib.sol#L54-L62](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/FollowLib.sol#L54-L62)\n\n```solidity\n    function unfollow(\n        uint256 unfollowerProfileId,\n        address transactionExecutor,\n        uint256[] calldata idsOfProfilesToUnfollow\n    ) external {\n        uint256 i;\n        while (i < idsOfProfilesToUnfollow.length) {\n            uint256 idOfProfileToUnfollow = idsOfProfilesToUnfollow[i];\n            ValidationLib.validateProfileExists(idOfProfileToUnfollow); // auditor: This check\n```\n\nHowever, this implementation seems incorrect as users should be able to unfollow burnt profiles. \n\nThis issue can be sidestepped by calling [`removeFollower()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/FollowNFT.sol#L131-L138) or [`burn()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/FollowNFT.sol#L255-L258) in the burnt profile's FollowNFT contract, but could be extremely inconvenient as users will have to first wrap their follow token.\n\n### Recommendation\n\nConsider removing the `validateProfileExists()` check in `unfollow()`:\n\n[FollowLib.sol#L54-L62](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/FollowLib.sol#L54-L62)\n\n```diff\n    function unfollow(\n        uint256 unfollowerProfileId,\n        address transactionExecutor,\n        uint256[] calldata idsOfProfilesToUnfollow\n    ) external {\n        uint256 i;\n        while (i < idsOfProfilesToUnfollow.length) {\n            uint256 idOfProfileToUnfollow = idsOfProfilesToUnfollow[i];\n-           ValidationLib.validateProfileExists(idOfProfileToUnfollow); // auditor: This check\n```\n\nThis is possible as the `followNFT` addrress of non-existent profiles (profiles that are not minted yet) is 0, which causes the function to revert later on during execution.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/libraries/FollowLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {IFollowModule} from 'contracts/interfaces/IFollowModule.sol';\nimport {ValidationLib} from 'contracts/libraries/ValidationLib.sol';\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {Events} from 'contracts/libraries/constants/Events.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\nimport {FollowNFTProxy} from 'contracts/base/upgradeability/FollowNFTProxy.sol';\n\nlibrary FollowLib {\n    function follow(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata followModuleDatas\n    ) external returns (uint256[] memory) {\n        if (\n            idsOfProfilesToFollow.length != followTokenIds.length ||\n            idsOfProfilesToFollow.length != followModuleDatas.length\n        ) {\n            revert Errors.ArrayMismatch();\n        }\n        uint256[] memory followTokenIdsAssigned = new uint256[](idsOfProfilesToFollow.length);\n        uint256 i;\n        while (i < idsOfProfilesToFollow.length) {\n            ValidationLib.validateProfileExists({profileId: idsOfProfilesToFollow[i]});\n\n            ValidationLib.validateNotBlocked({profile: followerProfileId, byProfile: idsOfProfilesToFollow[i]});\n\n            if (followerProfileId == idsOfProfilesToFollow[i]) {\n                revert Errors.SelfFollow();\n            }\n\n            followTokenIdsAssigned[i] = _follow({\n                followerProfileId: followerProfileId,\n                transactionExecutor: transactionExecutor,\n                idOfProfileToFollow: idsOfProfilesToFollow[i],\n                followTokenId: followTokenIds[i],\n                followModuleData: followModuleDatas[i]\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n        return followTokenIdsAssigned;\n    }\n\n    function unfollow(\n        uint256 unfollowerProfileId,\n        address transactionExecutor,\n        uint256[] calldata idsOfProfilesToUnfollow\n    ) external {\n        uint256 i;\n        while (i < idsOfProfilesToUnfollow.length) {\n            uint256 idOfProfileToUnfollow = idsOfProfilesToUnfollow[i];\n            ValidationLib.validateProfileExists(idOfProfileToUnfollow);\n\n            address followNFT = StorageLib.getProfile(idOfProfileToUnfollow).followNFT;\n\n            if (followNFT == address(0)) {\n                revert Errors.NotFollowing();\n            }\n\n            IFollowNFT(followNFT).unfollow({\n                unfollowerProfileId: unfollowerProfileId,\n                transactionExecutor: transactionExecutor\n            });\n\n            emit Events.Unfollowed(unfollowerProfileId, idOfProfileToUnfollow, block.timestamp);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Deploys the given profile's Follow NFT contract.\n     *\n     * @param profileId The token ID of the profile which Follow NFT should be deployed.\n     *\n     * @return address The address of the deployed Follow NFT contract.\n     */\n    function _deployFollowNFT(uint256 profileId) private returns (address) {\n        bytes memory functionData = abi.encodeWithSelector(IFollowNFT.initialize.selector, profileId);\n        address followNFT = address(new FollowNFTProxy(functionData));\n        emit Events.FollowNFTDeployed(profileId, followNFT, block.timestamp);\n\n        return followNFT;\n    }\n\n    function _follow(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 idOfProfileToFollow,\n        uint256 followTokenId,\n        bytes calldata followModuleData\n    ) private returns (uint256) {\n        Types.Profile storage _profileToFollow = StorageLib.getProfile(idOfProfileToFollow);\n\n        address followNFT = _profileToFollow.followNFT;\n        if (followNFT == address(0)) {\n            followNFT = _deployFollowNFT(idOfProfileToFollow);\n            _profileToFollow.followNFT = followNFT;\n        }\n\n        uint256 followTokenIdAssigned = IFollowNFT(followNFT).follow({\n            followerProfileId: followerProfileId,\n            transactionExecutor: transactionExecutor,\n            followTokenId: followTokenId\n        });\n\n        bytes memory processFollowModuleReturnData;\n        address followModule = _profileToFollow.followModule;\n        if (followModule != address(0)) {\n            processFollowModuleReturnData = IFollowModule(followModule).processFollow(\n                followerProfileId,\n                followTokenId,\n                transactionExecutor,\n                idOfProfileToFollow,\n                followModuleData\n            );\n        }\n\n        emit Events.Followed(\n            followerProfileId,\n            idOfProfileToFollow,\n            followTokenIdAssigned,\n            followModuleData,\n            processFollowModuleReturnData,\n            block.timestamp\n        );\n\n        return followTokenIdAssigned;\n    }\n}"
    },
    {
      "filename": "contracts/FollowNFT.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {ERC2981CollectionRoyalties} from 'contracts/base/ERC2981CollectionRoyalties.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {HubRestricted} from 'contracts/base/HubRestricted.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC721Timestamped} from 'contracts/interfaces/IERC721Timestamped.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\nimport {LensBaseERC721} from 'contracts/base/LensBaseERC721.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {FollowTokenURILib} from 'contracts/libraries/token-uris/FollowTokenURILib.sol';\n\ncontract FollowNFT is HubRestricted, LensBaseERC721, ERC2981CollectionRoyalties, IFollowNFT {\n    using Strings for uint256;\n\n    string constant FOLLOW_NFT_NAME_SUFFIX = '-Follower';\n    string constant FOLLOW_NFT_SYMBOL_SUFFIX = '-Fl';\n\n    uint256[5] ___DEPRECATED_SLOTS; // Deprecated slots, previously used for delegations.\n    uint256 internal _followedProfileId;\n\n    // Old uint256 `_lastFollowTokenId` slot splitted into two uint128s to include `_followerCount`.\n    uint128 internal _lastFollowTokenId;\n    // `_followerCount` will not be decreased when a follower profile is burned, making the counter not fully accurate.\n    // New variable added in V2 in the same slot, lower-ordered to not conflict with previous storage layout.\n    uint128 internal _followerCount;\n\n    bool private _initialized;\n\n    // Introduced in v2\n    mapping(uint256 => Types.FollowData) internal _followDataByFollowTokenId;\n    mapping(uint256 => uint256) internal _followTokenIdByFollowerProfileId;\n    mapping(uint256 => uint256) internal _followApprovalByFollowTokenId;\n    uint256 internal _royaltiesInBasisPoints;\n\n    event FollowApproval(uint256 indexed followerProfileId, uint256 indexed followTokenId);\n\n    constructor(address hub) HubRestricted(hub) {\n        _initialized = true;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function initialize(uint256 profileId) external override {\n        // This is called right after deployment by the LensHub, so we can skip the onlyHub check.\n        if (_initialized) {\n            revert Errors.Initialized();\n        }\n        _initialized = true;\n        _followedProfileId = profileId;\n        _setRoyalty(1000); // 10% of royalties\n    }\n\n    /// @inheritdoc IFollowNFT\n    function follow(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 followTokenId\n    ) external override onlyHub returns (uint256) {\n        if (_followTokenIdByFollowerProfileId[followerProfileId] != 0) {\n            revert AlreadyFollowing();\n        }\n\n        if (followTokenId == 0) {\n            // Fresh follow.\n            return _followMintingNewToken(followerProfileId);\n        }\n\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner != address(0)) {\n            // Provided follow token is wrapped.\n            return\n                _followWithWrappedToken({\n                    followerProfileId: followerProfileId,\n                    transactionExecutor: transactionExecutor,\n                    followTokenId: followTokenId,\n                    followTokenOwner: followTokenOwner\n                });\n        }\n\n        uint256 currentFollowerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (currentFollowerProfileId != 0) {\n            // Provided follow token is unwrapped.\n            // It has a follower profile set already, it can only be used to follow if that profile was burnt.\n            return\n                _followWithUnwrappedTokenFromBurnedProfile({\n                    followerProfileId: followerProfileId,\n                    followTokenId: followTokenId,\n                    currentFollowerProfileId: currentFollowerProfileId\n                });\n        }\n\n        // Provided follow token does not exist anymore, it can only be used if the profile attempting to follow is\n        // allowed to recover it.\n        return _followByRecoveringToken({followerProfileId: followerProfileId, followTokenId: followTokenId});\n    }\n\n    /// @inheritdoc IFollowNFT\n    function unfollow(uint256 unfollowerProfileId, address transactionExecutor) external override onlyHub {\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[unfollowerProfileId];\n        if (followTokenId == 0) {\n            revert NotFollowing();\n        }\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner == address(0)) {\n            // Follow token is unwrapped.\n            // Unfollowing and allowing recovery.\n            _unfollow({unfollower: unfollowerProfileId, followTokenId: followTokenId});\n            _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover = unfollowerProfileId;\n        } else {\n            // Follow token is wrapped.\n            address unfollowerProfileOwner = IERC721(HUB).ownerOf(unfollowerProfileId);\n            // Follower profile owner or its approved delegated executor must hold the token or be approved-for-all.\n            if (\n                (followTokenOwner != unfollowerProfileOwner) &&\n                (followTokenOwner != transactionExecutor) &&\n                !isApprovedForAll(followTokenOwner, transactionExecutor) &&\n                !isApprovedForAll(followTokenOwner, unfollowerProfileOwner)\n            ) {\n                revert DoesNotHavePermissions();\n            }\n            _unfollow({unfollower: unfollowerProfileId, followTokenId: followTokenId});\n        }\n    }\n\n    /// @inheritdoc IFollowNFT\n    function removeFollower(uint256 followTokenId) external override {\n        address followTokenOwner = ownerOf(followTokenId);\n        if (followTokenOwner == msg.sender || isApprovedForAll(followTokenOwner, msg.sender)) {\n            _unfollowIfHasFollower(followTokenId);\n        } else {\n            revert DoesNotHavePermissions();\n        }\n    }\n\n    /// @inheritdoc IFollowNFT\n    function approveFollow(uint256 followerProfileId, uint256 followTokenId) external override {\n        if (!IERC721Timestamped(HUB).exists(followerProfileId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner == address(0)) {\n            revert OnlyWrappedFollowTokens();\n        }\n        if (followTokenOwner != msg.sender && !isApprovedForAll(followTokenOwner, msg.sender)) {\n            revert DoesNotHavePermissions();\n        }\n        _approveFollow(followerProfileId, followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function wrap(uint256 followTokenId, address wrappedTokenReceiver) external override {\n        if (wrappedTokenReceiver == address(0)) {\n            revert Errors.InvalidParameter();\n        }\n        _wrap(followTokenId, wrappedTokenReceiver);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function wrap(uint256 followTokenId) external override {\n        _wrap(followTokenId, address(0));\n    }\n\n    function _wrap(uint256 followTokenId, address wrappedTokenReceiver) internal {\n        if (_isFollowTokenWrapped(followTokenId)) {\n            revert AlreadyWrapped();\n        }\n        uint256 followerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (followerProfileId == 0) {\n            followerProfileId = _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n            if (followerProfileId == 0) {\n                revert FollowTokenDoesNotExist();\n            }\n            delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n        }\n        address followerProfileOwner = IERC721(HUB).ownerOf(followerProfileId);\n        if (msg.sender != followerProfileOwner) {\n            revert DoesNotHavePermissions();\n        }\n        _mint(wrappedTokenReceiver == address(0) ? followerProfileOwner : wrappedTokenReceiver, followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function unwrap(uint256 followTokenId) external override {\n        if (_followDataByFollowTokenId[followTokenId].followerProfileId == 0) {\n            revert NotFollowing();\n        }\n        super.burn(followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function processBlock(uint256 followerProfileId) external override onlyHub returns (bool) {\n        bool hasUnfollowed;\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[followerProfileId];\n        if (followTokenId != 0) {\n            if (!_isFollowTokenWrapped(followTokenId)) {\n                // Wrap it first, so the user stops following but does not lose the token when being blocked.\n                _mint(IERC721(HUB).ownerOf(followerProfileId), followTokenId);\n            }\n            _unfollow(followerProfileId, followTokenId);\n            hasUnfollowed = true;\n        }\n        return hasUnfollowed;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowerProfileId(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].followerProfileId;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function isFollowing(uint256 followerProfileId) external view override returns (bool) {\n        return _followTokenIdByFollowerProfileId[followerProfileId] != 0;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowTokenId(uint256 followerProfileId) external view override returns (uint256) {\n        return _followTokenIdByFollowerProfileId[followerProfileId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getOriginalFollowTimestamp(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].originalFollowTimestamp;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowTimestamp(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].followTimestamp;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getProfileIdAllowedToRecover(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowData(uint256 followTokenId) external view override returns (Types.FollowData memory) {\n        return _followDataByFollowTokenId[followTokenId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowApproved(uint256 followTokenId) external view override returns (uint256) {\n        return _followApprovalByFollowTokenId[followTokenId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowerCount() external view override returns (uint256) {\n        return _followerCount;\n    }\n\n    function burn(uint256 followTokenId) public override {\n        _unfollowIfHasFollower(followTokenId);\n        super.burn(followTokenId);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(LensBaseERC721, ERC2981CollectionRoyalties)\n        returns (bool)\n    {\n        return\n            LensBaseERC721.supportsInterface(interfaceId) || ERC2981CollectionRoyalties.supportsInterface(interfaceId);\n    }\n\n    function name() public view override returns (string memory) {\n        return string(abi.encodePacked(_followedProfileId.toString(), FOLLOW_NFT_NAME_SUFFIX));\n    }\n\n    function symbol() public view override returns (string memory) {\n        return string(abi.encodePacked(_followedProfileId.toString(), FOLLOW_NFT_SYMBOL_SUFFIX));\n    }\n\n    /**\n     * @dev This returns the follow NFT URI fetched from the hub.\n     */\n    function tokenURI(uint256 followTokenId) public view override returns (string memory) {\n        if (!_exists(followTokenId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        return\n            FollowTokenURILib.getTokenURI(\n                followTokenId,\n                _followedProfileId,\n                _followDataByFollowTokenId[followTokenId].originalFollowTimestamp\n            );\n    }\n\n    function _followMintingNewToken(uint256 followerProfileId) internal returns (uint256) {\n        uint256 followTokenIdAssigned;\n        unchecked {\n            followTokenIdAssigned = ++_lastFollowTokenId;\n            _followerCount++;\n        }\n        _baseFollow({\n            followerProfileId: followerProfileId,\n            followTokenId: followTokenIdAssigned,\n            isOriginalFollow: true\n        });\n        return followTokenIdAssigned;\n    }\n\n    function _followWithWrappedToken(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 followTokenId,\n        address followTokenOwner\n    ) internal returns (uint256) {\n        bool isFollowApproved = _followApprovalByFollowTokenId[followTokenId] == followerProfileId;\n        address followerProfileOwner = IERC721(HUB).ownerOf(followerProfileId);\n        if (\n            !isFollowApproved &&\n            followTokenOwner != followerProfileOwner &&\n            followTokenOwner != transactionExecutor &&\n            !isApprovedForAll(followTokenOwner, transactionExecutor) &&\n            !isApprovedForAll(followTokenOwner, followerProfileOwner)\n        ) {\n            revert DoesNotHavePermissions();\n        }\n        // The transactionExecutor is allowed to write the follower in that wrapped token.\n        if (isFollowApproved) {\n            // The `_followApprovalByFollowTokenId` was used, and now it needs to be cleared.\n            _approveFollow(0, followTokenId);\n        }\n        _replaceFollower({\n            currentFollowerProfileId: _followDataByFollowTokenId[followTokenId].followerProfileId,\n            newFollowerProfileId: followerProfileId,\n            followTokenId: followTokenId\n        });\n        return followTokenId;\n    }\n\n    function _followWithUnwrappedTokenFromBurnedProfile(\n        uint256 followerProfileId,\n        uint256 followTokenId,\n        uint256 currentFollowerProfileId\n    ) internal returns (uint256) {\n        if (IERC721Timestamped(HUB).exists(currentFollowerProfileId)) {\n            revert DoesNotHavePermissions();\n        }\n        _replaceFollower({\n            currentFollowerProfileId: currentFollowerProfileId,\n            newFollowerProfileId: followerProfileId,\n            followTokenId: followTokenId\n        });\n        return followTokenId;\n    }\n\n    function _followByRecoveringToken(uint256 followerProfileId, uint256 followTokenId) internal returns (uint256) {\n        if (_followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover != followerProfileId) {\n            revert FollowTokenDoesNotExist();\n        }\n        unchecked {\n            _followerCount++;\n        }\n        _baseFollow({followerProfileId: followerProfileId, followTokenId: followTokenId, isOriginalFollow: false});\n        return followTokenId;\n    }\n\n    function _replaceFollower(\n        uint256 currentFollowerProfileId,\n        uint256 newFollowerProfileId,\n        uint256 followTokenId\n    ) internal {\n        if (currentFollowerProfileId != 0) {\n            // As it has a follower, unfollow first, removing the current follower.\n            delete _followTokenIdByFollowerProfileId[currentFollowerProfileId];\n            ILensHub(HUB).emitUnfollowedEvent(currentFollowerProfileId, _followedProfileId);\n        } else {\n            unchecked {\n                _followerCount++;\n            }\n        }\n        // Perform the follow, setting a new follower.\n        _baseFollow({followerProfileId: newFollowerProfileId, followTokenId: followTokenId, isOriginalFollow: false});\n    }\n\n    function _baseFollow(\n        uint256 followerProfileId,\n        uint256 followTokenId,\n        bool isOriginalFollow\n    ) internal {\n        _followTokenIdByFollowerProfileId[followerProfileId] = followTokenId;\n        _followDataByFollowTokenId[followTokenId].followerProfileId = uint160(followerProfileId);\n        _followDataByFollowTokenId[followTokenId].followTimestamp = uint48(block.timestamp);\n        delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n        if (isOriginalFollow) {\n            _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = uint48(block.timestamp);\n        } else {\n            // Migration code.\n            // If the follow token was minted before the originalFollowTimestamp was introduced, it will be 0.\n            // In that case, we need to fetch the mint timestamp from the token data.\n            if (_followDataByFollowTokenId[followTokenId].originalFollowTimestamp == 0) {\n                uint48 mintTimestamp = uint48(StorageLib.getTokenData(followTokenId).mintTimestamp);\n                _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = mintTimestamp;\n            }\n        }\n    }\n\n    function _unfollowIfHasFollower(uint256 followTokenId) internal {\n        uint256 followerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (followerProfileId != 0) {\n            _unfollow(followerProfileId, followTokenId);\n            ILensHub(HUB).emitUnfollowedEvent(followerProfileId, _followedProfileId);\n        }\n    }\n\n    function _unfollow(uint256 unfollower, uint256 followTokenId) internal {\n        unchecked {\n            // This is safe, as this line can only be reached if the unfollowed profile is being followed by the\n            // unfollower profile, so _followerCount is guaranteed to be greater than zero.\n            _followerCount--;\n        }\n        delete _followTokenIdByFollowerProfileId[unfollower];\n        delete _followDataByFollowTokenId[followTokenId].followerProfileId;\n        delete _followDataByFollowTokenId[followTokenId].followTimestamp;\n        delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n    }\n\n    function _approveFollow(uint256 approvedProfileId, uint256 followTokenId) internal {\n        _followApprovalByFollowTokenId[followTokenId] = approvedProfileId;\n        emit FollowApproval(approvedProfileId, followTokenId);\n    }\n\n    /**\n     * @dev Upon transfers, we clear follow approvals and emit the transfer event in the hub.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 followTokenId\n    ) internal override {\n        if (from != address(0)) {\n            // It is cleared on unwrappings and transfers, and it can not be set on unwrapped tokens.\n            // As a consequence, there is no need to clear it on wrappings.\n            _approveFollow(0, followTokenId);\n        }\n        super._beforeTokenTransfer(from, to, followTokenId);\n    }\n\n    function _getReceiver(\n        uint256 /* followTokenId */\n    ) internal view override returns (address) {\n        return IERC721(HUB).ownerOf(_followedProfileId);\n    }\n\n    function _beforeRoyaltiesSet(\n        uint256 /* royaltiesInBasisPoints */\n    ) internal view override {\n        if (IERC721(HUB).ownerOf(_followedProfileId) != msg.sender) {\n            revert Errors.NotProfileOwner();\n        }\n    }\n\n    function _isFollowTokenWrapped(uint256 followTokenId) internal view returns (bool) {\n        return _exists(followTokenId);\n    }\n\n    function _getRoyaltiesInBasisPointsSlot() internal pure override returns (uint256) {\n        uint256 slot;\n        assembly {\n            slot := _royaltiesInBasisPoints.slot\n        }\n        return slot;\n    }\n\n    //////////////////\n    /// Migrations ///\n    //////////////////\n\n    // This function shouldn't fail under no circumstances, except if wrong parameters are passed.\n    function tryMigrate(\n        uint256 followerProfileId,\n        address followerProfileOwner,\n        uint256 idOfProfileFollowed,\n        uint256 followTokenId\n    ) external onlyHub returns (uint48) {\n        // Migrated FollowNFTs should have `originalFollowTimestamp` set\n        if (_followDataByFollowTokenId[followTokenId].originalFollowTimestamp != 0) {\n            return 0; // Already migrated\n        }\n\n        if (_followedProfileId != idOfProfileFollowed) {\n            revert Errors.InvalidParameter();\n        }\n\n        if (!_exists(followTokenId)) {\n            return 0; // Doesn't exist\n        }\n\n        address followTokenOwner = ownerOf(followTokenId);\n\n        // ProfileNFT and FollowNFT should be in the same account\n        if (followerProfileOwner != followTokenOwner) {\n            return 0; // Not holding both Profile & Follow NFTs together\n        }\n\n        unchecked {\n            ++_followerCount;\n        }\n\n        _followTokenIdByFollowerProfileId[followerProfileId] = followTokenId;\n\n        uint48 mintTimestamp = uint48(StorageLib.getTokenData(followTokenId).mintTimestamp);\n\n        _followDataByFollowTokenId[followTokenId].followerProfileId = uint160(followerProfileId);\n        _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = mintTimestamp;\n        _followDataByFollowTokenId[followTokenId].followTimestamp = mintTimestamp;\n\n        super._burn(followTokenId);\n        return mintTimestamp;\n    }\n}"
    },
    {
      "filename": "contracts/libraries/FollowLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {IFollowModule} from 'contracts/interfaces/IFollowModule.sol';\nimport {ValidationLib} from 'contracts/libraries/ValidationLib.sol';\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {Events} from 'contracts/libraries/constants/Events.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\nimport {FollowNFTProxy} from 'contracts/base/upgradeability/FollowNFTProxy.sol';\n\nlibrary FollowLib {\n    function follow(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata followModuleDatas\n    ) external returns (uint256[] memory) {\n        if (\n            idsOfProfilesToFollow.length != followTokenIds.length ||\n            idsOfProfilesToFollow.length != followModuleDatas.length\n        ) {\n            revert Errors.ArrayMismatch();\n        }\n        uint256[] memory followTokenIdsAssigned = new uint256[](idsOfProfilesToFollow.length);\n        uint256 i;\n        while (i < idsOfProfilesToFollow.length) {\n            ValidationLib.validateProfileExists({profileId: idsOfProfilesToFollow[i]});\n\n            ValidationLib.validateNotBlocked({profile: followerProfileId, byProfile: idsOfProfilesToFollow[i]});\n\n            if (followerProfileId == idsOfProfilesToFollow[i]) {\n                revert Errors.SelfFollow();\n            }\n\n            followTokenIdsAssigned[i] = _follow({\n                followerProfileId: followerProfileId,\n                transactionExecutor: transactionExecutor,\n                idOfProfileToFollow: idsOfProfilesToFollow[i],\n                followTokenId: followTokenIds[i],\n                followModuleData: followModuleDatas[i]\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n        return followTokenIdsAssigned;\n    }\n\n    function unfollow(\n        uint256 unfollowerProfileId,\n        address transactionExecutor,\n        uint256[] calldata idsOfProfilesToUnfollow\n    ) external {\n        uint256 i;\n        while (i < idsOfProfilesToUnfollow.length) {\n            uint256 idOfProfileToUnfollow = idsOfProfilesToUnfollow[i];\n            ValidationLib.validateProfileExists(idOfProfileToUnfollow);\n\n            address followNFT = StorageLib.getProfile(idOfProfileToUnfollow).followNFT;\n\n            if (followNFT == address(0)) {\n                revert Errors.NotFollowing();\n            }\n\n            IFollowNFT(followNFT).unfollow({\n                unfollowerProfileId: unfollowerProfileId,\n                transactionExecutor: transactionExecutor\n            });\n\n            emit Events.Unfollowed(unfollowerProfileId, idOfProfileToUnfollow, block.timestamp);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Deploys the given profile's Follow NFT contract.\n     *\n     * @param profileId The token ID of the profile which Follow NFT should be deployed.\n     *\n     * @return address The address of the deployed Follow NFT contract.\n     */\n    function _deployFollowNFT(uint256 profileId) private returns (address) {\n        bytes memory functionData = abi.encodeWithSelector(IFollowNFT.initialize.selector, profileId);\n        address followNFT = address(new FollowNFTProxy(functionData));\n        emit Events.FollowNFTDeployed(profileId, followNFT, block.timestamp);\n\n        return followNFT;\n    }\n\n    function _follow(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 idOfProfileToFollow,\n        uint256 followTokenId,\n        bytes calldata followModuleData\n    ) private returns (uint256) {\n        Types.Profile storage _profileToFollow = StorageLib.getProfile(idOfProfileToFollow);\n\n        address followNFT = _profileToFollow.followNFT;\n        if (followNFT == address(0)) {\n            followNFT = _deployFollowNFT(idOfProfileToFollow);\n            _profileToFollow.followNFT = followNFT;\n        }\n\n        uint256 followTokenIdAssigned = IFollowNFT(followNFT).follow({\n            followerProfileId: followerProfileId,\n            transactionExecutor: transactionExecutor,\n            followTokenId: followTokenId\n        });\n\n        bytes memory processFollowModuleReturnData;\n        address followModule = _profileToFollow.followModule;\n        if (followModule != address(0)) {\n            processFollowModuleReturnData = IFollowModule(followModule).processFollow(\n                followerProfileId,\n                followTokenId,\n                transactionExecutor,\n                idOfProfileToFollow,\n                followModuleData\n            );\n        }\n\n        emit Events.Followed(\n            followerProfileId,\n            idOfProfileToFollow,\n            followTokenIdAssigned,\n            followModuleData,\n            processFollowModuleReturnData,\n            block.timestamp\n        );\n\n        return followTokenIdAssigned;\n    }\n}"
    }
  ]
}