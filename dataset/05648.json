{
  "Title": "[L-01] `assert()` does not provide any information when thrown.",
  "Content": "\n*This finding escalates **[N-09]** of the automated report.*\n\nhttps://github.com/code-423n4/2023-10-ens/blob/main/contracts/ERC20MultiDelegate.sol#L131\n\nThe following assertion will throw when the user attempts to re-delegate more than the existing amount. Using `assert` here has the following two issues:\n1. `assert` does not provide any error message when thrown, while it should have been reported told as an `Insufficient balance` error message or similar.\n2. Even if the condition passes, the tx is guaranteed to fail at the `_burnBatch` call anyway, as the owner would not have enough ERC1155 to burn.\n\nWe suggest changing `assert` to a `require` statement, with a clear error message, or using custom errors.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-ens",
  "Code": [
    {
      "filename": "contracts/ERC20MultiDelegate.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @dev A child contract which will be deployed by the ERC20MultiDelegate utility contract\n * This is a proxy delegator contract to vote given delegate on behalf of original delegator\n */\ncontract ERC20ProxyDelegator {\n    constructor(ERC20Votes _token, address _delegate) {\n        _token.approve(msg.sender, type(uint256).max);\n        _token.delegate(_delegate);\n    }\n}\n\n/**\n * @dev A utility contract to let delegators to pick multiple delegate\n */\ncontract ERC20MultiDelegate is ERC1155, Ownable {\n    using Address for address;\n\n    ERC20Votes public token;\n\n    /** ### EVENTS ### */\n\n    event ProxyDeployed(address indexed delegate, address proxyAddress);\n    event DelegationProcessed(\n        address indexed from,\n        address indexed to,\n        uint256 amount\n    );\n\n    /**\n     * @dev Constructor.\n     * @param _token The ERC20 token address\n     * @param _metadata_uri ERC1155 metadata uri\n     */\n    constructor(\n        ERC20Votes _token,\n        string memory _metadata_uri\n    ) ERC1155(_metadata_uri) {\n        token = _token;\n    }\n\n    /**\n     * @dev Executes the delegation transfer process for multiple source and target delegates.\n     * @param sources The list of source delegates.\n     * @param targets The list of target delegates.\n     * @param amounts The list of amounts to deposit/withdraw.\n     */\n    function delegateMulti(\n        uint256[] calldata sources,\n        uint256[] calldata targets,\n        uint256[] calldata amounts\n    ) external {\n        _delegateMulti(sources, targets, amounts);\n    }\n\n    function _delegateMulti(\n        uint256[] calldata sources,\n        uint256[] calldata targets,\n        uint256[] calldata amounts\n    ) internal {\n        uint256 sourcesLength = sources.length;\n        uint256 targetsLength = targets.length;\n        uint256 amountsLength = amounts.length;\n\n        require(\n            sourcesLength > 0 || targetsLength > 0,\n            \"Delegate: You should provide at least one source or one target delegate\"\n        );\n\n        require(\n            Math.max(sourcesLength, targetsLength) == amountsLength,\n            \"Delegate: The number of amounts must be equal to the greater of the number of sources or targets\"\n        );\n\n        // Iterate until all source and target delegates have been processed.\n        for (\n            uint transferIndex = 0;\n            transferIndex < Math.max(sourcesLength, targetsLength);\n            transferIndex++\n        ) {\n            address source = transferIndex < sourcesLength\n                ? address(uint160(sources[transferIndex]))\n                : address(0);\n            address target = transferIndex < targetsLength\n                ? address(uint160(targets[transferIndex]))\n                : address(0);\n            uint256 amount = amounts[transferIndex];\n\n            if (transferIndex < Math.min(sourcesLength, targetsLength)) {\n                // Process the delegation transfer between the current source and target delegate pair.\n                _processDelegation(source, target, amount);\n            } else if (transferIndex < sourcesLength) {\n                // Handle any remaining source amounts after the transfer process.\n                _reimburse(source, amount);\n            } else if (transferIndex < targetsLength) {\n                // Handle any remaining target amounts after the transfer process.\n                createProxyDelegatorAndTransfer(target, amount);\n            }\n        }\n\n        if (sourcesLength > 0) {\n            _burnBatch(msg.sender, sources, amounts[:sourcesLength]);\n        }\n        if (targetsLength > 0) {\n            _mintBatch(msg.sender, targets, amounts[:targetsLength], \"\");\n        }\n    }\n\n    /**\n     * @dev Processes the delegation transfer between a source delegate and a target delegate.\n     * @param source The source delegate from which tokens are being withdrawn.\n     * @param target The target delegate to which tokens are being transferred.\n     * @param amount The amount of tokens transferred between the source and target delegates.\n     */\n    function _processDelegation(\n        address source,\n        address target,\n        uint256 amount\n    ) internal {\n        uint256 balance = getBalanceForDelegate(source);\n\n        assert(amount <= balance);\n\n        deployProxyDelegatorIfNeeded(target);\n        transferBetweenDelegators(source, target, amount);\n\n        emit DelegationProcessed(source, target, amount);\n    }\n\n    /**\n     * @dev Reimburses any remaining source amounts back to the delegator after the delegation transfer process.\n     * @param source The source delegate from which tokens are being withdrawn.\n     * @param amount The amount of tokens to be withdrawn from the source delegate.\n     */\n    function _reimburse(address source, uint256 amount) internal {\n        // Transfer the remaining source amount or the full source amount\n        // (if no remaining amount) to the delegator\n        address proxyAddressFrom = retrieveProxyContractAddress(token, source);\n        token.transferFrom(proxyAddressFrom, msg.sender, amount);\n    }\n\n    function setUri(string memory uri) external onlyOwner {\n        _setURI(uri);\n    }\n\n    function createProxyDelegatorAndTransfer(\n        address target,\n        uint256 amount\n    ) internal {\n        address proxyAddress = deployProxyDelegatorIfNeeded(target);\n        token.transferFrom(msg.sender, proxyAddress, amount);\n    }\n\n    function transferBetweenDelegators(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        address proxyAddressFrom = retrieveProxyContractAddress(token, from);\n        address proxyAddressTo = retrieveProxyContractAddress(token, to);\n        token.transferFrom(proxyAddressFrom, proxyAddressTo, amount);\n    }\n\n    function deployProxyDelegatorIfNeeded(\n        address delegate\n    ) internal returns (address) {\n        address proxyAddress = retrieveProxyContractAddress(token, delegate);\n\n        // check if the proxy contract has already been deployed\n        uint bytecodeSize;\n        assembly {\n            bytecodeSize := extcodesize(proxyAddress)\n        }\n\n        // if the proxy contract has not been deployed, deploy it\n        if (bytecodeSize == 0) {\n            new ERC20ProxyDelegator{salt: 0}(token, delegate);\n            emit ProxyDeployed(delegate, proxyAddress);\n        }\n        return proxyAddress;\n    }\n\n    function getBalanceForDelegate(\n        address delegate\n    ) internal view returns (uint256) {\n        return ERC1155(this).balanceOf(msg.sender, uint256(uint160(delegate)));\n    }\n\n    function retrieveProxyContractAddress(\n        ERC20Votes _token,\n        address _delegate\n    ) private view returns (address) {\n        bytes memory bytecode = abi.encodePacked(\n            type(ERC20ProxyDelegator).creationCode, \n            abi.encode(_token, _delegate)\n        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                uint256(0), // salt\n                keccak256(bytecode)\n            )\n        );\n        return address(uint160(uint256(hash)));\n    }\n}"
    }
  ]
}