{
  "Title": "The risk of storage overflow in volatility oracle",
  "Content": "##### Description\nThe volatility oracle's storage is constrained by a `UINT16_MODULO` capacity, allowing for approximately 45 values to be recorded per minute over a 24-hour period.\n\nhttps://github.com/cryptoalgebra/Algebra/blob/6f57b3e218630106a4d41aedefd38f9e83b41e2b/src/plugins/contracts/libraries/VolatilityOracle.sol#L14-L15\n\nWhile this capacity is sufficient for the Ethereum mainnet, which generates about 5 blocks per minute, it may be insufficient for other EVM-compatible networks with more frequent block generation. An attacker could exploit this limitation to cause the loss of some volatility data by triggering an excessive number of volatility records.\n\nThis issue has been rated as LOW severity due to its limited impact and the complexity involved in reproducing the exploit.\n##### Recommendation\nTo address this issue, it is recommended to adjust the frequency of volatility storage updates in accordance with both the storage capacity and the desired time window for data retention.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/plugins/contracts/libraries/VolatilityOracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n/// @title VolatilityOracle\n/// @notice Provides price and volatility data useful for a wide variety of system designs\n/// @dev Instances of stored oracle data, \"timepoints\", are collected in the oracle array\n/// Timepoints are overwritten when the full length of the timepoints array is populated.\n/// The most recent timepoint is available by passing 0 to getSingleTimepoint().\n/// Version for AlgebraBasePluginV1\nlibrary VolatilityOracle {\n  /// @notice `target` timestamp is older than oldest timepoint\n  error targetIsTooOld();\n\n  uint32 internal constant WINDOW = 1 days;\n  uint256 private constant UINT16_MODULO = 65536;\n\n  struct Timepoint {\n    bool initialized; // whether or not the timepoint is initialized\n    uint32 blockTimestamp; // the block timestamp of the timepoint\n    int56 tickCumulative; // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\n    uint88 volatilityCumulative; // the volatility accumulator; overflow after ~34800 years is desired :)\n    int24 tick; // tick at this blockTimestamp\n    int24 averageTick; // average tick at this blockTimestamp (for WINDOW seconds)\n    uint16 windowStartIndex; // index of closest timepoint >= WINDOW seconds ago (or oldest timepoint), used to speed up searches\n  }\n\n  /// @notice Initialize the timepoints array by writing the first slot. Called once for the lifecycle of the timepoints array\n  /// @param self The stored timepoints array\n  /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32\n  /// @param tick Initial tick\n  function initialize(Timepoint[UINT16_MODULO] storage self, uint32 time, int24 tick) internal {\n    Timepoint storage _zero = self[0];\n    require(!_zero.initialized, 'oracle already initialized');\n    (_zero.initialized, _zero.blockTimestamp, _zero.tick, _zero.averageTick) = (true, time, tick, tick);\n  }\n\n  /// @notice Writes a timepoint to the array\n  /// @dev Writable at most once per block. `lastIndex` must be tracked externally.\n  /// @param self The stored timepoints array\n  /// @param lastIndex The index of the timepoint that was most recently written to the timepoints array\n  /// @param blockTimestamp The timestamp of the new timepoint\n  /// @param tick The active tick at the time of the new timepoint\n  /// @return indexUpdated The new index of the most recently written element in the timepoints array\n  /// @return oldestIndex The new index of the oldest timepoint\n  function write(\n    Timepoint[UINT16_MODULO] storage self,\n    uint16 lastIndex,\n    uint32 blockTimestamp,\n    int24 tick\n  ) internal returns (uint16 indexUpdated, uint16 oldestIndex) {\n    Timepoint memory last = self[lastIndex];\n    // early return if we've already written a timepoint this block\n    if (last.blockTimestamp == blockTimestamp) return (lastIndex, 0);\n\n    // get next index considering overflow\n    unchecked {\n      indexUpdated = lastIndex + 1;\n    }\n\n    // check if we have overflow in the past\n    if (self[indexUpdated].initialized) oldestIndex = indexUpdated;\n\n    (int24 avgTick, uint16 windowStartIndex) = _getAverageTickCasted(\n      self,\n      blockTimestamp,\n      tick,\n      lastIndex,\n      oldestIndex,\n      last.blockTimestamp,\n      last.tickCumulative\n    );\n    if (windowStartIndex == indexUpdated) windowStartIndex++;\n    self[indexUpdated] = _createNewTimepoint(last, blockTimestamp, tick, avgTick, windowStartIndex);\n    if (oldestIndex == indexUpdated) oldestIndex++; // previous oldest index has been overwritten\n  }\n\n  /// @dev Reverts if a timepoint at or before the desired timepoint timestamp does not exist.\n  /// 0 may be passed as `secondsAgo' to return the current cumulative values.\n  /// If called with a timestamp falling between two timepoints, returns the counterfactual accumulator values\n  /// at exactly the timestamp between the two timepoints.\n  /// @param self The stored timepoints array\n  /// @param time The current block timestamp\n  /// @param secondsAgo The amount of time to look back, in seconds, at which point to return a timepoint\n  /// @param tick The current tick\n  /// @param lastIndex The index of the timepoint that was most recently written to the timepoints array\n  /// @param oldestIndex The index of the oldest timepoint\n  /// @return targetTimepoint desired timepoint or it's interpolation\n  function getSingleTimepoint(\n    Timepoint[UINT16_MODULO] storage self,\n    uint32 time,\n    uint32 secondsAgo,\n    int24 tick,\n    uint16 lastIndex,\n    uint16 oldestIndex\n  ) internal view returns (Timepoint memory targetTimepoint) {\n    unchecked {\n      uint32 target = time - secondsAgo;\n      (Timepoint storage beforeOrAt, Timepoint storage atOrAfter, bool samePoint, ) = _getTimepointsAt(self, time, target, lastIndex, oldestIndex);\n\n      targetTimepoint = beforeOrAt;\n      if (target == targetTimepoint.blockTimestamp) return targetTimepoint; // we're at the left boundary\n      if (samePoint) {\n        // if target is newer than last timepoint\n        (int24 avgTick, uint16 windowStartIndex) = _getAverageTickCasted(\n          self,\n          time,\n          tick,\n          lastIndex,\n          oldestIndex,\n          targetTimepoint.blockTimestamp,\n          targetTimepoint.tickCumulative\n        );\n        return _createNewTimepoint(targetTimepoint, time - secondsAgo, tick, avgTick, windowStartIndex);\n      }\n\n      (uint32 timestampAfter, int56 tickCumulativeAfter) = (atOrAfter.blockTimestamp, atOrAfter.tickCumulative);\n      if (target == timestampAfter) return atOrAfter; // we're at the right boundary\n\n      // we're in the middle\n      (uint32 timepointTimeDelta, uint32 targetDelta) = (timestampAfter - targetTimepoint.blockTimestamp, target - targetTimepoint.blockTimestamp);\n\n      targetTimepoint.tickCumulative +=\n        ((tickCumulativeAfter - targetTimepoint.tickCumulative) / int56(uint56(timepointTimeDelta))) *\n        int56(uint56(targetDelta));\n      targetTimepoint.volatilityCumulative +=\n        ((atOrAfter.volatilityCumulative - targetTimepoint.volatilityCumulative) / timepointTimeDelta) *\n        targetDelta;\n    }\n  }\n\n  /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\n  /// @dev Reverts if `secondsAgos` > oldest timepoint\n  /// @param self The stored timepoints array\n  /// @param currentTime The current block.timestamp\n  /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return a timepoint\n  /// @param tick The current tick\n  /// @param lastIndex The index of the timepoint that was most recently written to the timepoints array\n  /// @return tickCumulatives The cumulative time-weighted tick since the pool was first initialized, as of each `secondsAgo`\n  /// @return volatilityCumulatives The cumulative volatility values since the pool was first initialized, as of each `secondsAgo`\n  function getTimepoints(\n    Timepoint[UINT16_MODULO] storage self,\n    uint32 currentTime,\n    uint32[] memory secondsAgos,\n    int24 tick,\n    uint16 lastIndex\n  ) internal view returns (int56[] memory tickCumulatives, uint112[] memory volatilityCumulatives) {\n    uint256 secondsLength = secondsAgos.length;\n    tickCumulatives = new int56[](secondsLength);\n    volatilityCumulatives = new uint112[](secondsLength);\n\n    uint16 oldestIndex = getOldestIndex(self, lastIndex);\n    Timepoint memory current;\n    unchecked {\n      for (uint256 i; i < secondsLength; ++i) {\n        current = getSingleTimepoint(self, currentTime, secondsAgos[i], tick, lastIndex, oldestIndex);\n        (tickCumulatives[i], volatilityCumulatives[i]) = (current.tickCumulative, current.volatilityCumulative);\n      }\n    }\n  }\n\n  /// @notice Returns the index of the oldest timepoint\n  /// @param self The stored timepoints array\n  /// @param lastIndex The index of the timepoint that was most recently written to the timepoints array\n  /// @return oldestIndex The index of the oldest timepoint\n  function getOldestIndex(Timepoint[UINT16_MODULO] storage self, uint16 lastIndex) internal view returns (uint16 oldestIndex) {\n    unchecked {\n      uint16 nextIndex = lastIndex + 1; // considering overflow\n      if (self[nextIndex].initialized) oldestIndex = nextIndex; // check if we have overflow in the past\n    }\n  }\n\n  /// @notice Returns average volatility in the range from currentTime-WINDOW to currentTime\n  /// @param self The stored timepoints array\n  /// @param currentTime The current block.timestamp\n  /// @param tick The current tick\n  /// @param lastIndex The index of the timepoint that was most recently written to the timepoints array\n  /// @param oldestIndex The index of the oldest timepoint\n  /// @return volatilityAverage The average volatility in the recent range\n  function getAverageVolatility(\n    Timepoint[UINT16_MODULO] storage self,\n    uint32 currentTime,\n    int24 tick,\n    uint16 lastIndex,\n    uint16 oldestIndex\n  ) internal view returns (uint88 volatilityAverage) {\n    unchecked {\n      Timepoint storage lastTimepoint = self[lastIndex];\n      bool timeAtLastTimepoint = lastTimepoint.blockTimestamp == currentTime;\n      uint88 lastCumulativeVolatility = lastTimepoint.volatilityCumulative;\n      uint16 windowStartIndex = lastTimepoint.windowStartIndex; // index of timepoint before of at lastTimepoint.blockTimestamp - WINDOW\n\n      if (!timeAtLastTimepoint) {\n        lastCumulativeVolatility = _getVolatilityCumulativeAt(self, currentTime, 0, tick, lastIndex, oldestIndex);\n      }\n\n      uint32 oldestTimestamp = self[oldestIndex].blockTimestamp;\n      if (_lteConsideringOverflow(oldestTimestamp, currentTime - WINDOW, currentTime)) {\n        // oldest timepoint is earlier than 24 hours ago\n        uint88 cumulativeVolatilityAtStart;\n        if (timeAtLastTimepoint) {\n          // interpolate cumulative volatility to avoid search. Since the last timepoint has _just_ been written, we know for sure\n          // that the start of the window is between windowStartIndex and windowStartIndex + 1\n          (oldestTimestamp, cumulativeVolatilityAtStart) = (self[windowStartIndex].blockTimestamp, self[windowStartIndex].volatilityCumulative);\n\n          uint32 timeDeltaBetweenPoints = self[windowStartIndex + 1].blockTimestamp - oldestTimestamp;\n\n          cumulativeVolatilityAtStart +=\n            ((self[windowStartIndex + 1].volatilityCumulative - cumulativeVolatilityAtStart) * (currentTime - WINDOW - oldestTimestamp)) /\n            timeDeltaBetweenPoints;\n        } else {\n          cumulativeVolatilityAtStart = _getVolatilityCumulativeAt(self, currentTime, WINDOW, tick, lastIndex, oldestIndex);\n        }\n\n        return ((lastCumulativeVolatility - cumulativeVolatilityAtStart) / WINDOW); // sample is big enough to ignore bias of variance\n      } else if (currentTime != oldestTimestamp) {\n        // recorded timepoints are not enough, so we will extrapolate\n        uint88 _oldestVolatilityCumulative = self[oldestIndex].volatilityCumulative;\n        uint32 unbiasedDenominator = currentTime - oldestTimestamp;\n        if (unbiasedDenominator > 1) unbiasedDenominator--; // Bessel's correction for \"small\" sample\n        return ((lastCumulativeVolatility - _oldestVolatilityCumulative) / unbiasedDenominator);\n      }\n    }\n  }\n\n  // ##### further functions are private to the library, but some are made internal for fuzzy testing #####\n\n  /// @notice Transforms a previous timepoint into a new timepoint, given the passage of time and the current tick and liquidity values\n  /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\n  /// @dev The function changes the structure given to the input, and does not create a new one\n  /// @param last The specified timepoint to be used in creation of new timepoint\n  /// @param blockTimestamp The timestamp of the new timepoint\n  /// @param tick The active tick at the time of the new timepoint\n  /// @param averageTick The average tick at the time of the new timepoint\n  /// @param windowStartIndex The index of closest timepoint >= WINDOW seconds ago\n  /// @return Timepoint The newly populated timepoint\n  function _createNewTimepoint(\n    Timepoint memory last,\n    uint32 blockTimestamp,\n    int24 tick,\n    int24 averageTick,\n    uint16 windowStartIndex\n  ) internal pure returns (Timepoint memory) {\n    unchecked {\n      uint32 delta = blockTimestamp - last.blockTimestamp; // overflow is desired\n      // We don't create a new structure in memory to save gas. Therefore, the function changes the old structure\n      last.initialized = true;\n      last.blockTimestamp = blockTimestamp;\n      last.tickCumulative += int56(tick) * int56(uint56(delta));\n      last.volatilityCumulative += uint88(_volatilityOnRange(int256(uint256(delta)), last.tick, tick, last.averageTick, averageTick)); // always fits 88 bits\n      last.tick = tick;\n      last.averageTick = averageTick;\n      last.windowStartIndex = windowStartIndex;\n      return last;\n    }\n  }\n\n  /// @notice Calculates volatility between two sequential timepoints with resampling to 1 sec frequency\n  /// @param dt Timedelta between timepoints, must be within uint32 range\n  /// @param tick0 The tick at the left timepoint, must be within int24 range\n  /// @param tick1 The tick at the right timepoint, must be within int24 range\n  /// @param avgTick0 The average tick at the left timepoint, must be within int24 range\n  /// @param avgTick1 The average tick at the right timepoint, must be within int24 range\n  /// @return volatility The volatility between two sequential timepoints\n  /// If the requirements for the parameters are met, it always fits 88 bits\n  function _volatilityOnRange(int256 dt, int256 tick0, int256 tick1, int256 avgTick0, int256 avgTick1) internal pure returns (uint256 volatility) {\n    // On the time interval from the previous timepoint to the current\n    // we can represent tick and average tick change as two straight lines:\n    // tick = k*t + b, where k and b are some constants\n    // avgTick = p*t + q, where p and q are some constants\n    // we want to get sum of (tick(t) - avgTick(t))^2 for every t in the interval (0; dt]\n    // so: (tick(t) - avgTick(t))^2 = ((k*t + b) - (p*t + q))^2 = (k-p)^2 * t^2 + 2(k-p)(b-q)t + (b-q)^2\n    // since everything except t is a constant, we need to use progressions for t and t^2:\n    // sum(t) for t from 1 to dt = dt*(dt + 1)/2 = sumOfSequence\n    // sum(t^2) for t from 1 to dt = dt*(dt+1)*(2dt + 1)/6 = sumOfSquares\n    // so result will be: (k-p)^2 * sumOfSquares + 2(k-p)(b-q)*sumOfSequence + dt*(b-q)^2\n    unchecked {\n      int256 k = (tick1 - tick0) - (avgTick1 - avgTick0); // (k - p)*dt\n      int256 b = (tick0 - avgTick0) * dt; // (b - q)*dt\n      int256 sumOfSequence = dt * (dt + 1); // sumOfSequence * 2\n      int256 sumOfSquares = sumOfSequence * (2 * dt + 1); // sumOfSquares * 6\n      volatility = uint256((k ** 2 * sumOfSquares + 6 * b * k * sumOfSequence + 6 * dt * b ** 2) / (6 * dt ** 2));\n    }\n  }\n\n  /// @notice Calculates average tick for WINDOW seconds at the moment of `time`\n  /// @dev Guaranteed that the result is within the bounds of int24\n  /// @return avgTick The average tick\n  /// @return windowStartIndex The index of closest timepoint <= WINDOW seconds ago\n  function _getAverageTickCasted(\n    Timepoint[UINT16_MODULO] storage self,\n    uint32 time,\n    int24 tick,\n    uint16 lastIndex,\n    uint16 oldestIndex,\n    uint32 lastTimestamp,\n    int56 lastTickCumulative\n  ) internal view returns (int24 avgTick, uint16 windowStartIndex) {\n    (int256 _avgTick, uint256 _windowStartIndex) = _getAverageTick(self, time, tick, lastIndex, oldestIndex, lastTimestamp, lastTickCumulative);\n    unchecked {\n      (avgTick, windowStartIndex) = (int24(_avgTick), uint16(_windowStartIndex)); // overflow in uint16(_windowStartIndex) is desired\n    }\n  }\n\n  /// @notice Calculates average tick for WINDOW seconds at the moment of `time`\n  /// @dev Guaranteed that the result is within the bounds of int24, but result is not casted\n  /// @return avgTick int256 for fuzzy tests\n  /// @return windowStartIndex The index of closest timepoint <= WINDOW seconds ago\n  function _getAverageTick(\n    Timepoint[UINT16_MODULO] storage self,\n    uint32 currentTime,\n    int24 tick,\n    uint16 lastIndex,\n    uint16 oldestIndex,\n    uint32 lastTimestamp,\n    int56 lastTickCumulative\n  ) internal view returns (int256 avgTick, uint256 windowStartIndex) {\n    (uint32 oldestTimestamp, int56 oldestTickCumulative) = (self[oldestIndex].blockTimestamp, self[oldestIndex].tickCumulative);\n    unchecked {\n      if (!_lteConsideringOverflow(oldestTimestamp, currentTime - WINDOW, currentTime)) {\n        // if oldest is newer than WINDOW ago\n        return (\n          (lastTimestamp == oldestTimestamp) ? tick : (lastTickCumulative - oldestTickCumulative) / int56(uint56(lastTimestamp - oldestTimestamp)),\n          oldestIndex\n        );\n      }\n\n      if (_lteConsideringOverflow(lastTimestamp, currentTime - WINDOW, currentTime)) {\n        // if last timepoint is older than WINDOW ago\n        Timepoint storage _start = self[lastIndex - 1]; // considering underflow\n        (bool initialized, uint32 startTimestamp, int56 startTickCumulative) = (_start.initialized, _start.blockTimestamp, _start.tickCumulative);\n        avgTick = initialized ? (lastTickCumulative - startTickCumulative) / int56(uint56(lastTimestamp - startTimestamp)) : tick;\n        windowStartIndex = lastIndex;\n      } else {\n        oldestIndex = self[lastIndex].windowStartIndex;\n        if (currentTime == lastTimestamp) {\n          lastIndex = oldestIndex + 1;\n        }\n        int56 tickCumulativeAtStart;\n        (tickCumulativeAtStart, windowStartIndex) = _getTickCumulativeAt(self, currentTime, WINDOW, tick, lastIndex, oldestIndex);\n\n        //    current-WINDOW  last   current\n        // _________*____________*_______*_\n        //           ||||||||||||\n        avgTick = (lastTickCumulative - tickCumulativeAtStart) / int56(uint56(lastTimestamp - currentTime + WINDOW));\n      }\n    }\n  }\n\n  /// @notice comparator for 32-bit timestamps\n  /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to currentTime\n  /// @param a A comparison timestamp from which to determine the relative position of `currentTime`\n  /// @param b From which to determine the relative position of `currentTime`\n  /// @param currentTime A timestamp truncated to 32 bits\n  /// @return res Whether `a` is chronologically <= `b`\n  function _lteConsideringOverflow(uint32 a, uint32 b, uint32 currentTime) private pure returns (bool res) {\n    res = a > currentTime;\n    if (res == b > currentTime) res = a <= b; // if both are on the same side\n  }\n\n  /// @notice Calculates cumulative volatility at the moment of `time` - `secondsAgo`\n  /// @dev More optimal than via `getSingleTimepoint`\n  /// @return volatilityCumulative The cumulative volatility\n  function _getVolatilityCumulativeAt(\n    Timepoint[UINT16_MODULO] storage self,\n    uint32 time,\n    uint32 secondsAgo,\n    int24 tick,\n    uint16 lastIndex,\n    uint16 oldestIndex\n  ) internal view returns (uint88 volatilityCumulative) {\n    unchecked {\n      uint32 target = time - secondsAgo;\n      (Timepoint storage beforeOrAt, Timepoint storage atOrAfter, bool samePoint, ) = _getTimepointsAt(self, time, target, lastIndex, oldestIndex);\n\n      (uint32 timestampBefore, uint88 volatilityCumulativeBefore) = (beforeOrAt.blockTimestamp, beforeOrAt.volatilityCumulative);\n      if (target == timestampBefore) return volatilityCumulativeBefore; // we're at the left boundary\n      if (samePoint) {\n        // since target != beforeOrAt.blockTimestamp, `samePoint` means that target is newer than last timepoint\n        (int24 avgTick, ) = _getAverageTickCasted(self, time, tick, lastIndex, oldestIndex, timestampBefore, beforeOrAt.tickCumulative);\n\n        return (volatilityCumulativeBefore +\n          uint88(_volatilityOnRange(int256(uint256(target - timestampBefore)), beforeOrAt.tick, tick, beforeOrAt.averageTick, avgTick)));\n      }\n\n      (uint32 timestampAfter, uint88 volatilityCumulativeAfter) = (atOrAfter.blockTimestamp, atOrAfter.volatilityCumulative);\n      if (target == timestampAfter) return volatilityCumulativeAfter; // we're at the right boundary\n\n      // we're in the middle\n      (uint32 timepointTimeDelta, uint32 targetDelta) = (timestampAfter - timestampBefore, target - timestampBefore);\n      return volatilityCumulativeBefore + ((volatilityCumulativeAfter - volatilityCumulativeBefore) / timepointTimeDelta) * targetDelta;\n    }\n  }\n\n  /// @notice Calculates cumulative tick at the moment of `time` - `secondsAgo`\n  /// @dev More optimal than via `getSingleTimepoint`\n  /// @return tickCumulative The cumulative tick\n  /// @return indexBeforeOrAt The index of closest timepoint before or at the moment of `time` - `secondsAgo`\n  function _getTickCumulativeAt(\n    Timepoint[UINT16_MODULO] storage self,\n    uint32 time,\n    uint32 secondsAgo,\n    int24 tick,\n    uint16 lastIndex,\n    uint16 oldestIndex\n  ) internal view returns (int56 tickCumulative, uint256 indexBeforeOrAt) {\n    unchecked {\n      uint32 target = time - secondsAgo;\n      (Timepoint storage beforeOrAt, Timepoint storage atOrAfter, bool samePoint, uint256 _indexBeforeOrAt) = _getTimepointsAt(\n        self,\n        time,\n        target,\n        lastIndex,\n        oldestIndex\n      );\n\n      (uint32 timestampBefore, int56 tickCumulativeBefore) = (beforeOrAt.blockTimestamp, beforeOrAt.tickCumulative);\n      if (target == timestampBefore) return (tickCumulativeBefore, _indexBeforeOrAt); // we're at the left boundary\n      // since target != timestampBefore, `samePoint` means that target is newer than last timepoint\n      if (samePoint) return ((tickCumulativeBefore + int56(tick) * int56(uint56(target - timestampBefore))), _indexBeforeOrAt); // if target is newer than last timepoint\n\n      (uint32 timestampAfter, int56 tickCumulativeAfter) = (atOrAfter.blockTimestamp, atOrAfter.tickCumulative);\n      if (target == timestampAfter) return (tickCumulativeAfter, _indexBeforeOrAt); // we're at the right boundary\n\n      // we're in the middle\n      (uint32 timepointTimeDelta, uint32 targetDelta) = (timestampAfter - timestampBefore, target - timestampBefore);\n      return (\n        tickCumulativeBefore + ((tickCumulativeAfter - tickCumulativeBefore) / int56(uint56(timepointTimeDelta))) * int56(uint56(targetDelta)),\n        _indexBeforeOrAt\n      );\n    }\n  }\n\n  /// @notice Returns closest timepoint or timepoints to the moment of `target`\n  /// @return beforeOrAt The timepoint recorded before, or at, the target\n  /// @return atOrAfter The timepoint recorded at, or after, the target\n  /// @return samePoint Are `beforeOrAt` and `atOrAfter` the same or not\n  /// @return indexBeforeOrAt The index of closest timepoint before or at the moment of `target`\n  function _getTimepointsAt(\n    Timepoint[UINT16_MODULO] storage self,\n    uint32 currentTime,\n    uint32 target,\n    uint16 lastIndex,\n    uint16 oldestIndex\n  ) private view returns (Timepoint storage beforeOrAt, Timepoint storage atOrAfter, bool samePoint, uint256 indexBeforeOrAt) {\n    Timepoint storage lastTimepoint = self[lastIndex];\n    uint32 lastTimepointTimestamp = lastTimepoint.blockTimestamp;\n    uint16 windowStartIndex = lastTimepoint.windowStartIndex;\n\n    // if target is newer than last timepoint\n    if (target == currentTime || _lteConsideringOverflow(lastTimepointTimestamp, target, currentTime)) {\n      return (lastTimepoint, lastTimepoint, true, lastIndex);\n    }\n\n    uint32 oldestTimestamp = self[oldestIndex].blockTimestamp;\n    if (!_lteConsideringOverflow(oldestTimestamp, target, currentTime)) revert targetIsTooOld();\n\n    if (oldestTimestamp == target) return (self[oldestIndex], self[oldestIndex], true, oldestIndex);\n\n    unchecked {\n      if (lastTimepointTimestamp - target <= WINDOW) {\n        // we can limit the scope of the search\n        if (windowStartIndex != oldestIndex) {\n          (oldestIndex, oldestTimestamp) = (windowStartIndex, self[windowStartIndex].blockTimestamp);\n          if (oldestTimestamp == target) return (self[oldestIndex], self[oldestIndex], true, oldestIndex);\n        }\n      }\n      // no need to search if we already know the answer\n      if (lastIndex == oldestIndex + 1) return (self[oldestIndex], lastTimepoint, false, oldestIndex);\n    }\n\n    (beforeOrAt, atOrAfter, indexBeforeOrAt) = _binarySearch(self, currentTime, target, lastIndex, oldestIndex);\n    return (beforeOrAt, atOrAfter, false, indexBeforeOrAt);\n  }\n\n  /// @notice Fetches the timepoints beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.\n  /// The result may be the same timepoint, or adjacent timepoints.\n  /// @dev The answer must be older than the most recent timepoint and younger, or the same age as, the oldest timepoint\n  /// @param self The stored timepoints array\n  /// @param currentTime The current block.timestamp\n  /// @param target The timestamp at which the timepoint should be\n  /// @param lastIndex The index of the timepoint that was most recently written to the timepoints array\n  /// @param oldestIndex The index of the oldest timepoint in the timepoints array\n  /// @return beforeOrAt The timepoint recorded before, or at, the target\n  /// @return atOrAfter The timepoint recorded at, or after, the target\n  function _binarySearch(\n    Timepoint[UINT16_MODULO] storage self,\n    uint32 currentTime,\n    uint32 target,\n    uint16 lastIndex,\n    uint16 oldestIndex\n  ) private view returns (Timepoint storage beforeOrAt, Timepoint storage atOrAfter, uint256 indexBeforeOrAt) {\n    unchecked {\n      uint256 left = oldestIndex; // oldest timepoint\n      uint256 right = lastIndex < oldestIndex ? lastIndex + UINT16_MODULO : lastIndex; // newest timepoint considering one index overflow\n      indexBeforeOrAt = (left + right) >> 1; // \"middle\" point between the boundaries\n      beforeOrAt = self[uint16(indexBeforeOrAt)]; // checking the \"middle\" point between the boundaries\n      atOrAfter = beforeOrAt; // to suppress compiler warning; will be overridden\n      do {\n        (bool initializedBefore, uint32 timestampBefore) = (beforeOrAt.initialized, beforeOrAt.blockTimestamp);\n        if (initializedBefore) {\n          if (_lteConsideringOverflow(timestampBefore, target, currentTime)) {\n            // is current point before or at `target`?\n            atOrAfter = self[uint16(indexBeforeOrAt + 1)]; // checking the next point after \"middle\"\n            (bool initializedAfter, uint32 timestampAfter) = (atOrAfter.initialized, atOrAfter.blockTimestamp);\n            if (initializedAfter) {\n              if (_lteConsideringOverflow(target, timestampAfter, currentTime)) {\n                // is the \"next\" point after or at `target`?\n                return (beforeOrAt, atOrAfter, indexBeforeOrAt); // the only fully correct way to finish\n              }\n              left = indexBeforeOrAt + 1; // \"next\" point is before the `target`, so looking in the right half\n            } else {\n              // beforeOrAt is initialized and <= target, and next timepoint is uninitialized\n              // should be impossible if initial boundaries and `target` are correct\n              return (beforeOrAt, beforeOrAt, indexBeforeOrAt);\n            }\n          } else {\n            right = indexBeforeOrAt - 1; // current point is after the `target`, so looking in the left half\n          }\n        } else {\n          // we've landed on an uninitialized timepoint, keep searching higher\n          // should be impossible if initial boundaries and `target` are correct\n          left = indexBeforeOrAt + 1;\n        }\n        indexBeforeOrAt = (left + right) >> 1; // calculating the new \"middle\" point index after updating the bounds\n        beforeOrAt = self[uint16(indexBeforeOrAt)]; // update the \"middle\" point pointer\n      } while (true);\n    }\n  }\n}"
    }
  ]
}