{
  "Title": "[H-01] If a STRATEGY TOKEN is \"Toggled off\" STRATEGIES will still be able to withdraw, but returning of tokens with `replenishReserves` will be disabled.",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchPort.sol#L158-L169> \n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchPort.sol#L172-L186>\n\n### Impact\n\n`BranchPort.manage` allows a registered Strategy to withdraw certain amounts of enabled strategy tokens. It validates access rights; i.e. if called by a strategy registered for the requested token. However, it doesn't check to see if the token itself is currently enabled.\n\nConversely, `BranchPort.replenishTokens` allows a forced withdrawal of managed tokens from a strategy. However, it performs a check to see if the token is currently an active strategy token.\n\nA strategy token may be disabled by `toggleStrategyToken()` even if there are active strategies managing it actively. In such cases, these strategies will still be able to withdraw the tokens with calls to `manage()` while `replenishTokens` will not be callable on them; thus, tokens won't be forced as returnable.\n\n### Recommended Mitigation Steps\n\n1.  Add a check on the enabled strategy token in `manage()`.\n2.  Validate `getPortStrategyTokenDebt[_strategy][_token] > 0` instead of `!isStrategyToken[_token]` in `replenishReserves()`.\n\n### Assessed type\n\nAccess Control\n\n**[0xBugsy (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/882#issuecomment-1632539924)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/882#issuecomment-1708799318):**\n> Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/882).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/ulysses-omnichain/BranchPort.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IPortStrategy} from \"./interfaces/IPortStrategy.sol\";\nimport {IBranchPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {ERC20hTokenBranch} from \"./token/ERC20hTokenBranch.sol\";\n\n/// @title Branch Port - Omnichain Token Management Contract\ncontract BranchPort is Ownable, IBranchPort {\n    using SafeTransferLib for address;\n\n    /// @notice Local Core Branch Router Address.\n    address public coreBranchRouterAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address => bool) public isBridgeAgent;\n\n    /// @notice Branch Routers deployed in branc chain.\n    address[] public bridgeAgents;\n\n    /// @notice Number of Branch Routers deployed in current chain.\n    uint256 public bridgeAgentsLenght;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address => bool) public isBridgeAgentFactory;\n\n    /// @notice Branch Routers deployed in branc chain.\n    address[] public bridgeAgentFactories;\n\n    /// @notice Number of Branch Routers deployed in current chain.\n    uint256 public bridgeAgentFactoriesLenght;\n\n    /*///////////////////////////////////////////////////////////////\n                        PORT STRATEGY STATE\n    //////////////////////////////////////////////////////////////*/\n    /// Strategy Tokens\n\n    /// @notice Mapping returns true if Strategy Token Address is active for usage in Port Strategies.\n    mapping(address => bool) public isStrategyToken;\n\n    /// @notice List of Tokens whitelisted for usage in Port Strategies.\n    address[] public strategyTokens;\n\n    /// @notice Number of Port Strategies deployed in current branch chain.\n    uint256 public strategyTokensLenght;\n\n    /// @notice Mapping returns a given token's total debt incurred by Port Strategies.\n    mapping(address => uint256) public getStrategyTokenDebt;\n\n    /// @notice Mapping returns the minimum ratio of a given Strategy Token the Port should hold.\n    mapping(address => uint256) public getMinimumTokenReserveRatio;\n\n    /// Port Strategies\n\n    /// @notice Mapping returns true if Port Startegy is allowed to manage a given Strategy Token. Strategy => Token => bool.\n    mapping(address => mapping(address => bool)) public isPortStrategy;\n\n    /// @notice Port Strategy Addresses deployed in current branch chain.\n    address[] public portStrategies;\n\n    /// @notice Number of Port Strategies deployed in current branch chain.\n    uint256 public portStrategiesLenght;\n\n    /// @notice Mapping returns the amount of Strategy Token debt a given Port Startegy has.  Strategy => Token => uint256.\n    mapping(address => mapping(address => uint256)) public getPortStrategyTokenDebt;\n\n    /// @notice Mapping returns the last time a given Port Strategy managed a given Strategy Token. Strategy => Token => uint256.\n    mapping(address => mapping(address => uint256)) public lastManaged;\n\n    /// @notice Mapping returns the time limit a given Port Strategy must wait before managing a Strategy Token. Strategy => Token => uint256.\n    mapping(address => mapping(address => uint256)) public strategyDailyLimitAmount;\n\n    /// @notice Mapping returns the amount of a Strategy Token a given Port Strategy can manage.\n    mapping(address => mapping(address => uint256)) public strategyDailyLimitRemaining;\n\n    uint256 internal constant DIVISIONER = 1e4;\n    uint256 internal constant MIN_RESERVE_RATIO = 3e3;\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"Owner is zero address\");\n        _initializeOwner(_owner);\n    }\n\n    function initialize(address _coreBranchRouter, address _bridgeAgentFactory) external virtual onlyOwner {\n        require(coreBranchRouterAddress == address(0), \"Contract already initialized\");\n        require(!isBridgeAgentFactory[_bridgeAgentFactory], \"Contract already initialized\");\n\n        require(_coreBranchRouter != address(0), \"CoreBranchRouter is zero address\");\n        require(_bridgeAgentFactory != address(0), \"BridgeAgentFactory is zero address\");\n\n        coreBranchRouterAddress = _coreBranchRouter;\n        isBridgeAgentFactory[_bridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_bridgeAgentFactory);\n        bridgeAgentFactoriesLenght++;\n    }\n\n    /// @notice Function being overrriden to prevent mistakenly renouncing ownership.\n    function renounceOwnership() public payable override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns amount of Strategy Tokens\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 excess reserves\n     */\n    function _excessReserves(address _token) internal view returns (uint256) {\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n        uint256 minReserves = _minimumReserves(currBalance, _token);\n        return currBalance > minReserves ? currBalance - minReserves : 0;\n    }\n\n    /**\n     * @notice Returns amount of Strategy Tokens needed to reach minimum reserves\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 excess reserves\n     */\n    function _reservesLacking(address _token) internal view returns (uint256) {\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n        uint256 minReserves = _minimumReserves(currBalance, _token);\n        return currBalance < minReserves ? minReserves - currBalance : 0;\n    }\n\n    /**\n     * @notice Internal function to return the minimum amount of reserves of a given Strategy Token the Port should hold.\n     *   @param _currBalance Current balance of a given Strategy Token.\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 minimum reserves\n     */\n    function _minimumReserves(uint256 _currBalance, address _token) internal view returns (uint256) {\n        return ((_currBalance + getStrategyTokenDebt[_token]) * getMinimumTokenReserveRatio[_token]) / DIVISIONER;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        PORT STRATEGY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function manage(address _token, uint256 _amount) external requiresPortStrategy(_token) {\n        if (_amount > _excessReserves(_token)) revert InsufficientReserves();\n\n        _checkTimeLimit(_token, _amount);\n\n        getStrategyTokenDebt[_token] += _amount;\n        getPortStrategyTokenDebt[msg.sender][_token] += _amount;\n\n        _token.safeTransfer(msg.sender, _amount);\n\n        emit DebtCreated(msg.sender, _token, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function replenishReserves(address _strategy, address _token, uint256 _amount) external lock {\n        if (!isStrategyToken[_token]) revert UnrecognizedStrategyToken();\n        if (!isPortStrategy[_strategy][_token]) revert UnrecognizedPortStrategy();\n\n        uint256 reservesLacking = _reservesLacking(_token);\n\n        uint256 amountToWithdraw = _amount < reservesLacking ? _amount : reservesLacking;\n\n        IPortStrategy(_strategy).withdraw(address(this), _token, amountToWithdraw);\n\n        getPortStrategyTokenDebt[_strategy][_token] -= amountToWithdraw;\n        getStrategyTokenDebt[_token] -= amountToWithdraw;\n\n        emit DebtRepaid(_strategy, _token, amountToWithdraw);\n    }\n\n    /**\n     * @notice Internal function to check if a Port Strategy has reached its daily management limit.\n     *   @param _token address being managed.\n     *   @param _amount of token being requested.\n     */\n    function _checkTimeLimit(address _token, uint256 _amount) internal {\n        if (block.timestamp - lastManaged[msg.sender][_token] >= 1 days) {\n            strategyDailyLimitRemaining[msg.sender][_token] = strategyDailyLimitAmount[msg.sender][_token];\n        }\n        strategyDailyLimitRemaining[msg.sender][_token] -= _amount;\n        lastManaged[msg.sender][_token] = block.timestamp;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function withdraw(address _recipient, address _underlyingAddress, uint256 _deposit)\n        external\n        virtual\n        requiresBridgeAgent\n    {\n        _underlyingAddress.safeTransfer(\n            _recipient, _denormalizeDecimals(_deposit, ERC20(_underlyingAddress).decimals())\n        );\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeIn(address _recipient, address _localAddress, uint256 _amount)\n        external\n        virtual\n        requiresBridgeAgent\n    {\n        ERC20hTokenBranch(_localAddress).mint(_recipient, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeInMultiple(address _recipient, address[] memory _localAddresses, uint256[] memory _amounts)\n        external\n        virtual\n        requiresBridgeAgent\n    {\n        for (uint256 i = 0; i < _localAddresses.length;) {\n            ERC20hTokenBranch(_localAddresses[i]).mint(_recipient, _amounts[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeOut(\n        address _depositor,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _amount,\n        uint256 _deposit\n    ) external virtual requiresBridgeAgent {\n        if (_amount - _deposit > 0) {\n            _localAddress.safeTransferFrom(_depositor, address(this), _amount - _deposit);\n            ERC20hTokenBranch(_localAddress).burn(_amount - _deposit);\n        }\n        if (_deposit > 0) {\n            _underlyingAddress.safeTransferFrom(\n                _depositor, address(this), _denormalizeDecimals(_deposit, ERC20(_underlyingAddress).decimals())\n            );\n        }\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeOutMultiple(\n        address _depositor,\n        address[] memory _localAddresses,\n        address[] memory _underlyingAddresses,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits\n    ) external virtual requiresBridgeAgent {\n        for (uint256 i = 0; i < _localAddresses.length;) {\n            if (_deposits[i] > 0) {\n                _underlyingAddresses[i].safeTransferFrom(\n                    _depositor,\n                    address(this),\n                    _denormalizeDecimals(_deposits[i], ERC20(_underlyingAddresses[i]).decimals())\n                );\n            }\n            if (_amounts[i] - _deposits[i] > 0) {\n                _localAddresses[i].safeTransferFrom(_depositor, address(this), _amounts[i] - _deposits[i]);\n                ERC20hTokenBranch(_localAddresses[i]).burn(_amounts[i] - _deposits[i]);\n            }\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function addBridgeAgent(address _bridgeAgent) external requiresBridgeAgentFactory {\n        isBridgeAgent[_bridgeAgent] = true;\n        bridgeAgents.push(_bridgeAgent);\n        bridgeAgentsLenght++;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function setCoreRouter(address _newCoreRouter) external requiresCoreRouter {\n        require(coreBranchRouterAddress != address(0), \"CoreRouter address is zero\");\n        require(_newCoreRouter != address(0), \"New CoreRouter address is zero\");\n        coreBranchRouterAddress = _newCoreRouter;\n    }\n\n    /// @inheritdoc IBranchPort\n    function addBridgeAgentFactory(address _newBridgeAgentFactory) external requiresCoreRouter {\n        isBridgeAgentFactory[_newBridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_newBridgeAgentFactory);\n        bridgeAgentFactoriesLenght++;\n\n        emit BridgeAgentFactoryAdded(_newBridgeAgentFactory);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleBridgeAgentFactory(address _newBridgeAgentFactory) external requiresCoreRouter {\n        isBridgeAgentFactory[_newBridgeAgentFactory] = !isBridgeAgentFactory[_newBridgeAgentFactory];\n\n        emit BridgeAgentFactoryToggled(_newBridgeAgentFactory);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleBridgeAgent(address _bridgeAgent) external requiresCoreRouter {\n        isBridgeAgent[_bridgeAgent] = !isBridgeAgent[_bridgeAgent];\n\n        emit BridgeAgentToggled(_bridgeAgent);\n    }\n\n    /// @inheritdoc IBranchPort\n    function addStrategyToken(address _token, uint256 _minimumReservesRatio) external requiresCoreRouter {\n        if (_minimumReservesRatio >= DIVISIONER) revert InvalidMinimumReservesRatio();\n        strategyTokens.push(_token);\n        strategyTokensLenght++;\n        getMinimumTokenReserveRatio[_token] = _minimumReservesRatio;\n        isStrategyToken[_token] = true;\n\n        emit StrategyTokenAdded(_token, _minimumReservesRatio);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleStrategyToken(address _token) external requiresCoreRouter {\n        isStrategyToken[_token] = !isStrategyToken[_token];\n\n        emit StrategyTokenToggled(_token);\n    }\n\n    /// @inheritdoc IBranchPort\n    function addPortStrategy(address _portStrategy, address _token, uint256 _dailyManagementLimit)\n        external\n        requiresCoreRouter\n    {\n        if (!isStrategyToken[_token]) revert UnrecognizedStrategyToken();\n        portStrategies.push(_portStrategy);\n        portStrategiesLenght++;\n        strategyDailyLimitAmount[_portStrategy][_token] = _dailyManagementLimit;\n        isPortStrategy[_portStrategy][_token] = true;\n\n        emit PortStrategyAdded(_portStrategy, _token, _dailyManagementLimit);\n    }\n\n    /// @inheritdoc IBranchPort\n    function togglePortStrategy(address _portStrategy, address _token) external requiresCoreRouter {\n        isPortStrategy[_portStrategy][_token] = !isPortStrategy[_portStrategy][_token];\n\n        emit PortStrategyToggled(_portStrategy, _token);\n    }\n\n    /// @inheritdoc IBranchPort\n    function updatePortStrategy(address _portStrategy, address _token, uint256 _dailyManagementLimit)\n        external\n        requiresCoreRouter\n    {\n        strategyDailyLimitAmount[_portStrategy][_token] = _dailyManagementLimit;\n\n        emit PortStrategyUpdated(_portStrategy, _token, _dailyManagementLimit);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function that denormalizes an input from 18 decimal places.\n     * @param _amount amount of tokens\n     * @param _decimals number of decimal places\n     */\n    function _denormalizeDecimals(uint256 _amount, uint8 _decimals) internal pure returns (uint256) {\n        return _decimals == 18 ? _amount : _amount * 1 ether / (10 ** _decimals);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is the Branch Chain's Core Root Router.\n    modifier requiresCoreRouter() {\n        if (msg.sender != coreBranchRouterAddress) revert UnrecognizedCore();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent.\n    modifier requiresBridgeAgent() {\n        if (!isBridgeAgent[msg.sender]) revert UnrecognizedBridgeAgent();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent Factory.\n    modifier requiresBridgeAgentFactory() {\n        if (!isBridgeAgentFactory[msg.sender]) revert UnrecognizedBridgeAgentFactory();\n        _;\n    }\n\n    /// @notice Modifier that require msg sender to be an active Port Strategy\n    modifier requiresPortStrategy(address _token) {\n        if (!isPortStrategy[msg.sender][_token]) revert UnrecognizedPortStrategy();\n        _;\n    }\n\n    uint256 internal _unlocked = 1;\n\n    /// @notice Modifier for a simple re-entrancy check.\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n}"
    },
    {
      "filename": "src/ulysses-omnichain/BranchPort.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IPortStrategy} from \"./interfaces/IPortStrategy.sol\";\nimport {IBranchPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {ERC20hTokenBranch} from \"./token/ERC20hTokenBranch.sol\";\n\n/// @title Branch Port - Omnichain Token Management Contract\ncontract BranchPort is Ownable, IBranchPort {\n    using SafeTransferLib for address;\n\n    /// @notice Local Core Branch Router Address.\n    address public coreBranchRouterAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address => bool) public isBridgeAgent;\n\n    /// @notice Branch Routers deployed in branc chain.\n    address[] public bridgeAgents;\n\n    /// @notice Number of Branch Routers deployed in current chain.\n    uint256 public bridgeAgentsLenght;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address => bool) public isBridgeAgentFactory;\n\n    /// @notice Branch Routers deployed in branc chain.\n    address[] public bridgeAgentFactories;\n\n    /// @notice Number of Branch Routers deployed in current chain.\n    uint256 public bridgeAgentFactoriesLenght;\n\n    /*///////////////////////////////////////////////////////////////\n                        PORT STRATEGY STATE\n    //////////////////////////////////////////////////////////////*/\n    /// Strategy Tokens\n\n    /// @notice Mapping returns true if Strategy Token Address is active for usage in Port Strategies.\n    mapping(address => bool) public isStrategyToken;\n\n    /// @notice List of Tokens whitelisted for usage in Port Strategies.\n    address[] public strategyTokens;\n\n    /// @notice Number of Port Strategies deployed in current branch chain.\n    uint256 public strategyTokensLenght;\n\n    /// @notice Mapping returns a given token's total debt incurred by Port Strategies.\n    mapping(address => uint256) public getStrategyTokenDebt;\n\n    /// @notice Mapping returns the minimum ratio of a given Strategy Token the Port should hold.\n    mapping(address => uint256) public getMinimumTokenReserveRatio;\n\n    /// Port Strategies\n\n    /// @notice Mapping returns true if Port Startegy is allowed to manage a given Strategy Token. Strategy => Token => bool.\n    mapping(address => mapping(address => bool)) public isPortStrategy;\n\n    /// @notice Port Strategy Addresses deployed in current branch chain.\n    address[] public portStrategies;\n\n    /// @notice Number of Port Strategies deployed in current branch chain.\n    uint256 public portStrategiesLenght;\n\n    /// @notice Mapping returns the amount of Strategy Token debt a given Port Startegy has.  Strategy => Token => uint256.\n    mapping(address => mapping(address => uint256)) public getPortStrategyTokenDebt;\n\n    /// @notice Mapping returns the last time a given Port Strategy managed a given Strategy Token. Strategy => Token => uint256.\n    mapping(address => mapping(address => uint256)) public lastManaged;\n\n    /// @notice Mapping returns the time limit a given Port Strategy must wait before managing a Strategy Token. Strategy => Token => uint256.\n    mapping(address => mapping(address => uint256)) public strategyDailyLimitAmount;\n\n    /// @notice Mapping returns the amount of a Strategy Token a given Port Strategy can manage.\n    mapping(address => mapping(address => uint256)) public strategyDailyLimitRemaining;\n\n    uint256 internal constant DIVISIONER = 1e4;\n    uint256 internal constant MIN_RESERVE_RATIO = 3e3;\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"Owner is zero address\");\n        _initializeOwner(_owner);\n    }\n\n    function initialize(address _coreBranchRouter, address _bridgeAgentFactory) external virtual onlyOwner {\n        require(coreBranchRouterAddress == address(0), \"Contract already initialized\");\n        require(!isBridgeAgentFactory[_bridgeAgentFactory], \"Contract already initialized\");\n\n        require(_coreBranchRouter != address(0), \"CoreBranchRouter is zero address\");\n        require(_bridgeAgentFactory != address(0), \"BridgeAgentFactory is zero address\");\n\n        coreBranchRouterAddress = _coreBranchRouter;\n        isBridgeAgentFactory[_bridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_bridgeAgentFactory);\n        bridgeAgentFactoriesLenght++;\n    }\n\n    /// @notice Function being overrriden to prevent mistakenly renouncing ownership.\n    function renounceOwnership() public payable override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns amount of Strategy Tokens\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 excess reserves\n     */\n    function _excessReserves(address _token) internal view returns (uint256) {\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n        uint256 minReserves = _minimumReserves(currBalance, _token);\n        return currBalance > minReserves ? currBalance - minReserves : 0;\n    }\n\n    /**\n     * @notice Returns amount of Strategy Tokens needed to reach minimum reserves\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 excess reserves\n     */\n    function _reservesLacking(address _token) internal view returns (uint256) {\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n        uint256 minReserves = _minimumReserves(currBalance, _token);\n        return currBalance < minReserves ? minReserves - currBalance : 0;\n    }\n\n    /**\n     * @notice Internal function to return the minimum amount of reserves of a given Strategy Token the Port should hold.\n     *   @param _currBalance Current balance of a given Strategy Token.\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 minimum reserves\n     */\n    function _minimumReserves(uint256 _currBalance, address _token) internal view returns (uint256) {\n        return ((_currBalance + getStrategyTokenDebt[_token]) * getMinimumTokenReserveRatio[_token]) / DIVISIONER;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        PORT STRATEGY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function manage(address _token, uint256 _amount) external requiresPortStrategy(_token) {\n        if (_amount > _excessReserves(_token)) revert InsufficientReserves();\n\n        _checkTimeLimit(_token, _amount);\n\n        getStrategyTokenDebt[_token] += _amount;\n        getPortStrategyTokenDebt[msg.sender][_token] += _amount;\n\n        _token.safeTransfer(msg.sender, _amount);\n\n        emit DebtCreated(msg.sender, _token, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function replenishReserves(address _strategy, address _token, uint256 _amount) external lock {\n        if (!isStrategyToken[_token]) revert UnrecognizedStrategyToken();\n        if (!isPortStrategy[_strategy][_token]) revert UnrecognizedPortStrategy();\n\n        uint256 reservesLacking = _reservesLacking(_token);\n\n        uint256 amountToWithdraw = _amount < reservesLacking ? _amount : reservesLacking;\n\n        IPortStrategy(_strategy).withdraw(address(this), _token, amountToWithdraw);\n\n        getPortStrategyTokenDebt[_strategy][_token] -= amountToWithdraw;\n        getStrategyTokenDebt[_token] -= amountToWithdraw;\n\n        emit DebtRepaid(_strategy, _token, amountToWithdraw);\n    }\n\n    /**\n     * @notice Internal function to check if a Port Strategy has reached its daily management limit.\n     *   @param _token address being managed.\n     *   @param _amount of token being requested.\n     */\n    function _checkTimeLimit(address _token, uint256 _amount) internal {\n        if (block.timestamp - lastManaged[msg.sender][_token] >= 1 days) {\n            strategyDailyLimitRemaining[msg.sender][_token] = strategyDailyLimitAmount[msg.sender][_token];\n        }\n        strategyDailyLimitRemaining[msg.sender][_token] -= _amount;\n        lastManaged[msg.sender][_token] = block.timestamp;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function withdraw(address _recipient, address _underlyingAddress, uint256 _deposit)\n        external\n        virtual\n        requiresBridgeAgent\n    {\n        _underlyingAddress.safeTransfer(\n            _recipient, _denormalizeDecimals(_deposit, ERC20(_underlyingAddress).decimals())\n        );\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeIn(address _recipient, address _localAddress, uint256 _amount)\n        external\n        virtual\n        requiresBridgeAgent\n    {\n        ERC20hTokenBranch(_localAddress).mint(_recipient, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeInMultiple(address _recipient, address[] memory _localAddresses, uint256[] memory _amounts)\n        external\n        virtual\n        requiresBridgeAgent\n    {\n        for (uint256 i = 0; i < _localAddresses.length;) {\n            ERC20hTokenBranch(_localAddresses[i]).mint(_recipient, _amounts[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeOut(\n        address _depositor,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _amount,\n        uint256 _deposit\n    ) external virtual requiresBridgeAgent {\n        if (_amount - _deposit > 0) {\n            _localAddress.safeTransferFrom(_depositor, address(this), _amount - _deposit);\n            ERC20hTokenBranch(_localAddress).burn(_amount - _deposit);\n        }\n        if (_deposit > 0) {\n            _underlyingAddress.safeTransferFrom(\n                _depositor, address(this), _denormalizeDecimals(_deposit, ERC20(_underlyingAddress).decimals())\n            );\n        }\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeOutMultiple(\n        address _depositor,\n        address[] memory _localAddresses,\n        address[] memory _underlyingAddresses,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits\n    ) external virtual requiresBridgeAgent {\n        for (uint256 i = 0; i < _localAddresses.length;) {\n            if (_deposits[i] > 0) {\n                _underlyingAddresses[i].safeTransferFrom(\n                    _depositor,\n                    address(this),\n                    _denormalizeDecimals(_deposits[i], ERC20(_underlyingAddresses[i]).decimals())\n                );\n            }\n            if (_amounts[i] - _deposits[i] > 0) {\n                _localAddresses[i].safeTransferFrom(_depositor, address(this), _amounts[i] - _deposits[i]);\n                ERC20hTokenBranch(_localAddresses[i]).burn(_amounts[i] - _deposits[i]);\n            }\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function addBridgeAgent(address _bridgeAgent) external requiresBridgeAgentFactory {\n        isBridgeAgent[_bridgeAgent] = true;\n        bridgeAgents.push(_bridgeAgent);\n        bridgeAgentsLenght++;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function setCoreRouter(address _newCoreRouter) external requiresCoreRouter {\n        require(coreBranchRouterAddress != address(0), \"CoreRouter address is zero\");\n        require(_newCoreRouter != address(0), \"New CoreRouter address is zero\");\n        coreBranchRouterAddress = _newCoreRouter;\n    }\n\n    /// @inheritdoc IBranchPort\n    function addBridgeAgentFactory(address _newBridgeAgentFactory) external requiresCoreRouter {\n        isBridgeAgentFactory[_newBridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_newBridgeAgentFactory);\n        bridgeAgentFactoriesLenght++;\n\n        emit BridgeAgentFactoryAdded(_newBridgeAgentFactory);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleBridgeAgentFactory(address _newBridgeAgentFactory) external requiresCoreRouter {\n        isBridgeAgentFactory[_newBridgeAgentFactory] = !isBridgeAgentFactory[_newBridgeAgentFactory];\n\n        emit BridgeAgentFactoryToggled(_newBridgeAgentFactory);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleBridgeAgent(address _bridgeAgent) external requiresCoreRouter {\n        isBridgeAgent[_bridgeAgent] = !isBridgeAgent[_bridgeAgent];\n\n        emit BridgeAgentToggled(_bridgeAgent);\n    }\n\n    /// @inheritdoc IBranchPort\n    function addStrategyToken(address _token, uint256 _minimumReservesRatio) external requiresCoreRouter {\n        if (_minimumReservesRatio >= DIVISIONER) revert InvalidMinimumReservesRatio();\n        strategyTokens.push(_token);\n        strategyTokensLenght++;\n        getMinimumTokenReserveRatio[_token] = _minimumReservesRatio;\n        isStrategyToken[_token] = true;\n\n        emit StrategyTokenAdded(_token, _minimumReservesRatio);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleStrategyToken(address _token) external requiresCoreRouter {\n        isStrategyToken[_token] = !isStrategyToken[_token];\n\n        emit StrategyTokenToggled(_token);\n    }\n\n    /// @inheritdoc IBranchPort\n    function addPortStrategy(address _portStrategy, address _token, uint256 _dailyManagementLimit)\n        external\n        requiresCoreRouter\n    {\n        if (!isStrategyToken[_token]) revert UnrecognizedStrategyToken();\n        portStrategies.push(_portStrategy);\n        portStrategiesLenght++;\n        strategyDailyLimitAmount[_portStrategy][_token] = _dailyManagementLimit;\n        isPortStrategy[_portStrategy][_token] = true;\n\n        emit PortStrategyAdded(_portStrategy, _token, _dailyManagementLimit);\n    }\n\n    /// @inheritdoc IBranchPort\n    function togglePortStrategy(address _portStrategy, address _token) external requiresCoreRouter {\n        isPortStrategy[_portStrategy][_token] = !isPortStrategy[_portStrategy][_token];\n\n        emit PortStrategyToggled(_portStrategy, _token);\n    }\n\n    /// @inheritdoc IBranchPort\n    function updatePortStrategy(address _portStrategy, address _token, uint256 _dailyManagementLimit)\n        external\n        requiresCoreRouter\n    {\n        strategyDailyLimitAmount[_portStrategy][_token] = _dailyManagementLimit;\n\n        emit PortStrategyUpdated(_portStrategy, _token, _dailyManagementLimit);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function that denormaliz"
    }
  ]
}