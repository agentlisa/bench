{
  "Title": "[L-03] NFTs are not guaranteed to have sequential IDs",
  "Content": "\nhttps://github.com/code-423n4/2022-12-forgeries/blob/main/src/interfaces/IVRFNFTRandomDraw.sol#L71-L90\n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L249-L256\n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L271\n\n### Impact\n\nAccordingly to [EIP-721](https://eips.ethereum.org/EIPS/eip-721):\n\n> **NFT Identifiers**\n> \n> Every NFT is identified by a unique uint256 ID inside the ERC-721 smart contract. This identifying number SHALL NOT change for the life of the contract. The pair (contract address, uint256 tokenId) will then be a globally unique and fully-qualified identifier for a specific asset on an Ethereum chain. While some ERC-721 smart contracts may find it convenient to start with ID 0 and simply increment by one for each new NFT, **callers SHALL NOT assume that ID numbers have any specific pattern to them, and MUST treat the ID as a “black box”.** Also note that NFTs MAY become invalid (be destroyed). Please see the enumeration functions for a supported enumeration interface.\n> \n> The choice of uint256 allows a wide variety of applications because UUIDs and sha3 hashes are directly convertible to uint256.\n\nThis project, aims to create a raffle [specifying](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/interfaces/IVRFNFTRandomDraw.sol#L71-L90) that the potential winner will be between a range, where the lower limit is set by the candidate with the lowest TokenId and the candidate with the highest TokenId (`+1` to be included in the draw) sets the upper limit. As stated in the previous quote, this could generate gigantic ranges with numerous empty tokens given how it is [calculated](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L249-L256) (see [ENS](https://etherscan.io/token/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85#readContract) as an example of empty slots and how the ids [are generated](https://docs.ens.domains/dapp-developer-guide/ens-as-nft)).\n\nAfter generating the random number via VRF, the winner [is selected by](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L249-L256) _moduluing_ by the range plus the initial token id. The result is then used to determine [the winner](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L271). \n\nConsidering the costs to query VRF and the waiting time to claim the prize, this issue may turn the contract unusable. \n\nNote that any used method when casting the collection to IERC721EnumerableUpgradeable has the same effect as casting to IERC721, and giving how a raffle is setup, it seems the original intent was to use indexes instead of ids.\n\nExternal requirements:\n- non-sequential NFTs.\n\n### Proof of Concept\n\nConsider a scenario where:\n\n```\nDrawing NFT Collection: ABC\nTokenIDs: [1,10,1000]\nTotalSupply: 3\n```\n\nSetting a raffle to include each possible token results in [1..1001[ alternatives. Since there are only three possible winners, there's only `0.3%` of a successful draw.\n\n### Recommended Mitigation Steps\n\nDepending on the direction the project takes:\n1. Change the way the setup is performed;\n2. Give more guarantees that only collections with sequential ids are used (note that the same problem might happen in nfts with high number of burns);\n3. Only use indexed collections.\n\n## Non-Critical Issues Summary\n| Number |Issues Details|Context|\n|:--:|:-------|:--:|\n| [N-01] | `getRequestDetails()` should include the tokenid |1|\n| [N-02] | Avoid setting time variables manually  |1|\n| [N-03] | Use constants instead of immutable variables | 1 |\n| [N-04] | Uppercase immutable variables | 6 |\n| [N-05] | Empty blocks should be avoided | 1 |\n| [N-06] | Missing _NatSpec_ | 1 |\n| [N-07] | Contracts that extend interfaces should override its methods | 3 |\n| [N-08] | `_requestRoll()` after confirming that the raffle is viable  |1|\n| [N-09] | `IERC721EnumerableUpgradeable` may lead to false assumptions | 6 |\n| [N-10] | `drawingTokenEndId` should be inclusive or altered to a range | 1 |\n| [N-11] | `fulfillRandomWords` must not revert | 1 |\n\nTotal: 11 issues\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-12-forgeries-contest",
  "Code": [
    {
      "filename": "src/interfaces/IVRFNFTRandomDraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IVRFNFTRandomDraw {\n    /// @notice Cannot redraw during waiting period\n    error STILL_IN_WAITING_PERIOD_BEFORE_REDRAWING();\n    /// @notice Admin emergency withdraw can only happen once unlocked\n    error RECOVERY_IS_NOT_YET_POSSIBLE();\n    /// @notice Token that is offered does not exist with ownerOf\n    error TOKEN_BEING_OFFERED_NEEDS_TO_EXIST();\n    /// @notice Token needs to be a contract when initializing\n    error TOKEN_NEEDS_TO_BE_A_CONTRACT(address potentialTokenAddress);\n    /// @notice Token needs to be approved to raffle contract\n    error TOKEN_NEEDS_TO_BE_APPROVED_TO_CONTRACT();\n    /// @notice Waiting on a response from chainlink\n    error REQUEST_IN_FLIGHT();\n    /// @notice Chainlink VRF response doesn't match current ID\n    error REQUEST_DOES_NOT_MATCH_CURRENT_ID();\n    /// @notice The tokens' totalSupply doesn't match one claimed on contract\n    error SUPPLY_TOKENS_COUNT_WRONG();\n    /// @notice Cannot attempt to claim winnings if request is not started or in flight\n    error NEEDS_TO_HAVE_CHOSEN_A_NUMBER();\n\n    /// @notice When the range is [20,0] (from 20 to 0, that doesn't make sense)\n    error DRAWING_TOKEN_RANGE_INVALID();\n    /// @notice Withdraw timelock min is 1 hour\n    error REDRAW_TIMELOCK_NEEDS_TO_BE_MORE_THAN_AN_HOUR();\n    error REDRAW_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_MONTH();\n    /// @notice Admin NFT recovery timelock min is 1 week\n    error RECOVER_TIMELOCK_NEEDS_TO_BE_AT_LEAST_A_WEEK();\n    /// @notice Admin NFT recovery timelock max is 1 year\n    error RECOVER_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_YEAR();\n    /// @notice The given user has not won\n    error USER_HAS_NOT_WON();\n    /// @notice Cannot re-draw yet\n    error TOO_SOON_TO_REDRAW();\n    /// @notice NFT for raffle is not owned by the admin\n    error DOES_NOT_OWN_NFT();\n    /// @notice Too many / few random words are sent back from chainlink\n    error WRONG_LENGTH_FOR_RANDOM_WORDS();\n\n    /// @notice When the draw is initialized\n    event InitializedDraw(address indexed sender, Settings settings);\n    /// @notice When the draw is setup\n    event SetupDraw(address indexed sender, Settings settings);\n    /// @notice When the owner reclaims nft aftr recovery time delay\n    event OwnerReclaimedNFT(address indexed owner);\n    /// @notice Dice roll is complete from callback\n    event DiceRollComplete(address indexed sender, CurrentRequest request);\n    /// @notice Sent when the winner sends/claims an NFT\n    event WinnerSentNFT(\n        address indexed winner,\n        address indexed nft,\n        uint256 indexed tokenId,\n        Settings settings\n    );\n\n    /// @notice Struct to organize current request\n    struct CurrentRequest {\n        /// @notice current chainlink request id\n        uint256 currentChainlinkRequestId;\n        /// @notice current chosen random number\n        uint256 currentChosenTokenId;\n        /// @notice has chosen a random number (in case random number = 0(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0))\n        bool hasChosenRandomNumber;\n        /// @notice time lock (block.timestamp) that a re-draw can be issued\n        uint256 drawTimelock;\n    }\n\n    /// @notice Struct to organize user settings\n    struct Settings {\n        /// @notice Token Contract to put up for raffle\n        address token;\n        /// @notice Token ID to put up for raffle\n        uint256 tokenId;\n        /// @notice Token that each (sequential) ID has a entry in the raffle.\n        address drawingToken;\n        /// @notice Start token ID for the drawing (if totalSupply = 20 but the first token is 5 (5-25), setting this to 5 would fix the ordering)\n        uint256 drawingTokenStartId;\n        /// @notice End token ID for the drawing (exclusive) (token ids 0 - 9 would be 10 in this field)\n        uint256 drawingTokenEndId;\n        /// @notice Draw buffer time – time until a re-drawing can occur if the selected user cannot or does not claim the NFT.\n        uint256 drawBufferTime;\n        /// @notice block.timestamp that the admin can recover the NFT (as a safety fallback)\n        uint256 recoverTimelock;\n        /// @notice Chainlink gas keyhash\n        bytes32 keyHash;\n        /// @notice Chainlink subscription id\n        uint64 subscriptionId;\n    }\n\n    /// @notice Initialize the contract with settings and an admin\n    /// @param admin initial admin user\n    /// @param _settings initial settings for draw\n    function initialize(address admin, Settings memory _settings) external;\n\n    /// @notice Call this to start the raffle drawing\n    /// @return chainlink request id\n    function startDraw() external returns (uint256);\n\n    /// @notice Call this to re-draw the raffle\n    /// @return chainlink request ID\n    /// @dev Only callable by the owner\n    function redraw() external returns (uint256);\n\n    /// @notice Function to determine if the user has won in the current drawing\n    /// @param user address for the user to check if they have won in the current drawing\n    function hasUserWon(address user) external view returns (bool);\n\n    /// @notice Function for the winner to call to retrieve their NFT\n    function winnerClaimNFT() external;\n\n    /// @notice Optional last resort admin reclaim nft function\n    /// @dev Only callable by the owner\n    function lastResortTimelockOwnerClaimNFT() external;\n\n    /// @notice Getter for request details, does not include picked tokenID\n    /// @return currentChainlinkRequestId Current Chainlink Request ID\n    /// @return hasChosenRandomNumber If the random number for the drawing has been chosen\n    /// @return drawTimelock block.timestamp when a redraw can be issued\n    function getRequestDetails()\n        external\n        view\n        returns (\n            uint256 currentChainlinkRequestId,\n            bool hasChosenRandomNumber,\n            uint256 drawTimelock\n        );\n}"
    },
    {
      "filename": "src/VRFNFTRandomDraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {OwnableUpgradeable} from \"./ownable/OwnableUpgradeable.sol\";\nimport {IERC721EnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\";\n\nimport {VRFConsumerBaseV2} from \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport {VRFCoordinatorV2, VRFCoordinatorV2Interface} from \"@chainlink/contracts/src/v0.8/VRFCoordinatorV2.sol\";\n\nimport {IVRFNFTRandomDraw} from \"./interfaces/IVRFNFTRandomDraw.sol\";\nimport {Version} from \"./utils/Version.sol\";\n\n/// @notice VRFNFTRandom Draw with NFT Tickets\n/// @author @isiain\ncontract VRFNFTRandomDraw is\n    IVRFNFTRandomDraw,\n    VRFConsumerBaseV2,\n    OwnableUpgradeable,\n    Version(1)\n{\n    /// @notice Our callback is just setting a few variables, 200k should be more than enough gas.\n    uint32 immutable callbackGasLimit = 200_000;\n    /// @notice Chainlink request confirmations, left at the default\n    uint16 immutable minimumRequestConfirmations = 3;\n    /// @notice Number of words requested in a drawing\n    uint16 immutable wordsRequested = 1;\n\n    /// @dev 60 seconds in a min, 60 mins in an hour\n    uint256 immutable HOUR_IN_SECONDS = 60 * 60;\n    /// @dev 24 hours in a day 7 days in a week\n    uint256 immutable WEEK_IN_SECONDS = (3600 * 24 * 7);\n    // @dev about 30 days in a month\n    uint256 immutable MONTH_IN_SECONDS = (3600 * 24 * 7) * 30;\n\n\n    /// @notice Reference to chain-specific coordinator contract\n    VRFCoordinatorV2Interface immutable coordinator;\n\n    /// @notice Settings used for the contract.\n    IVRFNFTRandomDraw.Settings public settings;\n\n    /// @notice Details about the current request to chainlink\n    IVRFNFTRandomDraw.CurrentRequest public request;\n\n    /// @dev Save the coordinator to the contract\n    /// @param _coordinator Address for VRF Coordinator V2 Interface\n    constructor(VRFCoordinatorV2Interface _coordinator)\n        VRFConsumerBaseV2(address(_coordinator))\n        initializer\n    {\n        coordinator = _coordinator;\n    }\n\n    /// @notice Getter for request details, does not include picked tokenID\n    /// @return currentChainlinkRequestId Current Chainlink Request ID\n    /// @return hasChosenRandomNumber If the random number for the drawing has been chosen\n    /// @return drawTimelock block.timestamp when a redraw can be issued\n    function getRequestDetails()\n        external\n        view\n        returns (\n            uint256 currentChainlinkRequestId,\n            bool hasChosenRandomNumber,\n            uint256 drawTimelock\n        )\n    {\n        currentChainlinkRequestId = request.currentChainlinkRequestId;\n        hasChosenRandomNumber = request.hasChosenRandomNumber;\n        drawTimelock = request.drawTimelock;\n    }\n\n    /// @notice Initialize the contract with settings and an admin\n    /// @param admin initial admin user\n    /// @param _settings initial settings for draw\n    function initialize(address admin, Settings memory _settings)\n        public\n        initializer\n    {\n        // Set new settings\n        settings = _settings;\n\n        // Check values in memory:\n        if (_settings.drawBufferTime < HOUR_IN_SECONDS) {\n            revert REDRAW_TIMELOCK_NEEDS_TO_BE_MORE_THAN_AN_HOUR();\n        }\n        if (_settings.drawBufferTime > MONTH_IN_SECONDS) {\n            revert REDRAW_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_MONTH();\n        }\n\n        if (_settings.recoverTimelock < block.timestamp + WEEK_IN_SECONDS) {\n            revert RECOVER_TIMELOCK_NEEDS_TO_BE_AT_LEAST_A_WEEK();\n        }\n        if (\n            _settings.recoverTimelock >\n            block.timestamp + (MONTH_IN_SECONDS * 12)\n        ) {\n            revert RECOVER_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_YEAR();\n        }\n\n        // If NFT contract address is not a contract\n        if (_settings.token.code.length == 0) {\n            revert TOKEN_NEEDS_TO_BE_A_CONTRACT(_settings.token);\n        }\n\n        // If drawing token is not a contract\n        if (_settings.drawingToken.code.length == 0) {\n            revert TOKEN_NEEDS_TO_BE_A_CONTRACT(_settings.drawingToken);\n        }\n\n        // Validate token range: end needs to be greater than start\n        // and the size of the range needs to be at least 2 (end is exclusive)\n        if (\n            _settings.drawingTokenEndId < _settings.drawingTokenStartId ||\n            _settings.drawingTokenEndId - _settings.drawingTokenStartId < 2\n        ) {\n            revert DRAWING_TOKEN_RANGE_INVALID();\n        }\n\n        // Setup owner as admin\n        __Ownable_init(admin);\n\n        // Emit initialized event for indexing\n        emit InitializedDraw(msg.sender, settings);\n\n        // Get owner of raffled tokenId and ensure the current owner is the admin\n        try\n            IERC721EnumerableUpgradeable(_settings.token).ownerOf(\n                _settings.tokenId\n            )\n        returns (address nftOwner) {\n            // Check if address is the admin address\n            if (nftOwner != admin) {\n                revert DOES_NOT_OWN_NFT();\n            }\n        } catch {\n            revert TOKEN_BEING_OFFERED_NEEDS_TO_EXIST();\n        }\n    }\n\n    /// @notice Internal function to request entropy\n    function _requestRoll() internal {\n        // Chainlink request cannot be currently in flight.\n        // Request is cleared in re-roll if conditions are correct.\n        if (request.currentChainlinkRequestId != 0) {\n            revert REQUEST_IN_FLIGHT();\n        }\n\n        // If the number has been drawn and\n        if (\n            request.hasChosenRandomNumber &&\n            // Draw timelock not yet used\n            request.drawTimelock != 0 &&\n            request.drawTimelock > block.timestamp\n        ) {\n            revert STILL_IN_WAITING_PERIOD_BEFORE_REDRAWING();\n        }\n\n        // Setup re-draw timelock\n        request.drawTimelock = block.timestamp + settings.drawBufferTime;\n\n        // Request first random round\n        request.currentChainlinkRequestId = coordinator.requestRandomWords({\n            keyHash: settings.keyHash,\n            subId: settings.subscriptionId,\n            minimumRequestConfirmations: minimumRequestConfirmations,\n            callbackGasLimit: callbackGasLimit,\n            numWords: wordsRequested\n        });\n    }\n\n    /// @notice Call this to start the raffle drawing\n    /// @return chainlink request id\n    function startDraw() external onlyOwner returns (uint256) {\n        // Only can be called on first drawing\n        if (request.currentChainlinkRequestId != 0) {\n            revert REQUEST_IN_FLIGHT();\n        }\n\n        // Emit setup draw user event\n        emit SetupDraw(msg.sender, settings);\n\n        // Request initial roll\n        _requestRoll();\n\n        // Attempt to transfer token into this address\n        try\n            IERC721EnumerableUpgradeable(settings.token).transferFrom(\n                msg.sender,\n                address(this),\n                settings.tokenId\n            )\n        {} catch {\n            revert TOKEN_NEEDS_TO_BE_APPROVED_TO_CONTRACT();\n        }\n\n        // Return the current chainlink request id\n        return request.currentChainlinkRequestId;\n    }\n\n    /// @notice Call this to re-draw the raffle\n    /// @return chainlink request ID\n    /// @dev Only callable by the owner\n    function redraw() external onlyOwner returns (uint256) {\n        if (request.drawTimelock >= block.timestamp) {\n            revert TOO_SOON_TO_REDRAW();\n        }\n\n        // Reset request\n        delete request;\n\n        // Re-roll\n        _requestRoll();\n\n        // Owner of token to raffle needs to be this contract\n        if (\n            IERC721EnumerableUpgradeable(settings.token).ownerOf(\n                settings.tokenId\n            ) != address(this)\n        ) {\n            revert DOES_NOT_OWN_NFT();\n        }\n\n        // Return current chainlink request ID\n        return request.currentChainlinkRequestId;\n    }\n\n    /// @notice Function called by chainlink to resolve random words\n    /// @param _requestId ID of request sent to chainlink VRF\n    /// @param _randomWords List of uint256 words of random entropy\n    function fulfillRandomWords(\n        uint256 _requestId,\n        uint256[] memory _randomWords\n    ) internal override {\n        // Validate request ID\n        if (_requestId != request.currentChainlinkRequestId) {\n            revert REQUEST_DOES_NOT_MATCH_CURRENT_ID();\n        }\n\n        // Validate number of words returned\n        // Words requested is an immutable set to 1\n        if (_randomWords.length != wordsRequested) {\n            revert WRONG_LENGTH_FOR_RANDOM_WORDS();\n        }\n\n        // Set request details\n        request.hasChosenRandomNumber = true;\n\n        // Get total token range\n        uint256 tokenRange = settings.drawingTokenEndId -\n            settings.drawingTokenStartId;\n\n        // Store a number from it here (reduce number here to reduce gas usage)\n        // We know there will only be 1 word sent at this point.\n        request.currentChosenTokenId =\n            (_randomWords[0] % tokenRange) +\n            settings.drawingTokenStartId;\n\n        // Emit completed event.\n        emit DiceRollComplete(msg.sender, request);\n    }\n\n    /// @notice Function to determine if the user has won in the current drawing\n    /// @param user address for the user to check if they have won in the current drawing\n    function hasUserWon(address user) public view returns (bool) {\n        if (!request.hasChosenRandomNumber) {\n            revert NEEDS_TO_HAVE_CHOSEN_A_NUMBER();\n        }\n\n        return\n            user ==\n            IERC721EnumerableUpgradeable(settings.drawingToken).ownerOf(\n                request.currentChosenTokenId\n            );\n    }\n\n    /// @notice Function for the winner to call to retrieve their NFT\n    function winnerClaimNFT() external {\n        // Assume (potential) winner calls this fn, cache.\n        address user = msg.sender;\n\n        // Check if this user has indeed won.\n        if (!hasUserWon(user)) {\n            revert USER_HAS_NOT_WON();\n        }\n\n        // Emit a celebratory event\n        emit WinnerSentNFT(\n            user,\n            address(settings.token),\n            settings.tokenId,\n            settings\n        );\n\n        // Transfer token to the winter.\n        IERC721EnumerableUpgradeable(settings.token).transferFrom(\n            address(this),\n            msg.sender,\n            settings.tokenId\n        );\n    }\n\n    /// @notice Optional last resort admin reclaim nft function\n    /// @dev Only callable by the owner\n    function lastResortTimelockOwnerClaimNFT() external onlyOwner {\n        // If recoverTimelock is not setup, or if not yet occurred\n        if (settings.recoverTimelock > block.timestamp) {\n            // Stop the withdraw\n            revert RECOVERY_IS_NOT_YET_POSSIBLE();\n        }\n\n        // Send event for indexing that the owner reclaimed the NFT\n        emit OwnerReclaimedNFT(owner());\n\n        // Transfer token to the admin/owner.\n        IERC721EnumerableUpgradeable(settings.token).transferFrom(\n            address(this),\n            owner(),\n            settings.tokenId\n        );\n    }\n}"
    },
    {
      "filename": "src/VRFNFTRandomDraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {OwnableUpgradeable} from \"./ownable/OwnableUpgradeable.sol\";\nimport {IERC721EnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\";\n\nimport {VRFConsumerBaseV2} from \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport {VRFCoordinatorV2, VRFCoordinatorV2Interface} from \"@chainlink/contracts/src/v0.8/VRFCoordinatorV2.sol\";\n\nimport {IVRFNFTRandomDraw} from \"./interfaces/IVRFNFTRandomDraw.sol\";\nimport {Version} from \"./utils/Version.sol\";\n\n/// @notice VRFNFTRandom Draw with NFT Tickets\n/// @author @isiain\ncontract VRFNFTRandomDraw is\n    IVRFNFTRandomDraw,\n    VRFConsumerBaseV2,\n    OwnableUpgradeable,\n    Version(1)\n{\n    /// @notice Our callback is just setting a few variables, 200k should be more than enough gas.\n    uint32 immutable callbackGasLimit = 200_000;\n    /// @notice Chainlink request confirmations, left at the default\n    uint16 immutable minimumRequestConfirmations = 3;\n    /// @notice Number of words requested in a drawing\n    uint16 immutable wordsRequested = 1;\n\n    /// @dev 60 seconds in a min, 60 mins in an hour\n    uint256 immutable HOUR_IN_SECONDS = 60 * 60;\n    /// @dev 24 hours in a day 7 days in a week\n    uint256 immutable WEEK_IN_SECONDS = (3600 * 24 * 7);\n    // @dev about 30 days in a month\n    uint256 immutable MONTH_IN_SECONDS = (3600 * 24 * 7) * 30;\n\n\n    /// @notice Reference to chain-specific coordinator contract\n    VRFCoordinatorV2Interface immutable coordinator;\n\n    /// @notice Settings used for the contract.\n    IVRFNFTRandomDraw.Settings public settings;\n\n    /// @notice Details about the current request to chainlink\n    IVRFNFTRandomDraw.CurrentRequest public request;\n\n    /// @dev Save the coordinator to the contract\n    /// @param _coordinator Address for VRF Coordinator V2 Interface\n    constructor(VRFCoordinatorV2Interface _coordinator)\n        VRFConsumerBaseV2(address(_coordinator))\n        initializer\n    {\n        coordinator = _coordinator;\n    }\n\n    /// @notice Getter for request details, does not include picked tokenID\n    /// @return currentChainlinkRequestId Current Chainlink Request ID\n    /// @return hasChosenRandomNumber If the random number for the drawing has been chosen\n    /// @return drawTimelock block.timestamp when a redraw can be issued\n    function getRequestDetails()\n        external\n        view\n        returns (\n            uint256 currentChainlinkRequestId,\n            bool hasChosenRandomNumber,\n            uint256 drawTimelock\n        )\n    {\n        currentChainlinkRequestId = request.currentChainlinkRequestId;\n        hasChosenRandomNumber = request.hasChosenRandomNumber;\n        drawTimelock = request.drawTimelock;\n    }\n\n    /// @notice Initialize the contract with settings and an admin\n    /// @param admin initial admin user\n    /// @param _settings initial settings for draw\n    function initialize(address admin, Settings memory _settings)\n        public\n        initializer\n    {\n        // Set new settings\n        settings = _settings;\n\n        // Check values in memory:\n        if (_settings.drawBufferTime < HOUR_IN_SECONDS) {\n            revert REDRAW_TIMELOCK_NEEDS_TO_BE_MORE_THAN_AN_HOUR();\n        }\n        if (_settings.drawBufferTime > MONTH_IN_SECONDS) {\n            revert REDRAW_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_MONTH();\n        }\n\n        if (_settings.recoverTimelock < block.timestamp + WEEK_IN_SECONDS) {\n            revert RECOVER_TIMELOCK_NEEDS_TO_BE_AT_LEAST_A_WEEK();\n        }\n        if (\n            _settings.recoverTimelock >\n            block.timestamp + (MONTH_IN_SECONDS * 12)\n        ) {\n            revert RECOVER_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_YEAR();\n        }\n\n        // If NFT contract address is not a contract\n        if (_settings.token.code.length == 0) {\n            revert TOKEN_NEEDS_TO_BE_A_CONTRACT(_settings.token);\n        }\n\n        // If drawing token is not a contract\n        if (_settings.drawingToken.code.length == 0) {\n            revert TOKEN_NEEDS_TO_BE_A_CONTRACT(_settings.drawingToken);\n        }\n\n        // Validate token range: end needs to be greater than start\n        // and the size of the range needs to be at least 2 (end is exclusive)\n        if (\n            _settings.drawingTokenEndId < _settings.drawingTokenStartId ||\n            _settings.drawingTokenEndId - _settings.drawingTokenStartId < 2\n        ) {\n            revert DRAWING_TOKEN_RANGE_INVALID();\n        }\n\n        // Setup owner as admin\n        __Ownable_init(admin);\n\n        // Emit initialized event for indexing\n        emit InitializedDraw(msg.sender, settings);\n\n        // Get owner of raffled tokenId and ensure the current owner is the admin\n        try\n            IERC721EnumerableUpgradeable(_settings.token).ownerOf(\n                _settings.tokenId\n            )\n        returns (address nftOwner) {\n            // Check if address is the admin address\n            if (nftOwner != admin) {\n                revert DOES_NOT_OWN_NFT();\n            }\n        } catch {\n            revert TOKEN_BEING_OFFERED_NEEDS_TO_EXIST();\n        }\n    }\n\n    /// @notice Internal function to request entropy\n    function _requestRoll() internal {\n        // Chainlink request cannot be currently in flight.\n        // Request is cleared in re-roll if conditions are correct.\n        if (request.currentChainlinkRequestId != 0) {\n            revert REQUEST_IN_FLIGHT();\n        }\n\n        // If the number has been drawn and\n        if (\n            request.hasChosenRandomNumber &&\n            // Draw timelock not yet used\n            request.drawTimelock != 0 &&\n            request.drawTimelock > block.timestamp\n        ) {\n            revert STILL_IN_WAITING_PERIOD_BEFORE_REDRAWING();\n        }\n\n        // Setup re-draw timelock\n        request.drawTimelock = block.timestamp + settings.drawBufferTime;\n\n        // Request first random round\n        request.currentChainlinkRequestId = coordinator.requestRandomWords({\n            keyHash: settings.keyHash,\n            subId: settings.subscriptionId,\n            minimumRequestConfirmations: minimumRequestConfirmations,\n            callbackGasLimit: callbackGasLimit,\n            numWords: wordsRequested\n        });\n    }\n\n    /// @notice Call this to start the raffle drawing\n    /// @return chainlink request id\n    function startDraw() external onlyOwner returns (uint256) {\n        // Only can be called on first drawing\n        if (request.currentChainlinkRequestId != 0) {\n            revert REQUEST_IN_FLIGHT();\n        }\n\n        // Emit setup draw user event\n        emit SetupDraw(msg.sender, settings);\n\n        // Request initial roll\n        _requestRoll();\n\n        // Attempt to transfer token into this address\n        try\n            IERC721EnumerableUpgradeable(settings.token).transferFrom(\n                msg.sender,\n                address(this),\n                settings.tokenId\n            )\n        {} catch {\n            revert TOKEN_NEEDS_TO_BE_APPROVED_TO_CONTRACT();\n        }\n\n        // Return the current chainlink request id\n        return request.currentChainlinkRequestId;\n    }\n\n    /// @notice Call this to re-draw the raffle\n    /// @return chainlink request ID\n    /// @dev Only callable by the owner\n    function redraw() external onlyOwner returns (uint256) {\n        if (request.drawTimelock >= block.timestamp) {\n            revert TOO_SOON_TO_REDRAW();\n        }\n\n        // Reset request\n        delete request;\n\n        // Re-roll\n        _requestRoll();\n\n        // Owner of token to raffle needs to be this contract\n        if (\n            IERC721EnumerableUpgradeable(settings.token).ownerOf(\n                settings.tokenId\n            ) != address(this)\n        ) {\n            revert DOES_NOT_OWN_NFT();\n        }\n\n        // Return current chainlink request ID\n        return request.currentChainlinkRequestId;\n    }\n\n    /// @notice Function called by chainlink to resolve random words\n    /// @param _requestId ID of request sent to chainlink VRF\n    /// @param _randomWords List of uint256 words of random entropy\n    function fulfillRandomWords(\n        uint256 _requestId,\n        uint256[] memory _randomWords\n    ) internal override {\n        // Validate request ID\n        if (_requestId != request.currentChainlinkRequestId) {\n            revert REQUEST_DOES_NOT_MATCH_CURRENT_ID();\n        }\n\n        // Validate number of words returned\n        // Words requested is an immutable set to 1\n        if (_randomWords.length != wordsRequested) {\n            revert WRONG_LENGTH_FOR_RANDOM_WORDS();\n        }\n\n        // Set request details\n        request.hasChosenRandomNumber = true;\n\n        // Get total token range\n        uint256 tokenRange = settings.drawingTokenEndId -\n            settings.drawingTokenStartId;\n\n        // Store a number from it here (reduce number here to reduce gas usage)\n        // We know there will only be 1 word sent at this point.\n        request.currentChosenTokenId =\n            (_randomWords[0] % tokenRange) +\n            settings.drawingTokenStartId;\n\n        // Emit completed event.\n        emit DiceRollComplete(msg.sender, request);\n    }\n\n    /// @notice Function to determine if the user has won in the current drawing\n    /// @param user address for the user to check if they have won in the current drawing\n    function hasUserWon(address user) public view returns (bool) {\n        if (!request.hasChosenRandomNumber) {\n            revert NEEDS_TO_HAVE_CHOSEN_A_NUMBER();\n        }\n\n        return\n            user ==\n            IERC721EnumerableUpgradeable(settings.drawingToken).ownerOf(\n                request.currentChosenTokenId\n            );\n    }\n\n    /// @notice Function for the winner to call to retrieve their NFT\n    function winnerClaimNFT() external {\n        // Assume (potential) winner calls this fn, cache.\n        address user = msg.sender;\n\n        // Check if this user has indeed won.\n        if (!hasUserWon(user)) {\n            revert USER_HAS_NOT_WON();\n        }\n\n        // Emit a celebratory event\n        emit WinnerSentNFT(\n            user,\n            address(settings.token),\n            settings.tokenId,\n            settings\n        );\n\n        // Transfer token to the winter.\n        IERC721EnumerableUpgradeable(settings.token).transferFrom(\n            address(this),\n            msg.sender,\n            settings.tokenId\n        );\n    }\n\n    /// @notice Optional last resort admin reclaim nft function\n    /// @dev Only callable by the owner\n    function lastResortTimelockOwnerClaimNFT() external onlyOwner {\n        // If recoverTimelock is not setup, or if not yet occurred\n        if (settings.recoverTimelock > block.timestamp) {\n            // Stop the withdraw\n            revert RECOVERY_IS_NOT_YET_POSSIBLE();\n        }\n\n        // Send event for indexing that the owner reclaimed the NFT\n        emit OwnerReclaimedNFT(owner());\n\n        // Transfer token to the admin/owner.\n        IERC721EnumerableUpgradeable(settings.token).transferFrom(\n            address(this),\n            owner(),\n            settings.tokenId\n        );\n    }\n}"
    },
    {
      "filename": "src/interfaces/IVRFNFTRandomDraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IVRFNFTRandomDraw {\n    /// @notice Cannot redraw during waiting period\n    error STILL_IN_WAITING_PERIOD_BEFORE_REDRAWING();\n    /// @notice Admin emergency withdraw can only happen once unlocked\n    error RECOVERY_IS_NOT_YET_POSSIBLE();\n    /// @notice Token that is offered does not exist with ownerOf\n    error TOKEN_BEING_OFFERED_NEEDS_TO_EXIST();\n    /// @notice Token needs to be a contract when initializing\n    error TOKEN_NEEDS_TO_BE_A_CONTRACT(address potentialTokenAddress);\n    /// @notice Token needs to be approved to raffle contract\n    error TOKEN_NEEDS_TO_BE_APPROVED_TO_CONTRACT();\n    /// @notice Waiting on a response from chainlink\n    error REQUEST_IN_FLIGHT();\n    /// @notice Chainlink VRF response doesn't match current ID\n    error REQUEST_DOES_NOT_MATCH_CURRENT_ID();\n    /// @notice The tokens' totalSupply doesn't match one claimed on contract\n    error SUPPLY_TOKENS_COUNT_WRONG();\n    /// @notice Cannot attempt to claim winnings if request is not started or in flight\n    error NEEDS_TO_HAVE_CHOSEN_A_NUMBER();\n\n    /// @notice When the range is [20,0] (from 20 to 0, that doesn't make sense)\n    error DRAWING_TOKEN_RANGE_INVALID();\n    /// @notice Withdraw timelock min is 1 hour\n    error REDRAW_TIMELOCK_NEEDS_TO_BE_MORE_THAN_AN_HOUR();\n    error REDRAW_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_MONTH();\n    /// @notice Admin NFT recovery timelock min is 1 week\n    error RECOVER_TIMELOCK_NEEDS_TO_BE_AT_LEAST_A_WEEK();\n    /// @notice Admin NFT recovery timelock max is 1 year\n    error RECOVER_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_YEAR();\n    /// @notice The given user has not won\n    error USER_HAS_NOT_WON();\n    /// @notice Cannot re-draw yet\n    error TOO_SOON_TO_REDRAW();\n    /// @notice NFT for raffle is not owned by the admin\n    error DOES_NOT_OWN_NFT();\n    /// @notice Too many / few random words are sent back from chainlink\n    error WRONG_LENGTH_FOR_RANDOM_WORDS();\n\n    /// @notice When the draw is initialized\n    event InitializedDraw(address indexed sender, Settings settings);\n    /// @notice When the draw is setup\n    event SetupDraw(address indexed sender, Settings settings);\n    /// @notice When the owner reclaims nft aftr recovery time delay\n    event OwnerReclaimedNFT(address indexed owner);\n    /// @notice Dice roll is complete from callback\n    event DiceRollComplete(address indexed sender, CurrentRequest request);\n    /// @notice Sent when the winner sends/claims an NFT\n    event WinnerSentNFT(\n        address indexed winner,\n        address indexed nft,\n        uint256 indexed tokenId,\n        Settings settings\n    );\n\n    /// @notice Struct to organize current request\n    struct CurrentRequest {\n        /// @notice current chainlink request id\n        uint256 currentChainlinkRequestId;\n        /// @notice current chosen random number\n        uint256 currentChosenTokenId;\n        /// @notice has chosen a random number (in case random number = 0(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0))\n        bool hasChosenRandomNumber;\n        /// @notice time lock (block.timestamp) that a re-draw can be issued\n        uint256 drawTimelock;\n    }\n\n    /// @notice Struct to organize user settings\n    struct Settings {\n        /// @notice Token Contract to put up for raffle\n        address token;\n        /// @notice Token ID to put up for raffle\n        uint256 tokenId;\n        /// @notice Token that each (sequential) ID has a entry in the raffle.\n        address drawingToken;\n        /// @notice Start token ID for the drawing (if totalSupply = 20 but the first token is 5 (5-25), setting this to 5 would fix the ordering)\n        uint256 drawingTokenStartId;\n        /// @notice End token ID for the drawing (exclusive) (token ids 0 - 9 would be 10 in this field)\n        uint256 drawingTokenEndId;\n        /// @notice Draw buffer time – time until a re-drawing can occur if the selected user cannot or does not claim the NFT.\n        uint256 drawBufferTime;\n        /// @notice block.timestamp that the admin ca"
    }
  ]
}