{
  "Title": "[M-11] `CollectionBatchBuyOperator.sol`: `tokenIds` array is not shortened properly which makes execute function revert when not all NFTs are purchased successfully",
  "Content": "\nThe [`CollectionBatchBuyOperator`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L14-L224) contract allows parties to buy NFTs through proposals.\n\nThe proposal specifies an `nftContract` and token IDs (via the `nftTokenIdsMerkleRoot` parameter) that can be bought.\n\nAllowed `executors` can then execute the actual purchase by executing the proposal and providing execution data.\n\nThe execution data specifies which token IDs to buy, where to buy them from and the price to buy the tokens for.\n\nThe `CollectionBatchBuyOperator.execute` function is supposed to succeed even when not all purchases are successful.\n\nThis is achieved by skipping over failed purchases:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L132-L137)\n\n```solidity\n{\n    // Execute the call to buy the NFT.\n    (bool success, ) = _buy(call.target, callValue, call.data);\n\n\n    if (!success) continue;\n}\n```\n\nLater in the function the NFTs that have been bought are transferred to the party:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L186-L188)\n\n```solidity\nfor (uint256 i; i < tokenIds.length; ++i) {\n    op.nftContract.safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n}\n```\n\nIf at least one NFT purchase has failed, the `tokenIds` array is bigger than the amount of NFTs that has actually been purchased. In other words there are empty spots at the end of the `tokenIds` array, i.e. the value that is stored there is zero.\n\nTherefore, before transferring the NFTs, the `tokenIds` array needs to be shortened such that it is not attempted to transfer `tokenId=0`.\n\nThe contract uses the following code to achieve this:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L180-L183)\n\n```solidity\nassembly {\n    // Update length of `tokenIds`\n    mstore(mload(ex), tokensBought)\n}\n```\n\nThis code is wrong as I will explain later.\n\nThe impact of this is that when not all purchases are successful the function reverts because it attempts to transfer the `tokenId=0` (since there are empty spots in the `tokenIds` array and the array is not shortened).\n\nSo the execution of the proposal will fail when it should actually succeed.\n\n### Proof of Concept\n\nLet's have a look again at the code to shorten the `tokenIds` array:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L180-L183)\n\n```solidity\nassembly {\n    // Update length of `tokenIds`\n    mstore(mload(ex), tokensBought)\n}\n```\n\nIt loads the first 32 bytes of `ex` from memory (`ex` is a `CollectionBatchBuyExecutionData` struct) and stores `tokensBought` in the memory location where the 32 bytes point to.\n\nThis has nothing to do with shortening the `tokenIds` array.\n\nThe correct code would be:\n\n```solidity\nassembly {\n    // Update length of `tokenIds`\n    mstore(tokenIds, tokensBought)\n}\n```\n\nThis writes `tokensBought` to the first 32 bytes slot of the `tokenIds` array which is where the size of the array is stored.\n\nThere exists a test case for this scenario in the `CollectionBatchBuyOperator.t.sol` test file. However the test contains an error which makes the test pass even though the `tokenIds` array is not shortened.\n\nApply these changes to the test file:\n\n```diff\ndiff --git a/sol-tests/operators/CollectionBatchBuyOperator.t.sol b/sol-tests/operators/CollectionBatchBuyOperator.t.sol\nindex 3956e84..a944c74 100644\n--- a/sol-tests/operators/CollectionBatchBuyOperator.t.sol\n+++ b/sol-tests/operators/CollectionBatchBuyOperator.t.sol\n@@ -165,7 +165,7 @@ contract CollectionBatchBuyOperatorTest is Test, TestUtils, ERC721Receiver {\n         bytes memory executionData = abi.encode(\n             CollectionBatchBuyOperator.CollectionBatchBuyExecutionData({\n                 calls: calls,\n-                numOfTokens: 2\n+                numOfTokens: 3\n             })\n         );\n```\n\nNotice that when running the test (with the changes to the test file applied) it fails since the `tokenIds` array is not shortened properly.\n\nThen also apply the changes to the source file (shortening the array properly) and see that the test passes.\n\n### Tools Used\n\nVSCode, Foundry\n\n### Recommended Mitigation Steps\n\nAs explained above, this is how to properly shorten the `tokenIds` array:\n\n```diff\ndiff --git a/contracts/operators/CollectionBatchBuyOperator.sol b/contracts/operators/CollectionBatchBuyOperator.sol\nindex 4b1dcc9..fffa5e9 100644\n--- a/contracts/operators/CollectionBatchBuyOperator.sol\n+++ b/contracts/operators/CollectionBatchBuyOperator.sol\n@@ -179,7 +179,7 @@ contract CollectionBatchBuyOperator is IOperator {\n \n         assembly {\n             // Update length of `tokenIds`\n-            mstore(mload(ex), tokensBought)\n+            mstore(tokenIds, tokensBought)\n         }\n```\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-04-party-findings/issues/4#issuecomment-1512077491)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-party",
  "Code": [
    {
      "filename": "contracts/operators/CollectionBatchBuyOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IOperator.sol\";\nimport \"../party/Party.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/// @notice A crowdfund that purchases a specific NFT (i.e., with a known token\n///         ID) listing for a known price.\ncontract CollectionBatchBuyOperator is IOperator {\n    using LibRawResult for bytes;\n    using LibSafeERC721 for IERC721;\n    using LibAddress for address payable;\n\n    struct CollectionBatchBuyOperationData {\n        /// The contract of NFTs to buy.\n        IERC721 nftContract;\n        /// The merkle root of the token IDs that can be bought. If null,\n        /// allow any token ID in the collection can be bought.\n        bytes32 nftTokenIdsMerkleRoot;\n        // Maximum amount this crowdfund will pay for an NFT.\n        uint256 maximumPrice;\n        // Minimum number of tokens that must be purchased. If this limit is\n        // not reached, the batch buy will fail.\n        uint256 minTokensBought;\n        // Minimum amount of ETH that must be used to buy the tokens. If this\n        // amount is not reached, the batch buy will fail.\n        uint256 minTotalEthUsed;\n    }\n\n    struct TokenToBuy {\n        // The token ID of the NFT to buy.\n        uint256 tokenId;\n        // The price of the token. This cannot be greater than `maximumPrice`.\n        uint96 price;\n        // The proof needed to verify that the token ID is included in the\n        // `nftTokenIdsMerkleRoot` (if it is not null).\n        bytes32[] proof;\n    }\n\n    struct BuyCall {\n        // The contract to call to buy the NFTs in `tokensToBuy`.\n        address payable target;\n        // The calldata to call `target` with to buy the NFTs in `tokensToBuy`.\n        bytes data;\n        // The tokens to try buying with this call.\n        TokenToBuy[] tokensToBuy;\n    }\n\n    struct CollectionBatchBuyExecutionData {\n        // The calls made to buy the NFTs. Each call has a target, data, and\n        // the tokens to buy in that call.\n        BuyCall[] calls;\n        // The total number of tokens that can be bought in this batch buy. This\n        // should be equal to the sum of the each `tokensToBuy` in `calls`.\n        uint256 numOfTokens;\n    }\n\n    event CollectionBatchBuyOperationExecuted(\n        Party party,\n        IERC721 token,\n        uint256[] tokenIdsBought,\n        uint256 totalEthUsed\n    );\n\n    error NothingBoughtError();\n    error InvalidMinTokensBoughtError(uint256 minTokensBought);\n    error InvalidTokenIdError();\n    error NotEnoughTokensBoughtError(uint256 tokensBought, uint256 minTokensBought);\n    error NotEnoughEthUsedError(uint256 ethUsed, uint256 minTotalEthUsed);\n    error MaximumPriceError(uint256 callValue, uint256 maximumPrice);\n    error CallProhibitedError(address target, bytes data);\n    error NumOfTokensCannotBeLessThanMin(uint256 numOfTokens, uint256 min);\n    error EthUsedForFailedBuyError(uint256 expectedEthUsed, uint256 actualEthUsed);\n\n    function execute(bytes memory operatorData, bytes memory executionData) external payable {\n        // Decode the operator data.\n        CollectionBatchBuyOperationData memory op = abi.decode(\n            operatorData,\n            (CollectionBatchBuyOperationData)\n        );\n\n        // Decode the execution data.\n        CollectionBatchBuyExecutionData memory ex = abi.decode(\n            executionData,\n            (CollectionBatchBuyExecutionData)\n        );\n\n        if (op.minTokensBought == 0) {\n            // Must buy at least one token.\n            revert InvalidMinTokensBoughtError(0);\n        }\n\n        if (ex.numOfTokens < op.minTokensBought) {\n            // The number of tokens to buy must be greater than or equal to the\n            // minimum number of tokens to buy.\n            revert NumOfTokensCannotBeLessThanMin(ex.numOfTokens, op.minTokensBought);\n        }\n\n        // Lengths of arrays are updated at the end.\n        uint256[] memory tokenIds = new uint256[](ex.numOfTokens);\n\n        uint96 totalEthUsed;\n        uint256 tokensBought;\n        for (uint256 i; i < ex.calls.length; ++i) {\n            BuyCall memory call = ex.calls[i];\n\n            uint96 callValue;\n            for (uint256 j; j < call.tokensToBuy.length; ++j) {\n                TokenToBuy memory tokenToBuy = call.tokensToBuy[j];\n\n                if (op.nftTokenIdsMerkleRoot != bytes32(0)) {\n                    // Verify the token ID is in the merkle tree.\n                    _verifyTokenId(tokenToBuy.tokenId, op.nftTokenIdsMerkleRoot, tokenToBuy.proof);\n                }\n\n                // Check that the call value is under the maximum price.\n                uint96 price = tokenToBuy.price;\n                if (price > op.maximumPrice) {\n                    revert MaximumPriceError(price, op.maximumPrice);\n                }\n\n                // Add the price to the total value used for the call.\n                callValue += price;\n            }\n\n            uint256 balanceBefore = address(this).balance;\n            {\n                // Execute the call to buy the NFT.\n                (bool success, ) = _buy(call.target, callValue, call.data);\n\n                if (!success) continue;\n            }\n\n            {\n                uint96 ethUsed;\n                for (uint256 j; j < call.tokensToBuy.length; ++j) {\n                    uint256 tokenId = call.tokensToBuy[j].tokenId;\n                    uint96 price = call.tokensToBuy[j].price;\n\n                    // Check whether the NFT was successfully bought.\n                    if (op.nftContract.safeOwnerOf(tokenId) == address(this)) {\n                        ethUsed += price;\n                        ++tokensBought;\n\n                        // Add the token to the list of tokens to finalize.\n                        tokenIds[tokensBought - 1] = tokenId;\n                    }\n                }\n\n                // Check ETH spent for call is what was expected.\n                uint256 actualEthUsed = balanceBefore - address(this).balance;\n                if (ethUsed != actualEthUsed) {\n                    revert EthUsedForFailedBuyError(ethUsed, actualEthUsed);\n                }\n\n                totalEthUsed += ethUsed;\n            }\n        }\n\n        // This is to prevent this crowdfund from finalizing a loss if nothing\n        // was attempted to be bought (ie. `tokenIds` is empty) or all NFTs were\n        // bought for free.\n        if (totalEthUsed == 0) revert NothingBoughtError();\n\n        // Check number of tokens bought is not less than the minimum.\n        if (tokensBought < op.minTokensBought) {\n            revert NotEnoughTokensBoughtError(tokensBought, op.minTokensBought);\n        }\n\n        // Check total ETH used is not less than the minimum.\n        if (totalEthUsed < op.minTotalEthUsed) {\n            revert NotEnoughEthUsedError(totalEthUsed, op.minTotalEthUsed);\n        }\n\n        assembly {\n            // Update length of `tokenIds`\n            mstore(mload(ex), tokensBought)\n        }\n\n        // Transfer the NFTs to the party.\n        for (uint256 i; i < tokenIds.length; ++i) {\n            op.nftContract.safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n        }\n\n        // Transfer unused ETH to the party.\n        uint256 unusedEth = msg.value - totalEthUsed;\n        if (unusedEth > 0) payable(msg.sender).transferEth(unusedEth);\n\n        emit CollectionBatchBuyOperationExecuted(\n            Party(payable(msg.sender)),\n            op.nftContract,\n            tokenIds,\n            totalEthUsed\n        );\n    }\n\n    function _buy(\n        address payable callTarget,\n        uint96 callValue,\n        bytes memory callData\n    ) private returns (bool success, bytes memory revertData) {\n        // Check that call is not re-entering.\n        if (callTarget == address(this)) {\n            revert CallProhibitedError(callTarget, callData);\n        }\n        // Execute the call to buy the NFT.\n        (success, revertData) = callTarget.call{ value: callValue }(callData);\n    }\n\n    function _verifyTokenId(uint256 tokenId, bytes32 root, bytes32[] memory proof) private pure {\n        bytes32 leaf;\n        assembly {\n            mstore(0x00, tokenId)\n            leaf := keccak256(0x00, 0x20)\n        }\n\n        if (!MerkleProof.verify(proof, root, leaf)) revert InvalidTokenIdError();\n    }\n}"
    },
    {
      "filename": "contracts/operators/CollectionBatchBuyOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IOperator.sol\";\nimport \"../party/Party.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/// @notice A crowdfund that purchases a specific NFT (i.e., with a known token\n///         ID) listing for a known price.\ncontract CollectionBatchBuyOperator is IOperator {\n    using LibRawResult for bytes;\n    using LibSafeERC721 for IERC721;\n    using LibAddress for address payable;\n\n    struct CollectionBatchBuyOperationData {\n        /// The contract of NFTs to buy.\n        IERC721 nftContract;\n        /// The merkle root of the token IDs that can be bought. If null,\n        /// allow any token ID in the collection can be bought.\n        bytes32 nftTokenIdsMerkleRoot;\n        // Maximum amount this crowdfund will pay for an NFT.\n        uint256 maximumPrice;\n        // Minimum number of tokens that must be purchased. If this limit is\n        // not reached, the batch buy will fail.\n        uint256 minTokensBought;\n        // Minimum amount of ETH that must be used to buy the tokens. If this\n        // amount is not reached, the batch buy will fail.\n        uint256 minTotalEthUsed;\n    }\n\n    struct TokenToBuy {\n        // The token ID of the NFT to buy.\n        uint256 tokenId;\n        // The price of the token. This cannot be greater than `maximumPrice`.\n        uint96 price;\n        // The proof needed to verify that the token ID is included in the\n        // `nftTokenIdsMerkleRoot` (if it is not null).\n        bytes32[] proof;\n    }\n\n    struct BuyCall {\n        // The contract to call to buy the NFTs in `tokensToBuy`.\n        address payable target;\n        // The calldata to call `target` with to buy the NFTs in `tokensToBuy`.\n        bytes data;\n        // The tokens to try buying with this call.\n        TokenToBuy[] tokensToBuy;\n    }\n\n    struct CollectionBatchBuyExecutionData {\n        // The calls made to buy the NFTs. Each call has a target, data, and\n        // the tokens to buy in that call.\n        BuyCall[] calls;\n        // The total number of tokens that can be bought in this batch buy. This\n        // should be equal to the sum of the each `tokensToBuy` in `calls`.\n        uint256 numOfTokens;\n    }\n\n    event CollectionBatchBuyOperationExecuted(\n        Party party,\n        IERC721 token,\n        uint256[] tokenIdsBought,\n        uint256 totalEthUsed\n    );\n\n    error NothingBoughtError();\n    error InvalidMinTokensBoughtError(uint256 minTokensBought);\n    error InvalidTokenIdError();\n    error NotEnoughTokensBoughtError(uint256 tokensBought, uint256 minTokensBought);\n    error NotEnoughEthUsedError(uint256 ethUsed, uint256 minTotalEthUsed);\n    error MaximumPriceError(uint256 callValue, uint256 maximumPrice);\n    error CallProhibitedError(address target, bytes data);\n    error NumOfTokensCannotBeLessThanMin(uint256 numOfTokens, uint256 min);\n    error EthUsedForFailedBuyError(uint256 expectedEthUsed, uint256 actualEthUsed);\n\n    function execute(bytes memory operatorData, bytes memory executionData) external payable {\n        // Decode the operator data.\n        CollectionBatchBuyOperationData memory op = abi.decode(\n            operatorData,\n            (CollectionBatchBuyOperationData)\n        );\n\n        // Decode the execution data.\n        CollectionBatchBuyExecutionData memory ex = abi.decode(\n            executionData,\n            (CollectionBatchBuyExecutionData)\n        );\n\n        if (op.minTokensBought == 0) {\n            // Must buy at least one token.\n            revert InvalidMinTokensBoughtError(0);\n        }\n\n        if (ex.numOfTokens < op.minTokensBought) {\n            // The number of tokens to buy must be greater than or equal to the\n            // minimum number of tokens to buy.\n            revert NumOfTokensCannotBeLessThanMin(ex.numOfTokens, op.minTokensBought);\n        }\n\n        // Lengths of arrays are updated at the end.\n        uint256[] memory tokenIds = new uint256[](ex.numOfTokens);\n\n        uint96 totalEthUsed;\n        uint256 tokensBought;\n        for (uint256 i; i < ex.calls.length; ++i) {\n            BuyCall memory call = ex.calls[i];\n\n            uint96 callValue;\n            for (uint256 j; j < call.tokensToBuy.length; ++j) {\n                TokenToBuy memory tokenToBuy = call.tokensToBuy[j];\n\n                if (op.nftTokenIdsMerkleRoot != bytes32(0)) {\n                    // Verify the token ID is in the merkle tree.\n                    _verifyTokenId(tokenToBuy.tokenId, op.nftTokenIdsMerkleRoot, tokenToBuy.proof);\n                }\n\n                // Check that the call value is under the maximum price.\n                uint96 price = tokenToBuy.price;\n                if (price > op.maximumPrice) {\n                    revert MaximumPriceError(price, op.maximumPrice);\n                }\n\n                // Add the price to the total value used for the call.\n                callValue += price;\n            }\n\n            uint256 balanceBefore = address(this).balance;\n            {\n                // Execute the call to buy the NFT.\n                (bool success, ) = _buy(call.target, callValue, call.data);\n\n                if (!success) continue;\n            }\n\n            {\n                uint96 ethUsed;\n                for (uint256 j; j < call.tokensToBuy.length; ++j) {\n                    uint256 tokenId = call.tokensToBuy[j].tokenId;\n                    uint96 price = call.tokensToBuy[j].price;\n\n                    // Check whether the NFT was successfully bought.\n                    if (op.nftContract.safeOwnerOf(tokenId) == address(this)) {\n                        ethUsed += price;\n                        ++tokensBought;\n\n                        // Add the token to the list of tokens to finalize.\n                        tokenIds[tokensBought - 1] = tokenId;\n                    }\n                }\n\n                // Check ETH spent for call is what was expected.\n                uint256 actualEthUsed = balanceBefore - address(this).balance;\n                if (ethUsed != actualEthUsed) {\n                    revert EthUsedForFailedBuyError(ethUsed, actualEthUsed);\n                }\n\n                totalEthUsed += ethUsed;\n            }\n        }\n\n        // This is to prevent this crowdfund from finalizing a loss if nothing\n        // was attempted to be bought (ie. `tokenIds` is empty) or all NFTs were\n        // bought for free.\n        if (totalEthUsed == 0) revert NothingBoughtError();\n\n        // Check number of tokens bought is not less than the minimum.\n        if (tokensBought < op.minTokensBought) {\n            revert NotEnoughTokensBoughtError(tokensBought, op.minTokensBought);\n        }\n\n        // Check total ETH used is not less than the minimum.\n        if (totalEthUsed < op.minTotalEthUsed) {\n            revert NotEnoughEthUsedError(totalEthUsed, op.minTotalEthUsed);\n        }\n\n        assembly {\n            // Update length of `tokenIds`\n            mstore(mload(ex), tokensBought)\n        }\n\n        // Transfer the NFTs to the party.\n        for (uint256 i; i < tokenIds.length; ++i) {\n            op.nftContract.safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n        }\n\n        // Transfer unused ETH to the party.\n        uint256 unusedEth = msg.value - totalEthUsed;\n        if (unusedEth > 0) payable(msg.sender).transferEth(unusedEth);\n\n        emit CollectionBatchBuyOperationExecuted(\n            Party(payable(msg.sender)),\n            op.nftContract,\n            tokenIds,\n            totalEthUsed\n        );\n    }\n\n    function _buy(\n        address payable callTarget,\n        uint96 callValue,\n        bytes memory callData\n    ) private returns (bool success, bytes memory revertData) {\n        // Check that call is not re-entering.\n        if (callTarget == address(this)) {\n            revert CallProhibitedError(callTarget, callData);\n        }\n        // Execute the call to buy the NFT.\n        (success, revertData) = callTarget.call{ value: callValue }(callData);\n    }\n\n    function _verifyTokenId(uint256 tokenId, bytes32 root, bytes32[] memory proof) private pure {\n        bytes32 leaf;\n        assembly {\n            mstore(0x00, tokenId)\n            leaf := keccak256(0x00, 0x20)\n        }\n\n        if (!MerkleProof.verify(proof, root, leaf)) revert InvalidTokenIdError();\n    }\n}"
    },
    {
      "filename": "contracts/operators/CollectionBatchBuyOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IOperator.sol\";\nimport \"../party/Party.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/// @notice A crowdfund that purchases a specific NFT (i.e., with a known token\n///         ID) listing for a known price.\ncontract CollectionBatchBuyOperator is IOperator {\n    using LibRawResult for bytes;\n    using LibSafeERC721 for IERC721;\n    using LibAddress for address payable;\n\n    struct CollectionBatchBuyOperationData {\n        /// The contract of NFTs to buy.\n        IERC721 nftContract;\n        /// The merkle root of the token IDs that can be bought. If null,\n        /// allow any token ID in the collection can be bought.\n        bytes32 nftTokenIdsMerkleRoot;\n        // Maximum amount this crowdfund will pay for an NFT.\n        uint256 maximumPrice;\n        // Minimum number of tokens that must be purchased. If this limit is\n        // not reached, the batch buy will fail.\n        uint256 minTokensBought;\n        // Minimum amount of ETH that must be used to buy the tokens. If this\n        // amount is not reached, the batch buy will fail.\n        uint256 minTotalEthUsed;\n    }\n\n    struct TokenToBuy {\n        // The token ID of the NFT to buy.\n        uint256 tokenId;\n        // The price of the token. This cannot be greater than `maximumPrice`.\n        uint96 price;\n        // The proof needed to verify that the token ID is included in the\n        // `nftTokenIdsMerkleRoot` (if it is not null).\n        bytes32[] proof;\n    }\n\n    struct BuyCall {\n        // The contract to call to buy the NFTs in `tokensToBuy`.\n        address payable target;\n        // The calldata to call `target` with to buy the NFTs in `tokensToBuy`.\n        bytes data;\n        // The tokens to try buying with this call.\n        TokenToBuy[] tokensToBuy;\n    }\n\n    struct CollectionBatchBuyExecutionData {\n        // The calls made to buy the NFTs. Each call has a target, data, and\n        // the tokens to buy in that call.\n        BuyCall[] calls;\n        // The total number of tokens that can be bought in this batch buy. This\n        // should be equal to the sum of the each `tokensToBuy` in `calls`.\n        uint256 numOfTokens;\n    }\n\n    event CollectionBatchBuyOperationExecuted(\n        Party party,\n        IERC721 token,\n        uint256[] tokenIdsBought,\n        uint256 totalEthUsed\n    );\n\n    error NothingBoughtError();\n    error InvalidMinTokensBoughtError(uint256 minTokensBought);\n    error InvalidTokenIdError();\n    error NotEnoughTokensBoughtError(uint256 tokensBought, uint256 minTokensBought);\n    error NotEnoughEthUsedError(uint256 ethUsed, uint256 minTotalEthUsed);\n    error MaximumPriceError(uint256 callValue, uint256 maximumPrice);\n    error CallProhibitedError(address target, bytes data);\n    error NumOfTokensCannotBeLessThanMin(uint256 numOfTokens, uint256 min);\n    error EthUsedForFailedBuyError(uint256 expectedEthUsed, uint256 actualEthUsed);\n\n    function execute(bytes memory operatorData, bytes memory executionData) external payable {\n        // Decode the operator data.\n        CollectionBatchBuyOperationData memory op = abi.decode(\n            operatorData,\n            (CollectionBatchBuyOperationData)\n        );\n\n        // Decode the execution data.\n        CollectionBatchBuyExecutionData memory ex = abi.decode(\n            executionData,\n            (CollectionBatchBuyExecutionData)\n        );\n\n        if (op.minTokensBought == 0) {\n            // Must buy at least one token.\n            revert InvalidMinTokensBoughtError(0);\n        }\n\n        if (ex.numOfTokens < op.minTokensBought) {\n            // The number of tokens to buy must be greater than or equal to the\n            // minimum number of tokens to buy.\n            revert NumOfTokensCannotBeLessThanMin(ex.numOfTokens, op.minTokensBought);\n        }\n\n        // Lengths of arrays are updated at the end.\n        uint256[] memory tokenIds = new uint256[](ex.numOfTokens);\n\n        uint96 totalEthUsed;\n        uint256 tokensBought;\n        for (uint256 i; i < ex.calls.length; ++i) {\n            BuyCall memory call = ex.calls[i];\n\n            uint96 callValue;\n            for (uint256 j; j < call.tokensToBuy.length; ++j) {\n                TokenToBuy memory tokenToBuy = call.tokensToBuy[j];\n\n                if (op.nftTokenIdsMerkleRoot != bytes32(0)) {\n                    // Verify the token ID is in the merkle tree.\n                    _verifyTokenId(tokenToBuy.tokenId, op.nftTokenIdsMerkleRoot, tokenToBuy.proof);\n                }\n\n                // Check that the call value is under the maximum price.\n                uint96 price = tokenToBuy.price;\n                if (price > op.maximumPrice) {\n                    revert MaximumPriceError(price, op.maximumPrice);\n                }\n\n                // Add the price to the total value used for the call.\n                callValue += price;\n            }\n\n            uint256 balanceBefore = address(this).balance;\n            {\n                // Execute the call to buy the NFT.\n                (bool success, ) = _buy(call.target, callValue, call.data);\n\n                if (!success) continue;\n            }\n\n            {\n                uint96 ethUsed;\n                for (uint256 j; j < call.tokensToBuy.length; ++j) {\n                    uint256 tokenId = call.tokensToBuy[j].tokenId;\n                    uint96 price = call.tokensToBuy[j].price;\n\n                    // Check whether the NFT was successfully bought.\n                    if (op.nftContract.safeOwnerOf(tokenId) == address(this)) {\n                        ethUsed += price;\n                        ++tokensBought;\n\n                        // Add the token to the list of tokens to finalize.\n                        tokenIds[tokensBought - 1] = tokenId;\n                    }\n                }\n\n                // Check ETH spent for call is what was expected.\n                uint256 actualEthUsed = balanceBefore - address(this).balance;\n                if (ethUsed != actualEthUsed) {\n                    revert EthUsedForFailedBuyError(ethUsed, actualEthUsed);\n                }\n\n                totalEthUsed += ethUsed;\n            }\n        }\n\n        // This is to prevent this crowdfund from finalizing a loss if nothing\n        // was attempted to be bought (ie. `tokenIds` is empty) or all NFTs were\n        // bought for free.\n        if (totalEthUsed == 0) revert NothingBoughtError();\n\n        // Check number of tokens bought is not less than the minimum.\n        if (tokensBought < op.minTokensBought) {\n            revert NotEnoughTokensBoughtError(tokensBought, op.minTokensBought);\n        }\n\n        // Check total ETH used is not less than the minimum.\n        if (totalEthUsed < op.minTotalEthUsed) {\n            revert NotEnoughEthUsedError(totalEthUsed, op.minTotalEthUsed);\n        }\n\n        assembly {\n            // Update length of `tokenIds`\n            mstore(mload(ex), tokensBought)\n        }\n\n        // Transfer the NFTs to the party.\n        for (uint256 i; i < tokenIds.length; ++i) {\n            op.nftContract.safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n        }\n\n        // Transfer unused ETH to the party.\n        uint256 unusedEth = msg.value - totalEthUsed;\n        if (unusedEth > 0) payable(msg.sender).transferEth(unusedEth);\n\n        emit CollectionBatchBuyOperationExecuted(\n            Party(payable(msg.sender)),\n            op.nftContract,\n            tokenIds,\n            totalEthUsed\n        );\n    }\n\n    function _buy(\n        address payable callTarget,\n        uint96 callValue,\n        bytes memory callData\n    ) private returns (bool success, bytes memory revertData) {\n        // Check that call is not re-entering.\n        if (callTarget == address(this)) {\n            revert CallProhibitedError(callTarget, callData);\n        }\n        // Execute the call to buy the NFT.\n        (success, revertData) = callTarget.call{ value: callValue }(callData);\n    }\n\n    function _verifyTokenId(uint256 tokenId, bytes32 root, bytes32[] memory proof) private pure {\n        bytes32 leaf;\n        assembly {\n            mstore(0x00, tokenId)\n            leaf := keccak256(0x00, 0x20)\n        }\n\n        if (!MerkleProof.verify(proof, root, leaf)) revert InvalidTokenIdError();\n    }\n}"
    },
    {
      "filename": "contracts/operators/CollectionBatchBuyOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IOperator.sol\";\nimport \"../party/Party.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/// @notice A crowdfund that purchases a specific NFT (i.e., with a known token\n///         ID) listing for a known price.\ncontract CollectionBatchBuyOperator is IOperator {\n    using LibRawResult for bytes;\n    using LibSafeERC721 for IERC721;\n    using LibAddress for address payable;\n\n    struct CollectionBatchBuyOperationData {\n        /// The contract of NFTs to buy.\n        IERC721 nftContract;\n        /// The merkle root of the token IDs that can be bought. If null,\n        /// allow any token ID in the collection can be bought.\n        bytes32 nftTokenIdsMerkleRoot;\n        // Maximum amount this crowdfund will pay for an NFT.\n        uint256 maximumPrice;\n        // Minimum number of tokens that must be purchased. If this limit is\n        // not reached, the batch buy will fail.\n        uint256 minTokensBought;\n        // Minimum amount of ETH that must be used to buy the tokens. If this\n        // amount is not reached, the batch buy will fail.\n        uint256 minTotalEthUsed;\n    }\n\n    struct TokenToBuy {\n        // The token ID of the NFT to buy.\n        uint256 tokenId;\n        // The price of the token. This cannot be greater than `maximumPrice`.\n        uint96 price;\n        // The proof needed to verify that the token ID is included in the\n        // `nftTokenIdsMerkleRoot` (if it is not null).\n        bytes32[] proof;\n    }\n\n    struct BuyCall {\n        // The contract to call to buy the NFTs in `tokensToBuy`.\n        address payable target;\n        // The calldata to call `target` with to buy the NFTs in `tokensToBuy`.\n        bytes data;\n        // The tokens to try buying with this call.\n        TokenToBuy[] tokensToBuy;\n    }\n\n    struct CollectionBatchBuyExecutionData {\n        // The calls made to buy the NFTs. Each call has a target, data, and\n        // the tokens to buy in that call.\n        BuyCall[] calls;\n        // The total number of tokens that can be bought in this batch buy. This\n        // should be equal to the sum of the each `tokensToBuy` in `calls`.\n        uint256 numOfTokens;\n    }\n\n    event CollectionBatchBuyOperationExecuted(\n        Party party,\n        IERC721 token,\n        uint256[] tokenIdsBought,\n        uint256 totalEthUsed\n    );\n\n    error NothingBoughtError();\n    error InvalidMinTokensBoughtError(uint256 minTokensBought);\n    error InvalidTokenIdError();\n    error NotEnoughTokensBoughtError(uint256 tokensBought, uint256 minTokensBought);\n    error NotEnoughEthUsedError(uint256 ethUsed, uint256 minTotalEthUsed);\n    error MaximumPriceError(uint256 callValue, uint256 maximumPrice);\n    error CallProhibitedError(address target, bytes data);\n    error NumOfTokensCannotBeLessThanMin(uint256 numOfTokens, uint256 min);\n    error EthUsedForFailedBuyError(uint256 expectedEthUsed, uint256 actualEthUsed);\n\n    function execute(bytes memory operatorData, bytes memory executionData) external payable {\n        // Decode the operator data.\n        CollectionBatchBuyOperationData memory op = abi.decode(\n            operatorData,\n            (CollectionBatchBuyOperationData)\n        );\n\n        // Decode the execution data.\n        CollectionBatchBuyExecutionData memory ex = abi.decode(\n            executionData,\n            (CollectionBatchBuyExecutionData)\n        );\n\n        if (op.minTokensBought == 0) {\n            // Must buy at least one token.\n            revert InvalidMinTokensBoughtError(0);\n        }\n\n        if (ex.numOfTokens < op.minTokensBought) {\n            // The number of tokens to buy must be greater than or equal to the\n            // minimum number of tokens to buy.\n            revert NumOfTokensCannotBeLessThanMin(ex.numOfTokens, op.minTokensBought);\n        }\n\n        // Lengths of arrays are updated at the end.\n        uint256[] memory tokenIds = new uint256[](ex.numOfTokens);\n\n        uint96 totalEthUsed;\n        uint256 tokensBought;\n        for (uint256 i; i < ex.calls.length; ++i) {\n            BuyCall memory call = ex.calls[i];\n\n            uint96 callValue;\n            for (uint256 j; j < call.tokensToBuy.length; ++j) {\n                TokenToBuy memory tokenToBuy = call.tokensToBuy[j];\n\n                if (op.nftTokenIdsMerkleRoot != bytes32(0)) {\n                    // Verify the token ID is in the merkle tree.\n                    _verifyTokenId(tokenToBuy.tokenId, op.nftTokenIdsMerkleRoot, tokenToBuy.proof);\n                }\n\n                // Check that the call value is under the maximum price.\n                uint96 price = tokenToBuy.price;\n                if (price > op.maximumPrice) {\n                    revert MaximumPriceError(price, op.maximumPrice);\n                }\n\n                // Add the price to the total value used for the call.\n                callValue += price;\n            }\n\n            uint256 balanceBefore = address(this).balance;\n            {\n                // Execute the call to buy the NFT.\n                (bool success, ) = _buy(call.target, callValue, call.data);\n\n                if (!success) continue;\n            }\n\n            {\n                uint96 ethUsed;\n                for (uint256 j; j < call.tokensToBuy.length; ++j) {\n                    uint256 tokenId = call.tokensToBuy[j].tokenId;\n                    uint96 price = call.tokensToBuy[j].price;\n\n                    // Check whether the NFT was successfully bought.\n                    if (op.nftContract.safeOwnerOf(tokenId) == address(this)) {\n                        ethUsed += price;\n                        ++tokensBought;\n\n                        // Add the token to the list of tokens to finalize.\n                        tokenIds[tokensBought - 1] = tokenId;\n                    }\n                }\n\n                // Check ETH spent for call is what was expected.\n                uint256 actualEthUsed = balanceBefore - address(this).balance;\n                if (ethUsed != actualEthUsed) {\n                    revert EthUsedForFailedBuyError(ethUsed, actualEthUsed);\n                }\n\n                totalEthUsed += ethUsed;\n            }\n        }\n\n        // This is to prevent this crowdfund from finalizing a loss if nothing\n        // was attempted to be bought (ie. `tokenIds` is empty) or all NFTs were\n        // bought for free.\n        if (totalEthUsed == 0) revert NothingBoughtError();\n\n        // Check number of tokens bought is not less than the minimum.\n        if (tokensBought < op.minTokensBought) {\n            revert NotEnoughTokensBoughtError(tokensBought, op.minTokensBought);\n        }\n\n        // Check total ETH used is not less than the minimum.\n        if (totalEthUsed < op.minTotalEthUsed) {\n            revert NotEnoughEthUsedError(totalEthUsed, op.minTotalEthUsed);\n        }\n\n        assembly {\n            // Update length of `tokenIds`\n            mstore(mload(ex), tokensBought)\n        }\n\n        // Transfer the NFTs to the p"
    }
  ]
}