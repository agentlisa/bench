{
  "Title": "[H03] Relayers may not receive transaction fees",
  "Content": "Transactions that go through the [`execute` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L46) of an instance of the `OVM_ECDSAContractAccount` contract are [expected to pay transaction fees to relayers](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L92-L101). The function assumes that whoever called it is a relayer, and simply [transfers the fee](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L97-L99), paid in ovmETH.\n\n\nHowever, there are two common cases in which the `execute` function can be called, and in neither of them the fee appears to be correctly paid to relayer accounts.\n\n\n* For sequenced transactions, their entrypoint is set to the address of the [`OVM_ProxySequencerEntrypoint`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_ProxySequencerEntrypoint.sol) predeployed contract. Ultimately, it is this proxy who [calls the `execute` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol#L62-L70) of any `OVM_ECDSAContractAccount` contract. As a result, when the `execute` function [queries the `ovmCALLER`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L94), the address returned will be the address of the `OVM_ProxySequencerEntrypoint` contract, and fees will be sent to it. It is worth noting that neither this contract nor its associated implementation [`OVM_SequencerEntrypoint`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol)have any kind of functionality to handle the received fees.\n* For queued transactions, their entrypoint is set by whoever [enqueues](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L256) the transaction in the Canonical Transaction Chain. If this entrypoint is set to an instance of the `OVM_ECDSAContractAccount` contract, when the transaction is run and the `execute` function is called, the [internal call to `ovmCALLER`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L94), will simply return the default address for `ovmCALLER`, which is determined by the [`DEFAULT_ADDRESS` constant address](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L75) of the `OVM_ExecutionManager` contract. As a result, the fees will be sent to this address.\n\n\nConsider ensuring that when transaction fees are paid from instances of the `OVM_ECDSAContractAccount` contract, fees are correctly transferred to the expected relayer addresses.\n\n\n***Update:** Fixed in [pull request #1029](https://github.com/ethereum-optimism/optimism/pull/1029/commits/4a5bb28203dc6460b6e7ddaff3cd89e45a6b4d54). Fees are now transferred to a designated Sequencer Fee Wallet.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Interface Imports */\nimport { iOVM_ECDSAContractAccount } from \"../../iOVM/accounts/iOVM_ECDSAContractAccount.sol\";\n\n/* Library Imports */\nimport { Lib_EIP155Tx } from \"../../libraries/codec/Lib_EIP155Tx.sol\";\nimport { Lib_SafeExecutionManagerWrapper } from \"../../libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\";\nimport { Lib_SafeMathWrapper } from \"../../libraries/wrappers/Lib_SafeMathWrapper.sol\";\n\n/**\n * @title OVM_ECDSAContractAccount\n * @dev The ECDSA Contract Account can be used as the implementation for a ProxyEOA deployed by the\n * ovmCREATEEOA operation. It enables backwards compatibility with Ethereum's Layer 1, by\n * providing eth_sign and EIP155 formatted transaction encodings.\n *\n * Compiler used: solc\n * Runtime target: OVM\n */\ncontract OVM_ECDSAContractAccount is iOVM_ECDSAContractAccount {\n    using Lib_EIP155Tx for Lib_EIP155Tx.EIP155Tx;\n\n\n    /*************\n     * Constants *\n     *************/\n\n    // TODO: should be the amount sufficient to cover the gas costs of all of the transactions up\n    // to and including the CALL/CREATE which forms the entrypoint of the transaction.\n    uint256 constant EXECUTION_VALIDATION_GAS_OVERHEAD = 25000;\n    address constant ETH_ERC20_ADDRESS = 0x4200000000000000000000000000000000000006;\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Executes a signed transaction.\n     * @param _encodedTransaction Signed EIP155 transaction.\n     * @return Whether or not the call returned (rather than reverted).\n     * @return Data returned by the call.\n     */\n    function execute(\n        bytes memory _encodedTransaction\n    )\n        override\n        public\n        returns (\n            bool,\n            bytes memory\n        )\n    {\n        Lib_EIP155Tx.EIP155Tx memory decodedTx = Lib_EIP155Tx.decode(\n            _encodedTransaction,\n            Lib_SafeExecutionManagerWrapper.safeCHAINID()\n        );\n\n        // Recovery parameter being something other than 0 or 1 indicates that this transaction was\n        // signed using the wrong chain ID. We really should have this logic inside of Lib_EIP155Tx\n        // but I'd prefer not to add the \"safeREQUIRE\" logic into that library. So it'll live here\n        // for now.\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            decodedTx.recoveryParam < 2,\n            \"OVM_ECDSAContractAccount: Transaction was signed with the wrong chain ID.\"\n        );\n\n        // Address of this contract within the ovm (ovmADDRESS) should be the same as the\n        // recovered address of the user who signed this message. This is how we manage to shim\n        // account abstraction even though the user isn't a contract.\n        // Need to make sure that the transaction nonce is right and bump it if so.\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            decodedTx.sender() == Lib_SafeExecutionManagerWrapper.safeADDRESS(),\n            \"Signature provided for EOA transaction execution is invalid.\"\n        );\n\n        // Need to make sure that the transaction nonce is right.\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            decodedTx.nonce == Lib_SafeExecutionManagerWrapper.safeGETNONCE(),\n            \"Transaction nonce does not match the expected nonce.\"\n        );\n\n        // TEMPORARY: Disable gas checks for mainnet.\n        // // Need to make sure that the gas is sufficient to execute the transaction.\n        // Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n        //    gasleft() >= Lib_SafeMathWrapper.add(decodedTx.gasLimit, EXECUTION_VALIDATION_GAS_OVERHEAD),\n        //    \"Gas is not sufficient to execute the transaction.\"\n        // );\n\n        // Transfer fee to relayer. We assume that whoever called this function is the relayer,\n        // hence the usage of CALLER. Fee is computed as gasLimit * gasPrice.\n        address relayer = Lib_SafeExecutionManagerWrapper.safeCALLER();\n        uint256 fee = Lib_SafeMathWrapper.mul(decodedTx.gasLimit, decodedTx.gasPrice);\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _attemptETHTransfer(\n                relayer, fee\n            ),\n            \"Fee was not transferred to relayer.\"\n        );\n\n        if (decodedTx.isCreate) {\n            (address created, bytes memory revertData) = Lib_SafeExecutionManagerWrapper.safeCREATE(\n                gasleft(),\n                decodedTx.data\n            );\n\n            // Return true if the contract creation succeeded, false w/ revertData otherwise.\n            if (created != address(0)) {\n                return (true, abi.encode(created));\n            } else {\n                return (false, revertData);\n            }\n        } else {\n            // We only want to bump the nonce for `ovmCALL` because `ovmCREATE` automatically bumps\n            // the nonce of the calling account. Normally an EOA would bump the nonce for both\n            // cases, but since this is a contract we'd end up bumping the nonce twice.\n            Lib_SafeExecutionManagerWrapper.safeINCREMENTNONCE();\n\n            if (decodedTx.value > 0) {\n                Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n                    decodedTx.data.length == 0,\n                    \"Sending ETH with data is currently unsupported.\"\n                );\n\n                return (\n                    _attemptETHTransfer(decodedTx.to, decodedTx.value),\n                    bytes('')\n                );\n            } else {\n                return Lib_SafeExecutionManagerWrapper.safeCALL(\n                    gasleft(),\n                    decodedTx.to,\n                    decodedTx.data\n                );\n            }\n        }\n    }\n\n    /**\n     * Attempts to tansfer OVM_ETH.\n     * @param _to Address to send the L2 ETH to.\n     * @param _value Amount of L2 ETH to send.\n     * @return Whether the transfer was successful.\n     */\n    function _attemptETHTransfer(\n        address _to,\n        uint256 _value\n    )\n        internal\n        returns(\n            bool\n        )\n    {\n        (bool success, ) = Lib_SafeExecutionManagerWrapper.safeCALL(\n            gasleft(),\n            ETH_ERC20_ADDRESS,\n            abi.encodeWithSignature(\n                \"transfer(address,uint256)\",\n                _to,\n                _value\n            )\n        );\n        return success;\n    }\n}"
    },
    {
      "filename": "contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol",
      "content": "// SPDX-License-Identifier: MIT\n// @unsupported: ovm\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\nimport { Lib_MerkleTree } from \"../../libraries/utils/Lib_MerkleTree.sol\";\nimport { Lib_Math } from \"../../libraries/utils/Lib_Math.sol\";\n\n/* Interface Imports */\nimport { iOVM_CanonicalTransactionChain } from \"../../iOVM/chain/iOVM_CanonicalTransactionChain.sol\";\nimport { iOVM_ChainStorageContainer } from \"../../iOVM/chain/iOVM_ChainStorageContainer.sol\";\n\n/* Contract Imports */\nimport { OVM_ExecutionManager } from \"../execution/OVM_ExecutionManager.sol\";\n\n\n/**\n * @title OVM_CanonicalTransactionChain\n * @dev The Canonical Transaction Chain (CTC) contract is an append-only log of transactions\n * which must be applied to the rollup state. It defines the ordering of rollup transactions by\n * writing them to the 'CTC:batches' instance of the Chain Storage Container.\n * The CTC also allows any account to 'enqueue' an L2 transaction, which will require that the Sequencer\n * will eventually append it to the rollup state.\n * If the Sequencer does not include an enqueued transaction within the 'force inclusion period',\n * then any account may force it to be included by calling appendQueueBatch().\n *\n * Compiler used: solc\n * Runtime target: EVM\n */\ncontract OVM_CanonicalTransactionChain is iOVM_CanonicalTransactionChain, Lib_AddressResolver {\n\n    /*************\n     * Constants *\n     *************/\n\n    // L2 tx gas-related\n    uint256 constant public MIN_ROLLUP_TX_GAS = 100000;\n    uint256 constant public MAX_ROLLUP_TX_SIZE = 50000;\n    uint256 constant public L2_GAS_DISCOUNT_DIVISOR = 32;\n\n    // Encoding-related (all in bytes)\n    uint256 constant internal BATCH_CONTEXT_SIZE = 16;\n    uint256 constant internal BATCH_CONTEXT_LENGTH_POS = 12;\n    uint256 constant internal BATCH_CONTEXT_START_POS = 15;\n    uint256 constant internal TX_DATA_HEADER_SIZE = 3;\n    uint256 constant internal BYTES_TILL_TX_DATA = 65;\n\n\n    /*************\n     * Variables *\n     *************/\n\n    uint256 public forceInclusionPeriodSeconds;\n    uint256 public forceInclusionPeriodBlocks;\n    uint256 public maxTransactionGasLimit;\n\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _libAddressManager,\n        uint256 _forceInclusionPeriodSeconds,\n        uint256 _forceInclusionPeriodBlocks,\n        uint256 _maxTransactionGasLimit\n    )\n        Lib_AddressResolver(_libAddressManager)\n    {\n        forceInclusionPeriodSeconds = _forceInclusionPeriodSeconds;\n        forceInclusionPeriodBlocks = _forceInclusionPeriodBlocks;\n        maxTransactionGasLimit = _maxTransactionGasLimit;\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Accesses the batch storage container.\n     * @return Reference to the batch storage container.\n     */\n    function batches()\n        override\n        public\n        view\n        returns (\n            iOVM_ChainStorageContainer\n        )\n    {\n        return iOVM_ChainStorageContainer(\n            resolve(\"OVM_ChainStorageContainer:CTC:batches\")\n        );\n    }\n\n    /**\n     * Accesses the queue storage container.\n     * @return Reference to the queue storage container.\n     */\n    function queue()\n        override\n        public\n        view\n        returns (\n            iOVM_ChainStorageContainer\n        )\n    {\n        return iOVM_ChainStorageContainer(\n            resolve(\"OVM_ChainStorageContainer:CTC:queue\")\n        );\n    }\n\n    /**\n     * Retrieves the total number of elements submitted.\n     * @return _totalElements Total submitted elements.\n     */\n    function getTotalElements()\n        override\n        public\n        view\n        returns (\n            uint256 _totalElements\n        )\n    {\n        (uint40 totalElements,,,) = _getBatchExtraData();\n        return uint256(totalElements);\n    }\n\n    /**\n     * Retrieves the total number of batches submitted.\n     * @return _totalBatches Total submitted batches.\n     */\n    function getTotalBatches()\n        override\n        public\n        view\n        returns (\n            uint256 _totalBatches\n        )\n    {\n        return batches().length();\n    }\n\n    /**\n     * Returns the index of the next element to be enqueued.\n     * @return Index for the next queue element.\n     */\n    function getNextQueueIndex()\n        override\n        public\n        view\n        returns (\n            uint40\n        )\n    {\n        (,uint40 nextQueueIndex,,) = _getBatchExtraData();\n        return nextQueueIndex;\n    }\n\n    /**\n     * Returns the timestamp of the last transaction.\n     * @return Timestamp for the last transaction.\n     */\n    function getLastTimestamp()\n        override\n        public\n        view\n        returns (\n            uint40\n        )\n    {\n        (,,uint40 lastTimestamp,) = _getBatchExtraData();\n        return lastTimestamp;\n    }\n\n    /**\n     * Returns the blocknumber of the last transaction.\n     * @return Blocknumber for the last transaction.\n     */\n    function getLastBlockNumber()\n        override\n        public\n        view\n        returns (\n            uint40\n        )\n    {\n        (,,,uint40 lastBlockNumber) = _getBatchExtraData();\n        return lastBlockNumber;\n    }\n\n    /**\n     * Gets the queue element at a particular index.\n     * @param _index Index of the queue element to access.\n     * @return _element Queue element at the given index.\n     */\n    function getQueueElement(\n        uint256 _index\n    )\n        override\n        public\n        view\n        returns (\n            Lib_OVMCodec.QueueElement memory _element\n        )\n    {\n        return _getQueueElement(\n            _index,\n            queue()\n        );\n    }\n\n    /**\n     * Get the number of queue elements which have not yet been included.\n     * @return Number of pending queue elements.\n     */\n    function getNumPendingQueueElements()\n        override\n        public\n        view\n        returns (\n            uint40\n        )\n    {\n        return getQueueLength() - getNextQueueIndex();\n    }\n\n   /**\n     * Retrieves the length of the queue, including\n     * both pending and canonical transactions.\n     * @return Length of the queue.\n     */\n    function getQueueLength()\n        override\n        public\n        view\n        returns (\n            uint40\n        )\n    {\n        return _getQueueLength(\n            queue()\n        );\n    }\n\n    /**\n     * Adds a transaction to the queue.\n     * @param _target Target L2 contract to send the transaction to.\n     * @param _gasLimit Gas limit for the enqueued L2 transaction.\n     * @param _data Transaction data.\n     */\n    function enqueue(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    )\n        override\n        public\n    {\n        require(\n            _data.length <= MAX_ROLLUP_TX_SIZE,\n            \"Transaction data size exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit <= maxTransactionGasLimit,\n            \"Transaction gas limit exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit >= MIN_ROLLUP_TX_GAS,\n            \"Transaction gas limit too low to enqueue.\"\n        );\n\n        // We need to consume some amount of L1 gas in order to rate limit transactions going into\n        // L2. However, L2 is cheaper than L1 so we only need to burn some small proportion of the\n        // provided L1 gas.\n        uint256 gasToConsume = _gasLimit/L2_GAS_DISCOUNT_DIVISOR;\n        uint256 startingGas = gasleft();\n\n        // Although this check is not necessary (burn below will run out of gas if not true), it\n        // gives the user an explicit reason as to why the enqueue attempt failed.\n        require(\n            startingGas > gasToConsume,\n            \"Insufficient gas for L2 rate limiting burn.\"\n        );\n\n        // Here we do some \"dumb\" work in order to burn gas, although we should probably replace\n        // this with something like minting gas token later on.\n        uint256 i;\n        while(startingGas - gasleft() < gasToConsume) {\n            i++;\n        }\n\n        bytes32 transactionHash = keccak256(\n            abi.encode(\n                msg.sender,\n                _target,\n                _gasLimit,\n                _data\n            )\n        );\n\n        bytes32 timestampAndBlockNumber;\n        assembly {\n            timestampAndBlockNumber := timestamp()\n            timestampAndBlockNumber := or(timestampAndBlockNumber, shl(40, number()))\n        }\n\n        iOVM_ChainStorageContainer queueRef = queue();\n\n        queueRef.push(transactionHash);\n        queueRef.push(timestampAndBlockNumber);\n\n        // The underlying queue data structure stores 2 elements\n        // per insertion, so to get the real queue length we need\n        // to divide by 2 and subtract 1.\n        uint256 queueIndex = queueRef.length() / 2 - 1;\n        emit TransactionEnqueued(\n            msg.sender,\n            _target,\n            _gasLimit,\n            _data,\n            queueIndex,\n            block.timestamp\n        );\n    }\n\n    /**\n     * Appends a given number of queued transactions as a single batch.\n     * param _numQueuedTransactions Number of transactions to append.\n     */\n    function appendQueueBatch(\n        uint256 // _numQueuedTransactions\n    )\n        override\n        public\n        pure\n    {\n        // TEMPORARY: Disable `appendQueueBatch` for minnet\n        revert(\"appendQueueBatch is currently disabled.\");\n\n        // _numQueuedTransactions = Lib_Math.min(_numQueuedTransactions, getNumPendingQueueElements());\n        // require(\n        //     _numQueuedTransactions > 0,\n        //     \"Must append more than zero transactions.\"\n        // );\n\n        // bytes32[] memory leaves = new bytes32[](_numQueuedTransactions);\n        // uint40 nextQueueIndex = getNextQueueIndex();\n\n        // for (uint256 i = 0; i < _numQueuedTransactions; i++) {\n        //     if (msg.sender != resolve(\"OVM_Sequencer\")) {\n        //         Lib_OVMCodec.QueueElement memory el = getQueueElement(nextQueueIndex);\n        //         require(\n        //             el.timestamp + forceInclusionPeriodSeconds < block.timestamp,\n        //             \"Queue transactions cannot be submitted during the sequencer inclusion period.\"\n        //         );\n        //     }\n        //     leaves[i] = _getQueueLeafHash(nextQueueIndex);\n        //     nextQueueIndex++;\n        // }\n\n        // Lib_OVMCodec.QueueElement memory lastElement = getQueueElement(nextQueueIndex - 1);\n\n        // _appendBatch(\n        //     Lib_MerkleTree.getMerkleRoot(leaves),\n        //     _numQueuedTransactions,\n        //     _numQueuedTransactions,\n        //     lastElement.timestamp,\n        //     lastElement.blockNumber\n        // );\n\n        // emit QueueBatchAppended(\n        //     nextQueueIndex - _numQueuedTransactions,\n        //     _numQueuedTransactions,\n        //     getTotalElements()\n        // );\n    }\n\n    /**\n     * Allows the sequencer to append a batch of transactions.\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\n     * .param _contexts Array of batch contexts.\n     * .param _transactionDataFields Array of raw transaction data.\n     */\n    function appendSequencerBatch()\n        override\n        public\n    {\n        uint40 shouldStartAtElement;\n        uint24 totalElementsToAppend;\n        uint24 numContexts;\n        assembly {\n            shouldStartAtElement  := shr(216, calldataload(4))\n            totalElementsToAppend := shr(232, calldataload(9))\n            numContexts           := shr(232, calldataload(12))\n        }\n\n        require(\n            shouldStartAtElement == getTotalElements(),\n            \"Actual batch start index does not match expected start index.\"\n        );\n\n        require(\n            msg.sender == resolve(\"OVM_Sequencer\"),\n            \"Function can only be called by the Sequencer.\"\n        );\n\n        require(\n            numContexts > 0,\n            \"Must provide at least one batch context.\"\n        );\n\n        require(\n            totalElementsToAppend > 0,\n            \"Must append at least one element.\"\n        );\n\n        uint40 nextTransactionPtr = uint40(BATCH_CONTEXT_START_POS + BATCH_CONTEXT_SIZE * numContexts);\n\n        require(\n            msg.data.length >= nextTransactionPtr,\n            \"Not enough BatchContexts provided.\"\n        );\n\n        // Take a reference to the queue and its length so we don't have to keep resolving it.\n        // Length isn't going to change during the course of execution, so it's fine to simply\n        // resolve this once at the start. Saves gas.\n        iOVM_ChainStorageContainer queueRef = queue();\n        uint40 queueLength = _getQueueLength(queueRef);\n\n        // Reserve some memory to save gas on hashing later on. This is a relatively safe estimate\n        // for the average transaction size that will prevent having to resize this chunk of memory\n        // later on. Saves gas.\n        bytes memory hashMemory = new bytes((msg.data.length / totalElementsToAppend) * 2);\n\n        // Initialize the array of canonical chain leaves that we will append.\n        bytes32[] memory leaves = new bytes32[](totalElementsToAppend);\n\n        // Each leaf index corresponds to a tx, either sequenced or enqueued.\n        uint32 leafIndex = 0;\n\n        // Counter for number of sequencer transactions appended so far.\n        uint32 numSequencerTransactions = 0;\n\n        // We will sequentially append leaves which are pointers to the queue.\n        // The initial queue index is what is currently in storage.\n        uint40 nextQueueIndex = getNextQueueIndex();\n\n        BatchContext memory curContext;\n        for (uint32 i = 0; i < numContexts; i++) {\n            BatchContext memory nextContext = _getBatchContext(i);\n\n            if (i == 0) {\n                // Execute a special check for the first batch.\n                _validateFirstBatchContext(nextContext);\n            }\n\n            // Execute this check on every single batch, including the first one.\n            _validateNextBatchContext(\n                curContext,\n                nextContext,\n                nextQueueIndex,\n                queueRef\n            );\n\n            // Now we can update our current context.\n            curContext = nextContext;\n\n            // Process sequencer transactions first.\n            for (uint32 j = 0; j < curContext.numSequencedTransactions; j++) {\n                uint256 txDataLength;\n                assembly {\n                    txDataLength := shr(232, calldataload(nextTransactionPtr))\n                }\n                require(\n                    txDataLength <= MAX_ROLLUP_TX_SIZE,\n                    \"Transaction data size exceeds maximum for rollup transaction.\"\n                );\n\n                leaves[leafIndex] = _getSequencerLeafHash(\n                    curContext,\n                    nextTransactionPtr,\n                    txDataLength,\n                    hashMemory\n                );\n\n                nextTransactionPtr += uint40(TX_DATA_HEADER_SIZE + txDataLength);\n                numSequencerTransactions++;\n                leafIndex++;\n            }\n\n            // Now process any subsequent queue transactions.\n            for (uint32 j = 0; j < curContext.numSubsequentQueueTransactions; j++) {\n                require(\n                    nextQueueIndex < queueLength,\n                    \"Not enough queued transactions to append.\"\n                );\n\n                leaves[leafIndex] = _getQueueLeafHash(nextQueueIndex);\n                nextQueueIndex++;\n                leafIndex++;\n            }\n        }\n\n        _validateFinalBatchContext(\n            curContext,\n            nextQueueIndex,\n            queueLength,\n            queueRef\n        );\n\n        require(\n            msg.data.length == nextTransactionPtr,\n            \"Not all sequencer transactions were processed.\"\n        );\n\n        require(\n            leafIndex == totalElementsToAppend,\n            \"Actual transaction index does not match expected total elements to append.\"\n        );\n\n        // Generate the required metadata that we need to append this batch\n        uint40 numQueuedTransactions = totalElementsToAppend - numSequencerTransactions;\n        uint40 blockTimestamp;\n        uint40 blockNumber;\n        if (curContext.numSubsequentQueueTransactions == 0) {\n            // The last element is a sequencer tx, therefore pull timestamp and block number from the last context.\n            blockTimestamp = uint40(curContext.timestamp);\n            blockNumber = uint40(curContext.blockNumber);\n        } else {\n            // The last element is a queue tx, therefore pull timestamp and block number from the queue element.\n            // curContext.numSubsequentQueueTransactions > 0 which means that we've processed at least one queue element.\n            // We increment nextQueueIndex after processing each queue element,\n            // so the index of the last element we processed is nextQueueIndex - 1.\n            Lib_OVMCodec.QueueElement memory lastElement = _getQueueElement(\n                nextQueueIndex - 1,\n                queueRef\n            );\n\n            blockTimestamp = lastElement.timestamp;\n            blockNumber = lastElement.blockNumber;\n        }\n\n        // For efficiency reasons getMerkleRoot modifies the `leaves` argument in place\n        // while calculating the root hash therefore any arguments passed to it must not\n        // be used again afterwards\n        _appendBatch(\n            Lib_MerkleTree.getMerkleRoot(leaves),\n            totalElementsToAppend,\n            numQueuedTransactions,\n            blockTimestamp,\n            blockNumber\n        );\n\n        emit SequencerBatchAppended(\n            nextQueueIndex - numQueuedTransactions,\n            numQueuedTransactions,\n            getTotalElements()\n        );\n    }\n\n    /**\n     * Verifies whether a transaction is included in the chain.\n     * @param _transaction Transaction to verify.\n     * @param _txChainElement Transaction chain element corresponding to the transaction.\n     * @param _batchHeader Header of the batch the transaction was included in.\n     * @param _inclusionProof Inclusion proof for the provided transaction chain element.\n     * @return True if the transaction exists in the CTC, false if not.\n     */\n    function verifyTransaction(\n        Lib_OVMCodec.Transaction memory _transaction,\n        Lib_OVMCodec.TransactionChainElement memory _txChainElement,\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _inclusionProof\n    )\n        override\n        public\n        view\n        returns (\n            bool\n        )\n    {\n        if (_txChainElement.isSequenced == true) {\n            return _verifySequencerTransaction(\n                _transaction,\n                _txChainElement,\n                _batchHeader,\n                _inclusionProof\n            );\n        } else {\n            return _verifyQueueTransaction(\n                _transaction,\n                _txChainElement.queueIndex,\n                _batchHeader,\n                _inclusionProof\n            );\n        }\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Returns the BatchContext located at a particular index.\n     * @param _index The index of the BatchContext\n     * @return The BatchContext at the specified index.\n     */\n    function _getBatchContext(\n        uint256 _index\n    )\n        internal\n        pure\n        returns (\n            BatchContext memory\n        )\n    {\n        uint256 contextPtr = 15 + _index * BATCH_CONTEXT_SIZE;\n        uint256 numSequencedTransactions;\n        uint256 numSubsequentQueueTransactions;\n        uint256 ctxTimestamp;\n        uint256 ctxBlockNumber;\n\n        assembly {\n            numSequencedTransactions       := shr(232, calldataload(contextPtr))\n            numSubsequentQueueTransactions := shr(232, calldataload(add(contextPtr, 3)))\n            ctxTimestamp                   := shr(216, calldataload(add(contextPtr, 6)))\n            ctxBlockNumber                 := shr(216, calldataload(add(contextPtr, 11)))\n        }\n\n        return BatchContext({\n            numSequencedTransactions: numSequencedTransactions,\n            numSubsequentQueueTransactions: numSubsequentQueueTransactions,\n            timestamp: ctxTimestamp,\n            blockNumber: ctxBlockNumber\n        });\n    }\n\n    /**\n     * Parses the batch context from the extra data.\n     * @return Total number of elements submitted.\n     * @return Index of the next queue element.\n     */\n    function _getBatchExtraData()\n        internal\n        view\n        returns (\n            uint40,\n            uint40,\n            uint40,\n            uint40\n        )\n    {\n        bytes27 extraData = batches().getGlobalMetadata();\n\n        uint40 totalElements;\n        uint40 nextQueueIndex;\n        uint40 lastTimestamp;\n        uint40 lastBlockNumber;\n        assembly {\n            extraData       :=  shr(40, extraData)\n            totalElements   :=  and(extraData, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)\n            nextQueueIndex  :=  shr(40, and(extraData, 0x00000000000000000000000000000000000000000000FFFFFFFFFF0000000000))\n            lastTimestamp   :=  shr(80, and(extraData, 0x0000000000000000000000000000000000FFFFFFFFFF00000000000000000000))\n            lastBlockNumber :=  shr(120, and(extraData, 0x000000000000000000000000FFFFFFFFFF000000000000000000000000000000))\n        }\n\n        return (\n            totalElements,\n            nextQueueIndex,\n            lastTimestamp,\n            lastBlockNumber\n        );\n    }\n\n    /**\n     * Encodes the batch context for the extra data.\n     * @param _totalElements Total number of elements submitted.\n     * @param _nextQueueIndex Index of the next queue element.\n     * @param _timestamp Timestamp for the last batch.\n     * @param _blockNumber Block number of the last batch.\n     * @return Encoded batch context.\n     */\n    function _makeBatchExtraData(\n        uint40 _totalElements,\n        uint40 _nextQueueIndex,\n        uint40 _timestamp,\n        uint40 _blockNumber\n    )\n        internal\n        pure\n        returns (\n            bytes27\n        )\n    {\n        bytes27 extraData;\n        assembly {\n            extraData := _totalElements\n            extraData := or(extraData, shl(40, _nextQueueIndex))\n            extraData := or(extraData, shl(80, _timestamp))\n            extraData := or(extraData, shl(120, _blockNumber))\n            extraData := shl(40, extraData)\n        }\n\n        return extraData;\n    }\n\n    /**\n     * Retrieves the hash of a queue element.\n     * @param _index Index of the queue element to retrieve a hash for.\n     * @return Hash of the queue element.\n     */\n    function _getQueueLeafHash(\n        uint256 _index\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return _hashTransactionChainElement(\n            Lib_OVMCodec.TransactionChainElement({\n                isSequenced: false,\n                queueIndex: _index,\n                timestamp: 0,\n                blockNumber: 0,\n                txData: hex\"\"\n            })\n        );\n    }\n\n    /**\n     * Gets the queue element at a particular index.\n     * @param _index Index of the queue element to access.\n     * @return _element Queue element at the given index.\n     */\n    function _getQueueElement(\n        uint256 _index,\n        iOVM_ChainStorageContainer _queueRef\n    )\n        internal\n        view\n        returns (\n            Lib_OVMCodec.QueueElement memory _element\n        )\n    {\n        // The underlying queue data structure stores 2 elements\n        // per insertion, so to get the actual desired queue index\n        // we need to multiply by 2.\n        uint40 trueIndex = uint40(_index * 2);\n        bytes32 transactionHash = _queueRef.get(trueIndex);\n        bytes32 timestampAndBlockNumber = _queueRef.get(trueIndex + 1);\n\n        uint40 elementTimestamp;\n        uint40 elementBlockNumber;\n        assembly {\n            elementTimestamp   :=         and(timestampAndBlockNumber, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)\n            elementBlockNumber := shr(40, and(timestampAndBlockNumber, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000))\n        }\n\n        return Lib_OVMCodec.QueueElement({\n            transactionHash: transactionHash,\n            timestamp: elementTimestamp,\n            blockNumber: elementBlockNumber\n        });\n    }\n\n    /**\n     * Retrieves the length of the queue.\n     * @return Length of the queue.\n     */\n    function _getQueueLength(\n        iOVM_ChainStorageContainer _queueRef\n    )\n        internal\n        view\n        returns (\n            uint40\n        )\n    {\n        // The underlying queue data structure stores 2 elements\n        // per insertion, so to get the real queue length we need\n        // to divide by 2.\n        return uint40(_queueRef.length() / 2);\n    }\n\n    /**\n     * Retrieves the hash of a sequencer element.\n     * @param _context Batch context for the given element.\n     * @param _nextTransactionPtr Pointer to the next transaction in the calldata.\n     * @param _txDataLength Length of the transaction item.\n     * @return Hash of the sequencer element.\n     */\n    function _getSequencerLeafHash(\n        BatchContext memory _context,\n        uint256 _nextTransactionPtr,\n        uint256 _txDataLength,\n        bytes memory _hashMemory\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        // Only allocate more memory if we didn't reserve enough to begin with.\n        if (BYTES_TILL_TX_DATA + _txDataLe"
    }
  ]
}