{
  "Title": "Use msgSender instead of msg.sender in Event param",
  "Content": "##### Description\nSince the contract uses metatransactions everywhere (and uses NativeMetaTransaction), you should always use `msgSender()`\n- https://github.com/RealityCards/RealityCards-Contracts/blob/fd3b713d1a15f92ebc329f85038b76563f1587b8/contracts/RCMarket.sol#L584\n\notherwise the event parameter maybe not correct\n\nlook at the logic at https://github.com/RealityCards/RealityCards-Contracts/blob/fd3b713d1a15f92ebc329f85038b76563f1587b8/contracts/lib/NativeMetaTransaction.sol#L105\n\nBut at https://github.com/RealityCards/RealityCards-Contracts/blob/fd3b713d1a15f92ebc329f85038b76563f1587b8/contracts/RCMarket.sol#L579 the `msgSender()`, so it is used what is not consistent.\n\n##### Recommendation\nIt is recommended to use `msgSender()` in all of `msg.sender` usages (see also: https://medium.com/biconomy/biconomy-supports-native-meta-transactions-243ce52a2a2b).\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/RCMarket.sol",
      "content": "pragma solidity 0.5.13;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRealitio.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport './interfaces/IRCProxyXdai.sol';\nimport './interfaces/IRCNftHubXdai.sol';\nimport './lib/NativeMetaTransaction.sol';\n\n/// @title Reality Cards Market\n/// @author Andrew Stanger\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCMarket is Initializable, NativeMetaTransaction {\n\n    using SafeMath for uint256;\n\n    ////////////////////////////////////\n    //////// VARIABLES /////////////////\n    ////////////////////////////////////\n\n    ///// CONTRACT SETUP /////\n    /// @dev = how many outcomes/teams/NFTs etc \n    uint256 public numberOfTokens;\n    /// @dev only for _revertToUnderbidder to prevent gas limits\n    uint256 public constant MAX_ITERATIONS = 10;\n    uint256 public constant MAX_UINT256 = 2**256 - 1;\n    uint256 public constant MAX_UINT128 = 2**128 - 1;\n    enum States {CLOSED, OPEN, LOCKED, WITHDRAW}\n    States public state; \n    /// @dev type of event. 0 = classic, 1 = winner takes all, 2 = hot potato \n    uint256 public mode;\n    /// @dev so the Factory can check its a market\n    bool public constant isMarket = true;\n    /// @dev counts the total NFTs minted across all events at the time market created\n    /// @dev nft tokenId = card Id + totalNftMintCount\n    uint256 public totalNftMintCount;\n\n    ///// CONTRACT VARIABLES /////\n    ITreasury public treasury;\n    IFactory public factory;\n    IRCProxyXdai public proxy;\n    IRCNftHubXdai public nfthub;\n\n    ///// PRICE, DEPOSITS, RENT /////\n    /// @dev in attodai (so 100xdai = 100000000000000000000)\n    mapping (uint256 => uint256) public price; \n    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.\n    mapping (address => uint256) public collectedPerUser;\n    /// @dev keeps track of all the rent paid for each token, for card specific affiliate payout\n    mapping (uint256 => uint256) public collectedPerToken;\n    /// @dev an easy way to track the above across all tokens\n    uint256 public totalCollected; \n    /// @dev prevents user from exiting and re-renting in the same block (prevents troll attacks)\n    mapping (address => uint256) public exitedTimestamp;\n\n    ///// PARAMETERS /////\n    /// @dev read from the Factory upon market creation, can not be changed for existing market\n    /// @dev the minimum required price increase in %\n    uint256 public minimumPriceIncrease;\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public minRentalDivisor;\n    /// @dev if hot potato mode, how much rent new owner must pay current owner (1 week divisor: i.e. 7 = 1 day, 14 = 12 hours)\n    uint256 public hotPotatoDivisor;\n\n    ///// ORDERBOOK /////\n    /// @dev stores the orderbook. Doubly linked list. \n    mapping (uint256 => mapping(address => Bid)) public orderbook; // tokenID // user address // Bid\n    /// @dev orderbook uses uint128 to save gas, because Struct. Using uint256 everywhere else because best for maths. \n    struct Bid{\n  \t\tuint128 price;\n        uint128 timeHeldLimit; // users can optionally set a maximum time to hold it for\n        address next; // who it will return to when current owner exits (i.e, next = going down the list)\n        address prev; // who it returned from (i.e., prev = going up the list)\n    }\n \n    ///// TIME /////\n    /// @dev how many seconds each user has held each token for, for determining winnings  \n    mapping (uint256 => mapping (address => uint256) ) public timeHeld;\n    /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld\n    mapping (uint256 => uint256) public totalTimeHeld; \n    /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.\n    mapping (uint256 => uint256) public timeLastCollected; \n    /// @dev to track the max timeheld of each token (for giving NFT to winner)\n    mapping (uint256 => uint256) public longestTimeHeld;\n    /// @dev to track who has owned it the most (for giving NFT to winner)\n    mapping (uint256 => address) public longestOwner;\n    /// @dev tells the contract to exit position after min rental duration (or immediately, if already rented for this long)\n    /// @dev if not current owner, prevents ownership reverting back to you\n\n    ///// TIMESTAMPS ///// \n    /// @dev when the market opens \n    uint32 public marketOpeningTime; \n    /// @dev when the market locks \n    uint32 public marketLockingTime; \n    /// @dev when the question can be answered on realitio\n    /// @dev only needed for circuit breaker\n    uint32 public oracleResolutionTime;\n\n    ///// PAYOUT VARIABLES /////\n    uint256 public winningOutcome;\n    /// @dev prevent users withdrawing twice\n    mapping (address => bool) public userAlreadyWithdrawn;\n    /// @dev prevent users claiming twice\n    mapping (uint256 => mapping (address => bool) ) public userAlreadyClaimed; // token ID // user // bool\n    /// @dev the artist\n    address public artistAddress;\n    uint256 public artistCut;\n    bool public artistPaid;\n    /// @dev the affiliate\n    address public affiliateAddress;\n    uint256 public affiliateCut;\n    bool public affiliatePaid;\n    /// @dev the winner\n    uint256 public winnerCut;\n    /// @dev the market creator\n    address public marketCreatorAddress;\n    uint256 public creatorCut;\n    bool public creatorPaid;\n    /// @dev card specific recipients\n    address[] public cardAffiliateAddresses;\n    uint256 public cardAffiliateCut;\n    mapping (uint256 => bool) public cardAffiliatePaid;\n\n    ////////////////////////////////////\n    //////// EVENTS ////////////////////\n    ////////////////////////////////////\n\n    event LogAddToOrderbook(address indexed newOwner, uint256 indexed newPrice, uint256 timeHeldLimit, address insertedBelow, uint256 indexed tokenId);\n    event LogNewOwner(uint256 indexed tokenId, address indexed newOwner);\n    event LogRentCollection(uint256 indexed rentCollected, uint256 indexed tokenId, address indexed owner);\n    event LogRemoveFromOrderbook(address indexed owner, uint256 indexed tokenId);\n    event LogContractLocked(bool indexed didTheEventFinish);\n    event LogWinnerKnown(uint256 indexed winningOutcome);\n    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);\n    event LogStakeholderPaid(address indexed paidTo, uint256 indexed amountPaid);\n    event LogRentReturned(address indexed returnedTo, uint256 indexed amountReturned);\n    event LogTimeHeldUpdated(uint256 indexed newTimeHeld, address indexed owner, uint256 indexed tokenId);\n    event LogStateChange(uint256 indexed newState);\n    event LogUpdateTimeHeldLimit(address indexed owner, uint256 newLimit, uint256 tokenId);\n    event LogExit(address indexed owner, uint256 tokenId);\n    event LogSponsor(address indexed sponsor, uint256 indexed amount);\n    event LogNftUpgraded(uint256 indexed currentTokenId, uint256 indexed newTokenId);\n    event LogPayoutDetails(address indexed artistAddress, address marketCreatorAddress, address affiliateAddress, address[] cardAffiliateAddresses, uint256 indexed artistCut, uint256 winnerCut, uint256 creatorCut, uint256 affiliateCut, uint256 cardAffiliateCut);\n    event LogTransferCardToLongestOwner(uint256 tokenId, address longestOwner);\n    event LogSettings(uint256 indexed minRentalDivisor, uint256 indexed minimumPriceIncrease, uint256 hotPotatoDivisor);\n\n    ////////////////////////////////////\n    //////// CONSTRUCTOR ///////////////\n    ////////////////////////////////////\n    \n    /// @param _mode 0 = normal, 1 = winner takes all, 2 = hot potato\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _numberOfTokens how many Cards in this market\n    /// @param _totalNftMintCount total existing Cards across all markets excl this event's Cards\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliate's cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any\n    /// @param _marketCreatorAddress where to send market creator's cut, if any\n    function initialize(\n        uint256 _mode,\n        uint32[] memory _timestamps,\n        uint256 _numberOfTokens,\n        uint256 _totalNftMintCount,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        address _marketCreatorAddress\n    ) public initializer {\n        assert(_mode <= 2);\n\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsMarket\",\"1\");\n\n        // external contract variables:\n        factory = IFactory(msg.sender);\n        treasury = factory.treasury();\n        proxy = factory.proxy();\n        nfthub = factory.nfthub();\n\n        // get adjustable parameters from the factory/treasury\n        uint256[5] memory _potDistribution = factory.getPotDistribution();\n        minRentalDivisor = treasury.minRentalDivisor();\n        minimumPriceIncrease = factory.minimumPriceIncrease();\n        hotPotatoDivisor = factory.hotPotatoDivisor();\n        \n        // initialiiize!\n        winningOutcome = MAX_UINT256; // default invalid\n\n        // assign arguments to public variables\n        mode = _mode;\n        numberOfTokens = _numberOfTokens;\n        totalNftMintCount = _totalNftMintCount;\n        marketOpeningTime = _timestamps[0];\n        marketLockingTime = _timestamps[1];\n        oracleResolutionTime = _timestamps[2];\n        artistAddress = _artistAddress;\n        marketCreatorAddress = _marketCreatorAddress;\n        affiliateAddress = _affiliateAddress;\n        cardAffiliateAddresses = _cardAffiliateAddresses;\n        artistCut = _potDistribution[0];\n        winnerCut = _potDistribution[1];\n        creatorCut = _potDistribution[2];\n        affiliateCut = _potDistribution[3];\n        cardAffiliateCut = _potDistribution[4];\n\n        // reduce artist cut to zero if zero adddress set\n        if (_artistAddress == address(0)) {\n            artistCut = 0;\n        }\n\n        // reduce affiliate cut to zero if zero adddress set\n        if (_affiliateAddress == address(0)) {\n            affiliateCut = 0;\n        }\n\n        // check the validity of card affiliate array. \n        // if not valid, reduce payout to zero\n        if (_cardAffiliateAddresses.length == _numberOfTokens) {\n            for (uint i = 0; i < _numberOfTokens; i++) { \n                if (_cardAffiliateAddresses[i] == address(0)) {\n                    cardAffiliateCut = 0;\n                }\n            }\n        } else {\n            cardAffiliateCut = 0;\n        }\n\n        // if winner takes all mode, set winnerCut to max\n        if (_mode == 1) {\n            winnerCut = (((uint256(1000).sub(artistCut)).sub(creatorCut)).sub(affiliateCut)).sub(cardAffiliateCut);\n        } \n\n        // move to OPEN immediately if market opening time in the past\n        if (marketOpeningTime <= now) {\n            _incrementState();\n        }\n\n        emit LogPayoutDetails(_artistAddress, _marketCreatorAddress, _affiliateAddress, cardAffiliateAddresses, artistCut, winnerCut, creatorCut, affiliateCut, cardAffiliateCut);\n        emit LogSettings(minRentalDivisor, minimumPriceIncrease, hotPotatoDivisor);\n    } \n\n    ////////////////////////////////////\n    /////////// MODIFIERS //////////////\n    ////////////////////////////////////\n\n    /// @dev automatically opens market if appropriate\n    modifier autoUnlock() {\n        if (marketOpeningTime <= now && state == States.CLOSED) {\n            _incrementState();\n        }\n        _;\n    }\n\n    /// @dev automatically locks market if appropriate\n    modifier autoLock() {\n        _;\n        if (marketLockingTime <= now) {\n            lockMarket();\n        }\n    }\n\n    /// @notice what it says on the tin\n    modifier onlyTokenOwner(uint256 _tokenId) {\n        require(msgSender() == ownerOf(_tokenId), \"Not owner\");\n       _;\n    }\n\n    ////////////////////////////////////\n    //// ORACLE PROXY CONTRACT CALLS ///\n    ////////////////////////////////////\n\n    /// @notice send NFT to mainnet\n    /// @dev upgrades not possible if market not approved\n    function upgradeCard(uint256 _tokenId) external onlyTokenOwner(_tokenId) {\n        _checkState(States.WITHDRAW);\n        require(!factory.trapIfUnapproved() || factory.isMarketApproved(address(this)), \"Upgrade blocked\");\n        string memory _tokenUri = tokenURI(_tokenId);\n        address _owner = ownerOf(_tokenId);\n        uint256 _actualTokenId = _tokenId.add(totalNftMintCount);\n        proxy.saveCardToUpgrade(_actualTokenId, _tokenUri, _owner);\n        _transferCard(ownerOf(_tokenId), address(this), _tokenId); // contract becomes final resting place\n        emit LogNftUpgraded(_tokenId, _actualTokenId);\n    }\n\n    ////////////////////////////////////\n    /////// NFT HUB CONTRACT CALLS /////\n    ////////////////////////////////////\n\n    /// @notice gets the owner of the NFT via their Card Id\n    function ownerOf(uint256 _tokenId) public view returns(address) {\n        uint256 _actualTokenId = _tokenId.add(totalNftMintCount);\n        return nfthub.ownerOf(_actualTokenId);\n    }\n\n    /// @notice gets tokenURI via their Card Id\n    function tokenURI(uint256 _tokenId) public view returns(string memory) {\n        uint256 _actualTokenId = _tokenId.add(totalNftMintCount);\n        return nfthub.tokenURI(_actualTokenId);\n    }\n\n    /// @notice transfer ERC 721 between users\n    function _transferCard(address _from, address _to, uint256 _tokenId) internal {\n        require(_from != address(0) && _to != address(0) , \"Cannot send to/from zero address\");\n        uint256 _actualTokenId = _tokenId.add(totalNftMintCount);\n        assert(nfthub.transferNft(_from, _to, _actualTokenId));\n        emit LogNewOwner(_tokenId, _to);\n    }\n\n    ////////////////////////////////////\n    //// MARKET RESOLUTION FUNCTIONS ///\n    ////////////////////////////////////\n\n    /// @notice checks whether the competition has ended, if so moves to LOCKED state\n    /// @dev can be called by anyone \n    /// @dev public because called within autoLock modifier & setWinner\n    function lockMarket() public {\n        _checkState(States.OPEN);\n        require(marketLockingTime < now, \"Market has not finished\");\n        // do a final rent collection before the contract is locked down\n        collectRentAllCards();\n        _incrementState();\n        emit LogContractLocked(true);\n    }\n\n    /// @notice called by proxy, sets the winner\n    function setWinner(uint256 _winningOutcome) external {\n        if (state == States.OPEN) { lockMarket(); }\n        _checkState(States.LOCKED);\n        require(msg.sender == address(proxy), \"Not proxy\");\n        // get the winner. This will revert if answer is not resolved.\n        winningOutcome = _winningOutcome;\n        _incrementState();\n        emit LogWinnerKnown(winningOutcome);\n    }\n\n    /// @notice pays out winnings, or returns funds\n    /// @dev public because called by withdrawWinningsAndDeposit\n    function withdraw() external {\n        _checkState(States.WITHDRAW);\n        require(!userAlreadyWithdrawn[msgSender()], \"Already withdrawn\");\n        userAlreadyWithdrawn[msgSender()] = true;\n        if (totalTimeHeld[winningOutcome] > 0) {\n            _payoutWinnings();\n        } else {\n             _returnRent();\n        }\n    }\n\n    /// @notice the longest owner of each NFT gets to keep it\n    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known\n    function claimCard(uint256 _tokenId) external  {\n        _checkNotState(States.CLOSED);\n        _checkNotState(States.OPEN);\n        require(!userAlreadyClaimed[_tokenId][msgSender()], \"Already claimed\");\n        userAlreadyClaimed[_tokenId][msgSender()] = true;\n        require(longestOwner[_tokenId] == msgSender(), \"Not longest owner\");\n        _transferCard(ownerOf(_tokenId), longestOwner[_tokenId], _tokenId);\n    }\n\n    /// @notice pays winnings\n    function _payoutWinnings() internal {\n        uint256 _winningsToTransfer;\n        uint256 _remainingCut = ((((uint256(1000).sub(artistCut)).sub(affiliateCut))).sub(cardAffiliateCut).sub(winnerCut)).sub(creatorCut); \n        // calculate longest owner's extra winnings, if relevant\n        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0){\n            _winningsToTransfer = (totalCollected.mul(winnerCut)).div(1000);\n        }\n        // calculate normal winnings, if any\n        uint256 _remainingPot = (totalCollected.mul(_remainingCut)).div(1000);\n        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];\n        uint256 _numerator = _remainingPot.mul(_winnersTimeHeld);\n        _winningsToTransfer = _winningsToTransfer.add(_numerator.div(totalTimeHeld[winningOutcome]));\n        require(_winningsToTransfer > 0, \"Not a winner\");\n        _payout(msgSender(), _winningsToTransfer);\n        emit LogWinningsPaid(msgSender(), _winningsToTransfer);\n    }\n\n    /// @notice returns all funds to users in case of invalid outcome\n    function _returnRent() internal {\n        // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)\n        uint256 _remainingCut = ((uint256(1000).sub(artistCut)).sub(affiliateCut)).sub(cardAffiliateCut);      \n        uint256 _rentCollected = collectedPerUser[msgSender()];\n        require(_rentCollected > 0, \"Paid no rent\");\n        uint256 _rentCollectedAdjusted = (_rentCollected.mul(_remainingCut)).div(1000);\n        _payout(msgSender(), _rentCollectedAdjusted);\n        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);\n    }\n\n    /// @notice all payouts happen through here\n    function _payout(address _recipient, uint256 _amount) internal {\n        assert(treasury.payout(_recipient, _amount));\n    }\n\n    /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates)\n    /// @dev they are not called within determineWinner() because of the risk of an\n    /// @dev ....  address being a contract which refuses payment, then nobody could get winnings\n\n    /// @notice pay artist\n    function payArtist() external {\n        _checkState(States.WITHDRAW);\n        require(!artistPaid, \"Artist already paid\");\n        artistPaid = true;\n        _processStakeholderPayment(artistCut, artistAddress);\n    }\n\n    /// @notice pay market creator\n    function payMarketCreator() external {\n        _checkState(States.WITHDRAW);\n        require(totalTimeHeld[winningOutcome] > 0, \"No winner\");\n        require(!creatorPaid, \"Creator already paid\");\n        creatorPaid = true;\n        _processStakeholderPayment(creatorCut, marketCreatorAddress);\n    }\n\n    /// @notice pay affiliate\n    function payAffiliate() external {\n        _checkState(States.WITHDRAW);\n        require(!affiliatePaid, \"Affiliate already paid\");\n        affiliatePaid = true;\n        _processStakeholderPayment(affiliateCut, affiliateAddress);\n    }\n\n    /// @notice pay card affiliate\n    /// @dev does not call _processStakeholderPayment because it works differently\n    function payCardAffiliate(uint256 _tokenId) external {\n        _checkState(States.WITHDRAW);\n        require(!cardAffiliatePaid[_tokenId], \"Card affiliate already paid\");\n        cardAffiliatePaid[_tokenId] = true;\n        uint256 _cardAffiliatePayment = (collectedPerToken[_tokenId].mul(cardAffiliateCut)).div(1000);\n        if (_cardAffiliatePayment > 0) {\n            _payout(cardAffiliateAddresses[_tokenId], _cardAffiliatePayment);\n            emit LogStakeholderPaid(cardAffiliateAddresses[_tokenId], _cardAffiliatePayment);\n        }\n    }\n\n    function _processStakeholderPayment(uint256 _cut, address _recipient) internal {\n        if (_cut > 0) {\n            uint256 _payment = (totalCollected.mul(_cut)).div(1000);\n            _payout(_recipient, _payment);\n            emit LogStakeholderPaid(_recipient, _payment);\n        }\n    }\n\n    ////////////////////////////////////\n    ///// CORE FUNCTIONS- EXTERNAL /////\n    ////////////////////////////////////\n    /// @dev basically functions that have _checkState(States.OPEN) on first line\n\n    /// @notice collects rent for all tokens\n    /// @dev cannot be external because it is called within the lockMarket function, therefore public\n    function collectRentAllCards() public {\n        _checkState(States.OPEN);\n       for (uint i = 0; i < numberOfTokens; i++) {\n            _collectRent(i);\n        }\n    }\n\n    /// @notice rent every Card at the minimum price\n    function rentAllCards(uint256 _maxSumOfPrices) external {\n        // check that not being front run\n        uint256 _actualSumOfPrices;\n        for (uint i = 0; i < numberOfTokens; i++) {\n            _actualSumOfPrices = _actualSumOfPrices.add(price[i]);\n        }\n        require(_actualSumOfPrices <= _maxSumOfPrices, \"Prices too high\");\n\n        for (uint i = 0; i < numberOfTokens; i++) {\n            if (ownerOf(i) != msgSender()) {\n                uint _newPrice;\n                if (price[i]>0) {\n                    _newPrice = (price[i].mul(minimumPriceIncrease.add(100))).div(100);\n                } else {\n                    _newPrice = 1 ether;\n                }\n                newRental(_newPrice, 0, address(0), i);\n            }\n        }\n    }\n\n    /// @notice to rent a Card\n    /// @dev no event: it is emitted in _updateBid, _setNewOwner or _placeInList as appropriate\n    function newRental(uint256 _newPrice, uint256 _timeHeldLimit, address _startingPosition, uint256 _tokenId) public payable autoUnlock() autoLock() returns (uint256) {\n        _checkState(States.OPEN);\n        require(_newPrice >= 1 ether, \"Minimum rental 1 xDai\");\n        require(_tokenId < numberOfTokens, \"This token does not exist\");\n        require(exitedTimestamp[msgSender()] != now, \"Cannot lose and re-rent in same block\");\n\n        _collectRent(_tokenId);\n\n         // process deposit, if sent\n        if (msg.value > 0) {\n            assert(treasury.deposit.value(msg.value)(msgSender()));\n        }\n\n        // check sufficient deposit\n        uint256 _updatedTotalRentals =  treasury.userTotalRentals(msgSender()).add(_newPrice);\n        require(treasury.deposits(msgSender()) >= _updatedTotalRentals.div(minRentalDivisor), \"Insufficient deposit\");\n\n        // check _timeHeldLimit\n        if (_timeHeldLimit == 0) {\n            _timeHeldLimit = MAX_UINT128; // so 0 defaults to no limit\n        }\n        uint256 _minRentalTime = uint256(1 days).div(minRentalDivisor);\n        require(_timeHeldLimit >= timeHeld[_tokenId][msgSender()].add(_minRentalTime), \"Limit too low\"); // must be after collectRent so timeHeld is up to date\n\n        // if not in the orderbook, _newBid else _updateBid\n        if (orderbook[_tokenId][msgSender()].price == 0) {\n            _newBid(_newPrice, _tokenId, _timeHeldLimit, _startingPosition);\n        } else {\n            _updateBid(_newPrice, _tokenId, _timeHeldLimit, _startingPosition);\n        }\n\n        assert(treasury.updateLastRentalTime(msgSender()));\n        return price[_tokenId];\n    }\n\n    /// @notice to change your timeHeldLimit without having to re-rent\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _tokenId) external {\n        _checkState(States.OPEN);\n        _collectRent(_tokenId);\n        \n        if (_timeHeldLimit == 0) {\n            _timeHeldLimit = MAX_UINT128; // so 0 defaults to no limit\n        }\n        uint256 _minRentalTime = uint256(1 days).div(minRentalDivisor);\n        require(_timeHeldLimit >= timeHeld[_tokenId][msgSender()].add(_minRentalTime), \"Limit too low\"); // must be after collectRent so timeHeld is up to date\n\n        orderbook[_tokenId][msgSender()].timeHeldLimit = SafeCast.toUint128(_timeHeldLimit);\n        emit LogUpdateTimeHeldLimit(msgSender(), _timeHeldLimit, _tokenId); \n    }\n\n    /// @notice stop renting a token and/or remove from orderbook\n    /// @dev public because called by exitAll()\n    /// @dev doesn't need to be current owner so user can prevent ownership returning to them\n    /// @dev does not apply minimum rental duration, because it returns ownership to the next user\n    function exit(uint256 _tokenId) public {\n        _checkState(States.OPEN);\n        // if current owner, collect rent, revert if necessary\n        if (ownerOf(_tokenId) == msgSender()) {\n            // collectRent first\n            _collectRent(_tokenId);\n\n            // if still the current owner after collecting rent, revert to underbidder\n            if (ownerOf(_tokenId) == msgSender()) {\n                _revertToUnderbidder(_tokenId);\n            // if not current owner no further action necessary because they will have been deleted from the orderbook\n            } else {\n                assert(orderbook[_tokenId][msgSender()].price == 0);\n            }\n        // if not owner, just delete from orderbook\n        } else {\n            orderbook[_tokenId][orderbook[_tokenId][msgSender()].next].prev = orderbook[_tokenId][msgSender()].prev;\n            orderbook[_tokenId][orderbook[_tokenId][msgSender()].prev].next = orderbook[_tokenId][msgSender()].next;\n            delete orderbook[_tokenId][msgSender()];\n            emit LogRemoveFromOrderbook(msgSender(), _tokenId);\n        }\n        emit LogExit(msgSender(), _tokenId); \n    }\n\n    /// @notice stop renting all tokens\n    function exitAll() external {\n        for (uint i = 0; i < numberOfTokens; i++) {\n            exit(i);\n        }\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win. \n    function sponsor() external payable {\n        _checkNotState(States.LOCKED);\n        _checkNotState(States.WITHDRAW);\n        require(msg.value > 0, \"Must send something\");\n        // send funds to the Treasury\n        assert(treasury.sponsor.value(msg.value)());\n        totalCollected = totalCollected.add(msg.value);\n        // just so user can get it back if invalid outcome\n        collectedPerUser[msgSender()] = collectedPerUser[msgSender()].add(msg.value); \n        // allocate equally to each token, in case card specific affiliates\n        for (uint i = 0; i < numberOfTokens; i++) {\n            collectedPerToken[i] =  collectedPerToken[i].add(msg.value.div(numberOfTokens));\n        }\n        emit LogSponsor(msg.sender, msg.value); \n    }\n\n    ////////////////////////////////////\n    ///// CORE FUNCTIONS- INTERNAL /////\n    ////////////////////////////////////\n\n    /// @notice collects rent for a specific token\n    /// @dev also calculates and updates how long the current user has held the token for\n    /// @dev is not a problem if called externally, but making internal over public to save gas\n    function _collectRent(uint256 _tokenId) internal {\n        uint256 _timeOfThisCollection = now;\n        //only collect rent if the token is owned (ie, if owned by the contract this implies unowned)\n        if (ownerOf(_tokenId) != address(this)) {\n            \n            uint256 _rentOwed = price[_tokenId].mul(now.sub(timeLastCollected[_tokenId])).div(1 days);\n            address _collectRentFrom = ownerOf(_tokenId);\n            uint256 _deposit = treasury.deposits(_collectRentFrom);\n            \n            // get the maximum rent they can pay based on timeHeldLimit\n            uint256 _rentOwedLimit;\n            uint256 _timeHeldLimit = orderbook[_tokenId][_collectRentFrom].timeHeldLimit;\n            if (_timeHeldLimit == MAX_UINT128) {\n                _rentOwedLimit = MAX_UINT256;\n            } else {\n                _rentOwedLimit = price[_tokenId].mul(_timeHeldLimit.sub(timeHeld[_tokenId][_collectRentFrom])).div(1 days);\n            }\n\n            // if rent owed is too high, reduce\n            if (_rentOwed >= _deposit || _rentOwed >= _rentOwedLimit)  {\n                // case 1: rentOwed is reduced to _deposit\n                if (_deposit <= _rentOwedLimit)\n                {\n                    _timeOfThisCollection = timeLastCollected[_tokenId].add(((now.sub(timeLastCollected[_tokenId])).mul(_deposit).div(_rentOwed)));\n                    _rentOwed = _deposit; // take what's left     \n                // case 2: rentOwed is reduced to _rentOwedLimit\n                } else {\n                    _timeOfThisCollection = timeLastCollected[_tokenId].add(((now.sub(timeLastCollected[_tokenId])).mul(_rentOwedLimit).div(_rentOwed)));\n                    _rentOwed = _rentOwedLimit; // take up to the max   \n                }\n                _revertToUnderbidder(_tokenId);\n            } \n            \n            if (_rentOwed > 0) {\n                // decrease deposit by rent owed at the Treasury\n                assert(treasury.payRent(_collectRentFrom, _rentOwed));\n                // update internals\n                uint256 _timeHeldToIncrement = (_timeOfThisCollection.sub(timeLastCollected[_tokenId]));\n                timeHeld[_tokenId][_collectRentFrom] = timeHeld[_tokenId][_collectRentFrom].add(_timeHeldToIncrement);\n                totalTimeHeld[_tokenId] = totalTimeHeld[_tokenId].add(_timeHeldToIncrement);\n                collectedPerUser[_collectRentFrom] = collectedPerUser[_collectRentFrom].add(_rentOwed);\n                collectedPerToken[_tokenId] = collectedPerToken[_tokenId].add(_rentOwed);\n                totalCollected = totalCollected.add(_rentOwed);\n\n                // longest owner tracking\n                if (timeHeld[_tokenId][_collectRentFrom] > longestTimeHeld[_tokenId]) {\n                    longestTimeHeld[_tokenId] = timeHeld[_tokenId][_collectRentFrom];\n                    longestOwner[_tokenId] = _collectRentFrom;\n                }\n\n                emit LogTimeHeldUpdated(timeHeld[_tokenId][_collectRentFrom], _collectRentFrom, _tokenId);\n                emit LogRentCollection(_rentOwed, _tokenId, _collectRentFrom);\n            } \n        }\n\n        // timeLastCollected is updated regardless of whether the token is owned, so that the clock starts ticking\n        // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental\n        timeLastCollected[_tokenId] = _timeOfThisCollection;\n    }\n\n    /// @dev user is not in the orderbook\n    function _newBid(uint256 _newPrice, uint256 _tokenId, uint256 _timeHeldLimit, address _startingPosition) internal {\n        // check user not in the orderbook\n        assert(orderbook[_tokenId][msgSender()].price == 0);\n        uint256 _minPriceToOwn = (price[_tokenId].mul(minimumPriceIncrease.add(100))).div(100);\n        // case 1: user is sufficiently above highest bidder (or only bidder)\n        if(ownerOf(_tokenId) == address(this) || _newPrice >= _minPriceToOwn) {\n            _setNewOwner(_newPrice, _tokenId, _timeHeldLimit);\n        } else {\n        // case 2: user is not sufficiently above highest bidder\n            _placeInList(_newPrice, _tokenId, _timeHeldLimit, _startingPosition); \n        }\n    }\n\n    /// @dev user is already in the orderbook\n    function _updateBid(uint256 _newPrice, uint256 _tokenId, uint256 _timeHeldLimit, address _startingPosition) internal {\n        uint256 _minPriceToOwn;\n        // ensure user is in the orderbook\n        assert(orderbook[_tokenId][msgSender()].price > 0);\n        // case 1: user is currently the owner\n        if(msgSender() == ownerOf(_tokenId)) { \n            _minPriceToOwn = (price[_tokenId].mul(minimumPriceIncrease.add(100))).div(100);\n            // case 1A: new price is at least X% above current price- adjust price & timeHeldLimit. newRental event required. \n            if(_newPrice >= _minPriceToOwn) {\n                orderbook[_tokenId][msgSender()].price = SafeCast.toUint128(_newPrice);\n                orderbook[_tokenId][msgSender()].timeHeldLimit = SafeCast.toUint128(_timeHeldLimit);\n                _processUpdateOwner(_newPrice, _tokenId);\n                emit LogAddToOrderbook(msgSender(), _newPrice, _timeHeldLimit, orderbook[_tokenId][msgSender()].prev, _tokenId);\n            // case 1B: new price is higher than current price but by less than X%- revert the tx to prevent frontrunning\n            } else if (_newPrice > price[_tokenId]) {\n                require(false, \"Not 10% higher\");\n            // case 1C: new price is equal or below old price\n            } else {\n                _minPriceToOwn = (uint256(orderbook[_tokenId][orderbook[_tokenId][msgSender()].next].price).mul(minimumPriceIncrease.add(100))).div(100);\n                // case 1Ca: still the highest owner- adjust price & timeHe"
    }
  ]
}