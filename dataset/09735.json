{
  "Title": "[M-08] Arbitrary code can be run with Controller as msg.sender",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L497-L516\n\n\n# Vulnerability details\n\n## Impact\n\nA malicious user can call Controller's operate with ActionType.QTokenPermit, providing a precooked contract address as qToken, that will be called by Controller contract with IQToken(_qToken).permit(), which implementation can be arbitrary as long as IQToken interface and permit signature is implemented.\n\nThe Controller is asset bearing contract and it will be msg.sender in this arbitrary permit() function called, which is a setup that better be avoided.\n\n## Proof of Concept\n\nWhen the Controller's operate with a QTokenPermit action, it parses the arguments with Actions library and then calls internal _qTokenPermit:\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L91-L92\n\n_qTokenPermit calls the IQToken(_qToken) address provided without performing any additional checks:\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L497-L516\n\nThis way, contrary to the approach used in other actions, qToken isn't checked to be properly created address and is used right away, while the requirement that the address provided should implement IQToken interface and have permit function with a given signature can be easily met with a precooked contract.\n\n## Recommended Mitigation Steps\n\nGiven that QToken can be called directly please examine the need for QTokenPermit ActionType.\n\nIf current approach is based on UI convenience and better be kept, consider probing for IOptionsFactory(optionsFactory).isQToken(_qToken) before calling the address provided.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-rolla-contest",
  "Code": [
    {
      "filename": "quant-protocol/contracts/Controller.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./QuantConfig.sol\";\nimport \"./utils/EIP712MetaTransaction.sol\";\nimport \"./utils/OperateProxy.sol\";\nimport \"./interfaces/IQToken.sol\";\nimport \"./interfaces/IOracleRegistry.sol\";\nimport \"./interfaces/ICollateralToken.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IOperateProxy.sol\";\nimport \"./interfaces/IQuantCalculator.sol\";\nimport \"./interfaces/IOptionsFactory.sol\";\nimport \"./libraries/ProtocolValue.sol\";\nimport \"./libraries/QuantMath.sol\";\nimport \"./libraries/OptionsUtils.sol\";\nimport \"./libraries/Actions.sol\";\n\n/// @title The main entry point in the Quant Protocol\n/// @author Rolla\n/// @notice Handles minting options and spreads, exercising, claiming collateral and neutralizing positions.\n/// @dev This contract has no receive method, and also no way to recover tokens sent to it by accident.\n/// Its balance of options or any other tokens are never used in any calculations, so there is no risk if that happens.\n/// @dev This contract is an upgradeable proxy, and it supports meta transactions.\n/// @dev The Controller holds all the collateral used to mint options. Options need to be created through the\n/// OptionsFactory first.\ncontract Controller is\n    IController,\n    EIP712MetaTransaction,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using QuantMath for QuantMath.FixedPointInt;\n    using Actions for ActionArgs;\n\n    /// @inheritdoc IController\n    address public override optionsFactory;\n\n    /// @inheritdoc IController\n    address public override operateProxy;\n\n    /// @inheritdoc IController\n    address public override quantCalculator;\n\n    /// @inheritdoc IController\n    function operate(ActionArgs[] memory _actions)\n        external\n        override\n        nonReentrant\n        returns (bool)\n    {\n        uint256 length = _actions.length;\n        for (uint256 i = 0; i < length; ) {\n            ActionArgs memory action = _actions[i];\n\n            if (action.actionType == ActionType.MintOption) {\n                (address to, address qToken, uint256 amount) = action\n                    .parseMintOptionArgs();\n                _mintOptionsPosition(to, qToken, amount);\n            } else if (action.actionType == ActionType.MintSpread) {\n                (\n                    address qTokenToMint,\n                    address qTokenForCollateral,\n                    uint256 amount\n                ) = action.parseMintSpreadArgs();\n                _mintSpread(qTokenToMint, qTokenForCollateral, amount);\n            } else if (action.actionType == ActionType.Exercise) {\n                (address qToken, uint256 amount) = action.parseExerciseArgs();\n                _exercise(qToken, amount);\n            } else if (action.actionType == ActionType.ClaimCollateral) {\n                (uint256 collateralTokenId, uint256 amount) = action\n                    .parseClaimCollateralArgs();\n                _claimCollateral(collateralTokenId, amount);\n            } else if (action.actionType == ActionType.Neutralize) {\n                (uint256 collateralTokenId, uint256 amount) = action\n                    .parseNeutralizeArgs();\n                _neutralizePosition(collateralTokenId, amount);\n            } else if (action.actionType == ActionType.QTokenPermit) {\n                (\n                    address qToken,\n                    address owner,\n                    address spender,\n                    uint256 value,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = action.parseQTokenPermitArgs();\n                _qTokenPermit(qToken, owner, spender, value, deadline, v, r, s);\n            } else if (\n                action.actionType == ActionType.CollateralTokenApproval\n            ) {\n                (\n                    address owner,\n                    address operator,\n                    bool approved,\n                    uint256 nonce,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = action.parseCollateralTokenApprovalArgs();\n                _collateralTokenApproval(\n                    owner,\n                    operator,\n                    approved,\n                    nonce,\n                    deadline,\n                    v,\n                    r,\n                    s\n                );\n            } else {\n                require(\n                    action.actionType == ActionType.Call,\n                    \"Controller: Invalid action type\"\n                );\n                (address callee, bytes memory data) = action.parseCallArgs();\n                _call(callee, data);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return true;\n    }\n\n    // @inheritdoc IController\n    function initialize(\n        string memory _name,\n        string memory _version,\n        address _optionsFactory,\n        address _quantCalculator\n    ) public override initializer {\n        require(\n            _optionsFactory != address(0),\n            \"Controller: invalid OptionsFactory address\"\n        );\n        require(\n            _quantCalculator != address(0),\n            \"Controller: invalid QuantCalculator address\"\n        );\n\n        __ReentrancyGuard_init();\n        EIP712MetaTransaction.initializeEIP712(_name, _version);\n        optionsFactory = _optionsFactory;\n\n        /// @dev Unless this line is removed, a new OperateProxy will be created\n        /// during each upgrade. So make sure any application that requires approving\n        /// the OperateProxy to spend funds is aware of this.\n        operateProxy = address(new OperateProxy());\n\n        quantCalculator = _quantCalculator;\n    }\n\n    /// @notice Mints options for a given QToken, which must have been previously created in\n    /// the configured OptionsFactory.\n    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller\n    /// to spend the collateral asset, and then this function can be called, pulling the collateral\n    /// from the caller/signer and minting QTokens and CollateralTokens to the given `to` address.\n    /// Note that QTokens represent a long position, giving holders the ability to exercise options\n    /// after expiry, while CollateralTokens represent a short position, giving holders the ability\n    /// to claim the collateral after expiry.\n    /// @param _to The address to which the QTokens and CollateralTokens will be minted.\n    /// @param _qToken The QToken that represents the long position for the option to be minted.\n    /// @param _amount The amount of options to be minted.\n    function _mintOptionsPosition(\n        address _to,\n        address _qToken,\n        uint256 _amount\n    ) internal returns (uint256) {\n        IQToken qToken = IQToken(_qToken);\n\n        // get the collateral required to mint the specified amount of options\n        // the zero address is passed as the second argument as it's only used\n        // for spreads\n        (address collateral, uint256 collateralAmount) = IQuantCalculator(\n            quantCalculator\n        ).getCollateralRequirement(_qToken, address(0), _amount);\n\n        _checkIfUnexpiredQToken(_qToken);\n\n        // check if the oracle set during the option's creation through the OptionsFactory\n        // is an active oracle in the OracleRegistry\n        require(\n            IOracleRegistry(\n                IOptionsFactory(optionsFactory).quantConfig().protocolAddresses(\n                    ProtocolValue.encode(\"oracleRegistry\")\n                )\n            ).isOracleActive(qToken.oracle()),\n            \"Controller: Can't mint an options position as the oracle is inactive\"\n        );\n\n        // pull the required collateral from the caller/signer\n        IERC20(collateral).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            collateralAmount\n        );\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n\n        // Mint the options to the sender's address\n        qToken.mint(_to, _amount);\n        uint256 collateralTokenId = collateralToken.getCollateralTokenId(\n            _qToken,\n            address(0)\n        );\n\n        // There's no need to check if the collateralTokenId exists before minting because if the QToken is valid,\n        // then it's guaranteed that the respective CollateralToken has already also been created by the OptionsFactory\n        collateralToken.mintCollateralToken(_to, collateralTokenId, _amount);\n\n        emit OptionsPositionMinted(\n            _to,\n            _msgSender(),\n            _qToken,\n            _amount,\n            collateral,\n            collateralAmount\n        );\n\n        return collateralTokenId;\n    }\n\n    /// @notice Creates a spread position from an option to long and another option to short.\n    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller\n    /// to spend the collateral asset in cases of a debit spread.\n    /// @param _qTokenToMint The QToken for the option to be long.\n    /// @param _qTokenForCollateral The QToken for the option to be short.\n    /// @param _amount The amount of long options to be minted.\n    function _mintSpread(\n        address _qTokenToMint,\n        address _qTokenForCollateral,\n        uint256 _amount\n    ) internal returns (uint256) {\n        require(\n            _qTokenToMint != _qTokenForCollateral,\n            \"Controller: Can only create a spread with different tokens\"\n        );\n\n        IQToken qTokenToMint = IQToken(_qTokenToMint);\n        IQToken qTokenForCollateral = IQToken(_qTokenForCollateral);\n\n        // Calculate the extra collateral required to create the spread.\n        // A positive value for debit spreads and zero for credit spreads.\n        (address collateral, uint256 collateralAmount) = IQuantCalculator(\n            quantCalculator\n        ).getCollateralRequirement(\n                _qTokenToMint,\n                _qTokenForCollateral,\n                _amount\n            );\n\n        _checkIfUnexpiredQToken(_qTokenToMint);\n        _checkIfUnexpiredQToken(_qTokenForCollateral);\n\n        // Burn the QToken being shorted\n        qTokenForCollateral.burn(_msgSender(), _amount);\n\n        // Transfer in any collateral required for the spread\n        if (collateralAmount > 0) {\n            IERC20(collateral).safeTransferFrom(\n                _msgSender(),\n                address(this),\n                collateralAmount\n            );\n        }\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n\n        // Check if the CollateralToken representing this specific spread has already been created\n        // Create it if it hasn't\n        uint256 collateralTokenId = collateralToken.getCollateralTokenId(\n            _qTokenToMint,\n            _qTokenForCollateral\n        );\n        (, address qTokenAsCollateral) = collateralToken.idToInfo(\n            collateralTokenId\n        );\n        if (qTokenAsCollateral == address(0)) {\n            require(\n                collateralTokenId ==\n                    collateralToken.createCollateralToken(\n                        _qTokenToMint,\n                        _qTokenForCollateral\n                    ),\n                \"Controller: failed creating the collateral token to represent the spread\"\n            );\n        }\n\n        // Mint the tokens for the new spread position\n        collateralToken.mintCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            _amount\n        );\n        qTokenToMint.mint(_msgSender(), _amount);\n\n        emit SpreadMinted(\n            _msgSender(),\n            _qTokenToMint,\n            _qTokenForCollateral,\n            _amount,\n            collateral,\n            collateralAmount\n        );\n\n        return collateralTokenId;\n    }\n\n    /// @notice Closes a long position after the option's expiry.\n    /// @dev Pass an `_amount` of 0 to close the entire position.\n    /// @param _qToken The QToken representing the long position to be closed.\n    /// @param _amount The amount of options to exercise.\n    function _exercise(address _qToken, uint256 _amount) internal {\n        IQToken qToken = IQToken(_qToken);\n        require(\n            block.timestamp > qToken.expiryTime(),\n            \"Controller: Can not exercise options before their expiry\"\n        );\n\n        uint256 amountToExercise = _amount;\n        // if the amount is 0, the entire position will be exercised\n        if (amountToExercise == 0) {\n            amountToExercise = qToken.balanceOf(_msgSender());\n        }\n\n        // Use the QuantCalculator to check how much the sender/signer is due.\n        // Will only be a positive value for options that expired In The Money.\n        (\n            bool isSettled,\n            address payoutToken,\n            uint256 exerciseTotal\n        ) = IQuantCalculator(quantCalculator).getExercisePayout(\n                address(qToken),\n                amountToExercise\n            );\n\n        require(isSettled, \"Controller: Cannot exercise unsettled options\");\n\n        // Burn the long tokens\n        qToken.burn(_msgSender(), amountToExercise);\n\n        // Transfer any profit due after expiration\n        if (exerciseTotal > 0) {\n            IERC20(payoutToken).safeTransfer(_msgSender(), exerciseTotal);\n        }\n\n        emit OptionsExercised(\n            _msgSender(),\n            address(qToken),\n            amountToExercise,\n            exerciseTotal,\n            payoutToken\n        );\n    }\n\n    /// @notice Closes a short position after the option's expiry.\n    /// @param _collateralTokenId ERC1155 token id representing the short position to be closed.\n    /// @param _amount The size of the position to close.\n    function _claimCollateral(uint256 _collateralTokenId, uint256 _amount)\n        internal\n    {\n        uint256 collateralTokenId = _collateralTokenId;\n\n        // Use the QuantCalculator to check how much collateral the sender/signer is due.\n        (\n            uint256 returnableCollateral,\n            address collateralAsset,\n            uint256 amountToClaim\n        ) = IQuantCalculator(quantCalculator).calculateClaimableCollateral(\n                collateralTokenId,\n                _amount,\n                _msgSender()\n            );\n\n        // Burn the short tokens\n        IOptionsFactory(optionsFactory).collateralToken().burnCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            amountToClaim\n        );\n\n        // Transfer any collateral due after expiration\n        if (returnableCollateral > 0) {\n            IERC20(collateralAsset).safeTransfer(\n                _msgSender(),\n                returnableCollateral\n            );\n        }\n\n        emit CollateralClaimed(\n            _msgSender(),\n            collateralTokenId,\n            amountToClaim,\n            returnableCollateral,\n            collateralAsset\n        );\n    }\n\n    /// @notice Closes a neutral position, claiming all the collateral required to create it.\n    /// @dev Unlike `_exercise` and `_claimCollateral`, this function does not require the option to be expired.\n    /// @param _collateralTokenId ERC1155 token id representing the position to be closed.\n    /// @param _amount The size of the position to close.\n    function _neutralizePosition(uint256 _collateralTokenId, uint256 _amount)\n        internal\n    {\n        /// @dev Put these values in the stack to save gas from having to read\n        /// from calldata\n        (uint256 collateralTokenId, uint256 amount) = (\n            _collateralTokenId,\n            _amount\n        );\n\n        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)\n            .collateralToken();\n        (address qTokenShort, address qTokenLong) = collateralToken.idToInfo(\n            collateralTokenId\n        );\n\n        //get the amount of CollateralTokens owned\n        uint256 collateralTokensOwned = collateralToken.balanceOf(\n            _msgSender(),\n            collateralTokenId\n        );\n\n        //get the amount of QTokens owned\n        uint256 qTokensOwned = IQToken(qTokenShort).balanceOf(_msgSender());\n\n        // the size of the position that can be neutralized\n        uint256 maxNeutralizable = qTokensOwned < collateralTokensOwned\n            ? qTokensOwned\n            : collateralTokensOwned;\n\n        // make sure that the amount passed is not greater than the amount that can be neutralized\n        uint256 amountToNeutralize;\n        if (amount != 0) {\n            require(\n                amount <= maxNeutralizable,\n                \"Controller: Tried to neutralize more than balance\"\n            );\n            amountToNeutralize = amount;\n        } else {\n            amountToNeutralize = maxNeutralizable;\n        }\n\n        // use the QuantCalculator to check how much collateral the sender/signer is due\n        // for closing the neutral position\n        (address collateralType, uint256 collateralOwed) = IQuantCalculator(\n            quantCalculator\n        ).getNeutralizationPayout(qTokenShort, qTokenLong, amountToNeutralize);\n\n        // burn the short tokens\n        IQToken(qTokenShort).burn(_msgSender(), amountToNeutralize);\n\n        // burn the long tokens\n        collateralToken.burnCollateralToken(\n            _msgSender(),\n            collateralTokenId,\n            amountToNeutralize\n        );\n\n        // tranfer the collateral owed\n        IERC20(collateralType).safeTransfer(_msgSender(), collateralOwed);\n\n        //give the user their long tokens (if any, in case of CollateralTokens representing a spread)\n        if (qTokenLong != address(0)) {\n            IQToken(qTokenLong).mint(_msgSender(), amountToNeutralize);\n        }\n\n        emit NeutralizePosition(\n            _msgSender(),\n            qTokenShort,\n            amountToNeutralize,\n            collateralOwed,\n            collateralType,\n            qTokenLong\n        );\n    }\n\n    /// @notice Allows a QToken owner to approve a spender to transfer a specified amount of tokens on their behalf.\n    /// @param _qToken The QToken to be approved.\n    /// @param _spender The address of the spender.\n    /// @param _value The amount of tokens to be approved for spending.\n    /// @param _deadline Timestamp at which the permit signature expires.\n    /// @param _v The signature's v value.\n    /// @param _r The signature's r value.\n    /// @param _s The signature's s value.\n    function _qTokenPermit(\n        address _qToken,\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        IQToken(_qToken).permit(\n            _owner,\n            _spender,\n            _value,\n            _deadline,\n            _v,\n            _r,\n            _s\n        );\n    }\n\n    /// @notice Allows a CollateralToken owner to either approve an operator address\n    /// to spend all of their tokens on their behalf, or to remove a prior approval.\n    /// @param _owner The address of the owner of the CollateralToken.\n    /// @param _operator The address of the operator to be approved or removed.\n    /// @param _approved Whether the operator is being approved or removed.\n    /// @param _nonce The nonce for the approval through a meta transaction.\n    /// @param _deadline Timestamp at which the approval signature expires.\n    /// @param _v The signature's v value.\n    /// @param _r The signature's r value.\n    /// @param _s The signature's s value.\n    function _collateralTokenApproval(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _nonce,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        IOptionsFactory(optionsFactory).collateralToken().metaSetApprovalForAll(\n                _owner,\n                _operator,\n                _approved,\n                _nonce,\n                _deadline,\n                _v,\n                _r,\n                _s\n            );\n    }\n\n    /// @notice Allows a sender/signer to make external calls to any other contract.\n    /// @dev A separate OperateProxy contract is used to make the external calls so\n    /// that the Controller, which holds funds and has special privileges in the Quant\n    /// Protocol, is never the `msg.sender` in any of those external calls.\n    /// @param _callee The address of the contract to be called.\n    /// @param _data The calldata to be sent to the contract.\n    function _call(address _callee, bytes memory _data) internal {\n        IOperateProxy(operateProxy).callFunction(_callee, _data);\n    }\n\n    /// @notice Checks if the given QToken has not expired yet, reverting otherwise\n    /// @param _qToken The address of the QToken to check.\n    function _checkIfUnexpiredQToken(address _qToken) internal view {\n        require(\n            IQToken(_qToken).expiryTime() > block.timestamp,\n            \"Controller: Cannot mint expired options\"\n        );\n    }\n}"
    }
  ]
}