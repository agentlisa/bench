{
  "Title": "An event is omitted",
  "Content": "##### Description\nThere are omitted events at the lines:\n- https://github.com/lidofinance/lido-dao/blob/5b449b740cddfbef5c107505677e6a576e2c2b69/contracts/0.8.9/DepositSecurityModule.sol#L425\n\n- https://github.com/lidofinance/lido-dao/blob/5b449b740cddfbef5c107505677e6a576e2c2b69/contracts/0.4.24/Lido.sol#L283\n- https://github.com/lidofinance/lido-dao/blob/5b449b740cddfbef5c107505677e6a576e2c2b69/contracts/0.4.24/Lido.sol#L406\n- https://github.com/lidofinance/lido-dao/blob/5b449b740cddfbef5c107505677e6a576e2c2b69/contracts/0.4.24/Lido.sol#L415\n- https://github.com/lidofinance/lido-dao/blob/5b449b740cddfbef5c107505677e6a576e2c2b69/contracts/0.4.24/Lido.sol#L424\n- https://github.com/lidofinance/lido-dao/blob/5b449b740cddfbef5c107505677e6a576e2c2b69/contracts/0.4.24/Lido.sol#L429\n- https://github.com/lidofinance/lido-dao/blob/5b449b740cddfbef5c107505677e6a576e2c2b69/contracts/0.4.24/Lido.sol#L434\n- https://github.com/lidofinance/lido-dao/blob/5b449b740cddfbef5c107505677e6a576e2c2b69/contracts/0.4.24/Lido.sol#L546\n- https://github.com/lidofinance/lido-dao/blob/5b449b740cddfbef5c107505677e6a576e2c2b69/contracts/0.4.24/Lido.sol#L656\n##### Recommendation\nIt is recommended to add events.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/0.8.9/DepositSecurityModule.sol",
      "content": "// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.8.9;\n\nimport {ECDSA} from \"./lib/ECDSA.sol\";\n\n\ninterface IDepositContract {\n    function get_deposit_root() external view returns (bytes32 rootHash);\n}\n\n\ninterface ILido {\n    function depositBufferedEther(uint256 maxDeposits) external;\n}\n\n\ninterface INodeOperatorsRegistry {\n    function getKeysOpIndex() external view returns (uint256 index);\n}\n\n\ncontract DepositSecurityModule {\n    /**\n     * Short ECDSA signature as defined in https://eips.ethereum.org/EIPS/eip-2098.\n     */\n    struct Signature {\n        bytes32 r;\n        bytes32 vs;\n    }\n\n    event OwnerChanged(address newValue);\n    event NodeOperatorsRegistryChanged(address newValue);\n    event PauseIntentValidityPeriodBlocksChanged(uint256 newValue);\n    event MaxDepositsChanged(uint256 newValue);\n    event MinDepositBlockDistanceChanged(uint256 newValue);\n    event GuardianQuorumChanged(uint256 newValue);\n    event GuardianAdded(address guardian);\n    event GuardianRemoved(address guardian);\n    event DepositsPaused(address guardian);\n    event DepositsUnpaused();\n\n\n    bytes32 public immutable ATTEST_MESSAGE_PREFIX;\n    bytes32 public immutable PAUSE_MESSAGE_PREFIX;\n\n    address public immutable LIDO;\n    address public immutable DEPOSIT_CONTRACT;\n\n    address internal nodeOperatorsRegistry;\n    uint256 internal maxDepositsPerBlock;\n    uint256 internal minDepositBlockDistance;\n    uint256 internal pauseIntentValidityPeriodBlocks;\n\n    address internal owner;\n\n    address[] internal guardians;\n    mapping(address => uint256) guardianIndicesOneBased; // 1-based\n    uint256 internal quorum;\n\n    bool internal paused;\n    uint256 internal lastDepositBlock;\n\n\n    constructor(\n        address _lido,\n        address _depositContract,\n        address _nodeOperatorsRegistry,\n        uint256 _networkId,\n        uint256 _maxDepositsPerBlock,\n        uint256 _minDepositBlockDistance,\n        uint256 _pauseIntentValidityPeriodBlocks\n    ) {\n        LIDO = _lido;\n        DEPOSIT_CONTRACT = _depositContract;\n\n        ATTEST_MESSAGE_PREFIX = keccak256(abi.encodePacked(\n            // keccak256(\"lido.DepositSecurityModule.ATTEST_MESSAGE\")\n            bytes32(0x1085395a994e25b1b3d0ea7937b7395495fb405b31c7d22dbc3976a6bd01f2bf),\n            _networkId\n        ));\n\n        PAUSE_MESSAGE_PREFIX = keccak256(abi.encodePacked(\n            // keccak256(\"lido.DepositSecurityModule.PAUSE_MESSAGE\")\n            bytes32(0x9c4c40205558f12027f21204d6218b8006985b7a6359bcab15404bcc3e3fa122),\n            _networkId\n        ));\n\n        _setOwner(msg.sender);\n        _setNodeOperatorsRegistry(_nodeOperatorsRegistry);\n        _setMaxDeposits(_maxDepositsPerBlock);\n        _setMinDepositBlockDistance(_minDepositBlockDistance);\n        _setPauseIntentValidityPeriodBlocks(_pauseIntentValidityPeriodBlocks);\n\n        paused = false;\n        lastDepositBlock = 0;\n    }\n\n\n    /**\n     * Returns the owner address.\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"not an owner\");\n        _;\n    }\n\n    /**\n     * Sets new owner. Only callable by the current owner.\n     */\n    function setOwner(address newValue) external onlyOwner {\n        _setOwner(newValue);\n    }\n\n    function _setOwner(address newValue) internal {\n        owner = newValue;\n        emit OwnerChanged(newValue);\n    }\n\n\n    /**\n     * Returns NodeOperatorsRegistry contract address.\n     */\n    function getNodeOperatorsRegistry() external view returns (address) {\n        return nodeOperatorsRegistry;\n    }\n\n    /**\n     * Sets NodeOperatorsRegistry contract address. Only callable by the owner.\n     */\n    function setNodeOperatorsRegistry(address newValue) external onlyOwner {\n        _setNodeOperatorsRegistry(newValue);\n    }\n\n    function _setNodeOperatorsRegistry(address newValue) internal {\n        nodeOperatorsRegistry = newValue;\n        emit NodeOperatorsRegistryChanged(newValue);\n    }\n\n\n    /**\n     * Returns `PAUSE_INTENT_VALIDITY_PERIOD_BLOCKS` (see `pauseDeposits`).\n     */\n    function getPauseIntentValidityPeriodBlocks() external view returns (uint256) {\n        return pauseIntentValidityPeriodBlocks;\n    }\n\n    /**\n     * Sets `PAUSE_INTENT_VALIDITY_PERIOD_BLOCKS`. Only callable by the owner.\n     */\n    function setPauseIntentValidityPeriodBlocks(uint256 newValue) external onlyOwner {\n        _setPauseIntentValidityPeriodBlocks(newValue);\n    }\n\n    function _setPauseIntentValidityPeriodBlocks(uint256 newValue) internal {\n        require(newValue > 0, \"invalid value for pauseIntentValidityPeriodBlocks: must be greater then 0\");\n        pauseIntentValidityPeriodBlocks = newValue;\n        emit PauseIntentValidityPeriodBlocksChanged(newValue);\n    }\n\n\n    /**\n     * Returns `maxDepositsPerBlock` (see `depositBufferedEther`).\n     */\n    function getMaxDeposits() external view returns (uint256) {\n        return maxDepositsPerBlock;\n    }\n\n    /**\n     * Sets `maxDepositsPerBlock`. Only callable by the owner.\n     */\n    function setMaxDeposits(uint256 newValue) external onlyOwner {\n        _setMaxDeposits(newValue);\n    }\n\n    function _setMaxDeposits(uint256 newValue) internal {\n        maxDepositsPerBlock = newValue;\n        emit MaxDepositsChanged(newValue);\n    }\n\n\n    /**\n     * Returns `MIN_DEPOSIT_BLOCK_DISTANCE`  (see `depositBufferedEther`).\n     */\n    function getMinDepositBlockDistance() external view returns (uint256) {\n        return minDepositBlockDistance;\n    }\n\n    /**\n     * Sets `MIN_DEPOSIT_BLOCK_DISTANCE`. Only callable by the owner.\n     */\n    function setMinDepositBlockDistance(uint256 newValue) external onlyOwner {\n        _setMinDepositBlockDistance(newValue);\n    }\n\n    function _setMinDepositBlockDistance(uint256 newValue) internal {\n        require(newValue > 0, \"invalid value for minDepositBlockDistance: must be greater then 0\");\n        minDepositBlockDistance = newValue;\n        emit MinDepositBlockDistanceChanged(newValue);\n    }\n\n\n    /**\n     * Returns number of valid guardian signatures required to vet (depositRoot, keysOpIndex) pair.\n     */\n    function getGuardianQuorum() external view returns (uint256) {\n        return quorum;\n    }\n\n    function setGuardianQuorum(uint256 newValue) external onlyOwner {\n        _setGuardianQuorum(newValue);\n    }\n\n    function _setGuardianQuorum(uint256 newValue) internal {\n        // we're intentionally allowing setting quorum value higher than the number of quardians\n        quorum = newValue;\n        emit GuardianQuorumChanged(newValue);\n    }\n\n\n    /**\n     * Returns guardian committee member list.\n     */\n    function getGuardians() external view returns (address[] memory) {\n        return guardians;\n    }\n\n    /**\n     * Checks whether the given address is a guardian.\n     */\n    function isGuardian(address addr) external view returns (bool) {\n        return _isGuardian(addr);\n    }\n\n    function _isGuardian(address addr) internal view returns (bool) {\n        return guardianIndicesOneBased[addr] > 0;\n    }\n\n    /**\n     * Returns index of the guardian, or -1 if the address is not a guardian.\n     */\n    function getGuardianIndex(address addr) external view returns (int256) {\n        return _getGuardianIndex(addr);\n    }\n\n    function _getGuardianIndex(address addr) internal view returns (int256) {\n        return int256(guardianIndicesOneBased[addr]) - 1;\n    }\n\n    /**\n     * Adds a guardian address and sets a new quorum value.\n     * Reverts if the address is already a guardian.\n     *\n     * Only callable by the owner.\n     */\n    function addGuardian(address addr, uint256 newQuorum) external onlyOwner {\n        _addGuardian(addr);\n        _setGuardianQuorum(newQuorum);\n    }\n\n    /**\n     * Adds a set of guardian addresses and sets a new quorum value.\n     * Reverts any of them is already a guardian.\n     *\n     * Only callable by the owner.\n     */\n    function addGuardians(address[] memory addresses, uint256 newQuorum) external onlyOwner {\n        for (uint256 i = 0; i < addresses.length; ++i) {\n            _addGuardian(addresses[i]);\n        }\n        _setGuardianQuorum(newQuorum);\n    }\n\n    function _addGuardian(address addr) internal {\n        require(!_isGuardian(addr), \"duplicate address\");\n        guardians.push(addr);\n        guardianIndicesOneBased[addr] = guardians.length;\n        emit GuardianAdded(addr);\n    }\n\n    /**\n     * Removes a guardian with the given address and sets a new quorum value.\n     *\n     * Only callable by the owner.\n     */\n    function removeGuardian(address addr, uint256 newQuorum) external onlyOwner {\n        uint256 indexOneBased = guardianIndicesOneBased[addr];\n        require(indexOneBased != 0, \"not a guardian\");\n\n        uint256 totalGuardians = guardians.length;\n        assert(indexOneBased <= totalGuardians);\n\n        if (indexOneBased != totalGuardians) {\n            address addrToMove = guardians[totalGuardians - 1];\n            guardians[indexOneBased - 1] = addrToMove;\n            guardianIndicesOneBased[addrToMove] = indexOneBased;\n        }\n\n        guardianIndicesOneBased[addr] = 0;\n        guardians.pop();\n\n        _setGuardianQuorum(newQuorum);\n\n        emit GuardianRemoved(addr);\n    }\n\n\n    /**\n     * Returns whether deposits were paused.\n     */\n    function isPaused() external view returns (bool) {\n        return paused;\n    }\n\n    /**\n     * Pauses deposits given that both conditions are satisfied (reverts otherwise):\n     *\n     *   1. The function is called by the guardian with index guardianIndex OR sig\n     *      is a valid signature by the guardian with index guardianIndex of the data\n     *      defined below.\n     *\n     *   2. block.number - blockNumber <= PAUSE_INTENT_VALIDITY_PERIOD_BLOCKS\n     *\n     * The signature, if present, must be produced for keccak256 hash of the following\n     * message (each component taking 32 bytes):\n     *\n     * | PAUSE_MESSAGE_PREFIX | blockNumber\n     */\n    function pauseDeposits(uint256 blockNumber, Signature memory sig) external {\n        address guardianAddr = msg.sender;\n        int256 guardianIndex = _getGuardianIndex(msg.sender);\n\n        if (guardianIndex == -1) {\n            bytes32 msgHash = keccak256(abi.encodePacked(PAUSE_MESSAGE_PREFIX, blockNumber));\n            guardianAddr = ECDSA.recover(msgHash, sig.r, sig.vs);\n            guardianIndex = _getGuardianIndex(guardianAddr);\n            require(guardianIndex != -1, \"invalid signature\");\n        }\n\n        require(\n            block.number - blockNumber <= pauseIntentValidityPeriodBlocks,\n            \"pause intent expired\"\n        );\n\n        if (!paused) {\n            paused = true;\n            emit DepositsPaused(guardianAddr);\n        }\n    }\n\n    /**\n     * Unpauses deposits.\n     *\n     * Only callable by the owner.\n     */\n    function unpauseDeposits() external onlyOwner {\n        if (paused) {\n            paused = false;\n            emit DepositsUnpaused();\n        }\n    }\n\n\n    /**\n     * Returns whether depositBufferedEther can be called, given that the caller will provide\n     * guardian attestations of non-stale deposit root and `keysOpIndex`, and the number of\n     * such attestations will be enough to reach quorum.\n     */\n    function canDeposit() external view returns (bool) {\n        return !paused && quorum > 0 && block.number - lastDepositBlock >= minDepositBlockDistance;\n    }\n\n\n    /**\n     * Calls Lido.depositBufferedEther(maxDeposits).\n     *\n     * Reverts if any of the following is true:\n     *   1. IDepositContract.get_deposit_root() != depositRoot.\n     *   2. INodeOperatorsRegistry.getKeysOpIndex() != keysOpIndex.\n     *   3. The number of guardian signatures is less than getGuardianQuorum().\n     *   4. An invalid or non-guardian signature received.\n     *   5. block.number - lastLidoDepositBlock < MIN_DEPOSIT_BLOCK_DISTANCE\n     *   6. blockhash(blockNumber) == blockHash\n     *\n     * Signatures must be sorted in ascending order by index of the guardian. Each signature must\n     * be produced for keccak256 hash of the following message (each component taking 32 bytes):\n     *\n     * | ATTEST_MESSAGE_PREFIX | depositRoot | keysOpIndex | blockNumber | blockHash |\n     */\n    function depositBufferedEther(\n        bytes32 depositRoot,\n        uint256 keysOpIndex,\n        uint256 blockNumber,\n        bytes32 blockHash,\n        Signature[] memory sortedGuardianSignatures\n    ) external {\n        bytes32 onchainDepositRoot = IDepositContract(DEPOSIT_CONTRACT).get_deposit_root();\n        require(depositRoot == onchainDepositRoot, \"deposit root changed\");\n\n        require(!paused, \"deposits are paused\");\n        require(quorum > 0 && sortedGuardianSignatures.length >= quorum, \"no guardian quorum\");\n\n        require(block.number - lastDepositBlock >= minDepositBlockDistance, \"too frequent deposits\");\n        require(blockHash != bytes32(0) && blockhash(blockNumber) == blockHash, \"unexpected block hash\");\n\n        uint256 onchainKeysOpIndex = INodeOperatorsRegistry(nodeOperatorsRegistry).getKeysOpIndex();\n        require(keysOpIndex == onchainKeysOpIndex, \"keys op index changed\");\n\n        _verifySignatures(\n            depositRoot,\n            keysOpIndex,\n            blockNumber,\n            blockHash,\n            sortedGuardianSignatures\n        );\n\n        ILido(LIDO).depositBufferedEther(maxDepositsPerBlock);\n        lastDepositBlock = block.number;\n    }\n\n\n    function _verifySignatures(\n        bytes32 depositRoot,\n        uint256 keysOpIndex,\n        uint256 blockNumber,\n        bytes32 blockHash,\n        Signature[] memory sigs\n    )\n        internal view\n    {\n        bytes32 msgHash = keccak256(abi.encodePacked(\n            ATTEST_MESSAGE_PREFIX,\n            depositRoot,\n            keysOpIndex,\n            blockNumber,\n            blockHash\n        ));\n\n        address prevSignerAddr = address(0);\n\n        for (uint256 i = 0; i < sigs.length; ++i) {\n            address signerAddr = ECDSA.recover(msgHash, sigs[i].r, sigs[i].vs);\n            require(_isGuardian(signerAddr), \"invalid signature\");\n            require(signerAddr > prevSignerAddr, \"signatures not sorted\");\n            prevSignerAddr = signerAddr;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/0.4.24/Lido.sol",
      "content": "// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.4.24;\n\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport \"@aragon/os/contracts/lib/math/SafeMath.sol\";\nimport \"@aragon/os/contracts/lib/math/SafeMath64.sol\";\nimport \"@aragon/os/contracts/common/IsContract.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport \"./interfaces/ILido.sol\";\nimport \"./interfaces/INodeOperatorsRegistry.sol\";\nimport \"./interfaces/IDepositContract.sol\";\n\nimport \"./StETH.sol\";\n\n\n/**\n* @title Liquid staking pool implementation\n*\n* Lido is an Ethereum 2.0 liquid staking protocol solving the problem of frozen staked Ethers\n* until transfers become available in Ethereum 2.0.\n* Whitepaper: https://lido.fi/static/Lido:Ethereum-Liquid-Staking.pdf\n*\n* NOTE: the code below assumes moderate amount of node operators, e.g. up to 50.\n*\n* Since balances of all token holders change when the amount of total pooled Ether\n* changes, this token cannot fully implement ERC20 standard: it only emits `Transfer`\n* events upon explicit transfer between holders. In contrast, when Lido oracle reports\n* rewards, no Transfer events are generated: doing so would require emitting an event\n* for each token holder and thus running an unbounded loop.\n*/\ncontract Lido is ILido, IsContract, StETH, AragonApp {\n    using SafeMath for uint256;\n    using SafeMath64 for uint64;\n    using UnstructuredStorage for bytes32;\n\n    /// ACL\n    bytes32 constant public PAUSE_ROLE = keccak256(\"PAUSE_ROLE\");\n    bytes32 constant public MANAGE_FEE = keccak256(\"MANAGE_FEE\");\n    bytes32 constant public MANAGE_WITHDRAWAL_KEY = keccak256(\"MANAGE_WITHDRAWAL_KEY\");\n    bytes32 constant public SET_ORACLE = keccak256(\"SET_ORACLE\");\n    bytes32 constant public BURN_ROLE = keccak256(\"BURN_ROLE\");\n    bytes32 constant public SET_TREASURY = keccak256(\"SET_TREASURY\");\n    bytes32 constant public SET_INSURANCE_FUND = keccak256(\"SET_INSURANCE_FUND\");\n    bytes32 constant public DEPOSIT_ROLE = keccak256(\"DEPOSIT_ROLE\");\n\n    uint256 constant public PUBKEY_LENGTH = 48;\n    uint256 constant public WITHDRAWAL_CREDENTIALS_LENGTH = 32;\n    uint256 constant public SIGNATURE_LENGTH = 96;\n\n    uint256 constant public DEPOSIT_SIZE = 32 ether;\n\n    uint256 internal constant DEPOSIT_AMOUNT_UNIT = 1000000000 wei;\n\n    /// @dev default value for maximum number of Ethereum 2.0 validators registered in a single depositBufferedEther call\n    uint256 internal constant DEFAULT_MAX_DEPOSITS_PER_CALL = 150;\n\n    bytes32 internal constant FEE_POSITION = keccak256(\"lido.Lido.fee\");\n    bytes32 internal constant TREASURY_FEE_POSITION = keccak256(\"lido.Lido.treasuryFee\");\n    bytes32 internal constant INSURANCE_FEE_POSITION = keccak256(\"lido.Lido.insuranceFee\");\n    bytes32 internal constant NODE_OPERATORS_FEE_POSITION = keccak256(\"lido.Lido.nodeOperatorsFee\");\n\n    bytes32 internal constant DEPOSIT_CONTRACT_POSITION = keccak256(\"lido.Lido.depositContract\");\n    bytes32 internal constant ORACLE_POSITION = keccak256(\"lido.Lido.oracle\");\n    bytes32 internal constant NODE_OPERATORS_REGISTRY_POSITION = keccak256(\"lido.Lido.nodeOperatorsRegistry\");\n    bytes32 internal constant TREASURY_POSITION = keccak256(\"lido.Lido.treasury\");\n    bytes32 internal constant INSURANCE_FUND_POSITION = keccak256(\"lido.Lido.insuranceFund\");\n\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION = keccak256(\"lido.Lido.bufferedEther\");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION = keccak256(\"lido.Lido.depositedValidators\");\n    /// @dev total amount of Beacon-side Ether (sum of all the balances of Lido validators)\n    bytes32 internal constant BEACON_BALANCE_POSITION = keccak256(\"lido.Lido.beaconBalance\");\n    /// @dev number of Lido's validators available in the Beacon state\n    bytes32 internal constant BEACON_VALIDATORS_POSITION = keccak256(\"lido.Lido.beaconValidators\");\n\n    /// @dev Credentials which allows the DAO to withdraw Ether on the 2.0 side\n    bytes32 internal constant WITHDRAWAL_CREDENTIALS_POSITION = keccak256(\"lido.Lido.withdrawalCredentials\");\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    * @param depositContract official ETH2 Deposit contract\n    * @param _oracle oracle contract\n    * @param _operators instance of Node Operators Registry\n    */\n    function initialize(\n        IDepositContract depositContract,\n        address _oracle,\n        INodeOperatorsRegistry _operators,\n        address _treasury,\n        address _insuranceFund\n    )\n        public onlyInit\n    {\n        _setDepositContract(depositContract);\n        _setOracle(_oracle);\n        _setOperators(_operators);\n        _setTreasury(_treasury);\n        _setInsuranceFund(_insuranceFund);\n\n        initialized();\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Eth2.0 Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * depositBufferedEther() and pushes them to the ETH2 Deposit contract.\n    */\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, \"NON_EMPTY_DATA\");\n        _submit(0);\n    }\n\n    /**\n    * @notice Send funds to the pool with optional _referral parameter\n    * @dev This function is alternative way to submit funds. Supports optional referral address.\n    * @return Amount of StETH shares generated\n    */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n    * @notice Deposits buffered ethers to the official DepositContract.\n    * @dev This function is separated from submit() to reduce the cost of sending funds.\n    */\n    function depositBufferedEther() external auth(DEPOSIT_ROLE) {\n        return _depositBufferedEther(DEFAULT_MAX_DEPOSITS_PER_CALL);\n    }\n\n    /**\n      * @notice Deposits buffered ethers to the official DepositContract, making no more than `_maxDeposits` deposit calls.\n      * @dev This function is separated from submit() to reduce the cost of sending funds.\n      */\n    function depositBufferedEther(uint256 _maxDeposits) external auth(DEPOSIT_ROLE) {\n        return _depositBufferedEther(_maxDeposits);\n    }\n\n    function burnShares(address _account, uint256 _sharesAmount)\n        external\n        authP(BURN_ROLE, arr(_account, _sharesAmount))\n        returns (uint256 newTotalShares)\n    {\n        return _burnShares(_account, _sharesAmount);\n    }\n\n    /**\n      * @notice Stop pool routine operations\n      */\n    function stop() external auth(PAUSE_ROLE) {\n        _stop();\n    }\n\n    /**\n      * @notice Resume pool routine operations\n      */\n    function resume() external auth(PAUSE_ROLE) {\n        _resume();\n    }\n\n    /**\n      * @notice Set fee rate to `_feeBasisPoints` basis points. The fees are accrued when oracles report staking results\n      * @param _feeBasisPoints Fee rate, in basis points\n      */\n    function setFee(uint16 _feeBasisPoints) external auth(MANAGE_FEE) {\n        _setBPValue(FEE_POSITION, _feeBasisPoints);\n        emit FeeSet(_feeBasisPoints);\n    }\n\n    /**\n      * @notice Set fee distribution: `_treasuryFeeBasisPoints` basis points go to the treasury, `_insuranceFeeBasisPoints` basis points go to the insurance fund, `_operatorsFeeBasisPoints` basis points go to node operators. The sum has to be 10 000.\n      */\n    function setFeeDistribution(\n        uint16 _treasuryFeeBasisPoints,\n        uint16 _insuranceFeeBasisPoints,\n        uint16 _operatorsFeeBasisPoints\n    )\n        external auth(MANAGE_FEE)\n    {\n        require(\n            10000 == uint256(_treasuryFeeBasisPoints)\n            .add(uint256(_insuranceFeeBasisPoints))\n            .add(uint256(_operatorsFeeBasisPoints)),\n            \"FEES_DONT_ADD_UP\"\n        );\n\n        _setBPValue(TREASURY_FEE_POSITION, _treasuryFeeBasisPoints);\n        _setBPValue(INSURANCE_FEE_POSITION, _insuranceFeeBasisPoints);\n        _setBPValue(NODE_OPERATORS_FEE_POSITION, _operatorsFeeBasisPoints);\n\n        emit FeeDistributionSet(_treasuryFeeBasisPoints, _insuranceFeeBasisPoints, _operatorsFeeBasisPoints);\n    }\n\n    /**\n      * @notice Set authorized oracle contract address to `_oracle`\n      * @dev Contract specified here is allowed to make periodical updates of beacon states\n      * by calling pushBeacon.\n      * @param _oracle oracle contract\n      */\n    function setOracle(address _oracle) external auth(SET_ORACLE) {\n        _setOracle(_oracle);\n    }\n\n    /**\n      * @notice Set treasury contract address to `_treasury`\n      * @dev Contract specified here is used to accumulate the protocol treasury fee.\n      * @param _treasury contract which accumulates treasury fee.\n      */\n    function setTreasury(address _treasury) external auth(SET_TREASURY) {\n        _setTreasury(_treasury);\n    }\n\n    /**\n      * @notice Set insuranceFund contract address to `_insuranceFund`\n      * @dev Contract specified here is used to accumulate the protocol insurance fee.\n      * @param _insuranceFund contract which accumulates insurance fee.\n      */\n    function setInsuranceFund(address _insuranceFund) external auth(SET_INSURANCE_FUND) {\n        _setInsuranceFund(_insuranceFund);\n    }\n\n    /**\n      * @notice Set credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched to `_withdrawalCredentials`\n      * @dev Note that setWithdrawalCredentials discards all unused signing keys as the signatures are invalidated.\n      * @param _withdrawalCredentials hash of withdrawal multisignature key as accepted by\n      *        the deposit_contract.deposit function\n      */\n    function setWithdrawalCredentials(bytes32 _withdrawalCredentials) external auth(MANAGE_WITHDRAWAL_KEY) {\n        WITHDRAWAL_CREDENTIALS_POSITION.setStorageBytes32(_withdrawalCredentials);\n        getOperators().trimUnusedKeys();\n\n        emit WithdrawalCredentialsSet(_withdrawalCredentials);\n    }\n\n    /**\n      * @notice Issues withdrawal request. Not implemented.\n      * @param _amount Amount of StETH to withdraw\n      * @param _pubkeyHash Receiving address\n      */\n    function withdraw(uint256 _amount, bytes32 _pubkeyHash) external whenNotStopped { /* solhint-disable-line no-unused-vars */\n        //will be upgraded to an actual implementation when withdrawals are enabled (Phase 1.5 or 2 of Eth2 launch, likely late 2021 or 2022).\n        //at the moment withdrawals are not possible in the beacon chain and there's no workaround\n        revert(\"NOT_IMPLEMENTED_YET\");\n    }\n\n    /**\n    * @notice Updates the number of Lido-controlled keys in the beacon validators set and their total balance.\n    * @dev periodically called by the Oracle contract\n    * @param _beaconValidators number of Lido's keys in the beacon state\n    * @param _beaconBalance simmarized balance of Lido-controlled keys in wei\n    */\n    function pushBeacon(uint256 _beaconValidators, uint256 _beaconBalance) external whenNotStopped {\n        require(msg.sender == getOracle(), \"APP_AUTH_FAILED\");\n\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_beaconValidators <= depositedValidators, \"REPORTED_MORE_DEPOSITED\");\n\n        uint256 beaconValidators = BEACON_VALIDATORS_POSITION.getStorageUint256();\n        // Since the calculation of funds in the ingress queue is based on the number of validators\n        // that are in a transient state (deposited but not seen on beacon yet), we can't decrease the previously\n        // reported number (we'll be unable to figure out who is in the queue and count them).\n        // See LIP-1 for details https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-1.md\n        require(_beaconValidators >= beaconValidators, \"REPORTED_LESS_VALIDATORS\");\n        uint256 appearedValidators = _beaconValidators.sub(beaconValidators);\n\n        // RewardBase is the amount of money that is not included in the reward calculation\n        // Just appeared validators * 32 added to the previously reported beacon balance\n        uint256 rewardBase = (appearedValidators.mul(DEPOSIT_SIZE)).add(BEACON_BALANCE_POSITION.getStorageUint256());\n\n        // Save the current beacon balance and validators to\n        // calcuate rewards on the next push\n        BEACON_BALANCE_POSITION.setStorageUint256(_beaconBalance);\n        BEACON_VALIDATORS_POSITION.setStorageUint256(_beaconValidators);\n\n        if (_beaconBalance > rewardBase) {\n            uint256 rewards = _beaconBalance.sub(rewardBase);\n            distributeRewards(rewards);\n        }\n    }\n\n    /**\n      * @notice Send funds to recovery Vault. Overrides default AragonApp behaviour.\n      * @param _token Token to be sent to recovery vault.\n      */\n    function transferToVault(address _token) external {\n        require(allowRecoverability(_token), \"RECOVER_DISALLOWED\");\n        address vault = getRecoveryVault();\n        require(isContract(vault), \"RECOVER_VAULT_NOT_CONTRACT\");\n\n        uint256 balance;\n        if (_token == ETH) {\n            balance = _getUnaccountedEther();\n            vault.transfer(balance);\n        } else {\n            ERC20 token = ERC20(_token);\n            balance = token.staticBalanceOf(this);\n            // safeTransfer comes from overriden default implementation\n            require(token.safeTransfer(vault, balance), \"RECOVER_TOKEN_TRANSFER_FAILED\");\n        }\n\n        emit RecoverToVault(vault, _token, balance);\n    }\n\n    /**\n      * @notice Returns staking rewards fee rate\n      */\n    function getFee() external view returns (uint16 feeBasisPoints) {\n        return _getFee();\n    }\n\n    /**\n      * @notice Returns fee distribution proportion\n      */\n    function getFeeDistribution()\n        external\n        view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        return _getFeeDistribution();\n    }\n\n    /**\n      * @notice Returns current credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched\n      */\n    function getWithdrawalCredentials() public view returns (bytes32) {\n        return WITHDRAWAL_CREDENTIALS_POSITION.getStorageBytes32();\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return uint256 of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n      * @notice Gets deposit contract handle\n      */\n    function getDepositContract() public view returns (IDepositContract) {\n        return IDepositContract(DEPOSIT_CONTRACT_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Gets authorized oracle address\n    * @return address of oracle contract\n    */\n    function getOracle() public view returns (address) {\n        return ORACLE_POSITION.getStorageAddress();\n    }\n\n    /**\n      * @notice Gets node operators registry interface handle\n      */\n    function getOperators() public view returns (INodeOperatorsRegistry) {\n        return INodeOperatorsRegistry(NODE_OPERATORS_REGISTRY_POSITION.getStorageAddress());\n    }\n\n    /**\n      * @notice Returns the treasury address\n      */\n    function getTreasury() public view returns (address) {\n        return TREASURY_POSITION.getStorageAddress();\n    }\n\n    /**\n      * @notice Returns the insurance fund address\n      */\n    function getInsuranceFund() public view returns (address) {\n        return INSURANCE_FUND_POSITION.getStorageAddress();\n    }\n\n    /**\n    * @notice Returns the key values related to Beacon-side\n    * @return depositedValidators - number of deposited validators\n    * @return beaconValidators - number of Lido's validators visible in the Beacon state, reported by oracles\n    * @return beaconBalance - total amount of Beacon-side Ether (sum of all the balances of Lido validators)\n    */\n    function getBeaconStat() public view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = BEACON_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = BEACON_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n    * @dev Sets the address of Deposit contract\n    * @param _contract the address of Deposit contract\n    */\n    function _setDepositContract(IDepositContract _contract) internal {\n        require(isContract(address(_contract)), \"NOT_A_CONTRACT\");\n        DEPOSIT_CONTRACT_POSITION.setStorageAddress(address(_contract));\n    }\n\n    /**\n    * @dev Internal function to set authorized oracle address\n    * @param _oracle oracle contract\n    */\n    function _setOracle(address _oracle) internal {\n        require(isContract(_oracle), \"NOT_A_CONTRACT\");\n        ORACLE_POSITION.setStorageAddress(_oracle);\n    }\n\n    /**\n    * @dev Internal function to set node operator registry address\n    * @param _r registry of node operators\n    */\n    function _setOperators(INodeOperatorsRegistry _r) internal {\n        require(isContract(_r), \"NOT_A_CONTRACT\");\n        NODE_OPERATORS_REGISTRY_POSITION.setStorageAddress(_r);\n    }\n\n    function _setTreasury(address _treasury) internal {\n        require(_treasury != address(0), \"SET_TREASURY_ZERO_ADDRESS\");\n        TREASURY_POSITION.setStorageAddress(_treasury);\n    }\n\n    function _setInsuranceFund(address _insuranceFund) internal {\n        require(_insuranceFund != address(0), \"SET_INSURANCE_FUND_ZERO_ADDRESS\");\n        INSURANCE_FUND_POSITION.setStorageAddress(_insuranceFund);\n    }\n\n    /**\n    * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n    * @param _referral address of referral.\n    * @retur"
    }
  ]
}