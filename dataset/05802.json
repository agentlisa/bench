{
  "Title": "[H-03] AfEth deposits could use price data from an invalid Chainlink response",
  "Content": "\nThe current price implementation for the VotiumStrategy token uses a potentially invalid Chainlink response. This price is then used to calculate the price of AfEth and, subsequently, the amount of tokens to mint while depositing.\n\n### Impact\n\nThe price of VotiumStrategy tokens are determined by taking the amount of deposited CVX in the strategy, and multiplied by the current price of CVX in terms of ETH. This price is fetched using Chainlink in the `ethPerCvx()` function:\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L156-L186>\n\n```solidity\n156:     function ethPerCvx(bool _validate) public view returns (uint256) {\n157:         ChainlinkResponse memory cl;\n158:         try chainlinkCvxEthFeed.latestRoundData() returns (\n159:             uint80 roundId,\n160:             int256 answer,\n161:             uint256 /* startedAt */,\n162:             uint256 updatedAt,\n163:             uint80 /* answeredInRound */\n164:         ) {\n165:             cl.success = true;\n166:             cl.roundId = roundId;\n167:             cl.answer = answer;\n168:             cl.updatedAt = updatedAt;\n169:         } catch {\n170:             cl.success = false;\n171:         }\n172:         // verify chainlink response\n173:         if (\n174:             (!_validate ||\n175:                 (cl.success == true &&\n176:                     cl.roundId != 0 &&\n177:                     cl.answer >= 0 &&\n178:                     cl.updatedAt != 0 &&\n179:                     cl.updatedAt <= block.timestamp &&\n180:                     block.timestamp - cl.updatedAt <= 25 hours))\n181:         ) {\n182:             return uint256(cl.answer);\n183:         } else {\n184:             revert ChainlinkFailed();\n185:         }\n186:     }\n```\n\nAs we can see from the previous snippet of code, if the `_validate` flag is off, then *no validation* is done, it can even return an uninitialized response from a failed call given the usage of the `try/catch` structure. This means that it can invalid price, stale price, or even zero when the call fails.\n\nThe VotiumStrategy `price()` function calls `ethPerCvx(false)`, which means it carries forward any invalid CVX/ETH price.\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategy.sol#L31-L33>\n\n```solidity\n31:     function price() external view override returns (uint256) {\n32:         return (cvxPerVotium() * ethPerCvx(false)) / 1e18;\n33:     }\n```\n\nThe price of VotiumStrategy is then used in the AfEth contract to calculate its price and determine the amount of tokens to mint in `deposit()`\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L133-L169>\n\n```solidity\n133:     function price() public view returns (uint256) {\n134:         if (totalSupply() == 0) return 1e18;\n135:         AbstractStrategy vEthStrategy = AbstractStrategy(vEthAddress);\n136:         uint256 safEthValueInEth = (ISafEth(SAF_ETH_ADDRESS).approxPrice(true) *\n137:             safEthBalanceMinusPending()) / 1e18;\n138:         uint256 vEthValueInEth = (vEthStrategy.price() *\n139:             vEthStrategy.balanceOf(address(this))) / 1e18;\n140:         return ((vEthValueInEth + safEthValueInEth) * 1e18) / totalSupply();\n141:     }\n\n148:     function deposit(uint256 _minout) external payable virtual {\n149:         if (pauseDeposit) revert Paused();\n150:         uint256 amount = msg.value;\n151:         uint256 priceBeforeDeposit = price();\n152:         uint256 totalValue;\n153: \n154:         AbstractStrategy vStrategy = AbstractStrategy(vEthAddress);\n155: \n156:         uint256 sValue = (amount * ratio) / 1e18;\n157:         uint256 sMinted = sValue > 0\n158:             ? ISafEth(SAF_ETH_ADDRESS).stake{value: sValue}(0)\n159:             : 0;\n160:         uint256 vValue = (amount * (1e18 - ratio)) / 1e18;\n161:         uint256 vMinted = vValue > 0 ? vStrategy.deposit{value: vValue}() : 0;\n162:         totalValue +=\n163:             (sMinted * ISafEth(SAF_ETH_ADDRESS).approxPrice(true)) +\n164:             (vMinted * vStrategy.price());\n165:         if (totalValue == 0) revert FailedToDeposit();\n166:         uint256 amountToMint = totalValue / priceBeforeDeposit;\n167:         if (amountToMint < _minout) revert BelowMinOut();\n168:         _mint(msg.sender, amountToMint);\n169:     }\n```\n\nThe VotiumStrategy price is first used in line 138 to calculate its TVL (`vEthValueInEth`). Any invalid price here will also mean an invalid price for AfEth.\n\nThen both the AfEth price (line 151) and again the VotiumStrategy price (line 164) are used in `deposit()` to calculate the number of minted tokens. Depending on the direction of the wrong price, this means that the user will be minted more or less tokens than it should.\n\n### Proof of Concept\n\nLet's suppose the Chainlink feed is stale and the current price of CVX/ETH has increased since then.\n\n1.  A user calls `deposit()` to create a new position in AfEth.\n2.  The function calculates the current price (`priceBeforeDeposit`) in order to know how many tokens should be minted.\n3.  The `price()` implementation will calculate the Votium strategy TVL using `ethPerCvx(false)`, which will successfully return the stale price.\n4.  The price of AfEth will then be calculated using the old data, which will result in a lower value than the actual \"real\" price.\n5.  The user is minted tokens based on the incorrectly calculated `priceBeforeDeposit`, since this price is lower than the expected \"real\" price the user will be minted more tokens than expected.\n\n### Recommendation\n\nChange the `ethPerCvx()` argument to `true` to make sure prices coming from Chainlink are correctly validated.\n\n```diff\n  function price() external view override returns (uint256) {\n-     return (cvxPerVotium() * ethPerCvx(false)) / 1e18;\n+     return (cvxPerVotium() * ethPerCvx(true)) / 1e18;\n  }\n```\n\n**[elmutt (Asymmetry) confirmed](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/34#issuecomment-1741423338):**\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/34#issuecomment-1744973191):**\n > Should we not be prioritising liveness here over validating chainlink results?\n>\n > It seems important to avoid using stale price data which can be readily arbitraged. Severity seems correct.\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-10-asymmetry-mitigation#mitigations-to-be-reviewed):**\n >\tValidate Chainlink price data.\n\n**Status**: Mitigation confirmed. Full details in reports from [m\\_Rassska](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/6), [d3e4](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/14), and [adriro](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/29).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-09-asymmetry",
  "Code": [
    {
      "filename": "contracts/strategies/votium/VotiumStrategyCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../external_interfaces/IWETH.sol\";\nimport \"../../external_interfaces/ISwapRouter.sol\";\nimport \"../../external_interfaces/IVotiumMerkleStash.sol\";\nimport \"../../external_interfaces/ISnapshotDelegationRegistry.sol\";\nimport \"../../external_interfaces/ILockedCvx.sol\";\nimport \"../../external_interfaces/IClaimZap.sol\";\nimport \"../../external_interfaces/ICrvEthPool.sol\";\nimport \"../../external_interfaces/IAfEth.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"../AbstractStrategy.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../../external_interfaces/ISafEth.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title Votium Strategy Token internal functions\n/// @author Asymmetry Finance\ncontract VotiumStrategyCore is\n    Initializable,\n    OwnableUpgradeable,\n    ERC20Upgradeable\n{\n    address public constant SNAPSHOT_DELEGATE_REGISTRY =\n        0x469788fE6E9E9681C6ebF3bF78e7Fd26Fc015446;\n    address constant CVX_ADDRESS = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;\n    address constant VLCVX_ADDRESS = 0x72a19342e8F1838460eBFCCEf09F6585e32db86E;\n\n    struct SwapData {\n        address sellToken;\n        address spender;\n        address swapTarget;\n        bytes swapCallData;\n    }\n\n    struct ChainlinkResponse {\n        uint80 roundId;\n        int256 answer;\n        uint256 updatedAt;\n        bool success;\n    }\n\n    uint256 public cvxUnlockObligations;\n    address public rewarder;\n    address public manager;\n\n    AggregatorV3Interface public chainlinkCvxEthFeed;\n    uint256 latestWithdrawId;\n\n    // used to add storage variables in the future\n    uint256[20] private __gap;\n\n    event DepositReward(\n        uint256 indexed newPrice,\n        uint256 indexed ethAmount,\n        uint256 indexed cvxAmount\n    );\n\n    event FailedToSell(address indexed tokenAddress);\n\n    error SwapFailed(uint256 index);\n    error ChainlinkFailed();\n    error NotRewarder();\n    error InvalidLockedAmount();\n    error NotOwner();\n    error WithdrawNotReady();\n    error AlreadyWithdrawn();\n\n    /**\n        @notice - Sets the address for the chainlink feed\n        @param _cvxEthFeedAddress - Address of the chainlink feed\n    */\n    function setChainlinkCvxEthFeed(\n        address _cvxEthFeedAddress\n    ) public onlyOwner {\n        chainlinkCvxEthFeed = AggregatorV3Interface(_cvxEthFeedAddress);\n    }\n\n    modifier onlyRewarder() {\n        if (msg.sender != rewarder) revert NotRewarder();\n        _;\n    }\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _owner - Address of the owner of the contract (asym multisig)\n        @param _rewarder - Address of the rewarder contract (reward oracle)\n        @param _manager - Address of the manager contract (afEth)\n    */\n    function initialize(\n        address _owner,\n        address _rewarder,\n        address _manager\n    ) external initializer {\n        bytes32 VotiumVoteDelegationId = 0x6376782e65746800000000000000000000000000000000000000000000000000;\n        address DelegationRegistry = 0x469788fE6E9E9681C6ebF3bF78e7Fd26Fc015446;\n        address votiumVoteProxyAddress = 0xde1E6A7ED0ad3F61D531a8a78E83CcDdbd6E0c49;\n        ISnapshotDelegationRegistry(DelegationRegistry).setDelegate(\n            VotiumVoteDelegationId,\n            votiumVoteProxyAddress\n        );\n        rewarder = _rewarder;\n        manager = _manager;\n        __ERC20_init(\"Votium AfEth Strategy\", \"vAfEth\");\n        _transferOwnership(_owner);\n        chainlinkCvxEthFeed = AggregatorV3Interface(\n            0xC9CbF687f43176B302F03f5e58470b77D07c61c6\n        );\n    }\n\n    /**\n     * @notice - Function to set the address of the rewarder account that periodically claims rewards\n     * @param _rewarder - Address of the rewarder account\n     */\n    function setRewarder(address _rewarder) external onlyOwner {\n        rewarder = _rewarder;\n    }\n\n    /**\n     * @notice - The amount of cvx in the entire system\n     * @return - Amount of cvx in the entire system\n     */\n    function cvxInSystem() public view returns (uint256) {\n        (uint256 total, , , ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(\n            address(this)\n        );\n        return total + IERC20(CVX_ADDRESS).balanceOf(address(this));\n    }\n\n    /**\n     * @notice - Gets price of afEth in cvx\n     * @return - Price of afEth in cvx\n     */\n    function cvxPerVotium() public view returns (uint256) {\n        uint256 supply = totalSupply();\n        uint256 totalCvx = cvxInSystem();\n        if (supply == 0 || totalCvx == 0) return 1e18;\n        return ((totalCvx - cvxUnlockObligations) * 1e18) / supply;\n    }\n\n    /**\n        @notice - Eth per cvx (chainlink)\n        @param _validate - Whether or not to validate the chainlink response\n        @return - Price of cvx in eth\n     */\n    function ethPerCvx(bool _validate) public view returns (uint256) {\n        ChainlinkResponse memory cl;\n        try chainlinkCvxEthFeed.latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 updatedAt,\n            uint80 /* answeredInRound */\n        ) {\n            cl.success = true;\n            cl.roundId = roundId;\n            cl.answer = answer;\n            cl.updatedAt = updatedAt;\n        } catch {\n            cl.success = false;\n        }\n        // verify chainlink response\n        if (\n            (!_validate ||\n                (cl.success == true &&\n                    cl.roundId != 0 &&\n                    cl.answer >= 0 &&\n                    cl.updatedAt != 0 &&\n                    cl.updatedAt <= block.timestamp &&\n                    block.timestamp - cl.updatedAt <= 25 hours))\n        ) {\n            return uint256(cl.answer);\n        } else {\n            revert ChainlinkFailed();\n        }\n    }\n\n    /**\n     * @notice Allow rewarder oracle account to claim rewards\n     * @param _claimProofs - Array of claim proofs\n     */\n    function claimRewards(\n        IVotiumMerkleStash.ClaimParam[] calldata _claimProofs\n    ) public onlyRewarder {\n        claimVotiumRewards(_claimProofs);\n        claimVlCvxRewards();\n    }\n\n    /**\n     * @notice - Sells amount of eth from votium contract\n     * @dev - Puts it into safEthStrategy or votiumStrategy, whichever is underweight.\n     *  */\n    function depositRewards(uint256 _amount) public payable {\n        uint256 cvxAmount = buyCvx(_amount);\n        IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmount);\n        ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmount, 0);\n        emit DepositReward(cvxPerVotium(), _amount, cvxAmount);\n    }\n\n    /**\n     * @notice - Allows owner to withdraw any stuck erc20 tokens\n     * @dev - Lets us handle any that were not successfully sold via cvx\n     * @param _token - Address of the token to withdraw\n     */\n    function withdrawStuckTokens(address _token) public onlyOwner {\n        IERC20(_token).transfer(\n            msg.sender,\n            IERC20(_token).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice - Internal utility function to buy cvx using eth\n     * @param _ethAmountIn - Amount of eth to spend\n     * @return cvxAmountOut - Amount of cvx bought\n     */\n    function buyCvx(\n        uint256 _ethAmountIn\n    ) internal returns (uint256 cvxAmountOut) {\n        address CVX_ETH_CRV_POOL_ADDRESS = 0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4;\n        // eth -> cvx\n        uint256 cvxBalanceBefore = IERC20(CVX_ADDRESS).balanceOf(address(this));\n        ICrvEthPool(CVX_ETH_CRV_POOL_ADDRESS).exchange_underlying{\n            value: _ethAmountIn\n        }(\n            0,\n            1,\n            _ethAmountIn,\n            0 // this is handled at the afEth level\n        );\n        uint256 cvxBalanceAfter = IERC20(CVX_ADDRESS).balanceOf(address(this));\n        cvxAmountOut = cvxBalanceAfter - cvxBalanceBefore;\n    }\n\n    /**\n     * @notice - Internal utility function to sell cvx for eth\n     * @param _cvxAmountIn - Amount of cvx to sell\n     * @return ethAmountOut - Amount of eth received\n     */\n    function sellCvx(\n        uint256 _cvxAmountIn\n    ) internal returns (uint256 ethAmountOut) {\n        address CVX_ETH_CRV_POOL_ADDRESS = 0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4;\n        // cvx -> eth\n        uint256 ethBalanceBefore = address(this).balance;\n        IERC20(CVX_ADDRESS).approve(CVX_ETH_CRV_POOL_ADDRESS, _cvxAmountIn);\n\n        ICrvEthPool(CVX_ETH_CRV_POOL_ADDRESS).exchange_underlying(\n            1,\n            0,\n            _cvxAmountIn,\n            0 // this is handled at the afEth level\n        );\n        ethAmountOut = address(this).balance - ethBalanceBefore;\n    }\n\n    /**\n     * @notice - Function for rewarder to sell all claimed token rewards and buy & lock more cvx\n     * @dev - Causes price to go up\n     * @param _swapsData - Array of SwapData for 0x swaps\n     */\n    function applyRewards(SwapData[] calldata _swapsData) public onlyRewarder {\n        uint256 ethBalanceBefore = address(this).balance;\n        for (uint256 i = 0; i < _swapsData.length; i++) {\n            // Some tokens do not allow approval if allowance already exists\n            uint256 allowance = IERC20(_swapsData[i].sellToken).allowance(\n                address(this),\n                address(_swapsData[i].spender)\n            );\n            if (allowance != type(uint256).max) {\n                if (allowance > 0) {\n                    IERC20(_swapsData[i].sellToken).approve(\n                        address(_swapsData[i].spender),\n                        0\n                    );\n                }\n                IERC20(_swapsData[i].sellToken).approve(\n                    address(_swapsData[i].spender),\n                    type(uint256).max\n                );\n            }\n            (bool success, ) = _swapsData[i].swapTarget.call(\n                _swapsData[i].swapCallData\n            );\n            if (!success) {\n                emit FailedToSell(_swapsData[i].sellToken);\n            }\n        }\n        uint256 ethBalanceAfter = address(this).balance;\n        uint256 ethReceived = ethBalanceAfter - ethBalanceBefore;\n\n        if (address(manager) != address(0))\n            IAfEth(manager).depositRewards{value: ethReceived}(ethReceived);\n        else depositRewards(ethReceived);\n    }\n\n    /**\n     * @notice - Internal utility function to claim votium reward tokens\n     * @param _claimProofs - Array of claim proofs\n     */\n    function claimVotiumRewards(\n        IVotiumMerkleStash.ClaimParam[] calldata _claimProofs\n    ) private {\n        IVotiumMerkleStash(0x378Ba9B73309bE80BF4C2c027aAD799766a7ED5A)\n            .claimMulti(address(this), _claimProofs);\n    }\n\n    /**\n     * @notice - Internal utility function to claim vlCvx reward tokens\n     */\n    function claimVlCvxRewards() private {\n        address[] memory emptyArray;\n        IClaimZap(0x3f29cB4111CbdA8081642DA1f75B3c12DECf2516).claimRewards(\n            emptyArray,\n            emptyArray,\n            emptyArray,\n            emptyArray,\n            0,\n            0,\n            0,\n            0,\n            8\n        );\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/strategies/votium/VotiumStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"../AbstractStrategy.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./VotiumStrategyCore.sol\";\n\n/// @title Votium Strategy Token\n/// @author Asymmetry Finance\ncontract VotiumStrategy is VotiumStrategyCore, AbstractStrategy {\n    event WithdrawRequest(\n        address indexed user,\n        uint256 amount,\n        uint256 withdrawId\n    );\n\n    struct WithdrawRequestInfo {\n        uint256 cvxOwed;\n        bool withdrawn;\n        uint256 epoch;\n        address owner;\n    }\n\n    mapping(uint256 => WithdrawRequestInfo)\n        public withdrawIdToWithdrawRequestInfo;\n\n    /**\n     * @notice Gets price in eth\n     * @return Price of token in eth\n     */\n    function price() external view override returns (uint256) {\n        return (cvxPerVotium() * ethPerCvx(false)) / 1e18;\n    }\n\n    /**\n     * @notice Deposit eth to mint this token at current price\n     * @return mintAmount Amount of tokens minted\n     */\n    function deposit() public payable override returns (uint256 mintAmount) {\n        uint256 priceBefore = cvxPerVotium();\n        uint256 cvxAmount = buyCvx(msg.value);\n        IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmount);\n        ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmount, 0);\n        mintAmount = ((cvxAmount * 1e18) / priceBefore);\n        _mint(msg.sender, mintAmount);\n    }\n\n    /**\n     * @notice Request to withdraw from strategy emits event with eligible withdraw epoch\n     * @notice Burns afEth tokens and determines equivilent amount of cvx to start unlocking\n     * @param _amount Amount to request withdraw\n     * @return withdrawId Id of withdraw request\n     */\n    function requestWithdraw(\n        uint256 _amount\n    ) public override returns (uint256 withdrawId) {\n        latestWithdrawId++;\n        uint256 _priceInCvx = cvxPerVotium();\n\n        _burn(msg.sender, _amount);\n\n        uint256 currentEpoch = ILockedCvx(VLCVX_ADDRESS).findEpochId(\n            block.timestamp\n        );\n        (\n            ,\n            uint256 unlockable,\n            ,\n            ILockedCvx.LockedBalance[] memory lockedBalances\n        ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(address(this));\n        uint256 cvxAmount = (_amount * _priceInCvx) / 1e18;\n        cvxUnlockObligations += cvxAmount;\n\n        uint256 totalLockedBalancePlusUnlockable = unlockable +\n            IERC20(CVX_ADDRESS).balanceOf(address(this));\n\n        for (uint256 i = 0; i < lockedBalances.length; i++) {\n            totalLockedBalancePlusUnlockable += lockedBalances[i].amount;\n            // we found the epoch at which there is enough to unlock this position\n            if (totalLockedBalancePlusUnlockable >= cvxUnlockObligations) {\n                (, uint32 currentEpochStartingTime) = ILockedCvx(VLCVX_ADDRESS)\n                    .epochs(currentEpoch);\n                uint256 timeDifference = lockedBalances[i].unlockTime -\n                    currentEpochStartingTime;\n                uint256 epochOffset = timeDifference /\n                    ILockedCvx(VLCVX_ADDRESS).rewardsDuration();\n                uint256 withdrawEpoch = currentEpoch + epochOffset;\n                withdrawIdToWithdrawRequestInfo[\n                    latestWithdrawId\n                ] = WithdrawRequestInfo({\n                    cvxOwed: cvxAmount,\n                    withdrawn: false,\n                    epoch: withdrawEpoch,\n                    owner: msg.sender\n                });\n\n                emit WithdrawRequest(msg.sender, cvxAmount, latestWithdrawId);\n                return latestWithdrawId;\n            }\n        }\n        // should never get here\n        revert InvalidLockedAmount();\n    }\n\n    /**\n     * @notice Withdraws from requested withdraw if eligible epoch has passed\n     * @param _withdrawId Id of withdraw request\n     */\n    function withdraw(uint256 _withdrawId) external override {\n        if (withdrawIdToWithdrawRequestInfo[_withdrawId].owner != msg.sender)\n            revert NotOwner();\n        if (!this.canWithdraw(_withdrawId)) revert WithdrawNotReady();\n\n        if (withdrawIdToWithdrawRequestInfo[_withdrawId].withdrawn)\n            revert AlreadyWithdrawn();\n\n        relock();\n\n        uint256 cvxWithdrawAmount = withdrawIdToWithdrawRequestInfo[_withdrawId]\n            .cvxOwed;\n\n        uint256 ethReceived = sellCvx(cvxWithdrawAmount);\n        cvxUnlockObligations -= cvxWithdrawAmount;\n        withdrawIdToWithdrawRequestInfo[_withdrawId].withdrawn = true;\n\n        // solhint-disable-next-line\n        (bool sent, ) = msg.sender.call{value: ethReceived}(\"\");\n        if (!sent) revert FailedToSend();\n    }\n\n    /**\n     * @notice Relocks cvx while ensuring there is enough to cover all withdraw requests\n     * @dev This happens automatically on withdraw but will need to be manually called if no withdraws happen in an epoch where locks are expiring\n     */\n    function relock() public {\n        (, uint256 unlockable, , ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(\n            address(this)\n        );\n        if (unlockable > 0)\n            ILockedCvx(VLCVX_ADDRESS).processExpiredLocks(false);\n        uint256 cvxBalance = IERC20(CVX_ADDRESS).balanceOf(address(this));\n        uint256 cvxAmountToRelock = cvxBalance > cvxUnlockObligations\n            ? cvxBalance - cvxUnlockObligations\n            : 0;\n        if (cvxAmountToRelock > 0) {\n            IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmountToRelock);\n            ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmountToRelock, 0);\n        }\n    }\n\n    /**\n     * @notice Checks if withdraw request is eligible to be withdrawn\n     * @param _withdrawId Id of withdraw request\n     */\n    function canWithdraw(\n        uint256 _withdrawId\n    ) external view virtual override returns (bool) {\n        uint256 currentEpoch = ILockedCvx(VLCVX_ADDRESS).findEpochId(\n            block.timestamp\n        );\n        return\n            withdrawIdToWithdrawRequestInfo[_withdrawId].epoch <= currentEpoch;\n    }\n\n    /**\n     * @notice Checks how long it will take to withdraw a given amount\n     * @param _amount Amount of afEth to check how long it will take to withdraw\n     * @return When it would be withdrawable based on the amount\n     */\n    function withdrawTime(\n        uint256 _amount\n    ) external view virtual override returns (uint256) {\n        uint256 _priceInCvx = cvxPerVotium();\n        (\n            ,\n            uint256 unlockable,\n            ,\n            ILockedCvx.LockedBalance[] memory lockedBalances\n        ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(address(this));\n        uint256 cvxAmount = (_amount * _priceInCvx) / 1e18;\n        uint256 totalLockedBalancePlusUnlockable = unlockable +\n            IERC20(CVX_ADDRESS).balanceOf(address(this));\n\n        for (uint256 i = 0; i < lockedBalances.length; i++) {\n            totalLockedBalancePlusUnlockable += lockedBalances[i].amount;\n            // we found the epoch at which there is enough to unlock this position\n            if (\n                totalLockedBalancePlusUnlockable >=\n                cvxUnlockObligations + cvxAmount\n            ) {\n                return lockedBalances[i].unlockTime;\n            }\n        }\n        revert InvalidLockedAmount();\n    }\n}"
    },
    {
      "filename": "contracts/AfEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"contracts/strategies/votium/VotiumStrategy.sol\";\nimport \"contracts/external_interfaces/IVotiumStrategy.sol\";\nimport \"contracts/strategies/AbstractStrategy.sol\";\n\n// AfEth is the strategy manager for safEth and votium strategies\ncontract AfEth is Initializable, OwnableUpgradeable, ERC20Upgradeable {\n    uint256 public ratio;\n    uint256 public protocolFee;\n    address public feeAddress;\n    address public constant SAF_ETH_ADDRESS =\n        0x6732Efaf6f39926346BeF8b821a04B6361C4F3e5;\n    address public vEthAddress; // Votium Strategy Address\n    uint256 public latestWithdrawId;\n\n    struct WithdrawInfo {\n        address owner;\n        uint256 amount;\n        uint256 safEthWithdrawAmount;\n        uint256 vEthWithdrawId;\n        uint256 withdrawTime;\n    }\n\n    mapping(uint256 => WithdrawInfo) public withdrawIdInfo;\n    bool public pauseDeposit;\n    bool public pauseWithdraw;\n\n    error StrategyAlreadyAdded();\n    error StrategyNotFound();\n    error InsufficientBalance();\n    error InvalidStrategy();\n    error InvalidFee();\n    error CanNotWithdraw();\n    error NotOwner();\n    error FailedToSend();\n    error FailedToDeposit();\n    error Paused();\n    error BelowMinOut();\n\n    event WithdrawRequest(\n        address indexed account,\n        uint256 amount,\n        uint256 withdrawId,\n        uint256 withdrawTime\n    );\n\n    address private constant CVX_ADDRESS =\n        0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;\n    address private constant VLCVX_ADDRESS =\n        0x72a19342e8F1838460eBFCCEf09F6585e32db86E;\n\n    uint256 public pendingSafEthWithdraws;\n\n    modifier onlyWithdrawIdOwner(uint256 withdrawId) {\n        if (withdrawIdInfo[withdrawId].owner != msg.sender) revert NotOwner();\n        _;\n    }\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n    */\n    function initialize() external initializer {\n        _transferOwnership(msg.sender);\n        ratio = 5e17;\n    }\n\n    /**\n     * @notice - Sets the strategy addresses for safEth and votium\n     * @param _vEthAddress - vEth strategy address\n     */\n    function setStrategyAddress(address _vEthAddress) external onlyOwner {\n        vEthAddress = _vEthAddress;\n    }\n\n    /**\n        @notice - Sets the target ratio of safEth to votium. \n        @notice target ratio is maintained by directing rewards into either safEth or votium strategy\n        @param _newRatio - New ratio of safEth to votium\n    */\n    function setRatio(uint256 _newRatio) public onlyOwner {\n        ratio = _newRatio;\n    }\n\n    /**\n        @notice - Sets the protocol fee address which takes a percentage of the rewards.\n        @param _newFeeAddress - New protocol fee address to collect rewards\n    */\n    function setFeeAddress(address _newFeeAddress) public onlyOwner {\n        feeAddress = _newFeeAddress;\n    }\n\n    /**\n        @notice - Sets the protocol fee which takes a percentage of the rewards.\n        @param _newFee - New protocol fee\n    */\n    function setProtocolFee(uint256 _newFee) public onlyOwner {\n        if (_newFee > 1e18) revert InvalidFee();\n        protocolFee = _newFee;\n    }\n\n    /**\n        @notice - Enables/Disables depositing\n        @param _pauseDeposit - Bool to set pauseDeposit\n\n    */\n    function setPauseDeposit(bool _pauseDeposit) external onlyOwner {\n        pauseDeposit = _pauseDeposit;\n    }\n\n    /**\n        @notice - Enables/Disables withdrawing & requesting to withdraw\n        @param _pauseWithdraw - Bool to set pauseWithdraw\n    */\n    function setPauseWithdraw(bool _pauseWithdraw) external onlyOwner {\n        pauseWithdraw = _pauseWithdraw;\n    }\n\n    /**\n        @notice - Get's the price of afEth\n        @dev - Checks each strategy and calculates the total value in ETH divided by supply of afETH tokens\n        @return - Price of afEth\n    */\n    function price() public view returns (uint256) {\n        if (totalSupply() == 0) return 1e18;\n        AbstractStrategy vEthStrategy = AbstractStrategy(vEthAddress);\n        uint256 safEthValueInEth = (ISafEth(SAF_ETH_ADDRESS).approxPrice(true) *\n            safEthBalanceMinusPending()) / 1e18;\n        uint256 vEthValueInEth = (vEthStrategy.price() *\n            vEthStrategy.balanceOf(address(this))) / 1e18;\n        return ((vEthValueInEth + safEthValueInEth) * 1e18) / totalSupply();\n    }\n\n    /**\n        @notice - Deposits into each strategy\n        @dev - This is the entry into the protocol\n        @param _minout - Minimum amount of afEth to mint\n    */\n    function deposit(uint256 _minout) external payable virtual {\n        if (pauseDeposit) revert Paused();\n        uint256 amount = msg.value;\n        uint256 priceBeforeDeposit = price();\n        uint256 totalValue;\n\n        AbstractStrategy vStrategy = AbstractStrategy(vEthAddress);\n\n        uint256 sValue = (amount * ratio) / 1e18;\n        uint256 sMinted = sValue > 0\n            ? ISafEth(SAF_ETH_ADDRESS).stake{value: sValue}(0)\n            : 0;\n        uint256 vValue = (amount * (1e18 - ratio)) / 1e18;\n        uint256 vMinted = vValue > 0 ? vStrategy.deposit{value: vValue}() : 0;\n        totalValue +=\n            (sMinted * ISafEth(SAF_ETH_ADDRESS).approxPrice(true)) +\n            (vMinted * vStrategy.price());\n        if (totalValue == 0) revert FailedToDeposit();\n        uint256 amountToMint = totalValue / priceBeforeDeposit;\n        if (amountToMint < _minout) revert BelowMinOut();\n        _mint(msg.sender, amountToMint);\n    }\n\n    /**\n        @notice - Request to close position\n        @param _amount - Amount of afEth to withdraw\n    */\n    function requestWithdraw(uint256 _amount) external virtual {\n        uint256 withdrawTimeBefore = withdrawTime(_amount);\n        if (pauseWithdraw) revert Paused();\n        latestWithdrawId++;\n\n        // ratio of afEth being withdrawn to totalSupply\n        // we are transfering the afEth to the contract when we requestWithdraw\n        // we shouldn't include that in the withdrawRatio\n        uint256 afEthBalance = balanceOf(address(this));\n        uint256 withdrawRatio = (_amount * 1e18) /\n            (totalSupply() - afEthBalance);\n\n        _transfer(msg.sender, address(this), _amount);\n\n        uint256 votiumBalance = IERC20(vEthAddress).balanceOf(address(this));\n        uint256 votiumWithdrawAmount = (withdrawRatio * votiumBalance) / 1e18;\n        uint256 vEthWithdrawId = AbstractStrategy(vEthAddress).requestWithdraw(\n            votiumWithdrawAmount\n        );\n\n        uint256 safEthBalance = safEthBalanceMinusPending();\n\n        uint256 safEthWithdrawAmount = (withdrawRatio * safEthBalance) / 1e18;\n\n        pendingSafEthWithdraws += safEthWithdrawAmount;\n\n        withdrawIdInfo[latestWithdrawId]\n            .safEthWithdrawAmount = safEthWithdrawAmount;\n        withdrawIdInfo[latestWithdrawId].vEthWithdrawId = vEthWithdrawId;\n\n        withdrawIdInfo[latestWithdrawId].owner = msg.sender;\n        withdrawIdInfo[latestWithdrawId].amount = _amount;\n        withdrawIdInfo[latestWithdrawId].withdrawTime = withdrawTimeBefore;\n\n        emit WithdrawRequest(\n            msg.sender,\n            _amount,\n            latestWithdrawId,\n            withdrawTimeBefore\n        );\n    }\n\n    /**\n        @notice - Checks if withdraw can be executed from withdrawId\n        @param _withdrawId - Id of the withdraw request for SafEth\n        @return - Bool if withdraw can be executed\n    */\n    function canWithdraw(uint256 _withdrawId) public view returns (bool) {\n        return\n            AbstractStrategy(vEthAddress).canWithdraw(\n                withdrawIdInfo[_withdrawId].vEthWithdrawId\n            );\n    }\n\n    /**\n        @notice - Get's the withdraw time for an amount of AfEth\n        @param _amount - Amount of afETH to withdraw\n        @return - Highest withdraw time of the strategies\n    */\n    function withdrawTime(uint256 _amount) public view returns (uint256) {\n        return AbstractStrategy(vEthAddress).withdrawTime(_amount);\n    }\n\n    /**\n        @notice - Withdraw from each strategy\n        @param _withdrawId - Id of the withdraw request\n        @param _minout - Minimum amount of ETH to receive\n    */\n    function withdraw(\n        uint256 _withdrawId,\n        uint256 _minout\n    ) external virtual onlyWithdrawIdOwner(_withdrawId) {\n        if (pauseWithdraw) revert Paused();\n        uint256 ethBalanceBefore = address(this).balance;\n        WithdrawInfo memory withdrawInfo = withdrawIdInfo[_withdrawId];\n        if (!canWithdraw(_withdrawId)) revert CanNotWithdraw();\n\n        ISafEth(SAF_ETH_ADDRESS).unstake(withdrawInfo.safEthWithdrawAmount, 0);\n        AbstractStrategy(vEthAddress).withdraw(withdrawInfo.vEthWithdrawId);\n\n        _burn(address(this), withdrawIdInfo[_withdrawId].amount);\n        uint256 ethBalanceAfter = address(this).balance;\n        uint256 ethReceived = ethBalanceAfter - ethBalanceBefore;\n\n        pendingSafEthWithdraws -= withdrawInfo.safEthWithdrawAmount;\n\n        if (ethReceived < _minout) revert BelowMinOut();\n        // solhint-disable-next-line\n        (bool sent, ) = msg.sender.call{value: ethReceived}(\"\");\n        if (!sent) revert FailedToSend();\n    }\n\n    /**\n     * @notice - sells _amount of eth from votium contract\n     * @dev - puts it into safEthStrategy or votiumStrategy, whichever is underweight.\\\n     * @param _amount - amount of eth to sell\n     */\n    function depositRewards(uint256 _amount) public payable {\n        IVotiumStrategy votiumStrategy = IVotiumStrategy(vEthAddress);\n        uint256 feeAmount = (_amount * protocolFee) / 1e18;\n        if (feeAmount > 0) {\n            // solhint-disable-next-line\n            (bool sent, ) = feeAddress.call{value: feeAmount}(\"\");\n            if (!sent) revert FailedToSend();\n        }\n        uint256 amount = _amount - feeAmount;\n        uint256 safEthTvl = (ISafEth(SAF_ETH_ADDRESS).approxPrice(true) *\n            safEthBalanceMinusPending()) / 1e18;\n        uint256 votiumTvl = ((votiumStrategy.cvxPerVotium() *\n            votiumStrategy.ethPerCvx(true)) *\n            IERC20(vEthAddress).balanceOf(address(this))) / 1e36;\n        uint256 totalTvl = (safEthTvl + votiumTvl);\n        uint256 safEthRatio = (safEthTvl * 1e18) / totalTvl;\n        if (safEthRatio < ratio) {\n            ISafEth(SAF_ETH_ADDRESS).stake{value: amount}(0);\n        } else {\n            votiumStrategy.depositRewards{value: amount}(amount);\n        }\n    }\n\n    function safEthBalanceMinusPending() public view returns (uint256) {\n        return\n            IERC20(SAF_ETH_ADDRESS).balanceOf(address(this)) -\n            pendingSafEthWithdraws;\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}