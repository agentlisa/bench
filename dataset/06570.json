{
  "Title": "[M-03] Zero token transfer can cause a potential DoS in CVXStaker",
  "Content": "\nThe CVXStaker contract doesn't check for zero amount while transferring rewards, which can end up blocking the operation.\n\nThe CVXStaker contract is in charge of handling interaction with the Convex pool. The `getReward()` function is used to claim rewards and transfer them to the rewards recipient:\n\n<https://github.com/code-423n4/2023-05-xeth/blob/main/src/CVXStaker.sol#L185-L198>\n\n```solidity\n185:     function getReward(bool claimExtras) external {\n186:         IBaseRewardPool(cvxPoolInfo.rewards).getReward(\n187:             address(this),\n188:             claimExtras\n189:         );\n190:         if (rewardsRecipient != address(0)) {\n191:             for (uint i = 0; i < rewardTokens.length; i++) {\n192:                 uint256 balance = IERC20(rewardTokens[i]).balanceOf(\n193:                     address(this)\n194:                 );\n195:                 IERC20(rewardTokens[i]).safeTransfer(rewardsRecipient, balance);\n196:             }\n197:         }\n198:     }\n```\n\nAs we can see in the previous snippet of code, the implementation will loop all the configured reward tokens and transfer them one by one to the reward recipient.\n\nThis is a bit concerning as some ERC20 implementations revert on zero value transfers (see <https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers>). If at least one of the reward tokens includes this behavior, then the current implementation may cause a denial of service, as a zero amount transfer in this token will block the whole action and revert the transaction.\n\nNote that the rewards array is not modifiable, it is defined at construction time, a token cannot be removed.\n\n### Proof of Concept\n\nWe reproduce the issue in the following test. `token1` is a normal ERC20 and `token2` reverts on zero transfer amounts. Rewards from `token1` can't be transferred to the recipient as the zero transfer on `token2` will revert the operation.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/475d1f809301c5a0ccf2e6e9bec85472).\n\n```solidity\nfunction test_CVXStaker_RevertOnZeroTokenTransfer() public {\n    MockErc20 token1 = new MockErc20(\"Token1\", \"TOK1\", 18);\n    MockErc20 token2 = new RevertOnZeroErc20(\"Token2\", \"TOK2\", 18);\n\n    MockCVXRewards rewards = new MockCVXRewards();\n\n    address operator = makeAddr(\"operator\");\n    IERC20 clpToken = IERC20(makeAddr(\"clpToken\"));\n    ICVXBooster booster = ICVXBooster(makeAddr(\"booster\"));\n    address[] memory rewardTokens = new address[](2);\n    rewardTokens[0] = address(token1);\n    rewardTokens[1] = address(token2);\n\n    CVXStaker staker = new CVXStaker(operator, clpToken, booster, rewardTokens);\n    staker.setCvxPoolInfo(0, address(clpToken), address(rewards));\n\n    address rewardsRecipient = makeAddr(\"rewardsRecipient\");\n    staker.setRewardsRecipient(rewardsRecipient);\n\n    // simulate staker has some token1 but zero token2 after calling getRewards\n    deal(address(token1), address(staker), 1e18);\n\n    // The transaction will fail as the implementation will try to transfer zero\n    // tokens for token2, blocking the whole operation.\n    vm.expectRevert(\"cannot transfer zero amount\");\n    staker.getReward(true);\n}\n```\n\n### Recommendation\n\nCheck for zero amount before executing the transfer:\n\n```solidity\nfunction getReward(bool claimExtras) external {\n    IBaseRewardPool(cvxPoolInfo.rewards).getReward(\n        address(this),\n        claimExtras\n    );\n    if (rewardsRecipient != address(0)) {\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            uint256 balance = IERC20(rewardTokens[i]).balanceOf(\n                address(this)\n            );\n            \n+           if (balance > 0) {\n              IERC20(rewardTokens[i]).safeTransfer(rewardsRecipient, balance);\n+           }\n        }\n    }\n}\n```\n\n### Assessed type\nERC20\n\n**[vaporkane (xETH) confirmed](https://github.com/code-423n4/2023-05-xeth-findings/issues/30#issuecomment-1575444199)**\n\n**[xETH mitigated](https://github.com/code-423n4/2023-06-xeth-mitigation#mitigations-to-be-reviewed):**\n> This mitigation adds a balance check.\n> \n> PR: https://github.com/code-423n4/2023-05-xeth/commit/1f714868f193cdeb472ec097110901a997d87ec4\n\n**Status:** Mitigation confirmed. Full details in reports from [ronnyx2017](https://github.com/code-423n4/2023-06-xeth-mitigation-findings/issues/5), [bin2chen](https://github.com/code-423n4/2023-06-xeth-mitigation-findings/issues/4) and [d3e4](https://github.com/code-423n4/2023-06-xeth-mitigation-findings/issues/20).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-xeth",
  "Code": [
    {
      "filename": "src/CVXStaker.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\nimport \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin-contracts/access/Ownable.sol\";\nimport \"./interfaces/ICurvePool.sol\";\nimport \"./interfaces/ICVXBooster.sol\";\nimport \"./interfaces/IBaseRewardPool.sol\";\n\ncontract CVXStaker is Ownable {\n    using SafeERC20 for IERC20;\n\n    address public operator;\n    // @notice CLP tokens for curve pool\n    IERC20 public immutable clpToken;\n    CvxPoolInfo public cvxPoolInfo;\n    // @notice Cvx booster\n    ICVXBooster public immutable booster;\n\n    address public rewardsRecipient;\n    address[] public rewardTokens;\n\n    struct CvxPoolInfo {\n        address token;\n        address rewards;\n        uint32 pId;\n    }\n\n    struct Position {\n        uint256 staked;\n        uint256 earned;\n    }\n\n    error NotOperator();\n    error NotOperatorOrOwner();\n\n    event SetCvxPoolInfo(uint32 indexed pId, address token, address rewards);\n    event SetOperator(address operator);\n    event RecoveredToken(address token, address to, uint256 amount);\n    event SetRewardsRecipient(address recipient);\n\n    constructor(\n        address _operator,\n        IERC20 _clpToken,\n        ICVXBooster _booster,\n        address[] memory _rewardTokens\n    ) {\n        operator = _operator;\n        clpToken = _clpToken;\n        booster = _booster;\n        rewardTokens = _rewardTokens;\n    }\n\n    /**\n     * @dev Sets the CVX pool information.\n     * @param _pId The pool ID of the CVX pool.\n     * @param _token The address of the CLP token.\n     * @param _rewards The address of the CVX reward pool.\n     * Only the contract owner can call this function.\n     */\n    function setCvxPoolInfo(\n        uint32 _pId,\n        address _token,\n        address _rewards\n    ) external onlyOwner {\n        cvxPoolInfo.pId = _pId;\n        cvxPoolInfo.token = _token;\n        cvxPoolInfo.rewards = _rewards;\n\n        emit SetCvxPoolInfo(_pId, _token, _rewards);\n    }\n\n    /**\n     * @notice Set operator\n     * @param _operator New operator\n     */\n    function setOperator(address _operator) external onlyOwner {\n        operator = _operator;\n\n        emit SetOperator(_operator);\n    }\n\n    /**\n     * @dev Sets the address of the rewards recipient.\n     * @param _recipeint The address of the rewards recipient.\n     * Only the contract owner can call this function.\n     */\n    function setRewardsRecipient(address _recipeint) external onlyOwner {\n        rewardsRecipient = _recipeint;\n\n        emit SetRewardsRecipient(_recipeint);\n    }\n\n    /**\n     * @notice Recover any token from AMO\n     * @param token Token to recover\n     * @param to Recipient address\n     * @param amount Amount to recover\n     */\n    function recoverToken(\n        address token,\n        address to,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeTransfer(to, amount);\n\n        emit RecoveredToken(token, to, amount);\n    }\n\n    /**\n     * @dev Checks whether the CVX pool is currently shutdown.\n     * @return A boolean indicating whether the CVX pool is currently shutdown.\n     */\n    function isCvxShutdown() public view returns (bool) {\n        // It's not necessary to check that the booster itself is shutdown, as that can only\n        // be shutdown once all the pools are shutdown - see Cvx BoosterOwner.shutdownSystem()\n        return booster.poolInfo(cvxPoolInfo.pId).shutdown;\n    }\n\n    /**\n     * @dev Deposits a specified amount of CLP tokens into the booster and stakes them in the reward pool.\n     * @param amount The amount of CLP tokens to deposit and stake.\n     * Only the operator can call this function.\n     */\n    function depositAndStake(uint256 amount) external onlyOperator {\n        // Only deposit if the aura pool is open. Otherwise leave the CLP Token in this contract.\n        if (!isCvxShutdown()) {\n            clpToken.safeIncreaseAllowance(address(booster), amount);\n            booster.deposit(cvxPoolInfo.pId, amount, true);\n        }\n    }\n\n    /**\n     * @dev Withdraws a specified amount of staked tokens from the reward pool and unwraps them to the original tokens.\n     * @param amount The amount of tokens to withdraw and unwrap.\n     * @param claim A boolean indicating whether to claim rewards before withdrawing.\n     * @param to The address to receive the unwrapped tokens.\n     * If set to 0x0, the tokens will remain in the contract.\n     * Only the contract owner or operator can call this function.\n     */\n    function withdrawAndUnwrap(\n        uint256 amount,\n        bool claim,\n        address to\n    ) external onlyOperatorOrOwner {\n        // Optimistically use CLP balance in this contract, and then try and unstake any remaining\n        uint256 clpBalance = clpToken.balanceOf(address(this));\n        uint256 toUnstake = (amount < clpBalance) ? 0 : amount - clpBalance;\n        if (toUnstake > 0) {\n            IBaseRewardPool(cvxPoolInfo.rewards).withdrawAndUnwrap(\n                toUnstake,\n                claim\n            );\n        }\n\n        if (to != address(0)) {\n            // unwrapped amount is 1 to 1\n            clpToken.safeTransfer(to, amount);\n        }\n    }\n\n    /**\n     * @dev Withdraws all staked tokens from the reward pool and unwraps them to the original tokens.\n     * @param claim A boolean indicating whether to claim rewards before withdrawing.\n     * @param sendToOperator A boolean indicating whether to send the unwrapped tokens to the operator.\n     * If false, the tokens will remain in the contract.\n     * Only the contract owner can call this function.\n     */\n    function withdrawAllAndUnwrap(\n        bool claim,\n        bool sendToOperator\n    ) external onlyOwner {\n        IBaseRewardPool(cvxPoolInfo.rewards).withdrawAllAndUnwrap(claim);\n        if (sendToOperator) {\n            uint256 totalBalance = clpToken.balanceOf(address(this));\n            clpToken.safeTransfer(operator, totalBalance);\n        }\n    }\n\n    /**\n     * @dev Claims the rewards and transfers them to the rewards recipient, if specified.\n     * @param claimExtras A boolean indicating whether to claim extra rewards.\n     */\n    function getReward(bool claimExtras) external {\n        IBaseRewardPool(cvxPoolInfo.rewards).getReward(\n            address(this),\n            claimExtras\n        );\n        if (rewardsRecipient != address(0)) {\n            for (uint i = 0; i < rewardTokens.length; i++) {\n                uint256 balance = IERC20(rewardTokens[i]).balanceOf(\n                    address(this)\n                );\n                IERC20(rewardTokens[i]).safeTransfer(rewardsRecipient, balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the current staked balance of the contract.\n     * @return balance The current staked balance.\n     */\n    function stakedBalance() public view returns (uint256 balance) {\n        balance = IBaseRewardPool(cvxPoolInfo.rewards).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Returns the amount of earned rewards by the contract.\n     * @return earnedRewards The amount of earned rewards.\n     */\n    function earned() public view returns (uint256 earnedRewards) {\n        earnedRewards = IBaseRewardPool(cvxPoolInfo.rewards).earned(\n            address(this)\n        );\n    }\n\n    /**\n     * @notice show staked position and earned rewards\n     */\n    function showPositions() external view returns (Position memory position) {\n        position.staked = stakedBalance();\n        position.earned = earned();\n    }\n\n    /// @dev Modifier to restrict function execution to only the contract operator.\n    /// @notice Throws a custom exception `NotOperator` if the caller is not the operator.\n    modifier onlyOperator() {\n        if (msg.sender != operator) {\n            revert NotOperator();\n        }\n        _;\n    }\n\n    /// @dev Modifier to restrict function execution to only the contract operator or owner.\n    /// @notice Throws a custom exception `NotOperatorOrOwner` if the caller is neither the operator nor the owner.\n    modifier onlyOperatorOrOwner() {\n        if (msg.sender != operator && msg.sender != owner()) {\n            revert NotOperatorOrOwner();\n        }\n        _;\n    }\n}"
    }
  ]
}