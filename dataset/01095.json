{
  "Title": "Missing Event Emissions",
  "Content": "* `RiskFundConverter` emits the [`AssetsReservesUpdated` event](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/RiskFundConverter.sol#L52) upon updating the `poolsAssetsReserves` mapping in [`updateAssetsState`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/RiskFundConverter.sol#L168). `poolsAssetsReserves` is updated in [`updatePoolAssetsReserve`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/RiskFundConverter.sol#L231) as well, but no event is emitted here.\n* When tokens are sent from the `RiskFundConverter` to the `RiskFundV2` in [`updateAssetsState`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/RiskFundConverter.sol#L162-L163), the `AssetTransferredToDestination` event is emitted. Similarly, [`_actualAmounts`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/AbstractTokenConverter.sol#L598) in `AbstractTokenConverter` sends funds to `RiskFundV2`, but no event is emitted here.\n\n\nConsider adding event emissions in the previously described cases to ensure that off-chain monitoring can properly track these occurrences.\n\n\n***Update:** Resolved at commit [35dc0a1](https://github.com/VenusProtocol/protocol-reserve/pull/24/commits/35dc0a1211094458b2db4552ab07694001c6d6df).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/TokenConverter/RiskFundConverter.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { ResilientOracle } from \"@venusprotocol/oracle/contracts/ResilientOracle.sol\";\n\nimport { AbstractTokenConverter } from \"./AbstractTokenConverter.sol\";\nimport { ensureNonzeroAddress } from \"../Utils/Validators.sol\";\nimport { IPoolRegistry } from \"../Interfaces/IPoolRegistry.sol\";\nimport { IComptroller } from \"../Interfaces/IComptroller.sol\";\nimport { IRiskFund } from \"../Interfaces/IRiskFund.sol\";\nimport { IVToken } from \"../Interfaces/IVToken.sol\";\nimport { EXP_SCALE } from \"../Utils/Constants.sol\";\n\ncontract RiskFundConverter is AbstractTokenConverter {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice Address of the core pool comptroller\n    address public immutable corePoolComptroller;\n\n    ///@notice Address of the vBNB\n    ///@dev This address is used to exclude the BNB market while in getPools method\n    address public immutable vBNB;\n\n    ///@notice Address of the native wrapped currency\n    address public immutable NATIVE_WRAPPED;\n\n    /// @notice Store the previous state for the asset transferred to ProtocolShareReserve combined(for all pools)\n    mapping(address => uint256) internal assetsReserves;\n\n    /// @notice Store the asset's reserve per pool in the ProtocolShareReserve\n    /// @dev Comptroller(pool) -> Asset -> amount\n    mapping(address => mapping(address => uint256)) internal poolsAssetsReserves;\n\n    /// @notice Address of pool registry contract\n    address public poolRegistry;\n\n    /// @notice This mapping would contain the assets for the pool which would be send to RiskFund directly\n    /// @dev Comptroller(pool) -> Asset -> bool(should transfer directly on true)\n    mapping(address => mapping(address => bool)) public poolsAssetsDirectTransfer;\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain\n    uint256[46] private __gap;\n\n    /// @notice Emitted when pool registry address is updated\n    event PoolRegistryUpdated(address indexed oldPoolRegistry, address indexed newPoolRegistry);\n\n    // Event emitted after the updation of the assets reserves\n    // amount -> reserve increased by amount\n    event AssetsReservesUpdated(address indexed comptroller, address indexed asset, uint256 amount);\n\n    // Event emitted after the funds transferred to the destination address\n    event AssetTransferredToDestination(address indexed comptroller, address indexed asset, uint256 amount);\n\n    // Event emitted after the poolsAssetsDirectTransfer mapping is updated\n    event PoolAssetsDirectTransferUpdated(address indexed comptroller, address indexed asset, bool value);\n\n    // Error thrown when comptrollers array length is not equal to assets array length\n    error InvalidArguments();\n\n    /// @param corePoolComptroller_ Address of the Comptroller pool\n    /// @param vBNB_ Address of the vBNB\n    /// @param nativeWrapped_ Address of the wrapped native currency\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address corePoolComptroller_, address vBNB_, address nativeWrapped_) {\n        ensureNonzeroAddress(corePoolComptroller_);\n        corePoolComptroller = corePoolComptroller_;\n        vBNB = vBNB_;\n        NATIVE_WRAPPED = nativeWrapped_;\n    }\n\n    /// @param accessControlManager_ Access control manager contract address\n    /// @param priceOracle_ Resilient oracle address\n    /// @param destinationAddress_  Address at all incoming tokens will transferred to\n    /// @param poolRegistry_ Address of the pool registry\n    function initialize(\n        address accessControlManager_,\n        ResilientOracle priceOracle_,\n        address destinationAddress_,\n        address poolRegistry_\n    ) public initializer {\n        // Initialize AbstractTokenConverter\n        __AbstractTokenConverter_init(accessControlManager_, priceOracle_, destinationAddress_);\n        poolRegistry = poolRegistry_;\n    }\n\n    /// @dev Pool registry setter\n    /// @param poolRegistry_ Address of the pool registry\n    /// @custom:event PoolRegistryUpdated emits on success\n    /// @custom:error ZeroAddressNotAllowed is thrown when pool registry address is zero\n    function setPoolRegistry(address poolRegistry_) external onlyOwner {\n        ensureNonzeroAddress(poolRegistry_);\n        address oldPoolRegistry = poolRegistry;\n        poolRegistry = poolRegistry_;\n        emit PoolRegistryUpdated(oldPoolRegistry, poolRegistry_);\n    }\n\n    /// @notice Update the poolsAssetsDirectTransfer mapping\n    /// @param comptrollers Addresses of the pools\n    /// @param assets Addresses of the assets need to be added for direct transfer\n    /// @custom:error InvalidArguments thrown when comptrollers array length is not equal to assets array length\n    /// @custom:access Restricted by ACM\n    function setPoolsAssetsDirectTransfer(\n        address[] calldata comptrollers,\n        address[][] calldata assets,\n        bool[][] calldata values\n    ) external {\n        _checkAccessAllowed(\"setPoolsAssetsDirectTransfer(address[],address[][],bool[][])\");\n\n        uint256 comptrollersLength = comptrollers.length;\n\n        if ((comptrollersLength != assets.length) || (comptrollersLength != values.length)) {\n            revert InvalidArguments();\n        }\n\n        for (uint256 i; i < comptrollersLength; ++i) {\n            address[] memory poolAssets = assets[i];\n            bool[] memory assetsValues = values[i];\n\n            if (poolAssets.length != assetsValues.length) {\n                revert InvalidArguments();\n            }\n\n            for (uint256 j; j < poolAssets.length; ++j) {\n                poolsAssetsDirectTransfer[comptrollers[i]][poolAssets[j]] = assetsValues[j];\n                emit PoolAssetsDirectTransferUpdated(comptrollers[i], poolAssets[j], assetsValues[j]);\n            }\n        }\n    }\n\n    /// @dev Get the Amount of the asset in the risk fund for the specific pool\n    /// @param comptroller Comptroller address (pool)\n    /// @param asset Asset address\n    /// @return Asset's reserve in risk fund\n    function getPoolAssetReserve(address comptroller, address asset) external view returns (uint256) {\n        require(IComptroller(comptroller).isComptroller(), \"ReserveHelpers: Comptroller address invalid\");\n        require(asset != address(0), \"ReserveHelpers: Asset address invalid\");\n        return poolsAssetsReserves[comptroller][asset];\n    }\n\n    /// @dev Update the reserve of the asset for the specific pool after transferring to risk fund\n    /// and transferring funds to the protocol share reserve\n    /// @param comptroller Comptroller address (pool)\n    /// @param asset Asset address\n    function updateAssetsState(address comptroller, address asset) public {\n        require(IComptroller(comptroller).isComptroller(), \"ReserveHelpers: Comptroller address invalid\");\n        require(asset != address(0), \"ReserveHelpers: Asset address invalid\");\n        require(poolRegistry != address(0), \"ReserveHelpers: Pool Registry address is not set\");\n        require(ensureAssetListed(comptroller, asset), \"ReserveHelpers: The pool doesn't support the asset\");\n\n        IERC20Upgradeable token = IERC20Upgradeable(asset);\n        uint256 currentBalance = token.balanceOf(address(this));\n        uint256 assetReserve = assetsReserves[asset];\n        if (currentBalance > assetReserve) {\n            uint256 balanceDifference;\n            unchecked {\n                balanceDifference = currentBalance - assetReserve;\n            }\n            if (poolsAssetsDirectTransfer[comptroller][asset]) {\n                token.safeTransfer(destinationAddress, balanceDifference);\n                emit AssetTransferredToDestination(comptroller, asset, balanceDifference);\n                IRiskFund(destinationAddress).updatePoolState(comptroller, asset, balanceDifference);\n            } else {\n                assetsReserves[asset] += balanceDifference;\n                poolsAssetsReserves[comptroller][asset] += balanceDifference;\n                emit AssetsReservesUpdated(comptroller, asset, balanceDifference);\n            }\n        }\n    }\n\n    /// @notice Get the balance for specific token\n    /// @param tokenAddress Address of the token\n    function balanceOf(address tokenAddress) public view override returns (uint256 tokenBalance) {\n        return assetsReserves[tokenAddress];\n    }\n\n    /// @notice Hook to perform after converting tokens\n    /// @dev After transfromation poolsAssetsReserves are settled by pool's reserves fraction\n    /// @param tokenInAddress Address of the tokenIn\n    /// @param tokenOutAddress Address of the tokenOut\n    /// @param amountIn Amount of tokenIn transferred\n    /// @param amountOut Amount of tokenOut transferred\n    function postConversionHook(\n        address tokenInAddress,\n        address tokenOutAddress,\n        uint256 amountIn,\n        uint256 amountOut\n    ) internal override {\n        address[] memory pools = getPools(tokenOutAddress);\n        uint256 assetReserve = assetsReserves[tokenOutAddress];\n        for (uint256 i; i < pools.length; ++i) {\n            uint256 poolShare = (poolsAssetsReserves[pools[i]][tokenOutAddress] * EXP_SCALE) / assetReserve;\n            if (poolShare == 0) continue;\n            updatePoolAssetsReserve(pools[i], tokenOutAddress, amountOut, poolShare);\n            uint256 poolAmountInShare = (poolShare * amountIn) / EXP_SCALE;\n            IRiskFund(destinationAddress).updatePoolState(pools[i], tokenInAddress, poolAmountInShare);\n        }\n\n        assetsReserves[tokenOutAddress] -= amountOut;\n    }\n\n    /// @notice Operations to perform after sweepToken\n    /// @param tokenAddress Address of the token\n    /// @param amount Amount transferred to address(to)\n    function postSweepToken(address tokenAddress, uint256 amount) internal override {\n        uint256 balance = IERC20Upgradeable(tokenAddress).balanceOf(address(this));\n        uint256 balanceDiff = balance - assetsReserves[tokenAddress];\n\n        if (balanceDiff < amount) {\n            uint256 amountDiff = amount - balanceDiff;\n            address[] memory pools = getPools(tokenAddress);\n            uint256 assetReserve = assetsReserves[tokenAddress];\n            for (uint256 i; i < pools.length; ++i) {\n                uint256 poolShare = (poolsAssetsReserves[pools[i]][tokenAddress] * EXP_SCALE) / assetReserve;\n                if (poolShare == 0) continue;\n                updatePoolAssetsReserve(pools[i], tokenAddress, amountDiff, poolShare);\n            }\n            assetsReserves[tokenAddress] -= amountDiff;\n        }\n    }\n\n    /// @notice Update the poolAssetsResreves upon transferring the tokens\n    /// @param pool Address of the pool\n    /// @param tokenAddress Address of the token\n    /// @param amount Amount transferred to address(to)\n    /// @param poolShare share for corresponding pool\n    function updatePoolAssetsReserve(address pool, address tokenAddress, uint256 amount, uint256 poolShare) internal {\n        uint256 poolAmountShare = (poolShare * amount) / EXP_SCALE;\n        poolsAssetsReserves[pool][tokenAddress] -= poolAmountShare;\n    }\n\n    /// @notice Get the array of all pools addresses\n    /// @param tokenAddress Address of the token\n    function getPools(address tokenAddress) internal view returns (address[] memory) {\n        address[] memory pools = IPoolRegistry(poolRegistry).getPoolsSupportedByAsset(tokenAddress);\n\n        if (isAssetListedInCore(tokenAddress)) {\n            uint256 poolsLength = pools.length;\n            address[] memory poolsWithCore = new address[](poolsLength + 1);\n\n            for (uint256 i; i < poolsLength; ++i) {\n                poolsWithCore[i] = pools[i];\n            }\n            poolsWithCore[poolsLength] = corePoolComptroller;\n            return poolsWithCore;\n        }\n\n        return pools;\n    }\n\n    function isAssetListedInCore(address tokenAddress) internal view returns (bool isAssetListed) {\n        address[] memory coreMarkets = IComptroller(corePoolComptroller).getAllMarkets();\n\n        for (uint256 i; i < coreMarkets.length; ++i) {\n            isAssetListed = (vBNB == coreMarkets[i])\n                ? (tokenAddress == NATIVE_WRAPPED)\n                : (IVToken(coreMarkets[i]).underlying() == tokenAddress);\n\n            if (isAssetListed) {\n                break;\n            }\n        }\n    }\n\n    function ensureAssetListed(address comptroller, address asset) internal view returns (bool) {\n        if (comptroller == corePoolComptroller) {\n            return isAssetListedInCore(asset);\n        }\n\n        return IPoolRegistry(poolRegistry).getVTokenForAsset(comptroller, asset) != address(0);\n    }\n}"
    },
    {
      "filename": "contracts/TokenConverter/RiskFundConverter.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { ResilientOracle } from \"@venusprotocol/oracle/contracts/ResilientOracle.sol\";\n\nimport { AbstractTokenConverter } from \"./AbstractTokenConverter.sol\";\nimport { ensureNonzeroAddress } from \"../Utils/Validators.sol\";\nimport { IPoolRegistry } from \"../Interfaces/IPoolRegistry.sol\";\nimport { IComptroller } from \"../Interfaces/IComptroller.sol\";\nimport { IRiskFund } from \"../Interfaces/IRiskFund.sol\";\nimport { IVToken } from \"../Interfaces/IVToken.sol\";\nimport { EXP_SCALE } from \"../Utils/Constants.sol\";\n\ncontract RiskFundConverter is AbstractTokenConverter {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice Address of the core pool comptroller\n    address public immutable corePoolComptroller;\n\n    ///@notice Address of the vBNB\n    ///@dev This address is used to exclude the BNB market while in getPools method\n    address public immutable vBNB;\n\n    ///@notice Address of the native wrapped currency\n    address public immutable NATIVE_WRAPPED;\n\n    /// @notice Store the previous state for the asset transferred to ProtocolShareReserve combined(for all pools)\n    mapping(address => uint256) internal assetsReserves;\n\n    /// @notice Store the asset's reserve per pool in the ProtocolShareReserve\n    /// @dev Comptroller(pool) -> Asset -> amount\n    mapping(address => mapping(address => uint256)) internal poolsAssetsReserves;\n\n    /// @notice Address of pool registry contract\n    address public poolRegistry;\n\n    /// @notice This mapping would contain the assets for the pool which would be send to RiskFund directly\n    /// @dev Comptroller(pool) -> Asset -> bool(should transfer directly on true)\n    mapping(address => mapping(address => bool)) public poolsAssetsDirectTransfer;\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain\n    uint256[46] private __gap;\n\n    /// @notice Emitted when pool registry address is updated\n    event PoolRegistryUpdated(address indexed oldPoolRegistry, address indexed newPoolRegistry);\n\n    // Event emitted after the updation of the assets reserves\n    // amount -> reserve increased by amount\n    event AssetsReservesUpdated(address indexed comptroller, address indexed asset, uint256 amount);\n\n    // Event emitted after the funds transferred to the destination address\n    event AssetTransferredToDestination(address indexed comptroller, address indexed asset, uint256 amount);\n\n    // Event emitted after the poolsAssetsDirectTransfer mapping is updated\n    event PoolAssetsDirectTransferUpdated(address indexed comptroller, address indexed asset, bool value);\n\n    // Error thrown when comptrollers array length is not equal to assets array length\n    error InvalidArguments();\n\n    /// @param corePoolComptroller_ Address of the Comptroller pool\n    /// @param vBNB_ Address of the vBNB\n    /// @param nativeWrapped_ Address of the wrapped native currency\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address corePoolComptroller_, address vBNB_, address nativeWrapped_) {\n        ensureNonzeroAddress(corePoolComptroller_);\n        corePoolComptroller = corePoolComptroller_;\n        vBNB = vBNB_;\n        NATIVE_WRAPPED = nativeWrapped_;\n    }\n\n    /// @param accessControlManager_ Access control manager contract address\n    /// @param priceOracle_ Resilient oracle address\n    /// @param destinationAddress_  Address at all incoming tokens will transferred to\n    /// @param poolRegistry_ Address of the pool registry\n    function initialize(\n        address accessControlManager_,\n        ResilientOracle priceOracle_,\n        address destinationAddress_,\n        address poolRegistry_\n    ) public initializer {\n        // Initialize AbstractTokenConverter\n        __AbstractTokenConverter_init(accessControlManager_, priceOracle_, destinationAddress_);\n        poolRegistry = poolRegistry_;\n    }\n\n    /// @dev Pool registry setter\n    /// @param poolRegistry_ Address of the pool registry\n    /// @custom:event PoolRegistryUpdated emits on success\n    /// @custom:error ZeroAddressNotAllowed is thrown when pool registry address is zero\n    function setPoolRegistry(address poolRegistry_) external onlyOwner {\n        ensureNonzeroAddress(poolRegistry_);\n        address oldPoolRegistry = poolRegistry;\n        poolRegistry = poolRegistry_;\n        emit PoolRegistryUpdated(oldPoolRegistry, poolRegistry_);\n    }\n\n    /// @notice Update the poolsAssetsDirectTransfer mapping\n    /// @param comptrollers Addresses of the pools\n    /// @param assets Addresses of the assets need to be added for direct transfer\n    /// @custom:error InvalidArguments thrown when comptrollers array length is not equal to assets array length\n    /// @custom:access Restricted by ACM\n    function setPoolsAssetsDirectTransfer(\n        address[] calldata comptrollers,\n        address[][] calldata assets,\n        bool[][] calldata values\n    ) external {\n        _checkAccessAllowed(\"setPoolsAssetsDirectTransfer(address[],address[][],bool[][])\");\n\n        uint256 comptrollersLength = comptrollers.length;\n\n        if ((comptrollersLength != assets.length) || (comptrollersLength != values.length)) {\n            revert InvalidArguments();\n        }\n\n        for (uint256 i; i < comptrollersLength; ++i) {\n            address[] memory poolAssets = assets[i];\n            bool[] memory assetsValues = values[i];\n\n            if (poolAssets.length != assetsValues.length) {\n                revert InvalidArguments();\n            }\n\n            for (uint256 j; j < poolAssets.length; ++j) {\n                poolsAssetsDirectTransfer[comptrollers[i]][poolAssets[j]] = assetsValues[j];\n                emit PoolAssetsDirectTransferUpdated(comptrollers[i], poolAssets[j], assetsValues[j]);\n            }\n        }\n    }\n\n    /// @dev Get the Amount of the asset in the risk fund for the specific pool\n    /// @param comptroller Comptroller address (pool)\n    /// @param asset Asset address\n    /// @return Asset's reserve in risk fund\n    function getPoolAssetReserve(address comptroller, address asset) external view returns (uint256) {\n        require(IComptroller(comptroller).isComptroller(), \"ReserveHelpers: Comptroller address invalid\");\n        require(asset != address(0), \"ReserveHelpers: Asset address invalid\");\n        return poolsAssetsReserves[comptroller][asset];\n    }\n\n    /// @dev Update the reserve of the asset for the specific pool after transferring to risk fund\n    /// and transferring funds to the protocol share reserve\n    /// @param comptroller Comptroller address (pool)\n    /// @param asset Asset address\n    function updateAssetsState(address comptroller, address asset) public {\n        require(IComptroller(comptroller).isComptroller(), \"ReserveHelpers: Comptroller address invalid\");\n        require(asset != address(0), \"ReserveHelpers: Asset address invalid\");\n        require(poolRegistry != address(0), \"ReserveHelpers: Pool Registry address is not set\");\n        require(ensureAssetListed(comptroller, asset), \"ReserveHelpers: The pool doesn't support the asset\");\n\n        IERC20Upgradeable token = IERC20Upgradeable(asset);\n        uint256 currentBalance = token.balanceOf(address(this));\n        uint256 assetReserve = assetsReserves[asset];\n        if (currentBalance > assetReserve) {\n            uint256 balanceDifference;\n            unchecked {\n                balanceDifference = currentBalance - assetReserve;\n            }\n            if (poolsAssetsDirectTransfer[comptroller][asset]) {\n                token.safeTransfer(destinationAddress, balanceDifference);\n                emit AssetTransferredToDestination(comptroller, asset, balanceDifference);\n                IRiskFund(destinationAddress).updatePoolState(comptroller, asset, balanceDifference);\n            } else {\n                assetsReserves[asset] += balanceDifference;\n                poolsAssetsReserves[comptroller][asset] += balanceDifference;\n                emit AssetsReservesUpdated(comptroller, asset, balanceDifference);\n            }\n        }\n    }\n\n    /// @notice Get the balance for specific token\n    /// @param tokenAddress Address of the token\n    function balanceOf(address tokenAddress) public view override returns (uint256 tokenBalance) {\n        return assetsReserves[tokenAddress];\n    }\n\n    /// @notice Hook to perform after converting tokens\n    /// @dev After transfromation poolsAssetsReserves are settled by pool's reserves fraction\n    /// @param tokenInAddress Address of the tokenIn\n    /// @param tokenOutAddress Address of the tokenOut\n    /// @param amountIn Amount of tokenIn transferred\n    /// @param amountOut Amount of tokenOut transferred\n    function postConversionHook(\n        address tokenInAddress,\n        address tokenOutAddress,\n        uint256 amountIn,\n        uint256 amountOut\n    ) internal override {\n        address[] memory pools = getPools(tokenOutAddress);\n        uint256 assetReserve = assetsReserves[tokenOutAddress];\n        for (uint256 i; i < pools.length; ++i) {\n            uint256 poolShare = (poolsAssetsReserves[pools[i]][tokenOutAddress] * EXP_SCALE) / assetReserve;\n            if (poolShare == 0) continue;\n            updatePoolAssetsReserve(pools[i], tokenOutAddress, amountOut, poolShare);\n            uint256 poolAmountInShare = (poolShare * amountIn) / EXP_SCALE;\n            IRiskFund(destinationAddress).updatePoolState(pools[i], tokenInAddress, poolAmountInShare);\n        }\n\n        assetsReserves[tokenOutAddress] -= amountOut;\n    }\n\n    /// @notice Operations to perform after sweepToken\n    /// @param tokenAddress Address of the token\n    /// @param amount Amount transferred to address(to)\n    function postSweepToken(address tokenAddress, uint256 amount) internal override {\n        uint256 balance = IERC20Upgradeable(tokenAddress).balanceOf(address(this));\n        uint256 balanceDiff = balance - assetsReserves[tokenAddress];\n\n        if (balanceDiff < amount) {\n            uint256 amountDiff = amount - balanceDiff;\n            address[] memory pools = getPools(tokenAddress);\n            uint256 assetReserve = assetsReserves[tokenAddress];\n            for (uint256 i; i < pools.length; ++i) {\n                uint256 poolShare = (poolsAssetsReserves[pools[i]][tokenAddress] * EXP_SCALE) / assetReserve;\n                if (poolShare == 0) continue;\n                updatePoolAssetsReserve(pools[i], tokenAddress, amountDiff, poolShare);\n            }\n            assetsReserves[tokenAddress] -= amountDiff;\n        }\n    }\n\n    /// @notice Update the poolAssetsResreves upon transferring the tokens\n    /// @param pool Address of the pool\n    /// @param tokenAddress Address of the token\n    /// @param amount Amount transferred to address(to)\n    /// @param poolShare share for corresponding pool\n    function updatePoolAssetsReserve(address pool, address tokenAddress, uint256 amount, uint256 poolShare) internal {\n        uint256 poolAmountShare = (poolShare * amount) / EXP_SCALE;\n        poolsAssetsReserves[pool][tokenAddress] -= poolAmountShare;\n    }\n\n    /// @notice Get the array of all pools addresses\n    /// @param tokenAddress Address of the token\n    function getPools(address tokenAddress) internal view returns (address[] memory) {\n        address[] memory pools = IPoolRegistry(poolRegistry).getPoolsSupportedByAsset(tokenAddress);\n\n        if (isAssetListedInCore(tokenAddress)) {\n            uint256 poolsLength = pools.length;\n            address[] memory poolsWithCore = new address[](poolsLength + 1);\n\n            for (uint256 i; i < poolsLength; ++i) {\n                poolsWithCore[i] = pools[i];\n            }\n            poolsWithCore[poolsLength] = corePoolComptroller;\n            return poolsWithCore;\n        }\n\n        return pools;\n    }\n\n    function isAssetListedInCore(address tokenAddress) internal view returns (bool isAssetListed) {\n        address[] memory coreMarkets = IComptroller(corePoolComptroller).getAllMarkets();\n\n        for (uint256 i; i < coreMarkets.length; ++i) {\n            isAssetListed = (vBNB == coreMarkets[i])\n                ? (tokenAddress == NATIVE_WRAPPED)\n                : (IVToken(coreMarkets[i]).underlying() == tokenAddress);\n\n            if (isAssetListed) {\n                break;\n            }\n        }\n    }\n\n    function ensureAssetListed(address comptroller, address asset) internal view returns (bool) {\n        if (comptroller == corePoolComptroller) {\n            return isAssetListedInCore(asset);\n        }\n\n        return IPoolRegistry(poolRegistry).getVTokenForAsset(comptroller, asset) != address(0);\n    }\n}"
    }
  ]
}