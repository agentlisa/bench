{
  "Title": "[H-01] Liquidations can be prevented by frontrunning and liquidating 1 debt (or more) due to wrong assumption in POS\\_MANAGER",
  "Content": "\nUsers can avoid being liquidated if they frontrun liquidation calls with a liquidate call with 1 wei. Or, they may do a partial liquidation and avoid being liquidated before the interest reaches the value of the debt pre liquidation. The total interest stored in `__posBorrInfos[_posId].borrExtraInfos[_pool].totalInterest` would also be wrong.\n\n### Proof of Concept\n\nThe `POS_MANAGER` stores the total interest in `__posBorrInfos[_posId].borrExtraInfos[_pool].totalInterest`. Function `updatePosDebtShares()` [assumes](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/PosManager.sol#L175) that `ILendingPool(_pool).debtShareToAmtCurrent(currDebtShares)` is always increasing, but this is not the case, as a liquidation may happen that reduces the current debt amount. This leads to calls to `updatePosDebtShares()` reverting.\n\nThe most relevant is when liquidating, such that users could liquidate themselves for small amounts (1) and prevent liqudiations in the same block. This is because the debt accrual happens over time, so if the block.timestamp is the same, no debt accrual will happen. Thus, if a liquidate call with 1 amount frontruns a liquidate call with any amount, the second call will revert.\n\nA user could still stop liquidations for as long as the accrued interest doesn't reach the last debt value before liquidation, if the user liquidated a bigger part of the debt.\n\nAdd the following test to `TestInitCore.sol`:\n\n```solidity\nfunction test_POC_Liquidate_reverts_frontrunning_PosManager_WrongAssumption() public {\n    address poolUSDT = address(lendingPools[USDT]);\n    address poolWBTC = address(lendingPools[WBTC]);\n    _setTargetHealthAfterLiquidation_e18(1, type(uint64).max); // by pass max health after liquidate capped\n    _setFixedRateIRM(poolWBTC, 0.1e18); // 10% per sec\n\n    uint collAmt;\n    uint borrAmt;\n\n    {\n        uint collUSD = 100_000;\n        uint borrUSDMax = 80_000;\n        collAmt = _priceToTokenAmt(USDT, collUSD);\n        borrAmt = _priceToTokenAmt(WBTC, borrUSDMax);\n    }\n\n    address liquidator = BOB;\n    deal(USDT, ALICE, collAmt);\n    deal(WBTC, liquidator, borrAmt * 2);\n\n    // provides liquidity for borrow\n    _fundPool(poolWBTC, borrAmt);\n\n    // create position and collateralize\n    uint posId = _createPos(ALICE, ALICE, 1);\n    _collateralizePosition(ALICE, posId, poolUSDT, collAmt, bytes(''));\n\n    // borrow\n    _borrow(ALICE, posId, poolWBTC, borrAmt, bytes(''));\n\n    // fast forward time and accrue interest\n    vm.warp(block.timestamp + 1 seconds);\n    ILendingPool(poolWBTC).accrueInterest();\n\n    uint debtShares = positionManager.getPosDebtShares(posId, poolWBTC);\n\n    _liquidate(liquidator, posId, 1, poolWBTC, poolUSDT, false, bytes(''));\n\n    // liquidate all debtShares\n    _liquidate(liquidator, posId, 1000, poolWBTC, poolUSDT, false, bytes('panic'));\n}\n```\n\n### Tools Used\n\nVscode, Foundry\n\n### Recommended Mitigation Steps\n\nUpdate the user's last debt position `__posBorrInfos[_posId].borrExtraInfos[_pool].totalInterest` on `_repay()`.\n\n**[fez-init (INIT) confirmed](https://github.com/code-423n4/2023-12-initcapital-findings/issues/42#issuecomment-1872425149)**\n\n\n**[hansfriese (Judge) commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/42#issuecomment-1872433152):**\n > After discussing internally with the sponsor/warden, we've confirmed the issue.\n> Here is a part of the discussion:\n> \n> > \"When it frontruns the liquidation with 1 share, it removes 1 share and 2 debt.<br>\n> > When it calculates the amount again in the following liquidation, the shares will be worth 1 less and it reverts.\"\n> \n> As a mitigation, we can update `extraInfo.totalInterest` only when [debtAmtCurrent > extraInfo.lastDebtAmt](https://github.com/code-423n4/2023-12-initcapital/blob/a53e401529451b208095b3af11862984d0b32177/contracts/core/PosManager.sol#L176).\n>\n > ![image](https://github.com/code-423n4/2023-12-initcapital-findings/assets/45533148/c1bd109c-4c8e-4683-b559-055128efb64f)\n> \n > High is appropriate as the main invariant might be broken temporarily while repaying.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-12-initcapital",
  "Code": [
    {
      "filename": "contracts/core/PosManager.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport '../common/library/InitErrors.sol';\nimport '../common/library/UncheckedIncrement.sol';\nimport {IPosManager} from '../interfaces/core/IPosManager.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IBaseWrapLp} from '../interfaces/wrapper/IBaseWrapLp.sol';\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {SafeCast} from '@openzeppelin-contracts/utils/math/SafeCast.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {ERC721EnumerableUpgradeable} from\n    '@openzeppelin-contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol';\nimport {ERC721HolderUpgradeable} from\n    '@openzeppelin-contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\nimport {EnumerableSet} from '@openzeppelin-contracts/utils/structs/EnumerableSet.sol';\nimport {UnderACM} from '../common/UnderACM.sol';\n\ncontract PosManager is IPosManager, UnderACM, ERC721EnumerableUpgradeable, ERC721HolderUpgradeable {\n    using SafeCast for uint;\n    using SafeCast for int;\n    using UncheckedIncrement for uint;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    // constants\n    bytes32 private constant GUARDIAN = keccak256('guardian');\n\n    // storages\n    mapping(address => uint) public nextNonces; // @inheritdoc IPosManager\n    mapping(uint => PosInfo) private __posInfos;\n    mapping(uint => PosCollInfo) private __posCollInfos;\n    mapping(uint => PosBorrInfo) private __posBorrInfos;\n    mapping(address => uint) private __collBalances;\n    address public core;\n    uint8 public maxCollCount; // limit number of collateral to avoid out of gas\n    mapping(uint => mapping(address => uint)) public pendingRewards; // @inheritdoc IPosManager\n    mapping(address => mapping(uint => bool)) public isCollateralized; // @inheritdoc IPosManager\n    mapping(address => EnumerableSet.UintSet) private __viewerPosIds;\n\n    // modifiers\n    modifier onlyGuardian() {\n        ACM.checkRole(GUARDIAN, msg.sender);\n        _;\n    }\n\n    modifier onlyCore() {\n        _require(msg.sender == core, Errors.NOT_INIT_CORE);\n        _;\n    }\n\n    modifier onlyAuthorized(uint _posId) {\n        _require(_isApprovedOrOwner(msg.sender, _posId), Errors.NOT_AUTHORIZED);\n        _;\n    }\n\n    // constructor\n    constructor(address _acm) UnderACM(_acm) {\n        _disableInitializers();\n    }\n\n    // initializer\n    /// @dev initialize the contract, set the ERC721's name and symbol, and set the init core address\n    /// @param _name ERC721's name\n    /// @param _symbol ERC721's symbol\n    /// @param _core core address\n    function initialize(string calldata _name, string calldata _symbol, address _core, uint8 _maxCollCount)\n        external\n        initializer\n    {\n        __ERC721_init(_name, _symbol);\n        core = _core;\n        maxCollCount = _maxCollCount;\n        emit SetMaxCollCount(_maxCollCount);\n    }\n\n    // functions\n    /// @inheritdoc IPosManager\n    function getPosBorrInfo(uint _posId) external view returns (address[] memory pools, uint[] memory debtShares) {\n        PosBorrInfo storage posBorrInfo = __posBorrInfos[_posId];\n        pools = posBorrInfo.pools.values();\n        debtShares = new uint[](pools.length);\n        for (uint i; i < pools.length; i = i.uinc()) {\n            debtShares[i] = posBorrInfo.debtShares[pools[i]];\n        }\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosBorrExtraInfo(uint _posId, address _pool)\n        external\n        view\n        returns (uint totalInterest, uint lastDebtAmt)\n    {\n        PosBorrExtraInfo memory borrExtraInfo = __posBorrInfos[_posId].borrExtraInfos[_pool];\n        totalInterest = borrExtraInfo.totalInterest;\n        lastDebtAmt = borrExtraInfo.lastDebtAmt;\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosCollInfo(uint _posId)\n        external\n        view\n        returns (\n            address[] memory pools,\n            uint[] memory amts,\n            address[] memory wLps,\n            uint[][] memory ids,\n            uint[][] memory wLpAmts\n        )\n    {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        pools = posCollInfo.collTokens.values();\n        amts = new uint[](pools.length);\n        for (uint i; i < pools.length; i = i.uinc()) {\n            amts[i] = posCollInfo.collAmts[pools[i]];\n        }\n        wLps = posCollInfo.wLps.values();\n        ids = new uint[][](wLps.length);\n        wLpAmts = new uint[][](wLps.length);\n        for (uint i; i < wLps.length; i = i.uinc()) {\n            ids[i] = posCollInfo.ids[wLps[i]].values();\n            wLpAmts[i] = new uint[](ids[i].length);\n            for (uint j; j < ids[i].length; j = j.uinc()) {\n                wLpAmts[i][j] = IBaseWrapLp(wLps[i]).balanceOfLp(ids[i][j]);\n            }\n        }\n    }\n\n    /// @inheritdoc IPosManager\n    function getCollAmt(uint _posId, address _pool) external view returns (uint amt) {\n        amt = __posCollInfos[_posId].collAmts[_pool];\n    }\n\n    /// @inheritdoc IPosManager\n    function getCollWLpAmt(uint _posId, address _wLp, uint _tokenId) external view returns (uint amt) {\n        if (__posCollInfos[_posId].ids[_wLp].contains(_tokenId)) {\n            amt = IBaseWrapLp(_wLp).balanceOfLp(_tokenId);\n        }\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosInfo(uint _posId) external view returns (address viewer, uint16 mode) {\n        PosInfo memory info = __posInfos[_posId];\n        viewer = info.viewer;\n        mode = info.mode;\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosMode(uint _posId) external view returns (uint16 mode) {\n        mode = __posInfos[_posId].mode;\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosDebtShares(uint _posId, address _pool) external view returns (uint debtShares) {\n        debtShares = __posBorrInfos[_posId].debtShares[_pool];\n    }\n\n    /// @inheritdoc IPosManager\n    function getViewerPosIdsAt(address _viewer, uint _index) external view returns (uint posId) {\n        posId = __viewerPosIds[_viewer].at(_index);\n    }\n\n    /// @inheritdoc IPosManager\n    function getViewerPosIdsLength(address _viewer) external view returns (uint length) {\n        length = __viewerPosIds[_viewer].length();\n    }\n\n    /// @inheritdoc IPosManager\n    function updatePosDebtShares(uint _posId, address _pool, int _deltaShares) external onlyCore {\n        uint currDebtShares = __posBorrInfos[_posId].debtShares[_pool];\n        uint debtAmtCurrent = ILendingPool(_pool).debtShareToAmtCurrent(currDebtShares);\n        PosBorrExtraInfo storage extraInfo = __posBorrInfos[_posId].borrExtraInfos[_pool];\n        // update interest accrued since last update\n        // NOTE: debtAmtCurrent is always >= lastDebtAmt\n        extraInfo.totalInterest += (debtAmtCurrent - extraInfo.lastDebtAmt).toUint128();\n        uint newDebtShares = (currDebtShares.toInt256() + _deltaShares).toUint256();\n        // handle first borrower\n        uint newDebtAmt = ILendingPool(_pool).totalDebtShares() > 0\n            ? ILendingPool(_pool).debtShareToAmtStored(newDebtShares)\n            : newDebtShares;\n        __posBorrInfos[_posId].debtShares[_pool] = newDebtShares;\n        // snapshot the current debt amount for next interest calculation\n        extraInfo.lastDebtAmt = newDebtAmt.toUint128();\n        if (newDebtShares > 0) __posBorrInfos[_posId].pools.add(_pool);\n        else __posBorrInfos[_posId].pools.remove(_pool);\n    }\n\n    /// @inheritdoc IPosManager\n    function updatePosMode(uint _posId, uint16 _mode) external onlyCore {\n        __posInfos[_posId].mode = _mode;\n    }\n\n    /// @inheritdoc IPosManager\n    function addCollateral(uint _posId, address _pool) external onlyCore returns (uint amtIn) {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        uint newBalance = IERC20(_pool).balanceOf(address(this));\n        amtIn = newBalance - __collBalances[_pool];\n        _require(amtIn != 0, Errors.ZERO_VALUE);\n        uint posBalance = posCollInfo.collAmts[_pool];\n        if (posBalance == 0) {\n            posCollInfo.collTokens.add(_pool);\n            uint8 collCount = posCollInfo.collCount + 1;\n            // NOTE: to avoid out of gas\n            _require(collCount <= maxCollCount, Errors.MAX_COLLATERAL_COUNT_REACHED);\n            posCollInfo.collCount = collCount;\n        }\n        posCollInfo.collAmts[_pool] = posBalance + amtIn;\n        __collBalances[_pool] = newBalance;\n    }\n\n    /// @inheritdoc IPosManager\n    function addCollateralWLp(uint _posId, address _wLp, uint _tokenId) external onlyCore returns (uint amtIn) {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        _require(IBaseWrapLp(_wLp).ownerOf(_tokenId) == address(this), Errors.NOT_OWNER);\n        _require(!isCollateralized[_wLp][_tokenId], Errors.ALREADY_COLLATERALIZED);\n        _require(IBaseWrapLp(_wLp).balanceOfLp(_tokenId) != 0, Errors.ZERO_VALUE);\n        posCollInfo.wLps.add(_wLp);\n        // NOTE: will return true if add new id\n        if (posCollInfo.ids[_wLp].add(_tokenId)) {\n            uint8 collCount = posCollInfo.collCount + 1;\n            _require(collCount <= maxCollCount, Errors.MAX_COLLATERAL_COUNT_REACHED);\n            posCollInfo.collCount = collCount;\n        }\n        isCollateralized[_wLp][_tokenId] = true;\n        amtIn = IBaseWrapLp(_wLp).balanceOfLp(_tokenId);\n    }\n\n    /// @inheritdoc IPosManager\n    function removeCollateralTo(uint _posId, address _pool, uint _shares, address _receiver)\n        external\n        onlyCore\n        returns (uint)\n    {\n        _require(_shares > 0, Errors.ZERO_VALUE);\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        uint newPosCollAmt = posCollInfo.collAmts[_pool] - _shares;\n        if (newPosCollAmt == 0) {\n            posCollInfo.collTokens.remove(_pool);\n            posCollInfo.collCount -= 1;\n        }\n        posCollInfo.collAmts[_pool] = newPosCollAmt;\n        IERC20(_pool).safeTransfer(_receiver, _shares);\n        __collBalances[_pool] = IERC20(_pool).balanceOf(address(this));\n        return _shares;\n    }\n\n    /// @inheritdoc IPosManager\n    function removeCollateralWLpTo(uint _posId, address _wLp, uint _tokenId, uint _amt, address _receiver)\n        external\n        onlyCore\n        returns (uint)\n    {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        // NOTE: balanceOfLp should be 1:1 with amt\n        uint newWLpAmt = IBaseWrapLp(_wLp).balanceOfLp(_tokenId) - _amt;\n        if (newWLpAmt == 0) {\n            _require(posCollInfo.ids[_wLp].remove(_tokenId), Errors.NOT_CONTAIN);\n            posCollInfo.collCount -= 1;\n            if (posCollInfo.ids[_wLp].length() == 0) {\n                posCollInfo.wLps.remove(_wLp);\n            }\n            isCollateralized[_wLp][_tokenId] = false;\n        }\n        _harvest(_posId, _wLp, _tokenId);\n        IBaseWrapLp(_wLp).unwrap(_tokenId, _amt, _receiver);\n        return _amt;\n    }\n\n    /// @inheritdoc IPosManager\n    function createPos(address _owner, uint16 _mode, address _viewer) external onlyCore returns (uint posId) {\n        uint nonce = nextNonces[_owner]++;\n        posId = uint(keccak256(abi.encodePacked(_owner, nonce)));\n        _updateViewerPosIds(posId, _viewer);\n        __posInfos[posId].viewer = _viewer;\n        __posInfos[posId].mode = _mode;\n        _safeMint(_owner, posId);\n    }\n\n    /// @inheritdoc IPosManager\n    function harvestTo(uint _posId, address _wlp, uint _tokenId, address _to)\n        public\n        onlyAuthorized(_posId)\n        returns (address[] memory tokens, uint[] memory amts)\n    {\n        // check that pos hold wlp\n        _require(__posCollInfos[_posId].ids[_wlp].contains(_tokenId), Errors.NOT_CONTAIN);\n        (tokens, amts) = IBaseWrapLp(_wlp).harvest(_tokenId, _to);\n    }\n\n    /// @inheritdoc IPosManager\n    function claimPendingRewards(uint _posId, address[] calldata _tokens, address _to)\n        external\n        onlyAuthorized(_posId)\n        returns (uint[] memory amts)\n    {\n        amts = new uint[](_tokens.length);\n        for (uint i; i < _tokens.length; i = i.uinc()) {\n            amts[i] = pendingRewards[_posId][_tokens[i]];\n            if (amts[i] != 0) {\n                pendingRewards[_posId][_tokens[i]] = 0;\n                IERC20(_tokens[i]).safeTransfer(_to, amts[i]);\n            }\n        }\n    }\n\n    /// @dev harvest reward tokens and update the pending rewards for the position\n    function _harvest(uint _posId, address _wlp, uint _tokenId) internal {\n        (address[] memory tokens, uint[] memory amts) = IBaseWrapLp(_wlp).harvest(_tokenId, address(this));\n        for (uint i; i < tokens.length; i = i.uinc()) {\n            pendingRewards[_posId][tokens[i]] += amts[i];\n        }\n    }\n\n    /// @inheritdoc IPosManager\n    function isAuthorized(address _account, uint _posId) external view returns (bool) {\n        return _isApprovedOrOwner(_account, _posId);\n    }\n\n    /// @inheritdoc IPosManager\n    function setMaxCollCount(uint8 _maxCollCount) external onlyGuardian {\n        maxCollCount = _maxCollCount;\n        emit SetMaxCollCount(_maxCollCount);\n    }\n\n    /// @inheritdoc IPosManager\n    function setPosViewer(uint _posId, address _viewer) external onlyAuthorized(_posId) {\n        _require(__posInfos[_posId].viewer != _viewer, Errors.ALREADY_SET);\n        _updateViewerPosIds(_posId, _viewer);\n        __posInfos[_posId].viewer = _viewer;\n    }\n\n    /// @dev update position viewer to ids mapping\n    function _updateViewerPosIds(uint _posId, address _viewer) internal {\n        address oldViewer = __posInfos[_posId].viewer;\n        // remove pos id from old viewer\n        if (oldViewer != address(0)) __viewerPosIds[oldViewer].remove(_posId);\n        // add pos id to new viewer\n        __viewerPosIds[_viewer].add(_posId);\n    }\n}"
    },
    {
      "filename": "contracts/core/PosManager.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport '../common/library/InitErrors.sol';\nimport '../common/library/UncheckedIncrement.sol';\nimport {IPosManager} from '../interfaces/core/IPosManager.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IBaseWrapLp} from '../interfaces/wrapper/IBaseWrapLp.sol';\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {SafeCast} from '@openzeppelin-contracts/utils/math/SafeCast.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {ERC721EnumerableUpgradeable} from\n    '@openzeppelin-contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol';\nimport {ERC721HolderUpgradeable} from\n    '@openzeppelin-contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\nimport {EnumerableSet} from '@openzeppelin-contracts/utils/structs/EnumerableSet.sol';\nimport {UnderACM} from '../common/UnderACM.sol';\n\ncontract PosManager is IPosManager, UnderACM, ERC721EnumerableUpgradeable, ERC721HolderUpgradeable {\n    using SafeCast for uint;\n    using SafeCast for int;\n    using UncheckedIncrement for uint;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    // constants\n    bytes32 private constant GUARDIAN = keccak256('guardian');\n\n    // storages\n    mapping(address => uint) public nextNonces; // @inheritdoc IPosManager\n    mapping(uint => PosInfo) private __posInfos;\n    mapping(uint => PosCollInfo) private __posCollInfos;\n    mapping(uint => PosBorrInfo) private __posBorrInfos;\n    mapping(address => uint) private __collBalances;\n    address public core;\n    uint8 public maxCollCount; // limit number of collateral to avoid out of gas\n    mapping(uint => mapping(address => uint)) public pendingRewards; // @inheritdoc IPosManager\n    mapping(address => mapping(uint => bool)) public isCollateralized; // @inheritdoc IPosManager\n    mapping(address => EnumerableSet.UintSet) private __viewerPosIds;\n\n    // modifiers\n    modifier onlyGuardian() {\n        ACM.checkRole(GUARDIAN, msg.sender);\n        _;\n    }\n\n    modifier onlyCore() {\n        _require(msg.sender == core, Errors.NOT_INIT_CORE);\n        _;\n    }\n\n    modifier onlyAuthorized(uint _posId) {\n        _require(_isApprovedOrOwner(msg.sender, _posId), Errors.NOT_AUTHORIZED);\n        _;\n    }\n\n    // constructor\n    constructor(address _acm) UnderACM(_acm) {\n        _disableInitializers();\n    }\n\n    // initializer\n    /// @dev initialize the contract, set the ERC721's name and symbol, and set the init core address\n    /// @param _name ERC721's name\n    /// @param _symbol ERC721's symbol\n    /// @param _core core address\n    function initialize(string calldata _name, string calldata _symbol, address _core, uint8 _maxCollCount)\n        external\n        initializer\n    {\n        __ERC721_init(_name, _symbol);\n        core = _core;\n        maxCollCount = _maxCollCount;\n        emit SetMaxCollCount(_maxCollCount);\n    }\n\n    // functions\n    /// @inheritdoc IPosManager\n    function getPosBorrInfo(uint _posId) external view returns (address[] memory pools, uint[] memory debtShares) {\n        PosBorrInfo storage posBorrInfo = __posBorrInfos[_posId];\n        pools = posBorrInfo.pools.values();\n        debtShares = new uint[](pools.length);\n        for (uint i; i < pools.length; i = i.uinc()) {\n            debtShares[i] = posBorrInfo.debtShares[pools[i]];\n        }\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosBorrExtraInfo(uint _posId, address _pool)\n        external\n        view\n        returns (uint totalInterest, uint lastDebtAmt)\n    {\n        PosBorrExtraInfo memory borrExtraInfo = __posBorrInfos[_posId].borrExtraInfos[_pool];\n        totalInterest = borrExtraInfo.totalInterest;\n        lastDebtAmt = borrExtraInfo.lastDebtAmt;\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosCollInfo(uint _posId)\n        external\n        view\n        returns (\n            address[] memory pools,\n            uint[] memory amts,\n            address[] memory wLps,\n            uint[][] memory ids,\n            uint[][] memory wLpAmts\n        )\n    {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        pools = posCollInfo.collTokens.values();\n        amts = new uint[](pools.length);\n        for (uint i; i < pools.length; i = i.uinc()) {\n            amts[i] = posCollInfo.collAmts[pools[i]];\n        }\n        wLps = posCollInfo.wLps.values();\n        ids = new uint[][](wLps.length);\n        wLpAmts = new uint[][](wLps.length);\n        for (uint i; i < wLps.length; i = i.uinc()) {\n            ids[i] = posCollInfo.ids[wLps[i]].values();\n            wLpAmts[i] = new uint[](ids[i].length);\n            for (uint j; j < ids[i].length; j = j.uinc()) {\n                wLpAmts[i][j] = IBaseWrapLp(wLps[i]).balanceOfLp(ids[i][j]);\n            }\n        }\n    }\n\n    /// @inheritdoc IPosManager\n    function getCollAmt(uint _posId, address _pool) external view returns (uint amt) {\n        amt = __posCollInfos[_posId].collAmts[_pool];\n    }\n\n    /// @inheritdoc IPosManager\n    function getCollWLpAmt(uint _posId, address _wLp, uint _tokenId) external view returns (uint amt) {\n        if (__posCollInfos[_posId].ids[_wLp].contains(_tokenId)) {\n            amt = IBaseWrapLp(_wLp).balanceOfLp(_tokenId);\n        }\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosInfo(uint _posId) external view returns (address viewer, uint16 mode) {\n        PosInfo memory info = __posInfos[_posId];\n        viewer = info.viewer;\n        mode = info.mode;\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosMode(uint _posId) external view returns (uint16 mode) {\n        mode = __posInfos[_posId].mode;\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosDebtShares(uint _posId, address _pool) external view returns (uint debtShares) {\n        debtShares = __posBorrInfos[_posId].debtShares[_pool];\n    }\n\n    /// @inheritdoc IPosManager\n    function getViewerPosIdsAt(address _viewer, uint _index) external view returns (uint posId) {\n        posId = __viewerPosIds[_viewer].at(_index);\n    }\n\n    /// @inheritdoc IPosManager\n    function getViewerPosIdsLength(address _viewer) external view returns (uint length) {\n        length = __viewerPosIds[_viewer].length();\n    }\n\n    /// @inheritdoc IPosManager\n    function updatePosDebtShares(uint _posId, address _pool, int _deltaShares) external onlyCore {\n        uint currDebtShares = __posBorrInfos[_posId].debtShares[_pool];\n        uint debtAmtCurrent = ILendingPool(_pool).debtShareToAmtCurrent(currDebtShares);\n        PosBorrExtraInfo storage extraInfo = __posBorrInfos[_posId].borrExtraInfos[_pool];\n        // update interest accrued since last update\n        // NOTE: debtAmtCurrent is always >= lastDebtAmt\n        extraInfo.totalInterest += (debtAmtCurrent - extraInfo.lastDebtAmt).toUint128();\n        uint newDebtShares = (currDebtShares.toInt256() + _deltaShares).toUint256();\n        // handle first borrower\n        uint newDebtAmt = ILendingPool(_pool).totalDebtShares() > 0\n            ? ILendingPool(_pool).debtShareToAmtStored(newDebtShares)\n            : newDebtShares;\n        __posBorrInfos[_posId].debtShares[_pool] = newDebtShares;\n        // snapshot the current debt amount for next interest calculation\n        extraInfo.lastDebtAmt = newDebtAmt.toUint128();\n        if (newDebtShares > 0) __posBorrInfos[_posId].pools.add(_pool);\n        else __posBorrInfos[_posId].pools.remove(_pool);\n    }\n\n    /// @inheritdoc IPosManager\n    function updatePosMode(uint _posId, uint16 _mode) external onlyCore {\n        __posInfos[_posId].mode = _mode;\n    }\n\n    /// @inheritdoc IPosManager\n    function addCollateral(uint _posId, address _pool) external onlyCore returns (uint amtIn) {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        uint newBalance = IERC20(_pool).balanceOf(address(this));\n        amtIn = newBalance - __collBalances[_pool];\n        _require(amtIn != 0, Errors.ZERO_VALUE);\n        uint posBalance = posCollInfo.collAmts[_pool];\n        if (posBalance == 0) {\n            posCollInfo.collTokens.add(_pool);\n            uint8 collCount = posCollInfo.collCount + 1;\n            // NOTE: to avoid out of gas\n            _require(collCount <= maxCollCount, Errors.MAX_COLLATERAL_COUNT_REACHED);\n            posCollInfo.collCount = collCount;\n        }\n        posCollInfo.collAmts[_pool] = posBalance + amtIn;\n        __collBalances[_pool] = newBalance;\n    }\n\n    /// @inheritdoc IPosManager\n    function addCollateralWLp(uint _posId, address _wLp, uint _tokenId) external onlyCore returns (uint amtIn) {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        _require(IBaseWrapLp(_wLp).ownerOf(_tokenId) == address(this), Errors.NOT_OWNER);\n        _require(!isCollateralized[_wLp][_tokenId], Errors.ALREADY_COLLATERALIZED);\n        _require(IBaseWrapLp(_wLp).balanceOfLp(_tokenId) != 0, Errors.ZERO_VALUE);\n        posCollInfo.wLps.add(_wLp);\n        // NOTE: will return true if add new id\n        if (posCollInfo.ids[_wLp].add(_tokenId)) {\n            uint8 collCount = posCollInfo.collCount + 1;\n            _require(collCount <= maxCollCount, Errors.MAX_COLLATERAL_COUNT_REACHED);\n            posCollInfo.collCount = collCount;\n        }\n        isCollateralized[_wLp][_tokenId] = true;\n        amtIn = IBaseWrapLp(_wLp).balanceOfLp(_tokenId);\n    }\n\n    /// @inheritdoc IPosManager\n    function removeCollateralTo(uint _posId, address _pool, uint _shares, address _receiver)\n        external\n        onlyCore\n        returns (uint)\n    {\n        _require(_shares > 0, Errors.ZERO_VALUE);\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        uint newPosCollAmt = posCollInfo.collAmts[_pool] - _shares;\n        if (newPosCollAmt == 0) {\n            posCollInfo.collTokens.remove(_pool);\n            posCollInfo.collCount -= 1;\n        }\n        posCollInfo.collAmts[_pool] = newPosCollAmt;\n        IERC20(_pool).safeTransfer(_receiver, _shares);\n        __collBalances[_pool] = IERC20(_pool).balanceOf(address(this));\n        return _shares;\n    }\n\n    /// @inheritdoc IPosManager\n    function removeCollateralWLpTo(uint _posId, address _wLp, uint _tokenId, uint _amt, address _receiver)\n        external\n        onlyCore\n        returns (uint)\n    {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        // NOTE: balanceOfLp should be 1:1 with amt\n        uint newWLpAmt = IBaseWrapLp(_wLp).balanceOfLp(_tokenId) - _amt;\n        if (newWLpAmt == 0) {\n            _require(posCollInfo.ids[_wLp].remove(_tokenId), Errors.NOT_CONTAIN);\n            posCollInfo.collCount -= 1;\n            if (posCollInfo.ids[_wLp].length() == 0) {\n                posCollInfo.wLps.remove(_wLp);\n            }\n            isCollateralized[_wLp][_tokenId] = false;\n        }\n        _harvest(_posId, _wLp, _tokenId);\n        IBaseWrapLp(_wLp).unwrap(_tokenId, _amt, _receiver);\n        return _amt;\n    }\n\n    /// @inheritdoc IPosManager\n    function createPos(address _owner, uint16 _mode, address _viewer) external onlyCore returns (uint posId) {\n        uint nonce = nextNonces[_owner]++;\n        posId = uint(keccak256(abi.encodePacked(_owner, nonce)));\n        _updateViewerPosIds(posId, _viewer);\n        __posInfos[posId].viewer = _viewer;\n        __posInfos[posId].mode = _mode;\n        _safeMint(_owner, posId);\n    }\n\n    /// @inheritdoc IPosManager\n    function harvestTo(uint _posId, address _wlp, uint _tokenId, address _to)\n        public\n        onlyAuthorized(_posId)\n        returns (address[] memory tokens, uint[] memory amts)\n    {\n        // check that pos hold wlp\n        _require(__posCollInfos[_posId].ids[_wlp].contains(_tokenId), Errors.NOT_CONTAIN);\n        (tokens, amts) = IBaseWrapLp(_wlp).harvest(_tokenId, _to);\n    }\n\n    /// @inheritdoc IPosManager\n    function claimPendingRewards(uint _posId, address[] calldata _tokens, address _to)\n        external\n        onlyAuthorized(_posId)\n        returns (uint[] memory amts)\n    {\n        amts = new uint[](_tokens.length);\n        for (uint i; i < _tokens.length; i = i.uinc()) {\n            amts[i] = pendingRewards[_posId][_tokens[i]];\n            if (amts[i] != 0) {\n                pendingRewards[_posId][_tokens[i]] = 0;\n                IERC20(_tokens[i]).safeTransfer(_to, amts[i]);\n            }\n        }\n    }\n\n    /// @dev harvest reward tokens and update the pending rewards for the position\n    function _harvest(uint _posId, address _wlp, uint _tokenId) internal {\n        (address[] memory tokens, uint[] memory amts) = IBaseWrapLp(_wlp).harvest(_tokenId, address(this));\n        for (uint i; i < tokens.length; i = i.uinc()) {\n            pendingRewards[_posId][tokens[i]] += amts[i];\n        }\n    }\n\n    /// @inheritdoc IPosManager\n    function isAuthorized(address _account, uint _posId) external view returns (bool) {\n        return _isApprovedOrOwner(_account, _posId);\n    }\n\n    /// @inheritdoc IPosManager\n    function setMaxCollCount(uint8 _maxCollCount) external onlyGuardian {\n        maxCollCount = _maxCollCount;\n        emit SetMaxCollCount(_maxCollCount);\n    }\n\n    /// @inheritdoc IPosManager\n    function setPosViewer(uint _posId, address _viewer) external onlyAuthorized(_posId) {\n        _require(__posInfos[_posId].viewer != _viewer, Errors.ALREADY_SET);\n        _updateViewerPosIds(_posId, _viewer);\n        __posInfos[_posId].viewer = _viewer;\n    }\n\n    /// @dev update position viewer to ids mapping\n    function _updateViewerPosIds(uint _posId, address _viewer) internal {\n        address oldViewer = __posInfos[_posId].viewer;\n        // remove pos id from old viewer\n        if (oldViewer != address(0)) __viewerPosIds[oldViewer].remove(_posId);\n        // add pos id to new viewer\n        __viewerPosIds[_viewer].add(_posId);\n    }\n}"
    }
  ]
}