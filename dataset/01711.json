{
  "Title": "Missing Docstrings",
  "Content": "Throughout the [codebase](https://github.com/VenusProtocol/venus-protocol/tree/e5f112ac6f8cb9e5dcf760ad3626c9f3fc43609c/contracts/), there are several parts that do not have docstrings. For example:\n\n\n* [Line 18](https://github.com/VenusProtocol/venus-protocol/blob/e5f112ac6f8cb9e5dcf760ad3626c9f3fc43609c/contracts/Swap/IRouterHelper.sol#L17-L18) in [`IRouterHelper.sol`](https://github.com/VenusProtocol/venus-protocol/blob/e5f112ac6f8cb9e5dcf760ad3626c9f3fc43609c/contracts/Swap/IRouterHelper.sol)\n* [Line 20](https://github.com/VenusProtocol/venus-protocol/blob/e5f112ac6f8cb9e5dcf760ad3626c9f3fc43609c/contracts/Swap/IRouterHelper.sol#L19-L20) in [`IRouterHelper.sol`](https://github.com/VenusProtocol/venus-protocol/blob/e5f112ac6f8cb9e5dcf760ad3626c9f3fc43609c/contracts/Swap/IRouterHelper.sol)\n* [Line 14](https://github.com/VenusProtocol/venus-protocol/blob/e5f112ac6f8cb9e5dcf760ad3626c9f3fc43609c/contracts/Swap/RouterHelper.sol#L13-L14) in [`RouterHelper.sol`](https://github.com/VenusProtocol/venus-protocol/blob/e5f112ac6f8cb9e5dcf760ad3626c9f3fc43609c/contracts/Swap/RouterHelper.sol)\n* [Line 269](https://github.com/VenusProtocol/venus-protocol/blob/e5f112ac6f8cb9e5dcf760ad3626c9f3fc43609c/contracts/Swap/RouterHelper.sol#L269-L275) in [`RouterHelper.sol`](https://github.com/VenusProtocol/venus-protocol/blob/e5f112ac6f8cb9e5dcf760ad3626c9f3fc43609c/contracts/Swap/RouterHelper.sol)\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update:** Resolved in [pull request #281](https://github.com/VenusProtocol/venus-protocol/pull/281) at commits [394d1a7](https://github.com/VenusProtocol/venus-protocol/commit/394d1a7837fd0b6b3c950430d5fc89f3620336f3) and [9751c85](https://github.com/VenusProtocol/venus-protocol/commit/9751c85d7054485d5f082aa4ba48c7ce878d9a34). The functions were documented in their definitions in the contracts instead of their declarations in the interfaces.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Swap/IRouterHelper.sol",
      "content": "pragma solidity 0.8.13;\n\ninterface IRouterHelper {\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}"
    },
    {
      "filename": "contracts/Swap/IRouterHelper.sol",
      "content": "pragma solidity 0.8.13;\n\ninterface IRouterHelper {\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}"
    },
    {
      "filename": "contracts/Swap/RouterHelper.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./lib/PancakeLibrary.sol\";\nimport \"./interfaces/IWBNB.sol\";\nimport \"./lib/TransferHelper.sol\";\n\nimport \"./interfaces/CustomErrors.sol\";\nimport \"./IRouterHelper.sol\";\n\nabstract contract RouterHelper is IRouterHelper {\n    enum TypesOfTokens {\n        NON_SUPPORTING_FEE,\n        SUPPORTING_FEE\n    }\n\n    /// @notice Address of WBNB contract.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable WBNB;\n\n    /// @notice Address of pancake swap factory contract.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable factory;\n\n    // **************\n    // *** EVENTS ***\n    // **************\n    /// @notice This event is emitted whenever a successful swap (tokenA -> tokenB) occurs\n    event SwapTokensForTokens(address indexed swapper, address[] indexed path, uint256[] indexed amounts);\n\n    /// @notice This event is emitted whenever a successful swap (tokenA -> tokenB) occurs\n    event SwapTokensForTokensAtSupportingFee(address indexed swapper, address[] indexed path);\n\n    /// @notice This event is emitted whenever a successful swap (BNB -> token) occurs\n    event SwapBnbForTokens(address indexed swapper, address[] indexed path, uint256[] indexed amounts);\n\n    /// @notice This event is emitted whenever a successful swap (BNB -> token) occurs\n    event SwapBnbForTokensAtSupportingFee(address indexed swapper, address[] indexed path);\n\n    /// @notice This event is emitted whenever a successful swap (token -> BNB) occurs\n    event SwapTokensForBnb(address indexed swapper, address[] indexed path, uint256[] indexed amounts);\n\n    /// @notice This event is emitted whenever a successful swap (token -> BNB) occurs\n    event SwapTokensForBnbAtSupportingFee(address indexed swapper, address[] indexed path);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address WBNB_, address factory_) {\n        if (WBNB_ == address(0) || factory_ == address(0)) {\n            revert ZeroAddress();\n        }\n        WBNB = WBNB_;\n        factory = factory_;\n    }\n\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint256[] memory amounts, address[] memory path, address _to) internal virtual {\n        for (uint256 i; i < path.length - 1; ) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0, ) = PancakeLibrary.sortTokens(input, output);\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOut)\n                : (amountOut, uint256(0));\n            address to = i < path.length - 2 ? PancakeLibrary.pairFor(factory, output, path[i + 2]) : _to;\n            IPancakePair(PancakeLibrary.pairFor(factory, input, output)).swap(amount0Out, amount1Out, to, new bytes(0));\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\n        for (uint256 i; i < path.length - 1; ) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0, ) = PancakeLibrary.sortTokens(input, output);\n            IPancakePair pair = IPancakePair(PancakeLibrary.pairFor(factory, input, output));\n            uint256 amountInput;\n            uint256 amountOutput;\n            {\n                // scope to avoid stack too deep errors\n                (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n                (uint256 reserveInput, uint256 reserveOutput) = input == token0\n                    ? (reserve0, reserve1)\n                    : (reserve1, reserve0);\n\n                uint256 balance = IERC20(input).balanceOf(address(pair));\n                amountInput = balance - reserveInput;\n                amountOutput = PancakeLibrary.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOutput)\n                : (amountOutput, uint256(0));\n            address to = i < path.length - 2 ? PancakeLibrary.pairFor(factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    function _swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        TypesOfTokens swapFor\n    ) internal returns (uint256[] memory amounts) {\n        address pairAddress = PancakeLibrary.pairFor(factory, path[0], path[1]);\n        if (swapFor == TypesOfTokens.NON_SUPPORTING_FEE) {\n            amounts = PancakeLibrary.getAmountsOut(factory, amountIn, path);\n            if (amounts[amounts.length - 1] < amountOutMin) {\n                revert OutputAmountBelowMinimum(amounts[amounts.length - 1], amountOutMin);\n            }\n            TransferHelper.safeTransferFrom(path[0], msg.sender, pairAddress, amounts[0]);\n            _swap(amounts, path, to);\n            emit SwapTokensForTokens(msg.sender, path, amounts);\n        } else {\n            TransferHelper.safeTransferFrom(path[0], msg.sender, pairAddress, amountIn);\n            _swapSupportingFeeOnTransferTokens(path, to);\n            emit SwapTokensForTokensAtSupportingFee(msg.sender, path);\n        }\n    }\n\n    function _swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        TypesOfTokens swapFor\n    ) internal returns (uint256[] memory amounts) {\n        address wBNBAddress = WBNB;\n        if (path[0] != wBNBAddress) {\n            revert WrongAddress(wBNBAddress, path[0]);\n        }\n        IWBNB(wBNBAddress).deposit{ value: msg.value }();\n        TransferHelper.safeTransfer(wBNBAddress, PancakeLibrary.pairFor(factory, path[0], path[1]), msg.value);\n        if (swapFor == TypesOfTokens.NON_SUPPORTING_FEE) {\n            amounts = PancakeLibrary.getAmountsOut(factory, msg.value, path);\n            if (amounts[amounts.length - 1] < amountOutMin) {\n                revert OutputAmountBelowMinimum(amounts[amounts.length - 1], amountOutMin);\n            }\n            _swap(amounts, path, to);\n            emit SwapBnbForTokens(msg.sender, path, amounts);\n        } else {\n            _swapSupportingFeeOnTransferTokens(path, to);\n            emit SwapBnbForTokensAtSupportingFee(msg.sender, path);\n        }\n    }\n\n    function _swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        TypesOfTokens swapFor\n    ) internal returns (uint256[] memory amounts) {\n        if (path[path.length - 1] != WBNB) {\n            revert WrongAddress(WBNB, path[path.length - 1]);\n        }\n        uint256 WBNBAmount;\n        if (swapFor == TypesOfTokens.NON_SUPPORTING_FEE) {\n            amounts = PancakeLibrary.getAmountsOut(factory, amountIn, path);\n            if (amounts[amounts.length - 1] < amountOutMin) {\n                revert OutputAmountBelowMinimum(amounts[amounts.length - 1], amountOutMin);\n            }\n            TransferHelper.safeTransferFrom(\n                path[0],\n                msg.sender,\n                PancakeLibrary.pairFor(factory, path[0], path[1]),\n                amounts[0]\n            );\n            _swap(amounts, path, address(this));\n            WBNBAmount = amounts[amounts.length - 1];\n        } else {\n            uint256 balanceBefore = IWBNB(WBNB).balanceOf(address(this));\n            TransferHelper.safeTransferFrom(\n                path[0],\n                msg.sender,\n                PancakeLibrary.pairFor(factory, path[0], path[1]),\n                amountIn\n            );\n            _swapSupportingFeeOnTransferTokens(path, address(this));\n            uint256 balanceAfter = IWBNB(WBNB).balanceOf(address(this));\n            WBNBAmount = balanceAfter - balanceBefore;\n        }\n        IWBNB(WBNB).withdraw(WBNBAmount);\n        if (to != address(this)) {\n            TransferHelper.safeTransferETH(to, WBNBAmount);\n        }\n        if (swapFor == TypesOfTokens.NON_SUPPORTING_FEE) {\n            emit SwapTokensForBnb(msg.sender, path, amounts);\n        } else {\n            emit SwapTokensForBnbAtSupportingFee(msg.sender, path);\n        }\n    }\n\n    function _swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to\n    ) internal returns (uint256[] memory amounts) {\n        amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n        if (amounts[0] > amountInMax) {\n            revert InputAmountAboveMaximum(amounts[0], amountInMax);\n        }\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            PancakeLibrary.pairFor(factory, path[0], path[1]),\n            amounts[0]\n        );\n        _swap(amounts, path, to);\n        emit SwapTokensForTokens(msg.sender, path, amounts);\n    }\n\n    function _swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to\n    ) internal returns (uint256[] memory amounts) {\n        if (path[0] != WBNB) {\n            revert WrongAddress(WBNB, path[0]);\n        }\n        amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n        if (amounts[0] > msg.value) {\n            revert ExcessiveInputAmount(amounts[0], msg.value);\n        }\n        IWBNB(WBNB).deposit{ value: amounts[0] }();\n        TransferHelper.safeTransfer(WBNB, PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]);\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n        emit SwapBnbForTokens(msg.sender, path, amounts);\n    }\n\n    function _swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to\n    ) internal returns (uint256[] memory amounts) {\n        if (path[path.length - 1] != WBNB) {\n            revert WrongAddress(WBNB, path[path.length - 1]);\n        }\n        amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n        if (amounts[0] > amountInMax) {\n            revert InputAmountAboveMaximum(amounts[amounts.length - 1], amountInMax);\n        }\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            PancakeLibrary.pairFor(factory, path[0], path[1]),\n            amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWBNB(WBNB).withdraw(amounts[amounts.length - 1]);\n        if (to != address(this)) {\n            TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n        }\n        emit SwapTokensForBnb(msg.sender, path, amounts);\n    }\n\n    // **** LIBRARY FUNCTIONS ****\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) public pure virtual override returns (uint256 amountB) {\n        return PancakeLibrary.quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public pure virtual override returns (uint256 amountOut) {\n        return PancakeLibrary.getAmountOut(amountIn, reserveIn, reserveOut);\n    }\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public pure virtual override returns (uint256 amountIn) {\n        return PancakeLibrary.getAmountIn(amountOut, reserveIn, reserveOut);\n    }\n\n    function getAmountsOut(\n        uint256 amountIn,\n        address[] memory path\n    ) public view virtual override returns (uint256[] memory amounts) {\n        return PancakeLibrary.getAmountsOut(factory, amountIn, path);\n    }\n\n    function getAmountsIn(\n        uint256 amountOut,\n        address[] memory path\n    ) public view virtual override returns (uint256[] memory amounts) {\n        return PancakeLibrary.getAmountsIn(factory, amountOut, path);\n    }\n}"
    },
    {
      "filename": "contracts/Swap/RouterHelper.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./lib/PancakeLibrary.sol\";\nimport \"./interfaces/IWBNB.sol\";\nimport \"./lib/TransferHelper.sol\";\n\nimport \"./interfaces/CustomErrors.sol\";\nimport \"./IRouterHelper.sol\";\n\nabstract contract RouterHelper is IRouterHelper {\n    enum TypesOfTokens {\n        NON_SUPPORTING_FEE,\n        SUPPORTING_FEE\n    }\n\n    /// @notice Address of WBNB contract.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable WBNB;\n\n    /// @notice Address of pancake swap factory contract.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable factory;\n\n    // **************\n    // *** EVENTS ***\n    // **************\n    /// @notice This event is emitted whenever a successful swap (tokenA -> tokenB) occurs\n    event SwapTokensForTokens(address indexed swapper, address[] indexed path, uint256[] indexed amounts);\n\n    /// @notice This event is emitted whenever a successful swap (tokenA -> tokenB) occurs\n    event SwapTokensForTokensAtSupportingFee(address indexed swapper, address[] indexed path);\n\n    /// @notice This event is emitted whenever a successful swap (BNB -> token) occurs\n    event SwapBnbForTokens(address indexed swapper, address[] indexed path, uint256[] indexed amounts);\n\n    /// @notice This event is emitted whenever a successful swap (BNB -> token) occurs\n    event SwapBnbForTokensAtSupportingFee(address indexed swapper, address[] indexed path);\n\n    /// @notice This event is emitted whenever a successful swap (token -> BNB) occurs\n    event SwapTokensForBnb(address indexed swapper, address[] indexed path, uint256[] indexed amounts);\n\n    /// @notice This event is emitted whenever a successful swap (token -> BNB) occurs\n    event SwapTokensForBnbAtSupportingFee(address indexed swapper, address[] indexed path);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address WBNB_, address factory_) {\n        if (WBNB_ == address(0) || factory_ == address(0)) {\n            revert ZeroAddress();\n        }\n        WBNB = WBNB_;\n        factory = factory_;\n    }\n\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint256[] memory amounts, address[] memory path, address _to) internal virtual {\n        for (uint256 i; i < path.length - 1; ) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0, ) = PancakeLibrary.sortTokens(input, output);\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOut)\n                : (amountOut, uint256(0));\n            address to = i < path.length - 2 ? PancakeLibrary.pairFor(factory, output, path[i + 2]) : _to;\n            IPancakePair(PancakeLibrary.pairFor(factory, input, output)).swap(amount0Out, amount1Out, to, new bytes(0));\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\n        for (uint256 i; i < path.length - 1; ) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0, ) = PancakeLibrary.sortTokens(input, output);\n            IPancakePair pair = IPancakePair(PancakeLibrary.pairFor(factory, input, output));\n            uint256 amountInput;\n            uint256 amountOutput;\n            {\n                // scope to avoid stack too deep errors\n                (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n                (uint256 reserveInput, uint256 reserveOutput) = input == token0\n                    ? (reserve0, reserve1)\n                    : (reserve1, reserve0);\n\n                uint256 balance = IERC20(input).balanceOf(address(pair));\n                amountInput = balance - reserveInput;\n                amountOutput = PancakeLibrary.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOutput)\n                : (amountOutput, uint256(0));\n            address to = i < path.length - 2 ? PancakeLibrary.pairFor(factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    function _swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        TypesOfTokens swapFor\n    ) internal returns (uint256[] memory amounts) {\n        address pairAddress = PancakeLibrary.pairFor(factory, path[0], path[1]);\n        if (swapFor == TypesOfTokens.NON_SUPPORTING_FEE) {\n            amounts = PancakeLibrary.getAmountsOut(factory, amountIn, path);\n            if (amounts[amounts.length - 1] < amountOutMin) {\n                revert OutputAmountBelowMinimum(amounts[amounts.length - 1], amountOutMin);\n            }\n            TransferHelper.safeTransferFrom(path[0], msg.sender, pairAddress, amounts[0]);\n            _swap(amounts, path, to);\n            emit SwapTokensForTokens(msg.sender, path, amounts);\n        } else {\n            TransferHelper.safeTransferFrom(path[0], msg.sender, pairAddress, amountIn);\n            _swapSupportingFeeOnTransferTokens(path, to);\n            emit SwapTokensForTokensAtSupportingFee(msg.sender, path);\n        }\n    }\n\n    function _swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        TypesOfTokens swapFor\n    ) internal returns (uint256[] memory amounts) {\n        address wBNBAddress = WBNB;\n        if (path[0] != wBNBAddress) {\n            revert WrongAddress(wBNBAddress, path[0]);\n        }\n        IWBNB(wBNBAddress).deposit{ value: msg.value }();\n        TransferHelper.safeTransfer(wBNBAddress, PancakeLibrary.pairFor(factory, path[0], path[1]), msg.value);\n        if (swapFor == TypesOfTokens.NON_SUPPORTING_FEE) {\n            amounts = PancakeLibrary.getAmountsOut(factory, msg.value, path);\n            if (amounts[amounts.length - 1] < amountOutMin) {\n                revert OutputAmountBelowMinimum(amounts[amounts.length - 1], amountOutMin);\n            }\n            _swap(amounts, path, to);\n            emit SwapBnbForTokens(msg.sender, path, amounts);\n        } else {\n            _swapSupportingFeeOnTransferTokens(path, to);\n            emit SwapBnbForTokensAtSupportingFee(msg.sender, path);\n        }\n    }\n\n    function _swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        TypesOfTokens swapFor\n    ) internal returns (uint256[] memory amounts) {\n        if (path[path.length - 1] != WBNB) {\n            revert WrongAddress(WBNB, path[path.length - 1]);\n        }\n        uint256 WBNBAmount;\n        if (swapFor == TypesOfTokens.NON_SUPPORTING_FEE) {\n            amounts = PancakeLibrary.getAmountsOut(factory, amountIn, path);\n            if (amounts[amounts.length - 1] < amountOutMin) {\n                revert OutputAmountBelowMinimum(amounts[amounts.length - 1], amountOutMin);\n            }\n            TransferHelper.safeTransferFrom(\n                path[0],\n                msg.sender,\n                PancakeLibrary.pairFor(factory, path[0], path[1]),\n                amounts[0]\n            );\n            _swap(amounts, path, address(this));\n            WBNBAmount = amounts[amounts.length - 1];\n        } else {\n            uint256 balanceBefore = IWBNB(WBNB).balanceOf(address(this));\n            TransferHelper.safeTransferFrom(\n                path[0],\n                msg.sender,\n                PancakeLibrary.pairFor(factory, path[0], path[1]),\n                amountIn\n            );\n            _swapSupportingFeeOnTransferTokens(path, address(this));\n            uint256 balanceAfter = IWBNB(WBNB).balanceOf(address(this));\n            WBNBAmount = balanceAfter - balanceBefore;\n        }\n        IWBNB(WBNB).withdraw(WBNBAmount);\n        if (to != address(this)) {\n            TransferHelper.safeTransferETH(to, WBNBAmount);\n        }\n        if (swapFor == TypesOfTokens.NON_SUPPORTING_FEE) {\n            emit SwapTokensForBnb(msg.sender, path, amounts);\n        } else {\n            emit SwapTokensForBnbAtSupportingFee(msg.sender, path);\n        }\n    }\n\n    function _swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to\n    ) internal returns (uint256[] memory amounts) {\n        amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n        if (amounts[0] > amountInMax) {\n            revert InputAmountAboveMaximum(amounts[0], amountInMax);\n        }\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            PancakeLibrary.pairFor(factory, path[0], path[1]),\n            amounts[0]\n        );\n        _swap(amounts, path, to);\n        emit SwapTokensForTokens(msg.sender, path, amounts);\n    }\n\n    function _swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to\n    ) internal returns (uint256[] memory amounts) {\n        if (path[0] != WBNB) {\n            revert WrongAddress(WBNB, path[0]);\n        }\n        amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n        if (amounts[0] > msg.value) {\n            revert ExcessiveInputAmount(amounts[0], msg.value);\n        }\n        IWBNB(WBNB).deposit{ value: amounts[0] }();\n        TransferHelper.safeTransfer(WBNB, PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]);\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n        emit SwapBnbForTokens(msg.sender, path, amounts);\n    }\n\n    function _swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to\n    ) internal returns (uint256[] memory amounts) {\n        if (path[path.length - 1] != WBNB) {\n            revert WrongAddress(WBNB, path[path.length - 1]);\n        }\n        amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n        if (amounts[0] > amountInMax) {\n            revert InputAmountAboveMaximum(amounts[amounts.length - 1], amountInMax);\n        }\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            PancakeLibrary.pairFor(factory, path[0], path[1]),\n            amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWBNB(WBNB).withdraw(amounts[amounts.length - 1]);\n        if (to != address(this)) {\n            TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n        }\n        emit SwapTokensForBnb(msg.sender, path, amounts);\n    }\n\n    // **** LIBRARY FUNCTIONS ****\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) public pure virtual override returns (uint256 amountB) {\n        return PancakeLibrary.quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public pure virtual override returns (uint256 amountOut) {\n        return PancakeLibrary.getAmountOut(amountIn, reserveIn, reserveOut);\n    }\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public pure virtual override returns (uint256 amountIn) {\n        return PancakeLibrary.getAmountIn(amountOut, reserveIn, reserveOut);\n    }\n\n    function getAmountsOut(\n        uint256 amountIn,\n        address[] memory path\n    ) public view virtual override returns (uint256[] memory amounts) {\n        return PancakeLibrary.getAmountsOut(factory, amountIn, path);\n    }\n\n    function getAmountsIn(\n        uint256 amountOut,\n        address[] memory path\n    ) public view virtual override returns (uint256[] memory amounts) {\n        return PancakeLibrary.getAmountsIn(factory, amountOut, path);\n    }\n}"
    }
  ]
}