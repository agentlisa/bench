{
  "Title": "[M-06] DoS by gas limit",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L220\nhttps://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L233\n\n\n# Vulnerability details\n\nIn `deposit` function it is possible to push to `nftIdsStaked` of anyone, an attacker can deposit too many nfts to another user, and when the user will try to withdraw an nft at the end of the list, they will iterate on the list and revert because of gas limit.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-biconomy-hyphen-20-contest",
  "Code": [
    {
      "filename": "contracts/hyphen/LiquidityFarming.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\n\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/ILPToken.sol\";\nimport \"./interfaces/ILiquidityProviders.sol\";\n\ncontract HyphenLiquidityFarming is\n    Initializable,\n    ERC2771ContextUpgradeable,\n    OwnableUpgradeable,\n    Pausable,\n    ReentrancyGuardUpgradeable,\n    IERC721ReceiverUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    ILPToken public lpToken;\n    ILiquidityProviders public liquidityProviders;\n\n    struct NFTInfo {\n        address payable staker;\n        uint256 rewardDebt;\n        uint256 unpaidRewards;\n        bool isStaked;\n    }\n\n    struct PoolInfo {\n        uint256 accTokenPerShare;\n        uint256 lastRewardTime;\n    }\n\n    struct RewardsPerSecondEntry {\n        uint256 rewardsPerSecond;\n        uint256 timestamp;\n    }\n\n    /// @notice Mapping to track the rewarder pool.\n    mapping(address => PoolInfo) public poolInfo;\n\n    /// @notice Info of each NFT that is staked.\n    mapping(uint256 => NFTInfo) public nftInfo;\n\n    /// @notice Reward rate per base token\n    //mapping(address => uint256) public rewardPerSecond;\n\n    /// @notice Reward Token\n    mapping(address => address) public rewardTokens;\n\n    /// @notice Staker => NFTs staked\n    mapping(address => uint256[]) public nftIdsStaked;\n\n    /// @notice Token => Total Shares Staked\n    mapping(address => uint256) public totalSharesStaked;\n\n    /// @notice Token => Reward Rate Updation history\n    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;\n\n    uint256 private constant ACC_TOKEN_PRECISION = 1e12;\n    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);\n    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);\n    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);\n    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);\n    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);\n    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);\n    event LogNativeReceived(address indexed sender, uint256 value);\n\n    function initialize(\n        address _trustedForwarder,\n        address _pauser,\n        ILiquidityProviders _liquidityProviders,\n        ILPToken _lpToken\n    ) public initializer {\n        __ERC2771Context_init(_trustedForwarder);\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        __ReentrancyGuard_init();\n        liquidityProviders = _liquidityProviders;\n        lpToken = _lpToken;\n    }\n\n    /// @notice Initialize the rewarder pool.\n    /// @param _baseToken Base token to be used for the rewarder pool.\n    /// @param _rewardToken Reward token to be used for the rewarder pool.\n    /// @param _rewardPerSecond Reward rate per base token.\n    function initalizeRewardPool(\n        address _baseToken,\n        address _rewardToken,\n        uint256 _rewardPerSecond\n    ) external onlyOwner {\n        require(rewardTokens[_baseToken] == address(0), \"ERR__POOL_ALREADY_INITIALIZED\");\n        require(_baseToken != address(0), \"ERR__BASE_TOKEN_IS_ZERO\");\n        require(_rewardToken != address(0), \"ERR_REWARD_TOKEN_IS_ZERO\");\n        rewardTokens[_baseToken] = _rewardToken;\n        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));\n        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);\n    }\n\n    function _sendErc20AndGetSentAmount(\n        IERC20Upgradeable _token,\n        uint256 _amount,\n        address _to\n    ) private returns (uint256) {\n        uint256 recepientBalance = _token.balanceOf(_to);\n        _token.safeTransfer(_to, _amount);\n        return _token.balanceOf(_to) - recepientBalance;\n    }\n\n    /// @notice Update the reward state of a nft, and if possible send reward funds to _to.\n    /// @param _nftId NFT ID that is being locked\n    /// @param _to Address to which rewards will be credited.\n    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {\n        NFTInfo storage nft = nftInfo[_nftId];\n        require(nft.isStaked, \"ERR__NFT_NOT_STAKED\");\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        PoolInfo memory pool = updatePool(baseToken);\n        uint256 pending;\n        uint256 amountSent;\n        if (amount > 0) {\n            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;\n            if (rewardTokens[baseToken] == NATIVE) {\n                uint256 balance = address(this).balance;\n                if (pending > balance) {\n                    unchecked {\n                        nft.unpaidRewards = pending - balance;\n                    }\n                    (bool success, ) = _to.call{value: balance}(\"\");\n                    require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n                    amountSent = balance;\n                } else {\n                    nft.unpaidRewards = 0;\n                    (bool success, ) = _to.call{value: pending}(\"\");\n                    require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n                    amountSent = pending;\n                }\n            } else {\n                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);\n                uint256 balance = rewardToken.balanceOf(address(this));\n                if (pending > balance) {\n                    unchecked {\n                        nft.unpaidRewards = pending - balance;\n                    }\n                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);\n                } else {\n                    nft.unpaidRewards = 0;\n                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);\n                }\n            }\n        }\n        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;\n        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);\n    }\n\n    /// @notice Sets the sushi per second to be distributed. Can only be called by the owner.\n    /// @param _rewardPerSecond The amount of Sushi to be distributed per second.\n    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {\n        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));\n        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);\n    }\n\n    /// @notice Allows owner to reclaim/withdraw any tokens (including reward tokens) held by this contract\n    /// @param _token Token to reclaim, use 0x00 for Ethereum\n    /// @param _amount Amount of tokens to reclaim\n    /// @param _to Receiver of the tokens, first of his name, rightful heir to the lost tokens,\n    /// reightful owner of the extra tokens, and ether, protector of mistaken transfers, mother of token reclaimers,\n    /// the Khaleesi of the Great Token Sea, the Unburnt, the Breaker of blockchains.\n    function reclaimTokens(\n        address _token,\n        uint256 _amount,\n        address payable _to\n    ) external nonReentrant onlyOwner {\n        require(_to != address(0), \"ERR__TO_IS_ZERO\");\n        if (_token == NATIVE) {\n            (bool success, ) = payable(_to).call{value: _amount}(\"\");\n            require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        } else {\n            IERC20Upgradeable(_token).safeTransfer(_to, _amount);\n        }\n    }\n\n    /// @notice Deposit LP tokens\n    /// @param _nftId LP token nftId to deposit.\n    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        address msgSender = _msgSender();\n\n        require(\n            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),\n            \"ERR__NOT_APPROVED\"\n        );\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        require(rewardTokens[baseToken] != address(0), \"ERR__POOL_NOT_INITIALIZED\");\n        require(rewardRateLog[baseToken].length != 0, \"ERR__POOL_NOT_INITIALIZED\");\n\n        NFTInfo storage nft = nftInfo[_nftId];\n        require(!nft.isStaked, \"ERR__NFT_ALREADY_STAKED\");\n\n        lpToken.safeTransferFrom(msgSender, address(this), _nftId);\n\n        PoolInfo memory pool = updatePool(baseToken);\n        nft.isStaked = true;\n        nft.staker = _to;\n        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;\n\n        nftIdsStaked[_to].push(_nftId);\n        totalSharesStaked[baseToken] += amount;\n\n        emit LogDeposit(msgSender, baseToken, _nftId);\n    }\n\n    /// @notice Withdraw LP tokens\n    /// @param _nftId LP token nftId to withdraw.\n    /// @param _to The receiver of `amount` withdraw benefit.\n    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        address msgSender = _msgSender();\n        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;\n        uint256 index;\n        for (index = 0; index < nftsStakedLength; ++index) {\n            if (nftIdsStaked[msgSender][index] == _nftId) {\n                break;\n            }\n        }\n\n        require(index != nftsStakedLength, \"ERR__NFT_NOT_STAKED\");\n        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];\n        nftIdsStaked[msgSender].pop();\n\n        _sendRewardsForNft(_nftId, _to);\n        delete nftInfo[_nftId];\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n        totalSharesStaked[baseToken] -= amount;\n\n        lpToken.safeTransferFrom(address(this), msgSender, _nftId);\n\n        emit LogWithdraw(msgSender, baseToken, _nftId, _to);\n    }\n\n    /// @notice Extract all rewards without withdrawing LP tokens\n    /// @param _nftId LP token nftId for which rewards are to be withdrawn\n    /// @param _to The receiver of withdraw benefit.\n    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        require(nftInfo[_nftId].staker == _msgSender(), \"ERR__NOT_OWNER\");\n        _sendRewardsForNft(_nftId, _to);\n    }\n\n    /// @notice Calculates an up to date value of accTokenPerShare\n    /// @notice An updated value of accTokenPerShare is comitted to storage every time a new NFT is deposited, withdrawn or rewards are extracted\n    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {\n        uint256 accumulator = 0;\n        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;\n        uint256 counter = block.timestamp;\n        uint256 i = rewardRateLog[_baseToken].length - 1;\n        while (true) {\n            if (lastUpdatedTime >= counter) {\n                break;\n            }\n            unchecked {\n                accumulator +=\n                    rewardRateLog[_baseToken][i].rewardsPerSecond *\n                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));\n            }\n            counter = rewardRateLog[_baseToken][i].timestamp;\n            if (i == 0) {\n                break;\n            }\n            --i;\n        }\n\n        // We know that during all the periods that were included in the current iterations,\n        // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the\n        // updates to the pool that happened after the lastUpdatedTime.\n        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];\n        return accumulator + poolInfo[_baseToken].accTokenPerShare;\n    }\n\n    /// @notice View function to see pending Token\n    /// @param _nftId NFT for which pending tokens are to be viewed\n    /// @return pending reward for a given user.\n    function pendingToken(uint256 _nftId) external view returns (uint256) {\n        NFTInfo storage nft = nftInfo[_nftId];\n        if (!nft.isStaked) {\n            return 0;\n        }\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        PoolInfo memory pool = poolInfo[baseToken];\n        uint256 accToken1PerShare = pool.accTokenPerShare;\n        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {\n            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);\n        }\n        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @return pool Returns the pool that was updated.\n    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {\n        pool = poolInfo[_baseToken];\n        if (block.timestamp > pool.lastRewardTime) {\n            if (totalSharesStaked[_baseToken] > 0) {\n                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);\n            }\n            pool.lastRewardTime = block.timestamp;\n            poolInfo[_baseToken] = pool;\n            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);\n        }\n    }\n\n    /// @notice View function to see the tokens staked by a given user.\n    /// @param _user Address of user.\n    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {\n        nftIds = nftIdsStaked[_user];\n    }\n\n    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {\n        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n\n    receive() external payable {\n        emit LogNativeReceived(_msgSender(), msg.value);\n    }\n\n    function max(uint256 _a, uint256 _b) private pure returns (uint256) {\n        return _a >= _b ? _a : _b;\n    }\n}"
    },
    {
      "filename": "contracts/hyphen/LiquidityFarming.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\n\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/ILPToken.sol\";\nimport \"./interfaces/ILiquidityProviders.sol\";\n\ncontract HyphenLiquidityFarming is\n    Initializable,\n    ERC2771ContextUpgradeable,\n    OwnableUpgradeable,\n    Pausable,\n    ReentrancyGuardUpgradeable,\n    IERC721ReceiverUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    ILPToken public lpToken;\n    ILiquidityProviders public liquidityProviders;\n\n    struct NFTInfo {\n        address payable staker;\n        uint256 rewardDebt;\n        uint256 unpaidRewards;\n        bool isStaked;\n    }\n\n    struct PoolInfo {\n        uint256 accTokenPerShare;\n        uint256 lastRewardTime;\n    }\n\n    struct RewardsPerSecondEntry {\n        uint256 rewardsPerSecond;\n        uint256 timestamp;\n    }\n\n    /// @notice Mapping to track the rewarder pool.\n    mapping(address => PoolInfo) public poolInfo;\n\n    /// @notice Info of each NFT that is staked.\n    mapping(uint256 => NFTInfo) public nftInfo;\n\n    /// @notice Reward rate per base token\n    //mapping(address => uint256) public rewardPerSecond;\n\n    /// @notice Reward Token\n    mapping(address => address) public rewardTokens;\n\n    /// @notice Staker => NFTs staked\n    mapping(address => uint256[]) public nftIdsStaked;\n\n    /// @notice Token => Total Shares Staked\n    mapping(address => uint256) public totalSharesStaked;\n\n    /// @notice Token => Reward Rate Updation history\n    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;\n\n    uint256 private constant ACC_TOKEN_PRECISION = 1e12;\n    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);\n    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);\n    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);\n    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);\n    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);\n    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);\n    event LogNativeReceived(address indexed sender, uint256 value);\n\n    function initialize(\n        address _trustedForwarder,\n        address _pauser,\n        ILiquidityProviders _liquidityProviders,\n        ILPToken _lpToken\n    ) public initializer {\n        __ERC2771Context_init(_trustedForwarder);\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        __ReentrancyGuard_init();\n        liquidityProviders = _liquidityProviders;\n        lpToken = _lpToken;\n    }\n\n    /// @notice Initialize the rewarder pool.\n    /// @param _baseToken Base token to be used for the rewarder pool.\n    /// @param _rewardToken Reward token to be used for the rewarder pool.\n    /// @param _rewardPerSecond Reward rate per base token.\n    function initalizeRewardPool(\n        address _baseToken,\n        address _rewardToken,\n        uint256 _rewardPerSecond\n    ) external onlyOwner {\n        require(rewardTokens[_baseToken] == address(0), \"ERR__POOL_ALREADY_INITIALIZED\");\n        require(_baseToken != address(0), \"ERR__BASE_TOKEN_IS_ZERO\");\n        require(_rewardToken != address(0), \"ERR_REWARD_TOKEN_IS_ZERO\");\n        rewardTokens[_baseToken] = _rewardToken;\n        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));\n        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);\n    }\n\n    function _sendErc20AndGetSentAmount(\n        IERC20Upgradeable _token,\n        uint256 _amount,\n        address _to\n    ) private returns (uint256) {\n        uint256 recepientBalance = _token.balanceOf(_to);\n        _token.safeTransfer(_to, _amount);\n        return _token.balanceOf(_to) - recepientBalance;\n    }\n\n    /// @notice Update the reward state of a nft, and if possible send reward funds to _to.\n    /// @param _nftId NFT ID that is being locked\n    /// @param _to Address to which rewards will be credited.\n    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {\n        NFTInfo storage nft = nftInfo[_nftId];\n        require(nft.isStaked, \"ERR__NFT_NOT_STAKED\");\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        PoolInfo memory pool = updatePool(baseToken);\n        uint256 pending;\n        uint256 amountSent;\n        if (amount > 0) {\n            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;\n            if (rewardTokens[baseToken] == NATIVE) {\n                uint256 balance = address(this).balance;\n                if (pending > balance) {\n                    unchecked {\n                        nft.unpaidRewards = pending - balance;\n                    }\n                    (bool success, ) = _to.call{value: balance}(\"\");\n                    require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n                    amountSent = balance;\n                } else {\n                    nft.unpaidRewards = 0;\n                    (bool success, ) = _to.call{value: pending}(\"\");\n                    require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n                    amountSent = pending;\n                }\n            } else {\n                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);\n                uint256 balance = rewardToken.balanceOf(address(this));\n                if (pending > balance) {\n                    unchecked {\n                        nft.unpaidRewards = pending - balance;\n                    }\n                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);\n                } else {\n                    nft.unpaidRewards = 0;\n                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);\n                }\n            }\n        }\n        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;\n        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);\n    }\n\n    /// @notice Sets the sushi per second to be distributed. Can only be called by the owner.\n    /// @param _rewardPerSecond The amount of Sushi to be distributed per second.\n    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {\n        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));\n        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);\n    }\n\n    /// @notice Allows owner to reclaim/withdraw any tokens (including reward tokens) held by this contract\n    /// @param _token Token to reclaim, use 0x00 for Ethereum\n    /// @param _amount Amount of tokens to reclaim\n    /// @param _to Receiver of the tokens, first of his name, rightful heir to the lost tokens,\n    /// reightful owner of the extra tokens, and ether, protector of mistaken transfers, mother of token reclaimers,\n    /// the Khaleesi of the Great Token Sea, the Unburnt, the Breaker of blockchains.\n    function reclaimTokens(\n        address _token,\n        uint256 _amount,\n        address payable _to\n    ) external nonReentrant onlyOwner {\n        require(_to != address(0), \"ERR__TO_IS_ZERO\");\n        if (_token == NATIVE) {\n            (bool success, ) = payable(_to).call{value: _amount}(\"\");\n            require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        } else {\n            IERC20Upgradeable(_token).safeTransfer(_to, _amount);\n        }\n    }\n\n    /// @notice Deposit LP tokens\n    /// @param _nftId LP token nftId to deposit.\n    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        address msgSender = _msgSender();\n\n        require(\n            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),\n            \"ERR__NOT_APPROVED\"\n        );\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        require(rewardTokens[baseToken] != address(0), \"ERR__POOL_NOT_INITIALIZED\");\n        require(rewardRateLog[baseToken].length != 0, \"ERR__POOL_NOT_INITIALIZED\");\n\n        NFTInfo storage nft = nftInfo[_nftId];\n        require(!nft.isStaked, \"ERR__NFT_ALREADY_STAKED\");\n\n        lpToken.safeTransferFrom(msgSender, address(this), _nftId);\n\n        PoolInfo memory pool = updatePool(baseToken);\n        nft.isStaked = true;\n        nft.staker = _to;\n        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;\n\n        nftIdsStaked[_to].push(_nftId);\n        totalSharesStaked[baseToken] += amount;\n\n        emit LogDeposit(msgSender, baseToken, _nftId);\n    }\n\n    /// @notice Withdraw LP tokens\n    /// @param _nftId LP token nftId to withdraw.\n    /// @param _to The receiver of `amount` withdraw benefit.\n    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        address msgSender = _msgSender();\n        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;\n        uint256 index;\n        for (index = 0; index < nftsStakedLength; ++index) {\n            if (nftIdsStaked[msgSender][index] == _nftId) {\n                break;\n            }\n        }\n\n        require(index != nftsStakedLength, \"ERR__NFT_NOT_STAKED\");\n        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];\n        nftIdsStaked[msgSender].pop();\n\n        _sendRewardsForNft(_nftId, _to);\n        delete nftInfo[_nftId];\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n        totalSharesStaked[baseToken] -= amount;\n\n        lpToken.safeTransferFrom(address(this), msgSender, _nftId);\n\n        emit LogWithdraw(msgSender, baseToken, _nftId, _to);\n    }\n\n    /// @notice Extract all rewards without withdrawing LP tokens\n    /// @param _nftId LP token nftId for which rewards are to be withdrawn\n    /// @param _to The receiver of withdraw benefit.\n    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        require(nftInfo[_nftId].staker == _msgSender(), \"ERR__NOT_OWNER\");\n        _sendRewardsForNft(_nftId, _to);\n    }\n\n    /// @notice Calculates an up to date value of accTokenPerShare\n    /// @notice An updated value of accTokenPerShare is comitted to storage every time a new NFT is deposited, withdrawn or rewards are extracted\n    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {\n        uint256 accumulator = 0;\n        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;\n        uint256 counter = block.timestamp;\n        uint256 i = rewardRateLog[_baseToken].length - 1;\n        while (true) {\n            if (lastUpdatedTime >= counter) {\n                break;\n            }\n            unchecked {\n                accumulator +=\n                    rewardRateLog[_baseToken][i].rewardsPerSecond *\n                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));\n            }\n            counter = rewardRateLog[_baseToken][i].timestamp;\n            if (i == 0) {\n                break;\n            }\n            --i;\n        }\n\n        // We know that during all the periods that were included in the current iterations,\n        // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the\n        // updates to the pool that happened after the lastUpdatedTime.\n        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];\n        return accumulator + poolInfo[_baseToken].accTokenPerShare;\n    }\n\n    /// @notice View function to see pending Token\n    /// @param _nftId NFT for which pending tokens are to be viewed\n    /// @return pending reward for a given user.\n    function pendingToken(uint256 _nftId) external view returns (uint256) {\n        NFTInfo storage nft = nftInfo[_nftId];\n        if (!nft.isStaked) {\n            return 0;\n        }\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        PoolInfo memory pool = poolInfo[baseToken];\n        uint256 accToken1PerShare = pool.accTokenPerShare;\n        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {\n            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);\n        }\n        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @return pool Returns the pool that was updated.\n    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {\n        pool = poolInfo[_baseToken];\n        if (block.timestamp > pool.lastRewardTime) {\n            if (totalSharesStaked[_baseToken] > 0) {\n                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);\n            }\n            pool.lastRewardTime = block.timestamp;\n            poolInfo[_baseToken] = pool;\n            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);\n        }\n    }\n\n    /// @notice View function to see the tokens staked by a given user.\n    /// @param _user Address of user.\n    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {\n        nftIds = nftIdsStaked[_user];\n    }\n\n    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {\n        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n\n    receive() external payable {\n        emit LogNativeReceived(_msgSender(), msg.value);\n    }\n\n    function max(uint256 _a, uint256 _b) private pure returns (uint256) {\n        return _a >= _b ? _a : _b;\n    }\n}"
    }
  ]
}