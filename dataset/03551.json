{
  "Title": "[L05] Not leaving a storage gap in upgradeable contracts on multi-level inheritance",
  "Content": "The [`CompoundStrategy`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/strategies/CompoundStrategy.sol#L15), [`AaveStrategy`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/strategies/AaveStrategy.sol#L17), and [`ThreePoolStrategy`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/strategies/ThreePoolStrategy.sol#L19) contracts inherit from [`InitializableAbstractStrategy`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/utils/InitializableAbstractStrategy.sol), and are all meant to be upgradeable, which means that the governance can add new functions and/or storage variables to them. However, if a new storage variable is added to the `InitializableAbstractStrategy` contract, it will overwrite the storage of the children contracts and therefore will make the storage layout incompatible.\n\n\nTo allow additions of new state variables without compromising the storage compatibility with existing deployments, consider [leaving a storage gap](https://docs.openzeppelin.com/contracts/3.x/upgradeable#storage_gaps) at the end of each newely deployed upgradeable contract that has children contracts. Note that this should only be performed in newly deployed contracts, *and not between upgrades*.\n\n\n**Update:** *Fixed in [PR#713](https://github.com/OriginProtocol/origin-dollar/pull/713).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/strategies/CompoundStrategy.sol",
      "content": "pragma solidity 0.5.11;\n\n/**\n * @title OUSD Compound Strategy\n * @notice Investment strategy for investing stablecoins via Compound\n * @author Origin Protocol Inc\n */\nimport { ICERC20 } from \"./ICompound.sol\";\nimport { IComptroller } from \"../interfaces/IComptroller.sol\";\nimport {\n    IERC20,\n    InitializableAbstractStrategy\n} from \"../utils/InitializableAbstractStrategy.sol\";\n\ncontract CompoundStrategy is InitializableAbstractStrategy {\n    event SkippedWithdrawal(address asset, uint256 amount);\n\n    /**\n     * @dev Collect accumulated COMP and send to Vault.\n     */\n    function collectRewardToken() external onlyVault nonReentrant {\n        // Claim COMP from Comptroller\n        ICERC20 cToken = _getCTokenFor(assetsMapped[0]);\n        IComptroller comptroller = IComptroller(cToken.comptroller());\n        comptroller.claimComp(address(this));\n        // Transfer COMP to Vault\n        IERC20 rewardToken = IERC20(rewardTokenAddress);\n        uint256 balance = rewardToken.balanceOf(address(this));\n        emit RewardTokenCollected(vaultAddress, balance);\n        rewardToken.safeTransfer(vaultAddress, balance);\n    }\n\n    /**\n     * @dev Deposit asset into Compound\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     * @return amountDeposited Amount of asset that was deposited\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit asset into Compound\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     * @return amountDeposited Amount of asset that was deposited\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n        ICERC20 cToken = _getCTokenFor(_asset);\n        emit Deposit(_asset, address(cToken), _amount);\n        require(cToken.mint(_amount) == 0, \"cToken mint failed\");\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into Compound\n     */\n    function depositAll() external onlyVault nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = IERC20(assetsMapped[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _deposit(assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw asset from Compound\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     * @return amountWithdrawn Amount of asset that was withdrawn\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        ICERC20 cToken = _getCTokenFor(_asset);\n        // If redeeming 0 cTokens, just skip, else COMP will revert\n        uint256 cTokensToRedeem = _convertUnderlyingToCToken(cToken, _amount);\n        if (cTokensToRedeem == 0) {\n            emit SkippedWithdrawal(_asset, _amount);\n            return;\n        }\n\n        emit Withdrawal(_asset, address(cToken), _amount);\n        require(cToken.redeemUnderlying(_amount) == 0, \"Redeem failed\");\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external onlyVaultOrGovernor nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            // Redeem entire balance of cToken\n            ICERC20 cToken = _getCTokenFor(assetsMapped[i]);\n            if (cToken.balanceOf(address(this)) > 0) {\n                require(\n                    cToken.redeem(cToken.balanceOf(address(this))) == 0,\n                    \"Redeem failed\"\n                );\n                // Transfer entire balance to Vault\n                IERC20 asset = IERC20(assetsMapped[i]);\n                asset.safeTransfer(\n                    vaultAddress,\n                    asset.balanceOf(address(this))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     *      This includes any interest that was generated since depositing\n     *      Compound exchange rate between the cToken and asset gradually increases,\n     *      causing the cToken to be worth more corresponding asset.\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        returns (uint256 balance)\n    {\n        // Balance is always with token cToken decimals\n        ICERC20 cToken = _getCTokenFor(_asset);\n        balance = _checkBalance(cToken);\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     *      underlying = (cTokenAmt * exchangeRate) / 1e18\n     * @param _cToken     cToken for which to check balance\n     * @return balance    Total value of the asset in the platform\n     */\n    function _checkBalance(ICERC20 _cToken)\n        internal\n        view\n        returns (uint256 balance)\n    {\n        uint256 cTokenBalance = _cToken.balanceOf(address(this));\n        uint256 exchangeRate = _cToken.exchangeRateStored();\n        // e.g. 50e8*205316390724364402565641705 / 1e18 = 1.0265..e18\n        balance = cTokenBalance.mul(exchangeRate).div(1e18);\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) external view returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding cToken,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens() external {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; i++) {\n            address asset = assetsMapped[i];\n            address cToken = assetToPToken[asset];\n            // Safe approval\n            IERC20(asset).safeApprove(cToken, 0);\n            IERC20(asset).safeApprove(cToken, uint256(-1));\n        }\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset / cTokens\n     *      We need to approve the cToken and give it permission to spend the asset\n     * @param _asset Address of the asset to approve\n     * @param _cToken This cToken has the approval approval\n     */\n    function _abstractSetPToken(address _asset, address _cToken) internal {\n        // Safe approval\n        IERC20(_asset).safeApprove(_cToken, 0);\n        IERC20(_asset).safeApprove(_cToken, uint256(-1));\n    }\n\n    /**\n     * @dev Get the cToken wrapped in the ICERC20 interface for this asset.\n     *      Fails if the pToken doesn't exist in our mappings.\n     * @param _asset Address of the asset\n     * @return Corresponding cToken to this asset\n     */\n    function _getCTokenFor(address _asset) internal view returns (ICERC20) {\n        address cToken = assetToPToken[_asset];\n        require(cToken != address(0), \"cToken does not exist\");\n        return ICERC20(cToken);\n    }\n\n    /**\n     * @dev Converts an underlying amount into cToken amount\n     *      cTokenAmt = (underlying * 1e18) / exchangeRate\n     * @param _cToken     cToken for which to change\n     * @param _underlying Amount of underlying to convert\n     * @return amount     Equivalent amount of cTokens\n     */\n    function _convertUnderlyingToCToken(ICERC20 _cToken, uint256 _underlying)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        uint256 exchangeRate = _cToken.exchangeRateStored();\n        // e.g. 1e18*1e18 / 205316390724364402565641705 = 50e8\n        // e.g. 1e8*1e18 / 205316390724364402565641705 = 0.45 or 0\n        amount = _underlying.mul(1e18).div(exchangeRate);\n    }\n}"
    }
  ]
}