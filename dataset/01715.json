{
  "Title": "Incorrect sload in LibBytes",
  "Content": "**Description:** The function `storeUint128` in `LibBytes` intends to pack uint128 `reserves` starting at the given slot but will overwrite the final slot if [storing an odd number of reserves](https://github.com/BeanstalkFarms/Wells/blob/e5441fc78f0fd4b77a898812d0fd22cb43a0af55/src/libraries/LibBytes.sol#L70). It is currently only ever called in [`Well::_setReserves`](https://github.com/BeanstalkFarms/Wells/blob/e5441fc78f0fd4b77a898812d0fd22cb43a0af55/src/Well.sol#L609) which takes as input the result of `Well::_updatePumps` which itself always takes `_tokens.length` as an argument. Hence, in the case of an odd number of tokens, the final 128 bits in the slot are never accessed, regardless of the error. However, there may be a case in which the library is used by other implementations, setting a variable number of reserves at any one time rather than always acting on the length of tokens, which may inadvertently overwrite the final reserve to zero.\n\n**Impact:** Given assets are not directly at risk, we evaluate the severity to LOW.\n\n**Proof of Concept:** The following test case demonstrates this issue more clearly:\n\n```solidity\n// NOTE: Add to LibBytes.t.sol\nfunction test_exploitStoreAndRead() public {\n    // Write to storage slot to demonstrate overwriting existing values\n    // In this case, 420 will be stored in the lower 128 bits of the last slot\n    bytes32 slot = RESERVES_STORAGE_SLOT;\n    uint256 maxI = (NUM_RESERVES_MAX - 1) / 2;\n    uint256 storeValue = 420;\n    assembly {\n        sstore(add(slot, mul(maxI, 32)), storeValue)\n    }\n\n    // Read reserves and assert the final reserve is 420\n    uint[] memory reservesBefore = LibBytes.readUint128(RESERVES_STORAGE_SLOT, NUM_RESERVES_MAX);\n    emit log_named_array(\"reservesBefore\", reservesBefore);\n\n    // Set up reserves to store, but only up to NUM_RESERVES_MAX - 1 as we have already stored a value in the last 128 bits of the last slot\n    uint[] memory reserves = new uint[](NUM_RESERVES_MAX - 1);\n    for (uint i = 1; i < NUM_RESERVES_MAX; i++) {\n        reserves[i-1] = i;\n    }\n\n    // Log the last reserve before the store, perhaps from other implementations which don't always act on the entire reserves length\n    uint256 t;\n    assembly {\n        t := shr(128, shl(128, sload(add(slot, mul(maxI, 32)))))\n    }\n    emit log_named_uint(\"final slot, lower 128 bits before\", t);\n\n    // Store reserves\n    LibBytes.storeUint128(RESERVES_STORAGE_SLOT, reserves);\n\n    // Re-read reserves and compare\n    uint[] memory reserves2 = LibBytes.readUint128(RESERVES_STORAGE_SLOT, NUM_RESERVES_MAX);\n\n    emit log_named_array(\"reserves\", reserves);\n    emit log_named_array(\"reserves2\", reserves2);\n\n    // But wait, what about the last reserve\n    assembly {\n        t := shr(128, shl(128, sload(add(slot, mul(maxI, 32)))))\n    }\n\n    // Turns out it was overwritten by the last store as it calculates the sload incorrectly\n    emit log_named_uint(\"final slot, lower 128 bits after\", t);\n}\n```\n\nOutput before mitigation:\n\n```\nreservesBefore: [0, 0, 0, 0, 0, 0, 0, 420]\nfinal slot, lower 128 bits before: 420\nreserves: [1, 2, 3, 4, 5, 6, 7]\nreserves2: [1, 2, 3, 4, 5, 6, 7, 0]\nfinal slot, lower 128 bits after: 0\n```\n\n**Recommended Mitigation:** Implement the following fix to load the existing value from storage and pack in the lower bits:\n\n```solidity\n\tsload(add(slot, mul(maxI, 32)))\n```\n\nOutput after mitigation:\n\n```\nreservesBefore: [0, 0, 0, 0, 0, 0, 0, 420]\nfinal slot, lower 128 bits before: 420\nreserves: [1, 2, 3, 4, 5, 6, 7]\nreserves2: [1, 2, 3, 4, 5, 6, 7, 420]\nfinal slot, lower 128 bits after: 420\n```\n\n**Beanstalk:** Fixed in commit [5e61420](https://github.com/BeanstalkFarms/Basin/pull/71/commits/5e614205a49f1388c36b2a02ce38cf0df317dfde).\n\n**Cyfrin:** Acknowledged.\n\n\\clearpage",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/libraries/LibBytes.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\n/**\n * @title LibBytes\n * @author Publius\n * @notice Contains byte operations used during storage reads & writes.\n *\n * {LibBytes} tightly packs an array of `uint256` values into `n / 2` storage\n * slots, where `n` is number of items to pack.\n *\n * Each value must be `<= type(uint128).max` in order pack properly.\n */\nlibrary LibBytes {\n    bytes32 private constant ZERO_BYTES = bytes32(0);\n\n    /**\n     * @dev Read the `i`th 32-byte chunk from `data`.\n     */\n    function getBytes32FromBytes(bytes memory data, uint i) internal pure returns (bytes32 _bytes) {\n        uint index = i * 32;\n        if (index > data.length) {\n            _bytes = ZERO_BYTES;\n        } else {\n            assembly {\n                _bytes := mload(add(add(data, index), 32))\n            }\n        }\n    }\n\n    /**\n     * @dev Store packed uint128 `reserves` starting at storage position `slot`.\n     * Balances are passed as an uint256[], but values must be <= max uint128\n     * to allow for packing into a single storage slot.\n     */\n    function storeUint128(bytes32 slot, uint[] memory reserves) internal {\n        // Shortcut: two reserves can be packed into one slot without a loop\n        if (reserves.length == 2) {\n            require(reserves[0] <= type(uint128).max, \"ByteStorage: too large\");\n            require(reserves[1] <= type(uint128).max, \"ByteStorage: too large\");\n            assembly {\n                sstore(slot, add(shl(128, mload(add(reserves, 32))), shr(128, shl(128, mload(add(reserves, 64))))))\n            }\n        } else {\n            uint maxI = reserves.length / 2; // number of fully-packed slots\n            uint iByte; // byte offset of the current reserve\n            for (uint i; i < maxI; ++i) {\n                require(reserves[2 * i] <= type(uint128).max, \"ByteStorage: too large\");\n                require(reserves[2 * i + 1] <= type(uint128).max, \"ByteStorage: too large\");\n                iByte = i * 64;\n                assembly {\n                    sstore(\n                        add(slot, mul(i, 32)),\n                        add(\n                            shl(128, mload(add(reserves, add(iByte, 32)))),\n                            shr(128, shl(128, mload(add(reserves, add(iByte, 64)))))\n                        )\n                    )\n                }\n            }\n            // If there is an odd number of reserves, create a slot with the last reserve\n            // Since `i < maxI` above, the next byte offset `maxI * 64`\n            if (reserves.length % 2 == 1) {\n                require(reserves[reserves.length - 1] <= type(uint128).max, \"ByteStorage: too large\");\n                iByte = maxI * 64;\n                assembly {\n                    sstore(\n                        add(slot, mul(maxI, 32)),\n                        add(shl(128, mload(add(reserves, add(iByte, 32)))), shr(128, shl(128, sload(add(slot, maxI)))))\n                    )\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Read `n` packed uint128 reserves at storage position `slot`.\n     */\n    function readUint128(bytes32 slot, uint n) internal view returns (uint[] memory reserves) {\n        // Initialize array with length `n`, fill it in via assembly\n        reserves = new uint256[](n);\n\n        // Shortcut: two reserves can be quickly unpacked from one slot\n        if (n == 2) {\n            assembly {\n                mstore(add(reserves, 32), shr(128, sload(slot)))\n                mstore(add(reserves, 64), shr(128, shl(128, sload(slot))))\n            }\n            return reserves;\n        }\n\n        uint iByte;\n        for (uint i = 1; i <= n; ++i) {\n            // `iByte` is the byte position for the current slot:\n            // i        1 2 3 4 5 6\n            // iByte    0 0 1 1 2 2\n            iByte = (i - 1) / 2 * 32;\n            if (i % 2 == 1) {\n                assembly {\n                    mstore(\n                        // store at index i * 32; i = 0 is skipped by loop\n                        add(reserves, mul(i, 32)),\n                        shr(128, sload(add(slot, iByte)))\n                    )\n                }\n            } else {\n                assembly {\n                    mstore(add(reserves, mul(i, 32)), shr(128, shl(128, sload(add(slot, iByte)))))\n                }\n            }\n        }\n    }\n}"
    }
  ]
}