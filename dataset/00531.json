{
  "Title": "UniswapFlashswapDirectMintHandler Unusable When Not Leveraging",
  "Content": "Within the `UniswapFlashswapDirectMintHandler` contract, the `_flashswapAndMint` function contains a [clause](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol#L117) that is unreachable. This is due to the fact that the [`getEthAmountInForLstAmountOut` function](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/libraries/EtherFiLibrary.sol#L34) in the `EtherFiLibrary` contract always returns a value of [`1` or greater](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/libraries/EtherFiLibrary.sol#L41-L49). Intuitively, for an amount \"out\" of 0, the amount \"in\" should also be 0. However, due to [the addition of 1](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/libraries/EtherFiLibrary.sol#L41), this is not possible. The `UniswapFlashswapDirectMintHandler` contract is designed to handle cases in which the [`amountLrt` is 0](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol#L114), and when this is the case, we will get an `amountWethToFlashloan` of 1.\n\n\nNot only does this mean that an unnecessary flash-borrow will occur, but the transaction execution will fail as well. During the flashswap callback, the contract [will attempt to mint the collateral asset](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol#L201) using the value 1. This will [eventually revert inside the eETH liquidity pool contract](https://etherscan.io/address/0x11858bcac85832acdda0bde9b867830f7d21cf63#code#F1#L564) since [the division in `_sharesForDepositAmount`](https://etherscan.io/address/0x11858bcac85832acdda0bde9b867830f7d21cf63#code#F1#L580) returns 0. This prevents the contract from functioning under normal circumstances if a user were to use `flashswapAndMint` for depositing collateral and borrowing. Note that this is technically not a given and is dependent on the number of shares being less than the total pooled ETH in the eETH contract.\n\n\nConsider adding an early-escape check within [`getEthAmountInForLstAmountOut`](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/libraries/EtherFiLibrary.sol#L34), which returns 0 when `lrtAmount` is 0.\n\n\n***Update:** Resolved in [pull request #53](https://github.com/Ion-Protocol/ion-protocol/pull/53).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IonHandlerBase } from \"./IonHandlerBase.sol\";\nimport { IWETH9 } from \"../../../interfaces/IWETH9.sol\";\n\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { IUniswapV3SwapCallback } from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\nimport { IERC20 as IERC20Balancer } from \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { WSTETH_ADDRESS } from \"../../../Constants.sol\";\n\n/**\n * @notice This contract allows for easy creation of leverge positions through a\n * Uniswap flashswap and direct mint of the collateral from the provider. This\n * will be used when the collateral cannot be minted directly with the base\n * asset but can be directly minted by a token that the base asset has a\n * UniswapV3 pool with.\n *\n * This contract is to be used when there exists a UniswapV3 pool between the\n * base asset and the mint asset.\n *\n * @custom:security-contact security@molecularlabs.io\n */\nabstract contract UniswapFlashswapDirectMintHandler is IonHandlerBase, IUniswapV3SwapCallback {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH9;\n    using SafeCast for uint256;\n\n    error InvalidUniswapPool();\n    error InvalidZeroLiquidityRegionSwap();\n    error CallbackOnlyCallableByPool(address unauthorizedCaller);\n    error OutputAmountNotReceived(uint256 amountReceived, uint256 amountRequired);\n\n    uint256 private flashloanInitiated = 1;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4_295_128_739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1_461_446_703_485_210_103_287_273_052_203_988_822_378_723_970_342;\n\n    IUniswapV3Pool public immutable UNISWAP_POOL;\n    IERC20 public immutable MINT_ASSET;\n    bool private immutable MINT_IS_TOKEN0;\n\n    /**\n     * @notice Creates a new `UniswapFlashswapDirectMintHandler` instance.\n     * @param _uniswapPool Pool to perform the flashswap on.\n     * @param _mintAsset The asset used to mint the collateral.\n     */\n    constructor(IUniswapV3Pool _uniswapPool, IERC20 _mintAsset) {\n        if (address(_uniswapPool) == address(0)) revert InvalidUniswapPool();\n\n        MINT_ASSET = _mintAsset;\n\n        address token0 = _uniswapPool.token0();\n        address token1 = _uniswapPool.token1();\n\n        if (token0 != address(MINT_ASSET) && token1 != address(MINT_ASSET)) {\n            revert InvalidUniswapPool();\n        }\n        if (token0 == address(MINT_ASSET) && token1 == address(MINT_ASSET)) {\n            revert InvalidUniswapPool();\n        }\n\n        UNISWAP_POOL = _uniswapPool;\n        MINT_IS_TOKEN0 = token0 == address(MINT_ASSET) ? true : false;\n\n        address baseAsset = MINT_IS_TOKEN0 ? token1 : token0;\n\n        if (baseAsset != address(BASE)) revert InvalidUniswapPool();\n    }\n\n    /**\n     * @notice Transfer collateral from user -> Initiate flashswap between from\n     * base asset to mint asset -> Use the mint asset to mint the collateral ->\n     * Deposit all collateral into `IonPool` -> Borrow the base asset -> Close\n     * the flashswap by sending the base asset to the Uniswap pool.\n     * @param initialDeposit in collateral terms. [WAD]\n     * @param resultingAdditionalCollateral in collateral terms. [WAD]\n     * @param maxResultingDebt in base asset terms. [WAD]\n     * @param proof used to validate the user is whitelisted.\n     */\n    function flashswapAndMint(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt,\n        uint256 deadline,\n        bytes32[] memory proof\n    )\n        external\n        onlyWhitelistedBorrowers(proof)\n        checkDeadline(deadline)\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n        _flashswapAndMint(initialDeposit, resultingAdditionalCollateral, maxResultingDebt);\n    }\n\n    function _flashswapAndMint(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt\n    )\n        internal\n    {\n        IERC20Balancer[] memory addresses = new IERC20Balancer[](1);\n        addresses[0] = IERC20Balancer(address(WETH));\n\n        uint256 amountLrt = resultingAdditionalCollateral - initialDeposit; // in collateral terms\n        uint256 amountWethToFlashloan = _getAmountInForCollateralAmountOut(amountLrt);\n\n        if (amountWethToFlashloan == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        if (amountWethToFlashloan > maxResultingDebt) {\n            revert FlashloanRepaymentTooExpensive(amountWethToFlashloan, maxResultingDebt);\n        }\n\n        // We want to swap for ETH here\n        bool zeroForOne = MINT_IS_TOKEN0 ? false : true;\n        _initiateFlashSwap({\n            zeroForOne: zeroForOne,\n            amountOut: amountWethToFlashloan,\n            recipient: address(this),\n            data: abi.encode(msg.sender, resultingAdditionalCollateral, initialDeposit)\n        });\n    }\n\n    /**\n     * @notice Handles swap intiation logic. This function can only initiate\n     * exact output swaps.\n     * @param zeroForOne Direction of the swap.\n     * @param amountOut Desired amount of output.\n     * @param recipient of output tokens.\n     * @param data Arbitrary data to be passed through swap callback.\n     */\n    function _initiateFlashSwap(\n        bool zeroForOne,\n        uint256 amountOut,\n        address recipient,\n        bytes memory data\n    )\n        private\n        returns (uint256 amountIn)\n    {\n        (int256 amount0Delta, int256 amount1Delta) = UNISWAP_POOL.swap(\n            recipient, zeroForOne, -amountOut.toInt256(), zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1, data\n        );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n\n        // it's technically possible to not receive the full output amount,\n        if (amountOutReceived != amountOut) revert OutputAmountNotReceived(amountOutReceived, amountOut);\n    }\n\n    /**\n     * @notice From the perspective of the pool i.e. Negative amount means pool is\n     * sending. This function is intended to never be called directly. It should\n     * only be called by the Uniswap pool during a swap initiated by this\n     * contract.\n     *\n     * @dev One thing to note from a security perspective is that the pool only calls\n     * the callback on `msg.sender`. So a theoretical attacker cannot call this\n     * function by directing where to call the callback.\n     *\n     * @param amount0Delta change in token0\n     * @param amount1Delta change in token1\n     * @param _data arbitrary data\n     */\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external override {\n        if (msg.sender != address(UNISWAP_POOL)) revert CallbackOnlyCallableByPool(msg.sender);\n\n        // swaps entirely within 0-liquidity regions are not supported\n        if (amount0Delta == 0 && amount1Delta == 0) revert InvalidZeroLiquidityRegionSwap();\n        (address user, uint256 resultingAdditionalCollateral, uint256 initialDeposit) =\n            abi.decode(_data, (address, uint256, uint256));\n\n        // Code below this if statement will always assume token0 is MINT_ASSET. If it\n        // is not actually the case, we will flip the vars\n        if (!MINT_IS_TOKEN0) {\n            (amount0Delta, amount1Delta) = (amount1Delta, amount0Delta);\n        }\n\n        address tokenIn = address(BASE);\n\n        // Sanity check that Uniswap is sending MINT_ASSET\n        assert(amount0Delta < 0 && amount1Delta > 0);\n\n        // MINT_ASSET needs to be converted into collateral asset\n        uint256 collateralFromDeposit = _mintCollateralAsset(uint256(-amount0Delta));\n\n        // Sanity check\n        assert(collateralFromDeposit + initialDeposit == resultingAdditionalCollateral);\n\n        // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed\n        // to cover the amount owed back to Uniswap\n        _depositAndBorrow(\n            user, address(this), resultingAdditionalCollateral, uint256(amount1Delta), AmountToBorrow.IS_MIN\n        );\n\n        IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount1Delta));\n    }\n\n    /**\n     * @notice Deposits the mint asset into the a provider's collateral asset.\n     * @param amountMintAsset amount of \"mint asset\" to deposit. [WAD]\n     */\n    function _mintCollateralAsset(uint256 amountMintAsset) internal virtual returns (uint256);\n\n    /**\n     * @notice Calculates the amount of eth required to receive `amountLrt`.\n     * @dev Calculates the amount of eth required to receive `amountLrt`.\n     * @param amountLrt Desired output amount. [WAD]\n     * @return Amount mint asset required for desired output. [WAD]\n     */\n    function _getAmountInForCollateralAmountOut(uint256 amountLrt) internal view virtual returns (uint256);\n}"
    },
    {
      "filename": "src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IonHandlerBase } from \"./IonHandlerBase.sol\";\nimport { IWETH9 } from \"../../../interfaces/IWETH9.sol\";\n\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { IUniswapV3SwapCallback } from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\nimport { IERC20 as IERC20Balancer } from \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { WSTETH_ADDRESS } from \"../../../Constants.sol\";\n\n/**\n * @notice This contract allows for easy creation of leverge positions through a\n * Uniswap flashswap and direct mint of the collateral from the provider. This\n * will be used when the collateral cannot be minted directly with the base\n * asset but can be directly minted by a token that the base asset has a\n * UniswapV3 pool with.\n *\n * This contract is to be used when there exists a UniswapV3 pool between the\n * base asset and the mint asset.\n *\n * @custom:security-contact security@molecularlabs.io\n */\nabstract contract UniswapFlashswapDirectMintHandler is IonHandlerBase, IUniswapV3SwapCallback {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH9;\n    using SafeCast for uint256;\n\n    error InvalidUniswapPool();\n    error InvalidZeroLiquidityRegionSwap();\n    error CallbackOnlyCallableByPool(address unauthorizedCaller);\n    error OutputAmountNotReceived(uint256 amountReceived, uint256 amountRequired);\n\n    uint256 private flashloanInitiated = 1;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4_295_128_739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1_461_446_703_485_210_103_287_273_052_203_988_822_378_723_970_342;\n\n    IUniswapV3Pool public immutable UNISWAP_POOL;\n    IERC20 public immutable MINT_ASSET;\n    bool private immutable MINT_IS_TOKEN0;\n\n    /**\n     * @notice Creates a new `UniswapFlashswapDirectMintHandler` instance.\n     * @param _uniswapPool Pool to perform the flashswap on.\n     * @param _mintAsset The asset used to mint the collateral.\n     */\n    constructor(IUniswapV3Pool _uniswapPool, IERC20 _mintAsset) {\n        if (address(_uniswapPool) == address(0)) revert InvalidUniswapPool();\n\n        MINT_ASSET = _mintAsset;\n\n        address token0 = _uniswapPool.token0();\n        address token1 = _uniswapPool.token1();\n\n        if (token0 != address(MINT_ASSET) && token1 != address(MINT_ASSET)) {\n            revert InvalidUniswapPool();\n        }\n        if (token0 == address(MINT_ASSET) && token1 == address(MINT_ASSET)) {\n            revert InvalidUniswapPool();\n        }\n\n        UNISWAP_POOL = _uniswapPool;\n        MINT_IS_TOKEN0 = token0 == address(MINT_ASSET) ? true : false;\n\n        address baseAsset = MINT_IS_TOKEN0 ? token1 : token0;\n\n        if (baseAsset != address(BASE)) revert InvalidUniswapPool();\n    }\n\n    /**\n     * @notice Transfer collateral from user -> Initiate flashswap between from\n     * base asset to mint asset -> Use the mint asset to mint the collateral ->\n     * Deposit all collateral into `IonPool` -> Borrow the base asset -> Close\n     * the flashswap by sending the base asset to the Uniswap pool.\n     * @param initialDeposit in collateral terms. [WAD]\n     * @param resultingAdditionalCollateral in collateral terms. [WAD]\n     * @param maxResultingDebt in base asset terms. [WAD]\n     * @param proof used to validate the user is whitelisted.\n     */\n    function flashswapAndMint(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt,\n        uint256 deadline,\n        bytes32[] memory proof\n    )\n        external\n        onlyWhitelistedBorrowers(proof)\n        checkDeadline(deadline)\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n        _flashswapAndMint(initialDeposit, resultingAdditionalCollateral, maxResultingDebt);\n    }\n\n    function _flashswapAndMint(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt\n    )\n        internal\n    {\n        IERC20Balancer[] memory addresses = new IERC20Balancer[](1);\n        addresses[0] = IERC20Balancer(address(WETH));\n\n        uint256 amountLrt = resultingAdditionalCollateral - initialDeposit; // in collateral terms\n        uint256 amountWethToFlashloan = _getAmountInForCollateralAmountOut(amountLrt);\n\n        if (amountWethToFlashloan == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        if (amountWethToFlashloan > maxResultingDebt) {\n            revert FlashloanRepaymentTooExpensive(amountWethToFlashloan, maxResultingDebt);\n        }\n\n        // We want to swap for ETH here\n        bool zeroForOne = MINT_IS_TOKEN0 ? false : true;\n        _initiateFlashSwap({\n            zeroForOne: zeroForOne,\n            amountOut: amountWethToFlashloan,\n            recipient: address(this),\n            data: abi.encode(msg.sender, resultingAdditionalCollateral, initialDeposit)\n        });\n    }\n\n    /**\n     * @notice Handles swap intiation logic. This function can only initiate\n     * exact output swaps.\n     * @param zeroForOne Direction of the swap.\n     * @param amountOut Desired amount of output.\n     * @param recipient of output tokens.\n     * @param data Arbitrary data to be passed through swap callback.\n     */\n    function _initiateFlashSwap(\n        bool zeroForOne,\n        uint256 amountOut,\n        address recipient,\n        bytes memory data\n    )\n        private\n        returns (uint256 amountIn)\n    {\n        (int256 amount0Delta, int256 amount1Delta) = UNISWAP_POOL.swap(\n            recipient, zeroForOne, -amountOut.toInt256(), zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1, data\n        );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n\n        // it's technically possible to not receive the full output amount,\n        if (amountOutReceived != amountOut) revert OutputAmountNotReceived(amountOutReceived, amountOut);\n    }\n\n    /**\n     * @notice From the perspective of the pool i.e. Negative amount means pool is\n     * sending. This function is intended to never be called directly. It should\n     * only be called by the Uniswap pool during a swap initiated by this\n     * contract.\n     *\n     * @dev One thing to note from a security perspective is that the pool only calls\n     * the callback on `msg.sender`. So a theoretical attacker cannot call this\n     * function by directing where to call the callback.\n     *\n     * @param amount0Delta change in token0\n     * @param amount1Delta change in token1\n     * @param _data arbitrary data\n     */\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external override {\n        if (msg.sender != address(UNISWAP_POOL)) revert CallbackOnlyCallableByPool(msg.sender);\n\n        // swaps entirely within 0-liquidity regions are not supported\n        if (amount0Delta == 0 && amount1Delta == 0) revert InvalidZeroLiquidityRegionSwap();\n        (address user, uint256 resultingAdditionalCollateral, uint256 initialDeposit) =\n            abi.decode(_data, (address, uint256, uint256));\n\n        // Code below this if statement will always assume token0 is MINT_ASSET. If it\n        // is not actually the case, we will flip the vars\n        if (!MINT_IS_TOKEN0) {\n            (amount0Delta, amount1Delta) = (amount1Delta, amount0Delta);\n        }\n\n        address tokenIn = address(BASE);\n\n        // Sanity check that Uniswap is sending MINT_ASSET\n        assert(amount0Delta < 0 && amount1Delta > 0);\n\n        // MINT_ASSET needs to be converted into collateral asset\n        uint256 collateralFromDeposit = _mintCollateralAsset(uint256(-amount0Delta));\n\n        // Sanity check\n        assert(collateralFromDeposit + initialDeposit == resultingAdditionalCollateral);\n\n        // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed\n        // to cover the amount owed back to Uniswap\n        _depositAndBorrow(\n            user, address(this), resultingAdditionalCollateral, uint256(amount1Delta), AmountToBorrow.IS_MIN\n        );\n\n        IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount1Delta));\n    }\n\n    /**\n     * @notice Deposits the mint asset into the a provider's collateral asset.\n     * @param amountMintAsset amount of \"mint asset\" to deposit. [WAD]\n     */\n    function _mintCollateralAsset(uint256 amountMintAsset) internal virtual returns (uint256);\n\n    /**\n     * @notice Calculates the amount of eth required to receive `amountLrt`.\n     * @dev Calculates the amount of eth required to receive `amountLrt`.\n     * @param amountLrt Desired output amount. [WAD]\n     * @return Amount mint asset required for desired output. [WAD]\n     */\n    function _getAmountInForCollateralAmountOut(uint256 amountLrt) internal view virtual returns (uint256);\n}"
    },
    {
      "filename": "src/libraries/EtherFiLibrary.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IWeEth, IEEth, IEtherFiLiquidityPool } from \"../interfaces/ProviderInterfaces.sol\";\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { WadRayMath } from \"./math/WadRayMath.sol\";\n\nusing Math for uint256;\nusing WadRayMath for uint256;\n\n/**\n * @title EtherFiLibrary\n *\n * @notice A helper library for EtherFi-related conversions.\n *\n * @custom:security-contact security@molecularlabs.io\n */\nlibrary EtherFiLibrary {\n    error NoAmountInFound();\n\n    /**\n     * @notice Returns the amount of ETH required to obtain a given amount of weETH.\n     * @dev Performing the calculations seems to potentially yield a rounding\n     * error of 1-2 wei. In order to ensure that the correct value is returned,\n     * both versions are tested and the correct one is returned.\n     *\n     * Should a correct version ever not be found, any contracts using the\n     * library should halt execution.\n     * @param weEth contract.\n     * @param lrtAmount Desired amount of weETH. [WAD]\n     * @return Amount of ETH required to obtain the given amount of weETH. [WAD]\n     */\n    function getEthAmountInForLstAmountOut(IWeEth weEth, uint256 lrtAmount) internal view returns (uint256) {\n        IEtherFiLiquidityPool pool = IEtherFiLiquidityPool(weEth.liquidityPool());\n        IEEth eEth = IEEth(weEth.eETH());\n\n        uint256 totalPooledEther = pool.getTotalPooledEther();\n        uint256 totalShares = eEth.totalShares();\n\n        uint256 unroundedAmountIn = lrtAmount.wadMulDown(totalPooledEther).wadDivUp(totalShares) + 1;\n\n        // Rounding error tends to be ~1-2 wei. Check both options and return the correct one.\n        if (_getLstAmountOutForEthAmountIn(totalPooledEther, totalShares, unroundedAmountIn) == lrtAmount) {\n            return unroundedAmountIn;\n        }\n        if (_getLstAmountOutForEthAmountIn(totalPooledEther, totalShares, unroundedAmountIn + 1) == lrtAmount) {\n            return unroundedAmountIn + 1;\n        }\n\n        // Let's be defensive. If the rounding cannot be solved... create a DOS.\n        revert NoAmountInFound();\n    }\n\n    /**\n     * @notice Returns the amount of weETH that will be obtained from a given amount of ETH.\n     * @param weEth contract.\n     * @param ethAmount Amount of ETH to deposit. [WAD]\n     * @return Amount of weETH that will be obtained. [WAD]\n     */\n    function getLstAmountOutForEthAmountIn(IWeEth weEth, uint256 ethAmount) internal view returns (uint256) {\n        IEtherFiLiquidityPool pool = IEtherFiLiquidityPool(weEth.liquidityPool());\n        IEEth eEth = IEEth(weEth.eETH());\n\n        uint256 totalPooledEther = pool.getTotalPooledEther();\n        uint256 totalShares = eEth.totalShares();\n\n        return _getLstAmountOutForEthAmountIn(totalPooledEther, totalShares, ethAmount);\n    }\n\n    /**\n     * @notice An internal helper function to calculate the amount of weETH that\n     * will be obtained from a given amount of ETH.\n     * @dev This is useful if the function arguments are already known so that\n     * additional external calls can be avoided.\n     * @param totalPooledEther Total pooled ether in the Ether Fi pool. [WAD]\n     * @param totalShares Total amount of minted shares. [WAD]\n     * @param ethAmount Amount of ETH to deposit. [WAD]\n     * @return Amount of weETH that will be obtained. [WAD]\n     */\n    function _getLstAmountOutForEthAmountIn(\n        uint256 totalPooledEther,\n        uint256 totalShares,\n        uint256 ethAmount\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 eEthSharesAmount = _sharesForAmount(totalPooledEther, totalShares, ethAmount);\n        uint256 newTotalPooledEther = totalPooledEther + ethAmount;\n        if (newTotalPooledEther == 0) return 0;\n\n        uint256 newTotalShares = totalShares + eEthSharesAmount;\n        uint256 eEthAmount = _amountForShares(newTotalPooledEther, newTotalShares, eEthSharesAmount);\n\n        return _sharesForAmount(newTotalPooledEther, newTotalShares, eEthAmount);\n    }\n\n    /**\n     * @notice Deposits a given amount of ETH into the Ether Fi pool and then\n     * uses the received eETH to mint weETH.\n     * @param weEth contract.\n     * @param ethAmount Amount of ETH to deposit. [WAD]\n     * @return Amount of weETH that was obtained. [WAD]\n     */\n    function depositForLrt(IWeEth weEth, uint256 ethAmount) internal returns (uint256) {\n        IEtherFiLiquidityPool pool = IEtherFiLiquidityPool(weEth.liquidityPool());\n        uint256 eEthSharesAmount = pool.deposit{ value: ethAmount }();\n\n        uint256 newTotalPooledEther = pool.getTotalPooledEther();\n        uint256 newTotalShares = IEEth(weEth.eETH()).totalShares();\n        uint256 amountEEthRecieved = _amountForShares(newTotalPooledEther, newTotalShares, eEthSharesAmount);\n        return weEth.wrap(amountEEthRecieved);\n    }\n\n    /**\n     * @notice An internal helper function to calculate the amount of shares\n     * from amount.\n     * @dev Useful for avoiding external calls when the function arguments are\n     * already known.\n     * @param totalPooledEther Total pooled ether in the Ether Fi pool. [WAD]\n     * @param totalShares Total amount of minted shares. [WAD]\n     * @param _depositAmount Amount of ETH. [WAD]\n     */\n    function _sharesForAmount(\n        uint256 totalPooledEther,\n        uint256 totalShares,\n        uint256 _depositAmount\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (totalPooledEther == 0) return _depositAmount;\n\n        return (_depositAmount * totalShares) / totalPooledEther;\n    }\n\n    /**\n     * @notice An internal helper function to calculate the amount from given\n     * amount of shares.\n     * @dev Useful for avoiding external calls when the function arguments are\n     * already known.\n     * @param totalPooledEther Total pooled ether in the Ether Fi pool. [WAD]\n     * @param totalShares Total amount of minted shares. [WAD]\n     * @param _shares Amount of shares. [WAD]\n     */\n    function _amountForShares(\n        uint256 totalPooledEther,\n        uint256 totalShares,\n        uint256 _shares\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_shares * totalPooledEther) / totalShares;\n    }\n}"
    }
  ]
}