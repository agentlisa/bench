{
  "Title": "[G-09]  Move lesser gas costing checks to the top",
  "Content": "\n`Revert()` statements that check input arguments or cost less gas than what should be at the top of the function. Checks that involve constants should come before checks that involve state variables, function calls and calculations. By doing these checks first, the function is able to revert before wasting a lot of gas in a function that may ultimately revert in the unhappy case.\n\nMove `if (_nftIdLiquidator == _nftId) {revert InvalidLiquidator()}` to the top of the function.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/MainHelper.sol#L258-#L276\n\nIn the `_checkLiquidatorNft()` function as shown below the if-revert statement `if (positionLocked[_nftIdLiquidator] == true) {revert LiquidatorIsInPowerFarm()}` is more gas consuming than the if-revert statement `if (_nftIdLiquidator == _nftId) {revert InvalidLiquidator()}` as the former reads from state which cost `2100` gas units. \n\nWe can make the `_checkLiquidatorNft()` function more gas efficient by moving the cheaper if-revert statement `if (_nftIdLiquidator == _nftId) {revert InvalidLiquidator()}` to the top of the function so that in scenarios where the cheaper revert statement fails the function would revert without having to read from state which is expensive. The diff below shows how the code should be refactored:\n\n```solidity\nfile: contracts/MainHelper.sol\n\n258:    function _checkLiquidatorNft(\n259:        uint256 _nftId,\n260:        uint256 _nftIdLiquidator\n261:    )\n262:        internal\n263:        view\n264:    {\n265:        if (positionLocked[_nftIdLiquidator] == true) {\n266:            revert LiquidatorIsInPowerFarm();\n267:        }\n268:\n269:        if (_nftIdLiquidator == _nftId) {\n270:            revert InvalidLiquidator();\n271:        }\n272:\n273:        if (_nftIdLiquidator >= POSITION_NFT.getNextExpectedId()) {\n274:            revert InvalidLiquidator();\n275:        }\n276:    }\n```\n\n```diff\ndiff --git a/contracts/MainHelper.sol b/contracts/MainHelper.sol\nindex 46854bc..d84e200 100644\n--- a/contracts/MainHelper.sol\n+++ b/contracts/MainHelper.sol\n@@ -262,14 +262,14 @@ abstract contract MainHelper is WiseLowLevelHelper {\n         internal\n         view\n     {\n-        if (positionLocked[_nftIdLiquidator] == true) {\n-            revert LiquidatorIsInPowerFarm();\n-        }\n-\n         if (_nftIdLiquidator == _nftId) {\n             revert InvalidLiquidator();\n         }\n\n+        if (positionLocked[_nftIdLiquidator] == true) {\n+            revert LiquidatorIsInPowerFarm();\n+        }\n+\n         if (_nftIdLiquidator >= POSITION_NFT.getNextExpectedId()) {\n             revert InvalidLiquidator();\n         }\n```\n\nEstimated gas saved: 2100 gas units.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/MainHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./WiseLowLevelHelper.sol\";\n\nabstract contract MainHelper is WiseLowLevelHelper {\n\n    /**\n     * @dev Helper function to convert {_amount}\n     * of a certain pool with {_poolToken}\n     * into lending shares. Includes devison\n     * by zero and share security checks.\n     * Needs latest pseudo amount for accurate\n     * result.\n     */\n    function calculateLendingShares(\n        address _poolToken,\n        uint256 _amount,\n        bool _maxSharePrice\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _calculateShares(\n            lendingPoolData[_poolToken].totalDepositShares * _amount,\n            lendingPoolData[_poolToken].pseudoTotalPool,\n            _maxSharePrice\n        );\n    }\n\n    function _calculateShares(\n        uint256 _product,\n        uint256 _pseudo,\n        bool _maxSharePrice\n    )\n        private\n        pure\n        returns (uint256)\n    {\n        return _maxSharePrice == true\n            ? _product / _pseudo + 1\n            : _product / _pseudo - 1;\n    }\n\n    /**\n     * @dev Helper function to convert {_amount}\n     * of a certain pool with {_poolToken}\n     * into borrow shares. Includes devison\n     * by zero and share security checks.\n     * Needs latest pseudo amount for accurate\n     * result.\n     */\n    function calculateBorrowShares(\n        address _poolToken,\n        uint256 _amount,\n        bool _maxSharePrice\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _calculateShares(\n            borrowPoolData[_poolToken].totalBorrowShares * _amount,\n            borrowPoolData[_poolToken].pseudoTotalBorrowAmount,\n            _maxSharePrice\n        );\n    }\n\n    /**\n     * @dev Helper function to convert {_shares}\n     * of a certain pool with {_poolToken}\n     * into lending token. Includes devison\n     * by zero and share security checks.\n     * Needs latest pseudo amount for accurate\n     * result.\n     */\n    function cashoutAmount(\n        address _poolToken,\n        uint256 _shares\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _cashoutAmount(\n            _poolToken,\n            _shares\n        );\n    }\n\n    function _cashoutAmount(\n        address _poolToken,\n        uint256 _shares\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return _shares\n            * lendingPoolData[_poolToken].pseudoTotalPool\n            / lendingPoolData[_poolToken].totalDepositShares - 1;\n    }\n\n    /**\n     * @dev Helper function to convert {_shares}\n     * of a certain pool with {_poolToken}\n     * into borrow token. Includes devison\n     * by zero and share security checks.\n     * Needs latest pseudo amount for accurate\n     * result.\n     */\n    function paybackAmount(\n        address _poolToken,\n        uint256 _shares\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 product = _shares\n            * borrowPoolData[_poolToken].pseudoTotalBorrowAmount;\n\n        uint256 totalBorrowShares = borrowPoolData[_poolToken].totalBorrowShares;\n\n        return product / totalBorrowShares + 1;\n    }\n\n    /**\n     * @dev Internal helper combining one\n     * security check with lending share\n     * calculation for withdraw.\n     */\n    function _preparationsWithdraw(\n        uint256 _nftId,\n        address _caller,\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        _checkOwnerPosition(\n            _nftId,\n            _caller\n        );\n\n        return calculateLendingShares(\n            {\n                _poolToken: _poolToken,\n                _amount: _amount,\n                _maxSharePrice: true\n            }\n        );\n    }\n\n    /**\n     * @dev Internal helper calculating {_poolToken}\n     * utilization. Includes math underflow check.\n     */\n    function _getValueUtilization(\n        address _poolToken\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 totalPool = globalPoolData[_poolToken].totalPool;\n        uint256 pseudoPool = lendingPoolData[_poolToken].pseudoTotalPool;\n\n        if (totalPool >= pseudoPool) {\n            return 0;\n        }\n\n        return PRECISION_FACTOR_E18 - (PRECISION_FACTOR_E18\n            * totalPool\n            / pseudoPool\n        );\n    }\n\n    /**\n     * @dev Internal helper function setting new pool\n     * utilization by calling {_getValueUtilization}.\n     */\n    function _updateUtilization(\n        address _poolToken\n    )\n        private\n    {\n        globalPoolData[_poolToken].utilization = _getValueUtilization(\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Internal helper function checking if\n     * cleanup gathered new token to save into\n     * pool variables.\n     */\n    function _checkCleanUp(\n        uint256 _amountContract,\n        uint256 _totalPool,\n        uint256 _bareAmount\n    )\n        private\n        pure\n        returns (bool)\n    {\n        return _bareAmount + _totalPool >= _amountContract;\n    }\n\n    /**\n     * @dev Wrapper for isolation pool check.\n     */\n    function _onlyIsolationPool(\n        address _poolAddress\n    )\n        internal\n        view\n    {\n        if (verifiedIsolationPool[_poolAddress] == false) {\n            revert InvalidAction();\n        }\n    }\n\n    /**\n     * @dev Internal helper function checking if\n     * user inputs are safe.\n     */\n    function _validateIsolationPoolLiquidation(\n        address _caller,\n        uint256 _nftId,\n        uint256 _nftIdLiquidator\n    )\n        internal\n        view\n    {\n        _onlyIsolationPool(\n            _caller\n        );\n\n        if (positionLocked[_nftId] == false) {\n            revert NotPowerFarm();\n        }\n\n        _checkLiquidatorNft(\n            _nftId,\n            _nftIdLiquidator\n        );\n\n        if (POSITION_NFT.ownerOf(_nftId) != _caller) {\n            revert InvalidCaller();\n        }\n    }\n\n    function _checkLiquidatorNft(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator\n    )\n        internal\n        view\n    {\n        if (positionLocked[_nftIdLiquidator] == true) {\n            revert LiquidatorIsInPowerFarm();\n        }\n\n        if (_nftIdLiquidator == _nftId) {\n            revert InvalidLiquidator();\n        }\n\n        if (_nftIdLiquidator >= POSITION_NFT.getNextExpectedId()) {\n            revert InvalidLiquidator();\n        }\n    }\n\n    function _getBalance(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return IERC20(_tokenAddress).balanceOf(\n            address(this)\n        );\n    }\n\n    /**\n     * @dev Internal helper function checking if falsely\n     * sent token are inside the contract for the pool with\n     * {_poolToken}. If this is the case it adds those token\n     * to the pool by increasing pseudo and total amount.\n     * In context of aToken from aave pools it gathers the\n     * rebase amount from supply APY of aave pools.\n     */\n    function _cleanUp(\n        address _poolToken\n    )\n        internal\n    {\n        _validateNonZero(\n            lendingPoolData[_poolToken].totalDepositShares\n        );\n\n        uint256 amountContract = _getBalance(\n            _poolToken\n        );\n\n        uint256 totalPool = globalPoolData[_poolToken].totalPool;\n        uint256 bareToken = globalPoolData[_poolToken].totalBareToken;\n\n        if (_checkCleanUp(amountContract, totalPool, bareToken)) {\n            return;\n        }\n\n        unchecked {\n\n            uint256 difference = amountContract - (\n                totalPool + bareToken\n            );\n\n            uint256 allowedDifference = _getAllowedDifference(\n                _poolToken\n            );\n\n            if (difference > allowedDifference) {\n\n                _increaseTotalAndPseudoTotalPool(\n                    _poolToken,\n                    allowedDifference\n                );\n\n                return;\n            }\n\n            _increaseTotalAndPseudoTotalPool(\n                _poolToken,\n                difference\n            );\n        }\n    }\n\n    /**\n     * @dev Internal helper function calculating\n     * allowed increase of pseudoTotalPool to\n     * contain shareprice increase reasoanbly.\n    */\n    function _getAllowedDifference(\n        address _poolToken\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 timeDifference = block.timestamp\n            - timestampsPoolData[_poolToken].timeStamp;\n\n        return timeDifference\n            * lendingPoolData[_poolToken].pseudoTotalPool\n            * PRECISION_FACTOR_E18\n            / PRECISION_FACTOR_YEAR;\n    }\n\n    /**\n     * @dev Internal helper function for\n     * updating pools and calling {_cleanUp}.\n     * Also includes re-entrancy guard for\n     * curve pools security checks.\n     */\n    function _preparePool(\n        address _poolToken\n    )\n        internal\n    {\n        _cleanUp(\n            _poolToken\n        );\n\n        _updatePseudoTotalAmounts(\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Internal helper function for\n     * updating all lending tokens of a\n     * position.\n     */\n    function _preparationTokens(\n        mapping(uint256 => address[]) storage _userTokenData,\n        uint256 _nftId,\n        address _poolToken\n    )\n        internal\n        returns (address[] memory)\n    {\n        address[] memory tokens = _userTokenData[\n            _nftId\n        ];\n\n        _prepareTokens(\n            _poolToken,\n            tokens\n        );\n\n        return tokens;\n    }\n\n    /**\n     * @dev Internal helper function for\n     * updating pseudo amounts of a pool\n     * inside {tokens} array and sets new\n     * borrow rates.\n     */\n    function _prepareTokens(\n        address _poolToken,\n        address[] memory _tokens\n    )\n        private\n    {\n        address currentAddress;\n\n        uint256 i;\n        uint256 l = _tokens.length;\n\n        while (i < l) {\n\n            currentAddress = _tokens[i];\n\n            unchecked {\n                ++i;\n            }\n\n            if (currentAddress == _poolToken) {\n                continue;\n            }\n\n            _preparePool(\n                currentAddress\n            );\n\n            _newBorrowRate(\n                currentAddress\n            );\n        }\n    }\n\n    /**\n     * @dev Internal helper function for iterating\n     * over all tokens which may contain curvePools.\n     */\n    function _curveSecurityChecks(\n        address[] memory _lendTokens,\n        address[] memory _borrowTokens\n    )\n        internal\n    {\n        _whileLoopCurveSecurity(\n            _lendTokens\n        );\n\n        _whileLoopCurveSecurity(\n            _borrowTokens\n        );\n    }\n\n    /**\n     * @dev Internal helper function for executing while loops\n     * iterating over all tokens which may contain curvePools.\n     */\n    function _whileLoopCurveSecurity(\n        address[] memory _tokens\n    )\n        private\n    {\n        uint256 i;\n        uint256 l = _tokens.length;\n\n        while (i < l) {\n\n            WISE_SECURITY.curveSecurityCheck(\n                _tokens[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Internal helper function\n     * updating pseudo amounts and\n     * printing fee shares for the\n     * feeManager proportional to the\n     * fee percentage of the pool.\n     */\n    function _updatePseudoTotalAmounts(\n        address _poolToken\n    )\n        private\n    {\n        uint256 currentTime = block.timestamp;\n\n        uint256 bareIncrease = borrowPoolData[_poolToken].borrowRate\n            * (currentTime - timestampsPoolData[_poolToken].timeStamp)\n            * borrowPoolData[_poolToken].pseudoTotalBorrowAmount\n            + bufferIncrease[_poolToken];\n\n        if (bareIncrease < PRECISION_FACTOR_YEAR) {\n            bufferIncrease[_poolToken] = bareIncrease;\n\n            _setTimeStamp(\n                _poolToken,\n                currentTime\n            );\n\n            return;\n        }\n\n        delete bufferIncrease[_poolToken];\n\n        uint256 amountInterest = bareIncrease\n            / PRECISION_FACTOR_YEAR;\n\n        uint256 feeAmount = amountInterest\n            * globalPoolData[_poolToken].poolFee\n            / PRECISION_FACTOR_E18;\n\n        _increasePseudoTotalBorrowAmount(\n            _poolToken,\n            amountInterest\n        );\n\n        _increasePseudoTotalPool(\n            _poolToken,\n            amountInterest\n        );\n\n        if (feeAmount == 0) {\n            _setTimeStamp(\n                _poolToken,\n                currentTime\n            );\n            return;\n        }\n\n        uint256 feeShares = feeAmount\n            * lendingPoolData[_poolToken].totalDepositShares\n            / (lendingPoolData[_poolToken].pseudoTotalPool - feeAmount);\n\n        if (feeShares == 0) {\n            _setTimeStamp(\n                _poolToken,\n                currentTime\n            );\n            return;\n        }\n\n        _increasePositionLendingDeposit(\n            FEE_MANAGER_NFT,\n            _poolToken,\n            feeShares\n        );\n\n        _increaseTotalDepositShares(\n            _poolToken,\n            feeShares\n        );\n\n        _setTimeStamp(\n            _poolToken,\n            currentTime\n        );\n    }\n\n    /**\n     * @dev Internal increas function for\n     * lending shares of a postion {_nftId}\n     * and {_poolToken}.\n     */\n    function _increasePositionLendingDeposit(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _shares\n    )\n        internal\n    {\n        userLendingData[_nftId][_poolToken].shares += _shares;\n    }\n\n    /**\n     * @dev Internal decrease function for\n     * lending shares of a postion {_nftId}\n     * and {_poolToken}.\n     */\n    function _decreaseLendingShares(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _shares\n    )\n        internal\n    {\n        userLendingData[_nftId][_poolToken].shares -= _shares;\n    }\n\n    /**\n     * @dev Internal helper function adding a new\n     * {_poolToken} token to {userTokenData} if needed.\n     * Check is done by using hash maps.\n     */\n    function _addPositionTokenData(\n        uint256 _nftId,\n        address _poolToken,\n        mapping(bytes32 => bool) storage hashMap,\n        mapping(uint256 => address[]) storage userTokenData\n    )\n        internal\n    {\n        bytes32 hashData = _getHash(\n            _nftId,\n            _poolToken\n        );\n\n        if (hashMap[hashData] == true) {\n            return;\n        }\n\n        hashMap[hashData] = true;\n\n        userTokenData[_nftId].push(\n            _poolToken\n        );\n\n        if (userTokenData[_nftId].length > MAX_TOTAL_TOKEN_NUMBER) {\n            revert TooManyTokens();\n        }\n    }\n\n    /**\n     * @dev Internal helper calculating\n     * a hash out of {_nftId} and {_poolToken}\n     * using keccak256.\n     */\n    function _getHash(\n        uint256 _nftId,\n        address _poolToken\n    )\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encodePacked(\n                _nftId,\n                _poolToken\n            )\n        );\n    }\n\n    /**\n     * @dev Internal helper function deleting an\n     * entry in {_deleteLastPositionData}.\n     */\n    function _removePositionData(\n        uint256 _nftId,\n        address _poolToken,\n        function(uint256) view returns (uint256) _getPositionTokenLength,\n        function(uint256, uint256) view returns (address) _getPositionTokenByIndex,\n        function(uint256, address) internal _deleteLastPositionData,\n        bool isLending\n    )\n        private\n    {\n        uint256 length = _getPositionTokenLength(\n            _nftId\n        );\n\n        if (length == 1) {\n            _deleteLastPositionData(\n                _nftId,\n                _poolToken\n            );\n\n            return;\n        }\n\n        uint8 i;\n        uint256 endPosition = length - 1;\n\n        while (i < length) {\n\n            if (i == endPosition) {\n                _deleteLastPositionData(\n                    _nftId,\n                    _poolToken\n                );\n\n                break;\n            }\n\n            if (_getPositionTokenByIndex(_nftId, i) != _poolToken) {\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            address poolToken = _getPositionTokenByIndex(\n                _nftId,\n                endPosition\n            );\n\n            isLending == true\n                ? positionLendTokenData[_nftId][i] = poolToken\n                : positionBorrowTokenData[_nftId][i] = poolToken;\n\n            _deleteLastPositionData(\n                _nftId,\n                _poolToken\n            );\n\n            break;\n        }\n    }\n\n    /**\n     * @dev Internal helper deleting last entry\n     * of postion lending data.\n     */\n    function _deleteLastPositionLendingData(\n        uint256 _nftId,\n        address _poolToken\n    )\n        private\n    {\n        positionLendTokenData[_nftId].pop();\n        hashMapPositionLending[\n            _getHash(\n                _nftId,\n                _poolToken\n            )\n        ] = false;\n    }\n\n    /**\n     * @dev Core function combining payback\n     * logic with security checks.\n     */\n    function _corePayback(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares\n    )\n        internal\n    {\n        _updatePoolStorage(\n            _poolToken,\n            _amount,\n            _shares,\n            _increaseTotalPool,\n            _decreasePseudoTotalBorrowAmount,\n            _decreaseTotalBorrowShares\n        );\n\n        _decreasePositionMappingValue(\n            userBorrowShares,\n            _nftId,\n            _poolToken,\n            _shares\n        );\n\n        if (userBorrowShares[_nftId][_poolToken] > 0) {\n            return;\n        }\n\n        _removePositionData({\n            _nftId: _nftId,\n            _poolToken: _poolToken,\n            _getPositionTokenLength: getPositionBorrowTokenLength,\n            _getPositionTokenByIndex: getPositionBorrowTokenByIndex,\n            _deleteLastPositionData: _deleteLastPositionBorrowData,\n            isLending: false\n        });\n    }\n\n    /**\n     * @dev Internal helper deleting last entry\n     * of postion borrow data.\n     */\n    function _deleteLastPositionBorrowData(\n        uint256 _nftId,\n        address _poolToken\n    )\n        private\n    {\n        positionBorrowTokenData[_nftId].pop();\n        hashMapPositionBorrow[\n            _getHash(\n                _nftId,\n                _poolToken\n            )\n        ] = false;\n    }\n\n    /**\n     * @dev Internal helper function calculating\n     * returning if a {_poolToken} of a {_nftId}\n     * is uncollateralized.\n     */\n    function isUncollateralized(\n        uint256 _nftId,\n        address _poolToken\n    )\n        external\n        view\n        returns (bool)\n    {\n        return userLendingData[_nftId][_poolToken].unCollateralized;\n    }\n\n    /**\n     * @dev Internal helper function\n     * checking if {_nftId} as no\n     * {_poolToken} left.\n     */\n    function _checkLendingDataEmpty(\n        uint256 _nftId,\n        address _poolToken\n    )\n        private\n        view\n        returns (bool)\n    {\n        return userLendingData[_nftId][_poolToken].shares == 0\n            && pureCollateralAmount[_nftId][_poolToken] == 0;\n    }\n\n    /**\n     * @dev Internal helper function\n     * calculating new borrow rates\n     * for {_poolToken}. Uses smooth\n     * functions of the form\n     * f(x) = a * x /(p(p-x)) with\n     * p > 1E18 the {pole} and\n     * a the {mulFactor}.\n     */\n    function _calculateNewBorrowRate(\n        address _poolToken\n    )\n        internal\n    {\n        uint256 pole = borrowRatesData[_poolToken].pole;\n        uint256 utilization = globalPoolData[_poolToken].utilization;\n\n        uint256 baseDivider = pole\n            * (pole - utilization);\n\n        borrowPoolData[_poolToken].borrowRate =\n            borrowRatesData[_poolToken].multiplicativeFactor\n                * PRECISION_FACTOR_E18\n                * utilization\n                / baseDivider;\n    }\n\n    /**\n     * @dev Internal helper function\n     * updating utilization of the pool\n     * with {_poolToken}, calculating the\n     * new borrow rate and running LASA if\n     * the time intervall of three hours has\n     * passed.\n     */\n    function _newBorrowRate(\n        address _poolToken\n    )\n        internal\n    {\n        _updateUtilization(\n            _poolToken\n        );\n\n        _calculateNewBorrowRate(\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Internal helper function\n     * checking if time interval for\n     * next LASA call has passed.\n     */\n    function _aboveThreshold(\n        address _poolToken\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return block.timestamp - timestampsPoolData[_poolToken].timeStampScaling >= THREE_HOURS;\n    }\n\n    /**\n     * @dev function that tries to maximise totalDepositShares of the pool.\n     * Reacting to negative and positive feedback by changing the resonance\n     * factor of the pool. Method similar to one parameter monte-carlo methods\n     */\n    function _scalingAlgorithm(\n        address _poolToken\n    )\n        internal\n    {\n        uint256 totalShares = lendingPoolData[_poolToken].totalDepositShares;\n\n        if (algorithmData[_poolToken].maxValue <= totalShares) {\n\n            _newMaxPoolShares(\n                _poolToken,\n                totalShares\n            );\n\n            _saveUp(\n                _poolToken,\n                totalShares\n            );\n\n            return;\n        }\n\n        _resonanceOutcome(_poolToken, totalShares) == true\n            ? _resetResonanceFactor(_poolToken, totalShares)\n            : _updateResonanceFactor(_poolToken, totalShares);\n\n        _saveUp(\n            _poolToken,\n            totalShares\n        );\n    }\n\n    /**\n     * @dev Sets the new max value in shares\n     * and saves the corresponding resonance factor.\n     */\n    function _newMaxPoolShares(\n        address _poolToken,\n        uint256 _shareValue\n    )\n        private\n    {\n        _setMaxValue(\n            _poolToken,\n            _shareValue\n        );\n\n        _setBestPole(\n            _poolToken,\n            borrowRatesData[_poolToken].pole\n        );\n    }\n\n    /**\n     * @dev Internal function setting {previousValue}\n     * and {timestampScaling} for LASA of pool with\n     * {_poolToken}.\n     */\n    function _saveUp(\n        address _poolToken,\n        uint256 _shareValue\n    )\n        private\n    {\n        algorithmData[_poolToken].previousValue = _shareValue;\n\n        _setTimeStampScaling(\n            _poolToken,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Returns bool to determine if resonance\n     * factor needs to be reset to last best value.\n     */\n    function _resonanceOutcome(\n        address _poolToken,\n        uint256 _shareValue\n    )\n        private\n        view\n        returns (bool)\n    {\n        return _shareValue < THRESHOLD_RESET_RESONANCE_FACTOR\n            * algorithmData[_poolToken].maxValue\n            / PRECISION_FACTOR_E18;\n    }\n\n    /**\n     * @dev Resets resonance factor to old best value when system\n     * evolves into too bad state and sets current totalDepositShares\n     * amount to new maxPoolShares to exclude eternal loops and that\n     * unorganic peaks do not set maxPoolShares forever.\n     */\n    function _resetResonanceFactor(\n        address _poolToken,\n        uint256 _shareValue\n    )\n        private\n    {\n        _setPole(\n            _poolToken,\n            algorithmData[_poolToken].bestPole\n        );\n\n        _setMaxValue(\n            _poolToken,\n            _shareValue\n        );\n\n        _revertDirectionState(\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Reverts the flag for stepping direction from LASA.\n     */\n    function _revertDirectionState(\n        address _poolToken\n    )\n        private\n    {\n        _setIncreasePole(\n            _poolToken,\n            !algorithmData[_poolToken].increasePole\n        );\n    }\n\n    /**\n     * @dev Function combining all possible stepping scenarios.\n     * Depending how share values has changed compared to last time.\n     */\n    function _updateResonanceFactor(\n        address _poolToken,\n        uint256 _shareValues\n    )\n        private\n    {\n        _shareValues < THRESHOLD_SWITCH_DIRECTION\n            * algorithmData[_poolToken].previousValue\n            / PRECISION_FACTOR_E18\n            ? _reversedResonanceFactor(_poolToken)\n            : _changingResonanceFactor(_poolToken);\n    }\n\n    /**\n     * @dev Does a revert stepping and swaps stepping state in opposite flag.\n     */\n    function _reversedResonanceFactor(\n        address _poolToken\n    )\n        private\n    {\n        algorithmData[_poolToken].increasePole\n            ? _decreaseResonanceFactor(_poolToken)\n            : _increaseResonanceFactor(_poolToken);\n\n        _revertDirectionState(\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Increasing or decresing resonance factor depending on flag value.\n     */\n    function _changingResonanceFactor(\n        address _poolToken\n    )\n        private\n    {\n        algorithmData[_poolToken].increasePole\n            ? _increaseResonanceFactor(_poolToken)\n            : _decreaseResonanceFactor(_poolToken);\n    }\n\n    /**\n     * @dev stepping function increasing the resonance factor\n     * depending on the time past in the last time interval.\n     * Checks if current resonance factor is bigger than max value.\n     * If this is the case sets current value to maximal value\n     */\n    function _increaseResonanceFactor(\n        address _poolToken\n    )\n        private\n    {\n        BorrowRatesEntry memory borrowData = borrowRatesData[\n            _poolToken\n        ];\n\n        uint256 delta = borrowData.deltaPole\n            * (block.timestamp - timestampsPoolData[_poolToken].timeStampScaling);\n\n        uint256 sum = delta\n            + borrowData.pole;\n\n        uint256 setValue = sum > borrowData.maxPole\n            ? borrowData.maxPole\n            : sum;\n\n        _setPole(\n            _poolToken,\n            setValue\n        );\n    }\n\n    /**\n     * @dev Stepping function decresing the resonance factor\n     * depending on the time past in the last time interval.\n     * Checks if current resonance factor undergoes the min value,\n     * if this is the case sets current value to minimal value.\n     */\n    function _decreaseResonanceFactor(\n        address _poolToken\n    )\n        private\n    {\n        uint256 minValue = borrowRatesData[_poolToken].minPole;\n\n        uint256 delta = borrowRatesData[_poolToken].deltaPole\n            * (block.timestamp - timestampsPoolData[_poolToken].timeStampScaling);\n\n        uint256 sub = borrowRatesData[_poolToken].pole > delta\n            ? borrowRatesData[_poolToken].pole - delta\n            : 0;\n\n        uint256 setValue = sub < minValue\n            ? minValue\n            : sub;\n\n        _setPole(\n            _poolToken,\n            setValue\n        );\n    }\n\n    /**\n     * @dev Internal helper function for removing token address\n     * from lending data array if all shares are removed. When\n     * feeManager (nftId = 0) is calling this function is skipped\n     * to save gas for continues fee accounting.\n     */\n    function _removeEmptyLendingData(\n        uint256 _nftId,\n        address _poolToken\n    )\n        internal\n    {\n        if (_nftId == 0) {\n            return;\n        }\n\n        if (_checkLendingDataEmpty(_nftId, _poolToken) == false) {\n            return;\n        }\n\n        _removePositionData({\n            _nftId: _nftId,\n            _poolToken: _poolToken,\n            _getPositionTokenLength: getPositionLendingTokenLength,\n            _getPositionTokenByIndex: getPositionLendingTokenByIndex,\n            _deleteLastPositionData: _deleteLastPositionLendingData,\n            isLending: true\n        });\n    }\n\n    /**\n     * @dev Internal helper function grouping several function\n     * calls into one function for refactoring and code size\n     * reduction.\n     */\n    function _updatePoolStorage(\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares,\n        function(address, uint256) functionAmountA,\n        function(address, uint256) functionAmountB,\n        function(address, uint256) functionSharesA\n    )\n        internal\n    {\n        functionAmountA(\n            _poolToken,\n            _amount\n        );\n\n        functionAmountB(\n            _poolToken,\n            _amount\n        );\n\n        functionSharesA(\n            _poolToken,\n            _shares\n        );\n    }\n}"
    }
  ]
}