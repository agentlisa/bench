{
  "Title": "[H-04] Taiko L1 - Proposer can maliciously cause loss of funds by forcing someone else to pay prover's fee",
  "Content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/0d081a40e0b9637eddf8e760fabbecc250f23599/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L113-L116> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/0d081a40e0b9637eddf8e760fabbecc250f23599/packages/protocol/contracts/L1/libs/LibProposing.sol#L85-L87> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/0d081a40e0b9637eddf8e760fabbecc250f23599/packages/protocol/contracts/L1/libs/LibProposing.sol#L249-L255>\n\nProposal of new blocks triggers a call to proposeBlock in the libProposing library. In that function, there is this the following block of code:\n\n            if (params.coinbase == address(0)) {\n            params.coinbase = msg.sender;\n        }\n\nThis sets the params.coinbase variable set by the caller of the function to be the msg.sender if it was empty.\n\nAs part of the process of proposal, hooks can be called of type AssignmentHook. An assignment hook's onBlockProposed will be triggered as follows:\n\n                    // When a hook is called, all ether in this contract will be send to the hook.\n                // If the ether sent to the hook is not used entirely, the hook shall send the Ether\n                // back to this contract for the next hook to use.\n                // Proposers shall choose use extra hooks wisely.\n                IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }(\n                    blk, meta_, params.hookCalls[i].data\n                );\n\nNotice how the meta data is passed to this function. Part of the function of the onBlockProposed is to pay the assigned prover their fee and the payee should be the current proposer of the block. this is done as follows:\n\n            // The proposer irrevocably pays a fee to the assigned prover, either in\n        // Ether or ERC20 tokens.\n        if (assignment.feeToken == address(0)) {\n            // Paying Ether\n            _blk.assignedProver.sendEther(proverFee, MAX_GAS_PAYING_PROVER);\n        } else {\n            // Paying ERC20 tokens\n            IERC20(assignment.feeToken).safeTransferFrom(\n                _meta.coinbase, _blk.assignedProver, proverFee\n            );\n        }\n\nNotice how if the payment is in ERC20 tokens, the payee will be the variable  \\_meta.coinbase, and like we showed earlier, this can be set to any arbitrary address by the proposer. This can lead to a scenario as such:\n\n1.  proposer A approves the assignmentHook contract to spend a portion of their tokens, the allowance is set higher than the actual fee they will be paying.\n2.  proposer A proposes a block, and a fee is charged and payed to the assigned prover, but there remains allowance that the assignment hook contract can still use.\n3.  proposer B proposes a block and sets params.coinbase as the the address of proposer A.\n4.  proposer A address will be the payee of the fee for the assigned prover for the block proposed by proposer B.\n\nThe scenario above describes how someone can be forced maliciously to pay fees for block proposals by other actors.\n\n### Recommended Mitigation Steps\n\nA simple fix to this to ensure the block proposer will always be the msg.sender, as such:\n\n        if (params.coinbase == address(0 || params.coinbase != msg.sender)) {\n            params.coinbase = msg.sender;\n        }\n\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/163#issuecomment-2032257802):**\n > This is a valid bug report. It has been fixed here: https://github.com/taikoxyz/taiko-mono/pull/16327\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/L1/hooks/AssignmentHook.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../common/EssentialContract.sol\";\nimport \"../../libs/LibAddress.sol\";\nimport \"../ITaikoL1.sol\";\nimport \"./IHook.sol\";\n\n/// @title AssignmentHook\n/// @notice A hook that handles prover assignment verification and fee processing.\n/// @custom:security-contact security@taiko.xyz\ncontract AssignmentHook is EssentialContract, IHook {\n    using LibAddress for address;\n    using SafeERC20 for IERC20;\n\n    struct ProverAssignment {\n        address feeToken;\n        uint64 expiry;\n        uint64 maxBlockId;\n        uint64 maxProposedIn;\n        bytes32 metaHash;\n        bytes32 parentMetaHash;\n        TaikoData.TierFee[] tierFees;\n        bytes signature;\n    }\n\n    struct Input {\n        ProverAssignment assignment;\n        uint256 tip; // A tip to L1 block builder\n    }\n\n    /// @notice Max gas paying the prover.\n    /// @dev This should be large enough to prevent the worst cases for the prover.\n    /// To assure a trustless relationship between the proposer and the prover it's\n    /// the prover's job to make sure it can get paid within this limit.\n    uint256 public constant MAX_GAS_PAYING_PROVER = 50_000;\n\n    uint256[50] private __gap;\n\n    /// @notice Emitted when a block is assigned to a prover.\n    /// @param assignedProver The address of the assigned prover.\n    /// @param meta The metadata of the assigned block.\n    /// @param assignment The prover assignment.\n    event BlockAssigned(\n        address indexed assignedProver, TaikoData.BlockMetadata meta, ProverAssignment assignment\n    );\n\n    error HOOK_ASSIGNMENT_EXPIRED();\n    error HOOK_ASSIGNMENT_INVALID_SIG();\n    error HOOK_TIER_NOT_FOUND();\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    function init(address _owner, address _addressManager) external initializer {\n        __Essential_init(_owner, _addressManager);\n    }\n\n    /// @inheritdoc IHook\n    function onBlockProposed(\n        TaikoData.Block memory _blk,\n        TaikoData.BlockMetadata memory _meta,\n        bytes memory _data\n    )\n        external\n        payable\n        nonReentrant\n        onlyFromNamed(\"taiko\")\n    {\n        // Note that\n        // - 'msg.sender' is the TaikoL1 contract address\n        // - 'block.coinbase' is the L1 block builder\n        // - 'meta.coinbase' is the L2 block proposer\n\n        Input memory input = abi.decode(_data, (Input));\n        ProverAssignment memory assignment = input.assignment;\n\n        // Check assignment validity\n        if (\n            block.timestamp > assignment.expiry\n                || assignment.metaHash != 0 && _blk.metaHash != assignment.metaHash\n                || assignment.parentMetaHash != 0 && _meta.parentMetaHash != assignment.parentMetaHash\n                || assignment.maxBlockId != 0 && _meta.id > assignment.maxBlockId\n                || assignment.maxProposedIn != 0 && block.number > assignment.maxProposedIn\n        ) {\n            revert HOOK_ASSIGNMENT_EXPIRED();\n        }\n\n        // Hash the assignment with the blobHash, this hash will be signed by\n        // the prover, therefore, we add a string as a prefix.\n        address taikoL1Address = msg.sender;\n        bytes32 hash = hashAssignment(assignment, taikoL1Address, _meta.blobHash);\n\n        if (!_blk.assignedProver.isValidSignature(hash, assignment.signature)) {\n            revert HOOK_ASSIGNMENT_INVALID_SIG();\n        }\n\n        // Send the liveness bond to the Taiko contract\n        IERC20 tko = IERC20(resolve(\"taiko_token\", false));\n        tko.transferFrom(_blk.assignedProver, taikoL1Address, _blk.livenessBond);\n\n        // Find the prover fee using the minimal tier\n        uint256 proverFee = _getProverFee(assignment.tierFees, _meta.minTier);\n\n        // The proposer irrevocably pays a fee to the assigned prover, either in\n        // Ether or ERC20 tokens.\n        if (assignment.feeToken == address(0)) {\n            // Paying Ether\n            _blk.assignedProver.sendEther(proverFee, MAX_GAS_PAYING_PROVER);\n        } else {\n            // Paying ERC20 tokens\n            IERC20(assignment.feeToken).safeTransferFrom(\n                _meta.coinbase, _blk.assignedProver, proverFee\n            );\n        }\n\n        // block.coinbase can be address(0) in tests\n        if (input.tip != 0 && block.coinbase != address(0)) {\n            address(block.coinbase).sendEther(input.tip);\n        }\n\n        // Send all remaining Ether back to TaikoL1 contract\n        if (address(this).balance > 0) {\n            taikoL1Address.sendEther(address(this).balance);\n        }\n\n        emit BlockAssigned(_blk.assignedProver, _meta, assignment);\n    }\n\n    /// @notice Hashes the prover assignment.\n    /// @param _assignment The prover assignment.\n    /// @param _taikoL1Address The address of the TaikoL1 contract.\n    /// @param _blobHash The blob hash.\n    /// @return The hash of the prover assignment.\n    function hashAssignment(\n        ProverAssignment memory _assignment,\n        address _taikoL1Address,\n        bytes32 _blobHash\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encode(\n                \"PROVER_ASSIGNMENT\",\n                ITaikoL1(_taikoL1Address).getConfig().chainId,\n                _taikoL1Address,\n                address(this),\n                _assignment.metaHash,\n                _assignment.parentMetaHash,\n                _blobHash,\n                _assignment.feeToken,\n                _assignment.expiry,\n                _assignment.maxBlockId,\n                _assignment.maxProposedIn,\n                _assignment.tierFees\n            )\n        );\n    }\n\n    function _getProverFee(\n        TaikoData.TierFee[] memory _tierFees,\n        uint16 _tierId\n    )\n        private\n        pure\n        returns (uint256)\n    {\n        for (uint256 i; i < _tierFees.length; ++i) {\n            if (_tierFees[i].tier == _tierId) return _tierFees[i].fee;\n        }\n        revert HOOK_TIER_NOT_FOUND();\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L1/libs/LibProposing.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibAddress.sol\";\nimport \"../hooks/IHook.sol\";\nimport \"../tiers/ITierProvider.sol\";\nimport \"../TaikoData.sol\";\nimport \"./LibDepositing.sol\";\n\n/// @title LibProposing\n/// @notice A library for handling block proposals in the Taiko protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibProposing {\n    using LibAddress for address;\n\n    /// @notice The maximum number of bytes allowed per blob.\n    /// @dev According to EIP4844, each blob has up to 4096 field elements, and each\n    /// field element has 32 bytes.\n    uint256 public constant MAX_BYTES_PER_BLOB = 4096 * 32;\n\n    // Warning: Any events defined here must also be defined in TaikoEvents.sol.\n    /// @notice Emitted when a block is proposed.\n    /// @param blockId The ID of the proposed block.\n    /// @param assignedProver The address of the assigned prover.\n    /// @param livenessBond The liveness bond of the proposed block.\n    /// @param meta The metadata of the proposed block.\n    /// @param depositsProcessed The EthDeposit array about processed deposits in this proposed\n    /// block.\n    event BlockProposed(\n        uint256 indexed blockId,\n        address indexed assignedProver,\n        uint96 livenessBond,\n        TaikoData.BlockMetadata meta,\n        TaikoData.EthDeposit[] depositsProcessed\n    );\n\n    /// @notice Emitted when a blob is cached.\n    /// @param blobHash The hash of the cached blob.\n    event BlobCached(bytes32 blobHash);\n\n    // Warning: Any errors defined here must also be defined in TaikoErrors.sol.\n    error L1_BLOB_FOR_DA_DISABLED();\n    error L1_BLOB_NOT_FOUND();\n    error L1_BLOB_NOT_REUSABLE();\n    error L1_BLOB_REUSE_DISABLED();\n    error L1_INVALID_HOOK();\n    error L1_INVALID_PARAM();\n    error L1_INVALID_PROVER();\n    error L1_LIVENESS_BOND_NOT_RECEIVED();\n    error L1_PROPOSER_NOT_EOA();\n    error L1_TOO_MANY_BLOCKS();\n    error L1_TXLIST_OFFSET();\n    error L1_TXLIST_SIZE();\n    error L1_UNAUTHORIZED();\n    error L1_UNEXPECTED_PARENT();\n\n    /// @dev Proposes a Taiko L2 block.\n    /// @param _state Current TaikoData.State.\n    /// @param _config Actual TaikoData.Config.\n    /// @param _resolver Address resolver interface.\n    /// @param _data Encoded data bytes containing the block params.\n    /// @param _txList Transaction list bytes (if not blob).\n    /// @return meta_ The constructed block's metadata.\n    /// @return deposits_ The EthDeposit array about processed deposits in this proposed\n    /// block.\n    function proposeBlock(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        bytes calldata _data,\n        bytes calldata _txList\n    )\n        internal\n        returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)\n    {\n        TaikoData.BlockParams memory params = abi.decode(_data, (TaikoData.BlockParams));\n\n        // We need a prover that will submit proofs after the block has been submitted\n        if (params.assignedProver == address(0)) {\n            revert L1_INVALID_PROVER();\n        }\n\n        if (params.coinbase == address(0)) {\n            params.coinbase = msg.sender;\n        }\n\n        // Taiko, as a Based Rollup, enables permissionless block proposals.\n        // However, if the \"proposer\" address is set to a non-zero value, we\n        // ensure that only that specific address has the authority to propose\n        // blocks.\n        TaikoData.SlotB memory b = _state.slotB;\n        if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED();\n\n        // It's essential to ensure that the ring buffer for proposed blocks\n        // still has space for at least one more block.\n        if (b.numBlocks >= b.lastVerifiedBlockId + _config.blockMaxProposals + 1) {\n            revert L1_TOO_MANY_BLOCKS();\n        }\n\n        bytes32 parentMetaHash =\n            _state.blocks[(b.numBlocks - 1) % _config.blockRingBufferSize].metaHash;\n\n        // Check if parent block has the right meta hash\n        // This is to allow the proposer to make sure the block builds on the expected latest chain\n        // state\n        if (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) {\n            revert L1_UNEXPECTED_PARENT();\n        }\n\n        // Each transaction must handle a specific quantity of L1-to-L2\n        // Ether deposits.\n        deposits_ = LibDepositing.processDeposits(_state, _config, params.coinbase);\n\n        // Initialize metadata to compute a metaHash, which forms a part of\n        // the block data to be stored on-chain for future integrity checks.\n        // If we choose to persist all data fields in the metadata, it will\n        // require additional storage slots.\n        unchecked {\n            meta_ = TaikoData.BlockMetadata({\n                l1Hash: blockhash(block.number - 1),\n                difficulty: 0, // to be initialized below\n                blobHash: 0, // to be initialized below\n                extraData: params.extraData,\n                depositsHash: keccak256(abi.encode(deposits_)),\n                coinbase: params.coinbase,\n                id: b.numBlocks,\n                gasLimit: _config.blockMaxGasLimit,\n                timestamp: uint64(block.timestamp),\n                l1Height: uint64(block.number - 1),\n                txListByteOffset: 0, // to be initialized below\n                txListByteSize: 0, // to be initialized below\n                minTier: 0, // to be initialized below\n                blobUsed: _txList.length == 0,\n                parentMetaHash: parentMetaHash\n            });\n        }\n\n        // Update certain meta fields\n        if (meta_.blobUsed) {\n            if (!_config.blobAllowedForDA) revert L1_BLOB_FOR_DA_DISABLED();\n\n            if (params.blobHash != 0) {\n                if (!_config.blobReuseEnabled) revert L1_BLOB_REUSE_DISABLED();\n\n                // We try to reuse an old blob\n                if (!isBlobReusable(_state, _config, params.blobHash)) {\n                    revert L1_BLOB_NOT_REUSABLE();\n                }\n                meta_.blobHash = params.blobHash;\n            } else {\n                // Always use the first blob in this transaction. If the\n                // proposeBlock functions are called more than once in the same\n                // L1 transaction, these multiple L2 blocks will share the same\n                // blob.\n                meta_.blobHash = blobhash(0);\n\n                if (meta_.blobHash == 0) revert L1_BLOB_NOT_FOUND();\n\n                // Depends on the blob data price, it may not make sense to\n                // cache the blob which costs 20,000 (sstore) + 631 (event)\n                // extra gas.\n                if (_config.blobReuseEnabled && params.cacheBlobForReuse) {\n                    _state.reusableBlobs[meta_.blobHash] = block.timestamp;\n                    emit BlobCached(meta_.blobHash);\n                }\n            }\n\n            // Check that the txList data range is within the max size of a blob\n            if (uint256(params.txListByteOffset) + params.txListByteSize > MAX_BYTES_PER_BLOB) {\n                revert L1_TXLIST_OFFSET();\n            }\n\n            meta_.txListByteOffset = params.txListByteOffset;\n            meta_.txListByteSize = params.txListByteSize;\n        } else {\n            // The proposer must be an Externally Owned Account (EOA) for\n            // calldata usage. This ensures that the transaction is not an\n            // internal one, making calldata retrieval more straightforward for\n            // Taiko node software.\n            if (!LibAddress.isSenderEOA()) revert L1_PROPOSER_NOT_EOA();\n\n            // The txList is the full byte array without any offset\n            if (params.txListByteOffset != 0) {\n                revert L1_INVALID_PARAM();\n            }\n\n            meta_.blobHash = keccak256(_txList);\n            meta_.txListByteOffset = 0;\n            meta_.txListByteSize = uint24(_txList.length);\n        }\n\n        // Check that the tx length is non-zero and within the supported range\n        if (meta_.txListByteSize == 0 || meta_.txListByteSize > _config.blockMaxTxListBytes) {\n            revert L1_TXLIST_SIZE();\n        }\n\n        // Following the Merge, the L1 mixHash incorporates the\n        // prevrandao value from the beacon chain. Given the possibility\n        // of multiple Taiko blocks being proposed within a single\n        // Ethereum block, we choose to introduce a salt to this random\n        // number as the L2 mixHash.\n        meta_.difficulty = keccak256(abi.encodePacked(block.prevrandao, b.numBlocks, block.number));\n\n        // Use the difficulty as a random number\n        meta_.minTier = ITierProvider(_resolver.resolve(\"tier_provider\", false)).getMinTier(\n            uint256(meta_.difficulty)\n        );\n\n        // Create the block that will be stored onchain\n        TaikoData.Block memory blk = TaikoData.Block({\n            metaHash: keccak256(abi.encode(meta_)),\n            // Safeguard the liveness bond to ensure its preservation,\n            // particularly in scenarios where it might be altered after the\n            // block's proposal but before it has been proven or verified.\n            livenessBond: _config.livenessBond,\n            blockId: b.numBlocks,\n            proposedAt: meta_.timestamp,\n            proposedIn: uint64(block.number),\n            // For a new block, the next transition ID is always 1, not 0.\n            nextTransitionId: 1,\n            // For unverified block, its verifiedTransitionId is always 0.\n            verifiedTransitionId: 0,\n            assignedProver: params.assignedProver\n        });\n\n        // Store the block in the ring buffer\n        _state.blocks[b.numBlocks % _config.blockRingBufferSize] = blk;\n\n        // Increment the counter (cursor) by 1.\n        unchecked {\n            ++_state.slotB.numBlocks;\n        }\n\n        {\n            IERC20 tko = IERC20(_resolver.resolve(\"taiko_token\", false));\n            uint256 tkoBalance = tko.balanceOf(address(this));\n\n            // Run all hooks.\n            // Note that address(this).balance has been updated with msg.value,\n            // prior to any code in this function has been executed.\n            address prevHook;\n            for (uint256 i; i < params.hookCalls.length; ++i) {\n                if (uint160(prevHook) >= uint160(params.hookCalls[i].hook)) {\n                    revert L1_INVALID_HOOK();\n                }\n\n                // When a hook is called, all ether in this contract will be send to the hook.\n                // If the ether sent to the hook is not used entirely, the hook shall send the Ether\n                // back to this contract for the next hook to use.\n                // Proposers shall choose use extra hooks wisely.\n                IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }(\n                    blk, meta_, params.hookCalls[i].data\n                );\n\n                prevHook = params.hookCalls[i].hook;\n            }\n            // Refund Ether\n            if (address(this).balance != 0) {\n                msg.sender.sendEther(address(this).balance);\n            }\n\n            // Check that after hooks, the Taiko Token balance of this contract\n            // have increased by the same amount as _config.livenessBond (to prevent)\n            // multiple draining payments by a malicious proposer nesting the same\n            // hook.\n            if (tko.balanceOf(address(this)) != tkoBalance + _config.livenessBond) {\n                revert L1_LIVENESS_BOND_NOT_RECEIVED();\n            }\n        }\n\n        emit BlockProposed({\n            blockId: blk.blockId,\n            assignedProver: blk.assignedProver,\n            livenessBond: _config.livenessBond,\n            meta: meta_,\n            depositsProcessed: deposits_\n        });\n    }\n\n    /// @notice Checks if a blob is reusable.\n    /// @param _state Current TaikoData.State.\n    /// @param _config The TaikoData.Config.\n    /// @param _blobHash The blob hash\n    /// @return true if the blob is reusable, false otherwise.\n    function isBlobReusable(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        bytes32 _blobHash\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return _state.reusableBlobs[_blobHash] + _config.blobExpiry > block.timestamp;\n    }\n\n    function _isProposerPermitted(\n        TaikoData.SlotB memory _slotB,\n        IAddressResolver _resolver\n    )\n        private\n        view\n        returns (bool)\n    {\n        if (_slotB.numBlocks == 1) {\n            // Only proposer_one can propose the first block after genesis\n            address proposerOne = _resolver.resolve(\"proposer_one\", true);\n            if (proposerOne != address(0) && msg.sender != proposerOne) {\n                return false;\n            }\n        }\n\n        address proposer = _resolver.resolve(\"proposer\", true);\n        return proposer == address(0) || msg.sender == proposer;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L1/libs/LibProposing.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibAddress.sol\";\nimport \"../hooks/IHook.sol\";\nimport \"../tiers/ITierProvider.sol\";\nimport \"../TaikoData.sol\";\nimport \"./LibDepositing.sol\";\n\n/// @title LibProposing\n/// @notice A library for handling block proposals in the Taiko protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibProposing {\n    using LibAddress for address;\n\n    /// @notice The maximum number of bytes allowed per blob.\n    /// @dev According to EIP4844, each blob has up to 4096 field elements, and each\n    /// field element has 32 bytes.\n    uint256 public constant MAX_BYTES_PER_BLOB = 4096 * 32;\n\n    // Warning: Any events defined here must also be defined in TaikoEvents.sol.\n    /// @notice Emitted when a block is proposed.\n    /// @param blockId The ID of the proposed block.\n    /// @param assignedProver The address of the assigned prover.\n    /// @param livenessBond The liveness bond of the proposed block.\n    /// @param meta The metadata of the proposed block.\n    /// @param depositsProcessed The EthDeposit array about processed deposits in this proposed\n    /// block.\n    event BlockProposed(\n        uint256 indexed blockId,\n        address indexed assignedProver,\n        uint96 livenessBond,\n        TaikoData.BlockMetadata meta,\n        TaikoData.EthDeposit[] depositsProcessed\n    );\n\n    /// @notice Emitted when a blob is cached.\n    /// @param blobHash The hash of the cached blob.\n    event BlobCached(bytes32 blobHash);\n\n    // Warning: Any errors defined here must also be defined in TaikoErrors.sol.\n    error L1_BLOB_FOR_DA_DISABLED();\n    error L1_BLOB_NOT_FOUND();\n    error L1_BLOB_NOT_REUSABLE();\n    error L1_BLOB_REUSE_DISABLED();\n    error L1_INVALID_HOOK();\n    error L1_INVALID_PARAM();\n    error L1_INVALID_PROVER();\n    error L1_LIVENESS_BOND_NOT_RECEIVED();\n    error L1_PROPOSER_NOT_EOA();\n    error L1_TOO_MANY_BLOCKS();\n    error L1_TXLIST_OFFSET();\n    error L1_TXLIST_SIZE();\n    error L1_UNAUTHORIZED();\n    error L1_UNEXPECTED_PARENT();\n\n    /// @dev Proposes a Taiko L2 block.\n    /// @param _state Current TaikoData.State.\n    /// @param _config Actual TaikoData.Config.\n    /// @param _resolver Address resolver interface.\n    /// @param _data Encoded data bytes containing the block params.\n    /// @param _txList Transaction list bytes (if not blob).\n    /// @return meta_ The constructed block's metadata.\n    /// @return deposits_ The EthDeposit array about processed deposits in this proposed\n    /// block.\n    function proposeBlock(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        bytes calldata _data,\n        bytes calldata _txList\n    )\n        internal\n        returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)\n    {\n        TaikoData.BlockParams memory params = abi.decode(_data, (TaikoData.BlockParams));\n\n        // We need a prover that will submit proofs after the block has been submitted\n        if (params.assignedProver == address(0)) {\n            revert L1_INVALID_PROVER();\n        }\n\n        if (params.coinbase == address(0)) {\n            params.coinbase = msg.sender;\n        }\n\n        // Taiko, as a Based Rollup, enables permissionless block proposals.\n        // However, if the \"proposer\" address is set to a non-zero value, we\n        // ensure that only that specific address has the authority to propose\n        // blocks.\n        TaikoData.SlotB memory b = _state.slotB;\n        if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED();\n\n        // It's essential to ensure that the ring buffer for proposed blocks\n        // still has space for at least one more block.\n        if (b.numBlocks >= b.lastVerifiedBlockId + _config.blockMaxProposals + 1) {\n            revert L1_TOO_MANY_BLOCKS();\n        }\n\n        bytes32 parentMetaHash =\n            _state.blocks[(b.numBlocks - 1) % _config.blockRingBufferSize].metaHash;\n\n        // Check if parent block has the right meta hash\n        // This is to allow the proposer to make sure the block builds on the expected latest chain\n        // state\n        if (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) {\n            revert L1_UNEXPECTED_PARENT();\n        }\n\n        // Each transaction must handle a specific quantity of L1-to-L2\n        // Ether deposits.\n        deposits_ = LibDepositing.processDeposits(_state, _config, params.coinbase);\n\n        // Initialize metadata to compute a metaHash, which forms a part of\n        // the block data to be stored on-chain for future integrity checks.\n        // If we choose to persist all data fields in the metadata, it will\n        // require additional storage slots.\n        unchecked {\n            meta_ = TaikoData.BlockMetadata({\n                l1Hash: blockhash(block.number - 1),\n                difficulty: 0, // to be initialized below\n                blobHash: 0, // to be initialized below\n                extraData: params.extraData,\n                depositsHash: keccak256(abi.encode(deposits_)),\n                coinbase: params.coinbase,\n                id: b.numBlocks,\n                gasLimit: _config.blockMaxGasLimit,\n                timestamp: uint64(block.timestamp),\n                l1Height: uint64(block.number - 1),\n                txListByteOffset: 0, // to be initialized below\n                txListByteSize: 0, // to be initialized below\n                minTier: 0, // to be initialized below\n                blobUsed: _txList.length == 0,\n                parentMetaHash: parentMetaHash\n            });\n        }\n\n        // Update certain meta fields\n        if (meta_.blobUsed) {\n            if (!_config.blobAllowedForDA) revert L1_BLOB_FOR_DA_DISABLED();\n\n            if (params.blobHash != 0) {\n                if (!_config.blobReuseEnabled) revert L1_BLOB_REUSE_DISABLED();\n\n                // We try to reuse an old blob\n                if (!isBlobReusable(_state, _config, params.blobHash)) {\n                    revert L1_BLOB_NOT_REUSABLE();\n                }\n                meta_.blobHash = params.blobHash;\n            } else {\n                // Always use the first blob in this transaction. If the\n                // proposeBlock functions are called more than once in the same\n                // L1 transaction, these multiple L2 blocks will share the same\n                // blob.\n                meta_.blobHash = blobhash(0);\n\n                if (meta_.blobHash == 0) revert L1_BLOB_NOT_FOUND();\n\n                // Depends on the blob data price, it may not make sense to\n                // cache the blob which costs 20,000 (sstore) + 631 (event)\n                // extra gas.\n                if (_config.blobReuseEnabled && params.cacheBlobForReuse) {\n                    _state.reusableBlobs[meta_.blobHash] = block.timestamp;\n                    emit BlobCached(meta_.blobHash);\n                }\n            }\n\n            // Check that the txList data range is within the max size of a blob\n            if (uint256(params.txListByteOffset) + params.txListByteSize > MAX_BYTES_PER_BLOB) {\n                revert L1_TXLIST_OFFSET();\n            }\n\n            meta_.txListByteOffset = params.txListByteOffset;\n            meta_.txListByteSize = params.txListByteSize;\n        } else {\n            // The proposer must be an Externally Owned Account (EOA) for\n            // calldata usage. This ensures that the transaction is not an\n            // internal one, making calldata retrieval more straightforward for\n            // Taiko node software.\n            if (!LibAddress.isSenderEOA()) revert L1_PROPOSER_NOT_EOA();\n\n            // The txList is the full byte array without any offset\n            if (params.txListByteOffset != 0) {\n                revert L1_INVALID_PARAM();\n            }\n\n            meta_.blobHash = keccak256(_txList);\n            meta_.txListByteOffset = 0;\n            meta_.txListByteSize = uint24(_txList.length);\n        }\n\n        // Check that the tx length is non-zero and within the supported range\n        if (meta_.txListByteSize == 0 || meta_.txListByteSize > _config.blockMaxTxListBytes) {\n            revert L1_TXLIST_SIZE();\n        }\n\n        // Following the Merge, the L1 mixHash incorporates the\n        // prevrandao value from the beacon chain. Given the possibility\n        // of multiple Taiko blocks being proposed within a single\n        // Ethereum block, we choose to introduce a salt to this random\n        // number as the L2 mixHash.\n        meta_.difficulty = keccak256(abi.encodePacked(block.prevrandao, b.numBlocks, block.number));\n\n        // Use the difficulty as a random number\n        meta_.minTier = ITierProvider(_resolver.resolve(\"tier_provider\", false)).getMinTier(\n            uint256(meta_.difficulty)\n        );\n\n        // Create the block that will be stored onchain\n        TaikoData.Block memory blk = TaikoData.Block({\n            metaHash: keccak256(abi.encode(meta_)),\n            // Safeguard the liveness bond to ensure its preservation,\n            // particularly in scenarios where it might be altered after the\n            // block's proposal but before it has been proven or verified.\n            livenessBond: _config.livenessBond,\n            blockId: b.numBlocks,\n            proposedAt: meta_.timestamp,\n            proposedIn: uint64(block.number),\n            // For a new block, the next transition ID is always 1, not 0.\n            nextTransitionId: 1,\n            // For unverified block, its verifiedTransitionId is always 0.\n            verifiedTransitionId: 0,\n            assignedProver: params.assignedProver\n        });\n\n        // Store the block in the ring buffer\n        _state.blocks[b.numBlocks % _config.blockRingBufferSize] = blk;\n\n        // Increment the counter (cursor) by 1.\n        unchecked {\n            ++_state.slotB.numBlocks;\n        }\n\n        {\n            IERC20 tko = IERC20(_resolver.resolve(\"taiko_token\", false));\n            uint256 tkoBalance = tko.balanceOf(address(this));\n\n            // Run all hooks.\n            // Note that address(this).balance has been updated with msg.value,\n            // prior to any code in this function has been executed.\n            address prevHook;\n            for (uint256 i; i < params.hookCalls.length; ++i) {\n                if (uint160(prevHook) >= uint160(params.hookCalls[i].hook)) {\n                    revert L1_INVALID_HOOK();\n                }\n\n                // When a hook is called, all ether in this contract will be send to the hook.\n                // If the ether sent to the hook is not used entirely, the hook shall send the Ether\n                // back to this contract for the next hook to use.\n                // Proposers shall choose use extra hooks wisely.\n                IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }(\n                    blk, meta_, params.hookCalls[i].data\n                );\n\n                prevHook = params.hookCalls[i].hook;\n            }\n            // Refund Ether\n            if (address(this).balance != 0) {\n                msg.sender.sendEther(address(this).balance);\n            }\n\n            // Check that after hooks, the Taiko Token balance of this contract\n            // have increased by the same amount as _config.livenessBond (to prevent)\n            // multiple draining payments by a malicious proposer nesting the same\n            // hook.\n            if (tko.balanceOf(address(this)) != tkoBalance + _config.livenessBond) {\n                revert L1_LIVENESS_BOND_NOT_RECEIVED();\n            }\n        }\n\n        emit BlockProposed({\n            blockId: blk.blockId,\n            assignedProver: blk.assignedProver,\n            livenessBond: _config.livenessBond,\n            meta: meta_,\n            depositsProcessed: deposits_\n        });\n    }\n\n    /// @notice Checks if a blob is reusable.\n    /// @param _state Current TaikoData.State.\n    /// @param _config The TaikoData.Config.\n    /// @param _blobHash The blob hash\n    /// @return true if the blob is reusable, false otherwise.\n    function isBlobReusable(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        bytes32 _blobHash\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return _state.reusableBlobs[_blobHash] + _config.blobExpiry > block.timestamp;\n    }\n\n    function _isProposerPermitted(\n        TaikoData.SlotB memory _slotB,\n        IAddressResolver _resolver\n    )\n        private\n        view\n        returns (bool)\n    {\n        if (_slotB.numBlocks == 1) {\n            // Only proposer_one can propose the first block after genesis\n            address proposerOne = _resolver.resolve(\"proposer_one\", true);\n            if (proposerOne != address(0) && msg.sender != proposerOne) {\n                return false;\n            }\n        }\n\n        address proposer = _resolver.resolve(\"proposer\", true);\n        return proposer == address(0) || msg.sender == proposer;\n    }\n}"
    }
  ]
}