{
  "Title": "[07] Absorber removal request timelock leads to unnecessary disadvantages for users",
  "Content": "\nIf a user [requests](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/absorber.cairo#L441-L465) to [remove](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/absorber.cairo#L468-L530) yin from the Absorber within the `REQUEST_COOLDOWN` period, the `timelock` for removal multiplies. \n\nThis makes sense in case the user immediately requests again after a yin removal. However, the `timelock` is also multiplied in case the user accidentally requests again before a removal, which is simply unfair.\n\n### Recommendation\n\nOnly increase the `timelock` on request within `REQUEST_COOLDOWN` after a removal:\n\n```diff\ndiff --git a/src/core/absorber.cairo b/src/core/absorber.cairo\nindex 473275f..ab4ba07 100644\n--- a/src/core/absorber.cairo\n+++ b/src/core/absorber.cairo\n@@ -447,7 +447,12 @@ mod absorber {\n \n             let mut timelock: u64 = REQUEST_BASE_TIMELOCK;\n             if request.timestamp + REQUEST_COOLDOWN > current_timestamp {\n-                timelock = request.timelock * REQUEST_TIMELOCK_MULTIPLIER;\n+                if request.has_removed {\n+                    timelock = request.timelock * REQUEST_TIMELOCK_MULTIPLIER;\n+                }\n+                else {\n+                    timelock = request.timelock;\n+                }\n             }\n \n             let capped_timelock: u64 = min(timelock, REQUEST_MAX_TIMELOCK);\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-opus",
  "Code": [
    {
      "filename": "src/core/absorber.cairo",
      "content": "// Note on fixed point math in Absorber:\n//\n// Non-Wad/Ray fixed-point values (i.e., values whose number of decimals is something other than 18 or 27)\n// are used extensively throughout the contract. However, these values also rely on\n// wadray-fixed-point arithmetic functions in their calculations. Consequently,\n// wadray's internal functions are used to perform these calculations.\n#[starknet::contract]\nmod absorber {\n    use access_control::access_control_component;\n    use cmp::min;\n    use integer::u256_safe_divmod;\n    use opus::core::roles::absorber_roles;\n    use opus::interfaces::IAbsorber::{IAbsorber, IBlesserDispatcher, IBlesserDispatcherTrait};\n    use opus::interfaces::IERC20::{IERC20Dispatcher, IERC20DispatcherTrait};\n    use opus::interfaces::ISentinel::{ISentinelDispatcher, ISentinelDispatcherTrait};\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::types::{AssetBalance, DistributionInfo, Provision, Request, Reward};\n    use starknet::{ContractAddress, get_block_timestamp, get_caller_address, get_contract_address};\n    use wadray::{Ray, RayZeroable, u128_wdiv, u128_wmul, Wad, WadZeroable};\n\n    //\n    // Components\n    //\n\n    component!(path: access_control_component, storage: access_control, event: AccessControlEvent);\n\n    #[abi(embed_v0)]\n    impl AccessControlPublic = access_control_component::AccessControl<ContractState>;\n    impl AccessControlHelpers = access_control_component::AccessControlHelpers<ContractState>;\n\n    //\n    // Constants\n    //\n\n    // If the amount of yin Wad per share drops below this threshold, the epoch is incremented\n    // to reset the yin per share ratio to 1 : 1 parity for accounting. Otherwise, there will\n    // eventually be an overflow when converting yin to shares (and vice versa)\n    // as yin per share approaches 0.\n    const YIN_PER_SHARE_THRESHOLD: u128 = 1000000000000000; // 10**15 = 0.001 (Wad)\n\n    // Shares to be minted without a provider to avoid first provider front-running\n    const INITIAL_SHARES: u128 = 1000; // 10 ** 3 (Wad);\n\n    // Minimum total shares, including the initial shares, for each epoch\n    // to prevent overflows in fixed point operations when the divisor (total shares)\n    // is a very small number\n    const MINIMUM_SHARES: u128 = 1000000; // 10 ** 6 (Wad);\n\n    // First epoch of the Absorber\n    const FIRST_EPOCH: u32 = 1;\n\n    // Amount of time, in seconds, that needs to elapse after request is submitted before removal\n    const REQUEST_BASE_TIMELOCK: u64 = 60;\n\n    // Upper bound of time, in seconds, that needs to elapse after request is submitted before removal\n    // 7 days * 24 hours per day * 60 minutes per hour * 60 seconds per minute\n    const REQUEST_MAX_TIMELOCK: u64 = consteval_int!(7 * 24 * 60 * 60);\n\n    // Multiplier for each request's timelock from the last value if a new request is submitted\n    // before the cooldown of the previous request has elapsed\n    const REQUEST_TIMELOCK_MULTIPLIER: u64 = 5;\n\n    // Amount of time, in seconds, for which a request is valid, starting from expiry of the timelock\n    // 60 minutes * 60 seconds per minute\n    const REQUEST_VALIDITY_PERIOD: u64 = consteval_int!(60 * 60);\n\n    // Amount of time that needs to elapse after a request is submitted before the timelock\n    // for the next request is reset to the base value.\n    // 7 days * 24 hours per day * 60 minutes per hour * 60 seconds per minute\n    const REQUEST_COOLDOWN: u64 = consteval_int!(7 * 24 * 60 * 60);\n\n    // Helper constant to set the starting index for iterating over the Rewards\n    // in the order they were added\n    const REWARDS_LOOP_START: u8 = 1;\n\n    #[storage]\n    struct Storage {\n        // components\n        #[substorage(v0)]\n        access_control: access_control_component::Storage,\n        // Sentinel associated with the Shrine for this Absorber\n        sentinel: ISentinelDispatcher,\n        // Shrine associated with this Absorber\n        shrine: IShrineDispatcher,\n        // boolean flag indicating whether the Absorber is live or not\n        // once the Absorber is killed,\n        // 1. users can no longer `provide` yin\n        // 2. distribution of rewards via `bestow` stops\n        is_live: bool,\n        // epoch starts from 1\n        // both shares and absorptions are tied to an epoch\n        // the epoch is incremented when the amount of yin per share drops below the threshold.\n        // this includes when the absorber's yin balance is completely depleted.\n        current_epoch: u32,\n        // absorptions start from 1.\n        absorptions_count: u32,\n        // mapping from a provider to the last absorption ID accounted for\n        provider_last_absorption: LegacyMap::<ContractAddress, u32>,\n        // mapping of address to a struct of\n        // 1. epoch in which the provider's shares are issued\n        // 2. number of shares for the provider in the above epoch\n        provisions: LegacyMap::<ContractAddress, Provision>,\n        // mapping from an absorption to its epoch\n        absorption_epoch: LegacyMap::<u32, u32>,\n        // total number of shares for current epoch\n        total_shares: Wad,\n        // mapping of a tuple of asset and absorption ID to a struct of\n        // 1. the amount of that asset in its decimal precision absorbed per share Wad for an absorption\n        // 2. the rounding error from calculating (1) that is to be added to the next absorption\n        asset_absorption: LegacyMap::<(ContractAddress, u32), DistributionInfo>,\n        // conversion rate of an epoch's shares to the next\n        // if an update causes the yin per share to drop below the threshold,\n        // the epoch is incremented and yin per share is reset to one Ray.\n        // a provider with shares in that epoch will receive new shares in the next epoch\n        // based on this conversion rate.\n        // if the absorber's yin balance is wiped out, the conversion rate will be 0.\n        epoch_share_conversion_rate: LegacyMap::<u32, Ray>,\n        // total number of reward tokens, starting from 1\n        // a reward token cannot be removed once added.\n        rewards_count: u8,\n        // mapping from a reward token address to its id for iteration\n        reward_id: LegacyMap::<ContractAddress, u8>,\n        // mapping from a reward token ID to its Reward struct:\n        // 1. the ERC-20 token address\n        // 2. the address of the vesting contract (blesser) implementing `IBlesser` for the ERC-20 token\n        // 3. a boolean indicating if the blesser should be called\n        rewards: LegacyMap::<u8, Reward>,\n        // mapping from a reward token address and epoch to a struct of\n        // 1. the cumulative amount of that reward asset in its decimal precision per share Wad in that epoch\n        // 2. the rounding error from calculating (1) that is to be added to the next reward distribution\n        cumulative_reward_amt_by_epoch: LegacyMap::<(ContractAddress, u32), DistributionInfo>,\n        // mapping from a provider and reward token address to its last cumulative amount of that reward\n        // per share Wad in the epoch of the provider's Provision struct\n        provider_last_reward_cumulative: LegacyMap::<(ContractAddress, ContractAddress), u128>,\n        // Mapping from a provider to its latest request for removal\n        provider_request: LegacyMap::<ContractAddress, Request>,\n    }\n\n    //\n    // Events\n    //\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        AccessControlEvent: access_control_component::Event,\n        RewardSet: RewardSet,\n        EpochChanged: EpochChanged,\n        Provide: Provide,\n        RequestSubmitted: RequestSubmitted,\n        Remove: Remove,\n        Reap: Reap,\n        Gain: Gain,\n        Bestow: Bestow,\n        Killed: Killed,\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct RewardSet {\n        #[key]\n        asset: ContractAddress,\n        #[key]\n        blesser: ContractAddress,\n        is_active: bool\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct EpochChanged {\n        old_epoch: u32,\n        new_epoch: u32\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Provide {\n        #[key]\n        provider: ContractAddress,\n        epoch: u32,\n        yin: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct RequestSubmitted {\n        #[key]\n        provider: ContractAddress,\n        timestamp: u64,\n        timelock: u64\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Remove {\n        #[key]\n        provider: ContractAddress,\n        epoch: u32,\n        yin: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Reap {\n        #[key]\n        provider: ContractAddress,\n        absorbed_assets: Span<AssetBalance>,\n        reward_assets: Span<AssetBalance>\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Gain {\n        assets: Span<AssetBalance>,\n        total_recipient_shares: Wad,\n        epoch: u32,\n        absorption_id: u32\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Bestow {\n        assets: Span<AssetBalance>,\n        total_recipient_shares: Wad,\n        epoch: u32\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Killed {}\n\n    //\n    // Constructor\n    //\n    #[constructor]\n    fn constructor(\n        ref self: ContractState, admin: ContractAddress, shrine: ContractAddress, sentinel: ContractAddress,\n    ) {\n        self.access_control.initializer(admin, Option::Some(absorber_roles::default_admin_role()));\n\n        self.shrine.write(IShrineDispatcher { contract_address: shrine });\n        self.sentinel.write(ISentinelDispatcher { contract_address: sentinel });\n        self.is_live.write(true);\n        self.current_epoch.write(FIRST_EPOCH);\n    }\n\n    //\n    // External Absorber functions\n    //\n\n    #[abi(embed_v0)]\n    impl IAbsorberImpl of IAbsorber<ContractState> {\n        //\n        // Getters\n        //\n\n        fn get_rewards_count(self: @ContractState) -> u8 {\n            self.rewards_count.read()\n        }\n\n        fn get_rewards(self: @ContractState) -> Span<Reward> {\n            let rewards_count: u8 = self.rewards_count.read();\n\n            let mut reward_id: u8 = REWARDS_LOOP_START;\n            let mut rewards: Array<Reward> = ArrayTrait::new();\n\n            loop {\n                if reward_id == REWARDS_LOOP_START + rewards_count {\n                    break rewards.span();\n                }\n\n                rewards.append(self.rewards.read(reward_id));\n                reward_id += 1;\n            }\n        }\n\n        fn get_current_epoch(self: @ContractState) -> u32 {\n            self.current_epoch.read()\n        }\n\n        fn get_absorptions_count(self: @ContractState) -> u32 {\n            self.absorptions_count.read()\n        }\n\n        fn get_absorption_epoch(self: @ContractState, absorption_id: u32) -> u32 {\n            self.absorption_epoch.read(absorption_id)\n        }\n\n        fn get_total_shares_for_current_epoch(self: @ContractState) -> Wad {\n            self.total_shares.read()\n        }\n\n        fn get_provision(self: @ContractState, provider: ContractAddress) -> Provision {\n            self.provisions.read(provider)\n        }\n\n        fn get_provider_last_absorption(self: @ContractState, provider: ContractAddress) -> u32 {\n            self.provider_last_absorption.read(provider)\n        }\n\n        fn get_provider_request(self: @ContractState, provider: ContractAddress) -> Request {\n            self.provider_request.read(provider)\n        }\n\n        fn get_asset_absorption(self: @ContractState, asset: ContractAddress, absorption_id: u32) -> DistributionInfo {\n            self.asset_absorption.read((asset, absorption_id))\n        }\n\n        fn get_cumulative_reward_amt_by_epoch(\n            self: @ContractState, asset: ContractAddress, epoch: u32\n        ) -> DistributionInfo {\n            self.cumulative_reward_amt_by_epoch.read((asset, epoch))\n        }\n\n        fn get_provider_last_reward_cumulative(\n            self: @ContractState, provider: ContractAddress, asset: ContractAddress\n        ) -> u128 {\n            self.provider_last_reward_cumulative.read((provider, asset))\n        }\n\n        fn get_live(self: @ContractState) -> bool {\n            self.is_live.read()\n        }\n\n\n        //\n        // View\n        //\n\n        // Returns true if the total shares in current epoch is at least `MINIMUM_SHARES`, so as\n        // to prevent underflows when distributing absorbed assets and rewards.\n        fn is_operational(self: @ContractState) -> bool {\n            is_operational_helper(self.total_shares.read())\n        }\n\n        // Returns the maximum amount of yin removable by a provider.\n        fn preview_remove(self: @ContractState, provider: ContractAddress) -> Wad {\n            let provision: Provision = self.provisions.read(provider);\n            let current_epoch: u32 = self.current_epoch.read();\n            let current_provider_shares: Wad = self\n                .convert_epoch_shares(provision.epoch, current_epoch, provision.shares);\n\n            self.convert_to_yin(current_provider_shares)\n        }\n\n\n        // Returns the absorbed assets and rewards that a provider will receive based on\n        // the current on-chain conditions\n        fn preview_reap(self: @ContractState, provider: ContractAddress) -> (Span<AssetBalance>, Span<AssetBalance>) {\n            let provision: Provision = self.provisions.read(provider);\n            let current_epoch: u32 = self.current_epoch.read();\n\n            let total_shares: Wad = self.total_shares.read();\n            let current_provider_shares: Wad = self\n                .convert_epoch_shares(provision.epoch, current_epoch, provision.shares);\n            let include_pending_rewards: bool = is_operational_helper(total_shares)\n                && current_provider_shares.is_non_zero();\n            let (absorbed_assets, rewarded_assets) = self\n                .get_absorbed_and_rewarded_assets_for_provider(provider, provision, include_pending_rewards);\n\n            // NOTE: both absorbed assets and rewarded assets will be empty arrays\n            // if `provision.shares` is zero.\n            (absorbed_assets, rewarded_assets)\n        }\n\n\n        //\n        // Setters\n        //\n\n        // Note: rewards ID start from index 1. This allows `set_reward` to be used for both\n        // adding a new reward and updating an existing reward based on whether the initial\n        // reward ID is zero (new reward) or non-zero (existing reward).\n        fn set_reward(ref self: ContractState, asset: ContractAddress, blesser: ContractAddress, is_active: bool) {\n            self.access_control.assert_has_role(absorber_roles::SET_REWARD);\n\n            assert(asset.is_non_zero() && blesser.is_non_zero(), 'ABS: Address cannot be 0');\n\n            let reward: Reward = Reward { asset, blesser: IBlesserDispatcher { contract_address: blesser }, is_active };\n\n            // If this reward token hasn't been added yet, add it to the list\n            let reward_id: u8 = self.reward_id.read(asset);\n\n            if reward_id == 0 {\n                let current_count: u8 = self.rewards_count.read();\n                let new_count = current_count + 1;\n\n                self.rewards_count.write(new_count);\n                self.reward_id.write(asset, new_count);\n                self.rewards.write(new_count, reward);\n            } else {\n                // Otherwise, update the existing reward\n                self.rewards.write(reward_id, reward);\n            }\n\n            // Emit event\n            self.emit(RewardSet { asset, blesser, is_active });\n        }\n\n        //\n        // Core Absorber functions\n        //\n\n        // Supply yin to the absorber.\n        // Requires the caller to have approved spending by the absorber.\n        fn provide(ref self: ContractState, amount: Wad) {\n            self.assert_live();\n\n            let provider: ContractAddress = get_caller_address();\n\n            // Withdraw absorbed collateral before updating shares\n            let provision: Provision = self.provisions.read(provider);\n            self.reap_helper(provider, provision);\n\n            // Calculate number of shares to issue to provider and to add to total for current epoch\n            // The two values deviate only when it is the first provision of an epoch and\n            // total shares is below the minimum initial shares.\n            let (new_provision_shares, issued_shares) = self.convert_to_shares(amount, false);\n\n            // If epoch has changed, convert shares in previous epoch to new epoch's shares\n            let current_epoch: u32 = self.current_epoch.read();\n            let converted_shares: Wad = self.convert_epoch_shares(provision.epoch, current_epoch, provision.shares);\n\n            let new_shares: Wad = converted_shares + new_provision_shares;\n            self.provisions.write(provider, Provision { epoch: current_epoch, shares: new_shares });\n\n            // Update total shares for current epoch\n            self.total_shares.write(self.total_shares.read() + issued_shares);\n\n            // Perform transfer of yin\n            let absorber: ContractAddress = get_contract_address();\n\n            let success: bool = self.yin_erc20().transfer_from(provider, absorber, amount.into());\n            assert(success, 'ABS: Transfer failed');\n\n            // Event emission\n            self.emit(Provide { provider, epoch: current_epoch, yin: amount });\n        }\n\n\n        // Submit a request to `remove` that is valid for a fixed period of time after a variable timelock.\n        // - This is intended to prevent atomic removals to avoid risk-free yield (from rewards and interest)\n        //   frontrunning tactics.\n        //   The timelock increases if another request is submitted before the previous has cooled down.\n        // - A request is expended by either (1) a removal; (2) expiry; or (3) submitting a new request.\n        // - Note: A request may become valid in the next epoch if a provider in the previous epoch\n        //         submitted a request, a draining absorption occurs, and the provider provides again\n        //         in the next epoch. This is expected to be rare, and the maximum risk-free profit is\n        //         in any event greatly limited.\n        fn request(ref self: ContractState) {\n            let provider: ContractAddress = get_caller_address();\n            assert_provider(self.provisions.read(provider));\n\n            let request: Request = self.provider_request.read(provider);\n            let current_timestamp: u64 = get_block_timestamp();\n\n            let mut timelock: u64 = REQUEST_BASE_TIMELOCK;\n            if request.timestamp + REQUEST_COOLDOWN > current_timestamp {\n                timelock = request.timelock * REQUEST_TIMELOCK_MULTIPLIER;\n            }\n\n            let capped_timelock: u64 = min(timelock, REQUEST_MAX_TIMELOCK);\n            self\n                .provider_request\n                .write(\n                    provider, Request { timestamp: current_timestamp, timelock: capped_timelock, has_removed: false }\n                );\n            self.emit(RequestSubmitted { provider, timestamp: current_timestamp, timelock: capped_timelock });\n        }\n\n        // Withdraw yin (if any) and all absorbed collateral assets from the absorber.\n        fn remove(ref self: ContractState, amount: Wad) {\n            let provider: ContractAddress = get_caller_address();\n            let provision: Provision = self.provisions.read(provider);\n            assert_provider(provision);\n\n            let mut request: Request = self.provider_request.read(provider);\n            self.assert_can_remove(request);\n\n            // Withdraw absorbed collateral before updating shares\n            self.reap_helper(provider, provision);\n\n            // Fetch the shares for current epoch\n            let current_epoch: u32 = self.current_epoch.read();\n            let current_provider_shares: Wad = self\n                .convert_epoch_shares(provision.epoch, current_epoch, provision.shares);\n\n            if current_provider_shares.is_zero() {\n                // If no remaining shares after converting across epochs,\n                // provider's deposit has been completely absorbed.\n                // Since absorbed collateral have been reaped,\n                // we can update the provision to current epoch and shares.\n                self.provisions.write(provider, Provision { epoch: current_epoch, shares: WadZeroable::zero() });\n\n                request.has_removed = true;\n                self.provider_request.write(provider, request);\n\n                // Event emission\n                self.emit(Remove { provider, epoch: current_epoch, yin: WadZeroable::zero() });\n            } else {\n                // Calculations for yin need to be performed before updating total shares.\n                // Cap `amount` to maximum removable for provider, then derive the number of shares.\n                let max_removable_yin: Wad = self.convert_to_yin(current_provider_shares);\n                let yin_amt: Wad = min(amount, max_removable_yin);\n\n                // Due to precision loss, if the amount to remove is the max removable,\n                // set the shares to be removed as the provider's balance to avoid\n                // any remaining dust shares.\n                let mut shares_to_remove = current_provider_shares;\n                if yin_amt != max_removable_yin {\n                    let (shares_to_remove_ceiled, _) = self.convert_to_shares(yin_amt, true);\n                    shares_to_remove = shares_to_remove_ceiled;\n                }\n\n                self.total_shares.write(self.total_shares.read() - shares_to_remove);\n\n                // Update provision\n                let new_provider_shares: Wad = current_provider_shares - shares_to_remove;\n                self.provisions.write(provider, Provision { epoch: current_epoch, shares: new_provider_shares });\n\n                self\n                    .provider_request\n                    .write(\n                        provider,\n                        Request { timestamp: request.timestamp, timelock: request.timelock, has_removed: true }\n                    );\n\n                let success: bool = self.yin_erc20().transfer(provider, yin_amt.into());\n                assert(success, 'ABS: Transfer failed');\n\n                // Event emission\n                self.emit(Remove { provider, epoch: current_epoch, yin: yin_amt });\n            }\n        }\n\n        // Withdraw absorbed collateral only from the absorber\n        // Note that `reap` alone will not update a caller's Provision in storage\n        fn reap(ref self: ContractState) {\n            let provider: ContractAddress = get_caller_address();\n            let provision: Provision = self.provisions.read(provider);\n            assert_provider(provision);\n\n            self.reap_helper(provider, provision);\n\n            // Update provider's epoch and shares to current epoch's\n            // Epoch must be updated to prevent provider from repeatedly claiming rewards\n            let current_epoch: u32 = self.current_epoch.read();\n            let current_provider_shares: Wad = self\n                .convert_epoch_shares(provision.epoch, current_epoch, provision.shares);\n            self.provisions.write(provider, Provision { epoch: current_epoch, shares: current_provider_shares });\n        }\n\n        // Update assets received after an absorption\n        fn update(ref self: ContractState, asset_balances: Span<AssetBalance>) {\n            self.access_control.assert_has_role(absorber_roles::UPDATE);\n\n            let current_epoch: u32 = self.current_epoch.read();\n\n            // Trigger issuance of rewards\n            self.bestow();\n\n            // Increment absorption ID\n            let current_absorption_id: u32 = self.absorptions_count.read() + 1;\n            self.absorptions_count.write(current_absorption_id);\n\n            // Update epoch for absorption ID\n            self.absorption_epoch.write(current_absorption_id, current_epoch);\n\n            // Exclude initial shares from the total amount of shares receiving absorbed assets\n            let total_shares: Wad = self.total_shares.read();\n            let total_recipient_shares: Wad = total_shares - INITIAL_SHARES.into();\n\n            let mut asset_balances_copy = asset_balances;\n            loop {\n                match asset_balances_copy.pop_front() {\n                    Option::Some(asset_balance) => {\n                        self.update_absorbed_asset(current_absorption_id, total_recipient_shares, *asset_balance);\n                    },\n                    Option::None => { break; }\n                };\n            };\n\n            //\n            // Increment epoch ID only if yin per share drops below threshold or stability pool is emptied\n            //\n\n            let absorber: ContractAddress = get_contract_address();\n            let yin_balance: Wad = self.yin_erc20().balance_of(absorber).try_into().unwrap();\n            let yin_per_share: Wad = yin_balance / total_shares;\n\n            // This also checks for absorber's yin balance being emptied because yin per share will be\n            // below threshold if yin balance is 0.\n            if YIN_PER_SHARE_THRESHOLD > yin_per_share.val {\n                let new_epoch: u32 = current_epoch + 1;\n                self.current_epoch.write(new_epoch);\n\n                // If new epoch's yin balance exceeds the initial minimum shares, deduct the initial\n                // minimum shares worth of yin from the yin balance so that there is at least such amount\n                // of yin that cannot be removed in the next epoch.\n                if INITIAL_SHARES < yin_balance.val {\n                    let epoch_share_conversion_rate: Ray = wadray::rdiv_ww(\n                        yin_balance - INITIAL_SHARES.into(), total_recipient_shares\n                    );\n\n                    self.epoch_share_conversion_rate.write(current_epoch, epoch_share_conversion_rate);\n                    self.total_shares.write(yin_balance);\n                } else {\n                    // Otherwise, set the epoch share conversion rate to 0 and total shares to 0.\n                    // This is to prevent an attacker from becoming a majority shareholder\n                    // in a new epoch when the number of shares is very small, which would\n                    // allow them to execute an attack similar to a first-deposit front-running attack.\n                    // This would cause a negligible loss to the previous epoch's providers, but\n                    // partially compensates the first provider in the new epoch for the deducted\n                    // minimum initial amount.\n                    self.epoch_share_conversion_rate.write(current_epoch, RayZeroable::zero());\n                    self.total_shares.write(WadZeroable::zero());\n                }\n\n                self.emit(EpochChanged { old_epoch: current_epoch, new_epoch });\n\n                // Transfer reward errors of current epoch to the next epoch\n                self.propagate_reward_errors(current_epoch);\n            }\n\n            self\n                .emit(\n                    Gain {\n                        assets: asset_balances,\n                        total_recipient_shares,\n                        epoch: current_epoch,\n                        absorption_id: current_absorption_id\n                    }\n                );\n        }\n\n        fn kill(ref self: ContractState) {\n            self.access_control.assert_has_role(absorber_roles::KILL);\n            self.is_live.write(false);\n            self.emit(Killed {});\n        }\n    }\n\n    //\n    // Internal Absorber functions\n    //\n\n    #[generate_trait]\n    impl AbsorberHelpers of AbsorberHelpersTrait {\n        //\n        // Internal\n        //\n\n        #[inline(always)]\n        fn assert_live(self: @ContractState) {\n            assert(self.is_live.read(), 'ABS: Not live');\n        }\n\n        // Helper function to return a Yin ERC20 contract\n        #[inline(always)]\n        fn yin_erc20(self: @ContractState) -> IERC20Dispatcher {\n            IERC20Dispatcher { contract_address: self.shrine.read().contract_address }\n        }\n\n        //\n        // Internal - helpers for accounting of shares\n        //\n\n        // Convert to shares with a flag for whether the value should be rounded up or rounded down.\n        // When converting to shares, we always favour the Absorber to the expense of the provider.\n        // - Round down for `provide` (default for integer division)\n        // - Round up for `remove`\n        // Returns a tuple of the shares to be issued to the provider, and the total number of shares\n        // issued for the system.\n        // - There will be a difference between the two values only if it is the first `provide` of an epoch and\n        //   the total shares is less than the minimum initial shares.\n        fn convert_to_shares(self: @ContractState, yin_amt: Wad, round_up: bool) -> (Wad, Wad) {\n            let total_shares: Wad = self.total_shares.read();\n\n            if INITIAL_SHARES > total_shares.val {\n                // By subtracting the initial shares from the first provider's shares, we ensure that\n                // there is a non-removable amount of shares. This subtraction also prevents a user\n                // from providing an amount less than the minimum shares.\n                assert(yin_amt.val >= INITIAL_SHARES, 'ABS: provision < minimum');\n                return ((yin_amt.val - INITIAL_SHARES).into(), yin_amt);\n            }\n\n            let absorber: ContractAddress = get_contract_address();\n            let yin_balance: u256 = self.yin_erc20().balance_of(absorber);\n\n            let (computed_shares, r, _) = u256_safe_divmod(\n                yin_amt.into() * total_shares.into(), yin_balance.try_into().expect('Division by zero')\n            );\n            let computed_shares: u128 = computed_shares.try_into().unwrap();\n            if round_up && r.is_non_zero() {\n                return ((computed_shares + 1).into(), (computed_shares + 1).into());\n            }\n            (computed_shares.into(), computed_shares.into())\n        }\n\n        // This implementation is slightly different from Gate because the concept of shares is\n        // used for internal accounting only, and both shares and yin are wads.\n        fn convert_to_yin(self: @ContractState, shares_amt: Wad) -> Wad {\n            let total_shares: Wad = self.total_shares.read();\n\n            // If no shares are issued yet, then it is a new epoch and absorber is emptied.\n            if total_shares.is_zero() {\n                return WadZeroable::zero();\n            }\n\n            let absorber: ContractAddress = get_contract_address();\n            let yin_balance: Wad = self.yin_erc20().balance_of(absorber).try_into().unwrap();\n\n            (shares_amt * yin_balance) / total_shares\n        }\n\n        // Convert an epoch's shares to a subsequent epoch's shares\n        fn convert_epoch_shares(self: @ContractState, start_epoch: u32, end_epoch: u32, start_shares: Wad) -> Wad {\n            if start_epoch == end_epoch {\n                return start_shares;\n            }\n\n            let epoch_conversion_rate: Ray = self.epoch_share_conversion_rate.read(start_epoch);\n            let new_shares: Wad = wadray::rmul_wr(start_shares, epoch_conversion_rate);\n\n            self.convert_epoch_shares(start_epoch + 1, end_epoch, new_shares)\n        }\n\n        //\n        // Internal - helpers for `update`\n        //\n\n        // Helper function to update each provider's entitlement of an absorbed asset\n        fn update_absorbed_asset(\n            ref self: ContractState, absorption_id: u32, total_recipient_shares: Wad, asset_balance: AssetBalance\n        ) {\n            if asset_balance.amount.is_zero() {\n                return;\n            }\n\n            let last_error: u128 = self.get_recent_asset_absorption_error(asset_balance.address, absorption_id);\n            let total_amount_to_distribute: u128 = asset_balance.amount + last_error;\n\n            let asset_amt_per_share: u128 = u128_wdiv(total_amount_to_distribute, total_recipient_shares.val);\n            let actual_amount_distributed: u128 = u128_wmul(asset_amt_per_share, total_recipient_shares.val);\n            let error: u128 = total_amount_to_distribute - actual_amount_distributed;\n\n            self\n                .asset_absorption\n                .write((asset_balance.address, absorption_id), DistributionInfo { asset_amt_per_share, error });\n        }\n\n        // Returns the last error for an asset at a given `absorption_id` if th"
    }
  ]
}