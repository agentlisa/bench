{
  "Title": "[15] Wrong logic",
  "Content": "\nBoth [Utils, function `bytecodeLenInWords`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/libraries/Utils.sol#L46) and [L2ContractHelper, function `_bytecodeLen`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L50) do calculate the length in words of a given bytecode like the following:\n\n```solidity\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n```\n\nHowever, when hashing the bytecode, the bytes at position `[2]` are set to `0`:\n\n```solidity\n    function hashL2Bytecode(bytes memory _bytecode) internal pure returns (bytes32 hashedBytecode) {\n\n        ...\n\n        hashedBytecode = sha256(_bytecode) & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n```\n\nIt seems that `codeLengthInWords` should be equal to the bytes at position `[3]` alone, as the variable's name `bytecodeLenInWords` suggests, that is:\n\n[L2ContractHelper, function `_bytecodeLen`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L49C1-L51C6)\n\n```diff\n    function _bytecodeLen(bytes32 _bytecodeHash) private pure returns (uint256 codeLengthInWords) {\n-       codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n+       codeLengthInWords = uint256(uint8(_bytecodeHash[3]));\n    }\n```\n\n[Utils, function `bytecodeLenInWords`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/libraries/Utils.sol#L44C1-L48C6)\n\n```diff\n    function bytecodeLenInWords(bytes32 _bytecodeHash) internal pure returns (uint256 codeLengthInWords) {\n        unchecked {\n-           codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n+           codeLengthInWords = uint256(uint8(_bytecodeHash[3]));\n        }\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/libraries/Utils.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./EfficientCall.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @dev Common utilities used in zkSync system contracts\n */\nlibrary Utils {\n    /// @dev Bit mask of bytecode hash \"isConstructor\" marker\n    bytes32 constant IS_CONSTRUCTOR_BYTECODE_HASH_BIT_MASK =\n        0x00ff000000000000000000000000000000000000000000000000000000000000;\n\n    /// @dev Bit mask to set the \"isConstructor\" marker in the bytecode hash\n    bytes32 constant SET_IS_CONSTRUCTOR_MARKER_BIT_MASK =\n        0x0001000000000000000000000000000000000000000000000000000000000000;\n\n    function safeCastToU128(uint256 _x) internal pure returns (uint128) {\n        require(_x <= type(uint128).max, \"Overflow\");\n\n        return uint128(_x);\n    }\n\n    function safeCastToU32(uint256 _x) internal pure returns (uint32) {\n        require(_x <= type(uint32).max, \"Overflow\");\n\n        return uint32(_x);\n    }\n\n    function safeCastToU24(uint256 _x) internal pure returns (uint24) {\n        require(_x <= type(uint24).max, \"Overflow\");\n\n        return uint24(_x);\n    }\n\n    /// @return codeLength The bytecode length in bytes\n    function bytecodeLenInBytes(bytes32 _bytecodeHash) internal pure returns (uint256 codeLength) {\n        codeLength = bytecodeLenInWords(_bytecodeHash) << 5; // _bytecodeHash * 32\n    }\n\n    /// @return codeLengthInWords The bytecode length in machine words\n    function bytecodeLenInWords(bytes32 _bytecodeHash) internal pure returns (uint256 codeLengthInWords) {\n        unchecked {\n            codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n        }\n    }\n\n    /// @notice Denotes whether bytecode hash corresponds to a contract that already constructed\n    function isContractConstructed(bytes32 _bytecodeHash) internal pure returns (bool) {\n        return _bytecodeHash[1] == 0x00;\n    }\n\n    /// @notice Denotes whether bytecode hash corresponds to a contract that is on constructor or has already been constructed\n    function isContractConstructing(bytes32 _bytecodeHash) internal pure returns (bool) {\n        return _bytecodeHash[1] == 0x01;\n    }\n\n    /// @notice Sets \"isConstructor\" flag to TRUE for the bytecode hash\n    /// @param _bytecodeHash The bytecode hash for which it is needed to set the constructing flag\n    /// @return The bytecode hash with \"isConstructor\" flag set to TRUE\n    function constructingBytecodeHash(bytes32 _bytecodeHash) internal pure returns (bytes32) {\n        // Clear the \"isConstructor\" marker and set it to 0x01.\n        return constructedBytecodeHash(_bytecodeHash) | SET_IS_CONSTRUCTOR_MARKER_BIT_MASK;\n    }\n\n    /// @notice Sets \"isConstructor\" flag to FALSE for the bytecode hash\n    /// @param _bytecodeHash The bytecode hash for which it is needed to set the constructing flag\n    /// @return The bytecode hash with \"isConstructor\" flag set to FALSE\n    function constructedBytecodeHash(bytes32 _bytecodeHash) internal pure returns (bytes32) {\n        return _bytecodeHash & ~IS_CONSTRUCTOR_BYTECODE_HASH_BIT_MASK;\n    }\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecode The bytecode to hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(bytes calldata _bytecode) internal view returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecode.length % 32 == 0, \"po\");\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        require(bytecodeLenInWords < 2 ** 16, \"pp\"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, \"pr\"); // bytecode length in words must be odd\n        hashedBytecode =\n            EfficientCall.sha(_bytecode) &\n            0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Helper library for working with L2 contracts on L1.\n */\nlibrary L2ContractHelper {\n    /// @dev The prefix used to create CREATE2 addresses.\n    bytes32 constant CREATE2_PREFIX = keccak256(\"zksyncCreate2\");\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecode The bytecode to hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(bytes memory _bytecode) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecode.length % 32 == 0, \"pq\");\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        require(bytecodeLenInWords < 2**16, \"pp\"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, \"ps\"); // bytecode length in words must be odd\n        hashedBytecode = sha256(_bytecode) & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n\n    /// @notice Validates the format of the given bytecode hash.\n    /// @dev Due to the specification of the L2 bytecode hash, not every 32 bytes could be a legit bytecode hash.\n    /// @dev The function reverts on invalid bytecode hash formam.\n    /// @param _bytecodeHash The hash of the bytecode to validate.\n    function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), \"zf\"); // Incorrectly formatted bytecodeHash\n\n        require(_bytecodeLen(_bytecodeHash) % 2 == 1, \"uy\"); // Code length in words must be odd\n    }\n\n    /// @notice Returns the length of the bytecode associated with the given hash.\n    /// @param _bytecodeHash The hash of the bytecode.\n    /// @return codeLengthInWords The length of the bytecode in words.\n    function _bytecodeLen(bytes32 _bytecodeHash) private pure returns (uint256 codeLengthInWords) {\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n    }\n\n    /// @notice Computes the create2 address for a Layer 2 contract.\n    /// @param _sender The address of the sender.\n    /// @param _salt The salt value to use in the create2 address computation.\n    /// @param _bytecodeHash The contract bytecode hash.\n    /// @param _constructorInputHash The hash of the constructor input data.\n    /// @return The create2 address of the contract.\n    /// NOTE: L2 create2 derivation is different from L1 derivation!\n    function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }\n}"
    },
    {
      "filename": "code/system-contracts/contracts/libraries/Utils.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./EfficientCall.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @dev Common utilities used in zkSync system contracts\n */\nlibrary Utils {\n    /// @dev Bit mask of bytecode hash \"isConstructor\" marker\n    bytes32 constant IS_CONSTRUCTOR_BYTECODE_HASH_BIT_MASK =\n        0x00ff000000000000000000000000000000000000000000000000000000000000;\n\n    /// @dev Bit mask to set the \"isConstructor\" marker in the bytecode hash\n    bytes32 constant SET_IS_CONSTRUCTOR_MARKER_BIT_MASK =\n        0x0001000000000000000000000000000000000000000000000000000000000000;\n\n    function safeCastToU128(uint256 _x) internal pure returns (uint128) {\n        require(_x <= type(uint128).max, \"Overflow\");\n\n        return uint128(_x);\n    }\n\n    function safeCastToU32(uint256 _x) internal pure returns (uint32) {\n        require(_x <= type(uint32).max, \"Overflow\");\n\n        return uint32(_x);\n    }\n\n    function safeCastToU24(uint256 _x) internal pure returns (uint24) {\n        require(_x <= type(uint24).max, \"Overflow\");\n\n        return uint24(_x);\n    }\n\n    /// @return codeLength The bytecode length in bytes\n    function bytecodeLenInBytes(bytes32 _bytecodeHash) internal pure returns (uint256 codeLength) {\n        codeLength = bytecodeLenInWords(_bytecodeHash) << 5; // _bytecodeHash * 32\n    }\n\n    /// @return codeLengthInWords The bytecode length in machine words\n    function bytecodeLenInWords(bytes32 _bytecodeHash) internal pure returns (uint256 codeLengthInWords) {\n        unchecked {\n            codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n        }\n    }\n\n    /// @notice Denotes whether bytecode hash corresponds to a contract that already constructed\n    function isContractConstructed(bytes32 _bytecodeHash) internal pure returns (bool) {\n        return _bytecodeHash[1] == 0x00;\n    }\n\n    /// @notice Denotes whether bytecode hash corresponds to a contract that is on constructor or has already been constructed\n    function isContractConstructing(bytes32 _bytecodeHash) internal pure returns (bool) {\n        return _bytecodeHash[1] == 0x01;\n    }\n\n    /// @notice Sets \"isConstructor\" flag to TRUE for the bytecode hash\n    /// @param _bytecodeHash The bytecode hash for which it is needed to set the constructing flag\n    /// @return The bytecode hash with \"isConstructor\" flag set to TRUE\n    function constructingBytecodeHash(bytes32 _bytecodeHash) internal pure returns (bytes32) {\n        // Clear the \"isConstructor\" marker and set it to 0x01.\n        return constructedBytecodeHash(_bytecodeHash) | SET_IS_CONSTRUCTOR_MARKER_BIT_MASK;\n    }\n\n    /// @notice Sets \"isConstructor\" flag to FALSE for the bytecode hash\n    /// @param _bytecodeHash The bytecode hash for which it is needed to set the constructing flag\n    /// @return The bytecode hash with \"isConstructor\" flag set to FALSE\n    function constructedBytecodeHash(bytes32 _bytecodeHash) internal pure returns (bytes32) {\n        return _bytecodeHash & ~IS_CONSTRUCTOR_BYTECODE_HASH_BIT_MASK;\n    }\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecode The bytecode to hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(bytes calldata _bytecode) internal view returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecode.length % 32 == 0, \"po\");\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        require(bytecodeLenInWords < 2 ** 16, \"pp\"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, \"pr\"); // bytecode length in words must be odd\n        hashedBytecode =\n            EfficientCall.sha(_bytecode) &\n            0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n}"
    }
  ]
}