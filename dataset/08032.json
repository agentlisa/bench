{
  "Title": "[M-01] Attacker can list an NFT they own and inflate to zero all usersâ€™ contributions, keeping the NFT and all the money",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L117-L118\n\n\n# Vulnerability details\n\n## Description\nCrowdfunds split the voting power and distribution of profits rights according to the percentage used to purchase the NFT. When an attacker lists his own NFT for sale and contributes to it, any sum he contributes will return to him once the sell is executed. This behavior is fine so long as the sell price is fair, as other contributors will receive a fair portion of voting power and equity.  Therefore, when a maximum price is defined, it is not considered a vulnerability that an attacker can contribute ```maximumPrice - totalContributions``` and take a potentially large stake of the Crowdfund, as user's have contributed knowing the potential maximum price. \n\nHowever, when maximum price is zero, which is allowed in BuyCrowdfund and CollectionBuyCrowdfund, the lister of the NFT can always steal the entirety of the fund and keep the NFT. Attacker can send a massive contribution, buy the NFT and pass a unanimous proposal to approve the NFT to his wallet. Attacker can use a flash loan to finance the initial contribution, which is easily paid back from the NFT lister wallet.\n\nIt is important to note that there is no way for the system to know if the Crowdfund creator and the NFT owner are the same entity, and therefore it is critical for the platform to defend users against this scenario.\n\n## Impact\nAny crowdfund with zero maximumPrice configured is subject to NFT lister rug pull and complete takeover of the contribution funds.\n\n## Proof of Concept\n1. Suppose totalContributions=X. Attacker will prepare flashloan callback which does:\n    * contribute() with the borrowed funds\n    * call BuyCrowdfund's buy() with a contract that will purchase the NFT using the large sum\n    * call NFT lister contract's sendProfit() function which will send attacker the NFT sell amount\n    * pay back the flash loan\n2. Attacker will call flashloan(10,000X) to buy his own NFT and take unanimous holding of created party\n3. Attacker will create ArbitraryCallsProposal with a single call to token.approve(ATTACKER, token_id). It is immediately ready for execution because attacker has > 99.99% of votes. Precious approve() is allowed in unanimous proposals.\n4. Attacker calls NFT's transferFrom() to take back control of the NFT, leaving with the Crowdfund's contribution and the listed NFT.\n\n## Tools Used\nManual audit\n\n## Recommended Mitigation Steps\nDisable the option to have unlimited maximumPrice for BuyCrowdfund and CollectionBuyCrowdfund contracts. AuctionCrowdfund is already safe by not allowing a zero maximumBid.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/crowdfund/BuyCrowdfundBase.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../tokens/IERC721.sol\";\nimport \"../party/Party.sol\";\nimport \"../utils/Implementation.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\nimport \"./Crowdfund.sol\";\n\n// Base for BuyCrowdfund and CollectionBuyCrowdfund\nabstract contract BuyCrowdfundBase is Implementation, Crowdfund {\n    using LibSafeERC721 for IERC721;\n    using LibSafeCast for uint256;\n    using LibRawResult for bytes;\n\n    struct BuyCrowdfundBaseOptions {\n        // The name of the crowdfund.\n        // This will also carry over to the governance party.\n        string name;\n        // The token symbol for both the crowdfund and the governance NFTs.\n        string symbol;\n        // How long this crowdfund has to bid on the NFT, in seconds.\n        uint40 duration;\n        // Maximum amount this crowdfund will pay for the NFT.\n        // If zero, no maximum.\n        uint96 maximumPrice;\n        // An address that receieves an extra share of the final voting power\n        // when the party transitions into governance.\n        address payable splitRecipient;\n        // What percentage (in bps) of the final total voting power `splitRecipient`\n        // receives.\n        uint16 splitBps;\n        // If ETH is attached during deployment, it will be interpreted\n        // as a contribution. This is who gets credit for that contribution.\n        address initialContributor;\n        // If there is an initial contribution, this is who they will delegate their\n        // voting power to when the crowdfund transitions to governance.\n        address initialDelegate;\n        // The gatekeeper contract to use (if non-null) to restrict who can\n        // contribute to this crowdfund.\n        IGateKeeper gateKeeper;\n        // The gatekeeper contract to use (if non-null).\n        bytes12 gateKeeperId;\n        // Governance options.\n        FixedGovernanceOpts governanceOpts;\n    }\n\n    event Won(Party party, IERC721 token, uint256 tokenId, uint256 settledPrice);\n\n    error MaximumPriceError(uint96 callValue, uint96 maximumPrice);\n    error NoContributionsError();\n    error FailedToBuyNFTError(IERC721 token, uint256 tokenId);\n    error InvalidCallTargetError(address callTarget);\n\n    /// @notice When this crowdfund expires.\n    uint40 public expiry;\n    /// @notice Maximum amount this crowdfund will pay for the NFT. If zero, no maximum.\n    uint96 public maximumPrice;\n    /// @notice What the NFT was actually bought for.\n    uint96 public settledPrice;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) Crowdfund(globals) {}\n\n    // Initialize storage for proxy contracts.\n    function _initialize(BuyCrowdfundBaseOptions memory opts)\n        internal\n    {\n        expiry = uint40(opts.duration + block.timestamp);\n        maximumPrice = opts.maximumPrice;\n        Crowdfund._initialize(CrowdfundOptions({\n            name: opts.name,\n            symbol: opts.symbol,\n            splitRecipient: opts.splitRecipient,\n            splitBps: opts.splitBps,\n            initialContributor: opts.initialContributor,\n            initialDelegate: opts.initialDelegate,\n            gateKeeper: opts.gateKeeper,\n            gateKeeperId: opts.gateKeeperId,\n            governanceOpts: opts.governanceOpts\n        }));\n    }\n\n    // Execute arbitrary calldata to perform a buy, creating a party\n    // if it successfully buys the NFT.\n    function _buy(\n        IERC721 token,\n        uint256 tokenId,\n        address payable callTarget,\n        uint96 callValue,\n        bytes calldata callData,\n        FixedGovernanceOpts memory governanceOpts\n    )\n        internal\n        onlyDelegateCall\n        returns (Party party_)\n    {\n        // Ensure the call target isn't trying to reenter or trying to do\n        // anything weird with `PartyFactory`.\n        IPartyFactory partyFactory = _getPartyFactory();\n        if (callTarget == address(partyFactory) || callTarget == address(this)) {\n            revert InvalidCallTargetError(callTarget);\n        }\n        // Check that the crowdfund is still active.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Active) {\n            revert WrongLifecycleError(lc);\n        }\n        // Used to store the price the NFT was bought for.\n        uint96 settledPrice_;\n        {\n            uint96 maximumPrice_ = maximumPrice;\n            if (maximumPrice_ != 0 && callValue > maximumPrice_) {\n                revert MaximumPriceError(callValue, maximumPrice);\n            }\n            // If the purchase would be free, set the settled price to\n            // `totalContributions` so everybody who contributed wins.\n            settledPrice_ = callValue == 0 ? totalContributions : callValue;\n            if (settledPrice_ == 0) {\n                // Still zero, which means no contributions.\n                revert NoContributionsError();\n            }\n            settledPrice = settledPrice_;\n        }\n        {\n            // Execute the call to buy the NFT.\n            (bool s, bytes memory r) = callTarget.call{ value: callValue }(callData);\n            if (!s) {\n                r.rawRevert();\n            }\n        }\n        // Make sure we acquired the NFT we want.\n        if (token.safeOwnerOf(tokenId) != address(this)) {\n            revert FailedToBuyNFTError(token, tokenId);\n        }\n        emit Won(\n            // Create a party around the newly bought NFT.\n            party_ = _createParty(partyFactory, governanceOpts, token, tokenId),\n            token,\n            tokenId,\n            settledPrice_\n        );\n    }\n\n    /// @inheritdoc Crowdfund\n    function getCrowdfundLifecycle() public override view returns (CrowdfundLifecycle) {\n        // If there is a settled price then we tried to buy the NFT.\n        if (settledPrice != 0) {\n            return address(party) != address(0)\n                // If we have a party, then we succeeded buying the NFT.\n                ? CrowdfundLifecycle.Won\n                // Otherwise we're in the middle of the buy().\n                : CrowdfundLifecycle.Busy;\n        }\n        if (block.timestamp >= expiry) {\n            // Expired but nothing to do so skip straight to lost.\n            return CrowdfundLifecycle.Lost;\n        }\n        return CrowdfundLifecycle.Active;\n    }\n\n    function _getFinalPrice()\n        internal\n        override\n        view\n        returns (uint256)\n    {\n        return settledPrice;\n    }\n}"
    }
  ]
}