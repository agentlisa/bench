{
  "Title": "[M-08] Factory::create() is vulnerable to reorg attacks",
  "Content": "\nTake a look at <https://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/mimswap/periphery/Factory.sol#L81-L90>\n\n```solidity\n    function create(address baseToken_, address quoteToken_, uint256 lpFeeRate_, uint256 i_, uint256 k_) external returns (address clone) {\n        address creator = tx.origin;\n\n        bytes32 salt = _computeSalt(creator, baseToken_, quoteToken_, lpFeeRate_, i_, k_);\n        clone = LibClone.cloneDeterministic(address(implementation), salt);\n        IMagicLP(clone).init(address(baseToken_), address(quoteToken_), lpFeeRate_, address(maintainerFeeRateModel), i_, k_);\n\n        emit LogCreated(clone, baseToken_, quoteToken_, creator, lpFeeRate_, maintainerFeeRateModel, i_, k_);\n        _addPool(creator, baseToken_, quoteToken_, clone);\n    }\n```\n\nWe can see that this function uses the `create()` logic and depends on the `tx.origin`, now Blast is suspicious of a reorg attack and protocol would be deployed on here.\n\nWhere as one can assume that the tx.origin should be different for different calls this is not really the case as going to the [Blast Explorer for transactions that are currently enqueued](https://blastexplorer.io/txsEnqueued) we can see that only two addresses are rampant as the tx.origin, i.e `0x4b16E5d33D7ab3864d53aAec93c8301C1FA4a226` and `0x6e5572f31bd9385709ec61305Afc749F0fa8fae1` what this leads is the fact that another user can just wait and due to a re-org take control of the magic lp deployment, since the tx.origin in this case would be the same with original deployer's own.\n\n### Impact\n\nNow, if users rely on the address derivation in advance or try to deploy the magiclp with the same address, any funds/tokens sent to it could potentially be withdrawn by anyone else. All in all, it could lead to the theft of user funds.\n\n### Recommended Mitigation Steps\n\nTry the deployment using create2 with salt that includes real `msg.sender`.\n\n**[0xCalibur (Abracadabra) acknowledged and commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/211#issuecomment-2000142573):**\n > This was fixed during the audit. We now use the creator address as part of the salt.\n> \n> See here:\n> https://github.com/Abracadabra-money/abracadabra-money-contracts/blob/main/src/mimswap/periphery/Factory.sol\n\n**[cccz (Judge) commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/211#issuecomment-2027181916):**\n > https://docs.code4rena.com/roles/judges/how-to-judge-a-contest#notes-on-judging\n> > Unless there is something uniquely novel created by combining vectors, most submissions regarding vulnerabilities that are inherent to a particular system or the Ethereum network as a whole should be considered QA. Examples of such vulnerabilities include front running, sandwich attacks, and MEV. In such events, leave a comment on the issue:\n> \n> As per the c4 docs, will downgrade to QA.\n\n**[Bauchibred (Warden) commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/211#issuecomment-2034212115):**\n > Hi @cccz (Judge), thanks for judging, in regards to this:\n> \n> > https://docs.code4rena.com/roles/judges/how-to-judge-a-contest#notes-on-judging\n> > \n> > > Unless there is something uniquely novel created by combining vectors, most submissions regarding vulnerabilities that are inherent to a particular system or the Ethereum network as a whole should be considered QA. Examples of such vulnerabilities include front running, sandwich attacks, and MEV. In such events, leave a comment on the issue:\n> > \n> > As per the c4 docs, will downgrade to QA.\n> \n> The idea of using this rule as the grounds for downgrading this issue seems to be flawed, cause considering this rule, do we now say all front running, MEV bug ideas are invalid on Code4rena? We beg to differ as context really matters for bug cases like this.\n> \n> In fact a similar discussion around this bug case _(very similar instance)_ was held a short while ago, can be seen [here](https://github.com/code-423n4/2023-11-canto-findings/issues/313), and the deciding lines of the validity of the report not being a medium severity  was the fact that in that instance the protocol was to be deployed on Canto, and  Canto is a fork of Evmos/Ethermint, so it uses Tendermint Core BFT consensus, which provides a 1-block finality and not probabilisitic finality like other chains: https://docs.ethermint.zone/core/pending_state.html\n> \n> But that’s not the case we have here, in this case protocol is to be deployed on Blast\n> \n> 1. Blast is an optimistic rollup, just like Arbritrum, Base, Optimism, etc.\n> 2. Optimistic rollups are known for having re-org issues.\n> 3. Not all current `satisfactory` H/M issues have been fixed by the protocol, but this was not only confirmed by the protocol but also  addressed in [this commit](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/211#issuecomment-2000142573), proving that this issue is of great value to them and accepted by them to be worthy a fix.\n> \n> Considering all the above arguments, we’d request a reassessment of this finding being validated as medium severity, thank you.\n\n**[cccz (Judge) commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/211#issuecomment-2037546373):**\n > These facts raise the likelihood of this issue, will reconsider it as M:\n> >1. Blast is an optimistic rollup, just like Arbritrum, Base, Optimism, etc.\n> >2. Optimistic rollups are known for having re-org issues.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-abracadabra-money",
  "Code": [
    {
      "filename": "src/mimswap/periphery/Factory.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {LibClone} from \"solady/utils/LibClone.sol\";\nimport {IFeeRateModel} from \"/mimswap/interfaces/IFeeRateModel.sol\";\nimport {IMagicLP} from \"/mimswap/interfaces/IMagicLP.sol\";\nimport {MagicLP} from \"/mimswap/MagicLP.sol\";\n\n/// @notice Create and register MagicLP pools\ncontract Factory is Owned {\n    event LogCreated(\n        address clone_,\n        address indexed baseToken_,\n        address indexed quoteToken_,\n        address indexed creator_,\n        uint256 lpFeeRate_,\n        IFeeRateModel maintainerFeeRateModel,\n        uint256 i_,\n        uint256 k_\n    );\n\n    event LogPoolAdded(address baseToken, address quoteToken, address creator, address pool);\n    event LogPoolRemoved(address pool);\n    event LogSetImplementation(address indexed implementation);\n    event LogSetMaintainer(address indexed newMaintainer);\n    event LogSetMaintainerFeeRateModel(IFeeRateModel newMaintainerFeeRateModel);\n\n    error ErrInvalidUserPoolIndex();\n    error ErrZeroAddress();\n\n    address public implementation;\n    IFeeRateModel public maintainerFeeRateModel;\n\n    mapping(address base => mapping(address quote => address[] pools)) public pools;\n    mapping(address creator => address[] pools) public userPools;\n\n    constructor(address implementation_, IFeeRateModel maintainerFeeRateModel_, address owner_) Owned(owner_) {\n        if (implementation_ == address(0)) {\n            revert ErrZeroAddress();\n        }\n        if (address(maintainerFeeRateModel_) == address(0)) {\n            revert ErrZeroAddress();\n        }\n        implementation = implementation_;\n        maintainerFeeRateModel = maintainerFeeRateModel_;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// VIEWS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function getPoolCount(address token0, address token1) external view returns (uint256) {\n        return pools[token0][token1].length;\n    }\n\n    function getUserPoolCount(address creator) external view returns (uint256) {\n        return userPools[creator].length;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PUBLIC\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function predictDeterministicAddress(\n        address creator,\n        address baseToken_,\n        address quoteToken_,\n        uint256 lpFeeRate_,\n        uint256 i_,\n        uint256 k_\n    ) public view returns (address) {\n        return\n            LibClone.predictDeterministicAddress(\n                implementation,\n                _computeSalt(creator, baseToken_, quoteToken_, lpFeeRate_, i_, k_),\n                address(this)\n            );\n    }\n\n    function create(address baseToken_, address quoteToken_, uint256 lpFeeRate_, uint256 i_, uint256 k_) external returns (address clone) {\n        address creator = tx.origin;\n\n        bytes32 salt = _computeSalt(creator, baseToken_, quoteToken_, lpFeeRate_, i_, k_);\n        clone = LibClone.cloneDeterministic(address(implementation), salt);\n        IMagicLP(clone).init(address(baseToken_), address(quoteToken_), lpFeeRate_, address(maintainerFeeRateModel), i_, k_);\n\n        emit LogCreated(clone, baseToken_, quoteToken_, creator, lpFeeRate_, maintainerFeeRateModel, i_, k_);\n        _addPool(creator, baseToken_, quoteToken_, clone);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// ADMIN\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function setLpImplementation(address implementation_) external onlyOwner {\n        if (implementation_ == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        implementation = implementation_;\n        emit LogSetImplementation(implementation_);\n    }\n\n    function setMaintainerFeeRateModel(IFeeRateModel maintainerFeeRateModel_) external onlyOwner {\n        if (address(maintainerFeeRateModel_) == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        maintainerFeeRateModel = maintainerFeeRateModel_;\n        emit LogSetMaintainerFeeRateModel(maintainerFeeRateModel_);\n    }\n\n    /// @notice Register a pool to the list\n    /// Note this doesn't check if the pool is valid or if it's already registered.\n    function addPool(address creator, address baseToken, address quoteToken, address pool) external onlyOwner {\n        _addPool(creator, baseToken, quoteToken, pool);\n    }\n\n    function removePool(\n        address creator,\n        address baseToken,\n        address quoteToken,\n        uint256 poolIndex,\n        uint256 userPoolIndex\n    ) external onlyOwner {\n        address[] storage _pools = pools[baseToken][quoteToken];\n        address pool = _pools[poolIndex];\n        address[] storage _userPools = userPools[creator];\n\n        _pools[poolIndex] = _pools[_pools.length - 1];\n        _pools.pop();\n\n        if (_userPools[userPoolIndex] != pool) {\n            revert ErrInvalidUserPoolIndex();\n        }\n\n        _userPools[userPoolIndex] = _userPools[_userPools.length - 1];\n        _userPools.pop();\n\n        emit LogPoolRemoved(pool);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// INTERNALS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _addPool(address creator, address baseToken, address quoteToken, address pool) internal {\n        pools[baseToken][quoteToken].push(pool);\n        userPools[creator].push(pool);\n\n        emit LogPoolAdded(baseToken, quoteToken, creator, pool);\n    }\n\n    function _computeSalt(\n        address sender_,\n        address baseToken_,\n        address quoteToken_,\n        uint256 lpFeeRate_,\n        uint256 i_,\n        uint256 k_\n    ) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(sender_, implementation, baseToken_, quoteToken_, lpFeeRate_, i_, k_));\n    }\n}"
    }
  ]
}