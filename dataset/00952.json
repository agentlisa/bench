{
  "Title": "Missing minimum token amounts in the emergency contract functions allows MEV bots to take advantage of the protocols emergency situation",
  "Content": "# Missing minimum token amounts in the emergency contract functions allows MEV bots to take advantage of the protocols emergency situation\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L83-L90\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L83-L90</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L54-L61\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L54-L61</a>\n\n\n## Summary\n\nWhen an emergency situation arises and the protocol pauses or resumes the operation of the vault. All funds of the vault are removed from GMX or added back to GMX without any protection against slippage. This allows MEV bots to take advantage of the protocol's emergency situation and make huge profits with it.\n\n## Vulnerability Details\n\nWhen an emergency situation arises the protocol owners can call the emergencyPause function to remove all the liquidity from GMX:\n\n```jsx\nfunction emergencyPause(\n  GMXTypes.Store storage self\n) external {\n  self.refundee = payable(msg.sender);\n\n  GMXTypes.RemoveLiquidityParams memory _rlp;\n\n  // Remove all of the vault's LP tokens\n  _rlp.lpAmt = self.lpToken.balanceOf(address(this));\n  _rlp.executionFee = msg.value;\n\n  GMXManager.removeLiquidity(\n    self,\n    _rlp\n  );\n\n  self.status = GMXTypes.Status.Paused;\n\n  emit EmergencyPause();\n}\n```\n\nBut the minimum tokens amount to get back when removing liquidity is not provided to the RemoveLiquidityParams:\n\n```jsx\nstruct RemoveLiquidityParams {\n  // Amount of lpToken to remove liquidity\n  uint256 lpAmt;\n  // Array of market token in array to swap tokenA to other token in market\n  address[] tokenASwapPath;\n  // Array of market token in array to swap tokenB to other token in market\n  address[] tokenBSwapPath;\n  // Minimum amount of tokenA to receive in token decimals\n  uint256 minTokenAAmt;\n  // Minimum amount of tokenB to receive in token decimals\n  uint256 minTokenBAmt;\n  // Execution fee sent to GMX for removing liquidity\n  uint256 executionFee;\n}\n```\n\nAs it is not set, the default value 0 (uint256) is used. Therefore, up to 100% slippage is allowed.\n\nThe same parameters are also missing when normal operation resumes:\n\n```jsx\nfunction emergencyResume(\n  GMXTypes.Store storage self\n) external {\n  GMXChecks.beforeEmergencyResumeChecks(self);\n\n  self.status = GMXTypes.Status.Resume;\n\n  self.refundee = payable(msg.sender);\n\n  GMXTypes.AddLiquidityParams memory _alp;\n\n  _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n  _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n  _alp.executionFee = msg.value;\n\n  GMXManager.addLiquidity(\n    self,\n    _alp\n  );\n}\n```\n\nTherefore, MEV bots could take advantage of the protocol's emergency situation and as these trades include all funds of the vault it could lead to a big loss.\n\nIgnoring slippage when pausing could be a design choice of the protocol to avoid the possibility of a revert and pause the system as quickly as possible. However, this argument does not apply during the resume.\n\n## Impact\n\nBig loss of funds as all funds of the strategy vault are unprotected against MEV bots.\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\nImplement a custom minMarketTokens parameter, but do not implement the usual slippage calculation, as this could potentially lead to new critical vulnerabilities. If for example the reason for this emergency situation is a no longer supported chainlink feed, which will lead to reverts and therefore also to DoS of the emergency close / withdraw flow.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXEmergency.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\n\n/**\n  * @title GMXEmergency\n  * @author Steadefi\n  * @notice Re-usable library functions for emergency operations for Steadefi leveraged vaults\n*/\nlibrary GMXEmergency {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant DUST_AMOUNT = 1e17;\n\n  /* ======================== EVENTS ========================= */\n\n  event EmergencyPause();\n  event EmergencyResume();\n  event EmergencyClose(\n    uint256 repayTokenAAmt,\n    uint256 repayTokenBAmt\n  );\n  event EmergencyWithdraw(\n    address indexed user,\n    uint256 sharesAmt,\n    address assetA,\n    uint256 assetAAmt,\n    address assetB,\n    uint256 assetBAmt\n  );\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyPause(\n    GMXTypes.Store storage self\n  ) external {\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // Remove all of the vault's LP tokens\n    _rlp.lpAmt = self.lpToken.balanceOf(address(this));\n    _rlp.executionFee = msg.value;\n\n    GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    self.status = GMXTypes.Status.Paused;\n\n    emit EmergencyPause();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Resume;\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.executionFee = msg.value;\n\n    GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processEmergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit EmergencyResume();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyClose(\n    GMXTypes.Store storage self,\n    uint256 deadline\n  ) external {\n    GMXChecks.beforeEmergencyCloseChecks(self);\n\n    // Repay all borrowed assets; 1e18 == 100% shareRatio to repay\n    GMXTypes.RepayParams memory _rp;\n    (\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    ) = GMXManager.calcRepay(self, 1e18);\n\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = deadline;\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    GMXManager.repay(\n      self,\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n\n    self.status = GMXTypes.Status.Closed;\n\n    emit EmergencyClose(\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyWithdraw(\n    GMXTypes.Store storage self,\n    uint256 shareAmt\n  ) external {\n    // check to ensure shares withdrawn does not exceed user's balance\n    uint256 _userShareBalance = IERC20(address(self.vault)).balanceOf(msg.sender);\n\n    // to avoid leaving dust behind\n    unchecked {\n      if (_userShareBalance - shareAmt < DUST_AMOUNT) {\n        shareAmt = _userShareBalance;\n      }\n    }\n\n    GMXChecks.beforeEmergencyWithdrawChecks(self, shareAmt);\n\n    // share ratio calculation must be before burn()\n    uint256 _shareRatio = shareAmt * SAFE_MULTIPLIER\n                          / IERC20(address(self.vault)).totalSupply();\n\n    self.vault.burn(msg.sender, shareAmt);\n\n    uint256 _withdrawAmtTokenA = _shareRatio\n                                 * self.tokenA.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n    uint256 _withdrawAmtTokenB = _shareRatio\n                                 * self.tokenB.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n\n    self.tokenA.safeTransfer(msg.sender, _withdrawAmtTokenA);\n    self.tokenB.safeTransfer(msg.sender, _withdrawAmtTokenB);\n\n    emit EmergencyWithdraw(\n      msg.sender,\n      shareAmt,\n      address(self.tokenA),\n      _withdrawAmtTokenA,\n      address(self.tokenB),\n      _withdrawAmtTokenB\n    );\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXEmergency.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\n\n/**\n  * @title GMXEmergency\n  * @author Steadefi\n  * @notice Re-usable library functions for emergency operations for Steadefi leveraged vaults\n*/\nlibrary GMXEmergency {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant DUST_AMOUNT = 1e17;\n\n  /* ======================== EVENTS ========================= */\n\n  event EmergencyPause();\n  event EmergencyResume();\n  event EmergencyClose(\n    uint256 repayTokenAAmt,\n    uint256 repayTokenBAmt\n  );\n  event EmergencyWithdraw(\n    address indexed user,\n    uint256 sharesAmt,\n    address assetA,\n    uint256 assetAAmt,\n    address assetB,\n    uint256 assetBAmt\n  );\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyPause(\n    GMXTypes.Store storage self\n  ) external {\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // Remove all of the vault's LP tokens\n    _rlp.lpAmt = self.lpToken.balanceOf(address(this));\n    _rlp.executionFee = msg.value;\n\n    GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    self.status = GMXTypes.Status.Paused;\n\n    emit EmergencyPause();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Resume;\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.executionFee = msg.value;\n\n    GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processEmergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit EmergencyResume();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyClose(\n    GMXTypes.Store storage self,\n    uint256 deadline\n  ) external {\n    GMXChecks.beforeEmergencyCloseChecks(self);\n\n    // Repay all borrowed assets; 1e18 == 100% shareRatio to repay\n    GMXTypes.RepayParams memory _rp;\n    (\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    ) = GMXManager.calcRepay(self, 1e18);\n\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = deadline;\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    GMXManager.repay(\n      self,\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n\n    self.status = GMXTypes.Status.Closed;\n\n    emit EmergencyClose(\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyWithdraw(\n    GMXTypes.Store storage self,\n    uint256 shareAmt\n  ) external {\n    // check to ensure shares withdrawn does not exceed user's balance\n    uint256 _userShareBalance = IERC20(address(self.vault)).balanceOf(msg.sender);\n\n    // to avoid leaving dust behind\n    unchecked {\n      if (_userShareBalance - shareAmt < DUST_AMOUNT) {\n        shareAmt = _userShareBalance;\n      }\n    }\n\n    GMXChecks.beforeEmergencyWithdrawChecks(self, shareAmt);\n\n    // share ratio calculation must be before burn()\n    uint256 _shareRatio = shareAmt * SAFE_MULTIPLIER\n                          / IERC20(address(self.vault)).totalSupply();\n\n    self.vault.burn(msg.sender, shareAmt);\n\n    uint256 _withdrawAmtTokenA = _shareRatio\n                                 * self.tokenA.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n    uint256 _withdrawAmtTokenB = _shareRatio\n                                 * self.tokenB.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n\n    self.tokenA.safeTransfer(msg.sender, _withdrawAmtTokenA);\n    self.tokenB.safeTransfer(msg.sender, _withdrawAmtTokenB);\n\n    emit EmergencyWithdraw(\n      msg.sender,\n      shareAmt,\n      address(self.tokenA),\n      _withdrawAmtTokenA,\n      address(self.tokenB),\n      _withdrawAmtTokenB\n    );\n  }\n}"
    }
  ]
}