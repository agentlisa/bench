{
  "Title": "[L-07] Inefficient ERC20 allowance handling",
  "Content": "The below pattern is used in multiple instances to set an unlimited allowance in case the current value is lower than necessary:\n\n```solidity\nuint256 allowance = IERC20(_token).allowance(address(this), _spender);\nif (allowance < _value) {\n\tIERC20(_token).safeIncreaseAllowance(_spender, type(uint256).max - allowance);\n}\n```\n\nOccurrences of this pattern can be found in:\n[Dispatcher.sol#L272](https://github.com/perspectivefi/spectra-core/blob/fec59dc6720fb4861b07b30845ef2c1a42f947bf/src/router/Dispatcher.sol#L272)  \n[Router.sol#L165](https://github.com/perspectivefi/spectra-core/blob/fec59dc6720fb4861b07b30845ef2c1a42f947bf/src/router/Router.sol#L165)  \n[Factory.sol#L263](https://github.com/perspectivefi/spectra-core/blob/fec59dc6720fb4861b07b30845ef2c1a42f947bf/src/factory/Factory.sol#L263)\n\nHowever, `safeIncreaseAllowance()` will simply poll the current allowance again and add it back to the value passed in the argument before calling `forceApprove()`:\n\n```solidity\nfunction safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n\tuint256 oldAllowance = token.allowance(address(this), spender);\n\tforceApprove(token, spender, oldAllowance + value);\n}\n```\n\nCalling `forceApprove()` directly would be clearer and more gas efficient:\n\n```solidity\nuint256 allowance = IERC20(_token).allowance(address(this), _spender);\nif (allowance < _value) {\n\tIERC20(_token).forceApprove(_spender, type(uint256).max);\n}\n```",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/router/Dispatcher.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport \"openzeppelin-math/Math.sol\";\nimport \"../libraries/RayMath.sol\";\nimport \"../libraries/CurvePoolUtil.sol\";\nimport \"openzeppelin-contracts-upgradeable/access/manager/AccessManagedUpgradeable.sol\";\nimport {IERC20Permit} from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport {IERC4626} from \"openzeppelin-contracts/interfaces/IERC4626.sol\";\nimport {IPrincipalToken} from \"src/interfaces/IPrincipalToken.sol\";\nimport {SafeERC20} from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC3156FlashBorrower} from \"openzeppelin-contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"openzeppelin-contracts/interfaces/IERC3156FlashLender.sol\";\nimport {Commands} from \"./Commands.sol\";\nimport {Constants} from \"./Constants.sol\";\nimport {ICurvePool} from \"../interfaces/ICurvePool.sol\";\nimport {RouterUtil} from \"./util/RouterUtil.sol\";\n\nabstract contract Dispatcher is AccessManagedUpgradeable {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n    using RayMath for uint256;\n\n    error InvalidCommandType(uint256 commandType);\n    error MinimumBalanceNotReached(\n        address token,\n        address owner,\n        uint256 minimumBalance,\n        uint256 actualBalance\n    );\n    error InvalidTokenIndex(uint256 i, uint256 j);\n    error AddressError();\n\n    address internal msgSender;\n    address public routerUtil;\n\n    function initializeDispatcher(\n        address _routerUtil,\n        address _initialAuthority\n    ) internal initializer {\n        if (_routerUtil == address(0)) {\n            revert AddressError();\n        }\n        routerUtil = _routerUtil;\n        __AccessManaged_init(_initialAuthority);\n    }\n\n    /**\n     * @dev Setter for the router utility contract\n     * @param _newRouterUtil the new address of the router utility contract\n     */\n    function setRouterUtil(address _newRouterUtil) external restricted {\n        if (_newRouterUtil == address(0)) {\n            revert AddressError();\n        }\n        if (_newRouterUtil == routerUtil) {\n            return;\n        }\n        routerUtil = _newRouterUtil;\n    }\n\n    /**\n     * @dev Executes a single command along with its encoded input data\n     * @param _commandType encoded representation of the command\n     * @param _inputs calldata carrying the arguments to the functions that should be called\n     */\n    function _dispatch(bytes1 _commandType, bytes calldata _inputs) internal {\n        uint256 command = uint8(_commandType & Commands.COMMAND_TYPE_MASK);\n\n        if (command == Commands.TRANSFER_FROM) {\n            (address token, uint256 value) = abi.decode(_inputs, (address, uint256));\n            IERC20(token).safeTransferFrom(msgSender, address(this), value);\n        } else if (command == Commands.TRANSFER_FROM_WITH_PERMIT) {\n            (address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) = abi\n                .decode(_inputs, (address, uint256, uint256, uint8, bytes32, bytes32));\n            IERC20Permit(token).permit(msgSender, address(this), value, deadline, v, r, s);\n            IERC20(token).safeTransferFrom(msgSender, address(this), value);\n        } else if (command == Commands.TRANSFER) {\n            (address token, address recipient, uint256 value) = abi.decode(\n                _inputs,\n                (address, address, uint256)\n            );\n            recipient = _resolveAddress(recipient);\n            IERC20(token).safeTransfer(\n                recipient,\n                value == Constants.CONTRACT_BALANCE ? IERC20(token).balanceOf(address(this)) : value\n            );\n        } else if (command == Commands.CURVE_SWAP) {\n            (\n                address pool,\n                uint256 i,\n                uint256 j,\n                uint256 amountIn,\n                uint256 minAmountOut,\n                address recipient\n            ) = abi.decode(_inputs, (address, uint256, uint256, uint256, uint256, address));\n            address token = ICurvePool(pool).coins(i);\n            amountIn = _resolveTokenValue(token, amountIn);\n            recipient = _resolveAddress(recipient);\n            _ensureApproved(token, pool, amountIn); // pool.coins(i) is the token to be swapped\n            ICurvePool(pool).exchange(\n                i,\n                j,\n                amountIn,\n                minAmountOut,\n                false, // Do not use ETH\n                recipient\n            );\n        } else if (command == Commands.DEPOSIT_ASSET_IN_IBT) {\n            (address ibt, uint256 assets, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            address asset = IERC4626(ibt).asset();\n            assets = _resolveTokenValue(asset, assets);\n            recipient = _resolveAddress(recipient);\n            _ensureApproved(asset, ibt, assets);\n            IERC4626(ibt).deposit(assets, recipient);\n        } else if (command == Commands.DEPOSIT_ASSET_IN_PT) {\n            (address pt, uint256 assets, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            address asset = IPrincipalToken(pt).underlying();\n            assets = _resolveTokenValue(asset, assets);\n            recipient = _resolveAddress(recipient);\n            _ensureApproved(asset, pt, assets);\n            IPrincipalToken(pt).deposit(assets, recipient);\n        } else if (command == Commands.DEPOSIT_IBT_IN_PT) {\n            (address pt, uint256 ibts, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            address ibt = IPrincipalToken(pt).getIBT();\n            ibts = _resolveTokenValue(ibt, ibts);\n            recipient = _resolveAddress(recipient);\n            _ensureApproved(ibt, pt, ibts);\n            IPrincipalToken(pt).depositIBT(ibts, recipient);\n        } else if (\n            command == Commands.REDEEM_IBT_FOR_ASSET || command == Commands.REDEEM_PT_FOR_ASSET\n        ) {\n            // Redeems an ERC4626 IBT or a PT for the corresponding ERC20 underlying\n            // token represents the target IBT/PT and shares represents the amount of IBT/PT to redeem\n            (address token, uint256 shares, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            shares = _resolveTokenValue(token, shares);\n            recipient = _resolveAddress(recipient);\n            IERC4626(token).redeem(shares, recipient, address(this));\n        } else if (command == Commands.REDEEM_PT_FOR_IBT) {\n            (address pt, uint256 shares, address recipient) = abi.decode(\n                _inputs,\n                (address, uint256, address)\n            );\n            shares = _resolveTokenValue(pt, shares);\n            recipient = _resolveAddress(recipient);\n            IPrincipalToken(pt).redeemForIBT(shares, recipient, address(this));\n        } else if (command == Commands.FLASH_LOAN) {\n            (\n                IERC3156FlashLender lender,\n                IERC3156FlashBorrower receiver,\n                address token,\n                uint256 amount,\n                bytes memory data\n            ) = abi.decode(\n                    _inputs,\n                    (IERC3156FlashLender, IERC3156FlashBorrower, address, uint256, bytes)\n                );\n            lender.flashLoan(receiver, token, amount, data);\n        } else if (command == Commands.CURVE_SPLIT_IBT_LIQUIDITY) {\n            (address pool, uint256 ibts, address recipient, address ytRecipient) = abi.decode(\n                _inputs,\n                (address, uint256, address, address)\n            );\n            recipient = _resolveAddress(recipient);\n            ytRecipient = _resolveAddress(ytRecipient);\n            address ibt = ICurvePool(pool).coins(0);\n            address pt = ICurvePool(pool).coins(1);\n            ibts = _resolveTokenValue(ibt, ibts);\n            uint256 ibtToDepositInPT = CurvePoolUtil.calcIBTsToTokenizeForCurvePool(ibts, pool, pt);\n            if (ibtToDepositInPT != 0) {\n                _ensureApproved(ibt, pt, ibtToDepositInPT);\n                IPrincipalToken(pt).depositIBT(ibtToDepositInPT, recipient, ytRecipient);\n            }\n            if (recipient != address(this)) {\n                IERC20(ibt).safeTransfer(recipient, ibts - ibtToDepositInPT);\n            }\n        } else if (command == Commands.CURVE_ADD_LIQUIDITY) {\n            (\n                address pool,\n                uint256[2] memory amounts,\n                uint256 min_mint_amount,\n                address recipient\n            ) = abi.decode(_inputs, (address, uint256[2], uint256, address));\n            recipient = _resolveAddress(recipient);\n            address ibt = ICurvePool(pool).coins(0);\n            address pt = ICurvePool(pool).coins(1);\n            amounts[0] = _resolveTokenValue(ibt, amounts[0]);\n            amounts[1] = _resolveTokenValue(pt, amounts[1]);\n            _ensureApproved(ibt, pool, amounts[0]);\n            _ensureApproved(pt, pool, amounts[1]);\n            ICurvePool(pool).add_liquidity(amounts, min_mint_amount, false, recipient);\n        } else if (command == Commands.CURVE_REMOVE_LIQUIDITY) {\n            (address pool, uint256 lps, uint256[2] memory min_amounts, address recipient) = abi\n                .decode(_inputs, (address, uint256, uint256[2], address));\n            recipient = _resolveAddress(recipient);\n            address lpToken = ICurvePool(pool).token();\n            lps = _resolveTokenValue(lpToken, lps);\n            _ensureApproved(lpToken, pool, lps);\n            ICurvePool(pool).remove_liquidity(lps, min_amounts, false, recipient);\n        } else if (command == Commands.CURVE_REMOVE_LIQUIDITY_ONE_COIN) {\n            (address pool, uint256 lps, uint256 i, uint256 min_amount, address recipient) = abi\n                .decode(_inputs, (address, uint256, uint256, uint256, address));\n            recipient = _resolveAddress(recipient);\n            address lpToken = ICurvePool(pool).token();\n            lps = _resolveTokenValue(lpToken, lps);\n            _ensureApproved(lpToken, pool, lps);\n            ICurvePool(pool).remove_liquidity_one_coin(lps, i, min_amount, false, recipient);\n        } else if (command == Commands.ASSERT_MIN_BALANCE) {\n            (address token, address owner, uint256 minValue) = abi.decode(\n                _inputs,\n                (address, address, uint256)\n            );\n            owner = _resolveAddress(owner);\n            uint256 balance = IERC20(token).balanceOf(owner);\n            if (balance < minValue) {\n                revert MinimumBalanceNotReached(token, owner, minValue, balance);\n            }\n        } else {\n            revert InvalidCommandType(command);\n        }\n    }\n\n    /**\n     * @dev Returns either the input token value as is, or replaced with its corresponding behaviour in Constants.sol\n     * @param _token address of the token\n     * @param _value token amount\n     * @return The amount stored previously if current amount used for detecting contract balance, else current value\n     */\n    function _resolveTokenValue(address _token, uint256 _value) internal view returns (uint256) {\n        if (_value == Constants.CONTRACT_BALANCE) {\n            return IERC20(_token).balanceOf(address(this));\n        } else {\n            return _value;\n        }\n    }\n\n    /**\n     * @dev Returns either the input address as is, or replaced with its corresponding behaviour in Constants.sol\n     * @param _input input address\n     * @return address corresponding to input\n     */\n    function _resolveAddress(address _input) internal view returns (address) {\n        if (_input == Constants.ADDRESS_THIS) {\n            return address(this);\n        } else if (_input == Constants.MSG_SENDER) {\n            return msgSender;\n        } else {\n            return _input;\n        }\n    }\n\n    /**\n     * @dev Checks the allowance of a token and approves the spender if necessary\n     * @param _token address of the token to be approved\n     * @param _spender address of the spender\n     * @param _value token amount\n     */\n    function _ensureApproved(address _token, address _spender, uint256 _value) internal {\n        uint256 allowance = IERC20(_token).allowance(address(this), _spender);\n        if (allowance < _value) {\n            // This approval will only be executed the first time to save gas for subsequent operations\n            IERC20(_token).safeIncreaseAllowance(_spender, type(uint256).max - allowance);\n        }\n    }\n\n    /**\n     * Simulates the execution of batched commands.\n     * @param _commandType Type of command to be executed.\n     * @param _inputs Calldata for the commands.\n     * @param _spot If true, the preview uses the spot exchange rate. Otherwise, includes price impact and curve pool fees.\n     * @param _previousAmount Amount of tokens from the previous command.\n     * @return The preview of the rate and token amount in 27 decimals precision.\n     */\n    function _dispatchPreviewRate(\n        bytes1 _commandType,\n        bytes calldata _inputs,\n        bool _spot,\n        uint256 _previousAmount\n    ) internal view returns (uint256, uint256) {\n        uint256 command = uint8(_commandType & Commands.COMMAND_TYPE_MASK);\n        if (command == Commands.TRANSFER_FROM || command == Commands.TRANSFER_FROM_WITH_PERMIT) {\n            // Does not affect the rate, but amount is now set as the input value\n            (address token, uint256 value) = abi.decode(_inputs, (address, uint256));\n            if (_spot) {\n                return (RayMath.RAY_UNIT, RouterUtil(routerUtil).getUnit(token));\n            } else {\n                return (RayMath.RAY_UNIT, value);\n            }\n        } else if (command == Commands.TRANSFER) {\n            return (RayMath.RAY_UNIT, 0);\n        }\n        // Does not affect the amount\n        else if (command == Commands.CURVE_SWAP) {\n            (address pool, uint256 i, uint256 j, uint256 amountIn, , ) = abi.decode(\n                _inputs,\n                (address, uint256, uint256, uint256, uint256, address)\n            );\n            uint256 exchangeRate;\n            if (_spot) {\n                exchangeRate = RouterUtil(routerUtil).spotExchangeRate(pool, i, j).toRay(\n                    CurvePoolUtil.CURVE_DECIMALS\n                );\n            } else {\n                amountIn = _resolvePreviewTokenValue(amountIn, _previousAmount);\n                exchangeRate = ICurvePool(pool).get_dy(i, j, amountIn).mulDiv(\n                    RayMath.RAY_UNIT,\n                    amountIn\n                );\n            }\n            return (exchangeRate, 0);\n        } else if (command == Commands.DEPOSIT_ASSET_IN_IBT) {\n            (address ibt, uint256 assets, ) = abi.decode(_inputs, (address, uint256, address));\n            if (_spot) {\n                assets = RouterUtil(routerUtil).getUnit(ibt);\n            } else {\n                assets = _resolvePreviewTokenValue(assets, _previousAmount);\n            }\n            // rate : shares * rayUnit / assets\n            return (IERC4626(ibt).previewDeposit(assets).mulDiv(RayMath.RAY_UNIT, assets), 0);\n        } else if (command == Commands.DEPOSIT_ASSET_IN_PT) {\n            (address pt, uint256 assets, ) = abi.decode(_inputs, (address, uint256, address));\n            if (_spot) {\n                assets = RouterUtil(routerUtil).getUnderlyingUnit(pt);\n            } else {\n                assets = _resolvePreviewTokenValue(assets, _previousAmount);\n            }\n            // rate : shares * rayUnit / assets\n            return (IPrincipalToken(pt).previewDeposit(assets).mulDiv(RayMath.RAY_UNIT, assets), 0);\n        } else if (command == Commands.DEPOSIT_IBT_IN_PT) {\n            (address pt, uint256 ibts, ) = abi.decode(_inputs, (address, uint256, address));\n            if (_spot) {\n                ibts = RouterUtil(routerUtil).getUnit(pt);\n            } else {\n                ibts = _resolvePreviewTokenValue(ibts, _previousAmount);\n            }\n            // rate : shares * rayUnit / ibts\n            return (IPrincipalToken(pt).previewDepositIBT(ibts).mulDiv(RayMath.RAY_UNIT, ibts), 0);\n        } else if (\n            command == Commands.REDEEM_IBT_FOR_ASSET || command == Commands.REDEEM_PT_FOR_ASSET\n        ) {\n            (address token, uint256 shares, ) = abi.decode(_inputs, (address, uint256, address));\n            if (_spot) {\n                shares = RouterUtil(routerUtil).getUnit(token);\n            } else {\n                shares = _resolvePreviewTokenValue(shares, _previousAmount);\n            }\n            // rate : assets * rayUnit / shares\n            return (IERC4626(token).previewRedeem(shares).mulDiv(RayMath.RAY_UNIT, shares), 0);\n        } else if (command == Commands.REDEEM_PT_FOR_IBT) {\n            (address pt, uint256 shares, ) = abi.decode(_inputs, (address, uint256, address));\n            if (_spot) {\n                shares = RouterUtil(routerUtil).getUnit(pt);\n            } else {\n                shares = _resolvePreviewTokenValue(shares, _previousAmount);\n            }\n            // rate : ibts * rayUnit / shares\n            return (\n                IPrincipalToken(pt).previewRedeemForIBT(shares).mulDiv(RayMath.RAY_UNIT, shares),\n                0\n            );\n        } else if (command == Commands.ASSERT_MIN_BALANCE) {\n            return (RayMath.RAY_UNIT, 0);\n        } else {\n            revert InvalidCommandType(command);\n        }\n    }\n\n    /**\n     * @dev Returns either the input value as is or replaced with its corresponding behaviour in Constants.sol,\n     * taking into account the previous amount in preview mode as if it were the contract balance\n     * @param _value current value\n     * @param _previousAmount previous value\n     * @return The actual amount of tokens one needs\n     */\n    function _resolvePreviewTokenValue(\n        uint256 _value,\n        uint256 _previousAmount\n    ) internal pure returns (uint256) {\n        // In preview mode, the amount returned from the previous operation is used\n        // to simulate the contract balance.\n        if (_value == Constants.CONTRACT_BALANCE) {\n            return _previousAmount;\n        } else {\n            return _value;\n        }\n    }\n}"
    },
    {
      "filename": "src/router/Router.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport \"openzeppelin-math/Math.sol\";\nimport \"../libraries/RayMath.sol\";\nimport {IERC20} from \"openzeppelin-contracts/interfaces/IERC20.sol\";\nimport {SafeERC20} from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable2StepUpgradeable} from \"openzeppelin-contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport {IERC3156FlashBorrower} from \"openzeppelin-contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport {Dispatcher} from \"./Dispatcher.sol\";\nimport {IRouter} from \"../interfaces/IRouter.sol\";\n\ncontract Router is Dispatcher, IRouter, Ownable2StepUpgradeable, IERC3156FlashBorrower {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    bytes32 private immutable ON_FLASH_LOAN = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n\n    /**\n     * @notice Constructor of the contract\n     */\n    constructor() {\n        _disableInitializers(); // using this so that the deployed logic contract later cannot be initialized.\n    }\n\n    /**\n     * @notice Initializer of the contract.\n     */\n    function initialize(address _routerUtil, address _initialAuthority) external initializer {\n        __Ownable_init(_msgSender());\n        initializeDispatcher(_routerUtil, _initialAuthority);\n    }\n\n    /**\n     * @inheritdoc IRouter\n     */\n    function execute(\n        bytes calldata _commands,\n        bytes[] calldata _inputs,\n        uint256 _deadline\n    ) external payable override checkDeadline(_deadline) {\n        execute(_commands, _inputs);\n    }\n\n    /**\n     * @inheritdoc IRouter\n     */\n    function execute(bytes calldata _commands, bytes[] calldata _inputs) public payable override {\n        uint256 numCommands = _commands.length;\n        if (_inputs.length != numCommands) {\n            revert LengthMismatch();\n        }\n\n        // Relying on msg.sender is problematic as it changes during a flash loan.\n        // Thus, it's necessary to track who initiated the original Router execution.\n        if (msgSender == address(0)) {\n            msgSender = msg.sender;\n        }\n        // loop through all given commands, execute them and pass along outputs as defined\n        for (uint256 commandIndex; commandIndex < numCommands; ) {\n            bytes1 command = _commands[commandIndex];\n\n            bytes calldata input = _inputs[commandIndex];\n\n            _dispatch(command, input);\n            unchecked {\n                commandIndex++;\n            }\n        }\n        if (msgSender == msg.sender)\n            // top-level reset\n            msgSender = address(0);\n    }\n\n    /**\n     * Simulates the execution of a sequence of commands and returns the preview value for the return rate.\n     * @param _commands Encoded instructions passed to the dispatcher.\n     * @param _inputs Encoded arguments to pass to the functions called in the corresponding commands.\n     * @param _spot If true, previews the spot rate; otherwise, takes into account price impact and curve pool fees.\n     * @return The preview value for the return rate, expressed in ray (the rate is defined as the amount of tokens\n     * returned at the end of the sequence of operations executed by the router per unit of token sent to the contract).\n     */\n    function _previewRate(\n        bytes calldata _commands,\n        bytes[] calldata _inputs,\n        bool _spot\n    ) internal view returns (uint256) {\n        uint256 numCommands = _commands.length;\n        if (_inputs.length != numCommands) {\n            revert LengthMismatch();\n        }\n\n        uint256 previousAmount;\n        uint256 rate = RayMath.RAY_UNIT;\n\n        // loop through all given commands, execute them and pass along outputs as defined\n        for (uint256 commandIndex; commandIndex < numCommands; ) {\n            bytes1 command = _commands[commandIndex];\n            bytes calldata input = _inputs[commandIndex];\n\n            (uint256 commandRate, uint256 commandAmount) = _dispatchPreviewRate(\n                command,\n                input,\n                _spot,\n                previousAmount\n            );\n\n            if (commandRate != RayMath.RAY_UNIT) {\n                rate = rate.mulDiv(commandRate, RayMath.RAY_UNIT);\n            }\n\n            if (commandAmount != 0) {\n                previousAmount = commandAmount; // Keep track of the previous amount if it is forced\n            } else if (commandRate != RayMath.RAY_UNIT) {\n                previousAmount = previousAmount.mulDiv(commandRate, RayMath.RAY_UNIT); // If not, compute the new amount\n            }\n\n            unchecked {\n                commandIndex++;\n            }\n        }\n        return rate;\n    }\n\n    /**\n     * @inheritdoc IRouter\n     */\n\n    function previewRate(\n        bytes calldata _commands,\n        bytes[] calldata _inputs\n    ) external view override returns (uint256) {\n        return _previewRate(_commands, _inputs, false);\n    }\n\n    /**\n     * @inheritdoc IRouter\n     */\n    function previewSpotRate(\n        bytes calldata _commands,\n        bytes[] calldata _inputs\n    ) external view override returns (uint256) {\n        return _previewRate(_commands, _inputs, true);\n    }\n\n    /**\n     * @inheritdoc IERC3156FlashBorrower\n     */\n    function onFlashLoan(\n        address /* initiator */,\n        address _token,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _data\n    ) external returns (bytes32) {\n        (bytes memory commands, bytes[] memory inputs) = abi.decode(_data, (bytes, bytes[]));\n        this.execute(commands, inputs); // https://ethereum.stackexchange.com/questions/103437/converting-bytes-memory-to-bytes-calldata\n        uint256 repayAmount = _amount + _fee;\n        uint256 allowance = IERC20(_token).allowance(address(this), msg.sender);\n        if (allowance < repayAmount) {\n            // Approve the lender to pull the funds if needed\n            IERC20(_token).safeIncreaseAllowance(msg.sender, repayAmount - allowance);\n        }\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        if (balance < repayAmount) {\n            // Collect remaining debt from the original sender if needed\n            IERC20(_token).safeTransferFrom(msgSender, address(this), repayAmount - balance);\n        }\n        return ON_FLASH_LOAN;\n    }\n}"
    },
    {
      "filename": "src/factory/Factory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport \"openzeppelin-math/Math.sol\";\nimport \"../libraries/CurvePoolUtil.sol\";\nimport \"../interfaces/IFactory.sol\";\nimport \"../interfaces/ICurvePool.sol\";\nimport \"../interfaces/ICurveFactory.sol\";\nimport \"../interfaces/IPrincipalToken.sol\";\nimport \"../interfaces/IRegistry.sol\";\nimport \"../libraries/Roles.sol\";\nimport \"openzeppelin-contracts/access/manager/IAccessManager.sol\";\nimport \"openzeppelin-contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/access/manager/AccessManagedUpgradeable.sol\";\nimport \"openzeppelin-contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract Factory is IFactory, AccessManagedUpgradeable {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    bytes4 constant PAUSE_SELECTOR = IPrincipalToken(address(0)).pause.selector;\n    bytes4 constant UNPAUSE_SELECTOR = IPrincipalToken(address(0)).unPause.selector;\n    bytes4 constant SET_REWARDS_PROXY_SELECTOR =\n        IPrincipalToken(address(0)).setRewardsProxy.selector;\n    bytes4 constant CLAIM_REWARDS_SELECTOR = IPrincipalToken(address(0)).claimRewards.selector;\n    /* State\n     *****************************************************************************************************************/\n\n    address private registry;\n    address private curveAddressProvider;\n    address private curveFactory;\n\n    /* Events\n     *****************************************************************************************************************/\n\n    event PTDeployed(address indexed pt, address indexed poolCreator);\n    event CurvePoolDeployed(address indexed poolAddress, address indexed ibt, address indexed pt);\n    event RegistryChange(address indexed previousRegistry, address indexed newRegistry);\n    event CurveFactoryChange(address indexed previousFactory, address indexed newFactory);\n    event CurveAddressProviderChange(\n        address indexed previousCurveAddressProvider,\n        address indexed newCurveAddressProvider\n    );\n\n    /**\n     * @notice Constructor of the contract\n     */\n    constructor() {\n        _disableInitializers(); // using this so that the deployed logic contract later cannot be initialized.\n    }\n\n    /**\n     * @notice Initializer of the contract\n     * @param _registry The address of the registry.\n     * @param _initialAuthority The address of the access manager.\n     */\n    function initialize(address _registry, address _initialAuthority) external initializer {\n        __AccessManaged_init(_initialAuthority);\n        setRegistry(_registry);\n    }\n\n    /** @dev See {IFactory-deployPT}. */\n    function deployPT(address _ibt, uint256 _duration) public override returns (address pt) {\n        address ptBeacon = IRegistry(registry).getPTBeacon();\n        if (ptBeacon == address(0)) {\n            revert BeaconNotSet();\n        }\n\n        address accessManager = authority();\n        bytes memory _data = abi.encodeWithSelector(\n            IPrincipalToken(address(0)).initialize.selector,\n            _ibt,\n            _duration,\n            accessManager\n        );\n        pt = address(new BeaconProxy(ptBeacon, _data));\n        emit PTDeployed(pt, msg.sender);\n        IRegistry(registry).addPT(pt);\n\n        IAccessManager(accessManager).setTargetFunctionRole(pt, getPauserSigs(), Roles.PAUSER_ROLE);\n        IAccessManager(accessManager).setTargetFunctionRole(\n            pt,\n            getClaimRewardsProxySelectors(),\n            Roles.REWARDS_HARVESTER_ROLE\n        );\n        IAccessManager(accessManager).setTargetFunctionRole(\n            pt,\n            getSetRewardsProxySelectors(),\n            Roles.REWARDS_PROXY_SETTER_ROLE\n        );\n    }\n\n    /** @dev See {IFactory-deployCurvePool}. */\n    function deployCurvePool(\n        address _pt,\n        CurvePoolParams calldata _curvePoolParams,\n        uint256 _initialLiquidityInIBT\n    ) public returns (address curvePool) {\n        if (curveFactory == address(0)) {\n            revert CurveFactoryNotSet();\n        }\n        if (!IRegistry(registry).isRegisteredPT(_pt)) {\n            revert UnregisteredPT();\n        }\n        if (IPrincipalToken(_pt).maturity() < block.timestamp) {\n            revert ExpiredPT();\n        }\n        address ibt = IPrincipalToken(_pt).getIBT();\n        address[2] memory coins;\n        {\n            coins[0] = ibt;\n            coins[1] = _pt;\n        }\n        curvePool = _deployCurvePool(coins, _curvePoolParams);\n        emit CurvePoolDeployed(curvePool, ibt, _pt);\n\n        if (_initialLiquidityInIBT != 0) {\n            _addInitialLiquidity(curvePool, _initialLiquidityInIBT, _curvePoolParams.initial_price);\n        }\n    }\n\n    /** @dev See {IFactory-deployAll}. */\n    function deployAll(\n        address _ibt,\n        uint256 _duration,\n        CurvePoolParams calldata _curvePoolParams,\n        uint256 _initialLiquidityInIBT\n    ) public returns (address pt, address curvePool) {\n        // deploy PT\n        address ptBeacon = IRegistry(registry).getPTBeacon();\n        if (ptBeacon == address(0)) {\n            revert BeaconNotSet();\n        }\n        address accessManager = authority();\n        bytes memory _encodedData = abi.encodeWithSelector(\n            IPrincipalToken(address(0)).initialize.selector,\n            _ibt,\n            _duration,\n            accessManager\n        );\n        pt = address(new BeaconProxy(ptBeacon, _encodedData));\n        emit PTDeployed(pt, msg.sender);\n        IRegistry(registry).addPT(pt);\n        IAccessManager(accessManager).setTargetFunctionRole(pt, getPauserSigs(), Roles.PAUSER_ROLE);\n\n        // deploy Curve Pool\n        if (curveFactory == address(0)) {\n            revert CurveFactoryNotSet();\n        }\n        address[2] memory coins;\n        {\n            coins[0] = _ibt;\n            coins[1] = pt;\n        }\n        curvePool = _deployCurvePool(coins, _curvePoolParams);\n        emit CurvePoolDeployed(curvePool, _ibt, pt);\n\n        if (_initialLiquidityInIBT != 0) {\n            _addInitialLiquidity(curvePool, _initialLiquidityInIBT, _curvePoolParams.initial_price);\n        }\n    }\n\n    /* GETTERS\n     *****************************************************************************************************************/\n\n    /** @dev See {IFactory-getRegistry}. */\n    function getRegistry() external view override returns (address) {\n        return registry;\n    }\n\n    /** @dev See {IFactory-getCurveAddressProvider}. */\n    function getCurveAddressProvider() external view override returns (address) {\n        return curveAddressProvider;\n    }\n\n    /** @dev See {IFactory-getCurveFactory}. */\n    function getCurveFactory() external view override returns (address) {\n        return curveFactory;\n    }\n\n    /**\n     * @notice Getter for pause and unpause selectors, used for access management\n     */\n    function getPauserSigs() internal pure returns (bytes4[] memory) {\n        bytes4[] memory selectors = new bytes4[](2);\n        selectors[0] = PAUSE_SELECTOR;\n        selectors[1] = UNPAUSE_SELECTOR;\n        return selectors;\n    }\n\n    /**\n     * @notice Getter for the reward proxy setter selector, used for access management\n     */\n    function getSetRewardsProxySelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = SET_REWARDS_PROXY_SELECTOR;\n        return selectors;\n    }\n\n    /**\n     * @notice Getter for the claim rewards selector, used for access management\n     */\n    function getClaimRewardsProxySelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = CLAIM_REWARDS_SELECTOR;\n        return selectors;\n    }\n\n    /* SETTERS\n     *****************************************************************************************************************/\n\n    /** @de"
    }
  ]
}