{
  "Title": "[L03] Lists can be initialized multiple times",
  "Content": "The `MappedSinglyLinkedList` data structure can be initialized multiple times by calling any of the [initialize functions](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L21-L39), which can lead to several inconsistencies:\n\n\n* Addresses in the original list cannot be [added](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L44) to the active one\n* Addresses in the original list **can** be [removed](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L56), despite not affecting the active list, which [may lead to a negative integer overflow](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L61)\n* Addresses in the original list will appear to be [contained](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L68) in the active one\n\n\nThis does not occur in the audited code. Nevertheless, consider preventing initialization of non-empty lists.\n\n\n***Update:** Fixed in [pull request #106](https://github.com/pooltogether/pooltogether-pool-contracts/pull/106). Now, the `initialize` function explicitly checks that the number of items in the list is zero before initialization.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/utils/MappedSinglyLinkedList.sol",
      "content": "pragma solidity ^0.6.4;\n\n/// @notice An efficient implementation of a singly linked list of addresses\n/// @dev A mapping(address => address) tracks the 'next' pointer.  A special address called the SENTINAL is used to denote the beginning and end of the list.\nlibrary MappedSinglyLinkedList {\n\n  /// @notice The special value address used to denote the end of the list\n  address public constant SENTINAL = address(0x1);\n\n  /// @notice The data structure to use for the list.\n  struct Mapping {\n    /// @notice How many elements are in the list\n    uint256 count;\n\n    /// @notice The data structure used to map the \"next\" addresses.  The value of this mapping is the \"next\" address for the key.\n    mapping(address => address) addressMap;\n  }\n\n  /// @notice Initializes the list.\n  /// @dev It is important that this is called so that the SENTINAL is correctly setup.\n  function initialize(Mapping storage self) internal {\n    self.addressMap[SENTINAL] = SENTINAL;\n    self.count = 0;\n  }\n\n  /// @notice Initializes the list with an array of addresses.\n  /// @param self The Mapping struct that this function is attached to\n  /// @param addresses The addresses to be added to the list.  They will be added in reverse order.\n  function initialize(Mapping storage self, address[] memory addresses) internal {\n    uint256 count = 0;\n    self.addressMap[SENTINAL] = SENTINAL;\n    for (uint256 i = 0; i < addresses.length; i++) {\n      self.addressMap[addresses[i]] = self.addressMap[SENTINAL];\n      self.addressMap[SENTINAL] = addresses[i];\n      count += 1;\n    }\n    // console.log(\"sentinal initialized to %s\", self.addressMap[SENTINAL]);\n    self.count = count;\n  }\n\n  /// @notice Adds an address to the front of the list.\n  /// @param self The Mapping struct that this function is attached to\n  /// @param newAddress The address to shift to the front of the list\n  function addAddress(Mapping storage self, address newAddress) internal {\n    require(newAddress != SENTINAL && newAddress != address(0), \"Invalid address\");\n    require(self.addressMap[newAddress] == address(0), \"Already added\");\n    self.addressMap[newAddress] = self.addressMap[SENTINAL];\n    self.addressMap[SENTINAL] = newAddress;\n    self.count = self.count + 1;\n  }\n\n  /// @notice Removes an address from the list\n  /// @param self The Mapping struct that this function is attached to\n  /// @param prevAddress The address that precedes the address to be removed.  This may be the SENTINAL if at the start.\n  /// @param addr The address to remove from the list.\n  function removeAddress(Mapping storage self, address prevAddress, address addr) internal {\n    require(addr != SENTINAL && addr != address(0), \"Invalid address\");\n    require(self.addressMap[prevAddress] == addr, \"Invalid prevAddress\");\n    self.addressMap[prevAddress] = self.addressMap[addr];\n    self.addressMap[addr] = address(0);\n    self.count = self.count - 1;\n  }\n\n  /// @notice Determines whether the list contains the given address\n  /// @param self The Mapping struct that this function is attached to\n  /// @param addr The address to check\n  /// @return True if the address is contained, false otherwise.\n  function contains(Mapping storage self, address addr) internal view returns (bool) {\n    return addr != address(0) && self.addressMap[addr] != address(0);\n  }\n\n  /// @notice Returns an address array of all the addresses in this list\n  /// @dev Contains a for loop, so complexity is O(n) wrt the list size\n  /// @param self The Mapping struct that this function is attached to\n  /// @return An array of all the addresses\n  function addressArray(Mapping storage self) internal view returns (address[] memory) {\n    address[] memory array = new address[](self.count);\n    uint256 count;\n    address currentToken = self.addressMap[SENTINAL];\n    while (currentToken != address(0) && currentToken != SENTINAL) {\n      array[count] = currentToken;\n      currentToken = self.addressMap[currentToken];\n      count++;\n    }\n    return array;\n  }\n\n  /// @notice Removes every address from the list\n  /// @param self The Mapping struct that this function is attached to\n  function clearAll(Mapping storage self) internal {\n    address currentToken = self.addressMap[SENTINAL];\n    while (currentToken != address(0) && currentToken != SENTINAL) {\n      address nextToken = self.addressMap[currentToken];\n      delete self.addressMap[currentToken];\n      currentToken = nextToken;\n    }\n    self.addressMap[SENTINAL] = SENTINAL;\n    self.count = 0;\n  }\n}"
    },
    {
      "filename": "contracts/utils/MappedSinglyLinkedList.sol",
      "content": "pragma solidity ^0.6.4;\n\n/// @notice An efficient implementation of a singly linked list of addresses\n/// @dev A mapping(address => address) tracks the 'next' pointer.  A special address called the SENTINAL is used to denote the beginning and end of the list.\nlibrary MappedSinglyLinkedList {\n\n  /// @notice The special value address used to denote the end of the list\n  address public constant SENTINAL = address(0x1);\n\n  /// @notice The data structure to use for the list.\n  struct Mapping {\n    /// @notice How many elements are in the list\n    uint256 count;\n\n    /// @notice The data structure used to map the \"next\" addresses.  The value of this mapping is the \"next\" address for the key.\n    mapping(address => address) addressMap;\n  }\n\n  /// @notice Initializes the list.\n  /// @dev It is important that this is called so that the SENTINAL is correctly setup.\n  function initialize(Mapping storage self) internal {\n    self.addressMap[SENTINAL] = SENTINAL;\n    self.count = 0;\n  }\n\n  /// @notice Initializes the list with an array of addresses.\n  /// @param self The Mapping struct that this function is attached to\n  /// @param addresses The addresses to be added to the list.  They will be added in reverse order.\n  function initialize(Mapping storage self, address[] memory addresses) internal {\n    uint256 count = 0;\n    self.addressMap[SENTINAL] = SENTINAL;\n    for (uint256 i = 0; i < addresses.length; i++) {\n      self.addressMap[addresses[i]] = self.addressMap[SENTINAL];\n      self.addressMap[SENTINAL] = addresses[i];\n      count += 1;\n    }\n    // console.log(\"sentinal initialized to %s\", self.addressMap[SENTINAL]);\n    self.count = count;\n  }\n\n  /// @notice Adds an address to the front of the list.\n  /// @param self The Mapping struct that this function is attached to\n  /// @param newAddress The address to shift to the front of the list\n  function addAddress(Mapping storage self, address newAddress) internal {\n    require(newAddress != SENTINAL && newAddress != address(0), \"Invalid address\");\n    require(self.addressMap[newAddress] == address(0), \"Already added\");\n    self.addressMap[newAddress] = self.addressMap[SENTINAL];\n    self.addressMap[SENTINAL] = newAddress;\n    self.count = self.count + 1;\n  }\n\n  /// @notice Removes an address from the list\n  /// @param self The Mapping struct that this function is attached to\n  /// @param prevAddress The address that precedes the address to be removed.  This may be the SENTINAL if at the start.\n  /// @param addr The address to remove from the list.\n  function removeAddress(Mapping storage self, address prevAddress, address addr) internal {\n    require(addr != SENTINAL && addr != address(0), \"Invalid address\");\n    require(self.addressMap[prevAddress] == addr, \"Invalid prevAddress\");\n    self.addressMap[prevAddress] = self.addressMap[addr];\n    self.addressMap[addr] = address(0);\n    self.count = self.count - 1;\n  }\n\n  /// @notice Determines whether the list contains the given address\n  /// @param self The Mapping struct that this function is attached to\n  /// @param addr The address to check\n  /// @return True if the address is contained, false otherwise.\n  function contains(Mapping storage self, address addr) internal view returns (bool) {\n    return addr != address(0) && self.addressMap[addr] != address(0);\n  }\n\n  /// @notice Returns an address array of all the addresses in this list\n  /// @dev Contains a for loop, so complexity is O(n) wrt the list size\n  /// @param self The Mapping struct that this function is attached to\n  /// @return An array of all the addresses\n  function addressArray(Mapping storage self) internal view returns (address[] memory) {\n    address[] memory array = new address[](self.count);\n    uint256 count;\n    address currentToken = self.addressMap[SENTINAL];\n    while (currentToken != address(0) && currentToken != SENTINAL) {\n      array[count] = currentToken;\n      currentToken = self.addressMap[currentToken];\n      count++;\n    }\n    return array;\n  }\n\n  /// @notice Removes every address from the list\n  /// @param self The Mapping struct that this function is attached to\n  function clearAll(Mapping storage self) internal {\n    address currentToken = self.addressMap[SENTINAL];\n    while (currentToken != address(0) && currentToken != SENTINAL) {\n      address nextToken = self.addressMap[currentToken];\n      delete self.addressMap[currentToken];\n      currentToken = nextToken;\n    }\n    self.addressMap[SENTINAL] = SENTINAL;\n    self.count = 0;\n  }\n}"
    },
    {
      "filename": "contracts/utils/MappedSinglyLinkedList.sol",
      "content": "pragma solidity ^0.6.4;\n\n/// @notice An efficient implementation of a singly linked list of addresses\n/// @dev A mapping(address => address) tracks the 'next' pointer.  A special address called the SENTINAL is used to denote the beginning and end of the list.\nlibrary MappedSinglyLinkedList {\n\n  /// @notice The special value address used to denote the end of the list\n  address public constant SENTINAL = address(0x1);\n\n  /// @notice The data structure to use for the list.\n  struct Mapping {\n    /// @notice How many elements are in the list\n    uint256 count;\n\n    /// @notice The data structure used to map the \"next\" addresses.  The value of this mapping is the \"next\" address for the key.\n    mapping(address => address) addressMap;\n  }\n\n  /// @notice Initializes the list.\n  /// @dev It is important that this is called so that the SENTINAL is correctly setup.\n  function initialize(Mapping storage self) internal {\n    self.addressMap[SENTINAL] = SENTINAL;\n    self.count = 0;\n  }\n\n  /// @notice Initializes the list with an array of addresses.\n  /// @param self The Mapping struct that this function is attached to\n  /// @param addresses The addresses to be added to the list.  They will be added in reverse order.\n  function initialize(Mapping storage self, address[] memory addresses) internal {\n    uint256 count = 0;\n    self.addressMap[SENTINAL] = SENTINAL;\n    for (uint256 i = 0; i < addresses.length; i++) {\n      self.addressMap[addresses[i]] = self.addressMap[SENTINAL];\n      self.addressMap[SENTINAL] = addresses[i];\n      count += 1;\n    }\n    // console.log(\"sentinal initialized to %s\", self.addressMap[SENTINAL]);\n    self.count = count;\n  }\n\n  /// @notice Adds an address to the front of the list.\n  /// @param self The Mapping struct that this function is attached to\n  /// @param newAddress The address to shift to the front of the list\n  function addAddress(Mapping storage self, address newAddress) internal {\n    require(newAddress != SENTINAL && newAddress != address(0), \"Invalid address\");\n    require(self.addressMap[newAddress] == address(0), \"Already added\");\n    self.addressMap[newAddress] = self.addressMap[SENTINAL];\n    self.addressMap[SENTINAL] = newAddress;\n    self.count = self.count + 1;\n  }\n\n  /// @notice Removes an address from the list\n  /// @param self The Mapping struct that this function is attached to\n  /// @param prevAddress The address that precedes the address to be removed.  This may be the SENTINAL if at the start.\n  /// @param addr The address to remove from the list.\n  function removeAddress(Mapping storage self, address prevAddress, address addr) internal {\n    require(addr != SENTINAL && addr != address(0), \"Invalid address\");\n    require(self.addressMap[prevAddress] == addr, \"Invalid prevAddress\");\n    self.addressMap[prevAddress] = self.addressMap[addr];\n    self.addressMap[addr] = address(0);\n    self.count = self.count - 1;\n  }\n\n  /// @notice Determines whether the list contains the given address\n  /// @param self The Mapping struct that this function is attached to\n  /// @param addr The address to check\n  /// @return True if the address is contained, false otherwise.\n  function contains(Mapping storage self, address addr) internal view returns (bool) {\n    return addr != address(0) && self.addressMap[addr] != address(0);\n  }\n\n  /// @notice Returns an address array of all the addresses in this list\n  /// @dev Contains a for loop, so complexity is O(n) wrt the list size\n  /// @param self The Mapping struct that this function is attached to\n  /// @return An array of all the addresses\n  function addressArray(Mapping storage self) internal view returns (address[] memory) {\n    address[] memory array = new address[](self.count);\n    uint256 count;\n    address currentToken = self.addressMap[SENTINAL];\n    while (currentToken != address(0) && currentToken != SENTINAL) {\n      array[count] = currentToken;\n      currentToken = self.addressMap[currentToken];\n      count++;\n    }\n    return array;\n  }\n\n  /// @notice Removes every address from the list\n  /// @param self The Mapping struct that this function is attached to\n  function clearAll(Mapping storage self) internal {\n    address currentToken = self.addressMap[SENTINAL];\n    while (currentToken != address(0) && currentToken != SENTINAL) {\n      address nextToken = self.addressMap[currentToken];\n      delete self.addressMap[currentToken];\n      currentToken = nextToken;\n    }\n    self.addressMap[SENTINAL] = SENTINAL;\n    self.count = 0;\n  }\n}"
    },
    {
      "filename": "contracts/utils/MappedSinglyLinkedList.sol",
      "content": "pragma solidity ^0.6.4;\n\n/// @notice An efficient implementation of a singly linked list of addresses\n/// @dev A mapping(address => address) tracks the 'next' pointer.  A special address called the SENTINAL is used to denote the beginning and end of the list.\nlibrary MappedSinglyLinkedList {\n\n  /// @notice The special value address used to denote the end of the list\n  address public constant SENTINAL = address(0x1);\n\n  /// @notice The data structure to use for the list.\n  struct Mapping {\n    /// @notice How many elements are in the list\n    uint256 count;\n\n    /// @notice The data structure used to map the \"next\" addresses.  The value of this mapping is the \"next\" address for the key.\n    mapping(address => address) addressMap;\n  }\n\n  /// @notice Initializes the list.\n  /// @dev It is important that this is called so that the SENTINAL is correctly setup.\n  function initialize(Mapping storage self) internal {\n    self.addressMap[SENTINAL] = SENTINAL;\n    self.count = 0;\n  }\n\n  /// @notice Initializes the list with an array of addresses.\n  /// @param self The Mapping struct that this function is attached to\n  /// @param addresses The addresses to be added to the list.  They will be added in reverse order.\n  function initialize(Mapping storage self, address[] memory addresses) internal {\n    uint256 count = 0;\n    self.addressMap[SENTINAL] = SENTINAL;\n    for (uint256 i = 0; i < addresses.length; i++) {\n      self.addressMap[addresses[i]] = self.addressMap[SENTINAL];\n      self.addressMap[SENTINAL] = addresses[i];\n      count += 1;\n    }\n    // console.log(\"sentinal initialized to %s\", self.addressMap[SENTINAL]);\n    self.count = count;\n  }\n\n  /// @notice Adds an address to the front of the list.\n  /// @param self The Mapping struct that this function is attached to\n  /// @param newAddress The address to shift to the front of the list\n  function addAddress(Mapping storage self, address newAddress) internal {\n    require(newAddress != SENTINAL && newAddress != address(0), \"Invalid address\");\n    require(self.addressMap[newAddress] == address(0), \"Already added\");\n    self.addressMap[newAddress] = self.addressMap[SENTINAL];\n    self.addressMap[SENTINAL] = newAddress;\n    self.count = self.count + 1;\n  }\n\n  /// @notice Removes an address from the list\n  /// @param self The Mapping struct that this function is attached to\n  /// @param prevAddress The address that precedes the address to be removed.  This may be the SENTINAL if at the start.\n  /// @param addr The address to remove from the list.\n  function removeAddress(Mapping storage self, address prevAddress, address addr) internal {\n    require(addr != SENTINAL && addr != address(0), \"Invalid address\");\n    require(self.addressMap[prevAddress] == addr, \"Invalid prevAddress\");\n    self.addressMap[prevAddress] = self.addressMap[addr];\n    self.addressMap[addr] = address(0);\n    self.count = self.count - 1;\n  }\n\n  /// @notice Determines whether the list contains the given address\n  /// @param self The Mapping struct that this function is attached to\n  /// @param addr The address to check\n  /// @return True if the address is contained, false otherwise.\n  function contains(Mapping storage self, address addr) internal view returns (bool) {\n    return addr != address(0) && self.addressMap[addr] != address(0);\n  }\n\n  /// @notice Returns an address array of all the addresses in this list\n  /// @dev Contains a for loop, so complexity is O(n) wrt the list size\n  /// @param self The Mapping struct that this function is attached to\n  /// @return An array of all the addresses\n  function addressArray(Mapping storage self) internal view returns (address[] memory) {\n    address[] memory array = new address[](self.count);\n    uint256 count;\n    address currentToken = self.addressMap[SENTINAL];\n    while (currentToken != address(0) && currentToken != SENTINAL) {\n      array[count] = currentToken;\n      currentToken = self.addressMap[currentToken];\n      count++;\n    }\n    return array;\n  }\n\n  /// @notice Removes every address from the list\n  /// @param self The Mapping struct that this function is attached to\n  function clearAll(Mapping storage self) internal {\n    address currentToken = self.addressMap[SENTINAL];\n    while (currentToken != address(0) && currentToken != SENTINAL) {\n      address nextToken = self.addressMap[currentToken];\n      delete self.addressMap[currentToken];\n      currentToken = nextToken;\n    }\n    self.addressMap[SENTINAL] = SENTINAL;\n    self.count = 0;\n  }\n}"
    }
  ]
}