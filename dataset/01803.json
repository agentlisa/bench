{
  "Title": "Minting is still possible even if redemptions are not",
  "Content": "When redeeming OUSD or OETH, the corresponding amount of each collateral token is [calculated](https://github.com/OriginProtocol/origin-dollar/blob/508921bd39f988fa61b60cea372b910725ff7bd0/contracts/contracts/vault/VaultCore.sol#L165). The operation will fail if any of the tokens [drift too far](https://github.com/OriginProtocol/origin-dollar/blob/508921bd39f988fa61b60cea372b910725ff7bd0/contracts/contracts/vault/VaultCore.sol#L695) from the expected price. However, when minting new OUSD or OETH, [only the deposited collateral](https://github.com/OriginProtocol/origin-dollar/blob/508921bd39f988fa61b60cea372b910725ff7bd0/contracts/contracts/vault/VaultCore.sol#L74) needs to be within the acceptable range. This introduces the possibility that users can deposit funds but will be unable to withdraw them.\n\n\nIn the interest of predictability, consider preventing deposits unless all collateral tokens are redeemable. This would help ensure that deposits and withdrawals are enabled and disabled together during unexpected market conditions.\n\n\n***Update:** Acknowledged, not resolved. The Origin team stated:*\n\n\n\n> *For code simplicity, OUSD/OETH prioritizes protecting the protcool over protecting interacting users. If a user mints with a non-depegged coin when another coin is depegged, this is a benefit for the protocol.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/vault/VaultCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Vault Contract\n * @notice The Vault contract stores assets. On a deposit, OUSD will be minted\n           and sent to the depositor. On a withdrawal, OUSD will be burned and\n           assets will be sent to the withdrawer. The Vault accepts deposits of\n           interest from yield bearing strategies which will modify the supply\n           of OUSD.\n * @author Origin Protocol Inc\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IBasicToken } from \"../interfaces/IBasicToken.sol\";\nimport { IGetExchangeRateToken } from \"../interfaces/IGetExchangeRateToken.sol\";\nimport \"./VaultStorage.sol\";\n\ncontract VaultCore is VaultStorage {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n    using SafeMath for uint256;\n    // max signed int\n    uint256 constant MAX_INT = 2**255 - 1;\n    // max un-signed int\n    uint256 constant MAX_UINT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /**\n     * @dev Verifies that the rebasing is not paused.\n     */\n    modifier whenNotRebasePaused() {\n        require(!rebasePaused, \"Rebasing paused\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the deposits are not paused.\n     */\n    modifier whenNotCapitalPaused() {\n        require(!capitalPaused, \"Capital paused\");\n        _;\n    }\n\n    modifier onlyOusdMetaStrategy() {\n        require(\n            msg.sender == ousdMetaStrategy,\n            \"Caller is not the OUSD meta strategy\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Deposit a supported asset and mint OUSD.\n     * @param _asset Address of the asset being deposited\n     * @param _amount Amount of the asset being deposited\n     * @param _minimumOusdAmount Minimum OUSD to mint\n     */\n    function mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) external whenNotCapitalPaused nonReentrant {\n        require(assets[_asset].isSupported, \"Asset is not supported\");\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        uint256 units = _toUnits(_amount, _asset);\n        uint256 unitPrice = _toUnitPrice(_asset, true);\n        uint256 priceAdjustedDeposit = (units * unitPrice) / 1e18;\n\n        if (_minimumOusdAmount > 0) {\n            require(\n                priceAdjustedDeposit >= _minimumOusdAmount,\n                \"Mint amount lower than minimum\"\n            );\n        }\n\n        emit Mint(msg.sender, priceAdjustedDeposit);\n\n        // Rebase must happen before any transfers occur.\n        if (priceAdjustedDeposit >= rebaseThreshold && !rebasePaused) {\n            _rebase();\n        }\n\n        // Mint matching OUSD\n        oUSD.mint(msg.sender, priceAdjustedDeposit);\n\n        // Transfer the deposited coins to the vault\n        IERC20 asset = IERC20(_asset);\n        asset.safeTransferFrom(msg.sender, address(this), _amount);\n\n        if (priceAdjustedDeposit >= autoAllocateThreshold) {\n            _allocate();\n        }\n    }\n\n    /**\n     * @dev Mint OUSD for OUSD Meta Strategy\n     * @param _amount Amount of the asset being deposited\n     *\n     * Notice: can't use `nonReentrant` modifier since the `mint` function can\n     * call `allocate`, and that can trigger `ConvexOUSDMetaStrategy` to call this function\n     * while the execution of the `mint` has not yet completed -> causing a `nonReentrant` collision.\n     *\n     * Also important to understand is that this is a limitation imposed by the test suite.\n     * Production / mainnet contracts should never be configured in a way where mint/redeem functions\n     * that are moving funds between the Vault and end user wallets can influence strategies\n     * utilizing this function.\n     */\n    function mintForStrategy(uint256 _amount)\n        external\n        whenNotCapitalPaused\n        onlyOusdMetaStrategy\n    {\n        require(_amount < MAX_INT, \"Amount too high\");\n\n        emit Mint(msg.sender, _amount);\n\n        // Rebase must happen before any transfers occur.\n        // TODO: double check the relevance of this\n        if (_amount >= rebaseThreshold && !rebasePaused) {\n            _rebase();\n        }\n\n        // safe to cast because of the require check at the beginning of the function\n        netOusdMintedForStrategy += int256(_amount);\n\n        require(\n            abs(netOusdMintedForStrategy) < netOusdMintForStrategyThreshold,\n            \"Minted ousd surpassed netOusdMintForStrategyThreshold.\"\n        );\n\n        // Mint matching OUSD\n        oUSD.mint(msg.sender, _amount);\n    }\n\n    // In memoriam\n\n    /**\n     * @dev Withdraw a supported asset and burn OUSD.\n     * @param _amount Amount of OUSD to burn\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        external\n        whenNotCapitalPaused\n        nonReentrant\n    {\n        _redeem(_amount, _minimumUnitAmount);\n    }\n\n    /**\n     * @dev Withdraw a supported asset and burn OUSD.\n     * @param _amount Amount of OUSD to burn\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function _redeem(uint256 _amount, uint256 _minimumUnitAmount) internal {\n        // Calculate redemption outputs\n        uint256[] memory outputs = _calculateRedeemOutputs(_amount);\n\n        emit Redeem(msg.sender, _amount);\n\n        // Send outputs\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            if (outputs[i] == 0) continue;\n\n            IERC20 asset = IERC20(allAssets[i]);\n\n            if (asset.balanceOf(address(this)) >= outputs[i]) {\n                // Use Vault funds first if sufficient\n                asset.safeTransfer(msg.sender, outputs[i]);\n            } else {\n                address strategyAddr = assetDefaultStrategies[allAssets[i]];\n                if (strategyAddr != address(0)) {\n                    // Nothing in Vault, but something in Strategy, send from there\n                    IStrategy strategy = IStrategy(strategyAddr);\n                    strategy.withdraw(msg.sender, allAssets[i], outputs[i]);\n                } else {\n                    // Cant find funds anywhere\n                    revert(\"Liquidity error\");\n                }\n            }\n        }\n\n        if (_minimumUnitAmount > 0) {\n            uint256 unitTotal = 0;\n            for (uint256 i = 0; i < outputs.length; i++) {\n                unitTotal += _toUnits(outputs[i], allAssets[i]);\n            }\n            require(\n                unitTotal >= _minimumUnitAmount,\n                \"Redeem amount lower than minimum\"\n            );\n        }\n\n        oUSD.burn(msg.sender, _amount);\n\n        // Until we can prove that we won't affect the prices of our assets\n        // by withdrawing them, this should be here.\n        // It's possible that a strategy was off on its asset total, perhaps\n        // a reward token sold for more or for less than anticipated.\n        uint256 totalUnits = 0;\n        if (_amount >= rebaseThreshold && !rebasePaused) {\n            totalUnits = _rebase();\n        } else {\n            totalUnits = _totalValue();\n        }\n\n        // Check that OUSD is backed by enough assets\n        if (maxSupplyDiff > 0) {\n            // Allow a max difference of maxSupplyDiff% between\n            // backing assets value and OUSD total supply\n            uint256 diff = oUSD.totalSupply().divPrecisely(totalUnits);\n            require(\n                (diff > 1e18 ? diff.sub(1e18) : uint256(1e18).sub(diff)) <=\n                    maxSupplyDiff,\n                \"Backing supply liquidity error\"\n            );\n        }\n    }\n\n    /**\n     * @dev Burn OUSD for OUSD Meta Strategy\n     * @param _amount Amount of OUSD to burn\n     *\n     * Notice: can't use `nonReentrant` modifier since the `redeem` function could\n     * require withdrawal on `ConvexOUSDMetaStrategy` and that one can call `burnForStrategy`\n     * while the execution of the `redeem` has not yet completed -> causing a `nonReentrant` collision.\n     *\n     * Also important to understand is that this is a limitation imposed by the test suite.\n     * Production / mainnet contracts should never be configured in a way where mint/redeem functions\n     * that are moving funds between the Vault and end user wallets can influence strategies\n     * utilizing this function.\n     */\n    function burnForStrategy(uint256 _amount)\n        external\n        whenNotCapitalPaused\n        onlyOusdMetaStrategy\n    {\n        require(_amount < MAX_INT, \"Amount too high\");\n\n        emit Redeem(msg.sender, _amount);\n\n        // safe to cast because of the require check at the beginning of the function\n        netOusdMintedForStrategy -= int256(_amount);\n\n        require(\n            abs(netOusdMintedForStrategy) < netOusdMintForStrategyThreshold,\n            \"Attempting to burn too much OUSD.\"\n        );\n\n        // Burn OUSD\n        oUSD.burn(msg.sender, _amount);\n\n        // Until we can prove that we won't affect the prices of our assets\n        // by withdrawing them, this should be here.\n        // It's possible that a strategy was off on its asset total, perhaps\n        // a reward token sold for more or for less than anticipated.\n        if (_amount >= rebaseThreshold && !rebasePaused) {\n            _rebase();\n        }\n    }\n\n    /**\n     * @notice Withdraw a supported asset and burn all OUSD.\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function redeemAll(uint256 _minimumUnitAmount)\n        external\n        whenNotCapitalPaused\n        nonReentrant\n    {\n        _redeem(oUSD.balanceOf(msg.sender), _minimumUnitAmount);\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     * @dev Allocate unallocated funds on Vault to strategies.\n     **/\n    function allocate() external whenNotCapitalPaused nonReentrant {\n        _allocate();\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     * @dev Allocate unallocated funds on Vault to strategies.\n     **/\n    function _allocate() internal {\n        uint256 vaultValue = _totalValueInVault();\n        // Nothing in vault to allocate\n        if (vaultValue == 0) return;\n        uint256 strategiesValue = _totalValueInStrategies();\n        // We have a method that does the same as this, gas optimisation\n        uint256 calculatedTotalValue = vaultValue.add(strategiesValue);\n\n        // We want to maintain a buffer on the Vault so calculate a percentage\n        // modifier to multiply each amount being allocated by to enforce the\n        // vault buffer\n        uint256 vaultBufferModifier;\n        if (strategiesValue == 0) {\n            // Nothing in Strategies, allocate 100% minus the vault buffer to\n            // strategies\n            vaultBufferModifier = uint256(1e18).sub(vaultBuffer);\n        } else {\n            vaultBufferModifier = vaultBuffer.mul(calculatedTotalValue).div(\n                vaultValue\n            );\n            if (1e18 > vaultBufferModifier) {\n                // E.g. 1e18 - (1e17 * 10e18)/5e18 = 8e17\n                // (5e18 * 8e17) / 1e18 = 4e18 allocated from Vault\n                vaultBufferModifier = uint256(1e18).sub(vaultBufferModifier);\n            } else {\n                // We need to let the buffer fill\n                return;\n            }\n        }\n        if (vaultBufferModifier == 0) return;\n\n        // Iterate over all assets in the Vault and allocate to the appropriate\n        // strategy\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            IERC20 asset = IERC20(allAssets[i]);\n            uint256 assetBalance = asset.balanceOf(address(this));\n            // No balance, nothing to do here\n            if (assetBalance == 0) continue;\n\n            // Multiply the balance by the vault buffer modifier and truncate\n            // to the scale of the asset decimals\n            uint256 allocateAmount = assetBalance.mulTruncate(\n                vaultBufferModifier\n            );\n\n            address depositStrategyAddr = assetDefaultStrategies[\n                address(asset)\n            ];\n\n            if (depositStrategyAddr != address(0) && allocateAmount > 0) {\n                IStrategy strategy = IStrategy(depositStrategyAddr);\n                // Transfer asset to Strategy and call deposit method to\n                // mint or take required action\n                asset.safeTransfer(address(strategy), allocateAmount);\n                strategy.deposit(address(asset), allocateAmount);\n                emit AssetAllocated(\n                    address(asset),\n                    depositStrategyAddr,\n                    allocateAmount\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Calculate the total value of assets held by the Vault and all\n     *      strategies and update the supply of OUSD.\n     */\n    function rebase() external virtual nonReentrant {\n        _rebase();\n    }\n\n    /**\n     * @dev Calculate the total value of assets held by the Vault and all\n     *      strategies and update the supply of OUSD, optionally sending a\n     *      portion of the yield to the trustee.\n     * @return totalUnits Total balance of Vault in units\n     */\n    function _rebase() internal whenNotRebasePaused returns (uint256) {\n        uint256 ousdSupply = oUSD.totalSupply();\n        uint256 vaultValue = _totalValue();\n        if (ousdSupply == 0) {\n            return vaultValue;\n        }\n\n        // Yield fee collection\n        address _trusteeAddress = trusteeAddress; // gas savings\n        if (_trusteeAddress != address(0) && (vaultValue > ousdSupply)) {\n            uint256 yield = vaultValue.sub(ousdSupply);\n            uint256 fee = yield.mul(trusteeFeeBps).div(10000);\n            require(yield > fee, \"Fee must not be greater than yield\");\n            if (fee > 0) {\n                oUSD.mint(_trusteeAddress, fee);\n            }\n            emit YieldDistribution(_trusteeAddress, yield, fee);\n        }\n\n        // Only rachet OUSD supply upwards\n        ousdSupply = oUSD.totalSupply(); // Final check should use latest value\n        if (vaultValue > ousdSupply) {\n            oUSD.changeSupply(vaultValue);\n        }\n        return vaultValue;\n    }\n\n    /**\n     * @dev Determine the total value of assets held by the vault and its\n     *         strategies.\n     * @return value Total value in USD (1e18)\n     */\n    function totalValue() external view virtual returns (uint256 value) {\n        value = _totalValue();\n    }\n\n    /**\n     * @dev Internal Calculate the total value of the assets held by the\n     *         vault and its strategies.\n     * @return value Total value in USD (1e18)\n     */\n    function _totalValue() internal view virtual returns (uint256 value) {\n        return _totalValueInVault().add(_totalValueInStrategies());\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held in Vault.\n     * @return value Total value in ETH (1e18)\n     */\n    function _totalValueInVault() internal view returns (uint256 value) {\n        for (uint256 y = 0; y < allAssets.length; y++) {\n            IERC20 asset = IERC20(allAssets[y]);\n            uint256 balance = asset.balanceOf(address(this));\n            if (balance > 0) {\n                value += _toUnits(balance, allAssets[y]);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held in Strategies.\n     * @return value Total value in ETH (1e18)\n     */\n    function _totalValueInStrategies() internal view returns (uint256 value) {\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            value = value.add(_totalValueInStrategy(allStrategies[i]));\n        }\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held by strategy.\n     * @param _strategyAddr Address of the strategy\n     * @return value Total value in ETH (1e18)\n     */\n    function _totalValueInStrategy(address _strategyAddr)\n        internal\n        view\n        returns (uint256 value)\n    {\n        IStrategy strategy = IStrategy(_strategyAddr);\n        for (uint256 y = 0; y < allAssets.length; y++) {\n            if (strategy.supportsAsset(allAssets[y])) {\n                uint256 balance = strategy.checkBalance(allAssets[y]);\n                if (balance > 0) {\n                    value += _toUnits(balance, allAssets[y]);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @param _asset Address of asset\n     * @return uint256 Balance of asset in decimals of asset\n     */\n    function checkBalance(address _asset) external view returns (uint256) {\n        return _checkBalance(_asset);\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @param _asset Address of asset\n     * @return balance Balance of asset in decimals of asset\n     */\n    function _checkBalance(address _asset)\n        internal\n        view\n        virtual\n        returns (uint256 balance)\n    {\n        IERC20 asset = IERC20(_asset);\n        balance = asset.balanceOf(address(this));\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            IStrategy strategy = IStrategy(allStrategies[i]);\n            if (strategy.supportsAsset(_asset)) {\n                balance = balance.add(strategy.checkBalance(_asset));\n            }\n        }\n    }\n\n    /**\n     * @notice Calculate the outputs for a redeem function, i.e. the mix of\n     * coins that will be returned\n     */\n    function calculateRedeemOutputs(uint256 _amount)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return _calculateRedeemOutputs(_amount);\n    }\n\n    /**\n     * @notice Calculate the outputs for a redeem function, i.e. the mix of\n     * coins that will be returned.\n     * @return outputs Array of amounts respective to the supported assets\n     */\n    function _calculateRedeemOutputs(uint256 _amount)\n        internal\n        view\n        returns (uint256[] memory outputs)\n    {\n        // We always give out coins in proportion to how many we have,\n        // Now if all coins were the same value, this math would easy,\n        // just take the percentage of each coin, and multiply by the\n        // value to be given out. But if coins are worth more than $1,\n        // then we would end up handing out too many coins. We need to\n        // adjust by the total value of coins.\n        //\n        // To do this, we total up the value of our coins, by their\n        // percentages. Then divide what we would otherwise give out by\n        // this number.\n        //\n        // Let say we have 100 DAI at $1.06  and 200 USDT at $1.00.\n        // So for every 1 DAI we give out, we'll be handing out 2 USDT\n        // Our total output ratio is: 33% * 1.06 + 66% * 1.00 = 1.02\n        //\n        // So when calculating the output, we take the percentage of\n        // each coin, times the desired output value, divided by the\n        // totalOutputRatio.\n        //\n        // For example, withdrawing: 30 OUSD:\n        // DAI 33% * 30 / 1.02 = 9.80 DAI\n        // USDT = 66 % * 30 / 1.02 = 19.60 USDT\n        //\n        // Checking these numbers:\n        // 9.80 DAI * 1.06 = $10.40\n        // 19.60 USDT * 1.00 = $19.60\n        //\n        // And so the user gets $10.40 + $19.60 = $30 worth of value.\n\n        uint256 assetCount = allAssets.length;\n        uint256[] memory assetUnits = new uint256[](assetCount);\n        uint256[] memory assetBalances = new uint256[](assetCount);\n        outputs = new uint256[](assetCount);\n\n        // Calculate redeem fee\n        if (redeemFeeBps > 0) {\n            uint256 redeemFee = _amount.mul(redeemFeeBps).div(10000);\n            _amount = _amount.sub(redeemFee);\n        }\n\n        // Calculate assets balances and decimals once,\n        // for a large gas savings.\n        uint256 totalUnits = 0;\n        for (uint256 i = 0; i < assetCount; i++) {\n            uint256 balance = _checkBalance(allAssets[i]);\n            assetBalances[i] = balance;\n            assetUnits[i] = _toUnits(balance, allAssets[i]);\n            totalUnits = totalUnits.add(assetUnits[i]);\n        }\n        // Calculate totalOutputRatio\n        uint256 totalOutputRatio = 0;\n        for (uint256 i = 0; i < assetCount; i++) {\n            uint256 unitPrice = _toUnitPrice(allAssets[i], false);\n            uint256 ratio = assetUnits[i].mul(unitPrice).div(totalUnits);\n            totalOutputRatio = totalOutputRatio.add(ratio);\n        }\n        // Calculate final outputs\n        uint256 factor = _amount.divPrecisely(totalOutputRatio);\n        for (uint256 i = 0; i < assetCount; i++) {\n            outputs[i] = assetBalances[i].mul(factor).div(totalUnits);\n        }\n    }\n\n    /***************************************\n                    Pricing\n    ****************************************/\n\n    /**\n     * @dev Returns the total price in 18 digit units for a given asset.\n     *      Never goes above 1, since that is how we price mints.\n     * @param asset address of the asset\n     * @return price uint256: unit (USD / ETH) price for 1 unit of the asset, in 18 decimal fixed\n     */\n    function priceUnitMint(address asset)\n        external\n        view\n        returns (uint256 price)\n    {\n        /* need to supply 1 asset unit in asset's decimals and can not just hard-code\n         * to 1e18 and ignore calling `_toUnits` since we need to consider assets\n         * with the exchange rate\n         */\n        uint256 units = _toUnits(\n            uint256(1e18).scaleBy(_getDecimals(asset), 18),\n            asset\n        );\n        price = (_toUnitPrice(asset, true) * units) / 1e18;\n    }\n\n    /**\n     * @dev Returns the total price in 18 digit unit for a given asset.\n     *      Never goes below 1, since that is how we price redeems\n     * @param asset Address of the asset\n     * @return price uint256: unit (USD / ETH) price for 1 unit of the asset, in 18 decimal fixed\n     */\n    function priceUnitRedeem(address asset)\n        external\n        view\n        returns (uint256 price)\n    {\n        /* need to supply 1 asset unit in asset's decimals and can not just hard-code\n         * to 1e18 and ignore calling `_toUnits` since we need to consider assets\n         * with the exchange rate\n         */\n        uint256 units = _toUnits(\n            uint256(1e18).scaleBy(_getDecimals(asset), 18),\n            asset\n        );\n        price = (_toUnitPrice(asset, false) * units) / 1e18;\n    }\n\n    /***************************************\n                    Utils\n    ****************************************/\n\n    /**\n     * @dev Convert a quantity of a token into 1e18 fixed decimal \"units\"\n     * in the underlying base (USD/ETH) used by the vault.\n     * Price is not taken into account, only quantity.\n     *\n     * Examples of this conversion:\n     *\n     * - 1e18 DAI becomes 1e18 units (same decimals)\n     * - 1e6 USDC becomes 1e18 units (decimal conversion)\n     * - 1e18 rETH becomes 1.2e18 units (exchange rate conversion)\n     *\n     * @param _raw Quantity of asset\n     * @param _asset Core Asset address\n     * @return value 1e18 normalized quantity of units\n     */\n    function _toUnits(uint256 _raw, address _asset)\n        internal\n        view\n        returns (uint256)\n    {\n        UnitConversion conversion = assets[_asset].unitConversion;\n        if (conversion == UnitConversion.DECIMALS) {\n            return _raw.scaleBy(18, _getDecimals(_asset));\n        } else if (conversion == UnitConversion.GETEXCHANGERATE) {\n            uint256 exchangeRate = IGetExchangeRateToken(_asset)\n                .getExchangeRate();\n            return (_raw * exchangeRate) / 1e18;\n        } else {\n            require(false, \"Unsupported conversion type\");\n        }\n    }\n\n    /**\n     * @dev Returns asset's unit price accounting for different asset types\n     *      and takes into account the context in which that price exists -\n     *      - mint or redeem.\n     *\n     * Note: since we are returning the price of the unit and not the one of the\n     * asset (see comment above how 1 rETH exchanges for 1.2 units) we need\n     * to make the Oracle price adjustment as well since we are pricing the\n     * units and not the assets.\n     *\n     * The price also snaps to a \"full unit price\" in case a mint or redeem\n     * action would be unfavourable to the protocol.\n     *\n     */\n    function _toUnitPrice(address _asset, bool isMint)\n        internal\n        view\n        returns (uint256 price)\n    {\n        UnitConversion conversion = assets[_asset].unitConversion;\n        price = IOracle(priceProvider).price(_asset);\n\n        if (conversion == UnitConversion.GETEXCHANGERATE) {\n            uint256 exchangeRate = IGetExchangeRateToken(_asset)\n                .getExchangeRate();\n            price = (price * 1e18) / exchangeRate;\n        } else if (conversion != UnitConversion.DECIMALS) {\n            require(false, \"Unsupported conversion type\");\n        }\n\n        /* At this stage the price is already adjusted to the unit\n         * so the price checks are agnostic to underlying asset being\n         * pegged to a USD or to an ETH or having a custom exchange rate.\n         */\n        require(price <= MAX_UNIT_PRICE_DRIFT, \"Vault: Price exceeds max\");\n        require(price >= MIN_UNIT_PRICE_DRIFT, \"Vault: Price under min\");\n\n        if (isMint) {\n            /* Never price a normalized unit price for more than one\n             * unit of OETH/OUSD when minting.\n             */\n            if (price > 1e18) {\n                price = 1e18;\n            }\n            require(price >= MINT_MINIMUM_UNIT_PRICE, \"Asset price below peg\");\n        } else {\n            /* Never give out more than 1 normalized unit amount of assets\n             * for one unit of OETH/OUSD when redeeming.\n             */\n            if (price < 1e18) {\n                price = 1e18;\n            }\n        }\n    }\n\n    function _getDecimals(address _asset) internal view returns (uint256) {\n        uint256 decimals = assets[_asset].decimals;\n        require(decimals > 0, \"Decimals not cached\");\n        return decimals;\n    }\n\n    /**\n     * @dev Return the number of assets supported by the Vault.\n     */\n    function getAssetCount() public view returns (uint256) {\n        return allAssets.length;\n    }\n\n    /**\n     * @dev Return all asset addresses in order\n     */\n    function getAllAssets() external view returns (address[] memory) {\n        return allAssets;\n    }\n\n    /**\n     * @dev Return the number of strategies active on the Vault.\n     */\n    function getStrategyCount() external view returns (uint256) {\n        return allStrategies.length;\n    }\n\n    /**\n     * @dev Return the array of all strategies\n     */\n    function getAllStrategies() external view returns (address[] memory) {\n        return allStrategies;\n    }\n\n    function isSupportedAsset(address _asset) external view returns (bool) {\n        return assets[_asset].isSupported;\n    }\n\n    /**\n     * @dev Falldown to the admin implementation\n     * @notice This is a catch all for all functions not declared in core\n     */\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external payable {\n        bytes32 slot = adminImplPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(\n                gas(),\n                sload(slot),\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    function abs(int256 x) private pure returns (uint256) {\n        require(x < int256(MAX_INT), \"Amount too high\");\n        return x >= 0 ? uint256(x) : uint256(-x);\n    }\n}"
    }
  ]
}