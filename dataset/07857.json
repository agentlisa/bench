{
  "Title": "[L-02] Decoding an IPFS hash using a fixed hash function and length of the hash",
  "Content": "<h2 id=\"l-02-decoding-an-ipfs-hash-using-a-fixed-hash-function-and-length-of-the-hash\" style=\"position:relative;\"><a href=\"#l-02-decoding-an-ipfs-hash-using-a-fixed-hash-function-and-length-of-the-hash\" aria-label=\"l 02 decoding an ipfs hash using a fixed hash function and length of the hash permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-02] Decoding an IPFS hash using a fixed hash function and length of the hash</h2>\n<p>An IPFS hash specifies the hash function and length of the hash in the first two bytes of the hash. The first two bytes are <strong>0x1220</strong>, where <strong>12</strong> denotes that this is the SHA256 hash function and <strong>20</strong> is the length of the hash in bytes (32 bytes).</p>\n<p>Although SHA256 is 32 bytes and is currently the most common IPFS hash function, other content could use a hash function that is larger than 32 bytes. The current implementation limits the usage to the SHA256 hash function and a hash length of 32 bytes.</p>\n<h3 id=\"findings-1\" style=\"position:relative;\"><a href=\"#findings-1\" aria-label=\"findings 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Findings</h3>\n<p><a href=\"https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/libraries/JBIpfsDecoder.sol#L28\">libraries/JBIpfsDecoder.sol#L28</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"33\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">decode</span><span class=\"mtk1\">(</span><span class=\"mtk12\">string</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_baseUri</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_hexString</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">external</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">pure</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">string</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">{</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// Concatenate the hex string with the fixed IPFS hash part (0x12 and 0x20)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">bytes</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">completeHexString</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encodePacked</span><span class=\"mtk1\">(</span><span class=\"mtk11\">bytes2</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0x1220</span><span class=\"mtk1\">), </span><span class=\"mtk12\">_hexString</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// Convert the hex string to an hash</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">string</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">ipfsHash</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">_toBase58</span><span class=\"mtk1\">(</span><span class=\"mtk12\">completeHexString</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// Concatenate with the base URI</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">string</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encodePacked</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_baseUri</span><span class=\"mtk1\">, </span><span class=\"mtk12\">ipfsHash</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<h3 id=\"recommended-mitigation-steps-14\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-14\" aria-label=\"recommended mitigation steps 14 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended mitigation steps</h3>\n<p>Consider using a more generic implementation that can handle different hash functions and lengths and allow the user to choose.</p>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-10-juicebox-contest",
  "Code": [
    {
      "filename": "contracts/libraries/JBIpfsDecoder.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n  @notice\n  Utilities to decode an IPFS hash.\n*/\nlibrary JBIpfsDecoder {\n  //*********************************************************************//\n  // ------------------- internal constant properties ------------------ //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Just a kind reminder to our readers\n\n    @dev\n    Used in base58ToString\n  */\n  bytes internal constant _ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n  function decode(string memory _baseUri, bytes32 _hexString)\n    external\n    pure\n    returns (string memory)\n  {\n    // Concatenate the hex string with the fixed IPFS hash part (0x12 and 0x20)\n    bytes memory completeHexString = abi.encodePacked(bytes2(0x1220), _hexString);\n\n    // Convert the hex string to an hash\n    string memory ipfsHash = _toBase58(completeHexString);\n\n    // Concatenate with the base URI\n    return string(abi.encodePacked(_baseUri, ipfsHash));\n  }\n\n  /**\n    @notice\n    Convert an hex string to base58\n\n    @notice \n    Written by Martin Ludfall - Licence: MIT\n  */\n  function _toBase58(bytes memory _source) private pure returns (string memory) {\n    if (_source.length == 0) return new string(0);\n    uint8[] memory digits = new uint8[](46); // hash size with the prefix\n    digits[0] = 0;\n    uint8 digitlength = 1;\n    for (uint256 i = 0; i < _source.length; ++i) {\n      uint256 carry = uint8(_source[i]);\n      for (uint256 j = 0; j < digitlength; ++j) {\n        carry += uint256(digits[j]) * 256;\n        digits[j] = uint8(carry % 58);\n        carry = carry / 58;\n      }\n\n      while (carry > 0) {\n        digits[digitlength] = uint8(carry % 58);\n        digitlength++;\n        carry = carry / 58;\n      }\n    }\n    return string(_toAlphabet(_reverse(_truncate(digits, digitlength))));\n  }\n\n  function _truncate(uint8[] memory _array, uint8 _length) private pure returns (uint8[] memory) {\n    uint8[] memory output = new uint8[](_length);\n    for (uint256 i = 0; i < _length; i++) {\n      output[i] = _array[i];\n    }\n    return output;\n  }\n\n  function _reverse(uint8[] memory _input) private pure returns (uint8[] memory) {\n    uint8[] memory output = new uint8[](_input.length);\n    for (uint256 i = 0; i < _input.length; i++) {\n      output[i] = _input[_input.length - 1 - i];\n    }\n    return output;\n  }\n\n  function _toAlphabet(uint8[] memory _indices) private pure returns (bytes memory) {\n    bytes memory output = new bytes(_indices.length);\n    for (uint256 i = 0; i < _indices.length; i++) {\n      output[i] = _ALPHABET[_indices[i]];\n    }\n    return output;\n  }\n}"
    }
  ]
}