{
  "Title": "[H02] Outdated oracle prices being used throughout the protocol",
  "Content": "Throughout the system, the [`UniswapOracle` contract](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/oracle/UniswapOracle.sol) and the [`BondingCurveOracle` contract](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/oracle/BondingCurveOracle.sol) are used to [`read`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/oracle/UniswapOracle.sol#L71) the current `USDC/ETH` and `FEI/ETH` prices respectively. These prices are used throughout the protocol to peg the price for `FEI`, and so are of critical importance in the system.\n\n\nWhile the oracle is updated using the [`update` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/oracle/UniswapOracle.sol#L48) in a number of function calls, there are some calls within the system that read the price without updating it first. We understand that the Fei team is intending to manually update the oracle, however this poses a risk during times of high-volatility or high network-congestion.\n\n\nLocations in the code that do not update the oracle price include:\n\n\n* Within the function [`reweight`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pcv/EthUniswapPCVController.sol#L53) in the [`EthUniswapPCVController`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pcv/EthUniswapPCVController.sol) contract, the function first determines whether [`reweightEligible`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pcv/EthUniswapPCVController.sol#L78). To determine this, it calculates the [deviation from the current peg](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L107). However this peg is fetched without first updating the Uniswap Oracle. This means that the determination of whether to reweight is based on an outdated price, and the protocol could end up not reweighting when it should.\n* The call to [`isAtMaxPrice`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L142) to determine whether the `GenesisGroup` can execute [`launch`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L105) reads the [`peg`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/bondingcurve/BondingCurve.sol#L99) without updating it. This might cause the protocol to launch before the max has been reached, or to not launch when it should.\n* Functions in the [`BondingCurve`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/bondingcurve/BondingCurve.sol) contract that rely on the `peg`, for example [`getCurrentPrice`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/bondingcurve/BondingCurve.sol#L77), and [`getAdjustedAmount`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/bondingcurve/BondingCurve.sol#L98).\n* The [`thaw`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/oracle/BondingCurveOracle.sol#L65) function in the [`BondingCurveOracle`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/oracle/BondingCurveOracle.sol) which calculates the thawed FEI price based on the [current Uniswap price](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/oracle/BondingCurveOracle.sol#L73).\n\n\nConsider ensuring that all function calls that read an Oracle price execute a call to `update` before reading it.\n\n\n**Update:** *Fixed in [PR#28](https://github.com/fei-protocol/fei-protocol-core/pull/28). The issue was fixed in the `reweight` function of the `EthUniswapPCVController` contract, and the `isAtMaxPrice` check was removed from the `launch` function of the `GenesisGroup` contract.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/oracle/UniswapOracle.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n// Referencing Uniswap Example Simple Oracle\n// https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol\n\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\";\nimport \"./IUniswapOracle.sol\";\nimport \"../refs/CoreRef.sol\";\n\n/// @title IUniswapOracle implementation contract\n/// @author Fei Protocol\ncontract UniswapOracle is IUniswapOracle, CoreRef {\n\tusing Decimal for Decimal.D256;\n\n\tIUniswapV2Pair public override pair;\n\tbool private isPrice0;\n\n\tuint public override priorCumulative; \n\tuint32 public override priorTimestamp;\n\n\tDecimal.D256 private twap = Decimal.zero();\n\tuint32 public override duration;\n\n\tbool public override killSwitch;\n\n\t/// @notice UniswapOracle constructor\n\t/// @param _core Fei Core for reference\n\t/// @param _pair Uniswap Pair to provide TWAP\n\t/// @param _duration TWAP duration\n\t/// @param _isPrice0 flag for using token0 or token1 for cumulative on Uniswap\n\tconstructor(\n\t\taddress _core, \n\t\taddress _pair, \n\t\tuint32 _duration,\n\t\tbool _isPrice0\n\t) public CoreRef(_core) {\n\t\tpair = IUniswapV2Pair(_pair);\n\t\t// Relative to USD per ETH price\n\t\tisPrice0 = _isPrice0;\n\n\t\tduration = _duration;\n\n\t\t_init();\n\t}\n\n\tfunction update() external override returns (bool) {\n\t\t(uint price0Cumulative, uint price1Cumulative, uint32 currentTimestamp) =\n            UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n\t\tuint32 deltaTimestamp = currentTimestamp - priorTimestamp;\n\t\tif(currentTimestamp <= priorTimestamp || deltaTimestamp < duration) {\n\t\t\treturn false;\n\t\t}\n\n\t\tuint currentCumulative = _getCumulative(price0Cumulative, price1Cumulative);\n\t\tuint deltaCumulative = (currentCumulative - priorCumulative) / 1e12;\n\n\t\tDecimal.D256 memory _twap = Decimal.ratio(2**112, deltaCumulative / deltaTimestamp);\n\t\ttwap = _twap;\n\n\t\tpriorTimestamp = currentTimestamp;\n\t\tpriorCumulative = currentCumulative;\n\n\t\temit Update(_twap.asUint256());\n\n\t\treturn true;\n\t}\n\n    function read() external view override returns (Decimal.D256 memory, bool) {\n    \tbool valid = !(killSwitch || twap.isZero());\n    \treturn (twap, valid);\n    }\n \n\tfunction setKillSwitch(bool _killSwitch) external override onlyGovernor {\n\t\tkillSwitch = _killSwitch;\n\t\temit KillSwitchUpdate(_killSwitch);\n\t}\n\n\tfunction setDuration(uint32 _duration) external override onlyGovernor {\n\t\tduration = _duration;\n\t\temit DurationUpdate(_duration);\n\t}\n\n\tfunction _init() internal {\n        uint price0Cumulative = pair.price0CumulativeLast();\n        uint price1Cumulative = pair.price1CumulativeLast();\n\n        (,, uint32 currentTimestamp) = pair.getReserves();\n\n        priorTimestamp = currentTimestamp;\n\t\tpriorCumulative = _getCumulative(price0Cumulative, price1Cumulative);\n\t}\n\n    function _getCumulative(uint price0Cumulative, uint price1Cumulative) internal view returns (uint) {\n\t\treturn isPrice0 ? price0Cumulative : price1Cumulative;\n\t}\n}"
    },
    {
      "filename": "contracts/pcv/EthUniswapPCVController.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IWETH.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./IUniswapPCVController.sol\";\nimport \"../refs/UniRef.sol\";\nimport \"../oracle/IOracle.sol\";\nimport \"../external/Decimal.sol\";\n\n/// @title a IUniswapPCVController implementation for ETH\n/// @author Fei Protocol\ncontract EthUniswapPCVController is IUniswapPCVController, UniRef {\n\tusing Decimal for Decimal.D256;\n\n\tIPCVDeposit public override pcvDeposit;\n\tIUniswapIncentive public override incentiveContract;\n\n\tuint public override reweightIncentiveAmount;\n\tDecimal.D256 public minDistanceForReweight;\n\n\t/// @notice EthUniswapPCVController constructor\n\t/// @param _core Fei Core for reference\n\t/// @param _pcvDeposit PCV Deposit to reweight\n\t/// @param _oracle oracle for reference\n\t/// @param _incentiveContract incentive contract for reference\n\t/// @param _incentiveAmount amount of FEI for triggering a reweight\n\t/// @param _minDistanceForReweightBPs minimum distance from peg to reweight in basis points\n\t/// @param _pair Uniswap pair contract to reweight\n\t/// @param _router Uniswap Router\n\tconstructor (\n\t\taddress _core, \n\t\taddress _pcvDeposit, \n\t\taddress _oracle, \n\t\taddress _incentiveContract,\n\t\tuint _incentiveAmount,\n\t\tuint _minDistanceForReweightBPs,\n\t\taddress _pair,\n\t\taddress _router\n\t) public\n\t\tUniRef(_core, _pair, _router, _oracle)\n\t{\n\t\tpcvDeposit = IPCVDeposit(_pcvDeposit);\n\t\tincentiveContract = IUniswapIncentive(_incentiveContract);\n\n\t\treweightIncentiveAmount = _incentiveAmount;\n\t\tminDistanceForReweight = Decimal.ratio(_minDistanceForReweightBPs, 10000);\n\t}\n\n\treceive() external payable {}\n\n\tfunction reweight() external override postGenesis {\n\t\trequire(reweightEligible(), \"EthUniswapPCVController: Not at incentive parity or not at min distance\");\n\t\t_reweight();\n\t\t_incentivize();\n\t}\n\n\tfunction forceReweight() external override onlyGovernor {\n\t\t_reweight();\n\t}\n\n\tfunction setPCVDeposit(address _pcvDeposit) external override onlyGovernor {\n\t\tpcvDeposit = IPCVDeposit(_pcvDeposit);\n\t\temit PCVDepositUpdate(_pcvDeposit);\n\t}\n\n\tfunction setReweightIncentive(uint amount) external override onlyGovernor {\n\t\treweightIncentiveAmount = amount;\n\t\temit ReweightIncentiveUpdate(amount);\n\t}\n\n\tfunction setReweightMinDistance(uint basisPoints) external override onlyGovernor {\n\t\tminDistanceForReweight = Decimal.ratio(basisPoints, 10000);\n\t\temit ReweightMinDistanceUpdate(basisPoints);\n\t}\n\n\tfunction reweightEligible() public view override returns(bool) {\n\t\tbool magnitude = getDistanceToPeg().greaterThan(minDistanceForReweight);\n\t\tbool time = incentiveContract.isIncentiveParity();\n\t\treturn magnitude && time;\n\t}\n\n\tfunction _incentivize() internal ifMinterSelf {\n\t\tfei().mint(msg.sender, reweightIncentiveAmount);\n\t}\n\n\tfunction _reweight() internal {\n\t\t_withdrawAll();\n\t\t_returnToPeg();\n\n\t\tuint balance = address(this).balance;\n\t\tpcvDeposit.deposit{value: balance}(balance);\n\n\t\t_burnFeiHeld();\n\n\t\temit Reweight(msg.sender);\n\t}\n\n\tfunction _returnToPeg() internal {\n\t\t(uint feiReserves, uint ethReserves) = getReserves();\n\t\tif (feiReserves == 0 || ethReserves == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tupdateOracle();\n\n    \trequire(isBelowPeg(peg()), \"EthUniswapPCVController: already at or above peg\");\n    \t\n\t\tuint amountEth = getAmountToPegOther();\n    \t_swapEth(amountEth, ethReserves, feiReserves);\n\t}\n\n\tfunction _swapEth(uint amountEth, uint ethReserves, uint feiReserves) internal {\n\t\tuint balance = address(this).balance;\n\t\tuint amount = Math.min(amountEth, balance);\n\t\t\n\t\tuint amountOut = UniswapV2Library.getAmountOut(amount, ethReserves, feiReserves);\n\t\t\n\t\tIWETH weth = IWETH(router.WETH());\n\t\tweth.deposit{value: amount}();\n\t\tweth.transfer(address(pair), amount);\n\n\t\t(uint amount0Out, uint amount1Out) = pair.token0() == address(weth) ? (uint(0), amountOut) : (amountOut, uint(0));\n\t\tpair.swap(amount0Out, amount1Out, address(this), new bytes(0));\n\t}\n\n\tfunction _withdrawAll() internal {\n\t\tuint value = pcvDeposit.totalValue();\n\t\tpcvDeposit.withdraw(address(this), value);\n\t}\n}"
    },
    {
      "filename": "contracts/genesis/GenesisGroup.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IGenesisGroup.sol\";\nimport \"./IDOInterface.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../refs/CoreRef.sol\";\nimport \"../pool/IPool.sol\";\nimport \"../oracle/IBondingCurveOracle.sol\";\nimport \"../bondingcurve/IBondingCurve.sol\";\n\ninterface IOrchestrator {\n\tfunction launchGovernance() external;\n\tfunction pool() external returns(address);\n\tfunction bondingCurveOracle() external returns(address);\n}\n\n/// @title IGenesisGroup implementation\n/// @author Fei Protocol\ncontract GenesisGroup is IGenesisGroup, CoreRef, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\n\tIOrchestrator private orchestrator;\n\n\tIBondingCurve private bondingcurve;\n\n\tIBondingCurveOracle private bondingCurveOracle;\n\n\tIPool private pool;\n\n\tIDOInterface private ido;\n\tuint private exchangeRateDiscount;\n\n\t/// @notice a cap on the genesis group purchase price\n\tDecimal.D256 public maxGenesisPrice;\n\n\t/// @notice GenesisGroup constructor\n\t/// @param _core Fei Core address to reference\n\t/// @param _bondingcurve Bonding curve address for purchase\n\t/// @param _ido IDO contract to deploy\n\t/// @param _oracle Bonding curve oracle\n\t/// @param _pool Staking Pool\n\t/// @param _duration duration of the Genesis Period\n\t/// @param _maxPriceBPs max price of FEI allowed in Genesis Group in dollar terms\n\t/// @param _exchangeRateDiscount a divisor on the FEI/TRIBE ratio at Genesis to deploy to the IDO\n\tconstructor(\n\t\taddress _core, \n\t\taddress _bondingcurve,\n\t\taddress _ido,\n\t\taddress _oracle,\n\t\taddress _pool,\n\t\tuint32 _duration,\n\t\tuint _maxPriceBPs,\n\t\tuint _exchangeRateDiscount\n\t) public\n\t\tCoreRef(_core)\n\t\tERC20(\"Fei Genesis Group\", \"FGEN\")\n\t\tTimed(_duration)\n\t{\n\t\tbondingcurve = IBondingCurve(_bondingcurve);\n\n\t\texchangeRateDiscount = _exchangeRateDiscount;\n\t\tido = IDOInterface(_ido);\n\n\t\tpool = IPool(_pool);\n\t\tbondingCurveOracle = IBondingCurveOracle(_oracle);\n\n\t\t_initTimed();\n\n\t\tmaxGenesisPrice = Decimal.ratio(_maxPriceBPs, 10000);\n\t}\n\n\tmodifier onlyGenesisPeriod() {\n\t\trequire(!isTimeEnded(), \"GenesisGroup: Not in Genesis Period\");\n\t\t_;\n\t}\n\n\tfunction purchase(address to, uint value) external override payable onlyGenesisPeriod {\n\t\trequire(msg.value == value, \"GenesisGroup: value mismatch\");\n\t\trequire(value != 0, \"GenesisGroup: no value sent\");\n\n\t\t_mint(to, value);\n\n\t\temit Purchase(to, value);\n\t}\n\n\tfunction redeem(address to) external override postGenesis {\n\t\tDecimal.D256 memory ratio = _fgenRatio(to);\n\t\trequire(!ratio.equals(Decimal.zero()), \"GensisGroup: No balance to redeem\");\n\n\t\tuint amountIn = balanceOf(to);\n\t\tburnFrom(to, amountIn);\n\n\t\tuint feiAmount = ratio.mul(feiBalance()).asUint256();\n\t\tfei().transfer(to, feiAmount);\n\n\t\tuint tribeAmount = ratio.mul(tribeBalance()).asUint256();\n\t\ttribe().transfer(to, tribeAmount);\n\n\t\temit Redeem(to, amountIn, feiAmount, tribeAmount);\n\t}\n\n\tfunction launch() external override {\n\t\trequire(isTimeEnded() || isAtMaxPrice(), \"GenesisGroup: Still in Genesis Period\");\n\n\t\tcore().completeGenesisGroup();\n\n\t\taddress genesisGroup = address(this);\n\t\tuint balance = genesisGroup.balance;\n\n\t\tbondingCurveOracle.init(bondingcurve.getAveragePrice(balance));\n\n\t\tbondingcurve.purchase{value: balance}(genesisGroup, balance);\n\t\tbondingcurve.allocate();\n\n\t\tpool.init();\n\n\t\tido.deploy(_feiTribeExchangeRate());\n\n\t\t// solhint-disable-next-line not-rely-on-time\n\t\temit Launch(now);\n\t}\n\n\tfunction getAmountOut(\n\t\tuint amountIn, \n\t\tbool inclusive\n\t) public view override returns (uint feiAmount, uint tribeAmount) {\n\t\tuint totalIn = totalSupply();\n\t\tif (!inclusive) {\n\t\t\ttotalIn += amountIn;\n\t\t}\n\t\trequire(amountIn <= totalIn, \"GenesisGroup: Not enough supply\");\n\n\t\tuint totalFei = bondingcurve.getAmountOut(totalIn);\n\t\tuint totalTribe = tribeBalance();\n\n\t\treturn (totalFei * amountIn / totalIn, totalTribe * amountIn / totalIn);\n\t}\n\n\tfunction isAtMaxPrice() public view override returns(bool) {\n\t\tuint balance = address(this).balance;\n\t\trequire(balance != 0, \"GenesisGroup: No balance\");\n\n\t\treturn bondingcurve.getAveragePrice(balance).greaterThanOrEqualTo(maxGenesisPrice);\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\t// Sender doesn't need approval\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _fgenRatio(address account) internal view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(balanceOf(account), totalSupply());\n\t}\n\n\tfunction _feiTribeExchangeRate() public view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(feiBalance(), tribeBalance()).div(exchangeRateDiscount);\n\t}\n}"
    },
    {
      "filename": "contracts/oracle/BondingCurveOracle.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IBondingCurveOracle.sol\";\nimport \"../refs/CoreRef.sol\";\nimport \"../utils/Timed.sol\";\n\n/// @title IBondingCurveOracle implementation contract\n/// @author Fei Protocol\n/// @notice includes \"thawing\" on the initial purchase price at genesis. Time weights price from initial to true peg over a window.\ncontract BondingCurveOracle is IBondingCurveOracle, CoreRef, Timed {\n\tusing Decimal for Decimal.D256;\n\n\tIOracle public override uniswapOracle;\n\tIBondingCurve public override bondingCurve;\n\n\tbool public override killSwitch = true;\n\n\t/// @notice the price in dollars at initialization\n\t/// @dev this price will \"thaw\" to the peg price over `duration` window\n\tDecimal.D256 public initialPrice;\n\n\tevent KillSwitchUpdate(bool _killSwitch);\n\n\t/// @notice BondingCurveOracle constructor\n\t/// @param _core Fei Core to reference\n\t/// @param _oracle Uniswap Oracle to report from\n\t/// @param _bondingCurve Bonding curve to report from\n\t/// @param _duration price thawing duration\n\tconstructor(\n\t\taddress _core, \n\t\taddress _oracle, \n\t\taddress _bondingCurve, \n\t\tuint32 _duration\n\t) public CoreRef(_core) Timed(_duration) {\n\t\tuniswapOracle = IOracle(_oracle);\n\t\tbondingCurve = IBondingCurve(_bondingCurve);\n\t}\n\n\tfunction update() external override returns (bool) {\n\t\treturn uniswapOracle.update();\n\t}\n\n    function read() external view override returns (Decimal.D256 memory, bool) {\n    \tif (killSwitch) {\n    \t\treturn (Decimal.zero(), false);\n    \t}\n    \t(Decimal.D256 memory peg, bool valid) = getOracleValue();\n    \treturn (thaw(peg), valid);\n    }\n\n\tfunction setKillSwitch(bool _killSwitch) external override onlyGovernor {\n\t\tkillSwitch = _killSwitch;\n\t\temit KillSwitchUpdate(_killSwitch);\n\t}\n\n\tfunction init(Decimal.D256 memory _initialPrice) public override onlyGenesisGroup {\n    \tkillSwitch = false;\n\n    \tinitialPrice = _initialPrice;\n\n\t\t_initTimed();\n    }\n\n    function thaw(Decimal.D256 memory peg) internal view returns (Decimal.D256 memory) {\n    \tif (isTimeEnded()) {\n    \t\treturn peg;\n    \t}\n\t\tuint t = uint(timestamp());\n\t\tuint remaining = uint(remainingTime());\n\t\tuint d = uint(duration);\n\n    \t(Decimal.D256 memory uniswapPeg,) = uniswapOracle.read();\n    \tDecimal.D256 memory price = uniswapPeg.div(peg);\n\n    \tDecimal.D256 memory weightedPrice = initialPrice.mul(remaining).add(price.mul(t)).div(d);\n    \treturn uniswapPeg.div(weightedPrice);\n    }\n\n    function getOracleValue() internal view returns(Decimal.D256 memory, bool) {\n    \tif (bondingCurve.atScale()) {\n    \t\treturn uniswapOracle.read();\n    \t}\n    \treturn (bondingCurve.getCurrentPrice(), true);\n    }\n}"
    }
  ]
}