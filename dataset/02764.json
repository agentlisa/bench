{
  "Title": "M-4: Issue when handling native ETH trade and WETH trade in DODO RouterProxy#externalSwap",
  "Content": "# Issue M-4: Issue when handling native ETH trade and WETH trade in DODO RouterProxy#externalSwap \n\nSource: https://github.com/sherlock-audit/2022-11-dodo-judging/issues/20 \n\n## Found by \nctf\\_sec\n\n## Summary\n\nLack of logic to wrap the native ETH to WETH in function externalSwap\n\n## Vulnerability Detail\n\nThe function exeternalSwap can handle external swaps with 0x, 1inch and paraswap or other external resources.\n\n```solidity\n    function externalSwap(\n        address fromToken,\n        address toToken,\n        address approveTarget,\n        address swapTarget,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        bytes memory feeData,\n        bytes memory callDataConcat,\n        uint256 deadLine\n    ) external payable judgeExpired(deadLine) returns (uint256 receiveAmount) {      \n        require(isWhiteListedContract[swapTarget], \"DODORouteProxy: Not Whitelist Contract\");  \n        require(isApproveWhiteListedContract[approveTarget], \"DODORouteProxy: Not Whitelist Appprove Contract\");  \n\n        // transfer in fromToken\n        if (fromToken != _ETH_ADDRESS_) {\n            // approve if needed\n            if (approveTarget != address(0)) {\n                IERC20(fromToken).universalApproveMax(approveTarget, fromTokenAmount);\n            }\n\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n                fromToken,\n                msg.sender,\n                address(this),\n                fromTokenAmount\n            );\n        }\n\n        // swap\n        uint256 toTokenOriginBalance;\n        if(toToken != _ETH_ADDRESS_) {\n            toTokenOriginBalance = IERC20(toToken).universalBalanceOf(address(this));\n        } else {\n            toTokenOriginBalance = IERC20(_WETH_).universalBalanceOf(address(this));\n        }\n```\n\nnote the code above, if the fromToken is set to _ETH_ADDRESS, indicating the user wants to trade with native ETH pair. the function does has payable modifier and user can send ETH along when calling this function.\n\nHowever, the toTokenOriginBalance is check the only _WETH_ balance instead of ETH balance.\n\n```solidity\n  if(toToken != _ETH_ADDRESS_) {\n      toTokenOriginBalance = IERC20(toToken).universalBalanceOf(address(this));\n  } else {\n      toTokenOriginBalance = IERC20(_WETH_).universalBalanceOf(address(this));\n  }\n```\n\nThen we do the swap:\n\n```solidity\n(bool success, bytes memory result) = swapTarget.call{\n    value: fromToken == _ETH_ADDRESS_ ? fromTokenAmount : 0\n}(callDataConcat);\n```\n\nIf the fromToken is _ETH_ADDRESS, we send the user supplied fromTokenAmount without verifying that the fromTokenAmount.\n\nFinally, we use the before and after balance to get the amount with received.\n\n```solidity\n// calculate toToken amount\n  if(toToken != _ETH_ADDRESS_) {\n      receiveAmount = IERC20(toToken).universalBalanceOf(address(this)) - (\n          toTokenOriginBalance\n      );\n  } else {\n      receiveAmount = IERC20(_WETH_).universalBalanceOf(address(this)) - (\n          toTokenOriginBalance\n      );\n  }\n```\n\nWe are checking the WETH amount instead of ETH amount again.\n\n**The issue is that some trades may settle the trade in native ETH, for example**\n\nhttps://developers.paraswap.network/smart-contracts\n\nwe can look into the Paraswap contract\n\nhttps://etherscan.io/address/0xDEF171Fe48CF0115B1d80b88dc8eAB59176FEe57#writeProxyContract\n\nIf we click the implementation contract and see the method swapOnUniswapV2Fork\n\nhttps://etherscan.io/address/0x4ff0dec5f9a763aa1e5c2a962aa6f4edfee4f9ea#code\n\nCode line 927 - 944, which calls the function\n\n```solidity\nfunction swapOnUniswapV2Fork(\n\taddress tokenIn,\n\tuint256 amountIn,\n\tuint256 amountOutMin,\n\taddress weth,\n\tuint256[] calldata pools\n)\n\texternal\n\tpayable\n{\n\t_swap(\n\t\ttokenIn,\n\t\tamountIn,\n\t\tamountOutMin,\n\t\tweth,\n\t\tpools\n\t);\n}\n```\n\nwhich calls:\n\n```solidity\n  function _swap(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address weth,\n        uint256[] memory pools\n    )\n        private\n        returns (uint256 tokensBought)\n    {\n        uint256 pairs = pools.length;\n\n        require(pairs != 0, \"At least one pool required\");\n\n        bool tokensBoughtEth;\n\n        if (tokenIn == ETH_IDENTIFIER) {\n            require(amountIn == msg.value, \"Incorrect msg.value\");\n            IWETH(weth).deposit{value: msg.value}();\n            require(IWETH(weth).transfer(address(pools[0]), msg.value));\n        } else {\n            require(msg.value == 0, \"Incorrect msg.value\");\n            transferTokens(tokenIn, msg.sender, address(pools[0]), amountIn);\n            tokensBoughtEth = weth != address(0);\n        }\n\n        tokensBought = amountIn;\n\n        for (uint256 i = 0; i < pairs; ++i) {\n            uint256 p = pools[i];\n            address pool = address(p);\n            bool direction = p & DIRECTION_FLAG == 0;\n\n            tokensBought = NewUniswapV2Lib.getAmountOut(\n                tokensBought, pool, direction, p >> FEE_OFFSET\n            );\n            (uint256 amount0Out, uint256 amount1Out) = direction\n                ? (uint256(0), tokensBought) : (tokensBought, uint256(0));\n            IUniswapV2Pair(pool).swap(\n                amount0Out,\n                amount1Out,\n                i + 1 == pairs\n                    ? (tokensBoughtEth ? address(this) : msg.sender)\n                    : address(pools[i + 1]),\n                \"\"\n            );\n        }\n\n        if (tokensBoughtEth) {\n            IWETH(weth).withdraw(tokensBought);\n            TransferHelper.safeTransferETH(msg.sender, tokensBought);\n        }\n\n        require(tokensBought >= amountOutMin, \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n    }\n```\n\nas can clearly see, the code first receive ETH, wrap ETH to WETH, then instead end, unwrap the WETH to ETH and the send the ETH back to complete the trade.\n\n```solidity\nif (tokensBoughtEth) {\n\tIWETH(weth).withdraw(tokensBought);\n\tTransferHelper.safeTransferETH(msg.sender, tokensBought);\n}\n```\n\nIn DODORouterProxy.sol#ExternalSwap however, we are using WETH balance before and after to check the received amount,\n\nbut if we call swapOnUniswapV2Fork on Paraswap router, the balance change for WETH would be 0\n\nbecause as we see above, the method on paraswap side wrap ETH to WETH but in the end unwrap WETH and send ETH back.\n\nThere is also a lack of a method to wrap the ETH to WETH before the trade. making the ETH-related order not tradeable.\n\n## Impact\n\nA lot of method that does not use WETH to settle the trade will not be callable.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-dodo/blob/main/contracts/SmartRoute/DODORouteProxy.sol#L158-L230\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the project change from \n\n```solidity\n  // swap\n  uint256 toTokenOriginBalance;\n  if(toToken != _ETH_ADDRESS_) {\n      toTokenOriginBalance = IERC20(toToken).universalBalanceOf(address(this));\n  } else {\n      toTokenOriginBalance = IERC20(_WETH_).universalBalanceOf(address(this));\n  }\n```\n\n\n```solidity\n  // swap\n  uint256 toTokenOriginBalance;\n  if(toToken != _ETH_ADDRESS_) {\n      toTokenOriginBalance = IERC20(toToken).universalBalanceOf(address(this));\n  } else {\n      toTokenOriginBalance = IERC20(_ETH_ADDRESS).universalBalanceOf(address(this));\n  }\n```\n\nIf we want to use WETH to do the balance check, we can help the user wrap the ETH to WETH by calling before do the balance check.\n\n```solidity\nIWETH(_WETH_).deposit(receiveAmount);\n```\n\nIf we want to use WETH as the reference to trade, we also need to approve external contract to spend our WETH.\n\nWe can add\n\n```solidity\nif(fromToken == _ETH_ADDRESS) {\n   IERC20(_WETH_).universalApproveMax(approveTarget, fromTokenAmount);\n}\n```\n\nWe also need to verify the fromTokenAmount for\n\n```solidity\n(bool success, bytes memory result) = swapTarget.call{\n    value: fromToken == _ETH_ADDRESS_ ? fromTokenAmount : 0\n}(callDataConcat);\n```\n\nwe can add the check: \n\n```solidity\nrequire(msg.value == fromTokenAmount, \"invalid ETH amount\");\n```\n\n## Discussion\n\n**Attens1423**\n\nIn our api, we require toToken is WETH when contructing callData. We will add some notes here. Thanks for noticing\n\n**Evert0x**\n\nEven tough the API is requiring WETH we still think it's a valid issue as the contract has a payable modifier. \n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/21",
  "Code": [
    {
      "filename": "contracts/SmartRoute/DODORouteProxy.sol",
      "content": "/*\n\n    Copyright 2022 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.16;\npragma experimental ABIEncoderV2;\n\nimport { IDODOApproveProxy } from \"../DODOApproveProxy.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IWETH } from \"../intf/IWETH.sol\";\nimport { DecimalMath } from \"../lib/DecimalMath.sol\";\nimport { UniversalERC20 } from \"./lib/UniversalERC20.sol\";\nimport { IDODOAdapter } from \"./intf/IDODOAdapter.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title DODORouteProxy\n/// @author DODO Breeder\n/// @notice new routeProxy contract with fee rebate to manage all route. It provides three methods to swap, \n/// including mixSwap, multiSwap and externalSwap. Mixswap is for linear swap, which describes one token path \n/// with one pool each time. Multiswap is a simplified version about 1inch, which describes one token path \n/// with several pools each time. ExternalSwap is for other routers like 0x, 1inch and paraswap. Dodo and \n/// front-end users could take certain route fee rebate from each swap. Wherein dodo will get a fixed percentage, \n/// and front-end users could assign any proportion through function parameters.\n/// @dev dependence: DODOApprove.sol / DODOApproveProxy.sol / IDODOAdapter.sol\n/// In dodo's contract system, there is only one approve entrance DODOApprove.sol. DODOApprove manages DODOApproveProxy,\n/// Any contract which needs claim user's tokens must be registered in DODOApproveProxy. They used in DODORouteProxy are \n/// to manage user's token, all user's token must be claimed through DODOApproveProxy and DODOApprove\n/// IDODOAdapter determine the interface of adapter, in which swap happened. There are different adapters for different\n/// pools. Adapter addresses are parameters contructed off chain so they are loose coupling with routeProxy.\n/// adapters have two interface functions. func sellBase(address to, address pool, bytes memory moreInfo) and func sellQuote(address to, address pool, bytes memory moreInfo)\n\ncontract DODORouteProxy is Ownable {\n\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n\n    address constant _ETH_ADDRESS_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public immutable _WETH_;\n    // dodo appprove proxy address, the only entrance to get user's token\n    address public immutable _DODO_APPROVE_PROXY_;\n    // used in multiSwap for split, sum of pool weight must equal totalWeight\n    // in PoolInfo, pool weight has 8 bit, so totalWeight < 2**8\n    uint256 public totalWeight = 100;\n    // check safe safe for external call, add trusted external swap contract, 0x,1inch, paraswap\n    // only owner could manage\n    mapping(address => bool) public isWhiteListedContract; \n    // check safe for external approve, add trusted external swap approve contract, 0x, 1inch, paraswap\n    // only owner could manage\n    // Specially for 0x swap from eth, add zero address\n    mapping(address => bool) public isApproveWhiteListedContract; \n\n    // dodo route fee rate, unit is 10**18, default fee rate is 1.5 * 1e15 / 1e18 = 0.0015 = 0.015%\n    uint256 public routeFeeRate = 1500000000000000; \n    // dodo route fee receiver\n    address public routeFeeReceiver;\n\n    struct PoolInfo {\n        // pool swap direciton, 0 is for sellBase, 1 is for sellQuote\n        uint256 direction;\n        // distinct transferFrom pool(like dodoV1) and transfer pool\n        // 1 is for transferFrom pool, pool call transferFrom function to get tokens from adapter\n        // 2 is for transfer pool, pool determine swapAmount through balanceOf(Token) - reserve\n        uint256 poolEdition;\n        // pool weight, actualWeight = weight/totalWeight, totalAmount * actualWeight = amount through this pool swap\n        uint256 weight;\n        // pool address\n        address pool;\n        // pool adapter, making actual swap call in corresponding adapter\n        address adapter;\n        // pool adapter's Info, record addtional infos(could be zero-bytes) needed by each pool adapter\n        bytes moreInfo;\n    }\n\n    // ============ Events ============\n\n    event OrderHistory(\n        address fromToken,\n        address toToken,\n        address sender,\n        uint256 fromAmount,\n        uint256 returnAmount\n    );\n\n    // ============ Modifiers ============\n\n    modifier judgeExpired(uint256 deadLine) {\n        require(deadLine >= block.timestamp, \"DODORouteProxy: EXPIRED\");\n        _;\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Constructor ============\n\n    constructor(address payable weth, address dodoApproveProxy, address feeReceiver) public {\n        require(feeReceiver != address(0), \"DODORouteProxy: feeReceiver invalid\");\n        require(dodoApproveProxy != address(0), \"DODORouteProxy: dodoApproveProxy invalid\");\n        require(weth != address(0), \"DODORouteProxy: weth address invalid\");\n\n        _WETH_ = weth;\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\n        routeFeeReceiver = feeReceiver;\n    }\n\n    // ============ Owner only ============\n\n    function addWhiteList(address contractAddr) public onlyOwner {\n        isWhiteListedContract[contractAddr] = true;\n    }\n\n    function removeWhiteList(address contractAddr) public onlyOwner {\n        isWhiteListedContract[contractAddr] = false;\n    }\n\n    function addApproveWhiteList(address contractAddr) public onlyOwner {\n        isApproveWhiteListedContract[contractAddr] = true;\n    }\n\n    function removeApproveWhiteList(address contractAddr) public onlyOwner {\n        isApproveWhiteListedContract[contractAddr] = false;\n    }\n\n    function changeRouteFeeRate(uint256 newFeeRate) public onlyOwner {\n        require(newFeeRate < 10**18, \"DODORouteProxy: newFeeRate overflowed\");\n        routeFeeRate = newFeeRate;\n    }\n  \n    function changeRouteFeeReceiver(address newFeeReceiver) public onlyOwner {\n        require(newFeeReceiver != address(0), \"DODORouteProxy: feeReceiver invalid\");\n        routeFeeReceiver = newFeeReceiver;\n    }\n\n    function changeTotalWeight(uint256 newTotalWeight) public onlyOwner {\n        require(newTotalWeight < 2 ** 8, \"DODORouteProxy: totalWeight overflowed\");\n        totalWeight = newTotalWeight;\n    }\n\n    /// @notice used for emergency, generally there wouldn't be tokens left\n    function superWithdraw(address token) public onlyOwner {\n        if(token != _ETH_ADDRESS_) {\n            uint256 restAmount = IERC20(token).universalBalanceOf(address(this));\n            IERC20(token).universalTransfer(payable(routeFeeReceiver), restAmount);\n        } else {\n            uint256 restAmount = address(this).balance;\n            payable(routeFeeReceiver).transfer(restAmount);\n        }\n    }\n\n    // ============ Swap ============\n\n\n    /// @notice Call external black box contracts to finish a swap\n    /// @param approveTarget external swap approve address\n    /// @param swapTarget external swap address\n    /// @param feeData route fee info\n    /// @param callDataConcat external swap data\n    function externalSwap(\n        address fromToken,\n        address toToken,\n        address approveTarget,\n        address swapTarget,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        bytes memory feeData,\n        bytes memory callDataConcat,\n        uint256 deadLine\n    ) external payable judgeExpired(deadLine) returns (uint256 receiveAmount) {      \n        require(isWhiteListedContract[swapTarget], \"DODORouteProxy: Not Whitelist Contract\");  \n        require(isApproveWhiteListedContract[approveTarget], \"DODORouteProxy: Not Whitelist Appprove Contract\");  \n\n        // transfer in fromToken\n        if (fromToken != _ETH_ADDRESS_) {\n            // approve if needed\n            if (approveTarget != address(0)) {\n                IERC20(fromToken).universalApproveMax(approveTarget, fromTokenAmount);\n            }\n\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n                fromToken,\n                msg.sender,\n                address(this),\n                fromTokenAmount\n            );\n        }\n\n        // swap\n        uint256 toTokenOriginBalance;\n        if(toToken != _ETH_ADDRESS_) {\n            toTokenOriginBalance = IERC20(toToken).universalBalanceOf(address(this));\n        } else {\n            toTokenOriginBalance = IERC20(_WETH_).universalBalanceOf(address(this));\n        }\n\n        {\n            require(swapTarget != _DODO_APPROVE_PROXY_, \"DODORouteProxy: Risk Target\");\n            (bool success, bytes memory result) = swapTarget.call{\n                value: fromToken == _ETH_ADDRESS_ ? fromTokenAmount : 0\n            }(callDataConcat);\n            // revert with lowlevel info\n            if (success == false) {\n                assembly {\n                    revert(add(result,32),mload(result))\n                }\n            }\n        }\n\n        // calculate toToken amount\n        if(toToken != _ETH_ADDRESS_) {\n            receiveAmount = IERC20(toToken).universalBalanceOf(address(this)) - (\n                toTokenOriginBalance\n            );\n        } else {\n            receiveAmount = IERC20(_WETH_).universalBalanceOf(address(this)) - (\n                toTokenOriginBalance\n            );\n        }\n        \n        // distribute toToken\n        _routeWithdraw(toToken, receiveAmount, feeData, minReturnAmount);\n\n        emit OrderHistory(fromToken, toToken, msg.sender, fromTokenAmount, receiveAmount);\n    }\n\n    /// @notice linear version, describes one token path with one pool each time\n    /// @param mixAdapters adapter address array, record each pool's interrelated adapter in order\n    /// @param mixPairs pool address array, record pool address of the whole route in order\n    /// @param assetTo asset Address（pool or proxy）, describe pool adapter's receiver address. Specially assetTo[0] is deposit receiver before all\n    /// @param directions pool directions aggregation, one bit represent one pool direction, 0 means sellBase, 1 means sellQuote\n    /// @param moreInfos pool adapter's Info set, record addtional infos(could be zero-bytes) needed by each pool adapter, keeping order with adapters\n    /// @param feeData route fee info, bytes decode into broker and brokerFee, determine rebate proportion, brokerFee in [0, 1e18]\n    function mixSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] memory mixAdapters,\n        address[] memory mixPairs,\n        address[] memory assetTo,\n        uint256 directions,\n        bytes[] memory moreInfos,\n        bytes memory feeData,\n        uint256 deadLine\n    ) external payable judgeExpired(deadLine) returns (uint256 receiveAmount) {\n        require(mixPairs.length > 0, \"DODORouteProxy: PAIRS_EMPTY\");\n        require(mixPairs.length == mixAdapters.length, \"DODORouteProxy: PAIR_ADAPTER_NOT_MATCH\");\n        require(mixPairs.length == assetTo.length - 1, \"DODORouteProxy: PAIR_ASSETTO_NOT_MATCH\");\n        require(minReturnAmount > 0, \"DODORouteProxy: RETURN_AMOUNT_ZERO\");\n\n        address _toToken = toToken;\n        {\n        uint256 _fromTokenAmount = fromTokenAmount;\n        address _fromToken = fromToken;\n\n        uint256 toTokenOriginBalance;\n        if(_toToken != _ETH_ADDRESS_) {\n            toTokenOriginBalance = IERC20(_toToken).universalBalanceOf(address(this));\n        } else {\n            toTokenOriginBalance = IERC20(_WETH_).universalBalanceOf(address(this));\n        }\n\n        // transfer in fromToken\n        _deposit(\n            msg.sender,\n            assetTo[0],\n            _fromToken,\n            _fromTokenAmount,\n            _fromToken == _ETH_ADDRESS_\n        );\n\n        // swap\n        for (uint256 i = 0; i < mixPairs.length; i++) {\n            if (directions & 1 == 0) {\n                IDODOAdapter(mixAdapters[i]).sellBase(\n                    assetTo[i + 1],\n                    mixPairs[i],\n                    moreInfos[i]\n                );\n            } else {\n                IDODOAdapter(mixAdapters[i]).sellQuote(\n                    assetTo[i + 1],\n                    mixPairs[i],\n                    moreInfos[i]\n                );\n            }\n            directions = directions >> 1;\n        }\n\n        // calculate toToken amount\n        if(_toToken != _ETH_ADDRESS_) {\n            receiveAmount = IERC20(_toToken).universalBalanceOf(address(this)) - (\n                toTokenOriginBalance\n            );\n        } else {\n            receiveAmount = IERC20(_WETH_).universalBalanceOf(address(this)) - (\n                toTokenOriginBalance\n            );\n        }\n        }\n\n        // distribute toToken\n        _routeWithdraw(_toToken, receiveAmount, feeData, minReturnAmount);\n\n        emit OrderHistory(fromToken, toToken, msg.sender, fromTokenAmount, receiveAmount);\n    }\n\n    /// @notice split version, describes one token path with several pools each time. Called one token pair with several pools \"one split\"\n    /// @param splitNumber record pool number in one split, determine sequence(poolInfo) array subscript in transverse. Begin with 0\n    /// for example, [0,1, 3], mean the first split has one(1 - 0) pool, the second split has 2 (3 - 1) pool\n    /// @param midToken middle token set, record token path in order. \n    /// Specially midToken[1] is WETH addresss when fromToken is ETH. Besides midToken[1] is also fromToken \n    /// Specially midToken[length - 2] is WETH address and midToken[length -1 ] is ETH address when toToken is ETH. Besides midToken[length -1]\n    /// is the last toToken and midToken[length - 2] is common second last middle token.\n    /// @param assetFrom asset Address（pool or proxy）describe pool adapter's receiver address. Specially assetFrom[0] is deposit receiver before all\n    /// @param sequence PoolInfo sequence, describe each pool's attributions, ordered by spiltNumber\n    /// @param feeData route fee info, bytes decode into broker and brokerFee, determine rebate proportion, brokerFee in [0, 1e18]\n    function dodoMutliSwap(\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        uint256[] memory splitNumber,  \n        address[] memory midToken,\n        address[] memory assetFrom,\n        bytes[] memory sequence, \n        bytes memory feeData,\n        uint256 deadLine\n    ) external payable judgeExpired(deadLine) returns (uint256 receiveAmount) {\n        address toToken = midToken[midToken.length - 1];\n        {\n        require(\n            assetFrom.length == splitNumber.length,\n            \"DODORouteProxy: PAIR_ASSETTO_NOT_MATCH\"\n        );\n        require(minReturnAmount > 0, \"DODORouteProxy: RETURN_AMOUNT_ZERO\");\n        uint256 _fromTokenAmount = fromTokenAmount;\n        address fromToken = midToken[0];\n\n        uint256 toTokenOriginBalance;\n        if(toToken != _ETH_ADDRESS_) {\n            toTokenOriginBalance = IERC20(toToken).universalBalanceOf(address(this));\n        } else {\n            toTokenOriginBalance = IERC20(_WETH_).universalBalanceOf(address(this));\n        }\n\n        // transfer in fromToken\n        _deposit(\n            msg.sender,\n            assetFrom[0],\n            fromToken,\n            _fromTokenAmount,\n            fromToken == _ETH_ADDRESS_\n        );\n\n        // swap\n        _multiSwap(midToken, splitNumber, sequence, assetFrom);\n\n        // calculate toToken amount\n        if(toToken != _ETH_ADDRESS_) {\n            receiveAmount = IERC20(toToken).universalBalanceOf(address(this)) - (\n                toTokenOriginBalance\n            );\n        } else {\n            receiveAmount = IERC20(_WETH_).universalBalanceOf(address(this)) - (\n                toTokenOriginBalance\n            );\n        }\n        }\n        // distribute toToken\n        _routeWithdraw(toToken, receiveAmount, feeData, minReturnAmount);\n\n        emit OrderHistory(\n            midToken[0], //fromToken\n            midToken[midToken.length - 1], //toToken\n            msg.sender,\n            fromTokenAmount,\n            receiveAmount\n        );\n    }\n\n    //====================== internal =======================\n    /// @notice multiSwap process\n    function _multiSwap(\n        address[] memory midToken,\n        uint256[] memory splitNumber,\n        bytes[] memory swapSequence,\n        address[] memory assetFrom\n    ) internal {\n        for (uint256 i = 1; i < splitNumber.length; i++) {\n            // begin one split(one token pair with one or more pools)\n            // define midtoken address, ETH -> WETH address\n            uint256 curTotalAmount = IERC20(midToken[i]).tokenBalanceOf(assetFrom[i - 1]);\n            uint256 curTotalWeight = totalWeight;\n\n            // split amount into all pools if needed, transverse all pool in this split\n            for (uint256 j = splitNumber[i - 1]; j < splitNumber[i]; j++) {\n                PoolInfo memory curPoolInfo;\n                {\n                    (address pool, address adapter, uint256 mixPara, bytes memory moreInfo) = abi\n                        .decode(swapSequence[j], (address, address, uint256, bytes));\n\n                    curPoolInfo.direction = mixPara >> 17;\n                    curPoolInfo.weight = (0xffff & mixPara) >> 9;\n                    curPoolInfo.poolEdition = (0xff & mixPara);\n                    curPoolInfo.pool = pool;\n                    curPoolInfo.adapter = adapter;\n                    curPoolInfo.moreInfo = moreInfo;\n                }\n\n                // assetFrom[i - 1] is routeProxy when there are more than one pools in this split\n                if (assetFrom[i - 1] == address(this)) {\n                    uint256 curAmount = curTotalAmount * curPoolInfo.weight / curTotalWeight;\n\n                    if (curPoolInfo.poolEdition == 1) {\n                        //For using transferFrom pool (like dodoV1, Curve), pool call transferFrom function to get tokens from adapter\n                        IERC20(midToken[i]).transfer(curPoolInfo.adapter, curAmount);\n                    } else {\n                        //For using transfer pool (like dodoV2), pool determine swapAmount through balanceOf(Token) - reserve\n                        IERC20(midToken[i]).transfer(curPoolInfo.pool, curAmount);\n                    }\n                }\n\n                if (curPoolInfo.direction == 0) {\n                    IDODOAdapter(curPoolInfo.adapter).sellBase(\n                        assetFrom[i],\n                        curPoolInfo.pool,\n                        curPoolInfo.moreInfo\n                    );\n                } else {\n                    IDODOAdapter(curPoolInfo.adapter).sellQuote(\n                        assetFrom[i],\n                        curPoolInfo.pool,\n                        curPoolInfo.moreInfo\n                    );\n                }\n            }\n        }\n    }\n\n    /// @notice before the first pool swap, contract call _deposit to get ERC20 token through DODOApprove/transfer ETH to WETH\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount,\n        bool isETH\n    ) internal {\n        if (isETH) {\n            if (amount > 0) {\n                require(msg.value == amount, \"ETH_VALUE_WRONG\");\n                IWETH(_WETH_).deposit{value: amount}();\n                if (to != address(this)) SafeERC20.safeTransfer(IERC20(_WETH_), to, amount);\n            }\n        } else {\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(token, from, to, amount);\n        }\n    }\n\n    /// @notice after all swaps, transfer tokens to original receiver(user) and distribute fees to DODO and broker\n    /// Specially when toToken is ETH, distribute WETH\n    function _routeWithdraw(\n        address toToken,\n        uint256 receiveAmount,\n        bytes memory feeData,\n        uint256 minReturnAmount\n    ) internal {\n        address originToToken = toToken;\n        if(toToken == _ETH_ADDRESS_) {\n            toToken = _WETH_;\n        }\n        (address broker, uint256 brokerFeeRate) = abi.decode(feeData, (address, uint256));\n        require(brokerFeeRate < 10**18, \"DODORouteProxy: brokerFeeRate overflowed\");\n\n        uint256 routeFee = DecimalMath.mulFloor(receiveAmount, routeFeeRate);\n        IERC20(toToken).universalTransfer(payable(routeFeeReceiver), routeFee);\n\n        uint256 brokerFee = DecimalMath.mulFloor(receiveAmount, brokerFeeRate);\n        IERC20(toToken).universalTransfer(payable(broker), brokerFee);\n        \n        receiveAmount = receiveAmount - routeFee - brokerFee;\n        require(receiveAmount >= minReturnAmount, \"DODORouteProxy: Return amount is not enough\");\n        \n        if (originToToken == _ETH_ADDRESS_) {\n            IWETH(_WETH_).withdraw(receiveAmount);\n            payable(msg.sender).transfer(receiveAmount);\n        } else {\n            IERC20(toToken).universalTransfer(payable(msg.sender), receiveAmount);\n        }\n    }\n}"
    }
  ]
}