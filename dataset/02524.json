{
  "Title": "Missing or incomplete docstrings",
  "Content": "Several contracts and functions in the codebase lack complete documentation:\n\n\n* In [BaseEscalationManager.sol](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/escalation-manager/BaseEscalationManager.sol):\n\t+ [`assertionResolvedCallback`](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/escalation-manager/BaseEscalationManager.sol#L70) has undocumented `assertionId` and `assertedTruthfully` parameters.\n\t+ [`assertionDisputedCallback`](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/escalation-manager/BaseEscalationManager.sol#L73) has an undocumented `assertionId` parameter.\n* In [EscalationManagerInterface.sol](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/interfaces/EscalationManagerInterface.sol):\n\t+ The interface is undocumented.\n\t+ All functions and structs are undocumented.\n* In [FullPolicyEscalationManager.sol](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/escalation-manager/FullPolicyEscalationManager.sol):\n\t+ [`setDisputeCallerInWhitelist`](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/escalation-manager/FullPolicyEscalationManager.sol#L165) has an undocumented `value` parameter.\n\t+ [`setWhitelistedAssertingCallers`](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/escalation-manager/FullPolicyEscalationManager.sol#L174) has an undocumented `value` parameter.\n\t+ [`setWhitelistedAsserters`](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/escalation-manager/FullPolicyEscalationManager.sol#L184) has an undocumented `value` parameter.\n* In [OptimisticAsserter.sol](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/OptimisticAsserter.sol):\n\t+ [`assertTruthWithDefaults`](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/OptimisticAsserter.sol#L95) has an undocumented `asserter` parameter.\n\t+ [`assertTruth`](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/OptimisticAsserter.sol#L134) has an undocumented return value.\n\t+ [`getCurrentTimestamp`](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/OptimisticAsserter.sol#L339) has an undocumented return value.\n\t+ Functions marked `internal` are undocumented.\n* In [OptimisticAsserterInterface.sol](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/interfaces/OptimisticAsserterInterface.sol):\n\t+ The interface is undocumented.\n\t+ All functions are undocumented.\n\t+ The structs are only partially documented.\n* In [OptimisticAsserterCallbackRecipientInterface.sol](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/interfaces/OptimisticAsserterCallbackRecipientInterface.sol):\n\t+ The interface is undocumented.\n\t+ All functions are undocumented.\n\n\nIncomplete documentation hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and facilitate maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted.\n\n\nConsider thoroughly documenting all functions and their parameters. When writing docstrings, especially for publicly-exposed functions, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update:** Resolved in [pull request #4342](https://github.com/UMAprotocol/protocol/pull/4342) with commit [c831b8c](https://github.com/UMAprotocol/protocol/commit/c831b8cf2667bc451521d66cf18b97625d9dbe9a).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/optimistic-asserter/implementation/escalation-manager/BaseEscalationManager.sol",
      "content": "pragma solidity 0.8.16;\n\nimport \"../../interfaces/EscalationManagerInterface.sol\";\n\n/**\n * @title BaseEscalationManager\n * @notice Base contract for escalation managers. This contract is responsible for managing the escalation policy for\n * assertions. This base implementation simply exposes the required interface and provides a default implementation\n * (returning default values or doing nothing).\n */\ncontract BaseEscalationManager is EscalationManagerInterface {\n    event PriceRequestAdded(bytes32 indexed identifier, uint256 time, bytes ancillaryData);\n\n    /**\n     * @notice Returns the assertion policy for the given assertionId.\n     * @param assertionId the assertionId to get the assertion policy for.\n     * @return the assertion policy for the given assertionId.\n     */\n    function getAssertionPolicy(bytes32 assertionId) public view virtual override returns (AssertionPolicy memory) {\n        return\n            AssertionPolicy({\n                blockAssertion: false,\n                arbitrateViaEscalationManager: false,\n                discardOracle: false,\n                validateDisputers: false\n            });\n    }\n\n    /**\n     * @notice Callback function that is called by Optimistic Asserter when an assertion is disputed. Used to validate\n     * if the dispute should be allowed based on the escalation policy.\n     * @param assertionId the assertionId to validate the dispute for.\n     * @param disputeCaller the caller of the dispute function.\n     * @return bool if the dispute is allowed, false otherwise.\n     */\n    function isDisputeAllowed(bytes32 assertionId, address disputeCaller) public view virtual override returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Implements price getting logic. This method is called by Optimistic Asserter settling an assertion that\n     * is configured to use the escalation manager as the oracle. The interface is constructed to mimic the UMA DVM.\n     * @param identifier price identifier being requested.\n     * @param time timestamp of the price being requested.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return price from the escalation manager to inform the resolution of the dispute.\n     */\n    function getPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view virtual override returns (int256) {}\n\n    /**\n     * @notice Implements price requesting logic for the escalation manager. This function is called by the Optimistic\n     * on dispute and is constructed to mimic that of the UMA DVM interface.\n     * @param identifier the identifier to fetch the price for.\n     * @param time the time to fetch the price for.\n     * @param ancillaryData ancillary data of the price being requested.\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public virtual override {\n        emit PriceRequestAdded(identifier, time, ancillaryData);\n    }\n\n    // Callback function that is called by Optimistic Asserter when an assertion is resolved.\n    function assertionResolvedCallback(bytes32 assertionId, bool assertedTruthfully) public virtual override {}\n\n    // Callback function that is called by Optimistic Asserter when an assertion is disputed.\n    function assertionDisputedCallback(bytes32 assertionId) public virtual override {}\n}"
    },
    {
      "filename": "packages/core/contracts/optimistic-asserter/implementation/escalation-manager/BaseEscalationManager.sol",
      "content": "pragma solidity 0.8.16;\n\nimport \"../../interfaces/EscalationManagerInterface.sol\";\n\n/**\n * @title BaseEscalationManager\n * @notice Base contract for escalation managers. This contract is responsible for managing the escalation policy for\n * assertions. This base implementation simply exposes the required interface and provides a default implementation\n * (returning default values or doing nothing).\n */\ncontract BaseEscalationManager is EscalationManagerInterface {\n    event PriceRequestAdded(bytes32 indexed identifier, uint256 time, bytes ancillaryData);\n\n    /**\n     * @notice Returns the assertion policy for the given assertionId.\n     * @param assertionId the assertionId to get the assertion policy for.\n     * @return the assertion policy for the given assertionId.\n     */\n    function getAssertionPolicy(bytes32 assertionId) public view virtual override returns (AssertionPolicy memory) {\n        return\n            AssertionPolicy({\n                blockAssertion: false,\n                arbitrateViaEscalationManager: false,\n                discardOracle: false,\n                validateDisputers: false\n            });\n    }\n\n    /**\n     * @notice Callback function that is called by Optimistic Asserter when an assertion is disputed. Used to validate\n     * if the dispute should be allowed based on the escalation policy.\n     * @param assertionId the assertionId to validate the dispute for.\n     * @param disputeCaller the caller of the dispute function.\n     * @return bool if the dispute is allowed, false otherwise.\n     */\n    function isDisputeAllowed(bytes32 assertionId, address disputeCaller) public view virtual override returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Implements price getting logic. This method is called by Optimistic Asserter settling an assertion that\n     * is configured to use the escalation manager as the oracle. The interface is constructed to mimic the UMA DVM.\n     * @param identifier price identifier being requested.\n     * @param time timestamp of the price being requested.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return price from the escalation manager to inform the resolution of the dispute.\n     */\n    function getPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view virtual override returns (int256) {}\n\n    /**\n     * @notice Implements price requesting logic for the escalation manager. This function is called by the Optimistic\n     * on dispute and is constructed to mimic that of the UMA DVM interface.\n     * @param identifier the identifier to fetch the price for.\n     * @param time the time to fetch the price for.\n     * @param ancillaryData ancillary data of the price being requested.\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public virtual override {\n        emit PriceRequestAdded(identifier, time, ancillaryData);\n    }\n\n    // Callback function that is called by Optimistic Asserter when an assertion is resolved.\n    function assertionResolvedCallback(bytes32 assertionId, bool assertedTruthfully) public virtual override {}\n\n    // Callback function that is called by Optimistic Asserter when an assertion is disputed.\n    function assertionDisputedCallback(bytes32 assertionId) public virtual override {}\n}"
    },
    {
      "filename": "packages/core/contracts/optimistic-asserter/implementation/escalation-manager/FullPolicyEscalationManager.sol",
      "content": "pragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BaseEscalationManager.sol\";\nimport \"../../interfaces/OptimisticAsserterInterface.sol\";\n\n/**\n * @title The FullPolicyEscalationManager enables the owner to configure all policy parameters and store the arbitration\n * resolutions for the Escalation Manager. Optionally, assertion blocking can be enabled using a whitelist of\n * assertingCallers or assertingCallers and asserters. On the other hand, it enables the determination of whether to\n * arbitrate via the escalation manager as opposed to the DVM, whether to disregard the resolution of a potential\n * dispute arbitrated by the Oracle, and whether to restrict who can register disputes via a whitelistedDisputeCallers.\n * @dev If nothing is configured using the setters and configureEscalationManager method upon deployment, the\n * FullPolicyEscalationManager will return a default policy with all values set to false.\n */\ncontract FullPolicyEscalationManager is BaseEscalationManager, Ownable {\n    struct ArbitrationResolution {\n        bool valueSet; // True if the resolution has been set.\n        bool resolution; // True or false depending on the resolution.\n    }\n\n    event EscalationManagerConfigured(\n        bool blockByAssertingCaller,\n        bool blockByAsserter,\n        bool validateDisputers,\n        bool arbitrateViaEscalationManager,\n        bool discardOracle\n    );\n\n    event ArbitrationResolutionSet(bytes32 indexed identifier, uint256 time, bytes ancillaryData, bool resolution);\n\n    event DisputeCallerWhitelistSet(address disputeCaller, bool whitelisted);\n\n    event AssertingCallerWhitelistSet(address assertingCaller, bool whitelisted);\n\n    event AsserterWhitelistSet(address asserter, bool whitelisted);\n\n    bool public blockByAssertingCaller; // True if assertions are allowed only by whitelisted asserting callers.\n\n    bool public blockByAsserter; // True if assertions are allowed only by whitelisted asserters.\n\n    bool public arbitrateViaEscalationManager; // True if it is determined that the escalation manager should arbitrate.\n\n    bool public discardOracle; // True if escalation manager should disregard the Oracle's resolution.\n\n    bool public validateDisputers; // True if escalation manager should validate disputers via whitelistedDisputeCallers.\n\n    mapping(bytes32 => ArbitrationResolution) public arbitrationResolutions; // Arbitration resolutions for a given identifier, time, and ancillary data.\n\n    mapping(address => bool) public whitelistedDisputeCallers; // Whitelisted disputer that can file disputes.\n\n    mapping(address => bool) public whitelistedAssertingCallers; // Whitelisted assertingCallers that can assert prices.\n\n    mapping(address => bool) public whitelistedAsserters; // Whitelisted asserters that can assert prices.\n\n    /**\n     * @notice Returns the Assertion Policy defined by this contract's parameters and functions.\n     * @param assertionId the ID of the assertion to get the policy for.\n     * @return the Assertion Policy defined by this contract's parameters and functions.\n     * @dev If no configuration is done after deployment, this function returns an all false default policy.\n     */\n    function getAssertionPolicy(bytes32 assertionId) public view override returns (AssertionPolicy memory) {\n        bool blocked = _checkIfAssertionBlocked(assertionId);\n        return\n            AssertionPolicy({\n                blockAssertion: blocked, // Block assertion if it is blocked.\n                arbitrateViaEscalationManager: arbitrateViaEscalationManager, // Arbitrate via escalation manager if configured.\n                discardOracle: discardOracle, // Ignore Oracle (DVM or EM) resolution if configured.\n                validateDisputers: validateDisputers // Validate disputers if configured.\n            });\n    }\n\n    /**\n     * @notice Gets the price for identifier and time if it has already been requested and resolved.\n     * @dev If the price is not available, the method reverts.\n     * @param identifier uniquely identifies the price requested.\n     * @param time unix timestamp of the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @return int256 representing the resolved price for the given identifier and timestamp.\n     * @dev This function replicates the interface of the corresponding DVM function to allow the user to use his own\n     * dispute arbitration system when arbitrating via the escalation manager in a DVM-compatible manner. Refer to the\n     * UMA Voting and VotingV2 contracts for further details.\n     */\n    function getPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override returns (int256) {\n        bytes32 requestId = keccak256(abi.encode(identifier, time, ancillaryData));\n        require(arbitrationResolutions[requestId].valueSet, \"Arbitration resolution not set\");\n        if (arbitrationResolutions[requestId].resolution) return 1e18;\n        return 0;\n    }\n\n    /**\n     * @notice Returns, given an assertionId and a disputerCaller address, if the disputerCaller is authorised to\n     * dispute the assertion.\n     * @param assertionId the ID of the assertion to check the disputerCaller for.\n     * @param disputeCaller the address of the disputeCaller to check.\n     * @return true if the disputerCaller is authorised to dispute the assertion.\n     * @dev In order for this function to be used by the Optimistic Assertor, validateDisputers must be set to true.\n     */\n    function isDisputeAllowed(bytes32 assertionId, address disputeCaller) public view override returns (bool) {\n        return whitelistedDisputeCallers[disputeCaller];\n    }\n\n    /**\n     * @notice Defines how the assertion policy for each configuration's rules is to be defined.\n     * @param _blockByAssertingCaller true if assertions are allowed only by whitelisted asserting callers.\n     * @param _blockByAsserter true if assertions are allowed only by whitelisted asserters.\n     * @param _validateDisputers true if the escalation manager should validate disputers via whitelistedDisputeCallers.\n     * @param _arbitrateViaEscalationManager true if the escalation manager should arbitrate instead of the DVM.\n     * @param _discardOracle true if the escalation manager should disregard the Oracle's (DVM or EM) resolution.\n     * @dev This setting just activates the rules that will be executed; each rule must additionally be defined using\n     * the other functions.\n     */\n    function configureEscalationManager(\n        bool _blockByAssertingCaller,\n        bool _blockByAsserter,\n        bool _validateDisputers,\n        bool _arbitrateViaEscalationManager,\n        bool _discardOracle\n    ) public onlyOwner {\n        require(!_blockByAsserter || (_blockByAsserter && _blockByAssertingCaller), \"Cannot block only by asserter\");\n        blockByAssertingCaller = _blockByAssertingCaller;\n        blockByAsserter = _blockByAsserter;\n        validateDisputers = _validateDisputers;\n        arbitrateViaEscalationManager = _arbitrateViaEscalationManager;\n        discardOracle = _discardOracle;\n        emit EscalationManagerConfigured(\n            _blockByAssertingCaller,\n            _blockByAsserter,\n            _validateDisputers,\n            _arbitrateViaEscalationManager,\n            _discardOracle\n        );\n    }\n\n    /**\n     * @notice Set the arbitration resolution for a given identifier, time, and ancillary data.\n     * @param identifier uniquely identifies the price requested.\n     * @param time unix timestamp of the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param arbitrationResolution true if the assertion should be resolved as true, false otherwise.\n     * @dev The owner should use this function whenever a dispute arises and it should be arbitrated by the Escalation\n     * Manager; it is up to the owner to determine how to resolve the dispute. See the requestPrice implementation in\n     * BaseEscalationManager, which escalates a dispute to the Escalation Manager for resolution.\n     */\n    function setArbitrationResolution(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bool arbitrationResolution\n    ) public onlyOwner {\n        bytes32 requestId = keccak256(abi.encode(identifier, time, ancillaryData));\n        arbitrationResolutions[requestId] = ArbitrationResolution(true, arbitrationResolution);\n        emit ArbitrationResolutionSet(identifier, time, ancillaryData, arbitrationResolution);\n    }\n\n    /**\n     * @notice Adds a disputerCaller to the whitelist of disputers that can file disputes.\n     * @param disputeCaller the address of the disputeCaller to add.\n     * @dev This function is only used if validateDisputers is set to true.\n     */\n    function setDisputeCallerInWhitelist(address disputeCaller, bool value) public onlyOwner {\n        whitelistedDisputeCallers[disputeCaller] = value;\n        emit DisputeCallerWhitelistSet(disputeCaller, value);\n    }\n\n    /**\n     * @notice Adds an asserter to the whitelist of assertingCallers that can make assertions.\n     * @param assertingCaller the address of the assertingCaller to add.\n     */\n    function setWhitelistedAssertingCallers(address assertingCaller, bool value) public onlyOwner {\n        whitelistedAssertingCallers[assertingCaller] = value;\n        emit AssertingCallerWhitelistSet(assertingCaller, value);\n    }\n\n    /**\n     * @notice Adds an asserter to the whitelist of asserters that can make assertions.\n     * @param asserter the address of the asserter to add.\n     * @dev This function must be used in conjunction with setWhitelistedAssertingCallers in order to have an effect.\n     */\n    function setWhitelistedAsserters(address asserter, bool value) public onlyOwner {\n        whitelistedAsserters[asserter] = value;\n        emit AsserterWhitelistSet(asserter, value);\n    }\n\n    // Checks if an assertion is blocked depending on the blockByAssertingCaller / blockByAsserter settings and the\n    // assertion's properties.\n    function _checkIfAssertionBlocked(bytes32 assertionId) internal view returns (bool) {\n        OptimisticAsserterInterface optimisticAsserter = OptimisticAsserterInterface(msg.sender);\n        OptimisticAsserterInterface.Assertion memory assertion = optimisticAsserter.getAssertion(assertionId);\n        return\n            (blockByAssertingCaller &&\n                !whitelistedAssertingCallers[assertion.escalationManagerSettings.assertingCaller]) ||\n            (blockByAsserter && !whitelistedAsserters[assertion.asserter]);\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/optimistic-asserter/implementation/escalation-manager/FullPolicyEscalationManager.sol",
      "content": "pragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BaseEscalationManager.sol\";\nimport \"../../interfaces/OptimisticAsserterInterface.sol\";\n\n/**\n * @title The FullPolicyEscalationManager enables the owner to configure all policy parameters and store the arbitration\n * resolutions for the Escalation Manager. Optionally, assertion blocking can be enabled using a whitelist of\n * assertingCallers or assertingCallers and asserters. On the other hand, it enables the determination of whether to\n * arbitrate via the escalation manager as opposed to the DVM, whether to disregard the resolution of a potential\n * dispute arbitrated by the Oracle, and whether to restrict who can register disputes via a whitelistedDisputeCallers.\n * @dev If nothing is configured using the setters and configureEscalationManager method upon deployment, the\n * FullPolicyEscalationManager will return a default policy with all values set to false.\n */\ncontract FullPolicyEscalationManager is BaseEscalationManager, Ownable {\n    struct ArbitrationResolution {\n        bool valueSet; // True if the resolution has been set.\n        bool resolution; // True or false depending on the resolution.\n    }\n\n    event EscalationManagerConfigured(\n        bool blockByAssertingCaller,\n        bool blockByAsserter,\n        bool validateDisputers,\n        bool arbitrateViaEscalationManager,\n        bool discardOracle\n    );\n\n    event ArbitrationResolutionSet(bytes32 indexed identifier, uint256 time, bytes ancillaryData, bool resolution);\n\n    event DisputeCallerWhitelistSet(address disputeCaller, bool whitelisted);\n\n    event AssertingCallerWhitelistSet(address assertingCaller, bool whitelisted);\n\n    event AsserterWhitelistSet(address asserter, bool whitelisted);\n\n    bool public blockByAssertingCaller; // True if assertions are allowed only by whitelisted asserting callers.\n\n    bool public blockByAsserter; // True if assertions are allowed only by whitelisted asserters.\n\n    bool public arbitrateViaEscalationManager; // True if it is determined that the escalation manager should arbitrate.\n\n    bool public discardOracle; // True if escalation manager should disregard the Oracle's resolution.\n\n    bool public validateDisputers; // True if escalation manager should validate disputers via whitelistedDisputeCallers.\n\n    mapping(bytes32 => ArbitrationResolution) public arbitrationResolutions; // Arbitration resolutions for a given identifier, time, and ancillary data.\n\n    mapping(address => bool) public whitelistedDisputeCallers; // Whitelisted disputer that can file disputes.\n\n    mapping(address => bool) public whitelistedAssertingCallers; // Whitelisted assertingCallers that can assert prices.\n\n    mapping(address => bool) public whitelistedAsserters; // Whitelisted asserters that can assert prices.\n\n    /**\n     * @notice Returns the Assertion Policy defined by this contract's parameters and functions.\n     * @param assertionId the ID of the assertion to get the policy for.\n     * @return the Assertion Policy defined by this contract's parameters and functions.\n     * @dev If no configuration is done after deployment, this function returns an all false default policy.\n     */\n    function getAssertionPolicy(bytes32 assertionId) public view override returns (AssertionPolicy memory) {\n        bool blocked = _checkIfAssertionBlocked(assertionId);\n        return\n            AssertionPolicy({\n                blockAssertion: blocked, // Block assertion if it is blocked.\n                arbitrateViaEscalationManager: arbitrateViaEscalationManager, // Arbitrate via escalation manager if configured.\n                discardOracle: discardOracle, // Ignore Oracle (DVM or EM) resolution if configured.\n                validateDisputers: validateDisputers // Validate disputers if configured.\n            });\n    }\n\n    /**\n     * @notice Gets the price for identifier and time if it has already been requested and resolved.\n     * @dev If the price is not available, the method reverts.\n     * @param identifier uniquely identifies the price requested.\n     * @param time unix timestamp of the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @return int256 representing the resolved price for the given identifier and timestamp.\n     * @dev This function replicates the interface of the corresponding DVM function to allow the user to use his own\n     * dispute arbitration system when arbitrating via the escalation manager in a DVM-compatible manner. Refer to the\n     * UMA Voting and VotingV2 contracts for further details.\n     */\n    function getPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override returns (int256) {\n        bytes32 requestId = keccak256(abi.encode(identifier, time, ancillaryData));\n        require(arbitrationResolutions[requestId].valueSet, \"Arbitration resolution not set\");\n        if (arbitrationResolutions[requestId].resolution) return 1e18;\n        return 0;\n    }\n\n    /**\n     * @notice Returns, given an assertionId and a disputerCaller address, if the disputerCaller is authorised to\n     * dispute the assertion.\n     * @param assertionId the ID of the assertion to check the disputerCaller for.\n     * @param disputeCaller the address of the disputeCaller to check.\n     * @return true if the disputerCaller is authorised to dispute the assertion.\n     * @dev In order for this function to be used by the Optimistic Assertor, validateDisputers must be set to true.\n     */\n    function isDisputeAllowed(bytes32 assertionId, address disputeCaller) public view override returns (bool) {\n        return whitelistedDisputeCallers[disputeCaller];\n    }\n\n    /**\n     * @notice Defines how the assertion policy for each configuration's rules is to be defined.\n     * @param _blockByAssertingCaller true if assertions are allowed only by whitelisted asserting callers.\n     * @param _blockByAsserter true if assertions are allowed only by whitelisted asserters.\n     * @param _validateDisputers true if the escalation manager should validate disputers via whitelistedDisputeCallers.\n     * @param _arbitrateViaEscalationManager true if the escalation manager should arbitrate instead of the DVM.\n     * @param _discardOracle true if the escalation manager should disregard the Oracle's (DVM or EM) resolution.\n     * @dev This setting just activates the rules that will be executed; each rule must additionally be defined using\n     * the other functions.\n     */\n    function configureEscalationManager(\n        bool _blockByAssertingCaller,\n        bool _blockByAsserter,\n        bool _validateDisputers,\n        bool _arbitrateViaEscalationManager,\n        bool _discardOracle\n    ) public onlyOwner {\n        require(!_blockByAsserter || (_blockByAsserter && _blockByAssertingCaller), \"Cannot block only by asserter\");\n        blockByAssertingCaller = _blockByAssertingCaller;\n        blockByAsserter = _blockByAsserter;\n        validateDisputers = _validateDisputers;\n        arbitrateViaEscalationManager = _arbitrateViaEscalationManager;\n        discardOracle = _discardOracle;\n        emit EscalationManagerConfigured(\n            _blockByAssertingCaller,\n            _blockByAsserter,\n            _validateDisputers,\n            _arbitrateViaEscalationManager,\n            _discardOracle\n        );\n    }\n\n    /**\n     * @notice Set the arbitration resolution for a given identifier, time, and ancillary data.\n     * @param identifier uniquely identifies the price requested.\n     * @param time unix timestamp of the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param arbitrationResolution true if the assertion should be resolved as true, false otherwise.\n     * @dev The owner should use this function whenever a dispute arises and it should be arbitrated by the Escalation\n     * Manager; it is up to the owner to determine how to resolve the dispute. See the requestPrice implementation in\n     * BaseEscalationManager, which escalates a dispute to the Escalation Manager for resolution.\n     */\n    function setArbitrationResolution(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bool arbitrationResolution\n    ) public onlyOwner {\n        bytes32 requestId = keccak256(abi.encode(identifier, time, ancillaryData));\n        arbitrationResolutions[requestId] = ArbitrationResolution(true, arbitrationResolution);\n        emit ArbitrationResolutionSet(identifier, time, ancillaryData, arbitrationResolution);\n    }\n\n    /**\n     * @notice Adds a disputerCaller to the whitelist of disputers that can file disputes.\n     * @param disputeCaller the address of the disputeCaller to add.\n     * @dev This function is only used if validateDisputers is set to true.\n     */\n    function setDisputeCallerInWhitelist(address disputeCaller, bool value) public onlyOwner {\n        whitelistedDisputeCallers[disputeCaller] = value;\n        emit DisputeCallerWhitelistSet(disputeCaller, value);\n    }\n\n    /**\n     * @notice Adds an asserter to the whitelist of assertingCallers that can make assertions.\n     * @param assertingCaller the address of the assertingCaller to add.\n     */\n    function setWhitelistedAssertingCallers(address assertingCaller, bool value) public onlyOwner {\n        whitelistedAssertingCallers[assertingCaller] = value;\n        emit AssertingCallerWhitelistSet(assertingCaller, value);\n    }\n\n    /**\n     * @notice Adds an asserter to the whitelist of asserters that can make assertions.\n     * @param asserter the address of the asserter to add.\n     * @dev This function must be used in conjunction with setWhitelistedAssertingCallers in order to have an effect.\n     */\n    function setWhitelistedAsserters(address asserter, bool value) public onlyOwner {\n        whitelistedAsserters[asserter] = value;\n        emit AsserterWhitelistSet(asserter, value);\n    }\n\n    // Checks if an assertion is blocked depending on the blockByAssertingCaller / blockByAsserter settings and the\n    // assertion's properties.\n    function _checkIfAssertionBlocked(bytes32 assertionId) internal view returns (bool) {\n        OptimisticAsserterInterface optimisticAsserter = OptimisticAsserterInterface(msg.sender);\n        OptimisticAsserterInterface.Assertion memory assertion = optimisticAsserter.getAssertion(assertionId);\n        return\n            (blockByAssertingCaller &&\n                !whitelistedAssertingCallers[assertion.escalationManagerSettings.assertingCaller]) ||\n            (blockByAsserter && !whitelistedAsserters[assertion.asserter]);\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/optimistic-asserter/implementation/escalation-manager/FullPolicyEscalationManager.sol",
      "content": "pragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BaseEscalationManager.sol\";\nimport \"../../interfaces/OptimisticAsserterInterface.sol\";\n\n/**\n * @title The FullPolicyEscalationManager enables the owner to configure all policy parameters and store the arbitration\n * resolutions for the Escalation Manager. Optionally, assertion blocking can be enabled using a whitelist of\n * assertingCallers or assertingCallers and asserters. On the other hand, it enables the determination of whether to\n * arbitrate via the escalation manager as opposed to the DVM, whether to disregard the resolution of a potential\n * dispute arbitrated by the Oracle, and whether to restrict who can register disputes via a whitelistedDisputeCallers.\n * @dev If nothing is configured using the setters and configureEscalationManager method upon deployment, the\n * FullPolicyEscalationManager will return a default policy with all values set to false.\n */\ncontract FullPolicyEscalationManager is BaseEscalationManager, Ownable {\n    struct ArbitrationResolution {\n        bool valueSet; // True if the resolution has been set.\n        bool resolution; // True or false depending on the resolution.\n    }\n\n    event EscalationManagerConfigured(\n        bool blockByAssertingCaller,\n        bool blockByAsserter,\n        bool validateDisputers,\n        bool arbitrateViaEscalationManager,\n        bool discardOracle\n    );\n\n    event ArbitrationResolutionSet(bytes32 indexed identifier, uint256 time, bytes ancillaryData, bool resolution);\n\n    event DisputeCallerWhitelistSet(address disputeCaller, bool whitelisted);\n\n    event AssertingCallerWhitelistSet(address assertingCaller, bool whitelisted);\n\n    event AsserterWhitelistSet(address asserter, bool whitelisted);\n\n    bool public blockByAssertingCaller; // True if assertions are allowed only by whitelisted asserting callers.\n\n    bool public blockByAsserter; // True if assertions are allowed only by whitelisted asserters.\n\n    bool public arbitrateViaEscalationManager; // True if it is determined that the escalation manager should arbitrate.\n\n    bool public discardOracle; // True if escalation manager should disregard the Oracle's resolution.\n\n    bool public validateDisputers; // True if escalation manager should validate disputers via whitelistedDisputeCallers.\n\n    mapping(bytes32 => ArbitrationResolution) public arbitrationResolutions; // Arbitration resolutions for a given identifier, time, and ancillary data.\n\n    mapping(address => bool) public whitelistedDisputeCallers; // Whitelisted disputer that can file disputes.\n\n    mapping(address => bool) public whitelistedAssertingCallers; // Whitelisted assertingCallers that can assert prices.\n\n    mapping(address => bool) public whitelistedAsserters; // Whitelisted asserters that can assert prices.\n\n    /**\n     * @notice Returns the Assertion Policy defined by this contract's parameters and functions.\n     * @param assertionId the ID of the assertion to get the policy for.\n     * @return the Assertion Policy defined by this contract's parameters and functions.\n     * @dev If no configuration is done after deployment, this function returns an all false default policy.\n     */\n    function getAssertionPolicy(bytes32 assertionId) public view override returns (AssertionPolicy memory) {\n        bool blocked = _checkIfAssertionBlocked(assertionId);\n        return\n            AssertionPolicy({\n                blockAssertion: blocked, // Block assertion if it is blocked.\n                arbitrateViaEscalationManager: arbitrateViaEscalationManager, // Arbitrate via escalation manager if configured.\n                discardOracle: discardOracle, // Ignore Oracle (DVM or EM) resolution if configured.\n                validateDisputers: validateDisputers // Validate disputers if configured.\n            });\n    }\n\n    /*"
    }
  ]
}