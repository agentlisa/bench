{
  "Title": "Unhealthy Position Locks Collateral That Is Not Recognizable by the Controller",
  "Content": "The protocol connects compatible vaults through the Ethereum Vault Connector (EVC) and ensures that sensitive actions triggered by the user on any of the vaults are validated through both account and vault status checks. If the user [has a controller enabled](https://github.com/euler-xyz/ethereum-vault-connector/blob/52d368971964839c1890a683870f1729f4e32396/src/EthereumVaultConnector.sol#L928-L929), a [call is made](https://github.com/euler-xyz/ethereum-vault-connector/blob/52d368971964839c1890a683870f1729f4e32396/src/EthereumVaultConnector.sol#L932-L936) to ensure that the action does not [jeopardize the user's position's health](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/RiskManager.sol#L72-L82).\n\n\nHowever, the issue arises when this check is also conducted in cases where the vault the user interacts with is not recognized as valid collateral for the user's position and has no impact on the user's position. Consequently, this prevents users with unhealthy positions from withdrawing assets or transferring shares of vaults not associated with their positions as the account status check is executed for these operations.\n\n\nConsider redesigning the logic of managing vaults in a way that allows for the execution of actions on vaults not associated with the user's position. Alternatively, consider thoroughly documenting this behavior.\n\n\n***Update:** Resolved. The Euler team stated:*\n\n\n\n> *We acknowledge the issue. When a user enables a vault as a controller for their account, presumably in order to take out a loan, they accept that their access to the account will be limited by the arbitrary rules encoded in the controller.*\n> \n> \n> *EVaults are implemented to primarily monitor collaterals they are explicitly configured to support, but if the account is unhealthy, a user should accept, as part of the contract with the controller, that any deposit they have in their account may be withheld.*\n> \n> \n> *Although such deposits do not influence the health score of the position, they may nonetheless be withdrawn by the user in a batch and sold for a recognized collateral, or the liability asset, to bring the account back to health. We have improved the documentation to emphasize this behavior to the users: https://docs.euler.finance/euler-vault-kit-white-paper/#non-collateral-deposits*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/EthereumVaultConnector.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.19;\n\nimport {Set, SetStorage} from \"./Set.sol\";\nimport {Events} from \"./Events.sol\";\nimport {Errors} from \"./Errors.sol\";\nimport {ExecutionContext, EC} from \"./ExecutionContext.sol\";\nimport {TransientStorage} from \"./TransientStorage.sol\";\nimport {IEVC} from \"./interfaces/IEthereumVaultConnector.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IERC1271} from \"./interfaces/IERC1271.sol\";\n\n/// @title EthereumVaultConnector\n/// @custom:security-contact security@euler.xyz\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice This contract implements the Ethereum Vault Connector.\ncontract EthereumVaultConnector is Events, Errors, TransientStorage, IEVC {\n    using ExecutionContext for EC;\n    using Set for SetStorage;\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                       CONSTANTS                                           //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Name of the Ethereum Vault Connector.\n    string public constant name = \"Ethereum Vault Connector\";\n\n    /// @notice Version of the Ethereum Vault Connector.\n    string public constant version = \"1\";\n\n    uint160 internal constant ACCOUNT_ID_OFFSET = 8;\n    bytes32 internal constant HASHED_NAME = keccak256(bytes(name));\n    bytes32 internal constant HASHED_VERSION = keccak256(bytes(version));\n\n    bytes32 internal constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    bytes32 internal constant PERMIT_TYPEHASH = keccak256(\n        \"Permit(address signer,address sender,uint256 nonceNamespace,uint256 nonce,uint256 deadline,uint256 value,bytes data)\"\n    );\n\n    uint256 internal immutable CACHED_CHAIN_ID;\n    bytes32 internal immutable CACHED_DOMAIN_SEPARATOR;\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                        STORAGE                                            //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    // EVC implements controller isolation, meaning that unless in transient state, only one controller per account can\n    // be enabled. However, this can lead to a suboptimal user experience. In the event a user wants to have multiple\n    // controllers enabled, a separate wallet must be created and funded. Although there is nothing wrong with having\n    // many accounts within the same wallet, this can be a bad experience. In order to improve on this, EVC supports\n    // the concept of an owner that owns 256 accounts within EVC.\n\n    // Every Ethereum address has 256 accounts in the EVC (including the primary account - called the owner).\n    // Each account has an account ID from 0-255, where 0 is the owner account's ID. In order to compute the account\n    // addresses, the account ID is treated as a uint256 and XORed (exclusive ORed) with the Ethereum address.\n    // In order to record the owner of a group of 256 accounts, the EVC uses a definition of an address prefix.\n    // An address prefix is a part of an address having the first 19 bytes common with any of the 256 account\n    // addresses belonging to the same group.\n    // account/152 -> prefix/152\n    // To get an address prefix for the account, it's enough to take the account address and right shift it by 8 bits.\n\n    // Yes, this reduces the security of addresses by 8 bits, but creating multiple addresses in the wallet also reduces\n    // security: if somebody is trying to brute-force one of user's N>1 private keys, they have N times as many chances\n    // of succeeding per guess. It has to be admitted that the EVC model is weaker because finding a private key for\n    // an owner gives access to all accounts, but there is still a very comfortable security margin.\n\n    // Internal data structure that stores the addressPrefix owner and mode flags\n    struct OwnerStorage {\n        // The addressPrefix owner\n        address owner;\n        // Flag indicating if the addressPrefix is in lockdown mode\n        bool isLockdownMode;\n        // Flag indicating if the permit function is disabled for the addressPrefix\n        bool isPermitDisabledMode;\n    }\n\n    mapping(bytes19 addressPrefix => OwnerStorage) internal ownerLookup;\n\n    mapping(bytes19 addressPrefix => mapping(address operator => uint256 operatorBitField)) internal operatorLookup;\n\n    mapping(bytes19 addressPrefix => mapping(uint256 nonceNamespace => uint256 nonce)) internal nonceLookup;\n\n    mapping(address account => SetStorage) internal accountCollaterals;\n\n    mapping(address account => SetStorage) internal accountControllers;\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                CONSTRUCTOR, FALLBACKS                                     //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    constructor() {\n        CACHED_CHAIN_ID = block.chainid;\n        CACHED_DOMAIN_SEPARATOR = calculateDomainSeparator();\n    }\n\n    /// @notice Fallback function to receive Ether.\n    receive() external payable {\n        // only allows to receive value when checks are deferred\n        if (!executionContext.areChecksDeferred()) {\n            revert EVC_NotAuthorized();\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                       MODIFIERS                                           //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice A modifier that allows only the address recorded as an owner of the address prefix to call the function.\n    /// @dev The owner of an address prefix is an address that matches the address that has previously been recorded (or\n    /// will be) as an owner in the ownerLookup.\n    /// @param addressPrefix The address prefix for which it is checked whether the caller is the owner.\n    modifier onlyOwner(bytes19 addressPrefix) {\n        authenticateCaller({addressPrefix: addressPrefix, allowOperator: false, checkLockdownMode: false});\n\n        _;\n    }\n\n    /// @notice A modifier that allows only the owner or an operator of the account to call the function.\n    /// @dev The owner of an address prefix is an address that matches the address that has previously been recorded (or\n    /// will be) as an owner in the ownerLookup. An operator of an account is an address that has been authorized by the\n    /// owner of an account to perform operations on behalf of the owner.\n    /// @param account The address of the account for which it is checked whether the caller is the owner or an\n    /// operator.\n    modifier onlyOwnerOrOperator(address account) {\n        authenticateCaller({account: account, allowOperator: true, checkLockdownMode: true});\n\n        _;\n    }\n\n    /// @notice A modifier checks whether msg.sender is the only controller for the account.\n    /// @dev The controller cannot use permit function in conjunction with this modifier.\n    modifier onlyController(address account) {\n        {\n            uint256 numOfControllers = accountControllers[account].numElements;\n            address controller = accountControllers[account].firstElement;\n\n            if (numOfControllers != 1) {\n                revert EVC_ControllerViolation();\n            }\n\n            if (controller != msg.sender) {\n                revert EVC_NotAuthorized();\n            }\n        }\n\n        _;\n    }\n\n    /// @notice A modifier that verifies whether account or vault status checks are re-entered as well as checks for\n    /// controlCollateral re-entrancy.\n    modifier nonReentrantChecksAndControlCollateral() {\n        {\n            EC context = executionContext;\n\n            if (context.areChecksInProgress()) {\n                revert EVC_ChecksReentrancy();\n            }\n\n            if (context.isControlCollateralInProgress()) {\n                revert EVC_ControlCollateralReentrancy();\n            }\n        }\n\n        _;\n    }\n\n    /// @notice A modifier that verifies whether account or vault status checks are re-entered and sets the lock.\n    /// @dev This modifier also clears the current account on behalf of which the operation is performed as it shouldn't\n    /// be relied upon when the checks are in progress.\n    modifier nonReentrantChecks() {\n        EC contextCache = executionContext;\n\n        if (contextCache.areChecksInProgress()) {\n            revert EVC_ChecksReentrancy();\n        }\n\n        executionContext = contextCache.setChecksInProgress().setOnBehalfOfAccount(address(0));\n\n        _;\n\n        executionContext = contextCache;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                   PUBLIC FUNCTIONS                                        //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    // Execution internals\n\n    /// @inheritdoc IEVC\n    function getRawExecutionContext() external view returns (uint256 context) {\n        context = EC.unwrap(executionContext);\n    }\n\n    /// @inheritdoc IEVC\n    function getCurrentOnBehalfOfAccount(address controllerToCheck)\n        external\n        view\n        returns (address onBehalfOfAccount, bool controllerEnabled)\n    {\n        onBehalfOfAccount = executionContext.getOnBehalfOfAccount();\n\n        // for safety, revert if no account has been authenticated\n        if (onBehalfOfAccount == address(0)) {\n            revert EVC_OnBehalfOfAccountNotAuthenticated();\n        }\n\n        controllerEnabled =\n            controllerToCheck == address(0) ? false : accountControllers[onBehalfOfAccount].contains(controllerToCheck);\n    }\n\n    /// @inheritdoc IEVC\n    function areChecksDeferred() external view returns (bool) {\n        return executionContext.areChecksDeferred();\n    }\n\n    /// @inheritdoc IEVC\n    function areChecksInProgress() external view returns (bool) {\n        return executionContext.areChecksInProgress();\n    }\n\n    /// @inheritdoc IEVC\n    function isControlCollateralInProgress() external view returns (bool) {\n        return executionContext.isControlCollateralInProgress();\n    }\n\n    /// @inheritdoc IEVC\n    function isOperatorAuthenticated() external view returns (bool) {\n        return executionContext.isOperatorAuthenticated();\n    }\n\n    /// @inheritdoc IEVC\n    function isSimulationInProgress() external view returns (bool) {\n        return executionContext.isSimulationInProgress();\n    }\n\n    // Owners and operators\n\n    /// @inheritdoc IEVC\n    function haveCommonOwner(address account, address otherAccount) external pure returns (bool) {\n        return haveCommonOwnerInternal(account, otherAccount);\n    }\n\n    /// @inheritdoc IEVC\n    function getAddressPrefix(address account) external pure returns (bytes19) {\n        return getAddressPrefixInternal(account);\n    }\n\n    /// @inheritdoc IEVC\n    function getAccountOwner(address account) external view returns (address) {\n        return getAccountOwnerInternal(account);\n    }\n\n    /// @inheritdoc IEVC\n    function isLockdownMode(bytes19 addressPrefix) external view returns (bool) {\n        return ownerLookup[addressPrefix].isLockdownMode;\n    }\n\n    /// @inheritdoc IEVC\n    function isPermitDisabledMode(bytes19 addressPrefix) external view returns (bool) {\n        return ownerLookup[addressPrefix].isPermitDisabledMode;\n    }\n\n    /// @inheritdoc IEVC\n    function getNonce(bytes19 addressPrefix, uint256 nonceNamespace) external view returns (uint256) {\n        return nonceLookup[addressPrefix][nonceNamespace];\n    }\n\n    /// @inheritdoc IEVC\n    function getOperator(bytes19 addressPrefix, address operator) external view returns (uint256) {\n        return operatorLookup[addressPrefix][operator];\n    }\n\n    /// @inheritdoc IEVC\n    function isAccountOperatorAuthorized(address account, address operator) external view returns (bool) {\n        return isAccountOperatorAuthorizedInternal(account, operator);\n    }\n\n    /// @inheritdoc IEVC\n    function setLockdownMode(bytes19 addressPrefix, bool enabled) public payable virtual onlyOwner(addressPrefix) {\n        if (ownerLookup[addressPrefix].isLockdownMode != enabled) {\n            // to increase user security, it is prohibited to disable this mode within the self-call of the permit\n            // function or within a checks-deferrable call. to disable this mode, the setLockdownMode function must be\n            // called directly\n            if (!enabled && (executionContext.areChecksDeferred() || inPermitSelfCall())) {\n                revert EVC_NotAuthorized();\n            }\n\n            ownerLookup[addressPrefix].isLockdownMode = enabled;\n            emit LockdownModeStatus(addressPrefix, enabled);\n        }\n    }\n\n    /// @inheritdoc IEVC\n    function setPermitDisabledMode(\n        bytes19 addressPrefix,\n        bool enabled\n    ) public payable virtual onlyOwner(addressPrefix) {\n        if (ownerLookup[addressPrefix].isPermitDisabledMode != enabled) {\n            // to increase user security, it is prohibited to disable this mode within the self-call of the permit\n            // function (verified in the permit function) or within a checks-deferrable call. to disable this mode the\n            // setPermitDisabledMode function must be called directly\n            if (!enabled && executionContext.areChecksDeferred()) {\n                revert EVC_NotAuthorized();\n            }\n\n            ownerLookup[addressPrefix].isPermitDisabledMode = enabled;\n            emit PermitDisabledModeStatus(addressPrefix, enabled);\n        }\n    }\n\n    /// @inheritdoc IEVC\n    function setNonce(\n        bytes19 addressPrefix,\n        uint256 nonceNamespace,\n        uint256 nonce\n    ) public payable virtual onlyOwner(addressPrefix) {\n        uint256 currentNonce = nonceLookup[addressPrefix][nonceNamespace];\n\n        if (currentNonce >= nonce) {\n            revert EVC_InvalidNonce();\n        }\n\n        nonceLookup[addressPrefix][nonceNamespace] = nonce;\n\n        emit NonceStatus(addressPrefix, nonceNamespace, currentNonce, nonce);\n    }\n\n    /// @inheritdoc IEVC\n    /// @dev Uses authenticateCaller() function instead of onlyOwner() modifier to authenticate and get the caller\n    /// address at once.\n    function setOperator(bytes19 addressPrefix, address operator, uint256 operatorBitField) public payable virtual {\n        address msgSender =\n            authenticateCaller({addressPrefix: addressPrefix, allowOperator: false, checkLockdownMode: false});\n\n        // the operator can neither be the EVC nor can be one of 256 accounts of the owner\n        if (operator == address(this) || haveCommonOwnerInternal(msgSender, operator)) {\n            revert EVC_InvalidAddress();\n        }\n\n        if (operatorLookup[addressPrefix][operator] == operatorBitField) {\n            revert EVC_InvalidOperatorStatus();\n        } else {\n            operatorLookup[addressPrefix][operator] = operatorBitField;\n\n            emit OperatorStatus(addressPrefix, operator, operatorBitField);\n        }\n    }\n\n    /// @inheritdoc IEVC\n    /// @dev Uses authenticateCaller() function instead of onlyOwnerOrOperator() modifier to authenticate and get the\n    /// caller address at once.\n    function setAccountOperator(address account, address operator, bool authorized) public payable virtual {\n        address msgSender = authenticateCaller({account: account, allowOperator: true, checkLockdownMode: false});\n\n        // if the account and the caller have a common owner, the caller must be the owner. if the account and the\n        // caller don't have a common owner, the caller must be an operator and the owner address is taken from the\n        // storage. the caller authentication above guarantees that the account owner is already registered hence\n        // non-zero\n        address owner = haveCommonOwnerInternal(account, msgSender) ? msgSender : getAccountOwnerInternal(account);\n\n        // if it's an operator calling, it can only act for itself and must not be able to change other operators status\n        if (owner != msgSender && operator != msgSender) {\n            revert EVC_NotAuthorized();\n        }\n\n        // the operator can neither be the EVC nor can be one of 256 accounts of the owner\n        if (operator == address(this) || haveCommonOwnerInternal(owner, operator)) {\n            revert EVC_InvalidAddress();\n        }\n\n        bytes19 addressPrefix = getAddressPrefixInternal(account);\n\n        // The bitMask defines which accounts the operator is authorized for. The bitMask is created from the account\n        // number which is a number up to 2^8 in binary, or 256. 1 << (uint160(owner) ^ uint160(account)) transforms\n        // that number in an 256-position binary array like 0...010...0, marking the account positionally in a uint256.\n        uint256 bitMask = 1 << (uint160(owner) ^ uint160(account));\n\n        // The operatorBitField is a 256-position binary array, where each 1 signals by position the account that the\n        // operator is authorized for.\n        uint256 oldOperatorBitField = operatorLookup[addressPrefix][operator];\n        uint256 newOperatorBitField = authorized ? oldOperatorBitField | bitMask : oldOperatorBitField & ~bitMask;\n\n        if (oldOperatorBitField == newOperatorBitField) {\n            revert EVC_InvalidOperatorStatus();\n        } else {\n            operatorLookup[addressPrefix][operator] = newOperatorBitField;\n\n            emit OperatorStatus(addressPrefix, operator, newOperatorBitField);\n        }\n    }\n\n    // Collaterals management\n\n    /// @inheritdoc IEVC\n    function getCollaterals(address account) external view returns (address[] memory) {\n        return accountCollaterals[account].get();\n    }\n\n    /// @inheritdoc IEVC\n    function isCollateralEnabled(address account, address vault) external view returns (bool) {\n        return accountCollaterals[account].contains(vault);\n    }\n\n    /// @inheritdoc IEVC\n    function enableCollateral(\n        address account,\n        address vault\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\n        if (vault == address(this)) revert EVC_InvalidAddress();\n\n        if (accountCollaterals[account].insert(vault)) {\n            emit CollateralStatus(account, vault, true);\n        }\n        requireAccountStatusCheck(account);\n    }\n\n    /// @inheritdoc IEVC\n    function disableCollateral(\n        address account,\n        address vault\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\n        if (accountCollaterals[account].remove(vault)) {\n            emit CollateralStatus(account, vault, false);\n        }\n        requireAccountStatusCheck(account);\n    }\n\n    /// @inheritdoc IEVC\n    function reorderCollaterals(\n        address account,\n        uint8 index1,\n        uint8 index2\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\n        accountCollaterals[account].reorder(index1, index2);\n        requireAccountStatusCheck(account);\n    }\n\n    // Controllers management\n\n    /// @inheritdoc IEVC\n    function getControllers(address account) external view returns (address[] memory) {\n        return accountControllers[account].get();\n    }\n\n    /// @inheritdoc IEVC\n    function isControllerEnabled(address account, address vault) external view returns (bool) {\n        return accountControllers[account].contains(vault);\n    }\n\n    /// @inheritdoc IEVC\n    function enableController(\n        address account,\n        address vault\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\n        if (vault == address(this)) revert EVC_InvalidAddress();\n\n        if (accountControllers[account].insert(vault)) {\n            emit ControllerStatus(account, vault, true);\n        }\n        requireAccountStatusCheck(account);\n    }\n\n    /// @inheritdoc IEVC\n    function disableController(address account) public payable virtual nonReentrantChecksAndControlCollateral {\n        if (accountControllers[account].remove(msg.sender)) {\n            emit ControllerStatus(account, msg.sender, false);\n        }\n        requireAccountStatusCheck(account);\n    }\n\n    // Permit\n\n    /// @inheritdoc IEVC\n    function permit(\n        address signer,\n        address sender,\n        uint256 nonceNamespace,\n        uint256 nonce,\n        uint256 deadline,\n        uint256 value,\n        bytes calldata data,\n        bytes calldata signature\n    ) public payable virtual nonReentrantChecksAndControlCollateral {\n        // cannot be called within the self-call of the permit function; can occur for nested calls.\n        // the permit function can be called only by the specified sender\n        if (inPermitSelfCall() || (sender != address(0) && sender != msg.sender)) {\n            revert EVC_NotAuthorized();\n        }\n\n        if (signer == address(0) || !isSignerValid(signer)) {\n            revert EVC_InvalidAddress();\n        }\n\n        bytes19 addressPrefix = getAddressPrefixInternal(signer);\n\n        if (ownerLookup[addressPrefix].isPermitDisabledMode) {\n            revert EVC_PermitDisabledMode();\n        }\n\n        {\n            uint256 currentNonce = nonceLookup[addressPrefix][nonceNamespace];\n\n            if (currentNonce == type(uint256).max || currentNonce != nonce) {\n                revert EVC_InvalidNonce();\n            }\n        }\n\n        if (deadline < block.timestamp) {\n            revert EVC_InvalidTimestamp();\n        }\n\n        if (data.length == 0) {\n            revert EVC_InvalidData();\n        }\n\n        bytes32 permitHash = getPermitHash(signer, sender, nonceNamespace, nonce, deadline, value, data);\n\n        if (\n            signer != recoverECDSASigner(permitHash, signature)\n                && !isValidERC1271Signature(signer, permitHash, signature)\n        ) {\n            revert EVC_NotAuthorized();\n        }\n\n        unchecked {\n            nonceLookup[addressPrefix][nonceNamespace] = nonce + 1;\n        }\n\n        emit NonceUsed(addressPrefix, nonceNamespace, nonce);\n\n        // EVC address becomes the msg.sender for the duration this self-call, no authentication is required here.\n        // the signer will be later on authenticated as per data, depending on the functions that will be called\n        (bool success, bytes memory result) = callWithContextInternal(address(this), signer, value, data);\n\n        if (!success) revertBytes(result);\n    }\n\n    // Calls forwarding\n\n    /// @inheritdoc IEVC\n    function call(\n        address targetContract,\n        address onBehalfOfAccount,\n        uint256 value,\n        bytes calldata data\n    ) public payable virtual nonReentrantChecksAndControlCollateral returns (bytes memory result) {\n        EC contextCache = executionContext;\n        executionContext = contextCache.setChecksDeferred();\n\n        bool success;\n        (success, result) = callWithAuthenticationInternal(targetContract, onBehalfOfAccount, value, data);\n\n        if (!success) revertBytes(result);\n\n        restoreExecutionContext(contextCache);\n    }\n\n    /// @inheritdoc IEVC\n    function controlCollateral(\n        address targetCollateral,\n        address onBehalfOfAccount,\n        uint256 value,\n        bytes calldata data\n    )\n        public\n        payable\n        virtual\n        nonReentrantChecksAndControlCollateral\n        onlyController(onBehalfOfAccount)\n        returns (bytes memory result)\n    {\n        if (!accountCollaterals[onBehalfOfAccount].contains(targetCollateral)) {\n            revert EVC_NotAuthorized();\n        }\n\n        EC contextCache = executionContext;\n        executionContext = contextCache.setChecksDeferred().setControlCollateralInProgress();\n\n        bool success;\n        (success, result) = callWithContextInternal(targetCollateral, onBehalfOfAccount, value, data);\n\n        if (!success) revertBytes(result);\n\n        restoreExecutionContext(contextCache);\n    }\n\n    /// @inheritdoc IEVC\n    function batch(BatchItem[] calldata items) public payable virtual nonReentrantChecksAndControlCollateral {\n        EC contextCache = executionContext;\n        executionContext = contextCache.setChecksDeferred();\n\n        uint256 length = items.length;\n        for (uint256 i; i < length; ++i) {\n            BatchItem calldata item = items[i];\n            (bool success, bytes memory result) =\n                callWithAuthenticationInternal(item.targetContract, item.onBehalfOfAccount, item.value, item.data);\n\n            if (!success) revertBytes(result);\n        }\n\n        restoreExecutionContext(contextCache);\n    }\n\n    // Simulations\n\n    /// @inheritdoc IEVC\n    function batchRevert(BatchItem[] calldata items) public payable virtual nonReentrantChecksAndControlCollateral {\n        BatchItemResult[] memory batchItemsResult;\n        StatusCheckResult[] memory accountsStatusCheckResult;\n        StatusCheckResult[] memory vaultsStatusCheckResult;\n\n        EC contextCache = executionContext;\n\n        if (contextCache.areChecksDeferred()) {\n            revert EVC_SimulationBatchNested();\n        }\n\n        executionContext = contextCache.setChecksDeferred().setSimulationInProgress();\n\n        uint256 length = items.length;\n        batchItemsResult = new BatchItemResult[](length);\n\n        for (uint256 i; i < length; ++i) {\n            BatchItem calldata item = items[i];\n            (batchItemsResult[i].success, batchItemsResult[i].result) =\n                callWithAuthenticationInternal(item.targetContract, item.onBehalfOfAccount, item.value, item.data);\n        }\n\n        executionContext = contextCache.setChecksInProgress().setOnBehalfOfAccount(address(0));\n\n        accountsStatusCheckResult = checkStatusAllWithResult(SetType.Account);\n        vaultsStatusCheckResult = checkStatusAllWithResult(SetType.Vault);\n\n        executionContext = contextCache;\n\n        revert EVC_RevertedBatchResult(batchItemsResult, accountsStatusCheckResult, vaultsStatusCheckResult);\n    }\n\n    /// @inheritdoc IEVC\n    function batchSimulation(BatchItem[] calldata items)\n        external\n        payable\n        virtual\n        returns (\n            BatchItemResult[] memory batchItemsResult,\n            StatusCheckResult[] memory accountsStatusCheckResult,\n            StatusCheckResult[] memory vaultsStatusCheckResult\n        )\n    {\n        (bool success, bytes memory result) = address(this).delegatecall(abi.encodeCall(this.batchRevert, items));\n\n        if (success) {\n            revert EVC_BatchPanic();\n        } else if (result.length < 4 || bytes4(result) != EVC_RevertedBatchResult.selector) {\n            revertBytes(result);\n        }\n\n        assembly {\n            let length := mload(result)\n            // skip 4-byte EVC_RevertedBatchResult selector\n            result := add(result, 4)\n            // write new array length = original length - 4-byte selector\n            // cannot underflow as we require result.length >= 4 above\n            mstore(result, sub(length, 4))\n        }\n\n        (batchItemsResult, accountsStatusCheckResult, vaultsStatusCheckResult) =\n            abi.decode(result, (BatchItemResult[], StatusCheckResult[], StatusCheckResult[]));\n    }\n\n    // Account Status Check\n\n    /// @inheritdoc IEVC\n    function isAccountStatusCheckDeferred(address account) external view returns (bool) {\n        if (executionContext.areChecksInProgress()) {\n            revert EVC_ChecksReentrancy();\n        }\n\n        return accountStatusChecks.contains(account);\n    }\n\n    /// @inheritdoc IEVC\n    function requireAccountStatusCheck(address account) public payable virtual {\n        if (executionContext.areChecksDeferred()) {\n            accountStatusChecks.insert(account);\n        } else {\n            requireAccountStatusCheckInternalNonReentrantChecks(account);\n        }\n    }\n\n    /// @inheritdoc IEVC\n    function forgiveAccountStatusCheck(address account)\n        public\n        payable\n        virtual\n        nonReentrantChecks\n        onlyController(account)\n    {\n        accountStatusChecks.remove(account);\n    }\n\n    // Vault Status Check\n\n    /// @inheritdoc IEVC\n    function isVaultStatusCheckDeferred(address vault) external view returns (bool) {\n        if (executionContext.areChecksInProgress()) {\n            revert EVC_ChecksReentrancy();\n        }\n\n        return vaultStatusChecks.contains(vault);\n    }\n\n    /// @inheritdoc IEVC\n    function requireVaultStatusCheck() public payable virtual {\n        if (executionContext.areChecksDeferred()) {\n            vaultStatusChecks.insert(msg.sender);\n        } else {\n            requireVaultStatusCheckInternalNonReentrantChecks(msg.sender);\n        }\n    }\n\n    /// @inheritdoc IEVC\n    function forgiveVaultStatusCheck() public payable virtual nonReentrantChecks {\n        vaultStatusChecks.remove(msg.sender);\n    }\n\n    /// @inheritdoc IEVC\n    function requireAccountAndVaultStatusCheck(address account) public payable virtual {\n        if (executionContext.areChecksDeferred()) {\n            accountStatusChecks.insert(account);\n            vaultStatusChecks.insert(msg.sender);\n        } else {\n            requireAccountStatusCheckInternalNonReentrantChecks(account);\n            requireVaultStatusCheckInternalNonReentrantChecks(msg.sender);\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                  INTERNAL FUNCTIONS                                       //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Authenticates the caller of a function.\n    /// @dev This function checks if the caller is the owner or an authorized operator of the account, and if the\n    /// account is not in lockdown mode.\n    /// @param account The account address to authenticate the caller against.\n    /// @param allowOperator A boolean indicating if operators are allowed to authenticate as the caller.\n    /// @param checkLockdownMode A boolean indicating if the function should check for lockdown mode on the account.\n    /// @return The address of the authenticated caller.\n    function authenticateCaller(\n        address account,\n        bool allowOperator,\n        bool checkLockdownMode\n    ) internal virtual returns (address) {\n        bytes19 addressPrefix = getAddressPrefixInternal(account);\n        address owner = ownerLookup[addressPrefix].owner;\n        bool lockdownMode = ownerLookup[addressPrefix].isLockdownMode;\n        address msgSender = _msgSender();\n        bool authenticated = false;\n\n        // check if the caller is the owner of the account\n        if (haveCommonOwnerInternal(account, msgSender)) {\n            // if the owner is not registered, register it\n            if (owner == address(0)) {\n                ownerLookup[addressPrefix].owner = msgSender;\n                emit OwnerRegistered(addressPrefix, msgSender);\n                authenticated = true;\n            } else if (owner == msgSender) {\n                authenticated = true;\n            }\n        }\n\n        // if the caller is not the owner, check if it is an operator if operators are allowed\n        if (!authenticated && allowOperator && isAccountOperatorAuthorizedInternal(account, msgSender)) {\n            authenticated = true;\n        }\n\n        // must revert if neither the owner nor the operator were authenticated\n        if (!authenticated) {\n            revert EVC_NotAuthorized();\n        }\n\n        // revert if the account is in lockdown mode unless the lockdown mode is not being checked\n        if (checkLockdownMode && lockdownMode) {\n            revert EVC_LockdownMode();\n        }\n\n        return msgSender;\n    }\n\n    /// @notice Authenticates the caller of a function.\n    /// @dev This function converts a bytes19 address prefix into a phantom account address which is an account address\n    /// that belongs to the owner of the address prefix.\n    /// @param addressPrefix The bytes19 address prefix to authenticate the caller against.\n    /// @param allowOperator A boolean indicating if operators are allowed to authenticate as the caller.\n    /// @param checkLockdownMode A boolean indicating if the function should check for lockdown mode on the account.\n    /// @return The address of the authenticated caller.\n    function authenticateCaller(\n        bytes19 addressPrefix,\n        bool allow"
    }
  ]
}