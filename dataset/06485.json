{
  "Title": "[M-37] Branch Strategies lose yield due to wrong implementation of time limit in `BranchPort.sol`",
  "Content": "\nBranch Strategies lose yield due to a wrong implementation of the time limit in `BranchPort.sol`. This results in missed yield for branch strategies, less capital utilization of the platform, and ultimately a loss of additional revenue for the protocol's users.\n\n### Proof of Concept\n\nThe `_checkTimeLimit` function in `BranchPort.sol` controls whether amounts used by a branch strategy cumulatively do not exceed the daily limit, which is set for the particular strategy. It is only called from the `manage` function in the same contract (<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchPort.sol#L161>).\n\nThe current implementation of `_checkTimeLimit` looks like this:\n\n```Solidity\nfunction _checkTimeLimit(address _token, uint256 _amount) internal {\n    if (block.timestamp - lastManaged[msg.sender][_token] >= 1 days) {\n        strategyDailyLimitRemaining[msg.sender][_token] = strategyDailyLimitAmount[msg.sender][_token];\n    }\n    strategyDailyLimitRemaining[msg.sender][_token] -= _amount;\n    lastManaged[msg.sender][_token] = block.timestamp;\n}\n```\n\n**The current implementation does the following:**\n\n- The first time a strategy manages some amounts and `_checkTimeLimit` is called, the 24 hour window is started (`strategyDailyLimitRemaining[msg.sender][_token]` is initialized to the daily limit amount and `lastManaged[msg.sender][_token] `is set to `block.timestamp`).\n\n- On a second call, to use more of the daily limit (if the amount used in the above bullet, is not the full daily amount, which is not enforced), it will set `lastManaged[msg.sender][_token]` again to `block.timestamp`. This pushes the time when the daily budget will be reset (`strategyDailyLimitRemaining[msg.sender][_token]` = `strategyDailyLimitAmount[msg.sender][_token]`) again 24 hours into the future.\n\n**Consequences of the current implementation:**\n\n- Due to the setting of the `lastManaged[msg.sender][_token]` on every call,  the daily budget misses its purpose, as a budget reset after 24h is not guaranteed.\n\n- In the worst but likely case, a call is made by the strategy just before the current 24 hour time window passes to use the remaining amount. This will delay a reset of the daily limit by the maximum possible time. In consequence, a strategy misses 1 full amount of the daily budget.\n\n- The aforementioned results in a loss of yield for the strategy (assuming the strategy generates a yield), less capital utilization of the platform, and ultimately, a loss of additional revenue for the protocol's users.\n\n- Assuming there are multiple strategies in the protocol, the negative effect is multiplied.\n\n**The implementation that was probably intended:**\n\n```Solidity\nfunction _checkTimeLimit(address _token, uint256 _amount) internal {\n    if (block.timestamp - lastManaged[msg.sender][_token] >= 1 days) {\n        strategyDailyLimitRemaining[msg.sender][_token] = strategyDailyLimitAmount[msg.sender][_token];\n        lastManaged[msg.sender][_token] = block.timestamp; // <--- line moved here\n    }\n    strategyDailyLimitRemaining[msg.sender][_token] -= _amount;\n}\n```\n\n- Here, the reset of the daily budget is made after a 24 hour time window as expected.\n\n- What is lost is the information \"when the last time a strategy called the function\", as `lastManaged[msg.sender][_token]` now only stores the `block.timestamp` the last time the daily budget was reset and not when the last time the function was called. If this should still be tracked, consider an additional state variable (e.g. `lastDailyBudgetReset[msg.sender][_token]`).\n\n### Recommended Mitigation Steps\n\nImplement the logic as shown under section **The implementation that was probably intended**\n\nPlease also, consider the following comments:\n\n- To get the maximum amount out of their daily budget, a strategy must make a call to the `manage()` function exactly every 24 hours after the first time calling it. Otherwise, there are time frames where amounts could be retrieved, but are not. That would have the strategy missing out on investments and therefore, potential yield. E.g. the 2nd call happens 36 hours (instead of 24 hours) after the initial call => 12 hours (1/2 of a daily budget) remains unused.\n\n- The amount also needs to be fully used within the 24 hour timeframe, since the daily limit is overwriting and not cumulating (using `strategyDailyLimitRemaining[msg.sender][_token]` = `strategyDailyLimitAmount[msg.sender][_token]` and not `strategyDailyLimitRemaining[msg.sender][_token]` += `strategyDailyLimitAmount[msg.sender][_token]`).\n\n- An alternative to the aforementioned, could be to calculate the amount to grant to a strategy after an initial/last grant like the following: (time since last grant of fresh daily limit / 24 hours) `*` daily limit. This would have the effect that a strategy could use their granted limits without missing amounts due to suboptimal timing. It would also spare the strategy the necessary call every 24 hours, which would save some gas and remove the need for setting up automation for each strategy (e.g. using Chainlink keepers). The strategy could never spend more than the cumulative daily budget. But it may lead to a sudden usage of a large amount of accumulated budget, which may not be intended.\n\n### Assessed type\n\nTiming\n\n**[0xBugsy (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/264#issuecomment-1632522098)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/264#issuecomment-1709932221):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/264).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/ulysses-omnichain/BranchPort.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IPortStrategy} from \"./interfaces/IPortStrategy.sol\";\nimport {IBranchPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {ERC20hTokenBranch} from \"./token/ERC20hTokenBranch.sol\";\n\n/// @title Branch Port - Omnichain Token Management Contract\ncontract BranchPort is Ownable, IBranchPort {\n    using SafeTransferLib for address;\n\n    /// @notice Local Core Branch Router Address.\n    address public coreBranchRouterAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address => bool) public isBridgeAgent;\n\n    /// @notice Branch Routers deployed in branc chain.\n    address[] public bridgeAgents;\n\n    /// @notice Number of Branch Routers deployed in current chain.\n    uint256 public bridgeAgentsLenght;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address => bool) public isBridgeAgentFactory;\n\n    /// @notice Branch Routers deployed in branc chain.\n    address[] public bridgeAgentFactories;\n\n    /// @notice Number of Branch Routers deployed in current chain.\n    uint256 public bridgeAgentFactoriesLenght;\n\n    /*///////////////////////////////////////////////////////////////\n                        PORT STRATEGY STATE\n    //////////////////////////////////////////////////////////////*/\n    /// Strategy Tokens\n\n    /// @notice Mapping returns true if Strategy Token Address is active for usage in Port Strategies.\n    mapping(address => bool) public isStrategyToken;\n\n    /// @notice List of Tokens whitelisted for usage in Port Strategies.\n    address[] public strategyTokens;\n\n    /// @notice Number of Port Strategies deployed in current branch chain.\n    uint256 public strategyTokensLenght;\n\n    /// @notice Mapping returns a given token's total debt incurred by Port Strategies.\n    mapping(address => uint256) public getStrategyTokenDebt;\n\n    /// @notice Mapping returns the minimum ratio of a given Strategy Token the Port should hold.\n    mapping(address => uint256) public getMinimumTokenReserveRatio;\n\n    /// Port Strategies\n\n    /// @notice Mapping returns true if Port Startegy is allowed to manage a given Strategy Token. Strategy => Token => bool.\n    mapping(address => mapping(address => bool)) public isPortStrategy;\n\n    /// @notice Port Strategy Addresses deployed in current branch chain.\n    address[] public portStrategies;\n\n    /// @notice Number of Port Strategies deployed in current branch chain.\n    uint256 public portStrategiesLenght;\n\n    /// @notice Mapping returns the amount of Strategy Token debt a given Port Startegy has.  Strategy => Token => uint256.\n    mapping(address => mapping(address => uint256)) public getPortStrategyTokenDebt;\n\n    /// @notice Mapping returns the last time a given Port Strategy managed a given Strategy Token. Strategy => Token => uint256.\n    mapping(address => mapping(address => uint256)) public lastManaged;\n\n    /// @notice Mapping returns the time limit a given Port Strategy must wait before managing a Strategy Token. Strategy => Token => uint256.\n    mapping(address => mapping(address => uint256)) public strategyDailyLimitAmount;\n\n    /// @notice Mapping returns the amount of a Strategy Token a given Port Strategy can manage.\n    mapping(address => mapping(address => uint256)) public strategyDailyLimitRemaining;\n\n    uint256 internal constant DIVISIONER = 1e4;\n    uint256 internal constant MIN_RESERVE_RATIO = 3e3;\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"Owner is zero address\");\n        _initializeOwner(_owner);\n    }\n\n    function initialize(address _coreBranchRouter, address _bridgeAgentFactory) external virtual onlyOwner {\n        require(coreBranchRouterAddress == address(0), \"Contract already initialized\");\n        require(!isBridgeAgentFactory[_bridgeAgentFactory], \"Contract already initialized\");\n\n        require(_coreBranchRouter != address(0), \"CoreBranchRouter is zero address\");\n        require(_bridgeAgentFactory != address(0), \"BridgeAgentFactory is zero address\");\n\n        coreBranchRouterAddress = _coreBranchRouter;\n        isBridgeAgentFactory[_bridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_bridgeAgentFactory);\n        bridgeAgentFactoriesLenght++;\n    }\n\n    /// @notice Function being overrriden to prevent mistakenly renouncing ownership.\n    function renounceOwnership() public payable override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns amount of Strategy Tokens\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 excess reserves\n     */\n    function _excessReserves(address _token) internal view returns (uint256) {\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n        uint256 minReserves = _minimumReserves(currBalance, _token);\n        return currBalance > minReserves ? currBalance - minReserves : 0;\n    }\n\n    /**\n     * @notice Returns amount of Strategy Tokens needed to reach minimum reserves\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 excess reserves\n     */\n    function _reservesLacking(address _token) internal view returns (uint256) {\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n        uint256 minReserves = _minimumReserves(currBalance, _token);\n        return currBalance < minReserves ? minReserves - currBalance : 0;\n    }\n\n    /**\n     * @notice Internal function to return the minimum amount of reserves of a given Strategy Token the Port should hold.\n     *   @param _currBalance Current balance of a given Strategy Token.\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 minimum reserves\n     */\n    function _minimumReserves(uint256 _currBalance, address _token) internal view returns (uint256) {\n        return ((_currBalance + getStrategyTokenDebt[_token]) * getMinimumTokenReserveRatio[_token]) / DIVISIONER;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        PORT STRATEGY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function manage(address _token, uint256 _amount) external requiresPortStrategy(_token) {\n        if (_amount > _excessReserves(_token)) revert InsufficientReserves();\n\n        _checkTimeLimit(_token, _amount);\n\n        getStrategyTokenDebt[_token] += _amount;\n        getPortStrategyTokenDebt[msg.sender][_token] += _amount;\n\n        _token.safeTransfer(msg.sender, _amount);\n\n        emit DebtCreated(msg.sender, _token, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function replenishReserves(address _strategy, address _token, uint256 _amount) external lock {\n        if (!isStrategyToken[_token]) revert UnrecognizedStrategyToken();\n        if (!isPortStrategy[_strategy][_token]) revert UnrecognizedPortStrategy();\n\n        uint256 reservesLacking = _reservesLacking(_token);\n\n        uint256 amountToWithdraw = _amount < reservesLacking ? _amount : reservesLacking;\n\n        IPortStrategy(_strategy).withdraw(address(this), _token, amountToWithdraw);\n\n        getPortStrategyTokenDebt[_strategy][_token] -= amountToWithdraw;\n        getStrategyTokenDebt[_token] -= amountToWithdraw;\n\n        emit DebtRepaid(_strategy, _token, amountToWithdraw);\n    }\n\n    /**\n     * @notice Internal function to check if a Port Strategy has reached its daily management limit.\n     *   @param _token address being managed.\n     *   @param _amount of token being requested.\n     */\n    function _checkTimeLimit(address _token, uint256 _amount) internal {\n        if (block.timestamp - lastManaged[msg.sender][_token] >= 1 days) {\n            strategyDailyLimitRemaining[msg.sender][_token] = strategyDailyLimitAmount[msg.sender][_token];\n        }\n        strategyDailyLimitRemaining[msg.sender][_token] -= _amount;\n        lastManaged[msg.sender][_token] = block.timestamp;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function withdraw(address _recipient, address _underlyingAddress, uint256 _deposit)\n        external\n        virtual\n        requiresBridgeAgent\n    {\n        _underlyingAddress.safeTransfer(\n            _recipient, _denormalizeDecimals(_deposit, ERC20(_underlyingAddress).decimals())\n        );\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeIn(address _recipient, address _localAddress, uint256 _amount)\n        external\n        virtual\n        requiresBridgeAgent\n    {\n        ERC20hTokenBranch(_localAddress).mint(_recipient, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeInMultiple(address _recipient, address[] memory _localAddresses, uint256[] memory _amounts)\n        external\n        virtual\n        requiresBridgeAgent\n    {\n        for (uint256 i = 0; i < _localAddresses.length;) {\n            ERC20hTokenBranch(_localAddresses[i]).mint(_recipient, _amounts[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeOut(\n        address _depositor,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _amount,\n        uint256 _deposit\n    ) external virtual requiresBridgeAgent {\n        if (_amount - _deposit > 0) {\n            _localAddress.safeTransferFrom(_depositor, address(this), _amount - _deposit);\n            ERC20hTokenBranch(_localAddress).burn(_amount - _deposit);\n        }\n        if (_deposit > 0) {\n            _underlyingAddress.safeTransferFrom(\n                _depositor, address(this), _denormalizeDecimals(_deposit, ERC20(_underlyingAddress).decimals())\n            );\n        }\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeOutMultiple(\n        address _depositor,\n        address[] memory _localAddresses,\n        address[] memory _underlyingAddresses,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits\n    ) external virtual requiresBridgeAgent {\n        for (uint256 i = 0; i < _localAddresses.length;) {\n            if (_deposits[i] > 0) {\n                _underlyingAddresses[i].safeTransferFrom(\n                    _depositor,\n                    address(this),\n                    _denormalizeDecimals(_deposits[i], ERC20(_underlyingAddresses[i]).decimals())\n                );\n            }\n            if (_amounts[i] - _deposits[i] > 0) {\n                _localAddresses[i].safeTransferFrom(_depositor, address(this), _amounts[i] - _deposits[i]);\n                ERC20hTokenBranch(_localAddresses[i]).burn(_amounts[i] - _deposits[i]);\n            }\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function addBridgeAgent(address _bridgeAgent) external requiresBridgeAgentFactory {\n        isBridgeAgent[_bridgeAgent] = true;\n        bridgeAgents.push(_bridgeAgent);\n        bridgeAgentsLenght++;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function setCoreRouter(address _newCoreRouter) external requiresCoreRouter {\n        require(coreBranchRouterAddress != address(0), \"CoreRouter address is zero\");\n        require(_newCoreRouter != address(0), \"New CoreRouter address is zero\");\n        coreBranchRouterAddress = _newCoreRouter;\n    }\n\n    /// @inheritdoc IBranchPort\n    function addBridgeAgentFactory(address _newBridgeAgentFactory) external requiresCoreRouter {\n        isBridgeAgentFactory[_newBridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_newBridgeAgentFactory);\n        bridgeAgentFactoriesLenght++;\n\n        emit BridgeAgentFactoryAdded(_newBridgeAgentFactory);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleBridgeAgentFactory(address _newBridgeAgentFactory) external requiresCoreRouter {\n        isBridgeAgentFactory[_newBridgeAgentFactory] = !isBridgeAgentFactory[_newBridgeAgentFactory];\n\n        emit BridgeAgentFactoryToggled(_newBridgeAgentFactory);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleBridgeAgent(address _bridgeAgent) external requiresCoreRouter {\n        isBridgeAgent[_bridgeAgent] = !isBridgeAgent[_bridgeAgent];\n\n        emit BridgeAgentToggled(_bridgeAgent);\n    }\n\n    /// @inheritdoc IBranchPort\n    function addStrategyToken(address _token, uint256 _minimumReservesRatio) external requiresCoreRouter {\n        if (_minimumReservesRatio >= DIVISIONER) revert InvalidMinimumReservesRatio();\n        strategyTokens.push(_token);\n        strategyTokensLenght++;\n        getMinimumTokenReserveRatio[_token] = _minimumReservesRatio;\n        isStrategyToken[_token] = true;\n\n        emit StrategyTokenAdded(_token, _minimumReservesRatio);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleStrategyToken(address _token) external requiresCoreRouter {\n        isStrategyToken[_token] = !isStrategyToken[_token];\n\n        emit StrategyTokenToggled(_token);\n    }\n\n    /// @inheritdoc IBranchPort\n    function addPortStrategy(address _portStrategy, address _token, uint256 _dailyManagementLimit)\n        external\n        requiresCoreRouter\n    {\n        if (!isStrategyToken[_token]) revert UnrecognizedStrategyToken();\n        portStrategies.push(_portStrategy);\n        portStrategiesLenght++;\n        strategyDailyLimitAmount[_portStrategy][_token] = _dailyManagementLimit;\n        isPortStrategy[_portStrategy][_token] = true;\n\n        emit PortStrategyAdded(_portStrategy, _token, _dailyManagementLimit);\n    }\n\n    /// @inheritdoc IBranchPort\n    function togglePortStrategy(address _portStrategy, address _token) external requiresCoreRouter {\n        isPortStrategy[_portStrategy][_token] = !isPortStrategy[_portStrategy][_token];\n\n        emit PortStrategyToggled(_portStrategy, _token);\n    }\n\n    /// @inheritdoc IBranchPort\n    function updatePortStrategy(address _portStrategy, address _token, uint256 _dailyManagementLimit)\n        external\n        requiresCoreRouter\n    {\n        strategyDailyLimitAmount[_portStrategy][_token] = _dailyManagementLimit;\n\n        emit PortStrategyUpdated(_portStrategy, _token, _dailyManagementLimit);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function that denormalizes an input from 18 decimal places.\n     * @param _amount amount of tokens\n     * @param _decimals number of decimal places\n     */\n    function _denormalizeDecimals(uint256 _amount, uint8 _decimals) internal pure returns (uint256) {\n        return _decimals == 18 ? _amount : _amount * 1 ether / (10 ** _decimals);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is the Branch Chain's Core Root Router.\n    modifier requiresCoreRouter() {\n        if (msg.sender != coreBranchRouterAddress) revert UnrecognizedCore();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent.\n    modifier requiresBridgeAgent() {\n        if (!isBridgeAgent[msg.sender]) revert UnrecognizedBridgeAgent();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent Factory.\n    modifier requiresBridgeAgentFactory() {\n        if (!isBridgeAgentFactory[msg.sender]) revert UnrecognizedBridgeAgentFactory();\n        _;\n    }\n\n    /// @notice Modifier that require msg sender to be an active Port Strategy\n    modifier requiresPortStrategy(address _token) {\n        if (!isPortStrategy[msg.sender][_token]) revert UnrecognizedPortStrategy();\n        _;\n    }\n\n    uint256 internal _unlocked = 1;\n\n    /// @notice Modifier for a simple re-entrancy check.\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n}"
    }
  ]
}