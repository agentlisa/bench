{
  "Title": "M-1: AdvancedDistributorInitializable sets claim data to empty, making claims fail",
  "Content": "# Issue M-1: AdvancedDistributorInitializable sets claim data to empty, making claims fail \n\nSource: https://github.com/sherlock-audit/2024-05-tokensoft-distributor-contracts-update-judging/issues/11 \n\n## Found by \n0xboriskataa, 1337web3, BiasedMerc, Honour, Ironsidesec, Varun\\_05, aman, hunter\\_w3b, jkoppel, merlin, nfmelendez, robertodf, samuraii77\n## Summary\n\nAdvancedDistributorInitializable.claim overrides the passed-in data with new bytes(0). This data is needed by both PerAddressTrancheVestingMerkleDistributor and PerAddressContinuousVestingMerkleDistributor for claims to work. Therefore, claims do not work.\n\n## Vulnerability Detail\n\n\n## Impact\n\nClaims do not work\n\nBoth PerAddressTrancheVestingMerkleDistributor and PerAddressContinuousVestingMerkleDistributor also pass in `new bytes(0)` to this argument, causing the same issue. However, this is a separate issue per my understanding of Sherlock rules; it is in separate code, and will stay broken if the others are fixed. \n\n## Code Snippet\n\nAdvancedDistributorInitializable calls DistributorInitializable._executeClaim with data=new bytes(0)\n\nhttps://github.com/sherlock-audit/2024-05-tokensoft-distributor-contracts-update/blob/main/contracts/packages/hardhat/contracts/claim/factory/AdvancedDistributorInitializable.sol#L106-L113\n\n```solidity\n    function _executeClaim(address beneficiary, uint256 totalAmount, bytes memory)\n        internal\n        virtual\n        override\n        returns (uint256 _claimed)\n    {\n        _claimed = super._executeClaim(beneficiary, totalAmount, new bytes(0));\n        _reconcileVotingPower(beneficiary);\n    }\n```\n\n DistributorInitializable._executeClaim  forwards this data to getClaimableAmount, which forwards it to getVestedFraction\n\nhttps://github.com/sherlock-audit/2024-05-tokensoft-distributor-contracts-update/blob/main/contracts/packages/hardhat/contracts/claim/factory/DistributorInitializable.sol#L75\nhttps://github.com/sherlock-audit/2024-05-tokensoft-distributor-contracts-update/blob/main/contracts/packages/hardhat/contracts/claim/factory/DistributorInitializable.sol#L113\n\nMany implementations of getVestedFraction attempt to decode this data in ways that break if the data is empty.\n\nE.g.:\n\nhttps://github.com/sherlock-audit/2024-05-tokensoft-distributor-contracts-update/blob/main/contracts/packages/hardhat/contracts/claim/factory/PerAddressContinuousVestingInitializable.sol#L30-L35\n\n```solidity\n    function getVestedFraction(\n        address beneficiary,\n        uint256 time, // time is in seconds past the epoch (e.g. block.timestamp)\n        bytes memory data\n    ) public view override returns (uint256) {\n        (uint256 start, uint256 cliff, uint256 end) = abi.decode(data, (uint256, uint256, uint256));\n```\n\nPutting these together, attempting to claim will be a lot like this Chisel section.\n\n```text\n➜ bytes memory data = new bytes(0)\n➜ (uint256 start, uint256 cliff, uint256 end) = abi.decode(data, (uint256, uint256, uint256));\nTraces:\n  [805] 0xBd770416a3345F91E4B34576cb804a576fa48EB1::run()\n    └─ ← \"EvmError: Revert\"\n\n⚒️ Chisel Error: Failed to execute REPL contract!\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nPass the data parameter along properly\n\n\n\n## Discussion\n\n**ArshaanB**\n\nYes, can confirm, this seems like an issue.\n\n`ContinuousVestingInitializable`, `TrancheVestingInitializable` — the `getVestedFraction()` doesn't care about `data`\n`PerAddressContinuousVestingInitializable`, `PerAddressTrancheVestingInitializable` — the `getVestedFraction()` does care about `data`\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/SoftDAO/contracts/pull/47\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/285",
  "Code": [
    {
      "filename": "contracts/packages/hardhat/contracts/claim/factory/AdvancedDistributorInitializable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC20Votes, ERC20Permit, ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {DistributorInitializable, DistributionRecord, IERC20} from \"./DistributorInitializable.sol\";\nimport {IAdjustable} from \"../../interfaces/IAdjustable.sol\";\nimport {IVoting} from \"../../interfaces/IVoting.sol\";\nimport {Sweepable} from \"../../utilities/Sweepable.sol\";\nimport \"./FairQueueInitializable.sol\";\n\n/**\n * @title AdvancedDistributor\n * @notice Distributes tokens to beneficiaries with voting-while-vesting and administrative controls.\n * The contract owner can control these distribution parameters:\n * - the merkle root determining all distribution details\n * - adjustments to specific distributions\n * - the token being distributed\n * - the total amount to distribute\n * - the metadata URI\n * - the voting power of undistributed tokens\n * - the recipient of swept funds\n *\n * This contract also allows owners to perform several other admin functions\n * - updating the contract owner\n * - sweeping tokens and native currency to a recipient\n *\n * This contract tracks beneficiary voting power through an internal ERC20Votes token that cannot be transferred. The\n * beneficiary must delegate to an address to use this voting power. Their voting power decreases when the token is claimed.\n *\n * @dev Updates to the contract must follow these constraints:\n * - If a merkle root update alters the total token quantity to distribute across all users, also adjust the total value.\n *   The DistributionRecord for each beneficiary updated in the merkle root will be incorrect until a claim is executed.\n * - If the total changes, make sure to add or withdraw tokens being distributed to match the new total.\n */\nabstract contract AdvancedDistributorInitializable is\n    Initializable,\n    Ownable,\n    Sweepable,\n    ERC20Votes,\n    DistributorInitializable,\n    IAdjustable,\n    IVoting,\n    FairQueueInitializable\n{\n    using SafeERC20 for IERC20;\n\n    uint256 private voteFactor;\n\n    constructor()\n        ERC20Permit(\"Internal vote tracker\")\n        ERC20(\"Internal vote tracker\", \"IVT\")\n        Sweepable(payable(msg.sender))\n    {}\n\n    function __AdvancedDistributor_init(\n        IERC20 _token,\n        uint256 _total,\n        string memory _uri,\n        uint256 _voteFactor,\n        uint256 _fractionDenominator,\n        uint160 _maxDelayTime,\n        uint160 _salt,\n        address _owner\n    ) internal onlyInitializing {\n        _setSweepRecipient(payable(_owner));\n        voteFactor = _voteFactor;\n        emit SetVoteFactor(voteFactor);\n\n        __Distributor_init(_token, _total, _uri, _fractionDenominator);\n        __FairQueue_init(_maxDelayTime, _salt);\n    }\n\n    /**\n     * convert a token quantity to a vote quantity\n     */\n    function tokensToVotes(uint256 tokenAmount) private view returns (uint256) {\n        return (tokenAmount * voteFactor) / fractionDenominator;\n    }\n\n    // Update voting power based on distribution record initialization or claims\n    function _reconcileVotingPower(address beneficiary) private {\n        // current potential voting power\n        uint256 currentVotes = balanceOf(beneficiary);\n        // correct voting power after initialization, claim, or adjustment\n        DistributionRecord memory record = records[beneficiary];\n        uint256 newVotes = record.claimed >= record.total ? 0 : tokensToVotes(record.total - record.claimed);\n\n        if (currentVotes > newVotes) {\n            // reduce voting power through ERC20Votes extension\n            _burn(beneficiary, currentVotes - newVotes);\n        } else if (currentVotes < newVotes) {\n            // increase voting power through ERC20Votes extension\n            _mint(beneficiary, newVotes - currentVotes);\n        }\n    }\n\n    function _initializeDistributionRecord(address beneficiary, uint256 totalAmount) internal virtual override {\n        super._initializeDistributionRecord(beneficiary, totalAmount);\n        _reconcileVotingPower(beneficiary);\n    }\n\n    function _executeClaim(address beneficiary, uint256 totalAmount, bytes memory)\n        internal\n        virtual\n        override\n        returns (uint256 _claimed)\n    {\n        _claimed = super._executeClaim(beneficiary, totalAmount, new bytes(0));\n        _reconcileVotingPower(beneficiary);\n    }\n\n    /**\n     * @dev Adjust the quantity claimable by a user, overriding the value in the distribution record.\n     *\n     * Note: If used in combination with merkle proofs, adjustments to a beneficiary's total could be\n     * reset by anyone to the value in the merkle leaf at any time. Update the merkle root instead.\n     *\n     * Amount is limited to type(uint120).max to allow each DistributionRecord to be packed into a single storage slot.\n     */\n    function adjust(address beneficiary, int256 amount) external onlyOwner {\n        DistributionRecord memory distributionRecord = records[beneficiary];\n        require(distributionRecord.initialized, \"must initialize before adjusting\");\n\n        uint256 diff = uint256(amount > 0 ? amount : -amount);\n        require(diff < type(uint120).max, \"adjustment > max uint120\");\n\n        if (amount < 0) {\n            // decreasing claimable tokens\n            require(total >= diff, \"decrease greater than distributor total\");\n            require(distributionRecord.total >= diff, \"decrease greater than distributionRecord total\");\n            total -= diff;\n            records[beneficiary].total -= uint120(diff);\n            token.safeTransfer(owner(), diff);\n        } else {\n            // increasing claimable tokens\n            total += diff;\n            records[beneficiary].total += uint120(diff);\n        }\n        _reconcileVotingPower(beneficiary);\n        emit Adjust(beneficiary, amount);\n    }\n\n    function _setToken(IERC20 _token) internal virtual {\n        require(address(_token) != address(0), \"token is address(0)\");\n        token = _token;\n        emit SetToken(token);\n    }\n\n    // Set the token being distributed\n    function setToken(IERC20 _token) external virtual onlyOwner {\n        _setToken(_token);\n    }\n\n    function _setTotal(uint256 _total) internal virtual {\n        total = _total;\n        emit SetTotal(total);\n    }\n\n    // Set the total to distribute\n    function setTotal(uint256 _total) external virtual onlyOwner {\n        _setTotal(_total);\n    }\n\n    // Set the distributor metadata URI\n    function setUri(string memory _uri) external onlyOwner {\n        uri = _uri;\n        emit SetUri(uri);\n    }\n\n    // set the recipient of swept funds\n    function setSweepRecipient(address payable _recipient) external onlyOwner {\n        _setSweepRecipient(_recipient);\n    }\n\n    function getTotalVotes() external view returns (uint256) {\n        // supply of internal token used to track voting power\n        return totalSupply();\n    }\n\n    function getVoteFactor(address) external view returns (uint256) {\n        return voteFactor;\n    }\n\n    /**\n     * @notice Set the voting power of undistributed tokens\n     * @param _voteFactor The voting power multiplier as a fraction of fractionDenominator\n     * @dev The vote factor can be any integer. If voteFactor / fractionDenominator == 1,\n     * one unclaimed token provides one vote. If voteFactor / fractionDenominator == 2, one\n     * unclaimed token counts as two votes.\n     */\n    function setVoteFactor(uint256 _voteFactor) external onlyOwner {\n        voteFactor = _voteFactor;\n        emit SetVoteFactor(voteFactor);\n    }\n\n    /**\n     * @dev the internal token used only for tracking voting power cannot be transferred\n     */\n    function _approve(address, address, uint256) internal pure override {\n        revert(\"disabled for voting power\");\n    }\n\n    /**\n     * @dev the internal token used only for tracking voting power cannot be transferred\n     */\n    function _transfer(address, address, uint256) internal pure override {\n        revert(\"disabled for voting power\");\n    }\n}"
    },
    {
      "filename": "contracts/packages/hardhat/contracts/claim/factory/DistributorInitializable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport {IDistributor, DistributionRecord} from \"../../interfaces/IDistributor.sol\";\n\n/**\n * @title Distributor\n * @notice Distributes funds to beneficiaries and tracks distribution status\n */\nabstract contract DistributorInitializable is Initializable, IDistributor, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    mapping(address => DistributionRecord) internal records; // track distribution records per user\n    IERC20 public token; // the token being claimed\n    uint256 public total; // total tokens allocated for claims\n    uint256 public claimed; // tokens already claimed\n    string public uri; // ipfs link on distributor info\n    uint256 internal fractionDenominator; // denominator for vesting fraction (e.g. if vested fraction is 100 and fractionDenominator is 10000, 1% of tokens have vested)\n\n    // provide context on the contract name and version\n    function NAME() external view virtual returns (string memory);\n\n    function VERSION() external view virtual returns (uint256);\n\n    function __Distributor_init(IERC20 _token, uint256 _total, string memory _uri, uint256 _fractionDenominator)\n        internal\n        onlyInitializing\n    {\n        require(address(_token) != address(0), \"Distributor: token is address(0)\");\n        require(_total > 0, \"Distributor: total is 0\");\n\n        token = _token;\n        total = _total;\n        uri = _uri;\n        fractionDenominator = _fractionDenominator;\n        emit InitializeDistributor(token, total, uri, fractionDenominator);\n    }\n\n    /**\n     * @dev Set up the distribution record for a user. Permissions are not checked in this function.\n     * Amount is limited to type(uint120).max to allow each DistributionRecord to be packed into a single storage slot.\n     *\n     * @param beneficiary The address of the beneficiary\n     * @param _totalAmount The total amount of tokens to be distributed to the beneficiary\n     */\n    function _initializeDistributionRecord(address beneficiary, uint256 _totalAmount) internal virtual {\n        // Checks\n        require(_totalAmount <= type(uint120).max, \"Distributor: totalAmount > type(uint120).max\");\n        uint120 totalAmount = uint120(_totalAmount);\n\n        // Effects - note that the existing claimed quantity is re-used during re-initialization\n        records[beneficiary] = DistributionRecord(true, totalAmount, records[beneficiary].claimed);\n        emit InitializeDistributionRecord(beneficiary, totalAmount);\n    }\n\n    /**\n     * @notice Record the claim internally:\n     * @dev This function does not check permissions: caller must verify the claim is valid!\n     * this function should not call any untrusted external contracts to avoid reentrancy\n     */\n    function _executeClaim(address beneficiary, uint256 _totalAmount, bytes memory data) internal virtual returns (uint256) {\n        uint120 totalAmount = uint120(_totalAmount);\n\n        // effects\n        if (records[beneficiary].total != totalAmount) {\n            // re-initialize if the total has been updated\n            _initializeDistributionRecord(beneficiary, totalAmount);\n        }\n\n        uint120 claimableAmount = uint120(getClaimableAmount(beneficiary, data));\n        require(claimableAmount > 0, \"Distributor: no more tokens claimable right now\");\n\n        records[beneficiary].claimed += claimableAmount;\n        claimed += claimableAmount;\n\n        return claimableAmount;\n    }\n\n    /**\n     * @dev Move tokens associated with the claim to the recipient. This function should be called\n     * after the claim has been executed internally to avoid reentrancy issues.\n     * @param _recipient The address of the recipient\n     * @param _amount The amount of tokens to be transferred during this claim\n     */\n    function _settleClaim(address _recipient, uint256 _amount) internal virtual {\n        token.safeTransfer(_recipient, _amount);\n        emit Claim(_recipient, _amount);\n    }\n\n    /// @notice return a distribution record\n    function getDistributionRecord(address beneficiary) external view virtual returns (DistributionRecord memory) {\n        return records[beneficiary];\n    }\n\n    // Get tokens vested as fraction of fractionDenominator\n    function getVestedFraction(address beneficiary, uint256 time, bytes memory data) public view virtual returns (uint256);\n\n    function getFractionDenominator() public view returns (uint256) {\n        return fractionDenominator;\n    }\n\n    // get the number of tokens currently claimable by a specific use\n    function getClaimableAmount(address beneficiary, bytes memory data) public view virtual returns (uint256) {\n        require(records[beneficiary].initialized, \"Distributor: claim not initialized\");\n\n        DistributionRecord memory record = records[beneficiary];\n\n        uint256 claimable = (record.total * getVestedFraction(beneficiary, block.timestamp, data)) / fractionDenominator;\n        return record.claimed >= claimable\n            ? 0 // no more tokens to claim\n            : claimable - record.claimed; // claim all available tokens\n    }\n}"
    },
    {
      "filename": "contracts/packages/hardhat/contracts/claim/factory/DistributorInitializable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport {IDistributor, DistributionRecord} from \"../../interfaces/IDistributor.sol\";\n\n/**\n * @title Distributor\n * @notice Distributes funds to beneficiaries and tracks distribution status\n */\nabstract contract DistributorInitializable is Initializable, IDistributor, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    mapping(address => DistributionRecord) internal records; // track distribution records per user\n    IERC20 public token; // the token being claimed\n    uint256 public total; // total tokens allocated for claims\n    uint256 public claimed; // tokens already claimed\n    string public uri; // ipfs link on distributor info\n    uint256 internal fractionDenominator; // denominator for vesting fraction (e.g. if vested fraction is 100 and fractionDenominator is 10000, 1% of tokens have vested)\n\n    // provide context on the contract name and version\n    function NAME() external view virtual returns (string memory);\n\n    function VERSION() external view virtual returns (uint256);\n\n    function __Distributor_init(IERC20 _token, uint256 _total, string memory _uri, uint256 _fractionDenominator)\n        internal\n        onlyInitializing\n    {\n        require(address(_token) != address(0), \"Distributor: token is address(0)\");\n        require(_total > 0, \"Distributor: total is 0\");\n\n        token = _token;\n        total = _total;\n        uri = _uri;\n        fractionDenominator = _fractionDenominator;\n        emit InitializeDistributor(token, total, uri, fractionDenominator);\n    }\n\n    /**\n     * @dev Set up the distribution record for a user. Permissions are not checked in this function.\n     * Amount is limited to type(uint120).max to allow each DistributionRecord to be packed into a single storage slot.\n     *\n     * @param beneficiary The address of the beneficiary\n     * @param _totalAmount The total amount of tokens to be distributed to the beneficiary\n     */\n    function _initializeDistributionRecord(address beneficiary, uint256 _totalAmount) internal virtual {\n        // Checks\n        require(_totalAmount <= type(uint120).max, \"Distributor: totalAmount > type(uint120).max\");\n        uint120 totalAmount = uint120(_totalAmount);\n\n        // Effects - note that the existing claimed quantity is re-used during re-initialization\n        records[beneficiary] = DistributionRecord(true, totalAmount, records[beneficiary].claimed);\n        emit InitializeDistributionRecord(beneficiary, totalAmount);\n    }\n\n    /**\n     * @notice Record the claim internally:\n     * @dev This function does not check permissions: caller must verify the claim is valid!\n     * this function should not call any untrusted external contracts to avoid reentrancy\n     */\n    function _executeClaim(address beneficiary, uint256 _totalAmount, bytes memory data) internal virtual returns (uint256) {\n        uint120 totalAmount = uint120(_totalAmount);\n\n        // effects\n        if (records[beneficiary].total != totalAmount) {\n            // re-initialize if the total has been updated\n            _initializeDistributionRecord(beneficiary, totalAmount);\n        }\n\n        uint120 claimableAmount = uint120(getClaimableAmount(beneficiary, data));\n        require(claimableAmount > 0, \"Distributor: no more tokens claimable right now\");\n\n        records[beneficiary].claimed += claimableAmount;\n        claimed += claimableAmount;\n\n        return claimableAmount;\n    }\n\n    /**\n     * @dev Move tokens associated with the claim to the recipient. This function should be called\n     * after the claim has been executed internally to avoid reentrancy issues.\n     * @param _recipient The address of the recipient\n     * @param _amount The amount of tokens to be transferred during this claim\n     */\n    function _settleClaim(address _recipient, uint256 _amount) internal virtual {\n        token.safeTransfer(_recipient, _amount);\n        emit Claim(_recipient, _amount);\n    }\n\n    /// @notice return a distribution record\n    function getDistributionRecord(address beneficiary) external view virtual returns (DistributionRecord memory) {\n        return records[beneficiary];\n    }\n\n    // Get tokens vested as fraction of fractionDenominator\n    function getVestedFraction(address beneficiary, uint256 time, bytes memory data) public view virtual returns (uint256);\n\n    function getFractionDenominator() public view returns (uint256) {\n        return fractionDenominator;\n    }\n\n    // get the number of tokens currently claimable by a specific use\n    function getClaimableAmount(address beneficiary, bytes memory data) public view virtual returns (uint256) {\n        require(records[beneficiary].initialized, \"Distributor: claim not initialized\");\n\n        DistributionRecord memory record = records[beneficiary];\n\n        uint256 claimable = (record.total * getVestedFraction(beneficiary, block.timestamp, data)) / fractionDenominator;\n        return record.claimed >= claimable\n            ? 0 // no more tokens to claim\n            : claimable - record.claimed; // claim all available tokens\n    }\n}"
    },
    {
      "filename": "contracts/packages/hardhat/contracts/claim/factory/PerAddressContinuousVestingInitializable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./AdvancedDistributorInitializable.sol\";\n\nabstract contract PerAddressContinuousVestingInitializable is Initializable, AdvancedDistributorInitializable {\n    function __ContinuousVesting_init(\n        IERC20 _token,\n        uint256 _total,\n        string memory _uri,\n        uint160 _maxDelayTime,\n        uint160 _salt,\n        address _owner\n    ) internal onlyInitializing {\n        __AdvancedDistributor_init(\n            _token,\n            _total,\n            _uri,\n            10000, // 1x voting power\n            10 ** 18, // provides the highest resolution possible for continuous vesting\n            _maxDelayTime,\n            _salt,\n            _owner\n        );\n    }\n\n    function getVestedFraction(\n        address beneficiary,\n        uint256 time, // time is in seconds past the epoch (e.g. block.timestamp)\n        bytes memory data\n    ) public view override returns (uint256) {\n        (uint256 start, uint256 cliff, uint256 end) = abi.decode(data, (uint256, uint256, uint256));\n\n        uint256 delayedTime = time - getFairDelayTime(beneficiary);\n        // no tokens are vested\n        if (delayedTime <= cliff) {\n            return 0;\n        }\n\n        // all tokens are vested\n        if (delayedTime >= end) {\n            return fractionDenominator;\n        }\n\n        // some tokens are vested\n        return (fractionDenominator * (delayedTime - start)) / (end - start);\n    }\n}"
    }
  ]
}