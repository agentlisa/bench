{
  "Title": "M-4: cvgControlTower and veCVG lock timing will be different and lead to yield loss scenarios",
  "Content": "# Issue M-4: cvgControlTower and veCVG lock timing will be different and lead to yield loss scenarios \n\nSource: https://github.com/sherlock-audit/2023-11-convergence-judging/issues/178 \n\n## Found by \n0x52, 0xAlix2, bughuntoor, cergyk, hash\n## Summary\n\nWhen creating a locked CVG position, there are two more or less independent locks that are created. The first is in lockingPositionService and the other is in veCVG. LockingPositionService operates on cycles (which are not finite length) while veCVG always rounds down to the absolute nearest week. The disparity between these two accounting mechanism leads to conflicting scenario that the lock on LockingPositionService can be expired while the lock on veCVG isn't (and vice versa). Additionally tokens with expired locks on LockingPositionService cannot be extended. The result is that the token is expired but can't be withdrawn. The result of this is that the expired token must wait to be unstaked and then restaked, cause loss of user yield and voting power while the token is DOS'd.\n\n## Vulnerability Detail\n\nCycles operate using block.timestamp when setting lastUpdateTime on the new cycle in [L345](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Rewards/CvgRewards.sol#L345). It also requires that at least 7 days has passed since this update to roll the cycle forward in [L205](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Rewards/CvgRewards.sol#L205). The result is that the cycle can never be exactly 7 days long and the start/end of the cycle will constantly fluctuate. \n\nMeanwhile when veCVG is calculating the unlock time it uses the week rounded down as shown in [L328](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Locking/veCVG.vy#L328). \n\nWe can demonstrate with an example:\n\nAssume the first CVG cycle is started at block.timestamp == 1,000,000. This means our first cycle ends at 1,604,800. A user deposits for a single cycle at 1,400,000. A lock is created for cycle 2 which will unlock at 2,209,600. \n\nThe lock on veCVG does not match this though. Instead it's calculation will yield:\n\n    (1,400,000 + 2 * 604,800) / 604,800 = 4\n\n    4 * 604,800 = 2,419,200\n\nAs seen these are mismatched and the token won't be withdrawable until much after it should be due to the check in veCVG [L404](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Locking/veCVG.vy#L404).\n\nThis DOS will prevent the expired lock from being unstaked and restaked which causes loss of yield.\n\nThe opposite issue can also occur. For each cycle that is slightly longer than expected the veCVG lock will become further and further behind the cycle lock on lockingPositionService. This can also cause a dos and yield loss because it could prevent user from extending valid locks due to the checks in [L367](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Locking/veCVG.vy#L367) of veCVG.\n\nAn example of this:\n\nAssume a user locks for 96 weeks (58,060,800). Over the course of that year, it takes an average of 2 hours between the end of each cycle and when the cycle is rolled over. This effectively extends our cycle time from 604,800 to 612,000 (+7200). Now after 95 cycles, the user attempts to increase their lock duration. veCVG and lockingPositionService will now be completely out of sync:\n\nAfter 95 cycles the current time would be:\n\n    612,000 * 95 = 58,140,000\n\nWhereas veCVG lock ended:\n\n    612,000 * 96 = 58,060,800\n\nAccording to veCVG the position was unlocked at 58,060,800 and therefore increasing the lock time will revert due to [L367](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Locking/veCVG.vy#L367)\n\nThe result is another DOS that will cause the user loss of yield. During this time the user would also be excluded from taking place in any votes since their veCVG lock is expired.\n\n## Impact\n\nUnlock DOS that cause loss of yield to the user\n\n## Code Snippet\n\n[CvgRewards.sol#L341-L349](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Rewards/CvgRewards.sol#L341-L349)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI would recommend against using block.timestamp for CVG cycles, instead using an absolute measurement like veCVG uses.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/126",
  "Code": [
    {
      "filename": "sherlock-cvg/contracts/Rewards/CvgRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\n/**\n _____\n/  __ \\\n| /  \\/ ___  _ ____   _____ _ __ __ _  ___ _ __   ___ ___\n| |    / _ \\| '_ \\ \\ / / _ \\ '__/ _` |/ _ \\ '_ \\ / __/ _ \\\n| \\__/\\ (_) | | | \\ V /  __/ | | (_| |  __/ | | | (_|  __/\n \\____/\\___/|_| |_|\\_/ \\___|_|  \\__, |\\___|_| |_|\\___\\___|\n                                 __/ |\n                                |___/\n */\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ICvgControlTower.sol\";\nimport \"../interfaces/ICvgAssetStaking.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\n/// @title Cvg-Finance - CvgRewards\n/// @notice Distribute rewards among staking contracts\n/// @dev The function in charge of distributing CVG rewards is following th estate machine pattern\ncontract CvgRewards is Ownable2StepUpgradeable {\n    enum State {\n        CHECKPOINT,\n        LOCK_TOTAL_WEIGHT,\n        DISTRIBUTE,\n        CONTROL_TOWER_SYNC\n    }\n\n    struct InflationInfo {\n        address gauge;\n        uint256 cvgDistributed;\n        uint256 gaugeWeight;\n    }\n\n    struct CvgRewardsConfig {\n        uint88 maxChunkCheckpoint;\n        uint88 maxLoopSetTotalWeight;\n        uint80 maxChunkDistribute;\n    }\n\n    event Checkpoints(uint256 cvgCycle);\n    event SetTotalWeight(uint256 cvgCycle, uint256 totalWeight);\n    event EventChunkWriteStakingRewards(uint256 cvgCycle, uint256 totalGaugeWeight, InflationInfo[] inflationInfos);\n    event InflationAdjustment(uint256 indexed cycleId, uint256 adjustment);\n    event StakingDistribution(uint256 indexed cycleId, address indexed gaugeAddress, uint256 amount);\n\n    /// @dev 60,576.46 CVG distributed each cycle on the first 105 cycles\n    uint256 public constant INITIAL_CYCLE_INFLATION = 60576923076923076923076;\n\n    /// @dev On cycle 1041, inflation doesn't reduce anymore\n    uint256 public constant END_INFLATION_CYCLE = 1041;\n\n    /// @dev After the 1561 cycle, 923.2354137 CVG are distributed by cycle\n    uint256 public constant END_INFLATION_AMOUNT = 1893028846153846164575;\n\n    /// @dev approximation value for square root of 2\n    uint256 private constant SQRT_2 = 1414213562373095048;\n\n    /// @dev each 105 cycles, inflation is reduced by SRQT2\n    uint256 private constant INFLATION_CHANGE_INTERVAL_CYCLE = 105;\n\n    /// @dev convergence ecosystem address\n    ICvgControlTower public cvgControlTower;\n\n    /// @dev Percentage of CVG to distribute weekly. Can be between 80% and 120% of the planned inflation.\n    ///      This can be used to augment or reduce the APR in CVG after votes from the DAO.\n    uint256 public inflationRatio;\n\n    /// @dev current rewards distribution state\n    State public state;\n\n    /// @dev current cursor, used to determine the starting index of the next chunk\n    uint128 public cursor;\n\n    /// @dev timestamp corresponding to the last update of the cvg cycle\n    uint256 public lastUpdatedTimestamp;\n\n    /// @dev sum of all gauges weight excluding killed ones\n    /// @dev this is reset and incremented at each cycle during the LOCK_TOTAL_WEIGHT step\n    uint256 public totalWeightLocked;\n\n    /// @dev configuration of the distribution process, contains chunks length to process\n    CvgRewardsConfig public cvgRewardsConfig;\n\n    /// @dev array containing the addresses of all gauges\n    address[] public gauges;\n\n    /// @dev mapping containing the ID of a gauge by its address\n    mapping(address => uint256) public gaugesId; // gauge address => ID\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            CONSTRUCTOR\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(ICvgControlTower _cvgControlTower) external initializer {\n        cvgControlTower = _cvgControlTower;\n        address _treasuryDao = _cvgControlTower.treasuryDao();\n        require(_treasuryDao != address(0), \"TREASURY_DAO_ZERO\");\n        _transferOwnership(_treasuryDao);\n        lastUpdatedTimestamp = block.timestamp;\n        cvgRewardsConfig = CvgRewardsConfig({\n            maxChunkCheckpoint: 50,\n            maxLoopSetTotalWeight: 50,\n            maxChunkDistribute: 50\n        });\n        inflationRatio = 10_000;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        ADMIN FUNCTIONS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /**\n     *  @notice update rewards distribution's configuration of chunks length\n     *  @param newConfig distribution's configuration\n     */\n    function setMaxChunkConfigs(CvgRewardsConfig calldata newConfig) external onlyOwner {\n        cvgRewardsConfig = newConfig;\n    }\n\n    /**\n     *  @notice Add a gauge in the gauge list\n     *  @param gaugeAddress gaugeAddress to add\n     */\n    function addGauge(address gaugeAddress) external {\n        require(address(cvgControlTower.gaugeController()) == msg.sender, \"NOT_GAUGE_CONTROLLER\");\n        gauges.push(gaugeAddress);\n        gaugesId[gaugeAddress] = gauges.length - 1;\n    }\n\n    /**\n     *  @notice Remove a gauge from the array, replace it by the last gauge of the array\n     *  @param gaugeAddress gaugeAddress to remove\n     */\n    function removeGauge(address gaugeAddress) external {\n        require(address(cvgControlTower.gaugeController()) == msg.sender, \"NOT_GAUGE_CONTROLLER\");\n        uint256 idGaugeToRemove = gaugesId[gaugeAddress];\n        address lastGauge = gauges[gauges.length - 1];\n\n        /// @dev replace id of last gauge by deleted one\n        gaugesId[lastGauge] = idGaugeToRemove;\n        /// @dev Set ID of gauge as 0\n        gaugesId[gaugeAddress] = 0;\n\n        /// @dev moove last gauge address to the id of the deleted one\n        gauges[idGaugeToRemove] = lastGauge;\n\n        /// @dev remove last array element\n        gauges.pop();\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        VIEW FUNCTIONS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /**\n     *  @notice Compute the amount of CVG to be distributed through staking gauge contracts.\n                Made by subtracting the lastInflation with the one with the active stakingCycle\n     *  @param stakingCycle uint256\n     */\n    function stakingInflationAtCycle(uint256 stakingCycle) public view returns (uint256) {\n        if (stakingCycle <= 1) return 0;\n        if (stakingCycle >= END_INFLATION_CYCLE) return (END_INFLATION_AMOUNT * inflationRatio) / 10_000;\n\n        uint256 inflationTarget = INITIAL_CYCLE_INFLATION;\n        uint256 inflationCycle = stakingCycle / INFLATION_CHANGE_INTERVAL_CYCLE;\n\n        for (uint256 i; i < inflationCycle; ) {\n            inflationTarget = (inflationTarget * 10 ** 18) / SQRT_2;\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (inflationTarget * inflationRatio) / 10_000;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                    EXTERNAL FUNCTIONS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /// @notice start or continue the rewards distribution process\n    function writeStakingRewards() external {\n        State _state = state;\n        if (_state == State.CHECKPOINT) {\n            _checkpoints();\n        } else if (_state == State.LOCK_TOTAL_WEIGHT) {\n            _setTotalWeight();\n        } else if (_state == State.DISTRIBUTE) {\n            _distributeCvgRewards();\n        } else {\n            _triggerCvgCycle();\n        }\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                    INTERNAL FUNCTIONS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /// @notice Refresh in a chunked way, all gauge weights in GaugeController\n    function _checkpoints() internal {\n        require(lastUpdatedTimestamp + 7 days <= block.timestamp, \"NEED_WAIT_7_DAYS\");\n\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        IGaugeController _gaugeController = _cvgControlTower.gaugeController();\n        uint128 _cursor = cursor;\n        uint128 _totalGaugeNumber = uint128(gauges.length);\n\n        /// @dev if first chunk, to don't break gauges votes if someone votes between 2 writeStakingRewards chunks we need to lock the gauge votes on GaugeController\n        if (_cursor == 0) {\n            /// @dev Lock votes\n            _gaugeController.set_lock(true);\n        }\n\n        /// @dev compute the theoretical end of the chunk\n        uint128 _maxEnd = _cursor + cvgRewardsConfig.maxChunkCheckpoint;\n        /// @dev compute the real end of the chunk regarding the length of the tAssetArray\n        uint128 _endChunk = _maxEnd < _totalGaugeNumber ? _maxEnd : _totalGaugeNumber;\n\n        /// @dev if last chunk of the checkpoint process\n        if (_endChunk == _totalGaugeNumber) {\n            /// @dev reset the cursor to 0 for _setTotalWeight\n            cursor = 0;\n            /// @dev set the step as LOCK_TOTAL_WEIGHT for reward distribution\n            state = State.LOCK_TOTAL_WEIGHT;\n        } else {\n            /// @dev setup the cursor at the index start for the next chunk\n            cursor = _endChunk;\n        }\n\n        /// @dev updates the weight of the chunked gauges\n        _gaugeController.gauge_relative_weight_writes(_getGaugeChunk(_cursor, _endChunk));\n\n        /// @dev emit the event only at the last chunk\n        if (_endChunk == _totalGaugeNumber) {\n            emit Checkpoints(_cvgControlTower.cvgCycle());\n        }\n    }\n\n    /// @notice get the total weight of all gauges excluding killed ones\n    function _setTotalWeight() internal {\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        IGaugeController _gaugeController = _cvgControlTower.gaugeController();\n        uint128 _cursor = cursor;\n        uint128 _totalGaugeNumber = uint128(gauges.length);\n\n        /// @dev compute the theoric end of the chunk\n        uint128 _maxEnd = _cursor + cvgRewardsConfig.maxLoopSetTotalWeight;\n        /// @dev compute the real end of the chunk regarding the length of staking contracts\n        uint128 _endChunk = _maxEnd < _totalGaugeNumber ? _maxEnd : _totalGaugeNumber;\n\n        /// @dev if last chunk of the total weighted locked processs\n        if (_endChunk == _totalGaugeNumber) {\n            /// @dev reset the cursor to 0 for _distributeRewards\n            cursor = 0;\n            /// @dev set the step as DISTRIBUTE for reward distribution\n            state = State.DISTRIBUTE;\n        } else {\n            /// @dev setup the cursor at the index start for the next chunk\n            cursor = _endChunk;\n        }\n\n        totalWeightLocked += _gaugeController.get_gauge_weight_sum(_getGaugeChunk(_cursor, _endChunk));\n\n        /// @dev emit the event only at the last chunk\n        if (_endChunk == _totalGaugeNumber) {\n            emit SetTotalWeight(_cvgControlTower.cvgCycle(), totalWeightLocked);\n        }\n    }\n\n    /**\n     *  @notice Compute the amount of CVG to be distributed through staking gauge contracts.\n     *  Made by getting the inflation of the current CVG cycle and dispersing tokens to staking contracts\n     *  according to the weight of their associated gauge\n     */\n    function _distributeCvgRewards() internal {\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        IGaugeController gaugeController = _cvgControlTower.gaugeController();\n\n        uint256 _cvgCycle = _cvgControlTower.cvgCycle();\n\n        /// @dev number of gauge in GaugeController\n        uint128 _totalGaugeNumber = uint128(gauges.length);\n        uint128 _cursor = cursor;\n\n        uint256 _totalWeight = totalWeightLocked;\n        /// @dev cursor of the end of the actual chunk\n        uint128 cursorEnd = _cursor + cvgRewardsConfig.maxChunkDistribute;\n\n        /// @dev if the new cursor is higher than the number of gauge, cursor become the number of gauge\n        if (cursorEnd > _totalGaugeNumber) {\n            cursorEnd = _totalGaugeNumber;\n        }\n\n        /// @dev reset the cursor if the distribution has been done\n        if (cursorEnd == _totalGaugeNumber) {\n            cursor = 0;\n\n            /// @dev reset the total weight of the gauge\n            totalWeightLocked = 0;\n\n            /// @dev update the states to the control_tower sync\n            state = State.CONTROL_TOWER_SYNC;\n        }\n        /// @dev update the global cursor in order to be taken into account on next chunk\n        else {\n            cursor = cursorEnd;\n        }\n\n        uint256 stakingInflation = stakingInflationAtCycle(_cvgCycle);\n        uint256 cvgDistributed;\n        InflationInfo[] memory inflationInfos = new InflationInfo[](cursorEnd - _cursor);\n        address[] memory addresses = _getGaugeChunk(_cursor, cursorEnd);\n        /// @dev fetch weight of gauge relative to the cursor\n        uint256[] memory gaugeWeights = gaugeController.get_gauge_weights(addresses);\n        for (uint256 i; i < gaugeWeights.length; ) {\n            /// @dev compute the amount of CVG to distribute in the gauge\n            cvgDistributed = (stakingInflation * gaugeWeights[i]) / _totalWeight;\n\n            /// @dev Write the amount of CVG to distribute in the staking contract\n            ICvgAssetStaking(addresses[i]).processStakersRewards(cvgDistributed);\n\n            inflationInfos[i] = InflationInfo({\n                gauge: addresses[i],\n                cvgDistributed: cvgDistributed,\n                gaugeWeight: gaugeWeights[i]\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit EventChunkWriteStakingRewards(_cvgCycle, _totalWeight, inflationInfos);\n    }\n\n    /// @notice Synchronize the Global Cvg Cycle on the CvgControlTower\n    function _triggerCvgCycle() internal {\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        _cvgControlTower.updateCvgCycle();\n        state = State.CHECKPOINT;\n        lastUpdatedTimestamp = block.timestamp;\n\n        /// @dev unlock the votes after that distribution is done\n        _cvgControlTower.gaugeController().set_lock(false);\n    }\n\n    function _getGaugeChunk(uint256 from, uint256 to) internal view returns (address[] memory) {\n        address[] memory chunk = new address[](to - from);\n        for (uint256 i = from; i < to; ) {\n            chunk[i - from] = gauges[i];\n            unchecked {\n                ++i;\n            }\n        }\n        return chunk;\n    }\n\n    struct GaugeView {\n        string symbol;\n        address stakingAddress;\n        uint256 weight;\n        uint256 typeWeight;\n        int128 gaugeType;\n    }\n\n    /**\n     * @notice get the total number of gauges\n     * @return number of gauges\n     */\n    function gaugesLength() external view returns (uint256) {\n        return gauges.length;\n    }\n\n    /**\n     * @notice get a list of gauges with pagination\n     * @param from beginning of the pagination\n     * @param to end of the pagination\n     * @return array containing gauges information\n     */\n    function getGaugeChunk(uint256 from, uint256 to) external view returns (GaugeView[] memory) {\n        uint256 _gaugesLength = gauges.length;\n        address[] memory chunk = _getGaugeChunk(from, to > _gaugesLength ? _gaugesLength : to);\n        uint256 chunkLength = chunk.length;\n        IGaugeController.WeightType[] memory votes = cvgControlTower.gaugeController().get_gauge_weights_and_types(\n            chunk\n        );\n\n        GaugeView[] memory gaugesView = new GaugeView[](chunkLength);\n        for (uint256 i; i < chunk.length; ) {\n            gaugesView[i] = GaugeView({\n                symbol: ICvgAssetStaking(chunk[i]).symbol(),\n                stakingAddress: chunk[i],\n                weight: votes[i].weight,\n                gaugeType: votes[i].gauge_type,\n                typeWeight: votes[i].type_weight\n            });\n            unchecked {\n                ++i;\n            }\n        }\n        return gaugesView;\n    }\n\n    /**\n     * @notice Set up the inflation ratio of the staking inflation.\n     *         Callable only by the DAO.\n     * @param _inflationRatio New inflation ratio, between 80% and 120%.\n     */\n    function setInflationRatio(uint256 _inflationRatio) external onlyOwner {\n        require(_inflationRatio >= 8_000 && _inflationRatio <= 12_000, \"RATIO_OUT_OF_RANGE\");\n        inflationRatio = _inflationRatio;\n    }\n}"
    },
    {
      "filename": "sherlock-cvg/contracts/Locking/veCVG.vy",
      "content": "# @version 0.3.7\n\"\"\"\n@title Cvg-Finance - veCVG\n@notice Votes have a weight depending on time, so that users are committed to the future of (whatever they are voting for).\n@dev Vote weight decays linearly over time. Lock time cannot be more than `MAXTIME` (1.8 years).\n\"\"\"\n\n# Adpated fork from: Curve Finance's veCrv\n# Many thanks to Curve Finance\n\n# VotingPowerEscow to have time-weighted votes\n# Votes have a weight depending on time, so that users are committed\n# to the future of (whatever they are voting for).\n# The weight in this implementation is linear, and lock cannot be more than maxtime:\n# w ^\n# 1 +        /\n#   |      /\n#   |    /\n#   |  /\n#   |/\n# 0 +--------+------> time\n#       maxtime (1.8 years?)\n\nstruct Point:\n    bias: int128\n    slope: int128  # - dweight / dt\n    ts: uint256\n    blk: uint256  # block\n# We cannot really do block numbers per se b/c slope is per time, not per block\n# and per block could be fairly bad b/c Ethereum changes blocktimes.\n# What we can do is to extrapolate ***At functions\n\nstruct LockedBalance:\n    amount: int128\n    end: uint256\n\ninterface CvgControlTower:\n    def lockingPositionService() -> address: view\n    def treasuryDao() -> address:view\n\nDEPOSIT_FOR_TYPE: constant(int128) = 0\nCREATE_LOCK_TYPE: constant(int128) = 1\nINCREASE_LOCK_AMOUNT: constant(int128) = 2\nINCREASE_UNLOCK_TIME: constant(int128) = 3 # to be removed unless we implement the increasing of lock time\n\n\nevent CommitOwnership:\n    admin: address\n\nevent ApplyOwnership:\n    admin: address\n\nevent Deposit:\n    provider: indexed(uint256)\n    value: uint256\n    locktime: indexed(uint256)\n    type: int128\n    ts: uint256\n\nevent Withdraw:\n    provider: indexed(uint256)\n    value: uint256\n    ts: uint256\n\nevent Supply:\n    prevSupply: uint256\n    supply: uint256\n\n\nWEEK: constant(uint256) = 7 * 86400  # all future times are rounded by week\nMAXTIME: constant(uint256) = 97 * WEEK  \nMULTIPLIER: constant(uint256) = 10 ** 18\n\ncvg_control_tower: public(address)\nsupply: public(uint256)\nlocked: public(HashMap[uint256, LockedBalance]) # Locked balance of the NFT\n\nepoch: public(uint256)\npoint_history: public(Point[100000000000000000000000000000])  # epoch -> unsigned point\nnft_point_history: public(HashMap[uint256, Point[1000000000]])  # tokenId -> Point[user_epoch]\nnft_point_epoch: public(HashMap[uint256, uint256])\nslope_changes: public(HashMap[uint256, int128])  # time -> signed slope change\n\nname: public(String[64])\nsymbol: public(String[32])\nversion: public(String[32])\ndecimals: public(uint256)\n\nadmin: public(address)  # Can and will be a smart contract\nfuture_admin: public(address)\n\ninitialized: public(bool)\n\n@external\ndef __init__():\n    \"\"\"\n    @notice Contract constructor.\n    @dev The contract has an initializer to prevent the take over of the implementation.\n    \"\"\"\n    assert self.initialized == False, \"ALREADY_INIT\" #dev: contract is already initialized\n    self.initialized = True\n\n@external\ndef initialize(_cvg_control_tower: address, _name: String[64], _symbol: String[32], _version: String[32]):\n    \"\"\"\n    @notice Contract constructor.\n    @param _cvg_control_tower address\n    @param _name Token name\n    @param _symbol Token symbol\n    \"\"\"\n    assert self.initialized == False, \"ALREADY_INIT\" #dev: contract is already initialized\n    self.initialized = True\n    self.cvg_control_tower = _cvg_control_tower\n    self.point_history[0].blk = block.number\n    self.point_history[0].ts = block.timestamp\n\n    self.decimals = 18\n    self.name = _name\n    self.symbol = _symbol\n    self.version = _version\n\n@internal\ndef assert_locking_service_contract(addr: address):\n    \"\"\"\n    @dev Check if the call is the NFT locking service.\n    @param addr Address to be checked\n    \"\"\"\n    assert addr == CvgControlTower(self.cvg_control_tower).lockingPositionService(), \"NOT_LOCKING_SERVICE\" # Not the locking service\n\n\n@external\n@view\ndef get_last_nft_slope(tokenId: uint256) -> int128:\n    \"\"\"\n    @notice Get the most recently recorded rate of voting power decrease for `tokenId`.\n    @param tokenId NFT token Id\n    @return Value of the slope\n    \"\"\"\n    token_epoch: uint256 = self.nft_point_epoch[tokenId]\n    return self.nft_point_history[tokenId][token_epoch].slope\n\n\n@external\n@view\ndef nft_point_history_ts(_tokenId: uint256, _idx: uint256) -> uint256:\n    \"\"\"\n    @notice Get the timestamp for checkpoint `_idx` for `_tokenId`.\n    @param _tokenId NFT token Id\n    @param _idx User epoch number\n    @return Epoch time of the checkpoint\n    \"\"\"\n    return self.nft_point_history[_tokenId][_idx].ts\n\n\n@external\n@view\ndef locked__end(_tokenId: uint256) -> uint256:\n    \"\"\"\n    @notice Get timestamp when `_tokenId`'s lock finishes.\n    @param _tokenId NFT token Id\n    @return Epoch time of the lock end\n    \"\"\"\n    return self.locked[_tokenId].end\n\n\n@internal\ndef _checkpoint(tokenId: uint256, old_locked: LockedBalance, new_locked: LockedBalance):\n    \"\"\"\n    @dev Record global and per-user data to checkpoint.\n    @param tokenId of the NFT that embed the locking position\n    @param old_locked Pevious locked amount / end lock time for the user\n    @param new_locked New locked amount / end lock time for the user\n    \"\"\"\n    tokenId_old: Point = empty(Point)\n    tokenId_new: Point = empty(Point)\n    old_dslope: int128 = 0\n    new_dslope: int128 = 0\n    _epoch: uint256 = self.epoch\n\n    if tokenId != 0:\n        # Calculate slopes and biases\n        # Kept at zero when they have to\n        if old_locked.end > block.timestamp and old_locked.amount > 0:\n            tokenId_old.slope = old_locked.amount / convert(MAXTIME, int128)\n            tokenId_old.bias = tokenId_old.slope * convert(old_locked.end - block.timestamp, int128)\n        if new_locked.end > block.timestamp and new_locked.amount > 0:\n            tokenId_new.slope = new_locked.amount / convert(MAXTIME, int128)\n            tokenId_new.bias = tokenId_new.slope * convert(new_locked.end - block.timestamp, int128)\n\n        # Read values of scheduled changes in the slope\n        # old_locked.end can be in the past and in the future\n        # new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\n        old_dslope = self.slope_changes[old_locked.end]\n        if new_locked.end != 0:\n            if new_locked.end == old_locked.end:\n                new_dslope = old_dslope\n            else:\n                new_dslope = self.slope_changes[new_locked.end]\n\n    last_point: Point = Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number})\n    if _epoch > 0:\n        last_point = self.point_history[_epoch]\n    last_checkpoint: uint256 = last_point.ts\n    # initial_last_point is used for extrapolation to calculate block number\n    # (approximately, for *At methods) and save them\n    # as we cannot figure that out exactly from inside the contract\n    initial_last_point: Point = last_point\n    block_slope: uint256 = 0  # dblock/dt\n    if block.timestamp > last_point.ts:\n        block_slope = MULTIPLIER * (block.number - last_point.blk) / (block.timestamp - last_point.ts)\n    # If last point is already recorded in this block, slope=0\n    # But that's ok b/c we know the block in such case\n\n    # Go over weeks to fill history and calculate what the current point is\n    t_i: uint256 = (last_checkpoint / WEEK) * WEEK\n    for i in range(255):\n        # Hopefully it won't happen that this won't get used in 5 years!\n        # If it does, users will be able to withdraw but vote weight will be broken\n        t_i += WEEK\n        d_slope: int128 = 0\n        if t_i > block.timestamp:\n            t_i = block.timestamp\n        else:\n            d_slope = self.slope_changes[t_i]\n        last_point.bias -= last_point.slope * convert(t_i - last_checkpoint, int128)\n        last_point.slope += d_slope\n        if last_point.bias < 0:  # This can happen\n            last_point.bias = 0\n        if last_point.slope < 0:  # This cannot happen - just in case\n            last_point.slope = 0\n        last_checkpoint = t_i\n        last_point.ts = t_i\n        last_point.blk = initial_last_point.blk + block_slope * (t_i - initial_last_point.ts) / MULTIPLIER\n        _epoch += 1\n        if t_i == block.timestamp:\n            last_point.blk = block.number\n            break\n        else:\n            self.point_history[_epoch] = last_point\n\n    self.epoch = _epoch\n    # Now point_history is filled until t=now\n    if tokenId != 0:\n        # If last point was in this block, the slope change has been applied already\n        # But in such case we have 0 slope(s)\n        last_point.slope += (tokenId_new.slope - tokenId_old.slope)\n        last_point.bias += (tokenId_new.bias - tokenId_old.bias)\n        if last_point.slope < 0:\n            last_point.slope = 0\n        if last_point.bias < 0:\n            last_point.bias = 0\n\n    # Record the changed point into history\n    self.point_history[_epoch] = last_point\n\n    if tokenId != 0:\n        # Schedule the slope changes (slope is going down)\n        # We subtract new_tokeId_slope from [new_locked.end]\n        # and tokenId old_tokenId_slope to [old_locked.end]\n        if old_locked.end > block.timestamp:\n            # old_dslope was <something> - tokenId_old.slope, so we cancel that\n            old_dslope += tokenId_old.slope\n            if new_locked.end == old_locked.end:\n                old_dslope -= tokenId_new.slope  # It was a new deposit, not extension\n            self.slope_changes[old_locked.end] = old_dslope\n\n        if new_locked.end > block.timestamp:\n            if new_locked.end > old_locked.end:\n                new_dslope -= tokenId_new.slope  # old slope disappeared at this point\n                self.slope_changes[new_locked.end] = new_dslope\n            # else: we recorded it already in old_dslope\n\n        # Now handle user history\n        nft_epoch: uint256 = self.nft_point_epoch[tokenId] + 1\n\n        self.nft_point_epoch[tokenId] = nft_epoch\n        tokenId_new.ts = block.timestamp\n        tokenId_new.blk = block.number\n        self.nft_point_history[tokenId][nft_epoch] = tokenId_new\n\n\n@internal\ndef _deposit_for(_tokenId: uint256, _value: uint256, unlock_time: uint256, locked_balance: LockedBalance, type: int128):\n    \"\"\"\n    @dev Deposit and lock tokens for a user.\n    @param _tokenId of the NFT\n    @param _value Amount to deposit\n    @param unlock_time New time when to unlock the tokens, or 0 if unchanged\n    @param locked_balance Previous locked amount / timestamp\n    \"\"\"\n    _locked: LockedBalance = locked_balance\n    supply_before: uint256 = self.supply\n\n    self.supply = supply_before + _value\n    old_locked: LockedBalance = _locked\n    # Adding to existing lock, or if a lock is expired - creating a new one\n    _locked.amount += convert(_value, int128)\n    if unlock_time != 0:\n        _locked.end = unlock_time\n    self.locked[_tokenId] = _locked\n\n    # Possibilities:\n    # Both old_locked.end could be current or expired (>/< block.timestamp)\n    # value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n    # _locked.end > block.timestamp (always)\n    self._checkpoint(_tokenId, old_locked, _locked)\n\n    log Deposit(_tokenId, _value, _locked.end, type, block.timestamp)\n    log Supply(supply_before, supply_before + _value)\n\n\n@external\ndef checkpoint():\n    \"\"\"\n    @notice Record global data to checkpoint.\n    \"\"\"\n    self._checkpoint(0, empty(LockedBalance), empty(LockedBalance))\n\n@external\n@nonreentrant('lock')\ndef create_lock(_tokenId: uint256, _value: uint256, _unlock_time: uint256):\n    \"\"\"\n    @notice Deposit `_value` tokens for `msg.sender` and lock until `_unlock_time`.\n    @param _value Amount to deposit\n    @param _unlock_time Epoch time when tokens unlock, rounded down to whole weeks\n    \"\"\"\n    self.assert_locking_service_contract(msg.sender)\n    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\n    _locked: LockedBalance = self.locked[_tokenId]\n\n    assert _value > 0  # dev: need non-zero value\n    assert _locked.amount == 0, \"Withdraw old tokens first\"\n    assert unlock_time > block.timestamp, \"Can only lock until time in the future\"\n    assert unlock_time <= block.timestamp + MAXTIME, \"Voting lock can be 1.8 years max\" # 1 week buffer to take in account the time we can take after 1 week to update the cycle\n\n    self._deposit_for(_tokenId, _value, unlock_time, _locked, CREATE_LOCK_TYPE)\n\n\n@external\n@nonreentrant('lock')\ndef increase_amount(_tokenId: uint256, _value: uint256):\n    \"\"\"\n    @notice Deposit `_value` additional tokens for `msg.sender`.\n            without modifying the unlock time\n    @param _value Amount of tokens to deposit and add to the lock\n    \"\"\"\n    self.assert_locking_service_contract(msg.sender)\n    _locked: LockedBalance = self.locked[_tokenId]\n\n    assert _value > 0  # dev: need non-zero value\n    assert _locked.amount > 0, \"No existing lock found\"\n    assert _locked.end > block.timestamp, \"Cannot add to expired lock. Withdraw\"\n\n    self._deposit_for(_tokenId, _value, 0, _locked, INCREASE_LOCK_AMOUNT)\n\n@external\n@nonreentrant('lock')\ndef increase_unlock_time(_tokenId: uint256, _unlock_time: uint256):\n    \"\"\"\n    @notice Extend the unlock time for `msg.sender` to `_unlock_time`.\n    @param _unlock_time New epoch time for unlocking\n    \"\"\"\n    self.assert_locking_service_contract(msg.sender)\n    _locked: LockedBalance = self.locked[_tokenId]\n    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\n\n    assert _locked.end > block.timestamp, \"Lock expired\"\n    assert _locked.amount > 0, \"Nothing is locked\"\n    assert unlock_time > _locked.end, \"Can only increase lock duration\"\n    assert unlock_time <= block.timestamp + MAXTIME, \"Voting lock can be 1.8 years max\" # 1 week buffer to take in account the time we can take after 1 week to update the cycle\n\n    self._deposit_for(_tokenId, 0, unlock_time, _locked, INCREASE_UNLOCK_TIME)\n\n@external\n@nonreentrant('lock')\ndef increase_unlock_time_and_amount(_tokenId: uint256, _unlock_time: uint256, _value: uint256):\n    \"\"\"\n    @notice Extend the unlock time for `msg.sender` to `_unlock_time` and then the amount of Locked CVG\n    @param _unlock_time New epoch time for unlocking\n    @param _value Amount of CVG to add in the lock\n    \"\"\"\n    self.assert_locking_service_contract(msg.sender)\n    _locked: LockedBalance = self.locked[_tokenId]\n    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\n\n    assert _value > 0  # dev: need non-zero value\n    assert _locked.end > block.timestamp, \"Lock expired\"\n    assert _locked.amount > 0, \"Nothing is locked\"\n    assert unlock_time > _locked.end, \"Can only increase lock duration\"\n    assert unlock_time <= block.timestamp + MAXTIME, \"Voting lock can be 1.8 years max\" # 1 week buffer to take in account the time we can take after 1 week to update the cycle\n\n    self._deposit_for(_tokenId, 0, unlock_time, _locked, INCREASE_UNLOCK_TIME)\n    self._deposit_for(_tokenId, _value, 0, self.locked[_tokenId], INCREASE_LOCK_AMOUNT)\n\n@external\n@nonreentrant('lock')\ndef withdraw(_tokenId: uint256):\n    \"\"\"\n    @notice Withdraw all tokens for `msg.sender`.\n    @dev Only possible if the lock has expired.\n    \"\"\"\n    self.assert_locking_service_contract(msg.sender)\n    _locked: LockedBalance = self.locked[_tokenId]\n    assert block.timestamp >= _locked.end, \"The lock didn't expire\"\n    value: uint256 = convert(_locked.amount, uint256)\n\n    old_locked: LockedBalance = _locked\n    _locked.end = 0\n    _locked.amount = 0\n    self.locked[_tokenId] = _locked\n    supply_before: uint256 = self.supply\n    self.supply = supply_before - value\n\n    # old_locked can have either expired <= timestamp or zero end\n    # _locked has only 0 end\n    # Both can have >= 0 amount\n    self._checkpoint(_tokenId, old_locked, _locked)\n\n    log Withdraw(_tokenId, value, block.timestamp)\n    log Supply(supply_before, supply_before - value)\n\n\n# The following ERC20/minime-compatible methods are not real balanceOf and supply!\n# They measure the weights for the purpose of voting, so they don't represent\n# real coins.\n\n@internal\n@view\ndef find_block_epoch(_block: uint256, max_epoch: uint256) -> uint256:\n    \"\"\"\n    @dev Binary search to estimate timestamp for block number.\n    @param _block Block to find\n    @param max_epoch Don't go beyond this epoch\n    @return Approximate timestamp for block\n    \"\"\""
    }
  ]
}