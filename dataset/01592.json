{
  "Title": "H-3: Rogue validators can manipulate funding rates and profit unfairly from liquidations",
  "Content": "# Issue H-3: Rogue validators can manipulate funding rates and profit unfairly from liquidations \n\nSource: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183 \n\n## Found by \n0x52\n## Summary\n\nValidators are given the exclusive privilege to match. Any validator can abuse this privilege to manipulate funding rates and profit unfairly from liquidations. Normally validators are fully trusted but in the circumstances of these smart contracts and the chain it's deployed on, practically anyone can become a validator and abuse this privilege.\n\n## Vulnerability Detail\n\nConsider the following attack vectors:\n\n1) Profiting unfairly from liquidation. Assume the current mark price for WETH is 2000. A user is liquidated and 100 ETH needs to be sold. Assume there are available orders that can match this liquidation at 2000. Instead of matching it directly, the validator can create his own order at 1980 and match the liquidation to his own order. He can then immediately sell and match with the other available orders for a profit of 2,000 (20 * 100) USDC.\n\n2) Manipulation of funding rate. Validators are allowed to match non-liquidation orders at up to 20% spread from the oracle. This makes it incredibly easy for validators to manipulate the markPriceTwap. By creating and matching tiny orders at the extremes of this spread they can dramatically skew the funding rate it whatever way they please. Max funding rates can liquidate leveraged positions very quickly allowing that validator to further profit from their liquidations.\n\nNow we can discuss how just about anyone can become a validator and abuse this privilege with zero consequences.\n\nFirst we need to consider the typical methodology for ensuring validators behave and why NONE of those factors apply in this scenario. 1) \"Slash validators that misbehave.\" Hubble mainnet is a fork of the AVAX C-Chain which is different from most chains in the fact that **[AVAX validators can't be slashed](https://docs.cloud.coinbase.com/delegation/docs/avalanche-faq#what-are-the-risks-associated-with-delegating)**. 2) \"Validators are forced to hold a volatile protocol token that would depreciate if they are publicly observed misbehaving.\" On Hubble mainnet the gas token is USDC so it would not depreciate in the event that validators misbehave. 3) \"Blocks that break consensus rules are rejected.\" The Hubble exchange smart contracts are not part of the consensus layer so abusing validator privilege as described aren't breaking any consensus rules and would therefore be accepted by honest validators.\n\nSecond we consider the ease of becoming a validator. Hubble mainnet is a fork of AVAX and uses it's same consensus mechanism. This allows any node who posts the required stake to become a validator for the network. This allows anyone with access to any decent level of capital to become a validator and begin exploiting users. \n\n## Impact\n\nValidators can manipulate funding rates and profit unfairly from liquidations\n\n## Code Snippet\n\n[OrderBook.sol#L215-L258](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/orderbooks/OrderBook.sol#L215-L258)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe methodology of order matching needs to be rethought to force validators to match fairly and efficiently \n\n\n\n## Discussion\n\n**asquare08**\n\nWe will fix this with post-mainnet releases. Initially, we are launching with a trusted, closed set of validators and will fix this before we open for public validators. \nRemarks about point 2. Manipulation of funding rate - for this to happen, a validator will need to place and execute orders for a fairly large amount of time if there are other trades in the system. So this scenario can happen in case of low liquidity in the system. \n\n**P12473**\n\nEscalate\n\nThis should not be a high because validators in hubble are [decided by the governance](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/orderbooks/OrderBook.sol#L533-L535) which is different from the validators who secure the hubble network.\n\nFor this exploit to occur, an existing validator needs to be compromised or a rogue validator added by manipulating the governance vote. Moreover, this attack assumes that there is only 1 validator when there can be multiple non rogue validators matching orders as well.\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This should not be a high because validators in hubble are [decided by the governance](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/orderbooks/OrderBook.sol#L533-L535) which is different from the validators who secure the hubble network.\n> \n> For this exploit to occur, an existing validator needs to be compromised or a rogue validator added by manipulating the governance vote. Moreover, this attack assumes that there is only 1 validator when there can be multiple non rogue validators matching orders as well.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**djb15**\n\nI agree with this escalation. Regarding the manipulation of the funding rate see https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/100#issuecomment-1640389572 which is acknowledged as a low severity issue because you just need 1 non-malicious validator. I believe the same is true for this report where one non malicious validator would prevent the funding rate being manipulated over a significant period of time (in normal market conditions).\n\nEDIT: See https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/87#issuecomment-1644045278 for some related justification \n\n**ctf-sec**\n\nIn the part funding manipulation yes\n\nbut the attacker vector does not require all validator to be malicious, one malicious validator can do this and extract value from user.\n\n> Profiting unfairly from liquidation. Assume the current mark price for WETH is 2000. A user is liquidated and 100 ETH needs to be sold. Assume there are available orders that can match this liquidation at 2000. Instead of matching it directly, the validator can create his own order at 1980 and match the liquidation to his own order. He can then immediately sell and match with the other available orders for a profit of 2,000 (20 * 100) USDC.\n\nRecommend maintaining high severity\n\n**djb15**\n\nThat's a fair point, I've found the following quote from the sponsor in the discord channel (https://discord.com/channels/812037309376495636/1121092175216787507/1126818439646957628):\n\n> So, in that sense and from the perspective of the smart contract audit, validators are not trusted.\n\nSo I agree the \"profit unfairly from liquidations\" part of this report is probably a valid high as I agree you only need 1 malicious validator. But the \"manipulating funding rates part\" is probably a medium as you would need either lots of malicious validators in normal market conditions or 1 malicious validator in low liquidity market conditions. So high overall :D\n\n**IAm0x52**\n\nThe validators aren't different, they are the same. The concept that governance would restrict validators to a trusted set is new information that was never present in any of the docs or readme during the contest. All information indicated that validators would be open and decentralized. Based on that information anyone could be a validator which is why I think this should remain as a high risk issue.\n\n#87 should not be a dupe of this issue. Realistically I shouldn't have submitted this as a single issue and should have submitted it as two. One for liquidation manipulation and the other for the funding rate manipulation. Since a single issue can't be a dupe of two different issues, this should remain a separate issue.\n\n**P12473**\n\n> The validators aren't different, they are the same.\n\nIf they are the same and any validators of the network can participate in matching orders, then why was this information not communicated to us on the docs or the README?\n\nCan you please show me an example of a smart contract on AVAX C-Chain with a protected \"validator\" role in the smart contract and yet any of the validators of AVAX consensus layer can pass that check.\n\nMore generally, should vulnerabilities regarding information that was not communicated to us be also considered valid? This encompasses literally everything, and you start to go into the world of crazy hypothetical what-ifs. @hrishibhat \n\n> All information indicated that validators would be open and decentralized. \n\nThe README clearly states that there is a governance role which is a TRUSTED role. All actions of a trusted role should be trusted hence one would assume that who the governance selects as validators are to be trusted.\n\nIf this premise is wrong, then one can go so far as to generalise that all privileged roles cannot be trusted because there is a non-zero chance that they will go rogue / fall in the hands of the wrong people.\n\n> Realistically I shouldn't have submitted this as a single issue and should have submitted it as two. One for liquidation manipulation and the other for the funding rate manipulation.\n\nBoth liquidation manipulation and funding rate manipulation is predicated on the assumption that rogue validators [were selected to match orders by the governance](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/orderbooks/OrderBook.sol#L533-L535).\n\nLiquidation manipulation also assumes that: \n\n1. there are no other honest validators to match this user.\n2. the rogue validator of the smart contract also controls a substantial AVAX stake as a node at the consensus layer in order to ensure that his orders are finalized.\n\nAs described by the sponsor, funding rate manipulation can only occur when there is low liquidity. When there is high liquidity, manipulating the TWAP price will be too expensive just to extract funding from users. In many past contests, a comment like this by the sponsor would immediately invalidate the report.\n\nIt is also by design that if the system has low liquidity, the funding paid by the user will be high. The onus should be on the user to close his position.\n\n> Since a single issue can't be a dupe of two different issues, this should remain a separate issue.\n\nLol I'm gonna start grouping all my issues together too because multiple issues cant be a dup of a single issue. ðŸ¤·ðŸ¼â€â™‚ï¸ \n\n\n**IAm0x52**\n\n> If they are the same and any validators of the network can participate in matching orders, then why was this information not communicated to us on the docs or the README\n\nAll network validators have to be added by governance or else there would be a lot of empty blocks because the unverified block producers wouldn't be able to match any orders. Fundamentally they have to be the same.\n\n> there are no other honest validators to match this user.\n\nThis statement is incorrect. When it is this validator's turn to produce the block they will be able to abuse this.\n\n> the rogue validator of the smart contract also controls a substantial AVAX stake as a node at the consensus layer in order to ensure that his orders are finalized.\n\nAlso incorrect. If you would read my issue, abusing liquidations in this way doesn't break any consensus rules and therefore would be accepted by honest validators.\n\n> Both liquidation manipulation and funding rate manipulation is predicated on the assumption that rogue validators [were selected to match orders by the governance](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/orderbooks/OrderBook.sol#L533-L535).\n\nIncorrect again. Anyone, not just validators, can manipulate funding rate as demonstrated by #87. Hence why this is two separate issues.\n\n> Lol I'm gonna start grouping all my issues together too because multiple issues cant be a dup of a single issue. ðŸ¤·ðŸ¼â€â™‚ï¸\n\nYet another incorrect statement. In this scenario I receive less of the prize pool not more.\n\n**hrishibhat**\n\n@P12473 I think the above [response](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183#issuecomment-1661280730) makes sense. \ndo you have further comments?\n\n**P12473**\n\n> @P12473 I think the above [response](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183#issuecomment-1661280730) makes sense. do you have further comments?\n\nThanks for giving me this opportunity to speak but I do not have any comments.\n\n@IAm0x52 is a much better auditor than I am and it is most likely that I am wrong. I want to understand his perspective but I am unable to do so from his explanation. If you agree with his take then I will rest my case.\n\nI only hope that the decision was an impartial one. Thanks again!\n\n**asquare08**\n\nFor the scope of this audit, validators should not be trusted. However, we'll launch on mainnet with a closed set of trusted validators and plan to open for public validators later.\nSo, point 1 (liquidation) is a valid high issue as it can happen even if 1 validator is malicious and point 2 (funding payment) is a valid medium issue as it can happen only in low liquidity case and will also be costly to do so.\n\n**hrishibhat**\n\nResult:\nHigh\nUnique\nConsidering this issue a valid high based on the discussion above and Sponsor's [comment](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183#issuecomment-1665745210)\n\nAdditionally, the [readme](https://github.com/sherlock-audit/2023-04-hubble-exchange#q-are-there-any-additional-protocol-roles-if-yes-please-explain-in-detail) shared information about the trusted protocol roles were limited to the governance. \nAnd the docs provided context on the validators and their functioning:\nhttps://medium.com/hubbleexchange/introducing-hubble-exchange-a-purpose-built-chain-for-perps-25c60db66d44\nhttps://hubbleexchange.notion.site/Hubble-Exchange-Overview-e9487ec19fe9451c9d445be15978c740\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [p12473](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183/#issuecomment-1642958328): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/72",
  "Code": [
    {
      "filename": "hubble-protocol/contracts/orderbooks/OrderBook.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { ECDSAUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\nimport { EIP712Upgradeable } from \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { VanillaGovernable } from \"../legos/Governable.sol\";\nimport { IClearingHouse, IOrderBook, IAMM, IMarginAccount } from \"../Interfaces.sol\";\nimport { IHubbleBibliophile } from \"../precompiles/IHubbleBibliophile.sol\";\n\n/**\n * @title Takes care of order placement, matching, cancellations and liquidations.\n *        Mostly has only first level checks about validatiy of orders. More deeper checks and interactions happen in ClearingHouse.\n * @notice This contract is used by users to place/cancel orders and by validators to relay matched/liquidation orders\n * @dev At several places we are using something called a bibliophile. This is a special contract (precompile) that is deployed at a specific address.\n * But there is identical code in this contract that can be used as a fallback if the precompile is not available.\n*/\ncontract OrderBook is IOrderBook, VanillaGovernable, Pausable, EIP712Upgradeable {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    // keccak256(\"Order(uint256 ammIndex,address trader,int256 baseAssetQuantity,uint256 price,uint256 salt,bool reduceOnly)\");\n    bytes32 public constant ORDER_TYPEHASH = 0x0a2e4d36552888a97d5a8975ad22b04e90efe5ea0a8abb97691b63b431eb25d2;\n    string constant NOT_IS_MULTIPLE = \"OB.not_multiple\";\n\n    IClearingHouse public immutable clearingHouse;\n    IMarginAccount public immutable marginAccount;\n\n    mapping(bytes32 => OrderInfo) public orderInfo; // SLOT_53 !!! used in precompile !!!\n    mapping(address => bool) public isValidator; // SLOT_54 (not used in precompile)\n\n    /**\n    * @notice maps the address of the trader to the amount of reduceOnlyAmount for each amm\n    * trader => ammIndex => reduceOnlyAmount\n    */\n    mapping(address => mapping(uint => int256)) public reduceOnlyAmount;\n\n    // cache some variables for quick assertions\n    int256[] public minSizes; // min size for each AMM, array index is the ammIndex\n    uint public minAllowableMargin;\n    uint public takerFee;\n    IHubbleBibliophile public bibliophile;\n\n    uint256 public useNewPricingAlgorithm; // declared as uint256 to take 1 full slot\n    uint256[49] private __gap;\n\n    modifier onlyValidator {\n        require(isValidator[msg.sender], \"OB.only_validator\");\n        _;\n    }\n\n    modifier onlyClearingHouse {\n        require(msg.sender == address(clearingHouse), \"OB.only_clearingHouse\");\n        _;\n    }\n\n    constructor(address _clearingHouse, address _marginAccount) {\n        clearingHouse = IClearingHouse(_clearingHouse);\n        marginAccount = IMarginAccount(_marginAccount);\n    }\n\n    function initialize(\n        string memory _name,\n        string memory _version,\n        address _governance\n    ) external initializer {\n        __EIP712_init(_name, _version);\n        _setGovernace(_governance);\n    }\n\n    /* ****************** */\n    /*    Place Orders    */\n    /* ****************** */\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function placeOrder(Order memory order) external {\n        Order[] memory _orders = new Order[](1);\n        _orders[0] = order;\n        placeOrders(_orders);\n    }\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function placeOrders(Order[] memory orders) public whenNotPaused {\n        address trader = orders[0].trader;\n        int[] memory posSizes = _getPositionSizes(trader);\n        uint reserveAmount;\n        for (uint i = 0; i < orders.length; i++) {\n            require(orders[i].trader == trader, \"OB_trader_mismatch\");\n            reserveAmount += _placeOrder(orders[i], posSizes[orders[i].ammIndex]);\n        }\n        if (reserveAmount != 0) {\n            marginAccount.reserveMargin(trader, reserveAmount);\n        }\n    }\n\n    function _getPositionSizes(address trader) internal view returns (int[] memory) {\n        if (address(bibliophile) != address(0)) {\n            // precompile magic allows us to execute this for a fixed gas\n            return bibliophile.getPositionSizes(trader);\n        }\n        // folowing is the fallback code if precompile is not available. Precompile is intended to perform the same computation as the following code\n        uint numAmms = clearingHouse.getAmmsLength();\n        int[] memory posSizes = new int[](numAmms);\n        for (uint i; i < numAmms; ++i) {\n            (posSizes[i],,,) = IAMM(clearingHouse.amms(i)).positions(trader);\n        }\n        return posSizes;\n    }\n\n    /**\n     * @dev has some special handling for reduceOnly orders\n    */\n    function _placeOrder(Order memory order, int size) internal returns (uint reserveAmount) {\n        require(msg.sender == order.trader, \"OB_sender_is_not_trader\");\n\n        // orders should be multiple of pre-defined minimum quantity to prevent spam with dust orders\n        require(isMultiple(order.baseAssetQuantity, minSizes[order.ammIndex]), NOT_IS_MULTIPLE);\n\n        bytes32 orderHash = getOrderHash(order);\n        // order should not exist in the orderStatus map already\n        require(orderInfo[orderHash].status == OrderStatus.Invalid, \"OB_Order_already_exists\");\n\n        // reduce only orders should only reduce the position size. They need a bit of special handling.\n        if (order.reduceOnly) {\n            require(isOppositeSign(size, order.baseAssetQuantity), \"OB_reduce_only_order_must_reduce_position\");\n            // track the total size of all the reduceOnly orders for a trader in a particular market\n            reduceOnlyAmount[order.trader][order.ammIndex] += abs(order.baseAssetQuantity);\n            // total size of reduce only orders should not exceed the position size\n            require(abs(size) >= reduceOnlyAmount[order.trader][order.ammIndex], \"OB_reduce_only_amount_exceeded\");\n        } else {\n            /**\n            * Don't allow trade in opposite direction of existing position size if there is a reduceOnly order\n            * in case of liquidation, size == 0 && reduceOnlyAmount != 0 is possible\n            * in that case, we don't not allow placing a new order in any direction, must cancel reduceOnly order first\n            * in normal case, size = 0 => reduceOnlyAmount = 0\n            */\n            if (isOppositeSign(size, order.baseAssetQuantity) || size == 0) {\n                require(reduceOnlyAmount[order.trader][order.ammIndex] == 0, \"OB_cancel_reduce_only_order_first\");\n            }\n            // reserve margin for the order\n            reserveAmount = getRequiredMargin(order.baseAssetQuantity, order.price);\n        }\n\n        // add orderInfo for the corresponding orderHash\n        orderInfo[orderHash] = OrderInfo(block.number, 0, reserveAmount, OrderStatus.Placed);\n        emit OrderPlaced(order.trader, orderHash, order, block.timestamp);\n    }\n\n    /* ****************** */\n    /*    Cancel Orders   */\n    /* ****************** */\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function cancelOrder(Order memory order) override external {\n        Order[] memory _orders = new Order[](1);\n        _orders[0] = order;\n        cancelOrders(_orders);\n    }\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function cancelOrders(Order[] memory orders) override public {\n        address trader = orders[0].trader;\n        uint releaseMargin;\n        for (uint i; i < orders.length; i++) {\n            require(orders[i].trader == trader, \"OB_trader_mismatch\");\n            releaseMargin += _cancelOrder(orders[i]);\n        }\n        if (releaseMargin != 0) {\n            marginAccount.releaseMargin(trader, releaseMargin);\n        }\n    }\n\n    function _cancelOrder(Order memory order) internal returns (uint releaseMargin) {\n        bytes32 orderHash = getOrderHash(order);\n        require(orderInfo[orderHash].status == OrderStatus.Placed, \"OB_Order_does_not_exist\");\n\n        address trader = order.trader;\n        if (msg.sender != trader) {\n            require(isValidator[msg.sender], \"OB_invalid_sender\");\n            // allow cancellation of order by validator if availableMargin < 0\n            // there is more information in the description of the function\n            require(marginAccount.getAvailableMargin(trader) < 0, \"OB_available_margin_not_negative\");\n        }\n\n        orderInfo[orderHash].status = OrderStatus.Cancelled;\n        if (order.reduceOnly) {\n            int unfilledAmount = abs(order.baseAssetQuantity - orderInfo[orderHash].filledAmount);\n            reduceOnlyAmount[trader][order.ammIndex] -= unfilledAmount;\n        } else {\n            releaseMargin = orderInfo[orderHash].reservedMargin;\n        }\n\n        _deleteOrderInfo(orderHash);\n        emit OrderCancelled(trader, orderHash, block.timestamp);\n    }\n\n    /* ****************** */\n    /*    Match Orders    */\n    /* ****************** */\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function executeMatchedOrders(\n        Order[2] memory orders,\n        int256 fillAmount\n    )   override\n        external\n        whenNotPaused\n        onlyValidator\n    {\n        MatchInfo[2] memory matchInfo;\n        matchInfo[0].orderHash = getOrderHash(orders[0]);\n        matchInfo[1].orderHash = getOrderHash(orders[1]);\n\n        uint fillPrice;\n        (fillPrice, matchInfo[0].mode, matchInfo[1].mode) = useNewPricingAlgorithm == 1 ?\n            bibliophile.validateOrdersAndDetermineFillPrice(orders, [matchInfo[0].orderHash, matchInfo[1].orderHash], fillAmount) :\n            // folowing is the fallback code if precompile is not available. Precompile is intended to perform the same computation as the following code\n            _validateOrdersAndDetermineFillPrice(orders, [matchInfo[0].orderHash, matchInfo[1].orderHash], fillAmount);\n\n        try clearingHouse.openComplementaryPositions(orders, matchInfo, fillAmount, fillPrice) returns (uint256 openInterestNotional) {\n            _updateOrder(orders[0], matchInfo[0].orderHash, fillAmount);\n            _updateOrder(orders[1], matchInfo[1].orderHash, -fillAmount);\n            emit OrdersMatched(\n                matchInfo[0].orderHash,\n                matchInfo[1].orderHash,\n                fillAmount.toUint256(), // asserts fillAmount is +ve\n                fillPrice,\n                openInterestNotional,\n                msg.sender, // relayer\n                block.timestamp\n            );\n        } catch Error(string memory err) { // catches errors emitted from \"revert/require\"\n            try this.parseMatchingError(err) returns(bytes32 orderHash, string memory reason) {\n                emit OrderMatchingError(orderHash, reason);\n            } catch (bytes memory) {\n                // abi.decode failed; we bubble up the original err\n                revert(err);\n            }\n            return;\n        }\n        /* catch (bytes memory err) {\n            we do not any special handling for other generic type errors\n            they can revert the entire tx as usual\n        } */\n    }\n\n    /**\n     * @dev validate orders and determines the fill price of the orders being matched\n     * @param orders orders[0] is the long order and orders[1] is the short order\n     * @param orderHashes output of getOrderHash(order)\n     * @param fillAmount Amount of base asset to be traded between the two orders. Should be +ve. Scaled by 1e18\n    */\n    function _validateOrdersAndDetermineFillPrice(\n        Order[2] memory orders,\n        bytes32[2] memory orderHashes,\n        int256 fillAmount\n    )   internal\n        view\n        returns (uint256 fillPrice, OrderExecutionMode mode0, OrderExecutionMode mode1)\n    {\n        // Checks and Effects\n        require(orders[0].baseAssetQuantity > 0, \"OB_order_0_is_not_long\");\n        require(orders[1].baseAssetQuantity < 0, \"OB_order_1_is_not_short\");\n        require(orders[0].ammIndex == orders[1].ammIndex, \"OB_orders_for_different_amms\");\n        require(orders[0].price /* buy */ >= orders[1].price /* sell */, \"OB_orders_do_not_match\");\n        require(orderInfo[orderHashes[0]].status == OrderStatus.Placed, \"OB_invalid_order\");\n        require(orderInfo[orderHashes[1]].status == OrderStatus.Placed, \"OB_invalid_order\");\n\n        // fillAmount should be multiple of min size requirement and fillAmount should be non-zero\n        require(isMultiple(fillAmount, minSizes[orders[0].ammIndex]), NOT_IS_MULTIPLE);\n\n        uint blockPlaced0 = orderInfo[orderHashes[0]].blockPlaced;\n        uint blockPlaced1 = orderInfo[orderHashes[1]].blockPlaced;\n\n        if (blockPlaced0 < blockPlaced1) {\n            mode0 = OrderExecutionMode.Maker;\n            fillPrice = orders[0].price;\n        } else if (blockPlaced0 > blockPlaced1) {\n            mode1 = OrderExecutionMode.Maker;\n            fillPrice = orders[1].price;\n        } else { // both orders are placed in the same block, not possible to determine what came first in solidity\n            // executing both orders as taker order\n            mode0 = OrderExecutionMode.SameBlock;\n            mode1 = OrderExecutionMode.SameBlock;\n            // Bulls (Longs) are our friends. We give them a favorable price in this corner case\n            fillPrice = orders[1].price;\n        }\n        _validateSpread(orders[0].ammIndex, fillPrice, false);\n    }\n\n    /**\n     * @dev Check whether a given price is within a pre-defined % deviation from the index price of the market.\n     * This is to prevent malicious actors from manipulating the price too much\n     * @param ammIndex Market index\n     * @param price chosen fill price\n     * @param isLiquidation whether we should assert for a liquidation match or regular order match, because liquidation has a tigher spread requirement\n    */\n    function _validateSpread(uint ammIndex, uint256 price, bool isLiquidation) internal view {\n        IAMM amm = IAMM(clearingHouse.amms(ammIndex));\n        uint spreadLimit = isLiquidation ? amm.maxLiquidationPriceSpread() : amm.maxOracleSpreadRatio();\n        uint256 oraclePrice = amm.getUnderlyingPrice();\n\n        uint bound = oraclePrice * (1e6 + spreadLimit) / 1e6;\n        require(price <= bound, \"AMM.price_GT_bound\");\n        // if spreadLimit >= 1e6 it means that 100% variation is allowed which means shorts at $0 will also pass.\n        // so we don't need to check for that case\n        if (spreadLimit < 1e6) {\n            bound = oraclePrice * (1e6 - spreadLimit) / 1e6;\n            require(price >= bound, \"AMM.price_LT_bound\");\n        }\n    }\n\n    /* ****************** */\n    /*    Liquidation     */\n    /* ****************** */\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function liquidateAndExecuteOrder(\n        address trader,\n        Order calldata order,\n        uint256 liquidationAmount\n    )   override\n        external\n        whenNotPaused\n        onlyValidator\n    {\n        bytes32 orderHash = getOrderHash(order);\n        require(orderInfo[orderHash].status == OrderStatus.Placed, \"OB_invalid_order\");\n        uint fillPrice = useNewPricingAlgorithm == 1 ?\n            bibliophile.validateLiquidationOrderAndDetermineFillPrice(order, liquidationAmount.toInt256()) :\n            _validateLiquidationOrderAndDetermineFillPrice(order, liquidationAmount.toInt256());\n\n        int256 fillAmount = liquidationAmount.toInt256();\n        if (order.baseAssetQuantity < 0) { // order is short, so short position is being liquidated\n            fillAmount *= -1;\n        }\n\n        MatchInfo memory matchInfo = MatchInfo({\n            orderHash: orderHash,\n            mode: OrderExecutionMode.Maker // execute matching order as maker order\n        });\n\n        try clearingHouse.liquidate(order, matchInfo, fillAmount, fillPrice, trader) returns (uint256 openInterestNotional) {\n            _updateOrder(order, matchInfo.orderHash, fillAmount);\n            emit LiquidationOrderMatched(\n                trader,\n                matchInfo.orderHash,\n                liquidationAmount,\n                order.price,\n                openInterestNotional,\n                msg.sender, // relayer\n                block.timestamp\n            );\n        } catch Error(string memory err) { // catches errors emitted from \"revert/require\"\n            try this.parseMatchingError(err) returns(bytes32 _orderHash, string memory reason) {\n                if (matchInfo.orderHash == _orderHash) { // err in openPosition for the order\n                    emit OrderMatchingError(_orderHash, reason);\n                    reason = \"OrderMatchingError\";\n                } // else err in liquidating the trader; but we emit this either ways so that we can track liquidation didnt succeed for whatever reason\n                emit LiquidationError(trader, _orderHash, reason, liquidationAmount);\n            } catch (bytes memory) {\n                // abi.decode failed; we bubble up the original err\n                revert(err);\n            }\n            return;\n        }\n        /* catch (bytes memory err) {\n            we do not any special handling for other generic type errors\n            they can revert the entire tx as usual\n        } */\n    }\n\n    function _validateLiquidationOrderAndDetermineFillPrice(Order memory order, int256 liquidationAmount) internal view returns(uint256 fillPrice) {\n        // fillAmount should be multiple of min size requirement and fillAmount should be non-zero\n        require(isMultiple(liquidationAmount, minSizes[order.ammIndex]), NOT_IS_MULTIPLE);\n        fillPrice = order.price;\n        _validateSpread(order.ammIndex, fillPrice, true);\n    }\n\n    /* ****************** */\n    /*  Funding Payments  */\n    /* ****************** */\n\n    function settleFunding() external whenNotPaused onlyValidator {\n        clearingHouse.settleFunding();\n    }\n\n    /* ****************** */\n    /*       View         */\n    /* ****************** */\n\n    /**\n     * @dev This is not being utilized in the contract anymore. It is only here for backwards compatibility.\n    */\n    function verifySigner(Order memory order, bytes memory signature) public view returns (address, bytes32) {\n        bytes32 orderHash = getOrderHash(order);\n        address signer = ECDSAUpgradeable.recover(orderHash, signature);\n        require(signer == order.trader, \"OB_SINT\");\n        return (signer, orderHash);\n    }\n\n    function getOrderHash(Order memory order) public view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(abi.encode(ORDER_TYPEHASH, order)));\n    }\n\n    /**\n    * @notice Get the margin required to place an order\n    * @dev includes trade fee (taker fee)\n    */\n    function getRequiredMargin(int256 baseAssetQuantity, uint256 price) public view returns(uint256 requiredMargin) {\n        uint quoteAsset = abs(baseAssetQuantity).toUint256() * price / 1e18;\n        requiredMargin = quoteAsset * minAllowableMargin / 1e6;\n        requiredMargin += quoteAsset * takerFee / 1e6;\n    }\n\n    /* ****************** */\n    /*      Internal      */\n    /* ****************** */\n\n    function _updateOrder(Order memory order, bytes32 orderHash, int256 fillAmount) internal {\n        orderInfo[orderHash].filledAmount += fillAmount;\n\n        // assert that the order is not being overfilled\n        require(abs(orderInfo[orderHash].filledAmount) <= abs(order.baseAssetQuantity), \"OB_filled_amount_higher_than_order_base\");\n\n        // update order status if filled and free up reserved margin\n        if (order.reduceOnly) {\n            // free up the reduceOnly quota\n            reduceOnlyAmount[order.trader][order.ammIndex] -= abs(fillAmount);\n            if (orderInfo[orderHash].filledAmount == order.baseAssetQuantity) {\n                orderInfo[orderHash].status = OrderStatus.Filled;\n                _deleteOrderInfo(orderHash);\n            }\n        } else {\n            uint reservedMargin = orderInfo[orderHash].reservedMargin;\n            if (orderInfo[orderHash].filledAmount == order.baseAssetQuantity) {\n                orderInfo[orderHash].status = OrderStatus.Filled;\n                marginAccount.releaseMargin(order.trader, reservedMargin);\n                _deleteOrderInfo(orderHash);\n            } else {\n                // even though the fill price might be different from the order price;\n                // we use the order price to free up the margin because the order price is the price at which the margin was reserved.\n                uint utilisedMargin = uint(abs(fillAmount)) * reservedMargin / uint(abs(order.baseAssetQuantity));\n                // need to track this so we can free up the margin when the order is fulfilled/cancelled without leaving any dust margin reserved from precision loss from divisions\n                orderInfo[orderHash].reservedMargin -= utilisedMargin;\n                marginAccount.releaseMargin(order.trader, utilisedMargin);\n            }\n        }\n    }\n\n    /**\n    * @notice Deletes everything except status and filledAmount from orderInfo\n    * @dev cannot delete order status because then same order can be placed again\n    */\n    function _deleteOrderInfo(bytes32 orderHash) internal {\n        delete orderInfo[orderHash].blockPlaced;\n        delete orderInfo[orderHash].reservedMargin;\n    }\n\n    /* ****************** */\n    /*        Pure        */\n    /* ****************** */\n\n    function abs(int x) internal pure returns (int) {\n        return x >= 0 ? x : -x;\n    }\n\n    /**\n    * @notice returns true if x and y have opposite signs\n    * @dev it considers 0 to have positive sign\n    */\n    function isOppositeSign(int256 x, int256 y) internal pure returns (bool) {\n        return (x ^ y) < 0;\n    }\n\n    /**\n    * @notice checks `x` is non-zero and whether `x` is multiple of `y`\n    * @dev assumes y is positive\n    * @return `true` if `x` is multiple of `y` and abs(x) >= y\n    */\n    function isMultiple(int256 x, int256 y) internal pure returns (bool) {\n        return (x != 0 && x % y == 0);\n    }\n\n    function parseMatchingError(string memory err) pure public returns(bytes32 orderHash, string memory reason) {\n        (orderHash, reason) = abi.decode(bytes(err), (bytes32, string));\n    }\n\n    /* ****************** */\n    /*   Config Updates   */\n    /* ****************** */\n\n    function initializeMinSize(int minSize) external onlyGovernance {\n        minSizes.push(minSize);\n    }\n\n    function updateMinSize(uint ammIndex, int minSize) external onlyGovernance {\n        minSizes[ammIndex] = minSize;\n    }\n\n    function updateParams(uint _minAllowableMargin, uint _takerFee) external onlyClearingHouse {\n        minAllowableMargin = _minAllowableMargin;\n        takerFee = _takerFee;\n    }\n\n    /* ****************** */\n    /*     Governance     */\n    /* ****************** */\n\n    function pause() external onlyGovernance {\n        _pause();\n    }\n\n    function unpause() external onlyGovernance {\n        _unpause();\n    }\n\n    function setValidatorStatus(address validator, bool status) external onlyGovernance {\n        isValidator[validator] = status;\n    }\n\n    function setBibliophile(address _bibliophile) external onlyGovernance {\n        bibliophile = IHubbleBibliophile(_bibliophile);\n    }\n\n    function setUseNewPricingAlgorithm(bool useNew) external onlyGovernance {\n        if (useNew) {\n            useNewPricingAlgorithm = 1;\n        } else {\n            useNewPricingAlgorithm = 0;\n        }\n    }\n}"
    },
    {
      "filename": "hubble-protocol/contracts/orderbooks/OrderBook.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { ECDSAUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\nimport { EIP712Upgradeable } from \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { VanillaGovernable } from \"../legos/Governable.sol\";\nimport { IClearingHouse, IOrderBook, IAMM, IMarginAccount } from \"../Interfaces.sol\";\nimport { IHubbleBibliophile } from \"../precompiles/IHubbleBibliophile.sol\";\n\n/**\n * @title Takes care of order placement, matching, cancellations and liquidations.\n *        Mostly has only first level checks about validatiy of orders. More deeper checks and interactions happen in ClearingHouse.\n * @notice This contract is used by users to place/cancel orders and by validators to relay matched/liquidation orders\n * @dev At several places we are using something called a bibliophile. This is a special contract (precompile) that is deployed at a specific address.\n * But there is identical code in this contract that can be used as a fallback if the precompile is not available.\n*/\ncontract OrderBook is IOrderBook, VanillaGovernable, Pausable, EIP712Upgradeable {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    // keccak256(\"Order(uint256 ammIndex,address trader,int256 baseAssetQuantity,uint256 price,uint256 salt,bool reduceOnly)\");\n    bytes32 public constant ORDER_TYPEHASH = 0x0a2e4d36552888a97d5a8975ad22b04e90efe5ea0a8abb97691b63b431eb25d2;\n    string constant NOT_IS_MULTIPLE = \"OB.not_multiple\";\n\n    IClearingHouse public immutable clearingHouse;\n    IMarginAccount public immutable marginAccount;\n\n    mapping(bytes32 => OrderInfo) public orderInfo; // SLOT_53 !!! used in precompile !!!\n    mapping(address => bool) public isValidator; // SLOT_54 (not used in precompile)\n\n    /**\n    * @notice maps the address of the trader to the amount of reduceOnlyAmount for each amm\n    * trader => ammIndex => reduceOnlyAmount\n    */\n    mapping(address => mapping(uint => int256)) public reduceOnlyAmount;\n\n    // cache some variables for quick assertions\n    int256[] public minSizes; // min size for each AMM, array index is the ammIndex\n    uint public minAllowableMargin;\n    uint public takerFee;\n    IHubbleBibliophile public bibliophile;\n\n    uint256 public useNewPricingAlgorithm; // declared as uint256 to take 1 full slot\n    uint256[49] private __gap;\n\n    modifier onlyValidator {\n        require(isValidator[msg.sender], \"OB.only_validator\");\n        _;\n    }\n\n    modifier onlyClearingHouse {\n        require(msg.sender == address(clearingHouse), \"OB.only_clearingHouse\");\n        _;\n    }\n\n    constructor(address _clearingHouse, address _marginAccount) {\n        clearingHouse = IClearingHouse(_clearingHouse);\n        marginAccount = IMarginAccount(_marginAccount);\n    }\n\n    function initialize(\n        string memory _name,\n        string memory _version,\n        address _governance\n    ) external initializer {\n        __EIP712_init(_name, _version);\n        _setGovernace(_governance);\n    }\n\n    /* ****************** */\n    /*    Place Orders    */\n    /* ****************** */\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function placeOrder(Order memory order) external {\n        Order[] memory _orders = new Order[](1);\n        _orders[0] = order;\n        placeOrders(_orders);\n    }\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function placeOrders(Order[] memory orders) public whenNotPaused {\n        address trader = orders[0].trader;\n        int[] memory posSizes = _getPositionSizes(trader);\n        uint reserveAmount;\n        for (uint i = 0; i < orders.length; i++) {\n            require(orders[i].trader == trader, \"OB_trader_mismatch\");\n            reserveAmount += _placeOrder(orders[i], posSizes[orders[i].ammIndex]);\n        }\n        if (reserveAmount != 0) {\n            marginAccount.reserveMargin(trader, reserveAmount);\n        }\n    }\n\n    function _getPositionSizes(address trader) internal view returns (int[] memory) {\n        if (address(bibliophile) != address(0)) {\n            // precompile magic allows us to execute this for a fixed gas\n            return bibliophile.getPositionSizes(trader);\n        }\n        // folowing is the fallback code if precompile is not available. Precompile is intended to perform the same computation as the following code\n        uint numAmms = clearingHouse.getAmmsLength();\n        int[] memory posSizes = new int[](numAmms);\n        for (uint i; i < numAmms; ++i) {\n            (posSizes[i],,,) = IAMM(clearingHouse.amms(i)).positions(trader);\n        }\n        return posSizes;\n    }\n\n    /**\n     * @dev has some special handling for reduceOnly orders\n    */\n    function _placeOrder(Order memory order, int size) internal returns (uint reserveAmount) {\n        require(msg.sender == order.trader, \"OB_sender_is_not_trader\");\n\n        // orders should be multiple of pre-defined minimum quantity to prevent spam with dust orders\n        require(isMultiple(order.baseAssetQuantity, minSizes[order.ammIndex]), NOT_IS_MULTIPLE);\n\n        bytes32 orderHash = getOrderHash(order);\n        // order should not exist in the orderStatus map already\n        require(orderInfo[orderHash].status == OrderStatus.Invalid, \"OB_Order_already_exists\");\n\n        // reduce only orders should only reduce the position size. They need a bit of special handling.\n        if (order.reduceOnly) {\n            require(isOppositeSign(size, order.baseAssetQuantity), \"OB_reduce_only_order_must_reduce_position\");\n            // track the total size of all the reduceOnly orders for a trader in a particular market\n            reduceOnlyAmount[order.trader][order.ammIndex] += abs(order.baseAssetQuantity);\n            // total size of reduce only orders should not exceed the position size\n            require(abs(size) >= reduceOnlyAmount[order.trader][order.ammIndex], \"OB_reduce_only_amount_exceeded\");\n        } else {\n            /**\n            * Don't allow trade in opposite direction of existing position size if there is a reduceOnly order\n            * in case of liquidation, size == 0 && reduceOnlyAmount != 0 is possible\n            * in that case, we don't not allow placing a new order in any direction, must cancel reduceOnly order first\n            * in normal case, size = 0 => reduceOnlyAmount = 0\n            */\n            if (isOppositeSign(size, order.baseAssetQuantity) || size == 0) {\n                require(reduceOnlyAmount[order.trader][order.ammIndex] == 0, \"OB_cancel_reduce_only_order_first\");\n            }\n            // reserve margin for the order\n            reserveAmount = getRequiredMargin(order.baseAssetQuantity, order.price);\n        }\n\n        // add orderInfo for the corresponding orderHash\n        orderInfo[orderHash] = OrderInfo(block.number, 0, reserveAmount, OrderStatus.Placed);\n        emit OrderPlaced(order.trader, orderHash, order, block.timestamp);\n    }\n\n    /* ****************** */\n    /*    Cancel Orders   */\n    /* ****************** */\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function cancelOrder(Order memory order) override external {\n        Order[] memory _orders = new Order[](1);\n        _orders[0] = order;\n        cancelOrders(_orders);\n    }\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function cancelOrders(Order[] memory orders) override public {\n        address trader = orders[0].trader;\n        uint releaseMargin;\n        for (uint i; i < orders.length; i++) {\n            require(orders[i].trader == trader, \"OB_trader_mismatch\");\n            releaseMargin += _cancelOrder(orders[i]);\n        }\n        if (releaseMargin != 0) {\n            marginAccount.releaseMargin(trader, releaseMargin);\n        }\n    }\n\n    function _cancelOrder(Order memory order) internal returns (uint releaseMargin) {\n        bytes32 orderHash = getOrderHash(order);\n        require(orderInfo[orderHash].status == OrderStatus.Placed, \"OB_Order_does_not_exist\");\n\n        address trader = order.trader;\n        if (msg.sender != trader) {\n            require(isValidator[msg.sender], \"OB_invalid_sender\");\n            // allow cancellation of order by validator if availableMargin < 0\n            // there is more information in the description of the function\n            require(marginAccount.getAvailableMargin(trader) < 0, \"OB_available_margin_not_negative\");\n        }\n\n        orderInfo[orderHash].status = OrderStatus.Cancelled;\n        if (order.reduceOnly) {\n            int unfilledAmount = abs(order.baseAssetQuantity - orderInfo[orderHash].filledAmount);\n            reduceOnlyAmount[trader][order.ammIndex] -= unfilledAmount;\n        } else {\n            releaseMargin = orderInfo[orderHash].reservedMargin;\n        }\n\n        _deleteOrderInfo(orderHash);\n        emit OrderCancelled(trader, orderHash, block.timestamp);\n    }\n\n    /* ****************** */\n    /*    Match Orders    */\n    /* ****************** */\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function execu"
    }
  ]
}