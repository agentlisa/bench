{
  "Title": "[09] Potential Risks in Dynamic NFT Metadata Management in `VerbsToken` Smart Contract",
  "Content": "The `VerbsToken` smart contract contains two critical functions, [setContractURIHash](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/VerbsToken.sol#L165-L171) and [setDescriptor](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/VerbsToken.sol#L226-L236), that pose potential risks due to their ability to alter contract-level and individual NFT metadata, respectively. \n\nThe `setContractURIHash` function, with a low to medium severity level, allows changing the collection-level metadata, which could impact the overall perception and value of the NFTs in the market. This might lead to confusion or mistrust among NFT owners and potential buyers if the collection's description or theme is altered significantly. \n\nOn the other hand, the `setDescriptor` function poses a high-severity risk, as it directly affects the `tokenURI` of each NFT. Changes made by this function can be substantial as the `tokenURI` typically points to a JSON file that contains the NFTs' appearance and features, potentially compromising their originality and authenticity. This could have severe implications for the NFT's value and the owner's rights.\n\nThe presence of a [lockDescriptor](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/VerbsToken.sol#L238-L246) function, which irreversibly prevents further changes to the descriptor, shows an awareness of the potential risks associated with changing NFT metadata. However, the absence of a similar lock function for the `contractURIHash` indicates a different level of consideration for the collection-level metadata compared to the individual NFT metadata.\n\nTo mitigate these risks, it is recommended to implement immutable metadata practices, enhance transparency and community involvement in any changes, provide clear documentation, and introduce a versioning system for metadata. \n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/revolution/src/VerbsToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The Verbs ERC-721 token\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\nimport { ERC721CheckpointableUpgradeable } from \"./base/ERC721CheckpointableUpgradeable.sol\";\nimport { IDescriptorMinimal } from \"./interfaces/IDescriptorMinimal.sol\";\nimport { ICultureIndex } from \"./interfaces/ICultureIndex.sol\";\nimport { IVerbsToken } from \"./interfaces/IVerbsToken.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\ncontract VerbsToken is\n    IVerbsToken,\n    VersionedContract,\n    UUPS,\n    Ownable2StepUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC721CheckpointableUpgradeable\n{\n    // An address who has permissions to mint Verbs\n    address public minter;\n\n    // The Verbs token URI descriptor\n    IDescriptorMinimal public descriptor;\n\n    // The CultureIndex contract\n    ICultureIndex public cultureIndex;\n\n    // Whether the minter can be updated\n    bool public isMinterLocked;\n\n    // Whether the CultureIndex can be updated\n    bool public isCultureIndexLocked;\n\n    // Whether the descriptor can be updated\n    bool public isDescriptorLocked;\n\n    // The internal verb ID tracker\n    uint256 private _currentVerbId;\n\n    // IPFS content hash of contract-level metadata\n    string private _contractURIHash = \"QmQzDwaZ7yQxHHs7sQQenJVB89riTSacSGcJRv9jtHPuz5\";\n\n    // The Verb art pieces\n    mapping(uint256 => ICultureIndex.ArtPiece) public artPieces;\n\n    ///                                                          ///\n    ///                          MODIFIERS                       ///\n    ///                                                          ///\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier whenMinterNotLocked() {\n        require(!isMinterLocked, \"Minter is locked\");\n        _;\n    }\n\n    /**\n     * @notice Require that the CultureIndex has not been locked.\n     */\n    modifier whenCultureIndexNotLocked() {\n        require(!isCultureIndexLocked, \"CultureIndex is locked\");\n        _;\n    }\n\n    /**\n     * @notice Require that the descriptor has not been locked.\n     */\n    modifier whenDescriptorNotLocked() {\n        require(!isDescriptorLocked, \"Descriptor is locked\");\n        _;\n    }\n\n    /**\n     * @notice Require that the sender is the minter.\n     */\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"Sender is not the minter\");\n        _;\n    }\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's ERC-721 token contract\n    /// @param _minter The address of the minter\n    /// @param _initialOwner The address of the initial owner\n    /// @param _descriptor The address of the token URI descriptor\n    /// @param _cultureIndex The address of the CultureIndex contract\n    /// @param _erc721TokenParams The name, symbol, and contract metadata of the token\n    function initialize(\n        address _minter,\n        address _initialOwner,\n        address _descriptor,\n        address _cultureIndex,\n        IRevolutionBuilder.ERC721TokenParams memory _erc721TokenParams\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        require(_minter != address(0), \"Minter cannot be zero address\");\n        require(_initialOwner != address(0), \"Initial owner cannot be zero address\");\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Setup ownable\n        __Ownable_init(_initialOwner);\n\n        // Initialize the ERC-721 token\n        __ERC721_init(_erc721TokenParams.name, _erc721TokenParams.symbol);\n        _contractURIHash = _erc721TokenParams.contractURIHash;\n\n        // Set the contracts\n        minter = _minter;\n        descriptor = IDescriptorMinimal(_descriptor);\n        cultureIndex = ICultureIndex(_cultureIndex);\n    }\n\n    /**\n     * @notice The IPFS URI of contract-level metadata.\n     */\n    function contractURI() public view returns (string memory) {\n        return string(abi.encodePacked(\"ipfs://\", _contractURIHash));\n    }\n\n    /**\n     * @notice Set the _contractURIHash.\n     * @dev Only callable by the owner.\n     */\n    function setContractURIHash(string memory newContractURIHash) external onlyOwner {\n        _contractURIHash = newContractURIHash;\n    }\n\n    /**\n     * @notice Mint a Verb to the minter.\n     * @dev Call _mintTo with the to address(es).\n     */\n    function mint() public override onlyMinter nonReentrant returns (uint256) {\n        return _mintTo(minter);\n    }\n\n    /**\n     * @notice Burn a verb.\n     */\n    function burn(uint256 verbId) public override onlyMinter nonReentrant {\n        _burn(verbId);\n        emit VerbBurned(verbId);\n    }\n\n    /**\n     * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        return descriptor.tokenURI(tokenId, artPieces[tokenId].metadata);\n    }\n\n    /**\n     * @notice Similar to `tokenURI`, but always serves a base64 encoded data URI\n     * with the JSON contents directly inlined.\n     */\n    function dataURI(uint256 tokenId) public view override returns (string memory) {\n        return descriptor.dataURI(tokenId, artPieces[tokenId].metadata);\n    }\n\n    /**\n     * @notice Set the token minter.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setMinter(address _minter) external override onlyOwner nonReentrant whenMinterNotLocked {\n        require(_minter != address(0), \"Minter cannot be zero address\");\n        minter = _minter;\n\n        emit MinterUpdated(_minter);\n    }\n\n    /**\n     * @notice Lock the minter.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockMinter() external override onlyOwner whenMinterNotLocked {\n        isMinterLocked = true;\n\n        emit MinterLocked();\n    }\n\n    /**\n     * @notice Set the token URI descriptor.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setDescriptor(\n        IDescriptorMinimal _descriptor\n    ) external override onlyOwner nonReentrant whenDescriptorNotLocked {\n        descriptor = _descriptor;\n\n        emit DescriptorUpdated(_descriptor);\n    }\n\n    /**\n     * @notice Lock the descriptor.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockDescriptor() external override onlyOwner whenDescriptorNotLocked {\n        isDescriptorLocked = true;\n\n        emit DescriptorLocked();\n    }\n\n    /**\n     * @notice Set the token CultureIndex.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setCultureIndex(ICultureIndex _cultureIndex) external onlyOwner whenCultureIndexNotLocked nonReentrant {\n        cultureIndex = _cultureIndex;\n\n        emit CultureIndexUpdated(_cultureIndex);\n    }\n\n    /**\n     * @notice Lock the CultureIndex\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockCultureIndex() external override onlyOwner whenCultureIndexNotLocked {\n        isCultureIndexLocked = true;\n\n        emit CultureIndexLocked();\n    }\n\n    /**\n     * @notice Fetch an art piece by its ID.\n     * @param verbId The ID of the art piece.\n     * @return The ArtPiece struct associated with the given ID.\n     */\n    function getArtPieceById(uint256 verbId) public view returns (ICultureIndex.ArtPiece memory) {\n        require(verbId <= _currentVerbId, \"Invalid piece ID\");\n        return artPieces[verbId];\n    }\n\n    /**\n     * @notice Mint a Verb with `verbId` to the provided `to` address. Pulls the top voted art piece from the CultureIndex.\n     */\n    function _mintTo(address to) internal returns (uint256) {\n        ICultureIndex.ArtPiece memory artPiece = cultureIndex.getTopVotedPiece();\n\n        // Check-Effects-Interactions Pattern\n        // Perform all checks\n        require(\n            artPiece.creators.length <= cultureIndex.MAX_NUM_CREATORS(),\n            \"Creator array must not be > MAX_NUM_CREATORS\"\n        );\n\n        // Use try/catch to handle potential failure\n        try cultureIndex.dropTopVotedPiece() returns (ICultureIndex.ArtPiece memory _artPiece) {\n            artPiece = _artPiece;\n            uint256 verbId = _currentVerbId++;\n\n            ICultureIndex.ArtPiece storage newPiece = artPieces[verbId];\n\n            newPiece.pieceId = artPiece.pieceId;\n            newPiece.metadata = artPiece.metadata;\n            newPiece.isDropped = artPiece.isDropped;\n            newPiece.sponsor = artPiece.sponsor;\n            newPiece.totalERC20Supply = artPiece.totalERC20Supply;\n            newPiece.quorumVotes = artPiece.quorumVotes;\n            newPiece.totalVotesSupply = artPiece.totalVotesSupply;\n\n            for (uint i = 0; i < artPiece.creators.length; i++) {\n                newPiece.creators.push(artPiece.creators[i]);\n            }\n\n            _mint(to, verbId);\n\n            emit VerbCreated(verbId, artPiece);\n\n            return verbId;\n        } catch {\n            // Handle failure (e.g., revert, emit an event, set a flag, etc.)\n            revert(\"dropTopVotedPiece failed\");\n        }\n    }\n\n    ///                                                          ///\n    ///                         TOKEN UPGRADE                    ///\n    ///                                                          ///\n\n    // /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    // /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    // /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the implementation is valid\n        require(manager.isRegisteredUpgrade(_getImplementation(), _newImpl), \"Invalid upgrade\");\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/VerbsToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The Verbs ERC-721 token\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\nimport { ERC721CheckpointableUpgradeable } from \"./base/ERC721CheckpointableUpgradeable.sol\";\nimport { IDescriptorMinimal } from \"./interfaces/IDescriptorMinimal.sol\";\nimport { ICultureIndex } from \"./interfaces/ICultureIndex.sol\";\nimport { IVerbsToken } from \"./interfaces/IVerbsToken.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\ncontract VerbsToken is\n    IVerbsToken,\n    VersionedContract,\n    UUPS,\n    Ownable2StepUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC721CheckpointableUpgradeable\n{\n    // An address who has permissions to mint Verbs\n    address public minter;\n\n    // The Verbs token URI descriptor\n    IDescriptorMinimal public descriptor;\n\n    // The CultureIndex contract\n    ICultureIndex public cultureIndex;\n\n    // Whether the minter can be updated\n    bool public isMinterLocked;\n\n    // Whether the CultureIndex can be updated\n    bool public isCultureIndexLocked;\n\n    // Whether the descriptor can be updated\n    bool public isDescriptorLocked;\n\n    // The internal verb ID tracker\n    uint256 private _currentVerbId;\n\n    // IPFS content hash of contract-level metadata\n    string private _contractURIHash = \"QmQzDwaZ7yQxHHs7sQQenJVB89riTSacSGcJRv9jtHPuz5\";\n\n    // The Verb art pieces\n    mapping(uint256 => ICultureIndex.ArtPiece) public artPieces;\n\n    ///                                                          ///\n    ///                          MODIFIERS                       ///\n    ///                                                          ///\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier whenMinterNotLocked() {\n        require(!isMinterLocked, \"Minter is locked\");\n        _;\n    }\n\n    /**\n     * @notice Require that the CultureIndex has not been locked.\n     */\n    modifier whenCultureIndexNotLocked() {\n        require(!isCultureIndexLocked, \"CultureIndex is locked\");\n        _;\n    }\n\n    /**\n     * @notice Require that the descriptor has not been locked.\n     */\n    modifier whenDescriptorNotLocked() {\n        require(!isDescriptorLocked, \"Descriptor is locked\");\n        _;\n    }\n\n    /**\n     * @notice Require that the sender is the minter.\n     */\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"Sender is not the minter\");\n        _;\n    }\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's ERC-721 token contract\n    /// @param _minter The address of the minter\n    /// @param _initialOwner The address of the initial owner\n    /// @param _descriptor The address of the token URI descriptor\n    /// @param _cultureIndex The address of the CultureIndex contract\n    /// @param _erc721TokenParams The name, symbol, and contract metadata of the token\n    function initialize(\n        address _minter,\n        address _initialOwner,\n        address _descriptor,\n        address _cultureIndex,\n        IRevolutionBuilder.ERC721TokenParams memory _erc721TokenParams\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        require(_minter != address(0), \"Minter cannot be zero address\");\n        require(_initialOwner != address(0), \"Initial owner cannot be zero address\");\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Setup ownable\n        __Ownable_init(_initialOwner);\n\n        // Initialize the ERC-721 token\n        __ERC721_init(_erc721TokenParams.name, _erc721TokenParams.symbol);\n        _contractURIHash = _erc721TokenParams.contractURIHash;\n\n        // Set the contracts\n        minter = _minter;\n        descriptor = IDescriptorMinimal(_descriptor);\n        cultureIndex = ICultureIndex(_cultureIndex);\n    }\n\n    /**\n     * @notice The IPFS URI of contract-level metadata.\n     */\n    function contractURI() public view returns (string memory) {\n        return string(abi.encodePacked(\"ipfs://\", _contractURIHash));\n    }\n\n    /**\n     * @notice Set the _contractURIHash.\n     * @dev Only callable by the owner.\n     */\n    function setContractURIHash(string memory newContractURIHash) external onlyOwner {\n        _contractURIHash = newContractURIHash;\n    }\n\n    /**\n     * @notice Mint a Verb to the minter.\n     * @dev Call _mintTo with the to address(es).\n     */\n    function mint() public override onlyMinter nonReentrant returns (uint256) {\n        return _mintTo(minter);\n    }\n\n    /**\n     * @notice Burn a verb.\n     */\n    function burn(uint256 verbId) public override onlyMinter nonReentrant {\n        _burn(verbId);\n        emit VerbBurned(verbId);\n    }\n\n    /**\n     * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        return descriptor.tokenURI(tokenId, artPieces[tokenId].metadata);\n    }\n\n    /**\n     * @notice Similar to `tokenURI`, but always serves a base64 encoded data URI\n     * with the JSON contents directly inlined.\n     */\n    function dataURI(uint256 tokenId) public view override returns (string memory) {\n        return descriptor.dataURI(tokenId, artPieces[tokenId].metadata);\n    }\n\n    /**\n     * @notice Set the token minter.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setMinter(address _minter) external override onlyOwner nonReentrant whenMinterNotLocked {\n        require(_minter != address(0), \"Minter cannot be zero address\");\n        minter = _minter;\n\n        emit MinterUpdated(_minter);\n    }\n\n    /**\n     * @notice Lock the minter.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockMinter() external override onlyOwner whenMinterNotLocked {\n        isMinterLocked = true;\n\n        emit MinterLocked();\n    }\n\n    /**\n     * @notice Set the token URI descriptor.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setDescriptor(\n        IDescriptorMinimal _descriptor\n    ) external override onlyOwner nonReentrant whenDescriptorNotLocked {\n        descriptor = _descriptor;\n\n        emit DescriptorUpdated(_descriptor);\n    }\n\n    /**\n     * @notice Lock the descriptor.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockDescriptor() external override onlyOwner whenDescriptorNotLocked {\n        isDescriptorLocked = true;\n\n        emit DescriptorLocked();\n    }\n\n    /**\n     * @notice Set the token CultureIndex.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setCultureIndex(ICultureIndex _cultureIndex) external onlyOwner whenCultureIndexNotLocked nonReentrant {\n        cultureIndex = _cultureIndex;\n\n        emit CultureIndexUpdated(_cultureIndex);\n    }\n\n    /**\n     * @notice Lock the CultureIndex\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockCultureIndex() external override onlyOwner whenCultureIndexNotLocked {\n        isCultureIndexLocked = true;\n\n        emit CultureIndexLocked();\n    }\n\n    /**\n     * @notice Fetch an art piece by its ID.\n     * @param verbId The ID of the art piece.\n     * @return The ArtPiece struct associated with the given ID.\n     */\n    function getArtPieceById(uint256 verbId) public view returns (ICultureIndex.ArtPiece memory) {\n        require(verbId <= _currentVerbId, \"Invalid piece ID\");\n        return artPieces[verbId];\n    }\n\n    /**\n     * @notice Mint a Verb with `verbId` to the provided `to` address. Pulls the top voted art piece from the CultureIndex.\n     */\n    function _mintTo(address to) internal returns (uint256) {\n        ICultureIndex.ArtPiece memory artPiece = cultureIndex.getTopVotedPiece();\n\n        // Check-Effects-Interactions Pattern\n        // Perform all checks\n        require(\n            artPiece.creators.length <= cultureIndex.MAX_NUM_CREATORS(),\n            \"Creator array must not be > MAX_NUM_CREATORS\"\n        );\n\n        // Use try/catch to handle potential failure\n        try cultureIndex.dropTopVotedPiece() returns (ICultureIndex.ArtPiece memory _artPiece) {\n            artPiece = _artPiece;\n            uint256 verbId = _currentVerbId++;\n\n            ICultureIndex.ArtPiece storage newPiece = artPieces[verbId];\n\n            newPiece.pieceId = artPiece.pieceId;\n            newPiece.metadata = artPiece.metadata;\n            newPiece.isDropped = artPiece.isDropped;\n            newPiece.sponsor = artPiece.sponsor;\n            newPiece.totalERC20Supply = artPiece.totalERC20Supply;\n            newPiece.quorumVotes = artPiece.quorumVotes;\n            newPiece.totalVotesSupply = artPiece.totalVotesSupply;\n\n            for (uint i = 0; i < artPiece.creators.length; i++) {\n                newPiece.creators.push(artPiece.creators[i]);\n            }\n\n            _mint(to, verbId);\n\n            emit VerbCreated(verbId, artPiece);\n\n            return verbId;\n        } catch {\n            // Handle failure (e.g., revert, emit an event, set a flag, etc.)\n            revert(\"dropTopVotedPiece failed\");\n        }\n    }\n\n    ///                                                          ///\n    ///                         TOKEN UPGRADE                    ///\n    ///                                                          ///\n\n    // /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    // /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    // /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the implementation is valid\n        require(manager.isRegisteredUpgrade(_getImplementation(), _newImpl), \"Invalid upgrade\");\n    }\n}"
    }
  ]
}