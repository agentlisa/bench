{
  "Title": "[H-45] `SGLLiquidation::_computeAssetAmountToSolvency`, `Market::_isSolvent` and `Market::_computeMaxBorrowableAmount` may overestimate the collateral, resulting in false solvency",
  "Content": "\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L415-L421> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L385-L399> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L781-L785> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/singularity/SGLLiquidation.sol#L80-L87>\n\nAn user can borrow via `BigBang::borrow` when there is no collateral amount from the user's share. The `BigBang` will falsely consider the position as solvent, when it is not, resulting in a loss.\n\nA similar issue presents in the Singularity as `SGLLiquidation::_computeAssetAmountToSolvency` will overestimate the collateral, therefore liquidate less than it should.\n\n### Proof of Concept\n\nThe following proof of concept demonstrates that au user could borrow some assets, even though the collateral share will not give any amount of collateral.\n\nPut the full PoC in the following gist into `test/bigBang.test.ts` in tapiocabar-audit.\n\n<https://gist.github.com/zzzitron/14482ea3ab35b08421e7751bac0c2e3f>\n\n<details>\n\n```javascript\n        it('considers me solvent even when I have enough share for any amount PoCBorrow', async () => {\n            ///////\n            // setup is omitted\n            // full poc is https://gist.github.com/zzzitron/14482ea3ab35b08421e7751bac0c2e3f\n            ///////\n\n            const wethCollateralShare = ethers.BigNumber.from((1e8).toString()).sub(1);\n            await wethBigBangMarket.addCollateral(\n                deployer.address,\n                deployer.address,\n                false,\n                0,\n                wethCollateralShare,\n                // valShare,\n            );\n\n            // log\n            let userCollateralShare = await wethBigBangMarket.userCollateralShare(deployer.address);\n            console.log(\"userCollateralShare: \", userCollateralShare.toString());\n            let userCollateralShareToAmount = await yieldBox.toAmount(wethAssetId, userCollateralShare, false);\n            console.log(\"userCollateralShareToAmount: \", userCollateralShareToAmount.toString());\n            let collateralPartInAsset = (await yieldBox.toAmount(wethAssetId, userCollateralShare.mul(1e13).mul(75000), false))\n            console.log(\"collateralPart in asset times exchangerRate\", collateralPartInAsset.toString())\n            const exchangeRate = await wethBigBangMarket.exchangeRate();\n            console.log(\"exchangeRate:\",exchangeRate.toString());\n            console.log(\"can borrow this much:\",collateralPartInAsset.div(exchangeRate).toString());\n\n\n            //borrow even though the collateral share is not enough for any amount of collateral\n            const usdoBorrowVal = collateralPartInAsset.div(exchangeRate).sub(1)\n\n            await wethBigBangMarket.borrow(\n                deployer.address,\n                deployer.address,\n                usdoBorrowVal,\n            );\n\n            let userBorrowPart = await wethBigBangMarket.userBorrowPart(\n                deployer.address,\n            );\n            expect(userBorrowPart.gt(0)).to.be.true;\n            console.log(userBorrowPart.toString())\n        });\n```\n\n</details>\n\nThe result of the test is:\n\n      BigBang test\n        poc\n    userCollateralShare:  99999999\n    userCollateralShareToAmount:  0\n    collateralPart in asset times exchangerRate 749999992500000000\n    exchangeRate: 1000000000000000\n    can borrow this much: 749\n    748\n          âœ” considers me solvent even when I have enough share for any amount PoCBorrow (12405ms)\n\nIn the scenario above, The deployer is adding share of collateral to the bigbang using `BigBang::addCollateral`. The added amount in the below example is (1e8 - 1), which is too small to get any collateral from the YieldBox, as the `yieldBox.toAmount` is zero.\n\nHowever, due to the calculation error in the `Market::_isSolvent`, the deployer could borrow 748 of asset. Upon withdrawing the yieldBox will give zero amount of collateral, but the BigBang let the user borrow non zero amount of asset.\n\nSimilarly one can show that `Singularity` will liquidate less than it should, due to similar calculation error.\n\n### details of the bug\n\nThe problem stems from the calculation error, where multiplies the user's collateral share with `EXCHANGE_RATE_PRECISION` and `collateralizationRate` before calling `yieldBox.toAmount`.\nIt will give inflated amount, resulting in false solvency.\n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L415-L421>\n\n```solidity\n        return\n            yieldBox.toAmount(\n                collateralId,\n                collateralShare *\n                    (EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n                    collateralizationRate,\n                false\n            ) >=\n\n```\n\nThe same calculation happens in the `Market::_computeMaxBorrowableAmount`\n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L385-L399>\n\nIn the BigBang's liquidating logic (e.i. in the `BigBang::_updateBorrowAndCollateralShare`), the conversion from the share of collateral to the asset is calculated correctly:\n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L781-L785>\n\n```solidity\n        uint256 collateralPartInAsset = (yieldBox.toAmount(\n            collateralId,\n            userCollateralShare[user],\n            false\n        ) * EXCHANGE_RATE_PRECISION) / _exchangeRate;\n```\n\nHowever, the position in question will not get to this logic, even if `BigBang::liquidate` is called on the position, since the `_isSolvent` will falsely consider the position as solvent.\n\nSimilarly the `Singularity` will overestimate the collateral in the same manner.\n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/singularity/SGLLiquidation.sol#L70-L90>\n\n```solidity\n    function _computeAssetAmountToSolvency(\n        address user,\n        uint256 _exchangeRate\n    ) private view returns (uint256) {\n        // accrue must have already been called!\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return 0;\n        uint256 collateralShare = userCollateralShare[user];\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 collateralAmountInAsset = yieldBox.toAmount(\n            collateralId,\n            (collateralShare *\n                (EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n                lqCollateralizationRate),\n            false\n        ) / _exchangeRate;\n        // Obviously it's not `borrowPart` anymore but `borrowAmount`\n        borrowPart = (borrowPart * _totalBorrow.elastic) / _totalBorrow.base;\n```\n\n### Recommended Mitigation Steps\n\nThe `Market::_isSolvent` and `Market::_computeMaxBorrowableAmount`  should evaluate the value of collateral like `BigBang::_updateBorrowAndCollateralShare` function, (e.i. calculate the exchangeRate and collateralizationRate after converting the share to asset).\n\n<!-- zzzitron H-Market-isSolvent-PoCBorrow -->\n\n**[0xRektora (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/915#issuecomment-1700227210)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/markets/Market.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\n\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/YieldBox.sol\";\nimport \"tapioca-periph/contracts/interfaces/IOracle.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPenrose.sol\";\nimport \"./MarketERC20.sol\";\n\n/// @title Market contract\n/// @notice Market contract implemented by Singularity & BigBang\nabstract contract Market is MarketERC20, BoringOwnable {\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice returns YieldBox address\n    YieldBox public yieldBox;\n    /// @notice returns Penrose address\n    IPenrose public penrose;\n\n    /// @notice collateral token address\n    IERC20 public collateral;\n    /// @notice collateral token YieldBox id\n    uint256 public collateralId;\n    /// @notice asset token address\n    IERC20 public asset;\n    /// @notice asset token YieldBox id\n    uint256 public assetId;\n\n    /// @notice contract's pause state\n    bool public paused;\n    /// @notice conservator's addresss\n    /// @dev conservator can pause/unpause the contract\n    address public conservator;\n\n    /// @notice oracle address\n    IOracle public oracle;\n    /// @notice oracleData\n    bytes public oracleData;\n    /// @notice Exchange and interest rate tracking.\n    /// This is 'cached' here because calls to Oracles can be very expensive.\n    /// Asset -> collateral = assetAmount * exchangeRate.\n    uint256 public exchangeRate;\n\n    /// @notice total amount borrowed\n    /// @dev elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\n    Rebase public totalBorrow;\n    /// @notice total collateral supplied\n    uint256 public totalCollateralShare;\n    /// @notice max borrow cap\n    uint256 public totalBorrowCap;\n    /// @notice borrow amount per user\n    mapping(address => uint256) public userBorrowPart;\n    /// @notice collateral share per user\n    mapping(address => uint256) public userCollateralShare;\n\n    /// @notice liquidation caller rewards\n    uint256 public callerFee; // 90%\n    /// @notice liquidation protocol rewards\n    uint256 public protocolFee; // 10%\n    /// @notice min % a liquidator can receive in rewards\n    uint256 public minLiquidatorReward = 1e3; //1%\n    /// @notice max % a liquidator can receive in rewards\n    uint256 public maxLiquidatorReward = 1e4; //10%\n    /// @notice max liquidatable bonus amount\n    /// @dev max % added to the amount that can be liquidated\n    uint256 public liquidationBonusAmount = 1e4; //10%\n    /// @notice collateralization rate\n    uint256 public collateralizationRate; // 75%\n    /// @notice borrowing opening fee\n    uint256 public borrowOpeningFee = 50; //0.05%\n    /// @notice liquidation multiplier used to compute liquidator rewards\n    uint256 public liquidationMultiplier = 12000; //12%\n\n    // ***************** //\n    // *** CONSTANTS *** //\n    // ***************** //\n    uint256 internal EXCHANGE_RATE_PRECISION; //not costant, but can only be set in the 'init' method\n    uint256 internal constant FEE_PRECISION = 1e5;\n    uint256 internal constant FEE_PRECISION_DECIMALS = 5;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when conservator is updated\n    event ConservatorUpdated(address indexed old, address indexed _new);\n    /// @notice event emitted when pause state is changed\n    event PausedUpdated(bool oldState, bool newState);\n    /// @notice event emitted when cached exchange rate is updated\n    event LogExchangeRate(uint256 rate);\n    /// @notice event emitted when borrow cap is updated\n    event LogBorrowCapUpdated(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when oracle data is updated\n    event OracleDataUpdated();\n    /// @notice event emitted when oracle is updated\n    event OracleUpdated();\n    /// @notice event emitted when a position is liquidated\n    event Liquidated(\n        address liquidator,\n        address[] users,\n        uint256 liquidatorReward,\n        uint256 protocolReward,\n        uint256 repayedAmount,\n        uint256 collateralShareRemoved\n    );\n    /// @notice event emitted when borrow opening fee is updated\n    event LogBorrowingFee(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when the liquidation multiplier rate is updated\n    event LiquidationMultiplierUpdated(uint256 oldVal, uint256 newVal);\n\n    modifier notPaused() {\n        require(!paused, \"Market: paused\");\n        _;\n    }\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\n    modifier solvent(address from) {\n        updateExchangeRate();\n        _accrue();\n\n        _;\n\n        require(_isSolvent(from, exchangeRate), \"Market: insolvent\");\n    }\n\n    bool internal initialized;\n    modifier onlyOnce() {\n        require(!initialized, \"Market: initialized\");\n        _;\n        initialized = true;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice sets the borrowing opening fee\n    /// @dev can only be called by the owner\n    /// @param _val the new value\n    function setBorrowOpeningFee(uint256 _val) external onlyOwner {\n        require(_val <= FEE_PRECISION, \"Market: not valid\");\n        emit LogBorrowingFee(borrowOpeningFee, _val);\n        borrowOpeningFee = _val;\n    }\n\n    /// @notice sets max borrowable amount\n    /// @dev can only be called by the owner\n    /// @param _cap the new value\n    function setBorrowCap(uint256 _cap) external notPaused onlyOwner {\n        emit LogBorrowCapUpdated(totalBorrowCap, _cap);\n        totalBorrowCap = _cap;\n    }\n\n    /// @notice sets common market configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    function setMarketConfig(\n        uint256 _borrowOpeningFee,\n        IOracle _oracle,\n        bytes calldata _oracleData,\n        address _conservator,\n        uint256 _callerFee,\n        uint256 _protocolFee,\n        uint256 _liquidationBonusAmount,\n        uint256 _minLiquidatorReward,\n        uint256 _maxLiquidatorReward,\n        uint256 _totalBorrowCap,\n        uint256 _collateralizationRate\n    ) external onlyOwner {\n        if (_borrowOpeningFee > 0) {\n            require(_borrowOpeningFee <= FEE_PRECISION, \"Market: not valid\");\n            emit LogBorrowingFee(borrowOpeningFee, _borrowOpeningFee);\n            borrowOpeningFee = _borrowOpeningFee;\n        }\n\n        if (address(_oracle) != address(0)) {\n            oracle = _oracle;\n            emit OracleUpdated();\n        }\n\n        if (_oracleData.length > 0) {\n            oracleData = _oracleData;\n            emit OracleDataUpdated();\n        }\n\n        if (_conservator != address(0)) {\n            emit ConservatorUpdated(conservator, _conservator);\n            conservator = _conservator;\n        }\n\n        if (_callerFee > 0) {\n            require(_callerFee <= FEE_PRECISION, \"Market: not valid\");\n            callerFee = _callerFee;\n        }\n\n        if (_protocolFee > 0) {\n            require(_protocolFee <= FEE_PRECISION, \"Market: not valid\");\n            protocolFee = _protocolFee;\n        }\n\n        if (_liquidationBonusAmount > 0) {\n            require(\n                _liquidationBonusAmount < FEE_PRECISION,\n                \"Market: not valid\"\n            );\n            liquidationBonusAmount = _liquidationBonusAmount;\n        }\n\n        if (_minLiquidatorReward > 0) {\n            require(_minLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(\n                _minLiquidatorReward < maxLiquidatorReward,\n                \"Market: not valid\"\n            );\n            minLiquidatorReward = _minLiquidatorReward;\n        }\n\n        if (_maxLiquidatorReward > 0) {\n            require(_maxLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(\n                _maxLiquidatorReward > minLiquidatorReward,\n                \"Market: not valid\"\n            );\n            maxLiquidatorReward = _maxLiquidatorReward;\n        }\n\n        if (_totalBorrowCap > 0) {\n            emit LogBorrowCapUpdated(totalBorrowCap, _totalBorrowCap);\n            totalBorrowCap = _totalBorrowCap;\n        }\n\n        if (_collateralizationRate > 0) {\n            require(\n                _collateralizationRate <= FEE_PRECISION,\n                \"Market: not valid\"\n            );\n            collateralizationRate = _collateralizationRate;\n        }\n    }\n\n    /// @notice updates the pause state of the contract\n    /// @dev can only be called by the conservator\n    /// @param val the new value\n    function updatePause(bool val) external {\n        require(msg.sender == conservator, \"Market: unauthorized\");\n        require(val != paused, \"Market: same state\");\n        emit PausedUpdated(paused, val);\n        paused = val;\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns the maximum liquidatable amount for user\n    function computeClosingFactor(\n        uint256 borrowPart,\n        uint256 collateralPartInAsset,\n        uint256 borrowPartDecimals,\n        uint256 collateralPartDecimals,\n        uint256 ratesPrecision\n    ) public view returns (uint256) {\n        uint256 borrowPartScaled = borrowPart;\n        if (borrowPartDecimals > 18) {\n            borrowPartScaled = borrowPart / (10 ** (borrowPartDecimals - 18));\n        }\n        if (borrowPartDecimals < 18) {\n            borrowPartScaled = borrowPart * (10 ** (18 - borrowPartDecimals));\n        }\n\n        uint256 collateralPartInAssetScaled = collateralPartInAsset;\n        if (collateralPartDecimals > 18) {\n            collateralPartInAssetScaled =\n                collateralPartInAsset /\n                (10 ** (collateralPartDecimals - 18));\n        }\n        if (collateralPartDecimals < 18) {\n            collateralPartInAssetScaled =\n                collateralPartInAsset *\n                (10 ** (18 - collateralPartDecimals));\n        }\n\n        uint256 liquidationStartsAt = (collateralPartInAssetScaled *\n            collateralizationRate) / (10 ** ratesPrecision);\n        if (borrowPartScaled < liquidationStartsAt) return 0;\n\n        uint256 numerator = borrowPartScaled -\n            ((collateralizationRate * collateralPartInAssetScaled) /\n                (10 ** ratesPrecision));\n        uint256 denominator = ((10 ** ratesPrecision) -\n            (collateralizationRate *\n                ((10 ** ratesPrecision) + liquidationMultiplier)) /\n            (10 ** ratesPrecision)) * (10 ** (18 - ratesPrecision));\n\n        uint256 x = (numerator * 1e18) / denominator;\n        return x;\n    }\n\n    /// @notice return the amount of collateral for a `user` to be solvent, min TVL and max TVL. Returns 0 if user already solvent.\n    /// @dev we use a `CLOSED_COLLATERIZATION_RATE` that is a safety buffer when making the user solvent again,\n    ///      to prevent from being liquidated. This function is valid only if user is not solvent by `_isSolvent()`.\n    /// @param user The user to check solvency.\n    /// @param _exchangeRate the exchange rate asset/collateral.\n    /// @return amountToSolvency the amount of collateral to be solvent.\n    function computeTVLInfo(\n        address user,\n        uint256 _exchangeRate\n    )\n        public\n        view\n        returns (uint256 amountToSolvency, uint256 minTVL, uint256 maxTVL)\n    {\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return (0, 0, 0);\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 collateralAmountInAsset = _computeMaxBorrowableAmount(\n            user,\n            _exchangeRate\n        );\n\n        borrowPart = (borrowPart * _totalBorrow.elastic) / _totalBorrow.base;\n\n        amountToSolvency = borrowPart >= collateralAmountInAsset\n            ? borrowPart - collateralAmountInAsset\n            : 0;\n\n        (minTVL, maxTVL) = _computeMaxAndMinLTVInAsset(\n            userCollateralShare[user],\n            _exchangeRate\n        );\n    }\n\n    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.\n    /// @dev This function is supposed to be invoked if needed because Oracle queries can be expensive.\n    ///      Oracle should consider USDO at 1$\n    /// @return updated True if `exchangeRate` was updated.\n    /// @return rate The new exchange rate.\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\n        (updated, rate) = oracle.get(\"\");\n\n        if (updated) {\n            require(rate > 0, \"Market: invalid rate\");\n            exchangeRate = rate;\n            emit LogExchangeRate(rate);\n        } else {\n            // Return the old rate if fetching wasn't successful\n            rate = exchangeRate;\n        }\n    }\n\n    /// @notice computes the possible liquidator reward\n    /// @notice user the user for which a liquidation operation should be performed\n    /// @param _exchangeRate the exchange rate asset/collateral to use for internal computations\n    function computeLiquidatorReward(\n        address user,\n        uint256 _exchangeRate\n    ) public view returns (uint256) {\n        (uint256 minTVL, uint256 maxTVL) = _computeMaxAndMinLTVInAsset(\n            userCollateralShare[user],\n            _exchangeRate\n        );\n        return _getCallerReward(userBorrowPart[user], minTVL, maxTVL);\n    }\n\n    // ************************** //\n    // *** INTERNAL FUNCTIONS *** //\n    // ************************** //\n    function _accrue() internal virtual;\n\n    function _getRevertMsg(\n        bytes memory _returnData\n    ) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Market: no return data\";\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    function _computeMaxBorrowableAmount(\n        address user,\n        uint256 _exchangeRate\n    ) internal view returns (uint256 collateralAmountInAsset) {\n        collateralAmountInAsset =\n            yieldBox.toAmount(\n                collateralId,\n                (userCollateralShare[user] *\n                    (EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n                    collateralizationRate),\n                false\n            ) /\n            _exchangeRate;\n    }\n\n    /// @notice Concrete implementation of `isSolvent`. Includes a parameter to allow caching `exchangeRate`.\n    /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.\n    function _isSolvent(\n        address user,\n        uint256 _exchangeRate\n    ) internal view returns (bool) {\n        // accrue must have already been called!\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return true;\n        uint256 collateralShare = userCollateralShare[user];\n        if (collateralShare == 0) return false;\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        return\n            yieldBox.toAmount(\n                collateralId,\n                collateralShare *\n                    (EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n                    collateralizationRate,\n                false\n            ) >=\n            // Moved exchangeRate here instead of dividing the other side to preserve more precision\n            (borrowPart * _totalBorrow.elastic * _exchangeRate) /\n                _totalBorrow.base;\n    }\n\n    /// @notice Returns the min and max LTV for user in asset price\n    function _computeMaxAndMinLTVInAsset(\n        uint256 collateralShare,\n        uint256 _exchangeRate\n    ) internal view returns (uint256 min, uint256 max) {\n        uint256 collateralAmount = yieldBox.toAmount(\n            collateralId,\n            collateralShare,\n            false\n        );\n\n        max = (collateralAmount * EXCHANGE_RATE_PRECISION) / _exchangeRate;\n        min = (max * collateralizationRate) / FEE_PRECISION;\n    }\n\n    function _getCallerReward(\n        uint256 borrowed,\n        uint256 startTVLInAsset,\n        uint256 maxTVLInAsset\n    ) internal view returns (uint256) {\n        if (borrowed == 0) return 0;\n        if (startTVLInAsset == 0) return 0;\n\n        if (borrowed < startTVLInAsset) return 0;\n        if (borrowed >= maxTVLInAsset) return minLiquidatorReward;\n\n        uint256 rewardPercentage = ((borrowed - startTVLInAsset) *\n            FEE_PRECISION) / (maxTVLInAsset - startTVLInAsset);\n\n        int256 diff = int256(minLiquidatorReward) - int256(maxLiquidatorReward);\n        int256 reward = (diff * int256(rewardPercentage)) /\n            int256(FEE_PRECISION) +\n            int256(maxLiquidatorReward);\n\n        return uint256(reward);\n    }\n\n    function _computeAllowanceAmountInAsset(\n        address user,\n        uint256 _exchangeRate,\n        uint256 borrowAmount,\n        uint256 assetDecimals\n    ) internal view returns (uint256) {\n        uint256 maxBorrowabe = _computeMaxBorrowableAmount(user, _exchangeRate);\n\n        uint256 shareRatio = _getRatio(\n            borrowAmount,\n            maxBorrowabe,\n            assetDecimals\n        );\n        return (shareRatio * userCollateralShare[user]) / (10 ** assetDecimals);\n    }\n\n    function _getRatio(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 precision\n    ) private pure returns (uint256) {\n        if (numerator == 0 || denominator == 0) {\n            return 0;\n        }\n        uint256 _numerator = numerator * 10 ** (precision + 1);\n        uint256 _quotient = ((_numerator / denominator) + 5) / 10;\n        return (_quotient);\n    }\n}"
    },
    {
      "filename": "contracts/markets/Market.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\n\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/YieldBox.sol\";\nimport \"tapioca-periph/contracts/interfaces/IOracle.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPenrose.sol\";\nimport \"./MarketERC20.sol\";\n\n/// @title Market contract\n/// @notice Market contract implemented by Singularity & BigBang\nabstract contract Market is MarketERC20, BoringOwnable {\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice returns YieldBox address\n    YieldBox public yieldBox;\n    /// @notice returns Penrose address\n    IPenrose public penrose;\n\n    /// @notice collateral token address\n    IERC20 public collateral;\n    /// @notice collateral token YieldBox id\n    uint256 public collateralId;\n    /// @notice asset token address\n    IERC20 public asset;\n    /// @notice asset token YieldBox id\n    uint256 public assetId;\n\n    /// @notice contract's pause state\n    bool public paused;\n    /// @notice conservator's addresss\n    /// @dev conservator can pause/unpause the contract\n    address public conservator;\n\n    /// @notice oracle address\n    IOracle public oracle;\n    /// @notice oracleData\n    bytes public oracleData;\n    /// @notice Exchange and interest rate tracking.\n    /// This is 'cached' here because calls to Oracles can be very expensive.\n    /// Asset -> collateral = assetAmount * exchangeRate.\n    uint256 public exchangeRate;\n\n    /// @notice total amount borrowed\n    /// @dev elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\n    Rebase public totalBorrow;\n    /// @notice total collateral supplied\n    uint256 public totalCollateralShare;\n    /// @notice max borrow cap\n    uint256 public totalBorrowCap;\n    /// @notice borrow amount per user\n    mapping(address => uint256) public userBorrowPart;\n    /// @notice collateral share per user\n    mapping(address => uint256) public userCollateralShare;\n\n    /// @notice liquidation caller rewards\n    uint256 public callerFee; // 90%\n    /// @notice liquidation protocol rewards\n    uint256 public protocolFee; // 10%\n    /// @notice min % a liquidator can receive in rewards\n    uint256 public minLiquidatorReward = 1e3; //1%\n    /// @notice max % a liquidator can receive in rewards\n    uint256 public maxLiquidatorReward = 1e4; //10%\n    /// @notice max liquidatable bonus amount\n    /// @dev max % added to the amount that can be liquidated\n    uint256 public liquidationBonusAmount = 1e4; //10%\n    /// @notice collateralization rate\n    uint256 public collateralizationRate; // 75%\n    /// @notice borrowing opening fee\n    uint256 public borrowOpeningFee = 50; //0.05%\n    /// @notice liquidation multiplier used to compute liquidator rewards\n    uint256 public liquidationMultiplier = 12000; //12%\n\n    // ***************** //\n    // *** CONSTANTS *** //\n    // ***************** //\n    uint256 internal EXCHANGE_RATE_PRECISION; //not costant, but can only be set in the 'init' method\n    uint256 internal constant FEE_PRECISION = 1e5;\n    uint256 internal constant FEE_PRECISION_DECIMALS = 5;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when conservator is updated\n    event ConservatorUpdated(address indexed old, address indexed _new);\n    /// @notice event emitted when pause state is changed\n    event PausedUpdated(bool oldState, bool newState);\n    /// @notice event emitted when cached exchange rate is updated\n    event LogExchangeRate(uint256 rate);\n    /// @notice event emitted when borrow cap is updated\n    event LogBorrowCapUpdated(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when oracle data is updated\n    event OracleDataUpdated();\n    /// @notice event emitted when oracle is updated\n    event OracleUpdated();\n    /// @notice event emitted when a position is liquidated\n    event Liquidated(\n        address liquidator,\n        address[] users,\n        uint256 liquidatorReward,\n        uint256 protocolReward,\n        uint256 repayedAmount,\n        uint256 collateralShareRemoved\n    );\n    /// @notice event emitted when borrow opening fee is updated\n    event LogBorrowingFee(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when the liquidation multiplier rate is updated\n    event LiquidationMultiplierUpdated(uint256 oldVal, uint256 newVal);\n\n    modifier notPaused() {\n        require(!paused, \"Market: paused\");\n        _;\n    }\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\n    modifier solvent(address from) {\n        updateExchangeRate();\n        _accrue();\n\n        _;\n\n        require(_isSolvent(from, exchangeRate), \"Market: insolvent\");\n    }\n\n    bool internal initialized;\n    modifier onlyOnce() {\n        require(!initialized, \"Market: initialized\");\n        _;\n        initialized = true;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice sets the borrowing opening fee\n    /// @dev can only be called by the owner\n    /// @param _val the new value\n    function setBorrowOpeningFee(uint256 _val) external onlyOwner {\n        require(_val <= FEE_PRECISION, \"Market: not valid\");\n        emit LogBorrowingFee(borrowOpeningFee, _val);\n        borrowOpeningFee = _val;\n    }\n\n    /// @notice sets max borrowable amount\n    /// @dev can only be called by the owner\n    /// @param _cap the new value\n    function setBorrowCap(uint256 _cap) external notPaused onlyOwner {\n        emit LogBorrowCapUpdated(totalBorrowCap, _cap);\n        totalBorrowCap = _cap;\n    }\n\n    /// @notice sets common market configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    function setMarketConfig(\n        uint256 _borrowOpeningFee,\n        IOracle _oracle,\n        bytes calldata _oracleData,\n        address _conservator,\n        uint256 _callerFee,\n        uint256 _protocolFee,\n        uint256 _liquidationBonusAmount,\n        uint256 _minLiquidatorReward,\n        uint256 _maxLiquidatorReward,\n        uint256 _totalBorrowCap,\n        uint256 _collateralizationRate\n    ) external onlyOwner {\n        if (_borrowOpeningFee > 0) {\n            require(_borrowOpeningFee <= FEE_PRECISION, \"Market: not valid\");\n            emit LogBorrowingFee(borrowOpeningFee, _borrowOpeningFee);\n            borrowOpeningFee = _borrowOpeningFee;\n        }\n\n        if (address(_oracle) != address(0)) {\n            oracle = _oracle;\n            emit OracleUpdated();\n        }\n\n        if (_oracleData.length > 0) {\n            oracleData = _oracleData;\n            emit OracleDataUpdated();\n        }\n\n        if (_conservator != address(0)) {\n            emit ConservatorUpdated(conservator, _conservator);\n            conservator = _conservator;\n        }\n\n        if (_callerFee > 0) {\n            require(_callerFee <= FEE_PRECISION, \"Market: not valid\");\n            callerFee = _callerFee;\n        }\n\n        if (_protocolFee > 0) {\n            require(_protocolFee <= FEE_PRECISION, \"Market: not valid\");\n            protocolFee = _protocolFee;\n        }\n\n        if (_liquidationBonusAmount > 0) {\n            require(\n                _liquidationBonusAmount < FEE_PRECISION,\n                \"Market: not valid\"\n            );\n            liquidationBonusAmount = _liquidationBonusAmount;\n        }\n\n        if (_minLiquidatorReward > 0) {\n            require(_minLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(\n                _minLiquidatorReward < maxLiquidatorReward,\n                \"Market: not valid\"\n            );\n            minLiquidatorReward = _minLiquidatorReward;\n        }\n\n        if (_maxLiquidatorReward > 0) {\n            require(_maxLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(\n                _maxLiquidatorReward > minLiquidatorReward,\n                \"Market: not valid\"\n            );\n            maxLiquidatorReward = _maxLiquidatorReward;\n        }\n\n        if (_totalBorrowCap > 0) {\n            emit LogBorrowCapUpdated(totalBorrowCap, _totalBorrowCap);\n            totalBorrowCap = _totalBorrowCap;\n        }\n\n        if (_collateralizationRate > 0) {\n            require(\n                _collateralizationRate <= FEE_PRECISION,\n                \"Market: not valid\"\n            );\n            collateralizationRate = _collateralizationRate;\n        }\n    }\n\n    /// @notice updates the pause state of the contract\n    /// @dev can only be called by the conservator\n    /// @param val the new value\n    function updatePause(bool val) external {\n        require(msg.sender == conservator, \"Market: unauthorized\");\n        require(val != paused, \"Market: same state\");\n        emit PausedUpdated(paused, val);\n        paused = val;\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns the maximum liquidatable amount for user\n    function computeClosingFactor(\n        uint256 borrowPart,\n        uint256 collateralPartInAsset,\n        uint256 borrowPartDecimals,\n        uint256 collateralPartDecimals,\n        uint256 ratesPrecision\n    ) public view returns (uint256) {\n        uint256 borrowPartScaled = borrowPart;\n        if (borrowPartDecimals > 18) {\n            borrowPartScaled = borrowPart / (10 ** (borrowPartDecimals - 18));\n        }\n        if (borrowPartDecimals < 18) {\n            borrowPartScaled = borrowPart * (10 ** (18 - borrowPartDecimals));\n        }\n\n        uint256 collateralPartInAssetScaled = collateralPartInAsset;\n        if (collateralPartDecimals > 18) {\n            collateralPartInAssetScaled =\n                collateralPartInAsset /\n                (10 ** (collateralPartDecimals - 18));\n        }\n        if (collateralPartDecimals < 18) {\n            collateralPartInAssetScaled =\n                collateralPartInAsset *\n                (10 ** (18 - collateralPartDecimals));\n        }\n\n        uint256 liquidationStartsAt = (collateralPartInAssetScaled *\n            collateralizationRate) / (10 ** ratesPrecision);\n        if (borrowPartScaled < liquidationStartsAt) return 0;\n\n        uint256 numerator = borrowPartScaled -\n            ((collateralizationRate * collateralPartInAssetScaled) /\n                (10 ** ratesPrecision));\n        uint256 denominator = ((10 ** ratesPrecision) -\n            (collateralizationRate *\n                ((10 ** ratesPrecision) + liquidationMultiplier)) /\n            (10 ** ratesPrecision)) * (10 ** (18 - ratesPrecision));\n\n        uint256 x = (numerator * 1e18) / denominator;\n        return x;\n    }\n\n    /// @notice return the amount of collateral for a `user` to be solvent, min TVL and max TVL. Returns 0 if user already solvent.\n    /// @dev we use a `CLOSED_COLLATERIZATION_RATE` that is a safety buffer when making the user solvent again,\n    ///      to prevent from being liquidated. This function is valid only if user is not solvent by `_isSolvent()`.\n    /// @param user The user to check solvency.\n    /// @param _exchangeRate the exchange rate asset/collateral.\n    /// @return amountToSolvency the amount of collateral to be solvent.\n    function computeTVLInfo(\n        address user,\n        uint256 _exchangeRate\n    )\n        public\n        view\n        returns (uint256 amountToSolvency, uint256 minTVL, uint256 maxTVL)\n    {\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return (0, 0, 0);\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 collateralAmountInAsset = _computeMaxBorrowableAmount(\n            user,\n            _exchangeRate\n        );\n\n        borrowPart = (borrowPart * _totalBorrow.elastic) / _totalBorrow.base;\n\n        amountToSolvency = borrowPart >= collateralAmountInAsset\n            ? borrowPart - collateralAmountInAsset\n            : 0;\n\n        (minTVL, maxTVL) = _computeMaxAndMinLTVInAsset(\n            userCollateralShare[user],\n            _exchangeRate\n        );\n    }\n\n    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.\n    /// @dev This function is supposed to be invoked if needed because Oracle queries can be expensive.\n    ///      Oracle should consider USDO at 1$\n    /// @return updated True if `exchangeRate` was updated.\n    /// @return rate The new exchange rate.\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\n        (updated, rate) = oracle.get(\"\");\n\n        if (updated) {\n            require(rate > 0, \"Market: invalid rate\");\n            exchangeRate = rate;\n            emit LogExchangeRate(rate);\n        } else {\n            // Return the old rate if fetching wasn't successful\n            rate = exchangeRate;\n        }\n    }\n\n    /// @notice computes the possible liquidator reward\n    /// @notice user the user for which a liquidation operation should be performed\n    /// @param _exchangeRate the exchange rate asset/collateral to use for internal computations\n    function computeLiquidatorReward(\n        address user,\n        uint256 _exchangeRate\n    ) public view returns (uint256) {\n        (uint256 minTVL, uint256 maxTVL) = _computeMaxAndMinLTVInAsset(\n            userCollateralShare[user],\n            _exchangeRate\n        );\n        return _getCallerReward(userBorrowPart[user], minTVL, maxTVL);\n    }\n\n    // ************************** //\n    // *** INTERNAL FUNCTIONS *** //\n    // ************************** //\n    function _accrue() internal virtual;\n\n    function _getRevertMsg(\n        bytes memory _returnData\n    ) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Market: no return data\";\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    function _computeMaxBorrowableAmount(\n        address user,\n        uint256 _exchangeRate\n    ) internal view returns (uint256 collateralAmountInAsset) {\n        collateralAmountInAsset =\n            yieldBox.toAmount(\n                collateralId,\n                (userCollateralShare[user] *\n                    (EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n                    collateralizationRate),\n                false\n            ) /\n            _"
    }
  ]
}