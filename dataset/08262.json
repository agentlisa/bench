{
  "Title": "[H-02] Automation / management can be set for not yet existing vault",
  "Content": "_Submitted by Lambda, also found by ayeslick_\n\n<https://github.com/code-423n4/2022-08-mimo/blob/9adf46f2efc61898247c719f2f948b41d5d62bbe/contracts/actions/automated/MIMOAutoAction.sol#L33>\n\n<https://github.com/code-423n4/2022-08-mimo/blob/9adf46f2efc61898247c719f2f948b41d5d62bbe/contracts/actions/managed/MIMOManagedAction.sol#L35>\n\n### Impact & Proof Of Concept\n\n`vaultOwner` returns zero for a non-existing `vaultId`. Similarly, `proxyRegistry.getCurrentProxy(msg.sender)` returns zero when `msg.sender` has not deployed a proxy yet. Those two facts can be combined to set automation for a vault ID that does not exist yet. When this is done by a user without a proxy, it will succeed, as both `vaultOwner` and `mimoProxy` are `address(0)`, i.e. we have `vaultOwner == mimoProxy`.\n\nThe consequences of this are quite severe. As soon as the vault is created, it will be an automated vault (with potentially very high fees). An attacker can exploit this by setting very high fees before the creation of the vault and then performing actions for the automated vault, which leads to a loss of funds for the user.\n\nThe same attack is possible for `setManagement`.\n\n### Recommended Mitigation Steps\n\nDo not allow setting automation parameters for non-existing vaults, i.e. check that `vaultOwner != address(0)`.\n\n**[RayXpub (Mimo) confirmed and commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/68#issuecomment-1210497317):**\n > We confirm that this is a high risk issue and intend to fix this.\n\n**horsefacts (warden) reviewed mitigation:**\n> **Status:** âœ… Resolved after review (see finding M.H-01 in Mitigation Review section below)\n\n> **Finding:** Wardens identified that malicious callers could configure automation and management parameters for uninitialized vaults when vault owner and proxy address were unset for a given vault ID and caller and returned `adress(0)`, which caused an access control check to unintentionally pass.\n\n> **What changed:** `MIMOAutoAction#setAutomation` now [checks](https://github.com/mimo-capital/2022-08-mimo/blob/4e579420ecbe3fc3e770996610e6ab66b0c8d15b/contracts/actions/automated/MIMOAutoAction.sol#L34) whether the vault owner is the zero address. An [integration test](https://github.com/mimo-capital/2022-08-mimo/blob/4e579420ecbe3fc3e770996610e6ab66b0c8d15b/test/02_integration/automated/MIMOAutoActionSecurity.test.ts#L119) demonstrates that attempting to call `setAutomation` on an uninitialized vault will revert. `MIMOManagedAction#setAutomation` performs the same [check](https://github.com/mimo-capital/2022-08-mimo/blob/5a63c76ed74186d11d3adb361d3b3aacefa7795e/contracts/actions/managed/MIMOManagedAction.sol#L37), and an [integration test](https://github.com/mimo-capital/2022-08-mimo/blob/5a63c76ed74186d11d3adb361d3b3aacefa7795e/test/01_unit/managed/MIMOManagedAction.test.ts#L123) exercises it.  \n\n> **Why it works:** Since `setAutomation` now explicitly checks that the vault is initialized, configuration cannot be set for an uninitialized vault.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-08-mimo-august-2022-contest",
  "Code": [
    {
      "filename": "contracts/actions/automated/MIMOAutoAction.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"./interfaces/IMIMOAutoAction.sol\";\nimport \"../../core/interfaces/IAddressProvider.sol\";\nimport { CustomErrors } from \"../../libraries/CustomErrors.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\ncontract MIMOAutoAction is IMIMOAutoAction {\n  using WadRayMath for uint256;\n\n  IAddressProvider public immutable a;\n  IMIMOProxyRegistry public immutable proxyRegistry;\n\n  mapping(uint256 => AutomatedVault) internal _automatedVaults;\n  mapping(uint256 => uint256) internal _operationTracker;\n\n  constructor(IAddressProvider _a, IMIMOProxyRegistry _proxyRegistry) {\n    if (address(_a) == address(0) || address(_proxyRegistry) == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    a = _a;\n    proxyRegistry = _proxyRegistry;\n  }\n\n  /**\n    @notice Sets a vault automation parameters\n    @dev Can only be called by vault owner\n    @param vaultId Vault id of the vault to be automated\n    @param autoParams AutomatedVault struct containing all automation parameters\n   */\n  function setAutomation(uint256 vaultId, AutomatedVault calldata autoParams) external override {\n    address vaultOwner = a.vaultsData().vaultOwner(vaultId);\n    address mimoProxy = address(proxyRegistry.getCurrentProxy(msg.sender));\n\n    if (mimoProxy != vaultOwner && vaultOwner != msg.sender) {\n      revert CustomErrors.CALLER_NOT_VAULT_OWNER(mimoProxy, vaultOwner);\n    }\n\n    uint256 toVaultMcr = a.config().collateralMinCollateralRatio(autoParams.toCollateral);\n    uint256 maxVarFee = (autoParams.targetRatio.wadDiv(toVaultMcr + autoParams.mcrBuffer) + WadRayMath.WAD).wadDiv(\n      autoParams.targetRatio\n    );\n\n    if (autoParams.varFee >= maxVarFee) {\n      revert CustomErrors.VARIABLE_FEE_TOO_HIGH(maxVarFee, autoParams.varFee);\n    }\n\n    _automatedVaults[vaultId] = autoParams;\n\n    emit AutomationSet(vaultId, autoParams);\n  }\n\n  /**\n    @return AutomatedVault struct of a specific vault id\n   */\n  function getAutomatedVault(uint256 vaultId) external view override returns (AutomatedVault memory) {\n    return _automatedVaults[vaultId];\n  }\n\n  /**\n    @return Timestamp of the last performed operation\n   */\n  function getOperationTracker(uint256 vaultId) external view override returns (uint256) {\n    return _operationTracker[vaultId];\n  }\n\n  /**\n    @notice Helper function calculating a vault's net value and LTV ratio\n    @param vaultId Vault id of the vault for which to return info\n    @return vaultRatio Vault collateral value / vault debt\n    @return vaultState VaultState struct of the target vault\n   */\n  function _getVaultStats(uint256 vaultId) internal view returns (uint256 vaultRatio, VaultState memory vaultState) {\n    IAddressProvider _a = a;\n    IVaultsDataProvider vaultsData = _a.vaultsData();\n    IPriceFeed priceFeed = _a.priceFeed();\n\n    uint256 collateralBalance = vaultsData.vaultCollateralBalance(vaultId);\n    address collateralType = vaultsData.vaultCollateralType(vaultId);\n    uint256 collateralValue = priceFeed.convertFrom(collateralType, collateralBalance);\n    uint256 vaultDebt = vaultsData.vaultDebt(vaultId);\n    vaultRatio = vaultDebt == 0 ? type(uint256).max : collateralValue.wadDiv(vaultDebt);\n\n    vaultState = VaultState({ collateralType: collateralType, collateralValue: collateralValue, vaultDebt: vaultDebt });\n  }\n\n  /**\n    @notice Helper function determining if a vault value variation is within vault's management parameters\n    @return True if value change is below allowedVariation and false if it is above\n   */\n  function _isVaultVariationAllowed(\n    AutomatedVault memory autoVault,\n    uint256 rebalanceValue,\n    uint256 swapResultValue\n  ) internal pure returns (bool) {\n    if (swapResultValue >= rebalanceValue) {\n      return true;\n    }\n\n    uint256 vaultVariation = (rebalanceValue - swapResultValue).wadDiv(rebalanceValue);\n\n    if (vaultVariation > autoVault.allowedVariation) {\n      return false;\n    }\n\n    return true;\n  }\n}"
    },
    {
      "filename": "contracts/actions/managed/MIMOManagedAction.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"./interfaces/IMIMOManagedAction.sol\";\nimport { CustomErrors } from \"../../libraries/CustomErrors.sol\";\nimport \"../../core/interfaces/IAddressProvider.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\ncontract MIMOManagedAction is IMIMOManagedAction {\n  using WadRayMath for uint256;\n\n  IAddressProvider public immutable a;\n  IMIMOProxyRegistry public immutable proxyRegistry;\n\n  mapping(uint256 => ManagedVault) internal _managedVaults;\n  mapping(uint256 => uint256) internal _operationTracker;\n  mapping(address => bool) internal _managers;\n\n  constructor(IAddressProvider _a, IMIMOProxyRegistry _proxyRegistry) {\n    if (address(_a) == address(0) || address(_proxyRegistry) == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    a = _a;\n    proxyRegistry = _proxyRegistry;\n  }\n\n  /**\n    @notice Sets a vault management parameters\n    @dev Can only be called by vault owner and can only appoint whitelisting managers as manger\n    @param vaultId Vault id of the vault to be put under management\n    @param mgtParams ManagedVault struct containing all management parameters\n   */\n  function setManagement(uint256 vaultId, ManagedVault calldata mgtParams) external override {\n    address vaultOwner = a.vaultsData().vaultOwner(vaultId);\n    address mimoProxy = address(proxyRegistry.getCurrentProxy(msg.sender));\n\n    if (mimoProxy != vaultOwner && vaultOwner != msg.sender) {\n      revert CustomErrors.CALLER_NOT_VAULT_OWNER(mimoProxy, vaultOwner);\n    }\n    if (!_managers[mgtParams.manager]) {\n      revert CustomErrors.MANAGER_NOT_LISTED();\n    }\n\n    _managedVaults[vaultId] = mgtParams;\n\n    emit ManagementSet(vaultId, mgtParams);\n  }\n\n  /**\n    @notice Whitelists or removes a manager\n    @dev Can only be called by protocol manager\n    @param manager Manager address\n    @param isManager Bool value indicating if an address is allowed to manage user vaults or not\n   */\n  function setManager(address manager, bool isManager) external override {\n    IAccessController controller = a.controller();\n\n    if (!controller.hasRole(controller.MANAGER_ROLE(), msg.sender)) {\n      revert CustomErrors.CALLER_NOT_PROTOCOL_MANAGER();\n    }\n\n    _managers[manager] = isManager;\n\n    emit ManagerSet(manager, isManager);\n  }\n\n  /**\n    @return ManagedVault struct of a specific vault id\n   */\n  function getManagedVault(uint256 vaultId) external view override returns (ManagedVault memory) {\n    return _managedVaults[vaultId];\n  }\n\n  /**\n    @return Timestamp of the last performed operation\n   */\n  function getOperationTracker(uint256 vaultId) external view override returns (uint256) {\n    return _operationTracker[vaultId];\n  }\n\n  /**\n    @return Bool value indicating if an address is allowed to manage user vaults or not\n   */\n  function getManager(address manager) external view override returns (bool) {\n    return _managers[manager];\n  }\n\n  /**\n    @notice Helper function calculating LTV ratio\n    @return Vault collateral value / vault debt\n   */\n  function _getVaultRatio(uint256 vaultId) internal view returns (uint256) {\n    IAddressProvider _a = a;\n    IVaultsDataProvider vaultsData = _a.vaultsData();\n    IPriceFeed priceFeed = _a.priceFeed();\n\n    uint256 collateralBalance = vaultsData.vaultCollateralBalance(vaultId);\n    address collateralType = vaultsData.vaultCollateralType(vaultId);\n    uint256 collateralValue = priceFeed.convertFrom(collateralType, collateralBalance);\n    uint256 vaultDebt = vaultsData.vaultDebt(vaultId);\n\n    if (vaultDebt == 0) {\n      return (type(uint256).max);\n    }\n\n    uint256 vaultRatio = collateralValue.wadDiv(vaultDebt);\n\n    return (vaultRatio);\n  }\n\n  /**\n    @notice Helper function determining if a vault value variation is within vault's management parameters\n    @return True if value change is below allowedVariation and false if it is above\n   */\n  function _isVaultVariationAllowed(\n    ManagedVault memory managedVault,\n    uint256 rebalanceValue,\n    uint256 swapResultValue\n  ) internal pure returns (bool) {\n    if (swapResultValue >= rebalanceValue) {\n      return true;\n    }\n\n    uint256 vaultVariation = (rebalanceValue - swapResultValue).wadDiv(rebalanceValue);\n\n    if (vaultVariation > managedVault.allowedVariation) {\n      return false;\n    }\n\n    return true;\n  }\n}"
    },
    {
      "filename": "contracts/actions/automated/MIMOAutoAction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol\";\nimport \"./interfaces/IMIMOAutoAction.sol\";\nimport \"../../core/interfaces/IAddressProvider.sol\";\nimport { Errors } from \"../../libraries/Errors.sol\";\n\ncontract MIMOAutoAction is IMIMOAutoAction {\n  using WadRayMath for uint256;\n\n  IAddressProvider public immutable a;\n  IMIMOProxyFactory public immutable proxyFactory;\n\n  mapping(uint256 => AutomatedVault) internal _automatedVaults;\n  mapping(uint256 => uint256) internal _operationTracker;\n\n  constructor(IAddressProvider _a, IMIMOProxyFactory _proxyFactory) {\n    if (address(_a) == address(0) || address(_proxyFactory) == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    a = _a;\n    proxyFactory = _proxyFactory;\n  }\n\n  /**\n    @notice Sets a vault automation parameters\n    @dev Can only be called by vault owner\n    @param vaultId Vault id of the vault to be automated\n    @param autoParams AutomatedVault struct containing all automation parameters\n   */\n  function setAutomation(uint256 vaultId, AutomatedVault calldata autoParams) external override {\n    address vaultOwner = a.vaultsData().vaultOwner(vaultId); // vaultOwner is the owner in vaultsCore\n    if (vaultOwner == address(0)) {\n      revert Errors.VAULT_NOT_INITIALIZED(vaultId);\n    }\n    address mimoProxy = address(proxyFactory.getCurrentProxy(msg.sender));\n\n    // If msg.sender isn't the mimoProxy, msg.sender should own the mimoProxy for the vaultId\n    if (vaultOwner != msg.sender) {\n      if (mimoProxy != vaultOwner) {\n        revert Errors.CALLER_NOT_VAULT_OWNER(mimoProxy, vaultOwner);\n      }\n    }\n    uint256 toVaultMcr = a.config().collateralMinCollateralRatio(autoParams.toCollateral);\n    uint256 maxVarFee = (autoParams.targetRatio.wadDiv(toVaultMcr + autoParams.mcrBuffer) + WadRayMath.WAD).wadDiv(\n      autoParams.targetRatio\n    );\n\n    if (autoParams.varFee >= maxVarFee) {\n      revert Errors.VARIABLE_FEE_TOO_HIGH(maxVarFee, autoParams.varFee);\n    }\n\n    _automatedVaults[vaultId] = autoParams;\n\n    emit AutomationSet(vaultId, autoParams);\n  }\n\n  /**\n    @param vaultId Vault id of the queried vault\n    @return AutomatedVault struct of a specific vault id\n   */\n  function getAutomatedVault(uint256 vaultId) external view override returns (AutomatedVault memory) {\n    return _automatedVaults[vaultId];\n  }\n\n  /**\n    @param vaultId Vault id of the queried vault\n    @return Timestamp of the last performed operation\n   */\n  function getOperationTracker(uint256 vaultId) external view override returns (uint256) {\n    return _operationTracker[vaultId];\n  }\n\n  /**\n    @notice Helper function calculating a vault's net value and LTV ratio\n    @param vaultId Vault id of the queried vault\n    @return vaultRatio Vault collateral value / vault debt\n    @return vaultState VaultState struct of the target vault\n   */\n  function _getVaultStats(uint256 vaultId) internal view returns (uint256 vaultRatio, VaultState memory vaultState) {\n    IAddressProvider _a = a;\n    IVaultsDataProvider vaultsData = _a.vaultsData();\n    IPriceFeed priceFeed = _a.priceFeed();\n\n    uint256 collateralBalance = vaultsData.vaultCollateralBalance(vaultId);\n    address collateralType = vaultsData.vaultCollateralType(vaultId);\n    uint256 collateralValue = priceFeed.convertFrom(collateralType, collateralBalance);\n    uint256 vaultDebt = vaultsData.vaultDebt(vaultId);\n    vaultRatio = vaultDebt == 0 ? type(uint256).max : collateralValue.wadDiv(vaultDebt);\n\n    vaultState = VaultState({ collateralType: collateralType, collateralValue: collateralValue, vaultDebt: vaultDebt });\n  }\n\n  /**\n    @notice Helper function determining if a vault value variation is within vault's management parameters\n    @param autoVault AutomatedVault struct of the vault being rebalanced\n    @param rebalanceValue Rebalance value in stablex\n    @param swapResultValue Collateral value in stablex after swap\n    @return True if value change is below allowedVariation and false if it is above\n   */\n  function _isVaultVariationAllowed(\n    AutomatedVault memory autoVault,\n    uint256 rebalanceValue,\n    uint256 swapResultValue\n  ) internal pure returns (bool) {\n    if (swapResultValue >= rebalanceValue) {\n      return true;\n    }\n\n    uint256 vaultVariation = (rebalanceValue - swapResultValue).wadDiv(rebalanceValue);\n\n    if (vaultVariation > autoVault.allowedVariation) {\n      return false;\n    }\n\n    return true;\n  }\n}"
    }
  ]
}