{
  "Title": "M-4: LibTWAPOracle::update Providing large liquidity will manipulate TWAP, DOSing redeem of uADs",
  "Content": "# Issue M-4: LibTWAPOracle::update Providing large liquidity will manipulate TWAP, DOSing redeem of uADs \n\nSource: https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/56 \n\n## Found by \nGatewayGuardians, KupiaSec, cducrest-brainbot, cergyk, evmboi32\n## Summary\nThe twap oracle used by ubiquity does not compute a TWAP (Time weighted average price) but an instant price based on time weighted average of balances, and thus is more vulnerable to manipulation by an actor temporarily allocating a large amount to the metapool.\n\n## Vulnerability Detail\nWe can see the `LibTWAPOracle::update()` calls on \n`IMetapool::get_twap_balances(uint256[2] memory _first_balances, uint256[2] memory _last_balances, uint256 _time_elapsed)` which gets the time-weighted average of the pool reserves given time_elapsed and cumulative balances.\n\nThen the time-weighted average is deduced by using the average of reserves over the `time_elapsed`. However we can see that a user with a large amount of capital and controlling 2 consecutive blocks can either add large liquidity in an imbalanced way in block N, and remove in block N+1.\nIn that case the `higher` reserves ratio will have a higher weight in the computation and will last for many blocks.\n\n### Scenario\n1/ In block N-1:\n\nMetapool contains 10 of uAD and 10 of 3CRV, the price is balanced, and withdrawals of uAD are accepted.\n\n2/ In block N: \n\nAlice updates both metapool twap and ubiquityPool twap. \n\nAlice provides 100 uAD and 200 3CRV to the pool, now reserves are 110 uAD and 210 3CRV\n\n3/ In block N+1:\n\nAlice removes the previously added liquidity putting the reserves back to 10 uAD and 10 3CRV, but does not updates UbiquityPool right away.\n\n4/ In block N+40:\n\nAlice updates both Metapool and ubiquity TWAP oracle, \n\nLet's see the value which is computed for the returned TWAP: \n\nuAD cumulative reserve difference = 12\\*110+12\\*40\\*10 = 6120\n3CRV cumulative reserve difference = 12\\*210+12\\*40\\*10 = 7320\n\nWe can see that the reserves are still very imbalanced even 40 blocks after the 2 blocks manipulation, blocking withdrawals, because uAD price versus 3CRV is too high:\nhttps://github.com/sherlock-audit/2023-12-ubiquity/blob/main/ubiquity-dollar/packages/contracts/src/dollar/libraries/LibUbiquityPool.sol#L418-L421\n\n## Impact\nA malicious user with access to considerable capital and controlling two consecutive blocks (feasible since the merge), can DOS the withdraw functionality of UbiquityPool for many blocks.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nFind a way to compute the twap of the price (as Uniswap v3 does), instead of using twap of balances as a proxy \n\n\n\n## Discussion\n\n**gitcoindev**\n\n@rndquu @pavlovcik @molecula451 what do you think about this one? Technically possible, but would likely require lots of staked ETH. I am wondering if this is just hypothetical and controlling 2 blocks would require funds of e.g. Coinbase size. If this is the case, then perhaps impact is high but probability is very low. There are currently ~900k ETH validators https://beaconcha.in/charts/validators with each staked at least 32 ETH. \n\n**pavlovcik**\n\nI spent some time looking through our old issues and discussions but unfortunately I couldn't find my writeup on this. Basically as I recall, after The Merge there was a research report that proved how a two-consecutive-block TWAP attack could be performed with a realistic amount of funds. \n\nUnfortunately I don't remember the conclusion of how to mitigate.\n\n**rndquu**\n\n> uAD cumulative reserve difference = 12*110+12*40*10 = 6120\n> 3CRV cumulative reserve difference = 12*210+12*40*10 = 7320\n\nTWAP window here is ~8 minutes. If we take a 30 minutes TWAP window (suggested everywhere) we get `uAD cumulative reserves = 19320 & 3CRV cumulative reserves = 20520` which is much closer to a balanced pool.\n\nOverall this seems to be a duplicate of https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/20 since increasing the TWAP window fixes the issue (to some extent).\n\n\n**rndquu**\n\nSo, as far as I understand, the core issue is that the [curve metapool](https://etherscan.io/address/0x20955CB69Ae1515962177D164dfC9522feef567E#code) uses accumulated balances instead of accumulated spot prices hence the TWAP is not as accurate as it could be.\n\nI agree that it could be improved but disagree with the \"high\" severity.\n\n**0xLogos**\n\nEscalate\nShould be low. According to sherlock rules [here](https://docs.sherlock.xyz/audits/judging/judging#iii.-some-standards-observed). \n\n> If it will result in funds being inaccessible for >=1 year, then it would count as a loss of funds and be eligible for a Medium or High designation. \n\nIn this issue attacker would need a large amount of funds (exactly 15 times more than curve pool reserves according to example) and control over 2 consecutive block (feasible, but very difficult) just to dos withdrawals for short time (in example 40 blocks = 12*40/60 = 8 min). \n\n**sherlock-admin2**\n\n> Escalate\n> Should be low. According to sherlock rules [here](https://docs.sherlock.xyz/audits/judging/judging#iii.-some-standards-observed). \n> \n> > If it will result in funds being inaccessible for >=1 year, then it would count as a loss of funds and be eligible for a Medium or High designation. \n> \n> In this issue attacker would need a large amount of funds (exactly 15 times more than curve pool reserves according to example) and control over 2 consecutive block (feasible, but very difficult) just to dos withdrawals for short time (in example 40 blocks = 12*40/60 = 8 min). \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\n@CergyK any comments?\n\n**0xLogos**\n\nI also want to note that the proposed solution is quite difficult to implement correctly and I believe that it is an acceptable risk to leave it as is\n\n**0x3agle**\n\nIs uAD TWAP manipulatable?\nshort answer - Yes. Long answer - https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/72#issuecomment-1909410503\nPointing out that #212's main focus is on shorting the collateral at the cost of UbiquityPool. So, it should not be a duplicate of this issue\n\n**0xLogos**\n\n@0x3agle It is manipulatable because of #20\nI think firstly this issue should be fixed (not so trivial as recommended in report)\nAlso collateral tokens are \"stealed\" during arb\n\n**0x3agle**\n\n@0xLogos, even after addressing issue 20, the system remains susceptible to manipulation.\n\nIn a standard arbitrage situation, specific conditions enable arbitrageurs to profit. \n\nHowever, #212 deviates from this. Here, the attacker can intentionally trigger redemptions to acquire collateral at a lower price by influencing the uAD price. This means the attacker can engineer favorable conditions, rather than relying on chance, effectively manipulating the protocol to their advantage.\n\n**0xLogos**\n\n> The attacker opts to swap 3,000 uAD for X amount of 3CRV in the Curve pool, strategically lowering the \"spot price\" of uAD.\n\nfrom https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/72#issuecomment-1909410503\n\nDoesn't look like manipulation\n\n**0x3agle**\n\nThe attacker can lower the price to enable redeems as they can now get collateral for lower price. If this isn't manipulation, then what is it?\n\nEdit: improved the wording in the comment.\n\n**0xArz**\n\n@0x3agle but why would you even need to manipulate the twap? I think your issue describes pretty much the same thing as https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/72 and the root cause is the same - collateral depegging. The attack will be possible without the TWAP manipulation(assuming the the price of uAD stays at $1.00)\n\n\nTotal Spent: 97,000 LUSD (for minting uAD) + ~$50 (Slippage for swapping twice [uAD to 3CRV then 3CRV to uAD])\nTotal Received: 101,000 LUSD\nProfit: ~3,800 LUSD\n\nThere is no actual profit here, because 97,000 LUSD at $1.03 is worth the same as 101,000 LUSD at $0.99\n\nAlso i believe the redeemPriceThreshold is $1.01 not $0.99, it wouldnt make sense to not allow users to redeem when the price is $1.00 right? Would be great if sponsor could confirm this\n\nI think what you are saying is that you can manipulate the price so that redeems are opened but i believe that the redeemPriceThreshold is $1.01 so you dont have to manipulate anything but just wait when the collateral drops\n\n**0xLogos**\n\n> There is no actual profit here, because 97,000 LUSD at $1.03 is worth the same as 101,000 LUSD at $0.99\n\nGood point\n\n**0x3agle**\n\n@0xArz \n\nThis is called as hedging.\nThere is no profit but if the attacker held those 97,000 LUSD at $1.03 and when it drops to $0.99, the attacker loses 4%.\n\nBy applying this strategy, the attacker offsets the losses at the cost of protocol. Therefore, the attacker does not lose any value.\n\nRegarding redeem threshold: you are saying that to enable redeem, the uAD should go up instead of down.\nThink about it: if uAD goes up to $1.01, there is more demand. We need the uAD to move down to $1.\nYou can't control demand, you can control the supply.\n\nWhat will you do to level the uAD back? - Mint.\nIncrease the supply to match the demand. So, we want to enable mints when uAD goes up.\n\nWhen uAD goes down to $0.99, the supply is more demand is less. Therefore we need to burn the uAD to match supply and demand. Hence redeem will be enabled if uAD goes below $0.99\n\n\n**0xArz**\n\n@0x3agle \n\n```solidity\nrequire(\n            getDollarPriceUsd() >= poolStorage.mintPriceThreshold,\n            \"Dollar price too low\"\n        );\n\n```\nSo you are saying that the mintPriceThreshold is $1.01? How will then users be able to mint uAD when the curve pool was just created and the price is $1.00? \n\n$0.99 for minting and $1.01 for redeeming makes more sense.\n\nSame impact like in https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/72 btw\n\n\n**0x3agle**\n\nWhen the pool is first deployed, users can neither mint or redeem.\n\nThe demand for uAD arises. Users start buying it using 3CRV from curve pool. \n\nSo, eventually the twap will show an increased price. Letâ€™s say $1.02\nNow, the mints on the pool will be unlocked. So users can technically mint more uAD for exact amount from Ubiquity Pool instead of 3CRV. This will lead to arbitrage, balancing the curve pool. So, now the pool will reflect the stable price of $1 for uAD.\n\nHow will redeems be unlocked?\nIn case a lot if uAD is minted, users will swap it for 3CRV in the curve pool. Increasing the supply of uAD in curve pool. Therefore reducing the price of uAD, let's say $0.98\n\nNow redeems will be enabled (mints are disabled) which will give you more collateral for same uAD. Again arbitrage, leading to curve pool balance. Stabilising price of uAD back to $1- disabling any mints or redeems\n\n**0xArz**\n\nhey @pavlovcik @gitcoindev @rndquu what are the correct thresholds that will be used? In the [tests](https://github.com/ubiquity/ubiquity-dollar/blob/38c3656539ae19fe9be162f566b36ec62a3e6e41/packages/contracts/test/diamond/facets/UbiquityPoolFacet.t.sol#L110) the mintPriceThreshold is set to $1.01 and the redeemPriceThreshold is set to $0.99 which means that when the price is $1.00 users will not be able to mint or redeem uAD. This doesnt really makes sense as users are supposed to be able to obtain uAD on a 1:1 ratio or is the UbiquityPool just going to be used to rebalance the price? Thank you in advance!\n\n**pavlovcik**\n\n> Also i believe the redeemPriceThreshold is $1.01 not $0.99, it wouldnt make sense to not allow users to redeem when the price is $1.00 right? Would be great if sponsor could confirm this\n\nMinting above $1.00 and redemptions below $1.00. The threshold should be adjustable so for now `redeemPriceThreshold` should be $0.99. That way a user can purchase $0.99 \"dollars\" from the market and then redeem them for $1.00 worth of collateral. This stabilizes the price floor. \n\n> which means that when the price is $1.00 users will not be able to mint or redeem uAD. This doesnt really makes sense as users are supposed to be able to obtain uAD on a 1:1 ratio or is the UbiquityPool just going to be used to rebalance the price? Thank you in advance!\n\nThat's a good question. We have an [application](https://dao.ubq.fi/devpool) to manage and incentivize distributed teams which offers incentives to settle payments in our Ubiquity Dollars. Assuming that there is some demand generated for our Ubiquity Dollars with our DevPool system, we should easily be able to move the price above the threshold. \n\nIf there is no demand, I think it makes sense for the protocol to not respond with incentives to change the supply. \n\n**CergyK**\n\n> @CergyK any comments?\n\nIt seems the escalation is based on the fact that a relatively short (?) duration was used in the example.\nThis duration can be arbitrarily extended by using more capital.\nOverall this should not be happening in a TWAP, and for example in the TWAP as implemented in Uniswap, it is not possible to manipulate more efficiently by providing more liquidity during 2 blocks. \n\n**rndquu**\n\n> hey @pavlovcik @gitcoindev @rndquu what are the correct thresholds that will be used? In the [tests](https://github.com/ubiquity/ubiquity-dollar/blob/38c3656539ae19fe9be162f566b36ec62a3e6e41/packages/contracts/test/diamond/facets/UbiquityPoolFacet.t.sol#L110) the mintPriceThreshold is set to $1.01 and the redeemPriceThreshold is set to $0.99 which means that when the price is $1.00 users will not be able to mint or redeem uAD. This doesnt really makes sense as users are supposed to be able to obtain uAD on a 1:1 ratio or is the UbiquityPool just going to be used to rebalance the price? Thank you in advance!\n\nUsers may also get Dollar(`uAD`) tokens on secondary markets\n\n**0xLogos**\n\n> It seems the escalation is based on the fact that a relatively short (?) duration was used in the example. This duration can be arbitrarily extended by using more capital. Overall this should not be happening in a TWAP, and for example in the TWAP as implemented in Uniswap, it is not possible to manipulate more efficiently by providing more liquidity during 2 blocks.\n\n@pavlovcik @rndquu First of all we need to know max aceptable by protocol team time that pool can be DOSed taking into account that admin can  in any time prevent DOS by adjusting threshholds. Based on example you need 100K pool liquidity * 15 = 1.5M$ AND control over 2 block to DOS for 8 min (correct me if i am wrong)\n\n**rndquu**\n\n> > It seems the escalation is based on the fact that a relatively short (?) duration was used in the example. This duration can be arbitrarily extended by using more capital. Overall this should not be happening in a TWAP, and for example in the TWAP as implemented in Uniswap, it is not possible to manipulate more efficiently by providing more liquidity during 2 blocks.\n> \n> @pavlovcik @rndquu First of all we need to know max aceptable by protocol team time that pool can be DOSed taking into account that admin can in any time prevent DOS by adjusting threshholds. Based on example you need 100K pool liquidity * 15 = 1.5M$ AND control over 2 block to DOS for 8 min (correct me if i am wrong)\n\nI don't think that any time >0 seconds is an acceptable DOS duration for any protocol :)\n\n**0xLogos**\n\n> I don't think that any time >0 seconds is an acceptable DOS duration for any protocol :)\n\nSorry but this is not true. There's no perfect systems, you have to come up with suitable threat model. \n\nAlso I believe that in order to understand the severity of the issue you need to somehow evaluate the difference between  calculating price based on time average balances and using time average price like uni v3 because this is proposed solution. (If you have control over 2 block you can do similar thing with prices swapping back and forth in 2 blocks)\n\nMy point is example in report is very vague and there's need at least for more realistic PoC and ideally comparison with proposed solution.\n\n**Czar102**\n\nI believe oracle manipulation can have a more severe impact than a DoS for a few minutes, see https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/13#issuecomment-1945710223.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**0xLogos**\n\nhttps://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/13#issuecomment-1945710223 is inaccurate\n\n**CergyK**\n\nSince we are discussing this issue, it seems #184 #197 #212 are invalid/unrelated\n\n**Czar102**\n\nThank you @0xLogos for noting a mistake in my previous statement.\n@CergyK there seems to be no loss of funds impact here, I think it's just a DoS for a few minutes (TWAP length) and that's the risk of using TWAP. No serious loss is inflicted on anyone.\n\nWe are also discussing the severity of TWAP manipulation on #59 right now, it may be relevant.\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/ubiquity/ubiquity-dollar/pull/893.\n\n**Czar102**\n\nAfter extensive discussions with the LSW and the Lead Judge, planning to leave this issue a Medium severity one, as it doesn't only cause a DoS, but may allow for an easy value extraction strategy from the protocol, similar to the one described in #17 and duplicates.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xLogos](https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/56/#issuecomment-1912048200): rejected\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/138",
  "Code": [
    {
      "filename": "ubiquity-dollar/packages/contracts/src/dollar/libraries/LibUbiquityPool.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.19;\n\nimport {AggregatorV3Interface} from \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IDollarAmoMinter} from \"../interfaces/IDollarAmoMinter.sol\";\nimport {IERC20Ubiquity} from \"../interfaces/IERC20Ubiquity.sol\";\nimport {UBIQUITY_POOL_PRICE_PRECISION} from \"./Constants.sol\";\nimport {LibAppStorage} from \"./LibAppStorage.sol\";\nimport {LibTWAPOracle} from \"./LibTWAPOracle.sol\";\n\n/**\n * @notice Ubiquity pool library\n * @notice Allows users to:\n * - deposit collateral in exchange for Ubiquity Dollars\n * - redeem Ubiquity Dollars in exchange for the earlier provided collateral\n */\nlibrary LibUbiquityPool {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /// @notice Storage slot used to store data for this library\n    bytes32 constant UBIQUITY_POOL_STORAGE_POSITION =\n        bytes32(\n            uint256(keccak256(\"ubiquity.contracts.ubiquity.pool.storage\")) - 1\n        );\n\n    /// @notice Struct used as a storage for this library\n    struct UbiquityPoolStorage {\n        //========\n        // Core\n        //========\n        // minter address -> is it enabled\n        mapping(address amoMinter => bool isEnabled) isAmoMinterEnabled;\n        //======================\n        // Collateral related\n        //======================\n        // available collateral tokens\n        address[] collateralAddresses;\n        // collateral address -> collateral index\n        mapping(address collateralAddress => uint256 collateralIndex) collateralIndex;\n        // collateral index -> chainlink price feed addresses\n        address[] collateralPriceFeedAddresses;\n        // collateral index -> threshold in seconds when chainlink answer should be considered stale\n        uint256[] collateralPriceFeedStalenessThresholds;\n        // collateral index -> collateral price\n        uint256[] collateralPrices;\n        // array collateral symbols\n        string[] collateralSymbols;\n        // collateral address -> is it enabled\n        mapping(address collateralAddress => bool isEnabled) isCollateralEnabled;\n        // Number of decimals needed to get to E18. collateral index -> missing decimals\n        uint256[] missingDecimals;\n        // Total across all collaterals. Accounts for missing_decimals\n        uint256[] poolCeilings;\n        //====================\n        // Redeem related\n        //====================\n        // user -> block number (collateral independent)\n        mapping(address => uint256) lastRedeemedBlock;\n        // 1010000 = $1.01\n        uint256 mintPriceThreshold;\n        // 990000 = $0.99\n        uint256 redeemPriceThreshold;\n        // address -> collateral index -> balance\n        mapping(address user => mapping(uint256 collateralIndex => uint256 amount)) redeemCollateralBalances;\n        // number of blocks to wait before being able to collectRedemption()\n        uint256 redemptionDelayBlocks;\n        // collateral index -> balance\n        uint256[] unclaimedPoolCollateral;\n        //================\n        // Fees related\n        //================\n        // minting fee of a particular collateral index, 1_000_000 = 100%\n        uint256[] mintingFee;\n        // redemption fee of a particular collateral index, 1_000_000 = 100%\n        uint256[] redemptionFee;\n        //=================\n        // Pause related\n        //=================\n        // whether borrowing collateral by AMO minters is paused for a particular collateral index\n        bool[] isBorrowPaused;\n        // whether minting is paused for a particular collateral index\n        bool[] isMintPaused;\n        // whether redeeming is paused for a particular collateral index\n        bool[] isRedeemPaused;\n    }\n\n    /// @notice Struct used for detailed collateral information\n    struct CollateralInformation {\n        uint256 index;\n        string symbol;\n        address collateralAddress;\n        address collateralPriceFeedAddress;\n        uint256 collateralPriceFeedStalenessThreshold;\n        bool isEnabled;\n        uint256 missingDecimals;\n        uint256 price;\n        uint256 poolCeiling;\n        bool isMintPaused;\n        bool isRedeemPaused;\n        bool isBorrowPaused;\n        uint256 mintingFee;\n        uint256 redemptionFee;\n    }\n\n    /**\n     * @notice Returns struct used as a storage for this library\n     * @return uPoolStorage Struct used as a storage\n     */\n    function ubiquityPoolStorage()\n        internal\n        pure\n        returns (UbiquityPoolStorage storage uPoolStorage)\n    {\n        bytes32 position = UBIQUITY_POOL_STORAGE_POSITION;\n        assembly {\n            uPoolStorage.slot := position\n        }\n    }\n\n    //===========\n    // Events\n    //===========\n\n    /// @notice Emitted when new AMO minter is added\n    event AmoMinterAdded(address amoMinterAddress);\n    /// @notice Emitted when AMO minter is removed\n    event AmoMinterRemoved(address amoMinterAddress);\n    /// @notice Emitted on setting a chainlink's collateral price feed params\n    event CollateralPriceFeedSet(\n        uint256 collateralIndex,\n        address priceFeedAddress,\n        uint256 stalenessThreshold\n    );\n    /// @notice Emitted on setting a collateral price\n    event CollateralPriceSet(uint256 collateralIndex, uint256 newPrice);\n    /// @notice Emitted on enabling/disabling a particular collateral token\n    event CollateralToggled(uint256 collateralIndex, bool newState);\n    /// @notice Emitted when fees are updated\n    event FeesSet(\n        uint256 collateralIndex,\n        uint256 newMintFee,\n        uint256 newRedeemFee\n    );\n    /// @notice Emitted on toggling pause for mint/redeem/borrow\n    event MintRedeemBorrowToggled(uint256 collateralIndex, uint8 toggleIndex);\n    /// @notice Emitted when new pool ceiling (i.e. max amount of collateral) is set\n    event PoolCeilingSet(uint256 collateralIndex, uint256 newCeiling);\n    /// @notice Emitted when mint and redeem price thresholds are updated (1_000_000 = $1.00)\n    event PriceThresholdsSet(\n        uint256 newMintPriceThreshold,\n        uint256 newRedeemPriceThreshold\n    );\n    /// @notice Emitted when a new redemption delay in blocks is set\n    event RedemptionDelayBlocksSet(uint256 redemptionDelayBlocks);\n\n    //=====================\n    // Modifiers\n    //=====================\n\n    /**\n     * @notice Checks whether collateral token is enabled (i.e. mintable and redeemable)\n     * @param collateralIndex Collateral token index\n     */\n    modifier collateralEnabled(uint256 collateralIndex) {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        require(\n            poolStorage.isCollateralEnabled[\n                poolStorage.collateralAddresses[collateralIndex]\n            ],\n            \"Collateral disabled\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Checks whether a caller is the AMO minter address\n     */\n    modifier onlyAmoMinter() {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        require(\n            poolStorage.isAmoMinterEnabled[msg.sender],\n            \"Not an AMO Minter\"\n        );\n        _;\n    }\n\n    //=====================\n    // Views\n    //=====================\n\n    /**\n     * @notice Returns all collateral addresses\n     * @return All collateral addresses\n     */\n    function allCollaterals() internal view returns (address[] memory) {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        return poolStorage.collateralAddresses;\n    }\n\n    /**\n     * @notice Returns collateral information\n     * @param collateralAddress Address of the collateral token\n     * @return returnData Collateral info\n     */\n    function collateralInformation(\n        address collateralAddress\n    ) internal view returns (CollateralInformation memory returnData) {\n        // load the storage\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        // validation\n        require(\n            poolStorage.isCollateralEnabled[collateralAddress],\n            \"Invalid collateral\"\n        );\n\n        // get the index\n        uint256 index = poolStorage.collateralIndex[collateralAddress];\n\n        returnData = CollateralInformation(\n            index,\n            poolStorage.collateralSymbols[index],\n            collateralAddress,\n            poolStorage.collateralPriceFeedAddresses[index],\n            poolStorage.collateralPriceFeedStalenessThresholds[index],\n            poolStorage.isCollateralEnabled[collateralAddress],\n            poolStorage.missingDecimals[index],\n            poolStorage.collateralPrices[index],\n            poolStorage.poolCeilings[index],\n            poolStorage.isMintPaused[index],\n            poolStorage.isRedeemPaused[index],\n            poolStorage.isBorrowPaused[index],\n            poolStorage.mintingFee[index],\n            poolStorage.redemptionFee[index]\n        );\n    }\n\n    /**\n     * @notice Returns USD value of all collateral tokens held in the pool, in E18\n     * @return balanceTally USD value of all collateral tokens\n     */\n    function collateralUsdBalance()\n        internal\n        view\n        returns (uint256 balanceTally)\n    {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        uint256 collateralTokensCount = poolStorage.collateralAddresses.length;\n        balanceTally = 0;\n        for (uint256 i = 0; i < collateralTokensCount; i++) {\n            balanceTally += freeCollateralBalance(i)\n                .mul(10 ** poolStorage.missingDecimals[i])\n                .mul(poolStorage.collateralPrices[i])\n                .div(UBIQUITY_POOL_PRICE_PRECISION);\n        }\n    }\n\n    /**\n     * @notice Returns free collateral balance (i.e. that can be borrowed by AMO minters)\n     * @param collateralIndex collateral token index\n     * @return Amount of free collateral\n     */\n    function freeCollateralBalance(\n        uint256 collateralIndex\n    ) internal view returns (uint256) {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        return\n            IERC20(poolStorage.collateralAddresses[collateralIndex])\n                .balanceOf(address(this))\n                .sub(poolStorage.unclaimedPoolCollateral[collateralIndex]);\n    }\n\n    /**\n     * @notice Returns Dollar value in collateral tokens\n     * @param collateralIndex collateral token index\n     * @param dollarAmount Amount of Dollars\n     * @return Value in collateral tokens\n     */\n    function getDollarInCollateral(\n        uint256 collateralIndex,\n        uint256 dollarAmount\n    ) internal view returns (uint256) {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        return\n            dollarAmount\n                .mul(UBIQUITY_POOL_PRICE_PRECISION)\n                .div(10 ** poolStorage.missingDecimals[collateralIndex])\n                .div(poolStorage.collateralPrices[collateralIndex]);\n    }\n\n    /**\n     * @notice Returns Ubiquity Dollar token USD price (1e6 precision) from Curve Metapool (Ubiquity Dollar, Curve Tri-Pool LP)\n     * @return dollarPriceUsd USD price of Ubiquity Dollar\n     */\n    function getDollarPriceUsd()\n        internal\n        view\n        returns (uint256 dollarPriceUsd)\n    {\n        // get Dollar price from Curve Metapool (18 decimals)\n        uint256 dollarPriceUsdD18 = LibTWAPOracle.getTwapPrice();\n        // convert to 6 decimals\n        dollarPriceUsd = dollarPriceUsdD18\n            .mul(UBIQUITY_POOL_PRICE_PRECISION)\n            .div(1e18);\n    }\n\n    //====================\n    // Public functions\n    //====================\n\n    /**\n     * @notice Mints Dollars in exchange for collateral tokens\n     * @param collateralIndex Collateral token index\n     * @param dollarAmount Amount of dollars to mint\n     * @param dollarOutMin Min amount of dollars to mint (slippage protection)\n     * @param maxCollateralIn Max amount of collateral to send (slippage protection)\n     * @return totalDollarMint Amount of Dollars minted\n     * @return collateralNeeded Amount of collateral sent to the pool\n     */\n    function mintDollar(\n        uint256 collateralIndex,\n        uint256 dollarAmount,\n        uint256 dollarOutMin,\n        uint256 maxCollateralIn\n    )\n        internal\n        collateralEnabled(collateralIndex)\n        returns (uint256 totalDollarMint, uint256 collateralNeeded)\n    {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        require(\n            poolStorage.isMintPaused[collateralIndex] == false,\n            \"Minting is paused\"\n        );\n\n        // update Dollar price from Curve's Dollar Metapool\n        LibTWAPOracle.update();\n        // prevent unnecessary mints\n        require(\n            getDollarPriceUsd() >= poolStorage.mintPriceThreshold,\n            \"Dollar price too low\"\n        );\n\n        // update collateral price\n        updateChainLinkCollateralPrice(collateralIndex);\n\n        // get amount of collateral for minting Dollars\n        collateralNeeded = getDollarInCollateral(collateralIndex, dollarAmount);\n\n        // subtract the minting fee\n        totalDollarMint = dollarAmount\n            .mul(\n                UBIQUITY_POOL_PRICE_PRECISION.sub(\n                    poolStorage.mintingFee[collateralIndex]\n                )\n            )\n            .div(UBIQUITY_POOL_PRICE_PRECISION);\n\n        // check slippages\n        require((totalDollarMint >= dollarOutMin), \"Dollar slippage\");\n        require((collateralNeeded <= maxCollateralIn), \"Collateral slippage\");\n\n        // check the pool ceiling\n        require(\n            freeCollateralBalance(collateralIndex).add(collateralNeeded) <=\n                poolStorage.poolCeilings[collateralIndex],\n            \"Pool ceiling\"\n        );\n\n        // take collateral first\n        IERC20(poolStorage.collateralAddresses[collateralIndex])\n            .safeTransferFrom(msg.sender, address(this), collateralNeeded);\n\n        // mint Dollars\n        IERC20Ubiquity ubiquityDollarToken = IERC20Ubiquity(\n            LibAppStorage.appStorage().dollarTokenAddress\n        );\n        ubiquityDollarToken.mint(msg.sender, totalDollarMint);\n    }\n\n    /**\n     * @notice Burns redeemable Ubiquity Dollars and sends back 1 USD of collateral token for every 1 Ubiquity Dollar burned\n     * @dev Redeem process is split in two steps:\n     * @dev 1. `redeemDollar()`\n     * @dev 2. `collectRedemption()`\n     * @dev This is done in order to prevent someone using a flash loan of a collateral token to mint, redeem, and collect in a single transaction/block\n     * @param collateralIndex Collateral token index being withdrawn\n     * @param dollarAmount Amount of Ubiquity Dollars being burned\n     * @param collateralOutMin Minimum amount of collateral tokens that'll be withdrawn, used to set acceptable slippage\n     * @return collateralOut Amount of collateral tokens ready for redemption\n     */\n    function redeemDollar(\n        uint256 collateralIndex,\n        uint256 dollarAmount,\n        uint256 collateralOutMin\n    )\n        internal\n        collateralEnabled(collateralIndex)\n        returns (uint256 collateralOut)\n    {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        require(\n            poolStorage.isRedeemPaused[collateralIndex] == false,\n            \"Redeeming is paused\"\n        );\n\n        // update Dollar price from Curve's Dollar Metapool\n        LibTWAPOracle.update();\n        // prevent unnecessary redemptions that could adversely affect the Dollar price\n        require(\n            getDollarPriceUsd() <= poolStorage.redeemPriceThreshold,\n            \"Dollar price too high\"\n        );\n\n        uint256 dollarAfterFee = dollarAmount\n            .mul(\n                UBIQUITY_POOL_PRICE_PRECISION.sub(\n                    poolStorage.redemptionFee[collateralIndex]\n                )\n            )\n            .div(UBIQUITY_POOL_PRICE_PRECISION);\n\n        // update collateral price\n        updateChainLinkCollateralPrice(collateralIndex);\n\n        // get collateral output for incoming Dollars\n        collateralOut = getDollarInCollateral(collateralIndex, dollarAfterFee);\n\n        // checks\n        require(\n            collateralOut <=\n                (IERC20(poolStorage.collateralAddresses[collateralIndex]))\n                    .balanceOf(address(this))\n                    .sub(poolStorage.unclaimedPoolCollateral[collateralIndex]),\n            \"Insufficient pool collateral\"\n        );\n        require(collateralOut >= collateralOutMin, \"Collateral slippage\");\n\n        // account for the redeem delay\n        poolStorage.redeemCollateralBalances[msg.sender][\n            collateralIndex\n        ] = poolStorage\n        .redeemCollateralBalances[msg.sender][collateralIndex].add(\n                collateralOut\n            );\n        poolStorage.unclaimedPoolCollateral[collateralIndex] = poolStorage\n            .unclaimedPoolCollateral[collateralIndex]\n            .add(collateralOut);\n\n        poolStorage.lastRedeemedBlock[msg.sender] = block.number;\n\n        // burn Dollars\n        IERC20Ubiquity ubiquityDollarToken = IERC20Ubiquity(\n            LibAppStorage.appStorage().dollarTokenAddress\n        );\n        ubiquityDollarToken.burnFrom(msg.sender, dollarAmount);\n    }\n\n    /**\n     * @notice Used to collect collateral tokens after redeeming/burning Ubiquity Dollars\n     * @dev Redeem process is split in two steps:\n     * @dev 1. `redeemDollar()`\n     * @dev 2. `collectRedemption()`\n     * @dev This is done in order to prevent someone using a flash loan of a collateral token to mint, redeem, and collect in a single transaction/block\n     * @param collateralIndex Collateral token index being collected\n     * @return collateralAmount Amount of collateral tokens redeemed\n     */\n    function collectRedemption(\n        uint256 collateralIndex\n    ) internal returns (uint256 collateralAmount) {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        require(\n            poolStorage.isRedeemPaused[collateralIndex] == false,\n            \"Redeeming is paused\"\n        );\n        require(\n            (\n                poolStorage.lastRedeemedBlock[msg.sender].add(\n                    poolStorage.redemptionDelayBlocks\n                )\n            ) <= block.number,\n            \"Too soon to collect redemption\"\n        );\n\n        bool sendCollateral = false;\n\n        if (\n            poolStorage.redeemCollateralBalances[msg.sender][collateralIndex] >\n            0\n        ) {\n            collateralAmount = poolStorage.redeemCollateralBalances[msg.sender][\n                collateralIndex\n            ];\n            poolStorage.redeemCollateralBalances[msg.sender][\n                collateralIndex\n            ] = 0;\n            poolStorage.unclaimedPoolCollateral[collateralIndex] = poolStorage\n                .unclaimedPoolCollateral[collateralIndex]\n                .sub(collateralAmount);\n            sendCollateral = true;\n        }\n\n        // send out the tokens\n        if (sendCollateral) {\n            IERC20(poolStorage.collateralAddresses[collateralIndex])\n                .safeTransfer(msg.sender, collateralAmount);\n        }\n    }\n\n    /**\n     * @notice Updates collateral token price in USD from ChainLink price feed\n     * @param collateralIndex Collateral token index\n     */\n    function updateChainLinkCollateralPrice(uint256 collateralIndex) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            poolStorage.collateralPriceFeedAddresses[collateralIndex]\n        );\n\n        // fetch latest price\n        (\n            ,\n            // roundId\n            int256 answer, // startedAt\n            ,\n            uint256 updatedAt,\n\n        ) = // answeredInRound\n            priceFeed.latestRoundData();\n\n        // fetch number of decimals in chainlink feed\n        uint256 priceFeedDecimals = priceFeed.decimals();\n\n        // validation\n        require(answer > 0, \"Invalid price\");\n        require(\n            block.timestamp - updatedAt <\n                poolStorage.collateralPriceFeedStalenessThresholds[\n                    collateralIndex\n                ],\n            \"Stale data\"\n        );\n\n        // convert chainlink price to 6 decimals\n        uint256 price = uint256(answer).mul(UBIQUITY_POOL_PRICE_PRECISION).div(\n            10 ** priceFeedDecimals\n        );\n\n        poolStorage.collateralPrices[collateralIndex] = price;\n\n        emit CollateralPriceSet(collateralIndex, price);\n    }\n\n    //=========================\n    // AMO minters functions\n    //=========================\n\n    /**\n     * @notice Allows AMO minters to borrow collateral to make yield in external\n     * protocols like Compound, Curve, erc...\n     * @dev Bypasses the gassy mint->redeem cycle for AMOs to borrow collateral\n     * @param collateralAmount Amount of collateral to borrow\n     */\n    function amoMinterBorrow(uint256 collateralAmount) internal onlyAmoMinter {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        // checks the collateral index of the minter as an additional safety check\n        uint256 minterCollateralIndex = IDollarAmoMinter(msg.sender)\n            .collateralIndex();\n\n        // checks to see if borrowing is paused\n        require(\n            poolStorage.isBorrowPaused[minterCollateralIndex] == false,\n            \"Borrowing is paused\"\n        );\n\n        // ensure collateral is enabled\n        require(\n            poolStorage.isCollateralEnabled[\n                poolStorage.collateralAddresses[minterCollateralIndex]\n            ],\n            \"Collateral disabled\"\n        );\n\n        // transfer\n        IERC20(poolStorage.collateralAddresses[minterCollateralIndex])\n            .safeTransfer(msg.sender, collateralAmount);\n    }\n\n    //========================\n    // Restricted functions\n    //========================\n\n    /**\n     * @notice Adds a new AMO minter\n     * @param amoMinterAddress AMO minter address\n     */\n    function addAmoMinter(address amoMinterAddress) internal {\n        require(amoMinterAddress != address(0), \"Zero address detected\");\n\n        // make sure the AMO Minter has collateralDollarBalance()\n        uint256 collatValE18 = IDollarAmoMinter(amoMinterAddress)\n            .collateralDollarBalance();\n        require(collatValE18 >= 0, \"Invalid AMO\");\n\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        poolStorage.isAmoMinterEnabled[amoMinterAddress] = true;\n\n        emit AmoMinterAdded(amoMinterAddress);\n    }\n\n    /**\n     * @notice Adds a new collateral token\n     * @param collateralAddress Collateral token address\n     * @param chainLinkPriceFeedAddress Chainlink's price feed address\n     * @param poolCeiling Max amount of available tokens for collateral\n     */\n    function addCollateralToken(\n        address collateralAddress,\n        address chainLinkPriceFeedAddress,\n        uint256 poolCeiling\n    ) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        uint256 collateralIndex = poolStorage.collateralAddresses.length;\n\n        // add collateral address to all collaterals\n        poolStorage.collateralAddresses.push(collateralAddress);\n\n        // for fast collateral address -> collateral idx lookups later\n        poolStorage.collateralIndex[collateralAddress] = collateralIndex;\n\n        // set collateral initially to disabled\n        poolStorage.isCollateralEnabled[collateralAddress] = false;\n\n        // add in the missing decimals\n        poolStorage.missingDecimals.push(\n            uint256(18).sub(ERC20(collateralAddress).decimals())\n        );\n\n        // add in the collateral symbols\n        poolStorage.collateralSymbols.push(ERC20(collateralAddress).symbol());\n\n        // initialize unclaimed pool collateral\n        poolStorage.unclaimedPoolCollateral.push(0);\n\n        // initialize paused prices to $1 as a backup\n        poolStorage.collateralPrices.push(UBIQUITY_POOL_PRICE_PRECISION);\n\n        // set fees to 0 by default\n        poolStorage.mintingFee.push(0);\n        poolStorage.redemptionFee.push(0);\n\n        // handle the pauses\n        poolStorage.isMintPaused.push(false);\n        poolStorage.isRedeemPaused.push(false);\n        poolStorage.isBorrowPaused.push(false);\n\n        // set pool ceiling\n        poolStorage.poolCeilings.push(poolCeiling);\n\n        // set price feed address\n        poolStorage.collateralPriceFeedAddresses.push(\n            chainLinkPriceFeedAddress\n        );\n\n        // set price feed staleness threshold in seconds\n        poolStorage.collateralPriceFeedStalenessThresholds.push(1 days);\n    }\n\n    /**\n     * @notice Removes AMO minter\n     * @param amoMinterAddress AMO minter address to remove\n     */\n    function removeAmoMinter(address amoMinterAddress) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        poolStorage.isAmoMinterEnabled[amoMinterAddress] = false;\n\n        emit AmoMinterRemoved(amoMinterAddress);\n    }\n\n    /**\n     * @notice Sets collateral ChainLink price feed params\n     * @param collateralAddress Collateral token address\n     * @param chainLinkPriceFeedAddress ChainLink price feed address\n     * @param stalenessThreshold Threshold in seconds when chainlink answer should be considered stale\n     */\n    function setCollateralChainLinkPriceFeed(\n        address collateralAddress,\n        address chainLinkPriceFeedAddress,\n        uint256 stalenessThreshold\n    ) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        uint256 collateralIndex = poolStorage.collateralIndex[\n            collateralAddress\n        ];\n\n        // set price feed address\n        poolStorage.collateralPriceFeedAddresses[\n            collateralIndex\n        ] = chainLinkPriceFeedAddress;\n\n        // set staleness threshold in seconds when chainlink answer should be considered stale\n        poolStorage.collateralPriceFeedStalenessThresholds[\n            collateralIndex\n        ] = stalenessThreshold;\n\n        emit CollateralPriceFeedSet(\n            collateralIndex,\n            chainLinkPriceFeedAddress,\n            stalenessThreshold\n        );\n    }\n\n    /**\n     * @notice Sets mint and redeem fees, 1_000_000 = 100%\n     * @param collateralIndex Collateral token index\n     * @param newMintFee New mint fee\n     * @param newRedeemFee New redeem fee\n     */\n    function setFees(\n        uint256 collateralIndex,\n        uint256 newMintFee,\n        uint256 newRedeemFee\n    ) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        poolStorage.mintingFee[collateralIndex] = newMintFee;\n        poolStorage.redemptionFee[collateralIndex] = newRedeemFee;\n\n        emit FeesSet(collateralIndex, newMintFee, newRedeemFee);\n    }\n\n    /**\n     * @notice Sets max amount of collateral for a particular collateral token\n     * @param collateralIndex Collateral token index\n     * @param newCeiling Max amount of collateral\n     */\n    function setPoolCeiling(\n        uint256 collateralIndex,\n        uint256 newCeiling\n    ) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        poolStorage.poolCeilings[collateralIndex] = newCeiling;\n\n        emit PoolCeilingSet(collateralIndex, newCeiling);\n    }\n\n    /**\n     * @notice Sets mint and redeem price thresholds, 1_000_000 = $1.00\n     * @param newMintPriceThreshold New mint price threshold\n     * @param newRedeemPriceThreshold New redeem price threshold\n     */\n    function setPriceThresholds(\n        uint256 newMintPriceThreshold,\n        uint256 newRedeemPriceThreshold\n    ) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        poolStorage.mintPriceThreshold = newMintPriceThreshold;\n        poolStorage.redeemPriceThreshold = newRedeemPriceThreshold;\n\n        emit PriceThresholdsSet(newMintPriceThreshold, newRedeemPriceThreshold);\n    }\n\n    /**\n     * @notice Sets a redemption delay in blocks\n     * @dev Redeeming is split in 2 actions:\n     * @dev 1. `redeemDollar()`\n     * @dev 2. `collectRedemption()`\n     * @dev `newRedemptionDelayBlocks` sets number of blocks that should be mined after which user can call `collectRedemption()`\n     * @param newRedemptionDelayBlocks Redemption delay in blocks\n     */\n    function setRedemptionDelayBlocks(\n        uint256 newRedemptionDelayBlocks\n    ) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        poolStorage.redemptionDelayBlocks = newRedemptionDelayBlocks;\n\n        emit RedemptionDelayBlocksSet(newRedemptionDelayBlocks);\n    }\n\n    /**\n     * @notice Toggles (i.e. enables/disables) a particular collateral token\n     * @param collateralIndex Collateral token index\n     */\n    function toggleCollateral(uint256 collateralIndex) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        address collateralAddress = poolStorage.collateralAddresses[\n            collateralIndex\n        ];\n        poolStorage.isCollateralEnabled[collateralAddress] = !poolStorage\n            .isCollateralEnabled[collateralAddress];\n\n        emit CollateralToggled(\n            collateralIndex,\n            poolStorage.isCollateralEnabled[collateralAddress]\n        );\n    }\n\n    /**\n     * @notice Toggles pause for mint/redeem/borrow methods\n     * @param collateralIndex Collateral token index\n     * @param toggleIndex Method index. 0 - toggle mint pause, 1 - toggle redeem pause, 2 - toggle borrow by AMO pause\n     */\n    function toggleMintRedeemBorrow(\n        uint256 collateralIndex,\n        uint8 toggleIndex\n    ) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        if (toggleIndex == 0)\n            poolStorage.isMintPaused[collateralIndex] = !poolStorage\n                .isMintPaused[collateralIndex];\n        else if (toggleIndex == 1)\n            poolStorage.isRedeemPaused[collateralIndex] = !poolStorage\n                .isRedeemPaused[collateralIndex];\n        else if (toggleIndex == 2)\n            poolStorage.isBorrowPaused[collateralIndex] = !poolStorage\n                .isBorrowPaused[collateralIndex];\n\n        emit MintRedeemBorrowToggled(collateralIndex, toggleIndex);\n    }\n}"
    },
    {
      "filename": "packages/contracts/test/diamond/facets/UbiquityPoolFacet.t.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"forge-std/console.sol\";\nimport {DiamondTestSetup} from \"../DiamondTestSetup.sol\";\nimport {IDollarAmoMinter} from \"../../../src/dollar/interfaces/IDollarAmoMinter.sol\";\nimport {IMetaPool} from \"../../../src/dollar/interfaces/IMetaPool.sol\";\nimport {LibUbiquityPool} from \"../../../src/dollar/libraries/LibUbiquityPool.sol\";\nimport {MockChainLinkFeed} from \"../../../src/dollar/mocks/MockChainLinkFeed.sol\";\nimport {MockERC20} from \"../../../src/dollar/mocks/MockERC20.sol\";\nimport {MockMetaPool} from \"../../../src/dollar/mocks/MockMetaPool.sol\";\n\ncontract MockDollarAmoMinter is IDollarAmoMinter {\n    function collateralDollarBalance() external pure returns (uint256) {\n        return 0;\n    }\n\n    function collateralIndex() external pure returns (uint256) {\n        return 0;\n    }\n}\n\ncontract UbiquityPoolFacetTest is DiamondTestSetup {\n    MockDollarAmoMinter dollarAmoMinter;\n    MockERC20 collateralToken;\n    MockChainLinkFeed collateralTokenPriceFeed;\n    MockMetaPool curveDollarMetaPool;\n    MockERC20 curveTriPoolLpToken;\n\n    address user = address(1);\n\n    // Events\n    event AmoMinterAdded(address amoMinterAddress);\n    event AmoMinterRemoved(address amoMinterAddress);\n    event CollateralPriceFeedSet(\n        uint256 collateralIndex,\n        address priceFeedAddress,\n        uint256 stalenessThreshold\n    );\n    event CollateralPriceSet(uint256 collateralIndex, uint256 newPrice);\n    event CollateralToggled(uint256 collateralIndex, bool newState);\n    event FeesSet(\n        uint256 collateralIndex,\n        uint256 newMintFee,\n        uint256 newRedeemFee\n    );\n    event MintRedeemBorrowToggled(uint256 collateralIndex, uint8 toggleIndex);\n    event PoolCeilingSet(uint256 collateralIndex, uint256 newCeiling);\n    event PriceThresholdsSet(\n        uint256 newMintPriceThreshold,\n        uint256 newRedeemPriceThreshold\n    );\n    event RedemptionDelayBlocksSet(uint256 redemptionDelayBlocks);\n\n    function setUp() public overrid"
    }
  ]
}