{
  "Title": "Gas Inefficiencies",
  "Content": "There are many instances throughout the codebase where changes can be made to improve gas consumption. For example:\n\n\n1. Consolidate [`_callDepth`](https://github.com/spherex-collab/spherex-protect/blob/5b134b2b176deb94e75417ed9b9d3670444a4167/src/SphereXEngine.sol#L20), [`_currentPattern`](https://github.com/spherex-collab/spherex-protect/blob/5b134b2b176deb94e75417ed9b9d3670444a4167/src/SphereXEngine.sol#L19), and [`_currentBlockOriginHash`](https://github.com/spherex-collab/spherex-protect/blob/5b134b2b176deb94e75417ed9b9d3670444a4167/src/SphereXEngine.sol#L23) into a single slot. This can be done using a Struct that defines variables that will fit into a single slot. For example, using `uint16` for `_callDepth`, `uint216` for `_currentBlockOriginHash`, and `bytes3` for `_currentBlockOriginHash`. This optimization reduces storage operations and may save up to 5000-7000 gas per transaction during execution on L1.\n2. Avoid performing multiple storage reads and writes on `_callDepth`. `_currentBlockOriginHash` and `_currentPattern` during `_addCFElement` by reading once into stack variables, and writing back into storage at the end of the method.\n3. Avoid checking for the active rule twice during `_addCFElement` by using a separate internal method for each case. Additionally, splitting the method into two distinct methods will make the code more readable, auditable, and testable. This will also make the exclusivity of the modes clear.\n4. Use modifiers with internal methods. By doing so, bytecode size is reduced.\n5. The [`returnsIfNotActivated`](https://github.com/spherex-collab/spherex-protect/blob/5b134b2b176deb94e75417ed9b9d3670444a4167/src/SphereXEngine.sol#L29) check can be performed once in the `SphereXGuard` modifiers, rather than being checked twice for each hook (Pre and Post).\n6. Performing calculations for values that will not change is suboptimal. [`deactivateRules()`](https://github.com/spherex-collab/spherex-protect/blob/5b134b2b176deb94e75417ed9b9d3670444a4167/src/SphereXEngine.sol#LL55C14-L55C31) should set the value directly.\n7. Use a more recent version of Solidity to take advantage of compiler gas optimizations for both deployment and execution costs.\n8. Use [custom errors implementation](https://blog.soliditylang.org/2021/04/21/custom-errors/) (if upgrading to a more recent version of Solidity) to save on deployment cost and failed execution gas cost.\n\n\nWhen performing these changes, aim to reach an optimal tradeoff between gas optimizations and readability. Having a codebase that is easy to understand reduces the chance of future errors and improves community transparency.\n\n\n***Update**: Partially resolved. Suggestion 1 was implemented in [pull request #23](https://github.com/spherex-collab/spherex-protect/pull/23/) at [commit 950a31d](https://github.com/spherex-collab/spherex-protect/pull/23/commits/950a31dc51796cdbc6f8aaf3042aedfd6b5564e8). Suggestions 2 and 3 were implemented in [pull request #6](https://github.com/spherex-collab/spherex-protect/pull/6/). Suggestion 7 was implemented in [pull request #16](https://github.com/spherex-collab/spherex-protect/pull/16). Regarding the other suggestions, the SphereX team stated:*\n\n\n\n> *After deeply discussing every gas inefficiency issue, we have reached an optimal tradeoff from our point of view.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/SphereXEngine.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// (c) SphereX 2023 Terms&Conditions\n\npragma solidity >=0.6.0;\n\nimport \"./Ownable.sol\";\nimport \"./ISphereXEngine.sol\";\n\n/**\n * @title SphereX Engine\n * @notice Gathers information about an ongoing transaction and reverts if it seems malicious\n */\ncontract SphereXEngine is Ownable, ISphereXEngine {\n    bytes8 private _engineRules; // By default the contract will be deployed with no guarding rules activated\n    mapping(address => bool) private _allowedSenders;\n    mapping(uint256 => bool) private _allowedPatterns;\n\n    // We initialize the next variables to 1 and not 0 to save gas costs on future transactions\n    uint256 private _currentPattern = PATTERN_START;\n    uint256 private _callDepth = DEPTH_START;\n\n    // Represent keccak256(abi.encode(block.number, tx.origin))\n    bytes32 private _currentBlockOriginHash = bytes32(uint256(1));\n\n    uint256 private constant PATTERN_START = 1;\n    uint256 private constant DEPTH_START = 1;\n    bytes32 private constant DEACTIVATED = bytes32(0);\n\n    modifier returnsIfNotActivated() {\n        if (_engineRules == DEACTIVATED) {\n            return;\n        }\n\n        _;\n    }\n\n    modifier onlyApprovedSenders() {\n        require(_allowedSenders[msg.sender], \"!SX:SENDERS\");\n        _;\n    }\n\n    // ============ Management ============\n\n    /**\n     * Activate the guardian rules\n     * @param rules bytes8 representing the new rules to activate.\n     */\n    function activateRules(bytes8 rules) external onlyOwner {\n        _engineRules = rules;\n    }\n\n    /**\n     * Deactivates the engine, the calls will return without being checked\n     */\n    function deactivateRules() external onlyOwner {\n        _engineRules = bytes8(uint64(0));\n    }\n\n    /**\n     * Adds addresses that will be served by this engine. An address that was never added will get a revert if it tries to call the engine.\n     * @param senders list of address to add to the set of allowed addresses\n     */\n    function addAllowedSender(address[] calldata senders) external onlyOwner {\n        for (uint256 i = 0; i < senders.length; ++i) {\n            _allowedSenders[senders[i]] = true;\n        }\n    }\n\n    /**\n     * Removes address so that they will not get served when calling the engine. Transaction from these addresses will get reverted.\n     * @param senders list of address to stop service.\n     */\n    function removeAllowedSender(address[] calldata senders) external onlyOwner {\n        for (uint256 i = 0; i < senders.length; ++i) {\n            _allowedSenders[senders[i]] = false;\n        }\n    }\n\n    /**\n     * Add allowed patterns - these are representation of allowed flows of transactions, and prefixes of these flows\n     * @param patterns list of flows to allow as valid and non-malicious flows\n     */\n    function addAllowedPatterns(uint256[] calldata patterns) external onlyOwner {\n        for (uint256 i = 0; i < patterns.length; ++i) {\n            _allowedPatterns[patterns[i]] = true;\n        }\n    }\n\n    /**\n     * Remove allowed patterns - these are representation flows of transactions, and prefixes of these flows,\n     * that are no longer considered valid and benign\n     * @param patterns list of flows that no longer considered valid and non-malicious\n     */\n    function removeAllowedPatterns(uint256[] calldata patterns) external onlyOwner {\n        for (uint256 i = 0; i < patterns.length; ++i) {\n            _allowedPatterns[patterns[i]] = false;\n        }\n    }\n\n    // ============ CF ============\n\n    /**\n     * Checks if rule1 is activated.\n     */\n    function _isRule1Activated() private view returns (bool) {\n        return (_engineRules & bytes8(uint64(1))) > 0;\n    }\n\n    /**\n     * Checks if rule2 us activated.\n     */\n    function _isRule2Activated() private view returns (bool) {\n        return (_engineRules & bytes8(uint64(2))) > 0;\n    }\n\n    /**\n     * update the current CF pattern with a new number, \n     * when exiting a function we check the validity of the pattern.\n     * @param num element to add to the flow. Poistive number represents start of function, negative exit.\n     * @param forceCheck force the check of the current pattern, even if normal test conditions don't exist.\n     */\n    function _addCFElement(int16 num, bool forceCheck) private {\n        // Upon entry to a new function if we are configured to PrefixTxFlow we should check if we are at the same transaction\n        // or a new one. in case of a new one we need to reinit the _currentPattern, and save\n        // the new transaction \"hash\" (block.number+tx.origin)\n        if (num > 0 && _isRule2Activated()) {\n            bytes32 currentBlockOriginHash = keccak256(abi.encode(block.number, tx.origin));\n            if (currentBlockOriginHash != _currentBlockOriginHash) {\n                _currentPattern = PATTERN_START;\n                _currentBlockOriginHash = currentBlockOriginHash;\n            }\n        }\n\n        _currentPattern = uint256(keccak256(abi.encode(num, _currentPattern)));\n\n        if (num > 0) {\n            ++_callDepth;\n        } else if (num < 0) {\n            --_callDepth;\n        } else {\n            revert(\"!SX:ERROR\");\n        }\n\n        if ((_callDepth == DEPTH_START) || (forceCheck)) {\n            _checkCallFlow();\n        }\n\n        // If we are configured to CF then if we reach depth == DEPTH_START we should reinit the\n        // _currentPattern\n        if (_isRule1Activated() && _callDepth == DEPTH_START) {\n            _currentPattern = PATTERN_START;\n        }\n    }\n\n    /**\n     * Check if the current call flow pattern (that is, the result of the rolling hash) is an allowed pattern.\n     */\n    function _checkCallFlow() private view {\n        require(_allowedPatterns[_currentPattern], \"!SX:DETECTED\");\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract before the body of the function.\n     * This is used only for external call functions.\n     * @param num id of function to add. Should be positive\n     * @param sender For future use\n     * @param data For future use\n     * @return result in the future will return insturction on what storage slots to gather, but not used for now\n     */\n    function sphereXValidatePre(int16 num, address sender, bytes calldata data)\n        external\n        override\n        returnsIfNotActivated // may return empty bytes32[]\n        onlyApprovedSenders\n        returns (bytes32[] memory result)\n    {\n        _addCFElement(num, false);\n        return result;\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract after the body of the function.\n     * This is used only for external call functions (that is, external, and public when called outside the contract).\n     * @param num id of function to add. Should be negative\n     * @param valuesBefore For future use\n     * @param valuesAfter For future use\n     */\n    function sphereXValidatePost(int16 num, uint256 gas, bytes32[] calldata valuesBefore, bytes32[] calldata valuesAfter)\n        external\n        override\n        returnsIfNotActivated\n        onlyApprovedSenders\n    {\n        _addCFElement(num, true);\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract before and after the body of the function.\n     * This is used only for internal function calls (internal and private functions).\n     * @param num id of function to add.\n     */\n    function sphereXValidateInternalPre(int16 num) external override returnsIfNotActivated onlyApprovedSenders {\n        _addCFElement(num, false);\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract before and after the body of the function.\n     * This is used only for internal function calls (internal and private functions).\n     * @param num id of function to add.\n     */\n    function sphereXValidateInternalPost(int16 num, uint256 gas) external override returnsIfNotActivated onlyApprovedSenders {\n        _addCFElement(num, false);\n    }\n}"
    },
    {
      "filename": "src/SphereXEngine.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// (c) SphereX 2023 Terms&Conditions\n\npragma solidity >=0.6.0;\n\nimport \"./Ownable.sol\";\nimport \"./ISphereXEngine.sol\";\n\n/**\n * @title SphereX Engine\n * @notice Gathers information about an ongoing transaction and reverts if it seems malicious\n */\ncontract SphereXEngine is Ownable, ISphereXEngine {\n    bytes8 private _engineRules; // By default the contract will be deployed with no guarding rules activated\n    mapping(address => bool) private _allowedSenders;\n    mapping(uint256 => bool) private _allowedPatterns;\n\n    // We initialize the next variables to 1 and not 0 to save gas costs on future transactions\n    uint256 private _currentPattern = PATTERN_START;\n    uint256 private _callDepth = DEPTH_START;\n\n    // Represent keccak256(abi.encode(block.number, tx.origin))\n    bytes32 private _currentBlockOriginHash = bytes32(uint256(1));\n\n    uint256 private constant PATTERN_START = 1;\n    uint256 private constant DEPTH_START = 1;\n    bytes32 private constant DEACTIVATED = bytes32(0);\n\n    modifier returnsIfNotActivated() {\n        if (_engineRules == DEACTIVATED) {\n            return;\n        }\n\n        _;\n    }\n\n    modifier onlyApprovedSenders() {\n        require(_allowedSenders[msg.sender], \"!SX:SENDERS\");\n        _;\n    }\n\n    // ============ Management ============\n\n    /**\n     * Activate the guardian rules\n     * @param rules bytes8 representing the new rules to activate.\n     */\n    function activateRules(bytes8 rules) external onlyOwner {\n        _engineRules = rules;\n    }\n\n    /**\n     * Deactivates the engine, the calls will return without being checked\n     */\n    function deactivateRules() external onlyOwner {\n        _engineRules = bytes8(uint64(0));\n    }\n\n    /**\n     * Adds addresses that will be served by this engine. An address that was never added will get a revert if it tries to call the engine.\n     * @param senders list of address to add to the set of allowed addresses\n     */\n    function addAllowedSender(address[] calldata senders) external onlyOwner {\n        for (uint256 i = 0; i < senders.length; ++i) {\n            _allowedSenders[senders[i]] = true;\n        }\n    }\n\n    /**\n     * Removes address so that they will not get served when calling the engine. Transaction from these addresses will get reverted.\n     * @param senders list of address to stop service.\n     */\n    function removeAllowedSender(address[] calldata senders) external onlyOwner {\n        for (uint256 i = 0; i < senders.length; ++i) {\n            _allowedSenders[senders[i]] = false;\n        }\n    }\n\n    /**\n     * Add allowed patterns - these are representation of allowed flows of transactions, and prefixes of these flows\n     * @param patterns list of flows to allow as valid and non-malicious flows\n     */\n    function addAllowedPatterns(uint256[] calldata patterns) external onlyOwner {\n        for (uint256 i = 0; i < patterns.length; ++i) {\n            _allowedPatterns[patterns[i]] = true;\n        }\n    }\n\n    /**\n     * Remove allowed patterns - these are representation flows of transactions, and prefixes of these flows,\n     * that are no longer considered valid and benign\n     * @param patterns list of flows that no longer considered valid and non-malicious\n     */\n    function removeAllowedPatterns(uint256[] calldata patterns) external onlyOwner {\n        for (uint256 i = 0; i < patterns.length; ++i) {\n            _allowedPatterns[patterns[i]] = false;\n        }\n    }\n\n    // ============ CF ============\n\n    /**\n     * Checks if rule1 is activated.\n     */\n    function _isRule1Activated() private view returns (bool) {\n        return (_engineRules & bytes8(uint64(1))) > 0;\n    }\n\n    /**\n     * Checks if rule2 us activated.\n     */\n    function _isRule2Activated() private view returns (bool) {\n        return (_engineRules & bytes8(uint64(2))) > 0;\n    }\n\n    /**\n     * update the current CF pattern with a new number, \n     * when exiting a function we check the validity of the pattern.\n     * @param num element to add to the flow. Poistive number represents start of function, negative exit.\n     * @param forceCheck force the check of the current pattern, even if normal test conditions don't exist.\n     */\n    function _addCFElement(int16 num, bool forceCheck) private {\n        // Upon entry to a new function if we are configured to PrefixTxFlow we should check if we are at the same transaction\n        // or a new one. in case of a new one we need to reinit the _currentPattern, and save\n        // the new transaction \"hash\" (block.number+tx.origin)\n        if (num > 0 && _isRule2Activated()) {\n            bytes32 currentBlockOriginHash = keccak256(abi.encode(block.number, tx.origin));\n            if (currentBlockOriginHash != _currentBlockOriginHash) {\n                _currentPattern = PATTERN_START;\n                _currentBlockOriginHash = currentBlockOriginHash;\n            }\n        }\n\n        _currentPattern = uint256(keccak256(abi.encode(num, _currentPattern)));\n\n        if (num > 0) {\n            ++_callDepth;\n        } else if (num < 0) {\n            --_callDepth;\n        } else {\n            revert(\"!SX:ERROR\");\n        }\n\n        if ((_callDepth == DEPTH_START) || (forceCheck)) {\n            _checkCallFlow();\n        }\n\n        // If we are configured to CF then if we reach depth == DEPTH_START we should reinit the\n        // _currentPattern\n        if (_isRule1Activated() && _callDepth == DEPTH_START) {\n            _currentPattern = PATTERN_START;\n        }\n    }\n\n    /**\n     * Check if the current call flow pattern (that is, the result of the rolling hash) is an allowed pattern.\n     */\n    function _checkCallFlow() private view {\n        require(_allowedPatterns[_currentPattern], \"!SX:DETECTED\");\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract before the body of the function.\n     * This is used only for external call functions.\n     * @param num id of function to add. Should be positive\n     * @param sender For future use\n     * @param data For future use\n     * @return result in the future will return insturction on what storage slots to gather, but not used for now\n     */\n    function sphereXValidatePre(int16 num, address sender, bytes calldata data)\n        external\n        override\n        returnsIfNotActivated // may return empty bytes32[]\n        onlyApprovedSenders\n        returns (bytes32[] memory result)\n    {\n        _addCFElement(num, false);\n        return result;\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract after the body of the function.\n     * This is used only for external call functions (that is, external, and public when called outside the contract).\n     * @param num id of function to add. Should be negative\n     * @param valuesBefore For future use\n     * @param valuesAfter For future use\n     */\n    function sphereXValidatePost(int16 num, uint256 gas, bytes32[] calldata valuesBefore, bytes32[] calldata valuesAfter)\n        external\n        override\n        returnsIfNotActivated\n        onlyApprovedSenders\n    {\n        _addCFElement(num, true);\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract before and after the body of the function.\n     * This is used only for internal function calls (internal and private functions).\n     * @param num id of function to add.\n     */\n    function sphereXValidateInternalPre(int16 num) external override returnsIfNotActivated onlyApprovedSenders {\n        _addCFElement(num, false);\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract before and after the body of the function.\n     * This is used only for internal function calls (internal and private functions).\n     * @param num id of function to add.\n     */\n    function sphereXValidateInternalPost(int16 num, uint256 gas) external override returnsIfNotActivated onlyApprovedSenders {\n        _addCFElement(num, false);\n    }\n}"
    },
    {
      "filename": "src/SphereXEngine.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// (c) SphereX 2023 Terms&Conditions\n\npragma solidity >=0.6.0;\n\nimport \"./Ownable.sol\";\nimport \"./ISphereXEngine.sol\";\n\n/**\n * @title SphereX Engine\n * @notice Gathers information about an ongoing transaction and reverts if it seems malicious\n */\ncontract SphereXEngine is Ownable, ISphereXEngine {\n    bytes8 private _engineRules; // By default the contract will be deployed with no guarding rules activated\n    mapping(address => bool) private _allowedSenders;\n    mapping(uint256 => bool) private _allowedPatterns;\n\n    // We initialize the next variables to 1 and not 0 to save gas costs on future transactions\n    uint256 private _currentPattern = PATTERN_START;\n    uint256 private _callDepth = DEPTH_START;\n\n    // Represent keccak256(abi.encode(block.number, tx.origin))\n    bytes32 private _currentBlockOriginHash = bytes32(uint256(1));\n\n    uint256 private constant PATTERN_START = 1;\n    uint256 private constant DEPTH_START = 1;\n    bytes32 private constant DEACTIVATED = bytes32(0);\n\n    modifier returnsIfNotActivated() {\n        if (_engineRules == DEACTIVATED) {\n            return;\n        }\n\n        _;\n    }\n\n    modifier onlyApprovedSenders() {\n        require(_allowedSenders[msg.sender], \"!SX:SENDERS\");\n        _;\n    }\n\n    // ============ Management ============\n\n    /**\n     * Activate the guardian rules\n     * @param rules bytes8 representing the new rules to activate.\n     */\n    function activateRules(bytes8 rules) external onlyOwner {\n        _engineRules = rules;\n    }\n\n    /**\n     * Deactivates the engine, the calls will return without being checked\n     */\n    function deactivateRules() external onlyOwner {\n        _engineRules = bytes8(uint64(0));\n    }\n\n    /**\n     * Adds addresses that will be served by this engine. An address that was never added will get a revert if it tries to call the engine.\n     * @param senders list of address to add to the set of allowed addresses\n     */\n    function addAllowedSender(address[] calldata senders) external onlyOwner {\n        for (uint256 i = 0; i < senders.length; ++i) {\n            _allowedSenders[senders[i]] = true;\n        }\n    }\n\n    /**\n     * Removes address so that they will not get served when calling the engine. Transaction from these addresses will get reverted.\n     * @param senders list of address to stop service.\n     */\n    function removeAllowedSender(address[] calldata senders) external onlyOwner {\n        for (uint256 i = 0; i < senders.length; ++i) {\n            _allowedSenders[senders[i]] = false;\n        }\n    }\n\n    /**\n     * Add allowed patterns - these are representation of allowed flows of transactions, and prefixes of these flows\n     * @param patterns list of flows to allow as valid and non-malicious flows\n     */\n    function addAllowedPatterns(uint256[] calldata patterns) external onlyOwner {\n        for (uint256 i = 0; i < patterns.length; ++i) {\n            _allowedPatterns[patterns[i]] = true;\n        }\n    }\n\n    /**\n     * Remove allowed patterns - these are representation flows of transactions, and prefixes of these flows,\n     * that are no longer considered valid and benign\n     * @param patterns list of flows that no longer considered valid and non-malicious\n     */\n    function removeAllowedPatterns(uint256[] calldata patterns) external onlyOwner {\n        for (uint256 i = 0; i < patterns.length; ++i) {\n            _allowedPatterns[patterns[i]] = false;\n        }\n    }\n\n    // ============ CF ============\n\n    /**\n     * Checks if rule1 is activated.\n     */\n    function _isRule1Activated() private view returns (bool) {\n        return (_engineRules & bytes8(uint64(1))) > 0;\n    }\n\n    /**\n     * Checks if rule2 us activated.\n     */\n    function _isRule2Activated() private view returns (bool) {\n        return (_engineRules & bytes8(uint64(2))) > 0;\n    }\n\n    /**\n     * update the current CF pattern with a new number, \n     * when exiting a function we check the validity of the pattern.\n     * @param num element to add to the flow. Poistive number represents start of function, negative exit.\n     * @param forceCheck force the check of the current pattern, even if normal test conditions don't exist.\n     */\n    function _addCFElement(int16 num, bool forceCheck) private {\n        // Upon entry to a new function if we are configured to PrefixTxFlow we should check if we are at the same transaction\n        // or a new one. in case of a new one we need to reinit the _currentPattern, and save\n        // the new transaction \"hash\" (block.number+tx.origin)\n        if (num > 0 && _isRule2Activated()) {\n            bytes32 currentBlockOriginHash = keccak256(abi.encode(block.number, tx.origin));\n            if (currentBlockOriginHash != _currentBlockOriginHash) {\n                _currentPattern = PATTERN_START;\n                _currentBlockOriginHash = currentBlockOriginHash;\n            }\n        }\n\n        _currentPattern = uint256(keccak256(abi.encode(num, _currentPattern)));\n\n        if (num > 0) {\n            ++_callDepth;\n        } else if (num < 0) {\n            --_callDepth;\n        } else {\n            revert(\"!SX:ERROR\");\n        }\n\n        if ((_callDepth == DEPTH_START) || (forceCheck)) {\n            _checkCallFlow();\n        }\n\n        // If we are configured to CF then if we reach depth == DEPTH_START we should reinit the\n        // _currentPattern\n        if (_isRule1Activated() && _callDepth == DEPTH_START) {\n            _currentPattern = PATTERN_START;\n        }\n    }\n\n    /**\n     * Check if the current call flow pattern (that is, the result of the rolling hash) is an allowed pattern.\n     */\n    function _checkCallFlow() private view {\n        require(_allowedPatterns[_currentPattern], \"!SX:DETECTED\");\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract before the body of the function.\n     * This is used only for external call functions.\n     * @param num id of function to add. Should be positive\n     * @param sender For future use\n     * @param data For future use\n     * @return result in the future will return insturction on what storage slots to gather, but not used for now\n     */\n    function sphereXValidatePre(int16 num, address sender, bytes calldata data)\n        external\n        override\n        returnsIfNotActivated // may return empty bytes32[]\n        onlyApprovedSenders\n        returns (bytes32[] memory result)\n    {\n        _addCFElement(num, false);\n        return result;\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract after the body of the function.\n     * This is used only for external call functions (that is, external, and public when called outside the contract).\n     * @param num id of function to add. Should be negative\n     * @param valuesBefore For future use\n     * @param valuesAfter For future use\n     */\n    function sphereXValidatePost(int16 num, uint256 gas, bytes32[] calldata valuesBefore, bytes32[] calldata valuesAfter)\n        external\n        override\n        returnsIfNotActivated\n        onlyApprovedSenders\n    {\n        _addCFElement(num, true);\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract before and after the body of the function.\n     * This is used only for internal function calls (internal and private functions).\n     * @param num id of function to add.\n     */\n    function sphereXValidateInternalPre(int16 num) external override returnsIfNotActivated onlyApprovedSenders {\n        _addCFElement(num, false);\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract before and after the body of the function.\n     * This is used only for internal function calls (internal and private functions).\n     * @param num id of function to add.\n     */\n    function sphereXValidateInternalPost(int16 num, uint256 gas) external override returnsIfNotActivated onlyApprovedSenders {\n        _addCFElement(num, false);\n    }\n}"
    }
  ]
}