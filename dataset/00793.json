{
  "Title": "Accidental `renounceOwnership()` call can disrupt key operations in multiple contracts.",
  "Content": "# Accidental `renounceOwnership()` call can disrupt key operations in multiple contracts.\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/RESDLTokenBridge.sol#L16C1-L16C39\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/RESDLTokenBridge.sol#L16C1-L16C39</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol#L11C1-L11C65\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol#L11C1-L11C65</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L14C1-L14C67\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L14C1-L14C67</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/WrappedTokenBridge.sol#L19C1-L19C55\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/WrappedTokenBridge.sol#L19C1-L19C55</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/sdlPool/LinearBoostController.sol#L10C1-L10C44\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/sdlPool/LinearBoostController.sol#L10C1-L10C44</a>\n\n\n## Title\nAccidental `renounceOwnership()` call can disrupt key operations in multiple contracts.\n\n## Severity\nMedium\n\n## Relevant GitHub Links\n1. https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/RESDLTokenBridge.sol#L16C1-L16C39\n2. https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol#L11C1-L11C65\n3. https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L14C1-L14C67\n4. https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/WrappedTokenBridge.sol#L19C1-L19C55\n5. https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/sdlPool/LinearBoostController.sol#L10C1-L10C44\n\n## Summary\n`Ownable` contains a function named `renounceOwnership()` which can be used to remove the ownership of contracts in a protocol.\n\nThis can lead to `SDLPoolCCIPControllerPrimary`, `SDLPoolCCIPControllerPrimary`, `WrappedTokenBridge`, `LinearBoostController` and `RESDLTokenBridge` contracts becoming disowned, which will then break critical functions of the protocol.\n\n## Vulnerability Details\nThe `WrappedTokenBridge`, `LinearBoostController` and `RESDLTokenBridge` contracts inherit from `Ownable`, `SDLPoolCCIPControllerPrimary` from `SDLPoolCCIPController` which inherits `Ownable`, and `SDLPoolCCIPControllerSecondary` inherits from SDLPoolCCIPControllerPrimary; and hence inherit `renounceOwnership()` function.\n\nThe owner could accidentally (or intentionally) call `renounceOwnership()` which transfers ownership to `address(0)`. This will break numerous functions within each contract referenced that has the `onlyOwner()` modifier assigned. Below are a list of those functions:\n\n**`SDLPoolCCIPControllerPrimary`**\n- `setRewardsInitiator()`\n- `setWrappedRewardToken()`\n- `approveRewardTokens()`\n- `removeWhitelistedChain()`\n- `addWhitelistedChain()`\n\n**`SDLPoolCCIPControllerSecondary`**\n- `setExtraArgs()`\n\n**`WrappedTokenBridge`**\n- `recoverTokens()`\n- `transferTokens()`\n\n**`LinearBoostController`**\n- `setMaxLockingDuration()`\n- `setMaxBoost()`\n\n**`RESDLTokenBridge`.**\n- `setExtraArgs()`\n\n## POC\nAdd this test to `test/core/ccip/sdl-pool-ccip-controller-primary.test.ts`\n```json\n it.only('renounce ownership', async () => {\n    console.log(\"Owner before\", await controller.owner())\n    // set max link fee\n    await controller.setMaxLINKFee(toEther(100))\n    // console out the max link fee\n    console.log(\"Set max link fee with onlyOwner modifier\", await controller.maxLINKFee())\n    \n    // renounce ownership using renounceOwnership() from owner contract\n    await expect(controller.renounceOwnership())\n    // set max link fee and expect revert\n    await expect(controller.setMaxLINKFee(toEther(200))).to.be.revertedWith('Ownable: caller is not the owner')\n    // console out the max link fee\n    console.log(\"set max link fee hasn't changed\", await controller.maxLINKFee())\n    // console out the owner\n    console.log(\"Owner after\", await controller.owner())\n \n  })\n```\n\n## Tools Used\nManual Review\n\n## Recommendations\nDisable `renounceOwnership()` if function in the Ownable contract not required.\n\n```diff\n+ function renounceOwnership() public override onlyOwner {\n+     revert (\"Not allowed\");\n+ }\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clqf7mgla0001yeyfah59c674",
  "Code": [
    {
      "filename": "contracts/core/ccip/RESDLTokenBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/ISDLPool.sol\";\nimport \"../interfaces/ISDLPoolCCIPController.sol\";\n\n/**\n * @title reSDL Token Bridge\n * @notice Handles CCIP transfers of reSDL NFTs\n */\ncontract RESDLTokenBridge is Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public linkToken;\n\n    IERC20 public sdlToken;\n    ISDLPool public sdlPool;\n    ISDLPoolCCIPController public sdlPoolCCIPController;\n\n    mapping(uint64 => bytes) public extraArgsByChain;\n\n    event TokenTransferred(\n        bytes32 indexed messageId,\n        uint64 indexed destinationChainSelector,\n        address indexed sender,\n        address receiver,\n        uint256 tokenId,\n        address feeToken,\n        uint256 fees\n    );\n    event TokenReceived(\n        bytes32 indexed messageId,\n        uint64 indexed sourceChainSelector,\n        address indexed sender,\n        address receiver,\n        uint256 tokenId\n    );\n    event SetExtraArgs(uint64 indexed chainSelector, bytes extraArgs);\n\n    error InsufficientFee();\n    error TransferFailed();\n    error FeeExceedsLimit();\n    error SenderNotAuthorized();\n    error InvalidReceiver();\n    error InvalidMsgValue();\n\n    /**\n     * @notice Initializes the contract\n     * @param _linkToken address of the LINK token\n     * @param _sdlToken address of the SDL token\n     * @param _sdlPool address of the SDL Pool\n     * @param _sdlPoolCCIPController address of the SDL Pool CCIP controller\n     **/\n    constructor(\n        address _linkToken,\n        address _sdlToken,\n        address _sdlPool,\n        address _sdlPoolCCIPController\n    ) {\n        linkToken = IERC20(_linkToken);\n        sdlToken = IERC20(_sdlToken);\n        sdlPool = ISDLPool(_sdlPool);\n        sdlPoolCCIPController = ISDLPoolCCIPController(_sdlPoolCCIPController);\n    }\n\n    modifier onlySDLPoolCCIPController() {\n        if (msg.sender != address(sdlPoolCCIPController)) revert SenderNotAuthorized();\n        _;\n    }\n\n    /**\n     * @notice Transfers an reSDL token to a destination chain\n     * @param _destinationChainSelector id of destination chain\n     * @param _receiver address to receive reSDL on destination chain\n     * @param _tokenId id of reSDL token\n     * @param _payNative whether fee should be paid natively or with LINK\n     * @param _maxLINKFee call will revert if LINK fee exceeds this value\n     **/\n    function transferRESDL(\n        uint64 _destinationChainSelector,\n        address _receiver,\n        uint256 _tokenId,\n        bool _payNative,\n        uint256 _maxLINKFee\n    ) external payable returns (bytes32 messageId) {\n        if (msg.sender != sdlPool.ownerOf(_tokenId)) revert SenderNotAuthorized();\n        if (_receiver == address(0)) revert InvalidReceiver();\n        if (_payNative == false && msg.value != 0) revert InvalidMsgValue();\n\n        (address destination, ISDLPool.RESDLToken memory reSDLToken) = sdlPoolCCIPController.handleOutgoingRESDL(\n            _destinationChainSelector,\n            msg.sender,\n            _tokenId\n        );\n        bytes memory extraArgs = extraArgsByChain[_destinationChainSelector];\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            _receiver,\n            _tokenId,\n            reSDLToken,\n            destination,\n            _payNative ? address(0) : address(linkToken),\n            extraArgs\n        );\n\n        uint256 fees = IRouterClient(sdlPoolCCIPController.getRouter()).getFee(_destinationChainSelector, evm2AnyMessage);\n\n        if (_payNative) {\n            if (fees > msg.value) revert InsufficientFee();\n            messageId = sdlPoolCCIPController.ccipSend{value: fees}(_destinationChainSelector, evm2AnyMessage);\n            if (fees < msg.value) {\n                (bool success, ) = msg.sender.call{value: msg.value - fees}(\"\");\n                if (!success) revert TransferFailed();\n            }\n        } else {\n            if (fees > _maxLINKFee) revert FeeExceedsLimit();\n            linkToken.safeTransferFrom(msg.sender, address(sdlPoolCCIPController), fees);\n            messageId = sdlPoolCCIPController.ccipSend(_destinationChainSelector, evm2AnyMessage);\n        }\n\n        emit TokenTransferred(\n            messageId,\n            _destinationChainSelector,\n            msg.sender,\n            _receiver,\n            _tokenId,\n            _payNative ? address(0) : address(linkToken),\n            fees\n        );\n    }\n\n    /**\n     * @notice Returns the current fee for an reSDL transfer\n     * @param _destinationChainSelector id of destination chain\n     * @param _payNative whether fee should be paid natively or with LINK\n     * @return fee current fee\n     **/\n    function getFee(uint64 _destinationChainSelector, bool _payNative) external view returns (uint256) {\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            address(this),\n            0,\n            ISDLPool.RESDLToken(0, 0, 0, 0, 0),\n            address(this),\n            _payNative ? address(0) : address(linkToken),\n            extraArgsByChain[_destinationChainSelector]\n        );\n\n        return IRouterClient(sdlPoolCCIPController.getRouter()).getFee(_destinationChainSelector, evm2AnyMessage);\n    }\n\n    /**\n     * @notice Sets the extra args used for sending reSDL to a chain\n     * @param _chainSelector id of chain\n     * @param _extraArgs extra args as defined in CCIP API\n     **/\n    function setExtraArgs(uint64 _chainSelector, bytes calldata _extraArgs) external onlyOwner {\n        extraArgsByChain[_chainSelector] = _extraArgs;\n        emit SetExtraArgs(_chainSelector, _extraArgs);\n    }\n\n    /**\n     * @notice Processes a received message\n     * @dev handles incoming reSDL transfers\n     * @param _message CCIP message\n     **/\n    function ccipReceive(Client.Any2EVMMessage memory _message) external onlySDLPoolCCIPController {\n        address sender = abi.decode(_message.sender, (address));\n\n        (\n            address receiver,\n            uint256 tokenId,\n            uint256 amount,\n            uint256 boostAmount,\n            uint64 startTime,\n            uint64 duration,\n            uint64 expiry\n        ) = abi.decode(_message.data, (address, uint256, uint256, uint256, uint64, uint64, uint64));\n\n        sdlPoolCCIPController.handleIncomingRESDL(\n            _message.sourceChainSelector,\n            receiver,\n            tokenId,\n            ISDLPool.RESDLToken(amount, boostAmount, startTime, duration, expiry)\n        );\n\n        emit TokenReceived(_message.messageId, _message.sourceChainSelector, sender, receiver, tokenId);\n    }\n\n    /**\n     * @notice Builds a CCIP message\n     * @dev builds the message for outgoing reSDL transfers\n     * @param _receiver address to receive reSDL token on destination chain\n     * @param _tokenId id of reSDL token\n     * @param _reSDLToken reSDL token\n     * @param _destination address of destination contract\n     * @param _feeTokenAddress address of token that fees will be paid in\n     * @param _extraArgs encoded args as defined in CCIP API\n     **/\n    function _buildCCIPMessage(\n        address _receiver,\n        uint256 _tokenId,\n        ISDLPool.RESDLToken memory _reSDLToken,\n        address _destination,\n        address _feeTokenAddress,\n        bytes memory _extraArgs\n    ) internal view returns (Client.EVM2AnyMessage memory) {\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({\n            token: address(sdlToken),\n            amount: _reSDLToken.amount\n        });\n        tokenAmounts[0] = tokenAmount;\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(_destination),\n            data: abi.encode(\n                _receiver,\n                _tokenId,\n                _reSDLToken.amount,\n                _reSDLToken.boostAmount,\n                _reSDLToken.startTime,\n                _reSDLToken.duration,\n                _reSDLToken.expiry\n            ),\n            tokenAmounts: tokenAmounts,\n            extraArgs: _extraArgs,\n            feeToken: _feeTokenAddress\n        });\n\n        return evm2AnyMessage;\n    }\n}"
    },
    {
      "filename": "contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./base/SDLPoolCCIPController.sol\";\nimport \"../interfaces/IERC677.sol\";\n\ninterface ISDLPoolPrimary is ISDLPool {\n    function handleIncomingUpdate(uint256 _numNewRESDLTokens, int256 _totalRESDLSupplyChange) external returns (uint256);\n}\n\ncontract SDLPoolCCIPControllerPrimary is SDLPoolCCIPController {\n    using SafeERC20 for IERC20;\n\n    uint64[] internal whitelistedChains;\n    mapping(uint64 => address) public whitelistedDestinations;\n\n    mapping(uint64 => bytes) public updateExtraArgsByChain;\n    mapping(uint64 => bytes) public rewardsExtraArgsByChain;\n    mapping(uint64 => uint256) public reSDLSupplyByChain;\n\n    mapping(address => address) public wrappedRewardTokens;\n\n    address public rewardsInitiator;\n\n    event DistributeRewards(bytes32 indexed messageId, uint64 indexed destinationChainSelector, uint256 fees);\n    event ChainAdded(uint64 indexed chainSelector, address destination, bytes updateExtraArgs, bytes rewardsExtraArgs);\n    event ChainRemoved(uint64 indexed chainSelector, address destination);\n    event SetUpdateExtraArgs(uint64 indexed chainSelector, bytes extraArgs);\n    event SetRewardsExtraArgs(uint64 indexed chainSelector, bytes extraArgs);\n    event SetWrappedRewardToken(address indexed token, address rewardToken);\n\n    /**\n     * @notice Initializes the contract\n     * @param _router address of the CCIP router\n     * @param _linkToken address of the LINK token\n     * @param _sdlToken address of the SDL token\n     * @param _sdlPool address of the SDL Pool\n     * @param _maxLINKFee max fee to be paid on an outgoing message\n     **/\n    constructor(\n        address _router,\n        address _linkToken,\n        address _sdlToken,\n        address _sdlPool,\n        uint256 _maxLINKFee\n    ) SDLPoolCCIPController(_router, _linkToken, _sdlToken, _sdlPool, _maxLINKFee) {}\n\n    modifier onlyRewardsInitiator() {\n        if (msg.sender != rewardsInitiator) revert SenderNotAuthorized();\n        _;\n    }\n\n    /**\n     * @notice Claims and distributes rewards between all secondary chains\n     **/\n    function distributeRewards() external onlyRewardsInitiator {\n        uint256 totalRESDL = ISDLPoolPrimary(sdlPool).effectiveBalanceOf(address(this));\n        address[] memory tokens = ISDLPoolPrimary(sdlPool).supportedTokens();\n        uint256 numDestinations = whitelistedChains.length;\n\n        ISDLPoolPrimary(sdlPool).withdrawRewards(tokens);\n\n        uint256[][] memory distributionAmounts = new uint256[][](numDestinations);\n        for (uint256 i = 0; i < numDestinations; ++i) {\n            distributionAmounts[i] = new uint256[](tokens.length);\n        }\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            address token = tokens[i];\n            uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n\n            address wrappedToken = wrappedRewardTokens[token];\n            if (wrappedToken != address(0)) {\n                IERC677(token).transferAndCall(wrappedToken, tokenBalance, \"\");\n                tokens[i] = wrappedToken;\n                tokenBalance = IERC20(wrappedToken).balanceOf(address(this));\n            }\n\n            uint256 totalDistributed;\n            for (uint256 j = 0; j < numDestinations; ++j) {\n                uint64 chainSelector = whitelistedChains[j];\n                uint256 rewards = j == numDestinations - 1\n                    ? tokenBalance - totalDistributed\n                    : (tokenBalance * reSDLSupplyByChain[chainSelector]) / totalRESDL;\n                distributionAmounts[j][i] = rewards;\n                totalDistributed += rewards;\n            }\n        }\n\n        for (uint256 i = 0; i < numDestinations; ++i) {\n            _distributeRewards(whitelistedChains[i], tokens, distributionAmounts[i]);\n        }\n    }\n\n    /**\n     * @notice Handles the outgoing transfer of an reSDL token to another chain\n     * @param _destinationChainSelector id of the destination chain\n     * @param _sender sender of the transfer\n     * @param _tokenId id of token\n     * @return the destination address\n     * @return the token being transferred\n     **/\n    function handleOutgoingRESDL(\n        uint64 _destinationChainSelector,\n        address _sender,\n        uint256 _tokenId\n    ) external override onlyBridge returns (address, ISDLPool.RESDLToken memory) {\n        if (whitelistedDestinations[_destinationChainSelector] == address(0)) revert InvalidDestination();\n        ISDLPool.RESDLToken memory reSDLToken = ISDLPoolPrimary(sdlPool).handleOutgoingRESDL(\n            _sender,\n            _tokenId,\n            address(this)\n        );\n        reSDLSupplyByChain[_destinationChainSelector] += reSDLToken.amount + reSDLToken.boostAmount;\n        return (whitelistedDestinations[_destinationChainSelector], reSDLToken);\n    }\n\n    /**\n     * @notice Handles the incoming transfer of an reSDL token from another chain\n     * @param _sourceChainSelector id of the source chain\n     * @param _receiver receiver of the transfer\n     * @param _tokenId id of reSDL token\n     * @param _reSDLToken reSDL token\n     **/\n    function handleIncomingRESDL(\n        uint64 _sourceChainSelector,\n        address _receiver,\n        uint256 _tokenId,\n        ISDLPool.RESDLToken calldata _reSDLToken\n    ) external override onlyBridge {\n        sdlToken.safeTransfer(sdlPool, _reSDLToken.amount);\n        ISDLPoolPrimary(sdlPool).handleIncomingRESDL(_receiver, _tokenId, _reSDLToken);\n        reSDLSupplyByChain[_sourceChainSelector] -= _reSDLToken.amount + _reSDLToken.boostAmount;\n    }\n\n    /**\n     * @notice Returns a list of all whitelisted chains\n     * @return list of whitelisted chain ids\n     **/\n    function getWhitelistedChains() external view returns (uint64[] memory) {\n        return whitelistedChains;\n    }\n\n    /**\n     * @notice Whitelists a new chain\n     * @param _chainSelector id of chain\n     * @param _destination address to receive CCIP messages on chain\n     * @param _updateExtraArgs extraArgs for sending updates to this destination as defined in CCIP docs\n     * @param _rewardsExtraArgs extraArgs for sending rewards to this destination as defined in CCIP docs\n     **/\n    function addWhitelistedChain(\n        uint64 _chainSelector,\n        address _destination,\n        bytes calldata _updateExtraArgs,\n        bytes calldata _rewardsExtraArgs\n    ) external onlyOwner {\n        if (whitelistedDestinations[_chainSelector] != address(0)) revert AlreadyAdded();\n        if (_destination == address(0)) revert InvalidDestination();\n        whitelistedChains.push(_chainSelector);\n        whitelistedDestinations[_chainSelector] = _destination;\n        updateExtraArgsByChain[_chainSelector] = _updateExtraArgs;\n        rewardsExtraArgsByChain[_chainSelector] = _rewardsExtraArgs;\n        emit ChainAdded(_chainSelector, _destination, _updateExtraArgs, _rewardsExtraArgs);\n    }\n\n    /**\n     * @notice Removes an existing chain\n     * @param _chainSelector id of chain\n     **/\n    function removeWhitelistedChain(uint64 _chainSelector) external onlyOwner {\n        if (whitelistedDestinations[_chainSelector] == address(0)) revert InvalidDestination();\n        emit ChainRemoved(_chainSelector, whitelistedDestinations[_chainSelector]);\n\n        for (uint256 i = 0; i < whitelistedChains.length; ++i) {\n            if (whitelistedChains[i] == _chainSelector) {\n                whitelistedChains[i] = whitelistedChains[whitelistedChains.length - 1];\n                whitelistedChains.pop();\n            }\n        }\n\n        delete whitelistedDestinations[_chainSelector];\n        delete updateExtraArgsByChain[_chainSelector];\n        delete rewardsExtraArgsByChain[_chainSelector];\n    }\n\n    /**\n     * @notice Approves the CCIP router to transfer tokens on behalf of this contract\n     * @param _tokens list of tokens to approve\n     **/\n    function approveRewardTokens(address[] calldata _tokens) external onlyOwner {\n        address router = getRouter();\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).safeApprove(router, type(uint256).max);\n        }\n    }\n\n    /**\n     * @notice Sets the wrapped token address for a reward token\n     * @param _token address of token\n     * @param _wrappedToken address of wrapped token\n     **/\n    function setWrappedRewardToken(address _token, address _wrappedToken) external onlyOwner {\n        wrappedRewardTokens[_token] = _wrappedToken;\n        emit SetWrappedRewardToken(_token, _wrappedToken);\n    }\n\n    /**\n     * @notice Sets the extra args used for sending updates to a chain\n     * @param _chainSelector id of chain\n     * @param _updateExtraArgs extra args as defined in CCIP API\n     **/\n    function setUpdateExtraArgs(uint64 _chainSelector, bytes calldata _updateExtraArgs) external onlyOwner {\n        if (whitelistedDestinations[_chainSelector] == address(0)) revert InvalidDestination();\n        updateExtraArgsByChain[_chainSelector] = _updateExtraArgs;\n        emit SetUpdateExtraArgs(_chainSelector, _updateExtraArgs);\n    }\n\n    /**\n     * @notice Sets the extra args used for sending rewards to a chain\n     * @param _chainSelector id of chain\n     * @param _rewardsExtraArgs extra args as defined in CCIP API\n     **/\n    function setRewardsExtraArgs(uint64 _chainSelector, bytes calldata _rewardsExtraArgs) external onlyOwner {\n        if (whitelistedDestinations[_chainSelector] == address(0)) revert InvalidDestination();\n        rewardsExtraArgsByChain[_chainSelector] = _rewardsExtraArgs;\n        emit SetRewardsExtraArgs(_chainSelector, _rewardsExtraArgs);\n    }\n\n    /**\n     * @notice Sets the rewards initiator\n     * @dev this address has sole authority to update rewards\n     * @param _rewardsInitiator address of rewards initiator\n     **/\n    function setRewardsInitiator(address _rewardsInitiator) external onlyOwner {\n        rewardsInitiator = _rewardsInitiator;\n    }\n\n    /**\n     * @notice Distributes rewards to a single chain\n     * @param _destinationChainSelector id of chain\n     * @param _rewardTokens list of reward tokens to distribute\n     * @param _rewardTokenAmounts list of reward token amounts to distribute\n     **/\n    function _distributeRewards(\n        uint64 _destinationChainSelector,\n        address[] memory _rewardTokens,\n        uint256[] memory _rewardTokenAmounts\n    ) internal {\n        address destination = whitelistedDestinations[_destinationChainSelector];\n        if (destination == address(0)) revert InvalidDestination();\n\n        uint256 numRewardTokensToTransfer;\n        for (uint256 i = 0; i < _rewardTokens.length; ++i) {\n            if (_rewardTokenAmounts[i] != 0) {\n                numRewardTokensToTransfer++;\n            }\n        }\n\n        if (numRewardTokensToTransfer == 0) return;\n\n        address[] memory rewardTokens = new address[](numRewardTokensToTransfer);\n        uint256[] memory rewardTokenAmounts = new uint256[](numRewardTokensToTransfer);\n        uint256 tokensAdded;\n        for (uint256 i = 0; i < _rewardTokens.length; ++i) {\n            if (_rewardTokenAmounts[i] != 0) {\n                rewardTokens[tokensAdded] = _rewardTokens[i];\n                rewardTokenAmounts[tokensAdded] = _rewardTokenAmounts[i];\n                tokensAdded++;\n            }\n        }\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            destination,\n            0,\n            rewardTokens,\n            rewardTokenAmounts,\n            rewardsExtraArgsByChain[_destinationChainSelector]\n        );\n\n        IRouterClient router = IRouterClient(this.getRouter());\n        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);\n\n        if (fees > maxLINKFee) revert FeeExceedsLimit(fees);\n        bytes32 messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);\n\n        emit DistributeRewards(messageId, _destinationChainSelector, fees);\n    }\n\n    /**\n     * @notice Processes a received message\n     * @dev handles incoming updates from a secondary chain and sends an update in response\n     * @param _message CCIP message\n     **/\n    function _ccipReceive(Client.Any2EVMMessage memory _message) internal override {\n        uint64 sourceChainSelector = _message.sourceChainSelector;\n\n        (uint256 numNewRESDLTokens, int256 totalRESDLSupplyChange) = abi.decode(_message.data, (uint256, int256));\n\n        if (totalRESDLSupplyChange > 0) {\n            reSDLSupplyByChain[sourceChainSelector] += uint256(totalRESDLSupplyChange);\n        } else if (totalRESDLSupplyChange < 0) {\n            reSDLSupplyByChain[sourceChainSelector] -= uint256(-1 * totalRESDLSupplyChange);\n        }\n\n        uint256 mintStartIndex = ISDLPoolPrimary(sdlPool).handleIncomingUpdate(numNewRESDLTokens, totalRESDLSupplyChange);\n\n        _ccipSendUpdate(sourceChainSelector, mintStartIndex);\n\n        emit MessageReceived(_message.messageId, sourceChainSelector);\n    }\n\n    /**\n     * @notice Sends an update to a secondary chain\n     * @param _destinationChainSelector id of destination chain\n     * @param _mintStartIndex first index to be used for minting new reSDL tokens\n     **/\n    function _ccipSendUpdate(uint64 _destinationChainSelector, uint256 _mintStartIndex) internal {\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            whitelistedDestinations[_destinationChainSelector],\n            _mintStartIndex,\n            new address[](0),\n            new uint256[](0),\n            updateExtraArgsByChain[_destinationChainSelector]\n        );\n\n        IRouterClient router = IRouterClient(this.getRouter());\n        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);\n\n        if (fees > maxLINKFee) revert FeeExceedsLimit(fees);\n        bytes32 messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);\n\n        emit MessageSent(messageId, _destinationChainSelector, fees);\n    }\n\n    /**\n     * @notice Builds a CCIP message\n     * @dev builds the message for reward distribution or outgoing updates to a secondary chain\n     * @param _destination address of destination contract\n     * @param _mintStartIndex first index to be used for minting new reSDL tokens\n     * @param _tokens list of tokens to transfer\n     * @param _tokenAmounts list of token amounts to transfer\n     * @param _extraArgs encoded args as defined in CCIP API\n     **/\n    function _buildCCIPMessage(\n        address _destination,\n        uint256 _mintStartIndex,\n        address[] memory _tokens,\n        uint256[] memory _tokenAmounts,\n        bytes memory _extraArgs\n    ) internal view returns (Client.EVM2AnyMessage memory) {\n        bool isRewardDistribution = _tokens.length != 0;\n\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](_tokens.length);\n        for (uint256 i = 0; i < _tokenAmounts.length; ++i) {\n            tokenAmounts[i] = Client.EVMTokenAmount({token: _tokens[i], amount: _tokenAmounts[i]});\n        }\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(_destination),\n            data: isRewardDistribution ? bytes(\"\") : abi.encode(_mintStartIndex),\n            tokenAmounts: tokenAmounts,\n            extraArgs: _extraArgs,\n            feeToken: address(linkToken)\n        });\n\n        return evm2AnyMessage;\n    }\n\n    /**\n     * @notice Verifies the sender of a CCIP message is whitelisted\n     * @param _message CCIP message\n     **/\n    function _verifyCCIPSender(Client.Any2EVMMessage memory _message) internal view override {\n        address sender = abi.decode(_message.sender, (address));\n        uint64 sourceChainSelector = _message.sourceChainSelector;\n        if (sender != whitelistedDestinations[sourceChainSelector]) revert SenderNotAuthorized();\n    }\n}"
    },
    {
      "filename": "contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./base/SDLPoolCCIPController.sol\";\n\ninterface ISDLPoolSecondary is ISDLPool {\n    function handleOutgoingUpdate() external returns (uint256, int256);\n\n    function handleIncomingUpdate(uint256 _mintStartIndex) external;\n\n    function shouldUpdate() external view returns (bool);\n}\n\ncontract SDLPoolCCIPControllerSecondary is SDLPoolCCIPController {\n    using SafeERC20 for IERC20;\n\n    uint64 public immutable primaryChainSelector;\n    address public immutable primaryChainDestination;\n    bytes public extraArgs;\n\n    bool public shouldUpdate;\n\n    event SetExtraArgs(bytes extraArgs);\n\n    error UpdateConditionsNotMet();\n\n    /**\n     * @notice Initializes the contract\n     * @param _router address of the CCIP router\n     * @param _linkToken address of the LINK token\n     * @param _sdlToken address of the SDL token\n     * @param _sdlPool address of the SDL Pool\n     * @param _primaryChainSelector id of the primary chain\n     * @param _primaryChainDestination address to receive messages on primary chain\n     * @param _maxLINKFee max fee to be paid on an outgoing message\n     * @param _extraArgs extra args as defined in CCIP API to be used for outgoing messages\n     **/\n    constructor(\n        address _router,\n        address _linkToken,\n        address _sdlToken,\n        address _sdlPool,\n        uint64 _primaryChainSelector,\n        address _primaryChainDestination,\n        uint256 _maxLINKFee,\n        bytes memory _extraArgs\n    ) SDLPoolCCIPController(_router, _linkToken, _sdlToken, _sdlPool, _maxLINKFee) {\n        primaryChainSelector = _primaryChainSelector;\n        primaryChainDestination = _primaryChainDestination;\n        extraArgs = _extraArgs;\n    }\n\n    /**\n     * @notice Returns whether an update to the primary chain should be initiated\n     * @dev used by Chainlink automation\n     * @return whether an update should be initiated\n     **/\n    function checkUpkeep(bytes calldata) external view returns (bool, bytes memory) {\n        return (shouldUpdate, \"0x\");\n    }\n\n    /**\n     * @notice Initiates an update to the primary chain if update conditions are met\n     * @dev used by Chainlink automation\n     **/\n    function performUpkeep(bytes calldata) external {\n        if (!shouldUpdate) revert UpdateConditionsNotMet();\n\n        shouldUpdate = false;\n        _initiateUpdate(primaryChainSelector, primaryChainDestination, extraArgs);\n    }\n\n    /**\n     * @notice Handles the outgoing transfer of an reSDL token to the primary chain\n     * @param _sender sender of the transfer\n     * @param _tokenId id of token\n     * @return the destination address\n     * @return the token being transferred\n     **/\n    function handleOutgoingRESDL(\n        uint64,\n        address _sender,\n        uint256 _tokenId\n    ) external override onlyBridge returns (address, ISDLPool.RESDLToken memory) {\n        return (primaryChainDestination, ISDLPoolSecondary(sdlPool).handleOutgoingRESDL(_sender, _tokenId, address(this)));\n    }\n\n    /**\n     * @notice Handles the incoming transfer of an reSDL token from the primary chain\n     * @param _receiver receiver of the transfer\n     * @param _tokenId id of reSDL token\n     * @param _reSDLToken reSDL token\n     **/\n    function handleIncomingRESDL(\n        uint64,\n        address _receiver,\n        uint256 _tokenId,\n        ISDLPool.RESDLToken calldata _reSDLToken\n    ) external override onlyBridge {\n        sdlToken.safeTransfer(sdlPool, _reSDLToken.amount);\n        ISDLPoolSecondary(sdlPool).handleIncomingRESDL(_receiver, _tokenId, _reSDLToken);\n    }\n\n    /**\n     * @notice Sets the extra args for sending updates to the primary chain\n     * @param _extraArgs extra args as defined in CCIP API\n     **/\n    function setExtraArgs(bytes calldata _extraArgs) external onlyOwner {\n        extraArgs = _extraArgs;\n        emit SetExtraArgs(_extraArgs);\n    }\n\n    /**\n     * @notice Initiates an update to the primary chain\n     * @param _destinationChainSelector id of destination chain\n     * @param _destination address to receive message on destination chain\n     * @param _extraArgs extra args as defined in CCIP API\n     **/\n    function _initiateUpdate(\n        uint64 _destinationChainSelector,\n        address _destination,\n        bytes memory _extraArgs\n    ) internal {\n        (uint256 numNewRESDLTokens, int256 totalRESDLSupplyChange) = ISDLPoolSecondary(sdlPool).handleOutgoingUpdate();\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            _destination,\n            numNewRESDLTokens,\n            totalRESDLSupplyChange,\n            _extraArgs\n        );\n\n        IRouterClient router = IRouterClient(this.getRouter());\n        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);\n\n        if (fees > maxLINKFee) revert FeeExceedsLimit(fees);\n        bytes32 messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);\n\n        emit MessageSent(messageId, _destinationChainSelector, fees);\n    }\n\n    /**\n     * @notice Processes a received message\n     * @dev handles incoming updates and reward distributions from the primary chain\n     * @param _message CCIP message\n     **/\n    function _ccipReceive(Client.Any2EVMMessage memory _message) internal override {\n        if (_message.data.length == 0) {\n            uint256 numRewardTokens = _message.destTokenAmounts.length;\n            address[] memory rewardTokens = new address[](numRewardTokens);\n            if (numRewardTokens != 0) {\n                for (uint256 i = 0; i < numRewardTokens; ++i) {\n                    rewardTokens[i] = _message.destTokenAmounts[i].token;\n                    IERC20(rewardTokens[i]).safeTransfer(sdlPool, _message.destTokenAmounts[i].amount);\n                }\n                ISDLPoolSecondary(sdlPool).distributeTokens(rewardTokens);\n                if (ISDLPoolSecondary(sdlPool).shouldUpdate()) shouldUpdate = true;\n            }\n        } else {\n            uint256 mintStartIndex = abi.decode(_message.data, (uint256));\n            ISDLPoolSecondary(sdlPool).handleIncomingUpdate(mintStartIndex);\n        }\n\n        emit MessageReceived(_message.messageId, _message.sourceChainSelector);\n    }\n\n    /**\n     * @notice Builds a CCIP message\n     * @dev builds the message for outgoing updates to the primary chain\n     * @param _destination address of destination contract\n     * @param _numNewRESDLTokens number of new reSDL NFTs to be minted\n     * @param _totalRESDLSupplyChange reSDL supply change since last update\n     * @param _extraArgs encoded args as defined in CCIP API\n     **/\n    function _buildCCIPMessage(\n        address _destination,\n        uint256 _numNewRESDLTokens,\n        int256 _totalRESDLSupplyChange,\n        bytes memory _extraArgs\n    ) internal view returns (Client.EVM2AnyMessage memory) {\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(_destination),\n            data: abi.encode(_numNewRESDLTokens, _totalRESDLSupplyChange),\n            tokenAmounts: new Client.EVMTokenAmount[](0),\n            extraArgs: _extraArgs,\n            feeToken: address(linkToken)\n        });\n\n        return evm2AnyMessage;\n    }\n\n    /**\n     * @notice Verifies the sender of a CCIP message is whitelisted\n     * @param _message CCIP message\n     **/\n    function _verifyCCIPSender(Client.Any2EVMMessage memory _message) internal view override {\n        address sender = abi.decode(_message.sender, (address));\n        uint64 sourceChainSelector = _message.sourceChainSelector;\n        if (sourceChainSelector != primaryChainSelector || sender != primaryChainDestination) revert SenderNotAuthorized();\n    }\n}"
    },
    {
      "filename": "contracts/core/ccip/WrappedTokenBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IWrappedLST.sol\";\n\n/**\n * @title Wrapped token bridge\n * @notice Handles CCIP"
    }
  ]
}