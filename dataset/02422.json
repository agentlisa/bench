{
  "Title": "M-10: HardVault never deposits assets to Compound",
  "Content": "# Issue M-10: HardVault never deposits assets to Compound \n\nSource: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/147 \n\n## Found by \nobront, koxuan\n\n## Summary\n\nWhile the protocol states that all underlying assets are deposited to their Compound fork to earn interest, it appears this action never happens in `HardVault.sol`.\n\n## Vulnerability Detail\n\nThe documentation and comments seem to make clear that all assets deposited to `HardVault.sol` should be deposited to Compound to earn yield:\n\n```solidity\n/**\n    * @notice Deposit underlying assets on Compound and issue share token\n    * @param amount Underlying token amount to deposit\n    * @return shareAmount cToken amount\n    */\nfunction deposit(address token, uint256 amount) { ... }\n\n/**\n    * @notice Withdraw underlying assets from Compound\n    * @param shareAmount Amount of cTokens to redeem\n    * @return withdrawAmount Amount of underlying assets withdrawn\n    */\nfunction withdraw(address token, uint256 shareAmount) { ... }\n```\nHowever, if we examine the code in these functions, there is no movement of the assets to Compound. Instead, they sit in the Hard Vault and doesn't earn any yield.\n\n## Impact\n\nUsers who may expect to be earning yield on their underlying tokens will not be.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/vault/HardVault.sol#L68-L116\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEither add the functionality to the Hard Vault to have the assets pulled from the ERC1155 and deposited to the Compound fork, or change the comments and docs to be clear that such underlying assets will not be receiving any yield.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/41",
  "Code": [
    {
      "filename": "contracts/vault/HardVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../utils/BlueBerryConst.sol\";\nimport \"../utils/BlueBerryErrors.sol\";\nimport \"../interfaces/IProtocolConfig.sol\";\nimport \"../interfaces/IHardVault.sol\";\n\ncontract HardVault is\n    OwnableUpgradeable,\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    IHardVault\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    IProtocolConfig public config;\n\n    event Deposited(\n        address indexed account,\n        uint256 amount,\n        uint256 shareAmount\n    );\n    event Withdrawn(\n        address indexed account,\n        uint256 amount,\n        uint256 shareAmount\n    );\n\n    function initialize(IProtocolConfig _config) external initializer {\n        __ERC1155_init(\"HardVault\");\n        __Ownable_init();\n        if (address(_config) == address(0)) revert ZERO_ADDRESS();\n        config = _config;\n    }\n\n    /// @dev Return the underlying ERC20 balance for the user.\n    /// @param token token address to get balance of\n    /// @param user user address to get balance of\n    function balanceOfERC20(address token, address user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return balanceOf(user, uint256(uint160(token)));\n    }\n\n    /// @dev Return the underlying ERC-20 for the given ERC-1155 token id.\n    /// @param id token id (corresponds to token address for wrapped ERC20)\n    function getUnderlyingToken(uint256 id) external pure returns (address) {\n        address token = address(uint160(id));\n        if (uint256(uint160(token)) != id) revert INVALID_TOKEN_ID(id);\n        return token;\n    }\n\n    /**\n     * @notice Deposit underlying assets on Compound and issue share token\n     * @param amount Underlying token amount to deposit\n     * @return shareAmount cToken amount\n     */\n    function deposit(address token, uint256 amount)\n        external\n        override\n        nonReentrant\n        returns (uint256 shareAmount)\n    {\n        if (amount == 0) revert ZERO_AMOUNT();\n        IERC20Upgradeable uToken = IERC20Upgradeable(token);\n        uint256 uBalanceBefore = uToken.balanceOf(address(this));\n        uToken.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 uBalanceAfter = uToken.balanceOf(address(this));\n\n        shareAmount = uBalanceAfter - uBalanceBefore;\n        _mint(msg.sender, uint256(uint160(token)), shareAmount, \"\");\n\n        emit Deposited(msg.sender, amount, shareAmount);\n    }\n\n    /**\n     * @notice Withdraw underlying assets from Compound\n     * @param shareAmount Amount of cTokens to redeem\n     * @return withdrawAmount Amount of underlying assets withdrawn\n     */\n    function withdraw(address token, uint256 shareAmount)\n        external\n        override\n        nonReentrant\n        returns (uint256 withdrawAmount)\n    {\n        if (shareAmount == 0) revert ZERO_AMOUNT();\n        IERC20Upgradeable uToken = IERC20Upgradeable(token);\n        _burn(msg.sender, uint256(uint160(token)), shareAmount);\n        withdrawAmount = shareAmount;\n\n        // Cut withdraw fee if it is in withdrawVaultFee Window (2 months)\n        if (\n            block.timestamp <\n            config.withdrawVaultFeeWindowStartTime() +\n                config.withdrawVaultFeeWindow()\n        ) {\n            uint256 fee = (withdrawAmount * config.withdrawVaultFee()) /\n                DENOMINATOR;\n            uToken.safeTransfer(config.treasury(), fee);\n            withdrawAmount -= fee;\n        }\n        uToken.safeTransfer(msg.sender, withdrawAmount);\n\n        emit Withdrawn(msg.sender, withdrawAmount, shareAmount);\n    }\n}"
    }
  ]
}