{
  "Title": "[H-02] A malicious user can steal other user's deposits from Vault.sol",
  "Content": "\n### Lines of code\n\n<https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L509-L521>\n<https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L407-L415>\n\n### Impact\n\nWhen the `Vault.withdraw()` function is called, a maximum of `type(uint96).max` shares are burnt subsequently: `Vault.withdraw()`-> `Vault._withdraw()`-> `Vault._burn` burns `uint96(_shares)`, see [Vault.sol line 1139](<https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L1138-L1139>).\n\nA malicious user can exploit this in the following way:\n\n1. A malicious user deposits, for example, two times the value of `type(uint96).max` underlying assets into the Vault; calling the function `Vault.deposit()` two times. They can't deposit more in a single transaction because `type(uint96).max` is the maximum value to deposit.\n\n2. Then, the malicious user calls `Vault.withdraw()` with a higher value of assets to withdraw more than `type(uint96).max`. For example, they withdraw (`2 * type(uint96).max`), which is the total amount of assets they deposited before.\n\n3. Now what happens, is the Vault.sol contract only burns `type(uint96).max` shares for the user, but transfers `2 * type(uint96).max` underlying assets to the malicious user, which is the total amount they deposited before.\n\n4. This happens because `Vault._burn()` only burns `uint96(shares)` shares of the malicious users - see Vault.sol line 1155.\n\n5. Now, the malicious user has still vault shares left but they withdrew the total amount of their deposited assets.\n\n6. Now, the vault transferred the total amount of the malicious user's assets back to them and the malicious user still has shares left to withdraw; with even more assets that are now being stolen from assets deposited by other users.\n\n7. Or, if the malicious user was the first depositor, they wait until another user deposits and the malicious user can now withdraw the other users deposited assets since the malicious user still has Vault shares left.\n\n8. Or, if the malicious user is not the first depositor, they use a `flashLoan` or `flashMint` to deposit multiple times `type(uint96).max` assets into the vault. Then, they can withdraw their deposit, pay back the `flashLoan` or `flashMint` and they will still have enough vault shares left to steal all other users assets by withdrawing them.\n\nIn this way, other user's deposited assets can be stolen, as explained above.\n\n### Proof of Concept\n\nHere is a POC, where the problem is illustrated:\n\n<https://gist.github.com/zzzitron/397790302ca95aa3fbf05694ae1497ab>\n\n### Recommended Mitigation Steps\n\nConsider adjusting the `Vault._burn` function to not convert from `uint256` to `uint96` when burning shares.\n\n### Assessed type\n\nMath\n\n**[asselstine (PoolTogether) confirmed](https://github.com/code-423n4/2023-07-pooltogether-findings/issues/439#issuecomment-1644753948)**\n\n**[PoolTogether mitigated](https://github.com/code-423n4/2023-08-pooltogether-mitigation#individual-prs):**\n> Added SafeCast<br>\n> PR: https://github.com/GenerationSoftware/pt-v5-vault/pull/9\n\n**Status**: Mitigation confirmed. Full details in reports from [dirk\\_y](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/3), [rvierdiiev](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/28) and [0xStalin](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/25).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-pooltogether",
  "Code": [
    {
      "filename": "src/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ERC4626, ERC20, IERC20, IERC4626 } from \"openzeppelin/token/ERC20/extensions/ERC4626.sol\";\nimport { ERC20Permit, IERC20Permit } from \"openzeppelin/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport { SafeERC20 } from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"openzeppelin/utils/math/Math.sol\";\nimport { Ownable } from \"owner-manager-contracts/Ownable.sol\";\n\nimport { LiquidationPair } from \"v5-liquidator/LiquidationPair.sol\";\nimport { ILiquidationSource } from \"v5-liquidator-interfaces/ILiquidationSource.sol\";\nimport { PrizePool } from \"v5-prize-pool/PrizePool.sol\";\nimport { TwabController } from \"v5-twab-controller/TwabController.sol\";\nimport { VaultHooks } from \"./interfaces/IVaultHooks.sol\";\n\n/// @notice Emitted when the TWAB controller is set to the zero address\nerror TwabControllerZeroAddress();\n\n/// @notice Emitted when the Yield Vault is set to the zero address\nerror YieldVaultZeroAddress();\n\n/// @notice Emitted when the Prize Pool is set to the zero address\nerror PrizePoolZeroAddress();\n\n/// @notice Emitted when the Owner is set to the zero address\nerror OwnerZeroAddress();\n\n/// @notice Emitted when the amount being deposited for the receiver is greater than the max amount allowed\n/// @param receiver The receiver of the deposit\n/// @param amount The amount to deposit\n/// @param max The max deposit amount allowed\nerror DepositMoreThanMax(address receiver, uint256 amount, uint256 max);\n\n/// @notice Emitted when the amount being withdrawn for the owner is greater than the max amount allowed\n/// @param owner The owner of the assets\n/// @param amount The amount to withdraw\n/// @param max The max withdrawable amount\nerror WithdrawMoreThanMax(address owner, uint256 amount, uint256 max);\n\n/// @notice Emitted when the amount being redeemed for owner is greater than the max allowed amount\n/// @param owner The owner of the assets\n/// @param amount The amount to redeem\n/// @param max The max redeemable amount\nerror RedeemMoreThanMax(address owner, uint256 amount, uint256 max);\n\n/// @notice Emitted when the amount of shares being minted to the receiver is greater than the max amount allowed\n/// @param receiver The receiver address\n/// @param shares The shares being minted\n/// @param max The max amount of shares that can be minted to the receiver\nerror MintMoreThanMax(address receiver, uint256 shares, uint256 max);\n\n/// @notice Emitted during the liquidation process when the caller is not the liquidation pair contract\n/// @param caller The caller address\n/// @param liquidationPair The LP address\nerror LiquidationCallerNotLP(address caller, address liquidationPair);\n\n/// @notice Emitted during the liquidation process when the token in is not the prize token\n/// @param tokenIn The provided tokenIn address\n/// @param prizeToken The prize token address\nerror LiquidationTokenInNotPrizeToken(address tokenIn, address prizeToken);\n\n/// @notice Emitted during the liquidation process when the token out is not the vault share token\n/// @param tokenOut The provided tokenOut address\n/// @param vaultShare The vault share token address\nerror LiquidationTokenOutNotVaultShare(address tokenOut, address vaultShare);\n\n/// @notice Emitted during the liquidation process when the liquidation amount out is zero\nerror LiquidationAmountOutZero();\n\n/// @notice Emitted during the liquidation process if the amount out is greater than the available yield\n/// @param amountOut The amount out\n/// @param availableYield The available yield\nerror LiquidationAmountOutGTYield(uint256 amountOut, uint256 availableYield);\n\n/// @notice Emitted when the vault is under-collateralized\nerror VaultUnderCollateralized();\n\n/// @notice Emitted when the target token is not supported for a given token address\n/// @param token The unsupported token address\nerror TargetTokenNotSupported(address token);\n\n/// @notice Emitted when the caller is not the prize claimer\n/// @param caller The caller address\n/// @param claimer The claimer address\nerror CallerNotClaimer(address caller, address claimer);\n\n/// @notice Emitted when the minted yield exceeds the yield fee supply\n/// @param shares The shares to mint\n/// @param yieldFeeTotalSupply The accrued yield fee available\nerror YieldFeeGTAvailable(uint256 shares, uint256 yieldFeeTotalSupply);\n\n/// @notice Emitted when the Liquidation Pair being set is the zero address\nerror LPZeroAddress();\n\n/// @notice Emitted when the yield fee percentage being set is greater than 1\n/// @param yieldFeePercentage The yield fee percentage in integer format\n/// @param maxYieldFeePercentage The max yield fee percentage in integer format (this value is equal to 1 in decimal format)\nerror YieldFeePercentageGTPrecision(uint256 yieldFeePercentage, uint256 maxYieldFeePercentage);\n\n/**\n * @title  PoolTogether V5 Vault\n * @author PoolTogether Inc Team, Generation Software Team\n * @notice Vault extends the ERC4626 standard and is the entry point for users interacting with a V5 pool.\n *         Users deposit an underlying asset (i.e. USDC) in this contract and receive in exchange an ERC20 token\n *         representing their share of deposit in the vault.\n *         Underlying assets are then deposited in a YieldVault to generate yield.\n *         This yield is sold for prize tokens (i.e. POOL) via the Liquidator and captured by the PrizePool to be awarded to depositors.\n * @dev    Balances are stored in the TwabController contract.\n */\ncontract Vault is ERC4626, ERC20Permit, ILiquidationSource, Ownable {\n  using Math for uint256;\n  using SafeERC20 for IERC20;\n\n  /* ============ Events ============ */\n\n  /**\n   * @notice Emitted when a new Vault has been deployed.\n   * @param asset Address of the underlying asset used by the vault\n   * @param name Name of the ERC20 share minted by the vault\n   * @param symbol Symbol of the ERC20 share minted by the vault\n   * @param twabController Address of the TwabController used to keep track of balances\n   * @param yieldVault Address of the ERC4626 vault in which assets are deposited to generate yield\n   * @param prizePool Address of the PrizePool that computes prizes\n   * @param claimer Address of the claimer\n   * @param yieldFeeRecipient Address of the yield fee recipient\n   * @param yieldFeePercentage Yield fee percentage in integer format with 1e9 precision (50% would be 5e8)\n   * @param owner Address of the contract owner\n   */\n  event NewVault(\n    IERC20 indexed asset,\n    string name,\n    string symbol,\n    TwabController twabController,\n    IERC4626 indexed yieldVault,\n    PrizePool indexed prizePool,\n    address claimer,\n    address yieldFeeRecipient,\n    uint256 yieldFeePercentage,\n    address owner\n  );\n\n  /**\n   * @notice Emitted when a new claimer has been set.\n   * @param previousClaimer Address of the previous claimer\n   * @param newClaimer Address of the new claimer\n   */\n  event ClaimerSet(address previousClaimer, address newClaimer);\n\n  /**\n   * @notice Emitted when an account sets new hooks\n   * @param account The account whose hooks are being configured\n   * @param hooks The hooks being set\n   */\n  event SetHooks(address account, VaultHooks hooks);\n\n  /**\n   * @notice Emitted when a new LiquidationPair has been set.\n   * @param newLiquidationPair Address of the new liquidationPair\n   */\n  event LiquidationPairSet(LiquidationPair newLiquidationPair);\n\n  /**\n   * @notice Emitted when yield fee is minted to the yield recipient.\n   * @param caller Address that called the function\n   * @param recipient Address receiving the Vault shares\n   * @param shares Amount of shares minted to `recipient`\n   */\n  event MintYieldFee(address indexed caller, address indexed recipient, uint256 shares);\n\n  /**\n   * @notice Emitted when a new yield fee recipient has been set.\n   * @param previousYieldFeeRecipient Address of the previous yield fee recipient\n   * @param newYieldFeeRecipient Address of the new yield fee recipient\n   */\n  event YieldFeeRecipientSet(address previousYieldFeeRecipient, address newYieldFeeRecipient);\n\n  /**\n   * @notice Emitted when a new yield fee percentage has been set.\n   * @param previousYieldFeePercentage Previous yield fee percentage\n   * @param newYieldFeePercentage New yield fee percentage\n   */\n  event YieldFeePercentageSet(uint256 previousYieldFeePercentage, uint256 newYieldFeePercentage);\n\n  /**\n   * @notice Emitted when a user sponsors the Vault.\n   * @param caller Address that called the function\n   * @param receiver Address receiving the Vault shares\n   * @param assets Amount of assets deposited into the Vault\n   * @param shares Amount of shares minted to the receiving address\n   */\n  event Sponsor(address indexed caller, address indexed receiver, uint256 assets, uint256 shares);\n\n  /**\n   * @notice Emitted when the `_lastRecordedExchangeRate` is updated.\n   * @param exchangeRate The recorded exchange rate\n   * @dev This happens on mint and burn of shares\n   */\n  event RecordedExchangeRate(uint256 exchangeRate);\n\n  /* ============ Variables ============ */\n\n  /// @notice Address of the TwabController used to keep track of balances.\n  TwabController private immutable _twabController;\n\n  /// @notice Address of the ERC4626 vault generating yield.\n  IERC4626 private immutable _yieldVault;\n\n  /// @notice Address of the PrizePool that computes prizes.\n  PrizePool private immutable _prizePool;\n\n  /// @notice Address of the claimer.\n  address private _claimer;\n\n  /// @notice Address of the LiquidationPair used to liquidate yield for prize token.\n  LiquidationPair private _liquidationPair;\n\n  /// @notice Underlying asset unit (i.e. 10 ** 18 for DAI).\n  uint256 private _assetUnit;\n\n  /// @notice Most recent exchange rate recorded when burning or minting Vault shares.\n  uint256 private _lastRecordedExchangeRate;\n\n  /// @notice Yield fee percentage represented in integer format with 9 decimal places (i.e. 10000000 = 0.01 = 1%).\n  uint256 private _yieldFeePercentage;\n\n  /// @notice Address of the yield fee recipient that receives the fee amount when yield is captured.\n  address private _yieldFeeRecipient;\n\n  /// @notice Total accrued supply from the yield fee.\n  uint256 private _yieldFeeTotalSupply;\n\n  /// @notice Fee precision denominated in 9 decimal places and used to calculate yield fee percentage.\n  uint256 private constant FEE_PRECISION = 1e9;\n\n  /// @notice Maps user addresses to hooks that they want to execute when prizes are won\n  mapping(address => VaultHooks) internal _hooks;\n\n  /* ============ Constructor ============ */\n\n  /**\n   * @notice Vault constructor\n   * @dev `claimer_` can be set to address zero if none is available yet.\n   * @param asset_ Address of the underlying asset used by the vault\n   * @param name_ Name of the ERC20 share minted by the vault\n   * @param symbol_ Symbol of the ERC20 share minted by the vault\n   * @param twabController_ Address of the TwabController used to keep track of balances\n   * @param yieldVault_ Address of the ERC4626 vault in which assets are deposited to generate yield\n   * @param prizePool_ Address of the PrizePool that computes prizes\n   * @param claimer_ Address of the claimer\n   * @param yieldFeeRecipient_ Address of the yield fee recipient\n   * @param yieldFeePercentage_ Yield fee percentage\n   * @param owner_ Address that will gain ownership of this contract\n   */\n  constructor(\n    IERC20 asset_,\n    string memory name_,\n    string memory symbol_,\n    TwabController twabController_,\n    IERC4626 yieldVault_,\n    PrizePool prizePool_,\n    address claimer_,\n    address yieldFeeRecipient_,\n    uint256 yieldFeePercentage_,\n    address owner_\n  ) ERC4626(asset_) ERC20(name_, symbol_) ERC20Permit(name_) Ownable(owner_) {\n    if (address(twabController_) == address(0)) revert TwabControllerZeroAddress();\n    if (address(yieldVault_) == address(0)) revert YieldVaultZeroAddress();\n    if (address(prizePool_) == address(0)) revert PrizePoolZeroAddress();\n    if (address(owner_) == address(0)) revert OwnerZeroAddress();\n\n    _twabController = twabController_;\n    _yieldVault = yieldVault_;\n    _prizePool = prizePool_;\n\n    _setClaimer(claimer_);\n    _setYieldFeeRecipient(yieldFeeRecipient_);\n    _setYieldFeePercentage(yieldFeePercentage_);\n\n    _assetUnit = 10 ** super.decimals();\n\n    // Approve once for max amount\n    asset_.safeApprove(address(yieldVault_), type(uint256).max);\n\n    emit NewVault(\n      asset_,\n      name_,\n      symbol_,\n      twabController_,\n      yieldVault_,\n      prizePool_,\n      claimer_,\n      yieldFeeRecipient_,\n      yieldFeePercentage_,\n      owner_\n    );\n  }\n\n  /* ===================================================== */\n  /* ============ Public & External Functions ============ */\n  /* ===================================================== */\n\n  /**\n   * @notice Total available yield amount accrued by this vault.\n   * @dev This amount includes the liquidatable yield + yield fee amount.\n   * @dev The available yield is equal to the total amount of assets managed by this Vault\n   *      minus the total amount of assets supplied to the Vault and yield fees allocated to `_yieldFeeRecipient`.\n   * @dev If `_sharesToAssets` is greater than `_assets`, it means that the Vault is undercollateralized.\n   *      We must not mint more shares than underlying assets available so we return 0.\n   * @return uint256 Total yield amount\n   */\n  function availableYieldBalance() public view returns (uint256) {\n    uint256 _assets = _totalAssets();\n    uint256 _sharesToAssets = _convertToAssets(_totalShares(), Math.Rounding.Down);\n\n    return _sharesToAssets > _assets ? 0 : _assets - _sharesToAssets;\n  }\n\n  /**\n   * @notice Get the available yield fee amount accrued by this vault.\n   * @return uint256 Yield fee amount\n   */\n  function availableYieldFeeBalance() public view returns (uint256) {\n    uint256 _availableYield = availableYieldBalance();\n\n    if (_availableYield != 0 && _yieldFeePercentage != 0) {\n      return _availableYieldFeeBalance(_availableYield);\n    }\n\n    return 0;\n  }\n\n  /// @inheritdoc ERC20\n  function balanceOf(\n    address _account\n  ) public view virtual override(ERC20, IERC20) returns (uint256) {\n    return _twabController.balanceOf(address(this), _account);\n  }\n\n  /// @inheritdoc ERC4626\n  function decimals() public view virtual override(ERC4626, ERC20) returns (uint8) {\n    return super.decimals();\n  }\n\n  /// @inheritdoc ERC4626\n  function totalAssets() public view virtual override returns (uint256) {\n    return _totalAssets();\n  }\n\n  /// @inheritdoc ERC20\n  function totalSupply() public view virtual override(ERC20, IERC20) returns (uint256) {\n    return _totalSupply();\n  }\n\n  /**\n   * @notice Current exchange rate between the Vault shares and\n   *         the total amount of underlying assets withdrawable from the YieldVault.\n   * @return uint256 Current exchange rate\n   */\n  function exchangeRate() public view returns (uint256) {\n    return _currentExchangeRate();\n  }\n\n  /**\n   * @notice Check if the Vault is collateralized.\n   * @return bool True if the vault is collateralized, false otherwise\n   */\n  function isVaultCollateralized() public view returns (bool) {\n    return _isVaultCollateralized();\n  }\n\n  /**\n   * @inheritdoc ERC4626\n   * @dev We use type(uint96).max cause this is the type used to store balances in TwabController.\n   */\n  function maxDeposit(address) public view virtual override returns (uint256) {\n    return _isVaultCollateralized() ? type(uint96).max : 0;\n  }\n\n  /**\n   * @inheritdoc ERC4626\n   * @dev We use type(uint96).max cause this is the type used to store balances in TwabController.\n   */\n  function maxMint(address) public view virtual override returns (uint256) {\n    return _isVaultCollateralized() ? type(uint96).max : 0;\n  }\n\n  /**\n   * @notice Mint Vault shares to the yield fee `_recipient`.\n   * @dev Will revert if the Vault is undercollateralized\n   *      or if the `_shares` are greater than the accrued `_yieldFeeTotalSupply`.\n   * @param _shares Amount of shares to mint\n   * @param _recipient Address of the yield fee recipient\n   */\n  function mintYieldFee(uint256 _shares, address _recipient) external {\n    _requireVaultCollateralized();\n    if (_shares > _yieldFeeTotalSupply) revert YieldFeeGTAvailable(_shares, _yieldFeeTotalSupply);\n\n    _yieldFeeTotalSupply -= _shares;\n    _mint(_recipient, _shares);\n\n    emit MintYieldFee(msg.sender, _recipient, _shares);\n  }\n\n  /* ============ Deposit Functions ============ */\n\n  /// @inheritdoc ERC4626\n  function deposit(uint256 _assets, address _receiver) public virtual override returns (uint256) {\n    if (_assets > maxDeposit(_receiver))\n      revert DepositMoreThanMax(_receiver, _assets, maxDeposit(_receiver));\n\n    uint256 _shares = _convertToShares(_assets, Math.Rounding.Down);\n    _deposit(msg.sender, _receiver, _assets, _shares);\n\n    return _shares;\n  }\n\n  /**\n   * @notice Approve underlying asset with permit, deposit into the Vault and mint Vault shares to `_receiver`.\n   * @param _assets Amount of assets to approve and deposit\n   * @param _receiver Address of the receiver of the vault shares\n   * @param _deadline Timestamp after which the approval is no longer valid\n   * @param _v V part of the secp256k1 signature\n   * @param _r R part of the secp256k1 signature\n   * @param _s S part of the secp256k1 signature\n   * @return uint256 Amount of Vault shares minted to `_receiver`.\n   */\n  function depositWithPermit(\n    uint256 _assets,\n    address _receiver,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external returns (uint256) {\n    _permit(IERC20Permit(asset()), msg.sender, address(this), _assets, _deadline, _v, _r, _s);\n    return deposit(_assets, _receiver);\n  }\n\n  /// @inheritdoc ERC4626\n  function mint(uint256 _shares, address _receiver) public virtual override returns (uint256) {\n    uint256 _assets = _beforeMint(_shares, _receiver);\n\n    _deposit(msg.sender, _receiver, _assets, _shares);\n\n    return _assets;\n  }\n\n  /**\n   * @notice Approve underlying asset with permit, deposit into the Vault and mint Vault shares to `_receiver`.\n   * @param _shares Amount of shares to mint to `_receiver`\n   * @param _receiver Address of the receiver of the vault shares\n   * @param _deadline Timestamp after which the approval is no longer valid\n   * @param _v V part of the secp256k1 signature\n   * @param _r R part of the secp256k1 signature\n   * @param _s S part of the secp256k1 signature\n   * @return uint256 Amount of assets deposited into the Vault.\n   */\n  function mintWithPermit(\n    uint256 _shares,\n    address _receiver,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external returns (uint256) {\n    uint256 _assets = _beforeMint(_shares, _receiver);\n\n    _permit(IERC20Permit(asset()), msg.sender, address(this), _assets, _deadline, _v, _r, _s);\n    _deposit(msg.sender, _receiver, _assets, _shares);\n\n    return _assets;\n  }\n\n  /**\n   * @notice Deposit assets into the Vault and delegate to the sponsorship address.\n   * @param _assets Amount of assets to deposit\n   * @param _receiver Address of the receiver of the vault shares\n   * @return uint256 Amount of shares minted to `_receiver`.\n   */\n  function sponsor(uint256 _assets, address _receiver) external returns (uint256) {\n    return _sponsor(_assets, _receiver);\n  }\n\n  /**\n   * @notice Deposit assets into the Vault and delegate to the sponsorship address.\n   * @param _assets Amount of assets to deposit\n   * @param _receiver Address of the receiver of the vault shares\n   * @param _deadline Timestamp after which the approval is no longer valid\n   * @param _v V part of the secp256k1 signature\n   * @param _r R part of the secp256k1 signature\n   * @param _s S part of the secp256k1 signature\n   * @return uint256 Amount of shares minted to `_receiver`.\n   */\n  function sponsorWithPermit(\n    uint256 _assets,\n    address _receiver,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external returns (uint256) {\n    _permit(IERC20Permit(asset()), msg.sender, address(this), _assets, _deadline, _v, _r, _s);\n    return _sponsor(_assets, _receiver);\n  }\n\n  /* ============ Withdraw Functions ============ */\n\n  /// @inheritdoc ERC4626\n  function withdraw(\n    uint256 _assets,\n    address _receiver,\n    address _owner\n  ) public virtual override returns (uint256) {\n    if (_assets > maxWithdraw(_owner))\n      revert WithdrawMoreThanMax(_owner, _assets, maxWithdraw(_owner));\n\n    uint256 _shares = _convertToShares(_assets, Math.Rounding.Up);\n    _withdraw(msg.sender, _receiver, _owner, _assets, _shares);\n\n    return _shares;\n  }\n\n  /// @inheritdoc ERC4626\n  function redeem(\n    uint256 _shares,\n    address _receiver,\n    address _owner\n  ) public virtual override returns (uint256) {\n    if (_shares > maxRedeem(_owner)) revert RedeemMoreThanMax(_owner, _shares, maxRedeem(_owner));\n\n    uint256 _assets = _convertToAssets(_shares, Math.Rounding.Down);\n    _withdraw(msg.sender, _receiver, _owner, _assets, _shares);\n\n    return _assets;\n  }\n\n  /* ============ Liquidation Functions ============ */\n\n  /// @inheritdoc ILiquidationSource\n  function liquidatableBalanceOf(address _token) public view override returns (uint256) {\n    return _liquidatableBalanceOf(_token);\n  }\n\n  /**\n   * @inheritdoc ILiquidationSource\n   * @dev User provides prize tokens and receives in exchange Vault shares.\n   * @dev The yield fee can serve as a buffer in case of undercollateralization of the Vault.\n   * @dev If assets are living in the Vault, we deposit it in the YieldVault.\n   */\n  function liquidate(\n    address _account,\n    address _tokenIn,\n    uint256 _amountIn,\n    address _tokenOut,\n    uint256 _amountOut\n  ) public virtual override returns (bool) {\n    _requireVaultCollateralized();\n    if (msg.sender != address(_liquidationPair))\n      revert LiquidationCallerNotLP(msg.sender, address(_liquidationPair));\n    if (_tokenIn != address(_prizePool.prizeToken()))\n      revert LiquidationTokenInNotPrizeToken(_tokenIn, address(_prizePool.prizeToken()));\n    if (_tokenOut != address(this))\n      revert LiquidationTokenOutNotVaultShare(_tokenOut, address(this));\n    if (_amountOut == 0) revert LiquidationAmountOutZero();\n\n    uint256 _liquidableYield = _liquidatableBalanceOf(_tokenOut);\n    if (_amountOut > _liquidableYield)\n      revert LiquidationAmountOutGTYield(_amountOut, _liquidableYield);\n\n    _prizePool.contributePrizeTokens(address(this), _amountIn);\n\n    if (_yieldFeePercentage != 0) {\n      _increaseYieldFeeBalance(\n        (_amountOut * FEE_PRECISION) / (FEE_PRECISION - _yieldFeePercentage) - _amountOut\n      );\n    }\n\n    uint256 _vaultAssets = IERC20(asset()).balanceOf(address(this));\n\n    if (_vaultAssets != 0 && _amountOut >= _vaultAssets) {\n      _yieldVault.deposit(_vaultAssets, address(this));\n    }\n\n    _mint(_account, _amountOut);\n\n    return true;\n  }\n\n  /// @inheritdoc ILiquidationSource\n  function targetOf(address _token) external view returns (address) {\n    if (_token != _liquidationPair.tokenIn()) revert TargetTokenNotSupported(_token);\n    return address(_prizePool);\n  }\n\n  /* ============ Claim Functions ============ */\n\n  /**\n   * @notice Claim prizes for the `_winners`\n   * @dev The caller must be the claimer\n   * @param _tier Tier to claim prize for\n   * @param _winners Addresses of the winners to claim prizes\n   * @param _prizeIndices The prizes to claim for each winner\n   * @param _feePerClaim Fee to be charged per prize claim\n   * @param _feeRecipient Address that will receive `_claimFee` amount\n   * @return uint256 The total prize amounts claimed\n   */\n  function claimPrizes(\n    uint8 _tier,\n    address[] calldata _winners,\n    uint32[][] calldata _prizeIndices,\n    uint96 _feePerClaim,\n    address _feeRecipient\n  ) external returns (uint256) {\n    if (msg.sender != _claimer) revert CallerNotClaimer(msg.sender, _claimer);\n\n    uint totalPrizes;\n\n    for (uint w = 0; w < _winners.length; w++) {\n      uint prizeIndicesLength = _prizeIndices[w].length;\n      for (uint p = 0; p < prizeIndicesLength; p++) {\n        totalPrizes += _claimPrize(\n          _winners[w],\n          _tier,\n          _prizeIndices[w][p],\n          _feePerClaim,\n          _feeRecipient\n        );\n      }\n    }\n\n    return totalPrizes;\n  }\n\n  /* ============ Setter Functions ============ */\n\n  /**\n   * @notice Set claimer.\n   * @param claimer_ Address of the claimer\n   * @return address New claimer address\n   */\n  function setClaimer(address claimer_) external onlyOwner returns (address) {\n    address _previousClaimer = _claimer;\n    _setClaimer(claimer_);\n\n    emit ClaimerSet(_previousClaimer, claimer_);\n    return claimer_;\n  }\n\n  /**\n   * @notice Sets the hooks for a winner\n   * @param hooks The hooks to set.\n   */\n  function setHooks(VaultHooks memory hooks) external {\n    _hooks[msg.sender] = hooks;\n\n    emit SetHooks(msg.sender, hooks);\n  }\n\n  /**\n   * @notice Set liquidationPair.\n   * @dev We reset approval of the previous liquidationPair and approve max for new one.\n   * @param liquidationPair_ New liquidationPair address\n   * @return address New liquidationPair address\n   */\n  function setLiquidationPair(\n    LiquidationPair liquidationPair_\n  ) external onlyOwner returns (address) {\n    if (address(liquidationPair_) == address(0)) revert LPZeroAddress();\n\n    IERC20 _asset = IERC20(asset());\n    address _previousLiquidationPair = address(_liquidationPair);\n\n    if (_previousLiquidationPair != address(0)) {\n      _asset.safeApprove(_previousLiquidationPair, 0);\n    }\n\n    _asset.safeApprove(address(liquidationPair_), type(uint256).max);\n\n    _liquidationPair = liquidationPair_;\n\n    emit LiquidationPairSet(liquidationPair_);\n    return address(liquidationPair_);\n  }\n\n  /**\n   * @notice Set yield fee percentage.\n   * @dev Yield fee is represented in 9 decimals and can't exceed `1e9`.\n   * @param yieldFeePercentage_ Yield fee percentage\n   * @return uint256 New yield fee percentage\n   */\n  function setYieldFeePercentage(uint256 yieldFeePercentage_) external onlyOwner returns (uint256) {\n    uint256 _previousYieldFeePercentage = _yieldFeePercentage;\n    _setYieldFeePercentage(yieldFeePercentage_);\n\n    emit YieldFeePercentageSet(_previousYieldFeePercentage, yieldFeePercentage_);\n    return yieldFeePercentage_;\n  }\n\n  /**\n   * @notice Set fee recipient.\n   * @param yieldFeeRecipient_ Address of the fee recipient\n   * @return address New fee recipient address\n   */\n  function setYieldFeeRecipient(address yieldFeeRecipient_) external onlyOwner returns (address) {\n    address _previousYieldFeeRecipient = _yieldFeeRecipient;\n    _setYieldFeeRecipient(yieldFeeRecipient_);\n\n    emit YieldFeeRecipientSet(_previousYieldFeeRecipient, yieldFeeRecipient_);\n    return yieldFeeRecipient_;\n  }\n\n  /* ============ Getter Functions ============ */\n\n  /**\n   * @notice Address of the yield fee recipient.\n   * @return address Yield fee recipient address\n   */\n\n  function yieldFeeRecipient() public view returns (address) {\n    return _yieldFeeRecipient;\n  }\n\n  /**\n   * @notice Yield fee percentage.\n   * @return uint256 Yield fee percentage\n   */\n\n  function yieldFeePercentage() public view returns (uint256) {\n    return _yieldFeePercentage;\n  }\n\n  /**\n   * @notice Get total yield fee accrued by this Vault.\n   * @dev If the vault becomes undercollateralized, this total yield fee can be used to collateralize it.\n   * @return uint256 Total accrued yield fee\n   */\n  function yieldFeeTotalSupply() public view returns (uint256) {\n    return _yieldFeeTotalSupply;\n  }\n\n  /**\n   * @notice Address of the TwabController keeping track of balances.\n   * @return address TwabController address\n   */\n  function twabController() public view returns (address) {\n    return address(_twabController);\n  }\n\n  /**\n   * @notice Address of the ERC4626 vault generating yield.\n   * @return address YieldVault address\n   */\n  function yieldVault() public view returns (address) {\n    return address(_yieldVault);\n  }\n\n  /**\n   * @notice Address of the LiquidationPair used to liquidate yield for prize token.\n   * @return address LiquidationPair address\n   */\n  function liquidationPair() public view returns (address) {\n    return address(_liquidationPair);\n  }\n\n  /**\n   * @notice Address of the PrizePool that computes prizes.\n   * @return address PrizePool address\n   */\n  function prizePool() public view returns (address) {\n    return address(_prizePool);\n  }\n\n  /**\n   * @notice Address of the claimer.\n   * @return address Claimer address\n   */\n  function claimer() public view returns (address) {\n    return _claimer;\n  }\n\n  /**\n   * @notice Gets the hooks for the given user\n   * @param _account The user to retrieve the hooks for\n   * @return VaultHooks The hooks for the given user\n   */\n  function getHooks(address _account) external view returns (VaultHooks memory) {\n    return _hooks[_account];\n  }\n\n  /* ============================================ */\n  /* ============ Internal Functions ============ */\n  /* ============================================ */\n\n  /**\n   * @notice Total amount of assets managed by this Vault.\n   * @dev The total amount of assets managed by this vault is equal to\n   *      the amount of assets managed by the YieldVault + the amount living in this vault.\n   * @return uint256 Total amount of assets\n   */\n  function _totalAssets() internal view returns (uint256) {\n    return _yieldVault.maxWithdraw(address(this)) + super.totalAssets();\n  }\n\n  /**\n   * @notice Total amount of shares minted by this Vault.\n   * @return uint256 Total amount of shares\n   */\n  function _totalSupply() internal view returns (uint256) {\n    return _twabController.totalSupply(address(this));\n  }\n\n  /**\n   * @notice Total amount of shares managed by this Vault.\n   * @dev Equal to the total amount of shares minted by this Vault\n   *      + the total amount of yield fees allocated by this Vault.\n   * @return uint256 Total amount of shares\n   */\n  function _totalShares() internal view returns (uint256) {\n    return _totalSupply() + _yieldFeeTotalSupply;\n  }\n\n  /* ============ Liquidation Functions ============ */\n\n  /**\n   * @notice Return the yield amount (available yield minus fees) that can be liquidated by minting Vault shares.\n   * @param _token Address of the token to get available balance for\n   * @return uint256 Available amount of `_token`\n   */\n  function _liquidatableBalanceOf(address _token) internal view returns (uint256) {\n    if (_token != address(this)) revert LiquidationTokenOutNotVaultShare(_token, address(this));\n\n    uint256 _availableYield = availableYieldBalance();\n\n    unchecked {\n      return _availableYield -= _availableYieldFeeBalance(_availableYield);\n    }\n  }\n\n  /**\n   * @notice Available yield fee amount.\n   * @param _availableYield Total amount of yield available\n   * @return uint256 Available yield fee balance\n   */\n  function _availableYieldFeeBalance(uint256 _availableYield) internal view returns (uint256) {\n    return (_availableYield * _yieldFeePercentage) / FEE_PRECISION;\n  }\n\n  /**\n   * @notice Increase yield fee balance accrued by `_yieldFeeRecipient`.\n   * @param _shares Amount of shares to increase yield fee balance by\n   */\n  function _increaseYieldFeeBalance(uint256 _shares) internal {\n    _yieldFeeTotalSupply += _shares;\n  }\n\n  /* ============ Conversion Functions ============ */\n\n  /**\n   * @inheritdoc ERC4626\n   * @param _assets Amount of assets to convert\n   * @param _rounding Rounding mode (i.e. down or up)\n   * @return uint256 Amount of shares for the assets\n   */\n  function _convertToShares(\n    uint256 _assets,\n    Math.Rounding _rounding\n  ) internal view virtual override returns (uint256) {\n    uint256 _exchangeRate = _currentExchangeRate();\n\n    return\n      (_assets == 0 || _exchangeRate == 0)\n        ? _assets\n        : _assets.mulDiv(_assetUnit, _exchangeRate, _rounding);\n  }\n\n  /**\n   * @inheritdoc ERC4626\n   * @param _shares Amount of shares to convert\n   * @param _rounding Rounding mode (i.e. down or up)\n   * @return uint256 Amount of assets represented by the shares\n   */\n  function _convertToAssets(\n    uint256 _shares,\n    Math.Rounding _rounding\n  ) internal view virtual override returns (uint256) {\n    return _convertToAssets(_shares, _currentExchangeRate(), _rounding);\n  }\n\n  /**\n   * @notice Convert `_shares` to `_assets`.\n   * @param _shares Amount of shares to convert\n   * @param _exchangeRate Exchange rate used to convert `_shares`\n   * @param _rounding Rounding mode (i.e. down or up)\n   * @return uint256 Amount of assets represented by the shares\n   */\n  function _convertToAssets(\n    uint256 _shares,\n    uint256 _exchangeRate,\n    Math.Rounding _rounding\n  ) internal view returns (uint256) {\n    return\n      (_shares == 0 || _exchangeRate == 0)"
    }
  ]
}