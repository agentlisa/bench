{
  "Title": "Frontrun griefing of isolated mode users",
  "Content": "##### Description\nThere is the following attack vector:\n\n- STEP 1) UserA supplies an asset that is Isolated - CRV. CRV will not automatically be used as collateral, so UserA will have to additionally call `Pool.setUserUseReserveAsCollateral()` later (STEP 3).\n\n- STEP 2) FrontrunnerB supplies a small amount on behalf of userA. The asset is not among Isolated assets - e.g., WETH. This transaction is confirmed before supplying CRV by userA. So, WETH will automatically be used as collateral. This check will return `true` for supplying WETH: https://github.com/aave-dao/aave-v3-origin/blob/ec60c001358ee6ddf316f79461d21f0a1c3ed7a5/src/core/contracts/protocol/libraries/logic/ValidationLogic.sol#L726-L741\n\n- STEP 3) UserA calls `Pool.setUserUseReserveAsCollateral()` for CRV.\nBut the call will fail and CRV will not be used as collateral as `validateUseAsCollateral()`: https://github.com/aave-dao/aave-v3-origin/blob/ec60c001358ee6ddf316f79461d21f0a1c3ed7a5/src/core/contracts/protocol/libraries/logic/SupplyLogic.sol#L271-L277\n\nAs a result, UserA will not be able to use CRV as collateral. UserA will have to manually either get rid of aWETH or disable WETH as collateral. It is easy for EOAs, and less easy for smart-contracts that may not expect such problems.\n\n##### Recommendation\n\nAlthough the attacker is not directly motivated to do this, we recommend changing the collateral configuration logic to protect against this attack vector.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/core/contracts/protocol/libraries/logic/ValidationLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.10;\n\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {Address} from '../../../dependencies/openzeppelin/contracts/Address.sol';\nimport {GPv2SafeERC20} from '../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {IReserveInterestRateStrategy} from '../../../interfaces/IReserveInterestRateStrategy.sol';\nimport {IStableDebtToken} from '../../../interfaces/IStableDebtToken.sol';\nimport {IScaledBalanceToken} from '../../../interfaces/IScaledBalanceToken.sol';\nimport {IPriceOracleGetter} from '../../../interfaces/IPriceOracleGetter.sol';\nimport {IAToken} from '../../../interfaces/IAToken.sol';\nimport {IPriceOracleSentinel} from '../../../interfaces/IPriceOracleSentinel.sol';\nimport {IPoolAddressesProvider} from '../../../interfaces/IPoolAddressesProvider.sol';\nimport {IAccessControl} from '../../../dependencies/openzeppelin/contracts/IAccessControl.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\nimport {Errors} from '../helpers/Errors.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {PercentageMath} from '../math/PercentageMath.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\nimport {GenericLogic} from './GenericLogic.sol';\nimport {SafeCast} from '../../../dependencies/openzeppelin/contracts/SafeCast.sol';\nimport {IncentivizedERC20} from '../../tokenization/base/IncentivizedERC20.sol';\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements functions to validate the different actions of the protocol\n */\nlibrary ValidationLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeCast for uint256;\n  using GPv2SafeERC20 for IERC20;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n  using Address for address;\n\n  // Factor to apply to \"only-variable-debt\" liquidity rate to get threshold for rebalancing, expressed in bps\n  // A value of 0.9e4 results in 90%\n  uint256 public constant REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 0.9e4;\n\n  // Minimum health factor allowed under any circumstance\n  // A value of 0.95e18 results in 0.95\n  uint256 public constant MINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 0.95e18;\n\n  /**\n   * @dev Minimum health factor to consider a user position healthy\n   * A value of 1e18 results in 1\n   */\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18;\n\n  /**\n   * @dev Role identifier for the role allowed to supply isolated reserves as collateral\n   */\n  bytes32 public constant ISOLATED_COLLATERAL_SUPPLIER_ROLE =\n    keccak256('ISOLATED_COLLATERAL_SUPPLIER');\n\n  /**\n   * @notice Validates a supply action.\n   * @param reserveCache The cached data of the reserve\n   * @param amount The amount to be supplied\n   */\n  function validateSupply(\n    DataTypes.ReserveCache memory reserveCache,\n    DataTypes.ReserveData storage reserve,\n    uint256 amount,\n    address onBehalfOf\n  ) internal view {\n    require(amount != 0, Errors.INVALID_AMOUNT);\n\n    (bool isActive, bool isFrozen, , , bool isPaused) = reserveCache\n      .reserveConfiguration\n      .getFlags();\n    require(isActive, Errors.RESERVE_INACTIVE);\n    require(!isPaused, Errors.RESERVE_PAUSED);\n    require(!isFrozen, Errors.RESERVE_FROZEN);\n    require(onBehalfOf != reserveCache.aTokenAddress, Errors.SUPPLY_TO_ATOKEN);\n\n    uint256 supplyCap = reserveCache.reserveConfiguration.getSupplyCap();\n    require(\n      supplyCap == 0 ||\n        ((IAToken(reserveCache.aTokenAddress).scaledTotalSupply() +\n          uint256(reserve.accruedToTreasury)).rayMul(reserveCache.nextLiquidityIndex) + amount) <=\n        supplyCap * (10 ** reserveCache.reserveConfiguration.getDecimals()),\n      Errors.SUPPLY_CAP_EXCEEDED\n    );\n  }\n\n  /**\n   * @notice Validates a withdraw action.\n   * @param reserveCache The cached data of the reserve\n   * @param amount The amount to be withdrawn\n   * @param userBalance The balance of the user\n   */\n  function validateWithdraw(\n    DataTypes.ReserveCache memory reserveCache,\n    uint256 amount,\n    uint256 userBalance\n  ) internal pure {\n    require(amount != 0, Errors.INVALID_AMOUNT);\n    require(amount <= userBalance, Errors.NOT_ENOUGH_AVAILABLE_USER_BALANCE);\n\n    (bool isActive, , , , bool isPaused) = reserveCache.reserveConfiguration.getFlags();\n    require(isActive, Errors.RESERVE_INACTIVE);\n    require(!isPaused, Errors.RESERVE_PAUSED);\n  }\n\n  struct ValidateBorrowLocalVars {\n    uint256 currentLtv;\n    uint256 collateralNeededInBaseCurrency;\n    uint256 userCollateralInBaseCurrency;\n    uint256 userDebtInBaseCurrency;\n    uint256 availableLiquidity;\n    uint256 healthFactor;\n    uint256 totalDebt;\n    uint256 totalSupplyVariableDebt;\n    uint256 reserveDecimals;\n    uint256 borrowCap;\n    uint256 amountInBaseCurrency;\n    uint256 assetUnit;\n    address eModePriceSource;\n    address siloedBorrowingAddress;\n    bool isActive;\n    bool isFrozen;\n    bool isPaused;\n    bool borrowingEnabled;\n    bool stableRateBorrowingEnabled;\n    bool siloedBorrowingEnabled;\n  }\n\n  /**\n   * @notice Validates a borrow action.\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param params Additional params needed for the validation\n   */\n  function validateBorrow(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.ValidateBorrowParams memory params\n  ) internal view {\n    require(params.amount != 0, Errors.INVALID_AMOUNT);\n\n    ValidateBorrowLocalVars memory vars;\n\n    (\n      vars.isActive,\n      vars.isFrozen,\n      vars.borrowingEnabled,\n      vars.stableRateBorrowingEnabled,\n      vars.isPaused\n    ) = params.reserveCache.reserveConfiguration.getFlags();\n\n    require(vars.isActive, Errors.RESERVE_INACTIVE);\n    require(!vars.isPaused, Errors.RESERVE_PAUSED);\n    require(!vars.isFrozen, Errors.RESERVE_FROZEN);\n    require(vars.borrowingEnabled, Errors.BORROWING_NOT_ENABLED);\n    require(\n      IERC20(params.reserveCache.aTokenAddress).totalSupply() >= params.amount,\n      Errors.INVALID_AMOUNT\n    );\n\n    require(\n      params.priceOracleSentinel == address(0) ||\n        IPriceOracleSentinel(params.priceOracleSentinel).isBorrowAllowed(),\n      Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED\n    );\n\n    //validate interest rate mode\n    require(\n      params.interestRateMode == DataTypes.InterestRateMode.VARIABLE ||\n        params.interestRateMode == DataTypes.InterestRateMode.STABLE,\n      Errors.INVALID_INTEREST_RATE_MODE_SELECTED\n    );\n\n    vars.reserveDecimals = params.reserveCache.reserveConfiguration.getDecimals();\n    vars.borrowCap = params.reserveCache.reserveConfiguration.getBorrowCap();\n    unchecked {\n      vars.assetUnit = 10 ** vars.reserveDecimals;\n    }\n\n    if (vars.borrowCap != 0) {\n      vars.totalSupplyVariableDebt = params.reserveCache.currScaledVariableDebt.rayMul(\n        params.reserveCache.nextVariableBorrowIndex\n      );\n\n      vars.totalDebt =\n        params.reserveCache.currTotalStableDebt +\n        vars.totalSupplyVariableDebt +\n        params.amount;\n\n      unchecked {\n        require(vars.totalDebt <= vars.borrowCap * vars.assetUnit, Errors.BORROW_CAP_EXCEEDED);\n      }\n    }\n\n    if (params.isolationModeActive) {\n      // check that the asset being borrowed is borrowable in isolation mode AND\n      // the total exposure is no bigger than the collateral debt ceiling\n      require(\n        params.reserveCache.reserveConfiguration.getBorrowableInIsolation(),\n        Errors.ASSET_NOT_BORROWABLE_IN_ISOLATION\n      );\n\n      require(\n        reservesData[params.isolationModeCollateralAddress].isolationModeTotalDebt +\n          (params.amount /\n            10 ** (vars.reserveDecimals - ReserveConfiguration.DEBT_CEILING_DECIMALS))\n            .toUint128() <=\n          params.isolationModeDebtCeiling,\n        Errors.DEBT_CEILING_EXCEEDED\n      );\n    }\n\n    if (params.userEModeCategory != 0) {\n      require(\n        params.reserveCache.reserveConfiguration.getEModeCategory() == params.userEModeCategory,\n        Errors.INCONSISTENT_EMODE_CATEGORY\n      );\n      vars.eModePriceSource = eModeCategories[params.userEModeCategory].priceSource;\n    }\n\n    (\n      vars.userCollateralInBaseCurrency,\n      vars.userDebtInBaseCurrency,\n      vars.currentLtv,\n      ,\n      vars.healthFactor,\n\n    ) = GenericLogic.calculateUserAccountData(\n      reservesData,\n      reservesList,\n      eModeCategories,\n      DataTypes.CalculateUserAccountDataParams({\n        userConfig: params.userConfig,\n        reservesCount: params.reservesCount,\n        user: params.userAddress,\n        oracle: params.oracle,\n        userEModeCategory: params.userEModeCategory\n      })\n    );\n\n    require(vars.userCollateralInBaseCurrency != 0, Errors.COLLATERAL_BALANCE_IS_ZERO);\n    require(vars.currentLtv != 0, Errors.LTV_VALIDATION_FAILED);\n\n    require(\n      vars.healthFactor > HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    vars.amountInBaseCurrency =\n      IPriceOracleGetter(params.oracle).getAssetPrice(\n        vars.eModePriceSource != address(0) ? vars.eModePriceSource : params.asset\n      ) *\n      params.amount;\n    unchecked {\n      vars.amountInBaseCurrency /= vars.assetUnit;\n    }\n\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n    vars.collateralNeededInBaseCurrency = (vars.userDebtInBaseCurrency + vars.amountInBaseCurrency)\n      .percentDiv(vars.currentLtv); //LTV is calculated in percentage\n\n    require(\n      vars.collateralNeededInBaseCurrency <= vars.userCollateralInBaseCurrency,\n      Errors.COLLATERAL_CANNOT_COVER_NEW_BORROW\n    );\n\n    /**\n     * Following conditions need to be met if the user is borrowing at a stable rate:\n     * 1. Reserve must be enabled for stable rate borrowing\n     * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency\n     *    they are borrowing, to prevent abuses.\n     * 3. Users will be able to borrow only a portion of the total available liquidity\n     */\n\n    if (params.interestRateMode == DataTypes.InterestRateMode.STABLE) {\n      //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\n\n      require(vars.stableRateBorrowingEnabled, Errors.STABLE_BORROWING_NOT_ENABLED);\n\n      require(\n        !params.userConfig.isUsingAsCollateral(reservesData[params.asset].id) ||\n          params.reserveCache.reserveConfiguration.getLtv() == 0 ||\n          params.amount > IERC20(params.reserveCache.aTokenAddress).balanceOf(params.userAddress),\n        Errors.COLLATERAL_SAME_AS_BORROWING_CURRENCY\n      );\n\n      vars.availableLiquidity = reservesData[params.asset].virtualUnderlyingBalance;\n\n      //calculate the max available loan size in stable rate mode as a percentage of the\n      //available liquidity\n      uint256 maxLoanSizeStable = vars.availableLiquidity.percentMul(params.maxStableLoanPercent);\n\n      require(params.amount <= maxLoanSizeStable, Errors.AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE);\n    }\n\n    if (params.userConfig.isBorrowingAny()) {\n      (vars.siloedBorrowingEnabled, vars.siloedBorrowingAddress) = params\n        .userConfig\n        .getSiloedBorrowingState(reservesData, reservesList);\n\n      if (vars.siloedBorrowingEnabled) {\n        require(vars.siloedBorrowingAddress == params.asset, Errors.SILOED_BORROWING_VIOLATION);\n      } else {\n        require(\n          !params.reserveCache.reserveConfiguration.getSiloedBorrowing(),\n          Errors.SILOED_BORROWING_VIOLATION\n        );\n      }\n    }\n  }\n\n  /**\n   * @notice Validates a repay action.\n   * @param reserveCache The cached data of the reserve\n   * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\n   * @param interestRateMode The interest rate mode of the debt being repaid\n   * @param onBehalfOf The address of the user msg.sender is repaying for\n   * @param stableDebt The borrow balance of the user\n   * @param variableDebt The borrow balance of the user\n   */\n  function validateRepay(\n    DataTypes.ReserveCache memory reserveCache,\n    uint256 amountSent,\n    DataTypes.InterestRateMode interestRateMode,\n    address onBehalfOf,\n    uint256 stableDebt,\n    uint256 variableDebt\n  ) internal view {\n    require(amountSent != 0, Errors.INVALID_AMOUNT);\n    require(\n      amountSent != type(uint256).max || msg.sender == onBehalfOf,\n      Errors.NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF\n    );\n\n    (bool isActive, , , , bool isPaused) = reserveCache.reserveConfiguration.getFlags();\n    require(isActive, Errors.RESERVE_INACTIVE);\n    require(!isPaused, Errors.RESERVE_PAUSED);\n\n    require(\n      (stableDebt != 0 && interestRateMode == DataTypes.InterestRateMode.STABLE) ||\n        (variableDebt != 0 && interestRateMode == DataTypes.InterestRateMode.VARIABLE),\n      Errors.NO_DEBT_OF_SELECTED_TYPE\n    );\n  }\n\n  /**\n   * @notice Validates a swap of borrow rate mode.\n   * @param reserve The reserve state on which the user is swapping the rate\n   * @param reserveCache The cached data of the reserve\n   * @param userConfig The user reserves configuration\n   * @param stableDebt The stable debt of the user\n   * @param variableDebt The variable debt of the user\n   * @param currentRateMode The rate mode of the debt being swapped\n   */\n  function validateSwapRateMode(\n    DataTypes.ReserveData storage reserve,\n    DataTypes.ReserveCache memory reserveCache,\n    DataTypes.UserConfigurationMap storage userConfig,\n    uint256 stableDebt,\n    uint256 variableDebt,\n    DataTypes.InterestRateMode currentRateMode\n  ) internal view {\n    (bool isActive, , , bool stableRateEnabled, bool isPaused) = reserveCache\n      .reserveConfiguration\n      .getFlags();\n    require(isActive, Errors.RESERVE_INACTIVE);\n    require(!isPaused, Errors.RESERVE_PAUSED);\n\n    if (currentRateMode == DataTypes.InterestRateMode.STABLE) {\n      require(stableDebt != 0, Errors.NO_OUTSTANDING_STABLE_DEBT);\n    } else if (currentRateMode == DataTypes.InterestRateMode.VARIABLE) {\n      require(variableDebt != 0, Errors.NO_OUTSTANDING_VARIABLE_DEBT);\n      /**\n       * user wants to swap to stable, before swapping we need to ensure that\n       * 1. stable borrow rate is enabled on the reserve\n       * 2. user is not trying to abuse the reserve by supplying\n       * more collateral than he is borrowing, artificially lowering\n       * the interest rate, borrowing at variable, and switching to stable\n       */\n      require(stableRateEnabled, Errors.STABLE_BORROWING_NOT_ENABLED);\n\n      require(\n        !userConfig.isUsingAsCollateral(reserve.id) ||\n          reserveCache.reserveConfiguration.getLtv() == 0 ||\n          stableDebt + variableDebt > IERC20(reserveCache.aTokenAddress).balanceOf(msg.sender),\n        Errors.COLLATERAL_SAME_AS_BORROWING_CURRENCY\n      );\n    } else {\n      revert(Errors.INVALID_INTEREST_RATE_MODE_SELECTED);\n    }\n  }\n\n  /**\n   * @notice Validates a stable borrow rate rebalance action.\n   * @dev Rebalancing is accepted when depositors are earning <= 90% of their earnings in pure supply/demand market (variable rate only)\n   * For this to be the case, there has to be quite large stable debt with an interest rate below the current variable rate.\n   * @param reserve The reserve state on which the user is getting rebalanced\n   * @param reserveCache The cached state of the reserve\n   * @param reserveAddress The address of the reserve\n   */\n  function validateRebalanceStableBorrowRate(\n    DataTypes.ReserveData storage reserve,\n    DataTypes.ReserveCache memory reserveCache,\n    address reserveAddress\n  ) internal view {\n    (bool isActive, , , , bool isPaused) = reserveCache.reserveConfiguration.getFlags();\n    require(isActive, Errors.RESERVE_INACTIVE);\n    require(!isPaused, Errors.RESERVE_PAUSED);\n\n    uint256 totalDebt = IERC20(reserveCache.stableDebtTokenAddress).totalSupply() +\n      IERC20(reserveCache.variableDebtTokenAddress).totalSupply();\n\n    (uint256 liquidityRateVariableDebtOnly, , ) = IReserveInterestRateStrategy(\n      reserve.interestRateStrategyAddress\n    ).calculateInterestRates(\n        DataTypes.CalculateInterestRatesParams({\n          unbacked: reserve.unbacked,\n          liquidityAdded: 0,\n          liquidityTaken: 0,\n          totalStableDebt: 0,\n          totalVariableDebt: totalDebt,\n          averageStableBorrowRate: 0,\n          reserveFactor: reserveCache.reserveFactor,\n          reserve: reserveAddress,\n          usingVirtualBalance: reserve.configuration.getIsVirtualAccActive(),\n          virtualUnderlyingBalance: reserve.virtualUnderlyingBalance\n        })\n      );\n\n    require(\n      reserveCache.currLiquidityRate <=\n        liquidityRateVariableDebtOnly.percentMul(REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD),\n      Errors.INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET\n    );\n  }\n\n  /**\n   * @notice Validates the action of setting an asset as collateral.\n   * @param reserveCache The cached data of the reserve\n   * @param userBalance The balance of the user\n   */\n  function validateSetUseReserveAsCollateral(\n    DataTypes.ReserveCache memory reserveCache,\n    uint256 userBalance\n  ) internal pure {\n    require(userBalance != 0, Errors.UNDERLYING_BALANCE_ZERO);\n\n    (bool isActive, , , , bool isPaused) = reserveCache.reserveConfiguration.getFlags();\n    require(isActive, Errors.RESERVE_INACTIVE);\n    require(!isPaused, Errors.RESERVE_PAUSED);\n  }\n\n  /**\n   * @notice Validates a flashloan action.\n   * @param reservesData The state of all the reserves\n   * @param assets The assets being flash-borrowed\n   * @param amounts The amounts for each asset being borrowed\n   */\n  function validateFlashloan(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    address[] memory assets,\n    uint256[] memory amounts\n  ) internal view {\n    require(assets.length == amounts.length, Errors.INCONSISTENT_FLASHLOAN_PARAMS);\n    for (uint256 i = 0; i < assets.length; i++) {\n      validateFlashloanSimple(reservesData[assets[i]], amounts[i]);\n    }\n  }\n\n  /**\n   * @notice Validates a flashloan action.\n   * @param reserve The state of the reserve\n   */\n  function validateFlashloanSimple(\n    DataTypes.ReserveData storage reserve,\n    uint256 amount\n  ) internal view {\n    DataTypes.ReserveConfigurationMap memory configuration = reserve.configuration;\n    require(!configuration.getPaused(), Errors.RESERVE_PAUSED);\n    require(configuration.getActive(), Errors.RESERVE_INACTIVE);\n    require(configuration.getFlashLoanEnabled(), Errors.FLASHLOAN_DISABLED);\n    require(IERC20(reserve.aTokenAddress).totalSupply() >= amount, Errors.INVALID_AMOUNT);\n  }\n\n  struct ValidateLiquidationCallLocalVars {\n    bool collateralReserveActive;\n    bool collateralReservePaused;\n    bool principalReserveActive;\n    bool principalReservePaused;\n    bool isCollateralEnabled;\n  }\n\n  /**\n   * @notice Validates the liquidation action.\n   * @param userConfig The user configuration mapping\n   * @param collateralReserve The reserve data of the collateral\n   * @param debtReserve The reserve data of the debt\n   * @param params Additional parameters needed for the validation\n   */\n  function validateLiquidationCall(\n    DataTypes.UserConfigurationMap storage userConfig,\n    DataTypes.ReserveData storage collateralReserve,\n    DataTypes.ReserveData storage debtReserve,\n    DataTypes.ValidateLiquidationCallParams memory params\n  ) internal view {\n    ValidateLiquidationCallLocalVars memory vars;\n\n    (vars.collateralReserveActive, , , , vars.collateralReservePaused) = collateralReserve\n      .configuration\n      .getFlags();\n\n    (vars.principalReserveActive, , , , vars.principalReservePaused) = params\n      .debtReserveCache\n      .reserveConfiguration\n      .getFlags();\n\n    require(vars.collateralReserveActive && vars.principalReserveActive, Errors.RESERVE_INACTIVE);\n    require(!vars.collateralReservePaused && !vars.principalReservePaused, Errors.RESERVE_PAUSED);\n\n    require(\n      params.priceOracleSentinel == address(0) ||\n        params.healthFactor < MINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD ||\n        IPriceOracleSentinel(params.priceOracleSentinel).isLiquidationAllowed(),\n      Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED\n    );\n\n    require(\n      collateralReserve.liquidationGracePeriodUntil < uint40(block.timestamp) &&\n        debtReserve.liquidationGracePeriodUntil < uint40(block.timestamp),\n      Errors.LIQUIDATION_GRACE_SENTINEL_CHECK_FAILED\n    );\n\n    require(\n      params.healthFactor < HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.HEALTH_FACTOR_NOT_BELOW_THRESHOLD\n    );\n\n    vars.isCollateralEnabled =\n      collateralReserve.configuration.getLiquidationThreshold() != 0 &&\n      userConfig.isUsingAsCollateral(collateralReserve.id);\n\n    //if collateral isn't enabled as collateral by user, it cannot be liquidated\n    require(vars.isCollateralEnabled, Errors.COLLATERAL_CANNOT_BE_LIQUIDATED);\n    require(params.totalDebt != 0, Errors.SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER);\n  }\n\n  /**\n   * @notice Validates the health factor of a user.\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param userConfig The state of the user for the specific reserve\n   * @param user The user to validate health factor of\n   * @param userEModeCategory The users active efficiency mode category\n   * @param reservesCount The number of available reserves\n   * @param oracle The price oracle\n   */\n  function validateHealthFactor(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.UserConfigurationMap memory userConfig,\n    address user,\n    uint8 userEModeCategory,\n    uint256 reservesCount,\n    address oracle\n  ) internal view returns (uint256, bool) {\n    (, , , , uint256 healthFactor, bool hasZeroLtvCollateral) = GenericLogic\n      .calculateUserAccountData(\n        reservesData,\n        reservesList,\n        eModeCategories,\n        DataTypes.CalculateUserAccountDataParams({\n          userConfig: userConfig,\n          reservesCount: reservesCount,\n          user: user,\n          oracle: oracle,\n          userEModeCategory: userEModeCategory\n        })\n      );\n\n    require(\n      healthFactor >= HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    return (healthFactor, hasZeroLtvCollateral);\n  }\n\n  /**\n   * @notice Validates the health factor of a user and the ltv of the asset being withdrawn.\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param userConfig The state of the user for the specific reserve\n   * @param asset The asset for which the ltv will be validated\n   * @param from The user from which the aTokens are being transferred\n   * @param reservesCount The number of available reserves\n   * @param oracle The price oracle\n   * @param userEModeCategory The users active efficiency mode category\n   */\n  function validateHFAndLtv(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.UserConfigurationMap memory userConfig,\n    address asset,\n    address from,\n    uint256 reservesCount,\n    address oracle,\n    uint8 userEModeCategory\n  ) internal view {\n    DataTypes.ReserveData memory reserve = reservesData[asset];\n\n    (, bool hasZeroLtvCollateral) = validateHealthFactor(\n      reservesData,\n      reservesList,\n      eModeCategories,\n      userConfig,\n      from,\n      userEModeCategory,\n      reservesCount,\n      oracle\n    );\n\n    require(\n      !hasZeroLtvCollateral || reserve.configuration.getLtv() == 0,\n      Errors.LTV_VALIDATION_FAILED\n    );\n  }\n\n  /**\n   * @notice Validates a transfer action.\n   * @param reserve The reserve object\n   */\n  function validateTransfer(DataTypes.ReserveData storage reserve) internal view {\n    require(!reserve.configuration.getPaused(), Errors.RESERVE_PAUSED);\n  }\n\n  /**\n   * @notice Validates a drop reserve action.\n   * @param reservesList The addresses of all the active reserves\n   * @param reserve The reserve object\n   * @param asset The address of the reserve's underlying asset\n   */\n  function validateDropReserve(\n    mapping(uint256 => address) storage reservesList,\n    DataTypes.ReserveData storage reserve,\n    address asset\n  ) internal view {\n    require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n    require(reserve.id != 0 || reservesList[0] == asset, Errors.ASSET_NOT_LISTED);\n    require(IERC20(reserve.stableDebtTokenAddress).totalSupply() == 0, Errors.STABLE_DEBT_NOT_ZERO);\n    require(\n      IERC20(reserve.variableDebtTokenAddress).totalSupply() == 0,\n      Errors.VARIABLE_DEBT_SUPPLY_NOT_ZERO\n    );\n    require(\n      IERC20(reserve.aTokenAddress).totalSupply() == 0 && reserve.accruedToTreasury == 0,\n      Errors.UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO\n    );\n  }\n\n  /**\n   * @notice Validates the action of setting efficiency mode.\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories a mapping storing configurations for all efficiency mode categories\n   * @param userConfig the user configuration\n   * @param reservesCount The total number of valid reserves\n   * @param categoryId The id of the category\n   */\n  function validateSetUserEMode(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.UserConfigurationMap memory userConfig,\n    uint256 reservesCount,\n    uint8 categoryId\n  ) internal view {\n    // category is invalid if the liq threshold is not set\n    require(\n      categoryId == 0 || eModeCategories[categoryId].liquidationThreshold != 0,\n      Errors.INCONSISTENT_EMODE_CATEGORY\n    );\n\n    // eMode can always be enabled if the user hasn't supplied anything\n    if (userConfig.isEmpty()) {\n      return;\n    }\n\n    // if user is trying to set another category than default we require that\n    // either the user is not borrowing, or it's borrowing assets of categoryId\n    if (categoryId != 0) {\n      unchecked {\n        for (uint256 i = 0; i < reservesCount; i++) {\n          if (userConfig.isBorrowing(i)) {\n            DataTypes.ReserveConfigurationMap memory configuration = reservesData[reservesList[i]]\n              .configuration;\n            require(\n              configuration.getEModeCategory() == categoryId,\n              Errors.INCONSISTENT_EMODE_CATEGORY\n            );\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Validates the action of activating the asset as collateral.\n   * @dev Only possible if the asset has non-zero LTV and the user is not in isolation mode\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param userConfig the user configuration\n   * @param reserveConfig The reserve configuration\n   * @return True if the asset can be activated as collateral, false otherwise\n   */\n  function validateUseAsCollateral(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    DataTypes.UserConfigurationMap storage userConfig,\n    DataTypes.ReserveConfigurationMap memory reserveConfig\n  ) internal view returns (bool) {\n    if (reserveConfig.getLtv() == 0) {\n      return false;\n    }\n    if (!userConfig.isUsingAsCollateralAny()) {\n      return true;\n    }\n    (bool isolationModeActive, , ) = userConfig.getIsolationModeState(reservesData, reservesList);\n\n    return (!isolationModeActive && reserveConfig.getDebtCeiling() == 0);\n  }\n\n  /**\n   * @notice Validates if an asset should be automatically activated as collateral in the following actions: supply,\n   * transfer, mint unbacked, and liquidate\n   * @dev This is used to ensure that isolated assets are not enabled as collateral automatically\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param userConfig the user configuration\n   * @param reserveConfig The reserve configuration\n   * @return True if the asset can be activated as collateral, false otherwise\n   */\n  function validateAutomaticUseAsCollateral(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    DataTypes.UserConfigurationMap storage userConfig,\n    DataTypes.ReserveConfigurationMap memory reserveConfig,\n    address aTokenAddress\n  ) internal view returns (bool) {\n    if (reserveConfig.getDebtCeiling() != 0) {\n      // ensures only the ISOLATED_COLLATERAL_SUPPLIER_ROLE can enable collateral as side-effect of an action\n      IPoolAddressesProvider addressesProvider = IncentivizedERC20(aTokenAddress)\n        .POOL()\n        .ADDRESSES_PROVIDER();\n      if (\n        !IAccessControl(addressesProvider.getACLManager()).hasRole(\n          ISOLATED_COLLATERAL_SUPPLIER_ROLE,\n          msg.sender\n        )\n      ) return false;\n    }\n    return validateUseAsCollateral(reservesData, reservesList, userConfig, reserveConfig);\n  }\n}"
    },
    {
      "filename": "src/core/contracts/protocol/libraries/logic/SupplyLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.10;\n\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {GPv2SafeERC20} from '../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {IAToken} from '../../../interfaces/IAToken.sol';\nimport {Errors} from '../helpers/Errors.sol';\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {PercentageMath} from '../math/PercentageMath.sol';\nimport {ValidationLogic} from './ValidationLogic.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\n\n/**\n * @title SupplyLogic library\n * @author Aave\n * @notice Implements the base logic for supply/withdraw\n */\nlibrary SupplyLogic {\n  using ReserveLogic for DataTypes.ReserveCache;\n  using ReserveLogic for DataTypes.ReserveData;\n  using GPv2SafeERC20 for IERC20;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n\n  // See `IPool` for descriptions\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @notice Implements the supply feature. Through `supply()`, users supply assets to the Aave protocol.\n   * @dev Emits the `Supply()` event.\n   * @dev In the first supply action, `ReserveUsedAsCollateralEnabled()` is emitted, if the asset can be enabled as\n   * collateral.\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n   * @param params The additional parameters needed to execute the supply function\n   */\n  function executeSupply(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    DataTypes.UserConfigurationMap storage userConfig,\n    DataTypes.ExecuteSupplyParams memory params"
    }
  ]
}