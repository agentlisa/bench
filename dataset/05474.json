{
  "Title": "[03] `getPriceAndFee()` has the issue of division precision loss issue",
  "Content": "\n[LinearBondingCurve.sol#L14-L25](https://github.com/code-423n4/2023-11-canto/blob/335930cd53cf9a137504a57f1215be52c6d67cb3/1155tech-contracts/src/bonding_curve/LinearBondingCurve.sol#L14-L25)\n\nThe problem is in the following line: \n\n```javascipt\nfee += (getFee(i) * tokenPrice) / 1e18;\n```\n\nThe division of `1e18` should be performed after the loop is completed to avoid early division rounding error. \n\nMitigation: The division of `1e19` is performed outside:\n\n```diff\n function getPriceAndFee(uint256 shareCount, uint256 amount)\n        external\n        view\n        override\n        returns (uint256 price, uint256 fee)\n    {\n        for (uint256 i = shareCount; i < shareCount + amount; i++) {\n            uint256 tokenPrice = priceIncrease * i;\n            price += tokenPrice;\n-            fee += (getFee(i) * tokenPrice) / 1e18;\n+            fee += (getFee(i) * tokenPrice);\n        }\n+            fee = fee / 1e18;\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-11-canto",
  "Code": [
    {
      "filename": "1155tech-contracts/src/bonding_curve/LinearBondingCurve.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.19;\n\nimport {IBondingCurve} from \"../../interface/IBondingCurve.sol\";\n\ncontract LinearBondingCurve is IBondingCurve {\n    // By how much the price increases per share, provided in the token decimals\n    uint256 public immutable priceIncrease;\n\n    constructor(uint256 _priceIncrease) {\n        priceIncrease = _priceIncrease;\n    }\n\n    function getPriceAndFee(uint256 shareCount, uint256 amount)\n        external\n        view\n        override\n        returns (uint256 price, uint256 fee)\n    {\n        for (uint256 i = shareCount; i < shareCount + amount; i++) {\n            uint256 tokenPrice = priceIncrease * i;\n            price += tokenPrice;\n            fee += (getFee(i) * tokenPrice) / 1e18;\n        }\n    }\n\n    function getFee(uint256 shareCount) public pure override returns (uint256) {\n        uint256 divisor;\n        if (shareCount > 1) {\n            divisor = log2(shareCount);\n        } else {\n            divisor = 1;\n        }\n        // 0.1 / log2(shareCount)\n        return 1e17 / divisor;\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    /// @notice Copied from Solady: https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(\n                r,\n                byte(\n                    and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                    0x0706060506020504060203020504030106050205030304010505030400000000\n                )\n            )\n        }\n    }\n}"
    }
  ]
}