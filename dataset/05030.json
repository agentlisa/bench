{
  "Title": "[01] No point in using regular http request over `batchhttperequest`",
  "Content": "\nhttps://github.com/code-423n4/2024-03-phala-network/blob/a01ffbe992560d8d0f17deadfb9b9a2bed38377e/phala-blockchain/crates/pink/runtime/src/capi/ecall_impl.rs#L299-L300\n\nSince the len in `batchhttprequest` is not restricted to being `> 1`, a user can just use `batchhttperequest` over the regular `httprequest` as the former is less likely to revert due to the timeout bound being longer.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-phala-network",
  "Code": [
    {
      "filename": "phala-blockchain/crates/pink/runtime/src/capi/ecall_impl.rs",
      "content": "use frame_support::{traits::Currency, weights::constants::WEIGHT_REF_TIME_PER_SECOND};\nuse log::info;\nuse pallet_contracts::{AddressGenerator, Determinism};\nuse phala_crypto::sr25519::Sr25519SecretKey;\nuse pink_capi::{\n    types::{AccountId, Balance, ExecutionMode, Hash, Weight},\n    v1::{\n        ecall::{self, ClusterSetupConfig, TransactionArguments},\n        ocall::OCalls,\n        Executing,\n    },\n};\nuse scale::Encode;\n\nuse crate::{\n    contract::check_instantiate_result,\n    runtime::{\n        on_genesis, on_idle, on_runtime_upgrade, Balances as PalletBalances,\n        Contracts as PalletContracts, Pink as PalletPink,\n    },\n    types::BlockNumber,\n};\n\nuse super::OCallImpl;\n\npub struct ECallImpl;\n\npub(crate) fn storage() -> crate::storage::ExternalStorage {\n    crate::storage::ExternalStorage::instantiate()\n}\n\n/// Set spans for blocknumber and request id\nmacro_rules! instrument_context {\n    ($context: expr) => {\n        let span = $context.req_id.map(|id| tracing::info_span!(\"prpc\", id));\n        let _enter = span.as_ref().map(|span| span.enter());\n        let span = tracing::info_span!(\"pink\", blk = $context.block_number);\n        let _enter = span.enter();\n    };\n}\n\nimpl Executing for crate::storage::ExternalStorage {\n    fn execute<T>(&self, f: impl FnOnce() -> T) -> T {\n        let context = OCallImpl.exec_context();\n        instrument_context!(&context);\n        let (rv, _effects, _) = self.execute_with(&context, f);\n        rv\n    }\n\n    fn execute_mut<T>(&mut self, f: impl FnOnce() -> T) -> T {\n        let context = OCallImpl.exec_context();\n        instrument_context!(&context);\n        let (rv, effects) = self.execute_mut(&context, f);\n        OCallImpl.emit_side_effects(effects);\n        rv\n    }\n}\n\nimpl ecall::ECalls for ECallImpl {\n    fn cluster_id(&self) -> Hash {\n        PalletPink::cluster_id()\n    }\n    fn setup(&mut self, config: ClusterSetupConfig) -> Result<(), String> {\n        on_genesis();\n        let ClusterSetupConfig {\n            cluster_id,\n            owner,\n            deposit,\n            gas_price,\n            deposit_per_item,\n            deposit_per_byte,\n            treasury_account,\n            system_code,\n        } = config;\n        PalletPink::set_cluster_id(cluster_id);\n        PalletPink::set_gas_price(gas_price);\n        PalletPink::set_deposit_per_item(deposit_per_item);\n        PalletPink::set_deposit_per_byte(deposit_per_byte);\n        PalletPink::set_treasury_account(&treasury_account);\n\n        self.deposit(owner.clone(), deposit);\n        let code_hash = self\n            .upload_code(owner.clone(), system_code, true)\n            .map_err(|err| format!(\"FailedToUploadSystemCode: {err:?}\"))?;\n        info!(\"Worker: pink system code hash {:?}\", code_hash);\n        let selector = vec![0xed, 0x4b, 0x9d, 0x1b]; // The default() constructor\n        let args = TransactionArguments {\n            origin: owner,\n            transfer: 0,\n            gas_limit: Weight::MAX,\n            gas_free: true,\n            storage_deposit_limit: None,\n            deposit: 0,\n        };\n        let result = crate::contract::instantiate(\n            code_hash,\n            selector,\n            vec![],\n            ExecutionMode::Transaction,\n            args,\n        );\n        let address = match check_instantiate_result(&result) {\n            Err(err) => {\n                info!(\"Worker: failed to deploy system contract: {:?}\", err);\n                return Err(\"FailedToDeploySystemContract\".into());\n            }\n            Ok(address) => address,\n        };\n        PalletPink::set_system_contract(&address);\n        info!(\n            \"Cluster deployed, id={:?}, system={:?}\",\n            cluster_id, address\n        );\n        Ok(())\n    }\n\n    fn deposit(&mut self, who: AccountId, value: Balance) {\n        let _ = PalletBalances::deposit_creating(&who, value);\n    }\n\n    fn set_key(&mut self, key: Sr25519SecretKey) {\n        PalletPink::set_key(key);\n    }\n\n    fn get_key(&self) -> Option<Sr25519SecretKey> {\n        PalletPink::key()\n    }\n\n    fn upload_code(\n        &mut self,\n        account: AccountId,\n        code: Vec<u8>,\n        deterministic: bool,\n    ) -> Result<Hash, String> {\n        /*\n        According to the cost estimation in ink tests: https://github.com/paritytech/substrate/pull/12993/files#diff-70e9723e9db62816e35f6f885b6770a8449c75a6c2733e9fa7a245fe52c4656cR423\n        If we set max code len to 2MB, the max memory cost for a single call stack would be calculated as:\n        cost = (MaxCodeLen * 4 + MAX_STACK_SIZE + max_heap_size) * max_call_depth\n             = (2MB * 4 + 1MB + 4MB) * 6\n             = 78MB\n        If we allow 8 concurrent calls, the total memory cost would be 78MB * 8 = 624MB.\n        */\n        let info =\n            phala_wasm_checker::wasm_info(&code).map_err(|err| format!(\"Invalid wasm: {err:?}\"))?;\n        let max_wasmi_cost = crate::runtime::MaxCodeLen::get() as usize * 4;\n        if info.estimate_wasmi_memory_cost() > max_wasmi_cost {\n            return Err(\"DecompressedCodeTooLarge\".into());\n        }\n        crate::runtime::Contracts::bare_upload_code(\n            account,\n            code,\n            None,\n            if deterministic {\n                Determinism::Enforced\n            } else {\n                Determinism::Relaxed\n            },\n        )\n        .map(|v| v.code_hash)\n        .map_err(|err| format!(\"{err:?}\"))\n    }\n\n    fn upload_sidevm_code(&mut self, account: AccountId, code: Vec<u8>) -> Result<Hash, String> {\n        PalletPink::put_sidevm_code(account, code).map_err(|err| format!(\"{err:?}\"))\n    }\n\n    fn get_sidevm_code(&self, hash: Hash) -> Option<Vec<u8>> {\n        PalletPink::sidevm_codes(hash).map(|v| v.code)\n    }\n\n    fn system_contract(&self) -> Option<AccountId> {\n        PalletPink::system_contract()\n    }\n\n    fn free_balance(&self, account: AccountId) -> Balance {\n        PalletBalances::free_balance(account)\n    }\n\n    fn total_balance(&self, account: AccountId) -> Balance {\n        PalletBalances::total_balance(&account)\n    }\n\n    fn code_hash(&self, account: AccountId) -> Option<Hash> {\n        PalletContracts::code_hash(&account)\n    }\n\n    fn contract_instantiate(\n        &mut self,\n        code_hash: Hash,\n        input_data: Vec<u8>,\n        salt: Vec<u8>,\n        mode: ExecutionMode,\n        tx_args: TransactionArguments,\n    ) -> Vec<u8> {\n        let tx_args = sanitize_args(tx_args, mode);\n        handle_deposit(&tx_args);\n        let address = PalletPink::contract_address(&tx_args.origin, &code_hash, &input_data, &salt);\n        let result = crate::contract::instantiate(code_hash, input_data, salt, mode, tx_args);\n        if !result.debug_message.is_empty() {\n            let message = String::from_utf8_lossy(&result.debug_message).into_owned();\n            OCallImpl.log_to_server(\n                address.clone(),\n                log::Level::Debug as usize as _,\n                message.clone(),\n            );\n            log::debug!(\"[{address:?}][{mode:?}] debug_message: {message:?}\");\n        }\n        match &result.result {\n            Err(err) => {\n                log::error!(\"[{address:?}][{mode:?}] instantiate error: {err:?}\");\n                OCallImpl.log_to_server(\n                    address,\n                    log::Level::Error as usize as _,\n                    format!(\"instantiate failed: {err:?}\"),\n                );\n            }\n            Ok(ret) if ret.result.did_revert() => {\n                log::error!(\"[{address:?}][{mode:?}] instantiate reverted\");\n                OCallImpl.log_to_server(\n                    address,\n                    log::Level::Error as usize as _,\n                    \"instantiate reverted\".into(),\n                );\n            }\n            Ok(_) => {\n                log::info!(\"[{address:?}][{mode:?}] instantiated\");\n                OCallImpl.log_to_server(\n                    address,\n                    log::Level::Info as usize as _,\n                    \"instantiated\".to_owned(),\n                );\n            }\n        }\n        result.encode()\n    }\n\n    fn contract_call(\n        &mut self,\n        address: AccountId,\n        input_data: Vec<u8>,\n        mode: ExecutionMode,\n        tx_args: TransactionArguments,\n    ) -> Vec<u8> {\n        let tx_args = sanitize_args(tx_args, mode);\n        handle_deposit(&tx_args);\n        let result = crate::contract::bare_call(address.clone(), input_data, mode, tx_args);\n        if !result.debug_message.is_empty() {\n            let message = String::from_utf8_lossy(&result.debug_message).into_owned();\n            OCallImpl.log_to_server(\n                address.clone(),\n                log::Level::Debug as usize as _,\n                message.clone(),\n            );\n            log::debug!(\"[{address:?}][{mode:?}] debug_message: {:?}\", message);\n        }\n        match &result.result {\n            Err(err) => {\n                log::error!(\"[{address:?}][{mode:?}] command exec error: {:?}\", err);\n                OCallImpl.log_to_server(\n                    address,\n                    log::Level::Error as usize as _,\n                    format!(\"contract call failed: {err:?}\"),\n                );\n            }\n            Ok(ret) if ret.did_revert() => {\n                log::error!(\"[{address:?}][{mode:?}] contract reverted: {:?}\", ret);\n                OCallImpl.log_to_server(\n                    address,\n                    log::Level::Error as usize as _,\n                    \"contract call reverted\".into(),\n                );\n            }\n            Ok(_) => {}\n        }\n        result.encode()\n    }\n\n    fn git_revision(&self) -> String {\n        phala_git_revision::git_revision().to_string()\n    }\n\n    fn on_genesis(&mut self) {\n        on_genesis();\n    }\n\n    fn on_runtime_upgrade(&mut self) {\n        on_runtime_upgrade();\n    }\n\n    fn on_idle(&mut self, block_number: BlockNumber) {\n        on_idle(block_number);\n    }\n}\n\n/// Clip gas limit to 0.5 second for tx, 10 seconds for query\nfn sanitize_args(mut args: TransactionArguments, mode: ExecutionMode) -> TransactionArguments {\n    const GAS_PER_SECOND: u64 = WEIGHT_REF_TIME_PER_SECOND * 5;\n    let gas_limit = match mode {\n        ExecutionMode::Transaction | ExecutionMode::Estimating => GAS_PER_SECOND / 2,\n        ExecutionMode::Query => GAS_PER_SECOND * 10,\n    };\n    args.gas_limit = args.gas_limit.min(gas_limit);\n    args\n}\n\nfn handle_deposit(args: &TransactionArguments) {\n    if args.deposit > 0 {\n        let _ = PalletBalances::deposit_creating(&args.origin, args.deposit);\n    }\n}"
    }
  ]
}