{
  "Title": "[M-19] Divergences in the Simulation of the `extcodehash` EVM Opcode",
  "Content": "\nThe divergences in the emulation of the `extcodehash` EVM opcode within zkSync Era carry several potential impacts, specially on Developers relying on zkSync Era's assurance that it emulates the `extcodehash` opcode as per EIP-1052 might encounter unexpected behavior in their smart contracts.\n\n### Proof of Concept\n\nThe `getCodeHash` function within the zkSync Era is designed to emulate the functionality of the `extcodehash` Ethereum Virtual Machine (EVM) opcode, as laid out in the Ethereum Improvement Proposal 1052 (EIP-1052). \n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/AccountCodeStorage.sol#L89>\n\nHowever, it's important to recognize that this function does not exhibit precisely identical behavior to the EVM's `extcodehash` opcode. There are specific discrepancies:\n\n1. EIP-161 defines an account as \"empty\" when it satisfies certain criteria: no code, a nonce value of zero, and a balance of zero. According to EIP-1052, the `extcodehash` of an empty account should evaluate to `bytes32(0)`. In the zkSync Era, the behavior aligns with this definition when `codeHash` is `0x00`, `getRawNonce(account)` is `0`, and `isContractConstructing(codeHash)` is `false`. If an account has nonzero balance, then based on the definition of EIP-161, it will not be considered as an empty account anymore. In this case, that account will be considered as an account with no code. So, `extcodehash` of such account will be `keccak256(\"\")` in EVM.\n\n**The issue is that, zkSync Era returns `bytes32(0)` regardless of the balance of the account. It only cares about the nonce and the code.**\n\n2. Based on EIP-1052, the `extcodehash` of an precompile contract is either `keccak256(\"\")` or `bytes32(0)`. For instance, the `extcodehash` of `address(0x02)`—representing the SHA-256 precompile contract in the EVM—should be `keccak256(\"\")` because it has no code, a nonce of zero, and a nonzero balance.\n\n**In contrast, the zkSync Era consistently returns `keccak256(\"\")` for precompile contracts, regardless of their balances. The zkSync Era's behavior is based solely on whether the address is lower/equal to `CURRENT_MAX_PRECOMPILE_ADDRESS`.**\n\nThese observed inconsistencies could potentially raise concerns for developers who rely on zkSync Era's assertion that it accurately simulates the `extcodehash` EVM opcode as dictated by the EIP-1051 specification.\n\n### Recommended Mitigation Steps\n\nThe following code is recommended to simulate the `extcodehash` EVM opcode precisely based on EIP-1052.\n\n```solidity\nfunction getCodeHash(uint256 _input) external view override returns (bytes32) {\n\n        address account = address(uint160(_input));\n        if (uint160(account) <= CURRENT_MAX_PRECOMPILE_ADDRESS && account.balance != 0) {\n            return EMPTY_STRING_KECCAK;\n        } else if (uint160(account) <= CURRENT_MAX_PRECOMPILE_ADDRESS && address(account).balance == 0) {\n            return bytes32(0);\n        }\n\n        bytes32 codeHash = getRawCodeHash(account);\n\n        if (codeHash == 0x00 && NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(account) > 0) {\n            codeHash = EMPTY_STRING_KECCAK;\n        }\n        else if (Utils.isContractConstructing(codeHash)) {\n            codeHash = EMPTY_STRING_KECCAK;\n        } else if (codeHash == 0x00 && NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(account) == 0 && address(account).balance != 0) {\n            codeHash = EMPTY_STRING_KECCAK;\n        }\n\n        return codeHash;\n    }\n```\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/AccountCodeStorage.sol#L89>\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/133#issuecomment-1794951243):**\n > The impact is medium, the probability is low. So, low severity can be fair.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/133#issuecomment-1826035774):**\n > While I agree with low impact, this seem to be an inconsistency in the implementation of the EVM, which makes the finding notable.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/133#issuecomment-1826036942):**\n > I would have a different perspective for an ERC or some implementation; however, in this case this is an opcode that behaves differently (although in a edge case). At this time, I believe Medium Severity is most appropriate as the finding demonstrates an inconsistent behaviour of the EVM with the zkSyncVM, as it breaks a coding convention that goes beyond a best-practice.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/AccountCodeStorage.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAccountCodeStorage.sol\";\nimport \"./libraries/Utils.sol\";\nimport {DEPLOYER_SYSTEM_CONTRACT, NONCE_HOLDER_SYSTEM_CONTRACT, CURRENT_MAX_PRECOMPILE_ADDRESS} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice The storage of this contract serves as a mapping for the code hashes of the 32-byte account addresses.\n * @dev Code hash is not strictly a hash, it's a structure where the first byte denotes the version of the hash,\n * the second byte denotes whether the contract is constructed, and the next two bytes denote the length in 32-byte words.\n * And then the next 28 bytes are the truncated hash.\n * @dev In this version of zkSync, the first byte of the hash MUST be 1.\n * @dev The length of each bytecode MUST be odd.  It's internal code format requirements, due to padding of SHA256 function.\n * @dev It is also assumed that all the bytecode hashes are *known*, i.e. the full bytecodes\n * were published on L1 as calldata. This contract trusts the ContractDeployer and the KnownCodesStorage\n * system contracts to enforce the invariants mentioned above.\n */\ncontract AccountCodeStorage is IAccountCodeStorage {\n    bytes32 constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n    modifier onlyDeployer() {\n        require(msg.sender == address(DEPLOYER_SYSTEM_CONTRACT), \"Callable only by the deployer system contract\");\n        _;\n    }\n\n    /// @notice Stores the bytecodeHash of constructing contract.\n    /// @param _address The address of the account to set the codehash to.\n    /// @param _hash The new bytecode hash of the constructing account.\n    /// @dev This method trusts the ContractDeployer to make sure that the bytecode is known and well-formed,\n    /// but checks whether the bytecode hash corresponds to the constructing smart contract.\n    function storeAccountConstructingCodeHash(address _address, bytes32 _hash) external override onlyDeployer {\n        // Check that code hash corresponds to the deploying smart contract\n        require(Utils.isContractConstructing(_hash), \"Code hash is not for a contract on constructor\");\n        _storeCodeHash(_address, _hash);\n    }\n\n    /// @notice Stores the bytecodeHash of constructed contract.\n    /// @param _address The address of the account to set the codehash to.\n    /// @param _hash The new bytecode hash of the constructed account.\n    /// @dev This method trusts the ContractDeployer to make sure that the bytecode is known and well-formed,\n    /// but checks whether the bytecode hash corresponds to the constructed smart contract.\n    function storeAccountConstructedCodeHash(address _address, bytes32 _hash) external override onlyDeployer {\n        // Check that code hash corresponds to the deploying smart contract\n        require(Utils.isContractConstructed(_hash), \"Code hash is not for a constructed contract\");\n        _storeCodeHash(_address, _hash);\n    }\n\n    /// @notice Marks the account bytecodeHash as constructed.\n    /// @param _address The address of the account to mark as constructed\n    function markAccountCodeHashAsConstructed(address _address) external override onlyDeployer {\n        bytes32 codeHash = getRawCodeHash(_address);\n\n        require(Utils.isContractConstructing(codeHash), \"Code hash is not for a contract on constructor\");\n\n        // Get the bytecode hash with \"isConstructor\" flag equal to false\n        bytes32 constructedBytecodeHash = Utils.constructedBytecodeHash(codeHash);\n\n        _storeCodeHash(_address, constructedBytecodeHash);\n    }\n\n    /// @dev Store the codehash of the account without any checks.\n    /// @param _address The address of the account to set the codehash to.\n    /// @param _hash The new account bytecode hash.\n    function _storeCodeHash(address _address, bytes32 _hash) internal {\n        uint256 addressAsKey = uint256(uint160(_address));\n        assembly {\n            sstore(addressAsKey, _hash)\n        }\n    }\n\n    /// @notice Get the codehash stored for an address.\n    /// @param _address The address of the account of which the codehash to return\n    /// @return codeHash The codehash stored for this account.\n    function getRawCodeHash(address _address) public view override returns (bytes32 codeHash) {\n        uint256 addressAsKey = uint256(uint160(_address));\n\n        assembly {\n            codeHash := sload(addressAsKey)\n        }\n    }\n\n    /// @notice Simulate the behavior of the `extcodehash` EVM opcode.\n    /// @param _input The 256-bit account address.\n    /// @return codeHash - hash of the bytecode according to the EIP-1052 specification.\n    function getCodeHash(uint256 _input) external view override returns (bytes32) {\n        // We consider the account bytecode hash of the last 20 bytes of the input, because\n        // according to the spec \"If EXTCODEHASH of A is X, then EXTCODEHASH of A + 2**160 is X\".\n        address account = address(uint160(_input));\n        if (uint160(account) <= CURRENT_MAX_PRECOMPILE_ADDRESS) {\n            return EMPTY_STRING_KECCAK;\n        }\n\n        bytes32 codeHash = getRawCodeHash(account);\n\n        // The code hash is equal to the `keccak256(\"\")` if the account is an EOA with at least one transaction.\n        // Otherwise, the account is either deployed smart contract or an empty account,\n        // for both cases the code hash is equal to the raw code hash.\n        if (codeHash == 0x00 && NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(account) > 0) {\n            codeHash = EMPTY_STRING_KECCAK;\n        }\n        // The contract is still on the constructor, which means it is not deployed yet,\n        // so set `keccak256(\"\")` as a code hash. The EVM has the same behavior.\n        else if (Utils.isContractConstructing(codeHash)) {\n            codeHash = EMPTY_STRING_KECCAK;\n        }\n\n        return codeHash;\n    }\n\n    /// @notice Simulate the behavior of the `extcodesize` EVM opcode.\n    /// @param _input The 256-bit account address.\n    /// @return codeSize - the size of the deployed smart contract in bytes.\n    function getCodeSize(uint256 _input) external view override returns (uint256 codeSize) {\n        // We consider the account bytecode size of the last 20 bytes of the input, because\n        // according to the spec \"If EXTCODESIZE of A is X, then EXTCODESIZE of A + 2**160 is X\".\n        address account = address(uint160(_input));\n        bytes32 codeHash = getRawCodeHash(account);\n\n        // If the contract is a default account or is on constructor the code size is zero,\n        // otherwise extract the proper value for it from the bytecode hash.\n        // NOTE: zero address and precompiles are a special case, they are contracts, but we\n        // want to preserve EVM invariants (see EIP-1052 specification). That's why we automatically\n        // return `0` length in the following cases:\n        // - `codehash(0) == 0`\n        // - `account` is a precompile.\n        // - `account` is currently being constructed\n        if (\n            uint160(account) > CURRENT_MAX_PRECOMPILE_ADDRESS &&\n            codeHash != 0x00 &&\n            !Utils.isContractConstructing(codeHash)\n        ) {\n            codeSize = Utils.bytecodeLenInBytes(codeHash);\n        }\n    }\n}"
    },
    {
      "filename": "code/system-contracts/contracts/AccountCodeStorage.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAccountCodeStorage.sol\";\nimport \"./libraries/Utils.sol\";\nimport {DEPLOYER_SYSTEM_CONTRACT, NONCE_HOLDER_SYSTEM_CONTRACT, CURRENT_MAX_PRECOMPILE_ADDRESS} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice The storage of this contract serves as a mapping for the code hashes of the 32-byte account addresses.\n * @dev Code hash is not strictly a hash, it's a structure where the first byte denotes the version of the hash,\n * the second byte denotes whether the contract is constructed, and the next two bytes denote the length in 32-byte words.\n * And then the next 28 bytes are the truncated hash.\n * @dev In this version of zkSync, the first byte of the hash MUST be 1.\n * @dev The length of each bytecode MUST be odd.  It's internal code format requirements, due to padding of SHA256 function.\n * @dev It is also assumed that all the bytecode hashes are *known*, i.e. the full bytecodes\n * were published on L1 as calldata. This contract trusts the ContractDeployer and the KnownCodesStorage\n * system contracts to enforce the invariants mentioned above.\n */\ncontract AccountCodeStorage is IAccountCodeStorage {\n    bytes32 constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n    modifier onlyDeployer() {\n        require(msg.sender == address(DEPLOYER_SYSTEM_CONTRACT), \"Callable only by the deployer system contract\");\n        _;\n    }\n\n    /// @notice Stores the bytecodeHash of constructing contract.\n    /// @param _address The address of the account to set the codehash to.\n    /// @param _hash The new bytecode hash of the constructing account.\n    /// @dev This method trusts the ContractDeployer to make sure that the bytecode is known and well-formed,\n    /// but checks whether the bytecode hash corresponds to the constructing smart contract.\n    function storeAccountConstructingCodeHash(address _address, bytes32 _hash) external override onlyDeployer {\n        // Check that code hash corresponds to the deploying smart contract\n        require(Utils.isContractConstructing(_hash), \"Code hash is not for a contract on constructor\");\n        _storeCodeHash(_address, _hash);\n    }\n\n    /// @notice Stores the bytecodeHash of constructed contract.\n    /// @param _address The address of the account to set the codehash to.\n    /// @param _hash The new bytecode hash of the constructed account.\n    /// @dev This method trusts the ContractDeployer to make sure that the bytecode is known and well-formed,\n    /// but checks whether the bytecode hash corresponds to the constructed smart contract.\n    function storeAccountConstructedCodeHash(address _address, bytes32 _hash) external override onlyDeployer {\n        // Check that code hash corresponds to the deploying smart contract\n        require(Utils.isContractConstructed(_hash), \"Code hash is not for a constructed contract\");\n        _storeCodeHash(_address, _hash);\n    }\n\n    /// @notice Marks the account bytecodeHash as constructed.\n    /// @param _address The address of the account to mark as constructed\n    function markAccountCodeHashAsConstructed(address _address) external override onlyDeployer {\n        bytes32 codeHash = getRawCodeHash(_address);\n\n        require(Utils.isContractConstructing(codeHash), \"Code hash is not for a contract on constructor\");\n\n        // Get the bytecode hash with \"isConstructor\" flag equal to false\n        bytes32 constructedBytecodeHash = Utils.constructedBytecodeHash(codeHash);\n\n        _storeCodeHash(_address, constructedBytecodeHash);\n    }\n\n    /// @dev Store the codehash of the account without any checks.\n    /// @param _address The address of the account to set the codehash to.\n    /// @param _hash The new account bytecode hash.\n    function _storeCodeHash(address _address, bytes32 _hash) internal {\n        uint256 addressAsKey = uint256(uint160(_address));\n        assembly {\n            sstore(addressAsKey, _hash)\n        }\n    }\n\n    /// @notice Get the codehash stored for an address.\n    /// @param _address The address of the account of which the codehash to return\n    /// @return codeHash The codehash stored for this account.\n    function getRawCodeHash(address _address) public view override returns (bytes32 codeHash) {\n        uint256 addressAsKey = uint256(uint160(_address));\n\n        assembly {\n            codeHash := sload(addressAsKey)\n        }\n    }\n\n    /// @notice Simulate the behavior of the `extcodehash` EVM opcode.\n    /// @param _input The 256-bit account address.\n    /// @return codeHash - hash of the bytecode according to the EIP-1052 specification.\n    function getCodeHash(uint256 _input) external view override returns (bytes32) {\n        // We consider the account bytecode hash of the last 20 bytes of the input, because\n        // according to the spec \"If EXTCODEHASH of A is X, then EXTCODEHASH of A + 2**160 is X\".\n        address account = address(uint160(_input));\n        if (uint160(account) <= CURRENT_MAX_PRECOMPILE_ADDRESS) {\n            return EMPTY_STRING_KECCAK;\n        }\n\n        bytes32 codeHash = getRawCodeHash(account);\n\n        // The code hash is equal to the `keccak256(\"\")` if the account is an EOA with at least one transaction.\n        // Otherwise, the account is either deployed smart contract or an empty account,\n        // for both cases the code hash is equal to the raw code hash.\n        if (codeHash == 0x00 && NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(account) > 0) {\n            codeHash = EMPTY_STRING_KECCAK;\n        }\n        // The contract is still on the constructor, which means it is not deployed yet,\n        // so set `keccak256(\"\")` as a code hash. The EVM has the same behavior.\n        else if (Utils.isContractConstructing(codeHash)) {\n            codeHash = EMPTY_STRING_KECCAK;\n        }\n\n        return codeHash;\n    }\n\n    /// @notice Simulate the behavior of the `extcodesize` EVM opcode.\n    /// @param _input The 256-bit account address.\n    /// @return codeSize - the size of the deployed smart contract in bytes.\n    function getCodeSize(uint256 _input) external view override returns (uint256 codeSize) {\n        // We consider the account bytecode size of the last 20 bytes of the input, because\n        // according to the spec \"If EXTCODESIZE of A is X, then EXTCODESIZE of A + 2**160 is X\".\n        address account = address(uint160(_input));\n        bytes32 codeHash = getRawCodeHash(account);\n\n        // If the contract is a default account or is on constructor the code size is zero,\n        // otherwise extract the proper value for it from the bytecode hash.\n        // NOTE: zero address and precompiles are a special case, they are contracts, but we\n        // want to preserve EVM invariants (see EIP-1052 specification). That's why we automatically\n        // return `0` length in the following cases:\n        // - `codehash(0) == 0`\n        // - `account` is a precompile.\n        // - `account` is currently being constructed\n        if (\n            uint160(account) > CURRENT_MAX_PRECOMPILE_ADDRESS &&\n            codeHash != 0x00 &&\n            !Utils.isContractConstructing(codeHash)\n        ) {\n            codeSize = Utils.bytecodeLenInBytes(codeHash);\n        }\n    }\n}"
    }
  ]
}