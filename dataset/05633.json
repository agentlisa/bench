{
  "Title": "[L-02] No opt-out of creating a safe without looping over nonces",
  "Content": "\nWhen creating new safes, in either subAccounts or main console accounts, a nonce is used to create the salt used by the SafeDeployer:\n\n[`SafeDeployer::_createSafe`](https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/SafeDeployer.sol#L228-L244) and [`_genNonce`](https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/SafeDeployer.sol#L253-L255):\n```solidity\n228:        uint256 nonce = _genNonce(ownersHash, _salt);\n229:        do {\n230:            try IGnosisProxyFactory(gnosisProxyFactory).createProxyWithNonce(gnosisSafeSingleton, _initializer, nonce)\n231:            returns (address _deployedSafe) {\n232:                _safe = _deployedSafe;\n233:            } catch Error(string memory reason) {\n234:                // KEK\n235:                if (keccak256(bytes(reason)) != _SAFE_CREATION_FAILURE_REASON) {\n236:                    // A safe is already deployed with the same salt, retry with bumped nonce\n237:                    revert SafeProxyCreationFailed();\n238:                }\n239:                emit SafeProxyCreationFailure(gnosisSafeSingleton, nonce, _initializer);\n240:                nonce = _genNonce(ownersHash, _salt);\n241:            } catch {\n242:                revert SafeProxyCreationFailed();\n243:            }\n244:        } while (_safe == address(0));\n\n...\n\n253:    function _genNonce(bytes32 _ownersHash, bytes32 _salt) private returns (uint256) {\n254:        return uint256(keccak256(abi.encodePacked(_ownersHash, ownerSafeCount[_ownersHash]++, _salt, VERSION)));\n255:    }\n```\n\nIf the wallet creation fails, it retries with a new nonce (and thus a new salt) until it succeeds. This opens up an unlikely, but possible, attack vector where a rich malevolent actor could front run wallet creation by creating a lot of wallets increasing the gas cost for the victim due to the iterations.\n\nThis of course costs even more gas for the attacker as they need to actually create the wallets making this attack unlikely; but it's still possible.\n\nSince the wallets created by the attacker would be identical, a front run here doesn't really do anything else than what the victim wanted; creating a wallet. Hence, the wallet created by a possible attacker would work just as well for the victim.\n\n### Recommendation\n\nConsider adding a boolean flag if the user wishes to iterate over nonces when creating a safe. That way, a user can opt-in to having the looping logic or not.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-brahma",
  "Code": [
    {
      "filename": "contracts/src/core/SafeDeployer.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\nimport {ReentrancyGuard} from \"openzeppelin-contracts/security/ReentrancyGuard.sol\";\nimport {AddressProviderService} from \"../core/AddressProviderService.sol\";\nimport {WalletRegistry} from \"../core/registries/WalletRegistry.sol\";\nimport {PolicyRegistry} from \"../core/registries/PolicyRegistry.sol\";\nimport {IGnosisProxyFactory} from \"../../interfaces/external/IGnosisProxyFactory.sol\";\nimport {IGnosisSafe} from \"../../interfaces/external/IGnosisSafe.sol\";\nimport {Types, SafeHelper} from \"../libraries/SafeHelper.sol\";\nimport {IGnosisMultiSend} from \"../../interfaces/external/IGnosisMultiSend.sol\";\n\n/**\n * @title SafeDeployer\n * @author Brahma.fi\n * @notice Deploys new brahma console accounts and sub accounts\n */\ncontract SafeDeployer is AddressProviderService, ReentrancyGuard {\n    /// @notice version of safe deployer\n    string public constant VERSION = \"1\";\n\n    /**\n     * @notice hash of safe create2 failure reason\n     * @dev keccak256(\"Create2 call failed\");\n     */\n    bytes32 internal constant _SAFE_CREATION_FAILURE_REASON =\n        0xd7c71a0bdd2eb2834ad042153c811dd478e4ee2324e3003b9522e03e7b3735dc;\n\n    event SafeProxyCreationFailure(address indexed singleton, uint256 indexed nonce, bytes initializer);\n    event ConsoleAccountDeployed(address indexed consoleAddress);\n    event SubAccountDeployed(address indexed subAccountAddress, address indexed consoleAddress);\n    event PreComputeAccount(address[] indexed owners, uint256 indexed threshold);\n\n    error InvalidCommitment();\n    error NotWallet();\n    error PreComputedAccount(address addr);\n    error SafeProxyCreationFailed();\n\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\n\n    /// @notice owners nonce\n    mapping(bytes32 ownersHash => uint256 count) public ownerSafeCount;\n\n    /**\n     * @notice Deploys a new console account with or without policy commit and registers it\n     * @dev _owners list should contain addresses in the same order to generate same console address on all chains\n     * @param _owners list of safe owners\n     * @param _threshold safe threshold\n     * @param _policyCommit commitment\n     * @param _salt salt to be used during creation of safe\n     * @return _safe deployed console account address\n     */\n    function deployConsoleAccount(address[] calldata _owners, uint256 _threshold, bytes32 _policyCommit, bytes32 _salt)\n        external\n        nonReentrant\n        returns (address _safe)\n    {\n        bool _policyHashValid = _policyCommit != bytes32(0);\n\n        _safe = _createSafe(_owners, _setupConsoleAccount(_owners, _threshold, _policyHashValid), _salt);\n\n        if (_policyHashValid) {\n            PolicyRegistry(AddressProviderService._getRegistry(_POLICY_REGISTRY_HASH)).updatePolicy(\n                _safe, _policyCommit\n            );\n        }\n        emit ConsoleAccountDeployed(_safe);\n    }\n\n    /**\n     * @notice Deploys a new sub-account with policy commit and registers it\n     * @dev ConsoleAccount is enabled as module\n     * @param _owners list of safe owners\n     * @param _threshold safe threshold\n     * @param _policyCommit commitment\n     * @param _salt salt to be used during creation of safe, to generate nonce\n     * @return _subAcc deployed sub-account address\n     */\n    function deploySubAccount(address[] calldata _owners, uint256 _threshold, bytes32 _policyCommit, bytes32 _salt)\n        external\n        nonReentrant\n        returns (address _subAcc)\n    {\n        // Policy commit is required for sub account\n        if (_policyCommit == bytes32(0)) revert InvalidCommitment();\n\n        // Check if msg.sender is a registered wallet\n        WalletRegistry _walletRegistry = WalletRegistry(AddressProviderService._getRegistry(_WALLET_REGISTRY_HASH));\n        if (!_walletRegistry.isWallet(msg.sender)) revert NotWallet();\n\n        // Deploy sub account\n        _subAcc = _createSafe(_owners, _setupSubAccount(_owners, _threshold, msg.sender), _salt);\n\n        // Register sub account to wallet\n        _walletRegistry.registerSubAccount(msg.sender, _subAcc);\n\n        // Update policy commit for sub account\n        PolicyRegistry(AddressProviderService._getRegistry(_POLICY_REGISTRY_HASH)).updatePolicy(_subAcc, _policyCommit);\n        emit SubAccountDeployed(_subAcc, msg.sender);\n    }\n\n    /**\n     * @notice Private helper function to setup Console account with setUp transactions\n     * @param _owners list of owners addresses\n     * @param _threshold safe threshold\n     */\n    function _setupConsoleAccount(address[] memory _owners, uint256 _threshold, bool _policyHashValid)\n        private\n        view\n        returns (bytes memory)\n    {\n        address fallbackHandler;\n        Types.Executable[] memory txns;\n\n        if (_policyHashValid) {\n            txns = new Types.Executable[](2);\n            fallbackHandler = AddressProviderService._getAuthorizedAddress(_CONSOLE_FALLBACK_HANDLER_HASH);\n\n            // Enable guard on console account\n            txns[1] = Types.Executable({\n                callType: Types.CallType.DELEGATECALL,\n                target: AddressProviderService._getAuthorizedAddress(_SAFE_ENABLER_HASH),\n                value: 0,\n                data: abi.encodeCall(\n                    IGnosisSafe.setGuard, (AddressProviderService._getAuthorizedAddress(_SAFE_MODERATOR_OVERRIDABLE_HASH))\n                    )\n            });\n        } else {\n            txns = new Types.Executable[](1);\n            fallbackHandler = AddressProviderService._getAuthorizedAddress(_GNOSIS_FALLBACK_HANDLER_HASH);\n        }\n\n        // Register Wallet\n        /// @dev This function is being packed as a part of multisend transaction as, safe internally performs\n        // a delegatecall during initializer to the target contract, so direct call doesnt work. Multisend is\n        // supposed to be delegatecall\n        txns[0] = Types.Executable({\n            callType: Types.CallType.CALL,\n            target: AddressProviderService._getRegistry(_WALLET_REGISTRY_HASH),\n            value: 0,\n            data: abi.encodePacked(WalletRegistry.registerWallet.selector)\n        });\n\n        return abi.encodeCall(\n            IGnosisSafe.setup,\n            (\n                _owners,\n                _threshold,\n                AddressProviderService._getAuthorizedAddress(_GNOSIS_MULTI_SEND_HASH),\n                abi.encodeCall(IGnosisMultiSend.multiSend, (SafeHelper._packMultisendTxns(txns))),\n                fallbackHandler,\n                address(0),\n                0,\n                address(0)\n            )\n        );\n    }\n\n    /**\n     * @notice Private helper function to setup subAccount safe with setUp transactions\n     * @param _owners list of owners addresses\n     * @param _threshold safe threshold\n     * @param _consoleAccount address of Console account\n     */\n    function _setupSubAccount(address[] memory _owners, uint256 _threshold, address _consoleAccount)\n        private\n        view\n        returns (bytes memory)\n    {\n        address safeEnabler = AddressProviderService._getAuthorizedAddress(_SAFE_ENABLER_HASH);\n        Types.Executable[] memory txns = new Types.Executable[](2);\n\n        // Enable Brhma Console account as module on sub Account\n        txns[0] = Types.Executable({\n            callType: Types.CallType.DELEGATECALL,\n            target: safeEnabler,\n            value: 0,\n            data: abi.encodeCall(IGnosisSafe.enableModule, (_consoleAccount))\n        });\n\n        // Enable guard on subAccount\n        txns[1] = Types.Executable({\n            callType: Types.CallType.DELEGATECALL,\n            target: safeEnabler,\n            value: 0,\n            data: abi.encodeCall(IGnosisSafe.setGuard, (AddressProviderService._getAuthorizedAddress(_SAFE_MODERATOR_HASH)))\n        });\n\n        return abi.encodeCall(\n            IGnosisSafe.setup,\n            (\n                _owners,\n                _threshold,\n                AddressProviderService._getAuthorizedAddress(_GNOSIS_MULTI_SEND_HASH),\n                abi.encodeCall(IGnosisMultiSend.multiSend, (SafeHelper._packMultisendTxns(txns))),\n                AddressProviderService._getAuthorizedAddress(_CONSOLE_FALLBACK_HANDLER_HASH),\n                address(0),\n                0,\n                address(0)\n            )\n        );\n    }\n\n    /**\n     * @notice Internal function to create a new Gnosis Safe.\n     * @dev SafeDeployer calls createProxyWithNonce to deploy a new Gnosis Safe. This also contains initializer bytes\n     *  which are used during creation to setup the safe with owners and threshold. An actor can precompute the salt\n     *  for a given set of owners and deploy the safe. We choose to not consider that safe as a valid safe and deploy a new\n     *  safe. In case the actor chooses to deploy multiple precomputed safes with bumped nonces, the transaction will run out\n     *  of gas and user can retry with a new random salt\n     *  To generate deterministic addresses for a given set of owners, the order of owner addresses and threshold should be same\n     * @param _owners list of owners addresses\n     * @param _salt salt to be used during creation of safe, to generate nonce\n     * @return _safe The address of the created Gnosis Safe.\n     */\n    function _createSafe(address[] calldata _owners, bytes memory _initializer, bytes32 _salt)\n        private\n        returns (address _safe)\n    {\n        address gnosisProxyFactory = AddressProviderService._getAuthorizedAddress(_GNOSIS_PROXY_FACTORY_HASH);\n        address gnosisSafeSingleton = AddressProviderService._getAuthorizedAddress(_GNOSIS_SINGLETON_HASH);\n        bytes32 ownersHash = keccak256(abi.encode(_owners));\n\n        // Generate nonce based on owners and user provided salt\n        uint256 nonce = _genNonce(ownersHash, _salt);\n        do {\n            try IGnosisProxyFactory(gnosisProxyFactory).createProxyWithNonce(gnosisSafeSingleton, _initializer, nonce)\n            returns (address _deployedSafe) {\n                _safe = _deployedSafe;\n            } catch Error(string memory reason) {\n                // KEK\n                if (keccak256(bytes(reason)) != _SAFE_CREATION_FAILURE_REASON) {\n                    // A safe is already deployed with the same salt, retry with bumped nonce\n                    revert SafeProxyCreationFailed();\n                }\n                emit SafeProxyCreationFailure(gnosisSafeSingleton, nonce, _initializer);\n                nonce = _genNonce(ownersHash, _salt);\n            } catch {\n                revert SafeProxyCreationFailed();\n            }\n        } while (_safe == address(0));\n    }\n\n    /**\n     * @notice Internal function to get the nonce of a user's safe deployment\n     * @param _ownersHash address of owner of the safe.\n     * @param _salt salt to be used in nonce generation\n     * @return The nonce of the user's safe deployment.\n     */\n    function _genNonce(bytes32 _ownersHash, bytes32 _salt) private returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(_ownersHash, ownerSafeCount[_ownersHash]++, _salt, VERSION)));\n    }\n}"
    }
  ]
}