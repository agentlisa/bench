{
  "Title": "[M-05] Absence of autonomous mechanism for `selling collateral assets in the external market in exchange for USDS` will cause undercollateralization during market crashes and will cause USDS to depeg",
  "Content": "\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/Upkeep.sol#L244> \n\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/stable/CollateralAndLiquidity.sol#L140>\n\n*   The stablecoin USDS retains its US dollar peg by being overcollateralized. That is true on a bull market. That is also true on a bear market if the liquidation process is faster than the falling prices of the collateral assets.\n*   However during a bear market, there is a scenario where the the price of collateral assets may tank faster than the liquidation process. In this scenario, the total value of the collateral assets of the protocol may end up being lower than the minted / circulating USDS. This will cause undercollateralization and will cause the USDS to depeg.\n*   The depegging will cause the holders of USDS to lose financially. It may cause panic and that will be an existential threat to the protocol.\n\n### Recommended Mitigation Steps\n\n*   Create a function to `sell assets and acquire USDS on external market` and just like `liquidateUser()` and `performUpkeep()`, reward the users for doing it (calling the function).\n*   If USDS is not available, buy stablecoins USDC and store it for a while to serve as an emergency collateral backing until the market goes back to normal.\n\n**[othernet-global (Salty.IO) acknowledged and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/905#issuecomment-1947988321):**\n > Note: the overcollateralized stablecoin mechanism has been removed from the DEX.\n> \n> https://github.com/othernet-global/salty-io/commit/f3ff64a21449feb60a60c0d60721cfe2c24151c1\n\n > Note: the overcollateralized stablecoin mechanism has been removed from the DEX.\n> \n> https://github.com/othernet-global/salty-io/commit/f3ff64a21449feb60a60c0d60721cfe2c24151c1\n\n**[Picodes (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/905#issuecomment-1954535517):**\n > Regrouping as duplicates of this issue reports about the fact that the swaps are not atomic so the protocol holds a temporary change risk.\n\n**[othernet-global (Salty.IO) commented](https://github.com/code-423n4/2024-01-salty-findings/issues/905#issuecomment-1960682461):**\n > The stablecoin framework: /stablecoin, /price_feed, WBTC/WETH collateral, PriceAggregator, price feeds and USDS have been removed:\n> https://github.com/othernet-global/salty-io/commit/88b7fd1f3f5e037a155424a85275efd79f3e9bf9\n\n**Status:** Mitigation confirmed. Full details in reports from [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/51), [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/71), and [t0x1c].\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/Upkeep.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/finance/VestingWallet.sol\";\nimport \"./price_feed/interfaces/IPriceAggregator.sol\";\nimport \"./stable/interfaces/IStableConfig.sol\";\nimport \"./rewards/interfaces/IEmissions.sol\";\nimport \"./pools/interfaces/IPoolsConfig.sol\";\nimport \"./interfaces/IExchangeConfig.sol\";\nimport \"./dao/interfaces/IDAOConfig.sol\";\nimport \"./pools/interfaces/IPools.sol\";\nimport \"./dao/interfaces/IDAO.sol\";\n\n\n// Performs the following upkeep for each call to performUpkeep():\n// (Uses a maximum of 2.3 million gas with 100 whitelisted pools according to UpkeepGasUsage.t.sol)\n\n// 1. Swaps tokens previously sent to the Liquidizer contract for USDS and burns specified amounts of USDS.\n\n// 2. Withdraws existing WETH arbitrage profits from the Pools contract and rewards the caller of performUpkeep() with default 5% of the withdrawn amount.\n// 3. Converts a default 5% of the remaining WETH to USDS/DAI Protocol Owned Liquidity.\n// 4. Converts a default 20% of the remaining WETH to SALT/USDS Protocol Owned Liquidity.\n// 5. Converts remaining WETH to SALT and sends it to SaltRewards.\n\n// 6. Sends SALT Emissions to the SaltRewards contract.\n// 7. Distributes SALT from SaltRewards to the stakingRewardsEmitter and liquidityRewardsEmitter.\n// 8. Distributes SALT rewards from the stakingRewardsEmitter and liquidityRewardsEmitter.\n\n// 9. Collects SALT rewards from the DAO's Protocol Owned Liquidity (SALT/USDS from formed POL), sends 10% to the initial dev team and burns a default 50% of the remaining - the rest stays in the DAO.\n// 10. Sends SALT from the DAO vesting wallet to the DAO (linear distribution over 10 years).\n// 11. Sends SALT from the team vesting wallet to the team (linear distribution over 10 years).\n\n// WETH arbitrage profits are converted directly via depositSwapWithdraw - as performUpkeep is called often and the generated arbitrage profits should be manageable compared to the size of the reserves.\n// Additionally, simulations show that the impact from sandwich attacks on swap transactions (even without specifying slippage) is limited due to the atomic arbitrage process.\n// See PoolUtils.__placeInternalSwap and Sandwich.t.sol for more details.\n\ncontract Upkeep is IUpkeep, ReentrancyGuard\n    {\n\tusing SafeERC20 for ISalt;\n\tusing SafeERC20 for IUSDS;\n\tusing SafeERC20 for IERC20;\n\n    event UpkeepError(string description, bytes error);\n\n\tIPools immutable public pools;\n\tIExchangeConfig  immutable public exchangeConfig;\n\tIPoolsConfig immutable public poolsConfig;\n\tIDAOConfig immutable public daoConfig;\n\tIStableConfig immutable public stableConfig;\n\tIPriceAggregator immutable public priceAggregator;\n\tISaltRewards immutable public saltRewards;\n\tICollateralAndLiquidity immutable public collateralAndLiquidity;\n\tIEmissions immutable public emissions;\n\tIDAO immutable public dao;\n\n\tIERC20  immutable public weth;\n\tISalt  immutable public salt;\n\tIUSDS  immutable public usds;\n\tIERC20  immutable public dai;\n\n\tuint256 public lastUpkeepTimeEmissions;\n\tuint256 public lastUpkeepTimeRewardsEmitters;\n\n\n    constructor( IPools _pools, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IDAOConfig _daoConfig, IStableConfig _stableConfig, IPriceAggregator _priceAggregator, ISaltRewards _saltRewards, ICollateralAndLiquidity _collateralAndLiquidity, IEmissions _emissions, IDAO _dao )\n\t\t{\n\t\tpools = _pools;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\tdaoConfig = _daoConfig;\n\t\tstableConfig = _stableConfig;\n\t\tpriceAggregator = _priceAggregator;\n\t\tsaltRewards = _saltRewards;\n\t\tcollateralAndLiquidity = _collateralAndLiquidity;\n\t\temissions = _emissions;\n\t\tdao = _dao;\n\n\t\t// Cached for efficiency\n\t\tweth = _exchangeConfig.weth();\n\t\tsalt = _exchangeConfig.salt();\n\t\tusds = _exchangeConfig.usds();\n\t\tdai = _exchangeConfig.dai();\n\n\t\tlastUpkeepTimeEmissions = block.timestamp;\n\t\tlastUpkeepTimeRewardsEmitters = block.timestamp;\n\n\t\t// Approve for future WETH swaps.\n\t\t// This contract only has a temporary WETH balance within the performUpkeep() function itself.\n\t\tweth.approve( address(pools), type(uint256).max );\n\t\t}\n\n\n\tmodifier onlySameContract()\n\t\t{\n    \trequire(msg.sender == address(this), \"Only callable from within the same contract\");\n    \t_;\n\t\t}\n\n\n\t// Note - while the following steps are public so that they can be wrapped in a try/catch, they are all still only callable from this same contract.\n\n\t// 1. Swap tokens previously sent to the Liquidizer contract for USDS and burn specified amounts of USDS.\n\tfunction step1() public onlySameContract\n\t\t{\n\t\tcollateralAndLiquidity.liquidizer().performUpkeep();\n\t\t}\n\n\n\t// 2. Withdraw existing WETH arbitrage profits from the Pools contract and reward the caller of performUpkeep() with default 5% of the withdrawn amount.\n\tfunction step2(address receiver) public onlySameContract\n\t\t{\n\t\tuint256 withdrawnAmount = exchangeConfig.dao().withdrawArbitrageProfits(weth);\n\t\tif ( withdrawnAmount == 0 )\n\t\t\treturn;\n\n\t\t// Default 5% of the arbitrage profits for the caller of performUpkeep()\n\t\tuint256 rewardAmount = withdrawnAmount * daoConfig.upkeepRewardPercent() / 100;\n\n\t\t// Send the reward\n\t\tweth.safeTransfer(receiver, rewardAmount);\n\t\t}\n\n\n\t// Have the DAO form the specified Protocol Owned Liquidity with the given amount of WETH\n\tfunction _formPOL( IERC20 tokenA, IERC20 tokenB, uint256 amountWETH) internal\n\t\t{\n\t\tuint256 wethAmountPerToken = amountWETH >> 1;\n\n\t\t// Swap WETH for the specified tokens\n\t\tuint256 amountA = pools.depositSwapWithdraw( weth, tokenA, wethAmountPerToken, 0, block.timestamp );\n\t\tuint256 amountB = pools.depositSwapWithdraw( weth, tokenB, wethAmountPerToken, 0, block.timestamp );\n\n\t\t// Transfer the tokens to the DAO\n\t\ttokenA.safeTransfer( address(dao), amountA );\n\t\ttokenB.safeTransfer( address(dao), amountB );\n\n\t\t// Have the DAO form POL\n\t\tdao.formPOL(tokenA, tokenB, amountA, amountB);\n\t\t}\n\n\n\t// 3. Convert a default 5% of the remaining WETH to USDS/DAI Protocol Owned Liquidity.\n\tfunction step3() public onlySameContract\n\t\t{\n\t\tuint256 wethBalance = weth.balanceOf( address(this) );\n\t\tif ( wethBalance == 0 )\n\t\t\treturn;\n\n\t\t// A default 5% of the remaining WETH will be swapped for USDS/DAI POL.\n\t\tuint256 amountOfWETH = wethBalance * stableConfig.percentArbitrageProfitsForStablePOL() / 100;\n\t\t_formPOL(usds, dai, amountOfWETH);\n\t\t}\n\n\n\t// 4. Convert a default 20% of the remaining WETH to SALT/USDS Protocol Owned Liquidity.\n\tfunction step4() public onlySameContract\n\t\t{\n\t\tuint256 wethBalance = weth.balanceOf( address(this) );\n\t\tif ( wethBalance == 0 )\n\t\t\treturn;\n\n\t\t// A default 20% of the remaining WETH will be swapped for SALT/USDS POL.\n\t\tuint256 amountOfWETH = wethBalance * daoConfig.arbitrageProfitsPercentPOL() / 100;\n\t\t_formPOL(salt, usds, amountOfWETH);\n\t\t}\n\n\n\t// 5. Convert remaining WETH to SALT and sends it to SaltRewards.\n\tfunction step5() public onlySameContract\n\t\t{\n\t\tuint256 wethBalance = weth.balanceOf( address(this) );\n\t\tif ( wethBalance == 0 )\n\t\t\treturn;\n\n\t\t// Convert remaining WETH to SALT and send it to SaltRewards\n\t\tuint256 amountSALT = pools.depositSwapWithdraw( weth, salt, wethBalance, 0, block.timestamp );\n\t\tsalt.safeTransfer(address(saltRewards), amountSALT);\n\t\t}\n\n\n\t// 6. Send SALT Emissions to the SaltRewards contract.\n\tfunction step6() public onlySameContract\n\t\t{\n\t\tuint256 timeSinceLastUpkeep = block.timestamp - lastUpkeepTimeEmissions;\n\t\temissions.performUpkeep(timeSinceLastUpkeep);\n\n\t\tlastUpkeepTimeEmissions = block.timestamp;\n\t\t}\n\n\n\t// 7. Distribute SALT from SaltRewards to the stakingRewardsEmitter and liquidityRewardsEmitter.\n\tfunction step7() public onlySameContract\n\t\t{\n\t\tuint256[] memory profitsForPools = pools.profitsForWhitelistedPools();\n\n\t\tbytes32[] memory poolIDs = poolsConfig.whitelistedPools();\n\t\tsaltRewards.performUpkeep(poolIDs, profitsForPools );\n\t\tpools.clearProfitsForPools();\n\t\t}\n\n\n\t// 8. Distribute SALT rewards from the stakingRewardsEmitter and liquidityRewardsEmitter.\n\tfunction step8() public onlySameContract\n\t\t{\n\t\tuint256 timeSinceLastUpkeep = block.timestamp - lastUpkeepTimeRewardsEmitters;\n\n\t\tsaltRewards.stakingRewardsEmitter().performUpkeep(timeSinceLastUpkeep);\n\t\tsaltRewards.liquidityRewardsEmitter().performUpkeep(timeSinceLastUpkeep);\n\n\t\tlastUpkeepTimeRewardsEmitters = block.timestamp;\n\t\t}\n\n\n\t// 9. Collect SALT rewards from the DAO's Protocol Owned Liquidity (SALT/USDS from formed POL), send 10% to the initial dev team and burn a default 50% of the remaining - the rest stays in the DAO.\n\tfunction step9() public onlySameContract\n\t\t{\n\t\tdao.processRewardsFromPOL();\n\t\t}\n\n\n\t// 10. Send SALT from the DAO vesting wallet to the DAO (linear distribution over 10 years).\n\tfunction step10() public onlySameContract\n\t\t{\n\t\tVestingWallet(payable(exchangeConfig.daoVestingWallet())).release(address(salt));\n\t\t}\n\n\n\t// 11. Sends SALT from the team vesting wallet to the team (linear distribution over 10 years).\n\tfunction step11() public onlySameContract\n\t\t{\n\t\tuint256 releaseableAmount = VestingWallet(payable(exchangeConfig.teamVestingWallet())).releasable(address(salt));\n\n\t\t// teamVestingWallet actually sends the vested SALT to this contract - which will then need to be sent to the active teamWallet\n\t\tVestingWallet(payable(exchangeConfig.teamVestingWallet())).release(address(salt));\n\n\t\tsalt.safeTransfer( exchangeConfig.managedTeamWallet().mainWallet(), releaseableAmount );\n\t\t}\n\n\n\t// Perform the various steps of performUpkeep as outlined at the top of the contract.\n\t// Each step is wrapped in a try/catch to prevent reversions from cascading through the performUpkeep.\n\tfunction performUpkeep() public nonReentrant\n\t\t{\n\t\t// Perform the multiple steps of performUpkeep()\n \t\ttry this.step1() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 1\", error); }\n\n \t\ttry this.step2(msg.sender) {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 2\", error); }\n\n \t\ttry this.step3() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 3\", error); }\n\n \t\ttry this.step4() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 4\", error); }\n\n \t\ttry this.step5() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 5\", error); }\n\n \t\ttry this.step6() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 6\", error); }\n\n \t\ttry this.step7() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 7\", error); }\n\n \t\ttry this.step8() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 8\", error); }\n\n \t\ttry this.step9() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 9\", error); }\n\n \t\ttry this.step10() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 10\", error); }\n\n \t\ttry this.step11() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 11\", error); }\n\t\t}\n\n\n\t// ==== VIEWS ====\n\t// Returns the amount of WETH that will currently be rewarded for calling performUpkeep().\n\t// Useful for potential callers to know if calling the function will be profitable in comparison to current gas costs.\n\tfunction currentRewardsForCallingPerformUpkeep() public view returns (uint256)\n\t\t{\n\t\tuint256 daoWETH = pools.depositedUserBalance( address(dao), weth );\n\n\t\treturn daoWETH * daoConfig.upkeepRewardPercent() / 100;\n\t\t}\n\t}"
    },
    {
      "filename": "src/stable/CollateralAndLiquidity.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../price_feed/interfaces/IPriceAggregator.sol\";\nimport \"./interfaces/ICollateralAndLiquidity.sol\";\nimport \"./interfaces/IStableConfig.sol\";\nimport \"./interfaces/ILiquidizer.sol\";\nimport \"../staking/Liquidity.sol\";\n\n// The deployed contract through which all liquidity on the exchange is deposited and withdrawn.\n// Also allows users to deposit WBTC/WETH liquidity as collateral for borrowing USDS stablecoin.\n\n// The default initial collateralization ratio of collateral / borrowed USDS is 200%.\n// The minimum default collateral ratio is 110%, below which positions can be liquidated by any user.\n// Users who call the liquidation function on undercollateralized positions receive a default 5% of the liquidated collateral (up to a default max value of $500).\n// Liquidated users lose their deposited WBTC/WETH collateral and keep the USDS that they borrowed.\n\ncontract CollateralAndLiquidity is Liquidity, ICollateralAndLiquidity\n    {\n    event CollateralDeposited(address indexed depositor, uint256 amountWBTC, uint256 amountWETH, uint256 liquidity);\n    event CollateralWithdrawn(address indexed withdrawer, uint256 collateralWithdrawn, uint256 reclaimedWBTC, uint256 reclaimedWETH);\n    event BorrowedUSDS(address indexed borrower, uint256 amountBorrowed);\n    event RepaidUSDS(address indexed repayer, uint256 amountRepaid);\n    event Liquidation(address indexed liquidator, address indexed liquidatee, uint256 reclaimedWBTC, uint256 reclaimedWETH, uint256 originallyBorrowedUSDS);\n\n\tusing SafeERC20 for IERC20;\n\tusing SafeERC20 for IUSDS;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IStableConfig immutable public stableConfig;\n\tIPriceAggregator immutable public priceAggregator;\n    IUSDS immutable public usds;\n\tIERC20 immutable public wbtc;\n\tIERC20 immutable public weth;\n\tILiquidizer immutable public liquidizer;\n\n\t// Cached for efficiency\n\tuint256 immutable public wbtcTenToTheDecimals;\n    uint256 immutable public wethTenToTheDecimals;\n\n   \t// Keeps track of wallets that have borrowed USDS (so that they can be checked easily for sufficient collateral ratios)\n   \tEnumerableSet.AddressSet private _walletsWithBorrowedUSDS;\n\n\t// The amount of USDS that has been borrowed by each user\n    mapping(address=>uint256) public usdsBorrowedByUsers;\n\n\n    constructor( IPools _pools, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig, IStableConfig _stableConfig, IPriceAggregator _priceAggregator, ILiquidizer _liquidizer )\n\t\tLiquidity( _pools, _exchangeConfig, _poolsConfig, _stakingConfig )\n    \t{\n\t\tpriceAggregator = _priceAggregator;\n        stableConfig = _stableConfig;\n        liquidizer = _liquidizer;\n\n\t\tusds = _exchangeConfig.usds();\n\t\twbtc = exchangeConfig.wbtc();\n\t\tweth = exchangeConfig.weth();\n\n\t\twbtcTenToTheDecimals = 10 ** IERC20Metadata(address(wbtc)).decimals();\n\t\twethTenToTheDecimals = 10 ** IERC20Metadata(address(weth)).decimals();\n    \t}\n\n\n\t// Deposit WBTC/WETH liqudity as collateral and increase the caller's collateral share for future rewards.\n\t// Requires exchange access for the sending wallet (through depositLiquidityAndIncreaseShare)\n\tfunction depositCollateralAndIncreaseShare( uint256 maxAmountWBTC, uint256 maxAmountWETH, uint256 minLiquidityReceived, uint256 deadline, bool useZapping ) external nonReentrant ensureNotExpired(deadline)  returns (uint256 addedAmountWBTC, uint256 addedAmountWETH, uint256 addedLiquidity)\n\t\t{\n\t\t// Have the user deposit the specified WBTC/WETH liquidity and increase their collateral share\n\t\t(addedAmountWBTC, addedAmountWETH, addedLiquidity) = _depositLiquidityAndIncreaseShare( wbtc, weth, maxAmountWBTC, maxAmountWETH, minLiquidityReceived, useZapping );\n\n\t\temit CollateralDeposited(msg.sender, addedAmountWBTC, addedAmountWETH, addedLiquidity);\n\t\t}\n\n\n\t// Withdraw WBTC/WETH collateral and claim any pending rewards.\n    function withdrawCollateralAndClaim( uint256 collateralToWithdraw, uint256 minReclaimedWBTC, uint256 minReclaimedWETH, uint256 deadline ) external nonReentrant ensureNotExpired(deadline) returns (uint256 reclaimedWBTC, uint256 reclaimedWETH)\n\t\t{\n\t\t// Make sure that the user has collateral and if they have borrowed USDS that collateralToWithdraw doesn't bring their collateralRatio below allowable levels.\n\t\trequire( userShareForPool( msg.sender, collateralPoolID ) > 0, \"User does not have any collateral\" );\n\t\trequire( collateralToWithdraw <= maxWithdrawableCollateral(msg.sender), \"Excessive collateralToWithdraw\" );\n\n\t\t// Withdraw the WBTC/WETH liquidity from the liquidity pool (sending the reclaimed tokens back to the user)\n\t\t(reclaimedWBTC, reclaimedWETH) = _withdrawLiquidityAndClaim( wbtc, weth, collateralToWithdraw, minReclaimedWBTC, minReclaimedWETH );\n\n\t\temit CollateralWithdrawn(msg.sender, collateralToWithdraw, reclaimedWBTC, reclaimedWETH);\n\t\t}\n\n\n\t// Borrow USDS using existing collateral, making sure that the amount being borrowed does not exceed maxBorrowable\n\t// Requires exchange access for the sending wallet\n    function borrowUSDS( uint256 amountBorrowed ) external nonReentrant\n\t\t{\n\t\trequire( exchangeConfig.walletHasAccess(msg.sender), \"Sender does not have exchange access\" );\n\t\trequire( userShareForPool( msg.sender, collateralPoolID ) > 0, \"User does not have any collateral\" );\n\t\trequire( amountBorrowed <= maxBorrowableUSDS(msg.sender), \"Excessive amountBorrowed\" );\n\n\t\t// Increase the borrowed amount for the user\n\t\tusdsBorrowedByUsers[msg.sender] += amountBorrowed;\n\n\t\t// Remember that the user has borrowed USDS (so they can later be checked for sufficient collateralization ratios and liquidated if necessary)\n\t\t_walletsWithBorrowedUSDS.add(msg.sender);\n\n\t\t// Mint USDS and send it to the user\n\t\tusds.mintTo( msg.sender, amountBorrowed );\n\n\t\temit BorrowedUSDS(msg.sender, amountBorrowed);\n\t\t}\n\n\n     // Repay borrowed USDS and adjust the user's usdsBorrowedByUser\n     function repayUSDS( uint256 amountRepaid ) external nonReentrant\n\t\t{\n\t\trequire( userShareForPool( msg.sender, collateralPoolID ) > 0, \"User does not have any collateral\" );\n\t\trequire( amountRepaid <= usdsBorrowedByUsers[msg.sender], \"Cannot repay more than the borrowed amount\" );\n\t\trequire( amountRepaid > 0, \"Cannot repay zero amount\" );\n\n\t\t// Decrease the borrowed amount for the user\n\t\tusdsBorrowedByUsers[msg.sender] -= amountRepaid;\n\n\t\t// Have the user send the USDS to the USDS contract so that it can later be burned (on USDS.performUpkeep)\n\t\tusds.safeTransferFrom(msg.sender, address(usds), amountRepaid);\n\n\t\t// Have USDS remember that the USDS should be burned\n\t\tliquidizer.incrementBurnableUSDS( amountRepaid );\n\n\t\t// Check if the user no longer has any borrowed USDS\n\t\tif ( usdsBorrowedByUsers[msg.sender] == 0 )\n\t\t\t_walletsWithBorrowedUSDS.remove(msg.sender);\n\n\t\temit RepaidUSDS(msg.sender, amountRepaid);\n\t\t}\n\n\n\t// Liquidate a position which has fallen under the minimum collateral ratio.\n\t// A default 5% of the value of the collateral is sent to the caller, with the rest being sent to the Liquidator for later conversion to USDS which is then burned.\n\tfunction liquidateUser( address wallet ) external nonReentrant\n\t\t{\n\t\trequire( wallet != msg.sender, \"Cannot liquidate self\" );\n\n\t\t// First, make sure that the user's collateral ratio is below the required level\n\t\trequire( canUserBeLiquidated(wallet), \"User cannot be liquidated\" );\n\n\t\tuint256 userCollateralAmount = userShareForPool( wallet, collateralPoolID );\n\n\t\t// Withdraw the liquidated collateral from the liquidity pool.\n\t\t// The liquidity is owned by this contract so when it is withdrawn it will be reclaimed by this contract.\n\t\t(uint256 reclaimedWBTC, uint256 reclaimedWETH) = pools.removeLiquidity(wbtc, weth, userCollateralAmount, 0, 0, totalShares[collateralPoolID] );\n\n\t\t// Decrease the user's share of collateral as it has been liquidated and they no longer have it.\n\t\t_decreaseUserShare( wallet, collateralPoolID, userCollateralAmount, true );\n\n\t\t// The caller receives a default 5% of the value of the liquidated collateral.\n\t\tuint256 rewardPercent = stableConfig.rewardPercentForCallingLiquidation();\n\n\t\tuint256 rewardedWBTC = (reclaimedWBTC * rewardPercent) / 100;\n\t\tuint256 rewardedWETH = (reclaimedWETH * rewardPercent) / 100;\n\n\t\t// Make sure the value of the rewardAmount is not excessive\n\t\tuint256 rewardValue = underlyingTokenValueInUSD( rewardedWBTC, rewardedWETH ); // in 18 decimals\n\t\tuint256 maxRewardValue = stableConfig.maxRewardValueForCallingLiquidation(); // 18 decimals\n\t\tif ( rewardValue > maxRewardValue )\n\t\t\t{\n\t\t\trewardedWBTC = (rewardedWBTC * maxRewardValue) / rewardValue;\n\t\t\trewardedWETH = (rewardedWETH * maxRewardValue) / rewardValue;\n\t\t\t}\n\n\t\t// Reward the caller\n\t\twbtc.safeTransfer( msg.sender, rewardedWBTC );\n\t\tweth.safeTransfer( msg.sender, rewardedWETH );\n\n\t\t// Send the remaining WBTC and WETH to the Liquidizer contract so that the tokens can be converted to USDS and burned (on Liquidizer.performUpkeep)\n\t\twbtc.safeTransfer( address(liquidizer), reclaimedWBTC - rewardedWBTC );\n\t\tweth.safeTransfer( address(liquidizer), reclaimedWETH - rewardedWETH );\n\n\t\t// Have the Liquidizer contract remember the amount of USDS that will need to be burned.\n\t\tuint256 originallyBorrowedUSDS = usdsBorrowedByUsers[wallet];\n\t\tliquidizer.incrementBurnableUSDS(originallyBorrowedUSDS);\n\n\t\t// Clear the borrowedUSDS for the user who was liquidated so that they can simply keep the USDS they previously borrowed.\n\t\tusdsBorrowedByUsers[wallet] = 0;\n\t\t_walletsWithBorrowedUSDS.remove(wallet);\n\n\t\temit Liquidation(msg.sender, wallet, reclaimedWBTC, reclaimedWETH, originallyBorrowedUSDS);\n\t\t}\n\n\n\t// === VIEWS ===\n\n\t// The current market value in USD for a given amount of BTC and ETH using the PriceAggregator\n\t// Returns the value with 18 decimals\n\tfunction underlyingTokenValueInUSD( uint256 amountBTC, uint256 amountETH ) public view returns (uint256)\n\t\t{\n\t\t// Prices from the price feed have 18 decimals\n\t\tuint256 btcPrice = priceAggregator.getPriceBTC();\n        uint256 ethPrice = priceAggregator.getPriceETH();\n\n\t\t// Keep the 18 decimals from the price and remove the decimals from the token balance\n\t\tuint256 btcValue = ( amountBTC * btcPrice ) / wbtcTenToTheDecimals;\n\t\tuint256 ethValue = ( amountETH * ethPrice ) / wethTenToTheDecimals;\n\n\t\treturn btcValue + ethValue;\n\t\t}\n\n\n\t// The current market value of all WBTC/WETH collateral that has been deposited\n\t// Returns the value with 18 decimals\n\tfunction totalCollateralValueInUSD() public view returns (uint256)\n\t\t{\n\t\t(uint256 reservesWBTC, uint256 reservesWETH) = pools.getPoolReserves(wbtc, weth);\n\n\t\treturn underlyingTokenValueInUSD( reservesWBTC, reservesWETH );\n\t\t}\n\n\n\t// The current market value of the user's collateral in USD\n\t// Returns the value with 18 decimals\n\tfunction userCollateralValueInUSD( address wallet ) public view returns (uint256)\n\t\t{\n\t\tuint256 userCollateralAmount = userShareForPool( wallet, collateralPoolID );\n\t\tif ( userCollateralAmount == 0 )\n\t\t\treturn 0;\n\n\t\tuint256 totalCollateralShares = totalShares[collateralPoolID];\n\n\t\t// Determine how much collateral share the user currently has\n\t\t(uint256 reservesWBTC, uint256 reservesWETH) = pools.getPoolReserves(wbtc, weth);\n\n\t\tuint256 userWBTC = (reservesWBTC * userCollateralAmount ) / totalCollateralShares;\n\t\tuint256 userWETH = (reservesWETH * userCollateralAmount ) / totalCollateralShares;\n\n\t\treturn underlyingTokenValueInUSD( userWBTC, userWETH );\n\t\t}\n\n\n\t// The maximum amount of collateral that can be withdrawn while keeping the collateral ratio above a default of 200%\n\t// Returns value with 18 decimals\n\tfunction maxWithdrawableCollateral( address wallet ) public view returns (uint256)\n\t\t{\n\t\tuint256 userCollateralAmount = userShareForPool( wallet, collateralPoolID );\n\n\t\t// If the user has no collateral then they can't withdraw any collateral\n\t\tif ( userCollateralAmount == 0 )\n\t\t\treturn 0;\n\n\t\t// When withdrawing, require that the user keep at least the inital collateral ratio (default 200%)\n\t\tuint256 requiredCollateralValueAfterWithdrawal = ( usdsBorrowedByUsers[wallet] * stableConfig.initialCollateralRatioPercent() ) / 100;\n\t\tuint256 userCollateralValue = userCollateralValueInUSD( wallet );\n\n\t\t// If the user doesn't even have the minimum amount of required collateral then return zero\n\t\tif ( userCollateralValue <= requiredCollateralValueAfterWithdrawal )\n\t\t\treturn 0;\n\n\t\t// The maximum withdrawable value in USD\n\t\tuint256 maxWithdrawableValue = userCollateralValue - requiredCollateralValueAfterWithdrawal;\n\n\t\t// Return the collateralAmount that can be withdrawn\n\t\treturn userCollateralAmount * maxWithdrawableValue / userCollateralValue;\n   \t\t}\n\n\n\t// The maximum amount of USDS that can be borrowed given the user's current collateral and existing balance of borrowedUSDS.\n\t// Max borrowable USDS defaults to 50% of collateral value.\n\t// Returns value with 18 decimals.\n\tfunction maxBorrowableUSDS( address wallet ) public view returns (uint256)\n\t\t{\n\t\t// If the user doesn't have any collateral, then they can't borrow any USDS\n\t\tif ( userShareForPool( wallet, collateralPoolID ) == 0 )\n\t\t\treturn 0;\n\n\t\t// The user's current collateral value will determine the maximum amount that can be borrowed\n\t\tuint256 userCollateralValue  = userCollateralValueInUSD( wallet );\n\n\t\tif ( userCollateralValue < stableConfig.minimumCollateralValueForBorrowing() )\n\t\t\treturn 0;\n\n\t\tuint256 maxBorrowableAmount = ( userCollateralValue * 100 ) / stableConfig.initialCollateralRatioPercent();\n\n\t\t// Already borrowing more than the max?\n\t\tif ( usdsBorrowedByUsers[wallet] >= maxBorrowableAmount )\n\t\t\treturn 0;\n\n\t\treturn maxBorrowableAmount - usdsBorrowedByUsers[wallet];\n   \t\t}\n\n\n\tfunction numberOfUsersWithBorrowedUSDS() public view returns (uint256)\n\t\t{\n\t\treturn _walletsWithBorrowedUSDS.length();\n\t\t}\n\n\n\t// Confirm that a user can be liquidated - that they have borrowed USDS and that their collateral value / borrowedUSDS ratio is less than the minimum required\n\tfunction canUserBeLiquidated( address wallet ) public view returns (bool)\n\t\t{\n\t\t// Check the current collateral ratio for the user\n\t\tuint256 usdsBorrowedAmount = usdsBorrowedByUsers[wallet];\n\t\tif ( usdsBorrowedAmount == 0 )\n\t\t\treturn false;\n\n\t\tuint256 userCollateralValue = userCollateralValueInUSD(wallet);\n\n\t\t// Make sure the user's position is under collateralized\n\t\treturn (( userCollateralValue * 100 ) / usdsBorrowedAmount) < stableConfig.minimumCollateralRatioPercent();\n\t\t}\n\n\n\tfunction findLiquidatableUsers( uint256 startIndex, uint256 endIndex ) public view returns (address[] memory)\n\t\t{\n\t\taddress[] memory liquidatableUsers = new address[](endIndex - startIndex + 1);\n\t\tuint256 count = 0;\n\n\t\t// Cache\n\t\tuint256 totalCollateralShares = totalShares[collateralPoolID];\n\t\tuint256 totalCollateralValue = totalCollateralValueInUSD();\n\n\t\tif ( totalCollateralValue != 0 )\n\t\t\tfor ( uint256 i = startIndex; i <= endIndex; i++ )\n\t\t\t\t{\n\t\t\t\taddress wallet = _walletsWithBorrowedUSDS.at(i);\n\n\t\t\t\t// Determine the minCollateralValue a user needs to have based on their borrowedUSDS\n\t\t\t\tuint256 minCollateralValue = (usdsBorrowedByUsers[wallet] * stableConfig.minimumCollateralRatioPercent()) / 100;\n\n\t\t\t\t// Determine minCollateral in terms of minCollateralValue\n\t\t\t\tuint256 minCollateral = (minCollateralValue * totalCollateralShares) / totalCollateralValue;\n\n\t\t\t\t// Make sure the user has at least minCollateral\n\t\t\t\tif ( userShareForPool( wallet, collateralPoolID ) < minCollateral )\n\t\t\t\t\tliquidatableUsers[count++] = wallet;\n\t\t\t\t}\n\n\t\t// Resize the array to match the actual number of liquidatable positions found\n\t\taddress[] memory resizedLiquidatableUsers = new address[](count);\n\t\tfor ( uint256 i = 0; i < count; i++ )\n\t\t\tresizedLiquidatableUsers[i] = liquidatableUsers[i];\n\n\t\treturn resizedLiquidatableUsers;\n\t\t}\n\n\n\tfunction findLiquidatableUsers() external view returns (address[] memory)\n\t\t{\n\t\tif ( numberOfUsersWithBorrowedUSDS() == 0 )\n\t\t\treturn new address[](0);\n\n\t\treturn findLiquidatableUsers( 0, numberOfUsersWithBorrowedUSDS() - 1 );\n\t\t}\n\t}"
    }
  ]
}