{
  "Title": "[H-10] Sellers may lose NFTs when orders are matched with `matchOrders()`",
  "Content": "_Submitted by KIntern, also found by csanuragjain, GimelSec, kenzo, and unforgiven_\n\nFunction `matchOrders` uses custom constraints to make the matching more flexible, allow seller/buyer to specify maximum/minimum number of NFTs they want to sell/buy. This function first does some checks and then execute matching.\n\nBut in [function](https://github.com/infinitydotxyz/exchange-contracts-v2/blob/c51b7e8af6f95cc0a3b5489369cbc7cee060434b/contracts/core/InfinityOrderBookComplication.sol#L192) `areNumItemsValid()`, there is a wrong checking will lead to wrong logic in `matchOrders()` function.\n\nInstead of checking if `numConstructedItems <= sell.constraints[0]` or not, function `areNumItemsValid()` check if `buy.constraints[0] <= sell.constraints[0]`. It will lead to the scenario that `numConstructedItems > sell.constraints[0]` and make the seller sell more number of nfts than he/she allow.\n\n### Proof of Concept\n\nConsider the scenario\n\n1.  Alice create a sell order to sell maximum 2 in her 3 BAYC with ids `[1, 2, 3]`\n2.  Bob create a buy order to buy mimimum any 2 BAYC with id in list `[1, 2, 3]`\n3.  Match executor call `matchOrders()` to match Alice's order and Bob's one with parameter `constructs = [1, 2, 3]`\n4.  Function `matchOrders` will transfer all NFT in `construct` list (3 NFTs `1, 2, 3`) from seller to buyer even though seller only want to sell maximum 2 NFTs.\n\nFor more information, please check this PoC.\n<https://gist.github.com/minhquanym/a95c8652de8431c5d1d24aa4076a1878>\n\n### Tools Used\n\nHardhat, Chai\n\n### Recommended Mitigation Steps\n\nReplace check `buy.constraints[0] <= sell.constraints[0]` with `numConstructedItems <= sell.constraints[0]`\n\n**[nneverlander (Infinity) confirmed](https://github.com/code-423n4/2022-06-infinity-findings/issues/164#issuecomment-1163505913)**\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/164#issuecomment-1179746706):**\n > Seller's may specify a max number of NFTs to sell, but in the scenario outlined by the warden that requirement is not enforced - leading to the sale of more NFTs than authorized.\n> \n> Accepting this as a High risk report.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-06-infinity-nft-marketplace-contest",
  "Code": [
    {
      "filename": "contracts/core/InfinityOrderBookComplication.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {OrderTypes} from '../libs/OrderTypes.sol';\nimport {IComplication} from '../interfaces/IComplication.sol';\n\n/**\n * @title InfinityOrderBookComplication\n * @author nneverlander. Twitter @nneverlander\n * @notice Complication to execute orderbook orders\n */\ncontract InfinityOrderBookComplication is IComplication, Ownable {\n  // ======================================================= EXTERNAL FUNCTIONS ==================================================\n\n  /**\n   * @notice Checks whether one to one matches can be executed\n   * @dev This function is called by the main exchange to check whether one to one matches can be executed.\n          It checks whether orders have the right constraints - i.e they have one NFT only, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param makerOrder1 first makerOrder\n   * @param makerOrder2 second makerOrder\n   * @return returns whether the order can be executed and the execution price\n   */\n  function canExecMatchOneToOne(OrderTypes.MakerOrder calldata makerOrder1, OrderTypes.MakerOrder calldata makerOrder2)\n    external\n    view\n    override\n    returns (bool, uint256)\n  {\n    bool numItemsValid = makerOrder2.constraints[0] == makerOrder1.constraints[0] &&\n      makerOrder2.constraints[0] == 1 &&\n      makerOrder2.nfts.length == 1 &&\n      makerOrder2.nfts[0].tokens.length == 1 &&\n      makerOrder1.nfts.length == 1 &&\n      makerOrder1.nfts[0].tokens.length == 1;\n    bool _isTimeValid = makerOrder2.constraints[3] <= block.timestamp &&\n      makerOrder2.constraints[4] >= block.timestamp &&\n      makerOrder1.constraints[3] <= block.timestamp &&\n      makerOrder1.constraints[4] >= block.timestamp;\n    bool _isPriceValid = false;\n    uint256 makerOrder1Price = _getCurrentPrice(makerOrder1);\n    uint256 makerOrder2Price = _getCurrentPrice(makerOrder2);\n    uint256 execPrice;\n    if (makerOrder1.isSellOrder) {\n      _isPriceValid = makerOrder2Price >= makerOrder1Price;\n      execPrice = makerOrder1Price;\n    } else {\n      _isPriceValid = makerOrder1Price >= makerOrder2Price;\n      execPrice = makerOrder2Price;\n    }\n    return (\n      numItemsValid && _isTimeValid && doItemsIntersect(makerOrder1.nfts, makerOrder2.nfts) && _isPriceValid,\n      execPrice\n    );\n  }\n\n  /**\n   * @notice Checks whether one to matches matches can be executed\n   * @dev This function is called by the main exchange to check whether one to many matches can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param makerOrder the one makerOrder\n   * @param manyMakerOrders many maker orders\n   * @return returns whether the order can be executed\n   */\n  function canExecMatchOneToMany(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external view override returns (bool) {\n    uint256 numItems;\n    bool isOrdersTimeValid = true;\n    bool itemsIntersect = true;\n    uint256 ordersLength = manyMakerOrders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      if (!isOrdersTimeValid || !itemsIntersect) {\n        return false; // short circuit\n      }\n\n      uint256 nftsLength = manyMakerOrders[i].nfts.length;\n      for (uint256 j = 0; j < nftsLength; ) {\n        numItems += manyMakerOrders[i].nfts[j].tokens.length;\n        unchecked {\n          ++j;\n        }\n      }\n\n      isOrdersTimeValid =\n        isOrdersTimeValid &&\n        manyMakerOrders[i].constraints[3] <= block.timestamp &&\n        manyMakerOrders[i].constraints[4] >= block.timestamp;\n\n      itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    bool _isTimeValid = isOrdersTimeValid &&\n      makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp;\n\n    uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);\n    uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);\n\n    bool _isPriceValid = false;\n    if (makerOrder.isSellOrder) {\n      _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;\n    } else {\n      _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;\n    }\n\n    return (numItems == makerOrder.constraints[0]) && _isTimeValid && itemsIntersect && _isPriceValid;\n  }\n\n  /**\n   * @notice Checks whether match orders with a higher order intent can be executed\n   * @dev This function is called by the main exchange to check whether one to one matches can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param sell sell order\n   * @param buy buy order\n   * @param constructedNfts - nfts constructed by the off chain matching engine\n   * @return returns whether the order can be executed and the execution price\n   */\n  function canExecMatchOrder(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts\n  ) external view override returns (bool, uint256) {\n    (bool _isPriceValid, uint256 execPrice) = isPriceValid(sell, buy);\n    return (\n      isTimeValid(sell, buy) &&\n        _isPriceValid &&\n        areNumItemsValid(sell, buy, constructedNfts) &&\n        doItemsIntersect(sell.nfts, constructedNfts) &&\n        doItemsIntersect(buy.nfts, constructedNfts) &&\n        doItemsIntersect(sell.nfts, buy.nfts),\n      execPrice\n    );\n  }\n\n  /**\n   * @notice Checks whether take orders with a higher order intent can be executed\n   * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid\n          and whether the nfts intersect\n   * @param makerOrder the maker order\n   * @param takerItems the taker items specified by the taker\n   * @return returns whether order can be executed\n   */\n  function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n    external\n    view\n    override\n    returns (bool)\n  {\n    return (makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp &&\n      areTakerNumItemsValid(makerOrder, takerItems) &&\n      doItemsIntersect(makerOrder.nfts, takerItems));\n  }\n\n  // ======================================================= PUBLIC FUNCTIONS ==================================================\n\n  /// @dev checks whether the orders are active and not expired\n  function isTimeValid(OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy)\n    public\n    view\n    returns (bool)\n  {\n    return\n      sell.constraints[3] <= block.timestamp &&\n      sell.constraints[4] >= block.timestamp &&\n      buy.constraints[3] <= block.timestamp &&\n      buy.constraints[4] >= block.timestamp;\n  }\n\n  /// @dev checks whether the price is valid; a buy order should always have a higher price than a sell order\n  function isPriceValid(OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy)\n    public\n    view\n    returns (bool, uint256)\n  {\n    (uint256 currentSellPrice, uint256 currentBuyPrice) = (_getCurrentPrice(sell), _getCurrentPrice(buy));\n    return (currentBuyPrice >= currentSellPrice, currentSellPrice);\n  }\n\n  /// @dev sanity check to make sure the constructed nfts conform to the user signed constraints\n  function areNumItemsValid(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts\n  ) public pure returns (bool) {\n    uint256 numConstructedItems = 0;\n    uint256 nftsLength = constructedNfts.length;\n    for (uint256 i = 0; i < nftsLength; ) {\n      unchecked {\n        numConstructedItems += constructedNfts[i].tokens.length;\n        ++i;\n      }\n    }\n    return numConstructedItems >= buy.constraints[0] && buy.constraints[0] <= sell.constraints[0];\n  }\n\n  /// @dev sanity check to make sure that a taker is specifying the right number of items\n  function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 numTakerItems = 0;\n    uint256 nftsLength = takerItems.length;\n    for (uint256 i = 0; i < nftsLength; ) {\n      unchecked {\n        numTakerItems += takerItems[i].tokens.length;\n        ++i;\n      }\n    }\n    return makerOrder.constraints[0] == numTakerItems;\n  }\n\n  /**\n   * @notice Checks whether nfts intersect\n   * @dev This function checks whether there are intersecting nfts between two orders\n   * @param order1Nfts nfts in the first order\n   * @param order2Nfts nfts in the second order\n   * @return returns whether items intersect\n   */\n  function doItemsIntersect(OrderTypes.OrderItem[] calldata order1Nfts, OrderTypes.OrderItem[] calldata order2Nfts)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 order1NftsLength = order1Nfts.length;\n    uint256 order2NftsLength = order2Nfts.length;\n    // case where maker/taker didn't specify any items\n    if (order1NftsLength == 0 || order2NftsLength == 0) {\n      return true;\n    }\n\n    uint256 numCollsMatched = 0;\n    // check if taker has all items in maker\n    for (uint256 i = 0; i < order2NftsLength; ) {\n      for (uint256 j = 0; j < order1NftsLength; ) {\n        if (order1Nfts[j].collection == order2Nfts[i].collection) {\n          // increment numCollsMatched\n          unchecked {\n            ++numCollsMatched;\n          }\n          // check if tokenIds intersect\n          bool tokenIdsIntersect = doTokenIdsIntersect(order1Nfts[j], order2Nfts[i]);\n          require(tokenIdsIntersect, 'tokenIds dont intersect');\n          // short circuit\n          break;\n        }\n        unchecked {\n          ++j;\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n\n    return numCollsMatched == order2NftsLength;\n  }\n\n  /**\n   * @notice Checks whether tokenIds intersect\n   * @dev This function checks whether there are intersecting tokenIds between two order items\n   * @param item1 first item\n   * @param item2 second item\n   * @return returns whether tokenIds intersect\n   */\n  function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 item1TokensLength = item1.tokens.length;\n    uint256 item2TokensLength = item2.tokens.length;\n    // case where maker/taker didn't specify any tokenIds for this collection\n    if (item1TokensLength == 0 || item2TokensLength == 0) {\n      return true;\n    }\n    uint256 numTokenIdsPerCollMatched = 0;\n    for (uint256 k = 0; k < item2TokensLength; ) {\n      for (uint256 l = 0; l < item1TokensLength; ) {\n        if (\n          item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens\n        ) {\n          // increment numTokenIdsPerCollMatched\n          unchecked {\n            ++numTokenIdsPerCollMatched;\n          }\n          // short circuit\n          break;\n        }\n        unchecked {\n          ++l;\n        }\n      }\n      unchecked {\n        ++k;\n      }\n    }\n\n    return numTokenIdsPerCollMatched == item2TokensLength;\n  }\n\n  // ======================================================= UTILS ============================================================\n\n  /// @dev returns the sum of current order prices; used in match one to many orders\n  function _sumCurrentPrices(OrderTypes.MakerOrder[] calldata orders) internal view returns (uint256) {\n    uint256 sum = 0;\n    uint256 ordersLength = orders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      sum += _getCurrentPrice(orders[i]);\n      unchecked {\n        ++i;\n      }\n    }\n    return sum;\n  }\n\n  /// @dev Gets current order price for orders that vary in price over time (dutch and reverse dutch auctions)\n  function _getCurrentPrice(OrderTypes.MakerOrder calldata order) internal view returns (uint256) {\n    (uint256 startPrice, uint256 endPrice) = (order.constraints[1], order.constraints[2]);\n    uint256 duration = order.constraints[4] - order.constraints[3];\n    uint256 priceDiff = startPrice > endPrice ? startPrice - endPrice : endPrice - startPrice;\n    if (priceDiff == 0 || duration == 0) {\n      return startPrice;\n    }\n    uint256 elapsedTime = block.timestamp - order.constraints[3];\n    uint256 PRECISION = 10**4; // precision for division; similar to bps\n    uint256 portionBps = elapsedTime > duration ? PRECISION : ((elapsedTime * PRECISION) / duration);\n    priceDiff = (priceDiff * portionBps) / PRECISION;\n    return startPrice > endPrice ? startPrice - priceDiff : startPrice + priceDiff;\n  }\n}"
    }
  ]
}