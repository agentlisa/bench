{
  "Title": "[M-02] User may lose rewards if the receipt is minted after quest end time",
  "Content": "# Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L219-L229\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L81-L87\n\n\n# Vulnerability details\n\nAfter completing a task in the context of a quest, a user receives a signed hash that needs to be redeemed on-chain for a receipt that can later be claimed for a reward.\n\nThe receipt is minted in the `mintReceipt` function present in the `QuestFactory` contract:\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L219-L229\n\n```solidity\nfunction mintReceipt(string memory questId_, bytes32 hash_, bytes memory signature_) public {\n    if (quests[questId_].numberMinted + 1 > quests[questId_].totalParticipants) revert OverMaxAllowedToMint();\n    if (quests[questId_].addressMinted[msg.sender] == true) revert AddressAlreadyMinted();\n    if (keccak256(abi.encodePacked(msg.sender, questId_)) != hash_) revert InvalidHash();\n    if (recoverSigner(hash_, signature_) != claimSignerAddress) revert AddressNotSigned();\n\n    quests[questId_].addressMinted[msg.sender] = true;\n    quests[questId_].numberMinted++;\n    emit ReceiptMinted(msg.sender, questId_);\n    rabbitholeReceiptContract.mint(msg.sender, questId_);\n}\n```\n\nThis function doesn't check if the quest has ended, and the hash doesn't contain any kind of deadline. A user may receive a signed hash and mint the receipt at any point in time. \n\nThe quest owner can withdraw remaining tokens after the quest end time using the `withdrawRemainingTokens` present in the quests contracts. This is the implementation for `Erc20Quest`:\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L81-L87\n\n```solidity\nfunction withdrawRemainingTokens(address to_) public override onlyOwner {\n    super.withdrawRemainingTokens(to_);\n\n    uint unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;\n    uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;\n    IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);\n}\n\nfunction receiptRedeemers() public view returns (uint256) {\n    return questFactoryContract.getNumberMinted(questId);\n}\n```\n\nThe function calculates how many receipts have been minted but are pending to be claimed, in order to leave the funds in the contract so the user can still claim those. However, this won't take into account receipts that are still pending to be minted.\n\n## Impact\n\nA user can mint the receipt for completing the task after the quest has ended, and in particular, if this is done after the owner of the quest has called `withdrawRemainingTokens`, then the user won't be able to claim the reward associated with that receipt.\n\nThis occurs because the user can mint the receipt after the quest end time, while the owner may have already withdrawn the remaining tokens, which only accounts for previously minted receipts.\n\nGiven this scenario, the user won't be able to claim the rewards, the contract won't have the required funds.\n\n## PoC\n\nIn the following test, Alice mints her receipt after the quest owner has called `withdrawRemainingTokens`. Her call to `quest.claim()` will be reverted due to insufficient funds in the contract.\n\n```solidity\ncontract AuditTest is Test {\n    address deployer;\n    uint256 signerPrivateKey;\n    address signer;\n    address royaltyRecipient;\n    address minter;\n    address protocolFeeRecipient;\n\n    QuestFactory factory;\n    ReceiptRenderer receiptRenderer;\n    RabbitHoleReceipt receipt;\n    TicketRenderer ticketRenderer;\n    RabbitHoleTickets tickets;\n    ERC20 token;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        signerPrivateKey = 0x123;\n        signer = vm.addr(signerPrivateKey);\n        vm.label(signer, \"signer\");\n        royaltyRecipient = makeAddr(\"royaltyRecipient\");\n        minter = makeAddr(\"minter\");\n        protocolFeeRecipient = makeAddr(\"protocolFeeRecipient\");\n\n        vm.startPrank(deployer);\n\n        // Receipt\n        receiptRenderer = new ReceiptRenderer();\n        RabbitHoleReceipt receiptImpl = new RabbitHoleReceipt();\n        receipt = RabbitHoleReceipt(\n            address(new ERC1967Proxy(address(receiptImpl), \"\"))\n        );\n        receipt.initialize(\n            address(receiptRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // factory\n        QuestFactory factoryImpl = new QuestFactory();\n        factory = QuestFactory(\n            address(new ERC1967Proxy(address(factoryImpl), \"\"))\n        );\n        factory.initialize(signer, address(receipt), protocolFeeRecipient);\n        receipt.setMinterAddress(address(factory));\n\n        // tickets\n        ticketRenderer = new TicketRenderer();\n        RabbitHoleTickets ticketsImpl = new RabbitHoleTickets();\n        tickets = RabbitHoleTickets(\n            address(new ERC1967Proxy(address(ticketsImpl), \"\"))\n        );\n        tickets.initialize(\n            address(ticketRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // ERC20 token\n        token = new ERC20(\"Mock ERC20\", \"MERC20\");\n        factory.setRewardAllowlistAddress(address(token), true);\n\n        vm.stopPrank();\n    }\n\n    function signReceipt(address account, string memory questId)\n        internal\n        view\n        returns (bytes32 hash, bytes memory signature)\n    {\n        hash = keccak256(abi.encodePacked(account, questId));\n        bytes32 message = ECDSA.toEthSignedMessageHash(hash);\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey, message);\n        signature = abi.encodePacked(r, s, v);\n    }\n\n    function test_Erc20Quest_UserCantClaimIfLateRedeem() public {\n        address alice = makeAddr(\"alice\");\n\n        uint256 startTime = block.timestamp + 1 hours;\n        uint256 endTime = startTime + 1 hours;\n        uint256 totalParticipants = 1;\n        uint256 rewardAmountOrTokenId = 1 ether;\n        string memory questId = \"a quest\";\n\n        // create, fund and start quest\n        vm.startPrank(deployer);\n\n        factory.setQuestFee(0);\n\n        Erc20Quest quest = Erc20Quest(\n            factory.createQuest(\n                address(token),\n                endTime,\n                startTime,\n                totalParticipants,\n                rewardAmountOrTokenId,\n                \"erc20\",\n                questId\n            )\n        );\n\n        uint256 rewards = totalParticipants * rewardAmountOrTokenId;\n        deal(address(token), address(quest), rewards);\n        quest.start();\n\n        vm.stopPrank();\n\n        // Alice has the signature to mint her receipt\n        (bytes32 hash, bytes memory signature) = signReceipt(alice, questId);\n\n        // simulate time elapses until the end of the quest\n        vm.warp(endTime);\n\n        vm.prank(deployer);\n        quest.withdrawRemainingTokens(deployer);\n\n        // Now Alice claims her receipt and tries to claim her reward\n        vm.startPrank(alice);\n\n        factory.mintReceipt(questId, hash, signature);\n\n        // The following will fail since there are no more rewards in the contract\n        vm.expectRevert();\n        quest.claim();\n\n        vm.stopPrank();\n    }\n}\n```\n\n## Recommendation\n\nSince tasks are verified off-chain by the indexer, given the current architecture it is not possible to determine on-chain how many tasks have been completed. In this case the recommendation is to prevent the minting of the receipt after the quest end time. This can be done in the `mintReceipt` by checking the `endTime` property which would need to be added to the `Quest` struct or by including it as a deadline in the signed hash.\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-rabbithole-quest-protocol-contest",
  "Code": [
    {
      "filename": "contracts/QuestFactory.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {Erc20Quest} from './Erc20Quest.sol';\nimport {IQuestFactory} from './interfaces/IQuestFactory.sol';\nimport {Erc1155Quest} from './Erc1155Quest.sol';\nimport {RabbitHoleReceipt} from './RabbitHoleReceipt.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\n\n/// @title QuestFactory\n/// @author RabbitHole.gg\n/// @dev This contract is used to create quests and mint receipts\ncontract QuestFactory is Initializable, OwnableUpgradeable, AccessControlUpgradeable, IQuestFactory {\n    bytes32 public constant CREATE_QUEST_ROLE = keccak256('CREATE_QUEST_ROLE');\n    // storage vars. Insert new vars at the end to keep the storage layout the same.\n    struct Quest {\n        mapping(address => bool) addressMinted;\n        address questAddress;\n        uint totalParticipants;\n        uint numberMinted;\n    }\n\n    address public claimSignerAddress;\n    address public protocolFeeRecipient;\n    mapping(string => Quest) public quests;\n    RabbitHoleReceipt public rabbitholeReceiptContract;\n    mapping(address => bool) public rewardAllowlist;\n    uint public questFee;\n    uint public questIdCount;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    function initialize(\n        address claimSignerAddress_,\n        address rabbitholeReceiptContract_,\n        address protocolFeeRecipient_\n    ) public initializer {\n        __Ownable_init();\n        __AccessControl_init();\n        grantDefaultAdminAndCreateQuestRole(msg.sender);\n        claimSignerAddress = claimSignerAddress_;\n        rabbitholeReceiptContract = RabbitHoleReceipt(rabbitholeReceiptContract_);\n        setProtocolFeeRecipient(protocolFeeRecipient_);\n        setQuestFee(2_000);\n        questIdCount = 1;\n    }\n\n    /// @dev Create either an erc20 or erc1155 quest, only accounts with the CREATE_QUEST_ROLE can create quests\n    /// @param rewardTokenAddress_ The contract address of the reward token\n    /// @param endTime_ The end time of the quest\n    /// @param startTime_ The start time of the quest\n    /// @param totalParticipants_ The total amount of participants (accounts) the quest will have\n    /// @param rewardAmountOrTokenId_ The reward amount for an erc20 quest or the token id for an erc1155 quest\n    /// @param contractType_ The type of quest, either erc20 or erc1155\n    /// @param questId_ The id of the quest\n    /// @return address the quest contract address\n    function createQuest(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountOrTokenId_,\n        string memory contractType_,\n        string memory questId_\n    ) public onlyRole(CREATE_QUEST_ROLE) returns (address) {\n        if (quests[questId_].questAddress != address(0)) revert QuestIdUsed();\n\n        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc20'))) {\n            if (rewardAllowlist[rewardTokenAddress_] == false) revert RewardNotAllowed();\n\n            Erc20Quest newQuest = new Erc20Quest(\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_,\n                questId_,\n                address(rabbitholeReceiptContract),\n                questFee,\n                protocolFeeRecipient\n            );\n\n            emit QuestCreated(\n                msg.sender,\n                address(newQuest),\n                questId_,\n                contractType_,\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_\n            );\n            quests[questId_].questAddress = address(newQuest);\n            quests[questId_].totalParticipants = totalParticipants_;\n            newQuest.transferOwnership(msg.sender);\n            ++questIdCount;\n            return address(newQuest);\n        }\n\n        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc1155'))) {\n            if (msg.sender != owner()) revert OnlyOwnerCanCreate1155Quest();\n\n            Erc1155Quest newQuest = new Erc1155Quest(\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_,\n                questId_,\n                address(rabbitholeReceiptContract)\n            );\n\n            emit QuestCreated(\n                msg.sender,\n                address(newQuest),\n                questId_,\n                contractType_,\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_\n            );\n            quests[questId_].questAddress = address(newQuest);\n            quests[questId_].totalParticipants = totalParticipants_;\n            newQuest.transferOwnership(msg.sender);\n            ++questIdCount;\n            return address(newQuest);\n        }\n\n        revert QuestTypeInvalid();\n    }\n\n    /// @dev grant the create quest role to an account\n    /// @param account_ The account to grant or revoke the create quest role to\n    /// @param canCreateQuest_ Boolean to grant or revoke the create quest role. True grants access\n    function changeCreateQuestRole(address account_, bool canCreateQuest_) public onlyOwner {\n        if (canCreateQuest_) {\n            _grantRole(CREATE_QUEST_ROLE, account_);\n        } else {\n            _revokeRole(CREATE_QUEST_ROLE, account_);\n        }\n    }\n\n    /// @dev grant the default admin role and the create quest role to the owner\n    /// @param account_ The account to grant admin and create quest roles\n    function grantDefaultAdminAndCreateQuestRole(address account_) internal {\n        _grantRole(DEFAULT_ADMIN_ROLE, account_);\n        _grantRole(CREATE_QUEST_ROLE, account_);\n    }\n\n    /// @dev set the claim signer address\n    /// @param claimSignerAddress_ The address of the claim signer\n    function setClaimSignerAddress(address claimSignerAddress_) public onlyOwner {\n        claimSignerAddress = claimSignerAddress_;\n    }\n\n    /// @dev set the protocol fee recipient\n    /// @param protocolFeeRecipient_ The address of the protocol fee recipient\n    function setProtocolFeeRecipient(address protocolFeeRecipient_) public onlyOwner {\n        if (protocolFeeRecipient_ == address(0)) revert AddressZeroNotAllowed();\n        protocolFeeRecipient = protocolFeeRecipient_;\n    }\n\n    /// @dev set the rabbithole receipt contract\n    /// @param rabbitholeReceiptContract_ The address of the rabbithole receipt contract\n    function setRabbitHoleReceiptContract(address rabbitholeReceiptContract_) public onlyOwner {\n        rabbitholeReceiptContract = RabbitHoleReceipt(rabbitholeReceiptContract_);\n    }\n\n    /// @dev set or remave a contract address to be used as a reward\n    /// @param rewardAddress_ The contract address to set\n    /// @param allowed_ Whether the contract address is allowed or not\n    function setRewardAllowlistAddress(address rewardAddress_, bool allowed_) public onlyOwner {\n        rewardAllowlist[rewardAddress_] = allowed_;\n    }\n\n    /// @dev set the quest fee\n    /// @notice the quest fee should be in Basis Point units: https://www.investopedia.com/terms/b/basispoint.asp\n    /// @param questFee_ The quest fee value\n    function setQuestFee(uint256 questFee_) public onlyOwner {\n        if (questFee_ > 10_000) revert QuestFeeTooHigh();\n        questFee = questFee_;\n    }\n\n    /// @dev return the number of minted receipts for a quest\n    /// @param questId_ The id of the quest\n    function getNumberMinted(string memory questId_) external view returns (uint) {\n        return quests[questId_].numberMinted;\n    }\n\n    /// @dev return data in the quest struct for a questId\n    /// @param questId_ The id of the quest\n    function questInfo(string memory questId_) external view returns (address, uint, uint) {\n        return (\n            quests[questId_].questAddress,\n            quests[questId_].totalParticipants,\n            quests[questId_].numberMinted\n        );\n    }\n\n    /// @dev recover the signer from a hash and signature\n    /// @param hash_ The hash of the message\n    /// @param signature_ The signature of the hash\n    function recoverSigner(bytes32 hash_, bytes memory signature_) public pure returns (address) {\n        bytes32 messageDigest = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', hash_));\n        return ECDSAUpgradeable.recover(messageDigest, signature_);\n    }\n\n    /// @dev mint a RabbitHole Receipt. Note: this contract must be set as Minter on the receipt contract\n    /// @param questId_ The id of the quest\n    /// @param hash_ The hash of the message\n    /// @param signature_ The signature of the hash\n    function mintReceipt(string memory questId_, bytes32 hash_, bytes memory signature_) public {\n        if (quests[questId_].numberMinted + 1 > quests[questId_].totalParticipants) revert OverMaxAllowedToMint();\n        if (quests[questId_].addressMinted[msg.sender] == true) revert AddressAlreadyMinted();\n        if (keccak256(abi.encodePacked(msg.sender, questId_)) != hash_) revert InvalidHash();\n        if (recoverSigner(hash_, signature_) != claimSignerAddress) revert AddressNotSigned();\n\n        quests[questId_].addressMinted[msg.sender] = true;\n        quests[questId_].numberMinted++;\n        emit ReceiptMinted(msg.sender, questId_);\n        rabbitholeReceiptContract.mint(msg.sender, questId_);\n    }\n}"
    },
    {
      "filename": "contracts/Erc20Quest.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {IERC20, SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {Quest} from './Quest.sol';\nimport {QuestFactory} from './QuestFactory.sol';\n\n/// @title Erc20Quest\n/// @author RabbitHole.gg\n/// @notice This contract is used to create a quest that rewards ERC20 tokens.\ncontract Erc20Quest is Quest {\n    using SafeERC20 for IERC20;\n    uint256 public immutable questFee;\n    address public immutable protocolFeeRecipient;\n    QuestFactory public immutable questFactoryContract;\n\n    constructor(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountInWeiOrTokenId_,\n        string memory questId_,\n        address receiptContractAddress_,\n        uint256 questFee_,\n        address protocolFeeRecipient_\n    )\n        Quest(\n            rewardTokenAddress_,\n            endTime_,\n            startTime_,\n            totalParticipants_,\n            rewardAmountInWeiOrTokenId_,\n            questId_,\n            receiptContractAddress_\n        )\n    {\n        questFee = questFee_;\n        protocolFeeRecipient = protocolFeeRecipient_;\n        questFactoryContract = QuestFactory(msg.sender);\n    }\n\n    /// @dev Function that gets the maximum amount of rewards that can be claimed by all users. It does not include the protocol fee\n    /// @return The maximum amount of rewards that can be claimed by all users\n    function maxTotalRewards() public view returns (uint256) {\n        return totalParticipants * rewardAmountInWeiOrTokenId;\n    }\n\n    /// @notice Function that gets the maximum amount of rewards that can be claimed by the protocol or the quest deployer\n    /// @dev The 10_000 comes from Basis Points: https://www.investopedia.com/terms/b/basispoint.asp\n    /// @return The maximum amount of rewards that can be claimed by the protocol or the quest deployer\n    function maxProtocolReward() public view returns (uint256) {\n        return (maxTotalRewards() * questFee) / 10_000;\n    }\n\n    /// @notice Starts the quest by marking it ready to start at the contract level. Marking a quest ready to start does not mean that it is live. It also requires that the start time has passed\n    /// @dev Requires that the balance of the rewards in the contract is greater than or equal to the maximum amount of rewards that can be claimed by all users and the protocol\n    function start() public override {\n        if (IERC20(rewardToken).balanceOf(address(this)) < maxTotalRewards() + maxProtocolReward())\n            revert TotalAmountExceedsBalance();\n        super.start();\n    }\n\n    /// @notice Internal function that transfers the rewards to the msg.sender\n    /// @param amount_ The amount of rewards to transfer\n    function _transferRewards(uint256 amount_) internal override {\n        IERC20(rewardToken).safeTransfer(msg.sender, amount_);\n    }\n\n    /// @notice Internal function that calculates the reward amount\n    /// @dev It is possible for users to have multiple receipts (if they buy others on secondary markets)\n    /// @param redeemableTokenCount_ The amount of tokens that can be redeemed\n    /// @return The total amount of rewards that can be claimed by a user\n    function _calculateRewards(uint256 redeemableTokenCount_) internal view override returns (uint256) {\n        return redeemableTokenCount_ * rewardAmountInWeiOrTokenId;\n    }\n\n    /// @notice Function that allows the owner to withdraw the remaining tokens in the contract\n    /// @dev Every receipt minted should still be able to claim rewards (and cannot be withdrawn). This function can only be called after the quest end time\n    /// @param to_ The address to send the remaining tokens to\n    function withdrawRemainingTokens(address to_) public override onlyOwner {\n        super.withdrawRemainingTokens(to_);\n\n        uint unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;\n        uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;\n        IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);\n    }\n\n    /// @notice Call the QuestFactory contract to get the amount of receipts that have been minted\n    /// @return The amount of receipts that have been minted for the given quest\n    function receiptRedeemers() public view returns (uint256) {\n        return questFactoryContract.getNumberMinted(questId);\n    }\n\n    /// @notice Function that calculates the protocol fee\n    function protocolFee() public view returns (uint256) {\n        return (receiptRedeemers() * rewardAmountInWeiOrTokenId * questFee) / 10_000;\n    }\n\n    /// @notice Sends the protocol fee to the protocolFeeRecipient\n    /// @dev Only callable when the quest is ended\n    function withdrawFee() public onlyAdminWithdrawAfterEnd {\n        IERC20(rewardToken).safeTransfer(protocolFeeRecipient, protocolFee());\n    }\n}"
    }
  ]
}