{
  "Title": "[10] MISSING `address(0)` CHECKS FOR `address` CONSTRUCTOR INPUTS",
  "Content": "To prevent unintended behaviors, critical constructor inputs that are `address` should be checked against `address(0)`. `address(0)` checks are missing for the `address` inputs of the following constructors. Please consider checking them.\n\nhttps://github.com/ethereum-optimism/optimism/blob/d322c6d651022ceb0798168726fe47416c6ddf00/packages/contracts-bedrock/contracts/L1/L2OutputOracle.sol#L90-L112\n```solidity\n    constructor(\n        ...\n        address _proposer,\n        address _challenger,\n        ...\n    ) Semver(1, 3, 0) {\n        ...\n        PROPOSER = _proposer;\n        CHALLENGER = _challenger;\n        ...\n    }\n```\n\nhttps://github.com/ethereum-optimism/optimism/blob/6eb05430d1ec1ae18ee96c2a206c60cc80fcbcf6/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L150-L160\n```solidity\n    constructor(\n        ...\n        address _guardian,\n        ...\n    ) Semver(1, 6, 0) {\n        ...\n        GUARDIAN = _guardian;\n        ...\n    }\n```\n\nhttps://github.com/ethereum-optimism/optimism/blob/4a01d2750ea10ad1109ff643faea2d8cfb28013f/packages/contracts-bedrock/contracts/L1/SystemConfig.sol#L93-L111\n```solidity\n    constructor(\n        address _owner,\n        ...\n        address _unsafeBlockSigner,\n        ...\n    ) Semver(1, 3, 0) {\n        initialize({\n            _owner: _owner,\n            ...\n            _unsafeBlockSigner: _unsafeBlockSigner,\n            ...\n        });\n    }\n```\n\nhttps://github.com/ethereum-optimism/optimism/blob/365367e6716d65ba45b583d72d9b030fbb5c0e47/packages/contracts-bedrock/contracts/universal/OptimismMintableERC20Factory.sol#L55-L57\n```solidity\n    constructor(address _bridge) Semver(1, 1, 0) {\n        BRIDGE = _bridge;\n    }\n```\n\nhttps://github.com/ethereum-optimism/optimism/blob/3b8fcafab4438b17e019c72391f829450a94a434/packages/contracts-bedrock/contracts/universal/ProxyAdmin.sol#L75-L77\n```solidity\n    constructor(address _owner) Ownable() {\n        _transferOwnership(_owner);\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-base",
  "Code": [
    {
      "filename": "packages/contracts-bedrock/contracts/L1/L2OutputOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { Types } from \"../libraries/Types.sol\";\n\n/**\n * @custom:proxied\n * @title L2OutputOracle\n * @notice The L2OutputOracle contains an array of L2 state outputs, where each output is a\n *         commitment to the state of the L2 chain. Other contracts like the OptimismPortal use\n *         these outputs to verify information about the state of L2.\n */\ncontract L2OutputOracle is Initializable, Semver {\n    /**\n     * @notice The interval in L2 blocks at which checkpoints must be submitted. Although this is\n     *         immutable, it can safely be modified by upgrading the implementation contract.\n     */\n    uint256 public immutable SUBMISSION_INTERVAL;\n\n    /**\n     * @notice The time between L2 blocks in seconds. Once set, this value MUST NOT be modified.\n     */\n    uint256 public immutable L2_BLOCK_TIME;\n\n    /**\n     * @notice The address of the challenger. Can be updated via upgrade.\n     */\n    address public immutable CHALLENGER;\n\n    /**\n     * @notice The address of the proposer. Can be updated via upgrade.\n     */\n    address public immutable PROPOSER;\n\n    /**\n     * @notice Minimum time (in seconds) that must elapse before a withdrawal can be finalized.\n     */\n    uint256 public immutable FINALIZATION_PERIOD_SECONDS;\n\n    /**\n     * @notice The number of the first L2 block recorded in this contract.\n     */\n    uint256 public startingBlockNumber;\n\n    /**\n     * @notice The timestamp of the first L2 block recorded in this contract.\n     */\n    uint256 public startingTimestamp;\n\n    /**\n     * @notice Array of L2 output proposals.\n     */\n    Types.OutputProposal[] internal l2Outputs;\n\n    /**\n     * @notice Emitted when an output is proposed.\n     *\n     * @param outputRoot    The output root.\n     * @param l2OutputIndex The index of the output in the l2Outputs array.\n     * @param l2BlockNumber The L2 block number of the output root.\n     * @param l1Timestamp   The L1 timestamp when proposed.\n     */\n    event OutputProposed(\n        bytes32 indexed outputRoot,\n        uint256 indexed l2OutputIndex,\n        uint256 indexed l2BlockNumber,\n        uint256 l1Timestamp\n    );\n\n    /**\n     * @notice Emitted when outputs are deleted.\n     *\n     * @param prevNextOutputIndex Next L2 output index before the deletion.\n     * @param newNextOutputIndex  Next L2 output index after the deletion.\n     */\n    event OutputsDeleted(uint256 indexed prevNextOutputIndex, uint256 indexed newNextOutputIndex);\n\n    /**\n     * @custom:semver 1.3.0\n     *\n     * @param _submissionInterval  Interval in blocks at which checkpoints must be submitted.\n     * @param _l2BlockTime         The time per L2 block, in seconds.\n     * @param _startingBlockNumber The number of the first L2 block.\n     * @param _startingTimestamp   The timestamp of the first L2 block.\n     * @param _proposer            The address of the proposer.\n     * @param _challenger          The address of the challenger.\n     */\n    constructor(\n        uint256 _submissionInterval,\n        uint256 _l2BlockTime,\n        uint256 _startingBlockNumber,\n        uint256 _startingTimestamp,\n        address _proposer,\n        address _challenger,\n        uint256 _finalizationPeriodSeconds\n    ) Semver(1, 3, 0) {\n        require(_l2BlockTime > 0, \"L2OutputOracle: L2 block time must be greater than 0\");\n        require(\n            _submissionInterval > 0,\n            \"L2OutputOracle: submission interval must be greater than 0\"\n        );\n\n        SUBMISSION_INTERVAL = _submissionInterval;\n        L2_BLOCK_TIME = _l2BlockTime;\n        PROPOSER = _proposer;\n        CHALLENGER = _challenger;\n        FINALIZATION_PERIOD_SECONDS = _finalizationPeriodSeconds;\n\n        initialize(_startingBlockNumber, _startingTimestamp);\n    }\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _startingBlockNumber Block number for the first recoded L2 block.\n     * @param _startingTimestamp   Timestamp for the first recoded L2 block.\n     */\n    function initialize(uint256 _startingBlockNumber, uint256 _startingTimestamp)\n        public\n        initializer\n    {\n        require(\n            _startingTimestamp <= block.timestamp,\n            \"L2OutputOracle: starting L2 timestamp must be less than current time\"\n        );\n\n        startingTimestamp = _startingTimestamp;\n        startingBlockNumber = _startingBlockNumber;\n    }\n\n    /**\n     * @notice Deletes all output proposals after and including the proposal that corresponds to\n     *         the given output index. Only the challenger address can delete outputs.\n     *\n     * @param _l2OutputIndex Index of the first L2 output to be deleted. All outputs after this\n     *                       output will also be deleted.\n     */\n    // solhint-disable-next-line ordering\n    function deleteL2Outputs(uint256 _l2OutputIndex) external {\n        require(\n            msg.sender == CHALLENGER,\n            \"L2OutputOracle: only the challenger address can delete outputs\"\n        );\n\n        // Make sure we're not *increasing* the length of the array.\n        require(\n            _l2OutputIndex < l2Outputs.length,\n            \"L2OutputOracle: cannot delete outputs after the latest output index\"\n        );\n\n        // Do not allow deleting any outputs that have already been finalized.\n        require(\n            block.timestamp - l2Outputs[_l2OutputIndex].timestamp < FINALIZATION_PERIOD_SECONDS,\n            \"L2OutputOracle: cannot delete outputs that have already been finalized\"\n        );\n\n        uint256 prevNextL2OutputIndex = nextOutputIndex();\n\n        // Use assembly to delete the array elements because Solidity doesn't allow it.\n        assembly {\n            sstore(l2Outputs.slot, _l2OutputIndex)\n        }\n\n        emit OutputsDeleted(prevNextL2OutputIndex, _l2OutputIndex);\n    }\n\n    /**\n     * @notice Accepts an outputRoot and the timestamp of the corresponding L2 block. The timestamp\n     *         must be equal to the current value returned by `nextTimestamp()` in order to be\n     *         accepted. This function may only be called by the Proposer.\n     *\n     * @param _outputRoot    The L2 output of the checkpoint block.\n     * @param _l2BlockNumber The L2 block number that resulted in _outputRoot.\n     * @param _l1BlockHash   A block hash which must be included in the current chain.\n     * @param _l1BlockNumber The block number with the specified block hash.\n     */\n    function proposeL2Output(\n        bytes32 _outputRoot,\n        uint256 _l2BlockNumber,\n        bytes32 _l1BlockHash,\n        uint256 _l1BlockNumber\n    ) external payable {\n        require(\n            msg.sender == PROPOSER,\n            \"L2OutputOracle: only the proposer address can propose new outputs\"\n        );\n\n        require(\n            _l2BlockNumber == nextBlockNumber(),\n            \"L2OutputOracle: block number must be equal to next expected block number\"\n        );\n\n        require(\n            computeL2Timestamp(_l2BlockNumber) < block.timestamp,\n            \"L2OutputOracle: cannot propose L2 output in the future\"\n        );\n\n        require(\n            _outputRoot != bytes32(0),\n            \"L2OutputOracle: L2 output proposal cannot be the zero hash\"\n        );\n\n        if (_l1BlockHash != bytes32(0)) {\n            // This check allows the proposer to propose an output based on a given L1 block,\n            // without fear that it will be reorged out.\n            // It will also revert if the blockheight provided is more than 256 blocks behind the\n            // chain tip (as the hash will return as zero). This does open the door to a griefing\n            // attack in which the proposer's submission is censored until the block is no longer\n            // retrievable, if the proposer is experiencing this attack it can simply leave out the\n            // blockhash value, and delay submission until it is confident that the L1 block is\n            // finalized.\n            require(\n                blockhash(_l1BlockNumber) == _l1BlockHash,\n                \"L2OutputOracle: block hash does not match the hash at the expected height\"\n            );\n        }\n\n        emit OutputProposed(_outputRoot, nextOutputIndex(), _l2BlockNumber, block.timestamp);\n\n        l2Outputs.push(\n            Types.OutputProposal({\n                outputRoot: _outputRoot,\n                timestamp: uint128(block.timestamp),\n                l2BlockNumber: uint128(_l2BlockNumber)\n            })\n        );\n    }\n\n    /**\n     * @notice Returns an output by index. Exists because Solidity's array access will return a\n     *         tuple instead of a struct.\n     *\n     * @param _l2OutputIndex Index of the output to return.\n     *\n     * @return The output at the given index.\n     */\n    function getL2Output(uint256 _l2OutputIndex)\n        external\n        view\n        returns (Types.OutputProposal memory)\n    {\n        return l2Outputs[_l2OutputIndex];\n    }\n\n    /**\n     * @notice Returns the index of the L2 output that checkpoints a given L2 block number. Uses a\n     *         binary search to find the first output greater than or equal to the given block.\n     *\n     * @param _l2BlockNumber L2 block number to find a checkpoint for.\n     *\n     * @return Index of the first checkpoint that commits to the given L2 block number.\n     */\n    function getL2OutputIndexAfter(uint256 _l2BlockNumber) public view returns (uint256) {\n        // Make sure an output for this block number has actually been proposed.\n        require(\n            _l2BlockNumber <= latestBlockNumber(),\n            \"L2OutputOracle: cannot get output for a block that has not been proposed\"\n        );\n\n        // Make sure there's at least one output proposed.\n        require(\n            l2Outputs.length > 0,\n            \"L2OutputOracle: cannot get output as no outputs have been proposed yet\"\n        );\n\n        // Find the output via binary search, guaranteed to exist.\n        uint256 lo = 0;\n        uint256 hi = l2Outputs.length;\n        while (lo < hi) {\n            uint256 mid = (lo + hi) / 2;\n            if (l2Outputs[mid].l2BlockNumber < _l2BlockNumber) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n\n        return lo;\n    }\n\n    /**\n     * @notice Returns the L2 output proposal that checkpoints a given L2 block number. Uses a\n     *         binary search to find the first output greater than or equal to the given block.\n     *\n     * @param _l2BlockNumber L2 block number to find a checkpoint for.\n     *\n     * @return First checkpoint that commits to the given L2 block number.\n     */\n    function getL2OutputAfter(uint256 _l2BlockNumber)\n        external\n        view\n        returns (Types.OutputProposal memory)\n    {\n        return l2Outputs[getL2OutputIndexAfter(_l2BlockNumber)];\n    }\n\n    /**\n     * @notice Returns the number of outputs that have been proposed. Will revert if no outputs\n     *         have been proposed yet.\n     *\n     * @return The number of outputs that have been proposed.\n     */\n    function latestOutputIndex() external view returns (uint256) {\n        return l2Outputs.length - 1;\n    }\n\n    /**\n     * @notice Returns the index of the next output to be proposed.\n     *\n     * @return The index of the next output to be proposed.\n     */\n    function nextOutputIndex() public view returns (uint256) {\n        return l2Outputs.length;\n    }\n\n    /**\n     * @notice Returns the block number of the latest submitted L2 output proposal. If no proposals\n     *         been submitted yet then this function will return the starting block number.\n     *\n     * @return Latest submitted L2 block number.\n     */\n    function latestBlockNumber() public view returns (uint256) {\n        return\n            l2Outputs.length == 0\n                ? startingBlockNumber\n                : l2Outputs[l2Outputs.length - 1].l2BlockNumber;\n    }\n\n    /**\n     * @notice Computes the block number of the next L2 block that needs to be checkpointed.\n     *\n     * @return Next L2 block number.\n     */\n    function nextBlockNumber() public view returns (uint256) {\n        return latestBlockNumber() + SUBMISSION_INTERVAL;\n    }\n\n    /**\n     * @notice Returns the L2 timestamp corresponding to a given L2 block number.\n     *\n     * @param _l2BlockNumber The L2 block number of the target block.\n     *\n     * @return L2 timestamp of the given block.\n     */\n    function computeL2Timestamp(uint256 _l2BlockNumber) public view returns (uint256) {\n        return startingTimestamp + ((_l2BlockNumber - startingBlockNumber) * L2_BLOCK_TIME);\n    }\n}"
    },
    {
      "filename": "packages/contracts-bedrock/contracts/L1/OptimismPortal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\nimport { SystemConfig } from \"./SystemConfig.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { SecureMerkleTrie } from \"../libraries/trie/SecureMerkleTrie.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { ResourceMetering } from \"./ResourceMetering.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @title OptimismPortal\n * @notice The OptimismPortal is a low-level contract responsible for passing messages between L1\n *         and L2. Messages sent directly to the OptimismPortal have no form of replayability.\n *         Users are encouraged to use the L1CrossDomainMessenger for a higher-level interface.\n */\ncontract OptimismPortal is Initializable, ResourceMetering, Semver {\n    /**\n     * @notice Represents a proven withdrawal.\n     *\n     * @custom:field outputRoot    Root of the L2 output this was proven against.\n     * @custom:field timestamp     Timestamp at whcih the withdrawal was proven.\n     * @custom:field l2OutputIndex Index of the output this was proven against.\n     */\n    struct ProvenWithdrawal {\n        bytes32 outputRoot;\n        uint128 timestamp;\n        uint128 l2OutputIndex;\n    }\n\n    /**\n     * @notice Version of the deposit event.\n     */\n    uint256 internal constant DEPOSIT_VERSION = 0;\n\n    /**\n     * @notice The L2 gas limit set when eth is deposited using the receive() function.\n     */\n    uint64 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Address of the L2OutputOracle contract.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice Address of the SystemConfig contract.\n     */\n    SystemConfig public immutable SYSTEM_CONFIG;\n\n    /**\n     * @notice Address that has the ability to pause and unpause withdrawals.\n     */\n    address public immutable GUARDIAN;\n\n    /**\n     * @notice Address of the L2 account which initiated a withdrawal in this transaction. If the\n     *         of this variable is the default L2 sender address, then we are NOT inside of a call\n     *         to finalizeWithdrawalTransaction.\n     */\n    address public l2Sender;\n\n    /**\n     * @notice A list of withdrawal hashes which have been successfully finalized.\n     */\n    mapping(bytes32 => bool) public finalizedWithdrawals;\n\n    /**\n     * @notice A mapping of withdrawal hashes to `ProvenWithdrawal` data.\n     */\n    mapping(bytes32 => ProvenWithdrawal) public provenWithdrawals;\n\n    /**\n     * @notice Determines if cross domain messaging is paused. When set to true,\n     *         withdrawals are paused. This may be removed in the future.\n     */\n    bool public paused;\n\n    /**\n     * @notice Emitted when a transaction is deposited from L1 to L2. The parameters of this event\n     *         are read by the rollup node and used to derive deposit transactions on L2.\n     *\n     * @param from       Address that triggered the deposit transaction.\n     * @param to         Address that the deposit transaction is directed to.\n     * @param version    Version of this deposit transaction event.\n     * @param opaqueData ABI encoded deposit data to be parsed off-chain.\n     */\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 indexed version,\n        bytes opaqueData\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is proven.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     */\n    event WithdrawalProven(\n        bytes32 indexed withdrawalHash,\n        address indexed from,\n        address indexed to\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is finalized.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     * @param success        Whether the withdrawal transaction was successful.\n     */\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\n\n    /**\n     * @notice Emitted when the pause is triggered.\n     *\n     * @param account Address of the account triggering the pause.\n     */\n    event Paused(address account);\n\n    /**\n     * @notice Emitted when the pause is lifted.\n     *\n     * @param account Address of the account triggering the unpause.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @notice Reverts when paused.\n     */\n    modifier whenNotPaused() {\n        require(paused == false, \"OptimismPortal: paused\");\n        _;\n    }\n\n    /**\n     * @custom:semver 1.6.0\n     *\n     * @param _l2Oracle                  Address of the L2OutputOracle contract.\n     * @param _guardian                  Address that can pause deposits and withdrawals.\n     * @param _paused                    Sets the contract's pausability state.\n     * @param _config                    Address of the SystemConfig contract.\n     */\n    constructor(\n        L2OutputOracle _l2Oracle,\n        address _guardian,\n        bool _paused,\n        SystemConfig _config\n    ) Semver(1, 6, 0) {\n        L2_ORACLE = _l2Oracle;\n        GUARDIAN = _guardian;\n        SYSTEM_CONFIG = _config;\n        initialize(_paused);\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize(bool _paused) public initializer {\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n        paused = _paused;\n        __ResourceMetering_init();\n    }\n\n    /**\n     * @notice Pause deposits and withdrawals.\n     */\n    function pause() external {\n        require(msg.sender == GUARDIAN, \"OptimismPortal: only guardian can pause\");\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @notice Unpause deposits and withdrawals.\n     */\n    function unpause() external {\n        require(msg.sender == GUARDIAN, \"OptimismPortal: only guardian can unpause\");\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /**\n     * @notice Computes the minimum gas limit for a deposit. The minimum gas limit\n     *         linearly increases based on the size of the calldata. This is to prevent\n     *         users from creating L2 resource usage without paying for it. This function\n     *         can be used when interacting with the portal to ensure forwards compatibility.\n     *\n     */\n    function minimumGasLimit(uint64 _byteCount) public pure returns (uint64) {\n        return _byteCount * 16 + 21000;\n    }\n\n    /**\n     * @notice Accepts value so that users can send ETH directly to this contract and have the\n     *         funds be deposited to their address on L2. This is intended as a convenience\n     *         function for EOAs. Contracts should call the depositTransaction() function directly\n     *         otherwise any deposited funds will be lost due to address aliasing.\n     */\n    // solhint-disable-next-line ordering\n    receive() external payable {\n        depositTransaction(msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, false, bytes(\"\"));\n    }\n\n    /**\n     * @notice Accepts ETH value without triggering a deposit to L2. This function mainly exists\n     *         for the sake of the migration between the legacy Optimism system and Bedrock.\n     */\n    function donateETH() external payable {\n        // Intentionally empty.\n    }\n\n    /**\n     * @notice Getter for the resource config. Used internally by the ResourceMetering\n     *         contract. The SystemConfig is the source of truth for the resource config.\n     *\n     * @return ResourceMetering.ResourceConfig\n     */\n    function _resourceConfig()\n        internal\n        view\n        override\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        return SYSTEM_CONFIG.resourceConfig();\n    }\n\n    /**\n     * @notice Proves a withdrawal transaction.\n     *\n     * @param _tx              Withdrawal transaction to finalize.\n     * @param _l2OutputIndex   L2 output index to prove against.\n     * @param _outputRootProof Inclusion proof of the L2ToL1MessagePasser contract's storage root.\n     * @param _withdrawalProof Inclusion proof of the withdrawal in L2ToL1MessagePasser contract.\n     */\n    function proveWithdrawalTransaction(\n        Types.WithdrawalTransaction memory _tx,\n        uint256 _l2OutputIndex,\n        Types.OutputRootProof calldata _outputRootProof,\n        bytes[] calldata _withdrawalProof\n    ) external whenNotPaused {\n        // Prevent users from creating a deposit transaction where this address is the message\n        // sender on L2. Because this is checked here, we do not need to check again in\n        // `finalizeWithdrawalTransaction`.\n        require(\n            _tx.target != address(this),\n            \"OptimismPortal: you cannot send messages to the portal contract\"\n        );\n\n        // Get the output root and load onto the stack to prevent multiple mloads. This will\n        // revert if there is no output root for the given block number.\n        bytes32 outputRoot = L2_ORACLE.getL2Output(_l2OutputIndex).outputRoot;\n\n        // Verify that the output root can be generated with the elements in the proof.\n        require(\n            outputRoot == Hashing.hashOutputRootProof(_outputRootProof),\n            \"OptimismPortal: invalid output root proof\"\n        );\n\n        // Load the ProvenWithdrawal into memory, using the withdrawal hash as a unique identifier.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // We generally want to prevent users from proving the same withdrawal multiple times\n        // because each successive proof will update the timestamp. A malicious user can take\n        // advantage of this to prevent other users from finalizing their withdrawal. However,\n        // since withdrawals are proven before an output root is finalized, we need to allow users\n        // to re-prove their withdrawal only in the case that the output root for their specified\n        // output index has been updated.\n        require(\n            provenWithdrawal.timestamp == 0 ||\n                L2_ORACLE.getL2Output(provenWithdrawal.l2OutputIndex).outputRoot !=\n                provenWithdrawal.outputRoot,\n            \"OptimismPortal: withdrawal hash has already been proven\"\n        );\n\n        // Compute the storage slot of the withdrawal hash in the L2ToL1MessagePasser contract.\n        // Refer to the Solidity documentation for more information on how storage layouts are\n        // computed for mappings.\n        bytes32 storageKey = keccak256(\n            abi.encode(\n                withdrawalHash,\n                uint256(0) // The withdrawals mapping is at the first slot in the layout.\n            )\n        );\n\n        // Verify that the hash of this withdrawal was stored in the L2toL1MessagePasser contract\n        // on L2. If this is true, under the assumption that the SecureMerkleTrie does not have\n        // bugs, then we know that this withdrawal was actually triggered on L2 and can therefore\n        // be relayed on L1.\n        require(\n            SecureMerkleTrie.verifyInclusionProof(\n                abi.encode(storageKey),\n                hex\"01\",\n                _withdrawalProof,\n                _outputRootProof.messagePasserStorageRoot\n            ),\n            \"OptimismPortal: invalid withdrawal inclusion proof\"\n        );\n\n        // Designate the withdrawalHash as proven by storing the `outputRoot`, `timestamp`, and\n        // `l2BlockNumber` in the `provenWithdrawals` mapping. A `withdrawalHash` can only be\n        // proven once unless it is submitted again with a different outputRoot.\n        provenWithdrawals[withdrawalHash] = ProvenWithdrawal({\n            outputRoot: outputRoot,\n            timestamp: uint128(block.timestamp),\n            l2OutputIndex: uint128(_l2OutputIndex)\n        });\n\n        // Emit a `WithdrawalProven` event.\n        emit WithdrawalProven(withdrawalHash, _tx.sender, _tx.target);\n    }\n\n    /**\n     * @notice Finalizes a withdrawal transaction.\n     *\n     * @param _tx Withdrawal transaction to finalize.\n     */\n    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx)\n        external\n        whenNotPaused\n    {\n        // Make sure that the l2Sender has not yet been set. The l2Sender is set to a value other\n        // than the default value when a withdrawal transaction is being finalized. This check is\n        // a defacto reentrancy guard.\n        require(\n            l2Sender == Constants.DEFAULT_L2_SENDER,\n            \"OptimismPortal: can only trigger one withdrawal per transaction\"\n        );\n\n        // Grab the proven withdrawal from the `provenWithdrawals` map.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // A withdrawal can only be finalized if it has been proven. We know that a withdrawal has\n        // been proven at least once when its timestamp is non-zero. Unproven withdrawals will have\n        // a timestamp of zero.\n        require(\n            provenWithdrawal.timestamp != 0,\n            \"OptimismPortal: withdrawal has not been proven yet\"\n        );\n\n        // As a sanity check, we make sure that the proven withdrawal's timestamp is greater than\n        // starting timestamp inside the L2OutputOracle. Not strictly necessary but extra layer of\n        // safety against weird bugs in the proving step.\n        require(\n            provenWithdrawal.timestamp >= L2_ORACLE.startingTimestamp(),\n            \"OptimismPortal: withdrawal timestamp less than L2 Oracle starting timestamp\"\n        );\n\n        // A proven withdrawal must wait at least the finalization period before it can be\n        // finalized. This waiting period can elapse in parallel with the waiting period for the\n        // output the withdrawal was proven against. In effect, this means that the minimum\n        // withdrawal time is proposal submission time + finalization period.\n        require(\n            _isFinalizationPeriodElapsed(provenWithdrawal.timestamp),\n            \"OptimismPortal: proven withdrawal finalization period has not elapsed\"\n        );\n\n        // Grab the OutputProposal from the L2OutputOracle, will revert if the output that\n        // corresponds to the given index has not been proposed yet.\n        Types.OutputProposal memory proposal = L2_ORACLE.getL2Output(\n            provenWithdrawal.l2OutputIndex\n        );\n\n        // Check that the output root that was used to prove the withdrawal is the same as the\n        // current output root for the given output index. An output root may change if it is\n        // deleted by the challenger address and then re-proposed.\n        require(\n            proposal.outputRoot == provenWithdrawal.outputRoot,\n            \"OptimismPortal: output root proven is not the same as current output root\"\n        );\n\n        // Check that the output proposal has also been finalized.\n        require(\n            _isFinalizationPeriodElapsed(proposal.timestamp),\n            \"OptimismPortal: output proposal finalization period has not elapsed\"\n        );\n\n        // Check that this withdrawal has not already been finalized, this is replay protection.\n        require(\n            finalizedWithdrawals[withdrawalHash] == false,\n            \"OptimismPortal: withdrawal has already been finalized\"\n        );\n\n        // Mark the withdrawal as finalized so it can't be replayed.\n        finalizedWithdrawals[withdrawalHash] = true;\n\n        // Set the l2Sender so contracts know who triggered this withdrawal on L2.\n        l2Sender = _tx.sender;\n\n        // Trigger the call to the target contract. We use a custom low level method\n        // SafeCall.callWithMinGas to ensure two key properties\n        //   1. Target contracts cannot force this call to run out of gas by returning a very large\n        //      amount of data (and this is OK because we don't care about the returndata here).\n        //   2. The amount of gas provided to the execution context of the target is at least the\n        //      gas limit specified by the user. If there is not enough gas in the current context\n        //      to accomplish this, `callWithMinGas` will revert.\n        bool success = SafeCall.callWithMinGas(_tx.target, _tx.gasLimit, _tx.value, _tx.data);\n\n        // Reset the l2Sender back to the default value.\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n\n        // All withdrawals are immediately finalized. Replayability can\n        // be achieved through contracts built on top of this contract\n        emit WithdrawalFinalized(withdrawalHash, success);\n\n        // Reverting here is useful for determining the exact gas cost to successfully execute the\n        // sub call to the target contract if the minimum gas limit specified by the user would not\n        // be sufficient to execute the sub call.\n        if (success == false && tx.origin == Constants.ESTIMATION_ADDRESS) {\n            revert(\"OptimismPortal: withdrawal failed\");\n        }\n    }\n\n    /**\n     * @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in\n     *         deriving deposit transactions. Note that if a deposit is made by a contract, its\n     *         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider\n     *         using the CrossDomainMessenger contracts for a simpler developer experience.\n     *\n     * @param _to         Target address on L2.\n     * @param _value      ETH value to send to the recipient.\n     * @param _gasLimit   Minimum L2 gas limit (can be greater than or equal to this value).\n     * @param _isCreation Whether or not the transaction is a contract creation.\n     * @param _data       Data to trigger the recipient with.\n     */\n    function depositTransaction(\n        address _to,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable metered(_gasLimit) {\n        // Just to be safe, make sure that people specify address(0) as the target when doing\n        // contract creations.\n        if (_isCreation) {\n            require(\n                _to == address(0),\n                \"OptimismPortal: must send to address(0) when creating a contract\"\n            );\n        }\n\n        // Prevent depositing transactions that have too small of a gas limit. Users should pay\n        // more for more resource usage.\n        require(\n            _gasLimit >= minimumGasLimit(uint64(_data.length)),\n            \"OptimismPortal: gas limit too small\"\n        );\n\n        // Prevent the creation of deposit transactions that have too much calldata. This gives an\n        // upper limit on the size of unsafe blocks over the p2p network. 120kb is chosen to ensure\n        // that the transaction can fit into the p2p network policy of 128kb even though deposit\n        // transactions are not gossipped over the p2p network.\n        require(_data.length <= 120_000, \"OptimismPortal: data too large\");\n\n        // Transform the from-address to its alias if the caller is a contract.\n        address from = msg.sender;\n        if (msg.sender != tx.origin) {\n            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.\n        // We use opaque data so that we can update the TransactionDeposited event in the future\n        // without breaking the current interface.\n        bytes memory opaqueData = abi.encodePacked(\n            msg.value,\n            _value,\n            _gasLimit,"
    }
  ]
}