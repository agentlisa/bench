{
  "Title": "M-5: Keepers can steal additional execution fee from users",
  "Content": "# Issue M-5: Keepers can steal additional execution fee from users \n\nSource: https://github.com/sherlock-audit/2023-04-gmx-judging/issues/199 \n\n## Found by \nJ4de, KingNFT\n## Summary\nThe implementation of ````payExecutionFee()```` didn't take EIP-150 into consideration, a malicious keeper can exploit it to  drain out all execution fee users have paid, regardless of the actual execution cost.\n\n## Vulnerability Detail\nThe issue arises on ````L55```` of ````payExecutionFee()````, as it's an ````external```` function, calling````payExecutionFee()```` is subject to EIP-150.\nOnly ````63/64```` gas is passed to the ````GasUtils```` sub-contract(````external library````), and the remaing ````1/64```` gas is reserved in the caller contract which will be refunded to keeper(````msg.sender````) after the execution of the whole transaction. But calculation of ````gasUsed ```` includes this portion of the cost as well.\n```diff\nFile: contracts\\gas\\GasUtils.sol\n46:     function payExecutionFee(\n47:         DataStore dataStore,\n48:         EventEmitter eventEmitter,\n49:         StrictBank bank,\n50:         uint256 executionFee,\n51:         uint256 startingGas,\n52:         address keeper,\n53:         address user\n54:     ) external { // @audit external call is subject to EIP-150\n-55:         uint256 gasUsed = startingGas - gasleft();\n+            uint256 gasUsed = startingGas - gasleft() * 64 / 63; // @audit the correct formula\n56:         uint256 executionFeeForKeeper = adjustGasUsage(dataStore, gasUsed) * tx.gasprice;\n57: \n58:         if (executionFeeForKeeper > executionFee) {\n59:             executionFeeForKeeper = executionFee;\n60:         }\n61: \n62:         bank.transferOutNativeToken(\n63:             keeper,\n64:             executionFeeForKeeper\n65:         );\n66: \n67:         emitKeeperExecutionFee(eventEmitter, keeper, executionFeeForKeeper);\n68: \n69:         uint256 refundFeeAmount = executionFee - executionFeeForKeeper;\n70:         if (refundFeeAmount == 0) {\n71:             return;\n72:         }\n73: \n74:         bank.transferOutNativeToken(\n75:             user,\n76:             refundFeeAmount\n77:         );\n78: \n79:         emitExecutionFeeRefund(eventEmitter, user, refundFeeAmount);\n80:     }\n```\nA malicious keeper can exploit this issue to drain out all execution fee, regardless of the actual execution cost.\nLet's take ````executeDeposit()```` operation as an example to show how it works:\n```solidity\nFile: contracts\\exchange\\DepositHandler.sol\n092:     function executeDeposit(\n093:         bytes32 key,\n094:         OracleUtils.SetPricesParams calldata oracleParams\n095:     ) external\n096:         globalNonReentrant\n097:         onlyOrderKeeper\n098:         withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n099:     {\n100:         uint256 startingGas = gasleft();\n101: \n102:         try this._executeDeposit(\n103:             key,\n104:             oracleParams,\n105:             msg.sender\n106:         ) {\n107:         } catch (bytes memory reasonBytes) {\n...\n113:         }\n114:     }\n\nFile: contracts\\exchange\\DepositHandler.sol\n141:     function _executeDeposit(\n142:         bytes32 key,\n143:         OracleUtils.SetPricesParams memory oracleParams,\n144:         address keeper\n145:     ) external onlySelf {\n146:         uint256 startingGas = gasleft();\n...\n171: \n172:         ExecuteDepositUtils.executeDeposit(params);\n173:     }\n\n\nFile: contracts\\deposit\\ExecuteDepositUtils.sol\n096:     function executeDeposit(ExecuteDepositParams memory params) external {\n...\n221: \n222:         GasUtils.payExecutionFee(\n223:             params.dataStore,\n224:             params.eventEmitter,\n225:             params.depositVault,\n226:             deposit.executionFee(),\n227:             params.startingGas,\n228:             params.keeper,\n229:             deposit.account()\n230:         );\n231:     }\n\nFile: contracts\\gas\\GasUtils.sol\n46:     function payExecutionFee(\n47:         DataStore dataStore,\n48:         EventEmitter eventEmitter,\n49:         StrictBank bank,\n50:         uint256 executionFee,\n51:         uint256 startingGas,\n52:         address keeper,\n53:         address user\n54:     ) external {\n55:         uint256 gasUsed = startingGas - gasleft();\n56:         uint256 executionFeeForKeeper = adjustGasUsage(dataStore, gasUsed) * tx.gasprice;\n57: \n58:         if (executionFeeForKeeper > executionFee) {\n59:             executionFeeForKeeper = executionFee;\n60:         }\n61: \n62:         bank.transferOutNativeToken(\n63:             keeper,\n64:             executionFeeForKeeper\n65:         );\n66: \n67:         emitKeeperExecutionFee(eventEmitter, keeper, executionFeeForKeeper);\n68: \n69:         uint256 refundFeeAmount = executionFee - executionFeeForKeeper;\n70:         if (refundFeeAmount == 0) {\n71:             return;\n72:         }\n73: \n74:         bank.transferOutNativeToken(\n75:             user,\n76:             refundFeeAmount\n77:         );\n78: \n79:         emitExecutionFeeRefund(eventEmitter, user, refundFeeAmount);\n80:     }\n\nFile: contracts\\gas\\GasUtils.sol\n097:     function adjustGasUsage(DataStore dataStore, uint256 gasUsed) internal view returns (uint256) {\n...\n105:         uint256 baseGasLimit = dataStore.getUint(Keys.EXECUTION_GAS_FEE_BASE_AMOUNT);\n...\n109:         uint256 multiplierFactor = dataStore.getUint(Keys.EXECUTION_GAS_FEE_MULTIPLIER_FACTOR);\n110:         uint256 gasLimit = baseGasLimit + Precision.applyFactor(gasUsed, multiplierFactor);\n111:         return gasLimit;\n112:     }\n```\nTo simplify the problem, given\n```solidity\nEXECUTION_GAS_FEE_BASE_AMOUNT = 0\nEXECUTION_GAS_FEE_MULTIPLIER_FACTOR = 1\nexecutionFeeUserHasPaid = 200K Gwei\ntx.gasprice = 1 Gwei\nactualUsedGas = 100K\n```\n````actualUsedGas```` is the gas cost since ````startingGas````(L146 of ````DepositHandler.sol````) but before calling ````payExecutionFee()````(L221 of ````ExecuteDepositUtils.sol````)\n\nLet's say, the keeper sets ````tx.gaslimit```` to make\n```solidity\nstartingGas = 164K\n```\nThen the calculation of ````gasUsed````,  L55 of ````GasUtils.sol````, would be\n```solidity\nuint256 gasUsed = startingGas - gasleft() = 164K - (164K - 100K) * 63 / 64 = 101K\n```\nand\n```solidity\nexecutionFeeForKeeper = 101K * tx.gasprice = 101K * 1 Gwei = 101K Gwei\nrefundFeeForUser = 200K - 101K = 99K Gwei\n```\n\nAs setting of ````tx.gaslimit```` doesn't affect the actual gas cost of the whole transaction, the excess gas will be refunded to ````msg.sender````. Now, the keeper increases ````tx.gaslimit```` to make ````startingGas = 6500K````, the calculation of ````gasUsed```` would be\n```solidity\nuint256 gasUsed = startingGas - gasleft() = 6500K - (6500K - 100K) * 63 / 64 = 200K\n```\nand\n```solidity\nexecutionFeeForKeeper = 200K * tx.gasprice = 200K * 1 Gwei = 200K Gwei\nrefundFeeForUser = 200K - 200K = 0 Gwei\n```\nWe can see the keeper successfully drain out all execution fee, the user gets nothing refunded.\n\n## Impact\nKeepers can steal additional execution fee from users.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/gas/GasUtils.sol#L55\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThe description in ````Vulnerability Detail```` section has been simplified. In fact, ````gasleft```` value should be adjusted after each external call during the whole call stack, not just in ````payExecutionFee()````.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/74",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/gas/GasUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\nimport \"../utils/Precision.sol\";\n\nimport \"../deposit/Deposit.sol\";\nimport \"../withdrawal/Withdrawal.sol\";\nimport \"../order/Order.sol\";\nimport \"../order/BaseOrderUtils.sol\";\n\nimport \"../bank/StrictBank.sol\";\n\n// @title GasUtils\n// @dev Library for execution fee estimation and payments\nlibrary GasUtils {\n    using Deposit for Deposit.Props;\n    using Withdrawal for Withdrawal.Props;\n    using Order for Order.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    // @param keeper address of the keeper\n    // @param amount the amount of execution fee received\n    event KeeperExecutionFee(address keeper, uint256 amount);\n    // @param user address of the user\n    // @param amount the amount of execution fee refunded\n    event UserRefundFee(address user, uint256 amount);\n\n    // @dev pay the keeper the execution fee and refund any excess amount to the user\n    //\n    // @param dataStore DataStore\n    // @param bank the StrictBank contract holding the execution fee\n    // @param executionFee the executionFee amount\n    // @param startingGas the starting gas\n    // @param keeper the keeper to pay\n    // @param user the user to refund\n    function payExecutionFee(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        StrictBank bank,\n        uint256 executionFee,\n        uint256 startingGas,\n        address keeper,\n        address user\n    ) external {\n        uint256 gasUsed = startingGas - gasleft();\n        uint256 executionFeeForKeeper = adjustGasUsage(dataStore, gasUsed) * tx.gasprice;\n\n        if (executionFeeForKeeper > executionFee) {\n            executionFeeForKeeper = executionFee;\n        }\n\n        bank.transferOutNativeToken(\n            keeper,\n            executionFeeForKeeper\n        );\n\n        emitKeeperExecutionFee(eventEmitter, keeper, executionFeeForKeeper);\n\n        uint256 refundFeeAmount = executionFee - executionFeeForKeeper;\n        if (refundFeeAmount == 0) {\n            return;\n        }\n\n        bank.transferOutNativeToken(\n            user,\n            refundFeeAmount\n        );\n\n        emitExecutionFeeRefund(eventEmitter, user, refundFeeAmount);\n    }\n\n    // @dev validate that the provided executionFee is sufficient based on the estimatedGasLimit\n    // @param dataStore DataStore\n    // @param estimatedGasLimit the estimated gas limit\n    // @param executionFee the execution fee provided\n    function validateExecutionFee(DataStore dataStore, uint256 estimatedGasLimit, uint256 executionFee) internal view {\n        uint256 gasLimit = adjustGasLimitForEstimate(dataStore, estimatedGasLimit);\n        uint256 minExecutionFee = gasLimit * tx.gasprice;\n        if (executionFee < minExecutionFee) {\n            revert Errors.InsufficientExecutionFee(minExecutionFee, executionFee);\n        }\n    }\n\n    // @dev adjust the gas usage to pay a small amount to keepers\n    // @param dataStore DataStore\n    // @param gasUsed the amount of gas used\n    function adjustGasUsage(DataStore dataStore, uint256 gasUsed) internal view returns (uint256) {\n        // gas measurements are done after the call to withOraclePrices\n        // withOraclePrices may consume a significant amount of gas\n        // the baseGasLimit used to calculate the execution cost\n        // should be adjusted to account for this\n        // additionally, a transaction could fail midway through an execution transaction\n        // before being cancelled, the possibility of this additional gas cost should\n        // be considered when setting the baseGasLimit\n        uint256 baseGasLimit = dataStore.getUint(Keys.EXECUTION_GAS_FEE_BASE_AMOUNT);\n        // the gas cost is estimated based on the gasprice of the request txn\n        // the actual cost may be higher if the gasprice is higher in the execution txn\n        // the multiplierFactor should be adjusted to account for this\n        uint256 multiplierFactor = dataStore.getUint(Keys.EXECUTION_GAS_FEE_MULTIPLIER_FACTOR);\n        uint256 gasLimit = baseGasLimit + Precision.applyFactor(gasUsed, multiplierFactor);\n        return gasLimit;\n    }\n\n    // @dev adjust the estimated gas limit to help ensure the execution fee is sufficient during\n    // the actual execution\n    // @param dataStore DataStore\n    // @param estimatedGasLimit the estimated gas limit\n    function adjustGasLimitForEstimate(DataStore dataStore, uint256 estimatedGasLimit) internal view returns (uint256) {\n        uint256 baseGasLimit = dataStore.getUint(Keys.ESTIMATED_GAS_FEE_BASE_AMOUNT);\n        uint256 multiplierFactor = dataStore.getUint(Keys.ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR);\n        uint256 gasLimit = baseGasLimit + Precision.applyFactor(estimatedGasLimit, multiplierFactor);\n        return gasLimit;\n    }\n\n    // @dev the estimated gas limit for deposits\n    // @param dataStore DataStore\n    // @param deposit the deposit to estimate the gas limit for\n    function estimateExecuteDepositGasLimit(DataStore dataStore, Deposit.Props memory deposit) internal view returns (uint256) {\n        uint256 gasPerSwap = dataStore.getUint(Keys.singleSwapGasLimitKey());\n        uint256 swapCount = deposit.longTokenSwapPath().length + deposit.shortTokenSwapPath().length;\n        uint256 gasForSwaps = swapCount * gasPerSwap;\n\n        if (deposit.initialLongTokenAmount() == 0 || deposit.initialShortTokenAmount() == 0) {\n            return dataStore.getUint(Keys.depositGasLimitKey(true)) + deposit.callbackGasLimit() + gasForSwaps;\n        }\n\n        return dataStore.getUint(Keys.depositGasLimitKey(false)) + deposit.callbackGasLimit() + gasForSwaps;\n    }\n\n    // @dev the estimated gas limit for withdrawals\n    // @param dataStore DataStore\n    // @param withdrawal the withdrawal to estimate the gas limit for\n    function estimateExecuteWithdrawalGasLimit(DataStore dataStore, Withdrawal.Props memory withdrawal) internal view returns (uint256) {\n        uint256 gasPerSwap = dataStore.getUint(Keys.singleSwapGasLimitKey());\n        uint256 swapCount = withdrawal.longTokenSwapPath().length + withdrawal.shortTokenSwapPath().length;\n        uint256 gasForSwaps = swapCount * gasPerSwap;\n\n        return dataStore.getUint(Keys.withdrawalGasLimitKey(false)) + withdrawal.callbackGasLimit() + gasForSwaps;\n    }\n\n    // @dev the estimated gas limit for orders\n    // @param dataStore DataStore\n    // @param order the order to estimate the gas limit for\n    function estimateExecuteOrderGasLimit(DataStore dataStore, Order.Props memory order) internal view returns (uint256) {\n        if (BaseOrderUtils.isIncreaseOrder(order.orderType())) {\n            return estimateExecuteIncreaseOrderGasLimit(dataStore, order);\n        }\n\n        if (BaseOrderUtils.isDecreaseOrder(order.orderType())) {\n            return estimateExecuteDecreaseOrderGasLimit(dataStore, order);\n        }\n\n        if (BaseOrderUtils.isSwapOrder(order.orderType())) {\n            return estimateExecuteSwapOrderGasLimit(dataStore, order);\n        }\n\n        revert Errors.UnsupportedOrderType();\n    }\n\n    // @dev the estimated gas limit for increase orders\n    // @param dataStore DataStore\n    // @param order the order to estimate the gas limit for\n    function estimateExecuteIncreaseOrderGasLimit(DataStore dataStore, Order.Props memory order) internal view returns (uint256) {\n        uint256 gasPerSwap = dataStore.getUint(Keys.singleSwapGasLimitKey());\n        return dataStore.getUint(Keys.increaseOrderGasLimitKey()) + gasPerSwap * order.swapPath().length + order.callbackGasLimit();\n    }\n\n    // @dev the estimated gas limit for decrease orders\n    // @param dataStore DataStore\n    // @param order the order to estimate the gas limit for\n    function estimateExecuteDecreaseOrderGasLimit(DataStore dataStore, Order.Props memory order) internal view returns (uint256) {\n        uint256 gasPerSwap = dataStore.getUint(Keys.singleSwapGasLimitKey());\n        return dataStore.getUint(Keys.decreaseOrderGasLimitKey()) + gasPerSwap * order.swapPath().length + order.callbackGasLimit();\n    }\n\n    // @dev the estimated gas limit for swap orders\n    // @param dataStore DataStore\n    // @param order the order to estimate the gas limit for\n    function estimateExecuteSwapOrderGasLimit(DataStore dataStore, Order.Props memory order) internal view returns (uint256) {\n        uint256 gasPerSwap = dataStore.getUint(Keys.singleSwapGasLimitKey());\n        return dataStore.getUint(Keys.swapOrderGasLimitKey()) + gasPerSwap * order.swapPath().length + order.callbackGasLimit();\n    }\n\n    function emitKeeperExecutionFee(\n        EventEmitter eventEmitter,\n        address keeper,\n        uint256 executionFeeAmount\n    ) internal {\n        EventUtils.EventLogData memory eventData;\n\n        eventData.addressItems.initItems(1);\n        eventData.addressItems.setItem(0, \"keeper\", keeper);\n\n        eventData.uintItems.initItems(1);\n        eventData.uintItems.setItem(0, \"executionFeeAmount\", executionFeeAmount);\n\n        eventEmitter.emitEventLog1(\n            \"KeeperExecutionFee\",\n            Cast.toBytes32(keeper),\n            eventData\n        );\n    }\n\n    function emitExecutionFeeRefund(\n        EventEmitter eventEmitter,\n        address account,\n        uint256 refundFeeAmount\n    ) internal {\n        EventUtils.EventLogData memory eventData;\n\n        eventData.addressItems.initItems(1);\n        eventData.addressItems.setItem(0, \"account\", account);\n\n        eventData.uintItems.initItems(1);\n        eventData.uintItems.setItem(0, \"refundFeeAmount\", refundFeeAmount);\n\n        eventEmitter.emitEventLog1(\n            \"ExecutionFeeRefund\",\n            Cast.toBytes32(account),\n            eventData\n        );\n    }\n}"
    }
  ]
}