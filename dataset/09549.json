{
  "Title": "[N-07] File is missing NatSpec",
  "Content": "\n1.  File: src/AdminMultisigBase.sol (line [0](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/AdminMultisigBase.sol#L0))\n\n```solidity\n// SPDX-License-Identifier: MIT\n```\n\n2.  File: src/DepositHandler.sol (line [0](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/DepositHandler.sol#L0))\n\n```solidity\n// SPDX-License-Identifier: MIT\n```\n\n3.  File: src/BurnableMintableCappedERC20.sol (line [0](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/BurnableMintableCappedERC20.sol#L0))\n\n```solidity\n// SPDX-License-Identifier: MIT\n```\n\n4.  File: src/Ownable.sol (line [0](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/Ownable.sol#L0))\n\n```solidity\n// SPDX-License-Identifier: MIT\n```\n\n5.  File: src/TokenDeployer.sol (line [0](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/TokenDeployer.sol#L0))\n\n```solidity\n// SPDX-License-Identifier: MIT\n```\n\n6.  File: src/interfaces/IAxelarGateway.sol (line [0](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/interfaces/IAxelarGateway.sol#L0))\n\n```solidity\n// SPDX-License-Identifier: MIT\n```\n\n7.  File: src/interfaces/IAxelarGatewayMultisig.sol (line [0](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/interfaces/IAxelarGatewayMultisig.sol#L0))\n\n```solidity\n// SPDX-License-Identifier: MIT\n```\n\n8.  File: src/interfaces/IERC20BurnFrom.sol (line [0](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/interfaces/IERC20BurnFrom.sol#L0))\n\n```solidity\n// SPDX-License-Identifier: MIT\n```\n\n9.  File: src/interfaces/IAxelarExecutable.sol (line [0](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/interfaces/IAxelarExecutable.sol#L0))\n\n```solidity\n// SPDX-License-Identifier: MIT\n```\n\n10. File: src/MintableCappedERC20.sol (line [0](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/MintableCappedERC20.sol#L0))\n\n```solidity\n// SPDX-License-Identifier: MIT\n```\n\n11. File: src/ERC20Permit.sol (line [0](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/ERC20Permit.sol#L0))\n\n```solidity\n// SPDX-License-Identifier: MIT\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-04-axelar",
  "Code": [
    {
      "filename": "src/AdminMultisigBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { EternalStorage } from './EternalStorage.sol';\n\ncontract AdminMultisigBase is EternalStorage {\n    error NotAdmin();\n    error AlreadyVoted();\n    error InvalidAdmins();\n    error InvalidAdminThreshold();\n    error DuplicateAdmin(address admin);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    // AUDIT: constants should be literal and their derivation should be in comments\n    bytes32 internal constant KEY_ADMIN_EPOCH = keccak256('admin-epoch');\n\n    bytes32 internal constant PREFIX_ADMIN = keccak256('admin');\n    bytes32 internal constant PREFIX_ADMIN_COUNT = keccak256('admin-count');\n    bytes32 internal constant PREFIX_ADMIN_THRESHOLD = keccak256('admin-threshold');\n    bytes32 internal constant PREFIX_ADMIN_VOTE_COUNTS = keccak256('admin-vote-counts');\n    bytes32 internal constant PREFIX_ADMIN_VOTED = keccak256('admin-voted');\n    bytes32 internal constant PREFIX_IS_ADMIN = keccak256('is-admin');\n\n    modifier onlyAdmin() {\n        uint256 adminEpoch = _adminEpoch();\n\n        if (!_isAdmin(adminEpoch, msg.sender)) revert NotAdmin();\n\n        bytes32 topic = keccak256(msg.data);\n\n        // Check that admin has not voted, then record that they have voted.\n        if (_hasVoted(adminEpoch, topic, msg.sender)) revert AlreadyVoted();\n\n        _setHasVoted(adminEpoch, topic, msg.sender, true);\n\n        // Determine the new vote count and update it.\n        uint256 adminVoteCount = _getVoteCount(adminEpoch, topic) + uint256(1);\n        _setVoteCount(adminEpoch, topic, adminVoteCount);\n\n        // Do not proceed with operation execution if insufficient votes.\n        if (adminVoteCount < _getAdminThreshold(adminEpoch)) return;\n\n        _;\n\n        // Clear vote count and voted booleans.\n        _setVoteCount(adminEpoch, topic, uint256(0));\n\n        uint256 adminCount = _getAdminCount(adminEpoch);\n\n        for (uint256 i; i < adminCount; i++) {\n            _setHasVoted(adminEpoch, topic, _getAdmin(adminEpoch, i), false);\n        }\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getAdminKey(uint256 adminEpoch, uint256 index) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN, adminEpoch, index));\n    }\n\n    function _getAdminCountKey(uint256 adminEpoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_COUNT, adminEpoch));\n    }\n\n    function _getAdminThresholdKey(uint256 adminEpoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_THRESHOLD, adminEpoch));\n    }\n\n    function _getAdminVoteCountsKey(uint256 adminEpoch, bytes32 topic) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTE_COUNTS, adminEpoch, topic));\n    }\n\n    function _getAdminVotedKey(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTED, adminEpoch, topic, account));\n    }\n\n    function _getIsAdminKey(uint256 adminEpoch, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_IS_ADMIN, adminEpoch, account));\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function _adminEpoch() internal view returns (uint256) {\n        return getUint(KEY_ADMIN_EPOCH);\n    }\n\n    function _getAdmin(uint256 adminEpoch, uint256 index) internal view returns (address) {\n        return getAddress(_getAdminKey(adminEpoch, index));\n    }\n\n    function _getAdminCount(uint256 adminEpoch) internal view returns (uint256) {\n        return getUint(_getAdminCountKey(adminEpoch));\n    }\n\n    function _getAdminThreshold(uint256 adminEpoch) internal view returns (uint256) {\n        return getUint(_getAdminThresholdKey(adminEpoch));\n    }\n\n    function _getVoteCount(uint256 adminEpoch, bytes32 topic) internal view returns (uint256) {\n        return getUint(_getAdminVoteCountsKey(adminEpoch, topic));\n    }\n\n    function _hasVoted(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account\n    ) internal view returns (bool) {\n        return getBool(_getAdminVotedKey(adminEpoch, topic, account));\n    }\n\n    function _isAdmin(uint256 adminEpoch, address account) internal view returns (bool) {\n        return getBool(_getIsAdminKey(adminEpoch, account));\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    function _setAdminEpoch(uint256 adminEpoch) internal {\n        _setUint(KEY_ADMIN_EPOCH, adminEpoch);\n    }\n\n    function _setAdmin(\n        uint256 adminEpoch,\n        uint256 index,\n        address account\n    ) internal {\n        _setAddress(_getAdminKey(adminEpoch, index), account);\n    }\n\n    function _setAdminCount(uint256 adminEpoch, uint256 adminCount) internal {\n        _setUint(_getAdminCountKey(adminEpoch), adminCount);\n    }\n\n    function _setAdmins(\n        uint256 adminEpoch,\n        address[] memory accounts,\n        uint256 threshold\n    ) internal {\n        uint256 adminLength = accounts.length;\n\n        if (adminLength < threshold) revert InvalidAdmins();\n\n        if (threshold == uint256(0)) revert InvalidAdminThreshold();\n\n        _setAdminThreshold(adminEpoch, threshold);\n        _setAdminCount(adminEpoch, adminLength);\n\n        for (uint256 i; i < adminLength; i++) {\n            address account = accounts[i];\n\n            // Check that the account wasn't already set as an admin for this epoch.\n            if (_isAdmin(adminEpoch, account)) revert DuplicateAdmin(account);\n\n            // Set this account as the i-th admin in this epoch (needed to we can clear topic votes in `onlyAdmin`).\n            _setAdmin(adminEpoch, i, account);\n            _setIsAdmin(adminEpoch, account, true);\n        }\n    }\n\n    function _setAdminThreshold(uint256 adminEpoch, uint256 adminThreshold) internal {\n        _setUint(_getAdminThresholdKey(adminEpoch), adminThreshold);\n    }\n\n    function _setVoteCount(\n        uint256 adminEpoch,\n        bytes32 topic,\n        uint256 voteCount\n    ) internal {\n        _setUint(_getAdminVoteCountsKey(adminEpoch, topic), voteCount);\n    }\n\n    function _setHasVoted(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account,\n        bool voted\n    ) internal {\n        _setBool(_getAdminVotedKey(adminEpoch, topic, account), voted);\n    }\n\n    function _setIsAdmin(\n        uint256 adminEpoch,\n        address account,\n        bool isAdmin\n    ) internal {\n        _setBool(_getIsAdminKey(adminEpoch, account), isAdmin);\n    }\n}"
    },
    {
      "filename": "src/DepositHandler.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ncontract DepositHandler {\n    uint256 internal constant IS_NOT_LOCKED = uint256(0);\n    uint256 internal constant IS_LOCKED = uint256(1);\n\n    uint256 internal _lockedStatus = IS_NOT_LOCKED;\n\n    modifier noReenter() {\n        require(_lockedStatus == IS_NOT_LOCKED);\n\n        _lockedStatus = IS_LOCKED;\n        _;\n        _lockedStatus = IS_NOT_LOCKED;\n    }\n\n    function execute(address callee, bytes calldata data)\n        external\n        noReenter\n        returns (bool success, bytes memory returnData)\n    {\n        (success, returnData) = callee.call(data);\n    }\n\n    function destroy(address etherDestination) external noReenter {\n        selfdestruct(payable(etherDestination));\n    }\n}"
    },
    {
      "filename": "src/BurnableMintableCappedERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { MintableCappedERC20 } from './MintableCappedERC20.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { EternalStorage } from './EternalStorage.sol';\n\ncontract BurnableMintableCappedERC20 is MintableCappedERC20 {\n    // keccak256('token-frozen')\n    bytes32 private constant PREFIX_TOKEN_FROZEN =\n        bytes32(0x1a7261d3a36c4ce4235d10859911c9444a6963a3591ec5725b96871d9810626b);\n\n    // keccak256('all-tokens-frozen')\n    bytes32 private constant KEY_ALL_TOKENS_FROZEN =\n        bytes32(0x75a31d1ce8e5f9892188befc328d3b9bd3fa5037457e881abc21f388471b8d96);\n\n    event Frozen(address indexed owner);\n    event Unfrozen(address indexed owner);\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        uint256 capacity\n    ) MintableCappedERC20(name, symbol, decimals, capacity) {}\n\n    function depositAddress(bytes32 salt) public view returns (address) {\n        /* Convert a hash which is bytes32 to an address which is 20-byte long\n        according to https://docs.soliditylang.org/en/v0.8.1/control-structures.html?highlight=create2#salted-contract-creations-create2 */\n        return\n            address(\n                uint160(\n                    uint256(\n                        keccak256(\n                            abi.encodePacked(\n                                bytes1(0xff),\n                                owner,\n                                salt,\n                                keccak256(abi.encodePacked(type(DepositHandler).creationCode))\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    function burn(bytes32 salt) public onlyOwner {\n        address account = depositAddress(salt);\n        _burn(account, balanceOf[account]);\n    }\n\n    function _beforeTokenTransfer(\n        address,\n        address,\n        uint256\n    ) internal view override {\n        require(!EternalStorage(owner).getBool(KEY_ALL_TOKENS_FROZEN), 'IS_FROZEN');\n        require(!EternalStorage(owner).getBool(keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol))), 'IS_FROZEN');\n    }\n}"
    },
    {
      "filename": "src/Ownable.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nabstract contract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, 'NOT_OWNER');\n        _;\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), 'ZERO_ADDR');\n\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}"
    },
    {
      "filename": "src/TokenDeployer.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { BurnableMintableCappedERC20 } from './BurnableMintableCappedERC20.sol';\n\ncontract TokenDeployer {\n    function deployToken(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        uint256 cap,\n        bytes32 salt\n    ) external returns (address tokenAddress) {\n        tokenAddress = address(new BurnableMintableCappedERC20{ salt: salt }(name, symbol, decimals, cap));\n    }\n}"
    },
    {
      "filename": "src/interfaces/IAxelarGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IAxelarGateway {\n    /**********\\\n    |* Events *|\n    \\**********/\n\n    event TokenSent(\n        address indexed sender,\n        string destinationChain,\n        string destinationAddress,\n        string symbol,\n        uint256 amount\n    );\n\n    event ContractCall(\n        address indexed sender,\n        string destinationChain,\n        string destinationContractAddress,\n        bytes32 indexed payloadHash,\n        bytes payload\n    );\n\n    event ContractCallWithToken(\n        address indexed sender,\n        string destinationChain,\n        string destinationContractAddress,\n        bytes32 indexed payloadHash,\n        bytes payload,\n        string symbol,\n        uint256 amount\n    );\n\n    event Executed(bytes32 indexed commandId);\n\n    event TokenDeployed(string symbol, address tokenAddresses);\n\n    event ContractCallApproved(\n        bytes32 indexed commandId,\n        string sourceChain,\n        string sourceAddress,\n        address indexed contractAddress,\n        bytes32 indexed payloadHash,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    );\n\n    event ContractCallApprovedWithMint(\n        bytes32 indexed commandId,\n        string sourceChain,\n        string sourceAddress,\n        address indexed contractAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    );\n\n    event TokenFrozen(string symbol);\n\n    event TokenUnfrozen(string symbol);\n\n    event AllTokensFrozen();\n\n    event AllTokensUnfrozen();\n\n    event AccountBlacklisted(address indexed account);\n\n    event AccountWhitelisted(address indexed account);\n\n    event Upgraded(address indexed implementation);\n\n    /******************\\\n    |* Public Methods *|\n    \\******************/\n\n    function sendToken(\n        string memory destinationChain,\n        string memory destinationAddress,\n        string memory symbol,\n        uint256 amount\n    ) external;\n\n    function callContract(\n        string memory destinationChain,\n        string memory contractAddress,\n        bytes memory payload\n    ) external;\n\n    function callContractWithToken(\n        string memory destinationChain,\n        string memory contractAddress,\n        bytes memory payload,\n        string memory symbol,\n        uint256 amount\n    ) external;\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view returns (bool);\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) external view returns (bool);\n\n    function validateContractCall(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        bytes32 payloadHash\n    ) external returns (bool);\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) external returns (bool);\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function allTokensFrozen() external view returns (bool);\n\n    function implementation() external view returns (address);\n\n    function tokenAddresses(string memory symbol) external view returns (address);\n\n    function tokenFrozen(string memory symbol) external view returns (bool);\n\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\n\n    function adminEpoch() external view returns (uint256);\n\n    function adminThreshold(uint256 epoch) external view returns (uint256);\n\n    function admins(uint256 epoch) external view returns (address[] memory);\n\n    /*******************\\\n    |* Admin Functions *|\n    \\*******************/\n\n    function freezeToken(string memory symbol) external;\n\n    function unfreezeToken(string memory symbol) external;\n\n    function freezeAllTokens() external;\n\n    function unfreezeAllTokens() external;\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external;\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    function setup(bytes calldata params) external;\n\n    function execute(bytes calldata input) external;\n}"
    },
    {
      "filename": "src/interfaces/IAxelarGatewayMultisig.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './IAxelarGateway.sol';\n\ninterface IAxelarGatewayMultisig is IAxelarGateway {\n    event OwnershipTransferred(address[] preOwners, uint256 prevThreshold, address[] newOwners, uint256 newThreshold);\n\n    event OperatorshipTransferred(\n        address[] preOperators,\n        uint256 prevThreshold,\n        address[] newOperators,\n        uint256 newThreshold\n    );\n\n    function ownerEpoch() external view returns (uint256);\n\n    function ownerThreshold(uint256 epoch) external view returns (uint256);\n\n    function owners(uint256 epoch) external view returns (address[] memory);\n\n    function operatorEpoch() external view returns (uint256);\n\n    function operatorThreshold(uint256 epoch) external view returns (uint256);\n\n    function operators(uint256 epoch) external view returns (address[] memory);\n}"
    },
    {
      "filename": "src/interfaces/IERC20BurnFrom.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IERC20BurnFrom {\n    function burnFrom(address account, uint256 amount) external;\n}"
    },
    {
      "filename": "src/interfaces/IAxelarExecutable.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './IAxelarGateway.sol';\n\nabstract contract IAxelarExecutable {\n    error NotApprovedByGateway();\n\n    IAxelarGateway public gateway;\n\n    constructor(address gateway_) {\n        gateway = IAxelarGateway(gateway_);\n    }\n\n    function execute(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        bytes calldata payload\n    ) external {\n        bytes32 payloadHash = keccak256(payload);\n        if (!IAxelarGateway(gateway).validateContractCall(commandId, sourceChain, sourceAddress, payloadHash))\n            revert NotApprovedByGateway();\n        _execute(sourceChain, sourceAddress, payload);\n    }\n\n    function executeWithToken(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        bytes calldata payload,\n        string memory tokenSymbol,\n        uint256 amount\n    ) external {\n        bytes32 payloadHash = keccak256(payload);\n        if (\n            !IAxelarGateway(gateway).validateContractCallAndMint(\n                commandId,\n                sourceChain,\n                sourceAddress,\n                payloadHash,\n                tokenSymbol,\n                amount\n            )\n        ) revert NotApprovedByGateway();\n\n        _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\n    }\n\n    function _getTokenAddress(string memory tokenSymbol) internal view returns (address) {\n        return IAxelarGateway(gateway).tokenAddresses(tokenSymbol);\n    }\n\n    function _execute(\n        string memory sourceChain,\n        string memory sourceAddress,\n        bytes calldata payload\n    ) internal virtual {}\n\n    function _executeWithToken(\n        string memory sourceChain,\n        string memory sourceAddress,\n        bytes calldata payload,\n        string memory tokenSymbol,\n        uint256 amount\n    ) internal virtual {}\n}"
    },
    {
      "filename": "src/MintableCappedERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IERC20BurnFrom } from './interfaces/IERC20BurnFrom.sol';\n\nimport { ERC20 } from './ERC20.sol';\nimport { ERC20Permit } from './ERC20Permit.sol';\nimport { Ownable } from './Ownable.sol';\n\ncontract MintableCappedERC20 is ERC20, ERC20Permit, Ownable, IERC20BurnFrom {\n    uint256 public cap;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        uint256 capacity\n    ) ERC20(name, symbol, decimals) ERC20Permit(name) Ownable() {\n        cap = capacity;\n    }\n\n    function mint(address account, uint256 amount) public onlyOwner {\n        uint256 capacity = cap;\n        require(capacity == 0 || totalSupply + amount <= capacity, 'CAP_EXCEEDED');\n\n        _mint(account, amount);\n    }\n\n    // TODO move burnFrom into a separate BurnableERC20 contract\n    function burnFrom(address account, uint256 amount) external onlyOwner {\n        _approve(account, owner, allowance[account][owner] - amount);\n        _burn(account, amount);\n    }\n}"
    },
    {
      "filename": "src/ERC20Permit.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { ERC20 } from './ERC20.sol';\n\nabstract contract ERC20Permit is ERC20 {\n    bytes32 public DOMAIN_SEPARATOR;\n\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = '\\x19\\x01';\n\n    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n    bytes32 private constant DOMAIN_TYPE_SIGNATURE_HASH =\n        bytes32(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f);\n\n    // keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)')\n    bytes32 private constant PERMIT_SIGNATURE_HASH =\n        bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9);\n\n    mapping(address => uint256) public nonces;\n\n    constructor(string memory name) {\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                DOMAIN_TYPE_SIGNATURE_HASH,\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function permit(\n        address issuer,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp < deadline, 'EXPIRED');\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'INV_S');\n        require(v == 27 || v == 28, 'INV_V');\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_SIGNATURE_HASH, issuer, spender, value, nonces[issuer]++, deadline))\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress == issuer, 'INV_SIG');\n\n        // _approve will revert if issuer is address(0x0)\n        _approve(issuer, spender, value);\n    }\n}"
    }
  ]
}