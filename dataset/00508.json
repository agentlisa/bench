{
  "Title": "Signature issues in KintoID and Faucet",
  "Content": "##### Description\n\n* https://github.com/KintoXYZ/kinto-core/blob/f7dd98f66b9dfba1f73758703b808051196e740b/src/KintoID.sol#L371-L399\n* https://github.com/KintoXYZ/kinto-core/blob/f7dd98f66b9dfba1f73758703b808051196e740b/src/Faucet.sol#L90-L114\n\nIn the current implementation, it is assumed that a KYC node can issue a user a KintoID and cannot burn it unless the user signs such a transaction. Incorrect handling of nonces and non-standard construction of the hash for signature lead to the situation where a node with the KYC_PROVIDER_ROLE can at any time burn a user's KintoID.\n\nThe `SignatureData` struct has fields `signer` and `account`. Signer is the one who makes the signature. Account is the one to whom the KintoID is issued. The minting and burning functions check the signature of the following structure:\n```\nkeccak256(\n    abi.encodePacked(\n    '\\x19\\x01',   // EIP-191 header\n    keccak256(abi.encode(\n        _signature.signer,\n        address(this),\n        _signature.account,\n        _id,\n        _signature.expiresAt,\n        nonces[_signature.signer],\n        bytes32(block.chainid)\n    ))\n    )\n)\n```\n\nIt can be noticed that `nonces[_signature.signer]` is hashed. However, after the signature check, `nonces[_signature.account]` is increased, which is incorrect.\n\nFurthermore, in building the hash, the name of the function for which the signature is given is missing. This allows the same signature to be used to call any of the functions, such as `mintIndividualKyc()`, as well as `burnKYC()`.\n\nAs the nonce for the signature effectively does not change, the KYC node can subsequently use the same signature that was applied for the `mintIndividualKyc()` function to burn the KintoID through `burnKYC()`.\n\nIt should be noted that similar problems are present in the Faucet contract.\n\n##### Recommendation\n\nWe recommend increasing the nonce of the signer; revisiting the logic when signer and account does not match; and also adding the function signature into the hash for which the signature is given.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/KintoID.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n/* External Imports */\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {SignatureChecker} from '@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/structs/BitMapsUpgradeable.sol';\nimport {IKintoID} from './interfaces/IKintoID.sol';\n\n// import \"forge-std/console2.sol\";\n\n\n/**\n * @title Kinto ID\n * @dev The Kinto ID predeploy provides an interface to access all the ID functionality from the L2.\n */\ncontract KintoID is Initializable,\n    ERC1155Upgradeable, AccessControlUpgradeable, ERC1155SupplyUpgradeable, UUPSUpgradeable, IKintoID {\n    using BitMapsUpgradeable for BitMapsUpgradeable.BitMap;\n    using ECDSAUpgradeable for bytes32;\n    using SignatureChecker for address;\n\n    /* ============ Events ============ */\n    event TraitAdded(address indexed _to, uint16 _traitIndex, uint256 _timestamp);\n    event TraitRemoved(address indexed _to, uint16 _traitIndex, uint256 _timestamp);\n    event SanctionAdded(address indexed _to, uint16 _sanctionIndex, uint256 _timestamp);\n    event SanctionRemoved(address indexed _to, uint16 _sanctionIndex, uint256 _timestamp);\n    event AccountsMonitoredAt(address indexed _signer, uint256 _accountsCount, uint256 _timestamp);\n\n    /* ============ Constants ============ */\n    bytes32 public override constant KYC_PROVIDER_ROLE = keccak256('KYC_PROVIDER_ROLE');\n    bytes32 public override constant UPGRADER_ROLE = keccak256('UPGRADER_ROLE');\n\n    uint8 public override constant KYC_TOKEN_ID = 1;\n\n    // We'll monitor the whole list every single day and update it\n    uint256 public override lastMonitoredAt;\n\n    /* ============ State Variables ============ */\n\n    // Metadata for each minted token\n    mapping(address => IKintoID.Metadata) private _kycmetas;\n\n    /// @dev We include a nonce in every hashed message, and increment the nonce as part of a\n    /// state-changing operation, so as to prevent replay attacks, i.e. the reuse of a signature.\n    mapping(address => uint256) public override nonces;\n\n    /* ============ Modifiers ============ */\n\n\n    /* ============ Constructor & Initializers ============ */\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize() initializer public {\n        __ERC1155_init('https://mamorilabs.com/metadata/{id}.json'); // pinata, ipfs\n        __AccessControl_init();\n        __ERC1155Supply_init();\n        __UUPSUpgradeable_init();\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(KYC_PROVIDER_ROLE, msg.sender);\n        _setupRole(UPGRADER_ROLE, msg.sender);\n        lastMonitoredAt = block.timestamp;\n    }\n\n    /**\n     * @dev Authorize the upgrade. Only by the upgrader role.\n     * @param newImplementation address of the new implementation\n     */\n    // This function is called by the proxy contract when the implementation is upgraded\n    function _authorizeUpgrade(address newImplementation) internal onlyRole(UPGRADER_ROLE) override {}\n\n    /* ============ Token name, symbol & URI ============ */\n\n    /**\n     * @dev Gets the token name.\n     * @return string representing the token name\n     */\n    function name() external pure override returns (string memory) {\n        return 'Kinto ID';\n    }\n\n    /**\n     * @dev Gets the token symbol.\n     * @return string representing the token symbol\n     */\n    function symbol() external pure override returns (string memory) {\n        return 'KINID';\n    }\n\n    /**\n     * @dev Sets the token URI. Only by the admin role.\n     * @param newuri representing the token URI.\n     */\n    function setURI(string memory newuri) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setURI(newuri);\n    }\n\n    /* ============ Mint & Burn ============ */\n\n    /**\n     * @dev Mints a new individual KYC token.\n     * @param _signatureData Signature data\n     * @param _traits Traits to be added to the account.\n     */\n    function mintIndividualKyc(IKintoID.SignatureData calldata _signatureData, uint16[] memory _traits)\n        external override {\n        _mintTo(KYC_TOKEN_ID, _signatureData,_traits, true);\n    }\n\n    /**\n     * @dev Mints a new company KYC token.\n     * @param _signatureData Signature data\n     * @param _traits Traits to be added to the account.\n     */\n    function mintCompanyKyc(IKintoID.SignatureData calldata _signatureData, uint16[] memory _traits)\n        external override {\n        _mintTo(KYC_TOKEN_ID, _signatureData, _traits, false);\n    }\n\n    /**\n     * @dev Mints a new token to the given account.\n     * @param _tokenId Token ID to be minted\n     * @param _signatureData Signature data\n     * @param _traits Traits to be added to the account.\n     * @param _indiv Whether the account is individual or a company.\n    */\n    function _mintTo(\n        uint8 _tokenId,\n        IKintoID.SignatureData calldata _signatureData,\n        uint16[] memory _traits,\n        bool _indiv\n    ) private\n      onlySignerVerified(_tokenId, _signatureData) {\n       require(balanceOf(_signatureData.account, _tokenId) == 0, 'Balance before mint must be 0');\n\n       Metadata storage meta = _kycmetas[_signatureData.account];\n       meta.mintedAt = block.timestamp;\n       meta.individual = _indiv;\n\n       for (uint16 i = 0; i < _traits.length; i++) {\n           meta.traits.set(_traits[i]);\n       }\n\n       nonces[_signatureData.account]++;\n       _mint(_signatureData.account, _tokenId, 1, '');\n    }\n\n    /* ============ Burn ============ */\n\n    /**\n     * @dev Burns a KYC token.\n     * @param _signatureData Signature data\n     */\n    function burnKYC(SignatureData calldata _signatureData) external override {\n        _burnp(KYC_TOKEN_ID, _signatureData);\n    }\n\n    /**\n     * @dev Burns a token.\n     * @param _tokenId  token ID to be burned\n     * @param _signatureData Signature data\n     */\n    function _burnp(\n        uint256 _tokenId,\n        SignatureData calldata _signatureData\n    ) private onlySignerVerified(_tokenId, _signatureData) {\n        require(balanceOf(_signatureData.account, _tokenId) > 0, 'Nothing to burn');\n        nonces[_signatureData.account] += 1;\n        _burn(_signatureData.account, _tokenId, 1);\n        require(balanceOf(_signatureData.account, _tokenId) == 0, 'Balance after burn must be 0');\n    }\n\n    /* ============ Sanctions & traits ============ */\n\n    /**\n     * @dev Monitors the account. Only by the KYC provider role.\n     */\n    function monitor(\n        address[] memory _accounts,\n        IKintoID.MonitorUpdateData[][] memory _traitsAndSanctions\n    ) external override onlyRole(KYC_PROVIDER_ROLE) {\n        require(_accounts.length == _traitsAndSanctions.length, 'Length mismatch');\n        require(_accounts.length <= 200, 'Too many accounts to monitor at once');\n        for (uint8 i = 0; i < _accounts.length; i+= 1) {\n            require(balanceOf(_accounts[i], 1) > 0, 'Invalid account address');\n            Metadata storage meta = _kycmetas[_accounts[i]];\n            meta.updatedAt = block.timestamp;\n            for (uint16 j = 0; j < _traitsAndSanctions[i].length; j+= 1) {\n                IKintoID.MonitorUpdateData memory updateData = _traitsAndSanctions[i][j];\n                if (updateData.isTrait && updateData.isSet) {\n                    addTrait(_accounts[i], updateData.index);\n                } else if (updateData.isTrait && !updateData.isSet) {\n                    removeTrait(_accounts[i], updateData.index);\n                } else if (!updateData.isTrait && updateData.isSet) {\n                    addSanction(_accounts[i], updateData.index);\n                } else {\n                    removeSanction(_accounts[i], updateData.index);\n                }\n            }\n        }\n        lastMonitoredAt = block.timestamp;\n        emit AccountsMonitoredAt(msg.sender, _accounts.length, block.timestamp);\n    }\n\n    /**\n     * @dev Adds a trait to the account. Only by the KYC provider role.\n     * @param _account  account to be added the trait to.\n     * @param _traitId trait id to be added.\n     */\n    function addTrait(address _account, uint16 _traitId) public override onlyRole(KYC_PROVIDER_ROLE) {\n        Metadata storage meta = _kycmetas[_account];\n        if (!meta.traits.get(_traitId)) {\n          meta.traits.set(_traitId);\n          meta.updatedAt = block.timestamp;\n          emit TraitAdded(_account, _traitId, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Removes a trait from the account. Only by the KYC provider role.\n     * @param _account  account to be removed the trait from.\n     * @param _traitId trait id to be removed.\n     */\n    function removeTrait(address _account, uint16 _traitId) public override onlyRole(KYC_PROVIDER_ROLE) {\n        Metadata storage meta = _kycmetas[_account];\n\n        if (meta.traits.get(_traitId)) {\n            meta.traits.unset(_traitId);\n            meta.updatedAt = block.timestamp;\n            emit TraitRemoved(_account, _traitId, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Adds a sanction to the account. Only by the KYC provider role.\n     * @param _account  account to be added the sanction to.\n     * @param _countryId country id to be added.\n     */\n    function addSanction(address _account, uint16 _countryId) public override onlyRole(KYC_PROVIDER_ROLE) {\n        Metadata storage meta = _kycmetas[_account];\n        if (!meta.sanctions.get(_countryId)) {\n            meta.sanctions.set(_countryId);\n            meta.sanctionsCount += 1;\n            meta.updatedAt = block.timestamp;\n            emit SanctionAdded(_account, _countryId, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Removes a sanction from the account. Only by the KYC provider role.\n     * @param _account  account to be removed the sanction from.\n     * @param _countryId country id to be removed.\n     */\n    function removeSanction(address _account, uint16 _countryId) public override onlyRole(KYC_PROVIDER_ROLE) {\n        Metadata storage meta = _kycmetas[_account];\n        if (meta.sanctions.get(_countryId)) {\n            meta.sanctions.unset(_countryId);\n            meta.sanctionsCount -= 1;\n            meta.updatedAt = block.timestamp;\n            emit SanctionRemoved(_account, _countryId, block.timestamp);\n        }\n    }\n\n    /* ============ View Functions ============ */\n\n    /**\n     * @dev Returns whether the account holder is KYCd\n     * @param _account account to be checked.\n     * @return true if the account has KYC token.\n     */\n    function isKYC(address _account) external view override returns (bool) {\n        return balanceOf(_account, KYC_TOKEN_ID) > 0 && isSanctionsSafe(_account);\n    }\n\n    /**\n     * @dev Returns whether the account has been monitored in the last x days.\n     * @param _days Days to be checked.\n     * @return true if the account has been monitored in the last x days.\n    */\n    function isSanctionsMonitored(uint32 _days) public view override returns(bool) {\n        return block.timestamp - lastMonitoredAt < _days * (1 days);\n    }\n\n    /**\n     * @dev Returns whether the account is sanctions safe.\n     * @param _account account to be checked.\n     * @return true if the account is sanctions safe.\n     */\n    function isSanctionsSafe(address _account) public view override returns (bool) {\n        return isSanctionsMonitored(7) && _kycmetas[_account].sanctionsCount == 0;\n    }\n\n    /**\n     * @dev Returns whether the account is sanctions safe in a given country.\n     * @param _account account to be checked.\n     * @param _countryId country id to be checked.\n     * @return true if the account is sanctions safe in a given country.\n     */\n    function isSanctionsSafeIn(address _account, uint16 _countryId) external view override returns (bool) {\n        return isSanctionsMonitored(7) && !_kycmetas[_account].sanctions.get(_countryId);\n    }\n\n    /**\n     * @dev Returns whether the KYC account is a company\n     * @param _account account to be checked.\n     * @return true if the account is a company.\n     */\n    function isCompany(address _account) external view override returns (bool) {\n        return !_kycmetas[_account].individual;\n    }\n\n    /**\n     * @dev Returns whether the KYC account is an individual\n     * @param _account account to be checked.\n     * @return true if the account is an indivdual.\n     */\n    function isIndividual(address _account) external view override returns (bool) {\n        return _kycmetas[_account].individual;\n    }\n\n    /**\n     * @dev Returns the timestamp when the KYC token was minted\n     * @param _account account to be checked.\n     * @return timestamp when the KYC token was minted.\n     */\n    function mintedAt(address _account) external view override returns (uint256) {\n        return _kycmetas[_account].mintedAt;\n    }\n\n    /**\n     * @dev Returns whether the account has a given trait.\n     * @param _account account to be checked.\n     * @param index index of the trait to be checked.\n     * @return true if the account has the trait.\n     */\n    function hasTrait(address _account, uint16 index) external view override returns (bool) {\n        return _kycmetas[_account].traits.get(index);\n    }\n\n    /**\n     * @dev Returns an array of 256 booleans representing the traits of the account.\n     * @param _account account to be checked.\n     * @return array of 256 booleans representing the traits of the account.\n     */\n    function traits(address _account) external view override returns (bool[] memory) {\n        BitMapsUpgradeable.BitMap storage tokenTraits = _kycmetas[_account].traits;\n        bool[] memory result = new bool[](256);\n        for (uint256 i = 0; i < 256; i++) {\n            result[i] = tokenTraits.get(i);\n        }\n        return result;\n    }\n\n    /* ============ Signature Recovery ============ */\n\n    /**\n     * @dev Check that the signature is valid and the sender is a valid KYC provider.\n     * @param _id id of the token to be signed.\n     * @param _signature signature to be recovered.\n     */\n    modifier onlySignerVerified(\n      uint256 _id,\n      IKintoID.SignatureData calldata _signature\n    ) {\n        require(block.timestamp < _signature.expiresAt, 'Signature has expired');\n        require(nonces[_signature.signer] == _signature.nonce, 'Invalid Nonce');\n        require(hasRole(KYC_PROVIDER_ROLE, msg.sender), 'Invalid Provider');\n\n        bytes32 hash = keccak256(\n          abi.encodePacked(\n            '\\x19\\x01',   // EIP-191 header\n            keccak256(abi.encode(\n                _signature.signer,\n                address(this),\n                _signature.account,\n                _id,\n                _signature.expiresAt,\n                nonces[_signature.signer],\n                bytes32(block.chainid)\n            ))\n          )\n        ).toEthSignedMessageHash();\n\n        require(\n          _signature.signer.isValidSignatureNow(hash, _signature.signature),\n          'Invalid Signer'\n        );\n        _;\n    }\n\n    /* ============ Disable token transfers ============ */\n\n    /**\n     * @dev Hook that is called before any token transfer. Allow only mints and burns, no transfers.\n     * @param operator address which called `safeTransferFrom` function\n     * @param from source address\n     * @param to target address\n     * @param ids ids of the token type\n     * @param amounts transfer amounts\n     * @param data additional data with no specified format\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal override(ERC1155Upgradeable, ERC1155SupplyUpgradeable) {\n        require(\n          (from == address(0) && to != address(0)) || (from != address(0) && to == address(0)),\n          'Only mint or burn transfers are allowed'\n        );\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    /* ============ Interface ============ */\n\n    /**\n     * @dev Returns whether the contract implements the interface defined by the id\n     * @param interfaceId id of the interface to be checked.\n     * @return true if the contract implements the interface defined by the id.\n    */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view override(ERC1155Upgradeable, AccessControlUpgradeable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}"
    },
    {
      "filename": "src/Faucet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport {IFaucet} from './interfaces/IFaucet.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\nimport {SignatureChecker} from '@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol';\n\n/**\n * @title Faucet\n * @dev The Kinto Faucet gives a bit of ETH to users to pay for gas fees\n */\ncontract Faucet is Ownable, IFaucet{\n    using ECDSA for bytes32;\n    using SignatureChecker for address;\n\n    /* ============ Events ============ */\n    event Claim(address indexed _to, uint256 _timestamp);\n\n    /* ============ Constants ============ */\n    uint public constant CLAIM_AMOUNT = 1 ether / 200;\n    uint public constant FAUCET_AMOUNT = 1 ether;\n\n    /* ============ State Variables ============ */\n    mapping(address => bool) public override claimed;\n    bool public active;\n\n    /// @dev We include a nonce in every hashed message, and increment the nonce as part of a\n    /// state-changing operation, so as to prevent replay attacks, i.e. the reuse of a signature.\n    mapping(address => uint256) public override nonces;\n\n    constructor(){}\n\n    /**\n    * @dev Allows users to claim KintoETH from the smart contract's faucet once per account\n    */\n    function claimKintoETH() external override {\n        _privateClaim(msg.sender);\n    }\n\n    /**\n     * @dev Claim via meta tx on behalf of a new account by the owner\n     * @param _signatureData Signature data\n    */\n    function claimOnBehalf(IFaucet.SignatureData calldata _signatureData) external\n      onlyOwner onlySignerVerified(_signatureData) {\n       _privateClaim(_signatureData.account);\n       nonces[_signatureData.account]++;\n    }\n\n    /**\n    * @dev Function to withdraw all eth by owner\n    */\n    function withdrawAll() external override onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    /**\n    * @dev Function to start the faucet\n    */\n    function startFaucet() payable external override onlyOwner {\n        require(msg.value >= FAUCET_AMOUNT, 'Not enough ETH to start faucet');\n        active = true;\n    }\n\n    /**\n    * @dev Allows the contract to receive Ether\n    */\n    receive() external payable {}\n\n    /* ============ Private functions ============ */\n\n    function _privateClaim(address _receiver) private {\n        require(active, 'Faucet is not active');\n        require(!claimed[_receiver], 'You have already claimed your KintoETH');\n        claimed[_receiver] = true;\n        payable(_receiver).transfer(CLAIM_AMOUNT);\n        if (address(this).balance < CLAIM_AMOUNT) {\n            active = false;\n        }\n        emit Claim(_receiver, block.timestamp);\n    }\n\n    /* ============ Signature Recovery ============ */\n\n    /**\n     * @dev Check that the signature is valid and the address has not claimed yet.\n     * @param _signature signature to be recovered.\n     */\n    modifier onlySignerVerified(\n      IFaucet.SignatureData calldata _signature\n    ) {\n        require(block.timestamp < _signature.expiresAt, 'Signature has expired');\n        require(nonces[_signature.signer] == _signature.nonce, 'Invalid Nonce');\n        require(owner() == msg.sender, 'Invalid Sender');\n        bytes32 hash = keccak256(\n          abi.encodePacked(\n            '\\x19\\x01',   // EIP-191 header\n            keccak256(abi.encode(\n                _signature.signer,\n                address(this),\n                _signature.account,\n                _signature.expiresAt,\n                nonces[_signature.signer],\n                bytes32(block.chainid)\n            ))\n          )\n        ).toEthSignedMessageHash();\n\n        require(\n          _signature.signer.isValidSignatureNow(hash, _signature.signature),\n          'Invalid Signer'\n        );\n        _;\n    }\n}"
    }
  ]
}