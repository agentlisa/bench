{
  "Title": "[G-16] Refactor modifier to avoid two external calls when calling `setPublicSuffixList`",
  "Content": "The `onlyOwner` modifier performs two external calls. In order to avoid these two calls everytime `setPublicSufficList` is called, we can perform these two calls in the constructor and create immutable variables for the return values.\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/DNSRegistrar.sol#L73-L78\n\n```solidity\nFile: contracts/dnsregistrar/DNSRegistrar.sol\n73:    modifier onlyOwner() {\n74:        Root root = Root(ens.owner(bytes32(0)));\n75:        address owner = root.owner();\n76:        require(msg.sender == owner);\n77:        _;\n78:    }\n```\n```diff\ndiff --git a/contracts/dnsregistrar/DNSRegistrar.sol b/contracts/dnsregistrar/DNSRegistrar.sol\nindex 953a9a3..3779292 100644\n--- a/contracts/dnsregistrar/DNSRegistrar.sol\n+++ b/contracts/dnsregistrar/DNSRegistrar.sol\n@@ -28,6 +28,7 @@ contract DNSRegistrar is IDNSRegistrar, IERC165 {\n     PublicSuffixList public suffixes;\n     address public immutable previousRegistrar;\n     address public immutable resolver;\n+    address private immutable rootOwner;\n     // A mapping of the most recent signatures seen for each claimed domain.\n     mapping(bytes32 => uint32) public inceptions;\n\n@@ -65,15 +66,14 @@ contract DNSRegistrar is IDNSRegistrar, IERC165 {\n         suffixes = _suffixes;\n         emit NewPublicSuffixList(address(suffixes));\n         ens = _ens;\n+        rootOwner = Root(_ens.owner(bytes32(0))).owner();\n     }\n\n     /**\n      * @dev This contract's owner-only functions can be invoked by the owner of the ENS root.\n      */\n     modifier onlyOwner() {\n-        Root root = Root(ens.owner(bytes32(0)));\n-        address owner = root.owner();\n-        require(msg.sender == owner);\n+        require(msg.sender == rootOwner);\n         _;\n     }\n```\n\n## `GasReport` output, with all optimizations applied\n```js\n·--------------------------------------------------------|---------------------------|--------------|-----------------------------·\n|                  Solc version: 0.8.17                  ·  Optimizer enabled: true  ·  Runs: 1300  ·  Block limit: 30000000 gas  │\n·························································|···························|··············|······························\n|  Methods                                                                                                                        │\n···························|·····························|·············|·············|··············|···············|··············\n|  Contract                ·  Method                     ·  Min        ·  Max        ·  Avg         ·  # calls      ·  eur (avg)  │\n···························|·····························|·············|·············|··············|···············|··············\n|  DNSRegistrar            ·  proveAndClaim              ·     170611  ·     277955  ·      240737  ·            7  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  DNSRegistrar            ·  proveAndClaimWithResolver  ·     272572  ·     310200  ·      291386  ·            2  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  DNSSECImpl              ·  setAlgorithm               ·      47660  ·      47672  ·       47671  ·           96  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  DNSSECImpl              ·  setDigest                  ·      47703  ·      47727  ·       47726  ·           48  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  ENSRegistry             ·  setOwner                   ·      28697  ·      28721  ·       28719  ·           21  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  ENSRegistry             ·  setResolver                ·      48254  ·      48266  ·       48265  ·          112  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  ENSRegistry             ·  setSubnodeOwner            ·      48998  ·      49394  ·       49319  ·          286  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  ERC20Recoverable        ·  recoverFunds               ·          -  ·          -  ·       35298  ·            1  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  MockERC20               ·  transfer                   ·          -  ·          -  ·       51378  ·            2  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  OwnedResolver           ·  setAddr                    ·      53760  ·      53772  ·       53770  ·            7  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  PublicResolver          ·  setAddr                    ·          -  ·          -  ·       58510  ·           22  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  PublicResolver          ·  setApprovalForAll          ·          -  ·          -  ·       46189  ·            1  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  PublicResolver          ·  setName                    ·          -  ·          -  ·       55359  ·           22  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  PublicResolver          ·  setText                    ·          -  ·          -  ·       57629  ·           22  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  ReverseRegistrar        ·  claim                      ·      60960  ·      60972  ·       60966  ·           44  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  Root                    ·  setController              ·          -  ·          -  ·       47813  ·           30  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  Root                    ·  setSubnodeOwner            ·          -  ·          -  ·       58638  ·            1  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n|  SimplePublicSuffixList  ·  addPublicSuffixes          ·      47573  ·      71045  ·       68810  ·           21  ·          -  │\n···························|·····························|·············|·············|··············|···············|··············\n```\n\n**[Arachnid (ENS) acknowledged](https://github.com/code-423n4/2023-04-ens-findings/issues/220#issuecomment-1536271298)**\n\n\n\n***\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-04-ens",
  "Code": [
    {
      "filename": "contracts/dnsregistrar/DNSRegistrar.sol",
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\nimport \"../dnssec-oracle/BytesUtils.sol\";\nimport \"../dnssec-oracle/DNSSEC.sol\";\nimport \"../dnssec-oracle/RRUtils.sol\";\nimport \"../registry/ENSRegistry.sol\";\nimport \"../root/Root.sol\";\nimport \"../resolvers/profiles/AddrResolver.sol\";\nimport \"./DNSClaimChecker.sol\";\nimport \"./PublicSuffixList.sol\";\nimport \"./IDNSRegistrar.sol\";\n\n/**\n * @dev An ENS registrar that allows the owner of a DNS name to claim the\n *      corresponding name in ENS.\n */\ncontract DNSRegistrar is IDNSRegistrar, IERC165 {\n    using BytesUtils for bytes;\n    using Buffer for Buffer.buffer;\n    using RRUtils for *;\n\n    ENS public immutable ens;\n    DNSSEC public immutable oracle;\n    PublicSuffixList public suffixes;\n    address public immutable previousRegistrar;\n    address public immutable resolver;\n    // A mapping of the most recent signatures seen for each claimed domain.\n    mapping(bytes32 => uint32) public inceptions;\n\n    error NoOwnerRecordFound();\n    error PermissionDenied(address caller, address owner);\n    error PreconditionNotMet();\n    error StaleProof();\n    error InvalidPublicSuffix(bytes name);\n\n    struct OwnerRecord {\n        bytes name;\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    event Claim(\n        bytes32 indexed node,\n        address indexed owner,\n        bytes dnsname,\n        uint32 inception\n    );\n    event NewPublicSuffixList(address suffixes);\n\n    constructor(\n        address _previousRegistrar,\n        address _resolver,\n        DNSSEC _dnssec,\n        PublicSuffixList _suffixes,\n        ENS _ens\n    ) {\n        previousRegistrar = _previousRegistrar;\n        resolver = _resolver;\n        oracle = _dnssec;\n        suffixes = _suffixes;\n        emit NewPublicSuffixList(address(suffixes));\n        ens = _ens;\n    }\n\n    /**\n     * @dev This contract's owner-only functions can be invoked by the owner of the ENS root.\n     */\n    modifier onlyOwner() {\n        Root root = Root(ens.owner(bytes32(0)));\n        address owner = root.owner();\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setPublicSuffixList(PublicSuffixList _suffixes) public onlyOwner {\n        suffixes = _suffixes;\n        emit NewPublicSuffixList(address(suffixes));\n    }\n\n    /**\n     * @dev Submits proofs to the DNSSEC oracle, then claims a name using those proofs.\n     * @param name The name to claim, in DNS wire format.\n     * @param input A chain of signed DNS RRSETs ending with a text record.\n     */\n    function proveAndClaim(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input\n    ) public override {\n        (bytes32 rootNode, bytes32 labelHash, address addr) = _claim(\n            name,\n            input\n        );\n        ens.setSubnodeOwner(rootNode, labelHash, addr);\n    }\n\n    function proveAndClaimWithResolver(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input,\n        address resolver,\n        address addr\n    ) public override {\n        (bytes32 rootNode, bytes32 labelHash, address owner) = _claim(\n            name,\n            input\n        );\n        if (msg.sender != owner) {\n            revert PermissionDenied(msg.sender, owner);\n        }\n        ens.setSubnodeRecord(rootNode, labelHash, owner, resolver, 0);\n        if (addr != address(0)) {\n            if (resolver == address(0)) {\n                revert PreconditionNotMet();\n            }\n            bytes32 node = keccak256(abi.encodePacked(rootNode, labelHash));\n            // Set the resolver record\n            AddrResolver(resolver).setAddr(node, addr);\n        }\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure override returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IDNSRegistrar).interfaceId;\n    }\n\n    function _claim(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input\n    ) internal returns (bytes32 parentNode, bytes32 labelHash, address addr) {\n        (bytes memory data, uint32 inception) = oracle.verifyRRSet(input);\n\n        // Get the first label\n        uint256 labelLen = name.readUint8(0);\n        labelHash = name.keccak(1, labelLen);\n\n        bytes memory parentName = name.substring(\n            labelLen + 1,\n            name.length - labelLen - 1\n        );\n\n        // Make sure the parent name is enabled\n        parentNode = enableNode(parentName);\n\n        bytes32 node = keccak256(abi.encodePacked(parentNode, labelHash));\n        if (!RRUtils.serialNumberGte(inception, inceptions[node])) {\n            revert StaleProof();\n        }\n        inceptions[node] = inception;\n\n        bool found;\n        (addr, found) = DNSClaimChecker.getOwnerAddress(name, data);\n        if (!found) {\n            revert NoOwnerRecordFound();\n        }\n\n        emit Claim(node, addr, name, inception);\n    }\n\n    function enableNode(bytes memory domain) public returns (bytes32 node) {\n        // Name must be in the public suffix list.\n        if (!suffixes.isPublicSuffix(domain)) {\n            revert InvalidPublicSuffix(domain);\n        }\n        return _enableNode(domain, 0);\n    }\n\n    function _enableNode(\n        bytes memory domain,\n        uint256 offset\n    ) internal returns (bytes32 node) {\n        uint256 len = domain.readUint8(offset);\n        if (len == 0) {\n            return bytes32(0);\n        }\n\n        bytes32 parentNode = _enableNode(domain, offset + len + 1);\n        bytes32 label = domain.keccak(offset + 1, len);\n        node = keccak256(abi.encodePacked(parentNode, label));\n        address owner = ens.owner(node);\n        if (owner == address(0) || owner == previousRegistrar) {\n            if (parentNode == bytes32(0)) {\n                Root root = Root(ens.owner(bytes32(0)));\n                root.setSubnodeOwner(label, address(this));\n                ens.setResolver(node, resolver);\n            } else {\n                ens.setSubnodeRecord(\n                    parentNode,\n                    label,\n                    address(this),\n                    resolver,\n                    0\n                );\n            }\n        } else if (owner != address(this)) {\n            revert PreconditionNotMet();\n        }\n        return node;\n    }\n}"
    }
  ]
}