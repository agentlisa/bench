{
  "Title": "ETH Deposits Can Get Stuck if They Are Not Successfully Bridged",
  "Content": "[Pull request #1011](https://github.com/scroll-tech/scroll/pull/1011) introduced the change of [redirecting the calls](https://github.com/scroll-tech/scroll/pull/1011/files#diff-ef2695307fe7f3dfd610ae22338941d20233e19db326322cfca61ad4ceeda1c7) to deposit ETH from the `L1GatewayRouter` contract to the `L1ScrollMessenger` contract without going through the `L1ETHGateway` contract. This was done with the intention of reducing the gas cost associated with such an action.\n\n\nHowever, this causes a problem. Namely, in situations in which a message could not be correctly sent through the bridge, the [dropping and asset-return mechanism](https://github.com/scroll-tech/scroll/blob/45e1305de5f7a1dc5aadadd7d3bb6726a5dee949/contracts/src/L1/L1ScrollMessenger.sol#L262-L311) implemented in the `L1ScrollMessenger` contract will get stuck and the assets will not be able to be paid back. This is due to the lack of the [`onDropMessage` hook](https://github.com/scroll-tech/scroll/blob/45e1305de5f7a1dc5aadadd7d3bb6726a5dee949/contracts/src/L1/L1ScrollMessenger.sol#L308) implementation in the [`L1GatewayRouter` contract](https://github.com/scroll-tech/scroll/blob/45e1305de5f7a1dc5aadadd7d3bb6726a5dee949/contracts/src/L1/gateways/L1GatewayRouter.sol), which serves as a handler to repay the respective origin of the message.\n\n\nFor instance, if a user wants to simply deposit ETH, in both versions they should call the [`depositETH` function](https://github.com/scroll-tech/scroll/blob/45e1305de5f7a1dc5aadadd7d3bb6726a5dee949/contracts/src/L1/gateways/L1GatewayRouter.sol#L206) from the `L1GatewayRouter` contract. The difference lies in [who calls](https://github.com/scroll-tech/scroll/blob/45e1305de5f7a1dc5aadadd7d3bb6726a5dee949/contracts/src/L1/L1ScrollMessenger.sol#L340) and passes the message to the `L1ScrollMessenger` contract. In the former implementation, the [message would come from](https://github.com/scroll-tech/scroll/blob/45e1305de5f7a1dc5aadadd7d3bb6726a5dee949/contracts/src/L1/gateways/L1ETHGateway.sol#L148) the `L1ETHGateway` contract, whereas in the current implementation, the `L1GatewayRouter` will be the [caller](https://github.com/scroll-tech/scroll/blob/45e1305de5f7a1dc5aadadd7d3bb6726a5dee949/contracts/src/L1/gateways/L1GatewayRouter.sol#L226). This is relevant as the `_msgSender` call will then be part of the [`_xDomainCalldata`](https://github.com/scroll-tech/scroll/blob/45e1305de5f7a1dc5aadadd7d3bb6726a5dee949/contracts/src/L1/L1ScrollMessenger.sol#L340) data that will be used to keep track of the message (with its hash) but will also be used in case the message needs [to be dropped](https://github.com/scroll-tech/scroll/blob/45e1305de5f7a1dc5aadadd7d3bb6726a5dee949/contracts/src/L1/L1ScrollMessenger.sol#L308).\n\n\nIn such a dropping scenario, as the address that sent the message to the `L1ScrollMessenger` contract is the one that will be called to execute the `onDropMessage` hook, if such hook is not implemented, the dropping mechanism will fail and the original user will not get their ETH back. This is the same as how it used to happen when routing the call through the `L1ETHGateway` contract. As this does not depend on the data added to the `depositETH` call, those funds will get stuck in case they are not bridged successfully.\n\n\nTo showcase this, one can get inspired by the following [gist](https://gist.github.com/andresbach/5dcd4fff562dc6c72ac713e46136bd27); however, caution should be made when fixing this issue, since the gist's proposed scenario in which the issue resolves is merely an example and it is not meant to represent a fully valid resolution.\n\n\nConsider implementing the `onDropMessage` hook in the `L1GatewayRouter` contract to handle the back payment when dropping messages.\n\n\n***Update:** Resolved in [pull request #1093](https://github.com/scroll-tech/scroll/pull/1093) at commit [`888c3d2`](https://github.com/scroll-tech/scroll/pull/1093/commits/888c3d26b34f217877628b1208ea3473d9836600). The respective contracts have been rolled back to a previous state in which the bypass previously done over the respective ETH gateways is no longer there, and in which the gateway routers have to go through the ETH gateways when depositing/withdrawing ETH.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/L1ScrollMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {IScrollChain} from \"./rollup/IScrollChain.sol\";\nimport {IL1MessageQueue} from \"./rollup/IL1MessageQueue.sol\";\nimport {IL1ScrollMessenger} from \"./IL1ScrollMessenger.sol\";\nimport {ScrollConstants} from \"../libraries/constants/ScrollConstants.sol\";\nimport {IScrollMessenger} from \"../libraries/IScrollMessenger.sol\";\nimport {ScrollMessengerBase} from \"../libraries/ScrollMessengerBase.sol\";\nimport {WithdrawTrieVerifier} from \"../libraries/verifier/WithdrawTrieVerifier.sol\";\n\nimport {IMessageDropCallback} from \"../libraries/callbacks/IMessageDropCallback.sol\";\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable not-rely-on-time\n// solhint-disable reason-string\n\n/// @title L1ScrollMessenger\n/// @notice The `L1ScrollMessenger` contract can:\n///\n/// 1. send messages from layer 1 to layer 2;\n/// 2. relay messages from layer 2 layer 1;\n/// 3. replay failed message by replacing the gas limit;\n/// 4. drop expired message due to sequencer problems.\n///\n/// @dev All deposited Ether (including `WETH` deposited throng `L1WETHGateway`) will locked in\n/// this contract.\ncontract L1ScrollMessenger is ScrollMessengerBase, IL1ScrollMessenger {\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of Rollup contract.\n    address public immutable rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public immutable messageQueue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct ReplayState {\n        // The number of replayed times.\n        uint128 times;\n        // The queue index of lastest replayed one. If it is zero, it means the message has not been replayed.\n        uint128 lastIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L1 message hash to the timestamp when the message is sent.\n    mapping(bytes32 => uint256) public messageSendTimestamp;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to drop status.\n    mapping(bytes32 => bool) public isL1MessageDropped;\n\n    /// @dev The storage slot used as Rollup contract, which is deprecated now.\n    address private __rollup;\n\n    /// @dev The storage slot used as L1MessageQueue contract, which is deprecated now.\n    address private __messageQueue;\n\n    /// @notice The maximum number of times each L1 message can be replayed.\n    uint256 public maxReplayTimes;\n\n    /// @notice Mapping from L1 message hash to replay state.\n    mapping(bytes32 => ReplayState) public replayStates;\n\n    /// @notice Mapping from queue index to previous replay queue index.\n    ///\n    /// @dev If a message `x` was replayed 3 times with index `q1`, `q2` and `q3`, the\n    /// value of `prevReplayIndex` and `replayStates` will be `replayStates[hash(x)].lastIndex = q3`,\n    /// `replayStates[hash(x)].times = 3`, `prevReplayIndex[q3] = q2`, `prevReplayIndex[q2] = q1`,\n    /// `prevReplayIndex[q1] = x` and `prevReplayIndex[x]=nil`.\n    ///\n    /// @dev The index `x` that `prevReplayIndex[x]=nil` is used as the termination of the list.\n    /// Usually we use `0` to represent `nil`, but we cannot distinguish it with the first message\n    /// with index zero. So a nonzero offset `1` is added to the value of `prevReplayIndex[x]` to\n    /// avoid such situation.\n    mapping(uint256 => uint256) public prevReplayIndex;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _counterpart,\n        address _rollup,\n        address _messageQueue\n    ) ScrollMessengerBase(_counterpart) {\n        if (_rollup == address(0) || _messageQueue == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        _disableInitializers();\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n    }\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    ///\n    /// @dev The parameters `_counterpart`, `_rollup` and `_messageQueue` are no longer used.\n    ///\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        ScrollMessengerBase.__ScrollMessengerBase_init(_counterpart, _feeVault);\n\n        __rollup = _rollup;\n        __messageQueue = _messageQueue;\n\n        maxReplayTimes = 3;\n        emit UpdateMaxReplayTimes(0, 3);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _msgSender());\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused notInExecution {\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], \"Message was already successfully executed\");\n\n        {\n            require(IScrollChain(rollup).isBatchFinalized(_proof.batchIndex), \"Batch is not finalized\");\n            bytes32 _messageRoot = IScrollChain(rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                \"Invalid proof\"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, \"Forbid to call message queue\");\n        _validateTargetAddress(_to);\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, \"Invalid message sender\");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused notInExecution {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` on layer 2 to avoid duplicated execution.\n        // So, only one message will succeed on layer 2. If one of the message is executed successfully, the other one\n        // will revert with \"Message was already successfully executed\".\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, \"Provided message has not been enqueued\");\n        // cannot replay dropped message\n        require(!isL1MessageDropped[_xDomainCalldataHash], \"Message already dropped\");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, \"Insufficient msg.value for fee\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // enqueue the new transaction\n        uint256 _nextQueueIndex = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _newGasLimit, _xDomainCalldata);\n\n        ReplayState memory _replayState = replayStates[_xDomainCalldataHash];\n        // update the replayed message chain.\n        unchecked {\n            if (_replayState.lastIndex == 0) {\n                // the message has not been replayed before.\n                prevReplayIndex[_nextQueueIndex] = _messageNonce + 1;\n            } else {\n                prevReplayIndex[_nextQueueIndex] = _replayState.lastIndex + 1;\n            }\n        }\n        _replayState.lastIndex = uint128(_nextQueueIndex);\n\n        // update replay times\n        require(_replayState.times < maxReplayTimes, \"Exceed maximum replay times\");\n        unchecked {\n            _replayState.times += 1;\n        }\n        replayStates[_xDomainCalldataHash] = _replayState;\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function dropMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) external override whenNotPaused notInExecution {\n        // The criteria for dropping a message:\n        // 1. The message is a L1 message.\n        // 2. The message has not been dropped before.\n        // 3. the message and all of its replacement are finalized in L1.\n        // 4. the message and all of its replacement are skipped.\n        //\n        // Possible denial of service attack:\n        // + replayMessage is called every time someone want to drop the message.\n        // + replayMessage is called so many times for a skipped message, thus results a long list.\n        //\n        // We limit the number of `replayMessage` calls of each message, which may solve the above problem.\n\n        // check message exists\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, \"Provided message has not been enqueued\");\n\n        // check message not dropped\n        require(!isL1MessageDropped[_xDomainCalldataHash], \"Message already dropped\");\n\n        // check message is finalized\n        uint256 _lastIndex = replayStates[_xDomainCalldataHash].lastIndex;\n        if (_lastIndex == 0) _lastIndex = _messageNonce;\n\n        // check message is skipped and drop it.\n        // @note If the list is very long, the message may never be dropped.\n        while (true) {\n            IL1MessageQueue(messageQueue).dropCrossDomainMessage(_lastIndex);\n            _lastIndex = prevReplayIndex[_lastIndex];\n            if (_lastIndex == 0) break;\n            unchecked {\n                _lastIndex = _lastIndex - 1;\n            }\n        }\n\n        isL1MessageDropped[_xDomainCalldataHash] = true;\n\n        // set execution context\n        xDomainMessageSender = ScrollConstants.DROP_XDOMAIN_MESSAGE_SENDER;\n        IMessageDropCallback(_from).onDropMessage{value: _value}(_message);\n        // clear execution context\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update max replay times.\n    /// @dev This function can only called by contract owner.\n    /// @param _newMaxReplayTimes The new max replay times.\n    function updateMaxReplayTimes(uint256 _newMaxReplayTimes) external onlyOwner {\n        uint256 _oldMaxReplayTimes = maxReplayTimes;\n        maxReplayTimes = _newMaxReplayTimes;\n\n        emit UpdateMaxReplayTimes(_oldMaxReplayTimes, _newMaxReplayTimes);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_msgSender(), _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, \"Insufficient msg.value\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won't happen, since each message has different nonce, but just in case.\n        require(messageSendTimestamp[_xDomainCalldataHash] == 0, \"Duplicated message\");\n        messageSendTimestamp[_xDomainCalldataHash] = block.timestamp;\n\n        emit SentMessage(_msgSender(), _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/gateways/L1GatewayRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {IL1ScrollMessenger} from \"../IL1ScrollMessenger.sol\";\nimport {IL1ETHGateway} from \"./IL1ETHGateway.sol\";\nimport {IL1ERC20Gateway} from \"./IL1ERC20Gateway.sol\";\nimport {IL1GatewayRouter} from \"./IL1GatewayRouter.sol\";\n\n/// @title L1GatewayRouter\n/// @notice The `L1GatewayRouter` is the main entry for depositing Ether and ERC20 tokens.\n/// All deposited tokens are routed to corresponding gateways.\n/// @dev One can also use this contract to query L1/L2 token address mapping.\n/// In the future, ERC-721 and ERC-1155 tokens will be added to the router too.\ncontract L1GatewayRouter is OwnableUpgradeable, IL1GatewayRouter {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of `L1ScrollMessenger`.\n    address public immutable messenger;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    /// @dev This variable is no longer used.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), \"Only not in context\");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, \"Only in deposit context\");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _messenger) {\n        if (_messenger == address(0)) revert ErrorZeroAddress();\n\n        _disableInitializers();\n\n        messenger = _messenger;\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    ///\n    /// @dev The parameters `_ethGateway` is no longer used.\n    ///\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), \"no gateway available\");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert(\"should never be called\");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        IL1ScrollMessenger(messenger).sendMessage{value: msg.value}(_to, _amount, _data, _gasLimit, _msgSender());\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert(\"should never be called\");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, \"length mismatch\");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}"
    }
  ]
}