{
  "Title": "[G-02] Multiplication and Division by 2 Should use in Bit Shifting",
  "Content": "- Severity: Gas Optimization\n- Confidence: High\n- Total Gas Saved: 40\n\n### Description\nThe expressions `x * 2` and `x / 2` can be optimized for gas efficiency by utilizing bitwise operations. In Solidity, you can achieve the same results by using bitwise left shift (x << 1) for multiplication and bitwise right shift (x >> 1) for division.\n\nUsing bitwise shift operations (SHL and SHR) instead of multiplication (MUL) and division (DIV) opcodes can lead to significant gas savings. The MUL and DIV opcodes cost 5 gas, while the SHL and SHR opcodes incur a lower cost of only 3 gas.\n\nBy leveraging these more efficient bitwise operations, you can reduce the gas consumption of your smart contracts and enhance their overall performance.\n\n<details>\n\n<summary>\nThere are 2 instances of this issue:\n\n</summary>\n\n###\n- File: solidity/contracts/periphery/oracles/CbEthEthOracle.sol\n```\n \nLine: 63          _maxPrice = (2 * _vp * FixedPointMathLib.sqrt(_basePrices)) / 1 ether\n```\n instead `2` use bit shifting `1` \n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/oracles/CbEthEthOracle.sol#L63](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/oracles/CbEthEthOracle.sol#L63)\n\n- File: solidity/contracts/utils/UFragments.sol\n```\n \nLine: 63          uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 1 * 10 ** DECIMALS\n```\n instead `1` use bit shifting `0` \n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/UFragments.sol#L63](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/UFragments.sol#L63)\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-amphora",
  "Code": [
    {
      "filename": "core/solidity/contracts/periphery/oracles/CbEthEthOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IOracleRelay, OracleRelay} from '@contracts/periphery/oracles/OracleRelay.sol';\nimport {IV2Pool} from '@interfaces/utils/ICurvePool.sol';\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\nimport {FixedPointMathLib} from 'solady/utils/FixedPointMathLib.sol';\nimport {CurveRegistryUtils} from '@contracts/periphery/oracles/CurveRegistryUtils.sol';\n\n/// @notice Oracle Relay for the cbETH/ETH pool\ncontract CbEthEthOracle is OracleRelay, CurveRegistryUtils {\n  /// @notice The Curve pool\n  IV2Pool public immutable CB_ETH_POOL;\n\n  /// @notice The oracle relay for the cbETH/ETH price\n  IOracleRelay public immutable CB_ETH_ORACLE_RELAY;\n\n  /// @notice The oracle relay for the ETH/USD price\n  IOracleRelay public immutable ETH_ORACLE_RELAY;\n\n  /// @notice The stored virtual price for the pool\n  uint256 public virtualPrice;\n\n  constructor(\n    address _cbETHPool,\n    IOracleRelay _cbEthOracleRelay,\n    IOracleRelay _ethOracleRelay\n  ) OracleRelay(OracleType.Chainlink) {\n    CB_ETH_POOL = IV2Pool(_cbETHPool);\n\n    CB_ETH_ORACLE_RELAY = _cbEthOracleRelay;\n    ETH_ORACLE_RELAY = _ethOracleRelay;\n\n    _setUnderlying(_getLpAddress(_cbETHPool));\n  }\n\n  /// @notice The current reported value of the oracle\n  /// @dev Implementation in _get\n  /// @return _value The current value\n  function peekValue() public view override returns (uint256 _value) {\n    _value = _get();\n  }\n\n  /// @notice returns the price with 18 decimals\n  /// @return _currentValue the current price\n  function currentValue() external override returns (uint256 _currentValue) {\n    _updateVirtualPrice();\n    _currentValue = _get();\n  }\n\n  /// @notice Calculated the price of 1 LP token\n  /// @dev This function comes from the implementation in vyper\n  /// @return _maxPrice The current value\n  function _get() internal view returns (uint256 _maxPrice) {\n    uint256 _vp = virtualPrice;\n\n    // Get the prices from chainlink and add 10 decimals\n    uint256 _cbEthPrice = CB_ETH_ORACLE_RELAY.peekValue();\n    uint256 _ethPrice = ETH_ORACLE_RELAY.peekValue();\n\n    uint256 _basePrices = (_cbEthPrice * _ethPrice);\n\n    _maxPrice = (2 * _vp * FixedPointMathLib.sqrt(_basePrices)) / 1 ether;\n    // removed discount since the % is so small that it doesn't make a difference\n  }\n\n  /// @notice updates the virtual price for the pool\n  /// @dev this function calls claim_admin_fees to lock the curve pool\n  ///      and prevent reentrancy attacks\n  function _updateVirtualPrice() internal {\n    uint256 _virtualPrice = CB_ETH_POOL.get_virtual_price();\n\n    // We remove claim admin fees on the curve pool locked to avoid any manipulation\n    CB_ETH_POOL.claim_admin_fees();\n\n    virtualPrice = _virtualPrice;\n  }\n}"
    },
    {
      "filename": "core/solidity/contracts/utils/UFragments.sol",
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable */\npragma solidity ^0.8.9;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\n\n/**\n * @title uFragments ERC20 token\n * @notice USDA uses the uFragments concept from the Ideal Money project to play interest\n *      Implementation is shamelessly borrowed from Ampleforth project\n *      uFragments is a normal ERC20 token, but its supply can be adjusted by splitting and\n *      combining tokens proportionally across all wallets.\n *\n *\n *      uFragment balances are internally represented with a hidden denomination, 'gons'.\n *      We support splitting the currency in expansion and combining the currency on contraction by\n *      changing the exchange rate between the hidden 'gons' and the public 'fragments'.\n */\ncontract UFragments is Ownable, IERC20Metadata {\n  // PLEASE READ BEFORE CHANGING ANY ACCOUNTING OR MATH\n  // Anytime there is division, there is a risk of numerical instability from rounding errors. In\n  // order to minimize this risk, we adhere to the following guidelines:\n  // 1) The conversion rate adopted is the number of gons that equals 1 fragment.\n  //    The inverse rate must not be used--_totalGons is always the numerator and _totalSupply is\n  //    always the denominator. (i.e. If you want to convert gons to fragments instead of\n  //    multiplying by the inverse rate, you should divide by the normal rate)\n  // 2) Gon balances converted into Fragments are always rounded down (truncated).\n  //\n  // We make the following guarantees:\n  // - If address 'A' transfers x Fragments to address 'B'. A's resulting external balance will\n  //   be decreased by precisely x Fragments, and B's external balance will be precisely\n  //   increased by x Fragments.\n  //\n  // We do not guarantee that the sum of all balances equals the result of calling totalSupply().\n  // This is because, for any conversion function 'f()' that has non-zero rounding error,\n  // f(x0) + f(x1) + ... + f(xn) is not always equal to f(x0 + x1 + ... xn).\n\n  event LogRebase(uint256 indexed epoch, uint256 totalSupply);\n  event LogMonetaryPolicyUpdated(address monetaryPolicy);\n\n  /// @notice Thrown when the signature is invalid\n  error UFragments_InvalidSignature();\n\n  /// @notice Thrown when the recipient is invalid\n  error UFragments_InvalidRecipient();\n\n  // Used for authentication\n  address public monetaryPolicy;\n\n  modifier onlyMonetaryPolicy() {\n    require(msg.sender == monetaryPolicy);\n    _;\n  }\n\n  modifier validRecipient(address _to) {\n    if (_to == address(0) || _to == address(this)) revert UFragments_InvalidRecipient();\n    _;\n  }\n\n  uint256 private constant DECIMALS = 18;\n  uint256 private constant MAX_UINT256 = 2 ** 256 - 1;\n  uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 1 * 10 ** DECIMALS;\n\n  // _totalGons is a multiple of INITIAL_FRAGMENTS_SUPPLY so that _gonsPerFragment is an integer.\n  // Use the highest value that fits in a uint256 for max granularity.\n  uint256 public _totalGons; // = INITIAL_FRAGMENTS_SUPPLY * 10**48;\n\n  // MAX_SUPPLY = maximum integer < (sqrt(4*_totalGons + 1) - 1) / 2\n  uint256 public MAX_SUPPLY; // = type(uint128).max; // (2^128) - 1\n\n  uint256 public _totalSupply;\n  uint256 public _gonsPerFragment;\n  mapping(address => uint256) public _gonBalances;\n\n  string public name;\n  string public symbol;\n  uint8 public constant decimals = uint8(DECIMALS);\n\n  // This is denominated in Fragments, because the gons-fragments conversion might change before\n  // it's fully paid.\n  mapping(address => mapping(address => uint256)) private _allowedFragments;\n\n  // EIP-2612: permit â€“ 712-signed approvals\n  // https://eips.ethereum.org/EIPS/eip-2612\n  string public constant EIP712_REVISION = '1';\n  bytes32 public constant EIP712_DOMAIN =\n    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n\n  // EIP-2612: keeps track of number of permits per address\n  mapping(address => uint256) private _nonces;\n\n  constructor(string memory _name, string memory _symbol) {\n    name = _name;\n    symbol = _symbol;\n\n    //set og initial values\n    _totalGons = INITIAL_FRAGMENTS_SUPPLY * 10 ** 48;\n    MAX_SUPPLY = 2 ** 128 - 1;\n    _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\n    _gonBalances[address(0x0)] = _totalGons; //send starting supply to a burner address so _totalSupply is never 0\n    _gonsPerFragment = _totalGons / _totalSupply;\n    emit Transfer(address(this), address(0x0), _totalSupply);\n  }\n\n  /**\n   * @param _monetaryPolicy The address of the monetary policy contract to use for authentication.\n   */\n  function setMonetaryPolicy(address _monetaryPolicy) external onlyOwner {\n    monetaryPolicy = _monetaryPolicy;\n    emit LogMonetaryPolicyUpdated(_monetaryPolicy);\n  }\n\n  /**\n   * @notice returns the total supply\n   * @return __totalSupply The total number of fragments.\n   */\n  function totalSupply() external view override returns (uint256 __totalSupply) {\n    return _totalSupply;\n  }\n\n  /**\n   * @param _who The address to query.\n   * @return _balance The balance of the specified address.\n   */\n  function balanceOf(address _who) external view override returns (uint256 _balance) {\n    return _gonBalances[_who] / _gonsPerFragment;\n  }\n\n  /**\n   * @param _who The address to query.\n   * @return _balance The gon balance of the specified address.\n   */\n  function scaledBalanceOf(address _who) external view returns (uint256 _balance) {\n    return _gonBalances[_who];\n  }\n\n  /**\n   *  @notice Returns the scaled total supply\n   * @return __totalGons the total number of gons.\n   */\n  function scaledTotalSupply() external view returns (uint256 __totalGons) {\n    return _totalGons;\n  }\n\n  /**\n   * @notice Returns the nonces of a given address\n   * @param _who The address to query.\n   * @return _addressNonces The number of successful permits by the specified address.\n   */\n  function nonces(address _who) public view returns (uint256 _addressNonces) {\n    return _nonces[_who];\n  }\n\n  /**\n   * @notice Returns the EIP712 domain separator\n   * @return _domainSeparator The computed DOMAIN_SEPARATOR to be used off-chain services\n   *         which implement EIP-712.\n   *         https://eips.ethereum.org/EIPS/eip-2612\n   */\n  function DOMAIN_SEPARATOR() public view returns (bytes32 _domainSeparator) {\n    uint256 _chainId;\n    assembly {\n      _chainId := chainid()\n    }\n    return keccak256(\n      abi.encode(EIP712_DOMAIN, keccak256(bytes(name)), keccak256(bytes(EIP712_REVISION)), _chainId, address(this))\n    );\n  }\n\n  /**\n   * @notice Transfer tokens to a specified address.\n   * @param _to The address to transfer to.\n   * @param _value The amount to be transferred.\n   * @return _success True on success, false otherwise.\n   */\n  function transfer(address _to, uint256 _value) external override validRecipient(_to) returns (bool _success) {\n    uint256 _gonValue = _value * _gonsPerFragment;\n\n    _gonBalances[msg.sender] = _gonBalances[msg.sender] - _gonValue;\n    _gonBalances[_to] = _gonBalances[_to] + _gonValue;\n\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @notice Transfer all of the sender's wallet balance to a specified address.\n   * @param _to The address to transfer to.\n   * @return _success True on success, false otherwise.\n   */\n  function transferAll(address _to) external validRecipient(_to) returns (bool _success) {\n    uint256 _gonValue = _gonBalances[msg.sender];\n    uint256 _value = _gonValue / _gonsPerFragment;\n\n    delete _gonBalances[msg.sender];\n    _gonBalances[_to] = _gonBalances[_to] + _gonValue;\n\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @notice Function to check the amount of tokens that an owner has allowed to a spender.\n   * @param _owner The address which owns the funds.\n   * @param _spender The address which will spend the funds.\n   * @return _remaining The number of tokens still available for the _spender.\n   */\n  function allowance(address _owner, address _spender) external view override returns (uint256 _remaining) {\n    return _allowedFragments[_owner][_spender];\n  }\n\n  /**\n   * @notice Transfer tokens from one address to another.\n   * @param _from The address you want to send tokens from.\n   * @param _to The address you want to transfer to.\n   * @param _value The amount of tokens to be transferred.\n   * @return _success True on success, false otherwise.\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  ) external override validRecipient(_to) returns (bool _success) {\n    _allowedFragments[_from][msg.sender] = _allowedFragments[_from][msg.sender] - _value;\n\n    uint256 _gonValue = _value * _gonsPerFragment;\n    _gonBalances[_from] = _gonBalances[_from] - _gonValue;\n    _gonBalances[_to] = _gonBalances[_to] + _gonValue;\n\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @notice Transfer all balance tokens from one address to another.\n   * @param _from The address you want to send tokens from.\n   * @param _to The address you want to transfer to.\n   * @return _success True on success, false otherwise.\n   */\n  function transferAllFrom(address _from, address _to) external validRecipient(_to) returns (bool _success) {\n    uint256 _gonValue = _gonBalances[_from];\n    uint256 _value = _gonValue / _gonsPerFragment;\n\n    _allowedFragments[_from][msg.sender] = _allowedFragments[_from][msg.sender] - _value;\n\n    delete _gonBalances[_from];\n    _gonBalances[_to] = _gonBalances[_to] + _gonValue;\n\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @notice Approve the passed address to spend the specified amount of tokens on behalf of\n   * msg.sender. This method is included for ERC20 compatibility.\n   * increaseAllowance and decreaseAllowance should be used instead.\n   * Changing an allowance with this method brings the risk that someone may transfer both\n   * the old and the new allowance - if they are both greater than zero - if a transfer\n   * transaction is mined before the later approve() call is mined.\n   *\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   * @return _success True on success, false otherwise.\n   */\n  function approve(address _spender, uint256 _value) external override returns (bool _success) {\n    _allowedFragments[msg.sender][_spender] = _value;\n\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @notice Increase the amount of tokens that an owner has allowed to a spender.\n   * This method should be used instead of approve() to avoid the double approval vulnerability\n   * described above.\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   * @return _success True on success, false otherwise.\n   */\n  function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool _success) {\n    _allowedFragments[msg.sender][_spender] = _allowedFragments[msg.sender][_spender] + _addedValue;\n\n    emit Approval(msg.sender, _spender, _allowedFragments[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @notice Decrease the amount of tokens that an owner has allowed to a spender.\n   *\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   * @return _success True on success, false otherwise.\n   */\n  function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool _success) {\n    uint256 _oldValue = _allowedFragments[msg.sender][_spender];\n    _allowedFragments[msg.sender][_spender] = (_subtractedValue >= _oldValue) ? 0 : _oldValue - _subtractedValue;\n\n    emit Approval(msg.sender, _spender, _allowedFragments[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @notice Allows for approvals to be made via secp256k1 signatures.\n   * @param _owner The owner of the funds\n   * @param _spender The _spender\n   * @param _value The amount\n   * @param _deadline The deadline timestamp, type(uint256).max for max deadline\n   * @param _v Signature param\n   * @param _s Signature param\n   * @param _r Signature param\n   */\n  function permit(\n    address _owner,\n    address _spender,\n    uint256 _value,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) public {\n    require(block.timestamp <= _deadline);\n\n    uint256 _ownerNonce = _nonces[_owner];\n    bytes32 _permitDataDigest = keccak256(abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, _ownerNonce, _deadline));\n    bytes32 _digest = keccak256(abi.encodePacked('\\x19\\x01', DOMAIN_SEPARATOR(), _permitDataDigest));\n\n    if (uint256(_s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      revert UFragments_InvalidSignature();\n    }\n    require(_owner == ecrecover(_digest, _v, _r, _s));\n    if (_owner == address(0x0)) revert UFragments_InvalidSignature();\n\n    _nonces[_owner] = _ownerNonce + 1;\n\n    _allowedFragments[_owner][_spender] = _value;\n    emit Approval(_owner, _spender, _value);\n  }\n}"
    }
  ]
}