{
  "Title": "[05] CODE COMMENT IN `ExtraordinaryFunding._extraordinaryProposalSucceeded` FUNCTION CAN BE INCORRECT",
  "Content": "In the following `ExtraordinaryFunding._extraordinaryProposalSucceeded` function, the comment for `(votesReceived >= tokensRequested_ + _getSliceOfNonTreasury(minThresholdPercentage))` is `succeeded if proposal's votes received doesn't exceed the minimum threshold required`. However, `(votesReceived >= tokensRequested_ + _getSliceOfNonTreasury(minThresholdPercentage))` can only be true when the proposal's votes received meet or exceed such minimum threshold, which is the opposite of the comment. To prevent confusion, please consider updating the comment to match the corresponding code.\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L164-L178\n```solidity\n    function _extraordinaryProposalSucceeded(\n        uint256 proposalId_,\n        uint256 tokensRequested_\n    ) internal view returns (bool) {\n        uint256 votesReceived          = uint256(_extraordinaryFundingProposals[proposalId_].votesReceived);\n        uint256 minThresholdPercentage = _getMinimumThresholdPercentage();\n\n        return\n            // succeeded if proposal's votes received doesn't exceed the minimum threshold required\n            (votesReceived >= tokensRequested_ + _getSliceOfNonTreasury(minThresholdPercentage))\n            &&\n            // succeeded if tokens requested are available for claiming from the treasury\n            (tokensRequested_ <= _getSliceOfTreasury(Maths.WAD - minThresholdPercentage))\n        ;\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-grants/src/grants/base/ExtraordinaryFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IERC20 }   from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"@oz/utils/math/SafeCast.sol\";\n\nimport { Funding } from \"./Funding.sol\";\n\nimport { IExtraordinaryFunding } from \"../interfaces/IExtraordinaryFunding.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nabstract contract ExtraordinaryFunding is Funding, IExtraordinaryFunding {\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice The maximum length of a proposal's voting period, in blocks.\n     */\n    uint256 internal constant MAX_EFM_PROPOSAL_LENGTH = 216_000; // number of blocks in one month\n\n    /**\n     * @notice Keccak hash of a prefix string for extraordinary funding mechanism\n     */\n    bytes32 internal constant DESCRIPTION_PREFIX_HASH_EXTRAORDINARY = keccak256(bytes(\"Extraordinary Funding: \"));\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice Mapping of extant extraordinary funding proposals.\n     * @dev proposalId => ExtraordinaryFundingProposal.\n     */\n    mapping (uint256 => ExtraordinaryFundingProposal) internal _extraordinaryFundingProposals;\n\n    /**\n     * @notice The list of extraordinary funding proposalIds that have been executed.\n     */\n    uint256[] internal _fundedExtraordinaryProposals;\n\n    /**\n     * @notice Mapping checking if a voter has voted on a given proposal.\n     * @dev proposalId => address => bool.\n     */\n    mapping(uint256 => mapping(address => bool)) public hasVotedExtraordinary;\n\n    /**************************/\n    /*** Proposal Functions ***/\n    /**************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function executeExtraordinary(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external nonReentrant override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, descriptionHash_)));\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n\n        // since we are casting from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 tokensRequested = uint256(proposal.tokensRequested);\n\n        // check proposal is succesful and hasn't already been executed\n        if (proposal.executed || !_extraordinaryProposalSucceeded(proposalId_, tokensRequested)) revert ExecuteExtraordinaryProposalInvalid();\n\n        _fundedExtraordinaryProposals.push(proposalId_);\n\n        // update proposal state\n        proposal.executed = true;\n\n        // update treasury\n        treasury -= tokensRequested;\n\n        // execute proposal's calldata\n        _execute(proposalId_, targets_, values_, calldatas_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function proposeExtraordinary(\n        uint256 endBlock_,\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_) external override returns (uint256 proposalId_) {\n\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, keccak256(bytes(description_)))));\n\n        ExtraordinaryFundingProposal storage newProposal = _extraordinaryFundingProposals[proposalId_];\n\n        // check if proposal already exists (proposal id not 0)\n        if (newProposal.proposalId != 0) revert ProposalAlreadyExists();\n\n        // check proposal length is within limits of 1 month maximum\n        if (block.number + MAX_EFM_PROPOSAL_LENGTH < endBlock_) revert InvalidProposal();\n\n        uint128 totalTokensRequested = _validateCallDatas(targets_, values_, calldatas_);\n\n        // check tokens requested are available for claiming from the treasury\n        if (uint256(totalTokensRequested) > _getSliceOfTreasury(Maths.WAD - _getMinimumThresholdPercentage())) revert InvalidProposal();\n\n        // store newly created proposal\n        newProposal.proposalId      = proposalId_;\n        newProposal.startBlock      = SafeCast.toUint128(block.number);\n        newProposal.endBlock        = SafeCast.toUint128(endBlock_);\n        newProposal.tokensRequested = totalTokensRequested;\n\n        emit ProposalCreated(\n            proposalId_,\n            msg.sender,\n            targets_,\n            values_,\n            new string[](targets_.length),\n            calldatas_,\n            block.number,\n            endBlock_,\n            description_\n        );\n    }\n\n    /************************/\n    /*** Voting Functions ***/\n    /************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function voteExtraordinary(\n        uint256 proposalId_\n    ) external override returns (uint256 votesCast_) {\n        // revert if msg.sender already voted on proposal\n        if (hasVotedExtraordinary[proposalId_][msg.sender]) revert AlreadyVoted();\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n        // revert if proposal is inactive\n        if (proposal.startBlock > block.number || proposal.endBlock < block.number || proposal.executed) {\n            revert ExtraordinaryFundingProposalInactive();\n        }\n\n        // check voting power at snapshot block and update proposal votes\n        votesCast_ = _getVotesExtraordinary(msg.sender, proposalId_);\n        proposal.votesReceived += SafeCast.toUint120(votesCast_);\n\n        // record that voter has voted on this extraordinary funding proposal\n        hasVotedExtraordinary[proposalId_][msg.sender] = true;\n\n        emit VoteCast(\n            msg.sender,\n            proposalId_,\n            1,\n            votesCast_,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Check if a proposal for extraordinary funding has succeeded.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return Boolean indicating whether the proposal has succeeded.\n     */\n    function _extraordinaryProposalSucceeded(\n        uint256 proposalId_,\n        uint256 tokensRequested_\n    ) internal view returns (bool) {\n        uint256 votesReceived          = uint256(_extraordinaryFundingProposals[proposalId_].votesReceived);\n        uint256 minThresholdPercentage = _getMinimumThresholdPercentage();\n\n        return\n            // succeeded if proposal's votes received doesn't exceed the minimum threshold required\n            (votesReceived >= tokensRequested_ + _getSliceOfNonTreasury(minThresholdPercentage))\n            &&\n            // succeeded if tokens requested are available for claiming from the treasury\n            (tokensRequested_ <= _getSliceOfTreasury(Maths.WAD - minThresholdPercentage))\n        ;\n    }\n\n    /********************************/\n    /*** Internal View Functions ****/\n    /********************************/\n\n    /**\n     * @notice Get the current ProposalState of a given proposal.\n     * @dev    Used by GrantFund.state() for analytics compatability purposes.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return The proposals status in the ProposalState enum.\n     */\n    function _getExtraordinaryProposalState(uint256 proposalId_) internal view returns (ProposalState) {\n        ExtraordinaryFundingProposal memory proposal = _extraordinaryFundingProposals[proposalId_];\n\n        bool voteSucceeded = _extraordinaryProposalSucceeded(proposalId_, uint256(proposal.tokensRequested));\n\n        if (proposal.executed)                                        return ProposalState.Executed;\n        else if (proposal.endBlock >= block.number && !voteSucceeded) return ProposalState.Active;\n        else if (voteSucceeded)                                       return ProposalState.Succeeded;\n        else                                                          return ProposalState.Defeated;\n    }\n\n    /**\n     * @notice Get the minimum percentage of ajna tokens required for a proposal to pass.\n     * @dev    The minimum threshold increases according to the number of funded EFM proposals.\n     * @return The minimum threshold percentage, as a WAD.\n     */\n    function _getMinimumThresholdPercentage() internal view returns (uint256) {\n        // default minimum threshold is 50\n        if (_fundedExtraordinaryProposals.length == 0) {\n            return 0.5 * 1e18;\n        }\n        // minimum threshold increases according to the number of funded EFM proposals\n        else {\n            return 0.5 * 1e18 + (_fundedExtraordinaryProposals.length * (0.05 * 1e18));\n        }\n    }\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param percentage_ The percentage of the Non treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function _getSliceOfNonTreasury(\n        uint256 percentage_\n    ) internal view returns (uint256) {\n        uint256 totalAjnaSupply = IERC20(ajnaTokenAddress).totalSupply();\n        return Maths.wmul(totalAjnaSupply - treasury, percentage_);\n    }\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param percentage_ The percentage of the treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function _getSliceOfTreasury(\n        uint256 percentage_\n    ) internal view returns (uint256) {\n        return Maths.wmul(treasury, percentage_);\n    }\n\n    /**\n     * @notice Get the voting power available to a voter for a given proposal.\n     * @param  account_        The address of the voter to check.\n     * @param  proposalId_     The ID of the proposal being voted on.\n     * @return votes_          The number of votes available to be cast in voteExtraordinary.\n     */\n    function _getVotesExtraordinary(address account_, uint256 proposalId_) internal view returns (uint256 votes_) {\n        if (proposalId_ == 0) revert ExtraordinaryFundingProposalInactive();\n\n        uint256 startBlock = _extraordinaryFundingProposals[proposalId_].startBlock;\n\n        votes_ = _getVotesAtSnapshotBlocks(\n            account_,\n            startBlock - VOTING_POWER_SNAPSHOT_DELAY,\n            startBlock\n        );\n    }\n\n    /********************************/\n    /*** External View Functions ****/\n    /********************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getMinimumThresholdPercentage() external view returns (uint256) {\n        return _getMinimumThresholdPercentage();\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getSliceOfNonTreasury(\n        uint256 percentage_\n    ) external view override returns (uint256) {\n        return _getSliceOfNonTreasury(percentage_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getSliceOfTreasury(\n        uint256 percentage_\n    ) external view override returns (uint256) {\n        return _getSliceOfTreasury(percentage_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getExtraordinaryProposalInfo(\n        uint256 proposalId_\n    ) external view override returns (uint256, uint128, uint128, uint128, uint120, bool) {\n        return (\n            _extraordinaryFundingProposals[proposalId_].proposalId,\n            _extraordinaryFundingProposals[proposalId_].startBlock,\n            _extraordinaryFundingProposals[proposalId_].endBlock,\n            _extraordinaryFundingProposals[proposalId_].tokensRequested,\n            _extraordinaryFundingProposals[proposalId_].votesReceived,\n            _extraordinaryFundingProposals[proposalId_].executed\n        );\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getExtraordinaryProposalSucceeded(uint256 proposalId_) external view override returns (bool) {\n        // since we are casting from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 tokensRequested = uint256(_extraordinaryFundingProposals[proposalId_].tokensRequested);\n\n        return _extraordinaryProposalSucceeded(proposalId_, tokensRequested);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getVotesExtraordinary(address account_, uint256 proposalId_) external view override returns (uint256) {\n        if (hasVotedExtraordinary[proposalId_][account_]) return 0;\n        return _getVotesExtraordinary(account_, proposalId_);\n    }\n\n}"
    }
  ]
}