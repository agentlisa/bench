{
  "Title": "[G-01] Optimize `finalize` with cancelled bids",
  "Content": "\nWhen `cancelBid` is called, the `commitment` is set to 0 in order to force to fail the `computeCommitment` comparison.\n\n```js\n    function cancelBid(uint256 auctionId, uint256 bidIndex)\n        external\n    {\n        ...\n\n        // Prevent any futher access to this EncryptedBid\n        b.sender = address(0);\n\n        // Prevent seller from finalizing a cancelled bid\n        b.commitment = 0;\n```\n\n This can be cheaper if `b.pubKey` is set to 0,0, because `ECCMath.ecMul` will return a (1,1) point and it will save all the `decryptMessage` from cancelled bids.\n\n```js\n            ECCMath.Point memory sharedPoint = ECCMath.ecMul(b.pubKey, sellerPriv);\n            // If the bidder public key isn't on the bn128 curve\n            if (sharedPoint.x == 1 && sharedPoint.y == 1) continue;\n\n            bytes32 decryptedMessage = ECCMath.decryptMessage(sharedPoint, b.encryptedMessage);\n            // If the bidder didn't faithfully submit commitment or pubkey\n            // Or the bid was cancelled\n            if (computeCommitment(decryptedMessage) != b.commitment) continue;\n```\n\n*Note: This also will be more secure because `computeCommitment` could return 0 with a collision, and process the cancelled bid as valid.*\n\n**Affected source code:**\n\n- [SizeSealed.sol:258](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L258)\n- [SizeSealed.sol:435](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L435)\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-11-size-contest",
  "Code": [
    {
      "filename": "src/SizeSealed.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ECCMath} from \"./util/ECCMath.sol\";\nimport {ISizeSealed} from \"./interfaces/ISizeSealed.sol\";\nimport {CommonTokenMath} from \"./util/CommonTokenMath.sol\";\n\n/// @title Size Sealed Auction\n/// @author Size Market\ncontract SizeSealed is ISizeSealed {\n    ///////////////////////////////\n    ///          STATE          ///\n    ///////////////////////////////\n\n    uint256 public currentAuctionId;\n\n    mapping(uint256 => Auction) public idToAuction;\n\n    ///////////////////////////////////////////////////\n    ///                  MODIFIERS                  ///\n    ///////////////////////////////////////////////////\n\n    modifier atState(Auction storage a, States _state) {\n        if (block.timestamp < a.timings.startTimestamp) {\n            if (_state != States.Created) revert InvalidState();\n        } else if (block.timestamp < a.timings.endTimestamp) {\n            if (_state != States.AcceptingBids) revert InvalidState();\n        } else if (a.data.lowestQuote != type(uint128).max) {\n            if (_state != States.Finalized) revert InvalidState();\n        } else if (block.timestamp <= a.timings.endTimestamp + 24 hours) {\n            if (_state != States.RevealPeriod) revert InvalidState();\n        } else if (block.timestamp > a.timings.endTimestamp + 24 hours) {\n            if (_state != States.Voided) revert InvalidState();\n        } else {\n            revert();\n        }\n        _;\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n    ///                          AUCTION LOGIC                          ///\n    ///////////////////////////////////////////////////////////////////////\n\n    /// @notice Creates a new sealed auction\n    /// @dev Transfers the `baseToken` from `msg.sender` to the contract\n    /// @return `auctionId` unique to that auction\n    /// @param auctionParams Parameters used during the auction\n    /// @param timings The timestamps at which the auction starts/ends\n    /// @param encryptedSellerPrivKey Encrypted seller's ephemeral private key\n    function createAuction(\n        AuctionParameters calldata auctionParams,\n        Timings calldata timings,\n        bytes calldata encryptedSellerPrivKey\n    ) external returns (uint256) {\n        if (timings.endTimestamp <= block.timestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.startTimestamp >= timings.endTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.endTimestamp > timings.vestingStartTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.vestingStartTimestamp > timings.vestingEndTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.cliffPercent > 1e18) {\n            revert InvalidCliffPercent();\n        }\n        // Revert if the min bid is more than the total reserve of the auction\n        if (\n            FixedPointMathLib.mulDivDown(\n                auctionParams.minimumBidQuote, type(uint128).max, auctionParams.totalBaseAmount\n            ) > auctionParams.reserveQuotePerBase\n        ) {\n            revert InvalidReserve();\n        }\n\n        uint256 auctionId = ++currentAuctionId;\n\n        Auction storage a = idToAuction[auctionId];\n        a.timings = timings;\n\n        a.data.seller = msg.sender;\n        a.data.lowestQuote = type(uint128).max;\n\n        a.params = auctionParams;\n\n        // Passes https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol#L9\n        // Transfer base tokens to auction contract and check for tax tokens\n        uint256 balanceBeforeTransfer = ERC20(auctionParams.baseToken).balanceOf(address(this));\n\n        SafeTransferLib.safeTransferFrom(\n            ERC20(auctionParams.baseToken), msg.sender, address(this), auctionParams.totalBaseAmount\n        );\n\n        uint256 balanceAfterTransfer = ERC20(auctionParams.baseToken).balanceOf(address(this));\n        if (balanceAfterTransfer - balanceBeforeTransfer != auctionParams.totalBaseAmount) {\n            revert UnexpectedBalanceChange();\n        }\n\n        emit AuctionCreated(auctionId, msg.sender, auctionParams, timings, encryptedSellerPrivKey);\n\n        return auctionId;\n    }\n\n    /// @notice Bid on a runnning auction\n    /// @dev Transfers `quoteAmount` of `quoteToken` from bidder to contract\n    /// @return Index of the bid\n    /// @param auctionId Id of the auction to bid on\n    /// @param quoteAmount Amount of `quoteTokens` bidding on a committed amount of `baseTokens`\n    /// @param commitment Hash commitment of the `baseAmount`\n    /// @param pubKey Public key used to encrypt `baseAmount`\n    /// @param encryptedMessage `baseAmount` encrypted to the seller's public key\n    /// @param encryptedPrivateKey Encrypted private key for on-chain storage\n    /// @param proof Merkle proof that checks seller against `merkleRoot` if there is a whitelist\n    function bid(\n        uint256 auctionId,\n        uint128 quoteAmount,\n        bytes32 commitment,\n        ECCMath.Point calldata pubKey,\n        bytes32 encryptedMessage,\n        bytes calldata encryptedPrivateKey,\n        bytes32[] calldata proof\n    ) external atState(idToAuction[auctionId], States.AcceptingBids) returns (uint256) {\n        Auction storage a = idToAuction[auctionId];\n        if (a.params.merkleRoot != bytes32(0)) {\n            bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n            if (!MerkleProofLib.verify(proof, a.params.merkleRoot, leaf)) {\n                revert InvalidProof();\n            }\n        }\n\n        // Seller cannot bid on their own auction\n        if (msg.sender == a.data.seller) {\n            revert UnauthorizedCaller();\n        }\n\n        if (quoteAmount == 0 || quoteAmount == type(uint128).max || quoteAmount < a.params.minimumBidQuote) {\n            revert InvalidBidAmount();\n        }\n\n        EncryptedBid memory ebid;\n        ebid.sender = msg.sender;\n        ebid.quoteAmount = quoteAmount;\n        ebid.commitment = commitment;\n        ebid.pubKey = pubKey;\n        ebid.encryptedMessage = encryptedMessage;\n\n        uint256 bidIndex = a.bids.length;\n        // Max of 1000 bids on an auction to prevent DOS\n        if (bidIndex >= 1000) {\n            revert InvalidState();\n        }\n\n        a.bids.push(ebid);\n\n        SafeTransferLib.safeTransferFrom(ERC20(a.params.quoteToken), msg.sender, address(this), quoteAmount);\n\n        emit Bid(\n            msg.sender, auctionId, bidIndex, quoteAmount, commitment, pubKey, encryptedMessage, encryptedPrivateKey\n        );\n\n        return bidIndex;\n    }\n\n    /// @notice Reveals the private key of the seller\n    /// @dev All valid bids are decrypted after this\n    ///      finalizeData should be empty if seller does not wish to finalize in this tx\n    /// @param privateKey Private key corresponding to the auctions public key\n    /// @param finalizeData Calldata that will be sent to finalize()\n    function reveal(uint256 auctionId, uint256 privateKey, bytes calldata finalizeData)\n        external\n        atState(idToAuction[auctionId], States.RevealPeriod)\n    {\n        Auction storage a = idToAuction[auctionId];\n        if (a.data.seller != msg.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        ECCMath.Point memory pubKey = ECCMath.publicKey(privateKey);\n        if (pubKey.x != a.params.pubKey.x || pubKey.y != a.params.pubKey.y || (pubKey.x == 1 && pubKey.y == 1)) {\n            revert InvalidPrivateKey();\n        }\n\n        a.data.privKey = privateKey;\n\n        emit RevealedKey(auctionId, privateKey);\n\n        if (finalizeData.length != 0) {\n            (uint256[] memory bidIndices, uint128 clearingBase, uint128 clearingQuote) =\n                abi.decode(finalizeData, (uint256[], uint128, uint128));\n            finalize(auctionId, bidIndices, clearingBase, clearingQuote);\n        }\n    }\n\n    // Used to get around stack too deep errors -- even with viaIr\n    struct FinalizeData {\n        uint256 reserveQuotePerBase;\n        uint128 totalBaseAmount;\n        uint128 filledBase;\n        uint256 previousQuotePerBase;\n        uint256 previousIndex;\n    }\n\n    /// @notice Finalises an auction by revealing all bids\n    /// @dev Calculates the minimum `quotePerBase` and marks successful bids\n    /// @param auctionId `auctionId` of the auction to bid on\n    /// @param bidIndices Bids sorted by price descending\n    /// @param clearingBase Denominator in the clearing price calculation\n    /// @param clearingQuote Numerator in the clearing price calculation\n    function finalize(uint256 auctionId, uint256[] memory bidIndices, uint128 clearingBase, uint128 clearingQuote)\n        public\n        atState(idToAuction[auctionId], States.RevealPeriod)\n    {\n        Auction storage a = idToAuction[auctionId];\n        uint256 sellerPriv = a.data.privKey;\n        if (sellerPriv == 0) {\n            revert InvalidPrivateKey();\n        }\n\n        if (bidIndices.length != a.bids.length) {\n            revert InvalidCalldata();\n        }\n\n        FinalizeData memory data;\n        data.reserveQuotePerBase = a.params.reserveQuotePerBase;\n        data.totalBaseAmount = a.params.totalBaseAmount;\n        data.previousQuotePerBase = type(uint256).max;\n\n        // Last filled bid is the clearing price\n        a.data.lowestBase = clearingBase;\n        a.data.lowestQuote = clearingQuote;\n\n        // Bitmap of all the bid indices that have been processed\n        uint256[] memory seenBidMap = new uint256[]((bidIndices.length/256)+1);\n\n        // Fill orders from highest price to lowest price\n        for (uint256 i; i < bidIndices.length; i++) {\n            uint256 bidIndex = bidIndices[i];\n            EncryptedBid storage b = a.bids[bidIndex];\n\n            // Verify this bid index hasn't been seen before\n            uint256 bitmapIndex = bidIndex / 256;\n            uint256 bitMap = seenBidMap[bitmapIndex];\n            uint256 indexBit = 1 << (bidIndex % 256);\n            if (bitMap & indexBit == 1) revert InvalidState();\n            seenBidMap[bitmapIndex] = bitMap | indexBit;\n\n            // G^k1^k2 == G^k2^k1\n            ECCMath.Point memory sharedPoint = ECCMath.ecMul(b.pubKey, sellerPriv);\n            // If the bidder public key isn't on the bn128 curve\n            if (sharedPoint.x == 1 && sharedPoint.y == 1) continue;\n\n            bytes32 decryptedMessage = ECCMath.decryptMessage(sharedPoint, b.encryptedMessage);\n            // If the bidder didn't faithfully submit commitment or pubkey\n            // Or the bid was cancelled\n            if (computeCommitment(decryptedMessage) != b.commitment) continue;\n\n            // First 128 bits are the base amount, last are random salt\n            uint128 baseAmount = uint128(uint256(decryptedMessage >> 128));\n\n            // Require that bids are passed in descending price\n            uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount);\n            if (quotePerBase >= data.previousQuotePerBase) {\n                // If last bid was the same price, make sure we filled the earliest bid first\n                if (quotePerBase == data.previousQuotePerBase) {\n                    if (data.previousIndex > bidIndex) revert InvalidSorting();\n                } else {\n                    revert InvalidSorting();\n                }\n            }\n\n            // Only fill if above reserve price\n            if (quotePerBase < data.reserveQuotePerBase) continue;\n\n            // Auction has been fully filled\n            if (data.filledBase == data.totalBaseAmount) continue;\n\n            data.previousQuotePerBase = quotePerBase;\n            data.previousIndex = bidIndex;\n\n            // Fill the remaining unfilled base amount\n            if (data.filledBase + baseAmount > data.totalBaseAmount) {\n                baseAmount = data.totalBaseAmount - data.filledBase;\n            }\n\n            b.filledBaseAmount = baseAmount;\n            data.filledBase += baseAmount;\n        }\n\n        if (data.previousQuotePerBase != FixedPointMathLib.mulDivDown(clearingQuote, type(uint128).max, clearingBase)) {\n            revert InvalidCalldata();\n        }\n\n        // seenBidMap[0:len-1] should be full\n        for (uint256 i; i < seenBidMap.length - 1; i++) {\n            if (seenBidMap[i] != type(uint256).max) {\n                revert InvalidState();\n            }\n        }\n\n        // seenBidMap[-1] should only have the last N bits set\n        if (seenBidMap[seenBidMap.length - 1] != (1 << (bidIndices.length % 256)) - 1) {\n            revert InvalidState();\n        }\n\n        if (data.filledBase > data.totalBaseAmount) {\n            revert InvalidState();\n        }\n\n        // Transfer the left over baseToken\n        if (data.totalBaseAmount != data.filledBase) {\n            uint128 unsoldBase = data.totalBaseAmount - data.filledBase;\n            a.params.totalBaseAmount = data.filledBase;\n            SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), a.data.seller, unsoldBase);\n        }\n\n        // Calculate quote amount based on clearing price\n        uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), a.data.seller, filledQuote);\n\n        emit AuctionFinalized(auctionId, bidIndices, data.filledBase, filledQuote);\n    }\n\n    /// @notice Called after finalize for unsuccessful bidders to return funds\n    /// @dev Returns all `quoteToken` to the original bidder\n    /// @param auctionId `auctionId` of the auction to bid on\n    /// @param bidIndex Index of the failed bid to be refunded\n    function refund(uint256 auctionId, uint256 bidIndex) external atState(idToAuction[auctionId], States.Finalized) {\n        Auction storage a = idToAuction[auctionId];\n        EncryptedBid storage b = a.bids[bidIndex];\n        if (msg.sender != b.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        if (b.filledBaseAmount != 0) {\n            revert InvalidState();\n        }\n\n        b.sender = address(0);\n\n        emit BidRefund(auctionId, bidIndex);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, b.quoteAmount);\n    }\n\n    /// @notice Called after finalize for successful bidders\n    /// @dev Returns won `baseToken` & any unfilled `quoteToken` to the bidder\n    /// @param auctionId `auctionId` of the auction bid on\n    /// @param bidIndex Index of the successful bid\n    function withdraw(uint256 auctionId, uint256 bidIndex) external atState(idToAuction[auctionId], States.Finalized) {\n        Auction storage a = idToAuction[auctionId];\n        EncryptedBid storage b = a.bids[bidIndex];\n        if (msg.sender != b.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        uint128 baseAmount = b.filledBaseAmount;\n        if (baseAmount == 0) {\n            revert InvalidState();\n        }\n\n        uint128 baseTokensAvailable = tokensAvailableForWithdrawal(auctionId, baseAmount);\n        baseTokensAvailable = baseTokensAvailable - b.baseWithdrawn;\n\n        b.baseWithdrawn += baseTokensAvailable;\n\n        // Refund unfilled quoteAmount on first withdraw\n        if (b.quoteAmount != 0) {\n            uint256 quoteBought = FixedPointMathLib.mulDivDown(baseAmount, a.data.lowestQuote, a.data.lowestBase);\n            uint256 refundedQuote = b.quoteAmount - quoteBought;\n            b.quoteAmount = 0;\n\n            SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, refundedQuote);\n        }\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), msg.sender, baseTokensAvailable);\n\n        emit Withdrawal(auctionId, bidIndex, baseTokensAvailable, baseAmount - b.baseWithdrawn);\n    }\n\n    /// @dev Transfers `baseToken` back to seller and will enable withdraws for bidders\n    /// @param auctionId `auctionId` of the auction to be cancelled\n    function cancelAuction(uint256 auctionId) external {\n        Auction storage a = idToAuction[auctionId];\n        if (msg.sender != a.data.seller) {\n            revert UnauthorizedCaller();\n        }\n        // Only allow cancellations before finalization\n        // Equivalent to atState(idToAuction[auctionId], ~STATE_FINALIZED)\n        if (a.data.lowestQuote != type(uint128).max) {\n            revert InvalidState();\n        }\n\n        // Allowing bidders to cancel bids (withdraw quote)\n        // Auction considered forever States.AcceptingBids but nobody can finalize\n        a.data.seller = address(0);\n        a.timings.endTimestamp = type(uint32).max;\n\n        emit AuctionCancelled(auctionId);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), msg.sender, a.params.totalBaseAmount);\n    }\n\n    /// @dev Transfers `quoteToken` back to bidder and prevents bid from being finalised\n    /// @param auctionId `auctionId` of the auction to be cancelled\n    /// @param bidIndex Index of the bid to be cancelled\n    function cancelBid(uint256 auctionId, uint256 bidIndex)\n        external\n    {\n        Auction storage a = idToAuction[auctionId];\n        EncryptedBid storage b = a.bids[bidIndex];\n        if (msg.sender != b.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        // Only allow bid cancellations while not finalized or in the reveal period\n        if (block.timestamp >= a.timings.endTimestamp) {\n            if (a.data.lowestQuote != type(uint128).max || block.timestamp <= a.timings.endTimestamp + 24 hours) {\n                revert InvalidState();\n            }\n        }\n\n        // Prevent any futher access to this EncryptedBid\n        b.sender = address(0);\n\n        // Prevent seller from finalizing a cancelled bid\n        b.commitment = 0;\n\n        emit BidCancelled(auctionId, bidIndex);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, b.quoteAmount);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    ///                            UTIL FUNCTIONS                            ///\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Calculates available unlocked tokens for an auction\n    /// @dev Uses vesting parameters to account for cliff & linearity\n    /// @return tokensAvailable Amount of unlocked `baseToken` at the current time\n    /// @param auctionId `auctionId` of the auction bid on\n    /// @param baseAmount Amount of total vested `baseToken`\n    function tokensAvailableForWithdrawal(uint256 auctionId, uint128 baseAmount)\n        public\n        view\n        returns (uint128 tokensAvailable)\n    {\n        Auction storage a = idToAuction[auctionId];\n        return CommonTokenMath.tokensAvailableAtTime(\n            a.timings.vestingStartTimestamp,\n            a.timings.vestingEndTimestamp,\n            uint32(block.timestamp),\n            a.timings.cliffPercent,\n            baseAmount\n        );\n    }\n\n    function computeCommitment(bytes32 message) public pure returns (bytes32) {\n        return keccak256(abi.encode(message));\n    }\n\n    function computeMessage(uint128 baseAmount, bytes16 salt) external pure returns (bytes32) {\n        return bytes32(abi.encodePacked(baseAmount, salt));\n    }\n\n    function getTimings(uint256 auctionId) external view returns (Timings memory timings) {\n        timings = idToAuction[auctionId].timings;\n    }\n\n    function getAuctionData(uint256 auctionId) external view returns (AuctionData memory data) {\n        data = idToAuction[auctionId].data;\n    }\n}"
    },
    {
      "filename": "src/SizeSealed.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ECCMath} from \"./util/ECCMath.sol\";\nimport {ISizeSealed} from \"./interfaces/ISizeSealed.sol\";\nimport {CommonTokenMath} from \"./util/CommonTokenMath.sol\";\n\n/// @title Size Sealed Auction\n/// @author Size Market\ncontract SizeSealed is ISizeSealed {\n    ///////////////////////////////\n    ///          STATE          ///\n    ///////////////////////////////\n\n    uint256 public currentAuctionId;\n\n    mapping(uint256 => Auction) public idToAuction;\n\n    ///////////////////////////////////////////////////\n    ///                  MODIFIERS                  ///\n    ///////////////////////////////////////////////////\n\n    modifier atState(Auction storage a, States _state) {\n        if (block.timestamp < a.timings.startTimestamp) {\n            if (_state != States.Created) revert InvalidState();\n        } else if (block.timestamp < a.timings.endTimestamp) {\n            if (_state != States.AcceptingBids) revert InvalidState();\n        } else if (a.data.lowestQuote != type(uint128).max) {\n            if (_state != States.Finalized) revert InvalidState();\n        } else if (block.timestamp <= a.timings.endTimestamp + 24 hours) {\n            if (_state != States.RevealPeriod) revert InvalidState();\n        } else if (block.timestamp > a.timings.endTimestamp + 24 hours) {\n            if (_state != States.Voided) revert InvalidState();\n        } else {\n            revert();\n        }\n        _;\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n    ///                          AUCTION LOGIC                          ///\n    ///////////////////////////////////////////////////////////////////////\n\n    /// @notice Creates a new sealed auction\n    /// @dev Transfers the `baseToken` from `msg.sender` to the contract\n    /// @return `auctionId` unique to that auction\n    /// @param auctionParams Parameters used during the auction\n    /// @param timings The timestamps at which the auction starts/ends\n    /// @param encryptedSellerPrivKey Encrypted seller's ephemeral private key\n    function createAuction(\n        AuctionParameters calldata auctionParams,\n        Timings calldata timings,\n        bytes calldata encryptedSellerPrivKey\n    ) external returns (uint256) {\n        if (timings.endTimestamp <= block.timestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.startTimestamp >= timings.endTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.endTimestamp > timings.vestingStartTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.vestingStartTimestamp > timings.vestingEndTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.cliffPercent > 1e18) {\n            revert InvalidCliffPercent();\n        }\n        // Revert if the min bid is more than the total reserve of the auction\n        if (\n            FixedPointMathLib.mulDivDown(\n                auctionParams.minimumBidQuote, type(uint128).max, auctionParams.totalBaseAmount\n            ) > auctionParams.reserveQuotePerBase\n        ) {\n            revert InvalidReserve();\n        }\n\n        uint256 auctionId = ++currentAuctionId;\n\n        Auction storage a = idToAuction[auctionId];\n        a.timings = timings;\n\n        a.data.seller = msg.sender;\n        a.data.lowestQuote = type(uint128).max;\n\n        a.params = auctionParams;\n\n        // Passes https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol#L9\n        // Transfer base tokens to auction contract and check for tax tokens\n        uint256 balanceBeforeTransfer = ERC20(auctionParams.baseToken).balanceOf(address(this));\n\n        SafeTransferLib.safeTransferFrom(\n            ERC20(auctionParams.baseToken), msg.sender, address(this), auctionParams.totalBaseAmount\n        );\n\n        uint256 balanceAfterTransfer = ERC20(auctionParams.baseToken).balanceOf(address(this));\n        if (balanceAfterTransfer - balanceBeforeTransfer != auctionParams.totalBaseAmount) {\n            revert UnexpectedBalanceChange();\n        }\n\n        emit AuctionCreated(auctionId, msg.sender, auctionParams, timings, encryptedSellerPrivKey);\n\n        return auctionId;\n    }\n\n    /// @notice Bid on a runnning auction\n    /// @dev Transfers `quoteAmount` of `quoteToken` from bidder to contract\n    /// @return Index of the bid\n    /// @param auctionId Id of the auction to bid on\n    /// @param quoteAmount Amount of `quoteTokens` bidding on a committed amount of `baseTokens`\n    /// @param commitment Hash commitment of the `baseAmount`\n    /// @param pubKey Public key used to encrypt `baseAmount`\n    /// @param encryptedMessage `baseAmount` encrypted to the seller's public key\n    /// @param encryptedPrivateKey Encrypted private key for on-chain storage\n    /// @param proof Merkle proof that checks seller against `merkleRoot` if there is a whitelist\n    function bid(\n        uint256 auctionId,\n        uint128 quoteAmount,\n        bytes32 commitment,\n        ECCMath.Point calldata pubKey,\n        bytes32 encryptedMessage,\n        bytes calldata encryptedPrivateKey,\n        bytes32[] calldata proof\n    ) external atState(idToAuction[auctionId], States.AcceptingBids) returns (uint256) {\n        Auction storage a = idToAuction[auctionId];\n        if (a.params.merkleRoot != bytes32(0)) {\n            bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n            if (!MerkleProofLib.verify(proof, a.params.merkleRoot, leaf)) {\n                revert InvalidProof();\n            }\n        }\n\n        // Seller cannot bid on their own auction\n        if (msg.sender == a.data.seller) {\n            revert UnauthorizedCaller();\n        }\n\n        if (quoteAmount == 0 || quoteAmount == type(uint128).max || quoteAmount < a.params.minimumBidQuote) {\n            revert InvalidBidAmount();\n        }\n\n        EncryptedBid memory ebid;\n        ebid.sender = msg.sender;\n        ebid.quoteAmount = quoteAmount;\n        ebid.commitment = commitment;\n        ebid.pubKey = pubKey;\n        ebid.encryptedMessage = encryptedMessage;\n\n        uint256 bidIndex = a.bids.length;\n        // Max of 1000 bids on an auction to prevent DOS\n        if (bidIndex >= 1000) {\n            revert InvalidState();\n        }\n\n        a.bids.push(ebid);\n\n        SafeTransferLib.safeTransferFrom(ERC20(a.params.quoteToken), msg.sender, address(this), quoteAmount);\n\n        emit Bid(\n            msg.sender, auctionId, bidIndex, quoteAmount, commitment, pubKey, encryptedMessage, encryptedPrivateKey\n        );\n\n        return bidIndex;\n    }\n\n    /// @notice Reveals the private key of the seller\n    /// @dev All valid bids are decrypted after this\n    ///      finalizeData should be empty if seller does not wish to finalize in this tx\n    /// @param privateKey Private key corresponding to the auctions public key\n    /// @param finalizeData Calldata that will be sent to finalize()\n    function reveal(uint256 auctionId, uint256 privateKey, bytes calldata finalizeData)\n        external\n        atState(idToAuction[auctionId], States.RevealPeriod)\n    {\n        Auction storage a = idToAuction[auctionId];\n        if (a.data.seller != msg.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        ECCMath.Point memory pubKey = ECCMath.publicKey(privateKey);\n        if (pubKey.x != a.params.pubKey.x || pubKey.y != a.params.pubKey.y || (pubKey.x == 1 && pubKey.y == 1)) {\n            revert InvalidPrivateKey();\n        }\n\n        a.data.privKey = privateKey;\n\n        emit RevealedKey(auctionId, privateKey);\n\n        if (finalizeData.length != 0) {\n            (uint256[] memory bidIndices, uint128 clearingBase, uint128 clearingQuote) =\n                abi.decode(finalizeData, (uint256[], uint128, uint128));\n            finalize(auctionId, bidIndices, clearingBase, clearingQuote);\n        }\n    }\n\n    // Used to get around stack too deep errors -- even with viaIr\n    struct FinalizeData {\n        uint256 reserveQuotePerBase;\n        uint128 totalBaseAmount;\n        uint128 filledBase;\n        uint256 previousQuotePerBase;\n        uint256 previousIndex;\n    }\n\n    /// @notice Finalises an auction by revealing all bids\n    /// @dev Calculates the minimum `quotePerBase` and marks successful bids\n    /// @param auctionId `auctionId` of the auction to bid on\n    /// @param bidIndices Bids sorted by price descending\n    /// @param clearingBase Denominator in the clearing price calculation\n    /// @param clearingQuote Numerator in the clearing price calculation\n    function finalize(uint256 auctionId, uint256[] memory bidIndices, uint128 clearingBase, uint128 clearingQuote)\n        public\n        atState(idToAuction[auctionId], States.RevealPeriod)\n    {\n        Auction storage a = idToAuction[auctionId];\n        uint256 sellerPriv = a.data.privKey;\n        if (sellerPriv == 0) {\n            revert InvalidPrivateKey();\n        }\n\n        if (bidIndices.length != a.bids.length) {\n            revert InvalidCalldata();\n        }\n\n        FinalizeData memory data;\n        data.reserveQuotePerBase = a.params.reserveQuotePerBase;\n        data.totalBaseAmount = a.params.totalBaseAmount;\n        data.previousQuotePerBase = type(uint256).max;\n\n        // Last filled bid is the clearing price\n        a.data.lowestBase = clearingBase;\n        a.data.lowestQuote = clearingQuote;\n\n        // Bitmap of all the bid indices that have been processed\n        uint256[] memory seenBidMap = new uint256[]((bidIndices.length/256)+1);\n\n        // Fill orders from highest price to lowest price\n        for (uint256 i; i < bidIndices.length; i++) {\n            uint256 bidIndex = bidIndices[i];\n            EncryptedBid storage b = a.bids[bidIndex];\n\n            // Verify this bid index hasn't been seen before\n            uint256 bitmapIndex = bidIndex / 256;\n            uint256 bitMap = seenBidMap[bitmapIndex];\n            uint256 indexBit = 1 << (bidIndex % 256);\n            if (bitMap & indexBit == 1) revert InvalidState();\n            seenBidMap[bitmapIndex] = bitMap | indexBit;\n\n            // G^k1^k2 == G^k2^k1\n            ECCMath.Point memory sharedPoint = ECCMath.ecMul(b.pubKey, sellerPriv);\n            // If the bidder public key isn't on the bn128 curve\n            if (sharedPoint.x == 1 && sharedPoint.y == 1) continue;\n\n            bytes32 decryptedMessage = ECCMath.decryptMessage(sharedPoint, b.encryptedMessage);\n            // If the bidder didn't faithfully submit commitment or pubkey\n            // Or the bid was cancelled\n            if (computeCommitment(decryptedMessage) != b.commitment) continue;\n\n            // First 128 bits are the base amount, last are random salt\n            uint128 baseAmount = uint128(uint256(decryptedMessage >> 128));\n\n            // Require that bids are passed in descending price\n            uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount);\n            if (quotePerBase >= data.previousQuotePerBase) {\n                // If last bid was the same price, make sure we filled the earliest bid first\n                if (quotePerBase == data.previousQuotePerBase) {\n                    if (data.previousIndex > bidIndex) revert InvalidSorting();\n                } else {\n                    revert InvalidSorting();\n                }\n            }\n\n            // Only fill if above reserve price\n            if (quotePerBase < data.reserveQuotePerBase) continue;\n\n            // Auction has been fully filled\n            if (data.filledBase == data.totalBaseAmount) continue;\n\n            data.previousQuotePerBase = quotePerBase;\n            data.previousIndex = bidIndex;\n\n            // Fill the remaining unfilled base amount\n            if (data.filledBase + baseAmount > data.totalBaseAmount) {\n                baseAmount = data.totalBaseAmount - data.filledBase;\n            }\n\n            b.filledBaseAmount = baseAmount;\n            data.filledBase += baseAmount;\n        }\n\n        if (data.previousQuotePerBase != FixedPointMathLib.mulDivDown(clearingQuote, type(uint128).max, clearingBase)) {\n            revert InvalidCalldata();\n        }\n\n        // seenBidMap[0:len-1] should be full\n        for (uint256 i; i < seenBidMap.length - 1; i++) {\n            if (seenBidMap[i] != type(uint256).max) {\n                revert InvalidState();\n            }\n        }\n\n        // seenBidMap[-1] should only have the last N bits set\n        if (seenBidMap[seenBidMap.length - 1] != (1 << (bidIndices.length % 256)) - 1) {\n            revert InvalidState();\n        }\n\n        if (data.filledBase > data.totalBaseAmount) {\n            revert InvalidState();\n        }\n\n        // Transfer the left over baseToken\n        if (data.totalBaseAmount != da"
    }
  ]
}