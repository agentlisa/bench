{
  "Title": "M-3: L2 sequencer down will push an auction's price down, causing unfair liquidation prices, and potentially guaranteeing bad debt",
  "Content": "# Issue M-3: L2 sequencer down will push an auction's price down, causing unfair liquidation prices, and potentially guaranteeing bad debt \n\nSource: https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/60 \n\n## Found by \nPUSH0, zzykxx\n## Summary\n\nThe protocol implements a L2 sequencer downtime check in the Registry. In the event of sequencer downtime (as well as a grace period following recovery), liquidations are disabled for the rightful reasons.\n\nHowever, while the sequencer is down, any ongoing auctions' price decay is still ongoing. When the sequencer goes back online, it will be possible to liquidate for a much lower price, guaranteeing bad debt past a certain point.\n\n## Vulnerability Detail\n\nWhile the price oracle has sequencer uptime checks, the liquidation auction's price curve calculation does not. The liquidation price is a function with respect to the user's total debt versus their total collateral. \n\nDue to no sequencer check within the liquidator, the liquidation price continues to decay when the sequencer is down. It is possible for the liquidation price to drop below 100%, that is, it is then possible to liquidate all collateral without repaying all debt. \n\nAny ongoing liquidations that are temporarily blocked by a sequencer outage will continue to experience price decay. When the sequencer goes back online, liquidation will have dropped significantly in price, causing liquidation to happen at an unfair price as well. Furthermore, longer downtime durations will make it possible to seize all collateral for less than $100\\\\%$ debt, guaranteeing bad debt for the protocol.\n\n### Proof of concept\n\nWe use the [default liquidator parameters defined in the constructor](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/lending-v2/src/Liquidator.sol#L103-L117) for our example:\n- Starting multiplier is 150%. \n- Final multiplier is 60%.\n- Half-life duration is 1 hour.\n- Cutoff time is irrelevant.\n\nConsider the following scenario:\n\n1. Bob's account becomes liquidatable. Someone triggers liquidation start.\n2. Anyone can now buy $100\\\\%$ of Bob's collateral for the price of $150\\\\%$ of Bob's debt. However, this is not profitable yet, so everyone waits for the price to drop a bit more.\n3. After 30 minutes, auction price is now $60\\\\% + 90\\\\% * 0.5^{0.5} = 123.63\\\\%$ of Bob's debt for $100\\\\%$ collateral. Market price hasn't moved much, so this is still not profitable yet.\n4. Sequencer goes down for one hour, not counting grace period. Note that Arbitrum's sequencer has experienced multiple outages of this duration in the past. In 2022, there was an outage of [approx. seven hours](https://cointelegraph.com/news/arbitrum-network-suffers-minor-outage-due-to-hardware-failure). There was also a 78-minute outage [just December 2023](https://cointelegraph.com/news/arbitrum-network-goes-offline-december-15).\n6. When the sequencer goes up, the auction has been going on for 1.5 hours, or 1.5 half-lives. Auction price is now $60\\\\% + 90\\\\% * 0.5^{1.5} = 91.82\\\\%$.\n7. Liquidation is now profitable. All of Bob's collaterals are liquidated, but the buyer only has to repay $91.82\\\\%$ of Bob's debt. Bob is left with $0$ collateral but positive debt (specifically, $8.18\\\\%$ of his original debt).\n\nThe impact becomes more severe the longer the sequencer goes down. In addition, the grace period on top of it will decay the auction price even further, before the auction can be back online.\n- In the above scenario, if the sequencer outage plus grace period is $2$ hours, then the repaid debt percentage is only $60\\\\% + 90\\\\% * 0.5^{2.5} = 75.91\\\\%$\n\nFurthermore, even if downtime is not enough to bring down the multiplier to less than $100\\\\%$, Bob will still incur unfair loss due to his collateral being sold at a lower price anyway. Therefore any duration of sequencer downtime will cause an unfair loss.\n\n## Impact\n\nAny ongoing liquidations during a sequencer outage event will execute at a lower debt-to-collateral ratio, potentially guaranteeing bad debt and/or user being liquidated for a lower price.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-arcadia/blob/main/lending-v2/src/Liquidator.sol#L364-L395\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAuctions' price curve should either check and exclude sequencer downtime alongside its grace period, or said auctions should simply be voided.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid\n\n\n\n**nevillehuang**\n\nSince it was mentioned in the contest details as the following, I believe the exception highlighted in [point 20. of sherlock rules](https://docs.sherlock.xyz/audits/judging/judging) applies here, so leaving as medium severity.\n\n> Chainlink and contracts of primary assets are TRUSTED, others are RESTRICTED\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/arcadia-finance/lending-v2/pull/136.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/137",
  "Code": [
    {
      "filename": "lending-v2/src/Liquidator.sol",
      "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { AssetValueAndRiskFactors } from \"../lib/accounts-v2/src/libraries/AssetValuationLib.sol\";\nimport { ERC20, SafeTransferLib } from \"../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { FixedPointMathLib } from \"../lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport { IAccount } from \"./interfaces/IAccount.sol\";\nimport { ICreditor } from \"../lib/accounts-v2/src/interfaces/ICreditor.sol\";\nimport { IFactory } from \"./interfaces/IFactory.sol\";\nimport { ILendingPool } from \"./interfaces/ILendingPool.sol\";\nimport { ILiquidator } from \"./interfaces/ILiquidator.sol\";\nimport { LogExpMath } from \"./libraries/LogExpMath.sol\";\nimport { LiquidatorErrors } from \"./libraries/Errors.sol\";\nimport { Owned } from \"../lib/solmate/src/auth/Owned.sol\";\nimport { ReentrancyGuard } from \"../lib/solmate/src/utils/ReentrancyGuard.sol\";\n\n/**\n * @title Liquidator.\n * @author Pragma Labs\n * @notice The Liquidator manages the Dutch auctions, used to sell collateral of unhealthy Arcadia Accounts.\n */\ncontract Liquidator is Owned, ReentrancyGuard, ILiquidator {\n    using FixedPointMathLib for uint256;\n    using SafeTransferLib for ERC20;\n    /* //////////////////////////////////////////////////////////////\n                               CONSTANTS\n    ////////////////////////////////////////////////////////////// */\n\n    // The unit for fixed point numbers with 4 decimals precision.\n    uint16 internal constant ONE_4 = 10_000;\n    // Contract address of the Arcadia Account Factory.\n    address internal immutable ACCOUNT_FACTORY;\n\n    /* //////////////////////////////////////////////////////////////\n                                STORAGE\n    ////////////////////////////////////////////////////////////// */\n\n    // The base of the auction price curve (decreasing power function).\n    // Determines in what time the auction price halves, 18 decimals precision.\n    uint64 internal base;\n    // The time after which the auction is considered not successful, in seconds.\n    uint32 internal cutoffTime;\n    // Sets the begin price of the auction, 4 decimals precision.\n    uint16 internal startPriceMultiplier;\n    // Sets the minimum price the auction converges to, 4 decimals precision.\n    uint16 internal minPriceMultiplier;\n    // Map of creditor to address to which all assets are transferred to after an unsuccessful auction.\n    mapping(address => address) internal creditorToAccountRecipient;\n\n    // Map Account => auctionInformation.\n    mapping(address => AuctionInformation) public auctionInformation;\n\n    // Struct with additional information about the auction of a specific Account.\n    struct AuctionInformation {\n        // The open debt, denominated in the Creditor's Numeraire.\n        uint128 startDebt;\n        // The base of the auction price curve.\n        uint64 base;\n        // The timestamp after which the auction is considered not successful.\n        uint32 cutoffTimeStamp;\n        // The timestamp the auction started.\n        uint32 startTime;\n        // The contract address of the Creditor.\n        address creditor;\n        // The minimum margin of the Account.\n        uint96 minimumMargin;\n        // Sets the begin price of the auction, 4 decimals precision.\n        uint16 startPriceMultiplier;\n        // Sets the minimum price the auction converges to, 4 decimals precision.\n        uint16 minPriceMultiplier;\n        // Flag indicating if the auction is still ongoing.\n        bool inAuction;\n        // The contract address of each asset in the Account, at the moment the liquidation was initiated.\n        address[] assetAddresses;\n        // The relative value of each asset in the Account (the \"assetShare\") with respect to the total value of the Account,\n        // at the moment the liquidation was initiated, 4 decimals precision.\n        uint32[] assetShares;\n        // The amount of each asset in the Account, at the moment the liquidation was initiated.\n        uint256[] assetAmounts;\n        // The ids of each asset in the Account, at the moment the liquidation was initiated.\n        uint256[] assetIds;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                EVENTS\n    ////////////////////////////////////////////////////////////// */\n\n    event AuctionCurveParametersSet(\n        uint64 base, uint32 cutoffTime, uint16 startPriceMultiplier, uint16 minPriceMultiplier\n    );\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice The constructor for the Liquidator.\n     * @param accountFactory The contract address of the Arcadia Account Factory.\n     */\n    constructor(address accountFactory) Owned(msg.sender) {\n        ACCOUNT_FACTORY = accountFactory;\n\n        // Half life of 3600s.\n        base = 999_807_477_651_317_446;\n        // 4 hours.\n        cutoffTime = 14_400;\n        // 150%.\n        startPriceMultiplier = 15_000;\n        // 60%.\n        minPriceMultiplier = 6000;\n\n        emit AuctionCurveParametersSet(999_807_477_651_317_446, 14_400, 15_000, 6000);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    AUCTION ACCOUNT RECIPIENT\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice The Account recipient receives the Accounts after an unsuccessful auction.\n     * @param creditor The contract address of the Creditor for which the Account recipient is set.\n     * @param accountRecipient The address of the new Account recipient for a given creditor.\n     * @dev This function can only be called by the Risk Manager of the Creditor.\n     */\n    function setAccountRecipient(address creditor, address accountRecipient) external {\n        if (msg.sender != ICreditor(creditor).riskManager()) revert LiquidatorErrors.NotAuthorized();\n        creditorToAccountRecipient[creditor] = accountRecipient;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    AUCTION PRICE CURVE PARAMETERS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Sets the parameters of the auction price curve (decreasing power function).\n     * @param halfLifeTime The base is not set directly, but it's derived from a more intuitive parameter, the halfLifeTime:\n     * The time ΔT_hl (in seconds with 0 decimals) it takes for the power function to halve in value.\n     * @param cutoffTime_ The time after which the auction is considered not successful.\n     * After the cutoffTime, the remaining assets are transferred to the protocol owner to be sold manually.\n     * @param startPriceMultiplier_ The start price multiplier, with 4 decimals precision.\n     * @param minPriceMultiplier_ The minimum price multiplier, with 4 decimals precision.\n     * @dev The relation between the base and the halfLife time (ΔT_hl):\n     * The power function is defined as: N(t) = N(0) * (1/2)^(t/ΔT_hl).\n     * Or simplified: N(t) = N(O) * base^t => base = 1/[2^(1/ΔT_hl)].\n     * @dev Setting a very short cutoffTime can be used by rogue owners to rug the most junior tranche(s)!!\n     * Therefore the cutoffTime has hardcoded constraints.\n     * @dev The start price multiplier is a multiplier that is used to increase the initial price of the auction.\n     * Since the value of all assets are discounted with the liquidation factor, and because pricing modules will take a conservative\n     * approach to price assets (eg. floor-prices for NFTs), the actual value of the assets being auctioned might be substantially higher\n     * than the open debt. Hence the auction starts at a multiplier of the openDebt, but decreases rapidly (exponential decay).\n     * @dev The minimum price multiplier sets a lower bound to which the auction price converges.\n     * @dev All calculations are done with 18 decimals precision.\n     */\n    function setAuctionCurveParameters(\n        uint32 halfLifeTime,\n        uint32 cutoffTime_,\n        uint16 startPriceMultiplier_,\n        uint16 minPriceMultiplier_\n    ) external onlyOwner {\n        // Checks that halfLifeTime and cutoffTime_ are within reasonable boundaries.\n        if (halfLifeTime < 120) revert LiquidatorErrors.HalfLifeTimeTooLow(); // 2 minutes.\n        if (halfLifeTime > 28_800) revert LiquidatorErrors.HalfLifeTimeTooHigh(); // 8 hours.\n        if (cutoffTime_ < 3600) revert LiquidatorErrors.CutOffTooLow(); // 1 hour.\n        if (cutoffTime_ > 64_800) revert LiquidatorErrors.CutOffTooHigh(); // 18 hours.\n\n        // Derive base from the halfLifeTime.\n        uint64 base_ = uint64(1e18 * 1e18 / LogExpMath.pow(2 * 1e18, 1e18 / halfLifeTime));\n\n        // Check that LogExpMath.pow(base, timePassed) does not error at cutoffTime (due to numbers smaller than minimum precision).\n        // Since LogExpMath.pow is a strictly decreasing function checking the power function at cutoffTime\n        // guarantees that the function does not revert on all timestamps between start of the auction and the cutoffTime.\n        LogExpMath.pow(base_, uint256(cutoffTime_) * 1e18);\n\n        // Checks that startPriceMultiplier_ and minPriceMultiplier_ are within reasonable boundaries.\n        if (startPriceMultiplier_ < 10_000) revert LiquidatorErrors.MultiplierTooLow();\n        if (startPriceMultiplier_ > 30_000) revert LiquidatorErrors.MultiplierTooHigh();\n        if (minPriceMultiplier_ > 9000) revert LiquidatorErrors.MultiplierTooHigh();\n\n        // Store the new parameters.\n        emit AuctionCurveParametersSet(\n            base = base_,\n            cutoffTime = cutoffTime_,\n            startPriceMultiplier = startPriceMultiplier_,\n            minPriceMultiplier = minPriceMultiplier_\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                      LIQUIDATION INITIATION\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Initiate the liquidation of an Account.\n     * @param account The contract address of the Account to be liquidated.\n     */\n    function liquidateAccount(address account) external nonReentrant {\n        if (!IFactory(ACCOUNT_FACTORY).isAccount(account)) revert LiquidatorErrors.IsNotAnAccount();\n\n        AuctionInformation storage auctionInformation_ = auctionInformation[account];\n\n        // Check if the account is already being auctioned.\n        if (auctionInformation_.inAuction) revert LiquidatorErrors.AuctionOngoing();\n\n        // Set the inAuction flag to true.\n        auctionInformation_.inAuction = true;\n\n        // Store the auction price-curve parameters.\n        // This ensures that changes of the price-curve parameters do not impact ongoing auctions.\n        auctionInformation_.base = base;\n        auctionInformation_.startTime = uint32(block.timestamp);\n        auctionInformation_.cutoffTimeStamp = uint32(block.timestamp) + cutoffTime;\n        auctionInformation_.startPriceMultiplier = startPriceMultiplier;\n        auctionInformation_.minPriceMultiplier = minPriceMultiplier;\n\n        // Check if the Account is insolvent and if it is, start the liquidation in the Account.\n        // startLiquidation will revert if the Account is still solvent.\n        (\n            address[] memory assetAddresses,\n            uint256[] memory assetIds,\n            uint256[] memory assetAmounts,\n            address creditor,\n            uint96 minimumMargin,\n            uint256 debt,\n            AssetValueAndRiskFactors[] memory assetValues\n        ) = IAccount(account).startLiquidation(msg.sender);\n\n        // Store the Account information.\n        auctionInformation_.assetAddresses = assetAddresses;\n        auctionInformation_.assetIds = assetIds;\n        auctionInformation_.assetAmounts = assetAmounts;\n        auctionInformation_.creditor = creditor;\n        auctionInformation_.minimumMargin = minimumMargin;\n        auctionInformation_.startDebt = uint128(debt);\n\n        // Store the relative value of each asset (the \"assetShare\"), with respect to the total value of the Account.\n        // These will be used to calculate the price of bids to partially liquidate the Account.\n        auctionInformation_.assetShares = _getAssetShares(assetValues);\n    }\n\n    /**\n     * @notice Calculate the relative value of each asset, with respect to the total value of the Account.\n     * @param assetValues An array with the values of each asset in the Account.\n     * @return assetShares An array of asset shares, with 4 decimals precision.\n     */\n    function _getAssetShares(AssetValueAndRiskFactors[] memory assetValues)\n        internal\n        pure\n        returns (uint32[] memory assetShares)\n    {\n        uint256 length = assetValues.length;\n        uint256 totalValue;\n        for (uint256 i; i < length; ++i) {\n            unchecked {\n                totalValue += assetValues[i].assetValue;\n            }\n        }\n        assetShares = new uint32[](length);\n\n        if (totalValue == 0) return assetShares;\n\n        for (uint256 i; i < length; ++i) {\n            // The asset shares are calculated relative to the total value of the Account.\n            assetShares[i] = uint32(assetValues[i].assetValue.mulDivUp(ONE_4, totalValue));\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                      LIQUIDATION BIDS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Places a bid.\n     * @param account The contract address of the Account being liquidated.\n     * @param askedAssetAmounts Array with the assets-amounts the bidder wants to buy.\n     * @param endAuction_ Bool indicating that the auction can be ended after the bid.\n     * @dev We use a Dutch auction: price of the assets constantly decreases.\n     * @dev The \"askedAssetAmounts\" array should have equal length as the stored \"assetAmounts\" array.\n     * An amount 0 should be passed for assets the bidder does not want to buy.\n     * @dev The bidder is not obliged to set endAuction to True if the account is healthy after the bid,\n     * but they are incentivised to do so by earning an additional \"auctionTerminationReward\".\n     */\n    function bid(address account, uint256[] memory askedAssetAmounts, bool endAuction_) external nonReentrant {\n        AuctionInformation storage auctionInformation_ = auctionInformation[account];\n        if (!auctionInformation_.inAuction) revert LiquidatorErrors.NotForSale();\n\n        // Calculate the current auction price of the assets being bought.\n        uint256 totalShare = _calculateTotalShare(auctionInformation_, askedAssetAmounts);\n        uint256 price = _calculateBidPrice(auctionInformation_, totalShare);\n\n        // Transfer an amount of \"price\" in \"Numeraire\" to the LendingPool to repay the Accounts debt.\n        // The LendingPool will call a \"transferFrom\" from the bidder to the pool -> the bidder must approve the LendingPool.\n        // If the amount transferred would exceed the debt, the surplus is paid out to the Account Owner and earlyTerminate is True.\n        uint128 startDebt = auctionInformation_.startDebt;\n        bool earlyTerminate = ILendingPool(auctionInformation_.creditor).auctionRepay(\n            startDebt, auctionInformation_.minimumMargin, price, account, msg.sender\n        );\n\n        // Transfer the assets to the bidder.\n        IAccount(account).auctionBid(\n            auctionInformation_.assetAddresses, auctionInformation_.assetIds, askedAssetAmounts, msg.sender\n        );\n\n        // If all the debt is repaid, the auction must be ended, even if the bidder did not set endAuction to true.\n        if (earlyTerminate) {\n            // Stop the auction, no need to do a health check for the account since it has no debt anymore.\n            _endAuction(account);\n        }\n        // If not all debt is repaid, the bidder can still earn a termination incentive by ending the auction\n        // if one of the conditions to end the auction is met.\n        // \"_endAuction()\" will silently fail without reverting, if the auction was not successfully ended.\n        else if (endAuction_) {\n            if (_settleAuction(account, auctionInformation_)) _endAuction(account);\n        }\n    }\n\n    /**\n     * @notice Calculates the share of the initial assets the bidder wants to buy.\n     * @param auctionInformation_ The auction information.\n     * @param askedAssetAmounts Array with the assets-amounts the bidder wants to buy.\n     * @return totalShare The share of initial assets the bidder wants to buy, 4 decimals precision.\n     * @dev totalShare is calculated based on the relative value of the assets when the auction was initiated.\n     */\n    function _calculateTotalShare(AuctionInformation storage auctionInformation_, uint256[] memory askedAssetAmounts)\n        internal\n        view\n        returns (uint256 totalShare)\n    {\n        uint256[] memory assetAmounts = auctionInformation_.assetAmounts;\n        uint32[] memory assetShares = auctionInformation_.assetShares;\n        if (assetAmounts.length != askedAssetAmounts.length) {\n            revert LiquidatorErrors.InvalidBid();\n        }\n\n        // When askedAssetAmounts[i] is greater than assetAmounts[i], _withdraw() will revert in the Account.\n        for (uint256 i; i < askedAssetAmounts.length; ++i) {\n            unchecked {\n                totalShare += askedAssetAmounts[i].mulDivUp(assetShares[i], assetAmounts[i]);\n            }\n        }\n    }\n\n    /**\n     * @notice Function returns the current auction price given time passed and a bid.\n     * @param auctionInformation_ The auction information.\n     * @param totalShare The share of initial assets the bidder wants to buy,\n     * calculated based on the relative value of the assets when the auction was initiated.\n     * @return price The price for which the bid can be purchased, denominated in the Numeraire.\n     * @dev We use a Dutch auction: price of the assets constantly decreases.\n     * @dev Price P(t) decreases exponentially over time: P(t) = Debt * S * [(SPM - MPM) * base^t + MPM]:\n     * Debt: The total debt of the Account at the moment the auction was initiated.\n     * S: The share of the assets being bought in the bid.\n     * SPM: The startPriceMultiplier defines the initial price: P(0) = Debt * S * SPM (4 decimals precision).\n     * MPM: The minPriceMultiplier defines the asymptotic end price for P(∞) = Debt * MPM (4 decimals precision).\n     * base: defines how fast the exponential curve decreases (18 decimals precision).\n     * t: time passed since start auction (in seconds, 18 decimals precision).\n     * @dev LogExpMath was made in solidity 0.7, where operations were unchecked.\n     * @dev Successful bids are only guaranteed until the cutoffTime.\n     * Calculating the bid price after the cutoffTime will revert at some point (due to too low precision of the LogExpMath library).\n     * Take this into account for bids done after the cutoffTime.\n     */\n    function _calculateBidPrice(AuctionInformation storage auctionInformation_, uint256 totalShare)\n        internal\n        view\n        returns (uint256 price)\n    {\n        unchecked {\n            // Calculate the time passed since the auction started and bring to 18 decimals precision,\n            // as required by LogExpMath.pow()\n            // No overflow possible: uint32 * uint64.\n            uint256 timePassed = (block.timestamp - auctionInformation_.startTime) * 1e18;\n\n            // Cache minPriceMultiplier.\n            uint256 minPriceMultiplier_ = auctionInformation_.minPriceMultiplier;\n\n            // Calculate askPrice as: P = Debt * S * [(SPM - MPM) * base^t + MPM]\n            // P: price, denominated in the Numeraire.\n            // Debt: The initial debt of the Account, denominated in the Numeraire.\n            // S: The share of assets being bought, 4 decimals precision\n            // SPM and MPM: multipliers to scale the price curve, 4 decimals precision.\n            // base^t: the exponential decay over time of the price (strictly smaller than 1), has 18 decimals precision.\n            // Since the result must be denominated in the Numeraire, we need to divide by 1e26 (1e18 + 1e4 + 1e4).\n            // No overflow possible: uint128 * uint32 * uint18 * uint18.\n            price = (\n                auctionInformation_.startDebt * totalShare\n                    * (\n                        LogExpMath.pow(auctionInformation_.base, timePassed)\n                            * (auctionInformation_.startPriceMultiplier - minPriceMultiplier_)\n                            + 1e18 * uint256(minPriceMultiplier_)\n                    )\n            ) / 1e26;\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    LIQUIDATION TERMINATION\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Ends an auction and settles the liquidation.\n     * @param account The contract address of the account in liquidation.\n     */\n    function endAuction(address account) external nonReentrant {\n        AuctionInformation storage auctionInformation_ = auctionInformation[account];\n\n        // Check if the account is being auctioned.\n        if (!auctionInformation_.inAuction) revert LiquidatorErrors.NotForSale();\n\n        if (!_settleAuction(account, auctionInformation_)) revert LiquidatorErrors.EndAuctionFailed();\n\n        _endAuction(account);\n    }\n\n    /**\n     * @notice Ends an auction and settles the liquidation.\n     * @param account The contract address of the account in liquidation.\n     * @param auctionInformation_ The struct containing all the auction information.\n     * @dev There are four different conditions on which an auction can be successfully ended.\n     * This function will check three of the four conditions (the fourth is already checked in the bid-function):\n     *  1) The Account is back in a healthy state (collateral value is equal or bigger than the used margin).\n     *  2) There are no remaining assets in the Account left to sell.\n     *  3) The Auction did not finish within the cutoff-period.\n     *  4) All open debt was repaid (not checked within this function).\n     * @dev If the third condition is met, an emergency process is triggered.\n     * The auction will be stopped and the remaining assets of the Account will be transferred to the Liquidator owner.\n     * The Tranches of the liquidity pool will pay for the bad debt.\n     * The protocol will sell/auction the assets manually to recover the debt.\n     * The protocol will later \"donate\" these proceeds back to the\n     * impacted Tranches, this last step is not enforced by the smart contracts.\n     * While this process is not fully trustless, it is the only way to solve an extreme unhappy flow,\n     * where an auction did not end within cutoffTime (due to market or technical reasons).\n     */\n    function _settleAuction(address account, AuctionInformation storage auctionInformation_)\n        internal\n        returns (bool success)\n    {\n        // Cache variables.\n        uint256 startDebt = auctionInformation_.startDebt;\n        address creditor = auctionInformation_.creditor;\n        uint96 minimumMargin = auctionInformation_.minimumMargin;\n\n        uint256 collateralValue = IAccount(account).getCollateralValue();\n        uint256 usedMargin = IAccount(account).getUsedMargin();\n\n        // Check the different conditions to end the auction.\n        if (collateralValue >= usedMargin || usedMargin == minimumMargin) {\n            // Happy flow: Account is back in a healthy state.\n            // An Account is healthy if the collateral value is equal or greater than the used margin.\n            // If usedMargin is equal to minimumMargin, the open liabilities are 0 and the Account is always healthy.\n            ILendingPool(creditor).settleLiquidationHappyFlow(account, startDebt, minimumMargin, msg.sender);\n        } else if (collateralValue == 0) {\n            // Unhappy flow: All collateral is sold.\n            ILendingPool(creditor).settleLiquidationUnhappyFlow(account, startDebt, minimumMargin, msg.sender);\n        } else if (block.timestamp > auctionInformation_.cutoffTimeStamp) {\n            // Unhappy flow: Auction did not end within the cutoffTime.\n            ILendingPool(creditor).settleLiquidationUnhappyFlow(account, startDebt, minimumMargin, msg.sender);\n            // All remaining assets are transferred to the asset recipient,\n            // and a manual (trusted) liquidation has to be done.\n            IAccount(account).auctionBoughtIn(creditorToAccountRecipient[creditor]);\n        } else {\n            // None of the conditions to end the auction are met.\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Ends the liquidation on the Account and removes data stored related to the auction.\n     */\n    function _endAuction(address account) internal {\n        delete auctionInformation[account];\n        IAccount(account).endAuction();\n    }\n}"
    },
    {
      "filename": "lending-v2/src/Liquidator.sol",
      "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { AssetValueAndRiskFactors } from \"../lib/accounts-v2/src/libraries/AssetValuationLib.sol\";\nimport { ERC20, SafeTransferLib } from \"../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { FixedPointMathLib } from \"../lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport { IAccount } from \"./interfaces/IAccount.sol\";\nimport { ICreditor } from \"../lib/accounts-v2/src/interfaces/ICreditor.sol\";\nimport { IFactory } from \"./interfaces/IFactory.sol\";\nimport { ILendingPool } from \"./interfaces/ILendingPool.sol\";\nimport { ILiquidator } from \"./interfaces/ILiquidator.sol\";\nimport { LogExpMath } from \"./libraries/LogExpMath.sol\";\nimport { LiquidatorErrors } from \"./libraries/Errors.sol\";\nimport { Owned } from \"../lib/solmate/src/auth/Owned.sol\";\nimport { ReentrancyGuard } from \"../lib/solmate/src/utils/ReentrancyGuard.sol\";\n\n/**\n * @title Liquidator.\n * @author Pragma Labs\n * @notice The Liquidator manages the Dutch auctions, used to sell collateral of unhealthy Arcadia Accounts.\n */\ncontract Liquidator is Owned, ReentrancyGuard, ILiquidator {\n    using FixedPointMathLib for uint256;\n    using SafeTransferLib for ERC20;\n    /* //////////////////////////////////////////////////////////////\n                               CONSTANTS\n    ////////////////////////////////////////////////////////////// */\n\n    // The unit for fixed point numbers with 4 decimals precision.\n    uint16 internal constant ONE_4 = 10_000;\n    // Contract address of the Arcadia Account Factory.\n    address internal immutable ACCOUNT_FACTORY;\n\n    /* //////////////////////////////////////////////////////////////\n                                STORAGE\n    ////////////////////////////////////////////////////////////// */\n\n    // The base of the auction price curve (decreasing power function).\n    // Determines in what time the auction price halves, 18 decimals precision.\n    uint64 internal base;\n    // The time after which the auction is considered not successful, in seconds.\n    uint32 internal cutoffTime;\n    // Sets the begin price of the auction, 4 decimals precision.\n    uint16 internal startPriceMultiplier;\n    // Sets the minimum price the auction converges to, 4 decimals precision.\n    uint16 internal minPriceMultiplier;\n    // Map of creditor to address to which all assets are transferred to after an unsuccessful auction.\n    mapping(address => address) internal creditorToAccountRecipient;\n\n    // Map Account => auctionInformation.\n    mapping(address => AuctionInformation) public auctionInformation;\n\n    // Struct with additional information about the auction of a specific Account.\n    struct AuctionInformation {\n        // The open debt, denominated in the Creditor's Numeraire.\n        uint128 startDebt;\n        // The base of the auction price curve.\n        uint64 base;\n        // The timestamp after which the auction is considered not successful.\n        uint32 cutoffTimeStamp;\n        // The timestamp the auction started.\n        uint32 startTime;\n        // The contract address of the Creditor.\n        address creditor;\n        // The minimum margin of the Account.\n        uint96 minimumMargin;\n        // Sets the begin price of the auction, 4 decimals precision.\n        uint16 startPriceMultiplier;\n        // Sets the minimum price the auction converges to, 4 decimals precision.\n        uint16 minPriceMultiplier;\n        // Flag indicating if the auction is still ongoing.\n        bool inAuction;\n        // The contract address of each asset in the Account, at the moment the liquidation was initiated.\n        address[] assetAddresses;\n        // The relative value of each asset in the Account (the \"assetShare\") with respect to the total value of the Account,\n        // at the moment the liquidation was initiated, 4 decimals precision.\n        uint32[] assetShares;\n        // The amount of each asset in the Account, at the moment the liquidation was initiated.\n        uint256[] assetAmounts;\n        // The ids of each asset in the Account, at the moment the liquidation was initiated.\n        uint256[] assetIds;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                EVENTS\n    ////////////////////////////////////////////////////////////// */\n\n    event AuctionCurveParametersSet(\n        uint64 base, uint32 cutoffTime, uint16 startPriceMultiplier, uint16 minPriceMultiplier\n    );\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice The constructor for the Liquidator.\n     * @param accountFactory The contract address of the Arcadia Account Factory.\n     */\n    constructor(address accountFactory) Owned(msg.sender) {\n        ACCOUNT_FACTORY = accountFactory;\n\n        // Half life of 3600s.\n        base = 999_807_477_651_317_446;\n        // 4 hours.\n        cutoffTime = 14_400;\n        // 150%.\n        startPriceMultiplier = 15_000;\n        // 60%.\n        minPriceMultiplier = 6000;\n\n        emit AuctionCurveParametersSet(999_807_477_651_317_446, 14_400, 15_000, 6000);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    AUCTION ACCOUNT RECIPIENT\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice The Account recipient receives the Accounts after an unsuccessful auction.\n     * @param creditor The contract address of the Creditor for which the Account recipient is set.\n     * @param accountRecipient The address of the new Account recipient for a given creditor.\n     * @dev This function can only be called by the Risk Manager of the Creditor.\n     */\n    function setAccountRecipient(address creditor, address accountRecipient) external {\n        if (msg.sender != ICreditor(creditor).riskManager()) revert LiquidatorErrors.NotAuthorized();\n        creditorToAccountRecipient[creditor] = accountRecipient;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    AUCTION PRICE CURVE PARAMETERS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Sets the parameters of the auction price curve (decreasing power function).\n     * @param halfLifeTime The base is not set directly, but it's derived from a more intuitive parameter, the halfLifeTime:\n     * The time ΔT_hl (in seconds with 0 decimals) it takes for the power function to halve in value.\n     * @param cutoffTime_ The time after which the auction is considered not successful.\n     * After the cutoffTime, the remaining assets are transferred to the protocol owner to be sold manually.\n     * @param startPriceMultiplier_ The start price multiplier, with 4 decimals precision.\n     * @param minPriceMultiplier_ The minimum price multiplier, with 4 decimals precision.\n     * @dev The relation between the base and the halfLife time (ΔT_hl):\n     * The power function is defined as: N(t) = N(0) * (1/2)^(t/ΔT_hl).\n     * Or simplified: N(t) = N(O) * base^t => base = 1/[2^(1/ΔT_hl)].\n     * @dev Setting a very short cutoffTime can be used by rogue owners to rug the most junior tranche(s)!!\n     * Therefore the cutoffTime has hardcoded constraints.\n     * @dev The start price multiplier is a multiplier that is used to increase the initial price of the auction.\n     * Since the value of all assets are discounted with the liquidati"
    }
  ]
}