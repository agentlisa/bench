{
  "Title": "H-2: `LIEN_TOKEN.ownerOf(i)` should be `LIEN_TOKEN.ownerOf(liensRemaining[i])`",
  "Content": "# Issue H-2: `LIEN_TOKEN.ownerOf(i)` should be `LIEN_TOKEN.ownerOf(liensRemaining[i])` \n\nSource: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/259 \n\n## Found by \n\\_\\_141345\\_\\_, 0xRajeev\n\n## Summary\n\nIn `endAuction()`, the check for public vault owner is referred to the wrong lien token id. And the actual vault lien amount is not properly recorded. \n\n\n## Vulnerability Detail\n\nThe lien token id should be queried is `liensRemaining[i]` instead of `i`.\n\n\n## Impact\n\n`YIntercept` will not be correctly recorded. The accounting for LienToken amounts will be wrong. Hence the `totalAssets` on book will be wrong, eventually the contract and users could lose fund due to the wrong accounting.\n\n\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L192-L204\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange `LIEN_TOKEN.ownerOf(i)` to `LIEN_TOKEN.ownerOf(liensRemaining[i])`.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/8",
  "Code": [
    {
      "filename": "lib/astaria-gpl/src/AuctionHouse.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.16;\n\npragma experimental ABIEncoderV2;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {IAuctionHouse} from \"./interfaces/IAuctionHouse.sol\";\nimport {ITransferProxy} from \"./interfaces/ITransferProxy.sol\";\n\nimport \"./interfaces/IWETH9.sol\";\nimport {ILienToken} from \"../../../src/interfaces/ILienToken.sol\";\nimport {ICollateralToken} from \"../../../src/interfaces/ICollateralToken.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeCastLib} from \"./utils/SafeCastLib.sol\";\nimport {PublicVault, IPublicVault} from \"../../../src/PublicVault.sol\";\n\ncontract AuctionHouse is Auth, IAuctionHouse {\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n  using FixedPointMathLib for uint256;\n  // The minimum amount of time left in an auction after a new bid is created\n  uint256 public timeBuffer;\n  // The minimum percentage difference between the last bid amount and the current bid.\n  uint256 public minBidIncrementPercentage;\n\n  // / The address of the WETH contract, so that any ETH transferred can be handled as an ERC-20\n  address public weth;\n\n  ITransferProxy TRANSFER_PROXY;\n  ILienToken LIEN_TOKEN;\n  ICollateralToken COLLATERAL_TOKEN;\n\n  // A mapping of all of the auctions currently running.\n  // collateralToken ID => auction\n  mapping(uint256 => IAuctionHouse.Auction) auctions;\n\n  /*\n   * Constructor\n   */\n  constructor(\n    address weth_,\n    Authority AUTHORITY_,\n    ICollateralToken COLLATERAL_TOKEN_,\n    ILienToken LIEN_TOKEN_,\n    ITransferProxy transferProxy_\n  ) Auth(msg.sender, Authority(address(AUTHORITY_))) {\n    weth = weth_;\n    TRANSFER_PROXY = transferProxy_;\n    COLLATERAL_TOKEN = COLLATERAL_TOKEN_;\n    LIEN_TOKEN = LIEN_TOKEN_;\n    timeBuffer = 15 minutes;\n    // extend 15 minutes after every bid made in last 15 minutes\n    minBidIncrementPercentage = 5;\n    // 5%\n\n    ERC20(weth).safeApprove(address(LIEN_TOKEN), type(uint256).max);\n  }\n\n  /**\n   * @notice Create an auction.\n   * @dev Store the auction details in the auctions mapping and emit an AuctionCreated event.\n   * If there is no curator, or if the curator is the auction creator, automatically approve the auction.\n   */\n  function createAuction(\n    uint256 tokenId,\n    uint256 duration,\n    address initiator,\n    uint256 initiatorFee\n  ) external requiresAuth returns (uint256 reserve) {\n    (reserve, ) = LIEN_TOKEN.stopLiens(tokenId);\n\n    Auction storage newAuction = auctions[tokenId];\n    newAuction.duration = duration.safeCastTo64();\n    newAuction.reservePrice = reserve;\n    newAuction.initiator = initiator;\n    newAuction.initiatorFee = initiatorFee;\n    newAuction.firstBidTime = block.timestamp.safeCastTo64();\n    newAuction.maxDuration = (duration + 1 days).safeCastTo64();\n    newAuction.currentBid = 0;\n\n    emit AuctionCreated(tokenId, duration, reserve);\n  }\n\n  /**\n   * @notice Create a bid on a token, with a given amount.\n   * @dev If provided a valid bid, transfers the provided amount to this contract.\n   * If the auction is run in native ETH, the ETH is wrapped so it can be identically to other\n   * auction currencies in this contract.\n   */\n  function createBid(uint256 tokenId, uint256 amount) external override {\n    address lastBidder = auctions[tokenId].bidder;\n    uint256 currentBid = auctions[tokenId].currentBid;\n    uint256 duration = auctions[tokenId].duration;\n    uint64 firstBidTime = auctions[tokenId].firstBidTime;\n    require(\n      firstBidTime == 0 || block.timestamp < firstBidTime + duration,\n      \"Auction expired\"\n    );\n    require(\n      amount > currentBid + ((currentBid * minBidIncrementPercentage) / 100),\n      \"Must send more than last bid by minBidIncrementPercentage amount\"\n    );\n\n    // If this is the first valid bid, we should set the starting time now.\n    // If it's not, then we should refund the last bidder\n    uint256 vaultPayment = (amount - currentBid);\n\n    if (firstBidTime == 0) {\n      auctions[tokenId].firstBidTime = block.timestamp.safeCastTo64();\n    } else if (lastBidder != address(0)) {\n      uint256 lastBidderRefund = amount - vaultPayment;\n      _handleOutGoingPayment(lastBidder, lastBidderRefund);\n    }\n\n    _handleIncomingPayment(tokenId, vaultPayment, address(msg.sender));\n\n    auctions[tokenId].currentBid = amount;\n    auctions[tokenId].bidder = address(msg.sender);\n\n    bool extended = false;\n    // at this point we know that the timestamp is less than start + duration (since the auction would be over, otherwise)\n    // we want to know by how much the timestamp is less than start + duration\n    // if the difference is less than the timeBuffer, increase the duration by the timeBuffer\n    if (firstBidTime + duration - block.timestamp < timeBuffer) {\n      // Playing code golf for gas optimization:\n      // uint256 expectedEnd = auctions[auctionId].firstBidTime.add(auctions[auctionId].duration);\n      // uint256 timeRemaining = expectedEnd.sub(block.timestamp);\n      // uint256 timeToAdd = timeBuffer.sub(timeRemaining);\n      // uint256 newDuration = auctions[auctionId].duration.add(timeToAdd);\n\n      //TODO: add the cap to the duration, do not let it extend beyond 24 hours extra from max duration\n      uint64 newDuration = uint256(\n        duration + (block.timestamp + timeBuffer - firstBidTime)\n      ).safeCastTo64();\n      if (newDuration <= auctions[tokenId].maxDuration) {\n        auctions[tokenId].duration = newDuration;\n      } else {\n        auctions[tokenId].duration =\n          auctions[tokenId].maxDuration -\n          firstBidTime;\n      }\n      extended = true;\n    }\n\n    emit AuctionBid(\n      tokenId,\n      msg.sender,\n      amount,\n      lastBidder == address(0), // firstBid boolean\n      extended\n    );\n\n    if (extended) {\n      emit AuctionDurationExtended(tokenId, auctions[tokenId].duration);\n    }\n  }\n\n  /**\n   * @notice End an auction, finalizing the bid on if applicable and paying out the respective parties.\n   * @dev If for some reason the auction cannot be finalized (invalid token recipient, for example),\n   * The auction is reset and the NFT is transferred back to the auction creator.\n   */\n  function endAuction(uint256 auctionId)\n    external\n    override\n    requiresAuth\n    returns (address winner)\n  {\n    require(\n      block.timestamp >=\n        auctions[auctionId].firstBidTime + auctions[auctionId].duration,\n      \"Auction hasn't completed\"\n    );\n    Auction storage auction = auctions[auctionId];\n    if (auction.bidder == address(0)) {\n      winner = auction.initiator;\n    } else {\n      winner = auction.bidder;\n    }\n\n    emit AuctionEnded(\n      auctionId,\n      winner,\n      auction.currentBid,\n      auction.recipients\n    );\n    uint256[] memory liensRemaining = LIEN_TOKEN.getLiens(auctionId);\n\n    for (uint256 i = 0; i < liensRemaining.length; i++) {\n      ILienToken.Lien memory lien = LIEN_TOKEN.getLien(liensRemaining[i]);\n      if (\n        PublicVault(LIEN_TOKEN.ownerOf(i)).supportsInterface(\n          type(IPublicVault).interfaceId\n        )\n      ) {\n        PublicVault(LIEN_TOKEN.ownerOf(i)).decreaseYIntercept(lien.amount);\n      }\n    }\n    LIEN_TOKEN.removeLiens(auctionId, liensRemaining);\n    delete auctions[auctionId];\n  }\n\n  /**\n   * @notice Cancel an auction.\n   * @dev Transfers the NFT back to the auction creator and emits an AuctionCanceled event\n   */\n  function cancelAuction(uint256 auctionId, address canceledBy)\n    external\n    requiresAuth\n  {\n    require(\n      auctions[auctionId].currentBid < auctions[auctionId].reservePrice,\n      \"cancelAuction: Auction is at or above reserve\"\n    );\n    _handleIncomingPayment(\n      auctionId,\n      auctions[auctionId].reservePrice,\n      canceledBy\n    );\n    _cancelAuction(auctionId);\n  }\n\n  function getAuctionData(uint256 _auctionId)\n    public\n    view\n    returns (\n      uint256 amount,\n      uint256 duration,\n      uint256 firstBidTime,\n      uint256 reservePrice,\n      address bidder\n    )\n  {\n    IAuctionHouse.Auction memory auction = auctions[_auctionId];\n    return (\n      auction.currentBid,\n      auction.duration,\n      auction.firstBidTime,\n      auction.reservePrice,\n      auction.bidder\n    );\n  }\n\n  event PaymentMade(address, uint256);\n  event PaymentAmount(uint256);\n\n  /**\n   * @dev Given an amount and a currency, transfer the currency to this contract.\n   */\n  function _handleIncomingPayment(\n    uint256 tokenId,\n    uint256 transferAmount,\n    address payer\n  ) internal {\n    require(transferAmount > uint256(0), \"cannot send nothing\");\n\n    Auction storage auction = auctions[tokenId];\n\n    //fee is in percent\n    //muldiv?\n    //        uint256 initiatorPayment = (transferAmount * auction.initiatorFee) / 100;\n    uint256 initiatorPayment = transferAmount.mulDivDown(\n      auction.initiatorFee,\n      100\n    ); //maybe consider making protocl computed like other fees\n\n    TRANSFER_PROXY.tokenTransferFrom(\n      weth,\n      payer,\n      auction.initiator,\n      initiatorPayment\n    );\n    transferAmount -= initiatorPayment;\n\n    uint256[] memory liens = LIEN_TOKEN.getLiens(tokenId);\n    uint256 totalLienAmount = 0;\n    if (liens.length > 0) {\n      for (uint256 i = 0; i < liens.length; ++i) {\n        uint256 payment;\n        uint256 lienId = liens[i];\n\n        ILienToken.Lien memory lien = LIEN_TOKEN.getLien(lienId);\n\n        if (transferAmount >= lien.amount) {\n          payment = lien.amount;\n          transferAmount -= payment;\n        } else {\n          payment = transferAmount;\n          transferAmount = 0;\n        }\n\n        if (payment > 0) {\n          LIEN_TOKEN.makePayment(tokenId, payment, lien.position, payer);\n        }\n      }\n    } else {\n      TRANSFER_PROXY.tokenTransferFrom(\n        weth,\n        payer,\n        COLLATERAL_TOKEN.ownerOf(tokenId),\n        transferAmount\n      );\n    }\n  }\n\n  function _handleOutGoingPayment(address to, uint256 amount) internal {\n    TRANSFER_PROXY.tokenTransferFrom(weth, address(msg.sender), to, amount);\n  }\n\n  function _cancelAuction(uint256 tokenId) internal {\n    emit AuctionCanceled(tokenId);\n    delete auctions[tokenId];\n  }\n\n  function auctionExists(uint256 tokenId) public view returns (bool) {\n    return auctions[tokenId].initiator != address(0);\n  }\n}"
    }
  ]
}