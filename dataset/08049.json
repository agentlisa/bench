{
  "Title": "[02] Left the Default `MESSAGE_HASH`",
  "Content": "\nFor the in-scope code `MESSAGE` is left to the default value\n\n[MultiMerkleRedeemer.sol#L53-L54](https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/fuse/MultiMerkleRedeemer.sol#L53-L54)\n\n```solidity\n    string public constant MESSAGE = \"Sample message, please update.\";\n\n```\n\nThis could cause the signature to be replayable in other applications that use the same message.\n\n### Mitigation Steps\n\nAdd the proper message, most likely a TOS acknowledgement or a ipfs hash to a document.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-09-tribe",
  "Code": [
    {
      "filename": "contracts/shutdown/fuse/MultiMerkleRedeemer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/// @title Abstract contract for exchange a number of ERC20 tokens for specific base token, permissioned via Merkle root(s)\n/// @notice This contract assumes that the users must sign a message to redeem tokens\n/// @author kryptoklob\nabstract contract MultiMerkleRedeemer {\n    /** ---------- Events ----------------------- **/\n\n    /// @notice Emitted when a user signs for the first time; should only be emitted once per user\n    /// @param signer the person singing; msg.sender\n    /// @param signature the signed message hash\n    event Signed(address indexed signer, bytes signature);\n\n    /// @notice Emitted when a user completes a claim on a cToken; should only be emitted once per user per cToken at most\n    /// @param claimant the person claiming; msg.sender\n    /// @param cToken the cToken being claimed on\n    /// @param claimAmount the amount the user says he has claim to; verified by Merkle root\n    event Claimed(address indexed claimant, address indexed cToken, uint256 claimAmount);\n\n    /// @notice Emitted when a user exchanges an amount of cTokens for the base token; can happen any number of times per user & cToken\n    /// @param recipient the user; msg.sender\n    /// @param cToken the cToken being exchange for the baseToken\n    /// @param cTokenAmount the amount of cTokens being exchanged\n    /// @param baseTokenAmount the amount of baseTokens being received\n    event Redeemed(address indexed recipient, address indexed cToken, uint256 cTokenAmount, uint256 baseTokenAmount);\n\n    /** ---------- Storage / Configuration ------ **/\n\n    /// @notice The address of the token that will be exchange for cTokens\n    address public baseToken;\n\n    /// @notice The merkle roots that permission users to claim cTokens; one root per cToken\n    mapping(address => bytes32) public merkleRoots;\n\n    /// @notice Exchange rate of the base asset per each cToken\n    mapping(address => uint256) public cTokenExchangeRates;\n\n    /// @notice Stores user signatures; one signature per user, can only be provided once\n    mapping(address => bytes) public userSignatures;\n\n    /// @notice The amount of cTokens a user has redeemed, indexed first by user address, then by cToken address\n    /// @dev This value starts at zero and can only increase\n    mapping(address => mapping(address => uint256)) public redemptions;\n\n    /// @notice The amount of cTokens a user in their claim, total; indexed first by user address, then by cToken address\n    /// @dev This value is set when a user proves their claim on a particular cToken, and cannot change once set\n    mapping(address => mapping(address => uint256)) public claims;\n\n    /// @notice The message to be signed by any users claiming on cTokens\n    string public constant MESSAGE = \"Sample message, please update.\";\n\n    /// @notice The hash of the message to be signed by any users claiming on cTokens\n    bytes32 public MESSAGE_HASH = ECDSA.toEthSignedMessageHash(bytes(MESSAGE));\n\n    /** ---------- Public State-Changing Funcs ----------------- **/\n\n    /// @notice Stores a user's signature (of the message stored in MESSAGE)\n    /// @param _signature the user's signature, encoded as a bytes array\n    /// @dev Signature must be encoded into a packed length of 65 bytes: bytes.concat(bytes32(r), bytes32(s), bytes1(v));\n    function sign(bytes calldata _signature) external virtual;\n\n    /// @notice Prove a claim on a particular cToken. Amount provided must match the amount in the merkle tree\n    /// @param _cToken the cToken being claimed\n    /// @param _amount the amount of the particular cToken to claim\n    /// @param _merkleProof the merkle proof for the claim\n    /// @dev This should set the user's claim for this cToken in the \"claims\" mapping\n    function claim(\n        address _cToken,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) external virtual;\n\n    /// @notice Plural version of claim. Amounts provided must match the amounts in the merkle trees\n    /// @param _cTokens the cTokens being claimed\n    /// @param _amounts the amounts of each particular cToken to claim\n    /// @param _merkleProofs the merkle proofs for each claim\n    /// @dev This should set the user's claim for *each* cToken in the \"claims\" mapping\n    function multiClaim(\n        address[] calldata _cTokens,\n        uint256[] calldata _amounts,\n        bytes32[][] calldata _merkleProofs\n    ) external virtual;\n\n    /// @notice Redeem an amount of the specified cToken.\n    /// @dev Requires an approval of the specified amount of the specified cToken to this contract.\n    /// Should increment the user's redeemed amount for this cToken in the \"redeemed\" mapping.\n    function redeem(address cToken, uint256 cTokenAmount) external virtual;\n\n    /// @notice Redeem an amount of each of the specified cTokens\n    /// @dev Requires an approval of the specified amount of each of the specified cTokens to this contract\n    /// Should increment the user's redeemed amount for each cToken in the \"redeemed\" mapping\n    function multiRedeem(address[] calldata cTokens, uint256[] calldata cTokenAmounts) external virtual;\n\n    /// @notice Combines sign and claim into a single function\n    /// @param _signature the user's signature, encoded as a 65-length bytes: bytes.concat(bytes32(r), bytes32(s), bytes1(v));\n    /// @param _cTokens the cTokens being claimed\n    /// @param _amounts the amounts of each cToken to claim\n    /// @param _merkleProofs the merkle proofs for each claim\n    function signAndClaim(\n        bytes calldata _signature,\n        address[] calldata _cTokens,\n        uint256[] calldata _amounts,\n        bytes32[][] calldata _merkleProofs\n    ) external virtual;\n\n    /// @notice Combines sign, claim, and redeem into a single function\n    /// @param _signature the user's signature, encoded as a 65-length bytes: bytes.concat(bytes32(r), bytes32(s), bytes1(v));\n    /// @param _cTokens the cTokens being claimed\n    /// @param _amountsToClaim the amounts of each cToken to claim; should match the merkle proofs\n    /// @param _amountsToRedeem the amounts of each cToken to redeem; must be greater than 0 for each cToken provided\n    /// @param _merkleProofs the merkle proofs for each claim\n    function signAndClaimAndRedeem(\n        bytes calldata _signature,\n        address[] calldata _cTokens,\n        uint256[] calldata _amountsToClaim,\n        uint256[] calldata _amountsToRedeem,\n        bytes32[][] calldata _merkleProofs\n    ) external virtual;\n\n    /** ---------- Public View/Pure Functions ---------- **/\n\n    /// @notice Returns the amount of the base token that can be exchanged for the specified cToken\n    function previewRedeem(address cToken, uint256 amount) external virtual returns (uint256 baseTokenAmount);\n}"
    }
  ]
}