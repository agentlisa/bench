{
  "Title": "H-16: `VaultImplementation._validateCommitment` may prevent liens that satisfy their terms of `maxPotentialDebt`",
  "Content": "# Issue H-16: `VaultImplementation._validateCommitment` may prevent liens that satisfy their terms of `maxPotentialDebt` \n\nSource: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/182 \n\n## Found by \nobront, 0xRajeev, hansfriese, rvierdiiev, zzykxx, Jeiwan, tives\n\n## Summary\n\nThe calculation of `potentialDebt` in `VaultImplementation._validateCommitment()` is incorrect and will cause a DoS to legitimate borrowers.\n\n## Vulnerability Detail\n\nThe calculation of potentialDebt in `VaultImplementation._validateCommitment()` is incorrect because it computes `uint256 potentialDebt = seniorDebt * (ld.rate + 1) * ld.duration;` which incorrectly adds a factor of `ld.duration` to `seniorDebt` thus making the potential debt much higher by that factor than it will be. The use of `INTEREST_DENOMINATOR` and implied lien rate is also missing here. \n\n\n## Impact\n\nLiens that would have otherwise satisfied the constraint of `potentialDebt <= ld.maxPotentialDebt` will fail because of this miscalculation and will cause a DoS to legitimate borrowers and likely all of them.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/VaultImplementation.sol#L221-L225\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L256-L262\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the calculation to `uint256 potentialDebt = seniorDebt * (ld.rate * ld.duration + 1).mulDivDown(1, INTEREST_DENOMINATOR);`. This should also consider the implied rate of all the liens against the collateral instead of only this lien.\n\n## Discussion\n\n**secureum**\n\nEscalate for 2 USDC.\n\nGiven the potential impact to different flows/contexts, we still think this is a high-severity impact (not Medium as judged). A majority of the dups (4 of 6) also reported this as a High.\n\ncc @berndartmueller @lucyoa\n\n**sherlock-admin**\n\n > Escalate for 2 USDC.\n> \n> Given the potential impact to different flows/contexts, we still think this is a high-severity impact (not Medium as judged). A majority of the dups (4 of 6) also reported this as a High.\n> \n> cc @berndartmueller @lucyoa\n\nYou've created a valid escalation for 2 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted.\n\n\n**sherlock-admin**\n\n> Escalation accepted.\n> \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/8",
  "Code": [
    {
      "filename": "src/VaultImplementation.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IAuctionHouse} from \"gpl/interfaces/IAuctionHouse.sol\";\nimport {IVault, AstariaVaultBase} from \"gpl/ERC4626-Cloned.sol\";\n\nimport {CollateralLookup} from \"./libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"./interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"./interfaces/ICollateralToken.sol\";\nimport {ILienBase, ILienToken} from \"./interfaces/ILienToken.sol\";\nimport {ILienToken} from \"./interfaces/ILienToken.sol\";\n\n/**\n * @title VaultImplementation\n * @author androolloyd\n * @notice A base implementation for the minimal features of an Astaria Vault.\n */\nabstract contract VaultImplementation is ERC721TokenReceiver, AstariaVaultBase {\n  using SafeTransferLib for ERC20;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n\n  address public delegate; //account connected to the daemon\n\n  event NewLien(\n    bytes32 strategyRoot,\n    address tokenContract,\n    uint256 tokenId,\n    uint256 amount\n  );\n\n  event NewVault(address appraiser, address vault);\n\n  /**\n   * @notice receive hook for ERC721 tokens, nothing special done\n   */\n  function onERC721Received(\n    address operator_,\n    address from_,\n    uint256 tokenId_,\n    bytes calldata data_\n  ) external pure override returns (bytes4) {\n    return ERC721TokenReceiver.onERC721Received.selector;\n  }\n\n  modifier whenNotPaused() {\n    if (IAstariaRouter(ROUTER()).paused()) {\n      revert(\"protocol is paused\");\n    }\n    _;\n  }\n\n  function domainSeparator() public view virtual returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          keccak256(\n            \"EIP712Domain(string version,uint256 chainId,address verifyingContract)\"\n          ),\n          keccak256(\"0\"),\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  /*\n   * @notice encodes the data for a 712 signature\n   * @param tokenContract The address of the token contract\n   * @param tokenId The id of the token\n   * @param amount The amount of the token\n   */\n\n  // cast k \"StrategyDetails(uint256 nonce,uint256 deadline,bytes32 root)\"\n  bytes32 private constant STRATEGY_TYPEHASH =\n    0x679f3933bd13bd2e4ec6e9cde341ede07736ad7b635428a8a211e9cccb4393b0;\n\n  function encodeStrategyData(\n    IAstariaRouter.StrategyDetails calldata strategy,\n    bytes32 root\n  ) public view returns (bytes memory) {\n    bytes32 hash = keccak256(\n      abi.encode(\n        STRATEGY_TYPEHASH,\n        IAstariaRouter(ROUTER()).strategistNonce(strategy.strategist),\n        strategy.deadline,\n        root\n      )\n    );\n    return\n      abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), hash);\n  }\n\n  /**\n   * @dev hook to allow inheriting contracts to perform payout for strategist\n   */\n  function _handleStrategistInterestReward(uint256, uint256) internal virtual {}\n\n  struct InitParams {\n    address delegate;\n  }\n\n  function init(InitParams calldata params) external virtual {\n    require(msg.sender == address(ROUTER()), \"only router\");\n\n    if (params.delegate != address(0)) {\n      delegate = params.delegate;\n    }\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner(), \"only strategist\");\n    _;\n  }\n\n  function setDelegate(address delegate_) public onlyOwner {\n    delegate = delegate_;\n  }\n\n  /**\n   * @dev Validates the terms for a requested loan.\n   * Who is requesting the borrow, is it a smart contract? or is it a user?\n   * if a smart contract, then ensure that the contract is approved to borrow and is also receiving the funds.\n   * if a user, then ensure that the user is approved to borrow and is also receiving the funds.\n   * The terms are hashed and signed by the borrower, and the signature validated against the strategist's address\n   * lien details are decoded from the obligation data and validated the collateral\n   *\n   * @param params The Commitment information containing the loan parameters and the merkle proof for the strategy supporting the requested loan.\n   * @param receiver The address of the prospective borrower.\n   */\n  function _validateCommitment(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  ) internal returns (IAstariaRouter.LienDetails memory) {\n    uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n\n    address operator = ERC721(COLLATERAL_TOKEN()).getApproved(collateralId);\n\n    address holder = ERC721(COLLATERAL_TOKEN()).ownerOf(collateralId);\n\n    if (msg.sender != holder) {\n      require(msg.sender == operator, \"invalid request\");\n    }\n\n    if (receiver != holder) {\n      require(\n        receiver == operator || IAstariaRouter(ROUTER()).isValidVault(receiver),\n        \"can only issue funds to an vault or operator if not the holder\"\n      );\n    }\n\n    address recovered = ecrecover(\n      keccak256(\n        encodeStrategyData(\n          params.lienRequest.strategy,\n          params.lienRequest.merkle.root\n        )\n      ),\n      params.lienRequest.v,\n      params.lienRequest.r,\n      params.lienRequest.s\n    );\n    require(\n      recovered == params.lienRequest.strategy.strategist,\n      \"strategist must match signature\"\n    );\n    require(\n      recovered == owner() || recovered == delegate,\n      \"invalid strategist\"\n    );\n\n    (bool valid, IAstariaRouter.LienDetails memory ld) = IAstariaRouter(\n      ROUTER()\n    ).validateCommitment(params);\n\n    require(\n      valid,\n      \"Vault._validateCommitment(): Verification of provided merkle branch failed for the vault and parameters\"\n    );\n\n    require(\n      ld.rate > 0,\n      \"Vault._validateCommitment(): Cannot have a 0 interest rate\"\n    );\n\n    require(\n      ld.rate < IAstariaRouter(ROUTER()).maxInterestRate(),\n      \"Vault._validateCommitment(): Rate is above maximum\"\n    );\n\n    require(\n      ld.maxAmount >= params.lienRequest.amount,\n      \"Vault._validateCommitment(): Attempting to borrow more than maxAmount available for this asset\"\n    );\n\n    uint256 seniorDebt = IAstariaRouter(ROUTER())\n      .LIEN_TOKEN()\n      .getTotalDebtForCollateralToken(\n        params.tokenContract.computeId(params.tokenId)\n      );\n    require(\n      params.lienRequest.amount <= ERC20(underlying()).balanceOf(address(this)),\n      \"Vault._validateCommitment():  Attempting to borrow more than available in the specified vault\"\n    );\n\n    uint256 potentialDebt = seniorDebt * (ld.rate + 1) * ld.duration;\n    require(\n      potentialDebt <= ld.maxPotentialDebt,\n      \"Vault._validateCommitment(): Attempting to initiate a loan with debt potentially higher than maxPotentialDebt\"\n    );\n\n    return ld;\n  }\n\n  function _afterCommitToLien(uint256 lienId, uint256 amount)\n    internal\n    virtual\n  {}\n\n  /**\n   * @notice Pipeline for lifecycle of new loan origination.\n   * Origination consists of a few phases: pre-commitment validation, lien token issuance, strategist reward, and after commitment actions\n   * Starts by depositing collateral and take out a lien against it. Next, verifies the merkle proof for a loan commitment. Vault owners are then rewarded fees for successful loan origination.\n   * @param params Commitment data for the incoming lien request\n   * @param receiver The borrower receiving the loan.\n   */\n  function commitToLien(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  ) external whenNotPaused {\n    IAstariaRouter.LienDetails memory ld = _validateCommitment(\n      params,\n      receiver\n    );\n    uint256 lienId = _requestLienAndIssuePayout(ld, params, receiver);\n    _afterCommitToLien(lienId, params.lienRequest.amount);\n    emit NewLien(\n      params.lienRequest.merkle.root,\n      params.tokenContract,\n      params.tokenId,\n      params.lienRequest.amount\n    );\n  }\n\n  /**\n   * @notice Returns whether a specific lien can be liquidated.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param position The specified lien position.\n   * @return A boolean value indicating whether the specified lien can be liquidated.\n   */\n  function canLiquidate(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (bool)\n  {\n    return IAstariaRouter(ROUTER()).canLiquidate(collateralId, position);\n  }\n\n  /**\n   * @notice Buy out a lien to replace it with new terms.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param position The position of the specified lien.\n   * @param incomingTerms The loan terms of the new lien.\n   */\n  function buyoutLien(\n    uint256 collateralId,\n    uint256 position,\n    IAstariaRouter.Commitment calldata incomingTerms\n  ) external whenNotPaused {\n    (, uint256 buyout) = IAstariaRouter(ROUTER()).LIEN_TOKEN().getBuyout(\n      collateralId,\n      position\n    );\n\n    require(\n      buyout <= ERC20(underlying()).balanceOf(address(this)),\n      \"not enough balance to buy out loan\"\n    );\n\n    _validateCommitment(incomingTerms, recipient());\n\n    ERC20(underlying()).safeApprove(\n      address(IAstariaRouter(ROUTER()).TRANSFER_PROXY()),\n      buyout\n    );\n    IAstariaRouter(ROUTER()).LIEN_TOKEN().buyoutLien(\n      ILienBase.LienActionBuyout(incomingTerms, position, recipient())\n    );\n  }\n\n  /**\n   * @notice Retrieves the recipient of loan repayments. For PublicVaults (VAULT_TYPE 2), this is always the vault address. For PrivateVaults, retrieves the owner() of the vault.\n   * @return The address of the recipient.\n   */\n  function recipient() public view returns (address) {\n    if (VAULT_TYPE() == uint8(IAstariaRouter.VaultType.PUBLIC)) {\n      return address(this);\n    } else {\n      return owner();\n    }\n  }\n\n  /**\n   * @dev Generates a Lien for a valid loan commitment proof and sends the loan amount to the borrower.\n   * @param c The Commitment information containing the loan parameters and the merkle proof for the strategy supporting the requested loan.\n   * @param receiver The borrower requesting the loan.\n   * @return The ID of the created Lien.\n   */\n  function _requestLienAndIssuePayout(\n    IAstariaRouter.LienDetails memory ld,\n    IAstariaRouter.Commitment calldata c,\n    address receiver\n  ) internal returns (uint256) {\n    uint256 newLienId = IAstariaRouter(ROUTER()).requestLienPosition(ld, c);\n\n    uint256 payout = _handleProtocolFee(c.lienRequest.amount);\n    ERC20(underlying()).safeTransfer(receiver, payout);\n    return newLienId;\n  }\n\n  function _handleProtocolFee(uint256 amount) internal returns (uint256) {\n    address feeTo = IAstariaRouter(ROUTER()).feeTo();\n    bool feeOn = feeTo != address(0);\n    if (feeOn) {\n      uint256 fee = IAstariaRouter(ROUTER()).getProtocolFee(amount);\n\n      unchecked {\n        amount -= fee;\n      }\n      ERC20(underlying()).safeTransfer(feeTo, fee);\n    }\n    return amount;\n  }\n}"
    },
    {
      "filename": "src/LienToken.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {IAuctionHouse} from \"gpl/interfaces/IAuctionHouse.sol\";\nimport {IERC721, IERC165} from \"gpl/interfaces/IERC721.sol\";\nimport {ITransferProxy} from \"gpl/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {Base64} from \"./libraries/Base64.sol\";\nimport {CollateralLookup} from \"./libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"./interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"./interfaces/ICollateralToken.sol\";\nimport {ILienBase, ILienToken} from \"./interfaces/ILienToken.sol\";\n\nimport {IPublicVault} from \"./PublicVault.sol\";\nimport {VaultImplementation} from \"./VaultImplementation.sol\";\n\ncontract TransferAgent {\n  address public immutable WETH;\n  ITransferProxy public immutable TRANSFER_PROXY;\n\n  constructor(ITransferProxy _TRANSFER_PROXY, address _WETH) {\n    TRANSFER_PROXY = _TRANSFER_PROXY;\n    WETH = _WETH;\n  }\n}\n\n/**\n * @title LienToken\n * @author androolloyd\n * @notice This contract handles the creation, payments, buyouts, and liquidations of tokenized NFT-collateralized debt (liens). Vaults which originate loans against supported collateral are issued a LienToken representing the right to loan repayments and auctioned funds on liquidation.\n */\ncontract LienToken is ERC721, ILienToken, Auth, TransferAgent {\n  using FixedPointMathLib for uint256;\n  using CollateralLookup for address;\n  using SafeCastLib for uint256;\n\n  IAuctionHouse public AUCTION_HOUSE;\n  IAstariaRouter public ASTARIA_ROUTER;\n  ICollateralToken public COLLATERAL_TOKEN;\n\n  uint256 INTEREST_DENOMINATOR = 1e18; //wad per second\n\n  uint256 constant MAX_LIENS = uint256(5);\n\n  mapping(uint256 => Lien) public lienData;\n  mapping(uint256 => uint256[]) public liens;\n\n  /**\n   * @dev Setup transfer authority and initialize the buyoutNumerator and buyoutDenominator for the lien buyout premium.\n   * @param _AUTHORITY The authority manager.\n   * @param _TRANSFER_PROXY The TransferProxy for balance transfers.\n   * @param _WETH The WETH address to use for transfers.\n   */\n  constructor(\n    Authority _AUTHORITY,\n    ITransferProxy _TRANSFER_PROXY,\n    address _WETH\n  )\n    Auth(address(msg.sender), _AUTHORITY)\n    TransferAgent(_TRANSFER_PROXY, _WETH)\n    ERC721(\"Astaria Lien Token\", \"ALT\")\n  {}\n\n  /**\n   * @notice Sets addresses for the AuctionHouse, CollateralToken, and AstariaRouter contracts to use.\n   * @param what The identifier for what is being filed.\n   * @param data The encoded address data to be decoded and filed.\n   */\n  function file(bytes32 what, bytes calldata data) external requiresAuth {\n    if (what == \"setAuctionHouse\") {\n      address addr = abi.decode(data, (address));\n      AUCTION_HOUSE = IAuctionHouse(addr);\n    } else if (what == \"setCollateralToken\") {\n      address addr = abi.decode(data, (address));\n      COLLATERAL_TOKEN = ICollateralToken(addr);\n    } else if (what == \"setAstariaRouter\") {\n      address addr = abi.decode(data, (address));\n      ASTARIA_ROUTER = IAstariaRouter(addr);\n    } else {\n      revert UnsupportedFile();\n    }\n    emit File(what, data);\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ILienToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @notice Purchase a LienToken for its buyout price.\n   * @param params The LienActionBuyout data specifying the lien position, receiver address, and underlying CollateralToken information of the lien.\n   */\n\n  function buyoutLien(ILienToken.LienActionBuyout calldata params) external {\n    (bool valid, IAstariaRouter.LienDetails memory ld) = ASTARIA_ROUTER\n      .validateCommitment(params.incoming);\n\n    if (!valid) {\n      revert InvalidTerms();\n    }\n\n    uint256 collateralId = params.incoming.tokenContract.computeId(\n      params.incoming.tokenId\n    );\n    (uint256 owed, uint256 buyout) = getBuyout(collateralId, params.position);\n    uint256 lienId = liens[collateralId][params.position];\n\n    //the borrower shouldn't incur more debt from the buyout than they already owe\n    if (ld.maxAmount < owed) {\n      revert InvalidBuyoutDetails(ld.maxAmount, owed);\n    }\n    if (!ASTARIA_ROUTER.isValidRefinance(lienData[lienId], ld)) {\n      revert InvalidRefinance();\n    }\n\n    TRANSFER_PROXY.tokenTransferFrom(\n      WETH,\n      address(msg.sender),\n      getPayee(lienId),\n      uint256(buyout)\n    );\n\n    lienData[lienId].last = block.timestamp.safeCastTo32();\n    lienData[lienId].start = block.timestamp.safeCastTo32();\n    lienData[lienId].rate = ld.rate.safeCastTo240();\n    lienData[lienId].duration = ld.duration.safeCastTo32();\n\n    _transfer(ownerOf(lienId), address(params.receiver), lienId);\n  }\n\n  /**\n   * @notice Public view function that computes the interest for a LienToken since its last payment.\n   * @param collateralId The ID of the underlying CollateralToken\n   * @param position The position of the lien to calculate interest for.\n   */\n  function getInterest(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (uint256)\n  {\n    uint256 lien = liens[collateralId][position];\n    return _getInterest(lienData[lien], block.timestamp);\n  }\n\n  /**\n   * @dev Computes the interest accrued for a lien since its last payment.\n   * @param lien The Lien for the loan to calculate interest for.\n   * @param timestamp The timestamp at which to compute interest for.\n   */\n  function _getInterest(Lien memory lien, uint256 timestamp)\n    internal\n    view\n    returns (uint256)\n  {\n    if (!lien.active) {\n      return uint256(0);\n    }\n    uint256 delta_t;\n    if (block.timestamp >= lien.start + lien.duration) {\n      delta_t = uint256(lien.start + lien.duration - lien.last);\n    } else {\n      delta_t = uint256(timestamp.safeCastTo32() - lien.last);\n    }\n    return\n      delta_t.mulDivDown(lien.rate, 1).mulDivDown(\n        lien.amount,\n        INTEREST_DENOMINATOR\n      );\n  }\n\n  /**\n   * @notice Stops accruing interest for all liens against a single CollateralToken.\n   * @param collateralId The ID for the  CollateralToken of the NFT used as collateral for the liens.\n   */\n  function stopLiens(uint256 collateralId)\n    external\n    requiresAuth\n    returns (uint256 reserve, uint256[] memory lienIds)\n  {\n    reserve = 0;\n    lienIds = liens[collateralId];\n    for (uint256 i = 0; i < lienIds.length; ++i) {\n      Lien storage lien = lienData[lienIds[i]];\n      unchecked {\n        lien.amount = _getOwed(lien);\n        reserve += lien.amount;\n      }\n      lien.active = false;\n    }\n  }\n\n  /**\n   * @dev See {IERC721Metadata-tokenURI}.\n   */\n  function tokenURI(uint256 tokenId)\n    public\n    pure\n    override\n    returns (string memory)\n  {\n    return \"\";\n  }\n\n  /**\n   * @notice Creates a new lien against a CollateralToken.\n   * @param params LienActionEncumber data containing CollateralToken information and lien parameters (rate, duration, and amount, rate, and debt caps).\n   */\n  function createLien(ILienBase.LienActionEncumber memory params)\n    external\n    requiresAuth\n    returns (uint256 lienId)\n  {\n    // require that the auction is not under way\n\n    uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n\n    if (AUCTION_HOUSE.auctionExists(collateralId)) {\n      revert InvalidCollateralState(InvalidStates.AUCTION);\n    }\n\n    (address tokenContract, ) = COLLATERAL_TOKEN.getUnderlying(collateralId);\n    if (tokenContract == address(0)) {\n      revert InvalidCollateralState(InvalidStates.NO_DEPOSIT);\n    }\n\n    uint256 totalDebt = getTotalDebtForCollateralToken(collateralId);\n    uint256 impliedRate = getImpliedRate(collateralId);\n\n    uint256 potentialDebt = totalDebt *\n      (impliedRate + 1) *\n      params.terms.duration;\n\n    if (potentialDebt > params.terms.maxPotentialDebt) {\n      revert InvalidCollateralState(InvalidStates.DEBT_LIMIT);\n    }\n\n    lienId = uint256(\n      keccak256(\n        abi.encodePacked(\n          abi.encode(\n            bytes32(collateralId),\n            params.vault,\n            WETH,\n            params.terms.maxAmount,\n            params.terms.rate,\n            params.terms.duration,\n            params.terms.maxPotentialDebt\n          ),\n          params.strategyRoot\n        )\n      )\n    );\n\n    //0 - 4 are valid\n    require(\n      uint256(liens[collateralId].length) < MAX_LIENS,\n      \"too many liens active\"\n    );\n\n    uint8 newPosition = uint8(liens[collateralId].length);\n\n    _mint(VaultImplementation(params.vault).recipient(), lienId);\n    lienData[lienId] = Lien({\n      collateralId: collateralId,\n      position: newPosition,\n      amount: params.amount,\n      active: true,\n      rate: params.terms.rate.safeCastTo240(),\n      last: block.timestamp.safeCastTo32(),\n      start: block.timestamp.safeCastTo32(),\n      duration: params.terms.duration.safeCastTo32(),\n      payee: address(0)\n    });\n\n    liens[collateralId].push(lienId);\n    emit NewLien(lienId, lienData[lienId]);\n  }\n\n  /**\n   * @notice Removes all liens for a given CollateralToken.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @param remainingLiens The IDs for the unpaid liens\n   */\n  function removeLiens(uint256 collateralId, uint256[] memory remainingLiens)\n    external\n    requiresAuth\n  {\n    for (uint256 i = 0; i < remainingLiens.length; i++) {\n      delete lienData[remainingLiens[i]];\n      _burn(remainingLiens[i]);\n    }\n    delete liens[collateralId];\n    emit RemovedLiens(collateralId);\n  }\n\n  /**\n   * @notice Retrieves all liens taken out against the underlying NFT of a CollateralToken.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @return The IDs of the liens against the CollateralToken.\n   */\n  function getLiens(uint256 collateralId)\n    public\n    view\n    returns (uint256[] memory)\n  {\n    return liens[collateralId];\n  }\n\n  /**\n   * @notice Retrieves a specific Lien by its ID.\n   * @param lienId The ID of the requested Lien.\n   * @return lien The Lien for the lienId.\n   */\n  function getLien(uint256 lienId) public view returns (Lien memory lien) {\n    lien = lienData[lienId];\n    lien.amount = _getOwed(lien);\n    lien.last = block.timestamp.safeCastTo32();\n  }\n\n  /**\n   * @notice Retrives a specific Lien from the ID of the CollateralToken for the underlying NFT and the lien position.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @param position The requested lien position.\n   *  @ return lien The Lien for the lienId.\n   */\n  function getLien(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (Lien memory)\n  {\n    uint256 lienId = liens[collateralId][position];\n    return getLien(lienId);\n  }\n\n  /**\n   * @notice Computes and returns the buyout amount for a Lien.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @param position The position of the Lien to compute the buyout amount for.\n   * @return The outstanding debt for the lien and the buyout amount for the Lien.\n   */\n  function getBuyout(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (uint256, uint256)\n  {\n    Lien memory lien = getLien(collateralId, position);\n\n    uint256 remainingInterest = _getRemainingInterest(lien, true);\n    uint256 buyoutTotal = lien.amount +\n      ASTARIA_ROUTER.getBuyoutFee(remainingInterest);\n\n    return (lien.amount, buyoutTotal);\n  }\n\n  /**\n   * @notice Make a payment for the debt against a CollateralToken.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param paymentAmount The amount to pay against the debt.\n   */\n  function makePayment(uint256 collateralId, uint256 paymentAmount) public {\n    _makePayment(collateralId, paymentAmount);\n  }\n\n  /**\n   * @notice Make a payment for the debt against a CollateralToken for a specific lien.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param paymentAmount The amount to pay against the debt.\n   * @param position The lien position to make a payment to.\n   */\n  function makePayment(\n    uint256 collateralId,\n    uint256 paymentAmount,\n    uint8 position\n  ) external {\n    _payment(collateralId, position, paymentAmount, address(msg.sender));\n  }\n\n  /**\n   * @notice Have a specified paymer make a payment for the debt against a CollateralToken.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param totalCapitalAvailable The amount to pay against the debts\n   */\n  function _makePayment(uint256 collateralId, uint256 totalCapitalAvailable)\n    internal\n  {\n    uint256[] memory openLiens = liens[collateralId];\n    uint256 paymentAmount = totalCapitalAvailable;\n    for (uint256 i = 0; i < openLiens.length; ++i) {\n      uint256 capitalSpent = _payment(\n        collateralId,\n        uint8(i),\n        paymentAmount,\n        address(msg.sender)\n      );\n      paymentAmount -= capitalSpent;\n    }\n  }\n\n  function makePayment(\n    uint256 collateralId,\n    uint256 paymentAmount,\n    uint8 position,\n    address payer\n  ) public requiresAuth {\n    _payment(collateralId, position, paymentAmount, payer);\n  }\n\n  /**\n   * @notice Computes the rate for a specified lien.\n   * @param lienId The ID for the lien.\n   * @return The rate for the specified lien, in WETH per second.\n   */\n  function calculateSlope(uint256 lienId) public view returns (uint256) {\n    Lien memory lien = lienData[lienId];\n    uint256 end = (lien.start + lien.duration);\n    uint256 owedAtEnd = _getOwed(lien, end);\n    return (owedAtEnd - lien.amount).mulDivDown(1, end - lien.last);\n  }\n\n  /**\n   * @notice Computes the change in rate for a lien if a specific payment amount was made.\n   * @param lienId The ID for the lien.\n   * @param paymentAmount The hypothetical payment amount that would be made to the lien.\n   * @return slope The difference between the current lien rate and the lien rate if the payment was made.\n   */\n  function changeInSlope(uint256 lienId, uint256 paymentAmount)\n    public\n    view\n    returns (uint256 slope)\n  {\n    Lien memory lien = lienData[lienId];\n    uint256 oldSlope = calculateSlope(lienId);\n    uint256 newAmount = (lien.amount - paymentAmount);\n\n    // slope = (rate*time*amount - amount) / time -> amount(rate*time - 1) / time\n    uint256 newSlope = newAmount.mulDivDown(\n      (uint256(lien.rate).mulDivDown(lien.duration, 1) - 1),\n      lien.duration\n    );\n\n    slope = oldSlope - newSlope;\n  }\n\n  /**\n   * @notice Computes the total amount owed on all liens against a CollateralToken.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @return totalDebt The aggregate debt for all loans against the collateral.\n   */\n  function getTotalDebtForCollateralToken(uint256 collateralId)\n    public\n    view\n    returns (uint256 totalDebt)\n  {\n    uint256[] memory openLiens = getLiens(collateralId);\n    totalDebt = 0;\n    for (uint256 i = 0; i < openLiens.length; ++i) {\n      totalDebt += _getOwed(lienData[openLiens[i]]);\n    }\n  }\n\n  /**\n   * @notice Computes the total amount owed on all liens against a CollateralToken at a specified timestamp.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param timestamp The timestamp to use to calculate owed debt.\n   * @return totalDebt The aggregate debt for all loans against the specified collateral at the specified timestamp.\n   */\n  function getTotalDebtForCollateralToken(\n    uint256 collateralId,\n    uint256 timestamp\n  ) public view returns (uint256 totalDebt) {\n    uint256[] memory openLiens = getLiens(collateralId);\n    totalDebt = 0;\n\n    for (uint256 i = 0; i < openLiens.length; ++i) {\n      totalDebt += _getOwed(lienData[openLiens[i]], timestamp);\n    }\n  }\n\n  /**\n   * @notice Computes the combined rate of all liens against a CollateralToken\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @return impliedRate The aggregate rate for all loans against the specified collateral.\n   */\n  function getImpliedRate(uint256 collateralId)\n    public\n    view\n    returns (uint256 impliedRate)\n  {\n    uint256 totalDebt = getTotalDebtForCollateralToken(collateralId);\n    uint256[] memory openLiens = getLiens(collateralId);\n    impliedRate = 0;\n    for (uint256 i = 0; i < openLiens.length; ++i) {\n      Lien memory lien = lienData[openLiens[i]];\n\n      impliedRate += lien.rate * lien.amount;\n    }\n\n    if (totalDebt > uint256(0)) {\n      impliedRate = impliedRate.mulDivDown(1, totalDebt);\n    }\n  }\n\n  /**\n   * @dev Computes the debt owed to a Lien.\n   * @param lien The specified Lien.\n   * @return The amount owed to the specified Lien.\n   */\n  function _getOwed(Lien memory lien) internal view returns (uint256) {\n    return _getOwed(lien, block.timestamp);\n  }\n\n  /**\n   * @dev Computes the debt owed to a Lien at a specified timestamp.\n   * @param lien The specified Lien.\n   * @return The amount owed to the Lien at the specified timestamp.\n   */\n  function _getOwed(Lien memory lien, uint256 timestamp)\n    internal\n    view\n    returns (uint256)\n  {\n    return lien.amount + _getInterest(lien, timestamp);\n  }\n\n  /**\n   * @dev Computes the interest still owed to a Lien.\n   * @param lien The specified Lien.\n   * @param buyout compute with a ceiling based on the buyout interest window\n   * @return The WETH still owed in interest to the Lien.\n   */\n  function _getRemainingInterest(Lien memory lien, bool buyout)\n    internal\n    view\n    returns (uint256)\n  {\n    uint256 end = lien.start + lien.duration;\n    if (buyout) {\n      uint32 getBuyoutInterestWindow = ASTARIA_ROUTER.getBuyoutInterestWindow();\n      if (\n        lien.start + lien.duration >= block.timestamp + getBuyoutInterestWindow\n      ) {\n        end = block.timestamp + getBuyoutInterestWindow;\n      }\n    }\n\n    uint256 delta_t = end - block.timestamp;\n\n    return\n      delta_t.mulDivDown(lien.rate, 1).mulDivDown(\n        lien.amount,\n        INTEREST_DENOMINATOR\n      );\n  }\n\n  function getInterest(uint256 lienId) public view returns (uint256) {\n    return _getInterest(lienData[lienId], block.timestamp);\n  }\n\n  /**\n   * @dev Make a payment from a payer to a specific lien against a CollateralToken.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param position The position of the lien to make a payment to.\n   * @param paymentAmount The amount to pay against the debt.\n   * @param payer The address to make the payment.\n   * @return The paymentAmount for the payment.\n   */\n  function _payment(\n    uint256 collateralId,\n    uint8 position,\n    uint256 paymentAmount,\n    address payer\n  ) internal returns (uint256) {\n    if (paymentAmount == uint256(0)) {\n      return uint256(0);\n    }\n\n    uint256 lienId = liens[collateralId][position];\n    Lien storage lien = lienData[lienId];\n    uint256 end = (lien.start + lien.duration);\n    require(\n      block.timestamp < end || address(msg.sender) == address(AUCTION_HOUSE),\n      \"cannot pay off an expired lien\"\n    );\n\n    address lienOwner = ownerOf(lienId);\n    bool isPublicVault = IPublicVault(lienOwner).supportsInterface(\n      type(IPublicVault).interfaceId\n    );\n\n    lien.amount = _getOwed(lien);\n\n    address payee = getPayee(lienId);\n    if (isPublicVault) {\n      IPublicVault(lienOwner).beforePayment(lienId, paymentAmount);\n    }\n    if (lien.amount > paymentAmount) {\n      lien.amount -= paymentAmount;\n      lien.last = block.timestamp.safeCastTo32();\n      // slope does not need to be updated if paying off the rest, since we neutralize slope in beforePayment()\n      if (isPublicVault) {\n        IPublicVault(lienOwner).afterPayment(lienId);\n      }\n    } else {\n      if (isPublicVault && !AUCTION_HOUSE.auctionExists(collateralId)) {\n        // since the openLiens count is only positive when there are liens that haven't been paid off\n        // that should be liquidated, this lien should not be counted anymore\n        IPublicVault(lienOwner).decreaseEpochLienCount(\n          IPublicVault(lienOwner).getLienEpoch(end)\n        );\n      }\n      //delete liens\n      _deleteLienPosition(collateralId, position);\n      delete lienData[lienId]; //full delete\n\n      _burn(lienId);\n    }\n\n    TRANSFER_PROXY.tokenTransferFrom(WETH, payer, payee, paymentAmount);\n\n    emit Payment(lienId, paymentAmount);\n    return paymentAmount;\n  }\n\n  function _deleteLienPosition(uint256 collateralId, uint256 position) public {\n    uint256[] storage stack = liens[collateralId];\n    require(position < stack.length, \"index out of bounds\");\n\n    emit RemoveLien(\n      stack[position],\n      lienData[stack[position]].collateralId,\n      lienData[stack[position]].position\n    );\n    for (uint256 i = position; i < stack.length - 1; i++) {\n      stack[i] = stack[i + 1];\n    }\n    stack.pop();\n  }\n\n  /**\n   * @notice Retrieve the payee (address that receives payments and auction funds) for a specified Lien.\n   * @param lienId The ID of the Lien.\n   * @return The address of the payee for the Lien.\n   */\n  function getPayee(uint256 lienId) public view returns (address) {\n    return\n      lienData[lienId].payee != address(0)\n        ? lienData[lienId].payee\n        : ownerOf(lienId);\n  }\n\n  /**\n   * @notice Change the payee for a specified L"
    }
  ]
}