{
  "Title": "H-3: Vault global shares and assets change will mismatch local shares and assets change during settlement due to incorrect `_withoutSettlementFeeGlobal` formula",
  "Content": "# Issue H-3: Vault global shares and assets change will mismatch local shares and assets change during settlement due to incorrect `_withoutSettlementFeeGlobal` formula \n\nSource: https://github.com/sherlock-audit/2024-02-perennial-v2-3-judging/issues/26 \n\n## Found by \npanprog\n## Summary\n\nEvery vault update, which involves change of position in the underlying markets, `settlementFee` is charged by the Market. Since many users can deposit and redeem during the same oracle version, this `settlementFee` is shared equally between all users of the same oracle version. However, there is an issue in that `settlementFee` is charged once both for deposits and redeems, however `_withoutSettlementFeeGlobal` subtracts `settlementFee` in full both for deposits and redeems, meaning that for global fee, it's basically subtracted twice (once for deposits, and another time for redeems). But for local fee, it's subtracted proportional to `checkpoint.orders`, with sum of fee subtracted equal to exactly `settlementFee` (once). This difference in global and local `settlementFee` calculations leads to inflated `shares` and `assets` added for user deposits (local state) compared to vault overall (global state).\n\n## Vulnerability Detail\n\nHere is an easy scenario to demonstrate the issue:\n1. `SettlementFee = $10`\n2. User1 deposits `$10` for oracle version `t = 100`\n3. User2 redeems `10 shares` (worth `$10`) for the same oracle version `t = 100` (`checkpoint.orders = 2`)\n4. Once the oracle version `t = 100` settles, we have the following:\n4.1. Global deposits = $10, redeems = $10\n4.2. Global deposits convert to `0 shares` (because `_withoutSettlementFeeGlobal(10)` applies `settlementFee` of $10 in full, returning `10-10=0`)\n4.3. Global redeems convert to `0 assets` (because `_withoutSettlementFeeGlobal(10)` applies `settlementFee` of $10 in full, returning `10-10=0`)\n4.4. User1 deposit of $10 converts to `5 shares` (because `_withoutSettlementFeeLocal(10)` applies `settlementFee` of $5 (because there are 2 orders), returning `10-5=5`)\n4.5. User2 redeem of 10 shares converts to `$5` (for the same reason)\n\nFrom the example above it can be seen that:\n1. User1 receives 5 shares, but global vault shares didn't increase. Over time this difference will keep growing potentially leading to a situation where many user redeems will lead to 0 global shares, but many users will still have local shares which they will be unable to redeem due to underflow, thus losing funds.\n2. User2's assets which he can claim increase by $5, but global claimable assets didn't change, meaning User2 will be unable to claim assets due to underflow when trying to decrease global assets, leading to loss of funds for User2.\n\nThe underflow in both cases will happen in `Vault._update` when trying to update global account:\n```solidity\nfunction update(\n    Account memory self,\n    uint256 currentId,\n    UFixed6 assets,\n    UFixed6 shares,\n    UFixed6 deposit,\n    UFixed6 redemption\n) internal pure {\n    self.current = currentId;\n    // @audit global account will have less assets and shares than sum of local accounts\n    (self.assets, self.shares) = (self.assets.sub(assets), self.shares.sub(shares));\n    (self.deposit, self.redemption) = (self.deposit.add(deposit), self.redemption.add(redemption));\n}\n```\n\n## Impact\n\nAny time there are both deposits and redeems in the same oracle version, the users receive more (local) shares and assets than overall vault shares and assets increase (global). This mismatch causes:\n1. Systematic increase of (sum of user shares - global shares), which can lead to bank run since the last users who try to redeem will be unable to do so due to underflow.\n2. Systematic increase of (sum of user assets - global assets), which will lead to users being unable to claim their redeemed assets due to underflow.\n\nThe total difference in local and global `shares+assets` equals to `settlementFee` per each oracle version with both deposits and redeems. This can add up to significant amounts (at `settlementFee = $1` this can be $100-$1000 per day), meaning it will quickly become visible especially for point 2., because typically global claimable assets are at or near 0 most of the time, since users usually redeem and then immediately claim, thus any difference of global and local assets will quickly lead to users being unable to claim.\n\n## Code Snippet\n\nSettlementFee subtracted in `_withoutSettlementFeeGlobal`\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial-vault/contracts/types/Checkpoint.sol#L183-L185\n\nThis is subtracted twice: for deposit and for redeem:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial-vault/contracts/types/Account.sol#L62-L63\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCalculate total orders to deposit and total orders to redeem (in addition to total orders overall). Then `settlementFee` should be multiplied by `deposit/orders` for `toGlobalShares` and by `redeems/orders` for `toGlobalAssets`. This weightening of `settlementFee` will make it in-line with local order weights.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/equilibria-xyz/perennial-v2/pull/305\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/254",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/types/Checkpoint.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Checkpoint as PerennialCheckpoint } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { Account } from \"./Account.sol\";\n\n/// @dev Checkpoint type\nstruct Checkpoint {\n    /// @dev The total amount of pending deposits\n    UFixed6 deposit;\n\n    /// @dev The total amount of pending redemptions\n    UFixed6 redemption;\n\n    /// @dev The total shares at the checkpoint\n    UFixed6 shares;\n\n    /// @dev The total assets at the checkpoint\n    Fixed6 assets;\n\n    /// @dev The total fee at the checkpoint\n    Fixed6 tradeFee;\n\n    /// @dev The total settlement fee at the checkpoint\n    UFixed6 settlementFee;\n\n    /// @dev The number of deposits and redemptions during the checkpoint\n    uint256 orders;\n\n    // @dev The timestamp of of the checkpoint\n    uint256 timestamp;\n}\nusing CheckpointLib for Checkpoint global;\nstruct StoredCheckpoint {\n    /* slot 0 */\n    uint64 deposit;         // <= 18.44t\n    uint64 redemption;      // <= 18.44t\n    uint64 shares;          // <= 18.44t\n    int64 assets;           // <= 9.22t\n\n    /* slot 1 */\n    int64 tradeFee;         // <= 9.22t\n    uint64 settlementFee;   // <= 18.44t\n    uint32 orders;           // <= 4.29b\n    uint32 timestamp;       // <= 4.29b\n    bytes8 __unallocated__;\n}\nstruct CheckpointStorage { StoredCheckpoint value; }\nusing CheckpointStorageLib for CheckpointStorage global;\n\n/// @title Checkpoint\n/// @notice Holds the state for the checkpoint type\nlibrary CheckpointLib {\n    /// @notice Initializes the checkpoint\n    /// @dev Saves the current shares, and the assets + liabilities in the vault itself (not in the markets)\n    /// @param self The checkpoint to initialize\n    /// @param timestamp The timestamp of the checkpoint\n    /// @param global The global account\n    function next(Checkpoint memory self, uint256 timestamp, Account memory global) internal pure {\n        (self.timestamp, self.shares, self.assets) =\n            (timestamp, global.shares, Fixed6Lib.from(-1, global.deposit.add(global.assets)));\n        (self.deposit, self.redemption, self.tradeFee, self.settlementFee, self.orders) =\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO, Fixed6Lib.ZERO, UFixed6Lib.ZERO, 0);\n    }\n\n    /// @notice Updates the checkpoint with a new deposit or redemption\n    /// @param self The checkpoint to update\n    /// @param deposit The amount of new deposits\n    /// @param redemption The amount of new redemptions\n    function update(Checkpoint memory self, UFixed6 deposit, UFixed6 redemption) internal pure {\n        (self.deposit, self.redemption) =\n            (self.deposit.add(deposit), self.redemption.add(redemption));\n        if (!deposit.isZero() || !redemption.isZero()) self.orders++;\n    }\n\n    /// @notice Completes the checkpoint\n    /// @dev Increments the assets by the snapshotted amount of collateral in the underlying markets\n    /// @param self The checkpoint to complete\n    /// @param marketCheckpoint The checkpoint to complete with\n    function complete(Checkpoint memory self, PerennialCheckpoint memory marketCheckpoint) internal pure {\n        self.assets = self.assets.add(marketCheckpoint.collateral);\n        self.tradeFee = marketCheckpoint.tradeFee;\n        self.settlementFee = marketCheckpoint.settlementFee;\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint in the global context\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function toSharesGlobal(Checkpoint memory self, UFixed6 assets) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        if (self.shares.isZero()) return assets;\n\n        // if vault is insolvent, default to par value\n        return  self.assets.lte(Fixed6Lib.ZERO) ? assets : _toShares(self, _withoutSettlementFeeGlobal(self, assets));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the global context\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssetsGlobal(Checkpoint memory self, UFixed6 shares) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        return _withoutSettlementFeeGlobal(self, self.shares.isZero() ? shares : _toAssets(self, shares));\n    }\n\n\n    /// @notice Converts a given amount of assets to shares at checkpoint in the local context\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function toSharesLocal(Checkpoint memory self, UFixed6 assets) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        if (self.shares.isZero()) return assets;\n\n        // if vault is insolvent, default to par value\n        return  self.assets.lte(Fixed6Lib.ZERO) ? assets : _toShares(self, _withoutSettlementFeeLocal(self, assets));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the local context\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssetsLocal(Checkpoint memory self, UFixed6 shares) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        return _withoutSettlementFeeLocal(self, self.shares.isZero() ? shares : _toAssets(self, shares));\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint in the global context\n    /// @dev Dev used in limit calculations when a non-historical settlement fee must be used\n    /// @param assets Number of assets to convert to shares\n    /// @param settlementFee Custom settlement fee\n    /// @return Amount of shares for the given assets at checkpoint\n    function toShares(Checkpoint memory self, UFixed6 assets, UFixed6 settlementFee) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        if (self.shares.isZero()) return assets;\n\n        // if vault is insolvent, default to par value\n        return  self.assets.lte(Fixed6Lib.ZERO) ? assets : _toShares(self, _withoutSettlementFee(assets, settlementFee));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the global context\n    /// @dev Dev used in limit calculations when a non-historical settlement fee must be used\n    /// @param shares Number of shares to convert to shares\n    /// @param settlementFee Custom settlement fee\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssets(Checkpoint memory self, UFixed6 shares, UFixed6 settlementFee) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        return _withoutSettlementFee(self.shares.isZero() ? shares : _toAssets(self, shares), settlementFee);\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function _toShares(Checkpoint memory self, UFixed6 assets) private pure returns (UFixed6) {\n        UFixed6 selfAssets = UFixed6Lib.unsafeFrom(self.assets);\n        return _withSpread(self, assets.muldiv(self.shares, selfAssets));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function _toAssets(Checkpoint memory self, UFixed6 shares) private pure returns (UFixed6) {\n        UFixed6 selfAssets = UFixed6Lib.unsafeFrom(self.assets);\n        return _withSpread(self, shares.muldiv(selfAssets, self.shares));\n    }\n\n    /// @notice Applies a spread to a given amount from the relative fee amount of the checkpoint\n    /// @param self The checkpoint to apply the spread to\n    /// @param amount The amount to apply the spread to\n    function _withSpread(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n        UFixed6 selfAssets = UFixed6Lib.unsafeFrom(self.assets);\n        UFixed6 totalAmount = self.deposit.add(self.redemption.muldiv(selfAssets, self.shares));\n        UFixed6 totalAmountIncludingFee = UFixed6Lib.unsafeFrom(Fixed6Lib.from(totalAmount).sub(self.tradeFee));\n\n        return totalAmount.isZero() ?\n            amount :\n            amount.muldiv(totalAmountIncludingFee, totalAmount);\n    }\n\n    /// @notice Applies the fixed settlement fee to a given amount in the global context\n    /// @param self The checkpoint to apply the fee to\n    /// @param amount The amount to apply the fee to\n    /// @return The amount with the settlement fee\n    function _withoutSettlementFeeGlobal(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n        return _withoutSettlementFee(amount, self.settlementFee);\n    }\n\n    /// @notice Applies the fixed settlement fee to a given amount in the local context\n    /// @param self The checkpoint to apply the fee to\n    /// @param amount The amount to apply the fee to\n    /// @return The amount with the settlement fee\n    function _withoutSettlementFeeLocal(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n        UFixed6 settlementFeePer = self.orders == 0 ?\n            UFixed6Lib.ZERO :\n            self.settlementFee.div(UFixed6Lib.from(self.orders));\n        return _withoutSettlementFee(amount, settlementFeePer);\n    }\n\n    /// @notice Applies the fixed settlement fee to a given amount in the local context\n    /// @param amount The amount to apply the fee to\n    /// @param settlementFee The amount of settlement fee to deduct\n    /// @return The amount with the settlement fee\n    function _withoutSettlementFee(UFixed6 amount, UFixed6 settlementFee) private pure returns (UFixed6) {\n        return amount.unsafeSub(settlementFee);\n    }\n\n    /// @notice Returns if the checkpoint is healthy\n    /// @dev A checkpoint is unhealthy when it has shares but no assets, since this cannot be recovered from\n    /// @param self The checkpoint to check\n    /// @return Whether the checkpoint is healthy\n    function unhealthy(Checkpoint memory self) internal pure returns (bool) {\n        return !self.shares.isZero() && self.assets.lte(Fixed6Lib.ZERO);\n    }\n}\n\nlibrary CheckpointStorageLib {\n    // sig: 0xba85116a\n    error CheckpointStorageInvalidError();\n\n    function read(CheckpointStorage storage self) internal view returns (Checkpoint memory) {\n        StoredCheckpoint memory storedValue = self.value;\n        return Checkpoint(\n            UFixed6.wrap(uint256(storedValue.deposit)),\n            UFixed6.wrap(uint256(storedValue.redemption)),\n            UFixed6.wrap(uint256(storedValue.shares)),\n            Fixed6.wrap(int256(storedValue.assets)),\n            Fixed6.wrap(int256(storedValue.tradeFee)),\n            UFixed6.wrap(uint256(storedValue.settlementFee)),\n            uint256(storedValue.orders),\n            uint256(storedValue.timestamp)\n        );\n    }\n\n    function store(CheckpointStorage storage self, Checkpoint memory newValue) internal {\n        if (newValue.deposit.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.redemption.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.shares.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.assets.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.assets.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\n        if (newValue.tradeFee.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.tradeFee.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\n        if (newValue.settlementFee.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.orders > uint256(type(uint32).max)) revert CheckpointStorageInvalidError();\n        if (newValue.timestamp > uint256(type(uint32).max)) revert CheckpointStorageInvalidError();\n\n        self.value = StoredCheckpoint(\n            uint64(UFixed6.unwrap(newValue.deposit)),\n            uint64(UFixed6.unwrap(newValue.redemption)),\n            uint64(UFixed6.unwrap(newValue.shares)),\n            int64(Fixed6.unwrap(newValue.assets)),\n\n            int64(Fixed6.unwrap(newValue.tradeFee)),\n            uint64(UFixed6.unwrap(newValue.settlementFee)),\n            uint32(newValue.orders),\n            uint32(newValue.timestamp),\n            bytes8(0)\n        );\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/types/Account.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport \"./Checkpoint.sol\";\n\n/// @dev Account type\nstruct Account {\n    /// @dev The current position id\n    uint256 current;\n\n    /// @dev The latest position id\n    uint256 latest;\n\n    /// @dev The total shares\n    UFixed6 shares;\n\n    /// @dev The total assets\n    UFixed6 assets;\n\n    /// @dev The amount of pending deposits\n    UFixed6 deposit;\n\n    /// @dev The amount of pending redemptions\n    UFixed6 redemption;\n}\nusing AccountLib for Account global;\nstruct StoredAccount {\n    /* slot 0 */\n    uint32 current;         // <= 4.29b\n    uint32 latest;          // <= 4.29b\n    bytes24 __unallocated0__;\n\n    /* slot 1 */\n    uint64 shares;          // <= 18.44t\n    uint64 assets;          // <= 18.44t\n    uint64 deposit;         // <= 18.44t\n    uint64 redemption;      // <= 18.44t\n}\nstruct AccountStorage { StoredAccount value; }\nusing AccountStorageLib for AccountStorage global;\n\n\n/// @title Account\n/// @notice Holds the state for the account type\nlibrary AccountLib {\n    /// @notice Processes the position in a global context\n    /// @param self The account to update\n    /// @param latestId The latest position id\n    /// @param checkpoint The checkpoint to process\n    /// @param deposit The amount of pending deposits\n    /// @param redemption The amount of pending redemptions\n    function processGlobal(\n        Account memory self,\n        uint256 latestId,\n        Checkpoint memory checkpoint,\n        UFixed6 deposit,\n        UFixed6 redemption\n    ) internal pure {\n        self.latest = latestId;\n        (self.assets, self.shares) = (\n            self.assets.add(checkpoint.toAssetsGlobal(redemption)),\n            self.shares.add(checkpoint.toSharesGlobal(deposit))\n        );\n        (self.deposit, self.redemption) = (self.deposit.sub(deposit), self.redemption.sub(redemption));\n    }\n\n    /// @notice Processes the position in a local context\n    /// @param self The account to update\n    /// @param latestId The latest position id\n    /// @param checkpoint The checkpoint to process\n    /// @param deposit The amount of pending deposits to clear\n    /// @param redemption The amount of pending redemptions to clear\n    function processLocal(\n        Account memory self,\n        uint256 latestId,\n        Checkpoint memory checkpoint,\n        UFixed6 deposit,\n        UFixed6 redemption\n    ) internal pure {\n        self.latest = latestId;\n        (self.assets, self.shares) = (\n            self.assets.add(checkpoint.toAssetsLocal(redemption)),\n            self.shares.add(checkpoint.toSharesLocal(deposit))\n        );\n        (self.deposit, self.redemption) = (self.deposit.sub(deposit), self.redemption.sub(redemption));\n    }\n\n    /// @notice Updates the account with a new order\n    /// @param self The account to update\n    /// @param currentId The current position id\n    /// @param assets The amount of assets to deduct\n    /// @param shares The amount of shares to deduct\n    /// @param deposit The amount of pending deposits\n    /// @param redemption The amount of pending redemptions\n    function update(\n        Account memory self,\n        uint256 currentId,\n        UFixed6 assets,\n        UFixed6 shares,\n        UFixed6 deposit,\n        UFixed6 redemption\n    ) internal pure {\n        self.current = currentId;\n        (self.assets, self.shares) = (self.assets.sub(assets), self.shares.sub(shares));\n        (self.deposit, self.redemption) = (self.deposit.add(deposit), self.redemption.add(redemption));\n    }\n}\n\nlibrary AccountStorageLib {\n    // sig: 0xb8a09499\n    error AccountStorageInvalidError();\n\n    function read(AccountStorage storage self) internal view returns (Account memory) {\n        StoredAccount memory storedValue = self.value;\n        return Account(\n            uint256(storedValue.current),\n            uint256(storedValue.latest),\n            UFixed6.wrap(uint256(storedValue.shares)),\n            UFixed6.wrap(uint256(storedValue.assets)),\n            UFixed6.wrap(uint256(storedValue.deposit)),\n            UFixed6.wrap(uint256(storedValue.redemption))\n        );\n    }\n\n    function store(AccountStorage storage self, Account memory newValue) internal {\n        if (newValue.current > uint256(type(uint32).max)) revert AccountStorageInvalidError();\n        if (newValue.latest > uint256(type(uint32).max)) revert AccountStorageInvalidError();\n        if (newValue.shares.gt(UFixed6.wrap(type(uint64).max))) revert AccountStorageInvalidError();\n        if (newValue.assets.gt(UFixed6.wrap(type(uint64).max))) revert AccountStorageInvalidError();\n        if (newValue.deposit.gt(UFixed6.wrap(type(uint64).max))) revert AccountStorageInvalidError();\n        if (newValue.redemption.gt(UFixed6.wrap(type(uint64).max))) revert AccountStorageInvalidError();\n\n        self.value = StoredAccount(\n            uint32(newValue.current),\n            uint32(newValue.latest),\n            bytes24(0),\n\n            uint64(UFixed6.unwrap(newValue.shares)),\n            uint64(UFixed6.unwrap(newValue.assets)),\n            uint64(UFixed6.unwrap(newValue.deposit)),\n            uint64(UFixed6.unwrap(newValue.redemption))\n        );\n    }\n}"
    }
  ]
}