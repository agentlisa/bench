{
  "Title": "[L-03] Solmate's SafeTransferLib doesn't check whether the ERC20 contract exists",
  "Content": "\nSolmate's SafeTransferLib, which is often used to interact with non-compliant/unsafe ERC20 tokens, does not check whether the ERC20 contract exists. The following code will not revert in case the token doesn't exist (yet).\n\nThis is stated in the Solmate library:\nhttps://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol#L9\n\n```solidity\n\n19 results \n\nsrc/PirexFees.sol:\n    5: import {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\n  114:         token.safeTransfer(treasury, treasuryDistribution);\n  115:         token.safeTransfer(contributors, contributorsDistribution);\n\nsrc/PirexGmx.sol:\n    7: import {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\n  392:         gmx.safeTransferFrom(msg.sender, address(this), amount);\n\n  506:             t.safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n  643:             ERC20(pxGlp).safeTransferFrom(\n\n  844:             gmxBaseReward.safeTransfer(receiver, postFeeAmount);\n \n  847:                 gmxBaseReward.safeTransfer(address(pirexFees), feeAmount);\n\n  946:         gmxBaseReward.safeTransfer(\n\n\n\nsrc/vaults/AutoPxGlp.sol:\n    6: import {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\n\n  258:                 asset.safeTransfer(msg.sender, pxGlpIncentive);\n  259  \n  260:             asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);\n\n  274:                 pxGmx.safeTransfer(msg.sender, pxGmxIncentive);\n  275  \n  276:             pxGmx.safeTransfer(owner, totalPxGmxFee - pxGmxIncentive);\n\n  344:         stakedGlp.safeTransferFrom(msg.sender, address(this), amount);\n\n  387:         erc20Token.safeTransferFrom(msg.sender, address(this), tokenAmount);\n  388  \n\nsrc/vaults/AutoPxGmx.sol:\n    7: import {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\t\n  297:             if (incentive != 0) asset.safeTransfer(msg.sender, incentive);\n  298  \n  299:             asset.safeTransfer(owner, totalFee - incentive);\n\n  336:         asset.safeTransfer(receiver, assets);\n\n  361:         asset.safeTransfer(receiver, assets);\n\n  382:         gmx.safeTransferFrom(msg.sender, address(this), amount);\n```\n\n### Recommended Mitigation Steps\n\nAdd a contract exist control in functions;\n```js\npragma solidity >=0.8.0;\n\nfunction isContract(address _addr) private returns (bool isContract) {\n    isContract = _addr.code.length > 0;\n}\n\n```\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-11-redacted-cartel-contest",
  "Code": [
    {
      "filename": "src/utils/SafeTransferLib.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}"
    }
  ]
}