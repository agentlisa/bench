{
  "Title": "M-1: `fundPool` does not work with fee-on-transfer token",
  "Content": "# Issue M-1: `fundPool` does not work with fee-on-transfer token \n\nSource: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/19 \n\n## Found by \n0x1337, 0x180db, 0x6980, 0xHelium, 0xMosh, 0xbepresent, 0xdeadbeef, 0xgoat, Aamirusmani1552, ArmedGoose, AsenXDeth, BenRai, DevABDee, Inspex, JP\\_Courses, Kodyvim, Kow, Martians, Proxy, Tri-pathi, Vagner, WATCHPUG, ace13567, adeolu, alexzoid, ashirleyshe, ast3ros, cats, detectiveking, foresthalberd, grearlake, imsrybr0, inspecktor, inzinko, lealCodes, lemonmon, lil.eth, marchev, nobody2018, osmanozdemir1, p0wd3r, parsely, pavankv241, pengun, pontifex, qbs, rvierdiiev, seeques, shtesesamoubiq, theclonedtyroneidgafmf, trevorjudice, tsvetanovv, vagrant, xAriextz\n## Vulnerability Detail\nIn `_fundPool`, the parameter for `increasePoolAmount` is directly the amount used in the `transferFrom` call.\n\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/core/Allo.sol#L516-L517\n```solidity\n        _transferAmountFrom(_token, TransferData({from: msg.sender, to: address(_strategy), amount: amountAfterFee}));\n        _strategy.increasePoolAmount(amountAfterFee);\n```\n\nWhen `_token` is a fee-on-transfer token, the actual amount transferred to `_strategy` will be less than `amountAfterFee`. Therefore, the current approach could lead to a recorded balance that is greater than the actual balance.\n## Impact\n`fundPool` does not work with fee-on-transfer token\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/core/Allo.sol#L516-L517\n## Tool used\n\nManual Review\n\n## Recommendation\nUse the change in `_token` balance as the parameter for `increasePoolAmount`.\n\n\n\n## Discussion\n\n**MLON33**\n\nhttps://github.com/allo-protocol/allo-v2/pull/355\n\n**quentin-abei**\n\nShould consider choosing this issue for report : \n[30](https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/30)\nIt's better detailed and have an actual working coded PoC\n\n**jack-the-pug**\n\nFixed.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/109",
  "Code": [
    {
      "filename": "allo-v2/contracts/core/Allo.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport \"solady/src/auth/Ownable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts/contracts/access/AccessControl.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n// Interfaces\nimport \"./interfaces/IAllo.sol\";\n\n// Internal Libraries\nimport {Clone} from \"./libraries/Clone.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\nimport \"./libraries/Native.sol\";\nimport {Transfer} from \"./libraries/Transfer.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Allo\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice This contract is used to create & manage pools as well as manage the protocol.\n/// @dev The contract must be initialized with the 'initialize()' function.\ncontract Allo is IAllo, Native, Transfer, Initializable, Ownable, AccessControl, ReentrancyGuardUpgradeable, Errors {\n    // ==========================\n    // === Storage Variables ====\n    // ==========================\n\n    /// @notice Percentage that is used to calculate the fee Allo takes from each pool when funded\n    ///         and is deducted when a pool is funded. So if you want to fund a round with 1000 DAI and the fee\n    ///         percentage is 1e17 (10%), then 100 DAI will be deducted from the 1000 DAI and the pool will be\n    ///         funded with 900 DAI. The fee is then sent to the treasury address.\n    /// @dev How the percentage is represented in our contracts: 1e18 = 100%, 1e17 = 10%, 1e16 = 1%, 1e15 = 0.1%\n    uint256 private percentFee;\n\n    /// @notice Fee Allo charges for all pools on creation\n    /// @dev This is different from the 'percentFee' in that this is a flat fee and not a percentage. So if you want to create a pool\n    ///      with a base fee of 100 DAI, then you would pass 100 DAI to the 'createPool()' function and the pool would be created\n    ///      with 100 DAI less than the amount you passed to the function. The base fee is sent to the treasury address.\n    uint256 internal baseFee;\n\n    /// @notice Incremental index to track the pools created\n    uint256 private _poolIndex;\n\n    /// @notice Allo treasury\n    address payable private treasury;\n\n    /// @notice Registry contract\n    IRegistry private registry;\n\n    /// @notice Maps the `msg.sender` to a `nonce` to prevent duplicates\n    /// @dev 'msg.sender' -> 'nonce' for cloning strategies\n    mapping(address => uint256) private _nonces;\n\n    /// @notice Maps the pool ID to the pool details\n    /// @dev 'Pool.id' -> 'Pool'\n    mapping(uint256 => Pool) private pools;\n\n    /// @notice Returns a bool for whether a strategy is cloneable or not using the strategy address as the key\n    /// @dev Strategy.address -> bool\n    mapping(address => bool) private cloneableStrategies;\n\n    // ====================================\n    // =========== Initializer =============\n    // ====================================\n\n    /// @notice Initializes the contract after an upgrade\n    /// @dev During upgrade -> a higher version should be passed to reinitializer\n    /// @param _registry The address of the registry\n    /// @param _treasury The address of the treasury\n    /// @param _percentFee The percentage fee\n    /// @param _baseFee The base fee\n    function initialize(address _registry, address payable _treasury, uint256 _percentFee, uint256 _baseFee)\n        external\n        reinitializer(1)\n    {\n        // Initialize the owner using Solady ownable library\n        _initializeOwner(msg.sender);\n\n        // Set the address of the registry\n        _updateRegistry(_registry);\n\n        // Set the address of the treasury\n        _updateTreasury(_treasury);\n\n        // Set the fee percentage\n        _updatePercentFee(_percentFee);\n\n        // Set the base fee\n        _updateBaseFee(_baseFee);\n    }\n\n    // ====================================\n    // =========== Modifier ===============\n    // ====================================\n\n    // Both modifiers below are using OpenZeppelin's AccessControl.sol with custom roles under the hood\n\n    /// @notice Reverts UNAUTHORIZED() if the caller is not a pool manager\n    /// @param _poolId The pool id\n    modifier onlyPoolManager(uint256 _poolId) {\n        _checkOnlyPoolManager(_poolId);\n        _;\n    }\n\n    /// @notice Reverts UNAUTHORIZED() if the caller is not a pool admin\n    /// @param _poolId The pool id\n    modifier onlyPoolAdmin(uint256 _poolId) {\n        _checkOnlyPoolAdmin(_poolId);\n        _;\n    }\n\n    //  ====================================\n    //  ==== External/Public Functions =====\n    //  ====================================\n\n    /// @notice Creates a new pool (with a custom strategy)\n    /// @dev 'msg.sender' must be a member or owner of a profile to create a pool with or without a custom strategy, The encoded data\n    ///      will be specific to a given strategy requirements, reference the strategy implementation of 'initialize()'. The strategy\n    ///      address passed must not be a cloneable strategy. The strategy address passed must not be the zero address. 'msg.sender' must\n    ///      be a member or owner of the profile id passed as '_profileId'.\n    /// @param _profileId The 'profileId' of the registry profile, used to check if 'msg.sender' is a member or owner of the profile\n    /// @param _strategy The address of the deployed custom strategy\n    /// @param _initStrategyData The data to initialize the strategy\n    /// @param _token The address of the token you want to use in your pool\n    /// @param _amount The amount of the token you want to deposit into the pool on initialization\n    /// @param _metadata The 'Metadata' of the pool, this uses our 'Meatdata.sol' struct (consistent throughout the protocol)\n    /// @param _managers The managers of the pool, and can be added/removed later by the pool admin\n    /// @return poolId The ID of the pool\n    function createPoolWithCustomStrategy(\n        bytes32 _profileId,\n        address _strategy,\n        bytes memory _initStrategyData,\n        address _token,\n        uint256 _amount,\n        Metadata memory _metadata,\n        address[] memory _managers\n    ) external payable returns (uint256 poolId) {\n        // Revert if the strategy address passed is the zero address with 'ZERO_ADDRESS()'\n        if (_strategy == address(0)) revert ZERO_ADDRESS();\n\n        // Revert if we already have this strategy in our cloneable mapping with 'IS_APPROVED_STRATEGY()' (only non-cloneable strategies can be used)\n        if (_isCloneableStrategy(_strategy)) revert IS_APPROVED_STRATEGY();\n\n        // Call the internal '_createPool()' function and return the pool ID\n        return _createPool(_profileId, IStrategy(_strategy), _initStrategyData, _token, _amount, _metadata, _managers);\n    }\n\n    /// @notice Creates a new pool (by cloning a cloneable strategies).\n    /// @dev 'msg.sender' must be owner or member of the profile id passed as '_profileId'.\n    /// @param _profileId The ID of the registry profile, used to check if 'msg.sender' is a member or owner of the profile\n    /// @param _strategy The address of the strategy contract the pool will use.\n    /// @param _initStrategyData The data to initialize the strategy\n    /// @param _token The address of the token\n    /// @param _amount The amount of the token\n    /// @param _metadata The metadata of the pool\n    /// @param _managers The managers of the pool\n    /// @custom:initstrategydata The encoded data will be specific to a given strategy requirements,\n    ///    reference the strategy implementation of 'initialize()'\n    function createPool(\n        bytes32 _profileId,\n        address _strategy,\n        bytes memory _initStrategyData,\n        address _token,\n        uint256 _amount,\n        Metadata memory _metadata,\n        address[] memory _managers\n    ) external payable nonReentrant returns (uint256 poolId) {\n        if (!_isCloneableStrategy(_strategy)) {\n            revert NOT_APPROVED_STRATEGY();\n        }\n\n        // Returns the created pool ID\n        return _createPool(\n            _profileId,\n            IStrategy(Clone.createClone(_strategy, _nonces[msg.sender]++)),\n            _initStrategyData,\n            _token,\n            _amount,\n            _metadata,\n            _managers\n        );\n    }\n\n    /// @notice Update pool metadata\n    /// @dev 'msg.sender' must be a pool manager. Emits 'PoolMetadataUpdated()' event.\n    /// @param _poolId ID of the pool\n    /// @param _metadata The new metadata of the pool\n    function updatePoolMetadata(uint256 _poolId, Metadata memory _metadata) external onlyPoolManager(_poolId) {\n        Pool storage pool = pools[_poolId];\n        pool.metadata = _metadata;\n\n        emit PoolMetadataUpdated(_poolId, _metadata);\n    }\n\n    /// @notice Updates the registry address.\n    /// @dev Use this to update the registry address. 'msg.sender' must be Allo owner.\n    /// @param _registry The new registry address\n    function updateRegistry(address _registry) external onlyOwner {\n        _updateRegistry(_registry);\n    }\n\n    /// @notice Updates the treasury address.\n    /// @dev Use this to update the treasury address. 'msg.sender' must be Allo owner.\n    /// @param _treasury The new treasury address\n    function updateTreasury(address payable _treasury) external onlyOwner {\n        _updateTreasury(_treasury);\n    }\n\n    /// @notice Updates the fee percentage.\n    /// @dev Use this to update the fee percentage. 'msg.sender' must be Allo owner.\n    /// @param _percentFee The new fee\n    function updatePercentFee(uint256 _percentFee) external onlyOwner {\n        _updatePercentFee(_percentFee);\n    }\n\n    /// @notice Updates the base fee.\n    /// @dev Use this to update the base fee. 'msg.sender' must be Allo owner.\n    /// @param _baseFee The new base fee\n    function updateBaseFee(uint256 _baseFee) external onlyOwner {\n        _updateBaseFee(_baseFee);\n    }\n\n    /// @notice Add a strategy to the allowlist.\n    /// @dev Emits the 'StrategyApproved()' event. 'msg.sender' must be Allo owner.\n    /// @param _strategy The address of the strategy\n    function addToCloneableStrategies(address _strategy) external onlyOwner {\n        if (_strategy == address(0)) revert ZERO_ADDRESS();\n\n        cloneableStrategies[_strategy] = true;\n        emit StrategyApproved(_strategy);\n    }\n\n    /// @notice Remove a strategy from the allowlist\n    /// @dev Emits 'StrategyRemoved()' event. 'msg.sender must be Allo owner.\n    /// @param _strategy The address of the strategy\n    function removeFromCloneableStrategies(address _strategy) external onlyOwner {\n        // Set the strategy to false in the cloneableStrategies mapping\n        cloneableStrategies[_strategy] = false;\n\n        // Emit the StrategyRemoved event\n        emit StrategyRemoved(_strategy);\n    }\n\n    /// @notice Add a pool manager\n    /// @dev Emits 'RoleGranted()' event. 'msg.sender' must be a pool admin.\n    /// @param _poolId ID of the pool\n    /// @param _manager The address to add\n    function addPoolManager(uint256 _poolId, address _manager) external onlyPoolAdmin(_poolId) {\n        // Reverts if the address is the zero address with 'ZERO_ADDRESS()'\n        if (_manager == address(0)) revert ZERO_ADDRESS();\n\n        // Grants the pool manager role to the '_manager' address\n        _grantRole(pools[_poolId].managerRole, _manager);\n    }\n\n    /// @notice Remove a pool manager\n    /// @dev Emits 'RoleRevoked()' event. 'msg.sender' must be a pool admin.\n    /// @param _poolId ID of the pool\n    /// @param _manager The address to remove\n    function removePoolManager(uint256 _poolId, address _manager) external onlyPoolAdmin(_poolId) {\n        _revokeRole(pools[_poolId].managerRole, _manager);\n    }\n\n    /// @notice Transfer the funds recovered  to the recipient\n    /// @dev 'msg.sender' must be Allo owner\n    /// @param _token The token to transfer\n    /// @param _recipient The recipient\n    function recoverFunds(address _token, address _recipient) external onlyOwner {\n        // Get the amount of the token to transfer, which is always the entire balance of the contract address\n        uint256 amount = _token == NATIVE ? address(this).balance : IERC20Upgradeable(_token).balanceOf(address(this));\n\n        // Transfer the amount to the recipient (pool owner)\n        _transferAmount(_token, _recipient, amount);\n    }\n\n    // ====================================\n    // ======= Strategy Functions =========\n    // ====================================\n\n    /// @notice Passes _data through to the strategy for that pool.\n    /// @dev The encoded data will be specific to a given strategy requirements, reference the strategy\n    ///      implementation of registerRecipient().\n    /// @param _poolId ID of the pool\n    /// @param _data Encoded data unique to a strategy that registerRecipient() requires\n    /// @return recipientId The recipient ID that has been registered\n    function registerRecipient(uint256 _poolId, bytes memory _data) external payable nonReentrant returns (address) {\n        // Return the recipientId (address) from the strategy\n        return pools[_poolId].strategy.registerRecipient(_data, msg.sender);\n    }\n\n    /// @notice Register multiple recipients to multiple pools.\n    /// @dev Returns the 'recipientIds' from the strategy that have been registered from calling this function.\n    ///      Encoded data unique to a strategy that registerRecipient() requires. Encoded '_data' length must match\n    ///      '_poolIds' length or this will revert with MISMATCH(). Other requirements will be determined by the strategy.\n    /// @param _poolIds ID's of the pools\n    /// @param _data An array of encoded data unique to a strategy that registerRecipient() requires.\n    /// @return recipientIds The recipient IDs that have been registered\n    function batchRegisterRecipient(uint256[] memory _poolIds, bytes[] memory _data)\n        external\n        nonReentrant\n        returns (address[] memory recipientIds)\n    {\n        uint256 poolIdLength = _poolIds.length;\n        recipientIds = new address[](poolIdLength);\n\n        if (poolIdLength != _data.length) revert MISMATCH();\n\n        // Loop through the '_poolIds' & '_data' and call the 'strategy.registerRecipient()' function\n        for (uint256 i; i < poolIdLength;) {\n            recipientIds[i] = pools[_poolIds[i]].strategy.registerRecipient(_data[i], msg.sender);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Return the recipientIds that have been registered\n        return recipientIds;\n    }\n\n    /// @notice Fund a pool.\n    /// @dev Anyone can fund a pool and call this function.\n    /// @param _poolId ID of the pool\n    /// @param _amount The amount to be deposited into the pool\n    function fundPool(uint256 _poolId, uint256 _amount) external payable nonReentrant {\n        // if amount is 0, revert with 'NOT_ENOUGH_FUNDS()' error\n        if (_amount == 0) revert NOT_ENOUGH_FUNDS();\n\n        // Call the internal fundPool() function\n        _fundPool(_amount, _poolId, pools[_poolId].strategy);\n    }\n\n    /// @notice Allocate to a recipient or multiple recipients.\n    /// @dev The encoded data will be specific to a given strategy requirements, reference the strategy\n    ///      implementation of allocate().\n    /// @param _poolId ID of the pool\n    /// @param _data Encoded data unique to the strategy for that pool\n    function allocate(uint256 _poolId, bytes memory _data) external payable nonReentrant {\n        _allocate(_poolId, _data);\n    }\n\n    /// @notice Allocate to multiple pools\n    /// @dev The encoded data will be specific to a given strategy requirements, reference the strategy\n    ///      implementation of allocate(). Please note that this is not a 'payable' function, so if you\n    ///      want to send funds to the strategy, you must send the funds using 'fundPool()'.\n    /// @param _poolIds IDs of the pools\n    /// @param _datas encoded data unique to the strategy for that pool\n    function batchAllocate(uint256[] calldata _poolIds, bytes[] memory _datas) external nonReentrant {\n        uint256 numPools = _poolIds.length;\n\n        // Reverts if the length of _poolIds does not match the length of _datas with 'MISMATCH()' error\n        if (numPools != _datas.length) revert MISMATCH();\n\n        // Loop through the _poolIds & _datas and call the internal _allocate() function\n        for (uint256 i; i < numPools;) {\n            _allocate(_poolIds[i], _datas[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Distribute to a recipient or multiple recipients.\n    /// @dev The encoded data will be specific to a given strategy requirements, reference the strategy\n    ///      implementation of 'strategy.distribute()'.\n    /// @param _poolId ID of the pool\n    /// @param _recipientIds Ids of the recipients of the distribution\n    /// @param _data Encoded data unique to the strategy\n    function distribute(uint256 _poolId, address[] memory _recipientIds, bytes memory _data) external nonReentrant {\n        pools[_poolId].strategy.distribute(_recipientIds, _data, msg.sender);\n    }\n\n    /// ====================================\n    /// ======= Internal Functions =========\n    /// ====================================\n\n    /// @notice Internal function to check is caller is pool manager\n    /// @param _poolId The pool id\n    function _checkOnlyPoolManager(uint256 _poolId) internal view {\n        if (!_isPoolManager(_poolId, msg.sender)) revert UNAUTHORIZED();\n    }\n\n    /// @notice Internal function to check is caller is pool admin\n    /// @param _poolId The pool id\n    function _checkOnlyPoolAdmin(uint256 _poolId) internal view {\n        if (!_isPoolAdmin(_poolId, msg.sender)) revert UNAUTHORIZED();\n    }\n\n    /// @notice Creates a new pool.\n    /// @dev This is an internal function that is called by the 'createPool()' & 'createPoolWithCustomStrategy()' functions\n    ///      It is used to create a new pool and is called by both functions. The 'msg.sender' must be a member or owner of\n    ///      a profile to create a pool.\n    /// @param _profileId The ID of the profile of for pool creator in the registry\n    /// @param _strategy The address of strategy\n    /// @param _initStrategyData The data to initialize the strategy\n    /// @param _token The address of the token that the pool is denominated in\n    /// @param _amount The amount of the token to be deposited into the pool\n    /// @param _metadata The 'Metadata' of the pool\n    /// @param _managers The managers of the pool\n    /// @return poolId The ID of the pool\n    function _createPool(\n        bytes32 _profileId,\n        IStrategy _strategy,\n        bytes memory _initStrategyData,\n        address _token,\n        uint256 _amount,\n        Metadata memory _metadata,\n        address[] memory _managers\n    ) internal returns (uint256 poolId) {\n        if (!registry.isOwnerOrMemberOfProfile(_profileId, msg.sender)) revert UNAUTHORIZED();\n\n        poolId = ++_poolIndex;\n\n        // Generate the manager & admin roles for the pool (this is the way we do this throughout the protocol for consistency)\n        bytes32 POOL_MANAGER_ROLE = bytes32(poolId);\n        bytes32 POOL_ADMIN_ROLE = keccak256(abi.encodePacked(poolId, \"admin\"));\n\n        // Create the Pool instance\n        Pool memory pool = Pool({\n            profileId: _profileId,\n            strategy: _strategy,\n            metadata: _metadata,\n            token: _token,\n            managerRole: POOL_MANAGER_ROLE,\n            adminRole: POOL_ADMIN_ROLE\n        });\n\n        // Add the pool to the mapping of created pools\n        pools[poolId] = pool;\n\n        // Grant admin roles to the pool creator\n        _grantRole(POOL_ADMIN_ROLE, msg.sender);\n\n        // Set admin role for POOL_MANAGER_ROLE\n        _setRoleAdmin(POOL_MANAGER_ROLE, POOL_ADMIN_ROLE);\n\n        // initialize strategies\n        // Initialization is expected to revert when invoked more than once with 'ALREADY_INITIALIZED()' error\n        _strategy.initialize(poolId, _initStrategyData);\n\n        if (_strategy.getPoolId() != poolId || address(_strategy.getAllo()) != address(this)) revert MISMATCH();\n\n        // grant pool managers roles\n        uint256 managersLength = _managers.length;\n        for (uint256 i; i < managersLength;) {\n            address manager = _managers[i];\n            if (manager == address(0)) revert ZERO_ADDRESS();\n\n            _grantRole(POOL_MANAGER_ROLE, manager);\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (baseFee > 0) {\n            // To prevent paying the baseFee from the Allo contract's balance\n            // If _token is NATIVE, then baseFee + _amount should be >= than msg.value.\n            // If _token is not NATIVE, then baseFee should be >= than msg.value.\n            if ((_token == NATIVE && (baseFee + _amount >= msg.value)) || (_token != NATIVE && baseFee >= msg.value)) {\n                revert NOT_ENOUGH_FUNDS();\n            }\n            _transferAmount(NATIVE, treasury, baseFee);\n            emit BaseFeePaid(poolId, baseFee);\n        }\n\n        if (_amount > 0) {\n            _fundPool(_amount, poolId, _strategy);\n        }\n\n        emit PoolCreated(poolId, _profileId, _strategy, _token, _amount, _metadata);\n    }\n\n    /// @notice Allocate to recipient(s).\n    /// @dev Passes '_data' & 'msg.sender' through to the strategy for that pool.\n    ///      This is an internal function that is called by the 'allocate()' & 'batchAllocate()' functions.\n    /// @param _poolId ID of the pool\n    /// @param _data Encoded data unique to the strategy for that pool\n    function _allocate(uint256 _poolId, bytes memory _data) internal {\n        pools[_poolId].strategy.allocate{value: msg.value}(_data, msg.sender);\n    }\n\n    /// @notice Fund a pool.\n    /// @dev Deducts the fee and transfers the amount to the distribution strategy.\n    ///      Emits a 'PoolFunded' event.\n    /// @param _amount The amount to transfer\n    /// @param _poolId The 'poolId' for the pool you are funding\n    /// @param _strategy The address of the strategy\n    function _fundPool(uint256 _amount, uint256 _poolId, IStrategy _strategy) internal {\n        uint256 feeAmount;\n        uint256 amountAfterFee = _amount;\n\n        Pool storage pool = pools[_poolId];\n        address _token = pool.token;\n\n        if (percentFee > 0) {\n            feeAmount = (_amount * percentFee) / getFeeDenominator();\n            amountAfterFee -= feeAmount;\n\n            _transferAmountFrom(_token, TransferData({from: msg.sender, to: treasury, amount: feeAmount}));\n        }\n\n        _transferAmountFrom(_token, TransferData({from: msg.sender, to: address(_strategy), amount: amountAfterFee}));\n        _strategy.increasePoolAmount(amountAfterFee);\n\n        emit PoolFunded(_poolId, amountAfterFee, feeAmount);\n    }\n\n    /// @notice Checks if the strategy is an approved cloneable strategy.\n    /// @dev Internal function used by createPoolwithCustomStrategy and createPool to\n    ///      determine if a strategy is in the cloneable strategy allow list.\n    /// @param _strategy The address of the strategy\n    /// @return This will return 'true' if the strategy is cloneable, otherwise 'false'\n    function _isCloneableStrategy(address _strategy) internal view returns (bool) {\n        return cloneableStrategies[_strategy];\n    }\n\n    /// @notice Checks if the address is a pool admin\n    /// @dev Internal function used to determine if an address is a pool admin\n    /// @param _poolId The ID of the pool\n    /// @param _address The address to check\n    /// @return This will return 'true' if the address is a pool admin, otherwise 'false'\n    function _isPoolAdmin(uint256 _poolId, address _address) internal view returns (bool) {\n        return hasRole(pools[_poolId].adminRole, _address);\n    }\n\n    /// @notice Checks if the address is a pool manager\n    /// @dev Internal function used to determine if an address is a pool manager\n    /// @param _poolId The ID of the pool\n    /// @param _address The address to check\n    /// @return This will return 'true' if the address is a pool manager, otherwise 'false'\n    function _isPoolManager(uint256 _poolId, address _address) internal view returns (bool) {\n        return hasRole(pools[_poolId].managerRole, _address) || _isPoolAdmin(_poolId, _address);\n    }\n\n    /// @notice Updates the registry address\n    /// @dev Internal function used to update the registry address.\n    ///      Emits a RegistryUpdated event.\n    /// @param _registry The new registry address\n    function _updateRegistry(address _registry) internal {\n        if (_registry == address(0)) revert ZERO_ADDRESS();\n\n        registry = IRegistry(_registry);\n        emit RegistryUpdated(_registry);\n    }\n\n    /// @notice Updates the treasury address\n    /// @dev Internal function used to update the treasury address.\n    ///      Emits a TreasuryUpdated event.\n    /// @param _treasury The new treasury address\n    function _updateTreasury(address payable _treasury) internal {\n        if (_treasury == address(0)) revert ZERO_ADDRESS();\n\n        treasury = _treasury;\n        emit TreasuryUpdated(treasury);\n    }\n\n    /// @notice Updates the fee percentage\n    /// @dev Internal function used to update the percentage fee.\n    ///      Emits a PercentFeeUpdated event.\n    /// @param _percentFee The new fee\n    function _updatePercentFee(uint256 _percentFee) internal {\n        if (_percentFee > 1e18) revert INVALID_FEE();\n\n        percentFee = _percentFee;\n\n        emit PercentFeeUpdated(percentFee);\n    }\n\n    /// @notice Updates the base fee\n    /// @dev Internal function used to update the base fee.\n    ///      Emits a BaseFeeUpdated event.\n    /// @param _baseFee The new base fee\n    function _updateBaseFee(uint256 _baseFee) internal {\n        baseFee = _baseFee;\n\n        emit BaseFeeUpdated(baseFee);\n    }\n\n    // =========================\n    // ==== View Functions =====\n    // =========================\n\n    /// @notice Getter for the fee denominator\n    /// @return FEE_DENOMINATOR The fee denominator is (1e18) which represents 100%\n    function getFeeDenominator() public pure returns (uint256 FEE_DENOMINATOR) {\n        return 1e18;\n    }\n\n    /// @notice Checks if the address is a pool admin.\n    /// @param _poolId The ID of the pool\n    /// @param _address The address to check\n    /// @return 'true' if the address is a pool admin, otherwise 'false'\n    function isPoolAdmin(uint256 _poolId, address _address) external view returns (bool) {\n        return _isPoolAdmin(_poolId, _address);\n    }\n\n    /// @notice Checks if the address is a pool manager\n    /// @param _poolId The ID of the pool\n    /// @param _address The address to check\n    /// @return 'true' if the address is a pool manager, otherwise 'false'\n    function isPoolManager(uint256 _poolId, address _address) external view returns (bool) {\n        return _isPoolManager(_poolId, _address);\n    }\n\n    /// @notice Getter for the strategy.\n    /// @param _poolId The ID of the pool\n    /// @return The address of the strategy\n    function getStrategy(uint256 _poolId) external view returns (address) {\n        return address(pools[_poolId].strategy);\n    }\n\n    /// @notice Getter for fee percentage.\n    /// @return The fee percentage (1e18 = 100%)\n    function getPercentFee() external view returns (uint256) {\n        return percentFee;\n    }\n\n    /// @notice Getter for base fee.\n    /// @return The base fee\n    function getBaseFee() external view returns (uint256) {\n        return baseFee;\n    }\n\n    /// @notice Getter for treasury address.\n    /// @return The treasury address\n    function getTreasury() external view returns (address payable) {\n        return treasury;\n    }\n\n    /// @notice Getter for registry.\n    /// @return The registry address\n    function getRegistry() external view returns (IRegistry) {\n        return registry;\n    }\n\n    /// @notice Getter for if strategy is cloneable.\n    /// @param _strategy The address of the strategy\n    /// @return 'true' if the strategy is cloneable, otherwise 'false'\n    function isCloneableStrategy(address _strategy) external view returns (bool) {\n        return _isCloneableStrategy(_strategy);\n    }\n\n    /// @notice Getter for the 'Pool'.\n    /// @param _poolId The ID of the pool\n    /// @return The 'Pool' struct\n    function getPool(uint256 _poolId) external view returns (Pool memory) {\n        return pools[_poolId];\n    }\n}"
    },
    {
      "filename": "allo-v2/contracts/core/Allo.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport \"solady/src/auth/Ownable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts/contracts/access/AccessControl.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n// Interfaces\nimport \"./interfaces/IAllo.sol\";\n\n// Internal Libraries\nimport {Clone} from \"./libraries/Clone.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\nimport \"./libraries/Native.sol\";\nimport {Transfer} from \"./libraries/Transfer.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Allo\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice This contract is used to create & manage pools as well as manage the protocol.\n/// @dev The contract must be initialized with the 'initialize()' function.\ncontract Allo is IAllo, Native, Transfer, Initializable, Ownable, AccessControl, ReentrancyGuardUpgradeable, Errors {\n    // ====="
    }
  ]
}