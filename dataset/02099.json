{
  "Title": "M-14: Single-sided deposits that are auto-adjusted may have their collateral value cut in half",
  "Content": "# Issue M-14: Single-sided deposits that are auto-adjusted may have their collateral value cut in half \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/164 \n\n## Found by \nIllIllI, joestakey, koxuan, rvierdiiev\n\n## Summary\n\nDeposits of only the long collateral token, when doing so results in an auto-adjustment of the order to minimize price impact, creating a larger adjusted short amount, does not properly track the new adjusted long amount.\n\n\n## Vulnerability Detail\n\nWhen such an adjustment is maid, the adjusted long amount is never updated, so it remains at the uninitialized value of zero.\n\n## Impact\n\nThe long portion of the collateral will be zero. If the user submitted the order without specifying a minimum number of market tokens to receive, the amount they receive may be half of what it should have been. If they provide sane slippage amounts, the transaction will revert, and the feature will essentially be broken.\n\n\n## Code Snippet\n\nRather than storing the result of the subtraction to the `adjustedLongTokenAmount` variable, the difference is subtracted from it, and the result is not stored:\n```solidity\n// File: gmx-synthetics/contracts/deposit/ExecuteDepositUtils.sol : ExecuteDepositUtils.getAdjustedLongAndShortTokenAmounts()   #1\n\n389 @>         uint256 adjustedLongTokenAmount;\n390            uint256 adjustedShortTokenAmount;\n...\n402                uint256 diff = poolShortTokenAmount - poolLongTokenAmount;\n403    \n404                if (diff < poolShortTokenAmount) {\n405                    adjustedShortTokenAmount = diff + (longTokenAmount - diff) / 2;\n406 @>                 adjustedLongTokenAmount - longTokenAmount - adjustedShortTokenAmount;\n407                } else {\n408                    adjustedLongTokenAmount = 0;\n409                    adjustedShortTokenAmount = longTokenAmount;\n410                }\n411            }\n412    \n413            return (adjustedLongTokenAmount, adjustedShortTokenAmount);\n414:       }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/deposit/ExecuteDepositUtils.sol#L389-L414\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n```diff\ndiff --git a/gmx-synthetics/contracts/deposit/ExecuteDepositUtils.sol b/gmx-synthetics/contracts/deposit/ExecuteDepositUtils.sol\nindex 03467e4..1a96f47 100644\n--- a/gmx-synthetics/contracts/deposit/ExecuteDepositUtils.sol\n+++ b/gmx-synthetics/contracts/deposit/ExecuteDepositUtils.sol\n@@ -403,7 +403,7 @@ library ExecuteDepositUtils {\n \n             if (diff < poolShortTokenAmount) {\n                 adjustedShortTokenAmount = diff + (longTokenAmount - diff) / 2;\n-                adjustedLongTokenAmount - longTokenAmount - adjustedShortTokenAmount;\n+                adjustedLongTokenAmount = longTokenAmount - adjustedShortTokenAmount;\n             } else {\n                 adjustedLongTokenAmount = 0;\n                 adjustedShortTokenAmount = longTokenAmount;\n```\n\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/commit/d4066840f925c43116eed3c2c83ae2e44be39eed\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/deposit/ExecuteDepositUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../adl/AdlUtils.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"./DepositVault.sol\";\nimport \"./DepositStoreUtils.sol\";\nimport \"./DepositEventUtils.sol\";\n\nimport \"../pricing/SwapPricingUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleUtils.sol\";\n\nimport \"../gas/GasUtils.sol\";\nimport \"../callback/CallbackUtils.sol\";\n\nimport \"../utils/Array.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\n// @title DepositUtils\n// @dev Library for deposit functions, to help with the depositing of liquidity\n// into a market in return for market tokens\nlibrary ExecuteDepositUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Array for uint256[];\n\n    using Price for Price.Props;\n    using Deposit for Deposit.Props;\n\n    // @dev ExecuteDepositParams struct used in executeDeposit to avoid stack\n    // too deep errors\n    //\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param oracle Oracle\n    // @param key the key of the deposit to execute\n    // @param oracleBlockNumbers the oracle block numbers for the prices in oracle\n    // @param keeper the address of the keeper executing the deposit\n    // @param startingGas the starting amount of gas\n    struct ExecuteDepositParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        DepositVault depositVault;\n        Oracle oracle;\n        bytes32 key;\n        uint256[] minOracleBlockNumbers;\n        uint256[] maxOracleBlockNumbers;\n        address keeper;\n        uint256 startingGas;\n    }\n\n    // @dev _ExecuteDepositParams struct used in executeDeposit to avoid stack\n    // too deep errors\n    //\n    // @param market the market to deposit into\n    // @param account the depositing account\n    // @param receiver the account to send the market tokens to\n    // @param tokenIn the token to deposit, either the market.longToken or\n    // market.shortToken\n    // @param tokenOut the other token, if tokenIn is market.longToken then\n    // tokenOut is market.shortToken and vice versa\n    // @param tokenInPrice price of tokenIn\n    // @param tokenOutPrice price of tokenOut\n    // @param amount amount of tokenIn\n    // @param priceImpactUsd price impact in USD\n    struct _ExecuteDepositParams {\n        Market.Props market;\n        address account;\n        address receiver;\n        address tokenIn;\n        address tokenOut;\n        Price.Props tokenInPrice;\n        Price.Props tokenOutPrice;\n        uint256 amount;\n        int256 priceImpactUsd;\n    }\n\n    struct ExecuteDepositCache {\n        uint256 longTokenAmount;\n        uint256 shortTokenAmount;\n        uint256 longTokenUsd;\n        uint256 shortTokenUsd;\n        uint256 receivedMarketTokens;\n        int256 priceImpactUsd;\n    }\n\n    error EmptyDeposit();\n    error MinMarketTokens(uint256 received, uint256 expected);\n    error EmptyDepositAmountsAfterSwap();\n    error UnexpectedNonZeroShortAmount();\n    error InvalidPoolValueForDeposit(int256 poolValue);\n    error InvalidSwapOutputToken(address outputToken, address expectedOutputToken);\n\n    // @dev executes a deposit\n    // @param params ExecuteDepositParams\n    function executeDeposit(ExecuteDepositParams memory params) external {\n        Deposit.Props memory deposit = DepositStoreUtils.get(params.dataStore, params.key);\n        ExecuteDepositCache memory cache;\n\n        if (deposit.account() == address(0)) {\n            revert EmptyDeposit();\n        }\n\n        OracleUtils.validateBlockNumberWithinRange(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            deposit.updatedAtBlock()\n        );\n\n        Market.Props memory market = MarketUtils.getEnabledMarket(params.dataStore, deposit.market());\n\n        MarketUtils.MarketPrices memory prices = MarketUtils.getMarketPrices(params.oracle, market);\n\n        // deposits should improve the pool state but it should be checked if\n        // the max pnl factor for deposits is exceeded as this would lead to the\n        // price of the market token decreasing below the allowed amount\n        MarketUtils.validateMaxPnl(\n            params.dataStore,\n            market,\n            prices,\n            Keys.MAX_PNL_FACTOR_FOR_DEPOSITS\n        );\n\n        cache.longTokenAmount = swap(\n            params,\n            deposit.longTokenSwapPath(),\n            deposit.initialLongToken(),\n            deposit.initialLongTokenAmount(),\n            market.marketToken,\n            market.longToken\n        );\n\n        cache.shortTokenAmount = swap(\n            params,\n            deposit.shortTokenSwapPath(),\n            deposit.initialShortToken(),\n            deposit.initialShortTokenAmount(),\n            market.marketToken,\n            market.shortToken\n        );\n\n        if (cache.longTokenAmount == 0 && cache.shortTokenAmount == 0) {\n            revert EmptyDepositAmountsAfterSwap();\n        }\n\n        // if the market.longToken and market.shortToken are the same, there are two cases to consider:\n        // 1. the user is depositing the market.longToken directly\n        // 2. the user is depositing an initialLongToken and swapping it to the market.longToken\n        // for both cases, we expect the cache.shortTokenAmount to be zero, because it is unlikely that\n        // the user provides different initialLongTokens and initialShortTokens to be swapped to the same\n        // token, so that flow is not supported\n        // for the first case, the deposited token will be recorded in initialLongTokenAmount, it is not possible\n        // to have an initialShortTokenAmount because recordTransferIn records a single difference in balance of the token\n        // after all transfers\n        // for both cases, split the longTokenAmount into longTokenAmount and shortTokenAmount to minimize\n        // price impact for the user\n        if (market.longToken == market.shortToken) {\n            if (cache.shortTokenAmount > 0) {\n                revert UnexpectedNonZeroShortAmount();\n            }\n\n            (cache.longTokenAmount, cache.shortTokenAmount) = getAdjustedLongAndShortTokenAmounts(\n                params.dataStore,\n                market,\n                cache.longTokenAmount\n            );\n        }\n\n        cache.longTokenUsd = cache.longTokenAmount * prices.longTokenPrice.midPrice();\n        cache.shortTokenUsd = cache.shortTokenAmount * prices.shortTokenPrice.midPrice();\n\n        cache.receivedMarketTokens;\n\n        cache.priceImpactUsd = SwapPricingUtils.getPriceImpactUsd(\n            SwapPricingUtils.GetPriceImpactUsdParams(\n                params.dataStore,\n                market.marketToken,\n                market.longToken,\n                market.shortToken,\n                prices.longTokenPrice.midPrice(),\n                prices.shortTokenPrice.midPrice(),\n                (cache.longTokenAmount * prices.longTokenPrice.midPrice()).toInt256(),\n                (cache.shortTokenAmount * prices.shortTokenPrice.midPrice()).toInt256()\n            )\n        );\n\n        if (cache.longTokenAmount > 0) {\n            _ExecuteDepositParams memory _params = _ExecuteDepositParams(\n                market,\n                deposit.account(),\n                deposit.receiver(),\n                market.longToken,\n                market.shortToken,\n                prices.longTokenPrice,\n                prices.shortTokenPrice,\n                cache.longTokenAmount,\n                cache.priceImpactUsd * cache.longTokenUsd.toInt256() / (cache.longTokenUsd + cache.shortTokenUsd).toInt256()\n            );\n\n            cache.receivedMarketTokens += _executeDeposit(params, _params);\n        }\n\n        if (cache.shortTokenAmount > 0) {\n            _ExecuteDepositParams memory _params = _ExecuteDepositParams(\n                market,\n                deposit.account(),\n                deposit.receiver(),\n                market.shortToken,\n                market.longToken,\n                prices.shortTokenPrice,\n                prices.longTokenPrice,\n                cache.shortTokenAmount,\n                cache.priceImpactUsd * cache.shortTokenUsd.toInt256() / (cache.longTokenUsd + cache.shortTokenUsd).toInt256()\n            );\n\n            cache.receivedMarketTokens += _executeDeposit(params, _params);\n        }\n\n        if (cache.receivedMarketTokens < deposit.minMarketTokens()) {\n            revert MinMarketTokens(cache.receivedMarketTokens, deposit.minMarketTokens());\n        }\n\n        DepositStoreUtils.remove(params.dataStore, params.key, deposit.account());\n\n        DepositEventUtils.emitDepositExecuted(\n            params.eventEmitter,\n            params.key,\n            cache.longTokenAmount,\n            cache.shortTokenAmount,\n            cache.receivedMarketTokens\n        );\n\n        CallbackUtils.afterDepositExecution(params.key, deposit);\n\n        GasUtils.payExecutionFee(\n            params.dataStore,\n            params.depositVault,\n            deposit.executionFee(),\n            params.startingGas,\n            params.keeper,\n            deposit.account()\n        );\n    }\n\n    // @dev executes a deposit\n    // @param params ExecuteDepositParams\n    // @param _params _ExecuteDepositParams\n    function _executeDeposit(ExecuteDepositParams memory params, _ExecuteDepositParams memory _params) internal returns (uint256) {\n        SwapPricingUtils.SwapFees memory fees = SwapPricingUtils.getSwapFees(\n            params.dataStore,\n            _params.market.marketToken,\n            _params.amount\n        );\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            fees.feeReceiverAmount,\n            Keys.DEPOSIT_FEE\n        );\n\n        SwapPricingUtils.emitSwapFeesCollected(\n            params.eventEmitter,\n             _params.market.marketToken,\n             _params.tokenIn,\n             \"deposit\",\n             fees\n         );\n\n        uint256 mintAmount;\n\n        int256 _poolValue = MarketUtils.getPoolValue(\n            params.dataStore,\n            _params.market,\n            _params.tokenIn == _params.market.longToken ? _params.tokenInPrice : _params.tokenOutPrice,\n            _params.tokenIn == _params.market.shortToken ? _params.tokenInPrice : _params.tokenOutPrice,\n            params.oracle.getPrimaryPrice(_params.market.indexToken),\n            Keys.MAX_PNL_FACTOR_FOR_DEPOSITS,\n            true\n        );\n\n        if (_poolValue < 0) {\n            revert InvalidPoolValueForDeposit(_poolValue);\n        }\n\n        uint256 poolValue = _poolValue.toUint256();\n\n        uint256 supply = MarketUtils.getMarketTokenSupply(MarketToken(payable(_params.market.marketToken)));\n\n        if (_params.priceImpactUsd > 0) {\n            // when there is a positive price impact factor,\n            // tokens from the swap impact pool are used to mint additional market tokens for the user\n            // for example, if 50,000 USDC is deposited and there is a positive price impact\n            // an additional 0.005 ETH may be used to mint market tokens\n            // the swap impact pool is decreased by the used amount\n            //\n            // priceImpactUsd is calculated based on pricing assuming only depositAmount of tokenIn\n            // was added to the pool\n            // since impactAmount of tokenOut is added to the pool here, the calculation of\n            // the tokenInPrice would not be entirely accurate\n            int256 positiveImpactAmount = MarketUtils.applySwapImpactWithCap(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                _params.tokenOut,\n                _params.tokenOutPrice,\n                _params.priceImpactUsd\n            );\n\n            // calculate the usd amount using positiveImpactAmount since it may\n            // be capped by the max available amount in the impact pool\n            mintAmount += MarketUtils.usdToMarketTokenAmount(\n                positiveImpactAmount.toUint256() * _params.tokenOutPrice.min,\n                poolValue,\n                supply\n            );\n\n            // deposit the token out, that was withdrawn from the impact pool, to mint market tokens\n            MarketUtils.applyDeltaToPoolAmount(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                _params.tokenOut,\n                positiveImpactAmount\n            );\n        } else {\n            // when there is a negative price impact factor,\n            // less of the deposit amount is used to mint market tokens\n            // for example, if 10 ETH is deposited and there is a negative price impact\n            // only 9.995 ETH may be used to mint market tokens\n            // the remaining 0.005 ETH will be stored in the swap impact pool\n            int256 negativeImpactAmount = MarketUtils.applySwapImpactWithCap(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                _params.tokenIn,\n                _params.tokenInPrice,\n                _params.priceImpactUsd\n            );\n            fees.amountAfterFees -= (-negativeImpactAmount).toUint256();\n        }\n\n        mintAmount += MarketUtils.usdToMarketTokenAmount(\n            fees.amountAfterFees * _params.tokenInPrice.min,\n            poolValue,\n            supply\n        );\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            (fees.amountAfterFees + fees.feeAmountForPool).toInt256()\n        );\n\n        MarketUtils.validatePoolAmount(\n            params.dataStore,\n            _params.market.marketToken,\n            _params.tokenIn\n        );\n\n        MarketToken(payable(_params.market.marketToken)).mint(_params.receiver, mintAmount);\n\n        return mintAmount;\n    }\n\n    // @dev this should only be called if the long and short tokens are the same\n    // calculate the long and short amounts that would lead to the smallest amount\n    // of price impact by helping to balance the pool\n    // @param dataStore DataStore\n    // @param market the market for the deposit\n    // @param longTokenAmount the long token amount\n    function getAdjustedLongAndShortTokenAmounts(\n        DataStore dataStore,\n        Market.Props memory market,\n        uint256 longTokenAmount\n    ) internal view returns (uint256, uint256) {\n        uint256 poolLongTokenAmount = MarketUtils.getPoolAmount(dataStore, market.marketToken, market.longToken);\n        uint256 poolShortTokenAmount = MarketUtils.getPoolAmount(dataStore, market.marketToken, market.shortToken);\n\n        uint256 adjustedLongTokenAmount;\n        uint256 adjustedShortTokenAmount;\n\n        if (poolLongTokenAmount < poolShortTokenAmount) {\n            uint256 diff = poolLongTokenAmount - poolShortTokenAmount;\n\n            if (diff < poolLongTokenAmount) {\n                adjustedLongTokenAmount = diff + (longTokenAmount - diff) / 2;\n                adjustedShortTokenAmount = longTokenAmount - adjustedLongTokenAmount;\n            } else {\n                adjustedLongTokenAmount = longTokenAmount;\n            }\n        } else {\n            uint256 diff = poolShortTokenAmount - poolLongTokenAmount;\n\n            if (diff < poolShortTokenAmount) {\n                adjustedShortTokenAmount = diff + (longTokenAmount - diff) / 2;\n                adjustedLongTokenAmount - longTokenAmount - adjustedShortTokenAmount;\n            } else {\n                adjustedLongTokenAmount = 0;\n                adjustedShortTokenAmount = longTokenAmount;\n            }\n        }\n\n        return (adjustedLongTokenAmount, adjustedShortTokenAmount);\n    }\n\n    function swap(\n        ExecuteDepositParams memory params,\n        address[] memory swapPath,\n        address initialToken,\n        uint256 inputAmount,\n        address market,\n        address expectedOutputToken\n    ) internal returns (uint256) {\n        Market.Props[] memory swapPathMarkets = MarketUtils.getEnabledMarkets(\n            params.dataStore,\n            swapPath\n        );\n\n        (address outputToken, uint256 outputAmount) = SwapUtils.swap(\n            SwapUtils.SwapParams(\n                params.dataStore, // dataStore\n                params.eventEmitter, // eventEmitter\n                params.oracle, // oracle\n                params.depositVault, // bank\n                initialToken, // tokenIn\n                inputAmount, // amountIn\n                swapPathMarkets, // swapPathMarkets\n                0, // minOutputAmount\n                market, // receiver\n                false // shouldUnwrapNativeToken\n            )\n        );\n\n        if (outputToken != expectedOutputToken) {\n            revert InvalidSwapOutputToken(outputToken, expectedOutputToken);\n        }\n\n        return outputAmount;\n    }\n}"
    }
  ]
}