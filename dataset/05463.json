{
  "Title": "[G-05] Use assembly to reuse memory space when making more than one external call",
  "Content": "\n**Issue Description** - When making external calls, the solidity compiler has to encode the function signature and arguments in memory. It does not\nclear or reuse memory, so it expands memory each time.\n\n**Proposed Optimization** - Use inline assembly to reuse the same memory space for multiple external calls. Store the function selector and arguments\nwithout expanding memory further.\n\n**Estimated Gas Savings** - Reusing memory can save thousands of gas compared to expanding on each call. The baseline memory expansion per call is 3,000\ngas. With larger arguments or return data, the savings would be even greater.\n\n```solidity\nSee the example below;\n\ncontract Called {\n    function add(uint256 a, uint256 b) external pure returns(uint256) {\n        return a + b;\n    }\n}\n\n\ncontract Solidity {\n    // cost: 7262\n    function call(address calledAddress) external pure returns(uint256) {\n        Called called = Called(calledAddress);\n        uint256 res1 = called.add(1, 2);\n        uint256 res2 = called.add(3, 4);\n\n        uint256 res = res1 + res2;\n        return res;\n    }\n}\n\n\ncontract Assembly {\n    // cost: 5281\n    function call(address calledAddress) external view returns(uint256) {\n        assembly {\n            // check that calledAddress has code deployed to it\n            if iszero(extcodesize(calledAddress)) {\n                revert(0x00, 0x00)\n            }\n\n            // first call\n            mstore(0x00, hex\"771602f7\")\n            mstore(0x04, 0x01)\n            mstore(0x24, 0x02)\n            let success := staticcall(gas(), calledAddress, 0x00, 0x44, 0x60, 0x20)\n            if iszero(success) {\n                revert(0x00, 0x00)\n            }\n            let res1 := mload(0x60)\n\n            // second call\n            mstore(0x04, 0x03)\n            mstore(0x24, 0x4)\n            success := staticcall(gas(), calledAddress, 0x00, 0x44, 0x60, 0x20)\n            if iszero(success) {\n                revert(0x00, 0x00)\n            }\n            let res2 := mload(0x60)\n\n            // add results\n            let res := add(res1, res2)\n\n            // return data\n            mstore(0x60, res)\n            return(0x60, 0x20)\n        }\n    }\n}\n```\n\nWe save approximately 2,000 gas by using the scratch space to store the function selector and its arguments and also reusing the same memory space for the second call while storing the returned data in the zero slot thus not expanding memory.\n\nIf the arguments of the external function you wish to call is above 64 bytes and if you are making one external call, it wouldnâ€™t save any significant gas writing it in assembly. However, if making more than one call. You can still save gas by reusing the same memory slot for the 2 calls using inline assembly.\n\n*Note: Always remember to update the free memory pointer if the offset it points to is already used, to avoid solidity overriding the data stored there or using the value stored there in an unexpected way.*\n\nAlso note to avoid overwriting the zero slot (`0x60` memory offset) if you have undefined dynamic memory values within that call stack. An alternative is to explicitly define dynamic memory values or if used, to set the slot back to `0x00` before exiting the assembly block.\n\n**Code Snippets:**\n\n```solidity\nFile: src/adapters/Curve2PoolAdapter.sol\n\n78        address xTokenAddress = ICurve2Pool(primitive).coins(0);\n81        decimals[xToken] = IERC20Metadata(xTokenAddress).decimals();\n84        address yTokenAddress = ICurve2Pool(primitive).coins(1);\n88        decimals[yToken] = IERC20Metadata(yTokenAddress).decimals();\n93        decimals[lpTokenId] = IERC20Metadata(primitive_).decimals();\n\n\n\n164                ICurve2Pool(primitive).exchange(indexOfInputAmount, indexOfOutputAmount, rawInputAmount, 0);\n168            rawOutputAmount = ICurve2Pool(primitive).add_liquidity(inputAmounts, 0);\n170            rawOutputAmount = ICurve2Pool(primitive).remove_liquidity_one_coin(rawInputAmount, indexOfOutputAmount, 0);\n\n\n\n190        IERC20Metadata(tokenAddress).approve(ocean, type(uint256).max);\n191        IERC20Metadata(tokenAddress).approve(primitive, type(uint256).max);\n```\n\nhttps://github.com/code-423n4/2023-11-shellprotocol/blob/main/src/adapters/Curve2PoolAdapter.sol#L78\n\n```solidity\nFile: src/adapters/CurveTricryptoAdapter.sol\n\n86        address xTokenAddress = ICurveTricrypto(primitive).coins(0);\n89        decimals[xToken] = IERC20Metadata(xTokenAddress).decimals();\n92        address yTokenAddress = ICurveTricrypto(primitive).coins(1);\n96        decimals[yToken] = IERC20Metadata(yTokenAddress).decimals();\n99        address wethAddress = ICurveTricrypto(primitive).coins(2);\n106        address lpTokenAddress = ICurveTricrypto(primitive).token();\n109        decimals[lpTokenId] = IERC20Metadata(lpTokenAddress).decimals();\n\n\n\n129            IOceanInteractions(ocean).doInteraction{ value: amount }(interaction);\n138            IOceanInteractions(ocean).doInteraction(interaction);\n\n\n201            ICurveTricrypto(primitive).exchange{ value: inputToken == zToken ? rawInputAmount : 0 }(\n208            if (inputToken == zToken) IWETH(underlying[zToken]).deposit{ value: rawInputAmount }();\n210            ICurveTricrypto(primitive).add_liquidity(inputAmounts, 0);\n213                uint256 wethBalance = IERC20Metadata(underlying[zToken]).balanceOf(address(this));\n214                ICurveTricrypto(primitive).remove_liquidity_one_coin(rawInputAmount, indexOfOutputAmount, 0);\n215                IWETH(underlying[zToken]).withdraw(\n216                    IERC20Metadata(underlying[zToken]).balanceOf(address(this)) - wethBalance\n219                ICurveTricrypto(primitive).remove_liquidity_one_coin(rawInputAmount, indexOfOutputAmount, 0);\n\n\n242       IERC20Metadata(tokenAddress).approve(ocean, type(uint256).max);\n243        IERC20Metadata(tokenAddress).approve(primitive, type(uint256).max);\n```\n\nhttps://github.com/code-423n4/2023-11-shellprotocol/blob/main/src/adapters/CurveTricryptoAdapter.sol#L86\n\nThis report discusses how using inline assembly can optimize gas costs when making multiple external calls by reusing memory space, rather than expanding memory separately for each call. This can save thousands of gas compared to the\nsolidity compiler's default behavior.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-11-shellprotocol",
  "Code": [
    {
      "filename": "src/adapters/Curve2PoolAdapter.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Cowri Labs Inc.\n\npragma solidity 0.8.20;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./ICurve2Pool.sol\";\nimport \"./OceanAdapter.sol\";\n\nenum ComputeType {\n    Deposit,\n    Swap,\n    Withdraw\n}\n\n/**\n * @notice\n *   curve2pool adapter contract enabling swapping, adding liquidity & removing liquidity for the curve usdc-usdt pool\n */\ncontract Curve2PoolAdapter is OceanAdapter {\n    /////////////////////////////////////////////////////////////////////\n    //                             Errors                              //\n    /////////////////////////////////////////////////////////////////////\n    error INVALID_COMPUTE_TYPE();\n    error SLIPPAGE_LIMIT_EXCEEDED();\n\n    /////////////////////////////////////////////////////////////////////\n    //                             Events                              //\n    /////////////////////////////////////////////////////////////////////\n    event Swap(\n        uint256 inputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 slippageProtection,\n        address user,\n        bool computeOutput\n    );\n    event Deposit(\n        uint256 inputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 slippageProtection,\n        address user,\n        bool computeOutput\n    );\n    event Withdraw(\n        uint256 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 slippageProtection,\n        address user,\n        bool computeOutput\n    );\n\n    /// @notice x token Ocean ID.\n    uint256 public immutable xToken;\n\n    /// @notice y token Ocean ID.\n    uint256 public immutable yToken;\n\n    /// @notice lp token Ocean ID.\n    uint256 public immutable lpTokenId;\n\n    /// @notice map token Ocean IDs to corresponding Curve pool indices\n    mapping(uint256 => int128) indexOf;\n\n    /// @notice The underlying token decimals wrt to the Ocean ID\n    mapping(uint256 => uint8) decimals;\n\n    //*********************************************************************//\n    // ---------------------------- constructor -------------------------- //\n    //*********************************************************************//\n\n    /**\n     * @notice only initializing the immutables, mappings & approves tokens\n     */\n    constructor(address ocean_, address primitive_) OceanAdapter(ocean_, primitive_) {\n        address xTokenAddress = ICurve2Pool(primitive).coins(0);\n        xToken = _calculateOceanId(xTokenAddress, 0);\n        underlying[xToken] = xTokenAddress;\n        decimals[xToken] = IERC20Metadata(xTokenAddress).decimals();\n        _approveToken(xTokenAddress);\n\n        address yTokenAddress = ICurve2Pool(primitive).coins(1);\n        yToken = _calculateOceanId(yTokenAddress, 0);\n        indexOf[yToken] = int128(1);\n        underlying[yToken] = yTokenAddress;\n        decimals[yToken] = IERC20Metadata(yTokenAddress).decimals();\n        _approveToken(yTokenAddress);\n\n        lpTokenId = _calculateOceanId(primitive_, 0);\n        underlying[lpTokenId] = primitive_;\n        decimals[lpTokenId] = IERC20Metadata(primitive_).decimals();\n        _approveToken(primitive_);\n    }\n\n    /**\n     * @dev wraps the underlying token into the Ocean\n     * @param tokenId Ocean ID of token to wrap\n     * @param amount wrap amount\n     */\n    function wrapToken(uint256 tokenId, uint256 amount) internal override {\n        address tokenAddress = underlying[tokenId];\n\n        Interaction memory interaction = Interaction({\n            interactionTypeAndAddress: _fetchInteractionId(tokenAddress, uint256(InteractionType.WrapErc20)),\n            inputToken: 0,\n            outputToken: 0,\n            specifiedAmount: amount,\n            metadata: bytes32(0)\n        });\n\n        IOceanInteractions(ocean).doInteraction(interaction);\n    }\n\n    /**\n     * @dev unwraps the underlying token from the Ocean\n     * @param tokenId Ocean ID of token to unwrap\n     * @param amount unwrap amount\n     */\n    function unwrapToken(uint256 tokenId, uint256 amount) internal override {\n        address tokenAddress = underlying[tokenId];\n\n        Interaction memory interaction = Interaction({\n            interactionTypeAndAddress: _fetchInteractionId(tokenAddress, uint256(InteractionType.UnwrapErc20)),\n            inputToken: 0,\n            outputToken: 0,\n            specifiedAmount: amount,\n            metadata: bytes32(0)\n        });\n\n        IOceanInteractions(ocean).doInteraction(interaction);\n    }\n\n    /**\n     * @dev swaps/add liquidity/remove liquidity from Curve 2pool\n     * @param inputToken The user is giving this token to the pool\n     * @param outputToken The pool is giving this token to the user\n     * @param inputAmount The amount of the inputToken the user is giving to the pool\n     * @param minimumOutputAmount The minimum amount of tokens expected back after the exchange\n     */\n    function primitiveOutputAmount(\n        uint256 inputToken,\n        uint256 outputToken,\n        uint256 inputAmount,\n        bytes32 minimumOutputAmount\n    )\n        internal\n        override\n        returns (uint256 outputAmount)\n    {\n        uint256 rawInputAmount = _convertDecimals(NORMALIZED_DECIMALS, decimals[inputToken], inputAmount);\n\n        ComputeType action = _determineComputeType(inputToken, outputToken);\n\n        uint256 rawOutputAmount;\n\n        // avoid multiple SLOADS\n        int128 indexOfInputAmount = indexOf[inputToken];\n        int128 indexOfOutputAmount = indexOf[outputToken];\n\n        if (action == ComputeType.Swap) {\n            rawOutputAmount =\n                ICurve2Pool(primitive).exchange(indexOfInputAmount, indexOfOutputAmount, rawInputAmount, 0);\n        } else if (action == ComputeType.Deposit) {\n            uint256[2] memory inputAmounts;\n            inputAmounts[uint256(int256(indexOfInputAmount))] = rawInputAmount;\n            rawOutputAmount = ICurve2Pool(primitive).add_liquidity(inputAmounts, 0);\n        } else {\n            rawOutputAmount = ICurve2Pool(primitive).remove_liquidity_one_coin(rawInputAmount, indexOfOutputAmount, 0);\n        }\n\n        outputAmount = _convertDecimals(decimals[outputToken], NORMALIZED_DECIMALS, rawOutputAmount);\n\n        if (uint256(minimumOutputAmount) > outputAmount) revert SLIPPAGE_LIMIT_EXCEEDED();\n\n        if (action == ComputeType.Swap) {\n            emit Swap(inputToken, inputAmount, outputAmount, minimumOutputAmount, primitive, true);\n        } else if (action == ComputeType.Deposit) {\n            emit Deposit(inputToken, inputAmount, outputAmount, minimumOutputAmount, primitive, true);\n        } else {\n            emit Withdraw(outputToken, inputAmount, outputAmount, minimumOutputAmount, primitive, true);\n        }\n    }\n\n    /**\n     * @dev Approves token to be spent by the Ocean and the Curve pool\n     */\n    function _approveToken(address tokenAddress) private {\n        IERC20Metadata(tokenAddress).approve(ocean, type(uint256).max);\n        IERC20Metadata(tokenAddress).approve(primitive, type(uint256).max);\n    }\n\n    /**\n     * @dev Uses the inputToken and outputToken to determine the ComputeType\n     *  (input: xToken, output: yToken) | (input: yToken, output: xToken) => SWAP\n     *  base := xToken | yToken\n     *  (input: base, output: lpToken) => DEPOSIT\n     *  (input: lpToken, output: base) => WITHDRAW\n     */\n    function _determineComputeType(\n        uint256 inputToken,\n        uint256 outputToken\n    )\n        private\n        view\n        returns (ComputeType computeType)\n    {\n        if (((inputToken == xToken) && (outputToken == yToken)) || ((inputToken == yToken) && (outputToken == xToken)))\n        {\n            return ComputeType.Swap;\n        } else if (((inputToken == xToken) || (inputToken == yToken)) && (outputToken == lpTokenId)) {\n            return ComputeType.Deposit;\n        } else if ((inputToken == lpTokenId) && ((outputToken == xToken) || (outputToken == yToken))) {\n            return ComputeType.Withdraw;\n        } else {\n            revert INVALID_COMPUTE_TYPE();\n        }\n    }\n}"
    },
    {
      "filename": "src/adapters/CurveTricryptoAdapter.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Cowri Labs Inc.\n\npragma solidity 0.8.20;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./ICurveTricrypto.sol\";\nimport \"./OceanAdapter.sol\";\n\ninterface IWETH {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external payable;\n}\n\nenum ComputeType {\n    Deposit,\n    Swap,\n    Withdraw\n}\n\n/**\n * @notice\n *   curve tricrypto adapter contract enabling swapping, adding liquidity & removing liquidity for the curve usdt-wbtc-eth pool\n */\ncontract CurveTricryptoAdapter is OceanAdapter {\n    /////////////////////////////////////////////////////////////////////\n    //                             Errors                              //\n    /////////////////////////////////////////////////////////////////////\n    error INVALID_COMPUTE_TYPE();\n    error SLIPPAGE_LIMIT_EXCEEDED();\n\n    /////////////////////////////////////////////////////////////////////\n    //                             Events                              //\n    /////////////////////////////////////////////////////////////////////\n    event Swap(\n        uint256 inputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 slippageProtection,\n        address user,\n        bool computeOutput\n    );\n    event Deposit(\n        uint256 inputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 slippageProtection,\n        address user,\n        bool computeOutput\n    );\n    event Withdraw(\n        uint256 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 slippageProtection,\n        address user,\n        bool computeOutput\n    );\n\n    /// @notice x token Ocean ID\n    uint256 public immutable xToken;\n\n    /// @notice y token Ocean ID\n    uint256 public immutable yToken;\n\n    /// @notice z token Ocean ID\n    uint256 public immutable zToken;\n\n    /// @notice lp token Ocean ID\n    uint256 public immutable lpTokenId;\n\n    /// @notice map token Ocean IDs to corresponding Curve pool indices\n    mapping(uint256 => uint256) indexOf;\n\n    /// @notice The underlying token decimals wrt to the Ocean ID\n    mapping(uint256 => uint8) decimals;\n\n    //*********************************************************************//\n    // ---------------------------- constructor -------------------------- //\n    //*********************************************************************//\n\n    /**\n     * @notice only initializing the immutables, mappings & approves tokens\n     */\n    constructor(address ocean_, address primitive_) OceanAdapter(ocean_, primitive_) {\n        address xTokenAddress = ICurveTricrypto(primitive).coins(0);\n        xToken = _calculateOceanId(xTokenAddress, 0);\n        underlying[xToken] = xTokenAddress;\n        decimals[xToken] = IERC20Metadata(xTokenAddress).decimals();\n        _approveToken(xTokenAddress);\n\n        address yTokenAddress = ICurveTricrypto(primitive).coins(1);\n        yToken = _calculateOceanId(yTokenAddress, 0);\n        indexOf[yToken] = 1;\n        underlying[yToken] = yTokenAddress;\n        decimals[yToken] = IERC20Metadata(yTokenAddress).decimals();\n        _approveToken(yTokenAddress);\n\n        address wethAddress = ICurveTricrypto(primitive).coins(2);\n        zToken = _calculateOceanId(address(0x4574686572), 0); // hexadecimal(ascii(\"Ether\"))\n        indexOf[zToken] = 2;\n        underlying[zToken] = wethAddress;\n        decimals[zToken] = NORMALIZED_DECIMALS;\n        _approveToken(wethAddress);\n\n        address lpTokenAddress = ICurveTricrypto(primitive).token();\n        lpTokenId = _calculateOceanId(lpTokenAddress, 0);\n        underlying[lpTokenId] = lpTokenAddress;\n        decimals[lpTokenId] = IERC20Metadata(lpTokenAddress).decimals();\n        _approveToken(lpTokenAddress);\n    }\n\n    /**\n     * @dev wraps the underlying token into the Ocean\n     * @param tokenId Ocean ID of token to wrap\n     * @param amount wrap amount\n     */\n    function wrapToken(uint256 tokenId, uint256 amount) internal override {\n        Interaction memory interaction;\n\n        if (tokenId == zToken) {\n            interaction = Interaction({\n                interactionTypeAndAddress: 0,\n                inputToken: 0,\n                outputToken: 0,\n                specifiedAmount: 0,\n                metadata: bytes32(0)\n            });\n            IOceanInteractions(ocean).doInteraction{ value: amount }(interaction);\n        } else {\n            interaction = Interaction({\n                interactionTypeAndAddress: _fetchInteractionId(underlying[tokenId], uint256(InteractionType.WrapErc20)),\n                inputToken: 0,\n                outputToken: 0,\n                specifiedAmount: amount,\n                metadata: bytes32(0)\n            });\n            IOceanInteractions(ocean).doInteraction(interaction);\n        }\n    }\n\n    /**\n     * @dev unwraps the underlying token from the Ocean\n     * @param tokenId Ocean ID of token to unwrap\n     * @param amount unwrap amount\n     */\n    function unwrapToken(uint256 tokenId, uint256 amount) internal override {\n        Interaction memory interaction;\n\n        if (tokenId == zToken) {\n            interaction = Interaction({\n                interactionTypeAndAddress: _fetchInteractionId(address(0), uint256(InteractionType.UnwrapEther)),\n                inputToken: 0,\n                outputToken: 0,\n                specifiedAmount: amount,\n                metadata: bytes32(0)\n            });\n        } else {\n            interaction = Interaction({\n                interactionTypeAndAddress: _fetchInteractionId(underlying[tokenId], uint256(InteractionType.UnwrapErc20)),\n                inputToken: 0,\n                outputToken: 0,\n                specifiedAmount: amount,\n                metadata: bytes32(0)\n            });\n        }\n\n        IOceanInteractions(ocean).doInteraction(interaction);\n    }\n\n    /**\n     * @dev swaps/add liquidity/remove liquidity from Curve Tricrypto Pool\n     * @param inputToken The user is giving this token to the pool\n     * @param outputToken The pool is giving this token to the user\n     * @param inputAmount The amount of the inputToken the user is giving to the pool\n     * @param minimumOutputAmount The minimum amount of tokens expected back after the exchange\n     */\n    function primitiveOutputAmount(\n        uint256 inputToken,\n        uint256 outputToken,\n        uint256 inputAmount,\n        bytes32 minimumOutputAmount\n    )\n        internal\n        override\n        returns (uint256 outputAmount)\n    {\n        uint256 rawInputAmount = _convertDecimals(NORMALIZED_DECIMALS, decimals[inputToken], inputAmount);\n\n        ComputeType action = _determineComputeType(inputToken, outputToken);\n\n        uint256 _balanceBefore = _getBalance(underlying[outputToken]);\n\n        // avoid multiple SLOADS\n        uint256 indexOfInputAmount = indexOf[inputToken];\n        uint256 indexOfOutputAmount = indexOf[outputToken];\n\n        if (action == ComputeType.Swap) {\n            bool useEth = inputToken == zToken || outputToken == zToken;\n\n            ICurveTricrypto(primitive).exchange{ value: inputToken == zToken ? rawInputAmount : 0 }(\n                indexOfInputAmount, indexOfOutputAmount, rawInputAmount, 0, useEth\n            );\n        } else if (action == ComputeType.Deposit) {\n            uint256[3] memory inputAmounts;\n            inputAmounts[indexOfInputAmount] = rawInputAmount;\n\n            if (inputToken == zToken) IWETH(underlying[zToken]).deposit{ value: rawInputAmount }();\n\n            ICurveTricrypto(primitive).add_liquidity(inputAmounts, 0);\n        } else {\n            if (outputToken == zToken) {\n                uint256 wethBalance = IERC20Metadata(underlying[zToken]).balanceOf(address(this));\n                ICurveTricrypto(primitive).remove_liquidity_one_coin(rawInputAmount, indexOfOutputAmount, 0);\n                IWETH(underlying[zToken]).withdraw(\n                    IERC20Metadata(underlying[zToken]).balanceOf(address(this)) - wethBalance\n                );\n            } else {\n                ICurveTricrypto(primitive).remove_liquidity_one_coin(rawInputAmount, indexOfOutputAmount, 0);\n            }\n        }\n\n        uint256 rawOutputAmount = _getBalance(underlying[outputToken]) - _balanceBefore;\n\n        outputAmount = _convertDecimals(decimals[outputToken], NORMALIZED_DECIMALS, rawOutputAmount);\n\n        if (uint256(minimumOutputAmount) > outputAmount) revert SLIPPAGE_LIMIT_EXCEEDED();\n\n        if (action == ComputeType.Swap) {\n            emit Swap(inputToken, inputAmount, outputAmount, minimumOutputAmount, primitive, true);\n        } else if (action == ComputeType.Deposit) {\n            emit Deposit(inputToken, inputAmount, outputAmount, minimumOutputAmount, primitive, true);\n        } else {\n            emit Withdraw(outputToken, inputAmount, outputAmount, minimumOutputAmount, primitive, true);\n        }\n    }\n\n    /**\n     * @dev Approves token to be spent by the Ocean and the Curve pool\n     */\n    function _approveToken(address tokenAddress) private {\n        IERC20Metadata(tokenAddress).approve(ocean, type(uint256).max);\n        IERC20Metadata(tokenAddress).approve(primitive, type(uint256).max);\n    }\n\n    /**\n     * @dev fetches underlying token balances\n     */\n    function _getBalance(address tokenAddress) internal view returns (uint256 balance) {\n        if (tokenAddress == underlying[zToken]) {\n            return address(this).balance;\n        } else {\n            return IERC20Metadata(tokenAddress).balanceOf(address(this));\n        }\n    }\n\n    /**\n     * @dev Uses the inputToken and outputToken to determine the ComputeType\n     *  (input: xToken, output: yToken) | (input: yToken, output: xToken) => SWAP\n     *  base := xToken | yToken\n     *  (input: base, output: lpToken) => DEPOSIT\n     *  (input: lpToken, output: base) => WITHDRAW\n     */\n    function _determineComputeType(\n        uint256 inputToken,\n        uint256 outputToken\n    )\n        private\n        view\n        returns (ComputeType computeType)\n    {\n        if (\n            ((inputToken == xToken && outputToken == yToken) || (inputToken == yToken && outputToken == xToken))\n                || ((inputToken == xToken && outputToken == zToken) || (inputToken == zToken && outputToken == xToken))\n                || ((inputToken == yToken && outputToken == zToken) || (inputToken == zToken && outputToken == yToken))\n        ) {\n            return ComputeType.Swap;\n        } else if (\n            ((inputToken == xToken) || (inputToken == yToken) || (inputToken == zToken)) && (outputToken == lpTokenId)\n        ) {\n            return ComputeType.Deposit;\n        } else if (\n            (inputToken == lpTokenId) && ((outputToken == xToken) || (outputToken == yToken) || (outputToken == zToken))\n        ) {\n            return ComputeType.Withdraw;\n        } else {\n            revert INVALID_COMPUTE_TYPE();\n        }\n    }\n\n    fallback() external payable { }\n}"
    }
  ]
}