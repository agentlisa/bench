{
  "Title": "H-4: Missing access modifier for `RFPSimpleStrategy.setPoolActive()` may lead to multiple issues",
  "Content": "# Issue H-4: Missing access modifier for `RFPSimpleStrategy.setPoolActive()` may lead to multiple issues \n\nSource: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/458 \n\n## Found by \n0x180db, 0xdeadbeef, 0xkaden, HChang26, HHK, Kow, fibonacci, jkoppel, lemonmon, rvierdiiev, simon135\n`RFPSimpleStrategy.setPoolActive()` can be called by anybody since it's missing the `onlyPoolManager(msg.sender)` modifier, which can be abused by a malicious actor to steal funds.\n\n## Vulnerability Detail\n\nThe comment on line 217 in RFPSimpleStrategy.sol says that `'msg.sender' must be a pool manager` in order to be able to call `RFPSimpleStrategy.setPoolActive()`. However, the necessary `onlyPoolManager(msg.sender)` modifier is missing.\n\n## Impact\n\nMultiple functions inside `RFPSimpleStrategy.sol` are either using the `onlyActivePool` or the `onlyInactivePool` modifiers:\n\n* `RFPSimpleStrategy._distribute()`\n* `RFPSimpleStrategy.withdraw()`\n* `RFPSimpleStrategy._registerRecipient()`\n* `RFPSimpleStrategy._allocate()`\n\nA malicious actor (Alice) might do the following for example:\n\n1. Alice registers themself as recipient for a `RFPSimpleStrategy`, specifying a `proposalBid` which is `15e18`.\n1. Alice is being declared as the accepted recipient by the pool manager.\n1. Now if the tokens were distributed to Alice, the amount of tokens Alice would receive would be `(15e18 * milestone.amountPercentage) / 1e18` (line 435 RFPSimpleStrategy.sol).\n1. However, Alice calls `RFPSimpleStrategy.setPoolActive()` to make the pool active again, before the tokens are distributed. Alice might do this by either frontrunning or by executing the tx earlier.\n1. Now Alice can call `RFPSimpleStrategy._registerRecipient()`, since the pool is active again, and Alice re-registers themself but with a higher `proposalBid` than was accepted before (line 378 RFPSimpleStrategy.sol), for example they re-register with a `proposalBid` of `60e18`.\n1. Then Alice calls `RFPSimpleStrategy.setPoolActive()` to set the pool inactive, so that the tokens can be distributed.\n1. Now when the tokens are distributed to Alice for the first milestone (and later also for subsequent milestones), they receive a much higher amount of tokens, since Alice maliciously increased their accepted `proposalBid` from `15e18` to `60e18`, so they would now receive `(60e18 * milestone.amountPercentage) / 1e18` (line 435 RFPSimpleStrategy.sol) which is more than was accepted.\n\nThe above example illustrates how Alice can abuse setting the pool to active and inactive to change their accepted `proposalBid` to receive more tokens.\n\nAlso, Alice could potentially steal funds from the strategy, if they get accepted with a smaller `proposalBid` and then maliciously increase the `proposalBid` as described in the above example, so that Alice would receive a much higher amount of tokens that they are not eligible to receive and that are effectively being stolen from the funds of the strategy.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L217-L221\n\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L417-L450\n\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L314-L380\n\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L386-L393\n\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L295\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding the missing access modifier `onlyPoolManager(msg.sender)` to `RFPSimpleStrategy.setPoolActive()`.\n\n\n\n## Discussion\n\n**jkoppel**\n\nEscalate.\n\nNearly all the issues marked as duplicates of this issue are not duplicates. The vast majority identify that setPoolActive is missing access control but fail to identify any substantive consequences of this fact. In accordance with Sherlock rules, they should not be marked duplicates.\n\nThis was extensively discussed in the Discord. See, for instance, https://discord.com/channels/812037309376495636/1150807984893591643/1154681894261227551 .\n\n\n\n**sherlock-admin2**\n\n > Escalate.\n> \n> Nearly all the issues marked as duplicates of this issue are not duplicates. The vast majority identify that setPoolActive is missing access control but fail to identify any substantive consequences of this fact. In accordance with Sherlock rules, they should not be marked duplicates.\n> \n> This was extensively discussed in the Discord. See, for instance, https://discord.com/channels/812037309376495636/1150807984893591643/1154681894261227551 .\n> \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**jkoppel**\n\nFor instance:\n\nI just reviewed the first 20 issues marked as duplicates of this one.\n\nSpecifically, I reviewed: #3 , #25 , #29 , #47 , #50 , #55 , #63 , #88 , #91 , #93 , #95 , #105 , #116 , #117 , #128, #130 , #134 , #135 , #143 , #147 \n\nOf those 20, **only 3 actually found a vulnerability**. They are #116 , #128 , and #130 . **Edit**: And #55. \nWho wants to help review the rest?\n\n**kadenzipfel**\n\nTo add to @jkoppel's escalation, this vulnerability specifically references the ability to frontrun `_distribute` with a re-registration, allowing the attacker to steal funds. The lack of authorization validation in `setPoolActive` is simply a dependency of the vulnerability. It's imperative that we separate \"lack of `setPoolActive` authorization\" submissions based on the actual impact. The other impact present from this lack of authorizations is griefing as defined in https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/356 and should be classified separately.\n\n**rvierdiyev**\n\nI am not going to take any side in this escalation, however in order to protect myself from possible results will say, that my issue  #55 also stated about ability to change bid amount with frontrunning\n\n> Another usage of this will be when distribute for milestone will be called to frontrun it to set pool to active, then change recipient bid to bigger amount, then again set pool to inactive and receive bigger payment.\n\n**0x00ffDa**\n\nI agree with [jkoppel](https://github.com/jkoppel) and [kadenzipfel](https://github.com/kadenzipfel).\n\n> The other impact present from this lack of authorizations is griefing as defined in #356 and should be classified separately.\n\nIf this ends up getting split according to attack method, [#574](https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/574) is also a griefing / DoS attack but more specific.\n\n\n**jkoppel**\n\nThe griefing attacks do not work. They require front-running every transaction, and, if it starts getting annoying, users can just start prefixing their calls with setPoolActive().\n\n**Abelaby**\n\nFollowing @rvierdiyev example I want to drop in my issue [#597](https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/597) I have stated multiple potential issues that could arise from this lack of access modifier including the frontrun issue.\n\n**jkoppel**\n\n@Abelaby Where do you mention the use of frontrunning to steal funds? I only see the griefing attack in your writeup.\n\n**Abelaby**\n\n@jkoppel oh mb, I was referring to the DoS caused by  front running in my case.\n\nOn another note, referring to your comment above;\n\n>The griefing attacks do not work. They require front-running every transaction, and, if it starts getting annoying, users can just start prefixing their calls with setPoolActive().\n\nI believe griefing attacks are very much possible, the malicious user can just listen for specific transactions and front run them with setPoolActive(). Even if gets annoying,  the 'average' user might just not be aware of or will start prefixing their calls with setPoolActive().\n\nAnd hypothetically, if the attacker is dedicated enough, their script can be smart enough to just not `frontrun` transactions with `prefixing`  `setPoolActive()` so that the users prefixing their calls with `setPoolActive()` will just sabotage themselves.\n\nAnd frontrunning every transactions are very much possible in chains with low cost, making this a valid attack vector.\n\n\n\n**jkoppel**\n\nI remain in favor of classifying the griefing attacks as a Low, but have nothing factual to  add.\n\nI've gone through the same set of 20 reports. In addition to the 4 that mention the High attack, another 2 mention the griefing attack: #63 and #88. There is an argument that #95 mentions it, but you have to squint hard.\n\nIf the griefing attack is classified as a Medium, then Sherlock rules state that such reports should be kept as a duplicate of this one.\n\n> Scenario A:\n> There is a root cause/error/vulnerability A in the code. This vulnerability A -> leads to two attack paths:\n> - B -> high severity path\n> - C -> medium severity attack path/just identifying the vulnerability.\n> Both B & C would not have been possible if error A did not exist in the first place. In this case, both B & C should be put together as duplicates.\n> - In addition to this, there is a submission D which identifies the core issue but does not clearly describe the impact or an attack path. Then D is considered low.\n\n**neeksec**\n\nAgree with Escalation.\n\nThe Sherlock docs are clear in this senario.\n\n> Scenario A:\n> There is a root cause/error/vulnerability A in the code. This vulnerability A -> leads to two attack paths:\n> - B -> high severity path\n> - C -> medium severity attack path/just identifying the vulnerability.\n> Both B & C would not have been possible if error A did not exist in the first place. In this case, both B & C should be put together as duplicates.\n> - In addition to this, there is a submission D which identifies the core issue but does not clearly describe the impact or an attack path. Then D is considered low.\n> Scenario B:\n> In the above example if the root issue A is one of the following generic vulnerabilities:\n> - Reentrancy\n> - Access control\n> - Front-running \n> Then the submissions with valid attack paths and higher vulnerability are considered valid. If the submission is vague or does not identify the attack path with higher severity clearly it will be considered low.\n> - B is a valid issue\n> - C is low\n\nDoS/griefing is low in this case.\n\nValid duplicates,\n#055,  #116,  #128,  #130,  #151,  #188,  #246,  #255,  #320,  #450\n\nOther submissions should be put low severity.\n\nComment if I mis-picked or missed any.\n\n**osmanozdemir1**\n\nIf the thing that matters is not the bug itself (`setPoolActive` being external) but the impact of the bug and how the bug can be used (front-running and increasing the `proposalBid`), then issues should be duped according to these impact not the bug itself. \n\nAll of the issues mentioned above describes front-running and increasing the `proposalBid`. That's the impact of the bug. That's why only these issues rewarded, right? Only validating these issues means the actual problem is not `setPoolActive` being external, it is the `proposalBid` being front-runned. But that is already a confirmed issue. #497 \n\nIf the important thing is the impact, it doesn't matter which function is being front-runned. `_allocate` or `_distribute` or `_registerRecipient`. What's the difference? \nThe actual attack is front-running and increasing the `proposalBid`. If only these 11 issues going to be validated, they should be duped with #497\n\n**jkoppel**\n\n@osmanozdemir1 \n\nThe Sherlock docs are very clear about this. To qualify, a report must find both the root cause and any Medium or High attack path, and then the reports are grouped by root cause.\n\nYes, there is a second attack that also involves front-running that transaction, but it works differently. A set of transactions that exploits this issue will not exploit that issue, nor vice versa. A fix to this issue will not fix that one, nor vice versa.\n\nNot in Sherlock docs, but a question I like to ask when thinking about dups: if the sponsor had only gotten this report, and was committed to only fixing medium and high vulnerabilities, would that be sufficient? If they had only gotten #497 and not this or its dupes, then the issue would  be at large in the code.\n\n**jacksanford1**\n\nhttps://github.com/allo-protocol/allo-v2/pull/340\n\n**osmanozdemir1**\n\n> @osmanozdemir1\n> \n> The Sherlock docs are very clear about this. To qualify, a report must find both the root cause and any Medium or High attack path, and then the reports are grouped by root cause.\n> \n> Yes, there is a second attack that also involves front-running that transaction, but it works differently. A set of transactions that exploits this issue will not exploit that issue, nor vice versa. A fix to this issue will not fix that one, nor vice versa.\n> \n> Not in Sherlock docs, but a question I like to ask when thinking about dups: if the sponsor had only gotten this report, and was committed to only fixing medium and high vulnerabilities, would that be sufficient? If they had only gotten #497 and not this or its dupes, then the issue would be at large in the code.\n\nA similar question can be ask this way: If the protocol had only gotten a few `setPoolActive` reports, but none of these reports mentioned any high/medium scenario, wouldn't the protocol fix this issue? They would definitely fix it because the bug itself is clear like a blue sky.\n\nBut it's okay, I get your point and rules are the rules. It is a good lesson for me and for some others :)\n\n**Evert0x**\n\nPlanning to accept escalation and remove all duplicates except \n\nhttps://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/55, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/116, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/128, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/130, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/151, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/188, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/246, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/255, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/320, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/450\n\n**Evert0x**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [jkoppel](https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/458/#issuecomment-1762776851): accepted\n\n**jack-the-pug**\n\nFixed.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/109",
  "Code": [
    {
      "filename": "allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport {ReentrancyGuard} from \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n// Interfaces\nimport {IAllo} from \"../../core/interfaces/IAllo.sol\";\nimport {IRegistry} from \"../../core/interfaces/IRegistry.sol\";\n// Core Contracts\nimport {BaseStrategy} from \"../BaseStrategy.sol\";\n// Internal Libraries\nimport {Metadata} from \"../../core/libraries/Metadata.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title RFP Simple Strategy\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Strategy for Request for Proposal (RFP) allocation with milestone submission and management.\ncontract RFPSimpleStrategy is BaseStrategy, ReentrancyGuard {\n    /// ================================\n    /// ========== Struct ==============\n    /// ================================\n\n    /// @notice Stores the details of the recipients.\n    struct Recipient {\n        bool useRegistryAnchor;\n        address recipientAddress;\n        uint256 proposalBid;\n        Status recipientStatus;\n    }\n\n    /// @notice Stores the details of the milestone\n    struct Milestone {\n        uint256 amountPercentage;\n        Metadata metadata;\n        Status milestoneStatus;\n    }\n\n    /// @notice Stores the details needed for initializing strategy\n    struct InitializeParams {\n        uint256 maxBid;\n        bool useRegistryAnchor;\n        bool metadataRequired;\n    }\n\n    /// ===============================\n    /// ========== Errors =============\n    /// ===============================\n\n    /// @notice Thrown when the milestone is invalid\n    error INVALID_MILESTONE();\n\n    /// @notice Thrown when the milestone is already accepted\n    error MILESTONE_ALREADY_ACCEPTED();\n\n    /// @notice Thrown when the proposal bid exceeds maximum bid\n    error EXCEEDING_MAX_BID();\n\n    /// @notice Thrown when the milestone are already approved and cannot be changed\n    error MILESTONES_ALREADY_SET();\n\n    /// @notice Thrown when the pool manager attempts to the lower the max bid\n    error AMOUNT_TOO_LOW();\n\n    /// ===============================\n    /// ========== Events =============\n    /// ===============================\n\n    /// @notice Emitted when the maximum bid is increased.\n    /// @param maxBid The mew maximum bid\n    event MaxBidIncreased(uint256 maxBid);\n\n    /// @notice Emitted when a milestone is submitted.\n    /// @param milestoneId Id of the milestone\n    event MilstoneSubmitted(uint256 milestoneId);\n\n    /// @notice Emitted for the status change of a milestone.\n    event MilestoneStatusChanged(uint256 milestoneId, Status status);\n\n    /// @notice Emitted when milestones are set.\n    event MilestonesSet();\n\n    /// @notice Emitted when a recipient updates their registration\n    /// @param recipientId Id of the recipient\n    /// @param data The encoded data - (address recipientId, address recipientAddress, Metadata metadata)\n    /// @param sender The sender of the transaction\n    event UpdatedRegistration(address indexed recipientId, bytes data, address sender);\n\n    /// ================================\n    /// ========== Storage =============\n    /// ================================\n\n    /// @notice Flag to indicate whether to use the registry anchor or not.\n    bool public useRegistryAnchor;\n\n    /// @notice Flag to indicate whether metadata is required or not.\n    bool public metadataRequired;\n\n    /// @notice The accepted recipient who can submit milestones.\n    address public acceptedRecipientId;\n\n    /// @notice The registry contract interface.\n    IRegistry private _registry;\n\n    /// @notice The maximum bid for the RFP pool.\n    uint256 public maxBid;\n\n    /// @notice The upcoming milestone which is to be paid.\n    uint256 public upcomingMilestone;\n\n    /// @notice Internal collection of recipients\n    address[] private _recipientIds;\n\n    /// @notice Collection of milestones submitted by the 'acceptedRecipientId'\n    Milestone[] public milestones;\n\n    /// @notice This maps accepted recipients to their details\n    /// @dev 'recipientId' to 'Recipient'\n    mapping(address => Recipient) internal _recipients;\n\n    /// ===============================\n    /// ======== Constructor ==========\n    /// ===============================\n\n    /// @notice Constructor for the RFP Simple Strategy\n    /// @param _allo The 'Allo' contract\n    /// @param _name The name of the strategy\n    constructor(address _allo, string memory _name) BaseStrategy(_allo, _name) {}\n\n    /// ===============================\n    /// ========= Initialize ==========\n    /// ===============================\n\n    // @notice Initialize the strategy\n    /// @param _poolId ID of the pool\n    /// @param _data The data to be decoded\n    /// @custom:data (uint256 _maxBid, bool registryGating, bool metadataRequired)\n    function initialize(uint256 _poolId, bytes memory _data) external virtual override {\n        (InitializeParams memory initializeParams) = abi.decode(_data, (InitializeParams));\n        __RFPSimpleStrategy_init(_poolId, initializeParams);\n    }\n\n    /// @notice This initializes the BaseStrategy\n    /// @dev You only need to pass the 'poolId' to initialize the BaseStrategy and the rest is specific to the strategy\n    /// @param _initializeParams The initialize params\n    function __RFPSimpleStrategy_init(uint256 _poolId, InitializeParams memory _initializeParams) internal {\n        // Initialize the BaseStrategy\n        __BaseStrategy_init(_poolId);\n\n        // Set the strategy specific variables\n        useRegistryAnchor = _initializeParams.useRegistryAnchor;\n        metadataRequired = _initializeParams.metadataRequired;\n        _registry = allo.getRegistry();\n        _increaseMaxBid(_initializeParams.maxBid);\n\n        // Set the pool to active - this is required for the strategy to work and distribute funds\n        // NOTE: There may be some cases where you may want to not set this here, but will be strategy specific\n        _setPoolActive(true);\n    }\n\n    /// ===============================\n    /// ============ Views ============\n    /// ===============================\n\n    /// @notice Get the recipient\n    /// @param _recipientId ID of the recipient\n    /// @return Recipient Returns the recipient\n    function getRecipient(address _recipientId) external view returns (Recipient memory) {\n        return _getRecipient(_recipientId);\n    }\n\n    /// @notice Checks if msg.sender is eligible for RFP allocation\n    /// @param _recipientId Id of the recipient\n    function _getRecipientStatus(address _recipientId) internal view override returns (Status) {\n        return _getRecipient(_recipientId).recipientStatus;\n    }\n\n    /// @notice Return the payout for acceptedRecipientId\n    function getPayouts(address[] memory, bytes[] memory) external view override returns (PayoutSummary[] memory) {\n        PayoutSummary[] memory payouts = new PayoutSummary[](1);\n        payouts[0] = _getPayout(acceptedRecipientId, \"\");\n\n        return payouts;\n    }\n\n    /// @notice Get the milestone\n    /// @param _milestoneId ID of the milestone\n    /// @return Milestone Returns the milestone\n    function getMilestone(uint256 _milestoneId) external view returns (Milestone memory) {\n        return milestones[_milestoneId];\n    }\n\n    /// @notice Get the status of the milestone\n    /// @param _milestoneId Id of the milestone\n    function getMilestoneStatus(uint256 _milestoneId) external view returns (Status) {\n        return milestones[_milestoneId].milestoneStatus;\n    }\n\n    /// ===============================\n    /// ======= External/Custom =======\n    /// ===============================\n\n    /// @notice Toggle the status between active and inactive.\n    /// @dev 'msg.sender' must be a pool manager to close the pool. Emits a 'PoolActive()' event.\n    /// @param _flag The flag to set the pool to active or inactive\n    function setPoolActive(bool _flag) external {\n        _setPoolActive(_flag);\n        emit PoolActive(_flag);\n    }\n\n    /// @notice Set the milestones for the acceptedRecipientId.\n    /// @dev 'msg.sender' must be a pool manager to set milestones. Emits 'MilestonesSet' event\n    /// @param _milestones Milestone[] The milestones to be set\n    function setMilestones(Milestone[] memory _milestones) external onlyPoolManager(msg.sender) {\n        if (upcomingMilestone != 0) revert MILESTONES_ALREADY_SET();\n\n        uint256 totalAmountPercentage;\n\n        // Loop through the milestones and add them to the milestones array\n        uint256 milestonesLength = _milestones.length;\n        for (uint256 i; i < milestonesLength;) {\n            totalAmountPercentage += _milestones[i].amountPercentage;\n            milestones.push(_milestones[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        // Check if the all milestone amount percentage totals to 1e18(100%)\n        if (totalAmountPercentage != 1e18) revert INVALID_MILESTONE();\n\n        emit MilestonesSet();\n    }\n\n    /// @notice Submit milestone by the acceptedRecipientId.\n    /// @dev 'msg.sender' must be the 'acceptedRecipientId' and must be a member\n    ///      of a 'Profile' to sumbit a milestone. Emits a 'MilestonesSubmitted()' event.\n    /// @param _metadata The proof of work\n    function submitUpcomingMilestone(Metadata calldata _metadata) external {\n        // Check if the 'msg.sender' is the 'acceptedRecipientId' and is a member of the 'Profile'\n        if (acceptedRecipientId != msg.sender && !_isProfileMember(acceptedRecipientId, msg.sender)) {\n            revert UNAUTHORIZED();\n        }\n\n        // Check if the upcoming milestone is in fact upcoming\n        if (upcomingMilestone >= milestones.length) revert INVALID_MILESTONE();\n\n        // Get the milestone and update the metadata and status\n        Milestone storage milestone = milestones[upcomingMilestone];\n        milestone.metadata = _metadata;\n\n        // Set the milestone status to 'Pending' to indicate that the milestone is submitted\n        milestone.milestoneStatus = Status.Pending;\n\n        // Emit event for the milestone\n        emit MilstoneSubmitted(upcomingMilestone);\n    }\n\n    /// @notice Update max bid for RFP pool\n    /// @dev 'msg.sender' must be a pool manager to update the max bid.\n    /// @param _maxBid The max bid to be set\n    function increaseMaxBid(uint256 _maxBid) external onlyPoolManager(msg.sender) {\n        _increaseMaxBid(_maxBid);\n    }\n\n    /// @notice Reject pending milestone submmited by the acceptedRecipientId.\n    /// @dev 'msg.sender' must be a pool manager to reject a milestone. Emits a 'MilestoneStatusChanged()' event.\n    /// @param _milestoneId ID of the milestone\n    function rejectMilestone(uint256 _milestoneId) external onlyPoolManager(msg.sender) {\n        // Check if the milestone is already accepted\n        if (milestones[_milestoneId].milestoneStatus == Status.Accepted) revert MILESTONE_ALREADY_ACCEPTED();\n\n        milestones[_milestoneId].milestoneStatus = Status.Rejected;\n\n        emit MilestoneStatusChanged(_milestoneId, milestones[_milestoneId].milestoneStatus);\n    }\n\n    /// @notice Withdraw funds from pool.\n    /// @dev 'msg.sender' must be a pool manager to withdraw funds.\n    /// @param _amount The amount to be withdrawn\n    function withdraw(uint256 _amount) external onlyPoolManager(msg.sender) onlyInactivePool {\n        // Decrement the pool amount\n        poolAmount -= _amount;\n\n        // Transfer the amount to the pool manager\n        _transferAmount(allo.getPool(poolId).token, msg.sender, _amount);\n    }\n\n    /// ====================================\n    /// ============ Internal ==============\n    /// ====================================\n\n    /// @notice Submit a proposal to RFP pool\n    /// @dev Emits a 'Registered()' event\n    /// @param _data The data to be decoded\n    /// @custom:data when 'useRegistryAnchor' is 'true' -> (address recipientId, uint256 proposalBid, Metadata metadata)\n    ///              when 'useRegistryAnchor' is 'false' -> (address recipientAddress, address registryAnchor, uint256 proposalBid, Metadata metadata)\n    /// @param _sender The sender of the transaction\n    /// @return recipientId The id of the recipient\n    function _registerRecipient(bytes memory _data, address _sender)\n        internal\n        override\n        onlyActivePool\n        returns (address recipientId)\n    {\n        bool isUsingRegistryAnchor;\n        address recipientAddress;\n        address registryAnchor;\n        uint256 proposalBid;\n        Metadata memory metadata;\n\n        // Decode '_data' depending on the 'useRegistryAnchor' flag\n        if (useRegistryAnchor) {\n            /// @custom:data when 'true' -> (address recipientId, uint256 proposalBid, Metadata metadata)\n            (recipientId, proposalBid, metadata) = abi.decode(_data, (address, uint256, Metadata));\n\n            // If the sender is not a profile member this will revert\n            if (!_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        } else {\n            //  @custom:data when 'false' -> (address recipientAddress, address registryAnchor, uint256 proposalBid, Metadata metadata)\n            (recipientAddress, registryAnchor, proposalBid, metadata) =\n                abi.decode(_data, (address, address, uint256, Metadata));\n\n            // Check if the registry anchor is valid so we know whether to use it or not\n            isUsingRegistryAnchor = registryAnchor != address(0);\n\n            // Ternerary to set the recipient id based on whether or not we are using the 'registryAnchor' or '_sender'\n            recipientId = isUsingRegistryAnchor ? registryAnchor : _sender;\n\n            // Checks if the '_sender' is a member of the profile 'anchor' being used and reverts if not\n            if (isUsingRegistryAnchor && !_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        }\n\n        // Check if the metadata is required and if it is, check if it is valid, otherwise revert\n        if (metadataRequired && (bytes(metadata.pointer).length == 0 || metadata.protocol == 0)) {\n            revert INVALID_METADATA();\n        }\n\n        if (proposalBid > maxBid) {\n            // If the proposal bid is greater than the max bid this will revert\n            revert EXCEEDING_MAX_BID();\n        } else if (proposalBid == 0) {\n            // If the proposal bid is 0, set it to the max bid\n            proposalBid = maxBid;\n        }\n\n        // If the recipient address is the zero address this will revert\n        if (recipientAddress == address(0)) revert RECIPIENT_ERROR(recipientId);\n\n        // Get the recipient\n        Recipient storage recipient = _recipients[recipientId];\n\n        if (recipient.recipientStatus == Status.None) {\n            // If the recipient status is 'None' add the recipient to the '_recipientIds' array\n            _recipientIds.push(recipientId);\n            emit Registered(recipientId, _data, _sender);\n        } else {\n            emit UpdatedRegistration(recipientId, _data, _sender);\n        }\n\n        // update the recipients data\n        recipient.recipientAddress = recipientAddress;\n        recipient.useRegistryAnchor = isUsingRegistryAnchor ? true : recipient.useRegistryAnchor;\n        recipient.proposalBid = proposalBid;\n        recipient.recipientStatus = Status.Pending;\n    }\n\n    /// @notice Select recipient for RFP allocation\n    /// @dev '_sender' must be a pool manager to allocate.\n    /// @param _data The data to be decoded\n    /// @param _sender The sender of the allocation\n    function _allocate(bytes memory _data, address _sender)\n        internal\n        virtual\n        override\n        nonReentrant\n        onlyActivePool\n        onlyPoolManager(_sender)\n    {\n        // Decode the '_data'\n        acceptedRecipientId = abi.decode(_data, (address));\n\n        Recipient storage recipient = _recipients[acceptedRecipientId];\n\n        if (acceptedRecipientId == address(0) || recipient.recipientStatus != Status.Pending) {\n            revert RECIPIENT_ERROR(acceptedRecipientId);\n        }\n\n        // Update status of acceptedRecipientId to accepted\n        recipient.recipientStatus = Status.Accepted;\n\n        _setPoolActive(false);\n\n        IAllo.Pool memory pool = allo.getPool(poolId);\n\n        // Emit event for the allocation\n        emit Allocated(acceptedRecipientId, recipient.proposalBid, pool.token, _sender);\n    }\n\n    /// @notice Distribute the upcoming milestone to acceptedRecipientId.\n    /// @dev '_sender' must be a pool manager to distribute.\n    /// @param _sender The sender of the distribution\n    function _distribute(address[] memory, bytes memory, address _sender)\n        internal\n        virtual\n        override\n        onlyInactivePool\n        onlyPoolManager(_sender)\n    {\n        // check to make sure there is a pending milestone\n        if (upcomingMilestone >= milestones.length) revert INVALID_MILESTONE();\n\n        IAllo.Pool memory pool = allo.getPool(poolId);\n        Milestone storage milestone = milestones[upcomingMilestone];\n        Recipient memory recipient = _recipients[acceptedRecipientId];\n\n        // make sure has enough funds to distribute based on the proposal bid\n        if (recipient.proposalBid > poolAmount) revert NOT_ENOUGH_FUNDS();\n\n        // Calculate the amount to be distributed for the milestone\n        uint256 amount = (recipient.proposalBid * milestone.amountPercentage) / 1e18;\n\n        // Get the pool, subtract the amount and transfer to the recipient\n        poolAmount -= amount;\n        _transferAmount(pool.token, recipient.recipientAddress, amount);\n\n        // Set the milestone status to 'Accepted'\n        milestone.milestoneStatus = Status.Accepted;\n\n        // Increment the upcoming milestone\n        upcomingMilestone++;\n\n        // Emit events for the milestone and the distribution\n        emit MilestoneStatusChanged(upcomingMilestone, Status.Accepted);\n        emit Distributed(acceptedRecipientId, recipient.recipientAddress, amount, _sender);\n    }\n\n    /// @notice Check if sender is a profile owner or member.\n    /// @param _anchor Anchor of the profile\n    /// @param _sender The sender of the transaction\n    /// @return 'true' if the sender is the owner or member of the profile, otherwise 'false'\n    function _isProfileMember(address _anchor, address _sender) internal view returns (bool) {\n        IRegistry.Profile memory profile = _registry.getProfileByAnchor(_anchor);\n        return _registry.isOwnerOrMemberOfProfile(profile.id, _sender);\n    }\n\n    /// @notice Get the recipient.\n    /// @param _recipientId ID of the recipient\n    /// @return recipient Returns the recipient information\n    function _getRecipient(address _recipientId) internal view returns (Recipient memory recipient) {\n        recipient = _recipients[_recipientId];\n\n        if (acceptedRecipientId != address(0) && acceptedRecipientId != _recipientId) {\n            recipient.recipientStatus = recipient.recipientStatus > Status.None ? Status.Rejected : Status.None;\n        }\n    }\n\n    /// @notice Increase max bid for RFP pool\n    /// @param _maxBid The new max bid to be set\n    function _increaseMaxBid(uint256 _maxBid) internal {\n        // make sure the new max bid is greater than the current max bid\n        if (_maxBid < maxBid) revert AMOUNT_TOO_LOW();\n\n        maxBid = _maxBid;\n\n        // emit the new max mid\n        emit MaxBidIncreased(maxBid);\n    }\n\n    /// @notice Get the payout summary for the accepted recipient.\n    /// @return Returns the payout summary for the accepted recipient\n    function _getPayout(address _recipientId, bytes memory) internal view override returns (PayoutSummary memory) {\n        Recipient memory recipient = _recipients[_recipientId];\n        return PayoutSummary(recipient.recipientAddress, recipient.proposalBid);\n    }\n\n    /// @notice Checks if address is eligible allocator.\n    /// @dev This is used to check if the allocator is a pool manager and able to allocate funds from the pool\n    /// @param _allocator Address of the allocator\n    /// @return 'true' if the allocator is a pool manager, otherwise false\n    function _isValidAllocator(address _allocator) internal view override returns (bool) {\n        return allo.isPoolManager(poolId, _allocator);\n    }\n\n    /// @notice This contract should be able to receive native token\n    receive() external payable {}\n}"
    },
    {
      "filename": "allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport {ReentrancyGuard} from \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n// Interfaces\nimport {IAllo} from \"../../core/interfaces/IAllo.sol\";\nimport {IRegistry} from \"../../core/interfaces/IRegistry.sol\";\n// Core Contracts\nimport {BaseStrategy} from \"../BaseStrategy.sol\";\n// Internal Libraries\nimport {Metadata} from \"../../core/libraries/Metadata.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title RFP Simple Strategy\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Strategy for Request for Proposal (RFP) allocation with milestone submission and management.\ncontract RFPSimpleStrategy is BaseStrategy, ReentrancyGuard {\n    /// ================================\n    /// ========== Struct ==============\n    /// ================================\n\n    /// @notice Stores the details of the recipients.\n    struct Recipient {\n        bool useRegistryAnchor;\n        address recipientAddress;\n        uint256 proposalBid;\n        Status recipientStatus;\n    }\n\n    /// @notice Stores the details of the milestone\n    struct Milestone {\n        uint256 amountPercentage;\n        Metadata metadata;\n        Status milestoneStatus;\n    }\n\n    /// @notice Stores the details needed for initializing strategy\n    struct InitializeParams {\n        uint256 maxBid;\n        bool useRegistryAnchor;\n        bool metadataRequired;\n    }\n\n    /// ===============================\n    /// ========== Errors =============\n    /// ===============================\n\n    /// @notice Thrown when the milestone is invalid\n    error INVALID_MILESTONE();\n\n    /// @notice Thrown when the milestone is already accepted\n    error MILESTONE_ALREADY_ACCEPTED();\n\n    /// @notice Thrown when the proposal bid exceeds maximum bid\n    error EXCEEDING_MAX_BID();\n\n    /// @notice Thrown when the milestone are already approved and cannot be changed\n    error MILESTONES_ALREADY_SET();\n\n    /// @notice Thrown when the pool manager attempts to the lower the max bid\n    error AMOUNT_TOO_LOW();\n\n    /// ===============================\n    /// ========== Events =============\n    /// ===============================\n\n    /// @notice Emitted when the maximum bid is increased.\n    /// @param maxBid The mew maximum bid\n    event MaxBidIncreased(uint256 maxBid);\n\n    /// @notice Emitted when a milestone is submitted.\n    /// @param milestoneId Id of the milestone\n    event MilstoneSubmitted(uint256 milestoneId);\n\n    /// @notice Emitted for the status change of a milestone.\n    event MilestoneStatusChanged(uint256 milestoneId, Status status);\n\n    /// @notice Emitted when milestones are set.\n    event MilestonesSet();\n\n    /// @notice Emitted when a recipient updates their registration\n    /// @param recipientId Id of the recipient\n    /// @param data The encoded data - (address recipientId, address recipientAddress, Metadata metadata)\n    /// @param sender The sender of the transaction\n    event UpdatedRegistration(address indexed recipientId, bytes data, address sender);\n\n    /// ================================\n    /// ========== Storage =============\n    /// ================================\n\n    /// @notice Flag to indicate whether to use the registry anchor or not.\n    bool public useRegistryAnchor;\n\n    /// @notice Flag to indicate whether metadata is required or not.\n    bool public metadataRequired;\n\n    /// @notice The accepted recipient who can submit milestones.\n    address public acceptedRecipientId;\n\n    /// @notice The registry contract interface.\n    IRegistry private _registry;\n\n    /// @notice The maximum bid for the RFP pool.\n    uint256 public maxBid;\n\n    /// @notice The upcoming milestone which is to be paid.\n    uint256 public upcomingMilestone;\n\n    /// @notice Internal collection of recipients\n    address[] private _recipientIds;\n\n    /// @notice Collection of milestones submitted by the 'acceptedRecipientId'\n    Milestone[] public milestones;\n\n    /// @notice This maps accepted recipients to their details\n    /// @dev 'recipientId' to 'Recipient'\n    mapping(address => Recipient) internal _recipients;\n\n    /// ===============================\n    /// ======== Constructor ==========\n    /// ===============================\n\n    /// @notice Constructor for the RFP Simple Strategy\n    /// @param _allo The 'Allo' contract\n    /// @param _name The name of the strategy\n    constructor(address _allo, string memory _name) BaseStrategy(_allo, _name) {}\n\n    /// ===============================\n    /// ========= Initialize ==========\n    /// ===============================\n\n    // @notice Initialize the strategy\n    /// @param _poolId ID of the pool\n    /// @param _data The data to be decoded\n    /// @custom:data (uint256 _maxBid, bool registryGating, bool metadataRequired)\n    function initialize(uint256 _poolId, bytes memory _data) external virtual override {\n        (InitializeParams memory initializeParams) = abi.decode(_data, (InitializeParams));\n        __RFPSimpleStrategy_init(_poolId, initializeParams);\n    }\n\n    /// @notice This initializes the BaseStrategy\n    /// @dev You only need to pass the 'poolId' to initialize the BaseStrategy and the rest is specific to the strategy\n    /// @param _initializeParams The initialize params\n    function __RFPSimpleStrategy_init(uint256 _poolId, InitializeParams memory _initializeParams) internal {\n        // Initialize the BaseStrategy\n        __BaseStrategy_init(_poolId);\n\n        // Set the strategy specific variables\n        useRegistryAnchor = _initializeParams.useRegistryAnchor;\n        metadataRequired = _initializeParams.metadataRequired;\n        _registry = allo.getRegistry();\n        _increaseMaxBid(_initializeParams.maxBid);\n\n        // Set the pool to active - this is required for the strategy to work and distribute funds\n        // NOTE: There may be some cases where you may want to not set this here, but will be strategy specific\n        _setPoolActive(true);\n    }\n\n    /// ===============================\n    /// ============ Views ============\n    /// ===============================\n\n    /// @notice Get the recipient\n    /// @param _recipientId ID of the recipient\n    /// @return Recipient Returns the recipient\n    function getRecipient(address _recipientId) external view returns (Recipient memory) {\n        return _getRecipient(_recipientId);\n    }\n\n    /// @notice Checks if msg.sender is eligible for RFP allocation\n    /// @param _recipientId Id of the recipient\n    function _getRecipientStatus(address _recipientId) internal view override returns (Status) {\n        return _getRecipient(_recipientId).recipientStatus;\n    }\n\n    /// @notice Return the payout for acceptedRecipientId\n    function getPayouts(address[] memory, bytes[] memory) external view override returns (PayoutSummary[] memory) {\n        PayoutSummary[] memory payouts = new PayoutSummary[](1);\n        payouts[0] = _getPayout(acceptedRecipientId, \"\");\n\n        return payouts;\n    }\n\n    /// @notice Get the milestone\n    /// @param _milestoneId ID of the milestone\n    /// @return Milestone Returns the milestone\n    function getMilestone(uint256 _milestoneId) external view returns (Milestone memory) {\n        return milestones[_milestoneId];\n    }\n\n    /// @notice Get the status of the milestone\n    /// @param _milestoneId Id of the milestone\n    function getMilestoneStatus(uint256 _milestoneId) external view returns (Status) {\n        return milestones[_milestoneId].milestoneStatus;\n    }\n\n    /// ===============================\n    /// ======= External/Custom =======\n    /// ===============================\n\n    /// @notice Toggle the status between active and inactive.\n    /// @dev 'msg.sender' must be a pool manager to close the pool. Emits a 'PoolActive()' event.\n    /// @param _flag The flag to set the pool to active or inactive\n    function setPoolActive(bool _flag) external {\n        _setPoolActive(_flag);\n        emit PoolActive(_flag);\n    }\n\n    /// @notice Set the milestones for the acceptedRecipientId.\n    /// @dev 'msg.sender' must be a pool manager to set milestones. Emits 'MilestonesSet' event\n    /// @param _milestones Milestone[] The milestones to be set\n    function setMilestones(Milestone[] memory _milestones) external onlyPoolManager(msg.sender) {\n        if (upcomingMilestone != 0) revert MILESTONES_ALREADY_SET();\n\n        uint256 totalAmountPercentage;\n\n        // Loop through the milestones and add them to the milestones array\n        uint256 milestonesLength = _milestones.length;\n        for (uint256 i; i < milestonesLength;) {\n            totalAmountPercentage += _milestones[i].amountPercentage;\n            milestones.push(_milestones[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        // Check if the all milestone amount percentage totals to 1e18(100%)\n        if (totalAmountPercentage != 1e18) revert INVALID_MILESTONE();\n\n        emit MilestonesSet();\n    }\n\n    /// @notice Submit milestone by the acceptedRecipientId.\n    /// @dev 'msg.sender' must be the 'acceptedRecipientId' and must be a member\n    ///      of a 'Profile' to sumbit a milestone. Emits a 'MilestonesSubmitted()' event.\n    /// @param _metadata The proof of work\n    function submitUpcomingMilestone(Metadata calldata _metadata) external {\n        // C"
    }
  ]
}