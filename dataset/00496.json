{
  "Title": "M-9: Mint and sales can be dossed due to lack of safeApprove to 0",
  "Content": "# Issue M-9: Mint and sales can be dossed due to lack of safeApprove to 0 \n\nSource: https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/118 \n\n## Found by \nZanyBonzy, panprog\n## Summary\nThe lack of approval to 0 to the dvp contract, and the fee managers during DVP mints and sales will cause that subsequent transactions involving approval of these contracts to spend the basetoken will fail, breaking their functionality.\n\n## Vulnerability Detail\nWhen DVPs are to be minted and sold through the PositionManager, the [mint](https://github.com/sherlock-audit/2024-02-smilee-finance/blob/3241f1bf0c8e951a41dd2e51997f64ef3ec017bd/smilee-v2-contracts/src/periphery/PositionManager.sol#L91) and [sell](https://github.com/sherlock-audit/2024-02-smilee-finance/blob/3241f1bf0c8e951a41dd2e51997f64ef3ec017bd/smilee-v2-contracts/src/periphery/PositionManager.sol#L189) functions are invoked. \nThe first issue appears [here](https://github.com/sherlock-audit/2024-02-smilee-finance/blob/3241f1bf0c8e951a41dd2e51997f64ef3ec017bd/smilee-v2-contracts/src/periphery/PositionManager.sol#L127), where the DVP contract is approved to spend the basetoken using the OpenZeppelin's `safeApprove` function, without first approving to zero. Further down the line, the `mint` and `sell` functions make calls to the DVP contract to [mint](https://github.com/sherlock-audit/2024-02-smilee-finance/blob/3241f1bf0c8e951a41dd2e51997f64ef3ec017bd/smilee-v2-contracts/src/periphery/PositionManager.sol#L129) and [burn](https://github.com/sherlock-audit/2024-02-smilee-finance/blob/3241f1bf0c8e951a41dd2e51997f64ef3ec017bd/smilee-v2-contracts/src/periphery/PositionManager.sol#L235) DVP respectively.\n\nThe [_mint](https://github.com/sherlock-audit/2024-02-smilee-finance/blob/3241f1bf0c8e951a41dd2e51997f64ef3ec017bd/smilee-v2-contracts/src/DVP.sol#L173) and [_burn](https://github.com/sherlock-audit/2024-02-smilee-finance/blob/3241f1bf0c8e951a41dd2e51997f64ef3ec017bd/smilee-v2-contracts/src/DVP.sol#L327) functions in the DVP contract approves the fee manager to spend the `fee - vaultFee`/`netFee`.\n\nThis issue here is that OpenZeppelin's `safeApprove()` function does not allow changing a non-zero allowance to another non-zero allowance. This will therefore cause all subsequent approval of the basetoken to fail after the first approval, dossing the contract's minting and selling/burning functionality.\n\nOpenZeppelin's `safeApprove()` will revert if the account already is approved and the new safeApprove() is done with a non-zero value.\n```solidity\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n```\n\n\n## Impact\nThis causes that after the first approval for the baseToken has been given, subsequent approvals will fail causing the functions to fail.\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/3241f1bf0c8e951a41dd2e51997f64ef3ec017bd/smilee-v2-contracts/src/DVP.sol#L173\nThe `_mint` and _`burn` functions both send a call to approve the feeManager to \"pull\" the tokens upon the `receiveFee` function being called.  And as can be seen from the snippets, a zero approval is not given first.\n\n```solidity\n    function _mint(\n        address recipient,\n        uint256 strike,\n        Amount memory amount,\n        uint256 expectedPremium,\n        uint256 maxSlippage\n    ) internal returns (uint256 premium_) {\n...\n        // Get fees from sender:\n        IERC20Metadata(baseToken).safeTransferFrom(msg.sender, address(this), fee - vaultFee);\n        IERC20Metadata(baseToken).safeApprove(address(feeManager), fee - vaultFee); //@note\n        feeManager.receiveFee(fee - vaultFee);\n...\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/3241f1bf0c8e951a41dd2e51997f64ef3ec017bd/smilee-v2-contracts/src/DVP.sol#L327\n```solidity\n    function _burn(\n        uint256 expiry,\n        address recipient,\n        uint256 strike,\n        Amount memory amount,\n        uint256 expectedMarketValue,\n        uint256 maxSlippage\n    ) internal returns (uint256 paidPayoff) {\n     ....\n        IERC20Metadata(baseToken).safeApprove(address(feeManager), netFee); //@note\n        feeManager.receiveFee(netFee);\n        feeManager.trackVaultFee(address(vault), vaultFee);\n\n        emit Burn(msg.sender);\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/3241f1bf0c8e951a41dd2e51997f64ef3ec017bd/smilee-v2-contracts/src/periphery/PositionManager.sol#L124\n\n```solidity\n    function mint(\n        IPositionManager.MintParams calldata params\n    ) external override returns (uint256 tokenId, uint256 premium) {\n...\n        // Transfer premium:\n        // NOTE: The PositionManager is just a middleman between the user and the DVP\n        IERC20 baseToken = IERC20(dvp.baseToken());\n        baseToken.safeTransferFrom(msg.sender, address(this), obtainedPremium); \n\n        // Premium already include fee\n        baseToken.safeApprove(params.dvpAddr, obtainedPremium);//@note\n\n...\n    }\n```\n## Tool used\n\nManual Review\n\n## Recommendation\n1. Approve first to 0;\n2. Update the OpenZeppelin version to the latest and use the `forceApprove` functions instead;\n3. Refactor the functions to allow for direct transfer of base tokens to the DVP and FeeManager contracts directly.  \n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> valid medium. dup of #41\n\n**takarez** commented:\n>  valid; medium(3)\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dverso/smilee-v2-contracts/commit/84174d20544970309c862a2bf35ccfa3046d6bd9.\n\n**panprog**\n\nFix review: Fixed\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/180",
  "Code": [
    {
      "filename": "smilee-v2-contracts/src/periphery/PositionManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.15;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IDVP} from \"../interfaces/IDVP.sol\";\nimport {IPositionManager} from \"../interfaces/IPositionManager.sol\";\nimport {Position} from \"../lib/Position.sol\";\nimport {Epoch} from \"../lib/EpochController.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PositionManager is ERC721Enumerable, Ownable, IPositionManager {\n    using SafeERC20 for IERC20;\n\n    struct ManagedPosition {\n        address dvpAddr;\n        uint256 strike;\n        uint256 expiry;\n        uint256 notionalUp;\n        uint256 notionalDown;\n        uint256 premium;\n        uint256 leverage;\n        uint256 cumulatedPayoff;\n    }\n\n    /// @dev Stored data by position ID\n    mapping(uint256 => ManagedPosition) internal _positions;\n\n    /// @dev The ID of the next token that will be minted. Skips 0\n    uint256 private _nextId;\n\n    // Used by TheGraph for frontend needs:\n    event Buy(address dvp, uint256 epoch, uint256 premium, address creditor);\n    event Sell(address dvp, uint256 epoch, uint256 payoff);\n\n    error CantBurnMoreThanMinted();\n    error InvalidTokenID();\n    error NotOwner();\n    error PositionExpired();\n    error AsymmetricAmount();\n\n    constructor() ERC721Enumerable() ERC721(\"Smilee V0 Trade Positions\", \"SMIL-V0-TRAD\") Ownable() {\n        _nextId = 1;\n    }\n\n    modifier isOwner(uint256 tokenId) {\n        if (ownerOf(tokenId) != msg.sender) {\n            revert NotOwner();\n        }\n        _;\n    }\n\n    // modifier isAuthorizedForToken(uint256 tokenId) {\n    //     if (!_isApprovedOrOwner(msg.sender, tokenId)) {\n    //         revert NotApproved();\n    //     }\n    //     _;\n    // }\n\n    /// @inheritdoc IPositionManager\n    function positionDetail(uint256 tokenId) external view override returns (IPositionManager.PositionDetail memory) {\n        ManagedPosition memory position = _positions[tokenId];\n        if (position.dvpAddr == address(0)) {\n            revert InvalidTokenID();\n        }\n\n        IDVP dvp = IDVP(position.dvpAddr);\n\n        Epoch memory epoch = dvp.getEpoch();\n\n        return\n            IPositionManager.PositionDetail({\n                dvpAddr: position.dvpAddr,\n                baseToken: dvp.baseToken(),\n                sideToken: dvp.sideToken(),\n                dvpFreq: epoch.frequency,\n                dvpType: dvp.optionType(),\n                strike: position.strike,\n                expiry: position.expiry,\n                premium: position.premium,\n                leverage: position.leverage,\n                notionalUp: position.notionalUp,\n                notionalDown: position.notionalDown,\n                cumulatedPayoff: position.cumulatedPayoff\n            });\n    }\n\n    /// @inheritdoc IPositionManager\n    function mint(\n        IPositionManager.MintParams calldata params\n    ) external override returns (uint256 tokenId, uint256 premium) {\n        IDVP dvp = IDVP(params.dvpAddr);\n\n        if (params.tokenId != 0) {\n            tokenId = params.tokenId;\n            ManagedPosition storage position = _positions[tokenId];\n\n            if (ownerOf(tokenId) != msg.sender) {\n                revert NotOwner();\n            }\n            // Check token compatibility:\n            if (position.dvpAddr != params.dvpAddr || position.strike != params.strike) {\n                revert InvalidTokenID();\n            }\n            Epoch memory epoch = dvp.getEpoch();\n            if (position.expiry != epoch.current) {\n                revert PositionExpired();\n            }\n        }\n        if ((params.notionalUp > 0 && params.notionalDown > 0) && (params.notionalUp != params.notionalDown)) {\n            // If amount is a smile, it must be balanced:\n            revert AsymmetricAmount();\n        }\n\n        uint256 obtainedPremium;\n        uint256 fee;\n        (obtainedPremium, fee) = dvp.premium(params.strike, params.notionalUp, params.notionalDown);\n\n        // Transfer premium:\n        // NOTE: The PositionManager is just a middleman between the user and the DVP\n        IERC20 baseToken = IERC20(dvp.baseToken());\n        baseToken.safeTransferFrom(msg.sender, address(this), obtainedPremium);\n\n        // Premium already include fee\n        baseToken.safeApprove(params.dvpAddr, obtainedPremium);\n\n        premium = dvp.mint(\n            address(this),\n            params.strike,\n            params.notionalUp,\n            params.notionalDown,\n            params.expectedPremium,\n            params.maxSlippage,\n            params.nftAccessTokenId\n        );\n\n        if (obtainedPremium > premium) {\n            baseToken.safeTransferFrom(address(this), msg.sender, obtainedPremium - premium);\n        }\n\n        if (params.tokenId == 0) {\n            // Mint token:\n            tokenId = _nextId++;\n            _mint(params.recipient, tokenId);\n\n            Epoch memory epoch = dvp.getEpoch();\n\n            // Save position:\n            _positions[tokenId] = ManagedPosition({\n                dvpAddr: params.dvpAddr,\n                strike: params.strike,\n                expiry: epoch.current,\n                premium: premium,\n                leverage: (params.notionalUp + params.notionalDown) / premium,\n                notionalUp: params.notionalUp,\n                notionalDown: params.notionalDown,\n                cumulatedPayoff: 0\n            });\n        } else {\n            ManagedPosition storage position = _positions[tokenId];\n            // Increase position:\n            position.premium += premium;\n            position.notionalUp += params.notionalUp;\n            position.notionalDown += params.notionalDown;\n            /* NOTE:\n                When, within the same epoch, a user wants to buy, sell partially\n                and then buy again, the leverage computation can fail due to\n                decreased notional; in order to avoid this issue, we have to\n                also adjust (decrease) the premium in the burn flow.\n             */\n            position.leverage = (position.notionalUp + position.notionalDown) / position.premium;\n        }\n\n        emit BuyDVP(tokenId, _positions[tokenId].expiry, params.notionalUp + params.notionalDown);\n        emit Buy(params.dvpAddr, _positions[tokenId].expiry, premium, params.recipient);\n    }\n\n    function payoff(\n        uint256 tokenId,\n        uint256 notionalUp,\n        uint256 notionalDown\n    ) external view returns (uint256 payoff_, uint256 fee) {\n        ManagedPosition storage position = _positions[tokenId];\n        return IDVP(position.dvpAddr).payoff(position.expiry, position.strike, notionalUp, notionalDown);\n    }\n\n    function sell(SellParams calldata params) external isOwner(params.tokenId) returns (uint256 payoff_) {\n        payoff_ = _sell(\n            params.tokenId,\n            params.notionalUp,\n            params.notionalDown,\n            params.expectedMarketValue,\n            params.maxSlippage\n        );\n    }\n\n    function sellAll(SellParams[] calldata params) external returns (uint256 totalPayoff_) {\n        uint256 paramsLength = params.length;\n        for (uint256 i = 0; i < paramsLength; i++) {\n            if (ownerOf(params[i].tokenId) != msg.sender) {\n                revert NotOwner();\n            }\n            totalPayoff_ += _sell(\n                params[i].tokenId,\n                params[i].notionalUp,\n                params[i].notionalDown,\n                params[i].expectedMarketValue,\n                params[i].maxSlippage\n            );\n        }\n    }\n\n    function _sell(\n        uint256 tokenId,\n        uint256 notionalUp,\n        uint256 notionalDown,\n        uint256 expectedMarketValue,\n        uint256 maxSlippage\n    ) internal returns (uint256 payoff_) {\n        ManagedPosition storage position = _positions[tokenId];\n        // NOTE: as the positions within the DVP are all of the PositionManager, we must replicate this check here.\n        if (notionalUp > position.notionalUp || notionalDown > position.notionalDown) {\n            revert CantBurnMoreThanMinted();\n        }\n\n        if ((notionalUp > 0 && notionalDown > 0) && (notionalUp != notionalDown)) {\n            // If amount is a smile, it must be balanced:\n            revert AsymmetricAmount();\n        }\n\n        // NOTE: the DVP already checks that the burned notional is lesser or equal to the position notional.\n        // NOTE: the payoff is transferred directly from the DVP\n        payoff_ = IDVP(position.dvpAddr).burn(\n            position.expiry,\n            msg.sender,\n            position.strike,\n            notionalUp,\n            notionalDown,\n            expectedMarketValue,\n            maxSlippage\n        );\n\n        // NOTE: premium fix for the leverage issue annotated in the mint flow.\n        // notional : position.notional = fix : position.premium\n        uint256 premiumFix = ((notionalUp + notionalDown) * position.premium) /\n            (position.notionalUp + position.notionalDown);\n        position.premium -= premiumFix;\n        position.cumulatedPayoff += payoff_;\n        position.notionalUp -= notionalUp;\n        position.notionalDown -= notionalDown;\n\n        if (position.notionalUp == 0 && position.notionalDown == 0) {\n            delete _positions[tokenId];\n            _burn(tokenId);\n        }\n\n        emit SellDVP(tokenId, (notionalUp + notionalDown), payoff_);\n        emit Sell(position.dvpAddr, position.expiry, payoff_);\n    }\n}"
    },
    {
      "filename": "smilee-v2-contracts/src/periphery/PositionManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.15;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IDVP} from \"../interfaces/IDVP.sol\";\nimport {IPositionManager} from \"../interfaces/IPositionManager.sol\";\nimport {Position} from \"../lib/Position.sol\";\nimport {Epoch} from \"../lib/EpochController.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PositionManager is ERC721Enumerable, Ownable, IPositionManager {\n    using SafeERC20 for IERC20;\n\n    struct ManagedPosition {\n        address dvpAddr;\n        uint256 strike;\n        uint256 expiry;\n        uint256 notionalUp;\n        uint256 notionalDown;\n        uint256 premium;\n        uint256 leverage;\n        uint256 cumulatedPayoff;\n    }\n\n    /// @dev Stored data by position ID\n    mapping(uint256 => ManagedPosition) internal _positions;\n\n    /// @dev The ID of the next token that will be minted. Skips 0\n    uint256 private _nextId;\n\n    // Used by TheGraph for frontend needs:\n    event Buy(address dvp, uint256 epoch, uint256 premium, address creditor);\n    event Sell(address dvp, uint256 epoch, uint256 payoff);\n\n    error CantBurnMoreThanMinted();\n    error InvalidTokenID();\n    error NotOwner();\n    error PositionExpired();\n    error AsymmetricAmount();\n\n    constructor() ERC721Enumerable() ERC721(\"Smilee V0 Trade Positions\", \"SMIL-V0-TRAD\") Ownable() {\n        _nextId = 1;\n    }\n\n    modifier isOwner(uint256 tokenId) {\n        if (ownerOf(tokenId) != msg.sender) {\n            revert NotOwner();\n        }\n        _;\n    }\n\n    // modifier isAuthorizedForToken(uint256 tokenId) {\n    //     if (!_isApprovedOrOwner(msg.sender, tokenId)) {\n    //         revert NotApproved();\n    //     }\n    //     _;\n    // }\n\n    /// @inheritdoc IPositionManager\n    function positionDetail(uint256 tokenId) external view override returns (IPositionManager.PositionDetail memory) {\n        ManagedPosition memory position = _positions[tokenId];\n        if (position.dvpAddr == address(0)) {\n            revert InvalidTokenID();\n        }\n\n        IDVP dvp = IDVP(position.dvpAddr);\n\n        Epoch memory epoch = dvp.getEpoch();\n\n        return\n            IPositionManager.PositionDetail({\n                dvpAddr: position.dvpAddr,\n                baseToken: dvp.baseToken(),\n                sideToken: dvp.sideToken(),\n                dvpFreq: epoch.frequency,\n                dvpType: dvp.optionType(),\n                strike: position.strike,\n                expiry: position.expiry,\n                premium: position.premium,\n                leverage: position.leverage,\n                notionalUp: position.notionalUp,\n                notionalDown: position.notionalDown,\n                cumulatedPayoff: position.cumulatedPayoff\n            });\n    }\n\n    /// @inheritdoc IPositionManager\n    function mint(\n        IPositionManager.MintParams calldata params\n    ) external override returns (uint256 tokenId, uint256 premium) {\n        IDVP dvp = IDVP(params.dvpAddr);\n\n        if (params.tokenId != 0) {\n            tokenId = params.tokenId;\n            ManagedPosition storage position = _positions[tokenId];\n\n            if (ownerOf(tokenId) != msg.sender) {\n                revert NotOwner();\n            }\n            // Check token compatibility:\n            if (position.dvpAddr != params.dvpAddr || position.strike != params.strike) {\n                revert InvalidTokenID();\n            }\n            Epoch memory epoch = dvp.getEpoch();\n            if (position.expiry != epoch.current) {\n                revert PositionExpired();\n            }\n        }\n        if ((params.notionalUp > 0 && params.notionalDown > 0) && (params.notionalUp != params.notionalDown)) {\n            // If amount is a smile, it must be balanced:\n            revert AsymmetricAmount();\n        }\n\n        uint256 obtainedPremium;\n        uint256 fee;\n        (obtainedPremium, fee) = dvp.premium(params.strike, params.notionalUp, params.notionalDown);\n\n        // Transfer premium:\n        // NOTE: The PositionManager is just a middleman between the user and the DVP\n        IERC20 baseToken = IERC20(dvp.baseToken());\n        baseToken.safeTransferFrom(msg.sender, address(this), obtainedPremium);\n\n        // Premium already include fee\n        baseToken.safeApprove(params.dvpAddr, obtainedPremium);\n\n        premium = dvp.mint(\n            address(this),\n            params.strike,\n            params.notionalUp,\n            params.notionalDown,\n            params.expectedPremium,\n            params.maxSlippage,\n            params.nftAccessTokenId\n        );\n\n        if (obtainedPremium > premium) {\n            baseToken.safeTransferFrom(address(this), msg.sender, obtainedPremium - premium);\n        }\n\n        if (params.tokenId == 0) {\n            // Mint token:\n            tokenId = _nextId++;\n            _mint(params.recipient, tokenId);\n\n            Epoch memory epoch = dvp.getEpoch();\n\n            // Save position:\n            _positions[tokenId] = ManagedPosition({\n                dvpAddr: params.dvpAddr,\n                strike: params.strike,\n                expiry: epoch.current,\n                premium: premium,\n                leverage: (params.notionalUp + params.notionalDown) / premium,\n                notionalUp: params.notionalUp,\n                notionalDown: params.notionalDown,\n                cumulatedPayoff: 0\n            });\n        } else {\n            ManagedPosition storage position = _positions[tokenId];\n            // Increase position:\n            position.premium += premium;\n            position.notionalUp += params.notionalUp;\n            position.notionalDown += params.notionalDown;\n            /* NOTE:\n                When, within the same epoch, a user wants to buy, sell partially\n                and then buy again, the leverage computation can fail due to\n                decreased notional; in order to avoid this issue, we have to\n                also adjust (decrease) the premium in the burn flow.\n             */\n            position.leverage = (position.notionalUp + position.notionalDown) / position.premium;\n        }\n\n        emit BuyDVP(tokenId, _positions[tokenId].expiry, params.notionalUp + params.notionalDown);\n        emit Buy(params.dvpAddr, _positions[tokenId].expiry, premium, params.recipient);\n    }\n\n    function payoff(\n        uint256 tokenId,\n        uint256 notionalUp,\n        uint256 notionalDown\n    ) external view returns (uint256 payoff_, uint256 fee) {\n        ManagedPosition storage position = _positions[tokenId];\n        return IDVP(position.dvpAddr).payoff(position.expiry, position.strike, notionalUp, notionalDown);\n    }\n\n    function sell(SellParams calldata params) external isOwner(params.tokenId) returns (uint256 payoff_) {\n        payoff_ = _sell(\n            params.tokenId,\n            params.notionalUp,\n            params.notionalDown,\n            params.expectedMarketValue,\n            params.maxSlippage\n        );\n    }\n\n    function sellAll(SellParams[] calldata params) external returns (uint256 totalPayoff_) {\n        uint256 paramsLength = params.length;\n        for (uint256 i = 0; i < paramsLength; i++) {\n            if (ownerOf(params[i].tokenId) != msg.sender) {\n                revert NotOwner();\n            }\n            totalPayoff_ += _sell(\n                params[i].tokenId,\n                params[i].notionalUp,\n                params[i].notionalDown,\n                params[i].expectedMarketValue,\n                params[i].maxSlippage\n            );\n        }\n    }\n\n    function _sell(\n        uint256 tokenId,\n        uint256 notionalUp,\n        uint256 notionalDown,\n        uint256 expectedMarketValue,\n        uint256 maxSlippage\n    ) internal returns (uint256 payoff_) {\n        ManagedPosition storage position = _positions[tokenId];\n        // NOTE: as the positions within the DVP are all of the PositionManager, we must replicate this check here.\n        if (notionalUp > position.notionalUp || notionalDown > position.notionalDown) {\n            revert CantBurnMoreThanMinted();\n        }\n\n        if ((notionalUp > 0 && notionalDown > 0) && (notionalUp != notionalDown)) {\n            // If amount is a smile, it must be balanced:\n            revert AsymmetricAmount();\n        }\n\n        // NOTE: the DVP already checks that the burned notional is lesser or equal to the position notional.\n        // NOTE: the payoff is transferred directly from the DVP\n        payoff_ = IDVP(position.dvpAddr).burn(\n            position.expiry,\n            msg.sender,\n            position.strike,\n            notionalUp,\n            notionalDown,\n            expectedMarketValue,\n            maxSlippage\n        );\n\n        // NOTE: premium fix for the leverage issue annotated in the mint flow.\n        // notional : position.notional = fix : position.premium\n        uint256 premiumFix = ((notionalUp + notionalDown) * position.premium) /\n            (position.notionalUp + position.notionalDown);\n        position.premium -= premiumFix;\n        position.cumulatedPayoff += payoff_;\n        position.notionalUp -= notionalUp;\n        position.notionalDown -= notionalDown;\n\n        if (position.notionalUp == 0 && position.notionalDown == 0) {\n            delete _positions[tokenId];\n            _burn(tokenId);\n        }\n\n        emit SellDVP(tokenId, (notionalUp + notionalDown), payoff_);\n        emit Sell(position.dvpAddr, position.expiry, payoff_);\n    }\n}"
    },
    {
      "filename": "smilee-v2-contracts/src/DVP.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IAddressProvider} from \"./interfaces/IAddressProvider.sol\";\nimport {IDVP, IDVPImmutables} from \"./interfaces/IDVP.sol\";\nimport {IEpochControls} from \"./interfaces/IEpochControls.sol\";\nimport {IFeeManager} from \"./interfaces/IFeeManager.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {Amount, AmountHelper} from \"./lib/Amount.sol\";\nimport {Epoch} from \"./lib/EpochController.sol\";\nimport {Finance} from \"./lib/Finance.sol\";\nimport {Notional} from \"./lib/Notional.sol\";\nimport {Position} from \"./lib/Position.sol\";\nimport {EpochControls} from \"./EpochControls.sol\";\nimport {VaultLib} from \"./lib/VaultLib.sol\";\n\nabstract contract DVP is IDVP, EpochControls, AccessControl, Pausable {\n    using AmountHelper for Amount;\n    using Position for Position.Info;\n    using Notional for Notional.Info;\n    using SafeERC20 for IERC20Metadata;\n\n    /// @inheritdoc IDVPImmutables\n    address public immutable override baseToken;\n    /// @inheritdoc IDVPImmutables\n    address public immutable override sideToken;\n    /// @inheritdoc IDVPImmutables\n    bool public immutable override optionType;\n    /// @inheritdoc IDVP\n    address public immutable override vault;\n\n    IAddressProvider internal immutable _addressProvider;\n    uint8 internal immutable _baseTokenDecimals;\n    uint8 internal immutable _sideTokenDecimals;\n\n    bytes32 public constant ROLE_GOD = keccak256(\"ROLE_GOD\");\n    bytes32 public constant ROLE_ADMIN = keccak256(\"ROLE_ADMIN\");\n    bytes32 public constant ROLE_EPOCH_ROLLER = keccak256(\"ROLE_EPOCH_ROLLER\");\n\n    /**\n        @notice liquidity for options indexed by epoch\n        @dev mapping epoch -> Notional.Info\n     */\n    mapping(uint256 => Notional.Info) internal _liquidity;\n\n    /**\n        @notice Users positions\n        @dev mapping epoch -> Position.getID(...) -> Position.Info\n        @dev There is an index by epoch in order to further avoid collisions within the hash of the position ID.\n     */\n    mapping(uint256 => mapping(bytes32 => Position.Info)) internal _epochPositions;\n\n    error NotEnoughNotional();\n    error PositionNotFound();\n    error CantBurnMoreThanMinted();\n    error MissingMarketOracle();\n    error MissingPriceOracle();\n    error MissingFeeManager();\n    error SlippedMarketValue();\n    error PayoffTooLow();\n    error VaultDead();\n    error OnlyPositionManager();\n\n    /**\n        @notice Emitted when option is minted for a given position\n        @param sender The address that minted the option\n        @param owner The owner of the option\n     */\n    event Mint(address sender, address indexed owner);\n\n    /**\n        @notice Emitted when a position's option is destroyed\n        @param owner The owner of the position that is being burnt\n     */\n    event Burn(address indexed owner);\n\n    event ChangedPauseState(bool paused);\n\n    constructor(\n        address vault_,\n        bool optionType_,\n        address addressProvider_\n    )\n        EpochControls(IEpochControls(vault_).getEpoch().frequency, IEpochControls(vault_).getEpoch().firstEpochTimespan)\n        AccessControl()\n        Pausable()\n    {\n        optionType = optionType_;\n        vault = vault_;\n        IVault vaultCt = IVault(vault);\n        baseToken = vaultCt.baseToken();\n        sideToken = vaultCt.sideToken();\n        _baseTokenDecimals = IERC20Metadata(baseToken).decimals();\n        _sideTokenDecimals = IERC20Metadata(sideToken).decimals();\n        _addressProvider = IAddressProvider(addressProvider_);\n\n        _setRoleAdmin(ROLE_GOD, ROLE_GOD);\n        _setRoleAdmin(ROLE_ADMIN, ROLE_GOD);\n        _setRoleAdmin(ROLE_EPOCH_ROLLER, ROLE_ADMIN);\n\n        _grantRole(ROLE_GOD, msg.sender);\n    }\n\n    /**\n        @notice Creates a new, or increases an existing, position\n        @param recipient The wallet of the recipient for the position\n        @param strike The strike of the position to mint\n        @param amount The notional of the position to mint\n        @param expectedPremium The expected premium, assumed to not consider fees, used to check against the actual premium, only known at the end of the trade\n        @param maxSlippage The maximum slippage percentage accepted between the given expected premium and the actual one\n        @return premium_ The actual paid premium\n        @dev The client must approve the expected premium + slippage percentage, if actual premium will result in more than this quantity it will revert\n     */\n    function _mint(\n        address recipient,\n        uint256 strike,\n        Amount memory amount,\n        uint256 expectedPremium,\n        uint256 maxSlippage\n    ) internal returns (uint256 premium_) {\n        _checkEpochNotFinished();\n        _requireNotPaused();\n        if (IVault(vault).dead()) {\n            revert VaultDead();\n        }\n        if (amount.up == 0 && amount.down == 0) {\n            revert AmountZero();\n        }\n        if ((amount.up > 0 && amount.down > 0) && (amount.up != amount.down)) {\n            // If amount is an unbalanced smile, only the position manager is allowed to proceed:\n            if (msg.sender != _addressProvider.dvpPositionManager()) {\n                revert OnlyPositionManager();\n            }\n        }\n\n        Epoch memory epoch = getEpoch();\n        Notional.Info storage liquidity = _liquidity[epoch.current];\n\n        // Check available liquidity:\n        Amount memory availableLiquidity = liquidity.available(strike);\n        if (availableLiquidity.up < amount.up || availableLiquidity.down < amount.down) {\n            revert NotEnoughNotional();\n        }\n\n        {\n            uint256 swapPrice = _deltaHedgePosition(strike, amount, true);\n            uint256 premiumOrac = _getMarketValue(strike, amount, true, IPriceOracle(_getPriceOracle()).getPrice(sideToken, baseToken));\n            uint256 premiumSwap = _getMarketValue(strike, amount, true, swapPrice);\n            premium_ = premiumSwap > premiumOrac ? premiumSwap : premiumOrac;\n        }\n\n        IFeeManager feeManager = IFeeManager(_getFeeManager());\n        (uint256 fee, uint256 vaultFee) = feeManager.tradeBuyFee(\n            address(this),\n            epoch.current,\n            amount.up + amount.down,\n            premium_,\n            _baseTokenDecimals\n        );\n\n        // Revert if actual price exceeds the previewed premium\n        // NOTE: cannot use the approved premium as a reference due to the PositionManager...\n        _checkSlippage(premium_ + fee, expectedPremium, maxSlippage, true);\n\n        // Get fees from sender:\n        IERC20Metadata(baseToken).safeTransferFrom(msg.sender, address(this), fee - vaultFee);\n        IERC20Metadata(baseToken).safeApprove(address(feeManager), fee - vaultFee);\n        feeManager.receiveFee(fee - vaultFee);\n\n        // Get base premium from sender:\n        IERC20Metadata(baseToken).safeTransferFrom(msg.sender, vault, premium_ + vaultFee);\n        feeManager.trackVaultFee(address(vault), vaultFee);\n\n        // Update user premium:\n        premium_ += fee;\n\n        // Decrease available liquidity:\n        liquidity.increaseUsage(strike, amount);\n\n        // Create or update position:\n        Position.Info storage position = _getPosition(epoch.current, recipient, strike);\n        position.premium += premium_;\n        position.epoch = epoch.current;\n        position.strike = strike;\n        position.amountUp += amount.up;\n        position.amountDown += amount.down;\n\n        emit Mint(msg.sender, recipient);\n    }\n\n    function _checkSlippage(\n        uint256 premium,\n        uint256 expectedpremium,\n        uint256 maxSlippage,\n        bool tradeIsBuy\n    ) internal pure {\n        if (!Finance.checkSlippage(premium, expectedpremium, maxSlippage, tradeIsBuy)) {\n            revert SlippedMarketValue();\n        }\n    }\n\n    /**\n        @notice It attempts to flat the DVP's delta by selling/buying an amount of side tokens in order to hedge the position.\n        @notice By hedging the position, we avoid the impermanent loss.\n        @param strike The position strike.\n        @param amount The position notional.\n        @param tradeIsBuy Positive if buyed by a user, negative otherwise.\n     */\n    function _deltaHedgePosition(\n        uint256 strike,\n        Amount memory amount,\n        bool tradeIsBuy\n    ) internal virtual returns (uint256 swapPrice);\n\n    /**\n        @notice Burn or decrease a position.\n        @param expiry The expiry timestamp of the position.\n        @param recipient The wallet of the recipient for the opened position.\n        @param strike The strike\n        @param amount The notional.\n        @param expectedMarketValue The expected market value when the epoch is the current one.\n        @param maxSlippage The maximum slippage percentage.\n        @return paidPayoff The paid payoff.\n     */\n    function _burn(\n        uint256 expiry,\n        address recipient,\n        uint256 strike,\n        Amount memory amount,\n        uint256 expectedMarketValue,\n        uint256 maxSlippage\n    ) internal returns (uint256 paidPayoff) {\n        _requireNotPaused();\n        Position.Info storage position = _getPosition(expiry, msg.sender, strike);\n        if (!position.exists()) {\n            revert PositionNotFound();\n        }\n\n        // // If the position reached maturity, the user must close the entire position\n        // // NOTE: we have to avoid this due to the PositionManager that holds positions for multiple tokens.\n        // if (position.epoch != epoch.current) {\n        //     amount = position.amount;\n        // }\n        if (amount.up == 0 && amount.down == 0) {\n            // NOTE: a zero amount may have some parasite effect, henct we proactively protect against it.\n            revert AmountZero();\n        }\n        if (amount.up > position.amountUp || amount.down > position.amountDown) {\n            revert CantBurnMoreThanMinted();\n        }\n        if ((amount.up > 0 && amount.down > 0) && (amount.up != amount.down)) {\n            // If amount is an unbalanced smile, only the position manager is allowed to proceed:\n            if (msg.sender != _addressProvider.dvpPositionManager()) {\n                revert OnlyPositionManager();\n            }\n        }\n\n        bool expired = expiry != getEpoch().current;\n        if (!expired) {\n            // NOTE: checked only here as expired positions needs to be burned even if the vault was killed.\n            _checkEpochNotFinished();\n\n            uint256 swapPrice = _deltaHedgePosition(strike, amount, false);\n            uint256 payoffOrac = _getMarketValue(strike, amount, false, IPriceOracle(_getPriceOracle()).getPrice(sideToken, baseToken));\n            uint256 payoffSwap = _getMarketValue(strike, amount, false, swapPrice);\n            paidPayoff = payoffSwap < payoffOrac ? payoffSwap : payoffOrac;\n            _checkSlippage(paidPayoff, expectedMarketValue, maxSlippage, false);\n        } else {\n            // Compute the payoff to be paid:\n            Amount memory payoff_ = _liquidity[expiry].shareOfPayoff(strike, amount, _baseTokenDecimals);\n            paidPayoff = payoff_.getTotal();\n\n            // Account transfer of setted aside payoff:\n            _liquidity[expiry].decreasePayoff(strike, payoff_);\n        }\n\n        // NOTE: premium fix for the leverage issue annotated in the mint flow.\n        // notional : position.notional = fix : position.premium\n        uint256 entryPremiumProp = ((amount.up + amount.down) * position.premium) /\n            (position.amountUp + position.amountDown);\n        position.premium -= entryPremiumProp;\n\n        IFeeManager feeManager = IFeeManager(_getFeeManager());\n        (uint256 fee, uint256 vaultFee) = feeManager.tradeSellFee(\n            address(this),\n            expiry,\n            amount.up + amount.down,\n            paidPayoff,\n            entryPremiumProp,\n            _baseTokenDecimals\n        );\n\n        if (paidPayoff >= fee) {\n            paidPayoff -= fee;\n        } else {\n            // if the option didn't reached maturity, vaultFee is always paid expect if vaultFee exceed paidPayoff\n            if (!expired && vaultFee > paidPayoff) {\n                revert PayoffTooLow();\n            }\n\n            // Fee becomes all paidPayoff and the user will not receive anything.\n            fee = paidPayoff;\n            paidPayoff = 0;\n\n            // if vaultFee is greater than the paidPayoff all the fee will be transfered to the Vault.\n            if (vaultFee > fee) {\n                vaultFee = fee;\n            }\n        }\n\n        // Account change of used liquidity between wallet and protocol:\n        position.amountUp -= amount.up;\n        position.amountDown -= amount.down;\n        // NOTE: must be updated after the previous computations based on used liquidity."
    }
  ]
}