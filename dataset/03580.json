{
  "Title": "No reporting on failed claimRewards attempt",
  "Content": "##### Description\nWhile a user is in debtors list, any attempt to claim rewards will be [silently ignored](https://github.com/CreamFi/liquidity-mining/blob/e7caa316e8a206b60996c199f26047b388b4ea31/contracts/LiquidityMining.sol#L469).\n##### Recommendation\nIt is recommended to report the user that claim action has been failed because of bad debt.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/LiquidityMining.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"./LiquidityMiningStorage.sol\";\nimport \"./interfaces/ComptrollerInterface.sol\";\nimport \"./interfaces/CTokenInterface.sol\";\nimport \"./interfaces/LiquidityMiningInterface.sol\";\n\ncontract LiquidityMining is Initializable, UUPSUpgradeable, OwnableUpgradeable, LiquidityMiningStorage, LiquidityMiningInterface {\n    using SafeERC20 for IERC20;\n\n    uint internal constant initialIndex = 1e18;\n    address public constant ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint public constant TOKENLESS_PRODCTION = 40;\n\n    /**\n     * @notice Emitted when a supplier's reward supply index is updated\n     */\n    event UpdateSupplierRewardIndex(\n        address indexed rewardToken,\n        address indexed cToken,\n        address indexed supplier,\n        uint rewards,\n        uint supplyIndex\n    );\n\n    /**\n     * @notice Emitted when a borrower's reward borrower index is updated\n     */\n    event UpdateBorrowerRewardIndex(\n        address indexed rewardToken,\n        address indexed cToken,\n        address indexed borrower,\n        uint rewards,\n        uint borrowIndex\n    );\n\n    /**\n     * @notice Emitted when a market's reward supply speed is updated\n     */\n    event UpdateSupplyRewardSpeed(\n        address indexed rewardToken,\n        address indexed cToken,\n        uint indexed speed,\n        uint start,\n        uint end\n    );\n\n    /**\n     * @notice Emitted when a market's reward borrow speed is updated\n     */\n    event UpdateBorrowRewardSpeed(\n        address indexed rewardToken,\n        address indexed cToken,\n        uint indexed speed,\n        uint start,\n        uint end\n    );\n\n    /**\n     * @notice Emitted when rewards are transferred to a user\n     */\n    event TransferReward(\n        address indexed rewardToken,\n        address indexed account,\n        uint indexed amount\n    );\n\n    /**\n     * @notice Emitted when a debtor is updated\n     */\n    event UpdateDebtor(\n        address indexed account,\n        bool indexed isDebtor\n    );\n\n    /**\n     * @notice Initialize the contract with admin and comptroller\n     */\n    function initialize(address _admin, address _comptroller, address _votingEscrow) initializer public {\n        __Ownable_init();\n\n        comptroller = _comptroller;\n        votingEscrow = _votingEscrow;\n        transferOwnership(_admin);\n    }\n\n    /**\n     * @notice Contract might receive ETH as one of the LM rewards.\n     */\n    receive() external payable {}\n\n    /* User functions */\n\n    /**\n     * @notice Accrue rewards to the market by updating the supply index and calculate rewards accrued by suppliers\n     * @param cToken The market whose supply index to update\n     * @param suppliers The related suppliers\n     */\n    function updateSupplyIndex(address cToken, address[] memory suppliers) external override {\n        // Distribute the rewards right away.\n        updateSupplyIndexInternal(rewardTokens, cToken, suppliers, true);\n    }\n\n    /**\n     * @notice Accrue rewards to the market by updating the borrow index and calculate rewards accrued by borrowers\n     * @param cToken The market whose borrow index to update\n     * @param borrowers The related borrowers\n     */\n    function updateBorrowIndex(address cToken, address[] memory borrowers) external override {\n        // Distribute the rewards right away.\n        updateBorrowIndexInternal(rewardTokens, cToken, borrowers, true);\n    }\n\n    /**\n     * @notice Return the current block timestamp.\n     * @return The current block timestamp\n     */\n    function getBlockTimestamp() public virtual view returns (uint) {\n        return block.timestamp;\n    }\n\n    /**\n     * @notice Return the reward token list.\n     * @return The list of reward token addresses\n     */\n    function getRewardTokenList() external view returns (address[] memory) {\n        return rewardTokens;\n    }\n\n    /**\n     * @notice Claim all the rewards accrued by holder in all markets\n     * @param holder The address to claim rewards for\n     */\n    function claimAllRewards(address holder) public {\n        address[] memory holders = new address[](1);\n        holders[0] = holder;\n        address[] memory allMarkets = ComptrollerInterface(comptroller).getAllMarkets();\n        return claimRewards(holders, allMarkets, rewardTokens, true, true);\n    }\n\n    /**\n     * @notice Claim the rewards accrued by the holders\n     * @param holders The addresses to claim rewards for\n     * @param cTokens The list of markets to claim rewards in\n     * @param rewards The list of reward tokens to claim\n     * @param borrowers Whether or not to claim rewards earned by borrowing\n     * @param suppliers Whether or not to claim rewards earned by supplying\n     */\n    function claimRewards(address[] memory holders, address[] memory cTokens, address[] memory rewards, bool borrowers, bool suppliers) public {\n        for (uint i = 0; i < cTokens.length; i++) {\n            address cToken = cTokens[i];\n            (bool isListed, , ) = ComptrollerInterface(comptroller).markets(cToken);\n            require(isListed, \"market must be listed\");\n\n            // Same reward generated from multiple markets could aggregate and distribute once later for gas consumption.\n            if (borrowers) {\n                updateBorrowIndexInternal(rewards, cToken, holders, false);\n            }\n            if (suppliers) {\n                updateSupplyIndexInternal(rewards, cToken, holders, false);\n            }\n        }\n\n        // Distribute the rewards.\n        for (uint i = 0; i < rewards.length; i++) {\n            for (uint j = 0; j < holders.length; j++) {\n                address rewardToken = rewards[i];\n                address holder = holders[j];\n                rewardAccrued[rewardToken][holder] = transferReward(rewardToken, holder, rewardAccrued[rewardToken][holder]);\n            }\n        }\n    }\n\n    /**\n     * @notice Update accounts to be debtors or not. Debtors couldn't claim rewards until their bad debts are repaid.\n     * @param accounts The list of accounts to be updated\n     */\n    function updateDebtors(address[] memory accounts) external {\n        for (uint i = 0; i < accounts.length; i++) {\n            address account = accounts[i];\n            (uint err, , uint shortfall) = ComptrollerInterface(comptroller).getAccountLiquidity(account);\n            require(err == 0, \"failed to get account liquidity from comptroller\");\n\n            if (shortfall > 0 && !debtors[account]) {\n                debtors[account] = true;\n                emit UpdateDebtor(account, true);\n            } else if (shortfall == 0 && debtors[account]) {\n                debtors[account] = false;\n                emit UpdateDebtor(account, false);\n            }\n        }\n    }\n\n    /* Admin functions */\n\n    /**\n     * @notice Add new reward token. Revert if the reward token has been added\n     * @param rewardToken The new reward token\n     */\n    function _addRewardToken(address rewardToken) external onlyOwner {\n        require(!rewardTokensMap[rewardToken], \"reward token has been added\");\n        rewardTokensMap[rewardToken] = true;\n        rewardTokens.push(rewardToken);\n    }\n\n    /**\n     * @notice Set cTokens reward supply speeds\n     * @param rewardToken The reward token\n     * @param cTokens The addresses of cTokens\n     * @param speeds The list of reward speeds\n     * @param starts The list of start timestamps\n     * @param ends The list of end timestamps\n     */\n    function _setRewardSupplySpeeds(address rewardToken, address[] memory cTokens, uint[] memory speeds, uint[] memory starts, uint[] memory ends) external onlyOwner {\n        _setRewardSpeeds(rewardToken, cTokens, speeds, starts, ends, true);\n    }\n\n    /**\n     * @notice Set cTokens reward borrow speeds\n     * @param rewardToken The reward token\n     * @param cTokens The addresses of cTokens\n     * @param speeds The list of reward speeds\n     * @param starts The list of start timestamps\n     * @param ends The list of end timestamps\n     */\n    function _setRewardBorrowSpeeds(address rewardToken, address[] memory cTokens, uint[] memory speeds, uint[] memory starts, uint[] memory ends) external onlyOwner {\n        _setRewardSpeeds(rewardToken, cTokens, speeds, starts, ends, false);\n    }\n\n    /* Internal functions */\n\n    /**\n     * @dev _authorizeUpgrade is used by UUPSUpgradeable to determine if it's allowed to upgrade a proxy implementation.\n     * @param newImplementation The new implementation\n     *\n     * Ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/UUPSUpgradeable.sol\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /**\n     * @notice Given the reward token list, accrue rewards to the market by updating the supply index and calculate rewards accrued by suppliers\n     * @param rewards The list of rewards to update\n     * @param cToken The market whose supply index to update\n     * @param suppliers The related suppliers\n     * @param distribute Distribute the reward or not\n     */\n    function updateSupplyIndexInternal(address[] memory rewards, address cToken, address[] memory suppliers, bool distribute) internal {\n        for (uint i = 0; i < rewards.length; i++) {\n            require(rewardTokensMap[rewards[i]], \"reward token not support\");\n            updateGlobalSupplyIndex(rewards[i], cToken);\n            for (uint j = 0; j < suppliers.length; j++) {\n                updateUserSupplyIndex(rewards[i], cToken, suppliers[j], distribute);\n                updateWorkingSupply(rewards[i], cToken, suppliers[j]);\n            }\n        }\n    }\n\n    /**\n     * @notice Given the reward token list, accrue rewards to the market by updating the borrow index and calculate rewards accrued by borrowers\n     * @param rewards The list of rewards to update\n     * @param cToken The market whose borrow index to update\n     * @param borrowers The related borrowers\n     * @param distribute Distribute the reward or not\n     */\n    function updateBorrowIndexInternal(address[] memory rewards, address cToken, address[] memory borrowers, bool distribute) internal {\n        for (uint i = 0; i < rewards.length; i++) {\n            require(rewardTokensMap[rewards[i]], \"reward token not support\");\n\n            updateGlobalBorrowIndex(rewards[i], cToken);\n            for (uint j = 0; j < borrowers.length; j++) {\n                updateUserBorrowIndex(rewards[i], cToken, borrowers[j], distribute);\n                updateWorkingBorrows(rewards[i], cToken, borrowers[j]);\n            }\n        }\n    }\n\n    /**\n     * @notice Accrue rewards to the market by updating the supply index\n     * @param rewardToken The reward token\n     * @param cToken The market whose supply index to update\n     */\n    function updateGlobalSupplyIndex(address rewardToken, address cToken) internal {\n        RewardState storage supplyState = rewardSupplyState[rewardToken][cToken];\n        RewardSpeed memory supplySpeed = rewardSupplySpeeds[rewardToken][cToken];\n        uint timestamp = getBlockTimestamp();\n        if (timestamp > supplyState.timestamp) {\n            if (supplySpeed.speed == 0 || supplySpeed.start > timestamp || supplyState.timestamp > supplySpeed.end) {\n                // 1. The reward speed is zero,\n                // 2. The reward hasn't started yet,\n                // 3. The supply state has handled the end of the reward,\n                // just update the timestamp.\n                supplyState.timestamp = timestamp;\n            } else {\n                // fromTimestamp is the max of the last update block timestamp and the reward start block timestamp.\n                uint fromTimestamp = max(supplyState.timestamp, supplySpeed.start);\n                // toTimestamp is the min of the current block timestamp and the reward end block timestamp.\n                uint toTimestamp = min(timestamp, supplySpeed.end);\n                // deltaTime is the time difference used for calculating the rewards.\n                uint deltaTime = toTimestamp - fromTimestamp;\n                uint rewardAccrued = deltaTime * supplySpeed.speed;\n                uint totalSupply = workingTotalSupply[rewardToken][cToken];\n                uint ratio = totalSupply > 0 ? rewardAccrued * 1e18 / totalSupply : 0;\n                uint index = supplyState.index + ratio;\n                rewardSupplyState[rewardToken][cToken] = RewardState({\n                    index: index,\n                    timestamp: timestamp\n                });\n            }\n        }\n    }\n\n    /**\n     * @notice Accrue rewards to the market by updating the borrow index\n     * @param rewardToken The reward token\n     * @param cToken The market whose borrow index to update\n     */\n    function updateGlobalBorrowIndex(address rewardToken, address cToken) internal {\n        RewardState storage borrowState = rewardBorrowState[rewardToken][cToken];\n        RewardSpeed memory borrowSpeed = rewardBorrowSpeeds[rewardToken][cToken];\n        uint timestamp = getBlockTimestamp();\n        if (timestamp > borrowState.timestamp) {\n            if (borrowSpeed.speed == 0 || timestamp < borrowSpeed.start || borrowState.timestamp > borrowSpeed.end) {\n                // 1. The reward speed is zero,\n                // 2. The reward hasn't started yet,\n                // 3. The borrow state has handled the end of the reward,\n                // just update the timestamp.\n                borrowState.timestamp = timestamp;\n            } else {\n                // fromTimestamp is the max of the last update block timestamp and the reward start block timestamp.\n                uint fromTimestamp = max(borrowState.timestamp, borrowSpeed.start);\n                // toTimestamp is the min of the current block timestamp and the reward end block timestamp.\n                uint toTimestamp = min(timestamp, borrowSpeed.end);\n                // deltaTime is the time difference used for calculating the rewards.\n                uint deltaTime = toTimestamp - fromTimestamp;\n                uint rewardAccrued = deltaTime * borrowSpeed.speed;\n                uint totalBorrows = workingTotalBorrows[rewardToken][cToken];\n                uint ratio = totalBorrows > 0 ? rewardAccrued * 1e18 / totalBorrows : 0;\n                uint index = borrowState.index + ratio;\n                rewardBorrowState[rewardToken][cToken] = RewardState({\n                    index: index,\n                    timestamp: timestamp\n                });\n            }\n        }\n    }\n\n    /**\n     * @notice Calculate rewards accrued by a supplier and possibly transfer it to them\n     * @dev Suppliers will not begin to accrue until after the first interaction with the protocol.\n     * @param rewardToken The reward token\n     * @param cToken The market in which the supplier is interacting\n     * @param supplier The address of the supplier to distribute rewards to\n     * @param distribute Distribute the reward or not\n     */\n    function updateUserSupplyIndex(address rewardToken, address cToken, address supplier, bool distribute) internal {\n        RewardState memory supplyState = rewardSupplyState[rewardToken][cToken];\n        uint supplyIndex = supplyState.index;\n        uint supplierIndex = rewardSupplierIndex[rewardToken][cToken][supplier];\n        rewardSupplierIndex[rewardToken][cToken][supplier] = supplyIndex;\n\n        if (supplierIndex > 0) {\n            uint deltaIndex = supplyIndex - supplierIndex;\n            uint workingSupply = userWorkingSupply[rewardToken][cToken][supplier];\n            uint supplierDelta = workingSupply * deltaIndex / 1e18;\n            uint accruedAmount = rewardAccrued[rewardToken][supplier] + supplierDelta;\n            if (distribute) {\n                rewardAccrued[rewardToken][supplier] = transferReward(rewardToken, supplier, accruedAmount);\n            } else {\n                rewardAccrued[rewardToken][supplier] = accruedAmount;\n            }\n            emit UpdateSupplierRewardIndex(rewardToken, cToken, supplier, supplierDelta, supplyIndex);\n        }\n    }\n\n    /**\n     * @notice Calculate rewards accrued by a borrower and possibly transfer it to them\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\n     * @param rewardToken The reward token\n     * @param cToken The market in which the borrower is interacting\n     * @param borrower The address of the borrower to distribute rewards to\n     * @param distribute Distribute the reward or not\n     */\n    function updateUserBorrowIndex(address rewardToken, address cToken, address borrower, bool distribute) internal {\n        RewardState memory borrowState = rewardBorrowState[rewardToken][cToken];\n        uint borrowIndex = borrowState.index;\n        uint borrowerIndex = rewardBorrowerIndex[rewardToken][cToken][borrower];\n        rewardBorrowerIndex[rewardToken][cToken][borrower] = borrowIndex;\n\n        if (borrowerIndex > 0) {\n            uint deltaIndex = borrowIndex - borrowerIndex;\n            uint workingBorrows = userWorkingBorrows[rewardToken][cToken][borrower];\n            uint borrowerDelta = workingBorrows * deltaIndex / 1e18;\n            uint accruedAmount = rewardAccrued[rewardToken][borrower] + borrowerDelta;\n            if (distribute) {\n                rewardAccrued[rewardToken][borrower] = transferReward(rewardToken, borrower, accruedAmount);\n            } else {\n                rewardAccrued[rewardToken][borrower] = accruedAmount;\n            }\n            emit UpdateBorrowerRewardIndex(rewardToken, cToken, borrower, borrowerDelta, borrowIndex);\n        }\n    }\n\n    /**\n     * @notice Update user working supply and working total supply\n     * @param rewardToken The reward token\n     * @param cToken The market in which the supplier is interacting\n     * @param supplier The address of the supplier to distribute rewards to\n     */\n    function updateWorkingSupply(address rewardToken, address cToken, address supplier) internal {\n        // update working supply, working total supply\n        uint votingBalance = IERC20(votingEscrow).balanceOf(supplier);\n        uint votingTotal = IERC20(votingEscrow).totalSupply();\n\n        // NOTE: make sure update user supply index call after ctoken update (verify hook)\n        uint supply = CTokenInterface(cToken).balanceOf(supplier);\n        uint newWorkingSupply = supply * TOKENLESS_PRODCTION / 100;\n        if (votingTotal > 0) {\n          newWorkingSupply += CTokenInterface(cToken).totalSupply() * votingBalance / votingTotal * (100 - TOKENLESS_PRODCTION) / 100;\n        }\n        newWorkingSupply = min(newWorkingSupply, supply);\n\n        uint oldWorkingSupply = userWorkingSupply[rewardToken][cToken][supplier];\n        userWorkingSupply[rewardToken][cToken][supplier] = newWorkingSupply;\n        workingTotalSupply[rewardToken][cToken] = workingTotalSupply[rewardToken][cToken] + newWorkingSupply - oldWorkingSupply;\n    }\n\n    /**\n     * @notice Update user working borrows and working total borrows\n     * @param rewardToken The reward token\n     * @param cToken The market in which the borrower is interacting\n     * @param borrower The address of the borrower to distribute rewards to\n     */\n    function updateWorkingBorrows(address rewardToken, address cToken, address borrower) internal {\n        uint marketBorrowIndex = CTokenInterface(cToken).borrowIndex();\n        uint votingBalance = IERC20(votingEscrow).balanceOf(borrower);\n        uint votingTotal = IERC20(votingEscrow).totalSupply();\n\n        // NOTE: make sure update user supply index call after ctoken update (verify hook)\n        uint borrows = CTokenInterface(cToken).borrowBalanceStored(borrower) * 1e18 / marketBorrowIndex;\n        uint newWorkingBorrows = borrows * TOKENLESS_PRODCTION / 100;\n\n        if (votingTotal > 0) {\n          newWorkingBorrows += CTokenInterface(cToken).totalBorrows() * 1e18 / marketBorrowIndex * votingBalance / votingTotal * (100 - TOKENLESS_PRODCTION) / 100;\n        }\n        newWorkingBorrows = min(newWorkingBorrows, borrows);\n\n        uint oldWorkingBorrows = userWorkingBorrows[rewardToken][cToken][borrower];\n        userWorkingBorrows[rewardToken][cToken][borrower] = newWorkingBorrows;\n        workingTotalBorrows[rewardToken][cToken] = workingTotalBorrows[rewardToken][cToken] + newWorkingBorrows - oldWorkingBorrows;\n    }\n\n\n    /**\n     * @notice Transfer rewards to the user\n     * @param rewardToken The reward token\n     * @param user The address of the user to transfer rewards to\n     * @param amount The amount of rewards to (possibly) transfer\n     * @return The amount of rewards which was NOT transferred to the user\n     */\n    function transferReward(address rewardToken, address user, uint amount) internal returns (uint) {\n        uint remain = rewardToken == ethAddress ? address(this).balance : IERC20(rewardToken).balanceOf(address(this));\n        if (amount > 0 && amount <= remain && !debtors[user]) {\n            if (rewardToken == ethAddress) {\n                payable(user).transfer(amount);\n            } else {\n                IERC20(rewardToken).safeTransfer(user, amount);\n            }\n            emit TransferReward(rewardToken, user, amount);\n            return 0;\n        }\n        return amount;\n    }\n\n    /**\n     * @notice Set reward speeds\n     * @param rewardToken The reward token\n     * @param cTokens The addresses of cTokens\n     * @param speeds The list of reward speeds\n     * @param starts The list of start timestamps\n     * @param ends The list of end timestamp\n     * @param supply It's supply speed or borrow speed\n     */\n    function _setRewardSpeeds(address rewardToken, address[] memory cTokens, uint[] memory speeds, uint[] memory starts, uint[] memory ends, bool supply) internal {\n        uint timestamp = getBlockTimestamp();\n        uint numMarkets = cTokens.length;\n        require(numMarkets != 0 && numMarkets == speeds.length && numMarkets == starts.length && numMarkets == ends.length, \"invalid input\");\n        require(rewardTokensMap[rewardToken], \"reward token was not added\");\n\n        for (uint i = 0; i < numMarkets; i++) {\n            address cToken = cTokens[i];\n            uint speed = speeds[i];\n            uint start = starts[i];\n            uint end = ends[i];\n            if (supply) {\n                if (isSupplyRewardStateInit(rewardToken, cToken)) {\n                    // Update the supply index.\n                    updateGlobalSupplyIndex(rewardToken, cToken);\n                } else {\n                    // Initialize the supply index.\n                    rewardSupplyState[rewardToken][cToken] = RewardState({\n                        index: initialIndex,\n                        timestamp: timestamp\n                    });\n                }\n\n                validateRewardContent(rewardSupplySpeeds[rewardToken][cToken], start, end);\n                rewardSupplySpeeds[rewardToken][cToken] = RewardSpeed({\n                    speed: speed,\n                    start: start,\n                    end: end\n                });\n                emit UpdateSupplyRewardSpeed(rewardToken, cToken, speed, start, end);\n            } else {\n                if (isBorrowRewardStateInit(rewardToken, cToken)) {\n                    // Update the borrow index.\n                    updateGlobalBorrowIndex(rewardToken, cToken);\n                } else {\n                    // Initialize the borrow index.\n                    rewardBorrowState[rewardToken][cToken] = RewardState({\n                        index: initialIndex,\n                        timestamp: timestamp\n                    });\n                }\n\n                validateRewardContent(rewardBorrowSpeeds[rewardToken][cToken], start, end);\n                rewardBorrowSpeeds[rewardToken][cToken] = RewardSpeed({\n                    speed: speed,\n                    start: start,\n                    end: end\n                });\n                emit UpdateBorrowRewardSpeed(rewardToken, cToken, speed, start, end);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to tell if the supply reward state is initialized or not.\n     * @param rewardToken The reward token\n     * @param cToken The market\n     * @return It's initialized or not\n     */\n    function isSupplyRewardStateInit(address rewardToken, address cToken) internal view returns (bool) {\n        return rewardSupplyState[rewardToken][cToken].index != 0 && rewardSupplyState[rewardToken][cToken].timestamp != 0;\n    }\n\n    /**\n     * @notice Internal function to tell if the borrow reward state is initialized or not.\n     * @param rewardToken The reward token\n     * @param cToken The market\n     * @return It's initialized or not\n     */\n    function isBorrowRewardStateInit(address rewardToken, address cToken) internal view returns (bool) {\n        return rewardBorrowState[rewardToken][cToken].index != 0 && rewardBorrowState[rewardToken][cToken].timestamp != 0;\n    }\n\n    /**\n     * @notice Internal function to check the new start block timestamp and the end block timestamp.\n     * @dev This function will revert if any validation failed.\n     * @param currentSpeed The current reward speed\n     * @param newStart The new start timestamp\n     * @param newEnd The new end block timestamp\n     */\n    function validateRewardContent(RewardSpeed memory currentSpeed, uint newStart, uint newEnd) internal view {\n        uint timestamp = getBlockTimestamp();\n        require(newEnd >= timestamp, \"the end timestamp must be greater than the current timestamp\");\n        require(newEnd >= newStart, \"the end timestamp must be greater than the start timestamp\");\n        if (timestamp < currentSpeed.end && timestamp > currentSpeed.start && currentSpeed.start != 0) {\n            require(currentSpeed.start == newStart, \"cannot change the start timestamp after the reward starts\");\n        }\n    }\n\n    /**\n     * @notice Internal function to get the min value of two.\n     * @param a The first value\n     * @param b The second value\n     * @return The min one\n     */\n    function min(uint a, uint b) internal pure returns (uint) {\n        if (a < b) {\n            return a;\n        }\n        return b;\n    }\n\n    /**\n     * @notice Internal function to get the max value of two.\n     * @param a The first value\n     * @param b The second value\n     * @return The max one\n     */\n    function max(uint a, uint b) internal pure returns (uint) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n}"
    }
  ]
}