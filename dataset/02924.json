{
  "Title": "M-17: `Comptroller::withdrawRewards` accounting error results in incorrect inflation index",
  "Content": "# Issue M-17: `Comptroller::withdrawRewards` accounting error results in incorrect inflation index \n\nSource: https://github.com/sherlock-audit/2022-10-union-finance-judging/issues/26 \n\n## Found by \nJeiwan, Lambda, dipp, lemonmon\n\n## Summary\n\nIn `Comptroller::withdrawRewards`, `totalFrozen` was subtracted twice from `totalStaked`, which will update `Comptroller::gInflationIndex` based on incorrect information.\nAlso, if more than half of `totalStaked` is frozen, the `Comptroller::withdrawRewards` will revert, so no one can call `UserManager::stake` or `UserManager::unstake`.\n\n## Vulnerability Detail\n\nIn `Comptroller:withdrawRewards` calls `_getUserManagerState` and saves it as `userManagerState`:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/token/Comptroller.sol?plain=1#L248\n\nNote that returned value of `userManagerState.totalStaked` is equivalent to `userManager.totalStaked() - userManager.totalFrozen()`:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/token/Comptroller.sol?plain=1#L306-L317\n\nHowever, in the `Comptroller::withdrawRewards` function, the returned value `userManagerState.totalStaked` will be subtracted by totalFrozen again:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/token/Comptroller.sol?plain=1#L260-L261\n\nSo, the `totalStaked_` is equivalent to `userManager.totalStaked() - 2 * userManager.totalFrozen()`, which was used to calculate `gInflationIndex` in the line 261 of `Comptroller.sol`. It will result in incorrect update of the `gInflationIndex`.\n\nMoreover, if more than half of total staked values are frozen, the line 260 in Comptroller.sol will revert from underflow. The `Comptroller::withdrawRewards` function is used in `UserManager::stake`, `UserManager::unstake` and `UserManager::withdrawRewards`, thus all of these function will stop working when the condition is met.\n\n## Impact\n\n- Updated to incorrect `gInflationIndex`\n- Revert when more than half of total staked is frozen\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/token/Comptroller.sol?plain=1#L248\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/token/Comptroller.sol?plain=1#L306-L317\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/token/Comptroller.sol?plain=1#L260-L261\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nthe following line \n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/token/Comptroller.sol?plain=1#L248\n\nshould be:\n\n```solidity\n        uint256 totalStaked_ = userManagerState.totalStaked;\n```\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/11",
  "Code": [
    {
      "filename": "union-v2-contracts/contracts/token/Comptroller.sol?plain=1",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {Controller} from \"../Controller.sol\";\nimport {WadRayMath} from \"../WadRayMath.sol\";\nimport {IComptroller} from \"../interfaces/IComptroller.sol\";\nimport {IMarketRegistry} from \"../interfaces/IMarketRegistry.sol\";\nimport {IUserManager} from \"../interfaces/IUserManager.sol\";\n\n/**\n *  @author Compound -> Union Finance\n *  @title Comptroller\n *  @dev  For the time being, only the reward calculation of a single\n *        token is supported, and the contract needs to be revised after\n *        determining the reward calculation scheme of multiple tokens\n */\ncontract Comptroller is Controller, IComptroller {\n    using WadRayMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /* -------------------------------------------------------------------\n      Types \n    ------------------------------------------------------------------- */\n\n    struct Info {\n        uint256 updatedBlock; //last withdraw rewards block\n        uint256 inflationIndex; //last withdraw rewards inflationIndex\n        uint256 accrued; //the unionToken accrued but not yet transferred to each user\n    }\n\n    struct UserManagerState {\n        uint256 totalFrozen;\n        uint256 totalStaked;\n    }\n\n    struct UserManagerAccountState {\n        uint256 totalStaked;\n        uint256 totalFrozen;\n        uint256 totalLocked;\n        uint256 pastBlocksFrozenCoinAge;\n        bool isMember;\n    }\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Initial inflation index\n     */\n    uint256 public constant INIT_INFLATION_INDEX = 10**18;\n\n    /**\n     * @dev Non member reward multiplier rate (75%)\n     */\n    uint256 public constant nonMemberRatio = 75 * 10**16; // 75%;\n\n    /**\n     * @dev Member reward multiplier rate (100%)\n     */\n    uint256 public constant memberRatio = 10**18;\n\n    /**\n     * @dev Half decay point to reduce rewards at\n     */\n    uint256 public halfDecayPoint;\n\n    /**\n     * @dev store the latest inflation index\n     */\n    uint256 public gInflationIndex;\n\n    /**\n     * @dev block number when updating the inflation index\n     */\n    uint256 public gLastUpdatedBlock;\n\n    /**\n     * @dev $UNION token contract\n     */\n    IERC20Upgradeable public unionToken;\n\n    /**\n     * @dev The market registry contract\n     */\n    IMarketRegistry public marketRegistry;\n\n    /**\n     * @dev Map account to token to Info\n     */\n    mapping(address => mapping(address => Info)) public users;\n\n    /* -------------------------------------------------------------------\n      Events \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Withdraw rewards event\n     *  @param account The staker's address\n     *  @param amount The amount of Union tokens to withdraw\n     */\n    event LogWithdrawRewards(address indexed account, uint256 amount);\n\n    /* -------------------------------------------------------------------\n      Errors\n    ------------------------------------------------------------------- */\n\n    error SenderNotUserManager();\n    error NotZero();\n    error FrozenCoinAge();\n    error InflationIndexTooSmall();\n\n    /* -------------------------------------------------------------------\n      Constructor/Initializer \n    ------------------------------------------------------------------- */\n\n    function __Comptroller_init(\n        address unionToken_,\n        address marketRegistry_,\n        uint256 _halfDecayPoint\n    ) public initializer {\n        Controller.__Controller_init(msg.sender);\n\n        gInflationIndex = INIT_INFLATION_INDEX;\n        gLastUpdatedBlock = block.number;\n\n        unionToken = IERC20Upgradeable(unionToken_);\n        marketRegistry = IMarketRegistry(marketRegistry_);\n        halfDecayPoint = _halfDecayPoint;\n    }\n\n    /* -------------------------------------------------------------------\n      Modifiers \n    ------------------------------------------------------------------- */\n\n    modifier onlyUserManager(address token) {\n        if (msg.sender != address(_getUserManager(token))) revert SenderNotUserManager();\n        _;\n    }\n\n    /* -------------------------------------------------------------------\n      Setters \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Set the half decay point\n     */\n    function setHalfDecayPoint(uint256 point) public onlyAdmin {\n        if (point == 0) revert NotZero();\n        halfDecayPoint = point;\n    }\n\n    /* -------------------------------------------------------------------\n      View Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Get the reward multipier based on the account status\n     *  @param account Account address\n     *  @param token ERC20 token address\n     *  @return Multiplier number (in wei)\n     */\n    function getRewardsMultiplier(address account, address token) external view override returns (uint256) {\n        IUserManager userManagerContract = _getUserManager(token);\n        uint256 stakingAmount = userManagerContract.getStakerBalance(account);\n        uint256 lockedStake = userManagerContract.getTotalLockedStake(account);\n        (uint256 totalFrozen, ) = userManagerContract.getFrozenInfo(account, block.number);\n        bool isMember = userManagerContract.checkIsMember(account);\n        return _getRewardsMultiplier(stakingAmount, lockedStake, totalFrozen, isMember);\n    }\n\n    /**\n     *  @dev Calculate unclaimed rewards based on blocks\n     *  @param account User address\n     *  @param token Staking token address\n     *  @param futureBlocks Number of blocks in the future\n     *  @return Unclaimed rewards\n     */\n    function calculateRewardsByBlocks(\n        address account,\n        address token,\n        uint256 futureBlocks\n    ) public view override returns (uint256) {\n        IUserManager userManager = _getUserManager(token);\n\n        // Lookup account stataddress accounte from UserManager\n        (\n            UserManagerAccountState memory userManagerAccountState,\n            Info memory userInfo,\n            uint256 pastBlocks\n        ) = _getUserInfoView(userManager, account, token, futureBlocks);\n\n        // Lookup global state from UserManager\n        UserManagerState memory userManagerState = _getUserManagerState(userManager);\n\n        return\n            _calculateRewardsByBlocks(account, token, pastBlocks, userInfo, userManagerState, userManagerAccountState);\n    }\n\n    /**\n     *  @dev Calculate currently unclaimed rewards\n     *  @param account Account address\n     *  @param token Staking token address\n     *  @return Unclaimed rewards\n     */\n    function calculateRewards(address account, address token) external view override returns (uint256) {\n        return calculateRewardsByBlocks(account, token, 0);\n    }\n\n    /**\n     *  @dev Calculate inflation per block\n     *  @param effectiveTotalStake Effective total stake\n     *  @return Inflation amount, div totalSupply is the inflation rate\n     */\n    function inflationPerBlock(uint256 effectiveTotalStake) public view returns (uint256) {\n        return _inflationPerBlock(effectiveTotalStake);\n    }\n\n    /* -------------------------------------------------------------------\n      Core Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Withdraw rewards\n     *  @param token Staking token address\n     *  @return Amount of rewards\n     */\n    function withdrawRewards(address account, address token)\n        external\n        override\n        whenNotPaused\n        onlyUserManager(token)\n        returns (uint256)\n    {\n        IUserManager userManager = _getUserManager(token);\n\n        // Lookup account state from UserManager\n        (\n            UserManagerAccountState memory userManagerAccountState,\n            Info memory userInfo,\n            uint256 pastBlocks\n        ) = _getUserInfo(userManager, account, token, 0);\n\n        // Lookup global state from UserManager\n        UserManagerState memory userManagerState = _getUserManagerState(userManager);\n\n        uint256 amount = _calculateRewardsByBlocks(\n            account,\n            token,\n            pastBlocks,\n            userInfo,\n            userManagerState,\n            userManagerAccountState\n        );\n\n        // update the global states\n        uint256 totalStaked_ = userManagerState.totalStaked - userManagerState.totalFrozen;\n        gInflationIndex = _getInflationIndexNew(totalStaked_, block.number - gLastUpdatedBlock);\n        gLastUpdatedBlock = block.number;\n        users[account][token].updatedBlock = block.number;\n        users[account][token].inflationIndex = gInflationIndex;\n        if (unionToken.balanceOf(address(this)) >= amount && amount > 0) {\n            unionToken.safeTransfer(account, amount);\n            users[account][token].accrued = 0;\n            emit LogWithdrawRewards(account, amount);\n\n            return amount;\n        } else {\n            users[account][token].accrued = amount;\n            emit LogWithdrawRewards(account, 0);\n\n            return 0;\n        }\n    }\n\n    /**\n     *  @dev When total staked change update inflation index\n     *  @param totalStaked totalStaked amount\n     *  @return Whether succeeded\n     */\n    function updateTotalStaked(address token, uint256 totalStaked)\n        external\n        override\n        whenNotPaused\n        onlyUserManager(token)\n        returns (bool)\n    {\n        if (totalStaked > 0) {\n            gInflationIndex = _getInflationIndexNew(totalStaked, block.number - gLastUpdatedBlock);\n        }\n        gLastUpdatedBlock = block.number;\n\n        return true;\n    }\n\n    /* -------------------------------------------------------------------\n       Internal Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Get UserManager global state values\n     */\n    function _getUserManagerState(IUserManager userManager) internal view returns (UserManagerState memory) {\n        UserManagerState memory userManagerState;\n\n        userManagerState.totalFrozen = userManager.totalFrozen();\n        userManagerState.totalStaked = userManager.totalStaked() - userManagerState.totalFrozen;\n        if (userManagerState.totalStaked < 1e18) {\n            userManagerState.totalStaked = 1e18;\n        }\n\n        return userManagerState;\n    }\n\n    /**\n     * @dev Get UserManager user specific state (view function does NOT update UserManage state)\n     * @param userManager UserManager contract\n     * @param account Account address\n     * @param token Token address\n     * @param futureBlocks Blocks in the future\n     */\n    function _getUserInfoView(\n        IUserManager userManager,\n        address account,\n        address token,\n        uint256 futureBlocks\n    )\n        internal\n        view\n        returns (\n            UserManagerAccountState memory,\n            Info memory,\n            uint256\n        )\n    {\n        Info memory userInfo = users[account][token];\n        uint256 lastUpdatedBlock = userInfo.updatedBlock;\n        if (block.number < lastUpdatedBlock) {\n            lastUpdatedBlock = block.number;\n        }\n\n        uint256 pastBlocks = block.number - lastUpdatedBlock + futureBlocks;\n\n        UserManagerAccountState memory userManagerAccountState;\n        (userManagerAccountState.totalFrozen, userManagerAccountState.pastBlocksFrozenCoinAge) = userManager\n            .getFrozenInfo(account, pastBlocks);\n\n        return (userManagerAccountState, userInfo, pastBlocks);\n    }\n\n    /**\n     * @dev Get UserManager user specific state (function does update UserManage state)\n     * @param userManager UserManager contract\n     * @param account Account address\n     * @param token Token address\n     * @param futureBlocks Blocks in the future\n     */\n    function _getUserInfo(\n        IUserManager userManager,\n        address account,\n        address token,\n        uint256 futureBlocks\n    )\n        internal\n        returns (\n            UserManagerAccountState memory,\n            Info memory,\n            uint256\n        )\n    {\n        Info memory userInfo = users[account][token];\n        uint256 lastUpdatedBlock = userInfo.updatedBlock;\n        if (block.number < lastUpdatedBlock) {\n            lastUpdatedBlock = block.number;\n        }\n\n        uint256 pastBlocks = block.number - lastUpdatedBlock + futureBlocks;\n\n        UserManagerAccountState memory userManagerAccountState;\n        (userManagerAccountState.totalFrozen, userManagerAccountState.pastBlocksFrozenCoinAge) = userManager\n            .updateFrozenInfo(account, pastBlocks);\n\n        return (userManagerAccountState, userInfo, pastBlocks);\n    }\n\n    /**\n     *  @dev Calculate currently unclaimed rewards\n     *  @param account Account address\n     *  @param token Staking token address\n     *  @param userManagerState User manager global state\n     *  @return Unclaimed rewards\n     */\n    function _calculateRewardsByBlocks(\n        address account,\n        address token,\n        uint256 pastBlocks,\n        Info memory userInfo,\n        UserManagerState memory userManagerState,\n        UserManagerAccountState memory userManagerAccountState\n    ) internal view returns (uint256) {\n        IUserManager userManagerContract = _getUserManager(token);\n\n        // Lookup account state from UserManager\n        userManagerAccountState.totalStaked = userManagerContract.getStakerBalance(account);\n        userManagerAccountState.totalLocked = userManagerContract.getTotalLockedStake(account);\n        userManagerAccountState.isMember = userManagerContract.checkIsMember(account);\n\n        uint256 inflationIndex = _getRewardsMultiplier(\n            userManagerAccountState.totalStaked,\n            userManagerAccountState.totalLocked,\n            userManagerAccountState.totalFrozen,\n            userManagerAccountState.isMember\n        );\n\n        return\n            userInfo.accrued +\n            _calculateRewards(\n                account,\n                token,\n                userManagerState.totalStaked,\n                userManagerAccountState.totalStaked,\n                userManagerAccountState.pastBlocksFrozenCoinAge,\n                pastBlocks,\n                inflationIndex\n            );\n    }\n\n    /**\n     *  @dev Calculate new inflation index based on # of blocks\n     *  @param totalStaked_ Number of total staked tokens in the system\n     *  @param blockDelta Number of blocks\n     *  @return New inflation index\n     */\n    function _getInflationIndexNew(uint256 totalStaked_, uint256 blockDelta) internal view returns (uint256) {\n        if (totalStaked_ == 0) return INIT_INFLATION_INDEX;\n        if (blockDelta == 0) return gInflationIndex;\n        return _getInflationIndex(totalStaked_, gInflationIndex, blockDelta);\n    }\n\n    function _calculateRewards(\n        address account,\n        address token,\n        uint256 totalStaked,\n        uint256 userStaked,\n        uint256 frozenCoinAge,\n        uint256 pastBlocks,\n        uint256 inflationIndex\n    ) internal view returns (uint256) {\n        uint256 startInflationIndex = users[account][token].inflationIndex;\n        if (userStaked * pastBlocks < frozenCoinAge) revert FrozenCoinAge();\n\n        if (userStaked == 0 || totalStaked == 0 || startInflationIndex == 0 || pastBlocks == 0) {\n            return 0;\n        }\n\n        uint256 effectiveStakeAmount = (userStaked * pastBlocks - frozenCoinAge) / pastBlocks;\n\n        uint256 curInflationIndex = _getInflationIndexNew(totalStaked, pastBlocks);\n\n        if (curInflationIndex < startInflationIndex) revert InflationIndexTooSmall();\n\n        return (curInflationIndex - startInflationIndex).wadMul(effectiveStakeAmount).wadMul(inflationIndex);\n    }\n\n    /**\n     * @dev Get the UserManager contract. First try and load it from state\n     * if it has been previously saved and fallback to loading it from the marketRegistry\n     * @return userManager contract\n     */\n    function _getUserManager(address token) internal view returns (IUserManager) {\n        return IUserManager(marketRegistry.userManagers(token));\n    }\n\n    /**\n     *  @dev See Comptroller.inflationPerBlock\n     */\n    function _inflationPerBlock(uint256 effectiveTotalStake) internal view returns (uint256) {\n        uint256 index = effectiveTotalStake / halfDecayPoint;\n        return _lookup(index);\n    }\n\n    function _lookup(uint256 index) internal pure returns (uint256) {\n        if (index <= 0.00001 * 10**18) {\n            return 1 * 10**18;\n        } else if (index <= 0.0001 * 10**18) {\n            return 0.9 * 10**18;\n        } else if (index <= 0.001 * 10**18) {\n            return 0.8 * 10**18;\n        } else if (index <= 0.01 * 10**18) {\n            return 0.7 * 10**18;\n        } else if (index <= 0.1 * 10**18) {\n            return 0.6 * 10**18;\n        } else if (index <= 1 * 10**18) {\n            return 0.5 * 10**18;\n        } else if (index <= 5 * 10**18) {\n            return 0.25 * 10**18;\n        } else if (index <= 10 * 10**18) {\n            return 0.1 * 10**18;\n        } else if (index <= 100 * 10**18) {\n            return 0.01 * 10**18;\n        } else if (index <= 1000 * 10**18) {\n            return 0.001 * 10**18;\n        } else if (index <= 10000 * 10**18) {\n            return 0.0001 * 10**18;\n        } else if (index <= 100000 * 10**18) {\n            return 0.00001 * 10**18;\n        } else {\n            return 0.000001 * 10**18;\n        }\n    }\n\n    function _getInflationIndex(\n        uint256 effectiveAmount,\n        uint256 inflationIndex,\n        uint256 blockDelta\n    ) internal view returns (uint256) {\n        return blockDelta * _inflationPerBlock(effectiveAmount).wadDiv(effectiveAmount) + inflationIndex;\n    }\n\n    function _getRewardsMultiplier(\n        uint256 userStaked,\n        uint256 lockedStake,\n        uint256 totalFrozen_,\n        bool isMember_\n    ) internal pure returns (uint256) {\n        if (isMember_) {\n            if (userStaked == 0 || totalFrozen_ >= lockedStake) {\n                return memberRatio;\n            }\n\n            uint256 effectiveLockedAmount = lockedStake - totalFrozen_;\n            uint256 effectiveStakeAmount = userStaked - totalFrozen_;\n\n            uint256 lendingRatio = effectiveLockedAmount.wadDiv(effectiveStakeAmount);\n\n            return lendingRatio + memberRatio;\n        } else {\n            return nonMemberRatio;\n        }\n    }\n}"
    },
    {
      "filename": "union-v2-contracts/contracts/token/Comptroller.sol?plain=1",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {Controller} from \"../Controller.sol\";\nimport {WadRayMath} from \"../WadRayMath.sol\";\nimport {IComptroller} from \"../interfaces/IComptroller.sol\";\nimport {IMarketRegistry} from \"../interfaces/IMarketRegistry.sol\";\nimport {IUserManager} from \"../interfaces/IUserManager.sol\";\n\n/**\n *  @author Compound -> Union Finance\n *  @title Comptroller\n *  @dev  For the time being, only the reward calculation of a single\n *        token is supported, and the contract needs to be revised after\n *        determining the reward calculation scheme of multiple tokens\n */\ncontract Comptroller is Controller, IComptroller {\n    using WadRayMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /* -------------------------------------------------------------------\n      Types \n    ------------------------------------------------------------------- */\n\n    struct Info {\n        uint256 updatedBlock; //last withdraw rewards block\n        uint256 inflationIndex; //last withdraw rewards inflationIndex\n        uint256 accrued; //the unionToken accrued but not yet transferred to each user\n    }\n\n    struct UserManagerState {\n        uint256 totalFrozen;\n        uint256 totalStaked;\n    }\n\n    struct UserManagerAccountState {\n        uint256 totalStaked;\n        uint256 totalFrozen;\n        uint256 totalLocked;\n        uint256 pastBlocksFrozenCoinAge;\n        bool isMember;\n    }\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Initial inflation index\n     */\n    uint256 public constant INIT_INFLATION_INDEX = 10**18;\n\n    /**\n     * @dev Non member reward multiplier rate (75%)\n     */\n    uint256 public constant nonMemberRatio = 75 * 10**16; // 75%;\n\n    /**\n     * @dev Member reward multiplier rate (100%)\n     */\n    uint256 public constant memberRatio = 10**18;\n\n    /**\n     * @dev Half decay point to reduce rewards at\n     */\n    uint256 public halfDecayPoint;\n\n    /**\n     * @dev store the latest inflation index\n     */\n    uint256 public gInflationIndex;\n\n    /**\n     * @dev block number when updating the inflation index\n     */\n    uint256 public gLastUpdatedBlock;\n\n    /**\n     * @dev $UNION token contract\n     */\n    IERC20Upgradeable public unionToken;\n\n    /**\n     * @dev The market registry contract\n     */\n    IMarketRegistry public marketRegistry;\n\n    /**\n     * @dev Map account to token to Info\n     */\n    mapping(address => mapping(address => Info)) public users;\n\n    /* -------------------------------------------------------------------\n      Events \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Withdraw rewards event\n     *  @param account The staker's address\n     *  @param amount The amount of Union tokens to withdraw\n     */\n    event LogWithdrawRewards(address indexed account, uint256 amount);\n\n    /* -------------------------------------------------------------------\n      Errors\n    ------------------------------------------------------------------- */\n\n    error SenderNotUserManager();\n    error NotZero();\n    error FrozenCoinAge();\n    error InflationIndexTooSmall();\n\n    /* -------------------------------------------------------------------\n      Constructor/Initializer \n    ------------------------------------------------------------------- */\n\n    function __Comptroller_init(\n        address unionToken_,\n        address marketRegistry_,\n        uint256 _halfDecayPoint\n    ) public initializer {\n        Controller.__Controller_init(msg.sender);\n\n        gInflationIndex = INIT_INFLATION_INDEX;\n        gLastUpdatedBlock = block.number;\n\n        unionToken = IERC20Upgradeable(unionToken_);\n        marketRegistry = IMarketRegistry(marketRegistry_);\n        halfDecayPoint = _halfDecayPoint;\n    }\n\n    /* -------------------------------------------------------------------\n      Modifiers \n    ------------------------------------------------------------------- */\n\n    modifier onlyUserManager(address token) {\n        if (msg.sender != address(_getUserManager(token))) revert SenderNotUserManager();\n        _;\n    }\n\n    /* -------------------------------------------------------------------\n      Setters \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Set the half decay point\n     */\n    function setHalfDecayPoint(uint256 point) public onlyAdmin {\n        if (point == 0) revert NotZero();\n        halfDecayPoint = point;\n    }\n\n    /* -------------------------------------------------------------------\n      View Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Get the reward multipier based on the account status\n     *  @param account Account address\n     *  @param token ERC20 token address\n     *  @return Multiplier number (in wei)\n     */\n    function getRewardsMultiplier(address account, address token) external view override returns (uint256) {\n        IUserManager userManagerContract = _getUserManager(token);\n        uint256 stakingAmount = userManagerContract.getStakerBalance(account);\n        uint256 lockedStake = userManagerContract.getTotalLockedStake(account);\n        (uint256 totalFrozen, ) = userManagerContract.getFrozenInfo(account, block.number);\n        bool isMember = userManagerContract.checkIsMember(account);\n        return _getRewardsMultiplier(stakingAmount, lockedStake, totalFrozen, isMember);\n    }\n\n    /**\n     *  @dev Calculate unclaimed rewards based on blocks\n     *  @param account User address\n     *  @param token Staking token address\n     *  @param futureBlocks Number of blocks in the future\n     *  @return Unclaimed rewards\n     */\n    function calculateRewardsByBlocks(\n        address account,\n        address token,\n        uint256 futureBlocks\n    ) public view override returns (uint256) {\n        IUserManager userManager = _getUserManager(token);\n\n        // Lookup account stataddress accounte from UserManager\n        (\n            UserManagerAccountState memory userManagerAccountState,\n            Info memory userInfo,\n            uint256 pastBlocks\n        ) = _getUserInfoView(userManager, account, token, futureBlocks);\n\n        // Lookup global state from UserManager\n        UserManagerState memory userManagerState = _getUserManagerState(userManager);\n\n        return\n            _calculateRewardsByBlocks(account, token, pastBlocks, userInfo, userManagerState, userManagerAccountState);\n    }\n\n    /**\n     *  @dev Calculate currently unclaimed rewards\n     *  @param account Account address\n     *  @param token Staking token address\n     *  @return Unclaimed rewards\n     */\n    function calculateRewards(address account, address token) external view override returns (uint256) {\n        return calculateRewardsByBlocks(account, token, 0);\n    }\n\n    /**\n     *  @dev Calculate inflation per block\n     *  @param effectiveTotalStake Effective total stake\n     *  @return Inflation amount, div totalSupply is the inflation rate\n     */\n    function inflationPerBlock(uint256 effectiveTotalStake) public view returns (uint256) {\n        return _inflationPerBlock(effectiveTotalStake);\n    }\n\n    /* -------------------------------------------------------------------\n      Core Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Withdraw rewards\n     *  @param token Staking token address\n     *  @return Amount of rewards\n     */\n    function withdrawRewards(address account, address token)\n        external\n        override\n        whenNotPaused\n        onlyUserManager(token)\n        returns (uint256)\n    {\n        IUserManager userManager = _getUserManager(token);\n\n        // Lookup account state from UserManager\n        (\n            UserManagerAccountState memory userManagerAccountState,\n            Info memory userInfo,\n            uint256 pastBlocks\n        ) = _getUserInfo(userManager, account, token, 0);\n\n        // Lookup global state from UserManager\n        UserManagerState memory userManagerState = _getUserManagerState(userManager);\n\n        uint256 amount = _calculateRewardsByBlocks(\n            account,\n            token,\n            pastBlocks,\n            userInfo,\n            userManagerState,\n            userManagerAccountState\n        );\n\n        // update the global states\n        uint256 totalStaked_ = userManagerState.totalStaked - userManagerState.totalFrozen;\n        gInflationIndex = _getInflationIndexNew(totalStaked_, block.number - gLastUpdatedBlock);\n        gLastUpdatedBlock = block.number;\n        users[account][token].updatedBlock = block.number;\n        users[account][token].inflationIndex = gInflationIndex;\n        if (unionToken.balanceOf(address(this)) >= amount && amount > 0) {\n            unionToken.safeTransfer(account, amount);\n            users[account][token].accrued = 0;\n            emit LogWithdrawRewards(account, amount);\n\n            return amount;\n        } else {\n            users[account][token].accrued = amount;\n            emit LogWithdrawRewards(account, 0);\n\n            return 0;\n        }\n    }\n\n    /**\n     *  @dev When total staked change update inflation index\n     *  @param totalStaked totalStaked amount\n     *  @return Whether succeeded\n     */\n    function updateTotalStaked(address token, uint256 totalStaked)\n        external\n        override\n        whenNotPaused\n        onlyUserManager(token)\n        returns (bool)\n    {\n        if (totalStaked > 0) {\n            gInflationIndex = _getInflationIndexNew(totalStaked, block.number - gLastUpdatedBlock);\n        }\n        gLastUpdatedBlock = block.number;\n\n        return true;\n    }\n\n    /* -------------------------------------------------------------------\n       Internal Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Get UserManager global state values\n     */\n    function _getUserManagerState(IUserManager userManager) internal view returns (UserManagerState memory) {\n        UserManagerState memory userManagerState;\n\n        userManagerState.totalFrozen = userManager.totalFrozen();\n        userManagerState.totalStaked = userManager.totalStaked() - userManagerState.totalFrozen;\n        if (userManagerState.totalStaked < 1e18) {\n            userManagerState.totalStaked = 1e18;\n        }\n\n        return userManagerState;\n    }\n\n    /**\n     * @dev Get UserManager user specific state (view function does NOT update UserManage state)\n     * @param userManager UserManager contract\n     * @param account Account address\n     * @param token Token address\n     * @param futureBlocks Blocks in the future\n     */\n    function _getUserInfoView(\n        IUserManager userManager,\n        address account,\n        address token,\n        uint256 futureBlocks\n    )\n        internal\n        view\n        returns (\n            UserManagerAccountState memory,\n            Info memory,\n            uint256\n        )\n    {\n        Info memory userInfo = users[account][token];\n        uint256 lastUpdatedBlock = userInfo.updatedBlock;\n        if (block.number < lastUpdatedBlock) {\n            lastUpdatedBlock = block.number;\n        }\n\n        uint256 pastBlocks = block.number - lastUpdatedBlock + futureBlocks;\n\n        UserManagerAccountState memory userManagerAccountState;\n        (userManagerAccountState.totalFrozen, userManagerAccountState.pastBlocksFrozenCoinAge) = userManager\n            .getFrozenInfo(account, pastBlocks);\n\n        return (userManagerAccountState, userInfo, pastBlocks);\n    }\n\n    /**\n     * @dev Get UserManager user specific state (function does update UserManage state)\n     * @param userManager UserManager contract\n     * @param account Account address\n     * @param token Token address\n     * @param futureBlocks Blocks in the future\n     */\n    function _getUserInfo(\n        IUserManager userManager,\n        address account,\n        address token,\n        uint256 futureBlocks\n    )\n        internal\n        returns (\n            UserManagerAccountState memory,\n            Info memory,\n            uint256\n        )\n    {\n        Info memory userInfo = users[account][token];\n        uint256 lastUpdatedBlock = userInfo.updatedBlock;\n        if (block.number < lastUpdatedBlock) {\n            lastUpdatedBlock = block.number;\n        }\n\n        uint256 pastBlocks = block.number - lastUpdatedBlock + futureBlocks;\n\n        UserManagerAccountState memory userManagerAccountState;\n        (userManagerAccountState.totalFrozen, userManagerAccountState.pastBlocksFrozenCoinAge) = userManager\n            .updateFrozenInfo(account, pastBlocks);\n\n        return (userManagerAccountState, userInfo, pastBlocks);\n    }\n\n    /**\n     *  @dev Calculate currently unclaimed rewards\n     *  @param account Account address\n     *  @param token Staking token address\n     *  @param userManagerState User manager global state\n     *  @return Unclaimed rewards\n     */\n    function _calculateRewardsByBlocks(\n        address account,\n        address token,\n        uint256 pastBlocks,\n        Info memory userInfo,\n        UserManagerState memory userManagerState,\n        UserManagerAccountState memory userManagerAccountState\n    ) internal view returns (uint256) {\n        IUserManager userManagerContract = _getUserManager(token);\n\n        // Lookup account state from UserManager\n        userManagerAccountState.totalStaked = userManagerContract.getStakerBalance(account);\n        userManagerAccountState.totalLocked = userManagerCo"
    }
  ]
}