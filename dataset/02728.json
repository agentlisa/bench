{
  "Title": "M-7: Create Fee Discount Feature Is Broken",
  "Content": "# Issue M-7: Create Fee Discount Feature Is Broken \n\nSource: https://github.com/sherlock-audit/2022-11-bond-judging/issues/16 \n\n## Found by \n8olidity, xiaoming90\n\n## Summary\n\n The create fee discount feature is found to be broken within the protocol. \n\n## Vulnerability Detail\n\nThe create fee discount feature relies on the `createFeeDiscount` state variable to determine the fee to be discounted from the protocol fee. However, it was observed that there is no way to initialize the `createFeeDiscount` state variable. As a result, the `createFeeDiscount` state variable will always be zero.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedExpiryTeller.sol#L118\n\n```solidity\nFile: BondFixedExpiryTeller.sol\n118:         // If fee is greater than the create discount, then calculate the fee and store it\n119:         // Otherwise, fee is zero.\n120:         if (protocolFee > createFeeDiscount) {\n121:             // Calculate fee amount\n122:             uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n123:             rewards[_protocol][underlying_] += feeAmount;\n124: \n125:             // Mint new bond tokens\n126:             bondToken.mint(msg.sender, amount_ - feeAmount);\n127: \n128:             return (bondToken, amount_ - feeAmount);\n129:         } else {\n130:             // Mint new bond tokens\n131:             bondToken.mint(msg.sender, amount_);\n132: \n133:             return (bondToken, amount_);\n134:         }\n```\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L118\n\n```solidity\nFile: BondFixedTermTeller.sol\n118:         // If fee is greater than the create discount, then calculate the fee and store it\n119:         // Otherwise, fee is zero.\n120:         if (protocolFee > createFeeDiscount) {\n121:             // Calculate fee amount\n122:             uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n123:             rewards[_protocol][underlying_] += feeAmount;\n124: \n125:             // Mint new bond tokens\n126:             _mintToken(msg.sender, tokenId, amount_ - feeAmount);\n127: \n128:             return (tokenId, amount_ - feeAmount);\n129:         } else {\n130:             // Mint new bond tokens\n131:             _mintToken(msg.sender, tokenId, amount_);\n132: \n133:             return (tokenId, amount_);\n134:         }\n```\n\n## Impact\n\n The create fee discount feature is broken within the protocol. There is no way for the protocol team to configure a discount for the users of the `BondFixedExpiryTeller.create` and `BondFixedTermTeller.create` functions. As such, the users will not obtain any discount from the protocol when using the create function.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedExpiryTeller.sol#L118\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L118\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement a setter method for the `createFeeDiscount` state variable and the necessary verification checks.\n\n```solidity\nfunction setCreateFeeDiscount(uint48 createFeeDiscount_) external requiresAuth {\n    if (createFeeDiscount_ > protocolFee)  revert Teller_InvalidParams();\n    if (createFeeDiscount_ > 5e3) revert Teller_InvalidParams();\n    createFeeDiscount = createFeeDiscount_;\n}\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree. We implemented a `setCreateFeeDiscount` function on the BondBaseTeller to allow updating the create fee discount.\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/570eb0b74b2401c7b6d07a30f8dd452bf7f225f9\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/20",
  "Code": [
    {
      "filename": "src/BondFixedExpiryTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ClonesWithImmutableArgs} from \"clones/ClonesWithImmutableArgs.sol\";\n\nimport {BondBaseTeller, IBondAggregator, Authority} from \"./bases/BondBaseTeller.sol\";\nimport {IBondFixedExpiryTeller} from \"./interfaces/IBondFixedExpiryTeller.sol\";\nimport {ERC20BondToken} from \"./ERC20BondToken.sol\";\n\nimport {TransferHelper} from \"./lib/TransferHelper.sol\";\nimport {FullMath} from \"./lib/FullMath.sol\";\n\n/// @title Bond Fixed Expiry Teller\n/// @notice Bond Fixed Expiry Teller Contract\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n/// @dev The Bond Fixed Expiry Teller is an implementation of the\n///      Bond Base Teller contract specific to handling user bond transactions\n///      and tokenizing bond markets where all purchases vest at the same timestamp\n///      as ERC20 tokens.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\ncontract BondFixedExpiryTeller is BondBaseTeller, IBondFixedExpiryTeller {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n    using ClonesWithImmutableArgs for address;\n\n    /* ========== EVENTS ========== */\n    event ERC20BondTokenCreated(\n        ERC20BondToken bondToken,\n        ERC20 indexed underlying,\n        uint48 indexed expiry\n    );\n\n    /* ========== STATE VARIABLES ========== */\n    /// @notice ERC20 bond tokens (unique to a underlying and expiry)\n    mapping(ERC20 => mapping(uint48 => ERC20BondToken)) public bondTokens;\n\n    /// @notice ERC20BondToken reference implementation (deployed on creation to clone from)\n    ERC20BondToken public immutable bondTokenImplementation;\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        address protocol_,\n        IBondAggregator aggregator_,\n        address guardian_,\n        Authority authority_\n    ) BondBaseTeller(protocol_, aggregator_, guardian_, authority_) {\n        bondTokenImplementation = new ERC20BondToken();\n    }\n\n    /* ========== PURCHASE ========== */\n\n    /// @notice             Handle payout to recipient\n    /// @param recipient_   Address to receive payout\n    /// @param payout_      Amount of payoutToken to be paid\n    /// @param underlying_   Token to be paid out\n    /// @param vesting_     Timestamp when the payout will vest\n    /// @return expiry      Timestamp when the payout will vest\n    function _handlePayout(\n        address recipient_,\n        uint256 payout_,\n        ERC20 underlying_,\n        uint48 vesting_\n    ) internal override returns (uint48 expiry) {\n        // If there is no vesting time, the deposit is treated as an instant swap.\n        // otherwise, deposit info is stored and payout is available at a future timestamp.\n        // instant swap is denoted by expiry == 0.\n        //\n        // bonds mature with a cliff at a set timestamp\n        // prior to the expiry timestamp, no payout tokens are accessible to the user\n        // after the expiry timestamp, the entire payout can be redeemed\n        //\n        // fixed-expiry bonds mature at a set timestamp\n        // i.e. expiry = day 10. when alice deposits on day 1, her term\n        // is 9 days. when bob deposits on day 2, his term is 8 days.\n        if (vesting_ > uint48(block.timestamp)) {\n            expiry = vesting_;\n            // Fixed-expiry bonds mint ERC-20 tokens\n            bondTokens[underlying_][expiry].mint(recipient_, payout_);\n        } else {\n            // If no expiry, then transfer payout directly to user\n            underlying_.safeTransfer(recipient_, payout_);\n        }\n    }\n\n    /* ========== DEPOSIT/MINT ========== */\n\n    /// @inheritdoc IBondFixedExpiryTeller\n    function create(\n        ERC20 underlying_,\n        uint48 expiry_,\n        uint256 amount_\n    ) external override nonReentrant returns (ERC20BondToken, uint256) {\n        // Revert if expiry is in the past\n        if (expiry_ < block.timestamp) revert Teller_InvalidParams();\n\n        ERC20BondToken bondToken = bondTokens[underlying_][expiry_];\n\n        // Revert if no token exists, must call deploy first\n        if (bondToken == ERC20BondToken(address(0x00)))\n            revert Teller_TokenDoesNotExist(underlying_, expiry_);\n\n        // Transfer in underlying\n        // Check that amount received is not less than amount expected\n        // Handles edge cases like fee-on-transfer tokens (which are not supported)\n        uint256 oldBalance = underlying_.balanceOf(address(this));\n        underlying_.safeTransferFrom(msg.sender, address(this), amount_);\n        if (underlying_.balanceOf(address(this)) < oldBalance + amount_)\n            revert Teller_UnsupportedToken();\n\n        // If fee is greater than the create discount, then calculate the fee and store it\n        // Otherwise, fee is zero.\n        if (protocolFee > createFeeDiscount) {\n            // Calculate fee amount\n            uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n            rewards[_protocol][underlying_] += feeAmount;\n\n            // Mint new bond tokens\n            bondToken.mint(msg.sender, amount_ - feeAmount);\n\n            return (bondToken, amount_ - feeAmount);\n        } else {\n            // Mint new bond tokens\n            bondToken.mint(msg.sender, amount_);\n\n            return (bondToken, amount_);\n        }\n    }\n\n    /* ========== REDEEM ========== */\n\n    /// @inheritdoc IBondFixedExpiryTeller\n    function redeem(ERC20BondToken token_, uint256 amount_) external override nonReentrant {\n        // Validate token is issued by this teller\n        ERC20 underlying = token_.underlying();\n        uint48 expiry = token_.expiry();\n\n        if (token_ != bondTokens[underlying][expiry]) revert Teller_UnsupportedToken();\n\n        // Validate token expiry has passed\n        if (uint48(block.timestamp) < expiry) revert Teller_TokenNotMatured(expiry);\n\n        // Burn bond token and transfer underlying\n        token_.burn(msg.sender, amount_);\n        underlying.safeTransfer(msg.sender, amount_);\n    }\n\n    /* ========== TOKENIZATION ========== */\n\n    /// @inheritdoc IBondFixedExpiryTeller\n    function deploy(ERC20 underlying_, uint48 expiry_)\n        external\n        override\n        nonReentrant\n        returns (ERC20BondToken)\n    {\n        // Revert if expiry is in the past\n        if (uint256(expiry_) < block.timestamp) revert Teller_InvalidParams();\n\n        // Create bond token if one doesn't already exist\n        ERC20BondToken bondToken = bondTokens[underlying_][expiry_];\n        if (bondToken == ERC20BondToken(address(0))) {\n            (string memory name, string memory symbol) = _getNameAndSymbol(underlying_, expiry_);\n            bytes memory tokenData = abi.encodePacked(\n                bytes32(bytes(name)),\n                bytes32(bytes(symbol)),\n                uint8(underlying_.decimals()),\n                underlying_,\n                uint256(expiry_),\n                address(this)\n            );\n            bondToken = ERC20BondToken(address(bondTokenImplementation).clone(tokenData));\n            bondTokens[underlying_][expiry_] = bondToken;\n            emit ERC20BondTokenCreated(bondToken, underlying_, expiry_);\n        }\n        return bondToken;\n    }\n\n    /// @inheritdoc IBondFixedExpiryTeller\n    function getBondTokenForMarket(uint256 id_) external view override returns (ERC20BondToken) {\n        (, , ERC20 underlying, , uint48 vesting, ) = _aggregator\n            .getAuctioneer(id_)\n            .getMarketInfoForPurchase(id_);\n\n        return bondTokens[underlying][vesting];\n    }\n}"
    },
    {
      "filename": "src/BondFixedTermTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {BondBaseTeller, IBondAggregator, Authority} from \"./bases/BondBaseTeller.sol\";\nimport {IBondFixedTermTeller} from \"./interfaces/IBondFixedTermTeller.sol\";\n\nimport {TransferHelper} from \"./lib/TransferHelper.sol\";\nimport {FullMath} from \"./lib/FullMath.sol\";\nimport {ERC1155} from \"./lib/ERC1155.sol\";\n\n/// @title Bond Fixed Term Teller\n/// @notice Bond Fixed Term Teller Contract\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Bond Fixed Term Teller is an implementation of the\n///      Bond Base Teller contract specific to handling user bond transactions\n///      and tokenizing bond markets where purchases vest in a fixed amount of time\n///      (rounded to the day) as ERC1155 tokens.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\ncontract BondFixedTermTeller is BondBaseTeller, IBondFixedTermTeller, ERC1155 {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== EVENTS ========== */\n    event ERC1155BondTokenCreated(uint256 tokenId, ERC20 indexed underlying, uint48 indexed expiry);\n\n    /* ========== STATE VARIABLES ========== */\n\n    mapping(uint256 => TokenMetadata) public tokenMetadata; // metadata for bond tokens\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        address protocol_,\n        IBondAggregator aggregator_,\n        address guardian_,\n        Authority authority_\n    ) BondBaseTeller(protocol_, aggregator_, guardian_, authority_) {}\n\n    /* ========== PURCHASE ========== */\n\n    /// @notice             Handle payout to recipient\n    /// @param recipient_   Address to receive payout\n    /// @param payout_      Amount of payoutToken to be paid\n    /// @param payoutToken_   Token to be paid out\n    /// @param vesting_     Amount of time to vest from current timestamp\n    /// @return expiry      Timestamp when the payout will vest\n    function _handlePayout(\n        address recipient_,\n        uint256 payout_,\n        ERC20 payoutToken_,\n        uint48 vesting_\n    ) internal override returns (uint48 expiry) {\n        // If there is no vesting time, the deposit is treated as an instant swap.\n        // otherwise, deposit info is stored and payout is available at a future timestamp.\n        // instant swap is denoted by expiry == 0.\n        //\n        // bonds mature with a cliff at a set timestamp\n        // prior to the expiry timestamp, no payout tokens are accessible to the user\n        // after the expiry timestamp, the entire payout can be redeemed\n        //\n        // fixed-term bonds mature in a set amount of time from deposit\n        // i.e. term = 1 week. when alice deposits on day 1, her bond\n        // expires on day 8. when bob deposits on day 2, his bond expires day 9.\n        if (vesting_ != 0) {\n            // Normalizing fixed term vesting timestamps to the same time each day\n            expiry = ((vesting_ + uint48(block.timestamp)) / uint48(1 days)) * uint48(1 days);\n\n            // Fixed-term user payout information is handled in BondTeller.\n            // Teller mints ERC-1155 bond tokens for user.\n            uint256 tokenId = getTokenId(payoutToken_, expiry);\n\n            // Create new bond token if it doesn't exist yet\n            if (!tokenMetadata[tokenId].active) {\n                _deploy(tokenId, payoutToken_, expiry);\n            }\n\n            // Mint bond token to recipient\n            _mintToken(recipient_, tokenId, payout_);\n        } else {\n            // If no expiry, then transfer payout directly to user\n            payoutToken_.safeTransfer(recipient_, payout_);\n        }\n    }\n\n    /* ========== DEPOSIT/MINT ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function create(\n        ERC20 underlying_,\n        uint48 expiry_,\n        uint256 amount_\n    ) external override nonReentrant returns (uint256, uint256) {\n        // Revert if expiry is in the past\n        if (expiry_ < block.timestamp) revert Teller_InvalidParams();\n\n        uint256 tokenId = getTokenId(underlying_, expiry_);\n\n        // Revert if no token exists, must call deploy first\n        if (!tokenMetadata[tokenId].active) revert Teller_TokenDoesNotExist(underlying_, expiry_);\n\n        // Transfer in underlying\n        // Check that amount received is not less than amount expected\n        // Handles edge cases like fee-on-transfer tokens (which are not supported)\n        uint256 oldBalance = underlying_.balanceOf(address(this));\n        underlying_.safeTransferFrom(msg.sender, address(this), amount_);\n        if (underlying_.balanceOf(address(this)) < oldBalance + amount_)\n            revert Teller_UnsupportedToken();\n\n        // If fee is greater than the create discount, then calculate the fee and store it\n        // Otherwise, fee is zero.\n        if (protocolFee > createFeeDiscount) {\n            // Calculate fee amount\n            uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n            rewards[_protocol][underlying_] += feeAmount;\n\n            // Mint new bond tokens\n            _mintToken(msg.sender, tokenId, amount_ - feeAmount);\n\n            return (tokenId, amount_ - feeAmount);\n        } else {\n            // Mint new bond tokens\n            _mintToken(msg.sender, tokenId, amount_);\n\n            return (tokenId, amount_);\n        }\n    }\n\n    /* ========== REDEEM ========== */\n\n    function _redeem(uint256 tokenId_, uint256 amount_) internal {\n        // Check that the tokenId is active\n        if (!tokenMetadata[tokenId_].active) revert Teller_InvalidParams();\n\n        // Cache token metadata\n        TokenMetadata memory meta = tokenMetadata[tokenId_];\n\n        // Check that the token has matured\n        if (block.timestamp < meta.expiry) revert Teller_TokenNotMatured(meta.expiry);\n\n        // Burn bond token and transfer underlying to sender\n        _burnToken(msg.sender, tokenId_, amount_);\n        meta.underlying.safeTransfer(msg.sender, amount_);\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function redeem(uint256 tokenId_, uint256 amount_) public override nonReentrant {\n        _redeem(tokenId_, amount_);\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function batchRedeem(uint256[] calldata tokenIds_, uint256[] calldata amounts_)\n        external\n        override\n        nonReentrant\n    {\n        uint256 len = tokenIds_.length;\n        if (len != amounts_.length) revert Teller_InvalidParams();\n        for (uint256 i; i < len; ++i) {\n            _redeem(tokenIds_[i], amounts_[i]);\n        }\n    }\n\n    /* ========== TOKENIZATION ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function deploy(ERC20 underlying_, uint48 expiry_)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 tokenId = getTokenId(underlying_, expiry_);\n        // Only creates token if it does not exist\n        if (!tokenMetadata[tokenId].active) {\n            _deploy(tokenId, underlying_, expiry_);\n        }\n        return tokenId;\n    }\n\n    /// @notice             \"Deploy\" a new ERC1155 bond token and stores its ID\n    /// @dev                ERC1155 tokens used for fixed term bonds\n    /// @param tokenId_     Calculated ID of new bond token (from getTokenId)\n    /// @param underlying_  Underlying token to be paid out when the bond token vests\n    /// @param expiry_      Timestamp that the token will vest at\n    function _deploy(\n        uint256 tokenId_,\n        ERC20 underlying_,\n        uint48 expiry_\n    ) internal {\n        // Revert if expiry is in the past\n        if (uint256(expiry_) < block.timestamp) revert Teller_InvalidParams();\n\n        // Store token metadata\n        tokenMetadata[tokenId_] = TokenMetadata(\n            true,\n            underlying_,\n            uint8(underlying_.decimals()),\n            expiry_,\n            0\n        );\n\n        emit ERC1155BondTokenCreated(tokenId_, underlying_, expiry_);\n    }\n\n    /// @notice             Mint bond token and update supply\n    /// @param to_          Address to mint tokens to\n    /// @param tokenId_     ID of bond token to mint\n    /// @param amount_      Amount of bond tokens to mint\n    function _mintToken(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_\n    ) internal {\n        _mint(to_, tokenId_, amount_, bytes(\"\"));\n        tokenMetadata[tokenId_].supply += amount_;\n    }\n\n    /// @notice             Burn bond token and update supply\n    /// @param from_        Address to burn tokens from\n    /// @param tokenId_     ID of bond token to burn\n    /// @param amount_      Amount of bond token to burn\n    function _burnToken(\n        address from_,\n        uint256 tokenId_,\n        uint256 amount_\n    ) internal {\n        _burn(from_, tokenId_, amount_);\n        tokenMetadata[tokenId_].supply -= amount_;\n    }\n\n    /* ========== TOKEN NAMING ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function getTokenId(ERC20 underlying_, uint48 expiry_) public pure override returns (uint256) {\n        // Vesting is divided by 1 day (in seconds) since bond tokens are only unique\n        // to a day, not a specific timestamp.\n        uint256 tokenId = uint256(\n            keccak256(abi.encodePacked(underlying_, expiry_ / uint48(1 days)))\n        );\n        return tokenId;\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function getTokenNameAndSymbol(uint256 tokenId_)\n        external\n        view\n        override\n        returns (string memory, string memory)\n    {\n        TokenMetadata memory meta = tokenMetadata[tokenId_];\n        (string memory name, string memory symbol) = _getNameAndSymbol(\n            meta.underlying,\n            meta.expiry\n        );\n        return (name, symbol);\n    }\n}"
    },
    {
      "filename": "src/BondFixedExpiryTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ClonesWithImmutableArgs} from \"clones/ClonesWithImmutableArgs.sol\";\n\nimport {BondBaseTeller, IBondAggregator, Authority} from \"./bases/BondBaseTeller.sol\";\nimport {IBondFixedExpiryTeller} from \"./interfaces/IBondFixedExpiryTeller.sol\";\nimport {ERC20BondToken} from \"./ERC20BondToken.sol\";\n\nimport {TransferHelper} from \"./lib/TransferHelper.sol\";\nimport {FullMath} from \"./lib/FullMath.sol\";\n\n/// @title Bond Fixed Expiry Teller\n/// @notice Bond Fixed Expiry Teller Contract\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n/// @dev The Bond Fixed Expiry Teller is an implementation of the\n///      Bond Base Teller contract specific to handling user bond transactions\n///      and tokenizing bond markets where all purchases vest at the same timestamp\n///      as ERC20 tokens.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\ncontract BondFixedExpiryTeller is BondBaseTeller, IBondFixedExpiryTeller {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n    using ClonesWithImmutableArgs for address;\n\n    /* ========== EVENTS ========== */\n    event ERC20BondTokenCreated(\n        ERC20BondToken bondToken,\n        ERC20 indexed underlying,\n        uint48 indexed expiry\n    );\n\n    /* ========== STATE VARIABLES ========== */\n    /// @notice ERC20 bond tokens (unique to a underlying and expiry)\n    mapping(ERC20 => mapping(uint48 => ERC20BondToken)) public bondTokens;\n\n    /// @notice ERC20BondToken reference implementation (deployed on creation to clone from)\n    ERC20BondToken public immutable bondTokenImplementation;\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        address protocol_,\n        IBondAggregator aggregator_,\n        address guardian_,\n        Authority authority_\n    ) BondBaseTeller(protocol_, aggregator_, guardian_, authority_) {\n        bondTokenImplementation = new ERC20BondToken();\n    }\n\n    /* ========== PURCHASE ========== */\n\n    /// @notice             Handle payout to recipient\n    /// @param recipient_   Address to receive payout\n    /// @param payout_      Amount of payoutToken to be paid\n    /// @param underlying_   Token to be paid out\n    /// @param vesting_     Timestamp when the payout will vest\n    /// @return expiry      Timestamp when the payout will vest\n    function _handlePayout(\n        address recipient_,\n        uint256 payout_,\n        ERC20 underlying_,\n        uint48 vesting_\n    ) internal override returns (uint48 expiry) {\n        // If there is no vesting time, the deposit is treated as an instant swap.\n        // otherwise, deposit info is stored and payout is available at a future timestamp.\n        // instant swap is denoted by expiry == 0.\n        //\n        // bonds mature with a cliff at a set timestamp\n        // prior to the expiry timestamp, no payout tokens are accessible to the user\n        // after the expiry timestamp, the entire payout can be redeemed\n        //\n        // fixed-expiry bonds mature at a set timestamp\n        // i.e. expiry = day 10. when alice deposits on day 1, her term\n        // is 9 days. when bob deposits on day 2, his term is 8 days.\n        if (vesting_ > uint48(block.timestamp)) {\n            expiry = vesting_;\n            // Fixed-expiry bonds mint ERC-20 tokens\n            bondTokens[underlying_][expiry].mint(recipient_, payout_);\n        } else {\n            // If no expiry, then transfer payout directly to user\n            underlying_.safeTransfer(recipient_, payout_);\n        }\n    }\n\n    /* ========== DEPOSIT/MINT ========== */\n\n    /// @inheritdoc IBondFixedExpiryTeller\n    function create(\n        ERC20 underlying_,\n        uint48 expiry_,\n        uint256 amount_\n    ) external override nonReentrant returns (ERC20BondToken, uint256) {\n        // Revert if expiry is in the past\n        if (expiry_ < block.timestamp) revert Teller_InvalidParams();\n\n        ERC20BondToken bondToken = bondTokens[underlying_][expiry_];\n\n        // Revert if no token exists, must call deploy first\n        if (bondToken == ERC20BondToken(address(0x00)))\n            revert Teller_TokenDoesNotExist(underlying_, expiry_);\n\n        // Transfer in underlying\n        // Check that amount received is not less than amount expected\n        // Handles edge cases like fee-on-transfer tokens (which are not supported)\n        uint256 oldBalance = underlying_.balanceOf(address(this));\n        underlying_.safeTransferFrom(msg.sender, address(this), amount_);\n        if (underlying_.balanceOf(address(this)) < oldBalance + amount_)\n            revert Teller_UnsupportedToken();\n\n        // If fee is greater than the create discount, then calculate the fee and store it\n        // Otherwise, fee is zero.\n        if (protocolFee > createFeeDiscount) {\n            // Calculate fee amount\n            uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n            rewards[_protocol][underlying_] += feeAmount;\n\n            // Mint new bond tokens\n            bondToken.mint(msg.sender, amount_ - feeAmount);\n\n            return (bondToken, amount_ - feeAmount);\n        } else {\n            // Mint new bond tokens\n            bondToken.mint(msg.sender, amount_);\n\n            return (bondToken, amount_);\n        }\n    }\n\n    /* ========== REDEEM ========== */\n\n    /// @inheritdoc IBondFixedExpiryTeller\n    function redeem(ERC20BondToken token_, uint256 amount_) external override nonReentrant {\n        // Validate token is issued by this teller\n        ERC20 underlying = token_.underlying();\n        uint48 expiry = token_.expiry();\n\n        if (token_ != bondTokens[underlying][expiry]) revert Teller_UnsupportedToken();\n\n        // Validate token expiry has passed\n        if (uint48(block.timestamp) < expiry) revert Teller_TokenNotMatured(expiry);\n\n        // Burn bond token and transfer underlying\n        token_.burn(msg.sender, amount_);\n        underlying.safeTransfer(msg.sender, amount_);\n    }\n\n    /* ========== TOKENIZATION ========== */\n\n    /// @inheritdoc IBondFixedExpiryTeller\n    function deploy(ERC20 underlying_, uint48 expiry_)\n        external\n        override\n        nonReentrant\n        returns (ERC20BondToken)\n    {\n        // Revert if expiry is in the past\n        if (uint256(expiry_) < block.timestamp) revert Teller_InvalidParams();\n\n        // Create bond token if one doesn't already exist\n        ERC20BondToken bondToken = bondTokens[underlying_][expiry_];\n        if (bondToken == ERC20BondToken(address(0))) {\n            (string memory name, string memory symbol) = _getNameAndSymbol(underlying_, expiry_);\n            bytes memory tokenData = abi.encodePacked(\n                bytes32(bytes(name)),\n                bytes32(bytes(symbol)),\n                uint8(underlying_.decimals()),\n                underlying_,\n                uint256(expiry_),\n                address(this)\n            );\n            bondToken = ERC20BondToken(address(bondTokenImplementation).clone(tokenData));\n            bondTokens[underlying_][expiry_] = bondToken;\n            emit ERC20BondTokenCreated(bondToken, underlying_, expiry_);\n        }\n        return bondToken;\n    }\n\n    /// @inheritdoc IBondFixedExpiryTeller\n    function getBondTokenForMarket(uint256 id_) external view override returns (ERC20BondToken) {\n        (, , ERC20 underlying, , uint48 vesting, ) = _aggregator\n            .getAuctioneer(id_)\n            .getMarketInfoForPurchase(id_);\n\n        return bondTokens[underlying][vesting];\n    }\n}"
    },
    {
      "filename": "src/BondFixedTermTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {BondBaseTeller, IBondAggregator, Authority} from \"./bases/BondBaseTeller.sol\";\nimport {IBondFixedTermTeller} from \"./interfaces/IBondFixedTermTeller.sol\";\n\nimport {TransferHelper} from \"./lib/TransferHelper.sol\";\nimport {FullMath} from \"./lib/FullMath.sol\";\nimport {ERC1155} from \"./lib/ERC1155.sol\";\n\n/// @title Bond Fixed Term Teller\n/// @notice Bond Fixed Term Teller Contract\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Bond Fixed Term Teller is an implementation of the\n///      Bond Base Teller contract specific to handling user bond transactions\n///      and tokenizing bond markets where purchases vest in a fixed amount of time\n///      (rounded to the day) as ERC1155 tokens.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\ncontract BondFixedTermTeller is BondBaseTeller, IBondFixedTermTeller, ERC1155 {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== EVENTS ========== */\n    event ERC1155BondTokenCreated(uint256 tokenId, ERC20 indexed underlying, uint48 indexed expiry);\n\n    /* ========== STATE VARIABLES ========== */\n\n    mapping(uint256 => TokenMetadata) public tokenMetadata; // metadata for bond tokens\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        address protocol_,\n        IBondAggregator aggregator_,\n        address guardian_,\n        Authority authority_\n    ) BondBaseTeller(protocol_, aggregator_, guardian_, authority_) {}\n\n    /* ========== PURCHASE ========== */\n\n    /// @notice             Handle payout to recipient\n    /// @param recipient_   Address to receive payout\n    /// @param payout_      Amount of payoutToken to be paid\n    /// @param payoutToken_   Token to be paid out\n    /// @param vesting_     Amount of time to vest from current timestamp\n    /// @return expiry      Timestamp when the payout will vest\n    function _handlePayout(\n        address recipient_,\n        uint256 payout_,\n        ERC20 payoutToken_,\n        uint48 vesting_\n    ) internal override returns (uint48 expiry) {\n        // If there is no vesting time, the deposit is treated as an instant swap.\n        // otherwise, deposit info is stored and payout is available at a future timestamp.\n        // instant swap is denoted by expiry == 0.\n        //\n        // bonds mature with a cliff at a set timestamp\n        // prior to the expiry timestamp, no payout tokens are accessible to the user\n        // after the expiry timestamp, the entire payout can be redeemed\n        //\n        // fixed-term bonds mature in a set amount of time from deposit\n        // i.e. term = 1 week. when alice deposits on day 1, her bond\n        // expires on day 8. when bob deposits on day 2, his bond expires day 9.\n        if (vesting_ != 0) {\n            // Normalizing fixed term vesting timestamps to the same time each day\n            expiry = ((vesting_ + uint48(block.timestamp)) / uint48(1 days)) * uint48(1 days);\n\n            // Fixed-term user payout information is handled in BondTeller.\n            // Teller mints ERC-1155 bond tokens for user.\n            uint256 tokenId = getTokenId(payoutToken_, expiry);\n\n            // Create new bond token if it doesn't exist yet\n            if (!tokenMetadata[tokenId].active) {\n                _deploy(tokenId, payoutToken_, expiry);\n            }\n\n            // Mint bond token to recipient\n            _mintToken(recipient_, tokenId, payout_);\n        } else {\n            // If no expiry, then transfer payout directly to user\n            payoutToken_.safeTransfer(recipient_, payout_);\n        }\n    }\n\n    /* ========== DEPOSIT/MINT ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function create(\n        ERC20 underlying_,\n        uint48 expiry_,\n        uint256 amount_\n    ) external override nonReentrant returns (uint256, uint256) {\n        // Revert if expiry is in the past\n        if (expiry_ < block.timestamp) revert Teller_InvalidParams();\n\n        uint256 tokenId = getTokenId(underlying_, expiry_);\n\n        // Revert if no token exists, must call deploy first\n        if (!tokenMetadata[tokenId].active) revert Teller_TokenDoesNotExist(underlying_, expiry_);\n\n        // Transfer in underlying\n        // Check that amount received is not less than amount expected\n        // Handles edge cases like fee-on-transfer tokens (which are not supported)\n        uint256 oldBalance = underlying_.balanceOf(address(this));\n        underlying_.safeTransferFrom(msg.sender, address(this), amount_);\n        if (underlying_.balanceOf(address(this)) < oldBalance + amount_)\n            revert Teller_UnsupportedToken();\n\n        // If fee is greater than the create discount, then calculate the fee and store it\n        // Otherwise, fee is zero.\n        if (protocolFee > createFeeDiscount) {\n            // Calculate fee amount\n            uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n            rewards[_protocol][underlying_] += feeAmount;\n\n            // Mint new bond tokens\n            _mintToken(msg.sender, tokenId, amount_ - feeAmount);\n\n            return (tokenId, amount_ - feeAmount);\n        } else {\n            // Mint new bond tokens\n            _mintToken(msg.sender, tokenId, amount_);\n\n            return (tokenId, amount_);\n        }\n    }\n\n    /* ========== REDEEM ========== */\n\n    function _redeem(uint256 tokenId_, uint256 amount_) internal {\n        // Check that the tokenId is active\n        if (!tokenM"
    }
  ]
}