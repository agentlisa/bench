{
  "Title": "[M-10] There are multiple ways for admins/governance to rug users",
  "Content": "_Submitted by IllIllI, also found by 0x1f8b_\n\n<https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L61>\n\n<https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L70-L75>\n\n<https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L50>\n\n### Impact\n\nA malicious admin can steal user funds or lock their balances forever.\n\nEven if the user is benevolent the fact that there is a rug vector available may [negatively impact the protocol's reputation](https://twitter.com/RugDocIO/status/1411732108029181960).\n\n### Proof of Concept\n\nUnlike the original Convex code that goes to great lengths to prevent users having the ability to transfer funds/mint things, this project introduces multiple roles and new abilities that require users to place more trust in governance:\n\n1.  Admins can initiate migrations and set the `newPool_` to be a contract that forwards funds to accounts they control\n\n```solidity\nFile: protocol/contracts/zaps/PoolMigrationZap.sol   #1\n\n61           ILiquidityPool newPool_ = _underlyingNewPools[underlying_];\n62           uint256 ethValue_ = underlying_ == address(0) ? underlyingAmount_ : 0;\n63           newPool_.depositFor{value: ethValue_}(msg.sender, underlyingAmount_);\n```\n\n<https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L61-L63>\n\n2.  Admins can add infinite `newRewardToken`s:\n\n```solidity\nFile: protocol/contracts/BkdLocker.sol   #2\n\n70       function migrate(address newRewardToken) external override onlyGovernance {\n71           _replacedRewardTokens.remove(newRewardToken);\n72           _replacedRewardTokens.set(rewardToken, block.timestamp);\n73           lastMigrationEvent = block.timestamp;\n74           rewardToken = newRewardToken;\n75       }\n```\n\n<https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L70-L75>\n\nso that `_userCheckpoint()`s, which are required to withdraw funds, revert because they run out of gas iterating over the tokens:\n\n```solidity\nFile: protocol/contracts/BkdLocker.sol   #3\n\n292       function _userCheckpoint(\n293           address user,\n294           uint256 amountAdded,\n295           uint256 newTotal\n296       ) internal {\n297           RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];\n298   \n299           // Compute the share earned by the user since they last updated\n300           uint256 userBalance = balances[user];\n301           if (userBalance > 0) {\n302               curRewardTokenData.userShares[user] += (curRewardTokenData.feeIntegral -\n303                   curRewardTokenData.userFeeIntegrals[user]).scaledMul(\n304                       userBalance.scaledMul(boostFactors[user])\n305                   );\n306   \n307               // Update values for previous rewardTokens\n308               if (lastUpdated[user] < lastMigrationEvent) {\n309                   uint256 length = _replacedRewardTokens.length();\n310                   for (uint256 i; i < length; i = i.uncheckedInc()) {\n```\n\n<https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L292-L310>\n\n3.  Admins can set a malicious `feeBurner`, via the addressProvider, which just takes the fees for itself\n\n```solidity\nFile: protocol/contracts/RewardHandler.sol   #4\n\n35       function burnFees() external override {\n36           IBkdLocker bkdLocker = IBkdLocker(addressProvider.getBKDLocker());\n37           IFeeBurner feeBurner = addressProvider.getFeeBurner();\n38           address targetLpToken = bkdLocker.rewardToken();\n39           address[] memory pools = addressProvider.allPools();\n40           uint256 ethBalance = address(this).balance;\n41           address[] memory tokens = new address[](pools.length);\n42           for (uint256 i; i < pools.length; i = i.uncheckedInc()) {\n43               ILiquidityPool pool = ILiquidityPool(pools[i]);\n44               address underlying = pool.getUnderlying();\n45               if (underlying != address(0)) {\n46                   _approve(underlying, address(feeBurner));\n47               }\n48               tokens[i] = underlying;\n49           }\n50           feeBurner.burnToTarget{value: ethBalance}(tokens, targetLpToken);\n```\n\n<https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L35-L50>\n\n4.  Admins can set an oracle that provides the wrong answers:\n\n```solidity\nFile: protocol/contracts/swappers/SwapperRouter.sol   #5\n\n452           try _addressProvider.getOracleProvider().getPriceETH(token_) returns (uint256 price_) {\n```\n\n<https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/swappers/SwapperRouter.sol#L452>\n\n### Recommended Mitigation Steps\n\nThe trust-minimizing approach that Convex took was to not allow admins to change addresses. In order for things to change, an admin is allowed to completely shut everything down, and during the shut down state, users are still able to withdraw their funds. Later, the admins spin up a whole new set of contracts, and let users migrate things themselves. Something similar can be done here by having the DAO accept proposals to spawn specific contracts, and hook up specific addresses in certain ways in the new deployment.\n\n**[danhper (Backd) disputed and commented](https://github.com/code-423n4/2022-05-backd-findings/issues/113#issuecomment-1147384553):**\n > This is a design decision. Many protocols are fully upgradeable (Compound, Aave, Maker) and some decide to be fully immutable (Convex, Curve). The governance process will be formalized a little later and have safeguards in place but we are not planning on following Convex's approach nor think that it is the \"correct\" way to design a protocol.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-backd-findings/issues/113#issuecomment-1159809027):**\n > The warden has listed multiple ways in which Admin Privilege can be used against users of the protocol.\n> \n> While the sponsor may be fully aware of these mechanics, it is very important that these type of risks are clearly explained to end-users as they can ultimately bear the consequences of those risks.\n> \n> Because the findings are contingent on a malicious admin, I believe Medium Severity to be appropriate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-backd-tokenomics-contest",
  "Code": [
    {
      "filename": "protocol/contracts/zaps/PoolMigrationZap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/zaps/IPoolMigrationZap.sol\";\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../../interfaces/pool/ILiquidityPool.sol\";\n\n/**\n * This is a Zap contract to assist in the migration from the V1 Backd Pools to the new Backd Pools.\n */\ncontract PoolMigrationZap is IPoolMigrationZap {\n    using SafeERC20 for IERC20;\n\n    mapping(address => ILiquidityPool) internal _underlyingNewPools; // A mapping from underlyings to new pools\n\n    event Migrated(address user, address oldPool, address newPool, uint256 lpTokenAmount); // Emitted when a migration is completed\n\n    constructor(address newAddressProviderAddress_) {\n        address[] memory newPools_ = IAddressProvider(newAddressProviderAddress_).allPools();\n        for (uint256 i; i < newPools_.length; ++i) {\n            ILiquidityPool newPool_ = ILiquidityPool(newPools_[i]);\n            address underlying_ = newPool_.getUnderlying();\n            _underlyingNewPools[underlying_] = newPool_;\n            if (underlying_ == address(0)) continue;\n            IERC20(underlying_).safeApprove(address(newPool_), type(uint256).max);\n        }\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Migrates all of a users balance from the old pools to the new pools.\n     * @dev The user must have balance in all pools given, otherwise transaction will revert.\n     * @param oldPoolAddresses_ The list of old pools to migrate for the user.\n     */\n    function migrateAll(address[] calldata oldPoolAddresses_) external override {\n        for (uint256 i; i < oldPoolAddresses_.length; ) {\n            migrate(oldPoolAddresses_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Migrates a users balance from an old pool to a new pool.\n     * @dev The user must have balance in the pool given, otherwise transaction will revert.\n     * @param oldPoolAddress_ The old pool to migrate for the user.\n     */\n    function migrate(address oldPoolAddress_) public override {\n        ILiquidityPool oldPool_ = ILiquidityPool(oldPoolAddress_);\n        IERC20 lpToken_ = IERC20(oldPool_.getLpToken());\n        uint256 lpTokenAmount_ = lpToken_.balanceOf(msg.sender);\n        require(lpTokenAmount_ != 0, \"No LP Tokens\");\n        require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, \"withdrawal fee not 0\");\n        lpToken_.safeTransferFrom(msg.sender, address(this), lpTokenAmount_);\n        uint256 underlyingAmount_ = oldPool_.redeem(lpTokenAmount_);\n        address underlying_ = oldPool_.getUnderlying();\n        ILiquidityPool newPool_ = _underlyingNewPools[underlying_];\n        uint256 ethValue_ = underlying_ == address(0) ? underlyingAmount_ : 0;\n        newPool_.depositFor{value: ethValue_}(msg.sender, underlyingAmount_);\n        emit Migrated(msg.sender, address(oldPool_), address(newPool_), lpTokenAmount_);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/BkdLocker.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../libraries/ScaledMath.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/EnumerableExtensions.sol\";\nimport \"../libraries/UncheckedMath.sol\";\nimport \"../interfaces/IBkdLocker.sol\";\nimport \"../interfaces/tokenomics/IMigrationContract.sol\";\nimport \"./utils/Preparable.sol\";\nimport \"./access/Authorization.sol\";\n\ncontract BkdLocker is IBkdLocker, Authorization, Preparable {\n    using ScaledMath for uint256;\n    using UncheckedMath for uint256;\n    using SafeERC20 for IERC20;\n    using EnumerableMapping for EnumerableMapping.AddressToUintMap;\n    using EnumerableExtensions for EnumerableMapping.AddressToUintMap;\n\n    bytes32 internal constant _START_BOOST = \"startBoost\";\n    bytes32 internal constant _MAX_BOOST = \"maxBoost\";\n    bytes32 internal constant _INCREASE_PERIOD = \"increasePeriod\";\n    bytes32 internal constant _WITHDRAW_DELAY = \"withdrawDelay\";\n\n    // User-specific data\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public boostFactors;\n    mapping(address => uint256) public lastUpdated;\n    mapping(address => WithdrawStash[]) public stashedGovTokens;\n    mapping(address => uint256) public totalStashed;\n\n    // Global data\n    uint256 public totalLocked;\n    uint256 public totalLockedBoosted;\n    uint256 public lastMigrationEvent;\n    EnumerableMapping.AddressToUintMap private _replacedRewardTokens;\n\n    // Reward token data\n    mapping(address => RewardTokenData) public rewardTokenData;\n    address public override rewardToken;\n    IERC20 public immutable govToken;\n\n    constructor(\n        address _rewardToken,\n        address _govToken,\n        IRoleManager roleManager\n    ) Authorization(roleManager) {\n        rewardToken = _rewardToken;\n        govToken = IERC20(_govToken);\n    }\n\n    function initialize(\n        uint256 startBoost,\n        uint256 maxBoost,\n        uint256 increasePeriod,\n        uint256 withdrawDelay\n    ) external override onlyGovernance {\n        require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED);\n        _setConfig(_START_BOOST, startBoost);\n        _setConfig(_MAX_BOOST, maxBoost);\n        _setConfig(_INCREASE_PERIOD, increasePeriod);\n        _setConfig(_WITHDRAW_DELAY, withdrawDelay);\n    }\n\n    /**\n     * @notice Sets a new token to be the rewardToken. Fees are then accumulated in this token.\n     * @dev Previously used rewardTokens can be set again here.\n     */\n    function migrate(address newRewardToken) external override onlyGovernance {\n        _replacedRewardTokens.remove(newRewardToken);\n        _replacedRewardTokens.set(rewardToken, block.timestamp);\n        lastMigrationEvent = block.timestamp;\n        rewardToken = newRewardToken;\n    }\n\n    /**\n     * @notice Lock gov. tokens.\n     * @dev The amount needs to be approved in advance.\n     */\n    function lock(uint256 amount) external override {\n        return lockFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Deposit fees (in the rewardToken) to be distributed to lockers of gov. tokens.\n     * @dev `deposit` or `depositFor` needs to be called at least once before this function can be called\n     * @param amount Amount of rewardToken to deposit.\n     */\n    function depositFees(uint256 amount) external override {\n        require(amount > 0, Error.INVALID_AMOUNT);\n        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];\n\n        curRewardTokenData.feeIntegral += amount.scaledDiv(totalLockedBoosted);\n        curRewardTokenData.feeBalance += amount;\n        emit FeesDeposited(amount);\n    }\n\n    function claimFees() external override {\n        claimFees(rewardToken);\n    }\n\n    /**\n     * @notice Checkpoint function to update user data, in particular the boost factor.\n     */\n    function userCheckpoint(address user) external override {\n        _userCheckpoint(user, 0, balances[user]);\n    }\n\n    /**\n     * @notice Prepare unlocking of locked gov. tokens.\n     * @dev A delay is enforced and unlocking can only be executed after that.\n     * @param amount Amount of gov. tokens to prepare for unlocking.\n     */\n    function prepareUnlock(uint256 amount) external override {\n        require(\n            totalStashed[msg.sender] + amount <= balances[msg.sender],\n            \"Amount exceeds locked balance\"\n        );\n        totalStashed[msg.sender] += amount;\n        stashedGovTokens[msg.sender].push(\n            WithdrawStash(block.timestamp + currentUInts256[_WITHDRAW_DELAY], amount)\n        );\n        emit WithdrawPrepared(msg.sender, amount);\n    }\n\n    /**\n     * @notice Execute all prepared gov. token withdrawals.\n     */\n    function executeUnlocks() external override {\n        uint256 totalAvailableToWithdraw;\n        WithdrawStash[] storage stashedWithdraws = stashedGovTokens[msg.sender];\n        uint256 length = stashedWithdraws.length;\n        require(length > 0, \"No entries\");\n        uint256 i = length;\n        while (i > 0) {\n            i = i - 1;\n            if (stashedWithdraws[i].releaseTime <= block.timestamp) {\n                totalAvailableToWithdraw += stashedWithdraws[i].amount;\n\n                stashedWithdraws[i] = stashedWithdraws[stashedWithdraws.length - 1];\n\n                stashedWithdraws.pop();\n            }\n        }\n        totalStashed[msg.sender] -= totalAvailableToWithdraw;\n        uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;\n        _userCheckpoint(msg.sender, 0, newTotal);\n        totalLocked -= totalAvailableToWithdraw;\n        govToken.safeTransfer(msg.sender, totalAvailableToWithdraw);\n        emit WithdrawExecuted(msg.sender, totalAvailableToWithdraw);\n    }\n\n    function getUserShare(address user) external view override returns (uint256) {\n        return getUserShare(user, rewardToken);\n    }\n\n    /**\n     * @notice Get the boosted locked balance for a user.\n     * @dev This includes the gov. tokens queued for withdrawal.\n     * @param user Address to get the boosted balance for.\n     * @return boosted balance for user.\n     */\n    function boostedBalance(address user) external view override returns (uint256) {\n        return balances[user].scaledMul(boostFactors[user]);\n    }\n\n    /**\n     * @notice Get the vote weight for a user.\n     * @dev This does not invlude the gov. tokens queued for withdrawal.\n     * @param user Address to get the vote weight for.\n     * @return vote weight for user.\n     */\n    function balanceOf(address user) external view override returns (uint256) {\n        return (balances[user] - totalStashed[user]).scaledMul(boostFactors[user]);\n    }\n\n    /**\n     * @notice Get the share of the total boosted locked balance for a user.\n     * @dev This includes the gov. tokens queued for withdrawal.\n     * @param user Address to get the share of the total boosted balance for.\n     * @return share of the total boosted balance for user.\n     */\n    function getShareOfTotalBoostedBalance(address user) external view override returns (uint256) {\n        return balances[user].scaledMul(boostFactors[user]).scaledDiv(totalLockedBoosted);\n    }\n\n    function getStashedGovTokens(address user)\n        external\n        view\n        override\n        returns (WithdrawStash[] memory)\n    {\n        return stashedGovTokens[user];\n    }\n\n    function claimableFees(address user) external view override returns (uint256) {\n        return claimableFees(user, rewardToken);\n    }\n\n    /**\n     * @notice Claim fees accumulated in the Locker.\n     */\n    function claimFees(address _rewardToken) public override {\n        require(\n            _rewardToken == rewardToken || _replacedRewardTokens.contains(_rewardToken),\n            Error.INVALID_ARGUMENT\n        );\n        _userCheckpoint(msg.sender, 0, balances[msg.sender]);\n        RewardTokenData storage curRewardTokenData = rewardTokenData[_rewardToken];\n        uint256 claimable = curRewardTokenData.userShares[msg.sender];\n        curRewardTokenData.userShares[msg.sender] = 0;\n        curRewardTokenData.feeBalance -= claimable;\n        IERC20(_rewardToken).safeTransfer(msg.sender, claimable);\n        emit RewardsClaimed(msg.sender, _rewardToken, claimable);\n    }\n\n    /**\n     * @notice Lock gov. tokens on behalf of another user.\n     * @dev The amount needs to be approved in advance.\n     * @param user Address of user to lock on behalf of.\n     * @param amount Amount of gov. tokens to lock.\n     */\n    function lockFor(address user, uint256 amount) public override {\n        govToken.safeTransferFrom(msg.sender, address(this), amount);\n        _userCheckpoint(user, amount, balances[user] + amount);\n        totalLocked += amount;\n        emit Locked(user, amount);\n    }\n\n    function getUserShare(address user, address _rewardToken)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return rewardTokenData[_rewardToken].userShares[user];\n    }\n\n    function claimableFees(address user, address _rewardToken)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 currentShare;\n        uint256 userBalance = balances[user];\n        RewardTokenData storage curRewardTokenData = rewardTokenData[_rewardToken];\n\n        // Compute the share earned by the user since they last updated\n        if (userBalance > 0) {\n            currentShare += (curRewardTokenData.feeIntegral -\n                curRewardTokenData.userFeeIntegrals[user]).scaledMul(\n                    userBalance.scaledMul(boostFactors[user])\n                );\n        }\n        return curRewardTokenData.userShares[user] + currentShare;\n    }\n\n    function computeNewBoost(\n        address user,\n        uint256 amountAdded,\n        uint256 newTotal\n    ) public view override returns (uint256) {\n        uint256 newBoost;\n        uint256 balance = balances[user];\n        uint256 startBoost = currentUInts256[_START_BOOST];\n        if (balance == 0 || newTotal == 0) {\n            newBoost = startBoost;\n        } else {\n            uint256 maxBoost = currentUInts256[_MAX_BOOST];\n            newBoost = boostFactors[user];\n            newBoost += (block.timestamp - lastUpdated[user])\n                .scaledDiv(currentUInts256[_INCREASE_PERIOD])\n                .scaledMul(maxBoost - startBoost);\n            if (newBoost > maxBoost) {\n                newBoost = maxBoost;\n            }\n            if (newTotal <= balance) {\n                return newBoost;\n            }\n            newBoost =\n                newBoost.scaledMul(balance.scaledDiv(newTotal)) +\n                startBoost.scaledMul(amountAdded.scaledDiv(newTotal));\n        }\n        return newBoost;\n    }\n\n    function _userCheckpoint(\n        address user,\n        uint256 amountAdded,\n        uint256 newTotal\n    ) internal {\n        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];\n\n        // Compute the share earned by the user since they last updated\n        uint256 userBalance = balances[user];\n        if (userBalance > 0) {\n            curRewardTokenData.userShares[user] += (curRewardTokenData.feeIntegral -\n                curRewardTokenData.userFeeIntegrals[user]).scaledMul(\n                    userBalance.scaledMul(boostFactors[user])\n                );\n\n            // Update values for previous rewardTokens\n            if (lastUpdated[user] < lastMigrationEvent) {\n                uint256 length = _replacedRewardTokens.length();\n                for (uint256 i; i < length; i = i.uncheckedInc()) {\n                    (address token, uint256 replacedAt) = _replacedRewardTokens.at(i);\n                    if (lastUpdated[user] < replacedAt) {\n                        RewardTokenData storage prevRewardTokenData = rewardTokenData[token];\n                        prevRewardTokenData.userShares[user] += (prevRewardTokenData.feeIntegral -\n                            prevRewardTokenData.userFeeIntegrals[user]).scaledMul(\n                                userBalance.scaledMul(boostFactors[user])\n                            );\n                        prevRewardTokenData.userFeeIntegrals[user] = prevRewardTokenData\n                            .feeIntegral;\n                    }\n                }\n            }\n        }\n\n        uint256 newBoost = computeNewBoost(user, amountAdded, newTotal);\n        totalLockedBoosted =\n            totalLockedBoosted +\n            newTotal.scaledMul(newBoost) -\n            balances[user].scaledMul(boostFactors[user]);\n\n        // Update user values\n        curRewardTokenData.userFeeIntegrals[user] = curRewardTokenData.feeIntegral;\n        lastUpdated[user] = block.timestamp;\n        boostFactors[user] = newBoost;\n        balances[user] = newTotal;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/RewardHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IFeeBurner.sol\";\nimport \"../interfaces/IBkdLocker.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IRewardHandler.sol\";\nimport \"./utils/Preparable.sol\";\nimport \"./access/Authorization.sol\";\nimport \"../libraries/AddressProviderHelpers.sol\";\nimport \"../libraries/UncheckedMath.sol\";\n\ncontract RewardHandler is IRewardHandler, Preparable, Authorization {\n    using UncheckedMath for uint256;\n    using SafeERC20 for IERC20;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = IAddressProvider(controller.addressProvider());\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Burns all accumulated fees and pays these out to the BKD locker.\n     */\n    function burnFees() external override {\n        IBkdLocker bkdLocker = IBkdLocker(addressProvider.getBKDLocker());\n        IFeeBurner feeBurner = addressProvider.getFeeBurner();\n        address targetLpToken = bkdLocker.rewardToken();\n        address[] memory pools = addressProvider.allPools();\n        uint256 ethBalance = address(this).balance;\n        address[] memory tokens = new address[](pools.length);\n        for (uint256 i; i < pools.length; i = i.uncheckedInc()) {\n            ILiquidityPool pool = ILiquidityPool(pools[i]);\n            address underlying = pool.getUnderlying();\n            if (underlying != address(0)) {\n                _approve(underlying, address(feeBurner));\n            }\n            tokens[i] = underlying;\n        }\n        feeBurner.burnToTarget{value: ethBalance}(tokens, targetLpToken);\n        uint256 burnedAmount = IERC20(targetLpToken).balanceOf(address(this));\n        IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount);\n        bkdLocker.depositFees(burnedAmount);\n        emit Burned(targetLpToken, burnedAmount);\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) > 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/zaps/PoolMigrationZap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/zaps/IPoolMigrationZap.sol\";\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../../interfaces/pool/ILiquidityPool.sol\";\n\n/**\n * This is a Zap contract to assist in the migration from the V1 Backd Pools to the new Backd Pools.\n */\ncontract PoolMigrationZap is IPoolMigrationZap {\n    using SafeERC20 for IERC20;\n\n    mapping(address => ILiquidityPool) internal _underlyingNewPools; // A mapping from underlyings to new pools\n\n    event Migrated(address user, address oldPool, address newPool, uint256 lpTokenAmount); // Emitted when a migration is completed\n\n    constructor(address newAddressProviderAddress_) {\n        address[] memory newPools_ = IAddressProvider(newAddressProviderAddress_).allPools();\n        for (uint256 i; i < newPools_.length; ++i) {\n            ILiquidityPool newPool_ = ILiquidityPool(newPools_[i]);\n            address underlying_ = newPool_.getUnderlying();\n            _underlyingNewPools[underlying_] = newPool_;\n            if (underlying_ == address(0)) continue;\n            IERC20(underlying_).safeApprove(address(newPool_), type(uint256).max);\n        }\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Migrates all of a users balance from the old pools to the new pools.\n     * @dev The user must have balance in all pools given, otherwise transaction will revert.\n     * @param oldPoolAddresses_ The list of old pools to migrate for the user.\n     */\n    function migrateAll(address[] calldata oldPoolAddresses_) external override {\n        for (uint256 i; i < oldPoolAddresses_.length; ) {\n            migrate(oldPoolAddresses_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Migrates a users balance from an old pool to a new pool.\n     * @dev The user must have balance in the pool given, otherwise transaction will revert.\n     * @param oldPoolAddress_ The old pool to migrate for the user.\n     */\n    function migrate(address oldPoolAddress_) public override {\n        ILiquidityPool oldPool_ = ILiquidityPool(oldPoolAddress_);\n        IERC20 lpToken_ = IERC20(oldPool_.getLpToken());\n        uint256 lpTokenAmount_ = lpToken_.balanceOf(msg.sender);\n        require(lpTokenAmount_ != 0, \"No LP Tokens\");\n        require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, \"withdrawal fee not 0\");\n        lpToken_.safeTransferFrom(msg.sender, address(this), lpTokenAmount_);\n        uint256 underlyingAmount_ = oldPool_.redeem(lpTokenAmount_);\n        address underlying_ = oldPool_.getUnderlying();\n        ILiquidityPool newPool_ = _underlyingNewPools[underlying_];\n        uint256 ethValue_ = underlying_ == address(0) ? underlyingAmount_ : 0;\n        newPool_.depositFor{value: ethValue_}(msg.sender, underlyingAmount_);\n        emit Migrated(msg.sender, address(oldPool_), address(newPool_), lpTokenAmount_);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/BkdLocker.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../libraries/ScaledMath.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/EnumerableExtensions.sol\";\nimport \"../libraries/UncheckedMath.sol\";\nimport \"../interfaces/IBkdLocker.sol\";\nimport \"../interfaces/tokenomics/IMigrationContract.sol\";\nimport \"./utils/Preparable.sol\";\nimport \"./access/Authorization.sol\";\n\ncontract BkdLocker is IBkdLocker, Authorization, Preparable {\n    using ScaledMath for uint256;\n    using UncheckedMath for uint256;\n    using SafeERC20 for IERC20;\n    using EnumerableMapping for EnumerableMapping.AddressToUintMap;\n    using EnumerableExtensions for EnumerableMapping.AddressToUintMap;\n\n    bytes32 internal constant _START_BOOST = \"startBoost\";\n    bytes32 internal constant _MAX_BOOST = \"maxBoost\";\n    bytes32 internal constant _INCREASE_PERIOD = \"increasePeriod\";\n    bytes32 internal constant _WITHDRAW_DELAY = \"withdrawDelay\";\n\n    // User-specific data\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public boostFactors;\n    mapping(address => uint256) public lastUpdated;\n    mapping(address => WithdrawStash[]) public stashedGovTokens;\n    mapping(address => uint256) public totalStashed;\n\n    // Global data\n    uint256 public totalLocked;\n    uint256 public totalLockedBoosted;\n    uint256 public lastMigrationEvent;\n    EnumerableMapping.AddressToUintMap private _replacedRewardTokens;\n\n    // Reward token data\n    mapping(address => RewardTokenData) public rewardTokenData;\n    address public override rewardToken;\n    IERC20 public immutable govToken;\n\n    constructor(\n        address _rewardToken,\n        address _govToken,\n        IRoleManager roleManager\n    ) Authorization(roleManager) {\n        rewardToken = _rewardToken;\n        govToken = IERC20(_govToken);\n    }\n\n    function initialize(\n        uint256 startBoost,\n        uint256 maxBoost,\n        uint256 increasePeriod,\n        uint256 withdrawDelay\n    ) external override onlyGovernance {\n        require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED);\n        _setConfig(_START_BOOST, startBoost);\n        _setConfig(_MAX_BOOST, maxBoost);\n        _setConfig(_INCREASE_PERIOD, increasePeriod);\n        _setConfig(_WITHDRAW_DELAY, withdrawDelay);\n    }\n\n    /**\n     * @notice Sets a new token to be the rewardToken. Fees are then accumulated in this token.\n     * @dev Previously used rewardTokens can be set again here.\n     */\n    function migrate(address newRewardToken) external override onlyGovernance {\n        _replacedRewardTokens.remove(newRewardToken);\n        _replacedRewardTokens.set(rewardToken, block.timestamp);\n        lastMigrationEvent = block.timestamp;\n        rewardToken = newRewardToken;\n    }\n\n    /**\n     * @notice Lock gov. tokens.\n     * @dev The amount needs to be approved in advance.\n     */\n    function lock(uint256 amount) external override {\n        return lockFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Deposit fees (in the rewardToken) to be distributed to lockers of gov. tokens.\n     * @dev `deposit` or `depositFor` needs to be called at least once before this function can be called\n     * @param amount Amount of rewardToken to deposit.\n     */\n    function depositFees(uint256 amount) external override {\n        require(amount > 0, Error.INVALID_AMOUNT);\n        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];\n\n        curRewardTokenData.feeIntegral += amount.scaledDiv(totalLockedBoosted);\n        curRewardTokenData.feeBalance += amount;\n        emit FeesDeposited(amount);\n    }\n\n    function claimFees() external override {\n        claimFees(rewardToken);\n    }\n\n    /**\n     * @notice Checkpoint function to update user data, in particular the boost factor.\n     */\n    function userCheckpoint(address user) external override {\n        _userCheckpoint(user, 0, balances[user]);\n    }\n\n    /**\n     * @notice Prepare unlocking of locked gov. tokens.\n     * @dev A delay is enforced and unlocking can only be executed after that.\n     * @param amount Amount of gov. tokens to prepare for unlocking.\n     */\n    function prepareUnlock(uint256 amount) external override {\n        require(\n            totalStashed[msg.sender] + amount <= balances[msg.sender],\n            \"Amount exceeds locked balance\"\n        );\n        totalStashed[msg.sender] += amount;\n        stashedGovTokens[msg.sender].push(\n            WithdrawStash(block.timestamp + currentUInts256[_WITHDRAW_DELAY], amount)\n        );\n        emit WithdrawPrepared(msg.sender, amount);\n    }\n\n    /**\n     * @notice Execute all prepared gov. token withdrawals.\n     */\n    function executeUnlocks() external override {\n        uint256 totalAvailableToWithdraw;\n        WithdrawStash[] storage stashedWithdraws = stashedGovTokens[msg.sender];\n        uint256 length = stashedWithdraws.length;\n        require(length > 0, \"No entries\");\n        uint256 i = length;\n        while (i > 0) {\n            i = i - 1;\n            if (stashedWithdraws[i].releaseTime <= block.timestamp) {\n                totalAvailableToWithdraw += stashedWithdraws[i].amount;\n\n                stashedWithdraws[i] = stashedWithdraws[stashedWithdraws.length - 1];\n\n                stashedWithdraws.pop();\n            }\n        }\n        totalStashed[msg.sender] -= totalAvailableToWithdraw;\n        uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;\n        _userCheckpoint(msg.sender, 0, newTotal);\n        totalLocked -= totalAvailableToWithdraw;\n        govToken.safeTransfer(msg.sender, totalAvailableToWithdraw);\n        emit WithdrawExecuted(msg.sender, totalAvailableToWithdraw);\n    }\n\n    function getUserShare(address user) external view override returns (uint256) {\n        return getUserShare(user, rewardToken);\n    }\n\n    /**\n     * @notice Get the boosted locked balance for a user.\n     * @dev This includes the gov. tokens queued for withdrawal.\n     * @param user Address to get the boosted balance for.\n     * @return boosted balance for user.\n     */\n    function boostedBalance(address user) external view override returns (uint256) {\n        return balances[user].scaledMul(boostFactors[user]);\n    }\n\n    /**\n     * @notice Get the vote weight for a user.\n     * @dev This does not invlude the gov. tokens queued for withdrawal.\n     * @param user Address to get the vote weight for.\n     * @return vote weight for user.\n     */\n    function balanceOf(address user) external view override returns (uint256) {\n        return (balances[user] - totalStashed[user]).scaledMul(boostFactors[user]);\n    }\n\n    /**\n     * @notice Get the share of the total boosted locked balance for a user.\n     * @dev This includes the gov. tokens queued for withdrawal.\n     * @param user Address to get the share of the total boosted balance for.\n     * @return share of the total boosted balance for user.\n     */\n    function getShareOfTotalBoostedBalance(address user) external view override returns (uint256) {\n        return balances[user].scaledMul(boostFactors[user]).scaledDiv(totalLockedBoosted);\n    }\n\n    function getStashedGovTokens(address user)\n        external\n        view\n        override\n        returns (WithdrawStash[] memory)\n    {\n        return stashedGovTokens[user];\n    }\n\n    function claimableFees(address user) external view override returns (uint256) {\n        return claimableFees(user, rewardToken);\n    }\n\n    /**\n     * @notice Claim fees accumulated in the Locker.\n     */\n    function claimFees(address _rewardToken) public override {\n        require(\n            _rewardToken == rewardToken || _replacedRewardTokens.contains(_rewardToken),\n            Error.INVALID_ARGUMENT\n        );\n        _userCheckpoint(msg.sender, 0, balances[msg.sender]);\n        RewardTokenData storage curRewardTokenData = rewardTokenData[_rewardToken];\n        uint256 claimable = curRewardTokenData.userShares[msg.sender];\n        curRewardTokenData.userShares[msg.sender] = 0;\n        curRewardTokenData.feeBalance -= claimable;\n        IERC20(_rewardToken).safeTransfer(msg.sender, claimable);\n        emit RewardsClaimed(msg.sender, _rewardToken, claimable);\n    }\n\n    /**\n     * @notice Lock gov. tokens on behalf of another user.\n     * @dev The amount needs to be approved in advance.\n     * @param user Address of user to lock on behalf of.\n     * @param amount Amount of gov. tokens to lock.\n     */\n    function lockFor(address user, uint256 amount) public override {\n        govToken.safeTransferFrom(msg.sender, address(this), amount);\n        _userCheckpoint(user, amount, balances[user] + amount);\n        totalLocked += amount;\n        emit Locked(user, amount);\n    }\n\n    function getUserShare(address user, address _rewardToken)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return rewardTokenData[_rewardToken].userShares[user];\n    }\n\n    function claimableFees(address user, address _rewardToken)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 currentShare;\n        uint256 userBalance = balances[user];\n        RewardTokenData storage curRewardTokenData = rewardTokenData[_rewardToken];\n\n        // Compute the share earned by the user since they last updated\n        if (userBalance > 0) {\n            currentShare += (curRewardTokenData.feeIntegral -\n                curRewardTokenData.userFeeIntegrals[user]).scaledMul(\n                    userBalance.scaledMul(boostFactors[user])\n                );\n        }\n        return curRewardTokenData.userShares[user] + currentShare;\n    }\n\n    function computeNewBoost(\n        address user,\n        uint256 amountAdded,\n        uint256 newTotal\n    ) public view override returns (uint256) {\n        uint256 newBoost;\n        uint256 balance = balances[user];\n        uint256 startBoost = currentUInts256[_START_BOOST];\n        if (balance == 0 || newTotal == 0) {\n            newBoost = startBoost;\n        } else {\n            uint256 maxBoost = currentUInts256[_MAX_BOOST];\n            newBoost = boostFactors[user];\n            newBoost += (block.timestamp - lastUpdated[user])\n                .scaledDiv(currentUInts256[_INCREASE_PERIOD])\n                .scaledMul(maxBoost - startBoost);\n            if (newBoost > maxBoost) {\n                newBoost = maxBoost;\n            }\n            if (newTotal <= balance) {\n                return newBoost;\n            }\n            newBoost =\n                newBoost.scaledMul(balance.scaledDiv(newTotal)) +\n                startBoost.scaledMul(amountAdded.scaledDiv(newTotal));\n        }\n        return newBoost;\n    }\n\n    function _userCheckpoint(\n        address user,\n        uint256 amountAdded,\n        uint256 newTotal\n    )"
    }
  ]
}