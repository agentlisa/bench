{
  "Title": "H-2: Malicious users can honeypot other users by transferring out ERC20 and ERC721 tokens right before sale",
  "Content": "# Issue H-2: Malicious users can honeypot other users by transferring out ERC20 and ERC721 tokens right before sale \n\nSource: https://github.com/sherlock-audit/2023-04-footium-judging/issues/291 \n\n## Found by \n0x52, 0xAsen, 0xRobocop, BAHOZ, Dug, J4de, ast3ros, igingu, kiki\\_dev, sashik\\_eth, shogoki\n## Summary\n\nSince the club and escrow are separate and tokens can be transferred at any time by the owner, it allows malicious users to honeypot victims. \n\n## Vulnerability Detail\n\nTokens can be transferred out of the escrow by the owner of the club at anytime. This includes right before (or even in the same block) that the club is sold. This allows users to easily honeypot victims when selling clubs:\n\n1) User A owns Club 1\n2) Club 1 has players worth 5 ETH\n3) User A lists Club 1 for 2.5 ETH\n4) User B buys Club 1\n5) User A sees the transaction in the mempool and quickly transfers all the players out\n6) User A maintains all their players and User B now has an empty club\n\n## Impact\n\nMalicious users can honeypot other users\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumEscrow.sol#L105-L111\n\nhttps://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumEscrow.sol#L120-L126\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nClub/escrow system needs a redesign\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/71",
  "Code": [
    {
      "filename": "footium-eth-shareable/contracts/FootiumEscrow.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./common/Errors.sol\";\n\n/**\n * @title Footium Escrow\n * @notice An escrow contract that stores club's players and tokens.\n */\ncontract FootiumEscrow is ERC721Holder, IERC1271 {\n    bytes4 private constant MAGICVALUE = 0x1626ba7e;\n\n    address private immutable footiumClubAddress;\n    uint256 private immutable clubId;\n\n    event ETHReceived(address sender, uint256 amount);\n\n    /**\n     * @notice Constructs Footium Escrow contract\n     * @param _footiumClubAddress The address of Footium Club contract.\n     * @param _clubId Footium Club ID.\n     */\n    constructor(address _footiumClubAddress, uint256 _clubId) {\n        footiumClubAddress = _footiumClubAddress;\n        clubId = _clubId;\n    }\n\n    modifier onlyClubOwner() {\n        if (msg.sender != IERC721(footiumClubAddress).ownerOf(clubId)) {\n            revert NotClubOwner(clubId, msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * @notice Enables the contract to receive ETH\n     * Emits a {ETHReceived} event when ETH is received.\n     */\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Checks if the signature is valid.\n     * @param hash The Hashed message.\n     * @param signature The signature of hashed message.\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature)\n        external\n        view\n        returns (bytes4 magicValue)\n    {\n        if (\n            ECDSA.recover(hash, signature) ==\n            IERC721(footiumClubAddress).ownerOf(clubId)\n        ) {\n            return MAGICVALUE;\n        }\n\n        return 0xffffffff;\n    }\n\n    /**\n     * @notice Sets approval for ERC20 tokens.\n     * @param erc20Contract ERC20 contract address.\n     * @param to The address of token spender.\n     * @param amount Token amount to spend.\n     * @dev only the club owner address allowed.\n     */\n    function setApprovalForERC20(\n        IERC20 erc20Contract,\n        address to,\n        uint256 amount\n    ) external onlyClubOwner {\n        erc20Contract.approve(to, amount);\n    }\n\n    /**\n     * @notice Sets approval for ERC721 tokens.\n     * @param erc721Contract ERC721 contract address.\n     * @param to The address of token spender.\n     * @param approved Boolean flag indicating whether approved or not.\n     * @dev only the club owner address allowed.\n     */\n    function setApprovalForERC721(\n        IERC721 erc721Contract,\n        address to,\n        bool approved\n    ) external onlyClubOwner {\n        erc721Contract.setApprovalForAll(to, approved);\n    }\n\n    /**\n     * @notice Transfers ERC20 tokens to `to` address.\n     * @param erc20Contract ERC20 contract address.\n     * @param to Token receiver address.\n     * @param amount Token amount to transfer.\n     * @dev only the club owner address allowed.\n     */\n    function transferERC20(\n        IERC20 erc20Contract,\n        address to,\n        uint256 amount\n    ) external onlyClubOwner {\n        erc20Contract.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers ERC721 tokens to `to` address.\n     * @param erc721Contract ERC721 contract address.\n     * @param to Token receiver address.\n     * @param tokenId Token ID to be transferred.\n     * @dev only the club owner address allowed.\n     */\n    function transferERC721(\n        IERC721 erc721Contract,\n        address to,\n        uint256 tokenId\n    ) external onlyClubOwner {\n        erc721Contract.safeTransferFrom(address(this), to, tokenId);\n    }\n\n    /**\n     * @notice Transfers contract available ether balance to the club owner address\n     * @dev Only club owner address allowed\n     */\n    function withdraw() external onlyClubOwner {\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            (bool sent, ) = payable(msg.sender).call{value: balance}(\"\");\n            if (!sent) {\n                revert FailedToSendETH(balance);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "footium-eth-shareable/contracts/FootiumEscrow.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./common/Errors.sol\";\n\n/**\n * @title Footium Escrow\n * @notice An escrow contract that stores club's players and tokens.\n */\ncontract FootiumEscrow is ERC721Holder, IERC1271 {\n    bytes4 private constant MAGICVALUE = 0x1626ba7e;\n\n    address private immutable footiumClubAddress;\n    uint256 private immutable clubId;\n\n    event ETHReceived(address sender, uint256 amount);\n\n    /**\n     * @notice Constructs Footium Escrow contract\n     * @param _footiumClubAddress The address of Footium Club contract.\n     * @param _clubId Footium Club ID.\n     */\n    constructor(address _footiumClubAddress, uint256 _clubId) {\n        footiumClubAddress = _footiumClubAddress;\n        clubId = _clubId;\n    }\n\n    modifier onlyClubOwner() {\n        if (msg.sender != IERC721(footiumClubAddress).ownerOf(clubId)) {\n            revert NotClubOwner(clubId, msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * @notice Enables the contract to receive ETH\n     * Emits a {ETHReceived} event when ETH is received.\n     */\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Checks if the signature is valid.\n     * @param hash The Hashed message.\n     * @param signature The signature of hashed message.\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature)\n        external\n        view\n        returns (bytes4 magicValue)\n    {\n        if (\n            ECDSA.recover(hash, signature) ==\n            IERC721(footiumClubAddress).ownerOf(clubId)\n        ) {\n            return MAGICVALUE;\n        }\n\n        return 0xffffffff;\n    }\n\n    /**\n     * @notice Sets approval for ERC20 tokens.\n     * @param erc20Contract ERC20 contract address.\n     * @param to The address of token spender.\n     * @param amount Token amount to spend.\n     * @dev only the club owner address allowed.\n     */\n    function setApprovalForERC20(\n        IERC20 erc20Contract,\n        address to,\n        uint256 amount\n    ) external onlyClubOwner {\n        erc20Contract.approve(to, amount);\n    }\n\n    /**\n     * @notice Sets approval for ERC721 tokens.\n     * @param erc721Contract ERC721 contract address.\n     * @param to The address of token spender.\n     * @param approved Boolean flag indicating whether approved or not.\n     * @dev only the club owner address allowed.\n     */\n    function setApprovalForERC721(\n        IERC721 erc721Contract,\n        address to,\n        bool approved\n    ) external onlyClubOwner {\n        erc721Contract.setApprovalForAll(to, approved);\n    }\n\n    /**\n     * @notice Transfers ERC20 tokens to `to` address.\n     * @param erc20Contract ERC20 contract address.\n     * @param to Token receiver address.\n     * @param amount Token amount to transfer.\n     * @dev only the club owner address allowed.\n     */\n    function transferERC20(\n        IERC20 erc20Contract,\n        address to,\n        uint256 amount\n    ) external onlyClubOwner {\n        erc20Contract.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers ERC721 tokens to `to` address.\n     * @param erc721Contract ERC721 contract address.\n     * @param to Token receiver address.\n     * @param tokenId Token ID to be transferred.\n     * @dev only the club owner address allowed.\n     */\n    function transferERC721(\n        IERC721 erc721Contract,\n        address to,\n        uint256 tokenId\n    ) external onlyClubOwner {\n        erc721Contract.safeTransferFrom(address(this), to, tokenId);\n    }\n\n    /**\n     * @notice Transfers contract available ether balance to the club owner address\n     * @dev Only club owner address allowed\n     */\n    function withdraw() external onlyClubOwner {\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            (bool sent, ) = payable(msg.sender).call{value: balance}(\"\");\n            if (!sent) {\n                revert FailedToSendETH(balance);\n            }\n        }\n    }\n}"
    }
  ]
}