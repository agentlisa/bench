{
  "Title": "[M02] Fragile implementation of conversion from integer to UTF-8 representation",
  "Content": "The private [`_uintToBytes` function](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Governor.sol#L193) of the `Governor` contract intends to convert any given integer number into its [UTF-8](https://en.wikipedia.org/wiki/UTF-8) bytes representation, returned as a `bytes32` type. Even though the function works as intended, we consider its implementation to be dangerously fragile for the following reasons:\n\n\n* Misleading function name: the function does not return a `bytes` type, but rather a `bytes32`.\n* Unclear intention: the fact that the function attempts to build a UTF-8 representation of the passed integer is not clear at all without thorough manual inspection.\n* Untested implementation: no unit tests were found for this function. Given the code was copied, and adapted, from an answer [in an online forum](https://ethereum.stackexchange.com/a/6613/47801), the lack of tests is particularly risky.\n* Lack of documentation: the function operates at a byte level to reproduce the UTF-8 representation of an integer, but none of the low-level steps are explained.\n* Hardcoded values: the function uses multiple hardcoded values without explaining what they represent.\n* Failing silently: the function implicitly discards any digits after the 32nd, failing silently at representing large numbers and producing output collisions.\n\n\nConsider refactoring, documenting and testing the `_uintToBytes` function of the `Governor` contract to address these shortcomings.\n\n\n**Update**: *Fixed in [PR#1204](https://github.com/UMAprotocol/protocol/pull/1204).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "core/contracts/oracle/implementation/Governor.sol",
      "content": "pragma solidity ^0.6.0;\n\npragma experimental ABIEncoderV2;\n\nimport \"../../common/implementation/MultiRole.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../interfaces/FinderInterface.sol\";\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../interfaces/OracleInterface.sol\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n/**\n * @title Takes proposals for certain governance actions and allows UMA token holders to vote on them.\n */\ncontract Governor is MultiRole, Testable {\n    using SafeMath for uint;\n\n    /****************************************\n     *     INTERNAL VARIABLES AND STORAGE   *\n     ****************************************/\n\n    enum Roles {\n        Owner, // Can set the proposer.\n        Proposer // Address that can make proposals.\n    }\n\n    struct Transaction {\n        address to;\n        uint value;\n        bytes data;\n    }\n\n    struct Proposal {\n        Transaction[] transactions;\n        uint requestTime;\n    }\n\n    FinderInterface private finder;\n    Proposal[] public proposals;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    // Emitted when a new proposal is created.\n    event NewProposal(uint indexed id, Transaction[] transactions);\n\n    // Emitted when an existing proposal is executed.\n    event ProposalExecuted(uint indexed id, uint transactionIndex);\n\n    /**\n     * @notice Construct the Governor contract.\n     * @param _finderAddress keeps track of all contracts within the system based on their interfaceName.\n     * @param _isTest whether this contract is being constructed for the purpose of running automated tests.\n     */\n    constructor(address _finderAddress, bool _isTest) public Testable(_isTest) {\n        finder = FinderInterface(_finderAddress);\n        _createExclusiveRole(uint(Roles.Owner), uint(Roles.Owner), msg.sender);\n        _createExclusiveRole(uint(Roles.Proposer), uint(Roles.Owner), msg.sender);\n    }\n\n    /****************************************\n     *          PROPOSAL ACTIONS            *\n     ****************************************/\n\n    /**\n     * @notice Proposes a new governance action. Can only be called by the holder of the Proposer role.\n     * @param transactions the list of transactions that are being proposed.\n     * @dev You can create the data portion of each transaction by doing the following:\n     * ```\n     * const truffleContractInstance = await TruffleContract.deployed()\n     * const data = truffleContractInstance.methods.methodToCall(arg1, arg2).encodeABI()\n     * ```\n     * Note: this method must be public because of a solidity limitation that\n     * disallows structs arrays to be passed to external functions.\n     * @param transactions array of `Transaction` which can be voted on.\n     */\n    function propose(Transaction[] memory transactions) public onlyRoleHolder(uint(Roles.Proposer)) {\n        uint id = proposals.length;\n        uint time = getCurrentTime();\n\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\n        // structs in storage to an an array of structs in memory is currently not implemented in solidity :/.\n\n        // Add a zero-initialized element to the proposals array.\n        proposals.push();\n\n        // Initialize the new proposal.\n        Proposal storage proposal = proposals[id];\n        proposal.requestTime = time;\n\n        // Initialize the transaction array.\n        for (uint i = 0; i < transactions.length; i++) {\n            require(transactions[i].to != address(0), \"The to address cannot be 0x0\");\n            proposal.transactions.push(transactions[i]);\n        }\n\n        bytes32 identifier = _constructIdentifier(id);\n\n        // Request a vote on this proposal in the DVM.\n        OracleInterface oracle = _getOracle();\n        IdentifierWhitelistInterface supportedIdentifiers = _getIdentifierWhitelist();\n        supportedIdentifiers.addSupportedIdentifier(identifier);\n\n        oracle.requestPrice(identifier, time);\n        supportedIdentifiers.removeSupportedIdentifier(identifier);\n\n        emit NewProposal(id, transactions);\n    }\n\n    /**\n     * @notice Executes a proposed governance action that has been approved by voters.\n     * @dev This can be called by any address.\n     * @param id unique id for the executed proposal.\n     * @param transactionIndex unique transaction index for the executed proposal.\n     */\n    function executeProposal(uint id, uint transactionIndex) external {\n        Proposal storage proposal = proposals[id];\n        int price = _getOracle().getPrice(_constructIdentifier(id), proposal.requestTime);\n\n        Transaction storage transaction = proposal.transactions[transactionIndex];\n\n        require(\n            transactionIndex == 0 || proposal.transactions[transactionIndex.sub(1)].to == address(0),\n            \"Previous transaction has not been executed\"\n        );\n        require(transaction.to != address(0), \"Transaction has already been executed\");\n        require(price != 0, \"Cannot execute, proposal was voted down\");\n        require(_executeCall(transaction.to, transaction.value, transaction.data), \"Transaction execution failed\");\n\n        // Delete the transaction.\n        delete proposal.transactions[transactionIndex];\n\n        emit ProposalExecuted(id, transactionIndex);\n    }\n\n    /***************************************\n     *       GOVERNOR STATE GETTERS         *\n     ****************************************/\n\n    /**\n     * @notice Gets the total number of proposals (includes executed and non-executed).\n     * @return uint representing the current number of proposals.\n     */\n    function numProposals() external view returns (uint) {\n        return proposals.length;\n    }\n\n    /**\n     * @notice Gets the proposal data for a particular id.\n     * @dev after a proposal is executed, its data will be zeroed out.\n     * @param id uniquely identify the identity of the proposal.\n     * @return proposal struct containing transactions[] and requestTime.\n     */\n    function getProposal(uint id) external view returns (Proposal memory proposal) {\n        return proposals[id];\n    }\n\n    /****************************************\n     *      PRIVATE GETTERS AND FUNCTIONS   *\n     ****************************************/\n\n    function _executeCall(address to, uint256 value, bytes memory data) private returns (bool success) {\n        // Mostly copied from:\n        // solhint-disable-next-line max-line-length\n        // https://github.com/gnosis/safe-contracts/blob/59cfdaebcd8b87a0a32f87b50fead092c10d3a05/contracts/base/Executor.sol#L23-L31\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n            let inputData := add(data, 0x20)\n            let inputDataSize := mload(data)\n            success := call(gas(), to, value, inputData, inputDataSize, 0, 0)\n        }\n    }\n\n    function _getOracle() private view returns (OracleInterface oracle) {\n        return OracleInterface(finder.getImplementationAddress(\"Oracle\"));\n    }\n\n    function _getIdentifierWhitelist() private view returns (IdentifierWhitelistInterface supportedIdentifiers) {\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(\"IdentifierWhitelist\"));\n    }\n\n    function _constructIdentifier(uint id) private pure returns (bytes32 identifier) {\n        bytes32 bytesId = _uintToBytes(id);\n        return _addPrefix(bytesId, \"Admin \", 6);\n    }\n\n    // This method is based off of this code: https://ethereum.stackexchange.com/a/6613/47801.\n    function _uintToBytes(uint v) private pure returns (bytes32 ret) {\n        if (v == 0) {\n            ret = \"0\";\n        } else {\n            while (v > 0) {\n                ret = ret >> 8;\n                ret |= bytes32((v % 10) + 48) << (31 * 8);\n                v /= 10;\n            }\n        }\n        return ret;\n    }\n\n    function _addPrefix(bytes32 input, bytes32 prefix, uint prefixLength) private pure returns (bytes32 output) {\n        bytes32 shiftedInput = input >> (prefixLength * 8);\n        return shiftedInput | prefix;\n    }\n}"
    }
  ]
}