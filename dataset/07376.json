{
  "Title": "[G-13] Pack Bid Struct",
  "Content": "\nThe Bid struct can be packed tighter\n\n```solidity\nstruct Bid {\n    uint256 bidId;\n    address owner;\n    uint256 price;\n    uint256 quantity;\n}\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol#L4-L9)\n\nto\n\n```solidity\nstruct Bid {\n    uint96 bidId;\n    address owner;\n    uint256 price;\n    uint256 quantity;\n}\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-12-tessera-versus-contest",
  "Code": [
    {
      "filename": "src/lib/MinPriorityQueue.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nstruct Bid {\n    uint256 bidId;\n    address owner;\n    uint256 price;\n    uint256 quantity;\n}\n\n///@notice a min priority queue implementation, based off https://algs4.cs.princeton.edu/24pq/MinPQ.java.html\nlibrary MinPriorityQueue {\n    struct Queue {\n        ///@notice incrementing bid id\n        uint256 nextBidId;\n        ///@notice array backing priority queue\n        uint256[] bidIdList;\n        ///@notice total number of bids in queue\n        uint256 numBids;\n        //@notice map bid ids to bids\n        mapping(uint256 => Bid) bidIdToBidMap;\n        ///@notice map addreses to bids they own\n        mapping(address => uint256[]) ownerToBidIds;\n    }\n\n    ///@notice initialize must be called before using queue.\n    function initialize(Queue storage self) public {\n        self.bidIdList.push(0);\n        self.nextBidId = 1;\n    }\n\n    function isEmpty(Queue storage self) public view returns (bool) {\n        return self.numBids == 0;\n    }\n\n    function getNumBids(Queue storage self) public view returns (uint256) {\n        return self.numBids;\n    }\n\n    ///@notice view min bid\n    function getMin(Queue storage self) public view returns (Bid storage) {\n        require(!isEmpty(self), \"nothing to return\");\n        uint256 minId = self.bidIdList[1];\n        return self.bidIdToBidMap[minId];\n    }\n\n    ///@notice move bid up heap\n    function swim(Queue storage self, uint256 k) private {\n        while (k > 1 && isGreater(self, k / 2, k)) {\n            exchange(self, k, k / 2);\n            k = k / 2;\n        }\n    }\n\n    ///@notice move bid down heap\n    function sink(Queue storage self, uint256 k) private {\n        while (2 * k <= self.numBids) {\n            uint256 j = 2 * k;\n            if (j < self.numBids && isGreater(self, j, j + 1)) {\n                j++;\n            }\n            if (!isGreater(self, k, j)) {\n                break;\n            }\n            exchange(self, k, j);\n            k = j;\n        }\n    }\n\n    ///@notice insert bid in heap\n    function insert(\n        Queue storage self,\n        address owner,\n        uint256 price,\n        uint256 quantity\n    ) public {\n        insert(self, Bid(self.nextBidId++, owner, price, quantity));\n    }\n\n    ///@notice insert bid in heap\n    function insert(Queue storage self, Bid memory bid) private {\n        self.bidIdList.push(bid.bidId);\n        self.bidIdToBidMap[bid.bidId] = bid;\n        self.numBids += 1;\n        swim(self, self.numBids);\n        self.ownerToBidIds[bid.owner].push(bid.bidId);\n    }\n\n    ///@notice delete min bid from heap and return\n    function delMin(Queue storage self) public returns (Bid memory) {\n        require(!isEmpty(self), \"nothing to delete\");\n        Bid memory min = self.bidIdToBidMap[self.bidIdList[1]];\n        exchange(self, 1, self.numBids--);\n        self.bidIdList.pop();\n        delete self.bidIdToBidMap[min.bidId];\n        sink(self, 1);\n        uint256[] storage curUserBids = self.ownerToBidIds[min.owner];\n        for (uint256 i = 0; i < curUserBids.length; i++) {\n            if (curUserBids[i] == min.bidId) {\n                //remove from array and delete struct\n                curUserBids[i] = curUserBids[curUserBids.length - 1];\n                curUserBids.pop();\n                break;\n            }\n        }\n        return min;\n    }\n\n    ///@notice helper function to determine ordering. When two bids have the same price, give priority\n    ///to the one with the larger quantity\n    function isGreater(\n        Queue storage self,\n        uint256 i,\n        uint256 j\n    ) private view returns (bool) {\n        Bid memory bidI = self.bidIdToBidMap[self.bidIdList[i]];\n        Bid memory bidJ = self.bidIdToBidMap[self.bidIdList[j]];\n        if (bidI.price == bidJ.price) {\n            return bidI.quantity <= bidJ.quantity;\n        }\n        return bidI.price > bidJ.price;\n    }\n\n    ///@notice helper function to exchange to bids in the heap\n    function exchange(\n        Queue storage self,\n        uint256 i,\n        uint256 j\n    ) private {\n        uint256 tempId = self.bidIdList[i];\n        self.bidIdList[i] = self.bidIdList[j];\n        self.bidIdList[j] = tempId;\n    }\n}"
    }
  ]
}