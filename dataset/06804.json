{
  "Title": "[H-03] `dMute.sol`: Attacker can push lock items to victim's array such that redemptions are forever blocked",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/dao/dMute.sol#L90-L129\nhttps://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/dao/dMute.sol#L135-L139\n\n\n# Vulnerability details\n\n## Impact\nThis report deals with how an attacker can abuse the fact that he can lock `MUTE` tokens for any other user and thereby push items to the array of `UserLockInfo` structs of the user.  \n\nThere are two functions in the `dMute` contract that iterate over all items in this array ([`RedeemTo`](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/dao/dMute.sol#L90-L129) and [`GetUnderlyingTokens`](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/dao/dMute.sol#L135-L139)).  \n\nThereby if the attacker pushes sufficient items to the array of a user, he can make the above two functions revert since they require more Gas than the Block Gas Limit.  \n\nAccording to the `zkSync` documentation the block gas limit is currently 12.5 million ([Link](https://docs.zksync.io/userdocs/tech/#:~:text=With%20the%20current%20block%20gas,can%20process%20over%202000%20TPS.)).  \n\nThe attack is of \"High\" impact for the `RedeemTo` function since this function needs to succeed in order for the user to redeem his `MUTE` tokens.  \n\nThe user might have a lot of `MUTE` tokens locked and the attacker can make it such that they can never be redeemed. The attacker cannot gain a profit from this attack, i.e. he cannot steal anything, but due to the possibility of this attack users will not lock their tokens, especially not a lot of them.  \n\nThis is all the more severe because the `MuteBond` and `MuteAmplifier` contracts also rely on the locking functionality so those upstream features can also not be used securely.  \n\nIn the Mitigation section I will show how the `GetUnderlyingTokens` function can be made to run in $O(1)$ time instead of $O(lock\\:array\\:length)$.  \n\nThe `RedeemTo` function can be made to run in $O(indexes\\:array\\:length)$ instead of $O(lock\\:array\\:length)$. The length of the indexes array is determined by the user and simply tells how many locked items to redeem. So there is no possibility of DOS.  \n\n## Proof of Concept\nNote: a redemption costs `~7 million Gas` when 1000 items are locked. So when running on the `zkSync` network even 2000 items should be enough. The hardhat tests use a local Ethereum network instead of a fork of `zkSync` so in order to hit `30 million Gas` (which is the Ethereum block gas limit) we need to add more items to the queue.  \n\nYou can add the following test to the `dao.ts` test file:  \n```javascript\nit('Lock DOS', async function () {\n    var tx = await muteToken.approve(dMuteToken.address, MaxUint256)\n\n\n    let lock_time_week = new BigNumber(60 * 60 * 24 * 7);\n    let max_lock = lock_time_week.times(52);\n\n    let lock_amount = new BigNumber(1).times(Math.pow(10,2))\n\n    // @audit fill up array\n    for(let i=0;i<5000;i++) {\n        tx = await dMuteToken.LockTo(lock_amount.toFixed(0), lock_time_week.toFixed(),owner.address)\n    }\n\n    await time.increase(60 * 60 * 24 * 7)\n\n    tx = await dMuteToken.Redeem([0])\n})\n```\nIt adds `5000` lock items to the array of the `owner` address. When the `owner` then tries to redeem even a single lock the transaction fails due to an out of gas error.  \n\n(Sometimes it reverts with `TransactionExecutionError: Transaction ran out of gas` error sometimes it reverts due to timeout. If you try a few times it should revert with the out of gas error.)  \n\nThe amount of `MUTE` tokens that the attacker loses to execute this attack is negligible. As you can see in the test `100 Wei * 5000 = 500,000 Wei` is sufficient (There needs to be some amount of `MUTE` such that the `LockTo` function does not revert). The only real cost comes down to Gas costs which are cheap on `zkSync`.  \n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nFirst for the `GetUnderlyingTokens` function: The contract should keep track of underlying token amounts for each user in a mapping that is updated with every lock / redeem call. The `GetUnderlyingTokens` function then simply needs to return the value from this mapping.  \n\nSecondly, fixing the issue with the `RedeemTo` function is a bit harder. I discussed this with the sponsor and I have been told they don't want this function to require an already sorted `lock_index` array as parameter. So the `lock_index` array can contain indexes in random order.  \n\nThis means it must be sorted internally. Depending on the expected length of the `lock_index` array different sorting algorithms may be used. I recommend to use an algorithm like [quick sort](https://gist.github.com/subhodi/b3b86cc13ad2636420963e692a4d896f) to allow for many indexes to be specified at once.  \n\nI will use a placeholder for the sorting algorithm for now so the sponsor may decide which one to use.  \n\nThe proposed fixes for both functions are then like this:  \n```diff\ndiff --git a/contracts/dao/dMute.sol b/contracts/dao/dMute.sol\nindex 59f95b7..11d21fb 100644\n--- a/contracts/dao/dMute.sol\n+++ b/contracts/dao/dMute.sol\n@@ -18,6 +18,7 @@ contract dMute is dSoulBound {\n     }\n \n     mapping(address => UserLockInfo[]) public _userLocks;\n+    mapping(address => uint256) public _amounts;\n \n     uint private unlocked = 1;\n \n@@ -79,6 +80,7 @@ contract dMute is dSoulBound {\n         _mint(to, tokens_to_mint);\n \n         _userLocks[to].push(UserLockInfo(_amount, block.timestamp.add(_lock_time), tokens_to_mint));\n+        _amounts[to] = _amounts[to] + _amount;\n \n         emit LockEvent(to, _amount, tokens_to_mint, _lock_time);\n     }\n@@ -91,8 +93,14 @@ contract dMute is dSoulBound {\n         uint256 total_to_redeem = 0;\n         uint256 total_to_burn = 0;\n \n-        for(uint256 i; i < lock_index.length; i++){\n-          uint256 index = lock_index[i];\n+        ///////////////////////////////////////////////\n+        //                                           //\n+        // sort lock_index array in ascending order //\n+        //                                          //\n+        //////////////////////////////////////////////\n+\n+        for(uint256 i = lock_index.length; i > 0; i--){\n+          uint256 index = lock_index[i - 1];\n           UserLockInfo memory lock_info = _userLocks[msg.sender][index];\n \n           require(block.timestamp >= lock_info.time, \"dMute::Redeem: INSUFFICIENT_LOCK_TIME\");\n@@ -102,23 +110,14 @@ contract dMute is dSoulBound {\n           total_to_redeem = total_to_redeem.add(lock_info.amount);\n           total_to_burn = total_to_burn.add(lock_info.tokens_minted);\n \n-          _userLocks[msg.sender][index] = UserLockInfo(0,0,0);\n+          _userLocks[msg.sender][index] = _userLocks[msg.sender][_userLocks[msg.sender].length - 1];\n+          _userLocks[msg.sender].pop();\n         }\n \n         require(total_to_redeem > 0, \"dMute::Lock: INSUFFICIENT_REDEEM_AMOUNT\");\n         require(total_to_burn > 0, \"dMute::Lock: INSUFFICIENT_BURN_AMOUNT\");\n \n-\n-        for(uint256 i = _userLocks[msg.sender].length; i > 0; i--){\n-          UserLockInfo memory lock_info = _userLocks[msg.sender][i - 1];\n-\n-          // recently redeemed lock, destroy it\n-          if(lock_info.time == 0){\n-            _userLocks[msg.sender][i - 1] = _userLocks[msg.sender][_userLocks[msg.sender].length - 1];\n-            _userLocks[msg.sender].pop();\n-          }\n-        }\n-\n+        _amounts[msg.sender] = _amounts[msg.sender] + total_to_redeem;\n         //redeem tokens to user\n         IERC20(MuteToken).transfer(to, total_to_redeem);\n         //burn dMute\n@@ -133,8 +132,6 @@ contract dMute is dSoulBound {\n     }\n \n     function GetUnderlyingTokens(address account) public view returns(uint256 amount) {\n-        for(uint256 i; i < _userLocks[account].length; i++){\n-          amount = amount.add(_userLocks[account][i].amount);\n-        }\n+        return _amounts[account];\n     }\n }\n```\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2023-03-mute-switch-versus-contest",
  "Code": [
    {
      "filename": "contracts/dao/dMute.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../interfaces/IERC20.sol';\nimport '../libraries/SafeMath.sol';\nimport './dSoulBound.sol';\n\n/// @notice Mute DAO token, untransferrable\ncontract dMute is dSoulBound {\n    using SafeMath for uint;\n\n    address public MuteToken;\n\n    struct UserLockInfo {\n      uint256 amount;\n      uint256 time;\n      uint256 tokens_minted;\n    }\n\n    mapping(address => UserLockInfo[]) public _userLocks;\n\n    uint private unlocked = 1;\n\n    event LockEvent(address to, uint256 lockAmount, uint256 mintedAmount, uint256 totalTime);\n    event RedeemEvent(address to, uint256 unlockedAmount, uint256 burnAmount);\n\n    modifier nonReentrant() {\n        require(unlocked == 1, 'dMute::ReentrancyGuard: REENTRANT_CALL');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    /// @dev Expects a LP token address & the base reward muteToken address\n    constructor (address _muteToken) {\n        require(_muteToken != address(0), \"MuteAmplifier: invalid muteToken\");\n        MuteToken = _muteToken;\n    }\n\n    /*\n    function lockBonus(uint256 lock_time) internal view returns (uint256){\n        uint256 week_time = 60 * 60 * 24 * 7;\n        uint256 max_lock = week_time.mul(52 * 2); // 2 years\n\n        return lock_time.mul(10**18).div(max_lock).mul(10);\n    }\n    */\n\n    function timeToTokens(uint256 _amount, uint256 _lock_time) internal pure returns (uint256){\n        uint256 week_time = 1 weeks;\n        uint256 max_lock = 52 weeks;\n\n        require(_lock_time >= week_time, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n        require(_lock_time <= max_lock, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n\n        // amount * % of time locked up from min to max\n        uint256 base_tokens = _amount.mul(_lock_time.mul(10**18).div(max_lock)).div(10**18);\n        // apply % min max bonus\n        //uint256 boosted_tokens = base_tokens.mul(lockBonus(lock_time)).div(10**18);\n\n        return base_tokens;\n    }\n\n    function Lock(uint256 _amount, uint256 _lock_time) public {\n        LockTo(_amount, _lock_time, msg.sender);\n    }\n\n    function LockTo(uint256 _amount, uint256 _lock_time, address to) public nonReentrant {\n        require(IERC20(MuteToken).balanceOf(msg.sender) >= _amount, \"dMute::Lock: INSUFFICIENT_BALANCE\");\n\n        //transfer tokens to this contract\n        IERC20(MuteToken).transferFrom(msg.sender, address(this), _amount);\n\n        // calculate dTokens to mint\n        uint256 tokens_to_mint = timeToTokens(_amount, _lock_time);\n\n        require(tokens_to_mint > 0, 'dMute::Lock: INSUFFICIENT_TOKENS_MINTED');\n\n        _mint(to, tokens_to_mint);\n\n        _userLocks[to].push(UserLockInfo(_amount, block.timestamp.add(_lock_time), tokens_to_mint));\n\n        emit LockEvent(to, _amount, tokens_to_mint, _lock_time);\n    }\n\n    function Redeem(uint256[] memory lock_index) public {\n        RedeemTo(lock_index, msg.sender);\n    }\n\n    function RedeemTo(uint256[] memory lock_index, address to) public nonReentrant {\n        uint256 total_to_redeem = 0;\n        uint256 total_to_burn = 0;\n\n        for(uint256 i; i < lock_index.length; i++){\n          uint256 index = lock_index[i];\n          UserLockInfo memory lock_info = _userLocks[msg.sender][index];\n\n          require(block.timestamp >= lock_info.time, \"dMute::Redeem: INSUFFICIENT_LOCK_TIME\");\n          require(lock_info.amount >= 0 , \"dMute::Redeem: INSUFFICIENT_AMOUNT\");\n          require(lock_info.tokens_minted >= 0 , \"dMute::Redeem: INSUFFICIENT_MINT_AMOUNT\");\n\n          total_to_redeem = total_to_redeem.add(lock_info.amount);\n          total_to_burn = total_to_burn.add(lock_info.tokens_minted);\n\n          _userLocks[msg.sender][index] = UserLockInfo(0,0,0);\n        }\n\n        require(total_to_redeem > 0, \"dMute::Lock: INSUFFICIENT_REDEEM_AMOUNT\");\n        require(total_to_burn > 0, \"dMute::Lock: INSUFFICIENT_BURN_AMOUNT\");\n\n\n        for(uint256 i = _userLocks[msg.sender].length; i > 0; i--){\n          UserLockInfo memory lock_info = _userLocks[msg.sender][i - 1];\n\n          // recently redeemed lock, destroy it\n          if(lock_info.time == 0){\n            _userLocks[msg.sender][i - 1] = _userLocks[msg.sender][_userLocks[msg.sender].length - 1];\n            _userLocks[msg.sender].pop();\n          }\n        }\n\n        //redeem tokens to user\n        IERC20(MuteToken).transfer(to, total_to_redeem);\n        //burn dMute\n        _burn(msg.sender, total_to_burn);\n\n\n        emit RedeemEvent(msg.sender, total_to_redeem, total_to_burn);\n    }\n\n    function GetUserLockLength(address account) public view returns (uint256 amount) {\n        amount = _userLocks[account].length;\n    }\n\n    function GetUnderlyingTokens(address account) public view returns(uint256 amount) {\n        for(uint256 i; i < _userLocks[account].length; i++){\n          amount = amount.add(_userLocks[account][i].amount);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/dao/dMute.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../interfaces/IERC20.sol';\nimport '../libraries/SafeMath.sol';\nimport './dSoulBound.sol';\n\n/// @notice Mute DAO token, untransferrable\ncontract dMute is dSoulBound {\n    using SafeMath for uint;\n\n    address public MuteToken;\n\n    struct UserLockInfo {\n      uint256 amount;\n      uint256 time;\n      uint256 tokens_minted;\n    }\n\n    mapping(address => UserLockInfo[]) public _userLocks;\n\n    uint private unlocked = 1;\n\n    event LockEvent(address to, uint256 lockAmount, uint256 mintedAmount, uint256 totalTime);\n    event RedeemEvent(address to, uint256 unlockedAmount, uint256 burnAmount);\n\n    modifier nonReentrant() {\n        require(unlocked == 1, 'dMute::ReentrancyGuard: REENTRANT_CALL');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    /// @dev Expects a LP token address & the base reward muteToken address\n    constructor (address _muteToken) {\n        require(_muteToken != address(0), \"MuteAmplifier: invalid muteToken\");\n        MuteToken = _muteToken;\n    }\n\n    /*\n    function lockBonus(uint256 lock_time) internal view returns (uint256){\n        uint256 week_time = 60 * 60 * 24 * 7;\n        uint256 max_lock = week_time.mul(52 * 2); // 2 years\n\n        return lock_time.mul(10**18).div(max_lock).mul(10);\n    }\n    */\n\n    function timeToTokens(uint256 _amount, uint256 _lock_time) internal pure returns (uint256){\n        uint256 week_time = 1 weeks;\n        uint256 max_lock = 52 weeks;\n\n        require(_lock_time >= week_time, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n        require(_lock_time <= max_lock, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n\n        // amount * % of time locked up from min to max\n        uint256 base_tokens = _amount.mul(_lock_time.mul(10**18).div(max_lock)).div(10**18);\n        // apply % min max bonus\n        //uint256 boosted_tokens = base_tokens.mul(lockBonus(lock_time)).div(10**18);\n\n        return base_tokens;\n    }\n\n    function Lock(uint256 _amount, uint256 _lock_time) public {\n        LockTo(_amount, _lock_time, msg.sender);\n    }\n\n    function LockTo(uint256 _amount, uint256 _lock_time, address to) public nonReentrant {\n        require(IERC20(MuteToken).balanceOf(msg.sender) >= _amount, \"dMute::Lock: INSUFFICIENT_BALANCE\");\n\n        //transfer tokens to this contract\n        IERC20(MuteToken).transferFrom(msg.sender, address(this), _amount);\n\n        // calculate dTokens to mint\n        uint256 tokens_to_mint = timeToTokens(_amount, _lock_time);\n\n        require(tokens_to_mint > 0, 'dMute::Lock: INSUFFICIENT_TOKENS_MINTED');\n\n        _mint(to, tokens_to_mint);\n\n        _userLocks[to].push(UserLockInfo(_amount, block.timestamp.add(_lock_time), tokens_to_mint));\n\n        emit LockEvent(to, _amount, tokens_to_mint, _lock_time);\n    }\n\n    function Redeem(uint256[] memory lock_index) public {\n        RedeemTo(lock_index, msg.sender);\n    }\n\n    function RedeemTo(uint256[] memory lock_index, address to) public nonReentrant {\n        uint256 total_to_redeem = 0;\n        uint256 total_to_burn = 0;\n\n        for(uint256 i; i < lock_index.length; i++){\n          uint256 index = lock_index[i];\n          UserLockInfo memory lock_info = _userLocks[msg.sender][index];\n\n          require(block.timestamp >= lock_info.time, \"dMute::Redeem: INSUFFICIENT_LOCK_TIME\");\n          require(lock_info.amount >= 0 , \"dMute::Redeem: INSUFFICIENT_AMOUNT\");\n          require(lock_info.tokens_minted >= 0 , \"dMute::Redeem: INSUFFICIENT_MINT_AMOUNT\");\n\n          total_to_redeem = total_to_redeem.add(lock_info.amount);\n          total_to_burn = total_to_burn.add(lock_info.tokens_minted);\n\n          _userLocks[msg.sender][index] = UserLockInfo(0,0,0);\n        }\n\n        require(total_to_redeem > 0, \"dMute::Lock: INSUFFICIENT_REDEEM_AMOUNT\");\n        require(total_to_burn > 0, \"dMute::Lock: INSUFFICIENT_BURN_AMOUNT\");\n\n\n        for(uint256 i = _userLocks[msg.sender].length; i > 0; i--){\n          UserLockInfo memory lock_info = _userLocks[msg.sender][i - 1];\n\n          // recently redeemed lock, destroy it\n          if(lock_info.time == 0){\n            _userLocks[msg.sender][i - 1] = _userLocks[msg.sender][_userLocks[msg.sender].length - 1];\n            _userLocks[msg.sender].pop();\n          }\n        }\n\n        //redeem tokens to user\n        IERC20(MuteToken).transfer(to, total_to_redeem);\n        //burn dMute\n        _burn(msg.sender, total_to_burn);\n\n\n        emit RedeemEvent(msg.sender, total_to_redeem, total_to_burn);\n    }\n\n    function GetUserLockLength(address account) public view returns (uint256 amount) {\n        amount = _userLocks[account].length;\n    }\n\n    function GetUnderlyingTokens(address account) public view returns(uint256 amount) {\n        for(uint256 i; i < _userLocks[account].length; i++){\n          amount = amount.add(_userLocks[account][i].amount);\n        }\n    }\n}"
    }
  ]
}