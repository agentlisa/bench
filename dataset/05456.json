{
  "Title": "[07] Comments on ERC20Wrap are misleading",
  "Content": "\nIn ERC20Wrap, the `amount` parameter is supposed to be the amount of shTokens to receive, not the amount of ERC20 tokens to be wrapped.\n\n```\n>    * @param amount amount of the ERC-20 token to be wrapped, in terms of\n     *  18-decimal fixed point\n     * @param userAddress the address of the user who is wrapping the token\n     */\n>   function _erc20Wrap(address tokenAddress, uint256 amount, address userAddress, uint256 outputToken) private {\n```\n\nThe `outputAmount` is the `specifiedAmount`, which is passed as `amount` into ERC20Wrap function.\n\n```\n        } else if (interactionType == InteractionType.WrapErc20) {\n            inputToken = 0;\n            inputAmount = 0;\n            outputToken = specifiedToken;\n>          outputAmount = specifiedAmount;\n>           _erc20Wrap(externalContract, outputAmount, userAddress, outputToken);\n```\n\nThis `outputAmount` is then minted as the shToken, which means that the `outputAmount` must be in the form of shTokens.\n\n```\n        if (outputAmount > 0) {\n            // since uint, same as (outputAmount != 0)\n            _mint(userAddress, outputToken, outputAmount);\n        }\n```\n\nIt will be useful if `amount` is more specific and better explained in the comments. Is `amount` referring to the token amount to deposit or the corresponding shToken to receive?\n\n[Ocean.sol#L426-L431](https://github.com/code-423n4/2023-11-shellprotocol/blob/485de7383cdf88284ee6bcf2926fb7c19e9fb257/src/ocean/Ocean.sol#L426-L431)\n\n**[0xA5DF (judge) commented](https://github.com/code-423n4/2023-11-shellprotocol-findings/issues/236#issuecomment-1858752730):**\n> [01] - Low<br>\n> [02] - Low<br>\n> [03] - Non-Critical<br>\n> [04] - Non-Critical<br>\n> [05] - Low<br>\n> [06] - Refactor<br>\n> [07] - Non-Critical\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-11-shellprotocol",
  "Code": [
    {
      "filename": "src/ocean/Ocean.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Cowri Labs Inc.\n\n// All solidity behavior related comments are in reference to this version of\n// the solc compiler.\npragma solidity 0.8.20;\n\n// OpenZeppelin ERC Interfaces\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { IERC1155Receiver } from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport { IERC721Receiver } from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\n// OpenZeppelin Utility Library\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// ShellV2 Interfaces, Data Structures, and Library\nimport { IOceanInteractions, Interaction, InteractionType } from \"./Interactions.sol\";\nimport { IOceanFeeChange } from \"./IOceanFeeChange.sol\";\nimport { IOceanPrimitive } from \"./IOceanPrimitive.sol\";\nimport { BalanceDelta, LibBalanceDelta } from \"./BalanceDelta.sol\";\n\n// ShellV2 ERC-1155 with logic related to public multitoken ledger management.\nimport { OceanERC1155 } from \"./OceanERC1155.sol\";\n\n/**\n * @title A public multitoken ledger for defi\n * @author Cowri Labs Team\n * @dev The ocean is designed to interact with contracts that implement IERC20,\n *  IERC721, IERC-1155, or IOceanPrimitive.\n * @dev The ocean is three things.\n *  1. At the highest level, it is a defi framework[0]. Users provide a list\n *   of interactions, and the ocean executes those interactions. Each\n *   interaction involves a call to an external contract. These calls result\n *   in updates to the ocean's accounting system.\n *  2. Suporting this defi framework is an accounting system that can transfer,\n *   mint, or burn tokens. Each token in the accounting system is identified by\n *   its oceanId. Every oceanId is uniquely derived from an external contract\n *   address. This external contract is the only contract able to cause mints\n *   or burns of this token[1].\n *  3. Supporting this accounting system is an ERC-1155 ledger with all the\n *   standard ERC-1155 features. Users and primitives can interact with their\n *   tokens using both the defi framework and the ERC-1155 functions.\n *\n * [0] We call it a framework because the ocean calls predefined functions on\n *  external contracts at certain points in its exection. The lifecycle is\n *  managed by the ocean, while the business logic is managed by external\n *  contracts.  Conceptually this is quite similar to a typical web framework.\n * [1] For example, when a user wraps an ERC-20 token into the ocean, the\n *   framework calls the ERC-20 transfer function, and upon success, mints the\n *   wrapped token to the user. In another case, when a user deposits a base\n *   token into a liquidity pool to recieve liquidity provider tokens, the\n *   framework calls the liquidity pool, tells it how much of the base token it\n *   will receive, and asks it how much of the liquidity provider token it\n *   would like to mint. When the pool responds, the framework mints this\n *   amount to the user.\n *\n * @dev Getting started tips:\n *  1. Check out Interactions.sol\n *  2. Read through the implementation of Ocean.doInteraction(), glossing over\n *   the function call to _executeInteraction().\n *  3. Read through the imlementation of Ocean.doMultipleInteractions(), again\n *   glossing over the function call to _executeInteraction(). When you\n *   encounter calls to LibBalanceDelta, check out their implementations.\n *  4. Read through _executeInteraction() and all the functions it calls.\n *   Understand how this is the line separating the accounting for the external\n *   contracts and the accounting for the current user.\n *   You can read the implementations of the specific interactions in any\n *   order, but it might be good to go through them in order of increasing\n *   complexity. The called functions, in order of increasing complexity, are:\n *   wrapErc721, unwrapErc721, wrapErc1155, unwrapErc1155, computeOutputAmount,\n *   computeInputAmount, unwrapErc20, and wrapErc20.  When you get to\n *   computeOutputAmount, check out IOceanPrimitive, IOceanToken, and the\n *   function registerNewTokens() in OceanERC1155.\n */\ncontract Ocean is IOceanInteractions, IOceanFeeChange, OceanERC1155, IERC721Receiver, IERC1155Receiver {\n    using LibBalanceDelta for BalanceDelta[];\n\n    /// @notice this is the oceanId used for shETH\n    /// @dev hexadecimal(ascii(\"shETH\"))\n    uint256 public immutable WRAPPED_ETHER_ID;\n\n    /// @notice Used to calculate the unwrap fee\n    /// unwrapFee = unwrapAmount / unwrapFeeDivisor\n    /// Because this uses integer division, the fee is always rounded down\n    /// If unwrapAmount < unwrapFeeDivisor, unwrapFee == 0\n    uint256 public unwrapFeeDivisor;\n    /// @dev this is equivalent to 5 basis points: 1 / 2000 = 0.05%\n    /// @dev When limited to 5 bips or less an integer divisor is an efficient\n    ///  and precise method of calculating a fee.\n    /// @notice As the divisor shrinks, the fee charged grows\n    uint256 constant MIN_UNWRAP_FEE_DIVISOR = 2000;\n\n    /// @notice wrapped ERC20 tokens are stored in an 18 decimal representation\n    /// @dev this makes it easier to implement AMMs between similar tokens\n    uint8 constant NORMALIZED_DECIMALS = 18;\n    /// @notice When the specifiedAmount is equal to this value, we set\n    ///  specifiedAmount to the balance delta.\n    uint256 constant GET_BALANCE_DELTA = type(uint256).max;\n\n    /// @dev Determines if a transfer callback is expected.\n    /// @dev adapted from OpenZeppelin Reentrancy Guard\n    uint256 constant NOT_INTERACTION = 1;\n    uint256 constant INTERACTION = 2;\n    uint256 _ERC1155InteractionStatus;\n    uint256 _ERC721InteractionStatus;\n\n    event ChangeUnwrapFee(uint256 oldFee, uint256 newFee, address sender);\n    event Erc20Wrap(\n        address indexed erc20Token,\n        uint256 transferredAmount,\n        uint256 wrappedAmount,\n        uint256 dust,\n        address indexed user,\n        uint256 indexed oceanId\n    );\n    event Erc20Unwrap(\n        address indexed erc20Token,\n        uint256 transferredAmount,\n        uint256 unwrappedAmount,\n        uint256 feeCharged,\n        address indexed user,\n        uint256 indexed oceanId\n    );\n    event Erc721Wrap(address indexed erc721Token, uint256 erc721id, address indexed user, uint256 indexed oceanId);\n    event Erc721Unwrap(address indexed erc721Token, uint256 erc721Id, address indexed user, uint256 indexed oceanId);\n    event Erc1155Wrap(\n        address indexed erc1155Token, uint256 erc1155Id, uint256 amount, address indexed user, uint256 indexed oceanId\n    );\n    event Erc1155Unwrap(\n        address indexed erc1155Token,\n        uint256 erc1155Id,\n        uint256 amount,\n        uint256 feeCharged,\n        address indexed user,\n        uint256 indexed oceanId\n    );\n    event EtherWrap(uint256 amount, address indexed user);\n    event EtherUnwrap(uint256 amount, uint256 feeCharged, address indexed user);\n    event ComputeOutputAmount(\n        address indexed primitive,\n        uint256 inputToken,\n        uint256 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        address indexed user\n    );\n    event ComputeInputAmount(\n        address indexed primitive,\n        uint256 inputToken,\n        uint256 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        address indexed user\n    );\n    event OceanTransaction(address indexed user, uint256 numberOfInteractions);\n    event ForwardedOceanTransaction(address indexed forwarder, address indexed user, uint256 numberOfInteractions);\n\n    /**\n     * @dev Creates custom ERC-1155 with passed uri_, sets DAO address, and\n     *  initializes ERC-1155 transfer guard.\n     * @notice initializes the fee divisor to uint256 max, which results in\n     *  a fee of zero unless unwrapAmount == type(uint256).max, in which\n     *  case the fee is one part in 1.16 * 10^77.\n     */\n    constructor(string memory uri_) OceanERC1155(uri_) {\n        unwrapFeeDivisor = type(uint256).max;\n        _ERC1155InteractionStatus = NOT_INTERACTION;\n        _ERC721InteractionStatus = NOT_INTERACTION;\n        WRAPPED_ETHER_ID = _calculateOceanId(address(0x4574686572), 0); // hexadecimal(ascii(\"Ether\"))\n    }\n\n    /**\n     * @dev ERC1155 Approvals also function as permission to execute\n     *  interactions on a user's behalf\n     * @param userAddress the address passed by the forwarder\n     *\n     * Because poorly chosen interactions are vulnerable to economic attacks,\n     *  calling do{Interaction|MultipleInteractions} on a user's behalf must\n     *  require the  same level of trust as direct balance transfers.\n     */\n    modifier onlyApprovedForwarder(address userAddress) {\n        if (!isApprovedForAll(userAddress, msg.sender)) revert FORWARDER_NOT_APPROVED();\n        _;\n    }\n\n    /**\n     * @notice this changes the unwrap fee immediately\n     * @notice The governance structure must appropriately handle any\n     *  time lock or other mechanism for managing fee changes\n     * @param nextUnwrapFeeDivisor the reciprocal of the next fee percentage.\n     */\n    function changeUnwrapFee(uint256 nextUnwrapFeeDivisor) external override onlyOwner {\n        /// @notice as the divisor gets smaller, the fee charged gets larger\n        if (MIN_UNWRAP_FEE_DIVISOR > nextUnwrapFeeDivisor) revert();\n        emit ChangeUnwrapFee(unwrapFeeDivisor, nextUnwrapFeeDivisor, msg.sender);\n        unwrapFeeDivisor = nextUnwrapFeeDivisor;\n    }\n\n    /**\n     * @notice Execute interactions `interaction`\n     * @notice Does not need ids because a single interaction does not require\n     *  the accounting system\n     * @dev call to _doInteraction() binds msg.sender to userAddress\n     * @param interaction Executed to produce a set of balance updates\n     */\n    function doInteraction(Interaction calldata interaction)\n        external\n        payable\n        override\n        returns (uint256 burnId, uint256 burnAmount, uint256 mintId, uint256 mintAmount)\n    {\n        emit OceanTransaction(msg.sender, 1);\n        return _doInteraction(interaction, msg.sender);\n    }\n\n    /**\n     * @notice Execute interactions `interactions` with tokens `ids`\n     * @notice ids must include all tokens invoked during the transaction\n     * @notice ids are used for memory allocation in the intra-transaction\n     *  accounting system.\n     * @dev call to _doMultipleInteractions() binds msg.sender to userAddress\n     * @param interactions Executed to produce a set of balance updates\n     * @param ids Ocean IDs of the tokens invoked by the interactions.\n     */\n    function doMultipleInteractions(\n        Interaction[] calldata interactions,\n        uint256[] calldata ids\n    )\n        external\n        payable\n        override\n        returns (\n            uint256[] memory burnIds,\n            uint256[] memory burnAmounts,\n            uint256[] memory mintIds,\n            uint256[] memory mintAmounts\n        )\n    {\n        emit OceanTransaction(msg.sender, interactions.length);\n        return _doMultipleInteractions(interactions, ids, msg.sender);\n    }\n\n    /**\n     * @notice Execute interactions `interactions` on behalf of `userAddress`\n     * @notice Does not need ids because a single interaction does not require\n     *  the overhead of the intra-transaction accounting system\n     * @dev MUST HAVE onlyApprovedForwarder modifer.\n     * @dev call to _doMultipleInteractions() forwards the userAddress\n     * @param interaction Executed to produce a set of balance updates\n     * @param userAddress interactions are executed on behalf of this address\n     */\n    function forwardedDoInteraction(\n        Interaction calldata interaction,\n        address userAddress\n    )\n        external\n        payable\n        override\n        onlyApprovedForwarder(userAddress)\n        returns (uint256 burnId, uint256 burnAmount, uint256 mintId, uint256 mintAmount)\n    {\n        emit ForwardedOceanTransaction(msg.sender, userAddress, 1);\n        return _doInteraction(interaction, userAddress);\n    }\n\n    /**\n     * @notice Execute interactions `interactions` with tokens `ids` on behalf of `userAddress`\n     * @notice ids must include all tokens invoked during the transaction\n     * @notice ids are used for memory allocation in the intra-transaction\n     *  accounting system.\n     * @dev MUST HAVE onlyApprovedForwarder modifer.\n     * @dev call to _doMultipleInteractions() forwards the userAddress\n     * @param interactions Executed to produce a set of balance updates\n     * @param ids Ocean IDs of the tokens invoked by the interactions.\n     * @param userAddress interactions are executed on behalf of this address\n     */\n    function forwardedDoMultipleInteractions(\n        Interaction[] calldata interactions,\n        uint256[] calldata ids,\n        address userAddress\n    )\n        external\n        payable\n        override\n        onlyApprovedForwarder(userAddress)\n        returns (\n            uint256[] memory burnIds,\n            uint256[] memory burnAmounts,\n            uint256[] memory mintIds,\n            uint256[] memory mintAmounts\n        )\n    {\n        emit ForwardedOceanTransaction(msg.sender, userAddress, interactions.length);\n        return _doMultipleInteractions(interactions, ids, userAddress);\n    }\n\n    /**\n     * @dev This callback is part of IERC1155Receiver, which we must implement\n     *  to wrap ERC-1155 tokens.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OceanERC1155, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function onERC721Received(address, address, uint256, bytes calldata) external view override returns (bytes4) {\n        if (_ERC721InteractionStatus == INTERACTION) {\n            return IERC721Receiver.onERC721Received.selector;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @dev This callback is part of IERC1155Receiver, which we must implement\n     *  to wrap ERC-1155 tokens.\n     * @dev The Ocean only accepts ERC1155 transfers initiated by the Ocean\n     *  while executing interactions.\n     * @dev We don't revert, prefering to let the external contract\n     *  decide what it wants to do when safeTransfer is called on a contract\n     *  that does not return the expected selector.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    )\n        external\n        view\n        override\n        returns (bytes4)\n    {\n        if (_ERC1155InteractionStatus == INTERACTION) {\n            return IERC1155Receiver.onERC1155Received.selector;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @dev This callback is part of IERC1155Receiver, which we must implement\n     *  to wrap ERC-1155 tokens.\n     * @dev The Ocean never initiates ERC1155 Batch Transfers.\n     * @dev We don't revert, prefering to let the external contract\n     *  decide what it wants to do when safeTransfer is called on a contract\n     *  that does not return the expected selector.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    )\n        external\n        pure\n        override\n        returns (bytes4)\n    {\n        return 0;\n    }\n\n    /**\n     * @dev This function handles both forwarded and non-forwarded single\n     *  interactions\n     * @dev the external functions that pass through their arguments to this\n     *  function have more information about the arguments.\n     * @param interaction the current interaction passed by the caller\n     * @param userAddress In the case of a forwarded interaction, this value\n     *  is passed by the caller, and this value must be validated against the\n     *  approvals set on this address and the caller's address (`msg.sender`)\n     *  In the case of a non-forwarded interaction, this value is the caller's\n     *  address.\n     */\n    function _doInteraction(\n        Interaction calldata interaction,\n        address userAddress\n    )\n        internal\n        returns (uint256 inputToken, uint256 inputAmount, uint256 outputToken, uint256 outputAmount)\n    {\n        // Ether payments are push only.  We always wrap ERC-X tokens using pull\n        // payments, so we cannot wrap Ether using the same pattern.\n        // We unwrap ERC-X tokens using push payments, so we can unwrap Ether\n        // the same way.\n        if (msg.value != 0) {\n            inputToken = 0;\n            inputAmount = 0;\n            outputToken = WRAPPED_ETHER_ID;\n            outputAmount = msg.value;\n            emit EtherWrap(msg.value, userAddress);\n        } else {\n            // Begin by unpacking the interaction type and the external contract\n            (InteractionType interactionType, address externalContract) = _unpackInteractionTypeAndAddress(interaction);\n\n            // Determine the specified token based on the interaction type and the\n            // interaction's external contract address, inputToken, outputToken,\n            // and metadata fields. The specified token is the token\n            // whose amount the user specifies.\n            uint256 specifiedToken = _getSpecifiedToken(interactionType, externalContract, interaction);\n\n            // Here we call _executeInteraction(), which is just a big\n            // if... else if... block branching on interaction type.\n            // Each branch sets the inputToken and outputToken and their\n            // respective amounts. This abstraction is what lets us treat\n            // interactions uniformly.\n            (inputToken, inputAmount, outputToken, outputAmount) = _executeInteraction(\n                interaction, interactionType, externalContract, specifiedToken, interaction.specifiedAmount, userAddress\n            );\n        }\n\n        // if _executeInteraction returned a positive value for inputAmount,\n        // this amount must be deducted from the user's Ocean balance\n        if (inputAmount > 0) {\n            // since uint, same as (inputAmount != 0)\n            _burn(userAddress, inputToken, inputAmount);\n        }\n\n        // if _executeInteraction returned a positive value for outputAmount,\n        // this amount must be credited to the user's Ocean balance\n        if (outputAmount > 0) {\n            // since uint, same as (outputAmount != 0)\n            _mint(userAddress, outputToken, outputAmount);\n        }\n    }\n\n    /**\n     * @dev This function handles both forwarded and non-forwarded multiple\n     *  interactions\n     * @dev the external functions that pass through their arguments to this\n     *  function have more information about the arguments.\n     * @param interactions The interactions passed by the caller\n     * @param ids the ids passed by the caller\n     * @param userAddress In the case of a forwarded interaction, this value\n     *  is passed by the caller, and this value must be validated against the\n     *  approvals set on this address and the caller's address (`msg.sender`)\n     *  In the case of a non-forwarded interaction, this value is the caller's\n     *  address.\n     */\n    function _doMultipleInteractions(\n        Interaction[] calldata interactions,\n        uint256[] calldata ids,\n        address userAddress\n    )\n        internal\n        returns (\n            uint256[] memory burnIds,\n            uint256[] memory burnAmounts,\n            uint256[] memory mintIds,\n            uint256[] memory mintAmounts\n        )\n    {\n        // Use the passed ids to create an array of balance deltas, used in\n        // the intra-transaction accounting system.\n        BalanceDelta[] memory balanceDeltas = new BalanceDelta[](ids.length);\n\n        uint256 _idLength = ids.length;\n        for (uint256 i = 0; i < _idLength;) {\n            balanceDeltas[i] = BalanceDelta(ids[i], 0);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Ether payments are push only.  We always wrap ERC-X tokens using pull\n        // payments, so we cannot wrap Ether using the same pattern.\n        // We unwrap ERC-X tokens using push payments, so we can unwrap Ether\n        // the same way.\n        if (msg.value != 0) {\n            // If msg.value != 0 and the user did not pass the WRAPPED_ETHER_ID\n            // as an id in the ids array, the balance delta library will revert\n            // This protects users who accidentally provide a msg.value.\n            balanceDeltas.increaseBalanceDelta(WRAPPED_ETHER_ID, msg.value);\n            emit EtherWrap(msg.value, userAddress);\n        }\n\n        // Execute the interactions\n        {\n            /**\n             * @dev Solidity does not reuse memory that has gone out of scope\n             *  and the gas cost of memory usage grows quadratically.\n             * @dev We passed interactions as calldata to lower memory usage.\n             *  However, accessing the members of a calldata structure uses\n             *  more local identifiers than accessing the members of an\n             *  in-memory structure. We're right up against the limit on\n             *  local identifiers. To solve this, we allocate a single\n             *  structure in memory and copy the calldata structures over one\n             *  by one as we process them.\n             */\n            Interaction memory interaction;\n            // This pulls the user's address to the top of the stack, above\n            // the ids array, which we won't need again. We're right up against\n            // the locals limit and this does the trick. Is there a better way?\n            address userAddress_ = userAddress;\n\n            for (uint256 i = 0; i < interactions.length;) {\n                interaction = interactions[i];\n\n                (InteractionType interactionType, address externalContract) =\n                    _unpackInteractionTypeAndAddress(interaction);\n\n                // specifiedToken is the token whose amount the user specifies\n                uint256 specifiedToken = _getSpecifiedToken(interactionType, externalContract, interaction);\n\n                // A user can pass uint256.max as the specifiedAmount when they\n                // want to use the total amount of the token held in the\n                // balance delta. Otherwise, the specifiedAmount is just the\n                // amount the user passed for this interaction.\n                uint256 specifiedAmount;\n                if (interaction.specifiedAmount == GET_BALANCE_DELTA) {\n                    specifiedAmount = balanceDeltas.getBalanceDelta(interactionType, specifiedToken);\n                } else {\n                    specifiedAmount = interaction.specifiedAmount;\n                }\n\n                (uint256 inputToken, uint256 inputAmount, uint256 outputToken, uint256 outputAmount) =\n                _executeInteraction(\n                    interaction, interactionType, externalContract, specifiedToken, specifiedAmount, userAddress_\n                );\n\n                // inputToken is given up by the user during the interaction\n                if (inputAmount > 0) {\n                    // equivalent to (inputAmount != 0)\n                    balanceDeltas.decreaseBalanceDelta(inputToken, inputAmount);\n                }\n\n                // outputToken is gained by the user during the interaction\n                if (outputAmount > 0) {\n                    // equivalent to (outputAmount != 0)\n                    balanceDeltas.increaseBalanceDelta(outputToken, outputAmount);\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        // Persist intra-transaction balance deltas to the Ocean's public ledger\n        {\n            // Place positive deltas into mintIds and mintAmounts\n            // Place negative deltas into burnIds and burnAmounts\n            (mintIds, mintAmounts, burnIds, burnAmounts) = balanceDeltas.createMintAndBurnArrays();\n\n            // Here we should know that uint[] memory arr = new uint[](0);\n            // produces a reference to an empty array called arr with property\n            // (arr.length == 0)\n\n            // mint the positive deltas to the user's balances\n            if (mintIds.length == 1) {\n                // if there's only one we can just use the more semantically\n                // appropriate _mint\n                _mint(userAddress, mintIds[0], mintAmounts[0]);\n            } else if (mintIds.length > 1) {\n                // if there's more than one we use _mintBatch\n                _mintBatch(userAddress, mintIds, mintAmounts);\n            } // if there are none, we do nothing\n\n            // burn the positive deltas from the user's balances\n            if (burnIds.length == 1) {\n                // if there's only one we can just use the more semantically\n                // appropriate _burn\n                _burn(userAddress, burnIds[0], burnAmounts[0]);\n            } else if (burnIds.length > 1) {\n                // if there's more than one we use _burnBatch\n                _burnBatch(userAddress, burnIds, burnAmounts);\n            } // if there are none, we do nothing\n        }\n    }\n\n    /**\n     * @dev Here is the core logic shared between doInteraction and\n     *  doMultipleInteractions\n     * @dev State mutations on the external ledgers happen during wraps/unwraps\n     * @dev State mutations on the Ocean's ledger for the externalContract\n     *  happen during computeInputAmount/computeOutputAmount\n     * @dev State mutations for the userAddress MUST happen in the calling\n     *  context based on the return values of this function.\n     * @param interaction the current interaction passed from calldata\n     * @param interactionType the type of interaction unpacked by caller\n     * @param externalContract the address of the external contract parsed by caller\n     * @param specifiedToken the token in this interaction that specifiedAmount\n     *  refers to\n     * @param specifiedAmount the amount of specifiedToken being used in this\n     *  interaction\n     * @param userAddress the address of the user this interaction is being\n     *  executed on behalf of. This is passed to the external contract.\n     * @return inputToken The token on the Ocean that the user is giving up\n     * @return inputAmount The amount of inputToken that the user is giving up\n     * @return outputToken The token on the Ocean that the user is gaining\n     * @return outputAmount The amount of ouputToken that the user is gaining\n     */\n    function _executeInteraction(\n        Interaction memory interaction,\n        InteractionType interactionType,\n        address externalContract,\n        uint256 specifiedToken,\n        uint256 specifiedAmount,\n        address userAddress\n    )\n        internal\n        returns (uint256 inputToken, uint256 inputAmount, uint256 outputToken, uint256 outputAmount)\n    {\n        if (interactionType == InteractionType.ComputeOutputAmount) {\n            inputToken = specifiedToken;\n            inputAmount = specifiedAmount;\n            outputToken = interaction.outputToken;\n            outputAmount = _computeOutputAmount(\n                externalContract, inputToken, outputToken, inputAmount, userAddress, interaction.metadata\n            );\n        } else if (interactionType == InteractionType.ComputeInputAmount) {\n            inputToken = interaction.inputToken;\n            outputToken = specifiedToken;\n            outputAmount = specifiedAmount;\n            inputAmount = _computeInputAmount(\n                externalContract, inputToken, outputToken, outputAmount, userAddress, interaction.metadata\n            );\n        } else if (interactionType == InteractionType.WrapErc20) {\n            inputToken = 0;\n            inputAmount = 0;\n            outputToken = specifiedToken;\n            outputAmount = specifiedAmount;\n            _erc20Wrap(externalContract, outputAmount, userAddress, outputToken);\n        } else if (interactionType == InteractionType.UnwrapErc20) {\n            inputToken = specifiedToken;\n            inputAmount = specifiedAmount;\n            outputToken = 0;\n            outputAmount = 0;\n            _erc20Unwrap(externalContract, inputAmount, userAddress, inputToken);\n        } else if (interactionType == InteractionType.WrapErc721) {\n            // An ERC-20 or ERC-1155 contract can have a transfer with\n            // any amount including zero. Here, we need to require that\n            // the specifiedAmount is equal to one, since the external\n            // call to the ERC-721 contract does not include an amount,\n            // and the ledger is mutated based on the specifiedAmount.\n            if (specifiedAmount != 1) revert INVALID_ERC721_AMOUNT();\n            inputToken = 0;\n            inputAmount = 0;\n            outputToken = specifiedToken;\n            outputAmount = specifiedAmount;\n            _erc721Wrap(externalContract, uint256(interaction.metadata), userAddress, outputToken);\n        } else if (interactionType == InteractionType.UnwrapErc721) {\n            // See the comment in the preceeding else if block.\n            if (specifiedAmount != 1) revert INVALID_ERC721_AMOUNT();\n            inputToken = specifiedToken;\n            inputAmount = specifiedAmount;\n            outputToken = 0;\n            outputAmount = 0;\n            _erc721Unwrap(externalContract, uint256(interaction.metadata), userAddress, inputToken);\n        } else if (interactionType == InteractionType.WrapErc1155) {\n            inputToken = 0;\n            inputAmount = 0;\n            outputToken = specifiedToken;\n            outputAmount = specifiedAmount;\n            _erc1155Wrap(externalContract, uint256(interaction.metadata), outputAmount, userAddress, outputToken);\n        } else if (interactionType == InteractionType.UnwrapErc1155) {\n            inputToken = specifiedToken;\n            inputAmount = specifiedAmount;\n            outputToken = 0;\n            outputAmount = 0;\n            _erc1155Unwrap(externalContract, uint256(interaction.metadata), inputAmount, userAddress, inputToken);\n        } else {\n            assert(interactionType == InteractionType.UnwrapEther && specifiedToken == WRAPPED_ETHER_ID);\n            inputToken = specifiedToken;\n            inputAmount = specifiedAmount;\n            outputToken = 0;\n            outputAmount = 0;\n            _etherUnwrap(inputAmount, userAddress);\n        }\n    }\n\n    /**\n     * @param interaction the interaction\n     * @dev the first byte contains the interactionType\n     * @dev the next eleven bytes are IGNORED\n     * @dev the final twenty bytes are the address targeted by the interaction\n     */\n    function _unpackInteractionTypeAndAddress(Interaction memory interaction)\n        internal\n        pure\n        returns (InteractionType interactionType, address externalContract)\n    {\n        bytes32 interactionTypeAndAddress = interaction.interactionTypeAndAddress;\n        interactionType = InteractionType(uint8(interactionTypeAndAddress[0]));\n        externalContract = address(uint160(uint256(interactionTypeAndAddress)));\n    }\n\n    /**\n     * @param interactionType determines how we derive the specifiedToken\n     * @param externalContract is the target of the interaction's external call\n     * @param interaction the interaction's fields are interpreted based on\n     *  the Interaction type. See the declarations in Interactions.sol\n     * @return specifiedToken is the ocean's internal ID for the token in a\n     *  interaction that's amount is specified by the user.\n     */\n    function _getSpecifiedToken(\n        InteractionType interactionType,\n        address externalContract,\n        Interaction memory interaction\n    )\n        internal\n        view\n        returns (uint256 specifiedToken)\n    {\n        if (interactionType == InteractionType.WrapErc20 || interactionType == InteractionType.UnwrapErc20) {\n            specifiedToken = _calculateOceanId(externalContract, 0);\n        } else if (\n            interactionType == InteractionType.WrapErc721 || interactionType == InteractionType.WrapErc1155\n                || interactionType == InteractionType.UnwrapErc721 || interactionType == InteractionType.UnwrapErc1155\n        ) {\n            specifiedToken = _calculateOceanId(externalContract, uint256(interaction.metadata));\n        } else if (interactionType == InteractionType.ComputeInputAmount) {\n            specifiedToken = inter"
    }
  ]
}