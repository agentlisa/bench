{
  "Title": "[G-11]  Use named returns for local variables of pure functions where it is possible",
  "Content": "\n### Proof of Concept\n\n<details>\n\n```solidity\nlibrary NoNamedReturnArithmetic {\n    \n    function sum(uint256 num1, uint256 num2) internal pure returns(uint256){\n        return num1 + num2;\n    }\n}\n\ncontract NoNamedReturn {\n    using NoNamedReturnArithmetic for uint256;\n\n    uint256 public stateVar;\n\n    function add2State(uint256 num) public {\n        stateVar = stateVar.sum(num);\n    }\n}\n```\n```solidity\ntest for test/NoNamedReturn.t.sol:NamedReturnTest\n[PASS] test_Increment() (gas: 27639)\n```\n\n```solidity\nlibrary NamedReturnArithmetic {\n    \n    function sum(uint256 num1, uint256 num2) internal pure returns(uint256 theSum){\n        theSum = num1 + num2;\n    }\n}\n\ncontract NamedReturn {\n    using NamedReturnArithmetic for uint256;\n\n    uint256 public stateVar;\n\n    function add2State(uint256 num) public {\n        stateVar = stateVar.sum(num);\n    }\n}\n```\n```solidity\ntest for test/NamedReturn.t.sol:NamedReturnTest\n[PASS] test_Increment() (gas: 27613)\n```\n\n</details>\n\n### 2 Instances\n1. ### Use named returns in the `SplToken.total_supply()` function\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/lockbox-solana/solidity/library/spl_token.sol#L109-#L111\n\n<details>\n\n```solidity\nfile: lockbox-solana/solidity/library/spl_token.sol\n\n109:\tfunction total_supply(AccountInfo account) internal view returns (uint64) {\n110:\t\treturn account.data.readUint64LE(36);\n112:\n113:     }\n```\n\n```diff\ndiff --git a/lockbox-solana/solidity/library/spl_token.sol b/lockbox-solana/solidity/library/spl_token.sol\nindex 4790760..6f89568 100644\n--- a/lockbox-solana/solidity/library/spl_token.sol\n+++ b/lockbox-solana/solidity/library/spl_token.sol\n@@ -106,8 +106,8 @@ library SplToken {\n\n        /// @dev Get the total supply for the mint, i.e. the total amount in circulation\n        /// @param account The AccountInfo struct for the mint account\n-       function total_supply(AccountInfo account) internal view returns (uint64) {\n-               return account.data.readUint64LE(36);\n+       function total_supply(AccountInfo account) internal view returns (uint64 totalSupply) {\n+               totalSupply = account.data.readUint64LE(36);\n        }\n```\n</details>\n\n2. ### Use named returns in the `SplToken.total_supply()` function\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/lockbox-solana/solidity/library/spl_token.sol#L115-#L117\n\n<details>\n\n```solidity\nfile: lockbox-solana/solidity/library/spl_token.sol\n\n115:\tfunction get_balance(AccountInfo account) internal view returns (uint64) {\n116:\t\treturn account.data.readUint64LE(64);\n117:\t}\n```\n\n```diff\ndiff --git a/lockbox-solana/solidity/library/spl_token.sol b/lockbox-solana/solidity/library/spl_token.sol\nindex 4790760..5ed4147 100644\n--- a/lockbox-solana/solidity/library/spl_token.sol\n+++ b/lockbox-solana/solidity/library/spl_token.sol\n@@ -112,7 +112,7 @@ library SplToken {\n\n        /// @dev Get the balance for an account.\n        /// @param account the struct AccountInfo whose account balance we want to retrieve\n-       function get_balance(AccountInfo account) internal view returns (uint64) {\n-               return account.data.readUint64LE(64);\n+       function get_balance(AccountInfo account) internal view returns (uint64 balance) {\n+               balance = account.data.readUint64LE(64);\n        }\n```\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "lockbox-solana/solidity/library/spl_token.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n// Disclaimer: This library provides a way for Solidity to interact with Solana's SPL-Token. Although it is production ready,\n// it has not been audited for security, so use it at your own risk.\n\nimport 'solana';\n\nlibrary SplToken {\n\taddress constant tokenProgramId = address\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\";\n\tenum TokenInstruction {\n\t\tInitializeMint, // 0\n\t\tInitializeAccount, // 1\n\t\tInitializeMultisig, // 2\n\t\tTransfer, // 3\n\t\tApprove, // 4\n\t\tRevoke, // 5\n\t\tSetAuthority, // 6\n\t\tMintTo, // 7\n\t\tBurn, // 8\n\t\tCloseAccount, // 9\n\t\tFreezeAccount, // 10\n\t\tThawAccount, // 11\n\t\tTransferChecked, // 12\n\t\tApproveChecked, // 13\n\t\tMintToChecked, // 14\n\t\tBurnChecked, // 15\n\t\tInitializeAccount2, // 16\n\t\tSyncNative, // 17\n\t\tInitializeAccount3, // 18\n\t\tInitializeMultisig2, // 19\n\t\tInitializeMint2, // 20\n\t\tGetAccountDataSize, // 21\n\t\tInitializeImmutableOwner, // 22\n\t\tAmountToUiAmount, // 23\n\t\tUiAmountToAmount, // 24\n\t\tInitializeMintCloseAuthority, // 25\n\t\tTransferFeeExtension, // 26\n\t\tConfidentialTransferExtension, // 27\n\t\tDefaultAccountStateExtension, // 28\n\t\tReallocate, // 29\n\t\tMemoTransferExtension, // 30\n\t\tCreateNativeMint // 31\n\t}\n\n\t/// @dev Mint new tokens. The transaction should be signed by the PDA mint authority keypair\n\t/// @param mint the account of the mint\n\t/// @param account the token account where the minted tokens should go\n\t/// @param authority the public key of the mint authority\n\t/// @param amount the amount of tokens to mint\n\t/// @param seed PDA seed\n\t/// @param bump PDA bump\n\tfunction pda_mint_to(address mint, address account, address authority, uint64 amount, bytes seed, bytes bump) internal {\n\t\tbytes instr = new bytes(9);\n\t\tinstr[0] = uint8(TokenInstruction.MintTo);\n\t\tinstr.writeUint64LE(amount, 1);\n\n\t\tAccountMeta[3] metas = [\n\t\t\tAccountMeta({pubkey: mint, is_writable: true, is_signer: false}),\n\t\t\tAccountMeta({pubkey: account, is_writable: true, is_signer: false}),\n\t\t\tAccountMeta({pubkey: authority, is_writable: false, is_signer: true})\n\t\t];\n\n\t\ttokenProgramId.call{accounts: metas, seeds: [[seed, bump]]}(instr);\n\t}\n\n\t/// @dev Transfer @amount token from @from to @to. The transaction should be signed by the owner\n\t/// keypair of the from account.\n\t/// @param from the account to transfer tokens from\n\t/// @param to the account to transfer tokens to\n\t/// @param owner the publickey of the from account owner keypair\n\t/// @param amount the amount to transfer\n\tfunction transfer(address from, address to, address owner, uint64 amount) internal {\n\t\tbytes instr = new bytes(9);\n\t\tinstr[0] = uint8(TokenInstruction.Transfer);\n\t\tinstr.writeUint64LE(amount, 1);\n\n\t\tAccountMeta[3] metas = [\n\t\t\tAccountMeta({pubkey: from, is_writable: true, is_signer: false}),\n\t\t\tAccountMeta({pubkey: to, is_writable: true, is_signer: false}),\n\t\t\tAccountMeta({pubkey: owner, is_writable: false, is_signer: true})\n\t\t];\n\n\t\ttokenProgramId.call{accounts: metas}(instr);\n\t}\n\n\t/// @dev Burn @amount tokens in account. This transaction should be signed by the PDA.\n\t/// @param account the acount for which tokens should be burned\n\t/// @param mint the mint for this token\n\t/// @param owner the publickey of the account owner keypair\n\t/// @param amount the amount to burn\n\t/// @param seed PDA seed\n\t/// @param bump PDA bump\n\tfunction pda_burn(address account, address mint, address owner, uint64 amount, bytes seed, bytes bump) internal {\n\t\tbytes instr = new bytes(9);\n\t\tinstr[0] = uint8(TokenInstruction.Burn);\n\t\tinstr.writeUint64LE(amount, 1);\n\n\t\tAccountMeta[3] metas = [\n\t\t\tAccountMeta({pubkey: account, is_writable: true, is_signer: false}),\n\t\t\tAccountMeta({pubkey: mint, is_writable: true, is_signer: false}),\n\t\t\tAccountMeta({pubkey: owner, is_writable: false, is_signer: true})\n\t\t];\n\n\t\ttokenProgramId.call{accounts: metas, seeds: [[seed, bump]]}(instr);\n\t}\n\n\t/// @dev Get the total supply for the mint, i.e. the total amount in circulation\n\t/// @param account The AccountInfo struct for the mint account\n\tfunction total_supply(AccountInfo account) internal view returns (uint64) {\n\t\treturn account.data.readUint64LE(36);\n\t}\n\n\t/// @dev Get the balance for an account.\n\t/// @param account the struct AccountInfo whose account balance we want to retrieve\n\tfunction get_balance(AccountInfo account) internal view returns (uint64) {\n\t\treturn account.data.readUint64LE(64);\n\t}\n}"
    },
    {
      "filename": "lockbox-solana/solidity/library/spl_token.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n// Disclaimer: This library provides a way for Solidity to interact with Solana's SPL-Token. Although it is production ready,\n// it has not been audited for security, so use it at your own risk.\n\nimport 'solana';\n\nlibrary SplToken {\n\taddress constant tokenProgramId = address\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\";\n\tenum TokenInstruction {\n\t\tInitializeMint, // 0\n\t\tInitializeAccount, // 1\n\t\tInitializeMultisig, // 2\n\t\tTransfer, // 3\n\t\tApprove, // 4\n\t\tRevoke, // 5\n\t\tSetAuthority, // 6\n\t\tMintTo, // 7\n\t\tBurn, // 8\n\t\tCloseAccount, // 9\n\t\tFreezeAccount, // 10\n\t\tThawAccount, // 11\n\t\tTransferChecked, // 12\n\t\tApproveChecked, // 13\n\t\tMintToChecked, // 14\n\t\tBurnChecked, // 15\n\t\tInitializeAccount2, // 16\n\t\tSyncNative, // 17\n\t\tInitializeAccount3, // 18\n\t\tInitializeMultisig2, // 19\n\t\tInitializeMint2, // 20\n\t\tGetAccountDataSize, // 21\n\t\tInitializeImmutableOwner, // 22\n\t\tAmountToUiAmount, // 23\n\t\tUiAmountToAmount, // 24\n\t\tInitializeMintCloseAuthority, // 25\n\t\tTransferFeeExtension, // 26\n\t\tConfidentialTransferExtension, // 27\n\t\tDefaultAccountStateExtension, // 28\n\t\tReallocate, // 29\n\t\tMemoTransferExtension, // 30\n\t\tCreateNativeMint // 31\n\t}\n\n\t/// @dev Mint new tokens. The transaction should be signed by the PDA mint authority keypair\n\t/// @param mint the account of the mint\n\t/// @param account the token account where the minted tokens should go\n\t/// @param authority the public key of the mint authority\n\t/// @param amount the amount of tokens to mint\n\t/// @param seed PDA seed\n\t/// @param bump PDA bump\n\tfunction pda_mint_to(address mint, address account, address authority, uint64 amount, bytes seed, bytes bump) internal {\n\t\tbytes instr = new bytes(9);\n\t\tinstr[0] = uint8(TokenInstruction.MintTo);\n\t\tinstr.writeUint64LE(amount, 1);\n\n\t\tAccountMeta[3] metas = [\n\t\t\tAccountMeta({pubkey: mint, is_writable: true, is_signer: false}),\n\t\t\tAccountMeta({pubkey: account, is_writable: true, is_signer: false}),\n\t\t\tAccountMeta({pubkey: authority, is_writable: false, is_signer: true})\n\t\t];\n\n\t\ttokenProgramId.call{accounts: metas, seeds: [[seed, bump]]}(instr);\n\t}\n\n\t/// @dev Transfer @amount token from @from to @to. The transaction should be signed by the owner\n\t/// keypair of the from account.\n\t/// @param from the account to transfer tokens from\n\t/// @param to the account to transfer tokens to\n\t/// @param owner the publickey of the from account owner keypair\n\t/// @param amount the amount to transfer\n\tfunction transfer(address from, address to, address owner, uint64 amount) internal {\n\t\tbytes instr = new bytes(9);\n\t\tinstr[0] = uint8(TokenInstruction.Transfer);\n\t\tinstr.writeUint64LE(amount, 1);\n\n\t\tAccountMeta[3] metas = [\n\t\t\tAccountMeta({pubkey: from, is_writable: true, is_signer: false}),\n\t\t\tAccountMeta({pubkey: to, is_writable: true, is_signer: false}),\n\t\t\tAccountMeta({pubkey: owner, is_writable: false, is_signer: true})\n\t\t];\n\n\t\ttokenProgramId.call{accounts: metas}(instr);\n\t}\n\n\t/// @dev Burn @amount tokens in account. This transaction should be signed by the PDA.\n\t/// @param account the acount for which tokens should be burned\n\t/// @param mint the mint for this token\n\t/// @param owner the publickey of the account owner keypair\n\t/// @param amount the amount to burn\n\t/// @param seed PDA seed\n\t/// @param bump PDA bump\n\tfunction pda_burn(address account, address mint, address owner, uint64 amount, bytes seed, bytes bump) internal {\n\t\tbytes instr = new bytes(9);\n\t\tinstr[0] = uint8(TokenInstruction.Burn);\n\t\tinstr.writeUint64LE(amount, 1);\n\n\t\tAccountMeta[3] metas = [\n\t\t\tAccountMeta({pubkey: account, is_writable: true, is_signer: false}),\n\t\t\tAccountMeta({pubkey: mint, is_writable: true, is_signer: false}),\n\t\t\tAccountMeta({pubkey: owner, is_writable: false, is_signer: true})\n\t\t];\n\n\t\ttokenProgramId.call{accounts: metas, seeds: [[seed, bump]]}(instr);\n\t}\n\n\t/// @dev Get the total supply for the mint, i.e. the total amount in circulation\n\t/// @param account The AccountInfo struct for the mint account\n\tfunction total_supply(AccountInfo account) internal view returns (uint64) {\n\t\treturn account.data.readUint64LE(36);\n\t}\n\n\t/// @dev Get the balance for an account.\n\t/// @param account the struct AccountInfo whose account balance we want to retrieve\n\tfunction get_balance(AccountInfo account) internal view returns (uint64) {\n\t\treturn account.data.readUint64LE(64);\n\t}\n}"
    }
  ]
}