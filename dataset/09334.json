{
  "Title": "[H-01] User can call liquidate() and steal all collateral due to arbitrary router call",
  "Content": "_Submitted by 0xDjango_\n\n<https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/liquidityMining/v2/PARMinerV2.sol#L126>\n\n<https://github.com/Uniswap/v2-periphery/blob/2efa12e0f2d808d9b49737927f0e416fafa5af68/contracts/UniswapV2Router02.sol#L299>\n\n<https://github.com/Uniswap/solidity-lib/blob/c01640b0f0f1d8a85cba8de378cc48469fcfd9a6/contracts/libraries/TransferHelper.sol#L47-L50>\n\nA malicious user is able to steal all collateral of an unhealthy position in `PARMinerV2.sol`. The code for the `liquidate()` function is written so that the following steps are followed:\n\n*   User calls `PARMinerV2.liquidate()`\n*   PARMinerV2 performs the liquidation with `_a.parallel().core().liquidatePartial()`\n*   PARMinerV2 receives the liquidated collateral\n*   An arbitrary router function is called to swap the collateral to PAR\n*   Finally, `PARMinerV2.liquidate()` checks that PARMinerV2's PAR balance is higher than the balance at the beginning of the function call.\n\nThe exploit occurs with the arbitrary router call. The malicious user is able to supply the `dexTxnData` parameter which dictates the function call to the router. If the user supplied a function such as UniswapV2Router's `swapExactTokenForETH()`, then control flow will be given to the user, allowing them to perform the exploit.\n\nNote: The Mimo developers have stated that the routers used by the protocol will be DEX Aggregators such as 1inch and Paraswap, but this submission will be referring to UniswapV2Router for simplicity. It can be assumed that the dex aggregators currently allow swapping tokens for ETH.\n\nContinuing the exploit, once the attacker has gained control due to the ETH transfer, they are able to swap the ETH for PAR. Finally, they deposit the PAR with `PARMinerV2.deposit()`. This will cause the final check of `liquidate()` to pass because PARMinerV2's PAR balance will be larger than the start of the liquidation call.\n\nThe attacker is able to steal all collateral from every unhealthy position that they liquidate. In the most extreme case, the attacker is able to open their own risky positions with the hope that the position becomes unhealthy. They will borrow the PAR and then liquidate themselves to take back the collateral. Thus effectively stealing PAR.\n\n### Proof of Concept\n\nSteps for exploit:\n\n*   Attacker monitors unhealthy positions. Finds a position to liquidate.\n*   Attacker calls `PARMinerV2.liquidate()`\n*   Position liquidated. Collateral transferred back to `PARMinerV2`\n*   In the `liquidate()` function, attacker supplies bytes for `UniswapV2Router.swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)`. For `to`, they supply the attacker contract.\n*   `swapExactTokensForETH()` firstly swaps the collateral for ETH and then transfers the ETH to the user with `TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);`\n*   `TransferHelper.safeTransferETH()` contains a call to the receiver via `(bool success, ) = to.call{value: value}(new bytes(0));`\n*   Therefore, the attacker contract will indeed gain control of execution.\n\nThe attacker contract will then perform the following steps:\n\n*   Swap the received ETH to PAR.\n*   Deposit the PAR in `PARMinerV2`\n*   Withdraw the deposited PAR.\n\n### Recommended Mitigation Steps\n\nThe arbitrary call to the router contracts is risky because of the various functions that they can contain. Perhaps a solution is to only allow certain calls such as swapping tokens to tokens, not ETH. This would require frequently updated knowledge of the router's functions, though would be beneficial for security.\n\nAlso, adding a check that the `_totalStake` variable has not increased during the liquidation call will mitigate the risk of the attacker depositing the PAR to increase the contract's balance. The attacker would have no option but to transfer the PAR to PARMinerV2 as is intended.\n\n**[m19 (Mimo Defi) disagreed with severity and commented](https://github.com/code-423n4/2022-04-mimo-findings/issues/83#issuecomment-1118331621):**\n > We believe in theory this attack is actually possible, but highly unlikely to happen. It also begs the question of whether it's really worth it for an attacker to do this because they could just call VaultsCore.liquidate() themselves (for example with a flashloan) and stake all the PAR they profit that way directly.\n\n**[m19 (Mimo DeFi) confirmed and commented](https://github.com/code-423n4/2022-04-mimo-findings/issues/83#issuecomment-1120159996):**\n > We misunderstood this exploit wrong and we confirm it. Basically, if the attacker was liquidating a 10,000 PAR position, he could potentially end up with a 10,000 PAR stake + liquidation profits. Our previous understanding was that he could only end up with the profits.\n> \n> At the very least we'll implement a check that `totalStake` hasn't changed, we will carefully consider if more changes are needed.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-04-mimo-defi-contest",
  "Code": [
    {
      "filename": "core/contracts/liquidityMining/v2/PARMinerV2.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/IGenericMinerV2.sol\";\nimport \"../../dex/interfaces/IDexAddressProvider.sol\";\nimport \"../../interfaces/IVaultsDataProvider.sol\";\nimport \"../../libraries/ABDKMath64x64.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\ncontract PARMinerV2 is IGenericMinerV2 {\n  using ABDKMath64x64 for int128;\n  using ABDKMath64x64 for uint256;\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  IERC20 internal _par;\n  IGovernanceAddressProvider internal _a;\n  IDexAddressProvider internal immutable _dexAP;\n\n  BoostConfig internal _boostConfig;\n\n  mapping(address => UserInfo) internal _users;\n\n  uint256 internal _totalStake;\n  uint256 internal _totalStakeWithBoost;\n  uint256 internal _liquidateCallerReward;\n\n  uint256 internal _mimoBalanceTracker;\n  uint256 internal _accMimoAmountPerShare;\n\n  uint256 internal _parBalanceTracker;\n  uint256 internal _accParAmountPerShare;\n\n  modifier onlyManager {\n    require(_a.parallel().controller().hasRole(_a.parallel().controller().MANAGER_ROLE(), msg.sender), \"LM010\");\n    _;\n  }\n\n  constructor(\n    IGovernanceAddressProvider govAP,\n    IDexAddressProvider dexAP,\n    BoostConfig memory boostConfig\n  ) public {\n    require(address(govAP) != address(0), \"LM000\");\n    require(address(dexAP) != address(0), \"LM000\");\n    require(boostConfig.a >= 1 && boostConfig.d > 0 && boostConfig.maxBoost >= 1, \"LM004\");\n    _a = govAP;\n    _dexAP = dexAP;\n    _liquidateCallerReward = 200 ether;\n\n    _par = IERC20(govAP.parallel().stablex());\n    _par.approve(address(_a.parallel().core()), uint256(-1));\n\n    _boostConfig = boostConfig;\n\n    emit BoostConfigSet(boostConfig);\n  }\n\n  /**\n    Sets new boost config\n    @dev can only be called by protocol manager\n    @param newBoostConfig contains all boost multiplier parameters, see {IGenericMinerV2 - BoostConfig}\n   */\n  function setBoostConfig(BoostConfig memory newBoostConfig) external onlyManager {\n    require(newBoostConfig.a >= 1 && newBoostConfig.d > 0 && newBoostConfig.maxBoost >= 1, \"LM004\");\n    _boostConfig = newBoostConfig;\n\n    emit BoostConfigSet(_boostConfig);\n  }\n\n  /**\n    Sets liquidation call reward amount\n    @dev can only be called by protocol manager\n    @param amount the amount to reward liquidate method callers with\n   */\n  function setLiquidateCallerReward(uint256 amount) external onlyManager {\n    _liquidateCallerReward = amount;\n  }\n\n  /**\n    Deposit an ERC20 pool token for staking\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20\n    @param amount the amount of tokens to be deposited. Unit is in WEI\n  **/\n  function deposit(uint256 amount) public {\n    _par.safeTransferFrom(msg.sender, address(this), amount);\n    _increaseStake(msg.sender, amount);\n  }\n\n  /**\n    Withdraw staked ERC20 pool tokens. Will fail if user does not have enough tokens staked\n    @param amount the amount of tokens to be withdrawn. Unit is in WEI\n  **/\n  function withdraw(uint256 amount) public {\n    _par.safeTransfer(msg.sender, amount);\n    _decreaseStake(msg.sender, amount);\n  }\n\n  /**\n    Liquidate a vault with a specific amount, and sell collaterall back to PAR\n    @param vaultId the ID of the vault to be liquidated\n    @param amount the amount of debt+liquidationFee to repay\n    @param dexIndex the index of dex in dex address provider mapping\n    @param dexTxData the tx data used to sell collateral back to PAR\n  **/\n  function liquidate(\n    uint256 vaultId,\n    uint256 amount,\n    uint256 dexIndex,\n    bytes calldata dexTxData\n  ) public {\n    uint256 parBalanceBefore = _par.balanceOf(address(this));\n\n    IVaultsDataProvider.Vault memory vault = _a.parallel().vaultsData().vaults(vaultId);\n    IERC20 collateralToken = IERC20(vault.collateralType);\n    _a.parallel().core().liquidatePartial(vaultId, amount);\n\n    (address proxy, address router) = _dexAP.dexMapping(dexIndex);\n    collateralToken.approve(proxy, collateralToken.balanceOf(address(this)));\n    router.call(dexTxData);\n    _par.safeTransfer(msg.sender, _liquidateCallerReward);\n    require(_par.balanceOf(address(this)) > parBalanceBefore, \"LM104\");\n    _refreshPAR(_totalStake);\n  }\n\n  /**\n    Releases outstanding rewards balances to the user\n    @param _user the address of the user for which the reward tokens will be released\n  */\n  function releaseRewards(address _user) public override {\n    UserInfo memory _userInfo = _users[_user];\n    _releaseRewards(_user, _userInfo, _totalStake, false);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n    _updateBoost(_user, _userInfo);\n  }\n\n  /**\n    Restakes the outstanding PAR reward balance to the user. Instead of sending the PAR to the user, it will be added to their stake\n    @param _user the address of the user for which the PAR tokens will be restaked\n  */\n  function restakePAR(address _user) public {\n    UserInfo storage userInfo = _users[_user];\n    _refresh();\n    _refreshPAR(_totalStake);\n    uint256 pendingPAR = userInfo.stakeWithBoost.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));\n    _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);\n    userInfo.accParAmountPerShare = _accParAmountPerShare;\n\n    _increaseStake(_user, pendingPAR);\n  }\n\n  /**\n    Reapplies the boost of the user, useful a whale's vMIMO has decreased but their boost is still the original value\n  */\n  function updateBoost(address _user) public {\n    UserInfo memory userInfo = _users[_user];\n    _updateBoost(_user, userInfo);\n  }\n\n  /**\n    Returns the number of tokens a user has staked\n    @param _user the address of the user\n    @return number of staked tokens\n  */\n  function stake(address _user) public view override returns (uint256) {\n    return _users[_user].stake;\n  }\n\n  /**\n    Returns the number of tokens a user has staked with the boost\n    @param _user the address of the user\n    @return number of staked tokens with boost\n  */\n  function stakeWithBoost(address _user) public view override returns (uint256) {\n    return _users[_user].stakeWithBoost;\n  }\n\n  /**\n    Returns the number of tokens a user can claim via `releaseMIMO`\n    @param _user the address of the user\n    @return number of MIMO tokens that the user can claim\n  */\n  function pendingMIMO(address _user) public view override returns (uint256) {\n    UserInfo memory _userInfo = _users[_user];\n    return _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);\n  }\n\n  /**\n    Returns the number of PAR tokens the user has earned as a reward\n    @param _user the address of the user\n    @return nnumber of PAR tokens that will be sent automatically when staking/unstaking\n  */\n  function pendingPAR(address _user) public view override returns (uint256) {\n    UserInfo memory _userInfo = _users[_user];\n    uint256 currentBalance = _par.balanceOf(address(this)).sub(_totalStake);\n    uint256 reward = currentBalance.sub(_parBalanceTracker);\n    uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));\n\n    return _pendingPAR(accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n  }\n\n  function par() public view override returns (IERC20) {\n    return _par;\n  }\n\n  function a() public view override returns (IGovernanceAddressProvider) {\n    return _a;\n  }\n\n  function boostConfig() public view override returns (BoostConfig memory) {\n    return _boostConfig;\n  }\n\n  function totalStake() public view override returns (uint256) {\n    return _totalStake;\n  }\n\n  function totalStakeWithBoost() public view override returns (uint256) {\n    return _totalStakeWithBoost;\n  }\n\n  function liquidateCallerReward() public view returns (uint256) {\n    return _liquidateCallerReward;\n  }\n\n  /**\n    Returns the userInfo stored of a user\n    @param _user the address of the user\n    @return `struct UserInfo {\n      uint256 stake;\n      uint256 stakeWithBoost;\n      uint256 accAmountPerShare;\n      uint256 accParAmountPerShare;\n    }`\n  **/\n  function userInfo(address _user) public view override returns (UserInfo memory) {\n    return _users[_user];\n  }\n\n  /**\n    Refreshes the global state and subsequently increases a user's stake\n    This is an internal call and meant to be called within derivative contracts\n    @param _user the address of the user\n    @param _value the amount by which the stake will be increased\n  */\n  function _increaseStake(address _user, uint256 _value) internal {\n    require(_value > 0, \"LM101\");\n\n    UserInfo memory _userInfo = _users[_user];\n\n    uint256 newTotalStake = _totalStake.add(_value);\n\n    _releaseRewards(_user, _userInfo, newTotalStake, true);\n    uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n    _totalStake = newTotalStake;\n    _userInfo.stake = _userInfo.stake.add(_value);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n\n    if (pendingPAR > 0) {\n      _userInfo.stake = _userInfo.stake.add(pendingPAR);\n      _totalStake = _totalStake.add(pendingPAR);\n    }\n\n    _updateBoost(_user, _userInfo);\n\n    emit StakeIncreased(_user, _value.add(pendingPAR));\n  }\n\n  /**\n    Refreshes the global state and subsequently decreases the stake a user has\n    This is an internal call and meant to be called within derivative contracts\n    @param _user the address of the user\n    @param _value the amount by which the stake will be reduced\n  */\n  function _decreaseStake(address _user, uint256 _value) internal {\n    require(_value > 0, \"LM101\");\n    UserInfo memory _userInfo = _users[_user];\n    require(_userInfo.stake >= _value, \"LM102\");\n\n    uint256 newTotalStake = _totalStake.sub(_value);\n\n    _releaseRewards(_user, _userInfo, newTotalStake, false);\n    _totalStake = newTotalStake;\n    _userInfo.stake = _userInfo.stake.sub(_value);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n    _updateBoost(_user, _userInfo);\n\n    emit StakeDecreased(_user, _value);\n  }\n\n  /**\n    Releases outstanding rewards balances to the user\n    @param _user the address of the user for which the reward tokens will be released\n  */\n  function _releaseRewards(\n    address _user,\n    UserInfo memory _userInfo,\n    uint256 _newTotalStake,\n    bool _restakePAR\n  ) internal {\n    uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);\n    _refresh();\n    _refreshPAR(_newTotalStake);\n    uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n    if (_userInfo.stakeWithBoost > 0) {\n      _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);\n      _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);\n    }\n\n    if (pendingPAR > 0 && !_restakePAR) {\n      require(_par.transfer(_user, pendingPAR), \"LM100\");\n    }\n    if (pendingMIMO > 0) {\n      require(_a.mimo().transfer(_user, pendingMIMO), \"LM100\");\n    }\n  }\n\n  /**\n    Updates the internal state variables based on user's veMIMO hodlings\n    @param _user the address of the user\n   */\n  function _updateBoost(address _user, UserInfo memory _userInfo) internal {\n    // if user had a boost already, first remove it from the totalStakeWithBoost\n    if (_userInfo.stakeWithBoost > 0) {\n      _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);\n    }\n    uint256 multiplier = _getBoostMultiplier(_user);\n    _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);\n    _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);\n    _users[_user] = _userInfo;\n  }\n\n  /**\n    Updates the internal state variables after accounting for newly received MIMO tokens\n  */\n  function _refresh() internal {\n    if (_totalStake == 0) {\n      return;\n    }\n    uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));\n    uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);\n    _mimoBalanceTracker = currentMimoBalance;\n    _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));\n  }\n\n  /**\n    Updates the internal state variables after accounting for newly received PAR tokens\n    @dev need to pass updated stake as arg because reward token and stake token are the same\n    @param newTotalStake updated total stake in PAR tokens\n  */\n  function _refreshPAR(uint256 newTotalStake) internal {\n    if (_totalStake == 0) {\n      return;\n    }\n    uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);\n    uint256 parReward = currentParBalance.sub(_parBalanceTracker);\n\n    _parBalanceTracker = currentParBalance;\n    _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));\n  }\n\n  /**\n    Returns the number of tokens a user can claim via `releaseMIMO`\n    @return number of MIMO tokens that the user can claim\n  */\n  function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {\n    if (_totalStakeWithBoost == 0) {\n      return 0;\n    }\n    uint256 currentBalance = _a.mimo().balanceOf(address(this));\n    uint256 reward = currentBalance.sub(_mimoBalanceTracker);\n    uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));\n    return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));\n  }\n\n  /**\n    Returns the number of PAR tokens the user has earned as a reward\n    @return number of PAR tokens that will be sent automatically when staking/unstaking\n  */\n  function _pendingPAR(\n    uint256 accParAmountPerShare,\n    uint256 _userStakeWithBoost,\n    uint256 _userAccParAmountPerShare\n  ) internal view returns (uint256) {\n    if (_totalStakeWithBoost == 0) {\n      return 0;\n    }\n    return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));\n  }\n\n  /**\n    Returns the boost multiplier the user is eligible for\n    @param _user the address of the user\n    @return the boost multuplie based on the user's veMIMO per the boost formula : a + b / (c + e^-((veMIMO / d) - e))\n   */\n  function _getBoostMultiplier(address _user) internal view returns (uint256) {\n    uint256 veMIMO = _a.votingEscrow().balanceOf(_user);\n\n    if (veMIMO == 0) return 1e18;\n\n    // Convert boostConfig variables to signed 64.64-bit fixed point numbers\n    int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);\n    int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);\n    int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);\n    int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);\n    int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);\n\n    int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000\n    int128 e2 = e1.sub(e); // x/25000 - 6\n    int128 e3 = e2.neg(); // -(x/25000 - 6)\n    int128 e4 = e3.exp(); // e^-(x/25000 - 6)\n    int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)\n    int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))\n    uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64\n    uint256 multiplier = uint256(e7); // convert to uint256\n\n    require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, \"LM103\");\n\n    return multiplier;\n  }\n}"
    },
    {
      "filename": "contracts/UniswapV2Router02.sol",
      "content": "pragma solidity =0.6.6;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '@uniswap/lib/contracts/libraries/TransferHelper.sol';\n\nimport './interfaces/IUniswapV2Router02.sol';\nimport './libraries/UniswapV2Library.sol';\nimport './libraries/SafeMath.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IWETH.sol';\n\ncontract UniswapV2Router02 is IUniswapV2Router02 {\n    using SafeMath for uint;\n\n    address public immutable override factory;\n    address public immutable override WETH;\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n        _;\n    }\n\n    constructor(address _factory, address _WETH) public {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal virtual returns (uint amountA, uint amountB) {\n        // create the pair if it doesn't exist yet\n        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n            IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n        }\n        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IUniswapV2Pair(pair).mint(to);\n    }\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = IUniswapV2Pair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n    }\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountA, uint amountB) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n    }\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountToken, uint amountETH) {\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\n        (, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountETH) {\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\n        );\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        uint amountIn = msg.value;\n        IWETH(WETH).deposit{value: amountIn}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(path, address(this));\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).withdraw(amountOut);\n        TransferHel"
    }
  ]
}