{
  "Title": "[M-06] `depositYBLendSGLLockXchainTOLP` function of the MagnetarAssetXChainModule will not work because it transfers Singularity tokens to the user before `_withdrawToChain`",
  "Content": "\n<https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/modules/MagnetarAssetXChainModule.sol#L85-L114>\n\n<https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/modules/MagnetarAssetCommonModule.sol#L52-L63>\n\n### Description\n\nIn `depositYBLendSGLLockXchainTOLP` function of the MagnetarAssetXChainModule, after lending to SGL, it will wrap the received Singularity tokens into the TOFT wrapping token of it. Afterward, it attempts to transfer those wrapped tokens cross-chain, then unwrap them in the destination chain to lock and participate.\n\n```solidity\nfunction depositYBLendSGLLockXchainTOLP(DepositAndSendForLockingData memory data) public payable {\n    ...\n    uint256 fraction =\n        _depositYBLendSGL(data.depositData, data.singularity, IYieldBox(yieldBox), data.user, data.lendAmount);\n\n    // wrap SGL receipt into tReceipt\n    // ! User should approve `address(this)` for `IERC20(data.singularity)` !\n    uint256 toftAmount = _wrapSglReceipt(IYieldBox(yieldBox), data.singularity, data.user, fraction, data.assetId);\n\n    data.lockAndParticipateSendParams.lzParams.sendParam.amountLD = toftAmount;\n\n    // decode `composeMsg` and re-encode it with updated params\n    (uint16 msgType_,, uint16 msgIndex_, bytes memory tapComposeMsg_, bytes memory nextMsg_) =\n    TapiocaOmnichainEngineCodec.decodeToeComposeMsg(data.lockAndParticipateSendParams.lzParams.sendParam.composeMsg);\n\n    LockAndParticipateData memory lockData = abi.decode(tapComposeMsg_, (LockAndParticipateData));\n    lockData.fraction = toftAmount;\n\n    data.lockAndParticipateSendParams.lzParams.sendParam.composeMsg =\n        TapiocaOmnichainEngineCodec.encodeToeComposeMsg(abi.encode(lockData), msgType_, msgIndex_, nextMsg_);\n\n    // send on another layer for lending\n    _withdrawToChain(\n        MagnetarWithdrawData({\n            yieldBox: yieldBox,\n            assetId: data.assetId,\n            unwrap: false,\n            lzSendParams: data.lockAndParticipateSendParams.lzParams,\n            sendGas: data.lockAndParticipateSendParams.lzSendGas,\n            composeGas: data.lockAndParticipateSendParams.lzComposeGas,\n            sendVal: data.lockAndParticipateSendParams.lzSendVal,\n            composeVal: data.lockAndParticipateSendParams.lzComposeVal,\n            composeMsg: data.lockAndParticipateSendParams.lzParams.sendParam.composeMsg,\n            composeMsgType: data.lockAndParticipateSendParams.lzComposeMsgType,\n            withdraw: true\n        })\n    );\n}\n```\n\nAfter lending into the Singularity contract, `_wrapSglReceipt` is used to wrap the received Singularity tokens into TOFT tokens. Thus, they will be able to be sent cross-chain by using `_withdrawToChain` with composed messages including the `lockAndParticipate` option to perform these actions after receiving tokens\n\nThe `_withdrawToChain` function attempts to withdraw YieldBox shares of this contract (address(this)) to obtain tokens before sending them cross-chain (see this [code snippet](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/modules/MagnetarBaseModule.sol#L69)). However, `_wrapSglReceipt` has sent tokens to the user after wrapping. Therefore, there are no tokens or YieldBox shares existing in this contract, resulting in `_withdrawToChain` reverting afterward.\n\n```solidity\nfunction _wrapSglReceipt(IYieldBox yieldBox, address sgl, address user, uint256 fraction, uint256 assetId)\n    internal\n    returns (uint256 toftAmount)\n{\n    IERC20(sgl).safeTransferFrom(user, address(this), fraction);\n\n    (, address tReceiptAddress,,) = yieldBox.assets(assetId);\n\n    IERC20(sgl).approve(tReceiptAddress, fraction);\n    toftAmount = ITOFT(tReceiptAddress).wrap(address(this), address(this), fraction);\n    IERC20(tReceiptAddress).safeTransfer(user, toftAmount);\n}\n```\n\n### Impact\n\n`depositYBLendSGLLockXchainTOLP` function of MagnetarAssetXChainModule will be broken.\n\n### Recommended Mitigation Steps\n\nShould deposit into YieldBox for address(this) after wrapping Singularity tokens in the `_wrapSglReceipt` function as following:\n\n```solidity\nfunction _wrapSglReceipt(IYieldBox yieldBox, address sgl, address user, uint256 fraction, uint256 assetId)\n    internal\n    returns (uint256 toftAmount)\n{\n    IERC20(sgl).safeTransferFrom(user, address(this), fraction);\n\n    (, address tReceiptAddress,,) = yieldBox.assets(assetId);\n\n    IERC20(sgl).approve(tReceiptAddress, fraction);\n    toftAmount = ITOFT(tReceiptAddress).wrap(address(this), address(this), fraction);\n    \n    //deposit to YieldBox for this \n    IERC20(tReceiptAddress).safeApprove(address(yieldBox), toftAmount);\n    yieldBox.depositAsset(assetId, address(this), address(this), toftAmount, 0);\n}\n```\n\n**[cryptotechmaker (Tapioca) confirmed and commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/157#issuecomment-2046771041):**\n > PR [here](https://github.com/Tapioca-DAO/tapioca-periph/pull/226).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/Magnetar/modules/MagnetarAssetXChainModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n// Tapioca\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {\n    MagnetarWithdrawData,\n    DepositRepayAndRemoveCollateralFromMarketData,\n    DepositAndSendForLockingData,\n    IDepositData,\n    LockAndParticipateData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {TapiocaOmnichainEngineCodec} from \"tapioca-periph/tapiocaOmnichainEngine/TapiocaOmnichainEngineCodec.sol\";\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {ITapiocaOption} from \"tapioca-periph/interfaces/tap-token/ITapiocaOption.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {Module, IMarket} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {SafeApprove} from \"tapioca-periph/libraries/SafeApprove.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\n\nimport {MagnetarAssetCommonModule} from \"./MagnetarAssetCommonModule.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title MagnetarAssetModule\n * @author TapiocaDAO\n * @notice Magnetar Usdo related operations\n */\ncontract MagnetarAssetXChainModule is MagnetarAssetCommonModule {\n    using SafeERC20 for IERC20;\n    using SafeApprove for address;\n\n    /// =====================\n    /// Public\n    /// =====================\n\n    /**\n     * @notice cross-chain helper to deposit mint from BB, lend on SGL, lock on tOLP and participate on tOB\n     * @dev Cross chain flow:\n     *  step 1: magnetar.mintBBLendXChainSGL (chain A) -->\n     *         step 2: IUsdo compose call calls magnetar.depositYBLendSGLLockXchainTOLP (chain B) -->\n     *              step 3: IToft(sglReceipt) compose call calls magnetar.lockAndParticipate (chain X)\n     *  Lends on SGL and sends receipt token on another layer\n     *  ! Handles `step 2` described above !\n     *  !!! All uint variables should be in the LD format !!!\n     *  !!! Sets `fraction` parameter of the next call (step 2) !!!\n     * @param data.user the user to perform the operation for\n     * @param data.singularity the SGL address\n     * @param data.lendAmount the amount to lend on SGL\n     * @param data.depositData the data needed to deposit on YieldBox\n     * @param data.lockAndParticipateSendParams LZ send params for the lock or/and the participate operations\n     */\n    function depositYBLendSGLLockXchainTOLP(DepositAndSendForLockingData memory data) public payable {\n        // Check sender\n        _checkSender(data.user);\n\n        address yieldBox = IMarket(data.singularity).yieldBox();\n\n        // if `depositData.deposit`:\n        //      - deposit SGL asset to YB for `data.user`\n        // if `lendAmount` > 0:\n        //      - add asset to SGL\n        uint256 fraction =\n            _depositYBLendSGL(data.depositData, data.singularity, IYieldBox(yieldBox), data.user, data.lendAmount);\n\n        // wrap SGL receipt into tReceipt\n        // ! User should approve `address(this)` for `IERC20(data.singularity)` !\n        uint256 toftAmount = _wrapSglReceipt(IYieldBox(yieldBox), data.singularity, data.user, fraction, data.assetId);\n\n        data.lockAndParticipateSendParams.lzParams.sendParam.amountLD = toftAmount;\n\n        // decode `composeMsg` and re-encode it with updated params\n        (uint16 msgType_,, uint16 msgIndex_, bytes memory tapComposeMsg_, bytes memory nextMsg_) =\n        TapiocaOmnichainEngineCodec.decodeToeComposeMsg(data.lockAndParticipateSendParams.lzParams.sendParam.composeMsg);\n\n        LockAndParticipateData memory lockData = abi.decode(tapComposeMsg_, (LockAndParticipateData));\n        lockData.fraction = toftAmount;\n\n        data.lockAndParticipateSendParams.lzParams.sendParam.composeMsg =\n            TapiocaOmnichainEngineCodec.encodeToeComposeMsg(abi.encode(lockData), msgType_, msgIndex_, nextMsg_);\n\n        // send on another layer for lending\n        _withdrawToChain(\n            MagnetarWithdrawData({\n                yieldBox: yieldBox,\n                assetId: data.assetId,\n                unwrap: false,\n                lzSendParams: data.lockAndParticipateSendParams.lzParams,\n                sendGas: data.lockAndParticipateSendParams.lzSendGas,\n                composeGas: data.lockAndParticipateSendParams.lzComposeGas,\n                sendVal: data.lockAndParticipateSendParams.lzSendVal,\n                composeVal: data.lockAndParticipateSendParams.lzComposeVal,\n                composeMsg: data.lockAndParticipateSendParams.lzParams.sendParam.composeMsg,\n                composeMsgType: data.lockAndParticipateSendParams.lzComposeMsgType,\n                withdraw: true\n            })\n        );\n    }\n}"
    },
    {
      "filename": "contracts/Magnetar/modules/MagnetarAssetCommonModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n// Tapioca\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {\n    MagnetarWithdrawData,\n    DepositRepayAndRemoveCollateralFromMarketData,\n    DepositAndSendForLockingData,\n    IDepositData,\n    LockAndParticipateData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {TapiocaOmnichainEngineCodec} from \"tapioca-periph/tapiocaOmnichainEngine/TapiocaOmnichainEngineCodec.sol\";\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {ITapiocaOption} from \"tapioca-periph/interfaces/tap-token/ITapiocaOption.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {Module, IMarket} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {SafeApprove} from \"tapioca-periph/libraries/SafeApprove.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {MagnetarBaseModule} from \"./MagnetarBaseModule.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title MagnetarAssetModule\n * @author TapiocaDAO\n * @notice Magnetar Usdo related operations\n */\ncontract MagnetarAssetCommonModule is MagnetarBaseModule {\n    using SafeERC20 for IERC20;\n    using SafeApprove for address;\n\n    error Magnetar_ActionParamsMismatch();\n    error Magnetar_tOLPTokenMismatch();\n\n    function _wrapSglReceipt(IYieldBox yieldBox, address sgl, address user, uint256 fraction, uint256 assetId)\n        internal\n        returns (uint256 toftAmount)\n    {\n        IERC20(sgl).safeTransferFrom(user, address(this), fraction);\n\n        (, address tReceiptAddress,,) = yieldBox.assets(assetId);\n\n        IERC20(sgl).approve(tReceiptAddress, fraction);\n        toftAmount = ITOFT(tReceiptAddress).wrap(address(this), address(this), fraction);\n        IERC20(tReceiptAddress).safeTransfer(user, toftAmount);\n    }\n\n    function _depositYBLendSGL(\n        IDepositData memory depositData,\n        address singularityAddress,\n        IYieldBox yieldBox_,\n        address user,\n        uint256 lendAmount\n    ) internal returns (uint256 fraction) {\n        if (singularityAddress != address(0)) {\n            if (!cluster.isWhitelisted(0, singularityAddress)) {\n                revert Magnetar_TargetNotWhitelisted(singularityAddress);\n            }\n            _setApprovalForYieldBox(singularityAddress, yieldBox_);\n\n            IMarket singularity_ = IMarket(singularityAddress);\n\n            // if `depositData.deposit`:\n            //      - deposit SGL asset to YB for `user`\n            uint256 sglAssetId = singularity_.assetId();\n            (, address sglAssetAddress,,) = yieldBox_.assets(sglAssetId);\n            if (depositData.deposit) {\n                depositData.amount = _extractTokens(user, sglAssetAddress, depositData.amount);\n\n                sglAssetAddress.safeApprove(address(yieldBox_), depositData.amount);\n                yieldBox_.depositAsset(sglAssetId, address(this), user, depositData.amount, 0);\n            }\n\n            // if `lendAmount` > 0:\n            //      - add asset to SGL\n            fraction = 0;\n            if (lendAmount == 0 && depositData.deposit) {\n                lendAmount = depositData.amount;\n            }\n            if (lendAmount > 0) {\n                uint256 lendShare = yieldBox_.toShare(sglAssetId, lendAmount, false);\n                fraction = ISingularity(singularityAddress).addAsset(user, user, false, lendShare);\n            }\n\n            _revertYieldBoxApproval(singularityAddress, yieldBox_);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/Magnetar/modules/MagnetarBaseModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {\n    PrepareLzCallData,\n    PrepareLzCallReturn,\n    ComposeMsgData\n} from \"tapioca-periph/tapiocaOmnichainEngine/extension/TapiocaOmnichainEngineHelper.sol\";\nimport {TapiocaOmnichainEngineHelper} from\n    \"tapioca-periph/tapiocaOmnichainEngine/extension/TapiocaOmnichainEngineHelper.sol\";\nimport {ITapiocaOmnichainEngine, LZSendParam} from \"tapioca-periph/interfaces/periph/ITapiocaOmnichainEngine.sol\";\nimport {MagnetarWithdrawData} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IOftSender} from \"tapioca-periph/interfaces/oft/IOftSender.sol\";\nimport {IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {MagnetarStorage} from \"../MagnetarStorage.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract MagnetarBaseModule is Ownable, MagnetarStorage {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    error Magnetar_GasMismatch(uint256 expected, uint256 received);\n    error Magnetar_TargetNotWhitelisted(address target);\n    error Magnetar_ExtractTokenFail();\n\n    constructor() MagnetarStorage(IPearlmit(address(0))) {}\n\n    /// =====================\n    /// Internal\n    /// =====================\n    function _withdrawToChain(MagnetarWithdrawData memory data) internal {\n        if (!cluster.isWhitelisted(0, address(data.yieldBox))) {\n            revert Magnetar_TargetNotWhitelisted(address(data.yieldBox));\n        }\n        IYieldBox _yieldBox = IYieldBox(data.yieldBox);\n\n        // perform a same chain withdrawal\n        if (data.lzSendParams.sendParam.dstEid == 0) {\n            _withdrawHere(_yieldBox, data.assetId, data.lzSendParams.sendParam.to, data.lzSendParams.sendParam.amountLD);\n            return;\n        }\n\n        // perform a cross chain withdrawal\n        (, address asset,,) = _yieldBox.assets(data.assetId);\n        if (!cluster.isWhitelisted(0, asset)) {\n            revert Magnetar_TargetNotWhitelisted(asset);\n        }\n\n        _yieldBox.withdraw(data.assetId, address(this), address(this), data.lzSendParams.sendParam.amountLD, 0);\n        // TODO: decide about try-catch here\n        if (data.unwrap) {\n            _lzCustomWithdraw(\n                asset,\n                data.lzSendParams,\n                data.sendGas,\n                data.sendVal,\n                data.composeGas,\n                data.composeVal,\n                data.composeMsgType\n            );\n        } else {\n            _lzWithdraw(asset, data.lzSendParams, data.sendGas, data.sendVal);\n        }\n    }\n\n    function _setApprovalForYieldBox(address _target, IYieldBox _yieldBox) internal {\n        bool isApproved = _yieldBox.isApprovedForAll(address(this), _target);\n        if (!isApproved) {\n            _yieldBox.setApprovalForAll(_target, true);\n        }\n    }\n\n    function _revertYieldBoxApproval(address _target, IYieldBox _yieldBox) internal {\n        bool isApproved = _yieldBox.isApprovedForAll(address(this), _target);\n        if (isApproved) {\n            _yieldBox.setApprovalForAll(_target, false);\n        }\n    }\n\n    function _extractTokens(address _from, address _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n        // IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n        bool isErr = pearlmit.transferFromERC20(_from, address(this), address(_token), _amount);\n        if (isErr) revert Magnetar_ExtractTokenFail();\n        uint256 balanceAfter = IERC20(_token).balanceOf(address(this));\n        if (balanceAfter <= balanceBefore) revert Magnetar_ExtractTokenFail();\n        return balanceAfter - balanceBefore;\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _withdrawHere(IYieldBox _yieldBox, uint256 _assetId, bytes32 _to, uint256 _amount) private {\n        _yieldBox.withdraw(_assetId, address(this), OFTMsgCodec.bytes32ToAddress(_to), _amount, 0);\n    }\n\n    function _lzWithdraw(address _asset, LZSendParam memory _lzSendParam, uint128 _lzSendGas, uint128 _lzSendVal)\n        private\n    {\n        PrepareLzCallReturn memory prepareLzCallReturn = _prepareLzSend(_asset, _lzSendParam, _lzSendGas, _lzSendVal);\n\n        if (msg.value < prepareLzCallReturn.msgFee.nativeFee) {\n            revert Magnetar_GasMismatch(prepareLzCallReturn.msgFee.nativeFee, msg.value);\n        }\n\n        IOftSender(_asset).sendPacket{value: prepareLzCallReturn.msgFee.nativeFee}(\n            prepareLzCallReturn.lzSendParam, prepareLzCallReturn.composeMsg\n        );\n    }\n\n    function _lzCustomWithdraw(\n        address _asset,\n        LZSendParam memory _lzSendParam,\n        uint128 _lzSendGas,\n        uint128 _lzSendVal,\n        uint128 _lzComposeGas,\n        uint128 _lzComposeVal,\n        uint16 _lzComposeMsgType\n    ) private {\n        PrepareLzCallReturn memory prepareLzCallReturn = _prepareLzSend(_asset, _lzSendParam, _lzSendGas, _lzSendVal);\n\n        TapiocaOmnichainEngineHelper _toeHelper = new TapiocaOmnichainEngineHelper();\n        PrepareLzCallReturn memory prepareLzCallReturn2 = _toeHelper.prepareLzCall(\n            ITapiocaOmnichainEngine(_asset),\n            PrepareLzCallData({\n                dstEid: _lzSendParam.sendParam.dstEid,\n                recipient: _lzSendParam.sendParam.to,\n                amountToSendLD: 0,\n                minAmountToCreditLD: 0,\n                msgType: _lzComposeMsgType,\n                composeMsgData: ComposeMsgData({\n                    index: 0,\n                    gas: _lzComposeGas,\n                    value: prepareLzCallReturn.msgFee.nativeFee.toUint128(),\n                    data: _lzSendParam.sendParam.composeMsg,\n                    prevData: bytes(\"\"),\n                    prevOptionsData: bytes(\"\")\n                }),\n                lzReceiveGas: _lzSendGas + _lzComposeGas,\n                lzReceiveValue: _lzComposeVal\n            })\n        );\n\n        if (msg.value < prepareLzCallReturn2.msgFee.nativeFee) {\n            revert Magnetar_GasMismatch(prepareLzCallReturn2.msgFee.nativeFee, msg.value);\n        }\n\n        IOftSender(_asset).sendPacket{value: prepareLzCallReturn2.msgFee.nativeFee}(\n            prepareLzCallReturn2.lzSendParam, prepareLzCallReturn2.composeMsg\n        );\n    }\n\n    function _prepareLzSend(address _asset, LZSendParam memory _lzSendParam, uint128 _lzSendGas, uint128 _lzSendVal)\n        private\n        returns (PrepareLzCallReturn memory prepareLzCallReturn)\n    {\n        TapiocaOmnichainEngineHelper _toeHelper = new TapiocaOmnichainEngineHelper();\n        prepareLzCallReturn = _toeHelper.prepareLzCall(\n            ITapiocaOmnichainEngine(_asset),\n            PrepareLzCallData({\n                dstEid: _lzSendParam.sendParam.dstEid,\n                recipient: _lzSendParam.sendParam.to,\n                amountToSendLD: _lzSendParam.sendParam.amountLD,\n                minAmountToCreditLD: _lzSendParam.sendParam.minAmountLD,\n                msgType: 1, // SEND\n                composeMsgData: ComposeMsgData({\n                    index: 0,\n                    gas: 0,\n                    value: 0,\n                    data: bytes(\"\"),\n                    prevData: bytes(\"\"),\n                    prevOptionsData: bytes(\"\")\n                }),\n                lzReceiveGas: _lzSendGas,\n                lzReceiveValue: _lzSendVal\n            })\n        );\n    }\n}"
    }
  ]
}