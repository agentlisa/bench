{
  "Title": "M-26: Fee receiver does not get paid when collateral is enough to cover the funding fee, during liquidation",
  "Content": "# Issue M-26: Fee receiver does not get paid when collateral is enough to cover the funding fee, during liquidation \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/146 \n\n## Found by \nIllIllI\n\n## Summary\n\nWhen a position is liquidated, and there is enough collateral to cover the outstanding funding fee, the fee receiver does not get paid its fee\n\n\n## Vulnerability Detail\n\nAll of the remaining collateral is given to the pool, rather than paying the portion of position fees owed to the fee receiver\n\n\n## Impact\n\nFee receiver does not get paid its share, which is instead given to the pool\n\n\n## Code Snippet\n\nThe PnL funds are all given to the pool, and the `_fees` variable, which contains the fee receiver portion remains uninitialized.\n```solidity\n// File: gmx-synthetics/contracts/position/DecreasePositionCollateralUtils.sol : DecreasePositionCollateralUtils.getLiquidationValues()   #1\n\n346            } else {\n347 @>             values.pnlAmountForPool = (params.position.collateralAmount() - fees.funding.fundingFeeAmount).toInt256();\n348            }\n349    \n350 @>         PositionPricingUtils.PositionFees memory _fees;\n351    \n352            PositionUtils.DecreasePositionCollateralValues memory _values = PositionUtils.DecreasePositionCollateralValues(\n353                values.pnlTokenForPool,\n354                values.executionPrice, // executionPrice\n355                0, // remainingCollateralAmount\n356                values.positionPnlUsd, // positionPnlUsd\n357 @>             values.pnlAmountForPool, // pnlAmountForPool\n358                0, // pnlAmountForUser\n359                values.sizeDeltaInTokens, // sizeDeltaInTokens\n360                values.priceImpactAmount, // priceImpactAmount\n361                0, // priceImpactDiffUsd\n362                0, // priceImpactDiffAmount\n363                PositionUtils.DecreasePositionCollateralValuesOutput(\n364                    address(0),\n365                    0,\n366                    address(0),\n367                    0\n368                )\n369            );\n370    \n371 @>         return (_values, _fees);\n372:       }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/position/DecreasePositionCollateralUtils.sol#L342-L372\n\nThe empty fees are returned, and the function exits, skipping the paying of the fee receiver's portion of the [position fees](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/position/DecreasePositionCollateralUtils.sol#L216-L258) that are [owed](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/position/DecreasePositionCollateralUtils.sol#L162).\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nSplit the fees properly in `getLiquidationValues()` and don't return early after the call to `getLiquidationValues()`\n\n\n\n\n\n## Discussion\n\n**xvi10**\n\nthis is a valid concern, but we do not think that the contracts should be changed for it, for simplicity the fee receiver does not receive a fee for this case\n\n**IllIllI000**\n\nI'm leaving this open since the fees are not paid\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/position/DecreasePositionCollateralUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Precision.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../pricing/PositionPricingUtils.sol\";\n\nimport \"./Position.sol\";\nimport \"./PositionEventUtils.sol\";\nimport \"./PositionStoreUtils.sol\";\nimport \"./PositionUtils.sol\";\nimport \"../order/BaseOrderUtils.sol\";\nimport \"../order/OrderEventUtils.sol\";\n\nimport \"../swap/SwapUtils.sol\";\n\n// @title DecreasePositionCollateralUtils\n// @dev Library for functions to help with the calculations when decreasing a position\nlibrary DecreasePositionCollateralUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    error InsufficientCollateral(int256 remainingCollateralAmount);\n    error InvalidOutputToken(address tokenOut, address expectedTokenOut);\n\n    struct ProcessCollateralCache {\n        int256 adjustedPositionPnlUsd;\n        uint256 adjustedPriceImpactDiffUsd;\n        uint256 adjustedPriceImpactDiffAmount;\n        uint256 pnlDiffAmount;\n    }\n\n    // @dev handle the collateral changes of the position\n    // @param params PositionUtils.UpdatePositionParams\n    // @param cache DecreasePositionCache\n    // @return (PositionUtils.DecreasePositionCollateralValues, PositionPricingUtils.PositionFees)\n    function processCollateral(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionUtils.DecreasePositionCache memory cache\n    ) external returns (\n        PositionUtils.DecreasePositionCollateralValues memory,\n        PositionPricingUtils.PositionFees memory\n    ) {\n        ProcessCollateralCache memory collateralCache;\n        PositionUtils.DecreasePositionCollateralValues memory values;\n        values.remainingCollateralAmount = cache.initialCollateralAmount.toInt256();\n\n        Price.Props memory collateralTokenPrice = MarketUtils.getCachedTokenPrice(params.order.initialCollateralToken(), params.market, cache.prices);\n\n        (values.executionPrice, values.priceImpactAmount, values.priceImpactDiffUsd) = getExecutionPrice(params, cache.prices, params.order.sizeDeltaUsd());\n\n        (values.positionPnlUsd, values.sizeDeltaInTokens) = PositionUtils.getPositionPnlUsd(\n            params.contracts.dataStore,\n            params.market,\n            cache.prices,\n            params.position,\n            values.executionPrice,\n            params.order.sizeDeltaUsd()\n        );\n\n        collateralCache.adjustedPositionPnlUsd = values.positionPnlUsd;\n        collateralCache.adjustedPriceImpactDiffUsd = values.priceImpactDiffUsd;\n\n        if (values.positionPnlUsd > 0 && values.priceImpactDiffUsd > 0) {\n            if (values.positionPnlUsd > values.priceImpactDiffUsd.toInt256()) {\n                collateralCache.adjustedPositionPnlUsd = values.positionPnlUsd - values.priceImpactDiffUsd.toInt256();\n                collateralCache.adjustedPriceImpactDiffUsd = 0;\n            } else {\n                collateralCache.adjustedPositionPnlUsd = 0;\n                collateralCache.adjustedPriceImpactDiffUsd = values.priceImpactDiffUsd - values.positionPnlUsd.toUint256();\n            }\n        }\n\n        collateralCache.adjustedPriceImpactDiffAmount = collateralCache.adjustedPriceImpactDiffUsd / collateralTokenPrice.max;\n\n        if (collateralCache.adjustedPriceImpactDiffUsd > 0 && params.order.initialCollateralDeltaAmount() > 0) {\n            uint256 initialCollateralDeltaAmount = params.order.initialCollateralDeltaAmount();\n\n            if (collateralCache.adjustedPriceImpactDiffAmount > params.order.initialCollateralDeltaAmount()) {\n                params.order.setInitialCollateralDeltaAmount(0);\n            } else {\n                params.order.setInitialCollateralDeltaAmount(params.order.initialCollateralDeltaAmount() - collateralCache.adjustedPriceImpactDiffAmount);\n            }\n\n            OrderEventUtils.emitOrderCollateralDeltaAmountAutoUpdated(\n                params.contracts.eventEmitter,\n                params.orderKey,\n                initialCollateralDeltaAmount,\n                params.order.initialCollateralDeltaAmount()\n            );\n        }\n\n        values.remainingCollateralAmount -= params.order.initialCollateralDeltaAmount().toInt256();\n        values.output.outputToken = params.position.collateralToken();\n        values.output.outputAmount = params.order.initialCollateralDeltaAmount();\n        values.output.secondaryOutputToken = cache.pnlToken;\n\n        if (collateralCache.adjustedPositionPnlUsd < 0) {\n            // position realizes a loss\n            // deduct collateral from user, transfer it to the pool\n            values.pnlTokenForPool = params.position.collateralToken();\n            values.pnlAmountForPool = -values.positionPnlUsd / collateralTokenPrice.min.toInt256();\n            values.remainingCollateralAmount -= values.pnlAmountForPool;\n        } else {\n            // position realizes a profit\n            // deduct the pnl from the pool\n            values.pnlTokenForPool = cache.pnlToken;\n            values.pnlAmountForPool = -values.positionPnlUsd / cache.pnlTokenPrice.max.toInt256();\n            values.pnlAmountForUser = collateralCache.adjustedPositionPnlUsd.toUint256() / cache.pnlTokenPrice.max;\n\n            // if the price impact was capped send the difference to a holding area\n            collateralCache.pnlDiffAmount = (-values.pnlAmountForPool - values.pnlAmountForUser.toInt256()).toUint256();\n            if (collateralCache.pnlDiffAmount > 0) {\n                MarketUtils.incrementClaimableCollateralAmount(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.market.marketToken,\n                    cache.pnlToken,\n                    params.order.receiver(),\n                    collateralCache.pnlDiffAmount\n                );\n            }\n\n            // swap profit to the collateral token here so that the profit can be used\n            // to pay for the totalNetCostAmount from the fees\n            (bool wasSwapped, uint256 swapOutputAmount) = swapProfitToCollateralToken(\n                params,\n                cache.pnlToken,\n                values.pnlAmountForUser\n            );\n\n            if (wasSwapped) {\n                values.output.outputAmount += swapOutputAmount;\n            } else {\n                if (params.position.collateralToken() == cache.pnlToken) {\n                    values.output.outputAmount += values.pnlAmountForUser;\n                } else {\n                    // store the pnlAmountForUser separately as it differs from the collateralToken\n                    values.output.secondaryOutputAmount = values.pnlAmountForUser;\n                }\n            }\n        }\n\n        PositionPricingUtils.PositionFees memory fees = PositionPricingUtils.getPositionFees(\n            params.contracts.dataStore,\n            params.contracts.referralStorage,\n            params.position,\n            collateralTokenPrice,\n            params.market.longToken,\n            params.market.shortToken,\n            params.order.sizeDeltaUsd()\n        );\n\n        // if there is a positive outputAmount, use the outputAmount to pay for fees and price impact\n        // the values.output.outputToken should be the same as the position.collateralToken at this point\n        if (values.output.outputToken == params.position.collateralToken() && values.output.outputAmount > 0) {\n            if (values.output.outputAmount > fees.totalNetCostAmount) {\n                values.output.outputAmount -= fees.totalNetCostAmount;\n                fees.totalNetCostAmount = 0;\n            } else {\n                fees.totalNetCostAmount -= values.output.outputAmount;\n                values.output.outputAmount = 0;\n            }\n        }\n\n        // deduct remaining fees from the position's collateral\n        values.remainingCollateralAmount -= fees.totalNetCostAmount.toInt256();\n\n        // if there is insufficient collateral remaining then prioritize using the collateral to pay\n        // funding fees, the rest of the collateral is sent to the pool\n        // paying of closing fees should be safe to skip\n        // any difference in the paying of borrowing fees should be accounted for\n        // from the transfer of collateral to the pool and by the update of the\n        // pending borrowing fees\n        // any difference in pending negative PnL should similarly be accounted for\n        // through the transfer fo collateral to the pool and by the update of the\n        // pending pnl\n        // paying of price impact should also be safe to skip, it would be the same as\n        // closing the position with zero price impact, just that if there were any collateral that could\n        // partially pay for negative price impact, it would be sent to the pool instead\n        if (BaseOrderUtils.isLiquidationOrder(params.order.orderType()) && values.remainingCollateralAmount < 0) {\n            PositionPricingUtils.emitPositionFeesInfo(\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.position.collateralToken(),\n                false,\n                fees\n            );\n\n            PositionEventUtils.emitLiquidationInfo(\n                params.contracts.eventEmitter,\n                params.orderKey,\n                params.position.collateralAmount(),\n                values.positionPnlUsd,\n                values.remainingCollateralAmount\n            );\n\n            return getLiquidationValues(params, values, fees);\n        }\n\n        if (values.remainingCollateralAmount < 0) {\n            revert InsufficientCollateral(values.remainingCollateralAmount);\n        }\n\n        // if there is a positive impact, the impact pool amount should be reduced\n        // if there is a negative impact, the impact pool amount should be increased\n        MarketUtils.applyDeltaToPositionImpactPool(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            -values.priceImpactAmount\n        );\n\n        // if the price impact was capped, deduct the difference from the collateral\n        // and send it to a holding area\n        if (collateralCache.adjustedPriceImpactDiffAmount > 0) {\n            if (values.remainingCollateralAmount.toUint256() < collateralCache.adjustedPriceImpactDiffAmount) {\n                collateralCache.adjustedPriceImpactDiffAmount = values.remainingCollateralAmount.toUint256();\n            }\n\n            values.remainingCollateralAmount -= collateralCache.adjustedPriceImpactDiffAmount.toInt256();\n\n            MarketUtils.incrementClaimableCollateralAmount(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.position.collateralToken(),\n                params.order.receiver(),\n                collateralCache.adjustedPriceImpactDiffAmount\n            );\n        }\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            params.position.collateralToken(),\n            fees.feeReceiverAmount,\n            Keys.POSITION_FEE\n        );\n\n        return (values, fees);\n    }\n\n    function getExecutionPrice(\n        PositionUtils.UpdatePositionParams memory params,\n        MarketUtils.MarketPrices memory prices,\n        uint256 sizeDeltaUsd\n    ) internal view returns (uint256, int256, uint256) {\n        int256 priceImpactUsd = PositionPricingUtils.getPriceImpactUsd(\n            PositionPricingUtils.GetPriceImpactUsdParams(\n                params.contracts.dataStore,\n                params.market.marketToken,\n                params.market.indexToken,\n                params.market.longToken,\n                params.market.shortToken,\n                -sizeDeltaUsd.toInt256(),\n                params.order.isLong()\n            )\n        );\n\n        priceImpactUsd = MarketUtils.getCappedPositionImpactUsd(\n            params.contracts.dataStore,\n            params.market.marketToken,\n            prices.indexTokenPrice,\n            priceImpactUsd,\n            sizeDeltaUsd\n        );\n\n        uint256 priceImpactDiffUsd;\n        if (priceImpactUsd < 0) {\n            uint256 maxPriceImpactFactor = MarketUtils.getMaxPositionImpactFactor(\n                params.contracts.dataStore,\n                params.market.marketToken,\n                false\n            );\n\n            // convert the max price impact to the min negative value\n            int256 minPriceImpactUsd = -Precision.applyFactor(sizeDeltaUsd, maxPriceImpactFactor).toInt256();\n\n            if (priceImpactUsd < minPriceImpactUsd) {\n                priceImpactDiffUsd = (minPriceImpactUsd - priceImpactUsd).toUint256();\n                priceImpactUsd = minPriceImpactUsd;\n            }\n        }\n\n        uint256 executionPrice = BaseOrderUtils.getExecutionPrice(\n            params.contracts.oracle.getCustomPrice(params.market.indexToken),\n            sizeDeltaUsd,\n            priceImpactUsd,\n            params.order.acceptablePrice(),\n            params.position.isLong(),\n            false\n        );\n\n        int256 priceImpactAmount = PositionPricingUtils.getPriceImpactAmount(\n            sizeDeltaUsd,\n            executionPrice,\n            prices.indexTokenPrice,\n            params.position.isLong(),\n            false\n        );\n\n        return (executionPrice, priceImpactAmount, priceImpactDiffUsd);\n    }\n\n    function getLiquidationValues(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionUtils.DecreasePositionCollateralValues memory values,\n        PositionPricingUtils.PositionFees memory fees\n    ) internal returns (\n        PositionUtils.DecreasePositionCollateralValues memory,\n        PositionPricingUtils.PositionFees memory\n    ) {\n        if (fees.funding.fundingFeeAmount > params.position.collateralAmount()) {\n            values.pnlAmountForPool = 0;\n            // the case where this is insufficient collateral to pay funding fees\n            // should be rare, and the difference should be small\n            // in case it happens, the pool should be topped up with the required amount using\n            // an insurance fund or similar mechanism\n            PositionEventUtils.emitInsufficientFundingFeePayment(\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.position.collateralToken(),\n                fees.funding.fundingFeeAmount,\n                params.position.collateralAmount()\n            );\n        } else {\n            values.pnlAmountForPool = (params.position.collateralAmount() - fees.funding.fundingFeeAmount).toInt256();\n        }\n\n        PositionPricingUtils.PositionFees memory _fees;\n\n        PositionUtils.DecreasePositionCollateralValues memory _values = PositionUtils.DecreasePositionCollateralValues(\n            values.pnlTokenForPool,\n            values.executionPrice, // executionPrice\n            0, // remainingCollateralAmount\n            values.positionPnlUsd, // positionPnlUsd\n            values.pnlAmountForPool, // pnlAmountForPool\n            0, // pnlAmountForUser\n            values.sizeDeltaInTokens, // sizeDeltaInTokens\n            values.priceImpactAmount, // priceImpactAmount\n            0, // priceImpactDiffUsd\n            0, // priceImpactDiffAmount\n            PositionUtils.DecreasePositionCollateralValuesOutput(\n                address(0),\n                0,\n                address(0),\n                0\n            )\n        );\n\n        return (_values, _fees);\n    }\n\n    // swap the withdrawn collateral from collateralToken to pnlToken if needed\n    function swapWithdrawnCollateralToPnlToken(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionUtils.DecreasePositionCollateralValues memory values\n    ) external returns (PositionUtils.DecreasePositionCollateralValues memory) {\n        if (params.order.decreasePositionSwapType() == Order.DecreasePositionSwapType.SwapCollateralTokenToPnlToken) {\n            Market.Props[] memory swapPathMarkets = new Market.Props[](1);\n            swapPathMarkets[0] = params.market;\n\n            try params.contracts.swapHandler.swap(\n                SwapUtils.SwapParams(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.contracts.oracle,\n                    Bank(payable(params.market.marketToken)),\n                    params.position.collateralToken(), // tokenIn\n                    values.output.outputAmount, // amountIn\n                    swapPathMarkets, // markets\n                    0, // minOutputAmount\n                    params.market.marketToken, // receiver\n                    false // shouldUnwrapNativeToken\n                )\n            ) returns (address tokenOut, uint256 swapOutputAmount) {\n                if (tokenOut != values.output.secondaryOutputToken) {\n                    revert InvalidOutputToken(tokenOut, values.output.secondaryOutputToken);\n                }\n                // combine the values into outputToken and outputAmount\n                values.output.outputToken = tokenOut;\n                values.output.outputAmount = values.output.secondaryOutputAmount + swapOutputAmount;\n                values.output.secondaryOutputAmount = 0;\n            } catch Error(string memory reason) {\n                emit SwapUtils.SwapReverted(reason, \"\");\n            } catch (bytes memory reasonBytes) {\n                (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n                emit SwapUtils.SwapReverted(reason, reasonBytes);\n            }\n        }\n\n        return values;\n    }\n\n    // swap the realized profit from the pnlToken to the collateralToken if needed\n    function swapProfitToCollateralToken(\n        PositionUtils.UpdatePositionParams memory params,\n        address pnlToken,\n        uint256 profitAmount\n    ) internal returns (bool, uint256) {\n        if (params.order.decreasePositionSwapType() == Order.DecreasePositionSwapType.SwapPnlTokenToCollateralToken) {\n            Market.Props[] memory swapPathMarkets = new Market.Props[](1);\n            swapPathMarkets[0] = params.market;\n\n            try params.contracts.swapHandler.swap(\n                SwapUtils.SwapParams(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.contracts.oracle,\n                    Bank(payable(params.market.marketToken)),\n                    pnlToken, // tokenIn\n                    profitAmount, // amountIn\n                    swapPathMarkets, // markets\n                    0, // minOutputAmount\n                    params.market.marketToken, // receiver\n                    false // shouldUnwrapNativeToken\n                )\n            ) returns (address /* tokenOut */, uint256 swapOutputAmount) {\n                return (true, swapOutputAmount);\n            } catch Error(string memory reason) {\n                emit SwapUtils.SwapReverted(reason, \"\");\n            } catch (bytes memory reasonBytes) {\n                (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n                emit SwapUtils.SwapReverted(reason, reasonBytes);\n            }\n        }\n\n        return (false, 0);\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/position/DecreasePositionCollateralUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Precision.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../pricing/PositionPricingUtils.sol\";\n\nimport \"./Position.sol\";\nimport \"./PositionEventUtils.sol\";\nimport \"./PositionStoreUtils.sol\";\nimport \"./PositionUtils.sol\";\nimport \"../order/BaseOrderUtils.sol\";\nimport \"../order/OrderEventUtils.sol\";\n\nimport \"../swap/SwapUtils.sol\";\n\n// @title DecreasePositionCollateralUtils\n// @dev Library for functions to help with the calculations when decreasing a position\nlibrary DecreasePositionCollateralUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    error InsufficientCollateral(int256 remainingCollateralAmount);\n    error InvalidOutputToken(address tokenOut, address expectedTokenOut);\n\n    struct ProcessCollateralCache {\n        int256 adjustedPositionPnlUsd;\n        uint256 adjustedPriceImpactDiffUsd;\n        uint256 adjustedPriceImpactDiffAmount;\n        uint256 pnlDiffAmount;\n    }\n\n    // @dev handle the collateral changes of the position\n    // @param params PositionUtils.UpdatePositionParams\n    // @param cache DecreasePositionCache\n    // @return (PositionUtils.DecreasePositionCollateralValues, PositionPricingUtils.PositionFees)\n    function processCollateral(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionUtils.DecreasePositionCache memory cache\n    ) external returns (\n        PositionUtils.DecreasePositionCollateralValues memory,\n        PositionPricingUtils.PositionFees memory\n    ) {\n        ProcessCollateralCache memory collateralCache;\n        PositionUtils.DecreasePositionCollateralValues memory values;\n        values.remainingCollateralAmount = cache.initialCollateralAmount.toInt256();\n\n        Price.Props memory collateralTokenPrice = MarketUtils.getCachedTokenPrice(params.order.initialCollateralToken(), params.market, cache.prices);\n\n        (values.executionPrice, values.priceImpactAmount, values.priceImpactDiffUsd) = getExecutionPrice(params, cache.prices, params.order.sizeDeltaUsd());\n\n        (values.positionPnlUsd, values.sizeDeltaInTokens) = PositionUtils.getPositionPnlUsd(\n            params.contracts.dataStore,\n            params.market,\n            cache.prices,\n            params.position,\n            values.executionPrice,\n            params.order.sizeDeltaUsd()\n        );\n\n        collateralCache.adjustedPositionPnlUsd = values.positionPnlUsd;\n        collateralCache.adjustedPriceImpactDiffUsd = values.priceImpactDiffUsd;\n\n        if (values.positionPnlUsd > 0 && values.priceImpactDiffUsd > 0) {\n            if (values.positionPnlUsd > values.priceImpactDiffUsd.toInt256()) {\n                collateralCache.adjustedPositionPnlUsd = values.positionPnlUsd - values.priceImpactDiffUsd.toInt256();\n                collateralCache.adjustedPriceImpactDiffUsd = 0;\n            } else {\n                collateralCache.adjustedPositionPnlUsd = 0;\n                collateralCache.adjustedPriceImpactDiffUsd = values.priceImpactDiffUsd - values.positionPnlUsd.toUint256();\n            }\n        }\n\n        collateralCache.adjustedPriceImpactDiffAmount = collateralCache.adjustedPriceImpactDiffUsd / collateralTokenPrice.max;\n\n        if (collateralCache.adjustedPriceImpactDiffUsd > 0 && params.order.initialCollateralDeltaAmount() > 0) {\n            uint256 initialCollateralDeltaAmount = params.order.initialCollateralDeltaAmount();\n\n            if (collateralCache.adjustedPriceImpactDiffAmount > params.order.initialCollateralDeltaAmount()) {\n                params.order.setInitialCollateralDeltaAmount(0);\n            } else {\n                params.order.setInitialCollateralDeltaAmount(params.order.initialCollateralDeltaAmount() - collateralCache.adjustedPriceImpactDiffAmount);\n            }\n\n            OrderEventUtils.emitOrderCollateralDeltaAmountAutoUpdated(\n                params.contracts.eventEmitter,\n                params.orderKey,\n                initialCollateralDeltaAmount,\n                params.order.initialCollateralDeltaAmount()\n            );\n        }\n\n        values.remainingCollateralAmount -= params.order.initialCollateralDeltaAmount().toInt256();\n        values.output.outputToken = params.position.collateralToken();\n        values.output.outputAmount = params.order.initialCollateralDeltaAmount();\n        values.output.secondaryOutputToken = cache.pnlToken;\n\n        if (collateralCache.adjustedPositionPnlUsd < 0) {\n            // position realizes a loss\n            // deduct collateral from user, transfer it to the pool\n            values.pnlTokenForPool = params.position.collateralToken();\n            values.pnlAmountForPool = -values.positionPnlUsd / collateralTokenPrice.min.toInt256();\n            values.remainingCollateralAmount -= values.pnlAmountForPool;\n        } else {\n            // position realizes a profit\n            // deduct the pnl from the pool\n            values.pnlTokenForPool = cache.pnlToken;\n            values.pnlAmountForPool = -values.positionPnlUsd / cache.pnlTokenPrice.max.toInt256();\n            values.pnlAmountForUser = collateralCache.adjustedPositionPnlUsd.toUint256() / cache.pnlTokenPrice.max;\n\n            // if the price impact was capped send the difference to a holding area\n            collateralCache.pnlDiffAmount = (-values.pnlAmountForPool - values.pnlAmountForUser.toInt256()).toUint256();\n            if (collateralCache.pnlDiffAmount > 0) {\n                MarketUtils.incrementClaimableCollateralAmount(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.market.marketToken,\n                    cache.pnlToken,\n                    params.order.receiver(),\n                    collateralCache.pnlDiffAmount\n                );\n            }\n\n            // swap profit to the collateral token here so that the profit can be used\n            // to pay for the totalNetCostAmount from the fees\n            (bool wasSwapped, uint256 swapOutputAmount) = swapProfitToCollateralToken(\n                params,\n                cache.pnlToken,\n                values.pnlAmountForUser\n            );\n\n            if (wasSwapped) {\n                values.output.outputAmount += swapOutputAmount;\n            } else {\n                if (params.position.collateralToken() == cache.pnlToken) {\n                    values.output.outputAmount += values.pnlAmountForUser;\n                } else {\n                    // store the pnlAmountForUser separately as it differs from the collateralToken\n                    values.output.secondaryOutputAmount = values.pnlAmountForUser;\n                }\n            }\n        }\n\n        PositionPricingUtils.PositionFees memory fees = PositionPricingUtils.getPositionFees(\n            params.contracts.dataStore,\n            params.contracts.referralStorage,\n            params.position,\n            collateralTokenPrice,\n            params.market.longToken,\n            params.market.shortToken,\n            params.order.sizeDeltaUsd()\n        );\n\n        // if there is a positive outputAmount, use the outputAmount to pay for fees and price impact\n        // the values.output.outputToken should be the same as the position.collateralToken at this point\n        if (values.output.outputToken == params.position.collateralToken() && values.output.outputAmount > 0) {\n            if (values.output.outputAmount > fees.totalNetCostAmount) {\n                values.output.outputAmount -= fees.totalNetCostAmount;\n                fees.totalNetCostAmount = 0;\n            } else {\n                fees.totalNetCostAmount -= values.output.outputAmount;\n                values.output.outputAmount = 0;\n            }\n        }\n\n        // deduct remaining fees from the position's collateral\n        values.remainingCollateralAmount -= fees.totalNetCostAmount.toInt256();\n\n        // if there is insufficient collateral remaining then prioritize using the collateral to pay\n        // funding fees, the rest of the collateral is sent to the pool\n        // paying of closing fees should be safe to skip\n        // any difference in the paying of borrowing fees should be accounted for\n        // from the transfer of collateral to the pool and by the update of the\n        // pending borrowing fees\n        // any difference in pending negative PnL should similarly be accounted for\n        // through the transfer fo collateral to the pool and by the update of the\n        // pending pnl\n        // paying of price impact should also be safe to skip, it would be the same as\n        // closing the position with zero price impact, just that if there were any collateral that could\n        // partially pay for negative price impact, it would be sent to the pool instead\n        if (BaseOrderUtils.isLiquidationOrder(params.order.orderType()) && values.remainingCollateralAmount < 0) {\n            PositionPricingUtils.emitPositionFeesInfo(\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.position.collateralToken(),\n                false,\n                fees\n            );\n\n            PositionEventUtils.emitLiquidationInfo(\n                params.contracts.eventEmitter,\n                params.orderKey,\n                params.position.collateralAmount(),\n                values.positionPnlUsd,\n                values.remainingCollateralAmount\n            );\n\n            return getLiquidationValues(params, values, fees);\n        }\n\n        if (values.remainingCollateralAmount < 0) {\n            revert InsufficientCollateral(values.remainingCollateralAmount);\n        }\n\n        // if there is a positive impact, the impact pool amount should be reduced\n        // if there is a negative impact, the impact pool amount should be increased\n        MarketUtils.applyDeltaToPositionImpactPool(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            -values.priceImpactAmount\n        );\n\n        // if the price impact was capped, deduct the difference from the collateral\n        // and send it to a holding area\n        if (collateralCache.adjustedPriceImpactDiffAmount > 0) {\n            if (values.remainingCollateralAmount.toUint256() < collateralCache.adjustedPriceImpactDiffAmount) {\n                collateralCache.adjustedPriceImpactDiffAmount = values.remainingCollateralAmount.toUint256();\n            }\n\n            values.remainingCollateralAmount -= collateralCache.adjustedPriceImpactDiffAmount.toInt256();\n\n            MarketUtils.incrementClaimableCollateralAmount(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.position.collateralToken(),\n                params.order.receiver(),\n                collateralCache.adjustedPriceImpactDiffAmount\n            );\n        }\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            params.position.collateralToken(),\n            fees.feeReceiverAmount,\n            Keys.POSITION_FEE\n        );\n\n        return (values, fees);\n    }\n\n    function getExecutionPrice(\n        PositionUtils.UpdatePositionParams memory params,\n        MarketUtils.MarketPrices memory prices,\n        uint256 sizeDeltaUsd\n    ) internal view returns (uint256, int256, uint256) {\n        int256 priceImpactUsd = PositionPricingUtils.getPriceImpactUsd(\n            PositionPricingUtils.GetPriceImpactUsdParams(\n                params.contracts.dataStore,\n                params.market.marketToken,\n                params.market.indexToken,\n                params.market.longToken,\n                params.market.shortToken,\n                -sizeDeltaUsd.toInt256(),\n                params.order.isLong()\n            )\n        );\n\n        priceImpactUsd = MarketUtils.getCappedPositionImpactUsd(\n            params.contracts.dataStore,\n            params.market.marketToken,\n            prices.indexTokenPrice,\n            priceImp"
    }
  ]
}