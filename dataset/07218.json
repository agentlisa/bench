{
  "Title": "[M-01] Battery discharge mechanism doesnâ€™t work correctly for first redemption",
  "Content": "# Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/libraries/RedemptionBattery.sol#L59-L70\n\n\n# Vulnerability details\n\n## Impact\nThe `RTokenP1` contract implements a throttling mechanism using the `RedemptionBatteryLib` library. The library models a \"battery\" which \"recharges\" linearly block by block, over roughly 1 hour.\n\nRToken.sol\n```solidity\n    function redeem(uint256 amount) external notFrozen {\n        // ...\n\n        uint256 supply = totalSupply();\n\n        // ...\n        battery.discharge(supply, amount); // reverts on over-redemption\n\n        // ...\n    }\n```\nRedemptionBatteryLib.sol\n```solidity\n    function discharge(\n        Battery storage battery,\n        uint256 supply,\n        uint256 amount\n    ) internal {\n        if (battery.redemptionRateFloor == 0 && battery.scalingRedemptionRate == 0) return;\n\n        // {qRTok}\n        uint256 charge = currentCharge(battery, supply);\n\n        // A nice error message so people aren't confused why redemption failed\n        require(amount <= charge, \"redemption battery insufficient\");\n\n        // Update battery\n        battery.lastBlock = uint48(block.number);\n        battery.lastCharge = charge - amount;\n    }\n\n    /// @param supply {qRTok} Total RToken supply before the burn step\n    /// @return charge {qRTok} The current total charge as an amount of RToken\n    function currentCharge(Battery storage battery, uint256 supply)\n        internal\n        view\n        returns (uint256 charge)\n    {\n        // {qRTok/hour} = {qRTok} * D18{1/hour} / D18\n        uint256 amtPerHour = (supply * battery.scalingRedemptionRate) / FIX_ONE_256;\n\n        if (battery.redemptionRateFloor > amtPerHour) amtPerHour = battery.redemptionRateFloor;\n\n        // {blocks}\n        uint48 blocks = uint48(block.number) - battery.lastBlock; \n\n        // {qRTok} = {qRTok} + {qRTok/hour} * {blocks} / {blocks/hour}\n        charge = battery.lastCharge + (amtPerHour * blocks) / BLOCKS_PER_HOUR;\n\n        uint256 maxCharge = amtPerHour > supply ? supply : amtPerHour;\n        if (charge > maxCharge) charge = maxCharge;\n    }\n```\nThe linear redemption limit is calculated in the `currentCharge` function. This function calculates the delta blocks by `uint48 blocks = uint48(block.number) - battery.lastBlock;`.\n\nThe bug here is that the `lastBlock` value is never initialized by the `RTokenP1` contract so its value defaults to `0`. This results in incorrect delta blocks value as the delta blocks comes out to be an incorrectly large value\n```\n        blocks = current block number - 0 = current block number\n```\n\nDue do this issue, the `currentCharge` value comes out to be way larger than the actual intended value for the first RToken redemption. The `maxCharge` cap at the end of `currentCharge` function caps the result to the current total supply of RToken. \n\nThe issue results in an instant first RToken redemption for the full `totalSupply` of the RToken. The battery discharging mechanism is completely neglected.\n\nIt should be noted that the issue only exists for the first ever redemption as during the first redemption the `lastBlock` value gets updated with current block number.  \n\n\n## Proof of Concept\nThe following test case was added to `test/RToken.test.ts` file and was ran using command `PROTO_IMPL=1 npx hardhat test ./test/RToken.test.ts`.\n\n```typescript\n  describe.only('Battery lastBlock bug', () => {\n    it('redemption battery does not work on first redemption', async () => {\n      // real chain scenario\n      await advanceBlocks(1_000_000)\n      await Promise.all(tokens.map((t) => t.connect(addr1).approve(rToken.address, ethers.constants.MaxUint256)))\n\n      expect(await rToken.totalSupply()).to.eq(0)\n      await rToken.connect(owner).setRedemptionRateFloor(fp('1e4'))\n      await rToken.connect(owner).setScalingRedemptionRate(fp('0'))\n\n      // first issue\n      const issueAmount = fp('10000')\n      await rToken.connect(addr1)['issue(uint256)'](issueAmount)\n      expect(await rToken.balanceOf(addr1.address)).to.eq(issueAmount)\n      expect(await rToken.totalSupply()).to.eq(issueAmount)\n\n      // first redemption\n      expect(await rToken.redemptionLimit()).to.eq(await rToken.totalSupply())    // for first redemption the currentCharge value is capped by rToken.totalSupply() \n      await rToken.connect(addr1).redeem(issueAmount)\n      expect(await rToken.totalSupply()).to.eq(0)\n\n      // second redemption\n      await rToken.connect(addr1)['issue(uint256)'](issueAmount)\n      expect(await rToken.balanceOf(addr1.address)).to.eq(issueAmount)\n      // from second redemtion onwards the battery discharge mechanism takes place correctly\n      await expect(rToken.connect(addr1).redeem(issueAmount)).to.be.revertedWith('redemption battery insufficient')\n    })\n  })\n```\n\n## Tools Used\nHardhat\n\n## Recommended Mitigation Steps\nThe `battery.lastBlock` value must be initialized in the `init` function of `RTokenP1`\n```solidity\n    function init(\n        // ...\n    ) external initializer {\n        // ...\n        battery.lastBlock = uint48(block.number);\n    }\n``` ",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-reserve-contest",
  "Code": [
    {
      "filename": "contracts/libraries/RedemptionBattery.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"../interfaces/IRToken.sol\";\nimport \"./Fixed.sol\";\n\n// NOTE: This algorithm assumes the contract is running on PoS Ethereum and 100% of the\n// network is online. It is possible for the battery to recharge up to 2/3 as fast\n// depending on validator participation levels. Below 2/3 the chain halts, in which case\n// the battery stops charging completely.\nuint48 constant BLOCKS_PER_HOUR = 300; // {blocks/hour}\n\n/// Throttling mechanism:\n/// Models a \"battery\" which \"recharges\" linearly block by block, over roughly 1 hour.\n/// Calls to discharge() will revert if the battery doesn't have enough \"charge\".\n/// @dev This implementation basically assumes that maxCapacity is always the same value.\n///      It won't misbehave badly if maxCapacity is changed, but it doesn't have sharply-defined\n///      behavior in that case. (But keeping maxCapacity outside storage saves SLOADs)\nlibrary RedemptionBatteryLib {\n    using FixLib for uint192;\n\n    struct Battery {\n        uint256 redemptionRateFloor; // {qRTok/hour} the floor of the battery charging rate\n        uint192 scalingRedemptionRate; // {1/hour} charging rate as a fraction of supply\n        // for either: set to 0 to disable\n        // ===\n        uint48 lastBlock; // {blocks}\n        uint256 lastCharge; // {qRTok}\n    }\n\n    /// @param supply {qRTok} Total RToken supply before redemption\n    /// @param amount {qRTok} Amount of RToken being redeemed\n    function discharge(\n        Battery storage battery,\n        uint256 supply,\n        uint256 amount\n    ) internal {\n        if (battery.redemptionRateFloor == 0 && battery.scalingRedemptionRate == 0) return;\n\n        // {qRTok}\n        uint256 charge = currentCharge(battery, supply);\n\n        // A nice error message so people aren't confused why redemption failed\n        require(amount <= charge, \"redemption battery insufficient\");\n\n        // Update battery\n        battery.lastBlock = uint48(block.number);\n        battery.lastCharge = charge - amount;\n    }\n\n    /// @param supply {qRTok} Total RToken supply before the burn step\n    /// @return charge {qRTok} The current total charge as an amount of RToken\n    function currentCharge(Battery storage battery, uint256 supply)\n        internal\n        view\n        returns (uint256 charge)\n    {\n        // {qRTok/hour} = {qRTok} * D18{1/hour} / D18\n        uint256 amtPerHour = (supply * battery.scalingRedemptionRate) / FIX_ONE_256;\n\n        if (battery.redemptionRateFloor > amtPerHour) amtPerHour = battery.redemptionRateFloor;\n\n        // {blocks}\n        uint48 blocks = uint48(block.number) - battery.lastBlock;\n\n        // {qRTok} = {qRTok} + {qRTok/hour} * {blocks} / {blocks/hour}\n        charge = battery.lastCharge + (amtPerHour * blocks) / BLOCKS_PER_HOUR;\n\n        uint256 maxCharge = amtPerHour > supply ? supply : amtPerHour;\n        if (charge > maxCharge) charge = maxCharge;\n    }\n}"
    }
  ]
}