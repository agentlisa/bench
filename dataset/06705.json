{
  "Title": "[G-01] Refactor code to avoid unnecessary memory expansion and data check within loops",
  "Content": "In the instances below, the proof name is being read from memory and then stored into a new section of memory. After this is done an `if` statement is used to check a condition. Both the proof name and condition in the `if` statement stay the same for each iteration, and therefore those lines of code can be moved outside of the loop to avoid doing those computations on each iteration.\n\nTotal Instances: `2`\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L254-L264\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 3270 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  298194  |  336129  |  317162 |    2     |\n\n```solidity\nFile: contracts/dnsssec-oracle/DNSSECImpl.sol\n254:    function verifyWithKnownKey(\n255:        RRUtils.SignedSet memory rrset,\n256:        RRSetWithSignature memory data,\n257:        RRUtils.RRIterator memory proof\n258:    ) internal view {\n259:        // Check the DNSKEY's owner name matches the signer name on the RRSIG\n260:        for (; !proof.done(); proof.next()) {\n261:            bytes memory proofName = proof.name();\n262:            if (!proofName.equals(rrset.signerName)) {\n263:                revert ProofNameMismatch(rrset.signerName, proofName);\n264:            }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..f8adb3c 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -257,11 +257,11 @@ contract DNSSECImpl is DNSSEC, Owned {\n         RRUtils.RRIterator memory proof\n     ) internal view {\n         // Check the DNSKEY's owner name matches the signer name on the RRSIG\n+        bytes memory proofName = proof.name();\n+        if (!proofName.equals(rrset.signerName)) {\n+            revert ProofNameMismatch(rrset.signerName, proofName);\n+        }\n         for (; !proof.done(); proof.next()) {\n-            bytes memory proofName = proof.name();\n-            if (!proofName.equals(rrset.signerName)) {\n-                revert ProofNameMismatch(rrset.signerName, proofName);\n-            }\n\n             bytes memory keyrdata = proof.rdata();\n             RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L373-L384\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 3223 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  298241  |  336176  |  317209 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/DNSSECImpl.sol\n373:    function verifyKeyWithDS(\n374:        bytes memory keyname,\n375:        RRUtils.RRIterator memory dsrrs,\n376:        RRUtils.DNSKEY memory dnskey,\n377:        bytes memory keyrdata\n378:    ) internal view returns (bool) {\n379:        uint16 keytag = keyrdata.computeKeytag();\n380:        for (; !dsrrs.done(); dsrrs.next()) {\n381:            bytes memory proofName = dsrrs.name();\n382:            if (!proofName.equals(keyname)) {\n383:                revert ProofNameMismatch(keyname, proofName);\n384:            }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..ae9ba6a 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -377,11 +377,11 @@ contract DNSSECImpl is DNSSEC, Owned {\n         bytes memory keyrdata\n     ) internal view returns (bool) {\n         uint16 keytag = keyrdata.computeKeytag();\n+        bytes memory proofName = dsrrs.name();\n+        if (!proofName.equals(keyname)) {\n+            revert ProofNameMismatch(keyname, proofName);\n+        }\n         for (; !dsrrs.done(); dsrrs.next()) {\n-            bytes memory proofName = dsrrs.name();\n-            if (!proofName.equals(keyname)) {\n-                revert ProofNameMismatch(keyname, proofName);\n-            }\n\n             RRUtils.DS memory ds = dsrrs.data.readDS(\n                 dsrrs.rdataOffset,\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-04-ens",
  "Code": [
    {
      "filename": "contracts/dnssec-oracle/DNSSECImpl.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\nimport \"./Owned.sol\";\nimport \"./BytesUtils.sol\";\nimport \"./RRUtils.sol\";\nimport \"./DNSSEC.sol\";\nimport \"./algorithms/Algorithm.sol\";\nimport \"./digests/Digest.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/*\n * @dev An oracle contract that verifies and stores DNSSEC-validated DNS records.\n * @note This differs from the DNSSEC spec defined in RFC4034 and RFC4035 in some key regards:\n *       - NSEC & NSEC3 are not supported; only positive proofs are allowed.\n *       - Proofs involving wildcard names will not validate.\n *       - TTLs on records are ignored, as data is not stored persistently.\n *       - Canonical form of names is not checked; in ENS this is done on the frontend, so submitting\n *         proofs with non-canonical names will only result in registering unresolvable ENS names.\n */\ncontract DNSSECImpl is DNSSEC, Owned {\n    using Buffer for Buffer.buffer;\n    using BytesUtils for bytes;\n    using RRUtils for *;\n\n    uint16 constant DNSCLASS_IN = 1;\n\n    uint16 constant DNSTYPE_DS = 43;\n    uint16 constant DNSTYPE_DNSKEY = 48;\n\n    uint256 constant DNSKEY_FLAG_ZONEKEY = 0x100;\n\n    error InvalidLabelCount(bytes name, uint256 labelsExpected);\n    error SignatureNotValidYet(uint32 inception, uint32 now);\n    error SignatureExpired(uint32 expiration, uint32 now);\n    error InvalidClass(uint16 class);\n    error InvalidRRSet();\n    error SignatureTypeMismatch(uint16 rrsetType, uint16 sigType);\n    error InvalidSignerName(bytes rrsetName, bytes signerName);\n    error InvalidProofType(uint16 proofType);\n    error ProofNameMismatch(bytes signerName, bytes proofName);\n    error NoMatchingProof(bytes signerName);\n\n    mapping(uint8 => Algorithm) public algorithms;\n    mapping(uint8 => Digest) public digests;\n\n    /**\n     * @dev Constructor.\n     * @param _anchors The binary format RR entries for the root DS records.\n     */\n    constructor(bytes memory _anchors) {\n        // Insert the 'trust anchors' - the key hashes that start the chain\n        // of trust for all other records.\n        anchors = _anchors;\n    }\n\n    /**\n     * @dev Sets the contract address for a signature verification algorithm.\n     *      Callable only by the owner.\n     * @param id The algorithm ID\n     * @param algo The address of the algorithm contract.\n     */\n    function setAlgorithm(uint8 id, Algorithm algo) public owner_only {\n        algorithms[id] = algo;\n        emit AlgorithmUpdated(id, address(algo));\n    }\n\n    /**\n     * @dev Sets the contract address for a digest verification algorithm.\n     *      Callable only by the owner.\n     * @param id The digest ID\n     * @param digest The address of the digest contract.\n     */\n    function setDigest(uint8 id, Digest digest) public owner_only {\n        digests[id] = digest;\n        emit DigestUpdated(id, address(digest));\n    }\n\n    /**\n     * @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\n     *      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\n     * @param input A list of signed RRSets.\n     * @return rrs The RRData from the last RRSet in the chain.\n     * @return inception The inception time of the signed record set.\n     */\n    function verifyRRSet(\n        RRSetWithSignature[] memory input\n    )\n        external\n        view\n        virtual\n        override\n        returns (bytes memory rrs, uint32 inception)\n    {\n        return verifyRRSet(input, block.timestamp);\n    }\n\n    /**\n     * @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\n     *      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\n     * @param input A list of signed RRSets.\n     * @param now The Unix timestamp to validate the records at.\n     * @return rrs The RRData from the last RRSet in the chain.\n     * @return inception The inception time of the signed record set.\n     */\n    function verifyRRSet(\n        RRSetWithSignature[] memory input,\n        uint256 now\n    )\n        public\n        view\n        virtual\n        override\n        returns (bytes memory rrs, uint32 inception)\n    {\n        bytes memory proof = anchors;\n        for (uint256 i = 0; i < input.length; i++) {\n            RRUtils.SignedSet memory rrset = validateSignedSet(\n                input[i],\n                proof,\n                now\n            );\n            proof = rrset.data;\n            inception = rrset.inception;\n        }\n        return (proof, inception);\n    }\n\n    /**\n     * @dev Validates an RRSet against the already trusted RR provided in `proof`.\n     *\n     * @param input The signed RR set. This is in the format described in section\n     *        5.3.2 of RFC4035: The RRDATA section from the RRSIG without the signature\n     *        data, followed by a series of canonicalised RR records that the signature\n     *        applies to.\n     * @param proof The DNSKEY or DS to validate the signature against.\n     * @param now The current timestamp.\n     */\n    function validateSignedSet(\n        RRSetWithSignature memory input,\n        bytes memory proof,\n        uint256 now\n    ) internal view returns (RRUtils.SignedSet memory rrset) {\n        rrset = input.rrset.readSignedSet();\n\n        // Do some basic checks on the RRs and extract the name\n        bytes memory name = validateRRs(rrset, rrset.typeCovered);\n        if (name.labelCount(0) != rrset.labels) {\n            revert InvalidLabelCount(name, rrset.labels);\n        }\n        rrset.name = name;\n\n        // All comparisons involving the Signature Expiration and\n        // Inception fields MUST use \"serial number arithmetic\", as\n        // defined in RFC 1982\n\n        // o  The validator's notion of the current time MUST be less than or\n        //    equal to the time listed in the RRSIG RR's Expiration field.\n        if (!RRUtils.serialNumberGte(rrset.expiration, uint32(now))) {\n            revert SignatureExpired(rrset.expiration, uint32(now));\n        }\n\n        // o  The validator's notion of the current time MUST be greater than or\n        //    equal to the time listed in the RRSIG RR's Inception field.\n        if (!RRUtils.serialNumberGte(uint32(now), rrset.inception)) {\n            revert SignatureNotValidYet(rrset.inception, uint32(now));\n        }\n\n        // Validate the signature\n        verifySignature(name, rrset, input, proof);\n\n        return rrset;\n    }\n\n    /**\n     * @dev Validates a set of RRs.\n     * @param rrset The RR set.\n     * @param typecovered The type covered by the RRSIG record.\n     */\n    function validateRRs(\n        RRUtils.SignedSet memory rrset,\n        uint16 typecovered\n    ) internal pure returns (bytes memory name) {\n        // Iterate over all the RRs\n        for (\n            RRUtils.RRIterator memory iter = rrset.rrs();\n            !iter.done();\n            iter.next()\n        ) {\n            // We only support class IN (Internet)\n            if (iter.class != DNSCLASS_IN) {\n                revert InvalidClass(iter.class);\n            }\n\n            if (name.length == 0) {\n                name = iter.name();\n            } else {\n                // Name must be the same on all RRs. We do things this way to avoid copying the name\n                // repeatedly.\n                if (\n                    name.length != iter.data.nameLength(iter.offset) ||\n                    !name.equals(0, iter.data, iter.offset, name.length)\n                ) {\n                    revert InvalidRRSet();\n                }\n            }\n\n            // o  The RRSIG RR's Type Covered field MUST equal the RRset's type.\n            if (iter.dnstype != typecovered) {\n                revert SignatureTypeMismatch(iter.dnstype, typecovered);\n            }\n        }\n    }\n\n    /**\n     * @dev Performs signature verification.\n     *\n     * Throws or reverts if unable to verify the record.\n     *\n     * @param name The name of the RRSIG record, in DNS label-sequence format.\n     * @param data The original data to verify.\n     * @param proof A DS or DNSKEY record that's already verified by the oracle.\n     */\n    function verifySignature(\n        bytes memory name,\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        bytes memory proof\n    ) internal view {\n        // o  The RRSIG RR's Signer's Name field MUST be the name of the zone\n        //    that contains the RRset.\n        if (!name.isSubdomainOf(rrset.signerName)) {\n            revert InvalidSignerName(name, rrset.signerName);\n        }\n\n        RRUtils.RRIterator memory proofRR = proof.iterateRRs(0);\n        // Check the proof\n        if (proofRR.dnstype == DNSTYPE_DS) {\n            verifyWithDS(rrset, data, proofRR);\n        } else if (proofRR.dnstype == DNSTYPE_DNSKEY) {\n            verifyWithKnownKey(rrset, data, proofRR);\n        } else {\n            revert InvalidProofType(proofRR.dnstype);\n        }\n    }\n\n    /**\n     * @dev Attempts to verify a signed RRSET against an already known public key.\n     * @param rrset The signed set to verify.\n     * @param data The original data the signed set was read from.\n     * @param proof The serialized DS or DNSKEY record to use as proof.\n     */\n    function verifyWithKnownKey(\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        RRUtils.RRIterator memory proof\n    ) internal view {\n        // Check the DNSKEY's owner name matches the signer name on the RRSIG\n        for (; !proof.done(); proof.next()) {\n            bytes memory proofName = proof.name();\n            if (!proofName.equals(rrset.signerName)) {\n                revert ProofNameMismatch(rrset.signerName, proofName);\n            }\n\n            bytes memory keyrdata = proof.rdata();\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n                0,\n                keyrdata.length\n            );\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                return;\n            }\n        }\n        revert NoMatchingProof(rrset.signerName);\n    }\n\n    /**\n     * @dev Attempts to verify some data using a provided key and a signature.\n     * @param dnskey The dns key record to verify the signature with.\n     * @param rrset The signed RRSET being verified.\n     * @param data The original data `rrset` was decoded from.\n     * @return True iff the key verifies the signature.\n     */\n    function verifySignatureWithKey(\n        RRUtils.DNSKEY memory dnskey,\n        bytes memory keyrdata,\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data\n    ) internal view returns (bool) {\n        // TODO: Check key isn't expired, unless updating key itself\n\n        // The Protocol Field MUST have value 3 (RFC4034 2.1.2)\n        if (dnskey.protocol != 3) {\n            return false;\n        }\n\n        // o The RRSIG RR's Signer's Name, Algorithm, and Key Tag fields MUST\n        //   match the owner name, algorithm, and key tag for some DNSKEY RR in\n        //   the zone's apex DNSKEY RRset.\n        if (dnskey.algorithm != rrset.algorithm) {\n            return false;\n        }\n        uint16 computedkeytag = keyrdata.computeKeytag();\n        if (computedkeytag != rrset.keytag) {\n            return false;\n        }\n\n        // o The matching DNSKEY RR MUST be present in the zone's apex DNSKEY\n        //   RRset, and MUST have the Zone Flag bit (DNSKEY RDATA Flag bit 7)\n        //   set.\n        if (dnskey.flags & DNSKEY_FLAG_ZONEKEY == 0) {\n            return false;\n        }\n\n        Algorithm algorithm = algorithms[dnskey.algorithm];\n        if (address(algorithm) == address(0)) {\n            return false;\n        }\n        return algorithm.verify(keyrdata, data.rrset, data.sig);\n    }\n\n    /**\n     * @dev Attempts to verify a signed RRSET against an already known hash. This function assumes\n     *      that the record\n     * @param rrset The signed set to verify.\n     * @param data The original data the signed set was read from.\n     * @param proof The serialized DS or DNSKEY record to use as proof.\n     */\n    function verifyWithDS(\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        RRUtils.RRIterator memory proof\n    ) internal view {\n        uint256 proofOffset = proof.offset;\n        for (\n            RRUtils.RRIterator memory iter = rrset.rrs();\n            !iter.done();\n            iter.next()\n        ) {\n            if (iter.dnstype != DNSTYPE_DNSKEY) {\n                revert InvalidProofType(iter.dnstype);\n            }\n\n            bytes memory keyrdata = iter.rdata();\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n                0,\n                keyrdata.length\n            );\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                // It's self-signed - look for a DS record to verify it.\n                if (\n                    verifyKeyWithDS(rrset.signerName, proof, dnskey, keyrdata)\n                ) {\n                    return;\n                }\n                // Rewind proof iterator to the start for the next loop iteration.\n                proof.nextOffset = proofOffset;\n                proof.next();\n            }\n        }\n        revert NoMatchingProof(rrset.signerName);\n    }\n\n    /**\n     * @dev Attempts to verify a key using DS records.\n     * @param keyname The DNS name of the key, in DNS label-sequence format.\n     * @param dsrrs The DS records to use in verification.\n     * @param dnskey The dnskey to verify.\n     * @param keyrdata The RDATA section of the key.\n     * @return True if a DS record verifies this key.\n     */\n    function verifyKeyWithDS(\n        bytes memory keyname,\n        RRUtils.RRIterator memory dsrrs,\n        RRUtils.DNSKEY memory dnskey,\n        bytes memory keyrdata\n    ) internal view returns (bool) {\n        uint16 keytag = keyrdata.computeKeytag();\n        for (; !dsrrs.done(); dsrrs.next()) {\n            bytes memory proofName = dsrrs.name();\n            if (!proofName.equals(keyname)) {\n                revert ProofNameMismatch(keyname, proofName);\n            }\n\n            RRUtils.DS memory ds = dsrrs.data.readDS(\n                dsrrs.rdataOffset,\n                dsrrs.nextOffset - dsrrs.rdataOffset\n            );\n            if (ds.keytag != keytag) {\n                continue;\n            }\n            if (ds.algorithm != dnskey.algorithm) {\n                continue;\n            }\n\n            Buffer.buffer memory buf;\n            buf.init(keyname.length + keyrdata.length);\n            buf.append(keyname);\n            buf.append(keyrdata);\n            if (verifyDSHash(ds.digestType, buf.buf, ds.digest)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Attempts to verify a DS record's hash value against some data.\n     * @param digesttype The digest ID from the DS record.\n     * @param data The data to digest.\n     * @param digest The digest data to check against.\n     * @return True iff the digest matches.\n     */\n    function verifyDSHash(\n        uint8 digesttype,\n        bytes memory data,\n        bytes memory digest\n    ) internal view returns (bool) {\n        if (address(digests[digesttype]) == address(0)) {\n            return false;\n        }\n        return digests[digesttype].verify(data, digest);\n    }\n}"
    },
    {
      "filename": "contracts/dnssec-oracle/DNSSECImpl.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\nimport \"./Owned.sol\";\nimport \"./BytesUtils.sol\";\nimport \"./RRUtils.sol\";\nimport \"./DNSSEC.sol\";\nimport \"./algorithms/Algorithm.sol\";\nimport \"./digests/Digest.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/*\n * @dev An oracle contract that verifies and stores DNSSEC-validated DNS records.\n * @note This differs from the DNSSEC spec defined in RFC4034 and RFC4035 in some key regards:\n *       - NSEC & NSEC3 are not supported; only positive proofs are allowed.\n *       - Proofs involving wildcard names will not validate.\n *       - TTLs on records are ignored, as data is not stored persistently.\n *       - Canonical form of names is not checked; in ENS this is done on the frontend, so submitting\n *         proofs with non-canonical names will only result in registering unresolvable ENS names.\n */\ncontract DNSSECImpl is DNSSEC, Owned {\n    using Buffer for Buffer.buffer;\n    using BytesUtils for bytes;\n    using RRUtils for *;\n\n    uint16 constant DNSCLASS_IN = 1;\n\n    uint16 constant DNSTYPE_DS = 43;\n    uint16 constant DNSTYPE_DNSKEY = 48;\n\n    uint256 constant DNSKEY_FLAG_ZONEKEY = 0x100;\n\n    error InvalidLabelCount(bytes name, uint256 labelsExpected);\n    error SignatureNotValidYet(uint32 inception, uint32 now);\n    error SignatureExpired(uint32 expiration, uint32 now);\n    error InvalidClass(uint16 class);\n    error InvalidRRSet();\n    error SignatureTypeMismatch(uint16 rrsetType, uint16 sigType);\n    error InvalidSignerName(bytes rrsetName, bytes signerName);\n    error InvalidProofType(uint16 proofType);\n    error ProofNameMismatch(bytes signerName, bytes proofName);\n    error NoMatchingProof(bytes signerName);\n\n    mapping(uint8 => Algorithm) public algorithms;\n    mapping(uint8 => Digest) public digests;\n\n    /**\n     * @dev Constructor.\n     * @param _anchors The binary format RR entries for the root DS records.\n     */\n    constructor(bytes memory _anchors) {\n        // Insert the 'trust anchors' - the key hashes that start the chain\n        // of trust for all other records.\n        anchors = _anchors;\n    }\n\n    /**\n     * @dev Sets the contract address for a signature verification algorithm.\n     *      Callable only by the owner.\n     * @param id The algorithm ID\n     * @param algo The address of the algorithm contract.\n     */\n    function setAlgorithm(uint8 id, Algorithm algo) public owner_only {\n        algorithms[id] = algo;\n        emit AlgorithmUpdated(id, address(algo));\n    }\n\n    /**\n     * @dev Sets the contract address for a digest verification algorithm.\n     *      Callable only by the owner.\n     * @param id The digest ID\n     * @param digest The address of the digest contract.\n     */\n    function setDigest(uint8 id, Digest digest) public owner_only {\n        digests[id] = digest;\n        emit DigestUpdated(id, address(digest));\n    }\n\n    /**\n     * @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\n     *      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\n     * @param input A list of signed RRSets.\n     * @return rrs The RRData from the last RRSet in the chain.\n     * @return inception The inception time of the signed record set.\n     */\n    function verifyRRSet(\n        RRSetWithSignature[] memory input\n    )\n        external\n        view\n        virtual\n        override\n        returns (bytes memory rrs, uint32 inception)\n    {\n        return verifyRRSet(input, block.timestamp);\n    }\n\n    /**\n     * @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\n     *      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\n     * @param input A list of signed RRSets.\n     * @param now The Unix timestamp to validate the records at.\n     * @return rrs The RRData from the last RRSet in the chain.\n     * @return inception The inception time of the signed record set.\n     */\n    function verifyRRSet(\n        RRSetWithSignature[] memory input,\n        uint256 now\n    )\n        public\n        view\n        virtual\n        override\n        returns (bytes memory rrs, uint32 inception)\n    {\n        bytes memory proof = anchors;\n        for (uint256 i = 0; i < input.length; i++) {\n            RRUtils.SignedSet memory rrset = validateSignedSet(\n                input[i],\n                proof,\n                now\n            );\n            proof = rrset.data;\n            inception = rrset.inception;\n        }\n        return (proof, inception);\n    }\n\n    /**\n     * @dev Validates an RRSet against the already trusted RR provided in `proof`.\n     *\n     * @param input The signed RR set. This is in the format described in section\n     *        5.3.2 of RFC4035: The RRDATA section from the RRSIG without the signature\n     *        data, followed by a series of canonicalised RR records that the signature\n     *        applies to.\n     * @param proof The DNSKEY or DS to validate the signature against.\n     * @param now The current timestamp.\n     */\n    function validateSignedSet(\n        RRSetWithSignature memory input,\n        bytes memory proof,\n        uint256 now\n    ) internal view returns (RRUtils.SignedSet memory rrset) {\n        rrset = input.rrset.readSignedSet();\n\n        // Do some basic checks on the RRs and extract the name\n        bytes memory name = validateRRs(rrset, rrset.typeCovered);\n        if (name.labelCount(0) != rrset.labels) {\n            revert InvalidLabelCount(name, rrset.labels);\n        }\n        rrset.name = name;\n\n        // All comparisons involving the Signature Expiration and\n        // Inception fields MUST use \"serial number arithmetic\", as\n        // defined in RFC 1982\n\n        // o  The validator's notion of the current time MUST be less than or\n        //    equal to the time listed in the RRSIG RR's Expiration field.\n        if (!RRUtils.serialNumberGte(rrset.expiration, uint32(now))) {\n            revert SignatureExpired(rrset.expiration, uint32(now));\n        }\n\n        // o  The validator's notion of the current time MUST be greater than or\n        //    equal to the time listed in the RRSIG RR's Inception field.\n        if (!RRUtils.serialNumberGte(uint32(now), rrset.inception)) {\n            revert SignatureNotValidYet(rrset.inception, uint32(now));\n        }\n\n        // Validate the signature\n        verifySignature(name, rrset, input, proof);\n\n        return rrset;\n    }\n\n    /**\n     * @dev Validates a set of RRs.\n     * @param rrset The RR set.\n     * @param typecovered The type covered by the RRSIG record.\n     */\n    function validateRRs(\n        RRUtils.SignedSet memory rrset,\n        uint16 typecovered\n    ) internal pure returns (bytes memory name) {\n        // Iterate over all the RRs\n        for (\n            RRUtils.RRIterator memory iter = rrset.rrs();\n            !iter.done();\n            iter.next()\n        ) {\n            // We only support class IN (Internet)\n            if (iter.class != DNSCLASS_IN) {\n                revert InvalidClass(iter.class);\n            }\n\n            if (name.length == 0) {\n                name = iter.name();\n            } else {\n                // Name must be the same on all RRs. We do things this way to avoid copying the name\n                // repeatedly.\n                if (\n                    name.length != iter.data.nameLength(iter.offset) ||\n                    !name.equals(0, iter.data, iter.offset, name.length)\n                ) {\n                    revert InvalidRRSet();\n                }\n            }\n\n            // o  The RRSIG RR's Type Covered field MUST equal the RRset's type.\n            if (iter.dnstype != typecovered) {\n                revert SignatureTypeMismatch(iter.dnstype, typecovered);\n            }\n        }\n    }\n\n    /**\n     * @dev Performs signature verification.\n     *\n     * Throws or reverts if unable to verify the record.\n     *\n     * @param name The name of the RRSIG record, in DNS label-sequence format.\n     * @param data The original data to verify.\n     * @param proof A DS or DNSKEY record that's already verified by the oracle.\n     */\n    function verifySignature(\n        bytes memory name,\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        bytes memory proof\n    ) internal view {\n        // o  The RRSIG RR's Signer's Name field MUST be the name of the zone\n        //    that contains the RRset.\n        if (!name.isSubdomainOf(rrset.signerName)) {\n            revert InvalidSignerName(name, rrset.signerName);\n        }\n\n        RRUtils.RRIterator memory proofRR = proof.iterateRRs(0);\n        // Check the proof\n        if (proofRR.dnstype == DNSTYPE_DS) {\n            verifyWithDS(rrset, data, proofRR);\n        } else if (proofRR.dnstype == DNSTYPE_DNSKEY) {\n            verifyWithKnownKey(rrset, data, proofRR);\n        } else {\n            revert InvalidProofType(proofRR.dnstype);\n        }\n    }\n\n    /**\n     * @dev Attempts to verify a signed RRSET against an already known public key.\n     * @param rrset The signed set to verify.\n     * @param data The original data the signed set was read from.\n     * @param proof The serialized DS or DNSKEY record to use as proof.\n     */\n    function verifyWithKnownKey(\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        RRUtils.RRIterator memory proof\n    ) internal view {\n        // Check the DNSKEY's owner name matches the signer name on the RRSIG\n        for (; !proof.done(); proof.next()) {\n            bytes memory proofName = proof.name();\n            if (!proofName.equals(rrset.signerName)) {\n                revert ProofNameMismatch(rrset.signerName, proofName);\n            }\n\n            bytes memory keyrdata = proof.rdata();\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n                0,\n                keyrdata.length\n            );\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                return;\n            }\n        }\n        revert NoMatchingProof(rrset.signerName);\n    }\n\n    /**\n     * @dev Attempts to verify some data using a provided key and a signature.\n     * @param dnskey The dns key record to verify the signature with.\n     * @param rrset The signed RRSET being verified.\n     * @param data The original data `rrset` was decoded from.\n     * @return True iff the key verifies the signature.\n     */\n    function verifySignatureWithKey(\n        RRUtils.DNSKEY memory dnskey,\n        bytes memory keyrdata,\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data\n    ) internal view returns (bool) {\n        // TODO: Check key isn't expired, unless updating key itself\n\n        // The Protocol Field MUST have value 3 (RFC4034 2.1.2)\n        if (dnskey.protocol != 3) {\n            return false;\n        }\n\n        // o The RRSIG RR's Signer's Name, Algorithm, and Key Tag fields MUST\n        //   match the owner name, algorithm, and key tag for some DNSKEY RR in\n        //   the zone's apex DNSKEY RRset.\n        if (dnskey.algorithm != rrset.algorithm) {\n            return false;\n        }\n        uint16 computedkeytag = keyrdata.computeKeytag();\n        if (computedkeytag != rrset.keytag) {\n            return false;\n        }\n\n        // o The matching DNSKEY RR MUST be present in the zone's apex DNSKEY\n        //   RRset, and MUST have the Zone Flag bit (DNSKEY RDATA Flag bit 7)\n        //   set.\n        if (dnskey.flags & DNSKEY_FLAG_ZONEKEY == 0) {\n            return false;\n        }\n\n        Algorithm algorithm = algorithms[dnskey.algorithm];\n        if (address(algorithm) == address(0)) {\n            return false;\n        }\n        return algorithm.verify(keyrdata, data.rrset, data.sig);\n    }\n\n    /**\n     * @dev Attempts to verify a signed RRSET against an already known hash. This function assumes\n     *      that the record\n     * @param rrset The signed set to verify.\n     * @param data The original data the signed set was read from.\n     * @param proof The serialized DS or DNSKEY record to use as proof.\n     */\n    function verifyWithDS(\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        RRUtils.RRIterator memory proof\n    ) internal view {\n        uint256 proofOffset = proof.offset;\n        for (\n            RRUtils.RRIterator memory iter = rrset.rrs();\n            !iter.done();\n            iter.next()\n        ) {\n            if (iter.dnstype != DNSTYPE_DNSKEY) {\n                revert InvalidProofType(iter.dnstype);\n            }\n\n            bytes memory keyrdata = iter.rdata();\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n                0,\n                keyrdata.length\n            );\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                // It's self-signed - look for a DS record to verify it.\n                if (\n                    verifyKeyWithDS(rrset.signerName, proof, dnskey, keyrdata)\n                ) {\n                    return;\n                }\n                // Rewind proof iterator to the start for the next loop iteration.\n                proof.nextOffset = proofOffset;\n                proof.next();\n            }\n        }\n        revert NoMatchingProof(rrset.signerName);\n    }\n\n    /**\n     * @dev Attempts to verify a key using DS records.\n     * @param keyname The DNS name of the key, in DNS label-sequence format.\n     * @param dsrrs The DS records to use in verification.\n     * @param dnskey The dnskey to verify.\n     * @param keyrdata The RDATA section of the key.\n     * @return True if a DS record verifies this key.\n     */\n    function verifyKeyWithDS(\n        bytes memory keyname,\n        RRUtils.RRIterator memory dsrrs,\n        RRUtils.DNSKEY memory dnskey,\n        bytes memory keyrdata\n    ) internal view returns (bool) {\n        uint16 keytag = keyrdata.computeKeytag();\n        for (; !dsrrs.done(); dsrrs.next()) {\n            bytes memory proofName = dsrrs.name();\n            if (!proofName.equals(keyname)) {\n                revert ProofNameMismatch(keyname, proofName);\n            }\n\n            RRUtils.DS memory ds = dsrrs.data.readDS(\n                dsrrs.rdataOffset,\n                dsrrs.nextOffset - dsrrs.rdataOffset\n            );\n            if (ds.keytag != keytag) {\n                continue;\n            }\n            if (ds.algorithm != dnskey.algorithm) {\n                continue;\n            }\n\n            Buffer.buffer memory buf;\n            buf.init(keyname.length + keyrdata.length);\n            buf.append(keyname);\n            buf.append(keyrdata);\n            if (verifyDSHash(ds.digestType, buf.buf, ds.digest)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Attempts to verify a DS record's hash value against some data.\n     * @param digesttype The digest ID from the DS record.\n     * @param data The data to digest.\n     * @param digest The digest data to check against.\n     * @return True iff the digest matches.\n     */\n    function verifyDSHash(\n        uint8 digesttype,\n        bytes memory data,\n        bytes memory digest\n    ) internal view returns (bool) {\n        if (address(digests[digesttype]) == address(0)) {\n            return false;\n        }\n        return digests[digesttype].verify(data, digest);\n    }\n}"
    }
  ]
}