{
  "Title": "[M-22] VE3DRewardPool allows the same reward address to be added multiple times to the `extraRewards` array",
  "Content": "_Submitted by Ruhum_\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L134-L139>\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L214-L216>\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/BaseRewardPool.sol#L121>\n\n### Impact\n\nWhen the same address is included twice it might cause issues depending on the contract. I checked the current convex contract to see which addresses were added to the `extraRewards` array. For [cvxCRV Rewards](https://etherscan.io/address/0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e#readContract) there's only [0x7091dbb7fcbA54569eF1387Ac89Eb2a5C9F6d2EA](https://etherscan.io/address/0x7091dbb7fcbA54569eF1387Ac89Eb2a5C9F6d2EA#code) which is the VirtualBalanceRewardPool contract.\n\n### Proof of Concept\n\n1.  `rewardManager` adds the same address twice through [`addExtraReward()`](https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L134-L139)\n2.  VE3DRewardPool calls [`stake()`](https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L209-L226) twice with the same amount:\n\n```sol\n    function stake(uint256 _amount) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to sender balance sheet\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n```\n\n### Recommended Mitigation Steps\n\nPrevent the same addresses from being added multiple times to the `extraRewards` array.\n\n**[jetbrain10 (vetoken Finance) disagreed with severity and commented](https://github.com/code-423n4/2022-05-vetoken-findings/issues/55#issuecomment-1156650189):**\n > Will add code to check if this is same reward address.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-vetoken-findings/issues/55#issuecomment-1194880451):**\n > The warden has shown how, due to a misconfiguration, rewards could be disbursed twice, breaking protocol invariants.\n> \n> Because this is contingent on admin privilege, I believe Medium Severity to be appropriate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-vetoken-finance-contest",
  "Code": [
    {
      "filename": "contracts/VE3DRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: vetokenRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Interfaces/IVeAssetDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\ncontract VE3DRewardPool is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 7 days;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public immutable rewardManager;\n\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    // reward token => reward token info\n    mapping(address => RewardTokenInfo) public rewardTokenInfo;\n    // list of reward tokens\n    EnumerableSet.AddressSet internal rewardTokens;\n    EnumerableSet.AddressSet internal operators;\n\n    address[] public extraRewards;\n\n    struct RewardTokenInfo {\n        address veAssetDeposits;\n        address ve3TokenRewards;\n        address ve3Token;\n        uint256 queuedRewards;\n        uint256 rewardRate;\n        uint256 historicalRewards;\n        uint256 rewardPerTokenStored;\n        uint256 currentRewards;\n        uint256 periodFinish;\n        uint256 lastUpdateTime;\n        mapping(address => uint256) userRewardPerTokenPaid;\n        mapping(address => uint256) rewards;\n    }\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    constructor(address stakingToken_, address rewardManager_) {\n        stakingToken = IERC20(stakingToken_);\n\n        rewardManager = rewardManager_;\n    }\n\n    function addReward(\n        address _rewardToken,\n        address _veAssetDeposits,\n        address _ve3TokenRewards,\n        address _ve3Token\n    ) external onlyOwner {\n        rewardTokenInfo[_rewardToken].veAssetDeposits = _veAssetDeposits;\n        rewardTokenInfo[_rewardToken].ve3TokenRewards = _ve3TokenRewards;\n        rewardTokenInfo[_rewardToken].ve3Token = _ve3Token;\n        rewardTokens.add(_rewardToken);\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0), \"!reward setting\");\n\n        extraRewards.push(_reward);\n    }\n\n    function clearExtraRewards() external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n    }\n\n    modifier updateReward(address account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored = rewardPerToken(_rewardToken);\n            rewardTokenInfo[_rewardToken].lastUpdateTime = lastTimeRewardApplicable(_rewardToken);\n            if (account != address(0)) {\n                rewardTokenInfo[_rewardToken].rewards[account] = earnedReward(\n                    _rewardToken,\n                    account\n                );\n                rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account] = rewardTokenInfo[\n                    _rewardToken\n                ].rewardPerTokenStored;\n            }\n        }\n\n        _;\n    }\n\n    function lastTimeRewardApplicable(address _rewardToken) public view returns (uint256) {\n        return Math.min(block.timestamp, rewardTokenInfo[_rewardToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardToken) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            return rewardTokenInfo[_rewardToken].rewardPerTokenStored;\n        }\n        return\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored.add(\n                lastTimeRewardApplicable(_rewardToken)\n                    .sub(rewardTokenInfo[_rewardToken].lastUpdateTime)\n                    .mul(rewardTokenInfo[_rewardToken].rewardRate)\n                    .mul(1e18)\n                    .div(supply)\n            );\n    }\n\n    function earnedReward(address _rewardToken, address account) internal view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(\n                    rewardPerToken(_rewardToken).sub(\n                        rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account]\n                    )\n                )\n                .div(1e18)\n                .add(rewardTokenInfo[_rewardToken].rewards[account]);\n    }\n\n    function earned(address _rewardToken, address account) external view returns (uint256) {\n        uint256 depositFeeRate = IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits)\n            .lockIncentive();\n\n        uint256 r = earnedReward(_rewardToken, account);\n        uint256 fees = r.mul(depositFeeRate).div(FEE_DENOMINATOR);\n\n        //fees dont apply until whitelist+veVeAsset lock begins so will report\n        //slightly less value than what is actually received.\n        return r.sub(fees);\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to sender balance sheet\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function stakeAll() external {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to _for's balance sheet\n        _balances[_for] = _balances[_for].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function withdraw(uint256 _amount, bool claim) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        //also withdraw from linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.sub(_amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(_amount);\n        stakingToken.safeTransfer(msg.sender, _amount);\n        emit Withdrawn(msg.sender, _amount);\n\n        if (claim) {\n            getReward(msg.sender, true, false);\n        }\n    }\n\n    function withdrawAll(bool claim) external {\n        withdraw(_balances[msg.sender], claim);\n    }\n\n    function getReward(\n        address _account,\n        bool _claimExtras,\n        bool _stake\n    ) public updateReward(_account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n\n            uint256 reward = earnedReward(_rewardToken, _account);\n            if (reward > 0) {\n                rewardTokenInfo[_rewardToken].rewards[_account] = 0;\n                IERC20(_rewardToken).safeApprove(rewardTokenInfo[_rewardToken].veAssetDeposits, 0);\n                IERC20(_rewardToken).safeApprove(\n                    rewardTokenInfo[_rewardToken].veAssetDeposits,\n                    reward\n                );\n                IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits).deposit(\n                    reward,\n                    false\n                );\n\n                uint256 ve3TokenBalance = IERC20(rewardTokenInfo[_rewardToken].ve3Token).balanceOf(\n                    address(this)\n                );\n                if (_stake) {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        0\n                    );\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        ve3TokenBalance\n                    );\n                    IRewards(rewardTokenInfo[_rewardToken].ve3TokenRewards).stakeFor(\n                        _account,\n                        ve3TokenBalance\n                    );\n                } else {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeTransfer(\n                        _account,\n                        ve3TokenBalance\n                    );\n                }\n                emit RewardPaid(_account, ve3TokenBalance);\n            }\n        }\n\n        //also get rewards from linked rewards\n        if (_claimExtras) {\n            uint256 length = extraRewards.length;\n            for (uint256 i = 0; i < length; i++) {\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n    }\n\n    function getReward(bool _stake) external {\n        getReward(msg.sender, true, _stake);\n    }\n\n    function donate(address _rewardToken, uint256 _amount) external {\n        IERC20(_rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        rewardTokenInfo[_rewardToken].queuedRewards += _amount;\n    }\n\n    function queueNewRewards(address _rewardToken, uint256 _rewards) external {\n        require(operators.contains(_msgSender()), \"!authorized\");\n\n        _rewards = _rewards.add(rewardTokenInfo[_rewardToken].queuedRewards);\n\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n            return;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(\n            rewardTokenInfo[_rewardToken].periodFinish.sub(duration)\n        );\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardTokenInfo[_rewardToken].rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n        } else {\n            rewardTokenInfo[_rewardToken].queuedRewards = _rewards;\n        }\n    }\n\n    function notifyRewardAmount(address _rewardToken, uint256 reward)\n        internal\n        updateReward(address(0))\n    {\n        rewardTokenInfo[_rewardToken].historicalRewards += reward;\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = rewardTokenInfo[_rewardToken].periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardTokenInfo[_rewardToken].rewardRate);\n            reward = reward.add(leftover);\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        }\n        rewardTokenInfo[_rewardToken].currentRewards = reward;\n        rewardTokenInfo[_rewardToken].lastUpdateTime = block.timestamp;\n        rewardTokenInfo[_rewardToken].periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}"
    },
    {
      "filename": "contracts/VE3DRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: vetokenRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Interfaces/IVeAssetDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\ncontract VE3DRewardPool is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 7 days;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public immutable rewardManager;\n\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    // reward token => reward token info\n    mapping(address => RewardTokenInfo) public rewardTokenInfo;\n    // list of reward tokens\n    EnumerableSet.AddressSet internal rewardTokens;\n    EnumerableSet.AddressSet internal operators;\n\n    address[] public extraRewards;\n\n    struct RewardTokenInfo {\n        address veAssetDeposits;\n        address ve3TokenRewards;\n        address ve3Token;\n        uint256 queuedRewards;\n        uint256 rewardRate;\n        uint256 historicalRewards;\n        uint256 rewardPerTokenStored;\n        uint256 currentRewards;\n        uint256 periodFinish;\n        uint256 lastUpdateTime;\n        mapping(address => uint256) userRewardPerTokenPaid;\n        mapping(address => uint256) rewards;\n    }\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    constructor(address stakingToken_, address rewardManager_) {\n        stakingToken = IERC20(stakingToken_);\n\n        rewardManager = rewardManager_;\n    }\n\n    function addReward(\n        address _rewardToken,\n        address _veAssetDeposits,\n        address _ve3TokenRewards,\n        address _ve3Token\n    ) external onlyOwner {\n        rewardTokenInfo[_rewardToken].veAssetDeposits = _veAssetDeposits;\n        rewardTokenInfo[_rewardToken].ve3TokenRewards = _ve3TokenRewards;\n        rewardTokenInfo[_rewardToken].ve3Token = _ve3Token;\n        rewardTokens.add(_rewardToken);\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0), \"!reward setting\");\n\n        extraRewards.push(_reward);\n    }\n\n    function clearExtraRewards() external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n    }\n\n    modifier updateReward(address account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored = rewardPerToken(_rewardToken);\n            rewardTokenInfo[_rewardToken].lastUpdateTime = lastTimeRewardApplicable(_rewardToken);\n            if (account != address(0)) {\n                rewardTokenInfo[_rewardToken].rewards[account] = earnedReward(\n                    _rewardToken,\n                    account\n                );\n                rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account] = rewardTokenInfo[\n                    _rewardToken\n                ].rewardPerTokenStored;\n            }\n        }\n\n        _;\n    }\n\n    function lastTimeRewardApplicable(address _rewardToken) public view returns (uint256) {\n        return Math.min(block.timestamp, rewardTokenInfo[_rewardToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardToken) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            return rewardTokenInfo[_rewardToken].rewardPerTokenStored;\n        }\n        return\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored.add(\n                lastTimeRewardApplicable(_rewardToken)\n                    .sub(rewardTokenInfo[_rewardToken].lastUpdateTime)\n                    .mul(rewardTokenInfo[_rewardToken].rewardRate)\n                    .mul(1e18)\n                    .div(supply)\n            );\n    }\n\n    function earnedReward(address _rewardToken, address account) internal view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(\n                    rewardPerToken(_rewardToken).sub(\n                        rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account]\n                    )\n                )\n                .div(1e18)\n                .add(rewardTokenInfo[_rewardToken].rewards[account]);\n    }\n\n    function earned(address _rewardToken, address account) external view returns (uint256) {\n        uint256 depositFeeRate = IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits)\n            .lockIncentive();\n\n        uint256 r = earnedReward(_rewardToken, account);\n        uint256 fees = r.mul(depositFeeRate).div(FEE_DENOMINATOR);\n\n        //fees dont apply until whitelist+veVeAsset lock begins so will report\n        //slightly less value than what is actually received.\n        return r.sub(fees);\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to sender balance sheet\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function stakeAll() external {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to _for's balance sheet\n        _balances[_for] = _balances[_for].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function withdraw(uint256 _amount, bool claim) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        //also withdraw from linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.sub(_amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(_amount);\n        stakingToken.safeTransfer(msg.sender, _amount);\n        emit Withdrawn(msg.sender, _amount);\n\n        if (claim) {\n            getReward(msg.sender, true, false);\n        }\n    }\n\n    function withdrawAll(bool claim) external {\n        withdraw(_balances[msg.sender], claim);\n    }\n\n    function getReward(\n        address _account,\n        bool _claimExtras,\n        bool _stake\n    ) public updateReward(_account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n\n            uint256 reward = earnedReward(_rewardToken, _account);\n            if (reward > 0) {\n                rewardTokenInfo[_rewardToken].rewards[_account] = 0;\n                IERC20(_rewardToken).safeApprove(rewardTokenInfo[_rewardToken].veAssetDeposits, 0);\n                IERC20(_rewardToken).safeApprove(\n                    rewardTokenInfo[_rewardToken].veAssetDeposits,\n                    reward\n                );\n                IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits).deposit(\n                    reward,\n                    false\n                );\n\n                uint256 ve3TokenBalance = IERC20(rewardTokenInfo[_rewardToken].ve3Token).balanceOf(\n                    address(this)\n                );\n                if (_stake) {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        0\n                    );\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        ve3TokenBalance\n                    );\n                    IRewards(rewardTokenInfo[_rewardToken].ve3TokenRewards).stakeFor(\n                        _account,\n                        ve3TokenBalance\n                    );\n                } else {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeTransfer(\n                        _account,\n                        ve3TokenBalance\n                    );\n                }\n                emit RewardPaid(_account, ve3TokenBalance);\n            }\n        }\n\n        //also get rewards from linked rewards\n        if (_claimExtras) {\n            uint256 length = extraRewards.length;\n            for (uint256 i = 0; i < length; i++) {\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n    }\n\n    function getReward(bool _stake) external {\n        getReward(msg.sender, true, _stake);\n    }\n\n    function donate(address _rewardToken, uint256 _amount) external {\n        IERC20(_rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        rewardTokenInfo[_rewardToken].queuedRewards += _amount;\n    }\n\n    function queueNewRewards(address _rewardToken, uint256 _rewards) external {\n        require(operators.contains(_msgSender()), \"!authorized\");\n\n        _rewards = _rewards.add(rewardTokenInfo[_rewardToken].queuedRewards);\n\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n            return;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(\n            rewardTokenInfo[_rewardToken].periodFinish.sub(duration)\n        );\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardTokenInfo[_rewardToken].rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n        } else {\n            rewardTokenInfo[_rewardToken].queuedRewards = _rewards;\n        }\n    }\n\n    function notifyRewardAmount(address _rewardToken, uint256 reward)\n        internal\n        updateReward(address(0))\n    {\n        rewardTokenInfo[_rewardToken].historicalRewards += reward;\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = rewardTokenInfo[_rewardToken].periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardTokenInfo[_rewardToken].rewardRate);\n            reward = reward.add(leftover);\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        }\n        rewardTokenInfo[_rewardToken].currentRewards = reward;\n        rewardTokenInfo[_rewardToken].lastUpdateTime = block.timestamp;\n        rewardTokenInfo[_rewardToken].periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}"
    },
    {
      "filename": "contracts/BaseRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: BaseRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IRewards.sol\";\nimport \"./Interfaces/IDeposit.sol\";\n\ncontract BaseRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardToken;\n    IERC20 public stakingToken;\n    uint256 public constant duration = 7 days;\n    uint256 constant BLOCKS_PER_DAY = 6450;\n    uint256 constant BLOCKS_PER_YEAR = BLOCKS_PER_DAY * 365;\n    uint256 constant EXTRA_REWARD_POOLS = 3;\n\n    address public operator;\n    address public rewardManager;\n\n    uint256 public pid;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public queuedRewards = 0;\n    uint256 public currentRewards = 0;\n    uint256 public historicalRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    address[] public extraRewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event ExtraRewardAdded(address indexed reward);\n    event ExtraRewardCleared();\n    event RewardUpdated(\n        address indexed user,\n        uint256 reward,\n        uint256 rewardPerTokenStored,\n        uint256 lastUpdateTime\n    );\n    event Donated(uint256 queuedRewards);\n\n    constructor(\n        uint256 pid_,\n        address stakingToken_,\n        address rewardToken_,\n        address operator_,\n        address rewardManager_\n    ) {\n        pid = pid_;\n        stakingToken = IERC20(stakingToken_);\n        rewardToken = IERC20(rewardToken_);\n        operator = operator_;\n        rewardManager = rewardManager_;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external returns (bool) {\n        requ"
    }
  ]
}