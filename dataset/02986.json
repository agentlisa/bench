{
  "Title": "H-5: Settlement slippage is not implemented correctly which may lead to some vaults being impossible to settle",
  "Content": "# Issue H-5: Settlement slippage is not implemented correctly which may lead to some vaults being impossible to settle \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/42 \n\n## Found by \n0x52\n\n## Summary\n\nThe contract is supposed to implement a different max slippage value depending on the settlement type, but these values have no impact because they are never actually applied. Instead, regardless of settlement type or function inputs, max slippage will always be limited to the value of balancerPoolSlippageLimitPercent. This can be problematic because the default value allows only 1% slippage. If settlement slippage goes outside of 1% then settlement of any kind will become impossible. \n\n## Vulnerability Detail\n\n[Boosted3TokenAuraHelper.sol#L95-L99](https://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/external/Boosted3TokenAuraHelper.sol#L95-L99)\n\n        params.minPrimary = poolContext._getTimeWeightedPrimaryBalance(\n            oracleContext, strategyContext, bptToSettle\n        );\n\n        params.minPrimary = params.minPrimary * strategyContext.vaultSettings.balancerPoolSlippageLimitPercent / \n            uint256(BalancerConstants.VAULT_PERCENT_BASIS);\n\nBoosted3TokenAuraHelper#_executeSettlement first sets params.minPrimary overwriting any value from function input. Next it adjusts minPrimary by balancerPoolSlippageLimitPercent, which is a constant set at pool creation; however it doesn't ever adjust it by Params.DynamicTradeParams.oracleSlippagePercent. This means that the max possible slippage regardless of settlement type is limited to the slippage allowed by balancerPoolSlippageLimitPercent. If the max slippage ever goes outside of this range, then settlement of any kind will become impossible.\n\n## Impact\n\nSettlement may become impossible\n\n## Code Snippet\n\n[Boosted3TokenAuraHelper.sol#L85-L113](https://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/external/Boosted3TokenAuraHelper.sol#L85-L113)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nParams.DynamicTradeParams.oracleSlippagePercent is validated in every scenario before Boosted3TokenAuraHelper#_executeSettlement is called, so we can apply these values directly when calculating minPrimary:\n\n        params.minPrimary = poolContext._getTimeWeightedPrimaryBalance(\n            oracleContext, strategyContext, bptToSettle\n        );\n\n    +   DynamicTradeParams memory callbackData = abi.decode(\n    +       params.secondaryTradeParams, (DynamicTradeParams)\n    +   );\n\n    -   params.minPrimary = params.minPrimary * strategyContext.vaultSettings.balancerPoolSlippageLimitPercent / \n    +   params.minPrimary = params.minPrimary * \n    +      (strategyContext.vaultSettings.balancerPoolSlippageLimitPercent - callbackData.oracleSlippagePercent) / \n           uint256(BalancerConstants.VAULT_PERCENT_BASIS);\n\n## Discussion\n\n**jeffywu**\n\n@weitianjie2000 \n\n**weitianjie2000**\n\nnot valid, balancerPoolSlippageLimitPercent is configurable and can be updated by governance\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/external/Boosted3TokenAuraHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    Boosted3TokenAuraStrategyContext, \n    StrategyContext,\n    RedeemParams,\n    ReinvestRewardParams,\n    ThreeTokenPoolContext,\n    StrategyContext,\n    AuraStakingContext,\n    BoostedOracleContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../internal/BalancerConstants.sol\";\nimport {BalancerEvents} from \"../BalancerEvents.sol\";\nimport {SettlementUtils} from \"../internal/settlement/SettlementUtils.sol\";\nimport {StrategyUtils} from \"../internal/strategy/StrategyUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"../internal/pool/Boosted3TokenPoolUtils.sol\";\nimport {Boosted3TokenAuraRewardUtils} from \"../internal/reward/Boosted3TokenAuraRewardUtils.sol\";\nimport {BalancerVaultStorage} from \"../internal/BalancerVaultStorage.sol\";\nimport {StableMath} from \"../internal/math/StableMath.sol\";\n\nlibrary Boosted3TokenAuraHelper {\n    using Boosted3TokenAuraRewardUtils for ThreeTokenPoolContext;\n    using Boosted3TokenPoolUtils for ThreeTokenPoolContext;\n    using StrategyUtils for StrategyContext;\n    using SettlementUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n\n    function settleVault(\n        Boosted3TokenAuraStrategyContext calldata context,\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        RedeemParams memory params\n    ) external {\n        uint256 bptToSettle = context.baseStrategy._convertStrategyTokensToBPTClaim(strategyTokensToRedeem);\n\n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            bptToSettle: bptToSettle,\n            redeemStrategyTokenAmount: strategyTokensToRedeem,\n            params: params\n        });\n\n        emit BalancerEvents.VaultSettlement(maturity, bptToSettle, strategyTokensToRedeem);\n    }\n\n    function settleVaultEmergency(\n        Boosted3TokenAuraStrategyContext calldata context, \n        uint256 maturity, \n        bytes calldata data\n    ) external {\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.emergencySettlementSlippageLimitPercent,\n            data\n        );\n\n        uint256 bptToSettle = context.baseStrategy._getEmergencySettlementParams({\n            poolContext: context.poolContext.basePool.basePool, \n            maturity: maturity, \n            totalBPTSupply: context.poolContext._getVirtualSupply(context.oracleContext)\n        });\n\n        uint256 redeemStrategyTokenAmount \n            = context.baseStrategy._convertBPTClaimToStrategyTokens(bptToSettle);\n        \n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            bptToSettle: bptToSettle,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n\n        emit BalancerEvents.EmergencyVaultSettlement(maturity, bptToSettle, redeemStrategyTokenAmount);\n    }\n\n    function _executeSettlement(\n        StrategyContext calldata strategyContext,\n        BoostedOracleContext calldata oracleContext,\n        ThreeTokenPoolContext calldata poolContext,\n        uint256 maturity,\n        uint256 bptToSettle,\n        uint256 redeemStrategyTokenAmount,\n        RedeemParams memory params\n    ) private {\n        // Calculate minPrimary using Chainlink oracle data\n        params.minPrimary = poolContext._getTimeWeightedPrimaryBalance(\n            oracleContext, strategyContext, bptToSettle\n        );\n        params.minPrimary = params.minPrimary * strategyContext.vaultSettings.balancerPoolSlippageLimitPercent / \n            uint256(BalancerConstants.VAULT_PERCENT_BASIS);\n\n        int256 expectedUnderlyingRedeemed = poolContext._convertStrategyToUnderlying({\n            strategyContext: strategyContext,\n            oracleContext: oracleContext,\n            strategyTokenAmount: redeemStrategyTokenAmount\n        });\n\n        strategyContext._executeSettlement({\n            maturity: maturity,\n            expectedUnderlyingRedeemed: expectedUnderlyingRedeemed,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n    }\n\n    function reinvestReward(\n        Boosted3TokenAuraStrategyContext calldata context,\n        ReinvestRewardParams calldata params\n    ) external {        \n        StrategyContext calldata strategyContext = context.baseStrategy;\n        BoostedOracleContext calldata oracleContext = context.oracleContext;\n        AuraStakingContext calldata stakingContext = context.stakingContext;\n\n        (address rewardToken, uint256 primaryAmount) = context.poolContext._executeRewardTrades({\n            stakingContext: stakingContext,\n            tradingModule: strategyContext.tradingModule,\n            data: params.tradeData,\n            slippageLimit: strategyContext.vaultSettings.maxRewardTradeSlippageLimitPercent\n        });\n\n        uint256 minBPT = context.poolContext._getMinBPT(\n            oracleContext, strategyContext, primaryAmount\n        );\n\n        uint256 bptAmount = context.poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            oracleContext: oracleContext,\n            deposit: primaryAmount,\n            minBPT: minBPT\n        });\n\n        emit BalancerEvents.RewardReinvested(rewardToken, primaryAmount, 0, bptAmount); \n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/external/Boosted3TokenAuraHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    Boosted3TokenAuraStrategyContext, \n    StrategyContext,\n    RedeemParams,\n    ReinvestRewardParams,\n    ThreeTokenPoolContext,\n    StrategyContext,\n    AuraStakingContext,\n    BoostedOracleContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../internal/BalancerConstants.sol\";\nimport {BalancerEvents} from \"../BalancerEvents.sol\";\nimport {SettlementUtils} from \"../internal/settlement/SettlementUtils.sol\";\nimport {StrategyUtils} from \"../internal/strategy/StrategyUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"../internal/pool/Boosted3TokenPoolUtils.sol\";\nimport {Boosted3TokenAuraRewardUtils} from \"../internal/reward/Boosted3TokenAuraRewardUtils.sol\";\nimport {BalancerVaultStorage} from \"../internal/BalancerVaultStorage.sol\";\nimport {StableMath} from \"../internal/math/StableMath.sol\";\n\nlibrary Boosted3TokenAuraHelper {\n    using Boosted3TokenAuraRewardUtils for ThreeTokenPoolContext;\n    using Boosted3TokenPoolUtils for ThreeTokenPoolContext;\n    using StrategyUtils for StrategyContext;\n    using SettlementUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n\n    function settleVault(\n        Boosted3TokenAuraStrategyContext calldata context,\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        RedeemParams memory params\n    ) external {\n        uint256 bptToSettle = context.baseStrategy._convertStrategyTokensToBPTClaim(strategyTokensToRedeem);\n\n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            bptToSettle: bptToSettle,\n            redeemStrategyTokenAmount: strategyTokensToRedeem,\n            params: params\n        });\n\n        emit BalancerEvents.VaultSettlement(maturity, bptToSettle, strategyTokensToRedeem);\n    }\n\n    function settleVaultEmergency(\n        Boosted3TokenAuraStrategyContext calldata context, \n        uint256 maturity, \n        bytes calldata data\n    ) external {\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.emergencySettlementSlippageLimitPercent,\n            data\n        );\n\n        uint256 bptToSettle = context.baseStrategy._getEmergencySettlementParams({\n            poolContext: context.poolContext.basePool.basePool, \n            maturity: maturity, \n            totalBPTSupply: context.poolContext._getVirtualSupply(context.oracleContext)\n        });\n\n        uint256 redeemStrategyTokenAmount \n            = context.baseStrategy._convertBPTClaimToStrategyTokens(bptToSettle);\n        \n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            bptToSettle: bptToSettle,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n\n        emit BalancerEvents.EmergencyVaultSettlement(maturity, bptToSettle, redeemStrategyTokenAmount);\n    }\n\n    function _executeSettlement(\n        StrategyContext calldata strategyContext,\n        BoostedOracleContext calldata oracleContext,\n        ThreeTokenPoolContext calldata poolContext,\n        uint256 maturity,\n        uint256 bptToSettle,\n        uint256 redeemStrategyTokenAmount,\n        RedeemParams memory params\n    ) private {\n        // Calculate minPrimary using Chainlink oracle data\n        params.minPrimary = poolContext._getTimeWeightedPrimaryBalance(\n            oracleContext, strategyContext, bptToSettle\n        );\n        params.minPrimary = params.minPrimary * strategyContext.vaultSettings.balancerPoolSlippageLimitPercent / \n            uint256(BalancerConstants.VAULT_PERCENT_BASIS);\n\n        int256 expectedUnderlyingRedeemed = poolContext._convertStrategyToUnderlying({\n            strategyContext: strategyContext,\n            oracleContext: oracleContext,\n            strategyTokenAmount: redeemStrategyTokenAmount\n        });\n\n        strategyContext._executeSettlement({\n            maturity: maturity,\n            expectedUnderlyingRedeemed: expectedUnderlyingRedeemed,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n    }\n\n    function reinvestReward(\n        Boosted3TokenAuraStrategyContext calldata context,\n        ReinvestRewardParams calldata params\n    ) external {        \n        StrategyContext calldata strategyContext = context.baseStrategy;\n        BoostedOracleContext calldata oracleContext = context.oracleContext;\n        AuraStakingContext calldata stakingContext = context.stakingContext;\n\n        (address rewardToken, uint256 primaryAmount) = context.poolContext._executeRewardTrades({\n            stakingContext: stakingContext,\n            tradingModule: strategyContext.tradingModule,\n            data: params.tradeData,\n            slippageLimit: strategyContext.vaultSettings.maxRewardTradeSlippageLimitPercent\n        });\n\n        uint256 minBPT = context.poolContext._getMinBPT(\n            oracleContext, strategyContext, primaryAmount\n        );\n\n        uint256 bptAmount = context.poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            oracleContext: oracleContext,\n            deposit: primaryAmount,\n            minBPT: minBPT\n        });\n\n        emit BalancerEvents.RewardReinvested(rewardToken, primaryAmount, 0, bptAmount); \n    }\n}"
    }
  ]
}