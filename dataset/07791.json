{
  "Title": "[05]",
  "Content": "\nIt is not needed to have modifier `senderCanCallFunction` for the function `deposit` in both `L1ERC20Bridge` and `L1ETHBridge`, because they call the function `requestL2Transaction` in the `MailBox` that has already such modifier.<br>\n[L1EthBridge.sol#L92](https://github.com/code-423n4/2022-10-zksync/blob/358f38736351a8a27e325dfcb665eeba5ec02bd5/ethereum/contracts/bridge/L1EthBridge.sol#L92)<br>\n[Mailbox.sol#L112](https://github.com/code-423n4/2022-10-zksync/blob/358f38736351a8a27e325dfcb665eeba5ec02bd5/ethereum/contracts/zksync/facets/Mailbox.sol#L112)<br>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-10-zksync",
  "Code": [
    {
      "filename": "ethereum/contracts/bridge/L1EthBridge.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IL1Bridge.sol\";\nimport \"./interfaces/IL2Bridge.sol\";\n\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"../common/AllowListed.sol\";\nimport \"../common/libraries/UnsafeBytes.sol\";\nimport \"../common/L2ContractHelper.sol\";\nimport \"../common/ReentrancyGuard.sol\";\n\n/// @author Matter Labs\n/// @notice Default bridge for the native ether to zkSync 2.0.\n/// @notice This smart contracts is the only one way to get native ether inside the L2.\ncontract L1EthBridge is IL1Bridge, AllowListed, ReentrancyGuard {\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList immutable allowList;\n\n    /// @dev zkSync smart contract used to interact with L2 via asynchronous L2 <-> L1 communication\n    IMailbox immutable zkSyncMailbox;\n\n    /// @dev Ergs limit for requesting L2 deposit finalization transaction\n    /// NOTE: constant is not calculated accurately, because ergs count in L2 is not stable yet\n    uint256 constant DEPOSIT_ERGS_LIMIT = 2097152;\n\n    /// @dev Ergs limit for requesting L1 -> L2 transaction of deploying L2 bridge instance\n    /// NOTE: constant is not calculated accurately, because ergs count in L2 is not stable yet\n    uint256 constant DEPLOY_L2_BRIDGE_COUNTERPART_ERGS_LIMIT = 2097152;\n\n    /// @dev Ether native coin has no real address on L1, so a conventional zero address is used.\n    address constant CONVENTIONAL_ETH_ADDRESS = address(0);\n\n    /// @dev A mapping L2 block number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 => mapping(uint256 => bool)) public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address => mapping(bytes32 => uint256)) depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _mailbox, IAllowList _allowList) reentrancyGuardInitializer {\n        zkSyncMailbox = _mailbox;\n        allowList = _allowList;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy.\n    /// @dev Deploys L2 bridge counterpart during initialization.\n    /// @param _l2BridgeBytecode a raw bytecode of the L2 bridge contract, that will be deployed on L2.\n    function initialize(bytes calldata _l2BridgeBytecode) external reentrancyGuardInitializer {\n        bytes32 create2Salt = bytes32(0);\n        bytes memory create2Input = abi.encode(address(this));\n        bytes32 l2BridgeBytecodeHash = L2ContractHelper.hashL2Bytecode(_l2BridgeBytecode);\n        bytes memory deployL2BridgeCalldata = abi.encodeCall(\n            IContractDeployer.create2,\n            (create2Salt, l2BridgeBytecodeHash, create2Input)\n        );\n\n        l2Bridge = L2ContractHelper.computeCreate2Address(\n            address(this),\n            create2Salt,\n            l2BridgeBytecodeHash,\n            keccak256(create2Input)\n        );\n        bytes[] memory factoryDeps = new bytes[](1);\n        factoryDeps[0] = _l2BridgeBytecode;\n        zkSyncMailbox.requestL2Transaction(\n            DEPLOYER_SYSTEM_CONTRACT_ADDRESS,\n            0,\n            deployL2BridgeCalldata,\n            DEPLOY_L2_BRIDGE_COUNTERPART_ERGS_LIMIT,\n            factoryDeps\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where ether would be minted\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited. Always should be equal to zero\n    /// @param _amount The total amount of ether to be bridged\n    /// @return txHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) external payable nonReentrant senderCanCallFunction(allowList) returns (bytes32 txHash) {\n        require(_l1Token == CONVENTIONAL_ETH_ADDRESS, \"bx\");\n\n        // Will revert if msg.value is less than the amount of the deposit\n        uint256 zkSyncFee = msg.value - _amount;\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _amount);\n        txHash = zkSyncMailbox.requestL2Transaction{value: zkSyncFee}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            DEPOSIT_ERGS_LIMIT,\n            new bytes[](0)\n        );\n\n        // Save the deposit amount, to claim funds back if the L2 transaction will failed\n        depositAmount[msg.sender][txHash] = _amount;\n\n        emit DepositInitiated(msg.sender, _l2Receiver, _l1Token, _amount);\n    }\n\n    /// @dev Serialize the transaction calldata for the L2 bridge counterpart\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        uint256 _amount\n    ) internal pure returns (bytes memory txCalldata) {\n        txCalldata = abi.encodeCall(\n            IL2Bridge.finalizeDeposit,\n            (_l1Sender, _l2Receiver, CONVENTIONAL_ETH_ADDRESS, _amount, hex\"\")\n        );\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 token (should always be zero)\n    /// @param _l2TxHash The L2 transaction hash of the deposit finalization\n    /// @param _l2BlockNumber The L2 block number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BlockNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBlock,\n        bytes32[] calldata _merkleProof\n    ) external override nonReentrant senderCanCallFunction(allowList) {\n        require(_l1Token == CONVENTIONAL_ETH_ADDRESS, \"sj\");\n\n        // Checks\n        uint256 amount = depositAmount[_depositSender][_l2TxHash];\n        require(amount != 0);\n\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the deposit (L1 -> L2 transaction) was included in the L2 block with failed status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 for fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBlock = number of transaction in the block\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBlock: _l2TxNumberInBlock,\n            sender: BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(0)\n        });\n        bool success = zkSyncMailbox.proveL2LogInclusion(_l2BlockNumber, _l2MessageIndex, l2Log, _merkleProof);\n        require(success, \"ju\");\n\n        // Effects\n        delete depositAmount[_depositSender][_l2TxHash];\n        // Interactions\n        _withdrawFunds(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BlockNumber The L2 block number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BlockNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBlock,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external override nonReentrant senderCanCallFunction(allowList) {\n        require(!isWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex], \"jj\");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBlock: _l2TxNumberInBlock,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, uint256 amount) = _parseL2WithdrawalMessage(_message);\n\n        bool success = zkSyncMailbox.proveL2MessageInclusion(\n            _l2BlockNumber,\n            _l2MessageIndex,\n            l2ToL1Message,\n            _merkleProof\n        );\n        require(success, \"rj\");\n\n        isWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex] = true;\n        _withdrawFunds(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, CONVENTIONAL_ETH_ADDRESS, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(bytes memory _message)\n        internal\n        pure\n        returns (address l1Receiver, uint256 amount)\n    {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + uint256 = 4 + 20 + 32 = 56 (bytes).\n        require(_message.length == 56);\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector);\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_message, offset);\n    }\n\n    /// @notice Transfer ether from the contract to the receiver\n    /// @dev Reverts only if the transfer call failed\n    function _withdrawFunds(address _to, uint256 _amount) internal {\n        bool callSuccess;\n        // Low-level assembly call, to avoid any memory copying (save gas)\n        assembly {\n            callSuccess := call(gas(), _to, _amount, 0, 0, 0, 0)\n        }\n        require(callSuccess);\n    }\n\n    /// @notice The L2 token address that would be minted for deposit of the given L1 token\n    /// @dev Ignore function input and always return zero address as a only one token that the bridge process\n    function l2TokenAddress(address) public pure returns (address) {\n        return CONVENTIONAL_ETH_ADDRESS;\n    }\n}"
    },
    {
      "filename": "ethereum/contracts/zksync/facets/Mailbox.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMailbox.sol\";\nimport \"../libraries/Merkle.sol\";\nimport \"../libraries/PriorityQueue.sol\";\nimport \"../Storage.sol\";\nimport \"../Config.sol\";\nimport \"../../common/libraries/UncheckedMath.sol\";\nimport \"../../common/L2ContractHelper.sol\";\nimport \"./Base.sol\";\n\n/// @title zkSync Mailbox contract providing interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\ncontract MailboxFacet is Base, IMailbox {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 block number\n    /// @param _blockNumber The executed L2 block number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 block where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_blockNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 block\n    /// @param _blockNumber The executed L2 block number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    function proveL2LogInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_blockNumber, _index, _log, _proof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 block number\n    function _proveL2LogInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_blockNumber <= s.totalBlocksExecuted, \"xx\");\n\n        bytes32 hashedLog = keccak256(\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBlock, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, \"tw\");\n        // Check that the proof length is exactly the same as tree height, to prevent\n        // any shorter/longer paths attack on the Merkle path validation\n        require(_proof.length == L2_TO_L1_LOG_MERKLE_TREE_HEIGHT, \"rz\");\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_blockNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message calldata _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBlock: _message.txNumberInBlock,\n                sender: L2_TO_L1_MESSENGER,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @return The estimated ergs\n    function l2TransactionBaseCost(\n        uint256, // _gasPrice\n        uint256, // _ergsLimit\n        uint32 // _calldataLength\n    ) public pure returns (uint256) {\n        // TODO: estimate gas for L1 execute\n        return 0;\n    }\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction. Please note, this ether is not transferred with requesting priority op,\n    /// but will be taken from the balance in L2 during the execution\n    /// @param _calldata The input of the L2 transaction\n    /// @param _ergsLimit Maximum amount of ergs that transaction can consume during execution on L2\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) external payable nonReentrant senderCanCallFunction(s.allowList) returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2Transaction(msg.sender, _contractL2, _l2Value, _calldata, _ergsLimit, _factoryDeps);\n    }\n\n    function _requestL2Transaction(\n        address _sender,\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_ergsLimit <= PRIORITY_TX_MAX_ERGS_LIMIT, \"ui\");\n        uint64 expirationBlock = uint64(block.number + PRIORITY_EXPIRATION);\n        uint256 txId = s.priorityQueue.getTotalPriorityTxs();\n        // TODO: Restore after stable priority op fee modeling. (SMA-1230)\n        // uint256 baseCost = l2TransactionBaseCost(tx.gasprice, _ergsLimit, uint32(_calldata.length));\n        // uint256 layer2Tip = msg.value - baseCost;\n\n        canonicalTxHash = _writePriorityOp(\n            _sender,\n            txId,\n            _l2Value,\n            _contractL2,\n            _calldata,\n            expirationBlock,\n            _ergsLimit,\n            _factoryDeps\n        );\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        address _sender,\n        uint256 _txId,\n        uint256 _l2Value,\n        address _contractAddressL2,\n        bytes calldata _calldata,\n        uint64 _expirationBlock,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = serializeL2Transaction(\n            _txId,\n            _l2Value,\n            _sender,\n            _contractAddressL2,\n            _calldata,\n            _ergsLimit,\n            _factoryDeps\n        );\n        canonicalTxHash = keccak256(abi.encode(transaction));\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationBlock: _expirationBlock,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that needed for operator to simulate priority queue offchain\n        emit NewPriorityRequest(_txId, canonicalTxHash, _expirationBlock, transaction, _factoryDeps);\n    }\n\n    /// @dev Accepts the parameters of the l2 transaction and converts it to the canonical form.\n    /// @param _txId Priority operation ID, used as a unique identifier so that transactions always have a different hash\n    /// @param _l2Value `msg.value` of L2 transaction. Please note, this ether is not transferred with requesting priority op,\n    /// but will be taken from the balance in L2 during the execution\n    /// @param _sender The L2 address of the account that initiates the transaction\n    /// @param _contractAddressL2 The L2 receiver address\n    /// @param _calldata The input of the L2 transaction\n    /// @param _ergsLimit Maximum amount of ergs that transaction can consume during execution on L2\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @return The canonical form of the l2 transaction parameters\n    function serializeL2Transaction(\n        uint256 _txId,\n        uint256 _l2Value,\n        address _sender,\n        address _contractAddressL2,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) public pure returns (L2CanonicalTransaction memory) {\n        return\n            L2CanonicalTransaction({\n                txType: PRIORITY_OPERATION_L2_TX_TYPE,\n                from: uint256(uint160(_sender)),\n                to: uint256(uint160(_contractAddressL2)),\n                ergsLimit: _ergsLimit,\n                ergsPerPubdataByteLimit: uint256(1),\n                maxFeePerErg: uint256(0),\n                maxPriorityFeePerErg: uint256(0),\n                paymaster: uint256(0),\n                reserved: [uint256(_txId), _l2Value, 0, 0, 0, 0],\n                data: _calldata,\n                signature: new bytes(0),\n                factoryDeps: _hashFactoryDeps(_factoryDeps),\n                paymasterInput: new bytes(0),\n                reservedDynamic: new bytes(0)\n            });\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] calldata _factoryDeps)\n        internal\n        pure\n        returns (uint256[] memory hashedFactoryDeps)\n    {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}"
    }
  ]
}