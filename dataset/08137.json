{
  "Title": "[M-32] Admin cannot be changed to EOA after deployment",
  "Content": "_Submitted by Jeiwan, also found by datapunk_\n\nAfter contracts are deployed and initialized, the admin address in `Kernel` contract can only be set to a contract. Granting and revoking roles will be possible to do only via a contract, which looks like an unintended behavior since these operations cannot be performed via governance (the governance contract is designed to be the only executor).\n\n### Proof of Concept\n\nAdmin address can be changed to any address (EOA or contract) in the `executeAction` function in `Kernel`:<br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L252-L253>\n\nThis piece explicitly allows EOA addresses since the other actions in the function (besides `ChangeExecutor`) are checked to have only a contract as the target (see `ensureContract` function calls in the other actions). This, and the fact that roles cannot be managed via governance, leads to the conclusion that an admin is designed to be an EOA.\n\nHowever, in the `store` function in `INSTR`, action target can only be a contract:<br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L52>\n\nAfter the contracts are deployed, `INSTR` will be the only contract that's allowed to call `Kernel.executeAction`:<br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/scripts/Deploy.sol#L220>\n\nThus, there will be no way to change admin to an EOA. If admin needs to be an EOA, the `INSTR` contract needs to be patched and re-deployed to allow non-contract targets.\n\n### Recommended Mitigation Steps\n\nAllow EOA addresses as instruction targets or disallow non-contract admin addresses.\n\n**[fullyallocated (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/94#issuecomment-1234801408):**\n > Nice find + writeup.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/Kernel.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"src/utils/KernelUtils.sol\";\n\n// Kernel Adapter errors\nerror KernelAdapter_OnlyKernel(address caller_);\n\n// Module errors\nerror Module_PolicyNotPermitted(address policy_);\n\n// Policy errors\nerror Policy_OnlyRole(Role role_);\nerror Policy_ModuleDoesNotExist(Keycode keycode_);\n\n// Kernel errors\nerror Kernel_OnlyExecutor(address caller_);\nerror Kernel_OnlyAdmin(address caller_);\nerror Kernel_ModuleAlreadyInstalled(Keycode module_);\nerror Kernel_InvalidModuleUpgrade(Keycode module_);\nerror Kernel_PolicyAlreadyActivated(address policy_);\nerror Kernel_PolicyNotActivated(address policy_);\nerror Kernel_AddressAlreadyHasRole(address addr_, Role role_);\nerror Kernel_AddressDoesNotHaveRole(address addr_, Role role_);\nerror Kernel_RoleDoesNotExist(Role role_);\n\n/*//////////////////////////////////////////////////////////////\n                          GLOBAL TYPES\n//////////////////////////////////////////////////////////////*/\n\n/// @notice Actions to trigger state changes in the kernel. Passed by the executor\nenum Actions {\n    InstallModule,\n    UpgradeModule,\n    ActivatePolicy,\n    DeactivatePolicy,\n    ChangeExecutor,\n    ChangeAdmin,\n    MigrateKernel\n}\n\n/// @notice Used by executor to select an action and a target contract for a kernel action\nstruct Instruction {\n    Actions action;\n    address target;\n}\n\n/// @notice Used to define which module functions a policy needs access to\nstruct Permissions {\n    Keycode keycode;\n    bytes4 funcSelector;\n}\n\ntype Keycode is bytes5;\ntype Role is bytes32;\n\n/*//////////////////////////////////////////////////////////////\n                      COMPONENT ABSTRACTS\n//////////////////////////////////////////////////////////////*/\n\n/// @notice Generic adapter interface for kernel access in modules and policies.\nabstract contract KernelAdapter {\n    Kernel public kernel;\n\n    constructor(Kernel kernel_) {\n        kernel = kernel_;\n    }\n\n    /// @notice Modifier to restrict functions to be called only by kernel.\n    modifier onlyKernel() {\n        if (msg.sender != address(kernel)) revert KernelAdapter_OnlyKernel(msg.sender);\n        _;\n    }\n\n    /// @notice Function used by kernel when migrating to a new kernel.\n    function changeKernel(Kernel newKernel_) external onlyKernel {\n        kernel = newKernel_;\n    }\n}\n\n/// @notice Base level extension of the kernel. Modules act as independent state components to be\n///         interacted with and mutated through policies.\n/// @dev    Modules are installed and uninstalled via the executor.\nabstract contract Module is KernelAdapter {\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /// @notice Modifier to restrict which policies have access to module functions.\n    modifier permissioned() {\n        if (!kernel.modulePermissions(KEYCODE(), Policy(msg.sender), msg.sig))\n            revert Module_PolicyNotPermitted(msg.sender);\n        _;\n    }\n\n    /// @notice 5 byte identifier for a module.\n    function KEYCODE() public pure virtual returns (Keycode) {}\n\n    /// @notice Returns which semantic version of a module is being implemented.\n    /// @return major - Major version upgrade indicates breaking change to the interface.\n    /// @return minor - Minor version change retains backward-compatible interface.\n    function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\n\n    /// @notice Initialization function for the module\n    /// @dev    This function is called when the module is installed or upgraded by the kernel.\n    /// @dev    MUST BE GATED BY onlyKernel. Used to encompass any initialization or upgrade logic.\n    function INIT() external virtual onlyKernel {}\n}\n\n/// @notice Policies are application logic and external interface for the kernel and installed modules.\n/// @dev    Policies are activated and deactivated in the kernel by the executor.\n/// @dev    Module dependencies and function permissions must be defined in appropriate functions.\nabstract contract Policy is KernelAdapter {\n    /// @notice Denote if a policy is activated or not.\n    bool public isActive;\n\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /// @notice Modifier to restrict policy function access to certain addresses with a role.\n    /// @dev    Roles are defined in the policy and set by the kernel admin.\n    modifier onlyRole(bytes32 role_) {\n        Role role = toRole(role_);\n        if (!kernel.hasRole(msg.sender, role)) revert Policy_OnlyRole(role);\n        _;\n    }\n\n    /// @notice Function to let kernel grant or revoke active status.\n    function setActiveStatus(bool activate_) external onlyKernel {\n        isActive = activate_;\n    }\n\n    /// @notice Function to grab module address from a given keycode.\n    function getModuleAddress(Keycode keycode_) internal view returns (address) {\n        address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\n        return moduleForKeycode;\n    }\n\n    /// @notice Define module dependencies for this policy.\n    /// @return dependencies - Keycode array of module dependencies.\n    function configureDependencies() external virtual returns (Keycode[] memory dependencies) {}\n\n    /// @notice Function called by kernel to set module function permissions.\n    /// @return requests - Array of keycodes and function selectors for requested permissions.\n    function requestPermissions() external view virtual returns (Permissions[] memory requests) {}\n}\n\n/// @notice Main contract that acts as a central component registry for the protocol.\n/// @dev    The kernel manages modules, policies and defined roles. The kernel is mutated via predefined Actions,\n/// @dev    which are input from any address assigned as the executor. The executor can be changed as needed.\ncontract Kernel {\n    /*//////////////////////////////////////////////////////////////\n                          PRIVILEGED ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Address that is able to initiate Actions in the kernel. Can be assigned to a multisig or governance contract.\n    address public executor;\n\n    /// @notice Address that is responsible for assigning policy-defined roles to addresses.\n    address public admin;\n\n    /*//////////////////////////////////////////////////////////////\n                           MODULE MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Array of all modules currently installed.\n    Keycode[] public allKeycodes;\n\n    /// @notice Mapping of module address to keycode.\n    mapping(Keycode => Module) public getModuleForKeycode;\n\n    /// @notice Mapping of keycode to module address.\n    mapping(Module => Keycode) public getKeycodeForModule;\n\n    /// @notice Mapping of a keycode to all of its policy dependents. Used to efficiently reconfigure policy dependencies.\n    mapping(Keycode => Policy[]) public moduleDependents;\n\n    /// @notice Helper for module dependent arrays. Prevents the need to loop through array.\n    mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex;\n\n    /// @notice Module <> Policy Permissions.\n    /// @dev    Policy -> Keycode -> Function Selector -> bool for permission\n    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions;\n\n    /*//////////////////////////////////////////////////////////////\n                           POLICY MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice List of all active policies\n    Policy[] public activePolicies;\n\n    /// @notice Helper to get active policy quickly. Prevents need to loop through array.\n    mapping(Policy => uint256) public getPolicyIndex;\n\n    /// @notice Mapping for if an address has a policy-defined role.\n    mapping(address => mapping(Role => bool)) public hasRole;\n\n    /// @notice Mapping for if role exists.\n    mapping(Role => bool) public isRole;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event PermissionsUpdated(\n        Keycode indexed keycode_,\n        Policy indexed policy_,\n        bytes4 funcSelector_,\n        bool granted_\n    );\n    event RoleGranted(Role indexed role_, address indexed addr_);\n    event RoleRevoked(Role indexed role_, address indexed addr_);\n    event ActionExecuted(Actions indexed action_, address indexed target_);\n\n    /*//////////////////////////////////////////////////////////////\n                              KERNEL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        executor = msg.sender;\n        admin = msg.sender;\n    }\n\n    /// @notice Modifier to check if caller is the executor.\n    modifier onlyExecutor() {\n        if (msg.sender != executor) revert Kernel_OnlyExecutor(msg.sender);\n        _;\n    }\n\n    /// @notice Modifier to check if caller is the roles admin.\n    modifier onlyAdmin() {\n        if (msg.sender != admin) revert Kernel_OnlyAdmin(msg.sender);\n        _;\n    }\n\n    /// @notice Main kernel function. Initiates state changes to kernel depending on Action passed in.\n    function executeAction(Actions action_, address target_) external onlyExecutor {\n        if (action_ == Actions.InstallModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _installModule(Module(target_));\n        } else if (action_ == Actions.UpgradeModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _upgradeModule(Module(target_));\n        } else if (action_ == Actions.ActivatePolicy) {\n            ensureContract(target_);\n            _activatePolicy(Policy(target_));\n        } else if (action_ == Actions.DeactivatePolicy) {\n            ensureContract(target_);\n            _deactivatePolicy(Policy(target_));\n        } else if (action_ == Actions.ChangeExecutor) {\n            executor = target_;\n        } else if (action_ == Actions.ChangeAdmin) {\n            admin = target_;\n        } else if (action_ == Actions.MigrateKernel) {\n            ensureContract(target_);\n            _migrateKernel(Kernel(target_));\n        }\n\n        emit ActionExecuted(action_, target_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ACTIONS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _installModule(Module newModule_) internal {\n        Keycode keycode = newModule_.KEYCODE();\n\n        if (address(getModuleForKeycode[keycode]) != address(0))\n            revert Kernel_ModuleAlreadyInstalled(keycode);\n\n        getModuleForKeycode[keycode] = newModule_;\n        getKeycodeForModule[newModule_] = keycode;\n        allKeycodes.push(keycode);\n\n        newModule_.INIT();\n    }\n\n    function _upgradeModule(Module newModule_) internal {\n        Keycode keycode = newModule_.KEYCODE();\n        Module oldModule = getModuleForKeycode[keycode];\n\n        if (address(oldModule) == address(0) || oldModule == newModule_)\n            revert Kernel_InvalidModuleUpgrade(keycode);\n\n        getKeycodeForModule[oldModule] = Keycode.wrap(bytes5(0));\n        getKeycodeForModule[newModule_] = keycode;\n        getModuleForKeycode[keycode] = newModule_;\n\n        newModule_.INIT();\n\n        _reconfigurePolicies(keycode);\n    }\n\n    function _activatePolicy(Policy policy_) internal {\n        if (policy_.isActive()) revert Kernel_PolicyAlreadyActivated(address(policy_));\n\n        // Add policy to list of active policies\n        activePolicies.push(policy_);\n        getPolicyIndex[policy_] = activePolicies.length - 1;\n\n        // Record module dependencies\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depLength = dependencies.length;\n\n        for (uint256 i; i < depLength; ) {\n            Keycode keycode = dependencies[i];\n\n            moduleDependents[keycode].push(policy_);\n            getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Grant permissions for policy to access restricted module functions\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, true);\n\n        // Set policy status to active\n        policy_.setActiveStatus(true);\n    }\n\n    function _deactivatePolicy(Policy policy_) internal {\n        if (!policy_.isActive()) revert Kernel_PolicyNotActivated(address(policy_));\n\n        // Revoke permissions\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, false);\n\n        // Remove policy from all policy data structures\n        uint256 idx = getPolicyIndex[policy_];\n        Policy lastPolicy = activePolicies[activePolicies.length - 1];\n\n        activePolicies[idx] = lastPolicy;\n        activePolicies.pop();\n        getPolicyIndex[lastPolicy] = idx;\n        delete getPolicyIndex[policy_];\n\n        // Remove policy from module dependents\n        _pruneFromDependents(policy_);\n\n        // Set policy status to inactive\n        policy_.setActiveStatus(false);\n    }\n\n    /// @notice All functionality will move to the new kernel. WARNING: ACTION WILL BRICK THIS KERNEL.\n    /// @dev    New kernel must add in all of the modules and policies via executeAction.\n    /// @dev    NOTE: Data does not get cleared from this kernel.\n    function _migrateKernel(Kernel newKernel_) internal {\n        uint256 keycodeLen = allKeycodes.length;\n        for (uint256 i; i < keycodeLen; ) {\n            Module module = Module(getModuleForKeycode[allKeycodes[i]]);\n            module.changeKernel(newKernel_);\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint256 policiesLen = activePolicies.length;\n        for (uint256 j; j < policiesLen; ) {\n            Policy policy = activePolicies[j];\n\n            // Deactivate before changing kernel\n            policy.setActiveStatus(false);\n            policy.changeKernel(newKernel_);\n            unchecked {\n                ++j;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function _reconfigurePolicies(Keycode keycode_) internal {\n        Policy[] memory dependents = moduleDependents[keycode_];\n        uint256 depLength = dependents.length;\n\n        for (uint256 i; i < depLength; ) {\n            dependents[i].configureDependencies();\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _setPolicyPermissions(\n        Policy policy_,\n        Permissions[] memory requests_,\n        bool grant_\n    ) internal {\n        uint256 reqLength = requests_.length;\n        for (uint256 i = 0; i < reqLength; ) {\n            Permissions memory request = requests_[i];\n            modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\n\n            emit PermissionsUpdated(request.keycode, policy_, request.funcSelector, grant_);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _pruneFromDependents(Policy policy_) internal {\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depcLength = dependencies.length;\n\n        for (uint256 i; i < depcLength; ) {\n            Keycode keycode = dependencies[i];\n            Policy[] storage dependents = moduleDependents[keycode];\n\n            uint256 origIndex = getDependentIndex[keycode][policy_];\n            Policy lastPolicy = dependents[dependents.length - 1];\n\n            // Swap with last and pop\n            dependents[origIndex] = lastPolicy;\n            dependents.pop();\n\n            // Record new index and delete deactivated policy index\n            getDependentIndex[keycode][lastPolicy] = origIndex;\n            delete getDependentIndex[keycode][policy_];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          ROLES ADMIN FUNCTION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Function to grant policy-defined roles to some address. Can only be called by admin.\n    function grantRole(Role role_, address addr_) public onlyAdmin {\n        if (hasRole[addr_][role_]) revert Kernel_AddressAlreadyHasRole(addr_, role_);\n\n        ensureValidRole(role_);\n        if (!isRole[role_]) isRole[role_] = true;\n\n        hasRole[addr_][role_] = true;\n\n        emit RoleGranted(role_, addr_);\n    }\n\n    /// @notice Function to revoke policy-defined roles from some address. Can only be called by admin.\n    function revokeRole(Role role_, address addr_) public onlyAdmin {\n        if (!isRole[role_]) revert Kernel_RoleDoesNotExist(role_);\n        if (!hasRole[addr_][role_]) revert Kernel_AddressDoesNotHaveRole(addr_, role_);\n\n        hasRole[addr_][role_] = false;\n\n        emit RoleRevoked(role_, addr_);\n    }\n}"
    },
    {
      "filename": "src/modules/INSTR.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"src/Kernel.sol\";\n\nerror INSTR_InstructionsCannotBeEmpty();\nerror INSTR_InvalidChangeExecutorAction();\n\n/// @notice Caches and executes batched instructions for protocol upgrades in the Kernel.\ncontract OlympusInstructions is Module {\n    event InstructionsStored(uint256 instructionsId);\n\n    uint256 public totalInstructions;\n    mapping(uint256 => Instruction[]) public storedInstructions;\n\n    /*//////////////////////////////////////////////////////////////\n                            MODULE INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Kernel kernel_) Module(kernel_) {}\n\n    /// @inheritdoc Module\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"INSTR\");\n    }\n\n    /// @inheritdoc Module\n    function VERSION() public pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice View function for retrieving a list of Instructions in an outside contract.\n    function getInstructions(uint256 instructionsId_) public view returns (Instruction[] memory) {\n        return storedInstructions[instructionsId_];\n    }\n\n    /// @notice Store a list of Instructions to be executed in the future.\n    function store(Instruction[] calldata instructions_) external permissioned returns (uint256) {\n        uint256 length = instructions_.length;\n        uint256 instructionsId = ++totalInstructions;\n\n        Instruction[] storage instructions = storedInstructions[instructionsId];\n\n        if (length == 0) revert INSTR_InstructionsCannotBeEmpty();\n\n        for (uint256 i; i < length; ) {\n            Instruction calldata instruction = instructions_[i];\n            ensureContract(instruction.target);\n\n            // If the instruction deals with a module, make sure the module has a valid keycode (UPPERCASE A-Z ONLY)\n            if (\n                instruction.action == Actions.InstallModule ||\n                instruction.action == Actions.UpgradeModule\n            ) {\n                Module module = Module(instruction.target);\n                ensureValidKeycode(module.KEYCODE());\n            } else if (instruction.action == Actions.ChangeExecutor && i != length - 1) {\n                // Throw an error if ChangeExecutor exists and is not the last Action in the instruction list.\n                // This exists because if ChangeExecutor is not the last item in the list of instructions,\n                // the Kernel will not recognize any of the following instructions as valid, since the policy\n                // executing the list of instructions no longer has permissions in the Kernel. To avoid this issue\n                // and prevent invalid proposals from being saved, we perform this check.\n                revert INSTR_InvalidChangeExecutorAction();\n            }\n\n            instructions.push(instructions_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit InstructionsStored(instructionsId);\n\n        return instructionsId;\n    }\n}"
    },
    {
      "filename": "src/scripts/Deploy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {AggregatorV2V3Interface} from \"interfaces/AggregatorV2V3Interface.sol\";\nimport {Script, console2} from \"forge-std/Script.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IBondAggregator} from \"interfaces/IBondAggregator.sol\";\nimport {IBondAuctioneer} from \"interfaces/IBondAuctioneer.sol\";\nimport {IWETH9} from \"interfaces/IWETH9.sol\";\n\nimport \"src/Kernel.sol\";\nimport {OlympusPrice} from \"modules/PRICE.sol\";\nimport {OlympusRange} from \"modules/RANGE.sol\";\nimport {OlympusTreasury} from \"modules/TRSRY.sol\";\nimport {OlympusMinter} from \"modules/MINTR.sol\";\nimport {OlympusInstructions} from \"modules/INSTR.sol\";\nimport {OlympusVotes} from \"modules/VOTES.sol\";\n\nimport {Operator} from \"policies/Operator.sol\";\nimport {OlympusHeart} from \"policies/Heart.sol\";\nimport {BondCallback} from \"policies/BondCallback.sol\";\nimport {OlympusPriceConfig} from \"policies/PriceConfig.sol\";\nimport {VoterRegistration} from \"policies/VoterRegistration.sol\";\nimport {OlympusGovernance} from \"policies/Governance.sol\";\nimport {MockPriceFeed} from \"test/mocks/MockPriceFeed.sol\";\nimport {Faucet} from \"test/mocks/Faucet.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\n\n/// @notice Script to deploy and initialize the Olympus system\n/// @dev    The address that this script is broadcast from must have write access to the contracts being configured\ncontract OlympusDeploy is Script {\n    using TransferHelper for ERC20;\n    Kernel public kernel;\n\n    /// Modules\n    OlympusPrice public PRICE;\n    OlympusRange public RANGE;\n    OlympusTreasury public TRSRY;\n    OlympusMinter public MINTR;\n    OlympusInstructions public INSTR;\n    OlympusVotes public VOTES;\n\n    /// Policies\n    Operator public operator;\n    OlympusHeart public heart;\n    BondCallback public callback;\n    OlympusPriceConfig public priceConfig;\n    VoterRegistration public voterReg;\n    OlympusGovernance public governance;\n    Faucet public faucet;\n\n    /// Construction variables\n\n    /// Mainnet addresses\n    // ERC20 public constant ohm =\n    //     ERC20(0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5); // OHM mainnet address\n    // ERC20 public constant reserve =\n    //     ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F); // DAI mainnet address\n    // ERC20 public constant rewardToken =\n    //     ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH mainnet address\n\n    // IBondAuctioneer public constant bondAuctioneer =\n    //     IBondAuctioneer(address(0));\n    // IBondAggregator public constant bondAggregator =\n    //     IBondAggregator(address(0));\n\n    // AggregatorV2V3Interface public constant ohmEthPriceFeed =\n    //     AggregatorV2V3Interface(0x9a72298ae3886221820B1c878d12D872087D3a23); // OHM/ETH chainlink address\n    // AggregatorV2V3Interface public constant reserveEthPriceFeed =\n    //     AggregatorV2V3Interface(0x773616E4d11A78F511299002da57A0a94577F1f4); // DAI/ETH chainlink address\n\n    /// Goerli testnet addresses\n    ERC20 public constant ohm = ERC20(0x0595328847AF962F951a4f8F8eE9A3Bf261e4f6b); // OHM goerli address\n    ERC20 public constant reserve = ERC20(0x41e38e70a36150D08A8c97aEC194321b5eB545A5); // DAI goerli address\n    ERC20 public constant rewardToken = ERC20(0x0Bb7509324cE409F7bbC4b701f932eAca9736AB7); // WETH goerli address\n\n    /// Bond system addresses\n    IBondAuctioneer public constant bondAuctioneer =\n        IBondAuctioneer(0xaE73A94b94F6E7aca37f4c79C4b865F1AF06A68b);\n    IBondAggregator public constant bondAggregator =\n        IBondAggregator(0xB4860B2c12C6B894B64471dFb5a631ff569e220e);\n\n    /// Mock Price Feed addresses\n    AggregatorV2V3Interface public constant ohmEthPriceFeed =\n        AggregatorV2V3Interface(0x022710a589C9796dce59A0C52cA4E36f0a5e991A); // OHM/ETH\n    AggregatorV2V3Interface public constant reserveEthPriceFeed =\n        AggregatorV2V3Interface(0xdC8E4eD326cFb730a759312B6b1727C6Ef9ca233); // DAI/ETH\n\n    function deploy(address guardian_, address policy_) external {\n        vm.startBroadcast();\n\n        /// Deploy kernel first\n        kernel = new Kernel(); // sender will be executor initially\n        console2.log(\"Kernel deployed at:\", address(kernel));\n\n        /// Deploy modules\n        INSTR = new OlympusInstructions(kernel);\n        console2.log(\"Instructions module deployed at:\", address(INSTR));\n\n        VOTES = new OlympusVotes(kernel);\n        console2.log(\"Votes module deployed at:\", address(VOTES));\n\n        TRSRY = new OlympusTreasury(kernel);\n        console2.log(\"Treasury module deployed at:\", address(TRSRY));\n\n        MINTR = new OlympusMinter(kernel, address(ohm));\n        console2.log(\"Minter module deployed at:\", address(MINTR));\n\n        PRICE = new OlympusPrice(\n            kernel,\n            ohmEthPriceFeed,\n            reserveEthPriceFeed,\n            uint48(8 hours),\n            uint48(30 days)\n        );\n        console2.log(\"Price module deployed at:\", address(PRICE));\n\n        RANGE = new OlympusRange(\n            kernel,\n            [ohm, reserve],\n            [uint256(100), uint256(1200), uint256(3000)]\n        );\n        console2.log(\"Range module deployed at:\", address(RANGE));\n\n        /// Deploy policies\n        callback = new BondCallback(kernel, bondAggregator, ohm);\n        console2.log(\"Bond Callback deployed at:\", address(callback));\n\n        operator = new Operator(\n            kernel,\n            bondAuctioneer,\n            callback,\n            [ohm, reserve],\n            [\n                uint32(3000), // cushionFactor\n                uint32(3 days), // cushionDuration\n                uint32(100_000), // cushionDebtBuffer\n                uint32(1 hours), // cushionDepositInterval\n                uint32(800), // reserveFactor\n                uint32(1 hours), // regenWait\n                uint32(5), // regenThreshold // 18\n                uint32(7) // regenObserve    // 21\n            ] // TODO verify initial parameters\n        );\n        console2.log(\"Operator deployed at:\", address(operator));\n\n        heart = new OlympusHeart(kernel, operator, rewardToken, 0);\n        console2.log(\"Heart deployed at:\", address(heart));\n\n        priceConfig = new OlympusPriceConfig(kernel);\n        console2.log(\"PriceConfig deployed at:\", address(priceConfig));\n\n        voterReg = new VoterRegistration(kernel);\n        console2.log(\"VoterRegistration deployed at:\", address(voterReg));\n\n        governance = new OlympusGovernance(kernel);\n        console2.log(\"Governance deployed at:\", address(governance));\n\n        faucet = new Faucet(\n            kernel,\n            ohm,\n            reserve,\n            1 ether,\n            1_000_000 * 1e9,\n            10_000_000 * 1e18,\n            1 hours\n        );\n        console2.log(\"Faucet deployed at:\", address(faucet));\n\n        /// Execute actions on Kernel\n        /// Install modules\n        kernel.executeAction(Actions.InstallModule, address(INSTR));\n        kernel.executeAction(Actions.InstallModule, address(VOTES));\n        kernel.executeAction(Actions.InstallModule, address(PRICE));\n        kernel.executeAction(Actions.InstallModule, address(RANGE));\n        kernel.executeAction(Actions.InstallModule, address(TRSRY));\n        kernel.executeAction(Actions.InstallModule, address(MINTR));\n\n        /// Approve policies\n        kernel.executeAction(Actions.ActivatePolicy, address(callback));\n        kernel.executeAction(Actions.ActivatePolicy, address(operator));\n        kernel.executeAction(Actions.ActivatePolicy, address(heart));\n        kernel.executeAction(Actions.ActivatePolicy, address(priceConfig));\n        kernel.executeAction(Actions.ActivatePolicy, address(voterReg));\n        kernel.executeAction(Actions.ActivatePolicy, address(governance));\n        kernel.executeAction(Actions.ActivatePolicy, address(faucet));\n\n        /// Configure access control for policies\n\n        /// Operator roles\n        kernel.grantRole(toRole(\"operator_operate\"), address(heart));\n        kernel.grantRole(toRole(\"operator_operate\"), guardian_);\n        kernel.grantRole(toRole(\"operator_reporter\"), address(callback));\n        kernel.grantRole(toRole(\"operator_policy\"), policy_);\n        kernel.grantRole(toRole(\"operator_admin\"), guardian_);\n\n        /// Bond callback roles\n        kernel.grantRole(toRole(\"callback_whitelist\"), address(operator));\n        kernel.grantRole(toRole(\"callback_whitelist\"), guardian_);\n        kernel.grantRole(toRole(\"callback_admin\"), guardian_);\n\n        /// Heart roles\n        kernel.grantRole(toRole(\"heart_admin\"), guardian_);\n\n        /// VoterRegistration roles\n        kernel.grantRole(toRole(\"voter_admin\"), guardian_);\n\n        /// PriceConfig roles\n        kernel.grantRole(toRole(\"price_admin\"), guardian_);\n\n        /// TreasuryCustodian roles\n        kernel.grantRole(toRole(\"custodian\"), guardian_);\n\n        /// Faucet roles\n        kernel.grantRole(toRole(\"faucet_admin\"), guardian_);\n\n        // /// Transfer executor powers to INSTR\n        // kernel.executeAction(Actions.ChangeExecutor, address(INSTR));\n\n        vm.stopBroadcast();\n    }\n\n    /// @dev should be called by address with the guardian role\n    function initialize() external {\n        // Set addresses from deployment\n        priceConfig = OlympusPriceConfig(0x76FBaD8323f47e87c1646B70f2F53857aAF11D24);\n        operator = Operator(0x532AC8804b233846645C1Cd53D3005604F5eC1c3);\n        callback = BondCallback(0xdff3e45D4BE6B354384D770Fd63DDF90eA788d13);\n\n        /// Start broadcasting\n        vm.startBroadcast();\n\n        /// Initialize the Price oracle\n\n        /// These are placeholder values. Actual market data will be used to initialize in production.\n        uint256[] memory prices = new uint256[](90);\n        for (uint i = 0; i < 90; i++) {\n            prices[i] = 15 * 1e18;\n        }\n\n        priceConfig.initialize(prices, uint48(block.timestamp));\n\n        /// Set the operator address on the BondCallback contract\n        callback.setOperator(operator);\n\n        /// Initialize the Operator policy\n        operator.initialize();\n\n        // /// Deposit msg.value in WETH contract and deposit in heart\n        // IWETH9(address(rewardToken)).deposit{value: msg.value}();\n        // rewardToken.safeTransfer(address(heart), msg.value);\n\n        /// Stop broadcasting\n        vm.stopBroadcast();\n    }\n}\n\ncontract DependencyDeploy is Script {\n    MockPriceFeed public ohmEthPriceFeed;\n    MockPriceFeed public reserveEthPriceFeed;\n\n    function deploy() external {\n        vm.startBroadcast();\n\n        // Deploy the price feeds\n        ohmEthPriceFeed = new MockPriceFeed();\n        console2.log(\"OHM-ETH Price Feed deployed to:\", address(ohmEthPriceFeed));\n        reserveEthPriceFeed = new MockPriceFeed();\n        console2.log(\"RESERVE-ETH Price Feed deployed to:\", address(reserveEthPriceFeed));\n\n        // Set the decimals of the price feeds\n        ohmEthPriceFeed.setDecimals(18);\n        reserveEthPriceFeed.setDecimals(18);\n\n        vm.stopBroadcast();\n    }\n}"
    }
  ]
}