{
  "Title": "M-7: Checking `RSETH_DEPOSIT_POOL.minAmountToDeposit()` in `RsETHAdapter::_stake()` causes Dos",
  "Content": "# Issue M-7: Checking `RSETH_DEPOSIT_POOL.minAmountToDeposit()` in `RsETHAdapter::_stake()` causes Dos \n\nSource: https://github.com/sherlock-audit/2024-05-napier-update-judging/issues/46 \n\n## Found by \nDrynooo, PNS, merlin, no, zzykxx\n\n## Summary\nChecking `RSETH_DEPOSIT_POOL.minAmountToDeposit()` in `RsETHAdapter::_stake()` causes Dos\n## Vulnerability Detail\n```javascript\n function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n\n        // Check LRTDepositPool stake limit\n        uint256 stakeLimit = RSETH_DEPOSIT_POOL.getAssetCurrentLimit(Constants.ETH);\n        if (stakeAmount > stakeLimit) {\n            // Cap stake amount\n            stakeAmount = stakeLimit;\n        }\n        // Check LRTDepositPool minAmountToDeposit\n@>        if (stakeAmount <= RSETH_DEPOSIT_POOL.minAmountToDeposit()) revert MinAmountToDepositError();\n        // Check paused of LRTDepositPool\n        if (RSETH_DEPOSIT_POOL.paused()) revert ProtocolPaused();\n\n        // Interact\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _rsETHAmt = RSETH.balanceOf(address(this));\n        RSETH_DEPOSIT_POOL.depositETH{value: stakeAmount}(0, REFERRAL_ID);\n        _rsETHAmt = RSETH.balanceOf(address(this)) - _rsETHAmt;\n\n        if (_rsETHAmt == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n```\nThe _stake will revert in the condition that the stakeAmount is less than `RSETH_DEPOSIT_POOL.minAmountToDeposit()`, which is 100000000000000. This could always happens. Because stakeAmount is not the user's input, it is calculate by this protocal.\n```javascript\nfunction prefundedDeposit() external nonReentrant onlyTranche returns (uint256, uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        uint256 bufferEthCache = $.bufferEth; // cache storage reads\n        uint256 queueEthCache = $.totalQueueEth; // cache storage reads\n        uint256 assets = IWETH9(WETH).balanceOf(address(this)) - bufferEthCache; // amount of WETH deposited at this time\n        uint256 shares = previewDeposit(assets);\n\n        if (assets == 0) return (0, 0);\n        if (shares == 0) revert ZeroShares();\n\n        // Calculate the target buffer amount considering the user's deposit.\n        // bufferRatio is defined as the ratio of ETH balance to the total assets in the adapter in ETH.\n        // Formula:\n        // desiredBufferRatio = (totalQueueEth + bufferEth + assets - s) / (totalQueueEth + bufferEth + stakedEth + assets)\n        // Where:\n        // assets := Amount of ETH the user is depositing\n        // s := Amount of ETH to stake at this time, s <= bufferEth + assets.\n        //\n        // Thus, the formula can be simplified to:\n        // s = (totalQueueEth + bufferEth + assets) - (totalQueueEth + bufferEth + stakedEth + assets) * desiredBufferRatio\n        //   = (totalQueueEth + bufferEth + assets) - targetBufferEth\n        //\n        // Flow:\n        // If `s` <= 0, don't stake any ETH.\n        // If `s` < bufferEth + assets, stake `s` amount of ETH.\n        // If `s` >= bufferEth + assets, all available ETH can be staked in theory.\n        // However, we cap the stake amount. This is to prevent the buffer from being completely drained.\n        //\n        // Let `a` be the available amount of ETH in the buffer after the deposit. `a` is calculated as:\n        // a = (bufferEth + assets) - s\n        uint256 targetBufferEth = ((totalAssets() + assets) * $.targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        /// WRITE ///\n        _mint(msg.sender, shares);\n\n        uint256 availableEth = bufferEthCache + assets; // non-zero\n\n        // If the buffer is insufficient or staking is paused, doesn't stake any of the deposit\n        StakeLimitTypes.Data memory data = $.packedStakeLimitData.getStorageStakeLimitStruct();\n        if (targetBufferEth >= availableEth + queueEthCache || data.isStakingPaused()) {\n            /// WRITE ///\n            $.bufferEth = availableEth.toUint128();\n            return (assets, shares);\n        }\n\n        // Calculate the amount of ETH to stake\n        uint256 stakeAmount; // can be 0\n        unchecked {\n    @>        stakeAmount = availableEth + queueEthCache - targetBufferEth; // non-zero, no underflow\n        }\n        // If the calculated stake amount exceeds the available ETH, simply assign the available ETH to the stake amount.\n        // Possible scenarios:\n        // - Target buffer percentage was changed to a lower value and there is a large withdrawal request pending.\n        // - There is a pending withdrawal request and the available ETH are not left in the buffer.\n        // - There is no pending withdrawal request and the available ETH are not left in the buffer.\n        if (stakeAmount > availableEth) {\n            // Note: Admins should be aware of this situation and take action to refill the buffer.\n            // - Pause staking to prevent further staking until the buffer is refilled\n            // - Update stake limit to a lower value\n            // - Increase the target buffer percentage\n    @>          stakeAmount = availableEth; // All available ETH\n        }\n\n        // If the amount of ETH to stake exceeds the current stake limit, cap the stake amount.\n        // This is to prevent the buffer from being completely drained. This is not a complete solution.\n        uint256 currentStakeLimit = StakeLimitUtils.calculateCurrentStakeLimit(data); // can be 0 if the stake limit is exhausted\n        if (stakeAmount > currentStakeLimit) {\n    @>          stakeAmount = currentStakeLimit;\n        }\n        /// WRITE ///\n        // Update the stake limit state in the storage\n        $.packedStakeLimitData.setStorageStakeLimitStruct(data.updatePrevStakeLimit(currentStakeLimit - stakeAmount));\n\n        /// INTERACT ///\n        // Deposit into the yield source\n        // Actual amount of ETH spent may be less than the requested amount.\n    @>      stakeAmount = _stake(stakeAmount); // stake amount can be 0\n\n        /// WRITE ///\n        $.bufferEth = (availableEth - stakeAmount).toUint128(); // no underflow theoretically\n\n        return (assets, shares);\n    }\n```\nThe stakeAmount could be any small value. The users deposit right value using Tranche, but could revert, and they don't konw why.\n\n\n## Impact\nThe users deposit right value using Tranche, but could revert, and they don't konw why.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-uups-adapters/src/adapters/kelp/RsETHAdapter.sol#L77-L77\n## Tool used\n\nManual Review\n\n## Recommendation\n```diff\n function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n\n        // Check LRTDepositPool stake limit\n        uint256 stakeLimit = RSETH_DEPOSIT_POOL.getAssetCurrentLimit(Constants.ETH);\n        if (stakeAmount > stakeLimit) {\n            // Cap stake amount\n            stakeAmount = stakeLimit;\n        }\n        // Check LRTDepositPool minAmountToDeposit\n-        if (stakeAmount <= RSETH_DEPOSIT_POOL.minAmountToDeposit()) revert MinAmountToDepositError();\n+        if (stakeAmount <= RSETH_DEPOSIT_POOL.minAmountToDeposit()) return 0;\n        // Check paused of LRTDepositPool\n        if (RSETH_DEPOSIT_POOL.paused()) revert ProtocolPaused();\n\n        // Interact\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _rsETHAmt = RSETH.balanceOf(address(this));\n        RSETH_DEPOSIT_POOL.depositETH{value: stakeAmount}(0, REFERRAL_ID);\n        _rsETHAmt = RSETH.balanceOf(address(this)) - _rsETHAmt;\n\n        if (_rsETHAmt == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n```\n\n\n\n## Discussion\n\n**massun-onibakuchi**\n\nSuch DoS doesn't meat requirements. This is because\n- The revert doesn't always happen. It can happens when depositing small amount.\n- It's unlikely that users deposit such small amount, wasting gas cost.\n- `stakeAmount` can be changed by changing maxStakeLimit on adapter and we can definitely avoid such revert if needed\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**z3s** commented:\n> Low/Info; For an issue to be a valid Denial of Service (DoS), it must meet one of these criteria: 1. The issue causes locking of funds for users for more than a week. 2. The issue impacts the availability of time-sensitive functions. but The stakeAmount can be modified by changing the maxStakeLimit.\n\n\n\n**0502lian**\n\nit's not because It can happens when depositing small amount. It's because  stakeAmount is calculated by `prefundedDeposit `. User deposit a large amount, stakeAmount can still be small amount (even zero) in _stake()\n\n**WangSecurity**\n\nAfter the discussions on escalation on #54, this report will be the main issue of a new family.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/369",
  "Code": [
    {
      "filename": "napier-uups-adapters/src/adapters/kelp/RsETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\nimport {ILRTOracle} from \"./interfaces/ILRTOracle.sol\";\nimport {ILRTDepositPool} from \"./interfaces/ILRTDepositPool.sol\";\n\n// libs\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable@4.9.3/token/ERC20/IERC20Upgradeable.sol\";\nimport {LSTAdapterStorage} from \"../../Structs.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapterUpgradeable} from \"../BaseLSTAdapterUpgradeable.sol\";\n\n/// @notice RsETHAdapter - eRsETH (Napier rsETH Adapter)\n/// @notice rsETH is a Liquid Restaked Token (LRT) issued by Kelp DAO designed\n/// to offer liquidity to illiquid assets deposited into restaking platforms,\n///  such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking\ncontract RsETHAdapter is BaseLSTAdapterUpgradeable {\n    /// @notice LRTDepositPool\n    ILRTDepositPool constant RSETH_DEPOSIT_POOL = ILRTDepositPool(Constants.RSETH_DEPOSIT_POOL);\n\n    /// @notice LRTOracle\n    ILRTOracle constant RSETH_ORACLE = ILRTOracle(Constants.RSETH_ORACLE);\n\n    /// @notice rsETH\n    IERC20Upgradeable constant RSETH = IERC20Upgradeable(Constants.RSETH);\n\n    /// @notice RSETH referral id\n    string constant REFERRAL_ID = \"Napier-RsETHAdapter\";\n\n    error OnlyWETHOrRETH();\n    error InvariantViolation();\n    error MinAmountToDepositError();\n    error ProtocolPaused();\n\n    receive() external payable {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) public initializer {\n        __BaseLSTAdapter_init(_owner, _rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock);\n        __ERC20_init(\"Napier rsETH Adapter\", \"eRsETH\");\n    }\n\n    /// @notice Claim withdrawal from Kelp\n    /// @dev Kelp doesn't have claim functionality yet.\n    function claimWithdrawal(uint256) external pure override {\n        revert NotImplemented();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Rebalancer functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @notice Kelp allows ETH, ETHx, stETH or sfrxETH via LRTDepositPool.\n    /// @dev Kelp has a limit on the amount of ETH that can be staked.\n    /// @dev Need to check the current staking limit before staking to prevent DoS.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n\n        // Check LRTDepositPool stake limit\n        uint256 stakeLimit = RSETH_DEPOSIT_POOL.getAssetCurrentLimit(Constants.ETH);\n        if (stakeAmount > stakeLimit) {\n            // Cap stake amount\n            stakeAmount = stakeLimit;\n        }\n        // Check LRTDepositPool minAmountToDeposit\n        if (stakeAmount <= RSETH_DEPOSIT_POOL.minAmountToDeposit()) revert MinAmountToDepositError();\n        // Check paused of LRTDepositPool\n        if (RSETH_DEPOSIT_POOL.paused()) revert ProtocolPaused();\n\n        // Interact\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _rsETHAmt = RSETH.balanceOf(address(this));\n        RSETH_DEPOSIT_POOL.depositETH{value: stakeAmount}(0, REFERRAL_ID);\n        _rsETHAmt = RSETH.balanceOf(address(this)) - _rsETHAmt;\n\n        if (_rsETHAmt == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawal() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawalAll() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function _requestWithdrawal(uint256) internal pure override returns (uint256, uint256) {\n        revert NotImplemented();\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n        return $.totalQueueEth + $.bufferEth + (RSETH.balanceOf(address(this)) * RSETH_ORACLE.rsETHPrice()) / 1e18;\n    }\n}"
    }
  ]
}