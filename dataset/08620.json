{
  "Title": "[M-04] Ineffective TWAV Implementation",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L11\n\n\n# Vulnerability details\n\n## Background\n\nThe current TWAV implementation consists of an array of 4 observations/valuations called `twavObservations`. Whenever, the new valuation is updated, the new cumulative valuation will be appended to the `twavObservations` array and the oldest observation/valuation will be removed from the `twavObservations` array.\n\nDescription of current TWAV implementation can be found at https://github.com/NibblNFT/nibbl-smartcontracts#twavsol\n\n> - Time-weighted average valuation\n> - Uses an array of length 4 which stores cumulative valuation and timestamp.\n> - TWAV is calculated between the most and least recent observations recorded in the array.\n> - TWAV array is updated only when the system is in buyout state. In case of buyout rejection, the array is reset.\n\n[https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L11](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L11)\n\n```solidity\n/// @notice current index of twavObservations index\nuint8 public twavObservationsIndex;\nuint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks \nuint32 public lastBlockTimeStamp;\n\n/// @notice record of TWAV \nTwavObservation[TWAV_BLOCK_NUMBERS] public twavObservations;\n\n/// @notice updates twavObservations array\n/// @param _blockTimestamp timestamp of the block\n/// @param _valuation current valuation\nfunction _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n    uint32 _timeElapsed; \n    unchecked {\n        _timeElapsed = _blockTimestamp - lastBlockTimeStamp;\n    }\n\n    uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation;\n    twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n    twavObservationsIndex = (twavObservationsIndex + 1) % TWAV_BLOCK_NUMBERS;\n    lastBlockTimeStamp = _blockTimestamp;\n}\n```\n\nWithin the `NibblVault` contract, the `_updateTWAV` function will be called whenever the following events happen during the buyout period:\n\n1. `NibbleVault.buy()` and `NibbleVault.Sell()` functions are called\n2. `NibbleVault.initiateBuyout` function is called\n3. `NibbleVault.updateTWAV` function is called\n\nPer the code and comment of `_getTwav()` function, the function will return the TWAV of the last four (4) blocks. This function can be called by anyone.\n\n```solidity\n/// @notice returns the TWAV of the last 4 blocks\n/// @return _twav TWAV of the last 4 blocks\nfunction _getTwav() internal view returns(uint256 _twav){\n    if (twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp != 0) {\n        uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS;\n        TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n        TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n        _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp);\n    }\n}\n```\n\nTime weighted average valuation (TWAV) is supposed to be the average value of a security over a specified time (e.g. 15 minutes, 1 hour, 24 hours). However, based on the above implementation of the `_getTwav` function, it is not the average value of a security over a specific time. \n\nA user could call the `updateTWAV` function to add the new valuation/observation to the `twavObservations` array each time a new Ethereum block is mined. As such, the current implementation becomes the average value of a security over a specific number of observations (in this case 4 observations), thus it can be considered as Observation weighted average valuation (OWAV). \n\nThere is a fundamental difference between TWAV and OWAV.\n\n## Proof-of-Concept\n\nIn Ethereum, the average block time is around 15 seconds, so the time to take to mine 4 blocks will be 1 minute. As such, in term of TWAV, the current implementation only have a period of 1 minute, which is too short to prevent price manipulation.\n\nThe following shows an example where it is possible to buy tokens→ increase the valuation above the rejection valuation→ reject the buyout→ dump the tokens within 1 minute:\n\nAssume that a buyer has triggered a buyout on the vault/NFT, and the buyout rejection price is 120 ETH and the current valuation is 100 ETH. Further assume that all elements in the  `twavObservations` array have already been populated.\n\nNote: Fees are ignored to illustrate the issue.\n\n1. Block 100 at Time 0 - Attacker called `buy` function to increase the current valuation to 120 ETH attempting to reject the buyout.\n2. Block 101 at Time 15 - Attacker called `updateTWAV` function. The current valuation (120 ETH) will be replaced the first element in `twavObservations` array.\n3. Block 102 at Time 30 - Attacker called `updateTWAV` function. The current valuation (120 ETH) will be replaced the second element in `twavObservations` array.\n4. Block 103 at Time 45 - Attacker called `updateTWAV` function. The current valuation (120 ETH) will be replaced the third element in `twavObservations` array.\n5. Block 104 at Time 60 - Attacker called `sell` function to sell/dump all his shares. Within the `sell` function, `_updateTWAV` will be first called, thus the current valuation (120 ETH) will be replaced the fourth element in `twavObservations` array. Then, the `_rejectBuyout()` will be called, and the `_getTwav` function will be triggered. At this point, the TWAV valuation is finally 120 ETH, thus the buyout is rejected. Subseqently, attacker's shares are burned, and attacker get back his funds.\n\nSince attacker could perform the above attack within 1 minute, it is very unlikely that the attackers will lose money to arbitrageurs as it takes some time for the arbitrageurs to notice such an opportunity.\n\nAttacker could also front-run or set a higher gas fee to ensure that their transaction get mined in the next block to minimize the attack window period.\n\n## Impact\n\nBuyout can be easily rejected by attackers\n\n## Recommended Mitigation Steps\n\nImplement a proper TWAV that provides the average value of a security over a specified time. The time period/windows of the TWAV must be explicitly defined (e.g. 15 minutes, 1 hour, 24 hours) in the contract.\n\nThere are trade offs when choosing the length of the period of time to calculate a TWAP. Longer periods are better to protect against price manipulation, but come at the expense of a slower, and potentially less accurate, price. Thus, the team should determine the optimal period.\n\nConsider referencing the popular Uniswap V2 TWAP design (https://docs.uniswap.org/protocol/V2/concepts/core-concepts/oracles)\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-06-nibbl-contest",
  "Code": [
    {
      "filename": "contracts/Twav/Twav.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\ncontract Twav {\n    struct TwavObservation {\n        uint32 timestamp;\n        uint256 cumulativeValuation;\n    }\n\n    /// @notice current index of twavObservations index\n    uint8 public twavObservationsIndex;\n    uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks \n    uint32 public lastBlockTimeStamp;\n\n    /// @notice record of TWAV \n    TwavObservation[TWAV_BLOCK_NUMBERS] public twavObservations;\n\n    /// @notice updates twavObservations array\n    /// @param _blockTimestamp timestamp of the block\n    /// @param _valuation current valuation\n    function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n        uint32 _timeElapsed; \n        unchecked {\n            _timeElapsed = _blockTimestamp - lastBlockTimeStamp;\n        }\n\n        uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation;\n        twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n        twavObservationsIndex = (twavObservationsIndex + 1) % TWAV_BLOCK_NUMBERS;\n        lastBlockTimeStamp = _blockTimestamp;\n    }\n\n    /// @notice returns the TWAV of the last 4 blocks\n    /// @return _twav TWAV of the last 4 blocks\n    function _getTwav() internal view returns(uint256 _twav){\n        if (twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp != 0) {\n            uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS;\n            TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n            TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n            _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp);\n        }\n    }\n\n    function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) {\n        return twavObservations;\n    }\n}"
    }
  ]
}