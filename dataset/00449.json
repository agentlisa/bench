{
  "Title": "M-30: `TOFTMarketReceiverModule::marketBorrowReceiver` flow is broken",
  "Content": "# Issue M-30: `TOFTMarketReceiverModule::marketBorrowReceiver` flow is broken \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/137 \n\n## Found by \nGiuseppeDeLaZara\n## Summary\n\nThe `TOFTMarketReceiverModule::marketBorrowReceiver` flow is broken and will revert when the Magnetar contract tries to transfer the ERC1155 tokens to the Market contract.\n\n## Vulnerability Detail\n\n[`TOFTMarketReceiverModule::marketBorrowReceiver`](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol#L108) flow is broken.\n\nLet's examine it more closely:\n\n- After checking the whitelisting status for the `marketHelper`, `magnetar` and the `market` contracts an approval is made to the Magnetar contract. \n- [`MagnetarCollateralModule::depositAddCollateralAndBorrowFromMarket`](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol#L142) get called with the passed parameters.\n- If the `data.deposit` is true, the Magnetar contract will call `_extractTokens` with the following params: `from = msg_.user`, `token = collateralAddress` and `amount = msg_.collateralAmount`.\n\n```solidity\n    function _extractTokens(address _from, address _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n        // IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n        pearlmit.transferFromERC20(_from, address(this), address(_token), _amount);\n        uint256 balanceAfter = IERC20(_token).balanceOf(address(this));\n        if (balanceAfter <= balanceBefore) revert Magnetar_ExtractTokenFail();\n        return balanceAfter - balanceBefore;\n    }\n```\n- The collateral gets transferred into the Magnetar contract in case the `msg._user` has given sufficient allowance to the Magnetar contract through the Pearlmit contract.\n- After this `_setApprovalForYieldBox(data.market, yieldBox_);` is called that sets the allowance of the Magnetar contract to the Market contract. \n- Then `addCollateral` is called on the Market contract. I've inlined the internal function to make it easier to follow:\n```solidity\n    function _addCollateral(address from, address to, bool skim, uint256 amount, uint256 share) internal {\n        if (share == 0) {\n            share = yieldBox.toShare(collateralId, amount, false);\n        }\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        userCollateralShare[to] += share;\n        totalCollateralShare = oldTotalCollateralShare + share;\n\n        // yieldBox.transfer(from, address(this), _assetId, share);\n        bool isErr = pearlmit.transferFromERC1155(from, address(this), address(yieldBox), collateralId, share);\n        if (isErr) {\n            revert TransferFailed();\n        }\n    }\n```\n\n- After the `userCollateralShare` mapping is updated [`pearlmit.transferFromERC1155(from, address(this), address(yieldBox), collateralId, share);`](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/Tapioca-bar/contracts/markets/singularity/SGLCommon.sol#L172) gets called. \n- This is critical as now the Magnetar is supposed to transfer the ERC1155 tokens(Yieldbox) to the Market contract.\n- In order to do this the Magnetar contract should have given the allowance to the Market contract through the Pearlmit contract.\n- This is not the case, the Magnetar has only executed `_setApprovalForYieldBox(data.market, yieldBox_);`, nothing else.\n- It will revert inside the Pearlmit contract `transferFromERC1155` function when the allowance is being checked.\n\n### Other occurrences\n\n1. `TOFT::mintLendXChainSGLXChainLockAndParticipateReceiver` has a similar issue as:\n- Extract the bbCollateral from the user, sets approval for the BigBang contract through YieldBox.\n- But then inside the `BBCollateral::addCollateral` the [`_addTokens`](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/Tapioca-bar/contracts/markets/bigBang/BBCommon.sol#L133) again expects an allowance through the Pearlmit contract.  \n\n\n2. `TOFT::lockAndParticipateReceiver` calls the `Magnetar:lockAndParticipate` where:\n\n```solidity\n\n## MagnetarMintCommonModule.sol\n\nfunction _lockOnTOB(\n        IOptionsLockData memory lockData,\n        IYieldBox yieldBox_,\n        uint256 fraction,\n        bool participate,\n        address user,\n        address singularityAddress\n    ) internal returns (uint256 tOLPTokenId) {\n    ....\n        _setApprovalForYieldBox(lockData.target, yieldBox_);\n        tOLPTokenId = ITapiocaOptionLiquidityProvision(lockData.target).lock(\n             participate ? address(this) : user, singularityAddress, lockData.lockDuration, lockData.amount\n        );\n}\n\n## TapiocaOptionLiquidityProvision.sol\n\nfunction lock(address _to, IERC20 _singularity, uint128 _lockDuration, uint128 _ybShares)\n    external\n    nonReentrant\n    returns (uint256 tokenId)\n{\n    // Transfer the Singularity position to this contract\n    // yieldBox.transfer(msg.sender, address(this), sglAssetID, _ybShares);\n    {\n        bool isErr =\n            pearlmit.transferFromERC1155(msg.sender, address(this), address(yieldBox), sglAssetID, _ybShares);\n        if (isErr) {\n            revert TransferFailed();\n        }\n    }\n```\n- The same issue where approval through the Pearlmit contract is expected.\n\n\n## Impact\n\nThe `TOFTMarketReceiverModule::marketBorrowReceiver` flow is broken and will revert when the Magnetar contract tries to transfer the ERC1155 tokens to the Market contract. There are also other instances of similar issues. \n\n## Code Snippet\n\n- https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/Tapioca-bar/contracts/markets/bigBang/BBCommon.sol#L133\n- https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol#L108\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReview all the allowance mechanisms and ensure that they are correct. \n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  the cause of the revert wasn't mentioned\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/tapioca-periph/commit/0a03bbbd04b30bcac183f1bae24d7f9fe9fd4103#diff-4a6decd451580f83dfe716ed16851529590c8349b1ba9bff97b42248c75e5430.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {\n    TOFTInitStruct,\n    MarketBorrowMsg,\n    MarketRemoveCollateralMsg,\n    LeverageUpActionMsg\n} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {\n    IMagnetar,\n    MagnetarCall,\n    DepositAddCollateralAndBorrowFromMarketData,\n    MagnetarAction\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {MagnetarCollateralModule} from \"tapioca-periph/Magnetar/modules/MagnetarCollateralModule.sol\";\nimport {MagnetarYieldBoxModule} from \"tapioca-periph/Magnetar/modules/MagnetarYieldBoxModule.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {TOFTMsgCodec} from \"contracts/tOFT/libraries/TOFTMsgCodec.sol\";\nimport {BaseTOFT} from \"contracts/tOFT/BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFTMarketReceiverModule\n * @author TapiocaDAO\n * @notice TOFT Market module\n */\ncontract TOFTMarketReceiverModule is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n\n    error TOFTMarketReceiverModule_NotAuthorized(address invalidAddress);\n\n    event BorrowReceived(\n        address indexed user, address indexed market, uint256 indexed amount, bool deposit, bool withdraw\n    );\n\n    event RemoveCollateralReceived(address indexed user, address indexed market, uint256 indexed amount, bool withdraw);\n\n    event LeverageUpReceived(\n        address indexed user, address indexed market, uint256 indexed amount, uint256 supplyAmount\n    );\n\n    constructor(TOFTInitStruct memory _data) BaseTOFT(_data) {}\n\n    /**\n     * @notice Calls `buyCollateral` on a market\n     * @param _data The call data containing info about the operation.\n     *      - user::address: Address to leverage for.\n     *      - market::address: Address of the market.\n     *      - borrowAmount::address: Borrow amount to leverage with.\n     *      - supplyAmount::address: Extra asset amount used for the leverage operation.\n     *      - executorData::bytes: Leverage executor data.\n     */\n    function leverageUpReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        LeverageUpActionMsg memory msg_ = TOFTMsgCodec.decodeLeverageUpMsg(_data);\n\n        /// @dev 'market'\n        _checkWhitelistStatus(msg_.market);\n\n        msg_.borrowAmount = _toLD(msg_.borrowAmount.toUint64());\n        if (msg_.supplyAmount > 0) {\n            msg_.supplyAmount = _toLD(msg_.supplyAmount.toUint64());\n        }\n\n        approve(address(msg_.market), type(uint256).max);\n\n        {\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.marketHelper).buyCollateral(\n                msg_.user, msg_.borrowAmount, msg_.supplyAmount, msg_.executorData\n            );\n            IMarket(msg_.market).execute(modules, calls, true);\n        }\n\n        approve(address(msg_.market), 0);\n\n        emit LeverageUpReceived(msg_.user, msg_.market, msg_.borrowAmount, msg_.supplyAmount);\n    }\n\n    /**\n     * @notice Calls depositAddCollateralAndBorrowFromMarket on Magnetar\n     * @param _data The call data containing info about the operation.\n     *      - from::address: Address to debit tokens from.\n     *      - to::address: Address to execute operations on.\n     *      - borrowParams::struct: Borrow operation related params.\n     *      - withdrawParams::struct: Withdraw related params.\n     */\n    function marketBorrowReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketBorrowMsg memory msg_ = TOFTMsgCodec.decodeMarketBorrowMsg(_data);\n\n        _checkWhitelistStatus(msg_.borrowParams.marketHelper);\n        _checkWhitelistStatus(msg_.borrowParams.magnetar);\n        _checkWhitelistStatus(msg_.borrowParams.market);\n\n        msg_.borrowParams.amount = _toLD(msg_.borrowParams.amount.toUint64());\n        msg_.borrowParams.borrowAmount = _toLD(msg_.borrowParams.borrowAmount.toUint64());\n\n        /// @dev use market helper to deposit, add collateral to market and withdrawTo\n        approve(address(msg_.borrowParams.magnetar), msg_.borrowParams.amount);\n\n        bytes memory call = abi.encodeWithSelector(\n            MagnetarCollateralModule.depositAddCollateralAndBorrowFromMarket.selector,\n            DepositAddCollateralAndBorrowFromMarketData(\n                msg_.borrowParams.market,\n                msg_.borrowParams.marketHelper,\n                msg_.user,\n                msg_.borrowParams.amount,\n                msg_.borrowParams.borrowAmount,\n                msg_.borrowParams.deposit,\n                msg_.withdrawParams\n            )\n        );\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.CollateralModule,\n            target: msg_.borrowParams.market,\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.borrowParams.magnetar)).burst{value: msg.value}(magnetarCall);\n\n        emit BorrowReceived(\n            msg_.user,\n            msg_.borrowParams.market,\n            msg_.borrowParams.amount,\n            msg_.borrowParams.deposit,\n            msg_.withdrawParams.withdraw\n        );\n    }\n\n    /**\n     * @notice Performs market.removeCollateral()\n     * @param _data The call data containing info about the operation.\n     *      - from::address: Address to debit tokens from.\n     *      - to::address: Address to execute operations on.\n     *      - removeParams::struct: Remove collateral operation related params.\n     *      - withdrawParams::struct: Withdraw related params.\n     */\n    function marketRemoveCollateralReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketRemoveCollateralMsg memory msg_ = TOFTMsgCodec.decodeMarketRemoveCollateralMsg(_data);\n\n        _checkWhitelistStatus(msg_.removeParams.market);\n\n        address ybAddress = IMarket(msg_.removeParams.market).yieldBox();\n        uint256 assetId = IMarket(msg_.removeParams.market).collateralId();\n\n        msg_.removeParams.amount = _toLD(msg_.removeParams.amount.toUint64());\n\n        {\n            uint256 share = IYieldBox(ybAddress).toShare(assetId, msg_.removeParams.amount, false);\n            approve(msg_.removeParams.market, share);\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.removeParams.marketHelper)\n                .removeCollateral(msg_.user, msg_.withdrawParams.withdraw ? msg_.removeParams.magnetar : msg_.user, share);\n            IMarket(msg_.removeParams.market).execute(modules, calls, true);\n        }\n\n        {\n            if (msg_.withdrawParams.withdraw) {\n                _checkWhitelistStatus(msg_.removeParams.magnetar);\n\n                bytes memory call =\n                    abi.encodeWithSelector(MagnetarYieldBoxModule.withdrawToChain.selector, msg_.withdrawParams);\n                MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n                magnetarCall[0] = MagnetarCall({\n                    id: MagnetarAction.YieldBoxModule,\n                    target: address(this),\n                    value: msg.value,\n                    allowFailure: false,\n                    call: call\n                });\n                IMagnetar(payable(msg_.removeParams.magnetar)).burst{value: msg.value}(magnetarCall);\n            }\n        }\n\n        emit RemoveCollateralReceived(\n            msg_.user, msg_.removeParams.market, msg_.removeParams.amount, msg_.withdrawParams.withdraw\n        );\n    }\n\n    function _checkWhitelistStatus(address _addr) private view {\n        if (_addr != address(0)) {\n            if (!cluster.isWhitelisted(0, _addr)) {\n                revert TOFTMarketReceiverModule_NotAuthorized(_addr);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {\n    TOFTInitStruct,\n    MarketBorrowMsg,\n    MarketRemoveCollateralMsg,\n    LeverageUpActionMsg\n} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {\n    IMagnetar,\n    MagnetarCall,\n    DepositAddCollateralAndBorrowFromMarketData,\n    MagnetarAction\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {MagnetarCollateralModule} from \"tapioca-periph/Magnetar/modules/MagnetarCollateralModule.sol\";\nimport {MagnetarYieldBoxModule} from \"tapioca-periph/Magnetar/modules/MagnetarYieldBoxModule.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {TOFTMsgCodec} from \"contracts/tOFT/libraries/TOFTMsgCodec.sol\";\nimport {BaseTOFT} from \"contracts/tOFT/BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFTMarketReceiverModule\n * @author TapiocaDAO\n * @notice TOFT Market module\n */\ncontract TOFTMarketReceiverModule is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n\n    error TOFTMarketReceiverModule_NotAuthorized(address invalidAddress);\n\n    event BorrowReceived(\n        address indexed user, address indexed market, uint256 indexed amount, bool deposit, bool withdraw\n    );\n\n    event RemoveCollateralReceived(address indexed user, address indexed market, uint256 indexed amount, bool withdraw);\n\n    event LeverageUpReceived(\n        address indexed user, address indexed market, uint256 indexed amount, uint256 supplyAmount\n    );\n\n    constructor(TOFTInitStruct memory _data) BaseTOFT(_data) {}\n\n    /**\n     * @notice Calls `buyCollateral` on a market\n     * @param _data The call data containing info about the operation.\n     *      - user::address: Address to leverage for.\n     *      - market::address: Address of the market.\n     *      - borrowAmount::address: Borrow amount to leverage with.\n     *      - supplyAmount::address: Extra asset amount used for the leverage operation.\n     *      - executorData::bytes: Leverage executor data.\n     */\n    function leverageUpReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        LeverageUpActionMsg memory msg_ = TOFTMsgCodec.decodeLeverageUpMsg(_data);\n\n        /// @dev 'market'\n        _checkWhitelistStatus(msg_.market);\n\n        msg_.borrowAmount = _toLD(msg_.borrowAmount.toUint64());\n        if (msg_.supplyAmount > 0) {\n            msg_.supplyAmount = _toLD(msg_.supplyAmount.toUint64());\n        }\n\n        approve(address(msg_.market), type(uint256).max);\n\n        {\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.marketHelper).buyCollateral(\n                msg_.user, msg_.borrowAmount, msg_.supplyAmount, msg_.executorData\n            );\n            IMarket(msg_.market).execute(modules, calls, true);\n        }\n\n        approve(address(msg_.market), 0);\n\n        emit LeverageUpReceived(msg_.user, msg_.market, msg_.borrowAmount, msg_.supplyAmount);\n    }\n\n    /**\n     * @notice Calls depositAddCollateralAndBorrowFromMarket on Magnetar\n     * @param _data The call data containing info about the operation.\n     *      - from::address: Address to debit tokens from.\n     *      - to::address: Address to execute operations on.\n     *      - borrowParams::struct: Borrow operation related params.\n     *      - withdrawParams::struct: Withdraw related params.\n     */\n    function marketBorrowReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketBorrowMsg memory msg_ = TOFTMsgCodec.decodeMarketBorrowMsg(_data);\n\n        _checkWhitelistStatus(msg_.borrowParams.marketHelper);\n        _checkWhitelistStatus(msg_.borrowParams.magnetar);\n        _checkWhitelistStatus(msg_.borrowParams.market);\n\n        msg_.borrowParams.amount = _toLD(msg_.borrowParams.amount.toUint64());\n        msg_.borrowParams.borrowAmount = _toLD(msg_.borrowParams.borrowAmount.toUint64());\n\n        /// @dev use market helper to deposit, add collateral to market and withdrawTo\n        approve(address(msg_.borrowParams.magnetar), msg_.borrowParams.amount);\n\n        bytes memory call = abi.encodeWithSelector(\n            MagnetarCollateralModule.depositAddCollateralAndBorrowFromMarket.selector,\n            DepositAddCollateralAndBorrowFromMarketData(\n                msg_.borrowParams.market,\n                msg_.borrowParams.marketHelper,\n                msg_.user,\n                msg_.borrowParams.amount,\n                msg_.borrowParams.borrowAmount,\n                msg_.borrowParams.deposit,\n                msg_.withdrawParams\n            )\n        );\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.CollateralModule,\n            target: msg_.borrowParams.market,\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.borrowParams.magnetar)).burst{value: msg.value}(magnetarCall);\n\n        emit BorrowReceived(\n            msg_.user,\n            msg_.borrowParams.market,\n            msg_.borrowParams.amount,\n            msg_.borrowParams.deposit,\n            msg_.withdrawParams.withdraw\n        );\n    }\n\n    /**\n     * @notice Performs market.removeCollateral()\n     * @param _data The call data containing info about the operation.\n     *      - from::address: Address to debit tokens from.\n     *      - to::address: Address to execute operations on.\n     *      - removeParams::struct: Remove collateral operation related params.\n     *      - withdrawParams::struct: Withdraw related params.\n     */\n    function marketRemoveCollateralReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketRemoveCollateralMsg memory msg_ = TOFTMsgCodec.decodeMarketRemoveCollateralMsg(_data);\n\n        _checkWhitelistStatus(msg_.removeParams.market);\n\n        address ybAddress = IMarket(msg_.removeParams.market).yieldBox();\n        uint256 assetId = IMarket(msg_.removeParams.market).collateralId();\n\n        msg_.removeParams.amount = _toLD(msg_.removeParams.amount.toUint64());\n\n        {\n            uint256 share = IYieldBox(ybAddress).toShare(assetId, msg_.removeParams.amount, false);\n            approve(msg_.removeParams.market, share);\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.removeParams.marketHelper)\n                .removeCollateral(msg_.user, msg_.withdrawParams.withdraw ? msg_.removeParams.magnetar : msg_.user, share);\n            IMarket(msg_.removeParams.market).execute(modules, calls, true);\n        }\n\n        {\n            if (msg_.withdrawParams.withdraw) {\n                _checkWhitelistStatus(msg_.removeParams.magnetar);\n\n                bytes memory call =\n                    abi.encodeWithSelector(MagnetarYieldBoxModule.withdrawToChain.selector, msg_.withdrawParams);\n                MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n                magnetarCall[0] = MagnetarCall({\n                    id: MagnetarAction.YieldBoxModule,\n                    target: address(this),\n                    value: msg.value,\n                    allowFailure: false,\n                    call: call\n                });\n                IMagnetar(payable(msg_.removeParams.magnetar)).burst{value: msg.value}(magnetarCall);\n            }\n        }\n\n        emit RemoveCollateralReceived(\n            msg_.user, msg_.removeParams.market, msg_.removeParams.amount, msg_.withdrawParams.withdraw\n        );\n    }\n\n    function _checkWhitelistStatus(address _addr) private view {\n        if (_addr != address(0)) {\n            if (!cluster.isWhitelisted(0, _addr)) {\n                revert TOFTMarketReceiverModule_NotAuthorized(_addr);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/SGLCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {ISingularity, IMarket} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {SGLStorage} from \"./SGLStorage.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLCommon is SGLStorage {\n    using RebaseLibrary for Rebase;\n    using SafeCast for uint256;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error TooMuch();\n    error MinLimit();\n    error TransferFailed();\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() external {\n        _accrue();\n    }\n\n    function getInterestDetails()\n        external\n        view\n        returns (ISingularity.AccrueInfo memory _accrueInfo, uint256 utilization)\n    {\n        (_accrueInfo,,,,, utilization,) = _getInterestRate();\n    }\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _getInterestRate()\n        internal\n        view\n        returns (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256 feeFraction,\n            uint256 utilization,\n            bool logStartingInterest\n        )\n    {\n        _accrueInfo = accrueInfo;\n        _totalBorrow = totalBorrow;\n        _totalAsset = totalAsset;\n        extraAmount = 0;\n        feeFraction = 0;\n        logStartingInterest = false;\n\n        uint256 fullAssetAmount = yieldBox.toAmount(assetId, _totalAsset.elastic, false) + _totalBorrow.elastic;\n\n        utilization =\n            fullAssetAmount == 0 ? 0 : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) / fullAssetAmount;\n\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return (_accrueInfo, totalBorrow, totalAsset, 0, 0, utilization, logStartingInterest);\n        }\n        _accrueInfo.lastAccrued = block.timestamp.toUint64();\n\n        if (_totalBorrow.base == 0) {\n            // If there are no borrows, reset the interest rate\n            if (_accrueInfo.interestPerSecond != startingInterestPerSecond) {\n                _accrueInfo.interestPerSecond = startingInterestPerSecond;\n                logStartingInterest = true;\n            }\n            return (_accrueInfo, _totalBorrow, totalAsset, 0, 0, utilization, logStartingInterest);\n        }\n\n        // Accrue interest\n        extraAmount = (uint256(_totalBorrow.elastic) * _accrueInfo.interestPerSecond * elapsedTime) / 1e18;\n        _totalBorrow.elastic += extraAmount.toUint128();\n\n        //take accrued values into account\n        fullAssetAmount = yieldBox.toAmount(assetId, _totalAsset.elastic, false) + _totalBorrow.elastic;\n\n        uint256 feeAmount = (extraAmount * protocolFee) / FEE_PRECISION; // % of interest paid goes to fee\n        feeFraction = (feeAmount * _totalAsset.base) / (fullAssetAmount - feeAmount);\n        _accrueInfo.feesEarnedFraction += feeFraction.toUint128();\n        _totalAsset.base = _totalAsset.base + feeFraction.toUint128();\n\n        utilization =\n            fullAssetAmount == 0 ? 0 : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) / fullAssetAmount;\n\n        // Update interest rate\n        if (utilization < minimumTargetUtilization) {\n            uint256 underFactor =\n                ((minimumTargetUtilization - utilization) * FACTOR_PRECISION) / minimumTargetUtilization;\n            uint256 scale = interestElasticity + (underFactor * underFactor * elapsedTime);\n            _accrueInfo.interestPerSecond =\n                ((uint256(_accrueInfo.interestPerSecond) * interestElasticity) / scale).toUint64();\n            if (_accrueInfo.interestPerSecond < minimumInterestPerSecond) {\n                _accrueInfo.interestPerSecond = minimumInterestPerSecond; // 0.25% APR minimum\n            }\n        } else if (utilization > maximumTargetUtilization) {\n            uint256 overFactor = ((utilization - maximumTargetUtilization) * FACTOR_PRECISION) / fullUtilizationMinusMax;\n            uint256 scale = interestElasticity + (overFactor * overFactor * elapsedTime);\n            uint256 newInterestPerSecond = (uint256(_accrueInfo.interestPerSecond) * scale) / interestElasticity;\n            if (newInterestPerSecond > maximumInterestPerSecond) {\n                newInterestPerSecond = maximumInterestPerSecond; // 1000% APR maximum\n            }\n            _accrueInfo.interestPerSecond = newInterestPerSecond.toUint64();\n        }\n    }\n\n    function _accrueView() internal view override returns (Rebase memory _totalBorrow) {\n        (, _totalBorrow,,,,,) = _getInterestRate();\n    }\n\n    function _accrue() internal override {\n        (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256 feeFraction,\n            uint256 utilization,\n            bool logStartingInterest\n        ) = _getInterestRate();\n\n        if (logStartingInterest) {\n            emit LogAccrue(0, 0, startingInterestPerSecond, 0);\n        } else {\n            emit LogAccrue(extraAmount, feeFraction, _accrueInfo.interestPerSecond, utilization);\n        }\n        accrueInfo = _accrueInfo;\n        totalBorrow = _totalBorrow;\n        totalAsset = _totalAsset;\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param from Account to debit tokens from, in `yieldBox`.\n    /// @param _assetId The ERC-20 token asset ID in yieldBox.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    function _addTokens(address from, address, uint256 _assetId, uint256 share, uint256 total, bool skim) internal {\n        if (skim) {\n            if (share > yieldBox.balanceOf(address(this), _assetId) - total) {\n                revert TooMuch();\n            }\n        } else {\n            // yieldBox.transfer(from, address(this), _assetId, share);\n            bool isErr = pearlmit.transferFromERC1155(from, address(this), address(yieldBox), _assetId, share);\n            if (isErr) {\n                revert TransferFailed();\n            }\n        }\n    }\n\n    /// @dev Concrete implementation of `addAsset`.\n    function _addAsset(address from, address to, bool skim, uint256 share) internal returns (uint256 fraction) {\n        Rebase memory _totalAsset = totalAsset;\n        uint256 totalAssetShare = _totalAsset.elastic;\n        uint256 allShare = _totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, true);\n        fraction = allShare == 0 ? share : (share * _totalAsset.base) / allShare;\n        if (_totalAsset.base + fraction.toUint128() < 1000) {\n            return 0;\n        }\n        totalAsset = _totalAsset.add(share, fraction);\n\n        balanceOf[to] += fraction;\n        emit Transfer(address(0), to, fraction);\n\n        _addTokens(from, to, assetId, share, totalAssetShare, skim);\n        emit LogAddAsset(skim ? address(yieldBox) : from, to, share, fraction);\n    }\n\n    /// @dev Concrete implementation of `removeAsset`.\n    /// @param from The account to remove from. Should always be msg.sender except for `depositFeesToyieldBox()`.\n    function _removeAsset(address from, address to, uint256 fraction) internal returns (uint256 share) {\n        if (totalAsset.base == 0) {\n            return 0;\n        }\n        Rebase memory _totalAsset = totalAsset;\n        uint256 allShare = _totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, false);\n        share = (fraction * allShare) / _totalAsset.base;\n\n        _totalAsset.base -= fraction.toUint128();\n        if (_totalAsset.base < 1000) revert MinLimit();\n\n        balanceOf[from] -= fraction;\n        emit Transfer(from, address(0), fraction);\n        _totalAsset.elastic -= share.toUint128();\n        totalAsset = _totalAsset;\n        emit LogRemoveAsset(from, to, share, fraction);\n        yieldBox.transfer(address(this), to, assetId, share);\n    }\n\n    /// @dev Return the equivalent of collateral borrow part in asset amount.\n    function _getAmountForBorrowPart(uint256 borrowPart) internal view returns (uint256) {\n        return totalBorrow.toElastic(borrowPart, false);\n    }\n\n    function _isWhitelisted(uint16 _chainId, address _contract) internal view returns (bool) {\n        return ICluster(penrose.cluster()).isWhitelisted(_chainId, _contract);\n    }\n\n    struct _ViewLiquidationStruct {\n        address user;\n        uint256 maxBorrowPart;\n        uint256 minLiquidationBonus;\n        uint256 exchangeRate;\n        IYieldBox yieldBox;\n        uint256 collateralId;\n        uint256 userCollateralShare;\n        uint256 userBorrowPart;\n        Rebase totalBorrow;\n        uint256 liquidationBonusAmount;\n        uint256 liquidationCollateralizationRate;\n        uint256 liquidationMultiplier;\n        uint256 exchangeRatePrecision;\n        uint256 feeDecimalsPrecision;\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {IBigBang} from \"tapioca-periph/interfaces/bar/IBigBang.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBStorage} from \"./BBStorage.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBCommon is BBStorage {\n    using RebaseLibrary for Rebase;\n    using SafeCast for uint256;\n    using SafeApprove for address;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error NotEnough();\n    error TransferFailed();\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns total market debt\n    function getTotalDebt() external view returns (uint256) {\n        return totalBorrow.elastic;\n    }\n\n    /// @notice returns the current debt rate\n    function getDebtRate() public view returns (uint256) {\n        if (isMainMarket) return penrose.bigBangEthDebtRate(); // default 0.5%\n        if (totalBorrow.elastic == 0) return minDebtRate;\n\n        uint256 _ethMarketTotalDebt = IBigBang(penrose.bigBangEthMarket()).getTotalDebt();\n        uint256 _currentDebt = totalBorrow.elastic;\n        uint256 _maxDebtPoint = (_ethMarketTotalDebt * debtRateAgainstEthMarket) / 1e18;\n\n        if (_currentDebt >= _maxDebtPoint) return maxDebtRate;\n\n        uint256 debtPercentage = (_currentDebt * DEBT_PRECISION) / _maxDebtPoint;\n        uint256 debt = ((maxDebtRate - minDebtRate) * debtPercentage) / DEBT_PRECISION + minDebtRate;\n\n        if (debt > maxDebtRate) return maxDebtRate;\n\n        return debt;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() external {\n        _accrue();\n    }\n\n    function _accrueView() internal view override returns (Rebase memory _totalBorrow) {\n        uint256 elapsedTime = block.timestamp - accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return totalBorrow;\n        }\n\n        // Calculate fees\n        _totalBorrow = totalBorrow;\n        uint256 extraAmount = (uint256(_totalBorrow.elastic) * (getDebtRate() / 31536000) * elapsedTime) / 1e18;\n        uint256 max = type(uint128).max - totalBorrowCap;\n\n        if (extraAmount > max) {\n            extraAmount = max;\n        }\n        _totalBorrow.elastic += extraAmount.toUint128();\n    }\n\n    function _accrue() internal override {\n        IBigBang.AccrueInfo memory _accrueInfo = accrueInfo;\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return;\n        }\n        //update debt rate\n        uint256 annumDebtRate = getDebtRate();\n        _accrueInfo.debtRate = (annumDebtRate / 31557600).toUint64(); //per second; account for leap years\n        _accrueInfo.lastAccrued = block.timestamp.toUint64();\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        // Calculate fees\n        uint256 extraAmount = 0;\n        extraAmount = (uint256(_totalBorrow.elastic) * _accrueInfo.debtRate * elapsedTime) / 1e18;\n\n        // cap `extraAmount` to avoid overflow risk when converting it from uint256 to uint128\n        uint256 max = type(uint128).max - totalBorrowCap;\n\n        if (extraAmount > max) {\n            extraAmount = max;\n        }\n        _totalBorrow.elastic += extraAmount.toUint128();\n\n        totalBorrow = _totalBorrow;\n        accrueInfo = _accrueInfo;\n\n        emit LogAccrue(extraAmount, _accrueInfo.debtRate);\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param from Account to debit tokens from, in `yieldBox`.\n    /// @param _tokenId The ERC-20 token asset ID in yieldBox.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    function _addTokens(address from, uint256 _tokenId, uint256 share, uint256 total, bool skim) internal {\n        if (skim) {\n            require(share <= yieldBox.balanceOf(address(this), _tokenId) - total, \"BB: too much\");\n        } else {\n            // yieldBox.transfer(from, address(this), _tokenId, share);\n            bool isErr = pearlmit.transferFromERC1155(from, address(this), address(yieldBox), _tokenId, share);\n            if (isErr) {\n                revert TransferFailed();\n            }\n        }\n    }\n\n    /// @notice deposits an amount to YieldBox\n    /// @param token the IERC20 toke"
    }
  ]
}