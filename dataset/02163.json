{
  "Title": "H-2: Vault executes swaps without slippage protection",
  "Content": "# Issue H-2: Vault executes swaps without slippage protection \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/64 \n\n## Found by \nBauer, Jeiwan, Ruhum, nobody2018, hyh, immeas, Bobface, Nyx, cergyk\n\n## Summary\nThe vault executes swaps without slippage protection. That will cause a loss of funds because of sandwich attacks.\n\n## Vulnerability Detail\nBoth in `Vault.claimTokens()` and `MainVault.withdrawRewards()` swaps are executed through the Swaps library. It calculates the slippage parameters itself which doesn't work. Slippage calculations (min out) have to be calculated *outside* of the swap transaction. Otherwise, it uses the already modified pool values to calculate the min out value.\n\n## Impact\nSwaps will be sandwiched causing a loss of funds for users you withdraw their rewards.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/libraries/Swap.sol#L60-L97\n```sol\n  /// @notice Swap tokens on Uniswap\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\n  /// @param _uniswap Address of uniswapRouter, uniswapQuoter and poolfee\n  /// @return Amountout Number of tokens received\n  function swapTokensMulti(\n    SwapInOut memory _swap,\n    IController.UniswapParams memory _uniswap,\n    bool _rewardSwap\n  ) public returns (uint256) {\n    IERC20(_swap.tokenIn).safeIncreaseAllowance(_uniswap.router, _swap.amount);\n\n    uint256 amountOutMinimum = IQuoter(_uniswap.quoter).quoteExactInput(\n      abi.encodePacked(_swap.tokenIn, _uniswap.poolFee, WETH, _uniswap.poolFee, _swap.tokenOut),\n      _swap.amount\n    );\n\n    uint256 balanceBefore = IERC20(_swap.tokenOut).balanceOf(address(this));\n    if (_rewardSwap && balanceBefore > amountOutMinimum) return amountOutMinimum;\n\n    ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\n      path: abi.encodePacked(\n        _swap.tokenIn,\n        _uniswap.poolFee,\n        WETH,\n        _uniswap.poolFee,\n        _swap.tokenOut\n      ),\n      recipient: address(this),\n      deadline: block.timestamp,\n      amountIn: _swap.amount,\n      amountOutMinimum: amountOutMinimum\n    });\n\n    ISwapRouter(_uniswap.router).exactInput(params);\n    uint256 balanceAfter = IERC20(_swap.tokenOut).balanceOf(address(this));\n\n    return balanceAfter - balanceBefore;\n  }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nSlippage parameters should be included in the tx's calldata and passed to the Swap library.\n\n## Discussion\n\n**sjoerdsommen**\n\nduplicate with #157 and #48\n\n\n\n\n\n## Discussion\n\n**sjoerdsommen**\n\nduplicate with #157 and #48\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/libraries/Swap.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"../Interfaces/IController.sol\";\r\n\r\nimport \"../Interfaces/ExternalInterfaces/ISwapRouter.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IUniswapV3Factory.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IUniswapV3Pool.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IStableSwap3Pool.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IWETH.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IQuoter.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\nlibrary Swap {\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct SwapInOut {\r\n    uint256 amount;\r\n    address tokenIn;\r\n    address tokenOut;\r\n  }\r\n\r\n  address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n  uint256 internal constant gasUsedForSwap = 210000;\r\n\r\n  /// @notice Swap stable coins on Curve\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _tokenInUScale Scale of tokenIn e.g 1E6\r\n  /// @param _tokenOutUScale Scale of tokenOut e.g 1E6\r\n  /// @param _curve Curve pool index number of TokenIn address, tokenOut address, pool address and pool fee\r\n  function swapStableCoins(\r\n    SwapInOut memory _swap,\r\n    uint256 _tokenInUScale,\r\n    uint256 _tokenOutUScale,\r\n    IController.CurveParams memory _curve\r\n  ) public returns (uint256) {\r\n    uint256 amountOutMin = (((_swap.amount * (10000 - _curve.poolFee)) / 10000) * _tokenOutUScale) /\r\n      _tokenInUScale;\r\n    IERC20(_swap.tokenIn).safeIncreaseAllowance(_curve.pool, _swap.amount);\r\n\r\n    uint256 balanceBefore = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n\r\n    IStableSwap3Pool(_curve.pool).exchange(\r\n      _curve.indexTokenIn,\r\n      _curve.indexTokenOut,\r\n      _swap.amount,\r\n      amountOutMin\r\n    );\r\n\r\n    uint256 balanceAfter = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n\r\n    return balanceAfter - balanceBefore;\r\n  }\r\n\r\n  /// @notice Swap tokens on Uniswap\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _uniswap Address of uniswapRouter, uniswapQuoter and poolfee\r\n  /// @return Amountout Number of tokens received\r\n  function swapTokensMulti(\r\n    SwapInOut memory _swap,\r\n    IController.UniswapParams memory _uniswap,\r\n    bool _rewardSwap\r\n  ) public returns (uint256) {\r\n    IERC20(_swap.tokenIn).safeIncreaseAllowance(_uniswap.router, _swap.amount);\r\n\r\n    uint256 amountOutMinimum = IQuoter(_uniswap.quoter).quoteExactInput(\r\n      abi.encodePacked(_swap.tokenIn, _uniswap.poolFee, WETH, _uniswap.poolFee, _swap.tokenOut),\r\n      _swap.amount\r\n    );\r\n\r\n    uint256 balanceBefore = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n    if (_rewardSwap && balanceBefore > amountOutMinimum) return amountOutMinimum;\r\n\r\n    ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\r\n      path: abi.encodePacked(\r\n        _swap.tokenIn,\r\n        _uniswap.poolFee,\r\n        WETH,\r\n        _uniswap.poolFee,\r\n        _swap.tokenOut\r\n      ),\r\n      recipient: address(this),\r\n      deadline: block.timestamp,\r\n      amountIn: _swap.amount,\r\n      amountOutMinimum: amountOutMinimum\r\n    });\r\n\r\n    ISwapRouter(_uniswap.router).exactInput(params);\r\n    uint256 balanceAfter = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n\r\n    return balanceAfter - balanceBefore;\r\n  }\r\n\r\n  /// @notice Swap tokens on Uniswap Multi route\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _uniswapQuoter Address of uniswapQuoter\r\n  /// @param _poolFee Current uniswap pool fee set in router e.g 3000\r\n  /// @return amountOutMin minimum amount out of tokens to receive when executing swap\r\n  function amountOutMultiSwap(\r\n    SwapInOut memory _swap,\r\n    address _uniswapQuoter,\r\n    uint24 _poolFee\r\n  ) public returns (uint256) {\r\n    return\r\n      IQuoter(_uniswapQuoter).quoteExactInput(\r\n        abi.encodePacked(_swap.tokenIn, _poolFee, WETH, _poolFee, _swap.tokenOut),\r\n        _swap.amount\r\n      );\r\n  }\r\n}"
    }
  ]
}