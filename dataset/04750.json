{
  "Title": "[M-02] Users can front run the signature of the paymaster operation leading to some problems",
  "Content": "\nThe paymaster is an extension of the eip-4337, normally the paymaster is willing to pay a user transaction if the account can return the amount of gas at the final of the transaction.\n\nIn the context of the coinbase smart wallet, the paymaster is the contract call magicSpend.sol, This contract exposes the normal function needed to be a paymaster:\n\n    function validatePaymasterUserOp\n        (PackedUserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\n        external returns (bytes memory context, uint256 validationData);\n\n    function postOp\n        (PostOpMode mode, bytes calldata context, uint256 actualGasCost, uint256 actualUserOpFeePerGas)\n        external;\n\nThe magic spend is also implementing the entry point deposit, unlock and withdraw functions as required.\n\nAddionally of this the magicSpend is implementing a withdraw functions for users:\n\n    file:https://src/MagicSpend/MagicSpend.sol#L181\n     function withdraw(WithdrawRequest memory withdrawRequest) external {\n            _validateRequest(msg.sender, withdrawRequest);\n\n            if (!isValidWithdrawSignature(msg.sender, withdrawRequest)) {\n                revert InvalidSignature();\n            }\n\n            if (block.timestamp > withdrawRequest.expiry) {\n                revert Expired();\n            }\n\n            // reserve funds for gas, will credit user with difference in post op\n            _withdraw(withdrawRequest.asset, msg.sender, withdrawRequest.amount);\n        }\n\n[Link](https://github.com/code-423n4/2024-03-coinbase/blob/e0573369b865d47fed778de00a7b6df65ab1744e/src/MagicSpend/MagicSpend.sol#L181)\n\nThe problem is that [validatePaymasterUserOp](https://github.com/code-423n4/2024-03-coinbase/blob/e0573369b865d47fed778de00a7b6df65ab1744e/src/MagicSpend/MagicSpend.sol#L109) is consuming the same signature of the withdraw function, so user can request a transaction through the paymaster, then front runt this transaction calling the withdraw function in the magicSpend (as you notice this transaction is not being processed through the bundler so user can get this withdraw transaction first if he send the correct amount of gas to be included first) making the validatePaymasterUserOp revert because the nonce was already consumed.\n\n### Impact\n\n`Are there any griefing attacks that could cause this paymaster to be banned by bundlers?`\n\n1.  Paymaster can be banned by bundlers because the user can trigger revert transactions which is one of the reason because bundlers can ban paymasters.\n\nI consider that this has to be another vulnerability, but I decided to put it here because the main problem is the same.\n\n2.  Paymaster can be drained if user front runs the signature given to pay an operation, withdrawing directly funds in the withdraw function, user can do this repeated times until the Paymaster is completely drained.\n\n### Proof of Concept\n\nRun this test in `file:/test/MagicSpend/Withdraw.t.sol` :\n\n```\n\n    function test_frontRuning() public {  //@audit POC HIGH 1\n        MagicSpend.WithdrawRequest memory WithdrawRequest = MagicSpend.WithdrawRequest({\n            asset: asset,\n            amount: amount, \n            nonce: nonce,\n            expiry: expiry,\n            signature: _getSignature()\n        });\n\n        UserOperation memory userOp = UserOperation({\n            sender: withdrawer,\n            nonce: 0,\n            initCode: \"\",\n            callData: \"\",\n            callGasLimit: 49152,\n            verificationGasLimit: 378989,\n            preVerificationGas: 273196043,\n            maxFeePerGas: 1000304,\n            maxPriorityFeePerGas: 1000000,\n            paymasterAndData: abi.encodePacked(address(magic), abi.encode(WithdrawRequest)),\n            signature: \"\"\n        });\n\n        magic.withdraw(WithdrawRequest); //Front runing the validatePaymasterUserOp operation\n\n        bytes32 userOpHash = sha256(\"hi\");\n        uint256 maxCost = amount - 10;\n\n        vm.expectRevert();\n        magic.validatePaymasterUserOp(userOp, userOpHash, maxCost);\n    }\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nConsider adding another signer for the withdraw function different from the validatePaymasterUserOp signer.\n\n**[wilsoncusack (Coinbase) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2024-03-coinbase-findings/issues/39#issuecomment-2020737885):**\n > To be clear, the same signature cannot be used twice. The front run is interesting: requires a user to submit a userOp with the withdraw signature in `paymasterAndData`, and then call from their SCW (via another user op or direct call from an EOA owner) and directly call withdraw. There's a race condition here, but it could indeed hurt the paymaster's reputation if pulled off. \n\n**[3docSec (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-03-coinbase-findings/issues/39#issuecomment-2022177047):**\n > Because the front-run signature would DoS the second one, tokens would be spent only once (invalidating point #2 of the impact), so it looks more like a grieving attack on the MS reputation with no tokens at risk => medium seems more appropriate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-coinbase",
  "Code": [
    {
      "filename": "src/MagicSpend/MagicSpend.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SignatureCheckerLib} from \"solady/utils/SignatureCheckerLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {UserOperation} from \"account-abstraction/interfaces/UserOperation.sol\";\nimport {IPaymaster} from \"account-abstraction/interfaces/IPaymaster.sol\";\nimport {IEntryPoint} from \"account-abstraction/interfaces/IEntryPoint.sol\";\n\n/// @title Magic Spend\n///\n/// @author Coinbase (https://github.com/coinbase/magic-spend)\n///\n/// @notice ERC4337 Paymaster implementation compatible with Entrypoint v0.6.\n///\n/// @dev See https://eips.ethereum.org/EIPS/eip-4337#extension-paymasters.\ncontract MagicSpend is Ownable, IPaymaster {\n    /// @notice Signed withdraw request allowing accounts to withdraw funds from this contract.\n    struct WithdrawRequest {\n        /// @dev The signature associated with this withdraw request.\n        bytes signature;\n        /// @dev The asset to withdraw. NOTE: Only ETH (associated with zero address) is supported for now.\n        address asset;\n        /// @dev The requested amount to withdraw.\n        uint256 amount;\n        /// @dev Unique nonce used to prevent replays.\n        uint256 nonce;\n        /// @dev The maximum expiry the withdraw request remains valid for.\n        uint48 expiry;\n    }\n\n    /// @notice Track the ETH available to be withdrawn per user.\n    mapping(address user => uint256 amount) internal _withdrawableETH;\n\n    /// @dev Mappings keeping track of already used nonces per user to prevent replays of withdraw requests.\n    mapping(uint256 nonce => mapping(address user => bool used)) internal _nonceUsed;\n\n    /// @notice Emitted after validating a withdraw request and funds are about to be withdrawn.\n    ///\n    /// @param account The account address.\n    /// @param asset   The asset withdrawn.\n    /// @param amount  The amount withdrawn.\n    /// @param nonce   The request nonce.\n    event MagicSpendWithdrawal(address indexed account, address indexed asset, uint256 amount, uint256 nonce);\n\n    /// @notice Thrown when the withdraw request signature is invalid.\n    ///\n    /// @dev The withdraw request signature MUST be:\n    ///         - an ECDSA signature following EIP-191 (version 0x45)\n    ///         - performed over the content specified in `getHash()`\n    ///         - signed by the current owner of this contract\n    error InvalidSignature();\n\n    /// @notice Thrown when trying to use a withdraw request after its expiry has been reched.\n    error Expired();\n\n    /// @notice Thrown when trying to replay a withdraw request with the same nonce.\n    ///\n    /// @param nonce The already used nonce.\n    error InvalidNonce(uint256 nonce);\n\n    /// @notice Thrown during validation in the context of ERC4337, when the withraw reques amount is insufficient\n    ///         to sponsor the transaction gas.\n    ///\n    /// @param requested The withdraw request amount.\n    /// @param maxCost   The max gas cost required by the Entrypoint.\n    error RequestLessThanGasMaxCost(uint256 requested, uint256 maxCost);\n\n    /// @notice Thrown when the withdraw request asset is not ETH (zero address).\n    ///\n    /// @param asset The requested asset.\n    error UnsupportedPaymasterAsset(address asset);\n\n    /// @notice Thrown during `UserOperation` validation when the current balance is insufficient to cover the\n    ///         requested amount (exluding the `maxGasCost` set by the Entrypoint).\n    ///\n    /// @param requestedAmount The requested amount excluding gas.\n    /// @param balance         The current contract balance.\n    error InsufficientBalance(uint256 requestedAmount, uint256 balance);\n\n    /// @notice Thrown when trying to withdraw funds but nothing is available.\n    error NoExcess();\n\n    /// @notice Thrown in when `postOp()` is called a second time with `PostOpMode.postOpReverted`.\n    ///\n    /// @dev This should only really occur if for unknown reasons the transfer of the withdrwable\n    ///      funds to the user account failed (i.e. this contract's ETH balance is insufficient or\n    ///      the user account refused the funds or ran out of gas on receive).\n    error UnexpectedPostOpRevertedMode();\n\n    /// @dev Requires that the caller is the EntryPoint.\n    modifier onlyEntryPoint() virtual {\n        if (msg.sender != entryPoint()) revert Unauthorized();\n        _;\n    }\n\n    /// @notice Deploy the contract and set its initial owner.\n    ///\n    /// @param _owner The initial owner of this contract.\n    constructor(address _owner) {\n        Ownable._initializeOwner(_owner);\n    }\n\n    /// @notice Receive function allowing ETH to be deposited in this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IPaymaster\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32, uint256 maxCost)\n        external\n        onlyEntryPoint\n        returns (bytes memory context, uint256 validationData)\n    {\n        WithdrawRequest memory withdrawRequest = abi.decode(userOp.paymasterAndData[20:], (WithdrawRequest));\n        uint256 withdrawAmount = withdrawRequest.amount;\n\n        if (withdrawAmount < maxCost) {\n            revert RequestLessThanGasMaxCost(withdrawAmount, maxCost);\n        }\n\n        if (withdrawRequest.asset != address(0)) {\n            revert UnsupportedPaymasterAsset(withdrawRequest.asset);\n        }\n\n        _validateRequest(userOp.sender, withdrawRequest);\n\n        bool sigFailed = !isValidWithdrawSignature(userOp.sender, withdrawRequest);\n        validationData = (sigFailed ? 1 : 0) | (uint256(withdrawRequest.expiry) << 160);\n\n        // Ensure at validation that the contract has enough balance to cover the requested funds.\n        // NOTE: This check is necessary to enforce that the contract will be able to transfer the remaining funds\n        //       when `postOp()` is called back after the `UserOperation` has been executed.\n        if (address(this).balance < withdrawAmount) {\n            revert InsufficientBalance(withdrawAmount, address(this).balance);\n        }\n\n        // NOTE: Do not include the gas part in withdrawable funds as it will be handled in `postOp()`.\n        _withdrawableETH[userOp.sender] += withdrawAmount - maxCost;\n        context = abi.encode(maxCost, userOp.sender);\n    }\n\n    /// @inheritdoc IPaymaster\n    function postOp(IPaymaster.PostOpMode mode, bytes calldata context, uint256 actualGasCost)\n        external\n        onlyEntryPoint\n    {\n        // `PostOpMode.postOpReverted` should be impossible.\n        // Only possible cause would be if this contract does not own enough ETH to transfer\n        // but this is checked at the validation step.\n        assert(mode != PostOpMode.postOpReverted);\n\n        (uint256 maxGasCost, address account) = abi.decode(context, (uint256, address));\n\n        // Compute the total remaining funds available for the user accout.\n        // NOTE: Take into account the user operation gas that was not consummed.\n        uint256 withdrawable = _withdrawableETH[account] + (maxGasCost - actualGasCost);\n\n        // Send the all remaining funds to the user accout.\n        delete _withdrawableETH[account];\n        if (withdrawable > 0) {\n            SafeTransferLib.forceSafeTransferETH(account, withdrawable, SafeTransferLib.GAS_STIPEND_NO_STORAGE_WRITES);\n        }\n    }\n\n    /// @notice Allows the sender to withdraw any available funds associated with him.\n    ///\n    /// @dev Can be called back during the `UserOperation` execution to sponsor funds for non-gas related\n    ///      use cases (e.g., swap or mint).\n    function withdrawGasExcess() external {\n        uint256 amount = _withdrawableETH[msg.sender];\n        // we could allow 0 value transfers, but prefer to be explicit\n        if (amount == 0) revert NoExcess();\n\n        delete _withdrawableETH[msg.sender];\n        _withdraw(address(0), msg.sender, amount);\n    }\n\n    /// @notice Allows caller to withdraw funds by calling with a valid `withdrawRequest`\n    ///\n    /// @param withdrawRequest The withdraw request.\n    function withdraw(WithdrawRequest memory withdrawRequest) external {\n        _validateRequest(msg.sender, withdrawRequest);\n\n        if (!isValidWithdrawSignature(msg.sender, withdrawRequest)) {\n            revert InvalidSignature();\n        }\n\n        if (block.timestamp > withdrawRequest.expiry) {\n            revert Expired();\n        }\n\n        // reserve funds for gas, will credit user with difference in post op\n        _withdraw(withdrawRequest.asset, msg.sender, withdrawRequest.amount);\n    }\n\n    /// @notice Withdraws funds from this contract.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param asset The asset to withdraw.\n    /// @param to The beneficiary address.\n    /// @param amount The amount to withdraw.\n    function ownerWithdraw(address asset, address to, uint256 amount) external onlyOwner {\n        _withdraw(asset, to, amount);\n    }\n\n    /// @notice Deposits ETH from this contract funds into the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param amount The amount to deposit on the the Entrypoint.\n    function entryPointDeposit(uint256 amount) external payable onlyOwner {\n        SafeTransferLib.safeTransferETH(entryPoint(), amount);\n    }\n\n    /// @notice Withdraws ETH from the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param to     The beneficiary address.\n    /// @param amount The amount to withdraw from the Entrypoint.\n    function entryPointWithdraw(address payable to, uint256 amount) external onlyOwner {\n        IEntryPoint(entryPoint()).withdrawTo(to, amount);\n    }\n\n    /// @notice Adds stake to the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param amount              The amount to stake in the Entrypoint.\n    /// @param unstakeDelaySeconds The duration for which the stake cannot be withdrawn.\n    function entryPointAddStake(uint256 amount, uint32 unstakeDelaySeconds) external payable onlyOwner {\n        IEntryPoint(entryPoint()).addStake{value: amount}(unstakeDelaySeconds);\n    }\n\n    /// @notice Unlocks stake in the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    function entryPointUnlockStake() external onlyOwner {\n        IEntryPoint(entryPoint()).unlockStake();\n    }\n\n    /// @notice Withdraws stake from the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param to The beneficiary address.\n    function entryPointWithdrawStake(address payable to) external onlyOwner {\n        IEntryPoint(entryPoint()).withdrawStake(to);\n    }\n\n    /// @notice Returns whether the `withdrawRequest` signature is valid for the given `account`.\n    ///\n    /// @dev Does not validate nonce or expiry.\n    ///\n    /// @param account         The account address.\n    /// @param withdrawRequest The withdraw request.\n    ///\n    /// @return `true` if the signature is valid, else `false`.\n    function isValidWithdrawSignature(address account, WithdrawRequest memory withdrawRequest)\n        public\n        view\n        returns (bool)\n    {\n        return SignatureCheckerLib.isValidSignatureNow(\n            owner(), getHash(account, withdrawRequest), withdrawRequest.signature\n        );\n    }\n\n    /// @notice Returns the hash to be signed for a given `account` and `withdrawRequest` pair.\n    ///\n    /// @dev Returns an EIP-191 compliant Ethereum Signed Message (version 0x45), see\n    ///      https://eips.ethereum.org/EIPS/eip-191.\n    ///\n    /// @param account         The account address.\n    /// @param withdrawRequest The withdraw request.\n    ///\n    /// @return The hash to be signed for the given `account` and `withdrawRequest`.\n    function getHash(address account, WithdrawRequest memory withdrawRequest) public view returns (bytes32) {\n        return SignatureCheckerLib.toEthSignedMessageHash(\n            abi.encode(\n                address(this),\n                account,\n                block.chainid,\n                withdrawRequest.asset,\n                withdrawRequest.amount,\n                withdrawRequest.nonce,\n                withdrawRequest.expiry\n            )\n        );\n    }\n\n    /// @notice Returns whether the `nonce` has been used by the given `account`.\n    ///\n    /// @param account The account address.\n    /// @param nonce   The nonce to check.\n    ///\n    /// @return `true` if the nonce has already been used by the account, else `false`.\n    function nonceUsed(address account, uint256 nonce) external view returns (bool) {\n        return _nonceUsed[nonce][account];\n    }\n\n    /// @notice Returns the canonical ERC-4337 EntryPoint v0.6 contract.\n    function entryPoint() public pure returns (address) {\n        return 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789;\n    }\n\n    /// @notice Validate the `withdrawRequest` against the given `account`.\n    ///\n    /// @dev Runs all non-signature validation checks.\n    /// @dev Reverts if the withdraw request nonce has already been used.\n    ///\n    /// @param account         The account address.\n    /// @param withdrawRequest The withdraw request to validate.\n    function _validateRequest(address account, WithdrawRequest memory withdrawRequest) internal {\n        if (_nonceUsed[withdrawRequest.nonce][account]) {\n            revert InvalidNonce(withdrawRequest.nonce);\n        }\n\n        _nonceUsed[withdrawRequest.nonce][account] = true;\n\n        // This is emitted ahead of fund transfer, but allows a consolidated code path\n        emit MagicSpendWithdrawal(account, withdrawRequest.asset, withdrawRequest.amount, withdrawRequest.nonce);\n    }\n\n    /// @notice Withdraws funds from this contract.\n    ///\n    /// @dev Callers MUST validate that the withdraw is legitimate before calling this method as\n    ///      no validation is performed here.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param to     The beneficiary address.\n    /// @param amount The amount to withdraw.\n    function _withdraw(address asset, address to, uint256 amount) internal {\n        if (asset == address(0)) {\n            SafeTransferLib.safeTransferETH(to, amount);\n        } else {\n            SafeTransferLib.safeTransfer(asset, to, amount);\n        }\n    }\n}"
    },
    {
      "filename": "src/MagicSpend/MagicSpend.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SignatureCheckerLib} from \"solady/utils/SignatureCheckerLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {UserOperation} from \"account-abstraction/interfaces/UserOperation.sol\";\nimport {IPaymaster} from \"account-abstraction/interfaces/IPaymaster.sol\";\nimport {IEntryPoint} from \"account-abstraction/interfaces/IEntryPoint.sol\";\n\n/// @title Magic Spend\n///\n/// @author Coinbase (https://github.com/coinbase/magic-spend)\n///\n/// @notice ERC4337 Paymaster implementation compatible with Entrypoint v0.6.\n///\n/// @dev See https://eips.ethereum.org/EIPS/eip-4337#extension-paymasters.\ncontract MagicSpend is Ownable, IPaymaster {\n    /// @notice Signed withdraw request allowing accounts to withdraw funds from this contract.\n    struct WithdrawRequest {\n        /// @dev The signature associated with this withdraw request.\n        bytes signature;\n        /// @dev The asset to withdraw. NOTE: Only ETH (associated with zero address) is supported for now.\n        address asset;\n        /// @dev The requested amount to withdraw.\n        uint256 amount;\n        /// @dev Unique nonce used to prevent replays.\n        uint256 nonce;\n        /// @dev The maximum expiry the withdraw request remains valid for.\n        uint48 expiry;\n    }\n\n    /// @notice Track the ETH available to be withdrawn per user.\n    mapping(address user => uint256 amount) internal _withdrawableETH;\n\n    /// @dev Mappings keeping track of already used nonces per user to prevent replays of withdraw requests.\n    mapping(uint256 nonce => mapping(address user => bool used)) internal _nonceUsed;\n\n    /// @notice Emitted after validating a withdraw request and funds are about to be withdrawn.\n    ///\n    /// @param account The account address.\n    /// @param asset   The asset withdrawn.\n    /// @param amount  The amount withdrawn.\n    /// @param nonce   The request nonce.\n    event MagicSpendWithdrawal(address indexed account, address indexed asset, uint256 amount, uint256 nonce);\n\n    /// @notice Thrown when the withdraw request signature is invalid.\n    ///\n    /// @dev The withdraw request signature MUST be:\n    ///         - an ECDSA signature following EIP-191 (version 0x45)\n    ///         - performed over the content specified in `getHash()`\n    ///         - signed by the current owner of this contract\n    error InvalidSignature();\n\n    /// @notice Thrown when trying to use a withdraw request after its expiry has been reched.\n    error Expired();\n\n    /// @notice Thrown when trying to replay a withdraw request with the same nonce.\n    ///\n    /// @param nonce The already used nonce.\n    error InvalidNonce(uint256 nonce);\n\n    /// @notice Thrown during validation in the context of ERC4337, when the withraw reques amount is insufficient\n    ///         to sponsor the transaction gas.\n    ///\n    /// @param requested The withdraw request amount.\n    /// @param maxCost   The max gas cost required by the Entrypoint.\n    error RequestLessThanGasMaxCost(uint256 requested, uint256 maxCost);\n\n    /// @notice Thrown when the withdraw request asset is not ETH (zero address).\n    ///\n    /// @param asset The requested asset.\n    error UnsupportedPaymasterAsset(address asset);\n\n    /// @notice Thrown during `UserOperation` validation when the current balance is insufficient to cover the\n    ///         requested amount (exluding the `maxGasCost` set by the Entrypoint).\n    ///\n    /// @param requestedAmount The requested amount excluding gas.\n    /// @param balance         The current contract balance.\n    error InsufficientBalance(uint256 requestedAmount, uint256 balance);\n\n    /// @notice Thrown when trying to withdraw funds but nothing is available.\n    error NoExcess();\n\n    /// @notice Thrown in when `postOp()` is called a second time with `PostOpMode.postOpReverted`.\n    ///\n    /// @dev This should only really occur if for unknown reasons the transfer of the withdrwable\n    ///      funds to the user account failed (i.e. this contract's ETH balance is insufficient or\n    ///      the user account refused the funds or ran out of gas on receive).\n    error UnexpectedPostOpRevertedMode();\n\n    /// @dev Requires that the caller is the EntryPoint.\n    modifier onlyEntryPoint() virtual {\n        if (msg.sender != entryPoint()) revert Unauthorized();\n        _;\n    }\n\n    /// @notice Deploy the contract and set its initial owner.\n    ///\n    /// @param _owner The initial owner of this contract.\n    constructor(address _owner) {\n        Ownable._initializeOwner(_owner);\n    }\n\n    /// @notice Receive function allowing ETH to be deposited in this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IPaymaster\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32, uint256 maxCost)\n        external\n        onlyEntryPoint\n        returns (bytes memory context, uint256 validationData)\n    {\n        WithdrawRequest memory withdrawRequest = abi.decode(userOp.paymasterAndData[20:], (WithdrawRequest));\n        uint256 withdrawAmount = withdrawRequest.amount;\n\n        if (withdrawAmount < maxCost) {\n            revert RequestLessThanGasMaxCost(withdrawAmount, maxCost);\n        }\n\n        if (withdrawRequest.asset != address(0)) {\n            revert UnsupportedPaymasterAsset(withdrawRequest.asset);\n        }\n\n        _validateRequest(userOp.sender, withdrawRequest);\n\n        bool sigFailed = !isValidWithdrawSignature(userOp.sender, withdrawRequest);\n        validationData = (sigFailed ? 1 : 0) | (uint256(withdrawRequest.expiry) << 160);\n\n        // Ensure at validation that the contract has enough balance to cover the requested funds.\n        // NOTE: This check is necessary to enforce that the contract will be able to transfer the remaining funds\n        //       when `postOp()` is called back after the `UserOperation` has been executed.\n        if (address(this).balance < withdrawAmount) {\n            revert InsufficientBalance(withdrawAmount, address(this).balance);\n        }\n\n        // NOTE: Do not include the gas part in withdrawable funds as it will be handled in `postOp()`.\n        _withdrawableETH[userOp.sender] += withdrawAmount - maxCost;\n        context = abi.encode(maxCost, userOp.sender);\n    }\n\n    /// @inheritdoc IPaymaster\n    function postOp(IPaymaster.PostOpMode mode, bytes calldata context, uint256 actualGasCost)\n        external\n        onlyEntryPoint\n    {\n        // `PostOpMode.postOpReverted` should be impossible.\n        // Only possible cause would be if this contract does not own enough ETH to transfer\n        // but this is checked at the validation step.\n        assert(mode != PostOpMode.postOpReverted);\n\n        (uint256 maxGasCost, address account) = abi.decode(context, (uint256, address));\n\n        // Compute the total remaining funds available for the user accout.\n        // NOTE: Take into account the user operation gas that was not consummed.\n        uint256 withdrawable = _withdrawableETH[account] + (maxGasCost - actualGasCost);\n\n        // Send the all remaining funds to the user accout.\n        delete _withdrawableETH[account];\n        if (withdrawable > 0) {\n            SafeTransferLib.forceSafeTransferETH(account, withdrawable, SafeTransferLib.GAS_STIPEND_NO_STORAGE_WRITES);\n        }\n    }\n\n    /// @notice Allows the sender to withdraw any available funds associated with him.\n    ///\n    /// @dev Can be called back during the `UserOperation` execution to sponsor funds for non-gas related\n    ///      use cases (e.g., swap or mint).\n    function withdrawGasExcess() external {\n        uint256 amount = _withdrawableETH[msg.sender];\n        // we could allow 0 value transfers, but prefer to be explicit\n        if (amount == 0) revert NoExcess();\n\n        delete _withdrawableETH[msg.sender];\n        _withdraw(address(0), msg.sender, amount);\n    }\n\n    /// @notice Allows caller to withdraw funds by calling with a valid `withdrawRequest`\n    ///\n    /// @param withdrawRequest The withdraw request.\n    function withdraw(WithdrawRequest memory withdrawRequest) external {\n        _validateRequest(msg.sender, withdrawRequest);\n\n        if (!isValidWithdrawSignature(msg.sender, withdrawRequest)) {\n            revert InvalidSignature();\n        }\n\n        if (block.timestamp > withdrawRequest.expiry) {\n            revert Expired();\n        }\n\n        // reserve funds for gas, will credit user with difference in post op\n        _withdraw(withdrawRequest.asset, msg.sender, withdrawRequest.amount);\n    }\n\n    /// @notice Withdraws funds from this contract.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param asset The asset to withdraw.\n    /// @param to The beneficiary address.\n    /// @param amount The amount to withdraw.\n    function ownerWithdraw(address asset, address to, uint256 amount) external onlyOwner {\n        _withdraw(asset, to, amount);\n    }\n\n    /// @notice Deposits ETH from this contract funds into the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param amount The amount to deposit on the the Entrypoint.\n    function entryPointDeposit(uint256 amount) external payable onlyOwner {\n        SafeTransferLib.safeTransferETH(entryPoint(), amount);\n    }\n\n    /// @notice Withdraws ETH from the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param to     The beneficiary address.\n    /// @param amount The amount to withdraw from the Entrypoint.\n    function entryPointWithdraw(address payable to, uint256 amount) external onlyOwner {\n        IEntryPoint(entryPoint()).withdrawTo(to, amount);\n    }\n\n    /// @notice Adds stake to the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param amount              The amount to stake in the Entrypoint.\n    /// @param unstakeDelaySeconds The duration for which the stake cannot be withdrawn.\n    function entryPointAddStake(uint256 amount, uint32 unstakeDelaySeconds) external payable onlyOwner {\n        IEntryPoint(entryPoint()).addStake{value: amount}(unstakeDelaySeconds);\n    }\n\n    /// @notice Unlocks stake in the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    function entryPointUnlockStake() external onlyOwner {\n        IEntryPoint(entryPoint()).unlockStake();\n    }\n\n    /// @notice Withdraws stake from the EntryPoint.\n    ///\n    /// @dev Reverts if not called by the owner of the contract.\n    ///\n    /// @param to The beneficiary address.\n    function entryPointWithdrawStake(address payable to) external onlyOwner {\n        IEntryPoint(entryPoint()).withdrawStake(to);\n    }\n\n    /// @notice Returns whether the `withdrawRequest` signature is valid for the given `account`.\n    ///\n    /// @dev Does not validate nonce or expiry.\n    ///\n    /// @param account         The account address.\n    /// @param withdrawRequest The withdraw request.\n    ///\n    /// @return `true` if the signature is valid, else `false`.\n    function isValidWithdrawSignature(address account, WithdrawRequest memory withdrawRequest)\n        public\n        view\n        returns (bool)\n    {\n        return SignatureCheckerLib.isValidSignatureNow(\n            owner(), getHash(account, withdrawRequest), withdrawRequest.signature\n        );\n    }\n\n    /// @notice Returns the hash to be signed for a given `account` and `withdrawRequest` pair.\n    ///\n    /// @dev Returns an EIP-191 compliant Ethereum Signed Message (version 0x45), see\n    ///      https://eips.ethereum.org/EIPS/eip-191.\n    ///\n    /// @param account         The account address.\n    /// @param withdrawRequest The withdraw request.\n    ///\n    /// @return The hash to be signed for the given `account` and `withdrawRequest`.\n    function getHash(address account, WithdrawRequest memory withdrawRequest) public view returns (bytes32) {\n        return SignatureCheckerLib.toEthSignedMessageHash(\n            abi.encode(\n                address(this),\n                account,\n                block.chainid,\n                withdrawRequest.asset,\n                withdrawRequest.amount,\n                withdrawRequest.nonce,\n                withdrawRequest.expiry\n            )\n        );\n    }\n\n    /// @notice Returns whether the `nonce` has been used by the given `account`.\n    ///\n    /// @param account The account address.\n    /// @param nonce   The nonce to check.\n    ///\n    /// @return `true` if the nonce has already been used by the account, else `false`.\n    function nonceUsed(address account, uint256 nonce) external view returns (bool) {\n        return _nonceUsed[nonce][account];\n    }\n\n    /// @notice Returns the canonical ERC-4337 EntryPoint v0.6 contract.\n    function entryPoint() public pure returns (address) {\n        return 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789;\n    }\n\n    /// @notice Validate the `withdrawRequest` against the given `account`.\n    ///\n    /// @dev Runs all non-signature validation checks.\n    /// @dev Reverts if the withdraw request nonce has already been used.\n    ///\n    /// @param account         The account address.\n    /// @param withdrawRequest The withdraw request to validate.\n    function _validateRequest(address account, WithdrawRequest memory withdrawRequest) internal {\n        if (_nonceUsed[withdrawRequest.nonce][account]) {\n            revert InvalidNonce(withdrawRequest.nonce);\n        }\n\n        _nonceUsed[withdrawRequest.nonce][account] = true;\n\n        // This is emitted ahead of fund transfer, but allows a consolidated code path\n        emit MagicSpendWithdrawal(account, withdrawRequest.asset, withdrawRequest.amount, withdrawRequest.nonce);\n    }\n\n    /// @notice Withdraws funds from this contract.\n    ///\n    /// @dev Callers MUST validate that the withdraw is legitimate before calling this method as\n    ///      no validation is performed here.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param to     The beneficiary address.\n    /// @param amount The amount to withdraw.\n    function _withdraw(address asset, address to, uint256 amount) internal {\n        if (asset == address(0)) {\n            SafeTransferLib.safeTransferETH(to, amount);\n        } else {\n            SafeTransferLib.safeTransfer(asset, to, amount);\n        }\n    }\n}"
    }
  ]
}