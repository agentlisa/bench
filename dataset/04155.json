{
  "Title": "[M01] Cannot unpause exchange",
  "Content": "The `OneInchExchange.sol` contract exposes [a mechanism](https://github.com/1inch-exchange/1inch-v2-contracts/blob/72f2812837fdd73ec2d32c8988811df361e80985/contracts/OneInchExchange.sol#L179) for the owner to pause the contract. This [disables the `swap` functionality](https://github.com/1inch-exchange/1inch-v2-contracts/blob/72f2812837fdd73ec2d32c8988811df361e80985/contracts/OneInchExchange.sol#L99). However, there is no corresponding mechanism to unpause the contract.\n\n\nConsider introducing a mechanism for the owner to unpause the contract. Alternatively, if the current behavior is expected, consider renaming the `pause` function to `shutdown` or something similar that implies the contract will be permanently disabled.\n\n\n**Update**: *Fixed in [commit 0b89110a](https://github.com/1inch-exchange/1inch-v2-contracts/commit/0b89110ae5cc73c8b3f4baf8f2c4b8b290b1f923). The `pause` function has been renamed to `shutdown`.*\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/OneInchExchange.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"./interfaces/IChi.sol\";\nimport \"./interfaces/IERC20Permit.sol\";\nimport \"./interfaces/IOneInchCaller.sol\";\nimport \"./helpers/RevertReasonParser.sol\";\nimport \"./helpers/UniERC20.sol\";\n\n\ncontract OneInchExchange is Ownable, Pausable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using UniERC20 for IERC20;\n\n    uint256 private constant _PARTIAL_FILL = 0x01;\n    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;\n    uint256 private constant _SHOULD_CLAIM = 0x04;\n    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;\n    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;\n\n    struct SwapDescription {\n        IERC20 srcToken;\n        IERC20 dstToken;\n        address srcReceiver;\n        address dstReceiver;\n        uint256 amount;\n        uint256 minReturnAmount;\n        uint256 guaranteedAmount;\n        uint256 flags;\n        address referrer;\n        bytes permit;\n    }\n\n    event Swapped(\n        address indexed sender,\n        IERC20 indexed srcToken,\n        IERC20 indexed dstToken,\n        address dstReceiver,\n        uint256 amount,\n        uint256 spentAmount,\n        uint256 returnAmount,\n        uint256 minReturnAmount,\n        uint256 guaranteedAmount,\n        address referrer\n    );\n\n    event Error(\n        string reason\n    );\n\n    function discountedSwap(\n        IOneInchCaller caller,\n        SwapDescription calldata desc,\n        IOneInchCaller.CallDescription[] calldata calls\n    )\n        external\n        payable\n        returns (uint256 returnAmount)\n    {\n        uint256 initialGas = gasleft();\n\n        address chiSource = address(0);\n        if (desc.flags & _BURN_FROM_MSG_SENDER != 0) {\n            chiSource = msg.sender;\n        } else if (desc.flags & _BURN_FROM_TX_ORIGIN != 0) {\n            chiSource = tx.origin; // solhint-disable-line avoid-tx-origin\n        } else {\n            revert(\"Incorrect CHI burn flags\");\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory data) = address(this).delegatecall(abi.encodeWithSelector(this.swap.selector, caller, desc, calls));\n        if (success) {\n            returnAmount = abi.decode(data, (uint256));\n        } else {\n            if (msg.value > 0) {\n                msg.sender.transfer(msg.value);\n            }\n            emit Error(RevertReasonParser.parse(data, \"Swap failed: \"));\n        }\n\n        (IChi chi, uint256 amount) = caller.calculateGas(initialGas.sub(gasleft()), desc.flags, msg.data.length);\n        chi.freeFromUpTo(chiSource, amount);\n    }\n\n    function swap(\n        IOneInchCaller caller,\n        SwapDescription calldata desc,\n        IOneInchCaller.CallDescription[] calldata calls\n    )\n        external\n        payable\n        whenNotPaused\n        returns (uint256 returnAmount)\n    {\n        require(desc.minReturnAmount > 0, \"Min return should not be 0\");\n        require(calls.length > 0, \"Call data should exist\");\n\n        uint256 flags = desc.flags;\n        IERC20 srcToken = desc.srcToken;\n        IERC20 dstToken = desc.dstToken;\n\n        if (flags & _REQUIRES_EXTRA_ETH != 0) {\n            require(msg.value > (srcToken.isETH() ? desc.amount : 0), \"Invalid msg.value\");\n        } else {\n            require(msg.value == (srcToken.isETH() ? desc.amount : 0), \"Invalid msg.value\");\n        }\n\n        if (flags & _SHOULD_CLAIM != 0) {\n            require(!srcToken.isETH(), \"Claim token is ETH\");\n            _claim(srcToken, desc.srcReceiver, desc.amount, desc.permit);\n        }\n\n        address dstReceiver = (desc.dstReceiver == address(0)) ? msg.sender : desc.dstReceiver;\n        uint256 initialSrcBalance = (flags & _PARTIAL_FILL != 0) ? srcToken.uniBalanceOf(msg.sender) : 0;\n        uint256 initialDstBalance = dstToken.uniBalanceOf(dstReceiver);\n\n        caller.makeCalls{value: msg.value}(calls);\n\n        uint256 spentAmount = desc.amount;\n        returnAmount = dstToken.uniBalanceOf(dstReceiver).sub(initialDstBalance);\n\n        if (flags & _PARTIAL_FILL != 0) {\n            spentAmount = initialSrcBalance.add(desc.amount).sub(srcToken.uniBalanceOf(msg.sender));\n            require(returnAmount.mul(desc.amount) >= desc.minReturnAmount.mul(spentAmount), \"Return amount is not enough\");\n        } else {\n            require(returnAmount >= desc.minReturnAmount, \"Return amount is not enough\");\n        }\n\n        _emitSwapped(desc, srcToken, dstToken, dstReceiver, spentAmount, returnAmount);\n    }\n\n    function _emitSwapped(\n        SwapDescription calldata desc,\n        IERC20 srcToken,\n        IERC20 dstToken,\n        address dstReceiver,\n        uint256 spentAmount,\n        uint256 returnAmount\n     ) private {\n        emit Swapped(\n            msg.sender,\n            srcToken,\n            dstToken,\n            dstReceiver,\n            desc.amount,\n            spentAmount,\n            returnAmount,\n            desc.minReturnAmount,\n            desc.guaranteedAmount,\n            desc.referrer\n        );\n    }\n\n    function _claim(IERC20 token, address dst, uint256 amount, bytes calldata permit) private {\n        // TODO: Is it safe to call permit on tokens without implemented permit? Fallback will be called. Is it bad for proxies?\n\n        if (permit.length == 32 * 7) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory result) = address(token).call(abi.encodeWithSelector(IERC20Permit.permit.selector, permit));\n            if (!success) {\n                revert(RevertReasonParser.parse(result, \"Permit call failed: \"));\n            }\n        }\n\n        token.safeTransferFrom(msg.sender, dst, amount);\n    }\n\n    function rescueFunds(IERC20 token, uint256 amount) external onlyOwner {\n        token.uniTransfer(msg.sender, amount);\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n}"
    }
  ]
}