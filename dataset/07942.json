{
  "Title": "[H-02] Frontrunning by malicious validator",
  "Content": "_Submitted by parashar_\n\nFrontrunning by malicious validator changing withdrawal credentials.\n\n### Proof of Concept\n\nA malicious validator can frontrun depositEther transaction for its pubKey and deposit 1 ether for different withdrawal credential, thereby setting withdrawal credit before deposit of 32 ether by contract and thereby when 32 deposit ether are deposited, the withdrawal credential is also what was set before rather than the one being sent in depositEther transaction.\n\n### Recommended Mitigation Steps\n\nSet withdrawal credentials for validator by depositing 1 ether with desired withdrawal credentials, before adding it in Operator Registry.\n\n**[FortisFortuna (Frax) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/81#issuecomment-1257288417):**\n > Interesting point, but at the beginning, the only validators we will have will be Frax controlled.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/81#issuecomment-1276523610):**\n > ```\n> \n>     function deposit(\n>         bytes calldata pubkey,\n>         bytes calldata withdrawal_credentials,\n>         bytes calldata signature,\n>         bytes32 deposit_data_root\n>     ) override external payable {\n>         // Extended ABI length checks since dynamic types are used.\n>         require(pubkey.length == 48, \"DepositContract: invalid pubkey length\");\n>         require(withdrawal_credentials.length == 32, \"DepositContract: invalid withdrawal_credentials length\");\n>         require(signature.length == 96, \"DepositContract: invalid signature length\");\n> \n>         // Check deposit amount\n>         require(msg.value >= 1 ether, \"DepositContract: deposit value too low\");\n>         require(msg.value % 1 gwei == 0, \"DepositContract: deposit value not multiple of gwei\");\n>         uint deposit_amount = msg.value / 1 gwei;\n>         require(deposit_amount <= type(uint64).max, \"DepositContract: deposit value too high\");\n> \n>         // Emit `DepositEvent` log\n>         bytes memory amount = to_little_endian_64(uint64(deposit_amount));\n>         emit DepositEvent(\n>             pubkey,\n>             withdrawal_credentials,\n>             amount,\n>             signature,\n>             to_little_endian_64(uint64(deposit_count))\n>         );\n> \n>         // Compute deposit data root (`DepositData` hash tree root)\n>         bytes32 pubkey_root = sha256(abi.encodePacked(pubkey, bytes16(0)));\n>         bytes32 signature_root = sha256(abi.encodePacked(\n>             sha256(abi.encodePacked(signature[:64])),\n>             sha256(abi.encodePacked(signature[64:], bytes32(0)))\n>         ));\n>         bytes32 node = sha256(abi.encodePacked(\n>             sha256(abi.encodePacked(pubkey_root, withdrawal_credentials)),\n>             sha256(abi.encodePacked(amount, bytes24(0), signature_root))\n>         ));\n> \n>         // Verify computed and expected deposit data roots match\n>         require(node == deposit_data_root, \"DepositContract: reconstructed DepositData does not match supplied deposit_data_root\");\n> \n>         // Avoid overflowing the Merkle tree (and prevent edge case in computing `branch`)\n>         require(deposit_count < MAX_DEPOSIT_COUNT, \"DepositContract: merkle tree full\");\n> \n>         // Add deposit data root to Merkle tree (update a single `branch` node)\n>         deposit_count += 1;\n>         uint size = deposit_count;\n>         for (uint height = 0; height < DEPOSIT_CONTRACT_TREE_DEPTH; height++) {\n>             if ((size & 1) == 1) {\n>                 branch[height] = node;\n>                 return;\n>             }\n>             node = sha256(abi.encodePacked(branch[height], node));\n>             size /= 2;\n>         }\n>         // As the loop should always end prematurely with the `return` statement,\n>         // this code should be unreachable. We assert `false` just to be safe.\n>         assert(false);\n>     }\n> \n> ```\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/81#issuecomment-1276529987):**\n > It is unclear both in the code above for the deposit contract as well as the documentation on keys \n> \n> https://kb.beaconcha.in/ethereum-2.0-depositing<br>\n> https://kb.beaconcha.in/ethereum-2-keys<br>\n> \n> How exactly multiple deposits two the same validator using different withdrawal keys would work.  While it would make sense that they would allow a one to many mapping, I am unable to confirm or deny this and therefore will leave the risk currently as High on the side of caution.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/81#issuecomment-1279846360):**\n > Strong find. Indeed in ETH [specs](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#deposits) we can see that in `process_deposit()`, if the pubkey is already registered, we just increase its balance, not touching the withdrawal_credentials. However the recommended mitigation does not really address the issue IMO, and the detail is quite lacking.\n\n**[FortisFortuna (Frax) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/81#issuecomment-1280004724):**\n > I think it is technically a non-issue because we will be controlling the addition/removal of validators. Should that eventually become open, we will have to look at the entire code from a different perspective to close security holes.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/81#issuecomment-1280006325):**\n > I think it is relevant, because the idea is to make the protocol controlled validators work for the attacker, because they inserted their own withdrawal credentials directly on the deposit contract.\n\n**[FortisFortuna (Frax) confirmed and commented](https://github.com/code-423n4/2022-09-frax-findings/issues/81#issuecomment-1280006573):**\n > Ohh I see it now. Good point.\n >\n > More info<br>\n> https://research.lido.fi/t/mitigations-for-deposit-front-running-vulnerability/1239\n>\n > Since all of the validators are ours and we have the mnemonic, would it still be an issue though? Lido's setup is different: https://medium.com/immunefi/rocketpool-lido-frontrunning-bug-fix-postmortem-e701f26d7971\n\n**[FortisFortuna (Frax) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/81#issuecomment-1280063425):**\n > https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#deposits<br>\n> From @0xJM<br>\n> In the scenario that someone frontruns us with a 1 ETH deposit at the same time we do a 32 ETH deposit, their 1 ETH deposit would fail on beaconchain because it would fail bls.Verify. The result would be them losing their 1 ETH.\n> \n> Our 32 ETH would go through normally and the validator would activate\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/81#issuecomment-1280771801):**\n > @FortisFortuna - can you elaborate on why you believe that bls.Verify would fail?\n> \n> ` if not bls.Verify(pubkey, signing_root, deposit.data.signature):`\n\n**[FortisFortuna (Frax) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/81#issuecomment-1280885731):**\n > From @0xJM\n> \n> https://github.com/ethereum/staking-deposit-cli/blob/e2a7c942408f7fc446b889097f176238e4a10a76/staking_deposit/credentials.py#L127 \n> \n> the signing root includes the deposit message which has the withdrawal credentials \n> \n> https://github.com/ethereum/staking-deposit-cli/blob/e2a7c942408f7fc446b889097f176238e4a10a76/staking_deposit/credentials.py#L112\n> \n> hence bls.Verify would fail on Beaconchain as I mentioned\n> \n> the consensus spec has that signing_root = compute_signing_root(deposit_message, domain) which is verified against the signature.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/81#issuecomment-1280900859):**\n > The signature would be valid.  The validator would still sign the message containing the credentials that they are front running with. \n\n**[FortisFortuna (Frax) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/81#issuecomment-1280909443):**\n > From @denett<br>\n> \"The signature would be valid. The validator would still sign the message containing the credentials that they are front running with.\"\n> Only the validator can create a valid signature and we own the key to the validator.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/81#issuecomment-1280915906):**\n > Yea, so this is the root of it, the contest does not specify that Frax is the owner of all validators that are meant to be used with this protocol. Without stating that ahead of time for the Wardens to understand, I believe this to be a valid finding and the warden should be awarded.\n\n**[FortisFortuna (Frax) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/81#issuecomment-1280932310):**\n > Ok. So in our current setup, assuming Frax owns all validators, we are safe?\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/81#issuecomment-1280947388):**\n > :) I cannot guarantee anything in DeFi is safe.  My understanding of this particular vulnerability is that it would require a validator to act maliciously by using a smaller than 32 ETH deposit to front run your deposit and enable them to control the withdrawal in the future. If the validator is owned by your team and the keys are never exploited, then I don't see how the front ran signature could be generated. \n\n**[FortisFortuna (Frax) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/81#issuecomment-1280949422):**\n > Ya, I hear you lol. At least for this particular scenario we are ok then, according to the known bug. We can pay out for the bug because none of our team were aware of it and it is good to know for the future.\n\n\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-09-frax",
  "Code": [
    {
      "filename": "specs/phase0/beacon-chain.md",
      "content": "# Phase 0 -- The Beacon Chain\n\n## Table of contents\n<!-- TOC -->\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n- [Introduction](#introduction)\n- [Notation](#notation)\n- [Custom types](#custom-types)\n- [Constants](#constants)\n  - [Misc](#misc)\n  - [Withdrawal prefixes](#withdrawal-prefixes)\n  - [Domain types](#domain-types)\n- [Preset](#preset)\n  - [Misc](#misc-1)\n  - [Gwei values](#gwei-values)\n  - [Time parameters](#time-parameters)\n  - [State list lengths](#state-list-lengths)\n  - [Rewards and penalties](#rewards-and-penalties)\n  - [Max operations per block](#max-operations-per-block)\n- [Configuration](#configuration)\n  - [Genesis settings](#genesis-settings)\n  - [Time parameters](#time-parameters-1)\n  - [Validator cycle](#validator-cycle)\n- [Containers](#containers)\n  - [Misc dependencies](#misc-dependencies)\n    - [`Fork`](#fork)\n    - [`ForkData`](#forkdata)\n    - [`Checkpoint`](#checkpoint)\n    - [`Validator`](#validator)\n    - [`AttestationData`](#attestationdata)\n    - [`IndexedAttestation`](#indexedattestation)\n    - [`PendingAttestation`](#pendingattestation)\n    - [`Eth1Data`](#eth1data)\n    - [`HistoricalBatch`](#historicalbatch)\n    - [`DepositMessage`](#depositmessage)\n    - [`DepositData`](#depositdata)\n    - [`BeaconBlockHeader`](#beaconblockheader)\n    - [`SigningData`](#signingdata)\n  - [Beacon operations](#beacon-operations)\n    - [`ProposerSlashing`](#proposerslashing)\n    - [`AttesterSlashing`](#attesterslashing)\n    - [`Attestation`](#attestation)\n    - [`Deposit`](#deposit)\n    - [`VoluntaryExit`](#voluntaryexit)\n  - [Beacon blocks](#beacon-blocks)\n    - [`BeaconBlockBody`](#beaconblockbody)\n    - [`BeaconBlock`](#beaconblock)\n  - [Beacon state](#beacon-state)\n    - [`BeaconState`](#beaconstate)\n  - [Signed envelopes](#signed-envelopes)\n    - [`SignedVoluntaryExit`](#signedvoluntaryexit)\n    - [`SignedBeaconBlock`](#signedbeaconblock)\n    - [`SignedBeaconBlockHeader`](#signedbeaconblockheader)\n- [Helper functions](#helper-functions)\n  - [Math](#math)\n    - [`integer_squareroot`](#integer_squareroot)\n    - [`xor`](#xor)\n    - [`uint_to_bytes`](#uint_to_bytes)\n    - [`bytes_to_uint64`](#bytes_to_uint64)\n    - [`saturating_sub`](#saturating_sub)\n  - [Crypto](#crypto)\n    - [`hash`](#hash)\n    - [`hash_tree_root`](#hash_tree_root)\n    - [BLS signatures](#bls-signatures)\n  - [Predicates](#predicates)\n    - [`is_active_validator`](#is_active_validator)\n    - [`is_eligible_for_activation_queue`](#is_eligible_for_activation_queue)\n    - [`is_eligible_for_activation`](#is_eligible_for_activation)\n    - [`is_slashable_validator`](#is_slashable_validator)\n    - [`is_slashable_attestation_data`](#is_slashable_attestation_data)\n    - [`is_valid_indexed_attestation`](#is_valid_indexed_attestation)\n    - [`is_valid_merkle_branch`](#is_valid_merkle_branch)\n  - [Misc](#misc-2)\n    - [`compute_shuffled_index`](#compute_shuffled_index)\n    - [`compute_proposer_index`](#compute_proposer_index)\n    - [`compute_committee`](#compute_committee)\n    - [`compute_epoch_at_slot`](#compute_epoch_at_slot)\n    - [`compute_start_slot_at_epoch`](#compute_start_slot_at_epoch)\n    - [`compute_activation_exit_epoch`](#compute_activation_exit_epoch)\n    - [`compute_fork_data_root`](#compute_fork_data_root)\n    - [`compute_fork_digest`](#compute_fork_digest)\n    - [`compute_domain`](#compute_domain)\n    - [`compute_signing_root`](#compute_signing_root)\n  - [Beacon state accessors](#beacon-state-accessors)\n    - [`get_current_epoch`](#get_current_epoch)\n    - [`get_previous_epoch`](#get_previous_epoch)\n    - [`get_block_root`](#get_block_root)\n    - [`get_block_root_at_slot`](#get_block_root_at_slot)\n    - [`get_randao_mix`](#get_randao_mix)\n    - [`get_active_validator_indices`](#get_active_validator_indices)\n    - [`get_validator_churn_limit`](#get_validator_churn_limit)\n    - [`get_seed`](#get_seed)\n    - [`get_committee_count_per_slot`](#get_committee_count_per_slot)\n    - [`get_beacon_committee`](#get_beacon_committee)\n    - [`get_beacon_proposer_index`](#get_beacon_proposer_index)\n    - [`get_total_balance`](#get_total_balance)\n    - [`get_total_active_balance`](#get_total_active_balance)\n    - [`get_domain`](#get_domain)\n    - [`get_indexed_attestation`](#get_indexed_attestation)\n    - [`get_attesting_indices`](#get_attesting_indices)\n  - [Beacon state mutators](#beacon-state-mutators)\n    - [`increase_balance`](#increase_balance)\n    - [`decrease_balance`](#decrease_balance)\n    - [`initiate_validator_exit`](#initiate_validator_exit)\n    - [`slash_validator`](#slash_validator)\n- [Genesis](#genesis)\n  - [Genesis state](#genesis-state)\n  - [Genesis block](#genesis-block)\n- [Beacon chain state transition function](#beacon-chain-state-transition-function)\n  - [Epoch processing](#epoch-processing)\n    - [Helper functions](#helper-functions-1)\n    - [Justification and finalization](#justification-and-finalization)\n    - [Rewards and penalties](#rewards-and-penalties-1)\n      - [Helpers](#helpers)\n      - [Components of attestation deltas](#components-of-attestation-deltas)\n      - [`get_attestation_deltas`](#get_attestation_deltas)\n      - [`process_rewards_and_penalties`](#process_rewards_and_penalties)\n    - [Registry updates](#registry-updates)\n    - [Slashings](#slashings)\n    - [Eth1 data votes updates](#eth1-data-votes-updates)\n    - [Effective balances updates](#effective-balances-updates)\n    - [Slashings balances updates](#slashings-balances-updates)\n    - [Randao mixes updates](#randao-mixes-updates)\n    - [Historical roots updates](#historical-roots-updates)\n    - [Participation records rotation](#participation-records-rotation)\n  - [Block processing](#block-processing)\n    - [Block header](#block-header)\n    - [RANDAO](#randao)\n    - [Eth1 data](#eth1-data)\n    - [Operations](#operations)\n      - [Proposer slashings](#proposer-slashings)\n      - [Attester slashings](#attester-slashings)\n      - [Attestations](#attestations)\n      - [Deposits](#deposits)\n      - [Voluntary exits](#voluntary-exits)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n<!-- /TOC -->\n\n## Introduction\n\nThis document represents the specification for Phase 0 -- The Beacon Chain.\n\nAt the core of Ethereum proof-of-stake is a system chain called the \"beacon chain\". The beacon chain stores and manages the registry of validators. In the initial deployment phases of proof-of-stake, the only mechanism to become a validator is to make a one-way ETH transaction to a deposit contract on the Ethereum proof-of-work chain. Activation as a validator happens when deposit receipts are processed by the beacon chain, the activation balance is reached, and a queuing process is completed. Exit is either voluntary or done forcibly as a penalty for misbehavior.\nThe primary source of load on the beacon chain is \"attestations\". Attestations are simultaneously availability votes for a shard block (in a later upgrade) and proof-of-stake votes for a beacon block (Phase 0).\n\n## Notation\n\nCode snippets appearing in `this style` are to be interpreted as Python 3 code.\n\n## Custom types\n\nWe define the following Python custom types for type hinting and readability:\n\n| Name | SSZ equivalent | Description |\n| - | - | - |\n| `Slot` | `uint64` | a slot number |\n| `Epoch` | `uint64` | an epoch number |\n| `CommitteeIndex` | `uint64` | a committee index at a slot |\n| `ValidatorIndex` | `uint64` | a validator registry index |\n| `Gwei` | `uint64` | an amount in Gwei |\n| `Root` | `Bytes32` | a Merkle root |\n| `Hash32` | `Bytes32` | a 256-bit hash |\n| `Version` | `Bytes4` | a fork version number |\n| `DomainType` | `Bytes4` | a domain type |\n| `ForkDigest` | `Bytes4` | a digest of the current fork data |\n| `Domain` | `Bytes32` | a signature domain |\n| `BLSPubkey` | `Bytes48` | a BLS12-381 public key |\n| `BLSSignature` | `Bytes96` | a BLS12-381 signature |\n\n## Constants\n\nThe following values are (non-configurable) constants used throughout the specification.\n\n### Misc\n\n| Name | Value |\n| - | - |\n| `UINT64_MAX` | `uint64(2**64 - 1)` |\n| `UINT64_MAX_SQRT` | `uint64(4294967295)` |\n| `GENESIS_SLOT` | `Slot(0)` |\n| `GENESIS_EPOCH` | `Epoch(0)` |\n| `FAR_FUTURE_EPOCH` | `Epoch(2**64 - 1)` |\n| `BASE_REWARDS_PER_EPOCH` | `uint64(4)` |\n| `DEPOSIT_CONTRACT_TREE_DEPTH` | `uint64(2**5)` (= 32) |\n| `JUSTIFICATION_BITS_LENGTH` | `uint64(4)` |\n| `ENDIANNESS` | `'little'` |\n\n### Withdrawal prefixes\n\n| Name | Value |\n| - | - |\n| `BLS_WITHDRAWAL_PREFIX` | `Bytes1('0x00')` |\n| `ETH1_ADDRESS_WITHDRAWAL_PREFIX` | `Bytes1('0x01')` |\n\n### Domain types\n\n| Name | Value |\n| - | - |\n| `DOMAIN_BEACON_PROPOSER`     | `DomainType('0x00000000')` |\n| `DOMAIN_BEACON_ATTESTER`     | `DomainType('0x01000000')` |\n| `DOMAIN_RANDAO`              | `DomainType('0x02000000')` |\n| `DOMAIN_DEPOSIT`             | `DomainType('0x03000000')` |\n| `DOMAIN_VOLUNTARY_EXIT`      | `DomainType('0x04000000')` |\n| `DOMAIN_SELECTION_PROOF`     | `DomainType('0x05000000')` |\n| `DOMAIN_AGGREGATE_AND_PROOF` | `DomainType('0x06000000')` |\n| `DOMAIN_APPLICATION_MASK`    | `DomainType('0x00000001')` |\n\n*Note*: `DOMAIN_APPLICATION_MASK` reserves the rest of the bitspace in `DomainType` for application usage. This means for some `DomainType` `DOMAIN_SOME_APPLICATION`, `DOMAIN_SOME_APPLICATION & DOMAIN_APPLICATION_MASK` **MUST** be non-zero. This expression for any other `DomainType` in the consensus specs **MUST** be zero.\n\n## Preset\n\n*Note*: The below configuration is bundled as a preset: a bundle of configuration variables which are expected to differ\nbetween different modes of operation, e.g. testing, but not generally between different networks.\nAdditional preset configurations can be found in the [`configs`](../../configs) directory.\n\n### Misc\n\n| Name | Value |\n| - | - |\n| `MAX_COMMITTEES_PER_SLOT` | `uint64(2**6)` (= 64) |\n| `TARGET_COMMITTEE_SIZE` | `uint64(2**7)` (= 128) |\n| `MAX_VALIDATORS_PER_COMMITTEE` | `uint64(2**11)` (= 2,048) |\n| `SHUFFLE_ROUND_COUNT` | `uint64(90)` |\n| `HYSTERESIS_QUOTIENT` | `uint64(4)` |\n| `HYSTERESIS_DOWNWARD_MULTIPLIER` | `uint64(1)` |\n| `HYSTERESIS_UPWARD_MULTIPLIER` | `uint64(5)` |\n\n- For the safety of committees, `TARGET_COMMITTEE_SIZE` exceeds [the recommended minimum committee size of 111](http://web.archive.org/web/20190504131341/https://vitalik.ca/files/Ithaca201807_Sharding.pdf); with sufficient active validators (at least `SLOTS_PER_EPOCH * TARGET_COMMITTEE_SIZE`), the shuffling algorithm ensures committee sizes of at least `TARGET_COMMITTEE_SIZE`. (Unbiasable randomness with a Verifiable Delay Function (VDF) will improve committee robustness and lower the safe minimum committee size.)\n\n### Gwei values\n\n| Name | Value |\n| - | - |\n| `MIN_DEPOSIT_AMOUNT` | `Gwei(2**0 * 10**9)` (= 1,000,000,000) |\n| `MAX_EFFECTIVE_BALANCE` | `Gwei(2**5 * 10**9)` (= 32,000,000,000) |\n| `EFFECTIVE_BALANCE_INCREMENT` | `Gwei(2**0 * 10**9)` (= 1,000,000,000) |\n\n### Time parameters\n\n| Name | Value | Unit | Duration |\n| - | - | :-: | :-: |\n| `MIN_ATTESTATION_INCLUSION_DELAY` | `uint64(2**0)` (= 1) | slots | 12 seconds |\n| `SLOTS_PER_EPOCH` | `uint64(2**5)` (= 32) | slots | 6.4 minutes |\n| `MIN_SEED_LOOKAHEAD` | `uint64(2**0)` (= 1) | epochs | 6.4 minutes |\n| `MAX_SEED_LOOKAHEAD` | `uint64(2**2)` (= 4) | epochs | 25.6 minutes |\n| `MIN_EPOCHS_TO_INACTIVITY_PENALTY` | `uint64(2**2)` (= 4) | epochs | 25.6 minutes |\n| `EPOCHS_PER_ETH1_VOTING_PERIOD` | `uint64(2**6)` (= 64) | epochs | ~6.8 hours |\n| `SLOTS_PER_HISTORICAL_ROOT` | `uint64(2**13)` (= 8,192) | slots | ~27 hours |\n\n### State list lengths\n\n| Name | Value | Unit | Duration |\n| - | - | :-: | :-: |\n| `EPOCHS_PER_HISTORICAL_VECTOR` | `uint64(2**16)` (= 65,536) | epochs | ~0.8 years |\n| `EPOCHS_PER_SLASHINGS_VECTOR` | `uint64(2**13)` (= 8,192) | epochs | ~36 days |\n| `HISTORICAL_ROOTS_LIMIT` | `uint64(2**24)` (= 16,777,216) | historical roots | ~52,262 years |\n| `VALIDATOR_REGISTRY_LIMIT` | `uint64(2**40)` (= 1,099,511,627,776) | validators |\n\n### Rewards and penalties\n\n| Name | Value |\n| - | - |\n| `BASE_REWARD_FACTOR` | `uint64(2**6)` (= 64) |\n| `WHISTLEBLOWER_REWARD_QUOTIENT` | `uint64(2**9)` (= 512) |\n| `PROPOSER_REWARD_QUOTIENT` | `uint64(2**3)` (= 8) |\n| `INACTIVITY_PENALTY_QUOTIENT` | `uint64(2**26)` (= 67,108,864) |\n| `MIN_SLASHING_PENALTY_QUOTIENT` | `uint64(2**7)` (= 128) |\n| `PROPORTIONAL_SLASHING_MULTIPLIER` | `uint64(1)` |\n\n- The `INACTIVITY_PENALTY_QUOTIENT` equals `INVERSE_SQRT_E_DROP_TIME**2` where `INVERSE_SQRT_E_DROP_TIME := 2**13` epochs (about 36 days) is the time it takes the inactivity penalty to reduce the balance of non-participating validators to about `1/sqrt(e) ~= 60.6%`. Indeed, the balance retained by offline validators after `n` epochs is about `(1 - 1/INACTIVITY_PENALTY_QUOTIENT)**(n**2/2)`; so after `INVERSE_SQRT_E_DROP_TIME` epochs, it is roughly `(1 - 1/INACTIVITY_PENALTY_QUOTIENT)**(INACTIVITY_PENALTY_QUOTIENT/2) ~= 1/sqrt(e)`. Note this value will be upgraded to `2**24` after Phase 0 mainnet stabilizes to provide a faster recovery in the event of an inactivity leak.\n\n- The `PROPORTIONAL_SLASHING_MULTIPLIER` is set to `1` at initial mainnet launch, resulting in one-third of the minimum accountable safety margin in the event of a finality attack. After Phase 0 mainnet stabilizes, this value will be upgraded to `3` to provide the maximal minimum accountable safety margin.\n\n### Max operations per block\n\n| Name | Value |\n| - | - |\n| `MAX_PROPOSER_SLASHINGS` | `2**4` (= 16) |\n| `MAX_ATTESTER_SLASHINGS` | `2**1` (= 2) |\n| `MAX_ATTESTATIONS` | `2**7` (= 128) |\n| `MAX_DEPOSITS` | `2**4` (= 16) |\n| `MAX_VOLUNTARY_EXITS` | `2**4` (= 16) |\n\n## Configuration\n\n*Note*: The default mainnet configuration values are included here for illustrative purposes.\nDefaults for this more dynamic type of configuration are available with the presets in the [`configs`](../../configs) directory.\nTestnets and other types of chain instances may use a different configuration.\n\n### Genesis settings\n\n| Name | Value |\n| - | - |\n| `MIN_GENESIS_ACTIVE_VALIDATOR_COUNT` | `uint64(2**14)` (= 16,384) |\n| `MIN_GENESIS_TIME` | `uint64(1606824000)` (Dec 1, 2020, 12pm UTC) |\n| `GENESIS_FORK_VERSION` | `Version('0x00000000')` |\n| `GENESIS_DELAY` | `uint64(604800)` (7 days) |\n\n### Time parameters\n\n| Name | Value | Unit | Duration |\n| - | - | :-: | :-: |\n| `SECONDS_PER_SLOT` | `uint64(12)` | seconds | 12 seconds |\n| `SECONDS_PER_ETH1_BLOCK` | `uint64(14)` | seconds | 14 seconds |\n| `MIN_VALIDATOR_WITHDRAWABILITY_DELAY` | `uint64(2**8)` (= 256) | epochs | ~27 hours |\n| `SHARD_COMMITTEE_PERIOD` | `uint64(2**8)` (= 256) | epochs | ~27 hours |\n| `ETH1_FOLLOW_DISTANCE` | `uint64(2**11)` (= 2,048) | Eth1 blocks | ~8 hours |\n\n### Validator cycle\n\n| Name | Value |\n| - | - |\n| `EJECTION_BALANCE` | `Gwei(2**4 * 10**9)` (= 16,000,000,000) |\n| `MIN_PER_EPOCH_CHURN_LIMIT` | `uint64(2**2)` (= 4) |\n| `CHURN_LIMIT_QUOTIENT` | `uint64(2**16)` (= 65,536) |\n\n## Containers\n\nThe following types are [SimpleSerialize (SSZ)](../../ssz/simple-serialize.md) containers.\n\n*Note*: The definitions are ordered topologically to facilitate execution of the spec.\n\n*Note*: Fields missing in container instantiations default to their zero value.\n\n### Misc dependencies\n\n#### `Fork`\n\n```python\nclass Fork(Container):\n    previous_version: Version\n    current_version: Version\n    epoch: Epoch  # Epoch of latest fork\n```\n\n#### `ForkData`\n\n```python\nclass ForkData(Container):\n    current_version: Version\n    genesis_validators_root: Root\n```\n\n#### `Checkpoint`\n\n```python\nclass Checkpoint(Container):\n    epoch: Epoch\n    root: Root\n```\n\n#### `Validator`\n\n```python\nclass Validator(Container):\n    pubkey: BLSPubkey\n    withdrawal_credentials: Bytes32  # Commitment to pubkey for withdrawals\n    effective_balance: Gwei  # Balance at stake\n    slashed: boolean\n    # Status epochs\n    activation_eligibility_epoch: Epoch  # When criteria for activation were met\n    activation_epoch: Epoch\n    exit_epoch: Epoch\n    withdrawable_epoch: Epoch  # When validator can withdraw funds\n```\n\n#### `AttestationData`\n\n```python\nclass AttestationData(Container):\n    slot: Slot\n    index: CommitteeIndex\n    # LMD GHOST vote\n    beacon_block_root: Root\n    # FFG vote\n    source: Checkpoint\n    target: Checkpoint\n```\n\n#### `IndexedAttestation`\n\n```python\nclass IndexedAttestation(Container):\n    attesting_indices: List[ValidatorIndex, MAX_VALIDATORS_PER_COMMITTEE]\n    data: AttestationData\n    signature: BLSSignature\n```\n\n#### `PendingAttestation`\n\n```python\nclass PendingAttestation(Container):\n    aggregation_bits: Bitlist[MAX_VALIDATORS_PER_COMMITTEE]\n    data: AttestationData\n    inclusion_delay: Slot\n    proposer_index: ValidatorIndex\n```\n\n#### `Eth1Data`\n\n```python\nclass Eth1Data(Container):\n    deposit_root: Root\n    deposit_count: uint64\n    block_hash: Hash32\n```\n\n#### `HistoricalBatch`\n\n```python\nclass HistoricalBatch(Container):\n    block_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\n    state_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\n```\n\n#### `DepositMessage`\n\n```python\nclass DepositMessage(Container):\n    pubkey: BLSPubkey\n    withdrawal_credentials: Bytes32\n    amount: Gwei\n```\n\n#### `DepositData`\n\n```python\nclass DepositData(Container):\n    pubkey: BLSPubkey\n    withdrawal_credentials: Bytes32\n    amount: Gwei\n    signature: BLSSignature  # Signing over DepositMessage\n```\n\n#### `BeaconBlockHeader`\n\n```python\nclass BeaconBlockHeader(Container):\n    slot: Slot\n    proposer_index: ValidatorIndex\n    parent_root: Root\n    state_root: Root\n    body_root: Root\n```\n\n#### `SigningData`\n\n```python\nclass SigningData(Container):\n    object_root: Root\n    domain: Domain\n```\n\n### Beacon operations\n\n#### `ProposerSlashing`\n\n```python\nclass ProposerSlashing(Container):\n    signed_header_1: SignedBeaconBlockHeader\n    signed_header_2: SignedBeaconBlockHeader\n```\n\n#### `AttesterSlashing`\n\n```python\nclass AttesterSlashing(Container):\n    attestation_1: IndexedAttestation\n    attestation_2: IndexedAttestation\n```\n\n#### `Attestation`\n\n```python\nclass Attestation(Container):\n    aggregation_bits: Bitlist[MAX_VALIDATORS_PER_COMMITTEE]\n    data: AttestationData\n    signature: BLSSignature\n```\n\n#### `Deposit`\n\n```python\nclass Deposit(Container):\n    proof: Vector[Bytes32, DEPOSIT_CONTRACT_TREE_DEPTH + 1]  # Merkle path to deposit root\n    data: DepositData\n```\n\n#### `VoluntaryExit`\n\n```python\nclass VoluntaryExit(Container):\n    epoch: Epoch  # Earliest epoch when voluntary exit can be processed\n    validator_index: ValidatorIndex\n```\n\n### Beacon blocks\n\n#### `BeaconBlockBody`\n\n```python\nclass BeaconBlockBody(Container):\n    randao_reveal: BLSSignature\n    eth1_data: Eth1Data  # Eth1 data vote\n    graffiti: Bytes32  # Arbitrary data\n    # Operations\n    proposer_slashings: List[ProposerSlashing, MAX_PROPOSER_SLASHINGS]\n    attester_slashings: List[AttesterSlashing, MAX_ATTESTER_SLASHINGS]\n    attestations: List[Attestation, MAX_ATTESTATIONS]\n    deposits: List[Deposit, MAX_DEPOSITS]\n    voluntary_exits: List[SignedVoluntaryExit, MAX_VOLUNTARY_EXITS]\n```\n\n#### `BeaconBlock`\n\n```python\nclass BeaconBlock(Container):\n    slot: Slot\n    proposer_index: ValidatorIndex\n    parent_root: Root\n    state_root: Root\n    body: BeaconBlockBody\n```\n\n### Beacon state\n\n#### `BeaconState`\n\n```python\nclass BeaconState(Container):\n    # Versioning\n    genesis_time: uint64\n    genesis_validators_root: Root\n    slot: Slot\n    fork: Fork\n    # History\n    latest_block_header: BeaconBlockHeader\n    block_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\n    state_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\n    historical_roots: List[Root, HISTORICAL_ROOTS_LIMIT]\n    # Eth1\n    eth1_data: Eth1Data\n    eth1_data_votes: List[Eth1Data, EPOCHS_PER_ETH1_VOTING_PERIOD * SLOTS_PER_EPOCH]\n    eth1_deposit_index: uint64\n    # Registry\n    validators: List[Validator, VALIDATOR_REGISTRY_LIMIT]\n    balances: List[Gwei, VALIDATOR_REGISTRY_LIMIT]\n    # Randomness\n    randao_mixes: Vector[Bytes32, EPOCHS_PER_HISTORICAL_VECTOR]\n    # Slashings\n    slashings: Vector[Gwei, EPOCHS_PER_SLASHINGS_VECTOR]  # Per-epoch sums of slashed effective balances\n    # Attestations\n    previous_epoch_attestations: List[PendingAttestation, MAX_ATTESTATIONS * SLOTS_PER_EPOCH]\n    current_epoch_attestations: List[PendingAttestation, MAX_ATTESTATIONS * SLOTS_PER_EPOCH]\n    # Finality\n    justification_bits: Bitvector[JUSTIFICATION_BITS_LENGTH]  # Bit set for every recent justified epoch\n    previous_justified_checkpoint: Checkpoint  # Previous epoch snapshot\n    current_justified_checkpoint: Checkpoint\n    finalized_checkpoint: Checkpoint\n```\n\n### Signed envelopes\n\n#### `SignedVoluntaryExit`\n\n```python\nclass SignedVoluntaryExit(Container):\n    message: VoluntaryExit\n    signature: BLSSignature\n```\n\n#### `SignedBeaconBlock`\n\n```python\nclass SignedBeaconBlock(Container):\n    message: BeaconBlock\n    signature: BLSSignature\n```\n\n#### `SignedBeaconBlockHeader`\n\n```python\nclass SignedBeaconBlockHeader(Container):\n    message: BeaconBlockHeader\n    signature: BLSSignature\n```\n\n## Helper functions\n\n*Note*: The definitions below are for specification purposes and are not necessarily optimal implementations.\n\n### Math\n\n#### `integer_squareroot`\n\n```python\ndef integer_squareroot(n: uint64) -> uint64:\n    \"\"\"\n    Return the largest integer ``x`` such that ``x**2 <= n``.\n    \"\"\"\n    if n == UINT64_MAX:\n        return UINT64_MAX_SQRT\n    x = n\n    y = (x + 1) // 2\n    while y < x:\n        x = y\n        y = (x + n // x) // 2\n    return x\n```\n\n#### `xor`\n\n```python\ndef xor(bytes_1: Bytes32, bytes_2: Bytes32) -> Bytes32:\n    \"\"\"\n    Return the exclusive-or of two 32-byte strings.\n    \"\"\"\n    return Bytes32(a ^ b for a, b in zip(bytes_1, bytes_2))\n```\n\n#### `uint_to_bytes`\n\n`def uint_to_bytes(n: uint) -> bytes` is a function for serializing the `uint` type object to bytes in ``ENDIANNESS``-endian. The expected length of the output is the byte-length of the `uint` type.\n\n#### `bytes_to_uint64`\n\n```python\ndef bytes_to_uint64(data: bytes) -> uint64:\n    \"\"\"\n    Return the integer deserialization of ``data`` interpreted as ``ENDIANNESS``-endian.\n    \"\"\"\n    return uint64(int.from_bytes(data, ENDIANNESS))\n```\n\n#### `saturating_sub`\n\n```python\ndef saturating_sub(a: int, b: int) -> int:\n    \"\"\"\n    Computes a - b, saturating at numeric bounds.\n    \"\"\"\n    return a - b if a > b else 0\n```\n\n### Crypto\n\n#### `hash`\n\n`def hash(data: bytes) -> Bytes32` is SHA256.\n\n#### `hash_tree_root`\n\n`def hash_tree_root(object: SSZSerializable) -> Root` is a function for hashing objects into a single root by utilizing a hash tree structure, as defined in the [SSZ spec](../../ssz/simple-serialize.md#merkleization).\n\n#### BLS signatures\n\nThe [IETF BLS signature draft standard v4](https://tools.ietf.org/html/draft-irtf-cfrg-bls-signature-04) with ciphersuite `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_` defines the following functions:\n\n- `def Sign(privkey: int, message: Bytes) -> BLSSignature`\n- `def Verify(pubkey: BLSPubkey, message: Bytes, signature: BLSSignature) -> bool`\n- `def Aggregate(signatures: Sequence[BLSSignature]) -> BLSSignature`\n- `def FastAggregateVerify(pubkeys: Sequence[BLSPubkey], message: Bytes, signature: BLSSignature) -> bool`\n- `def AggregateVerify(pubkeys: Sequence[BLSPubkey], messages: Sequence[Bytes], signature: BLSSignature) -> bool`\n- `def KeyValidate(pubkey: BLSPubkey) -> bool`\n\nThe above functions are accessed through the `bls` module, e.g. `bls.Verify`.\n\n### Predicates\n\n#### `is_active_validator`\n\n```python\ndef is_active_validator(validator: Validator, epoch: Epoch) -> bool:\n    \"\"\"\n    Check if ``validator`` is active.\n    \"\"\"\n    return validator.activation_epoch <= epoch < validator.exit_epoch\n```\n\n#### `is_eligible_for_activation_queue`\n\n```python\ndef is_eligible_for_activation_queue(validator: Validator) -> bool:\n    \"\"\"\n    Check if ``validator`` is eligible to be placed into the activation queue.\n    \"\"\"\n    return (\n        validator.activation_eligibility_epoch == FAR_FUTURE_EPOCH\n        and validator.effective_balance == MAX_EFFECTIVE_BALANCE\n    )\n```\n\n#### `is_eligible_for_activation`\n\n```python\ndef is_eligible_for_activation(state: BeaconState, validator: Validator) -> bool:\n    \"\"\"\n    Check if ``validator`` is eligible for activation.\n    \"\"\"\n    return (\n        # Placement in queue is finalized\n        validator.activation_eligibility_epoch <= state.finalized_checkpoint.epoch\n        # Has not yet been activated\n        and validator.activation_epoch == FAR_FUTURE_EPOCH\n    )\n```\n\n#### `is_slashable_validator`\n\n```python\ndef is_slashable_validator(validator: Validator, epoch: Epoch) -> bool:\n    \"\"\"\n    Check if ``validator`` is slashable.\n    \"\"\"\n    return (not validator.slashed) and (validator.activation_epoch <= epoch < validator.withdrawable_epoch)\n```\n\n#### `is_slashable_attestation_data`\n\n```python\ndef is_slashable_attestation_data(data_1: AttestationData, data_2: AttestationData) -> bool:\n    \"\"\"\n    Check if ``data_1`` and ``data_2`` are slashable according to Casper FFG rules.\n    \"\"\"\n    return (\n        # Double vote\n        (data_1 != data_2 and data_1.target.epoch == data_2.target.epoch) or\n        # Surround vote\n        (data_1.source.epoch < data_2.source.epoch and data_2.target.epoch < data_1.target.epoch)\n    )\n```\n\n#### `is_valid_indexed_attestation`\n\n```python\ndef is_valid_indexed_attestation(state: BeaconState, indexed_attestation: IndexedAttestation) -> bool:\n    \"\"\"\n    Check if ``indexed_attestation`` is not empty, has sorted and unique indices and has a valid aggregate signature.\n    \"\"\"\n    # Verify indices are sorted and unique\n    indices = indexed_attestation.attesting_indices\n    if len(indices) == 0 or not indices == sorted(set(indices)):\n        return False\n    # Verify aggregate signature\n    pubkeys = [state.validators[i].pubkey for i in indices]\n    domain = get_domain(state, DOMAIN_BEACON_ATTESTER, indexed_attestation.data.target.epoch)\n    signing_root = compute_signing_root(indexed_attestation.data, domain)\n    return bls.FastAggregateVerify(pubkeys, signing_root, indexed_attestation.signature)\n```\n\n#### `is_valid_merkle_branch`\n\n```python\ndef is_valid_merkle_branch(leaf: Bytes32, branch: Sequence[Bytes32], depth: uint64, index: uint64, root: Root) -> bool:\n    \"\"\"\n    Check if ``leaf`` at ``index`` verifies against the Merkle ``root`` and ``branch``.\n    \"\"\"\n    value = leaf\n    for i in range(depth):\n        if index // (2**i) % 2:\n            value = hash(branch[i] + value)\n        else:\n            value = hash(value + branch[i])\n    return value == root\n```\n\n### Misc\n\n#### `compute_shuffled_index`\n\n```python\ndef compute_shuffled_index(index: uint64, index_count: uint64, seed: Bytes32) -> uint64:\n    \"\"\"\n    Return the shuffled index corresponding to ``seed`` (and ``index_count``).\n    \"\"\"\n    assert index < index_count\n\n    # Swap or not (https://link.springer.com/content/pdf/10.1007%2F978-3-642-32009-5_1.pdf)\n    # See the 'generalized domain' algorithm on page 3\n    for current_round in range(SHUFFLE_ROUND_COUNT):\n        pivot = bytes_to_uint64(hash(seed + uint_to_bytes(uint8(current_round)))[0:8]) % index_count\n        flip = (pivot + index_count - index) % index_count\n        position = max(index, flip)\n        source = hash(\n            seed\n            + uint_to_bytes(uint8(current_round))\n            + uint_to_bytes(uint32(position // 256))\n        )\n        byte = uint8(source[(position % 256) // 8])\n        bit = (byte >> (position % 8)) % 2\n        index = flip if bit else index\n\n    return index\n```\n\n#### `compute_proposer_index`\n\n```python\ndef compute_proposer_index(state: BeaconState, indices: Sequence[ValidatorIndex], seed: Bytes32) -> ValidatorIndex:\n    \"\"\"\n    Return from ``indices`` a random index sampled by effective balance.\n    \"\"\"\n    assert len(indices) > 0\n    MAX_RANDOM_BYTE = 2**8 - 1\n    i = uint64(0)\n    total = uint64(len(indices))\n    while True:\n        candidate_index = indices[compute_shuffled_index(i % total, total, seed)]\n        random_byte = hash(seed + uint_to_bytes(uint64(i // 32)))[i % 32]\n        effective_balance = state.validators[candidate_index].effective_balance\n        if effective_balance * MAX_RANDOM_BYTE >= MAX_EFFECTIVE_BALANCE * random_byte:\n            return candidate_index\n        i += 1\n```\n\n#### `compute_committee`\n\n```python\ndef compute_committee(indices: Sequence[ValidatorIndex],\n                      seed: Bytes32,\n                      index: uint64,\n                      count: uint64) -> Sequence[ValidatorIndex]:\n    \"\"\"\n    Return the committee corresponding to ``indices``, ``seed``, ``index``, and committee ``count``.\n    \"\"\"\n    start = (len(indices) * index) // count\n    end = (len(indices) * uint64(index + 1)) // count\n    return [indices[compute_shuffled_index(uint64(i), uint64(len(indices)), seed)] for i in range(start, end)]\n```\n\n#### `compute_epoch_at_slot`\n\n```python\ndef compute_epoch_at_slot(slot: Slot) -> Epoch:\n    \"\"\"\n    Return the epoch number at ``slot``.\n    \"\"\"\n    return Epoch(slot // SLOTS_PER_EPOCH)\n```\n\n#### `compute_start_slot_at_epoch`\n\n```python\ndef compute_start_slot_at_epoch(epoch: Epoch) -> Slot:\n    \"\"\"\n    Return the start slot of ``epoch``.\n    \"\"\"\n    return Slot(epoch * SLOTS_PER_EPOCH)\n```\n\n#### `compute_activation_exit_epoch`\n\n```python\ndef compute_activation_exit_epoch(epoch: Epoch) -> Epoch:\n    \"\"\"\n    Return the epoch during which validator activations and exits initiated in ``epoch`` take effect.\n    \"\"\"\n    return Epoch(epoch + 1 + MAX_SEED_LOOKAHEAD)\n```\n\n#### `compute_fork_data_root`\n\n```python\ndef compute_fork_data_root(current_version: Version, genesis_validators_root: Root) -> Root:\n    \"\"\"\n    Return the 32-byte fork data root for the ``current_version`` and ``genesis_validators_root``.\n    This is used primarily in signature domains to avoid collisions across forks/chains.\n    \"\"\"\n    return hash_tree_root(ForkData(\n        current_version=current_version,\n        genesis_validators_root=genesis_validators_root,\n    ))\n```\n\n#### `compute_fork_digest`\n\n```python\ndef compute_fork_digest(current_version: Version, genesis_validators_root: Root) -> ForkDigest:\n    \"\"\"\n    Return the 4-byte fork digest for the ``current_version`` and ``genesis_validators_root``.\n    This is a digest primarily used for domain separation on the p2p layer.\n    4-bytes suffices for practical separation of forks/chains.\n    \"\"\"\n    return ForkDigest(compute_fork_data_root(current_version, genesis_validators_root)[:4])\n```\n\n#### `compute_domain`\n\n```python\ndef compute_domain(domain_type: DomainType, fork_version: Version=None, genesis_validators_root: Root=None) -> Domain:\n    \"\"\"\n    Return the domain for the ``domain_type`` and ``fork_version``.\n    \"\"\"\n    if fork_version is None:\n        fork_version = GENESIS_FORK_VERSION\n    if genesis_validators_root is None:\n        genesis_validators_root = Root()  # all bytes zero by default\n    fork_data_root = compute_fork_data_root(fork_version, genesis_validators_root)\n    return Domain(domain_type + fork_data_root[:28])\n```\n\n#### `compute_signing_root`\n\n```python\ndef compute_signing_root(ssz_object: SSZObject, domain: Domain) -> Root:\n    \"\"\"\n    Return the signing root for the corresponding signing data.\n    \"\"\"\n    return hash_tree_root(SigningData(\n        object_root=hash_tree_root(ssz_object),\n        domain=domain,\n    ))\n```\n\n### Beacon state accessors\n\n#### `get_current_epoch`\n\n```python\ndef get_current_epoch(state: BeaconState) -> Epoch:\n    \"\"\"\n    Return the current epoch.\n    \"\"\"\n    return compute_epoch_at_slot(state.slot)\n```\n\n#### `get_previous_epoch`\n\n```python\ndef get_previous_epoch(state: BeaconState) -> Epoch:\n    \"\"\"`\n    Return the previous epoch (unless the current epoch is ``GENESIS_EPOCH``).\n    \"\"\"\n    current_epoch = get_current_epoch(state)\n    return GENESIS_EPOCH if current_epoch == GENESIS_EPOCH else Epoch(current_epoch - 1)\n```\n\n#### `get_block_root`\n\n```python\ndef get_block_root(state: BeaconState, epoch: Epoch) -> Root:\n    \"\"\"\n    Return the block root at the start of a recent ``epoch``.\n    \"\"\"\n    return get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch))\n```\n\n#### `get_block_root_at_slot`\n\n```python\ndef get_block_root_at_slot(state: BeaconState, slot: Slot) -> Root:\n    \"\"\"\n    Return the block root at a recent ``slot``.\n    \"\"\"\n    assert slot < state.slot <= slot + SLOTS_PER_HISTORICAL_ROOT\n    return state.block_roots[slot % SLOTS_PER_HISTORICAL_ROOT]\n```\n\n#### `get_randao_mix`\n\n```python\ndef get_randao_mix(state: BeaconState, epoch: Epoch) -> Bytes32:\n    \"\"\"\n    Return the randao mix at a recent ``epoch``.\n    \"\"\"\n    return state.randao_mixes[ep"
    }
  ]
}