{
  "Title": "[M-16] Auction manipulation by block stuffing and reverting on ERC-777 hooks",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/test/proposals/gips/GIP_0.sol#L175-L179>\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/loan/AuctionHouse.sol#L118-L196>\n\n### Summary\n\nThe protocol stated out in the C4 description that the deployment script of the protocol, located in `test/proposals/gips/GIP_0.sol` is also in scope, as protocol deployment/configuration mistakes could be made. A low immutable auction duration set in this deployment script can lead to profitable block stuffing attacks on the desired L2 chains. This attack vector can be further improved under the condition that the collateral token is ERC-777 compatible.\n\n### Vulnerability Details\n\nThe auction house contract is deployed with the following parameters (auctionDuration and midPoint are immutables):\n\n```solidity\nAuctionHouse auctionHouse = new AuctionHouse(\n    AddressLib.get(\"CORE\"),\n    650, // midPoint = 10m50s\n    1800 // auctionDuration = 30m\n);\n```\n\nDuring the first half of the auction (before `midPoint`), an increasing amount of the collateral is offered, for the full CREDIT amount.\n\nDuring the second half of the action (after `midPoint`), all collateral is offered, for a decreasing CREDIT amount.\n\nThe calculation can be seen in the `getBidDetail` function:\n\n```solidity\nuint256 public immutable midPoint;\nuint256 public immutable auctionDuration;\n\nfunction getBidDetail(bytes32 loanId) public view returns (uint256 collateralReceived, uint256 creditAsked) {\n  // check the auction for this loan exists\n  uint256 _startTime = auctions[loanId].startTime;\n  require(_startTime != 0, 'AuctionHouse: invalid auction');\n\n  // check the auction for this loan isn't ended\n  require(auctions[loanId].endTime == 0, 'AuctionHouse: auction ended');\n\n  // assertion should never fail because when an auction is created,\n  // block.timestamp is recorded as the auction start time, and we check in previous\n  // lines that start time != 0, so the auction has started.\n  assert(block.timestamp >= _startTime);\n\n  // first phase of the auction, where more and more collateral is offered\n  if (block.timestamp < _startTime + midPoint) {\n    // ask for the full debt\n    creditAsked = auctions[loanId].callDebt;\n\n    // compute amount of collateral received\n    uint256 elapsed = block.timestamp - _startTime; // [0, midPoint[\n    uint256 _collateralAmount = auctions[loanId].collateralAmount; // SLOAD\n    collateralReceived = (_collateralAmount * elapsed) / midPoint;\n  }\n  // second phase of the auction, where less and less CREDIT is asked\n  else if (block.timestamp < _startTime + auctionDuration) {\n    // receive the full collateral\n    collateralReceived = auctions[loanId].collateralAmount;\n\n    // compute amount of CREDIT to ask\n    uint256 PHASE_2_DURATION = auctionDuration - midPoint;\n    uint256 elapsed = block.timestamp - _startTime - midPoint; // [0, PHASE_2_DURATION[\n    uint256 _callDebt = auctions[loanId].callDebt; // SLOAD\n    creditAsked = _callDebt - (_callDebt * elapsed) / PHASE_2_DURATION;\n  }\n  // second phase fully elapsed, anyone can receive the full collateral and give 0 CREDIT\n  // in practice, somebody should have taken the arb before we reach this condition.\n  else {\n    // receive the full collateral\n    collateralReceived = auctions[loanId].collateralAmount;\n    //creditAsked = 0; // implicit\n  }\n}\n```\n\nThis means that as long as the auction goes until a bid is made (which instantly buys the auction), the more profit can be made by executing the auction.\n\nThe following conditions allow an attacker to manipulate auctions by stuffing blocks to increase profits:\n\n1. `auctionDuration` is set to 1800 seconds (30min) in the deployment script.\n2. auction `midPoint` is set to 650 seconds (10m50s) in the deployment script.\n3. the protocol will be deployed on L2s let's take optimism for example (as this chain was mentioned by the devs in discord):\n\nBlocks in optimism are minted every 2s. The block gas limit of optimism is 30M as in ethereum mainnet. At the time of writing this, the cost of stuffing a full block on optimism is around `$6.39`. See [here](<https://www.cryptoneur.xyz/en/gas-fees-calculator?gas-input=15000000&gas-price-option=on>).\n\nTherefore, preventing a bid for one minute costs `$6.39 * 30 blocks = $191.7`, and preventing a bid for 30 minutes costs `$191.7 * 30 minutes = $5751`.\n    \nBut the attacker will almost never need to stuff blocks for around 30 minutes, as the system of the auction is not profitable in the beginning and it starts to be really profitable after the midpoint. It also starts to be much more damaging to the system at this point. Which is after 10m 50s and the costs to stuff blocks for 10m 50s is `$191.7 * 10.5 minutes = $2012.85`. As mentioned before, the auction is not profitable at the beginning; therefore, no one will bid on second one and the attacker does not need to stuff blocks instantly. This means the attack will most likely cost less than `$2000`.\n\nTherefore, if at any given timestamp the profit of the auction outweighs the cost of stuffing blocks for the time till the deal becomes profitable for the attacker a system damaging incentive appears and manipulating auctions becomes a profitable attack vector.\n\nBut the impact increases further in terms of griefing as loss for terms can occur after the `midPoint` which will instantly lead to slashing and therefore, all stakers of the given term will lose all their credit tokens weighted on this term.\n\nThe following code snippets showcase the slashing mechanism that lead to a total loss for the stakers if the term receives any loss during these block stuffing attack:\n\n<details>\n\n```solidity\nfunction bid(bytes32 loanId) external {\n    ...\n\n    LendingTerm(_lendingTerm).onBid(\n        loanId,\n        msg.sender,\n        auctions[loanId].collateralAmount - collateralReceived, // collateralToBorrower\n        collateralReceived, // collateralToBidder\n        creditAsked // creditFromBidder\n    );\n\n    ...\n}\n\nfunction onBid(\n    bytes32 loanId,\n    address bidder,\n    uint256 collateralToBorrower,\n    uint256 collateralToBidder,\n    uint256 creditFromBidder\n) external {\n    ...\n\n    int256 pnl;\n    uint256 interest;\n    if (creditFromBidder >= principal) {\n        interest = creditFromBidder - principal;\n        pnl = int256(interest);\n    } else {\n        pnl = int256(creditFromBidder) - int256(principal);\n        principal = creditFromBidder;\n        require(\n            collateralToBorrower == 0,\n            \"LendingTerm: invalid collateral movement\"\n        );\n    }\n\n    ...\n\n    // handle profit & losses\n    if (pnl != 0) {\n        // forward profit, if any\n        if (interest != 0) {\n            CreditToken(refs.creditToken).transfer(\n                refs.profitManager,\n                interest\n            );\n        }\n        ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);\n    }\n\n    ...\n}\n\nfunction notifyPnL(\n    address gauge,\n    int256 amount\n) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {\n    ...\n\n    // handling loss\n    if (amount < 0) {\n        uint256 loss = uint256(-amount);\n\n        // save gauge loss\n        GuildToken(guild).notifyGaugeLoss(gauge);\n\n        // deplete the term surplus buffer, if any, and\n        // donate its content to the general surplus buffer\n        if (_termSurplusBuffer != 0) {\n            termSurplusBuffer[gauge] = 0;\n            emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);\n            _surplusBuffer += _termSurplusBuffer;\n        }\n\n        if (loss < _surplusBuffer) {\n            // deplete the surplus buffer\n            surplusBuffer = _surplusBuffer - loss;\n            emit SurplusBufferUpdate(\n                block.timestamp,\n                _surplusBuffer - loss\n            );\n            CreditToken(_credit).burn(loss);\n        }\n    } ...\n}\n\nfunction notifyGaugeLoss(address gauge) external {\n    require(msg.sender == profitManager, \"UNAUTHORIZED\");\n\n    // save gauge loss\n    lastGaugeLoss[gauge] = block.timestamp;\n    emit GaugeLoss(gauge, block.timestamp);\n}\n\n/// @notice apply a loss that occurred in a given gauge\n/// anyone can apply the loss on behalf of anyone else\nfunction applyGaugeLoss(address gauge, address who) external {\n    // check preconditions\n    uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n    uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][who];\n    require(\n        _lastGaugeLoss != 0 && _lastGaugeLossApplied < _lastGaugeLoss,\n        \"GuildToken: no loss to apply\"\n    );\n\n    // read user weight allocated to the lossy gauge\n    uint256 _userGaugeWeight = getUserGaugeWeight[who][gauge];\n\n    // remove gauge weight allocation\n    lastGaugeLossApplied[gauge][who] = block.timestamp;\n    _decrementGaugeWeight(who, gauge, _userGaugeWeight);\n    if (!_deprecatedGauges.contains(gauge)) {\n        totalTypeWeight[gaugeType[gauge]] -= _userGaugeWeight;\n        totalWeight -= _userGaugeWeight;\n    }\n\n    // apply loss\n    _burn(who, uint256(_userGaugeWeight));\n    emit GaugeLossApply(\n        gauge,\n        who,\n        uint256(_userGaugeWeight),\n        block.timestamp\n    );\n}\n```\n\n</details>\n\nThis attack vector can be further improved under the condition that the collateral token is ERC-777 compatible. It is advised to first read the report called `Bad debt can occur if the collateral token blacklists a borrower leading to total loss of stake for all lenders on that term` which showcases how the auction time is increased until the `midPoint` of the auction if transferring the collateral tokens to the borrower reverts.\n\nThe attack path would be as follows:\n\n1. Attacker borrows a loan (with a ERC-777 compatible collateral token) using a contract that revert on receiving the collateral back if the `tx.origin != address` (attacker).\n2. The attacker receives the credit token from the loan and deposits collateral into the protocol.\n3. The attacker does not repay the loan after the first partial duration and call it for auction.\n4. As showcased, every call until the `midPoint` will revert when trying to transfer the collateral back to the attacker. This will drastically decrease the costs for the attacker as he does not need to stuff blocks until the `midPoint` is reached.\n5. After the `midPoint` is reached, the attacker can start stuffing blocks till bad debt occurs. At this time, the attacker can bid on the auction and will therefore, buy the full collateral back for less credit tokens than the attacker received for the loan.\n6. If it is possible for the attacker to stuff blocks and wait until the asked credit amount goes to `0`, the attacker was able to steal almost the full loan amount; which can potentially be way bigger than the gas amount for stuffing the blocks.\n\n### Impact\n\nThe attacker can prevent other users from bidding on the auction and therefore, manipulate the auction to a point where the attacker would be able to buy the full collateral for almost zero credit tokens. As loss for the term occurs in such an event, all stakers of the given term will lose all their credit tokens weighted on this term. If the given collateral token is ERC-777 compatible, the costs of such an attack can be drastically reduced and the attack can potentially become a self liquidation attack.\n\n### Recommendation\n\nIncrease the auction duration, as the longer the auction goes the less profitable such an attack would be and implement the mentioned fix in the `Bad debt can occur if the collateral token blacklists a borrower leading to total loss of stake for all lenders on that term` report.\n\n### Assessed type\n\nMEV\n\n**[eswak (Ethereum Credit Guild) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/685#issuecomment-1888762080):**\n > I'm skeptical of this being a valid finding (despite fomo3d), at least it's not a high. It is true that there is more spam/censorship risk on Optimism & Arbitrum. On mainnet, liquidators can use flashbots etc, while on Arbitrum, the sequencer is first come first served. If the liquidator raises the gas price of one tx, the spammer has to raise the gas price of all tx that fill the block. Costs can get out of hand pretty quickly. Take-away I think is that on L2s, the auctions should be long enough to account for this. We've also been discussing very long auctions internally to minimize liquidity risk (and allow people to have time to bridge assets in order to participate in auctions), which also mitigates this vector.\n\n**[TrungOre (judge) decreased severity to Low](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/685#issuecomment-1912661238)**\n\n**[TrungOre (judge) increased severity to Medium and commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/685#issuecomment-1918442948):**\n > After reviewing again, I consider this to be an issue of block stuffing attack on the auctionâ€”a hypothetical attack path that could be profitable for attacker and result in losses for protocol. So I believe this should be a medium.\n\n**[btk (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/685#issuecomment-1924137548):**\n > @TrungOre, could you please take another look? \n> \n> The PoC seems impractical, assuming a constant gas price, which doesn't reflect reality. As the sponsor noted, \"Costs can get out of hand pretty quickly,\" and auction profits wouldn't cover such expenses. \n> \n> Edit: The report didn't consider EIP1559. Reference [here](https://consensys.io/blog/what-is-eip-1559-how-will-it-change-ethereum):\n> \n> > With EIP-1559, the base fee will increase and decrease by up to 12.5% after blocks are more than 50% full. For example, if a block is 100% full the base fee increases by 12.5%; if it is 50% full the base fee will be the same; if it is 0% full the base fee would decrease by 12.5%. \n\n**[Cosine (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/685#issuecomment-1925250785):**\n > @btk - The maximum increase of the base fee on optimism (which was the blockchain taken as an example in this report) is 10% (See [here](https://docs.optimism.io/chain/differences#eip-1559)). You are right that the costs of the attack are increased, but could still be profitable depending on the size of the loan. The attacker does also not need to stuff blocks for the full 30 minutes. Even one or a few blocks could be profitable depending on the size of the loan and the costs of stuffing a few blocks when the first one costs `$6` and increases by 10% is pretty low.\n\n**[TrungOre (judge) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/685#issuecomment-1934666714):**\n > Although it is very unlikely to make profits, I still consider it as a possible hypothetical path with low likelihood. With the current configuration (30 minutes for auction duration), it doesn't guarantee that block stuffing might not be possible, so this issue should be medium.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/685).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "test/proposals/gips/GIP_0.sol",
      "content": "//SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport {Core} from \"@src/core/Core.sol\";\nimport {Proposal} from \"@test/proposals/proposalTypes/Proposal.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {AddressLib} from \"@test/proposals/AddressLib.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {AuctionHouse} from \"@src/loan/AuctionHouse.sol\";\nimport {GuildGovernor} from \"@src/governance/GuildGovernor.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {ERC20MultiVotes} from \"@src/tokens/ERC20MultiVotes.sol\";\nimport {GuildVetoGovernor} from \"@src/governance/GuildVetoGovernor.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\nimport {SurplusGuildMinter} from \"@src/loan/SurplusGuildMinter.sol\";\nimport {LendingTermOnboarding} from \"@src/governance/LendingTermOnboarding.sol\";\nimport {GuildTimelockController} from \"@src/governance/GuildTimelockController.sol\";\nimport {LendingTermOffboarding} from \"@src/governance/LendingTermOffboarding.sol\";\n\n/// @notice deployer must have 100 USDC to deploy the system on mainnet for the initial PSM mint.\ncontract GIP_0 is Proposal {\n    string public constant name = \"Proposal_0\";\n\n    /// --------------------------------------------------------------\n    /// --------------------------------------------------------------\n    /// -------------------- DEPLOYMENT CONSTANTS --------------------\n    /// --------------------------------------------------------------\n    /// --------------------------------------------------------------\n\n    /// @notice maximum guild supply is 1b tokens, however this number can change\n    /// later if new tokens are minted\n    uint256 internal constant GUILD_SUPPLY = 1_000_000_000 * 1e18;\n\n    /// @notice guild mint ratio is 5e18, meaning for 1 credit 5 guild tokens are\n    /// minted in SurplusGuildMinter\n    uint256 internal constant GUILD_MINT_RATIO = 5e18;\n\n    /// @notice ratio of guild tokens received per Credit earned in\n    /// the Surplus Guild Minter\n    uint256 internal constant GUILD_CREDIT_REWARD_RATIO = 0.1e18;\n\n    /// @notice maximum delegates for both credit and guild token\n    uint256 internal constant MAX_DELEGATES = 10;\n\n    /// @notice for each SDAI collateral, up to 1 credit can be borrowed\n    uint256 internal constant MAX_SDAI_CREDIT_RATIO = 1e18;\n\n    /// @notice credit hardcap at launch\n    uint256 internal constant CREDIT_HARDCAP = 2_000_000 * 1e18;\n\n    /// @notice SDAI credit hardcap at launch\n    uint256 internal constant SDAI_CREDIT_HARDCAP = 2_000_000 * 1e18;\n\n    /// ------------------------------------------------------------------------\n    /// @notice Interest Rate Parameters\n    /// ------------------------------------------------------------------------\n\n    /// @notice rate to borrow against SDAI collateral\n    uint256 internal constant SDAI_RATE = 0.04e18;\n\n    /// ------------------------------------------------------------------------\n    /// @notice profit sharing configuration parameters for the Profit Manager\n    /// ------------------------------------------------------------------------\n\n    /// @notice 9% of profits go to the surplus buffer\n    uint256 internal constant SURPLUS_BUFFER_SPLIT = 0.09e18;\n\n    /// @notice 90% of profits go to credit holders that opt into rebasing\n    uint256 internal constant CREDIT_SPLIT = 0.9e18;\n\n    /// @notice 1% of profits go to guild holders staked in gauges\n    uint256 internal constant GUILD_SPLIT = 0.01e18;\n\n    /// @notice 0% of profits go to other\n    uint256 internal constant OTHER_SPLIT = 0;\n    address internal constant OTHER_ADDRESS = address(0);\n\n    uint256 public constant BLOCKS_PER_DAY = 7164;\n\n    // governance params\n    uint256 public constant DAO_TIMELOCK_DELAY = 7 days;\n    uint256 public constant ONBOARD_TIMELOCK_DELAY = 1 days;\n    uint256 public constant DAO_GOVERNOR_GUILD_VOTING_DELAY =\n        0 * BLOCKS_PER_DAY;\n    uint256 public constant DAO_GOVERNOR_GUILD_VOTING_PERIOD =\n        3 * BLOCKS_PER_DAY;\n    uint256 public constant DAO_GOVERNOR_GUILD_PROPOSAL_THRESHOLD =\n        2_500_000e18;\n    uint256 public constant DAO_GOVERNOR_GUILD_QUORUM = 25_000_000e18;\n    uint256 public constant DAO_VETO_CREDIT_QUORUM = 5_000_000e18;\n    uint256 public constant DAO_VETO_GUILD_QUORUM = 15_000_000e18;\n    uint256 public constant ONBOARD_GOVERNOR_GUILD_VOTING_DELAY =\n        0 * BLOCKS_PER_DAY;\n    uint256 public constant ONBOARD_GOVERNOR_GUILD_VOTING_PERIOD =\n        2 * BLOCKS_PER_DAY;\n    uint256 public constant ONBOARD_GOVERNOR_GUILD_PROPOSAL_THRESHOLD =\n        1_000_000e18;\n    uint256 public constant ONBOARD_GOVERNOR_GUILD_QUORUM = 10_000_000e18;\n    uint256 public constant ONBOARD_VETO_CREDIT_QUORUM = 5_000_000e18;\n    uint256 public constant ONBOARD_VETO_GUILD_QUORUM = 10_000_000e18;\n    uint256 public constant OFFBOARD_QUORUM = 10_000_000e18;\n\n    function deploy() public {\n        // Core\n        {\n            Core core = new Core();\n            AddressLib.set(\"CORE\", address(core));\n        }\n\n        // ProfitManager\n        {\n            ProfitManager profitManager = new ProfitManager(\n                AddressLib.get(\"CORE\")\n            );\n            AddressLib.set(\"PROFIT_MANAGER\", address(profitManager));\n        }\n\n        // Tokens & minting\n        {\n            CreditToken credit = new CreditToken(\n                AddressLib.get(\"CORE\"),\n                \"Ethereum Credit Guild - gUSDC\",\n                \"gUSDC\"\n            );\n            GuildToken guild = new GuildToken(\n                AddressLib.get(\"CORE\"),\n                AddressLib.get(\"PROFIT_MANAGER\")\n            );\n            RateLimitedMinter rateLimitedCreditMinter = new RateLimitedMinter(\n                AddressLib.get(\"CORE\"),\n                address(credit),\n                CoreRoles.RATE_LIMITED_CREDIT_MINTER,\n                0, // maxRateLimitPerSecond\n                0, // rateLimitPerSecond\n                uint128(CREDIT_HARDCAP) // bufferCap\n            );\n            RateLimitedMinter rateLimitedGuildMinter = new RateLimitedMinter(\n                AddressLib.get(\"CORE\"),\n                address(guild),\n                CoreRoles.RATE_LIMITED_GUILD_MINTER,\n                0, // maxRateLimitPerSecond\n                0, // rateLimitPerSecond\n                uint128(GUILD_SUPPLY) // 1b\n            );\n            SurplusGuildMinter guildMinter = new SurplusGuildMinter(\n                AddressLib.get(\"CORE\"),\n                AddressLib.get(\"PROFIT_MANAGER\"),\n                address(credit),\n                address(guild),\n                address(rateLimitedGuildMinter),\n                GUILD_MINT_RATIO, // ratio of GUILD minted per CREDIT staked\n                GUILD_CREDIT_REWARD_RATIO // amount of GUILD received per CREDIT earned from staking in Gauges\n            );\n\n            AddressLib.set(\"ERC20_GUSDC\", address(credit));\n            AddressLib.set(\"ERC20_GUILD\", address(guild));\n            AddressLib.set(\n                \"RATE_LIMITED_CREDIT_MINTER\",\n                address(rateLimitedCreditMinter)\n            );\n            AddressLib.set(\n                \"RATE_LIMITED_GUILD_MINTER\",\n                address(rateLimitedGuildMinter)\n            );\n            AddressLib.set(\"SURPLUS_GUILD_MINTER\", address(guildMinter));\n        }\n\n        // Auction House & LendingTerm Implementation V1 & PSM\n        {\n            AuctionHouse auctionHouse = new AuctionHouse(\n                AddressLib.get(\"CORE\"),\n                650, // midPoint = 10m50s\n                1800 // auctionDuration = 30m\n            );\n\n            LendingTerm termV1 = new LendingTerm();\n\n            SimplePSM psm = new SimplePSM(\n                AddressLib.get(\"CORE\"),\n                AddressLib.get(\"PROFIT_MANAGER\"),\n                AddressLib.get(\"ERC20_GUSDC\"),\n                AddressLib.get(\"ERC20_USDC\")\n            );\n\n            AddressLib.set(\"AUCTION_HOUSE\", address(auctionHouse));\n            AddressLib.set(\"LENDING_TERM_V1\", address(termV1));\n            AddressLib.set(\"PSM_USDC\", address(psm));\n        }\n\n        // Governance\n        {\n            GuildTimelockController daoTimelock = new GuildTimelockController(\n                AddressLib.get(\"CORE\"),\n                DAO_TIMELOCK_DELAY\n            );\n            GuildGovernor daoGovernorGuild = new GuildGovernor(\n                AddressLib.get(\"CORE\"),\n                address(daoTimelock),\n                AddressLib.get(\"ERC20_GUILD\"),\n                DAO_GOVERNOR_GUILD_VOTING_DELAY, // initialVotingDelay\n                DAO_GOVERNOR_GUILD_VOTING_PERIOD, // initialVotingPeriod\n                DAO_GOVERNOR_GUILD_PROPOSAL_THRESHOLD, // initialProposalThreshold\n                DAO_GOVERNOR_GUILD_QUORUM // initialQuorum\n            );\n            GuildVetoGovernor daoVetoCredit = new GuildVetoGovernor(\n                AddressLib.get(\"CORE\"),\n                address(daoTimelock),\n                AddressLib.get(\"ERC20_GUSDC\"),\n                DAO_VETO_CREDIT_QUORUM // initialQuorum\n            );\n            GuildVetoGovernor daoVetoGuild = new GuildVetoGovernor(\n                AddressLib.get(\"CORE\"),\n                address(daoTimelock),\n                AddressLib.get(\"ERC20_GUILD\"),\n                DAO_VETO_GUILD_QUORUM // initialQuorum\n            );\n\n            GuildTimelockController onboardTimelock = new GuildTimelockController(\n                AddressLib.get(\"CORE\"),\n                ONBOARD_TIMELOCK_DELAY\n            );\n            LendingTermOnboarding onboardGovernorGuild = new LendingTermOnboarding(\n                    LendingTerm.LendingTermReferences({\n                        profitManager: AddressLib.get(\"PROFIT_MANAGER\"),\n                        guildToken: AddressLib.get(\"ERC20_GUILD\"),\n                        auctionHouse: AddressLib.get(\"AUCTION_HOUSE\"),\n                        creditMinter: AddressLib.get(\n                            \"RATE_LIMITED_CREDIT_MINTER\"\n                        ),\n                        creditToken: AddressLib.get(\"ERC20_GUSDC\")\n                    }), /// _lendingTermReferences\n                    1, // _gaugeType\n                    AddressLib.get(\"CORE\"), // _core\n                    address(onboardTimelock), // _timelock\n                    ONBOARD_GOVERNOR_GUILD_VOTING_DELAY, // initialVotingDelay\n                    ONBOARD_GOVERNOR_GUILD_VOTING_PERIOD, // initialVotingPeriod\n                    ONBOARD_GOVERNOR_GUILD_PROPOSAL_THRESHOLD, // initialProposalThreshold\n                    ONBOARD_GOVERNOR_GUILD_QUORUM // initialQuorum\n                );\n            GuildVetoGovernor onboardVetoCredit = new GuildVetoGovernor(\n                AddressLib.get(\"CORE\"),\n                address(onboardTimelock),\n                AddressLib.get(\"ERC20_GUSDC\"),\n                ONBOARD_VETO_CREDIT_QUORUM // initialQuorum\n            );\n            GuildVetoGovernor onboardVetoGuild = new GuildVetoGovernor(\n                AddressLib.get(\"CORE\"),\n                address(onboardTimelock),\n                AddressLib.get(\"ERC20_GUILD\"),\n                ONBOARD_VETO_GUILD_QUORUM // initialQuorum\n            );\n\n            LendingTermOffboarding termOffboarding = new LendingTermOffboarding(\n                AddressLib.get(\"CORE\"),\n                AddressLib.get(\"ERC20_GUILD\"),\n                AddressLib.get(\"PSM_USDC\"),\n                OFFBOARD_QUORUM // quorum\n            );\n\n            AddressLib.set(\n                \"DAO_GOVERNOR_GUILD\",\n                address(daoGovernorGuild)\n            );\n            AddressLib.set(\"DAO_TIMELOCK\", address(daoTimelock));\n            AddressLib.set(\"DAO_VETO_CREDIT\", address(daoVetoCredit));\n            AddressLib.set(\"DAO_VETO_GUILD\", address(daoVetoGuild));\n            AddressLib.set(\n                \"ONBOARD_GOVERNOR_GUILD\",\n                address(onboardGovernorGuild)\n            );\n            AddressLib.set(\"ONBOARD_TIMELOCK\", address(onboardTimelock));\n            AddressLib.set(\n                \"ONBOARD_VETO_CREDIT\",\n                address(onboardVetoCredit)\n            );\n            AddressLib.set(\n                \"ONBOARD_VETO_GUILD\",\n                address(onboardVetoGuild)\n            );\n            AddressLib.set(\n                \"OFFBOARD_GOVERNOR_GUILD\",\n                address(termOffboarding)\n            );\n        }\n\n        // Terms\n        {\n            LendingTermOnboarding termOnboarding = LendingTermOnboarding(\n                payable(AddressLib.get(\"ONBOARD_GOVERNOR_GUILD\"))\n            );\n            address _lendingTermV1 = AddressLib.get(\"LENDING_TERM_V1\");\n            termOnboarding.allowImplementation(_lendingTermV1, true);\n\n            address termSDAI1 = termOnboarding.createTerm(\n                _lendingTermV1,\n                LendingTerm.LendingTermParams({\n                    collateralToken: AddressLib.get(\"ERC20_SDAI\"),\n                    maxDebtPerCollateralToken: 1e18, // 1 CREDIT per SDAI collateral + no decimals correction\n                    interestRate: SDAI_RATE, // 4%\n                    maxDelayBetweenPartialRepay: 0, // no periodic partial repay needed\n                    minPartialRepayPercent: 0, // no minimum size for partial repay\n                    openingFee: 0, // 0%\n                    hardCap: CREDIT_HARDCAP // max 2m CREDIT issued\n                })\n            );\n\n            AddressLib.set(\"TERM_SDAI_1\", termSDAI1);\n        }\n    }\n\n    function afterDeploy(address deployer) public {\n        Core core = Core(AddressLib.get(\"CORE\"));\n\n        // grant roles to smart contracts\n        // GOVERNOR\n        core.grantRole(CoreRoles.GOVERNOR, AddressLib.get(\"DAO_TIMELOCK\"));\n        core.grantRole(\n            CoreRoles.GOVERNOR,\n            AddressLib.get(\"ONBOARD_TIMELOCK\")\n        );\n        core.grantRole(\n            CoreRoles.GOVERNOR,\n            AddressLib.get(\"OFFBOARD_GOVERNOR_GUILD\")\n        );\n\n        // GUARDIAN\n        core.grantRole(CoreRoles.GUARDIAN, AddressLib.get(\"TEAM_MULTISIG\"));\n\n        // CREDIT_MINTER\n        core.grantRole(\n            CoreRoles.CREDIT_MINTER,\n            AddressLib.get(\"RATE_LIMITED_CREDIT_MINTER\")\n        );\n        core.grantRole(CoreRoles.CREDIT_MINTER, AddressLib.get(\"PSM_USDC\"));\n\n        // RATE_LIMITED_CREDIT_MINTER\n        core.grantRole(\n            CoreRoles.RATE_LIMITED_CREDIT_MINTER,\n            AddressLib.get(\"TERM_SDAI_1\")\n        );\n\n        // GUILD_MINTER\n        core.grantRole(\n            CoreRoles.GUILD_MINTER,\n            AddressLib.get(\"RATE_LIMITED_GUILD_MINTER\")\n        );\n\n        // RATE_LIMITED_GUILD_MINTER\n        core.grantRole(\n            CoreRoles.RATE_LIMITED_GUILD_MINTER,\n            AddressLib.get(\"SURPLUS_GUILD_MINTER\")\n        );\n\n        /// Grant Multisig Guild Rate Limited Minter\n        core.grantRole(\n            CoreRoles.RATE_LIMITED_GUILD_MINTER,\n            AddressLib.get(\"TEAM_MULTISIG\")\n        );\n\n        // GAUGE_ADD\n        core.grantRole(CoreRoles.GAUGE_ADD, AddressLib.get(\"DAO_TIMELOCK\"));\n        core.grantRole(\n            CoreRoles.GAUGE_ADD,\n            AddressLib.get(\"ONBOARD_TIMELOCK\")\n        );\n        core.grantRole(CoreRoles.GAUGE_ADD, deployer);\n\n        // GAUGE_REMOVE\n        core.grantRole(\n            CoreRoles.GAUGE_REMOVE,\n            AddressLib.get(\"DAO_TIMELOCK\")\n        );\n        core.grantRole(\n            CoreRoles.GAUGE_REMOVE,\n            AddressLib.get(\"OFFBOARD_GOVERNOR_GUILD\")\n        );\n\n        // GAUGE_PARAMETERS\n        core.grantRole(\n            CoreRoles.GAUGE_PARAMETERS,\n            AddressLib.get(\"DAO_TIMELOCK\")\n        );\n        core.grantRole(CoreRoles.GAUGE_PARAMETERS, deployer);\n\n        // GAUGE_PNL_NOTIFIER\n        core.grantRole(\n            CoreRoles.GAUGE_PNL_NOTIFIER,\n            AddressLib.get(\"TERM_SDAI_1\")\n        );\n\n        // GUILD_GOVERNANCE_PARAMETERS\n        core.grantRole(\n            CoreRoles.GUILD_GOVERNANCE_PARAMETERS,\n            AddressLib.get(\"DAO_TIMELOCK\")\n        );\n        core.grantRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS, deployer);\n\n        // GUILD_SURPLUS_BUFFER_WITHDRAW\n        core.grantRole(\n            CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW,\n            AddressLib.get(\"SURPLUS_GUILD_MINTER\")\n        );\n\n        // CREDIT_GOVERNANCE_PARAMETERS\n        core.grantRole(\n            CoreRoles.CREDIT_GOVERNANCE_PARAMETERS,\n            AddressLib.get(\"DAO_TIMELOCK\")\n        );\n        core.grantRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS, deployer);\n\n        // CREDIT_REBASE_PARAMETERS\n        core.grantRole(\n            CoreRoles.CREDIT_REBASE_PARAMETERS,\n            AddressLib.get(\"DAO_TIMELOCK\")\n        );\n        core.grantRole(\n            CoreRoles.CREDIT_REBASE_PARAMETERS,\n            AddressLib.get(\"PSM_USDC\")\n        );\n\n        // TIMELOCK_PROPOSER\n        core.grantRole(\n            CoreRoles.TIMELOCK_PROPOSER,\n            AddressLib.get(\"DAO_GOVERNOR_GUILD\")\n        );\n        core.grantRole(\n            CoreRoles.TIMELOCK_PROPOSER,\n            AddressLib.get(\"ONBOARD_GOVERNOR_GUILD\")\n        );\n\n        // TIMELOCK_EXECUTOR\n        core.grantRole(CoreRoles.TIMELOCK_EXECUTOR, address(0)); // anyone can execute\n\n        // TIMELOCK_CANCELLER\n\n        core.grantRole(\n            CoreRoles.TIMELOCK_CANCELLER,\n            AddressLib.get(\"DAO_VETO_CREDIT\")\n        );\n        core.grantRole(\n            CoreRoles.TIMELOCK_CANCELLER,\n            AddressLib.get(\"DAO_VETO_GUILD\")\n        );\n        core.grantRole(\n            CoreRoles.TIMELOCK_CANCELLER,\n            AddressLib.get(\"ONBOARD_VETO_CREDIT\")\n        );\n        core.grantRole(\n            CoreRoles.TIMELOCK_CANCELLER,\n            AddressLib.get(\"ONBOARD_VETO_GUILD\")\n        );\n        core.grantRole(\n            CoreRoles.TIMELOCK_CANCELLER,\n            AddressLib.get(\"DAO_GOVERNOR_GUILD\")\n        );\n        core.grantRole(\n            CoreRoles.TIMELOCK_CANCELLER,\n            AddressLib.get(\"ONBOARD_GOVERNOR_GUILD\")\n        );\n\n        // Configuration\n        ProfitManager(AddressLib.get(\"PROFIT_MANAGER\")).initializeReferences(\n            AddressLib.get(\"ERC20_GUSDC\"),\n            AddressLib.get(\"ERC20_GUILD\"),\n            AddressLib.get(\"PSM_USDC\")\n        );\n        ProfitManager(AddressLib.get(\"PROFIT_MANAGER\"))\n            .setProfitSharingConfig(\n                SURPLUS_BUFFER_SPLIT, // 9% surplusBufferSplit\n                CREDIT_SPLIT, // 90% creditSplit\n                GUILD_SPLIT, // 1% guildSplit\n                OTHER_SPLIT, // otherSplit\n                OTHER_ADDRESS // otherRecipient\n            );\n        GuildToken(AddressLib.get(\"ERC20_GUILD\")).setCanExceedMaxGauges(\n            AddressLib.get(\"SURPLUS_GUILD_MINTER\"),\n            true\n        );\n        GuildToken(AddressLib.get(\"ERC20_GUILD\")).setMaxGauges(10);\n        GuildToken(AddressLib.get(\"ERC20_GUILD\")).addGauge(\n            1,\n            AddressLib.get(\"TERM_SDAI_1\")\n        );\n        GuildToken(AddressLib.get(\"ERC20_GUILD\")).setMaxDelegates(\n            MAX_DELEGATES\n        );\n        CreditToken(AddressLib.get(\"ERC20_GUSDC\")).setMaxDelegates(\n            MAX_DELEGATES\n        );\n\n        // deployer renounces governor role\n        core.renounceRole(CoreRoles.GOVERNOR, deployer);\n        core.renounceRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS, deployer);\n        core.renounceRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS, deployer);\n        core.renounceRole(CoreRoles.GAUGE_PARAMETERS, deployer);\n        core.renounceRole(CoreRoles.GAUGE_ADD, deployer);\n    }\n\n    function run(address deployer) public pure {}\n\n    function teardown(address deployer) public pure {}\n\n    function validate(address deployer) public {\n        /// CORE Verification\n        Core core = Core(AddressLib.get(\"CORE\"));\n        {\n            assertEq(\n                address(core),\n                address(SimplePSM(AddressLib.get(\"PSM_USDC\")).core()),\n                \"USDC PSM Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(LendingTerm(AddressLib.get(\"TERM_SDAI_1\")).core()),\n                \"sDAI Term Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(\n                    LendingTerm(AddressLib.get(\"ONBOARD_VETO_GUILD\")).core()\n                ),\n                \"ONBOARD_VETO_GUILD Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(\n                    LendingTerm(AddressLib.get(\"OFFBOARD_GOVERNOR_GUILD\"))\n                        .core()\n                ),\n                \"OFFBOARD_GOVERNOR_GUILD Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(\n                    LendingTerm(AddressLib.get(\"ONBOARD_TIMELOCK\")).core()\n                ),\n                \"ONBOARD_TIMELOCK Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(\n                    LendingTerm(AddressLib.get(\"ONBOARD_GOVERNOR_GUILD\"))\n                        .core()\n                ),\n                \"ONBOARD_GOVERNOR_GUILD Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(\n                    LendingTerm(AddressLib.get(\"DAO_VETO_GUILD\")).core()\n                ),\n                \"DAO_VETO_GUILD Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(\n                    LendingTerm(AddressLib.get(\"DAO_VETO_CREDIT\")).core()\n                ),\n                \"DAO_VETO_CREDIT Incorrect Core Address\"\n            );\n\n            CreditToken credit = CreditToken(AddressLib.get(\"ERC20_GUSDC\"));\n            GuildToken guild = GuildToken(AddressLib.get(\"ERC20_GUILD\"));\n            LendingTermOnboarding onboarder = LendingTermOnboarding(\n                payable(AddressLib.get(\"ONBOARD_GOVERNOR_GUILD\"))\n            );\n            LendingTermOffboarding offboarding = LendingTermOffboarding(\n                payable(AddressLib.get(\"OFFBOARD_GOVERNOR_GUILD\"))\n            );\n            GuildTimelockController timelock = GuildTimelockController(\n                payable(AddressLib.get(\"DAO_TIMELOCK\"))\n            );\n            SurplusGuildMinter sgm = SurplusGuildMinter(\n                AddressLib.get(\"SURPLUS_GUILD_MINTER\")\n            );\n            ProfitManager profitManager = ProfitManager(\n                AddressLib.get(\"PROFIT_MANAGER\")\n            );\n            RateLimitedMinter rateLimitedCreditMinter = RateLimitedMinter(\n                AddressLib.get(\"RATE_LIMITED_CREDIT_MINTER\")\n            );\n            RateLimitedMinter rateLimitedGuildMinter = RateLimitedMinter(\n                AddressLib.get(\"RATE_LIMITED_GUILD_MINTER\")\n            );\n            AuctionHouse auctionHouse = AuctionHouse(\n                AddressLib.get(\"AUCTION_HOUSE\")\n            );\n            GuildGovernor governor = GuildGovernor(\n                payable(AddressLib.get(\"DAO_GOVERNOR_GUILD\"))\n            );\n            GuildVetoGovernor vetoGovernorCredit = GuildVetoGovernor(\n                payable(AddressLib.get(\"ONBOARD_VETO_CREDIT\"))\n            );\n\n            assertEq(\n                address(core),\n                address(profitManager.core()),\n                \"Profit Manager Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(sgm.core()),\n                \"Surplus Guild Minter Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(guild.core()),\n                \"Guild Token Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(credit.core()),\n                \"Credit Token Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(timelock.core()),\n                \"Timelock Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(governor.core()),\n                \"Governor Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(onboarder.core()),\n                \"Onboarder Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(offboarding.core()),\n                \"Offboarding Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(auctionHouse.core()),\n                \"Auction House Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(vetoGovernorCredit.core()),\n                \"Veto Governor Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(rateLimitedGuildMinter.core()),\n                \"Rate Limited Guild Minter Incorrect Core Address\"\n            );\n            assertEq(\n                address(core),\n                address(rateLimitedCreditMinter.core()),\n                \"Rate Limited Credit Minter Incorrect Core Address\"\n            );\n        }\n\n        /// PSM Verification\n        {\n            SimplePSM psm = SimplePSM(AddressLib.get(\"PSM_USDC\"));\n\n            assertEq(\n                psm.pegToken(),\n                AddressLib.get(\"ERC20_USDC\"),\n                \"USDC PSM Incorrect Peg Token Address\"\n            );\n            assertEq(\n                psm.decimalCorrection(),\n                1e12,\n                \"USDC PSM Incorrect Decimal Correction\"\n            );\n            assertEq(\n                psm.credit(),\n                AddressLib.get(\"ERC20_GUSDC\"),\n                \"USDC PSM Incorrect Credit Token Address\"\n            );\n            assertEq(\n                psm.profitManager(),\n                AddressLib.get(\"PROFIT_MANAGER\"),\n                \"USDC PSM Incorrect Profit Manager Address\"\n            );\n        }\n\n        /// Rate Limited Minter Verification\n        {\n            RateLimitedMinter rateLimitedCreditMinter = RateLimitedMinter(\n                AddressLib.get(\"RATE_LIMITED_CREDIT_MINTER\")\n            );\n            assertEq(\n                rateLimitedCreditMinter.MAX_RATE_LIMIT_PER_SECOND(),\n                0,\n                \"credit max rate limit per second\"\n            );\n            assertEq(\n                rateLimitedCreditMinter.token(),\n                AddressLib.get(\"ERC20_GUSDC\"),\n                \"credit token incorrect\"\n            );\n            assertEq(\n                rateLimitedCreditMinter.role(),\n                CoreRoles.RATE_LIMITED_CREDIT_MINTER,\n                \"credit minter role incorrect\"\n            );\n            assertEq(\n                rateLimitedCreditMinter.rateLimitPerSecond(),\n                0,\n                \"rate limit per second credit incorrect\"\n            );\n            assertEq(\n                CREDIT_HARDCAP,\n                rateLimitedCreditMinter.bufferCap(),\n                \"credit buffercap incorrect\"\n            );\n            assertEq(\n                rateLimitedCreditMinter.buffer(),\n                rateLimitedCreditMinter.bufferCap(),\n                \"credit buffer incorrect, should eq buffer cap\"\n            );\n        }\n        {\n            RateLimitedMinter rateLimitedGuildMinter = RateLimitedMinter(\n                AddressLib.get(\"RATE_LIMITED_GUILD_MINTER\")\n            );\n            assertEq(\n                rateLimitedGuildMinter.MAX_RATE_LIMIT_PER_SECOND(),\n                0,\n                \"guild max rate limit per second\"\n            );\n            assertEq(\n                rateLimitedGuildMinter.token(),\n                AddressLib.get(\"ERC20_GUILD\"),\n                \"guild token incorrect address rl guild minter\"\n            );\n            assertEq(\n                rateLimitedGuildMinter.role(),\n                CoreRoles.RATE_LIMITED_GUILD_MINTER,\n                \"guild minter role incorrect rl guild minter\"\n            );\n            assertEq(\n                rateLimitedGuildMinter.rateLimitPerSecond(),\n                0,\n                \"rate limit per second guild incorrect\"\n            );\n            assertEq(\n                rateLimitedGuildMinter.bufferCap(),\n                GUILD_SUPPLY,\n                \"guild buffercap incorrect\"\n            );\n            assertEq(\n                rateLimitedGuildMinter.buffer(),\n                GUILD_SUPPLY,\n                \"guild buffer incorrect\"\n            );\n        }\n\n        /// GUILD and CREDIT Token Total Supply and balances\n        {\n            assertEq(\n                ERC20MultiVotes(AddressLib.get(\"ERC20_GUSDC\"))\n                    .maxDelegates(),\n                MAX_DELEGATES,\n                \"max delegates incorrect\"\n            );\n            /// guild token starts non-transferrable\n            assertFalse(\n                GuildToken(AddressLib.get(\"ERC20_GUILD\")).transferable(),\n                \"guild token should not be transferable\"\n            );\n            assertEq(\n                ERC20MultiVotes(AddressLib.get(\"ERC20_GUILD\"))\n                    .maxDelegates(),\n                MAX_DELEGATES,\n                \"max delegates incorrect\"\n            );\n            assertEq(\n                ERC20MultiVotes(AddressLib.get(\"ERC20_GUILD\")).totalSupply(),\n                0,\n                \"guild total supply not 0 after deployment\"\n            );\n            assertEq(\n                ERC20MultiVotes(AddressLib.get(\"ERC20_GUILD\")).balanceOf(\n                    AddressLib.get(\"TEAM_MULTISIG\")\n                ),\n                0,\n                \"balance of team multisig not 0 after deployment\"\n            );\n            assertEq(\n                ERC20MultiVotes(AddressLib.get(\"ERC20_GUSDC\"))\n                    .totalSupply(),\n                0,\n                \"credit total supply not 0 after deployment\"\n            );\n            assertEq(\n                ERC20MultiVotes(AddressLib.get(\"ERC20_GUSDC\")).balanceOf(\n                    deployer\n                ),\n                0,\n                \"balance of deployer not 0 after deployment\"\n            );\n        }\n        /// PROFIT MANAGER Verification\n        {\n            assertEq(\n                ProfitManager(AddressLib.get(\"PROFIT_MANAGER\")).credit(),\n                AddressLib.get(\"ERC20_GUSDC\"),\n                \"Profit Manager credit token incorrect\"\n            );\n            assertEq(\n                ProfitManager(AddressLib.get(\"PROFIT_MANAGER\")).guild(),\n                AddressLib.get(\"ERC20_GUILD\"),\n                \"Profit Manager guild token incorrect\"\n            );\n            assertEq(\n                ProfitManager(AddressLib.get(\"PROFIT_MANAGER\"))\n                    .surplusBuffer(),\n                0,\n                \"Profit Manager surplus buffer incorrect\"\n            );\n\n            (\n                uint256 surplusBufferSplit,\n                uint256 creditSplit,\n                uint256 guildSplit,\n                uint256 otherSplit,\n                address otherRecipient\n            ) = ProfitManager(AddressLib.get(\"PROFIT_MANAGER\"))\n                    .getProfitSharingConfig();\n\n            assertEq(\n                surplusBufferSplit,\n                SURPLUS_BUFFER_SPLIT,\n                \"Profit Manager surplus buffer split incorrect\"\n            );\n            assertEq(\n                creditSplit,\n                CREDIT_SPLIT,\n                \"Profit Manager credit split incorrect\"\n            );\n            assertEq(\n                guildSplit,\n                GUILD_SPLIT,\n                \"Profit Manager guild split incorrect\"\n            );\n            assertEq(\n                otherSplit,\n                OTHER_SPLIT,\n                \"Profit Manager other split incorrect\"\n            );\n            assertEq(\n                otherRecipient,\n                OTHER_ADDRESS,\n                \"Profit Manager other recipient incorrect\"\n            );\n        }\n        /// TIMELOCK Verification\n        {\n            GuildTimelockController timelock = GuildTimelockController(\n                payable(AddressLib.get(\"DAO_TIMELOCK\"))\n            );\n\n            assertEq(\n                timelock.getMinDelay(),\n                DAO_TIMELOCK_DELAY,\n                \"DAO Timelock delay incorrect\"\n            );\n\n            GuildTimelockController onboardingTimelock = GuildTimelockController(\n                payable(AddressLib.get(\"ONBOARD_TIMELOCK\"))\n            );"
    }
  ]
}