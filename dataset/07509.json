{
  "Title": "[M-08] Unsafe downcasting operation truncate user's input",
  "Content": "\n<https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L71>\n\n<https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L82>\n\n<https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L101>\n\n<https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/FixedPrice.sol#L62>\n\n### Impact\n\nUnsafe downcasting operation truncates user's input.\n\n### Proof of Concept\n\nThere are a few unsafe downcasting operation that truncates user's input. The impact can be severe or minimal.\n\nIn FixedPrice.sol,\n\n```solidity\n/// @notice buy from a fixed price sale after the sale starts\n/// @param _amount the amount of editions to buy\nfunction buy(uint256 _amount) external payable {\n\tSale memory sale_ = sale;\n\tIEscher721 nft = IEscher721(sale_.edition);\n\trequire(block.timestamp >= sale_.startTime, \"TOO SOON\");\n\trequire(_amount * sale_.price == msg.value, \"WRONG PRICE\");\n\tuint48 newId = uint48(_amount) + sale_.currentId;\n\trequire(newId <= sale_.finalId, \"TOO MANY\");\n\n\tfor (uint48 x = sale_.currentId + 1; x <= newId; x++) {\n\t\tnft.mint(msg.sender, x);\n\t}\n\n\tsale.currentId = newId;\n\n\temit Buy(msg.sender, _amount, msg.value, sale);\n\n\tif (newId == sale_.finalId) _end(sale);\n}\n```\n\nThe amount is unsafely downcasted from uint256 to uint48, note the code:\n\n```solidity\nrequire(_amount * sale_.price == msg.value, \"WRONG PRICE\");\nuint48 newId = uint48(_amount) + sale_.currentId;\n```\n\nThe upper limit for uint48 is 281474976710655,\n\nIf user wants to buy more than 281474976710655 amount of NFT and pay the 281474976710655 \\* sale price amount, the user can only receive 281474976710655 amount of NFT because of the downcasting.\n\nIn LPDA.sol, we are unsafely downcasting the price in the buy function:\n\n```solidity\nreceipts[msg.sender].amount += amount;\nreceipts[msg.sender].balance += uint80(msg.value);\n\nfor (uint256 x = temp.currentId + 1; x <= newId; x++) {\n\tnft.mint(msg.sender, x);\n}\n\nsale.currentId = newId;\n\nemit Buy(msg.sender, amount, msg.value, temp);\n\nif (newId == temp.finalId) {\n\tsale.finalPrice = uint80(price);\n\tuint256 totalSale = price * amountSold;\n\tuint256 fee = totalSale / 20;\n\tISaleFactory(factory).feeReceiver().transfer(fee);\n\ttemp.saleReceiver.transfer(totalSale - fee);\n\t_end();\n}\n```\n\nNote the line:\n\nuint80(msg.value) and uint80(price)\n\nIn LPDA.sol, same issue exists in the refund function:\n\n```solidity\n/// @notice allow a buyer to get a refund on the current price difference\nfunction refund() public {\n\tReceipt memory r = receipts[msg.sender];\n\tuint80 price = uint80(getPrice()) * r.amount;\n\tuint80 owed = r.balance - price;\n\trequire(owed > 0, \"NOTHING TO REFUND\");\n\treceipts[msg.sender].balance = price;\n\tpayable(msg.sender).transfer(owed);\n}\n```\n\nNote the downcasting: `uint80(getPrice())`\n\nThis means if the price goes above uint80, it will be wrongly truncated to uint80 for price.\n\nThe Downcasting in LPDA.sol is damaging because it truncated user's fund.\n\nBelow is the POC:\n\nAdd test in LPDA.t.sol\n\n<https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/test/LPDA.t.sol#L167>\n\n```solidity\n    function test_LPDA_downcasting_POC() public {\n\n        // make the lpda sales contract\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n        // authorize the lpda sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        //lets buy an NFT\n\n        uint256 val = uint256(type(uint80).max) + 10 ether;\n        console.log('msg.value');\n        console.log(val);\n        sale.buy{value: val}(1);\n    \n    }\n```\n\nAnd import \"forge-std/console.sol\" in LPDA.sol:\n\n<https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L3>\n\n```solidity\nimport \"forge-std/console.sol\";\n```\n\nAnd add console.log in LPDA.sol buy function.\n\n<https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L69>\n\n```solidity\nreceipts[msg.sender].amount += amount;\nreceipts[msg.sender].balance += uint80(msg.value);\n\nconsole.log(\"truncated value\");\nconsole.log(receipts[msg.sender].balance);\n```\n\nWe run our test:\n\n```solidity\nforge test -vv --match test_LPDA_downcasting_POC\n```\n\nThe output is:\n\n```solidity\nRunning 1 test for test/LPDA.t.sol:LPDATest\n[PASS] test_LPDA_downcasting_POC() (gas: 385619)\nLogs:\n  msg.value\n  1208935819614629174706175\n  truncated value\n  9999999999999999999\n\nTest result: ok. 1 passed; 0 failed; finished in 3.61ms\n```\n\nAs we can see, user uses 1208935819614629174706175 to buy in LPDA.sol but the balance is truncated to 9999999999999999999, later user is not able to get the refund they are entitled to because the msg.value is unsafely downcasted.\n\nAlso note the downcasting for getPrice in LPDA.sol is also a issue:\n\nThe getPrice in LPDA.sol returns a uint256\n\n```solidity\n/// @notice the price of the sale\nfunction getPrice() public view returns (uint256) {\n\tSale memory temp = sale;\n\t(uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n\tif (block.timestamp < start) return type(uint256).max;\n\tif (temp.currentId == temp.finalId) return temp.finalPrice;\n\n\tuint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;\n\treturn temp.startPrice - (temp.dropPerSecond * timeElapsed);\n}\n```\n\nBut this is downcasted into uint80 in function buy and refund.\n\n```solidity\nuint80 price = uint80(getPrice()) * r.amount;\n```\n\n### Recommended Mitigation Steps\n\nWe recommend the project handle downcasting and use safe casting library to make sure the downcast does not provide an unexpected truncate value.\n\n<https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast>\n\n**[stevennevins (Escher) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-12-escher-findings/issues/369#issuecomment-1363388280):**\n > Scenarios seem pretty unlikely but we should just handle these truncations better.\n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2022-12-escher-findings/issues/369#issuecomment-1369790428):**\n >  While very unlikely, it could result in a loss of funds for the user. Therefore, I consider Medium severity to be appropriate.\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-escher-contest",
  "Code": [
    {
      "filename": "src/minters/LPDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract LPDA is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint80 startPrice;\n        uint80 finalPrice;\n        uint80 dropPerSecond;\n        // slot 3\n        uint96 endTime;\n        address payable saleReceiver;\n        // slot 4\n        uint96 startTime;\n    }\n\n    struct Receipt {\n        uint48 amount;\n        uint80 balance;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n    uint48 public amountSold = 0;\n\n    /// @notice tracked the amount paid by people during the LPDA\n    mapping(address => Receipt) public receipts;\n\n    event Start(Sale _saleInfo);\n    event End(Sale _saleInfo);\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        uint48 x = type(uint48).max;\n        uint80 y = type(uint80).max;\n        uint96 z = type(uint96).max;\n        address payable i = payable(address(0));\n        sale = LPDA.Sale(x, x, i, y, y, y, z, i, z);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint48 amount = uint48(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        uint256 price = getPrice();\n        require(msg.value >= amount * price, \"WRONG PRICE\");\n\n        amountSold += amount;\n        uint48 newId = amount + temp.currentId;\n        require(newId <= temp.finalId, \"TOO MANY\");\n\n        receipts[msg.sender].amount += amount;\n        receipts[msg.sender].balance += uint80(msg.value);\n\n        for (uint256 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n\n        if (newId == temp.finalId) {\n            sale.finalPrice = uint80(price);\n            uint256 totalSale = price * amountSold;\n            uint256 fee = totalSale / 20;\n            ISaleFactory(factory).feeReceiver().transfer(fee);\n            temp.saleReceiver.transfer(totalSale - fee);\n            _end();\n        }\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        sale.finalId = sale.currentId;\n        _end();\n    }\n\n    /// @notice allow a buyer to get a refund on the current price difference\n    function refund() public {\n        Receipt memory r = receipts[msg.sender];\n        uint80 price = uint80(getPrice()) * r.amount;\n        uint80 owed = r.balance - price;\n        require(owed > 0, \"NOTHING TO REFUND\");\n        receipts[msg.sender].balance = price;\n        payable(msg.sender).transfer(owed);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale calldata _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        Sale memory temp = sale;\n        (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n        if (block.timestamp < start) return type(uint256).max;\n        if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n        uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;\n        return temp.startPrice - (temp.dropPerSecond * timeElapsed);\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    function lowestPrice() public view returns (uint256) {\n        return sale.startPrice - (sale.dropPerSecond * (sale.endTime - sale.startTime));\n    }\n\n    function _end() internal {\n        emit End(sale);\n    }\n}"
    },
    {
      "filename": "src/minters/LPDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract LPDA is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint80 startPrice;\n        uint80 finalPrice;\n        uint80 dropPerSecond;\n        // slot 3\n        uint96 endTime;\n        address payable saleReceiver;\n        // slot 4\n        uint96 startTime;\n    }\n\n    struct Receipt {\n        uint48 amount;\n        uint80 balance;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n    uint48 public amountSold = 0;\n\n    /// @notice tracked the amount paid by people during the LPDA\n    mapping(address => Receipt) public receipts;\n\n    event Start(Sale _saleInfo);\n    event End(Sale _saleInfo);\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        uint48 x = type(uint48).max;\n        uint80 y = type(uint80).max;\n        uint96 z = type(uint96).max;\n        address payable i = payable(address(0));\n        sale = LPDA.Sale(x, x, i, y, y, y, z, i, z);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint48 amount = uint48(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        uint256 price = getPrice();\n        require(msg.value >= amount * price, \"WRONG PRICE\");\n\n        amountSold += amount;\n        uint48 newId = amount + temp.currentId;\n        require(newId <= temp.finalId, \"TOO MANY\");\n\n        receipts[msg.sender].amount += amount;\n        receipts[msg.sender].balance += uint80(msg.value);\n\n        for (uint256 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n\n        if (newId == temp.finalId) {\n            sale.finalPrice = uint80(price);\n            uint256 totalSale = price * amountSold;\n            uint256 fee = totalSale / 20;\n            ISaleFactory(factory).feeReceiver().transfer(fee);\n            temp.saleReceiver.transfer(totalSale - fee);\n            _end();\n        }\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        sale.finalId = sale.currentId;\n        _end();\n    }\n\n    /// @notice allow a buyer to get a refund on the current price difference\n    function refund() public {\n        Receipt memory r = receipts[msg.sender];\n        uint80 price = uint80(getPrice()) * r.amount;\n        uint80 owed = r.balance - price;\n        require(owed > 0, \"NOTHING TO REFUND\");\n        receipts[msg.sender].balance = price;\n        payable(msg.sender).transfer(owed);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale calldata _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        Sale memory temp = sale;\n        (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n        if (block.timestamp < start) return type(uint256).max;\n        if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n        uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;\n        return temp.startPrice - (temp.dropPerSecond * timeElapsed);\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    function lowestPrice() public view returns (uint256) {\n        return sale.startPrice - (sale.dropPerSecond * (sale.endTime - sale.startTime));\n    }\n\n    function _end() internal {\n        emit End(sale);\n    }\n}"
    },
    {
      "filename": "src/minters/LPDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract LPDA is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint80 startPrice;\n        uint80 finalPrice;\n        uint80 dropPerSecond;\n        // slot 3\n        uint96 endTime;\n        address payable saleReceiver;\n        // slot 4\n        uint96 startTime;\n    }\n\n    struct Receipt {\n        uint48 amount;\n        uint80 balance;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n    uint48 public amountSold = 0;\n\n    /// @notice tracked the amount paid by people during the LPDA\n    mapping(address => Receipt) public receipts;\n\n    event Start(Sale _saleInfo);\n    event End(Sale _saleInfo);\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        uint48 x = type(uint48).max;\n        uint80 y = type(uint80).max;\n        uint96 z = type(uint96).max;\n        address payable i = payable(address(0));\n        sale = LPDA.Sale(x, x, i, y, y, y, z, i, z);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint48 amount = uint48(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        uint256 price = getPrice();\n        require(msg.value >= amount * price, \"WRONG PRICE\");\n\n        amountSold += amount;\n        uint48 newId = amount + temp.currentId;\n        require(newId <= temp.finalId, \"TOO MANY\");\n\n        receipts[msg.sender].amount += amount;\n        receipts[msg.sender].balance += uint80(msg.value);\n\n        for (uint256 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n\n        if (newId == temp.finalId) {\n            sale.finalPrice = uint80(price);\n            uint256 totalSale = price * amountSold;\n            uint256 fee = totalSale / 20;\n            ISaleFactory(factory).feeReceiver().transfer(fee);\n            temp.saleReceiver.transfer(totalSale - fee);\n            _end();\n        }\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        sale.finalId = sale.currentId;\n        _end();\n    }\n\n    /// @notice allow a buyer to get a refund on the current price difference\n    function refund() public {\n        Receipt memory r = receipts[msg.sender];\n        uint80 price = uint80(getPrice()) * r.amount;\n        uint80 owed = r.balance - price;\n        require(owed > 0, \"NOTHING TO REFUND\");\n        receipts[msg.sender].balance = price;\n        payable(msg.sender).transfer(owed);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale calldata _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        Sale memory temp = sale;\n        (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n        if (block.timestamp < start) return type(uint256).max;\n        if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n        uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;\n        return temp.startPrice - (temp.dropPerSecond * timeElapsed);\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    function lowestPrice() public view returns (uint256) {\n        return sale.startPrice - (sale.dropPerSecond * (sale.endTime - sale.startTime));\n    }\n\n    function _end() internal {\n        emit End(sale);\n    }\n}"
    },
    {
      "filename": "src/minters/FixedPrice.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract FixedPrice is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// store nextId and remainingSupply, where nextId increases and remainingSupply decreases to 0\n    /// avoids strict equality of current == final\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint96 price;\n        address payable saleReceiver;\n        // slot 3\n        uint96 startTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(0, 0, address(0), type(uint96).max, payable(0), type(uint96).max);\n    }\n\n    /// @notice Owner can cancel current sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        Sale memory sale_ = sale;\n        IEscher721 nft = IEscher721(sale_.edition);\n        require(block.timestamp >= sale_.startTime, \"TOO SOON\");\n        require(_amount * sale_.price == msg.value, \"WRONG PRICE\");\n        uint48 newId = uint48(_amount) + sale_.currentId;\n        require(newId <= sale_.finalId, \"TOO MANY\");\n\n        for (uint48 x = sale_.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, _amount, msg.value, sale);\n\n        if (newId == sale_.finalId) _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(_sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice cancel a fixed price sale\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    /// @notice Owner can cancel current sale\n    /// @param _sale the sale info\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        selfdestruct(_sale.saleReceiver);\n    }\n}"
    },
    {
      "filename": "test/LPDA.t.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport {EscherTest} from \"./utils/EscherTest.sol\";\nimport {LPDAFactory, LPDA} from \"src/minters/LPDAFactory.sol\";\n\ncontract LPDABase is EscherTest {\n    LPDAFactory public lpdaSales;\n    LPDA.Sale public lpdaSale;\n\n    function setUp() public virtual override {\n        super.setUp();\n        lpdaSales = new LPDAFactory();\n        // set up a LPDA Sale\n        lpdaSale = LPDA.Sale({\n            currentId: uint48(0),\n            finalId: uint48(10),\n            edition: address(edition),\n            startPrice: uint80(uint256(1 ether)),\n            finalPrice: uint80(uint256(0.1 ether)),\n            dropPerSecond: uint80(uint256(0.1 ether) / 1 days),\n            startTime: uint96(block.timestamp),\n            saleReceiver: payable(address(69)),\n            endTime: uint96(block.timestamp + 1 days)\n        });\n    }\n}\n\ncontract LPDAFactoryTest is LPDABase {\n    function test_WhenOwner_SetFeeReceiver() public {\n        assertEq(address(lpdaSales.feeReceiver()), address(this));\n        lpdaSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(lpdaSales.feeReceiver()), address(69));\n    }\n\n    function test_RevertsWhenNotOwner_SetFeeReceiver() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        lpdaSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(lpdaSales.feeReceiver()), address(this));\n    }\n\n    function test_WhenOwner_TransferOwner() public {\n        lpdaSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwner() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        lpdaSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotAdmin_CreateSale() public {\n        vm.prank(address(69));\n        vm.expectRevert(\"NOT AUTHORIZED\");\n        lpdaSales.createLPDASale(lpdaSale);\n    }\n\n    function test_CreateSale() public {\n        lpdaSales.createLPDASale(lpdaSale);\n    }\n}\n\ncontract LPDATest is LPDABase {\n    LPDA public sale;\n    event End(LPDA.Sale _saleInfo);\n\n    function test_Buy() public {\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n        // authorize the lpda sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        //lets buy an NFT\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n    }\n\n    function test_RevertsWhenTooSoon_Buy() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"TOO SOON\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenTooLittleValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 0 ether}(1);\n    }\n\n    function test_RevertsWhenEnded_Buy() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime);\n\n        sale.buy{value: 9 ether}(9);\n    }\n\n    function test_SellsOut_Buy() public {\n        test_Buy();\n\n        sale.buy{value: 9 ether}(9);\n    }\n\n    function test_RevertsWhenSoldOut_Buy() public {\n        test_SellsOut_Buy();\n\n        vm.expectRevert(\"TOO MANY\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenNotOwner_Cancel() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.cancel();\n    }\n\n    function test_RevertsWhenTooLate_Cancel() public {\n        test_Buy();\n\n        vm.prank(address(69));\n        vm.expectRevert(\"TOO LATE\");\n        sale.cancel();\n    }\n\n    function test_Cancel() public {\n        lpdaSale.startTime = uint96(block.timestamp + 1);\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n\n        vm.prank(address(69));\n        sale.cancel();\n    }\n\n    function test_Refund() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime + 1);\n        sale.refund();\n    }\n\n    function test_WhenNotOver_Refund() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime - 1);\n        sale.refund();\n    }\n\n    function test_RevertsWhenNoRefund_Refund() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime + 1);\n        vm.expectRevert(\"NOTHING TO REFUND\");\n        vm.prank(address(69));\n        sale.refund();\n    }\n\n    function test_RevertsWhenAlreadyRefunded_Refund() public {\n        test_Refund();\n\n        vm.expectRevert(\"NOTHING TO REFUND\");\n        sale.refund();\n    }\n\n    function test_LPDA() public {\n        // make the lpda sales contract\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n        // authorize the lpda sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        //lets buy an NFT\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n\n        vm.warp(block.timestamp + 1 days);\n        assertApproxEqRel(sale.getPrice(), 0.9 ether, lpdaSale.dropPerSecond);\n\n        // buy the rest\n        // this will auto end the sale\n        sale.buy{value: uint256((0.9 ether + lpdaSale.dropPerSecond) * 9)}(9);\n\n        vm.warp(block.timestamp + 2 days);\n\n        // now lets get a refund\n        uint256 bal = address(this).balance;\n        sale.refund();\n        assertApproxEqRel(address(this).balance, bal + 0.1 ether, lpdaSale.dropPerSecond);\n    }\n}"
    },
    {
      "filename": "src/minters/LPDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract LPDA is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint80 startPrice;\n        uint80 finalPrice;\n        uint80 dropPerSecond;\n        // slot 3\n        uint96 endTime;\n        address payable saleReceiver;\n        // slot 4\n        uint96 startTime;\n    }\n\n    struct Receipt {\n        uint48 amount;\n        uint80 balance;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n    uint48 public amountSold = 0;\n\n    /// @notice tracked the amount paid by people during the LPDA\n    mapping(address => Receipt) public receipts;\n\n    event Start(Sale _saleInfo);\n    event End(Sale _saleInfo);\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        uint48 x = type(uint48).max;\n        uint80 y = type(uint80).max;\n        uint96 z = type(uint96).max;\n        address payable i = payable(address(0));\n        sale = LPDA.Sale(x, x, i, y, y, y, z, i, z);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint48 amount = uint48(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        uint256 price = getPrice();\n        require(msg.value >= amount * price, \"WRONG PRICE\");\n\n        amountSold += amount;\n        uint48 newId = amount + temp.currentId;\n        require(newId <= temp.finalId, \"TOO MANY\");\n\n        receipts[msg.sender].amount += amount;\n        receipts[msg.sender].balance += uint80(msg.value);\n\n        for (uint256 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n\n        if (newId == temp.finalId) {\n            sale.finalPrice = uint80(price);\n            uint256 totalSale = price * amountSold;\n            uint256 fee = totalSale / 20;\n            ISaleFactory(factory).feeReceiver().transfer(fee);\n            temp.saleReceiver.transfer(totalSale - fee);\n            _end();\n        }\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        sale.finalId = sale.currentId;\n        _end();\n    }\n\n    /// @notice allow a buyer to get a refund on the current price difference\n    function refund() public {\n        Receipt memory r = receipts[msg.sender];\n        uint80 price = uint80(getPrice()) * r.amount;\n        uint80 owed = r.balance - price;\n        require(owed > 0, \"NOTHING TO REFUND\");\n        receipts[msg.sender].balance = price;\n        payable(msg.sender).transfer(owed);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale calldata _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        Sale memory temp = sale;\n        (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n        if (block.timestamp < start) return type(uint256).max;\n        if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n        uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;\n        return temp.startPrice - (temp.dropPerSecond * timeElapsed);\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    function lowestPrice() public view returns (uint256) {\n        return sale.startPrice - (sale.dropPerSecond * (sale.endTime - sale.startTime));\n    }\n\n    function _end() internal {\n        emit End(sale);\n    }\n}"
    },
    {
      "filename": "src/minters/LPDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract LPDA is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint80 startPrice;\n        uint80 finalPrice;\n        uint80 dropPerSecond;\n        // slot 3\n        uint96 endTime;\n        address payable saleReceiver;\n        // slot 4\n        uint96 startTime;\n    }\n\n    struct Receipt {\n        uint48 amount;\n        uint80 balance;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n    uint48 public amountSold = 0;\n\n    /// @notice tracked the amount paid by people during the LPDA\n    mapping(address => Receipt) public receipts;\n\n    event Start(Sale _saleInfo);\n    event End(Sale _saleInfo);\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        uint48 x = type(uint48).max;\n        uint80 y = type(uint80).max;\n        uint96 z = type(uint96).max;\n        address payable i = payable(address(0));\n        sale = LPDA.Sale(x, x, i, y, y, y, z, i, z);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint48 amount = uint48(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        uint256 price = getPrice();\n        require(msg.value >= amount * price, \"WRONG PRICE\");\n\n        amountSold += amount;\n        uint48 newId = amount + temp.currentId;\n        require(newId <= temp.finalId, \"TOO MANY\");\n\n        receipts[msg.sender].amount += amount;\n        receipts[msg.sender].balance += uint80(msg.value);\n\n        for (uint256 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n\n        if (newId == temp.finalId) {\n            sale.finalPrice = uint80(price);\n            uint256 totalSale = price * amountSold;\n            uint256 fee = totalSale / 20;\n            ISaleFactory(factory).feeReceiver().transfer(fee);\n            temp.saleReceiver.transfer(totalSale - fee);\n            _end();\n        }\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        sale.finalId = sale.currentId;\n        _end();\n    }\n\n    /// @notice allow a buyer to get a refund on the current price difference"
    }
  ]
}