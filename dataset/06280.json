{
  "Title": "[M-02] Due to slot confusion, reserve amounts in the pump will be corrupted, resulting in wrong oracle values",
  "Content": "\n<https://github.com/code-423n4/2023-07-basin/blob/c1b72d4e372a6246e0efbd57b47fb4cbb5d77062/src/libraries/LibBytes16.sol#L45> <br><https://github.com/code-423n4/2023-07-basin/blob/c1b72d4e372a6246e0efbd57b47fb4cbb5d77062/src/libraries/LibLastReserveBytes.sol#L58>\n\n### Description\n\nThe MultiFlowPump contract stores reserve counts on every update, using the libraries LibBytes16 and LibLastReserveBytes. Those libs pack `bytes16` values efficiently with the `storeBytes16()` and `storeLastReserves` functions.\nIn case of an odd number of items, the last storage slot will be half full. Care must be taken to not step over the previous value in that slot. This is done correctly in `LibBytes`:\n\n```solidity\nif (reserves.length & 1 == 1) {\n    require(reserves[reserves.length - 1] <= type(uint128).max, \"ByteStorage: too large\");\n    iByte = maxI * 64;\n    assembly {\n        sstore(\n            // @audit - overwrite SLOT+MAXI*32\n            add(slot, mul(maxI, 32)),\n                                                       // @audit - read SLOT+MAXI*32 (2nd entry)\n            add(mload(add(reserves, add(iByte, 32))), shl(128, shr(128, sload(add(slot, mul(maxI, 32))))))\n        )\n    }\n}\n```\n\nAs can be seen, it overwrites the slot with the previous 128 bits in the upper half of the slot, only setting the lower 128 bytes.\n\nHowever, the wrong slot is read in the other two libraries. For example, in `storeLastReserves()`:\n\n```solidity\nif (reserves.length & 1 == 1) {\n    iByte = maxI * 64;\n    assembly {\n        sstore(\n            // @audit - overwrite SLOT+MAXI*32\n            add(slot, mul(maxI, 32)),\n                                                      // @audit - read SLOT+MAXI (2nd entry)??\n            add(mload(add(reserves, add(iByte, 32))), shr(128, shl(128, sload(add(slot, maxI)))))\n        )\n    }\n}\n```\n\nThe error is not multiplying `maxI` before adding it to `slot`. This means that the reserves count encoded in lower 16 bytes in `add(slot, mul(maxI, 32))` will have the value of a reserve in a much lower index.\nSlots are used in 32 byte increments, i.e. S, S+32, S+64...\nWhen `maxI==0`, the intended slot and the actual slot overlap. When `maxI` is 1..31, the read slot happens to be zero (unused), so the first actual corruption occurs on `maxI==32`. By substitution, we get:\n`SLOT[32*32] = correct reserve | SLOT[32]`\nIn other words, the 4rd reserve (stored in lower 128 bits of  `SLOT[32]`) will be written to the 64th reserve.\n\nThe Basin pump is intended to support an arbitrary number of reserves safely, therefore the described storage corruption impact is in scope.\n\n### Impact\n\nReserve amounts in the pump will be corrupted, resulting in wrong oracle values.\n\n### PoC\n\n1.  A reserve update is triggered on the pump when some Well action occurs.\n2.  Suppose reserves are array `[0,1,2,...,63,64]`\n3.  Reserve count is odd, so affected code block is reached\n4.  `SLOT[32*32] = UPPER: 64 | LOWER: SLOT[32] = 64 | 3`\n\n### Recommended Mitigation Steps\n\nChange the `sload()` operation in both affected functions to `sload(add(slot, mul(maxI, 32)`\n\n**[publiuss (Basin) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-07-basin-findings/issues/260#issuecomment-1637108823):**\n > This is a valid issue as the function incorrectly stores bytes, but it doesn't break anything of the Pump as the bytes that are incorrectly stored are never read.\n> \n> Regardless it should be fixed. Recommend changing to Medium.\n\n**[alcueca (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-07-basin-findings/issues/260#issuecomment-1663973312):**\n > The bug doesn't negatively impact the code in scope, only future code.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-basin",
  "Code": [
    {
      "filename": "src/libraries/LibBytes16.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\n/**\n * @title LibBytes16\n * @author Publius\n * @notice Contains byte operations used during storage reads & writes for Pumps.\n *\n * {LibBytes16} tightly packs an array of `bytes16` values into `n / 2` storage\n * slots, where `n` is number of items to pack.\n */\nlibrary LibBytes16 {\n    bytes32 private constant ZERO_BYTES = bytes32(0);\n\n    /**\n     * @dev Store packed bytes16 `reserves` starting at storage position `slot`.\n     */\n    function storeBytes16(bytes32 slot, bytes16[] memory reserves) internal {\n        // Shortcut: two reserves can be packed into one slot without a loop\n        if (reserves.length == 2) {\n            assembly {\n                sstore(slot, add(mload(add(reserves, 32)), shr(128, mload(add(reserves, 64)))))\n            }\n        } else {\n            uint256 maxI = reserves.length / 2; // number of fully-packed slots\n            uint256 iByte; // byte offset of the current reserve\n            for (uint256 i; i < maxI; ++i) {\n                iByte = i * 64;\n                assembly {\n                    sstore(\n                        add(slot, mul(i, 32)),\n                        add(mload(add(reserves, add(iByte, 32))), shr(128, mload(add(reserves, add(iByte, 64)))))\n                    )\n                }\n            }\n            // If there is an odd number of reserves, create a slot with the last reserve\n            // Since `i < maxI` above, the next byte offset `maxI * 64`\n            // Equivalent to \"i % 2 == 1\", but cheaper.\n            if (reserves.length & 1 == 1) {\n                iByte = maxI * 64;\n                assembly {\n                    sstore(\n                        add(slot, mul(maxI, 32)),\n                        add(mload(add(reserves, add(iByte, 32))), shr(128, sload(add(slot, maxI))))\n                    )\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Read `n` packed uint128 reserves at storage position `slot`.\n     */\n    function readBytes16(bytes32 slot, uint256 n) internal view returns (bytes16[] memory reserves) {\n        // Initialize array with length `n`, fill it in via assembly\n        reserves = new bytes16[](n);\n\n        // Shortcut: two reserves can be quickly unpacked from one slot\n        if (n == 2) {\n            assembly {\n                mstore(add(reserves, 32), sload(slot))\n                mstore(add(reserves, 64), shl(128, sload(slot)))\n            }\n            return reserves;\n        }\n\n        uint256 iByte;\n        for (uint256 i = 1; i <= n; ++i) {\n            // `iByte` is the byte position for the current slot:\n            // i        1 2 3 4 5 6\n            // iByte    0 0 1 1 2 2\n            iByte = (i - 1) / 2 * 32;\n            // Equivalent to \"i % 2 == 1\" but cheaper.\n            if (i & 1 == 1) {\n                assembly {\n                    mstore(\n                        // store at index i * 32; i = 0 is skipped by loop\n                        add(reserves, mul(i, 32)),\n                        sload(add(slot, iByte))\n                    )\n                }\n            } else {\n                assembly {\n                    mstore(add(reserves, mul(i, 32)), shl(128, sload(add(slot, iByte))))\n                }\n            }\n        }\n    }\n}"
    }
  ]
}