{
  "Title": "M-12: Chainlink's latestRoundData  return stale or incorrect result",
  "Content": "# Issue M-12: Chainlink's latestRoundData  return stale or incorrect result \n\nSource: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94 \n\n## Found by \n8olidity, tsvetanovv, WatchDogs, Nyx, Avci, obront, Aymen0909, SPYBOY, HonorLt, csanuragjain, koxuan, evan, rbserver, hl\\_, peanuts, Chinmay\n\n## Summary\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/ChainlinkAdapterOracle.sol#L76\n\n## Vulnerability Detail\n\n## Impact\nOn ChainlinkAdapterOracle.sol, you are using latestRoundData, but there is no check if the return value indicates stale data. \n```solidity\nfunction getPrice(address _token) external view override returns (uint256) {\n        // remap token if possible\n        address token = remappedTokens[_token];\n        if (token == address(0)) token = _token;\n\n        uint256 maxDelayTime = maxDelayTimes[token];\n        if (maxDelayTime == 0) revert NO_MAX_DELAY(_token);\n\n        // try to get token-USD price\n        uint256 decimals = registry.decimals(token, USD);\n        (, int256 answer, , uint256 updatedAt, ) = registry.latestRoundData(\n            token,\n            USD\n        );\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert PRICE_OUTDATED(_token);\n\n        return (answer.toUint256() * 1e18) / 10**decimals;\n    }\n```\nThis could lead to stale prices according to the Chainlink documentation:\nhttps://docs.chain.link/data-feeds/price-feeds/historical-data\nRelated report:\nhttps://github.com/code-423n4/2021-05-fairside-findings/issues/70\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/ChainlinkAdapterOracle.sol#L76\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd the below check for returned data\n```solidity\nfunction getPrice(address _token) external view override returns (uint256) {\n        // remap token if possible\n        address token = remappedTokens[_token];\n        if (token == address(0)) token = _token;\n\n        uint256 maxDelayTime = maxDelayTimes[token];\n        if (maxDelayTime == 0) revert NO_MAX_DELAY(_token);\n\n        // try to get token-USD price\n        uint256 decimals = registry.decimals(token, USD);\n        (uint80 roundID, int256 answer, uint256 timestamp, uint256 updatedAt, ) = registry.latestRoundData(\n            token,\n            USD\n        );\n        //Solution\n        require(updatedAt >= roundID, \"Stale price\");\n        require(timestamp != 0,\"Round not complete\");\n        require(answer > 0,\"Chainlink answer reporting 0\");\n\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert PRICE_OUTDATED(_token);\n\n        return (answer.toUint256() * 1e18) / 10**decimals;\n    }\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/41",
  "Code": [
    {
      "filename": "contracts/oracle/ChainlinkAdapterOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BaseAdapter.sol\";\nimport \"../utils/BlueBerryErrors.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/chainlink/IFeedRegistry.sol\";\n\ncontract ChainlinkAdapterOracle is IBaseOracle, BaseAdapter {\n    using SafeCast for int256;\n\n    // Chainlink denominations\n    // (source: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/Denominations.sol)\n    IFeedRegistry public registry;\n    address public constant USD = address(840);\n\n    /// @dev Mapping from original token to remapped token for price querying (e.g. WBTC -> BTC, renBTC -> BTC)\n    mapping(address => address) public remappedTokens;\n\n    event SetRegistry(address registry);\n    event SetTokenRemapping(\n        address indexed token,\n        address indexed remappedToken\n    );\n\n    constructor(IFeedRegistry registry_) {\n        if (address(registry_) == address(0)) revert ZERO_ADDRESS();\n\n        registry = registry_;\n    }\n\n    /// @dev Set chainlink feed registry source\n    /// @param _registry Chainlink feed registry source\n    function setFeedRegistry(IFeedRegistry _registry) external onlyOwner {\n        if (address(_registry) == address(0)) revert ZERO_ADDRESS();\n        registry = _registry;\n        emit SetRegistry(address(_registry));\n    }\n\n    /// @dev Set token remapping\n    /// @param _tokens List of tokens to set remapping\n    /// @param _remappedTokens List of tokens to set remapping to\n    /// @notice Token decimals of the original and remapped tokens should be the same\n    function setTokenRemappings(\n        address[] calldata _tokens,\n        address[] calldata _remappedTokens\n    ) external onlyOwner {\n        if (_remappedTokens.length != _tokens.length)\n            revert INPUT_ARRAY_MISMATCH();\n        for (uint256 idx = 0; idx < _tokens.length; idx++) {\n            if (_remappedTokens[idx] == address(0)) revert ZERO_ADDRESS();\n            if (_tokens[idx] == address(0)) revert ZERO_ADDRESS();\n            remappedTokens[_tokens[idx]] = _remappedTokens[idx];\n            emit SetTokenRemapping(_tokens[idx], _remappedTokens[idx]);\n        }\n    }\n\n    /**\n     * @notice Returns the USD based price of given token, price value has 18 decimals\n     * @param _token Token address to get price of\n     * @return price USD price of token in 18 decimal\n     */\n    function getPrice(address _token) external view override returns (uint256) {\n        // remap token if possible\n        address token = remappedTokens[_token];\n        if (token == address(0)) token = _token;\n\n        uint256 maxDelayTime = maxDelayTimes[token];\n        if (maxDelayTime == 0) revert NO_MAX_DELAY(_token);\n\n        // try to get token-USD price\n        uint256 decimals = registry.decimals(token, USD);\n        (, int256 answer, , uint256 updatedAt, ) = registry.latestRoundData(\n            token,\n            USD\n        );\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert PRICE_OUTDATED(_token);\n\n        return (answer.toUint256() * 1e18) / 10**decimals;\n    }\n}"
    },
    {
      "filename": "contracts/oracle/ChainlinkAdapterOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BaseAdapter.sol\";\nimport \"../utils/BlueBerryErrors.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/chainlink/IFeedRegistry.sol\";\n\ncontract ChainlinkAdapterOracle is IBaseOracle, BaseAdapter {\n    using SafeCast for int256;\n\n    // Chainlink denominations\n    // (source: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/Denominations.sol)\n    IFeedRegistry public registry;\n    address public constant USD = address(840);\n\n    /// @dev Mapping from original token to remapped token for price querying (e.g. WBTC -> BTC, renBTC -> BTC)\n    mapping(address => address) public remappedTokens;\n\n    event SetRegistry(address registry);\n    event SetTokenRemapping(\n        address indexed token,\n        address indexed remappedToken\n    );\n\n    constructor(IFeedRegistry registry_) {\n        if (address(registry_) == address(0)) revert ZERO_ADDRESS();\n\n        registry = registry_;\n    }\n\n    /// @dev Set chainlink feed registry source\n    /// @param _registry Chainlink feed registry source\n    function setFeedRegistry(IFeedRegistry _registry) external onlyOwner {\n        if (address(_registry) == address(0)) revert ZERO_ADDRESS();\n        registry = _registry;\n        emit SetRegistry(address(_registry));\n    }\n\n    /// @dev Set token remapping\n    /// @param _tokens List of tokens to set remapping\n    /// @param _remappedTokens List of tokens to set remapping to\n    /// @notice Token decimals of the original and remapped tokens should be the same\n    function setTokenRemappings(\n        address[] calldata _tokens,\n        address[] calldata _remappedTokens\n    ) external onlyOwner {\n        if (_remappedTokens.length != _tokens.length)\n            revert INPUT_ARRAY_MISMATCH();\n        for (uint256 idx = 0; idx < _tokens.length; idx++) {\n            if (_remappedTokens[idx] == address(0)) revert ZERO_ADDRESS();\n            if (_tokens[idx] == address(0)) revert ZERO_ADDRESS();\n            remappedTokens[_tokens[idx]] = _remappedTokens[idx];\n            emit SetTokenRemapping(_tokens[idx], _remappedTokens[idx]);\n        }\n    }\n\n    /**\n     * @notice Returns the USD based price of given token, price value has 18 decimals\n     * @param _token Token address to get price of\n     * @return price USD price of token in 18 decimal\n     */\n    function getPrice(address _token) external view override returns (uint256) {\n        // remap token if possible\n        address token = remappedTokens[_token];\n        if (token == address(0)) token = _token;\n\n        uint256 maxDelayTime = maxDelayTimes[token];\n        if (maxDelayTime == 0) revert NO_MAX_DELAY(_token);\n\n        // try to get token-USD price\n        uint256 decimals = registry.decimals(token, USD);\n        (, int256 answer, , uint256 updatedAt, ) = registry.latestRoundData(\n            token,\n            USD\n        );\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert PRICE_OUTDATED(_token);\n\n        return (answer.toUint256() * 1e18) / 10**decimals;\n    }\n}"
    }
  ]
}