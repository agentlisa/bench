{
  "Title": "[M-34] Anyone can reset fees to 0 value when Vault is deployed",
  "Content": "\nAnyone can reset fees to 0 value when Vault is deployed. As result protocol will stop collecting fees.\n\n### Proof of Concept\n\nAnyone can call `changeFees` function in order to change `fees` variable to `proposedFees`.\n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L540-L546>\n\n```solidity\n    function changeFees() external {\n        if (block.timestamp < proposedFeeTime + quitPeriod)\n            revert NotPassedQuitPeriod(quitPeriod);\n\n\n        emit ChangedFees(fees, proposedFees);\n        fees = proposedFees;\n    }\n```\n\nThere is a check that should not allow anyone to call function before `quitPeriod` has passed after fees changing was proposed.\n\nHowever function doesn't check that `proposedFeeTime` is not 0, so that means that after Vault has deployed, anyone can call this function and the check will pass.\n\nThat means that `fees` will be set to the `proposedFees`, which is 0.\n\nAs result protocol will stop collecting fees.\n\nUse this test inside Vault.t.sol. Here you can see that no one proposed fee changing, but it was changed and set fees to 0.\n\n```solidity\nfunction test__changeFees() public {\n    VaultFees memory newVaultFees = VaultFees({ deposit: 0, withdrawal: 0, management: 0, performance: 0 });\n    //noone proposed\n    //vault.proposeFees(newVaultFees);\n\n    vm.warp(block.timestamp + 3 days);\n\n    vm.expectEmit(false, false, false, true, address(vault));\n    emit ChangedFees(VaultFees({ deposit: 0, withdrawal: 0, management: 0, performance: 0 }), newVaultFees);\n\n    vault.changeFees();\n\n    (uint256 deposit, uint256 withdrawal, uint256 management, uint256 performance) = vault.fees();\n    assertEq(deposit, 0);\n    assertEq(withdrawal, 0);\n    assertEq(management, 0);\n    assertEq(performance, 0);\n  }\n```\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\n```solidity\n    function changeFees() external {\n        if (proposedFeeTime == 0 || block.timestamp < proposedFeeTime + quitPeriod)\n            revert NotPassedQuitPeriod(quitPeriod);\n\n\n        emit ChangedFees(fees, proposedFees);\n        fees = proposedFees;\n    }\n```\n\n**[RedVeil (Popcorn) confirmed, but disagreed with severity](https://github.com/code-423n4/2023-01-popcorn-findings/issues/78)** \n\n**[LSDan (judge) decreased severity to Medium](https://github.com/code-423n4/2023-01-popcorn-findings/issues/78)** \n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-popcorn",
  "Code": [
    {
      "filename": "src/vault/Vault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport {SafeERC20Upgradeable as SafeERC20} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {IERC4626, IERC20} from \"../interfaces/vault/IERC4626.sol\";\nimport {IERC20Metadata} from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {VaultFees} from \"../interfaces/vault/IVault.sol\";\nimport {MathUpgradeable as Math} from \"openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {OwnedUpgradeable} from \"../utils/OwnedUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/**\n * @title   Vault\n * @author  RedVeil\n * @notice  See the following for the full EIP-4626 specification https://eips.ethereum.org/EIPS/eip-4626.\n *\n * A simple ERC4626-Implementation of a Vault.\n * The vault delegates any actual protocol interaction to an adapter.\n * It allows for multiple type of fees which are taken by issuing new vault shares.\n * Adapter and fees can be changed by the owner after a ragequit time.\n */\ncontract Vault is\n    ERC20Upgradeable,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable,\n    OwnedUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    uint256 constant SECONDS_PER_YEAR = 365.25 days;\n\n    IERC20 public asset;\n    uint8 internal _decimals;\n\n    bytes32 public contractName;\n\n    event VaultInitialized(bytes32 contractName, address indexed asset);\n\n    error InvalidAsset();\n    error InvalidAdapter();\n\n    /**\n     * @notice Initialize a new Vault.\n     * @param asset_ Underlying Asset which users will deposit.\n     * @param adapter_ Adapter which will be used to interact with the wrapped protocol.\n     * @param fees_ Desired fees in 1e18. (1e18 = 100%, 1e14 = 1 BPS)\n     * @param feeRecipient_ Recipient of all vault fees. (Must not be zero address)\n     * @param owner Owner of the contract. Controls management functions.\n     * @dev This function is called by the factory contract when deploying a new vault.\n     * @dev Usually the adapter should already be pre configured. Otherwise a new one can only be added after a ragequit time.\n     */\n    function initialize(\n        IERC20 asset_,\n        IERC4626 adapter_,\n        VaultFees calldata fees_,\n        address feeRecipient_,\n        address owner\n    ) external initializer {\n        __ERC20_init(\n            string.concat(\n                \"Popcorn \",\n                IERC20Metadata(address(asset_)).name(),\n                \" Vault\"\n            ),\n            string.concat(\"pop-\", IERC20Metadata(address(asset_)).symbol())\n        );\n        __Owned_init(owner);\n\n        if (address(asset_) == address(0)) revert InvalidAsset();\n        if (address(asset_) != adapter_.asset()) revert InvalidAdapter();\n\n        asset = asset_;\n        adapter = adapter_;\n\n        asset.approve(address(adapter_), type(uint256).max);\n\n        _decimals = IERC20Metadata(address(asset_)).decimals();\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n\n        feesUpdatedAt = block.timestamp;\n        fees = fees_;\n\n        if (feeRecipient_ == address(0)) revert InvalidFeeRecipient();\n        feeRecipient = feeRecipient_;\n\n        contractName = keccak256(\n            abi.encodePacked(\"Popcorn\", name(), block.timestamp, \"Vault\")\n        );\n\n        emit VaultInitialized(contractName, address(asset));\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    error InvalidReceiver();\n\n    function deposit(uint256 assets) public returns (uint256) {\n        return deposit(assets, msg.sender);\n    }\n\n    /**\n     * @notice Deposit exactly `assets` amount of tokens, issuing vault shares to `receiver`.\n     * @param assets Quantity of tokens to deposit.\n     * @param receiver Receiver of issued vault shares.\n     * @return shares Quantity of vault shares issued to `receiver`.\n     */\n    function deposit(uint256 assets, address receiver)\n        public\n        nonReentrant\n        whenNotPaused\n        syncFeeCheckpoint\n        returns (uint256 shares)\n    {\n        if (receiver == address(0)) revert InvalidReceiver();\n\n        uint256 feeShares = convertToShares(\n            assets.mulDiv(uint256(fees.deposit), 1e18, Math.Rounding.Down)\n        );\n\n        shares = convertToShares(assets) - feeShares;\n\n        if (feeShares > 0) _mint(feeRecipient, feeShares);\n\n        _mint(receiver, shares);\n\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        adapter.deposit(assets, address(this));\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function mint(uint256 shares) external returns (uint256) {\n        return mint(shares, msg.sender);\n    }\n\n    /**\n     * @notice Mint exactly `shares` vault shares to `receiver`, taking the necessary amount of `asset` from the caller.\n     * @param shares Quantity of shares to mint.\n     * @param receiver Receiver of issued vault shares.\n     * @return assets Quantity of assets deposited by caller.\n     */\n    function mint(uint256 shares, address receiver)\n        public\n        nonReentrant\n        whenNotPaused\n        syncFeeCheckpoint\n        returns (uint256 assets)\n    {\n        if (receiver == address(0)) revert InvalidReceiver();\n\n        uint256 depositFee = uint256(fees.deposit);\n\n        uint256 feeShares = shares.mulDiv(\n            depositFee,\n            1e18 - depositFee,\n            Math.Rounding.Down\n        );\n\n        assets = convertToAssets(shares + feeShares);\n\n        if (feeShares > 0) _mint(feeRecipient, feeShares);\n\n        _mint(receiver, shares);\n\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        adapter.deposit(assets, address(this));\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function withdraw(uint256 assets) public returns (uint256) {\n        return withdraw(assets, msg.sender, msg.sender);\n    }\n\n    /**\n     * @notice Burn shares from `owner` in exchange for `assets` amount of underlying token.\n     * @param assets Quantity of underlying `asset` token to withdraw.\n     * @param receiver Receiver of underlying token.\n     * @param owner Owner of burned vault shares.\n     * @return shares Quantity of vault shares burned in exchange for `assets`.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public nonReentrant syncFeeCheckpoint returns (uint256 shares) {\n        if (receiver == address(0)) revert InvalidReceiver();\n\n        shares = convertToShares(assets);\n\n        uint256 withdrawalFee = uint256(fees.withdrawal);\n\n        uint256 feeShares = shares.mulDiv(\n            withdrawalFee,\n            1e18 - withdrawalFee,\n            Math.Rounding.Down\n        );\n\n        shares += feeShares;\n\n        if (msg.sender != owner)\n            _approve(owner, msg.sender, allowance(owner, msg.sender) - shares);\n\n        _burn(owner, shares);\n\n        if (feeShares > 0) _mint(feeRecipient, feeShares);\n\n        adapter.withdraw(assets, receiver, address(this));\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n    }\n\n    function redeem(uint256 shares) external returns (uint256) {\n        return redeem(shares, msg.sender, msg.sender);\n    }\n\n    /**\n     * @notice Burn exactly `shares` vault shares from `owner` and send underlying `asset` tokens to `receiver`.\n     * @param shares Quantity of vault shares to exchange for underlying tokens.\n     * @param receiver Receiver of underlying tokens.\n     * @param owner Owner of burned vault shares.\n     * @return assets Quantity of `asset` sent to `receiver`.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public nonReentrant returns (uint256 assets) {\n        if (receiver == address(0)) revert InvalidReceiver();\n\n        if (msg.sender != owner)\n            _approve(owner, msg.sender, allowance(owner, msg.sender) - shares);\n\n        uint256 feeShares = shares.mulDiv(\n            uint256(fees.withdrawal),\n            1e18,\n            Math.Rounding.Down\n        );\n\n        assets = convertToAssets(shares - feeShares);\n\n        _burn(owner, shares);\n\n        if (feeShares > 0) _mint(feeRecipient, feeShares);\n\n        adapter.withdraw(assets, receiver, address(this));\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @return Total amount of underlying `asset` token managed by vault. Delegates to adapter.\n    function totalAssets() public view returns (uint256) {\n        return adapter.convertToAssets(adapter.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Amount of shares the vault would exchange for given amount of assets, in an ideal scenario.\n     * @param assets Exact amount of assets\n     * @return Exact amount of shares\n     */\n    function convertToShares(uint256 assets) public view returns (uint256) {\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return\n            supply == 0\n                ? assets\n                : assets.mulDiv(supply, totalAssets(), Math.Rounding.Down);\n    }\n\n    /**\n     * @notice Amount of assets the vault would exchange for given amount of shares, in an ideal scenario.\n     * @param shares Exact amount of shares\n     * @return Exact amount of assets\n     */\n    function convertToAssets(uint256 shares) public view returns (uint256) {\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return\n            supply == 0\n                ? shares\n                : shares.mulDiv(totalAssets(), supply, Math.Rounding.Down);\n    }\n\n    /**\n     * @notice Simulate the effects of a deposit at the current block, given current on-chain conditions.\n     * @param assets Exact amount of underlying `asset` token to deposit\n     * @return shares of the vault issued in exchange to the user for `assets`\n     * @dev This method accounts for issuance of accrued fee shares.\n     */\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        shares = adapter.previewDeposit(\n            assets -\n                assets.mulDiv(uint256(fees.deposit), 1e18, Math.Rounding.Down)\n        );\n    }\n\n    /**\n     * @notice Simulate the effects of a mint at the current block, given current on-chain conditions.\n     * @param shares Exact amount of vault shares to mint.\n     * @return assets quantity of underlying needed in exchange to mint `shares`.\n     * @dev This method accounts for issuance of accrued fee shares.\n     */\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        uint256 depositFee = uint256(fees.deposit);\n\n        shares += shares.mulDiv(\n            depositFee,\n            1e18 - depositFee,\n            Math.Rounding.Up\n        );\n\n        assets = adapter.previewMint(shares);\n    }\n\n    /**\n     * @notice Simulate the effects of a withdrawal at the current block, given current on-chain conditions.\n     * @param assets Exact amount of `assets` to withdraw\n     * @return shares to be burned in exchange for `assets`\n     * @dev This method accounts for both issuance of fee shares and withdrawal fee.\n     */\n    function previewWithdraw(uint256 assets)\n        external\n        view\n        returns (uint256 shares)\n    {\n        uint256 withdrawalFee = uint256(fees.withdrawal);\n\n        assets += assets.mulDiv(\n            withdrawalFee,\n            1e18 - withdrawalFee,\n            Math.Rounding.Up\n        );\n\n        shares = adapter.previewWithdraw(assets);\n    }\n\n    /**\n     * @notice Simulate the effects of a redemption at the current block, given current on-chain conditions.\n     * @param shares Exact amount of `shares` to redeem\n     * @return assets quantity of underlying returned in exchange for `shares`.\n     * @dev This method accounts for both issuance of fee shares and withdrawal fee.\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = adapter.previewRedeem(shares);\n\n        assets -= assets.mulDiv(\n            uint256(fees.withdrawal),\n            1e18,\n            Math.Rounding.Down\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @return Maximum amount of underlying `asset` token that may be deposited for a given address. Delegates to adapter.\n    function maxDeposit(address caller) public view returns (uint256) {\n        return adapter.maxDeposit(caller);\n    }\n\n    /// @return Maximum amount of vault shares that may be minted to given address. Delegates to adapter.\n    function maxMint(address caller) external view returns (uint256) {\n        return adapter.maxMint(caller);\n    }\n\n    /// @return Maximum amount of underlying `asset` token that can be withdrawn by `caller` address. Delegates to adapter.\n    function maxWithdraw(address caller) external view returns (uint256) {\n        return adapter.maxWithdraw(caller);\n    }\n\n    /// @return Maximum amount of shares that may be redeemed by `caller` address. Delegates to adapter.\n    function maxRedeem(address caller) external view returns (uint256) {\n        return adapter.maxRedeem(caller);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        FEE ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Management fee that has accrued since last fee harvest.\n     * @return Accrued management fee in underlying `asset` token.\n     * @dev Management fee is annualized per minute, based on 525,600 minutes per year. Total assets are calculated using\n     *  the average of their current value and the value at the previous fee harvest checkpoint. This method is similar to\n     *  calculating a definite integral using the trapezoid rule.\n     */\n    function accruedManagementFee() public view returns (uint256) {\n        uint256 managementFee = fees.management;\n        return\n            managementFee > 0\n                ? managementFee.mulDiv(\n                    totalAssets() * (block.timestamp - feesUpdatedAt),\n                    SECONDS_PER_YEAR,\n                    Math.Rounding.Down\n                ) / 1e18\n                : 0;\n    }\n\n    /**\n     * @notice Performance fee that has accrued since last fee harvest.\n     * @return Accrued performance fee in underlying `asset` token.\n     * @dev Performance fee is based on a high water mark value. If vault share value has increased above the\n     *   HWM in a fee period, issue fee shares to the vault equal to the performance fee.\n     */\n    function accruedPerformanceFee() public view returns (uint256) {\n        uint256 highWaterMark_ = highWaterMark;\n        uint256 shareValue = convertToAssets(1e18);\n        uint256 performanceFee = fees.performance;\n\n        return\n            performanceFee > 0 && shareValue > highWaterMark\n                ? performanceFee.mulDiv(\n                    (shareValue - highWaterMark) * totalSupply(),\n                    1e36,\n                    Math.Rounding.Down\n                )\n                : 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            FEE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public highWaterMark = 1e18;\n    uint256 public assetsCheckpoint;\n    uint256 public feesUpdatedAt;\n\n    error InsufficientWithdrawalAmount(uint256 amount);\n\n    /// @notice Minimal function to call `takeFees` modifier.\n    function takeManagementAndPerformanceFees()\n        external\n        nonReentrant\n        takeFees\n    {}\n\n    /// @notice Collect management and performance fees and update vault share high water mark.\n    modifier takeFees() {\n        uint256 managementFee = accruedManagementFee();\n        uint256 totalFee = managementFee + accruedPerformanceFee();\n        uint256 currentAssets = totalAssets();\n        uint256 shareValue = convertToAssets(1e18);\n\n        if (shareValue > highWaterMark) highWaterMark = shareValue;\n\n        if (managementFee > 0) feesUpdatedAt = block.timestamp;\n\n        if (totalFee > 0 && currentAssets > 0)\n            _mint(feeRecipient, convertToShares(totalFee));\n\n        _;\n    }\n\n    modifier syncFeeCheckpoint() {\n        _;\n        highWaterMark = convertToAssets(1e18);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            FEE MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    VaultFees public fees;\n\n    VaultFees public proposedFees;\n    uint256 public proposedFeeTime;\n\n    address public feeRecipient;\n\n    event NewFeesProposed(VaultFees newFees, uint256 timestamp);\n    event ChangedFees(VaultFees oldFees, VaultFees newFees);\n    event FeeRecipientUpdated(address oldFeeRecipient, address newFeeRecipient);\n\n    error InvalidVaultFees();\n    error InvalidFeeRecipient();\n    error NotPassedQuitPeriod(uint256 quitPeriod);\n\n    /**\n     * @notice Propose new fees for this vault. Caller must be owner.\n     * @param newFees Fees for depositing, withdrawal, management and performance in 1e18.\n     * @dev Fees can be 0 but never 1e18 (1e18 = 100%, 1e14 = 1 BPS)\n     */\n    function proposeFees(VaultFees calldata newFees) external onlyOwner {\n        if (\n            newFees.deposit >= 1e18 ||\n            newFees.withdrawal >= 1e18 ||\n            newFees.management >= 1e18 ||\n            newFees.performance >= 1e18\n        ) revert InvalidVaultFees();\n\n        proposedFees = newFees;\n        proposedFeeTime = block.timestamp;\n\n        emit NewFeesProposed(newFees, block.timestamp);\n    }\n\n    /// @notice Change fees to the previously proposed fees after the quit period has passed.\n    function changeFees() external {\n        if (block.timestamp < proposedFeeTime + quitPeriod)\n            revert NotPassedQuitPeriod(quitPeriod);\n\n        emit ChangedFees(fees, proposedFees);\n        fees = proposedFees;\n    }\n\n    /**\n     * @notice Change `feeRecipient`. Caller must be Owner.\n     * @param _feeRecipient The new fee recipient.\n     * @dev Accrued fees wont be transferred to the new feeRecipient.\n     */\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        if (_feeRecipient == address(0)) revert InvalidFeeRecipient();\n\n        emit FeeRecipientUpdated(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          ADAPTER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    IERC4626 public adapter;\n    IERC4626 public proposedAdapter;\n    uint256 public proposedAdapterTime;\n\n    event NewAdapterProposed(IERC4626 newAdapter, uint256 timestamp);\n    event ChangedAdapter(IERC4626 oldAdapter, IERC4626 newAdapter);\n\n    error VaultAssetMismatchNewAdapterAsset();\n\n    /**\n     * @notice Propose a new adapter for this vault. Caller must be Owner.\n     * @param newAdapter A new ERC4626 that should be used as a yield adapter for this asset.\n     */\n    function proposeAdapter(IERC4626 newAdapter) external onlyOwner {\n        if (newAdapter.asset() != address(asset))\n            revert VaultAssetMismatchNewAdapterAsset();\n\n        proposedAdapter = newAdapter;\n        proposedAdapterTime = block.timestamp;\n\n        emit NewAdapterProposed(newAdapter, block.timestamp);\n    }\n\n    /**\n     * @notice Set a new Adapter for this Vault after the quit period has passed.\n     * @dev This migration function will remove all assets from the old Vault and move them into the new vault\n     * @dev Additionally it will zero old allowances and set new ones\n     * @dev Last we update HWM and assetsCheckpoint for fees to make sure they adjust to the new adapter\n     */\n    function changeAdapter() external takeFees {\n        if (block.timestamp < proposedAdapterTime + quitPeriod)\n            revert NotPassedQuitPeriod(quitPeriod);\n\n        adapter.redeem(\n            adapter.balanceOf(address(this)),\n            address(this),\n            address(this)\n        );\n\n        asset.approve(address(adapter), 0);\n\n        emit ChangedAdapter(adapter, proposedAdapter);\n\n        adapter = proposedAdapter;\n\n        asset.approve(address(adapter), type(uint256).max);\n\n        adapter.deposit(asset.balanceOf(address(this)), address(this));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          RAGE QUIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public quitPeriod = 3 days;\n\n    event QuitPeriodSet(uint256 quitPeriod);\n\n    error InvalidQuitPeriod();\n\n    /**\n     * @notice Set a quitPeriod for rage quitting after new adapter or fees are proposed. Caller must be Owner.\n     * @param _quitPeriod Time to rage quit after proposal.\n     */\n    function setQuitPeriod(uint256 _quitPeriod) external onlyOwner {\n        if (_quitPeriod < 1 days || _quitPeriod > 7 days)\n            revert InvalidQuitPeriod();\n\n        quitPeriod = _quitPeriod;\n\n        emit QuitPeriodSet(quitPeriod);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          PAUSING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Pause deposits. Caller must be Owner.\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Unpause deposits. Caller must be Owner.\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      EIP-2612 LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    //  EIP-2612 STORAGE\n    uint256 internal INITIAL_CHAIN_ID;\n    bytes32 internal INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n\n    error PermitDeadlineExpired(uint256 deadline);\n    error InvalidSigner(address signer);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (deadline < block.timestamp) revert PermitDeadlineExpired(deadline);\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            if (recoveredAddress == address(0) || recoveredAddress != owner)\n                revert InvalidSigner(recoveredAddress);\n\n            _approve(recoveredAddress, spender, value);\n        }\n    }\n\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        return\n            block.chainid == INITIAL_CHAIN_ID\n                ? INITIAL_DOMAIN_SEPARATOR\n                : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(name())),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n}"
    }
  ]
}