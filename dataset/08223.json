{
  "Title": "[G-03]  Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate",
  "Content": "Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - 30 gas) and that calculation's associated stack operations.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: src/contracts/FraxlendPairCore.sol\n\n127       mapping(address => uint256) public userCollateralBalance; // amount of collateral each user is backed\n128       /// @notice Stores the balance of borrow shares for each user\n129:      mapping(address => uint256) public userBorrowShares; // represents the shares held by individuals\n\n```\nhttps://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L127-L129\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-08-frax",
  "Code": [
    {
      "filename": "src/contracts/FraxlendPairCore.sol",
      "content": "// SPDX-License-Identifier: ISC\npragma solidity ^0.8.15;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ========================= FraxlendPairCore =========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author\n// Drake Evans: https://github.com/DrakeEvans\n\n// Reviewers\n// Dennis: https://github.com/denett\n// Sam Kazemian: https://github.com/samkazemian\n// Travis Moore: https://github.com/FortisFortuna\n// Jack Corddry: https://github.com/corddry\n// Rich Gee: https://github.com/zer0blockchain\n\n// ====================================================================\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./FraxlendPairConstants.sol\";\nimport \"./libraries/VaultAccount.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./interfaces/IERC4626.sol\";\nimport \"./interfaces/IFraxlendWhitelist.sol\";\nimport \"./interfaces/IRateCalculator.sol\";\nimport \"./interfaces/ISwapper.sol\";\n\n/// @title FraxlendPairCore\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\n/// @notice  An abstract contract which contains the core logic and storage for the FraxlendPair\nabstract contract FraxlendPairCore is FraxlendPairConstants, IERC4626, ERC20, Ownable, Pausable, ReentrancyGuard {\n    using VaultAccountingLibrary for VaultAccount;\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    string public version = \"1.0.0\";\n\n    // ============================================================================================\n    // Settings set by constructor() & initialize()\n    // ============================================================================================\n\n    // Asset and collateral contracts\n    IERC20 internal immutable assetContract;\n    IERC20 public immutable collateralContract;\n\n    // Oracle wrapper contract and oracleData\n    address public immutable oracleMultiply;\n    address public immutable oracleDivide;\n    uint256 public immutable oracleNormalization;\n\n    // LTV Settings\n    uint256 public immutable maxLTV;\n\n    // Liquidation Fee\n    uint256 public immutable cleanLiquidationFee;\n    uint256 public immutable dirtyLiquidationFee;\n\n    // Interest Rate Calculator Contract\n    IRateCalculator public immutable rateContract; // For complex rate calculations\n    bytes public rateInitCallData; // Optional extra data from init function to be passed to rate calculator\n\n    // Swapper\n    mapping(address => bool) public swappers; // approved swapper addresses\n\n    // Deployer\n    address public immutable DEPLOYER_ADDRESS;\n\n    // Admin contracts\n    address public immutable CIRCUIT_BREAKER_ADDRESS;\n    address public immutable COMPTROLLER_ADDRESS;\n    address public TIME_LOCK_ADDRESS;\n\n    // Dependencies\n    address public immutable FRAXLEND_WHITELIST_ADDRESS;\n\n    // ERC20 token name, accessible via name()\n    string internal nameOfContract;\n\n    // Maturity Date & Penalty Interest Rate (per Sec)\n    uint256 public immutable maturityDate;\n    uint256 public immutable penaltyRate;\n\n    // ============================================================================================\n    // Storage\n    // ============================================================================================\n\n    /// @notice Stores information about the current interest rate\n    /// @dev struct is packed to reduce SLOADs. feeToProtocolRate is 1e5 precision, ratePerSec is 1e18 precision\n    CurrentRateInfo public currentRateInfo;\n    struct CurrentRateInfo {\n        uint64 lastBlock;\n        uint64 feeToProtocolRate; // Fee amount 1e5 precision\n        uint64 lastTimestamp;\n        uint64 ratePerSec;\n    }\n\n    /// @notice Stores information about the current exchange rate. Collateral:Asset ratio\n    /// @dev Struct packed to save SLOADs. Amount of Collateral Token to buy 1e18 Asset Token\n    ExchangeRateInfo public exchangeRateInfo;\n    struct ExchangeRateInfo {\n        uint32 lastTimestamp;\n        uint224 exchangeRate; // collateral:asset ratio. i.e. how much collateral to buy 1e18 asset\n    }\n\n    // Contract Level Accounting\n    VaultAccount public totalAsset; // amount = total amount of assets, shares = total shares outstanding\n    VaultAccount public totalBorrow; // amount = total borrow amount with interest accrued, shares = total shares outstanding\n    uint256 public totalCollateral; // total amount of collateral in contract\n\n    // User Level Accounting\n    /// @notice Stores the balance of collateral for each user\n    mapping(address => uint256) public userCollateralBalance; // amount of collateral each user is backed\n    /// @notice Stores the balance of borrow shares for each user\n    mapping(address => uint256) public userBorrowShares; // represents the shares held by individuals\n    // NOTE: user shares of assets are represented as ERC-20 tokens and accessible via balanceOf()\n\n    // Internal Whitelists\n    bool public immutable borrowerWhitelistActive;\n    mapping(address => bool) public approvedBorrowers;\n\n    bool public immutable lenderWhitelistActive;\n    mapping(address => bool) public approvedLenders;\n\n    // ============================================================================================\n    // Initialize\n    // ============================================================================================\n\n    /// @notice The ```constructor``` function is called on deployment\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate date of the Pair\n    /// @param _penaltyRate The interest rate after maturity date\n    /// @param _isBorrowerWhitelistActive Enables borrower whitelist\n    /// @param _isLenderWhitelistActive Enables lender whitelist\n    constructor(\n        bytes memory _configData,\n        bytes memory _immutables,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate,\n        uint256 _penaltyRate,\n        bool _isBorrowerWhitelistActive,\n        bool _isLenderWhitelistActive\n    ) {\n        // Handle Immutables Configuration\n        {\n            (\n                address _circuitBreaker,\n                address _comptrollerAddress,\n                address _timeLockAddress,\n                address _fraxlendWhitelistAddress\n            ) = abi.decode(_immutables, (address, address, address, address));\n\n            // Deployer contract\n            DEPLOYER_ADDRESS = msg.sender;\n            CIRCUIT_BREAKER_ADDRESS = _circuitBreaker;\n            COMPTROLLER_ADDRESS = _comptrollerAddress;\n            TIME_LOCK_ADDRESS = _timeLockAddress;\n            FRAXLEND_WHITELIST_ADDRESS = _fraxlendWhitelistAddress;\n        }\n\n        {\n            (\n                address _asset,\n                address _collateral,\n                address _oracleMultiply,\n                address _oracleDivide,\n                uint256 _oracleNormalization,\n                address _rateContract,\n\n            ) = abi.decode(_configData, (address, address, address, address, uint256, address, bytes));\n\n            // Pair Settings\n            assetContract = IERC20(_asset);\n            collateralContract = IERC20(_collateral);\n            currentRateInfo.feeToProtocolRate = DEFAULT_PROTOCOL_FEE;\n            cleanLiquidationFee = _liquidationFee;\n            dirtyLiquidationFee = (_liquidationFee * 9000) / LIQ_PRECISION; // 90% of clean fee\n\n            if (_maxLTV >= LTV_PRECISION && !_isBorrowerWhitelistActive) revert BorrowerWhitelistRequired();\n            maxLTV = _maxLTV;\n\n            // Swapper Settings\n            swappers[FRAXSWAP_ROUTER_ADDRESS] = true;\n\n            // Oracle Settings\n            {\n                IFraxlendWhitelist _fraxlendWhitelist = IFraxlendWhitelist(FRAXLEND_WHITELIST_ADDRESS);\n                // Check that oracles are on the whitelist\n                if (_oracleMultiply != address(0) && !_fraxlendWhitelist.oracleContractWhitelist(_oracleMultiply)) {\n                    revert NotOnWhitelist(_oracleMultiply);\n                }\n\n                if (_oracleDivide != address(0) && !_fraxlendWhitelist.oracleContractWhitelist(_oracleDivide)) {\n                    revert NotOnWhitelist(_oracleDivide);\n                }\n\n                // Write oracleData to storage\n                oracleMultiply = _oracleMultiply;\n                oracleDivide = _oracleDivide;\n                oracleNormalization = _oracleNormalization;\n\n                // Rate Settings\n                if (!_fraxlendWhitelist.rateContractWhitelist(_rateContract)) {\n                    revert NotOnWhitelist(_rateContract);\n                }\n            }\n\n            rateContract = IRateCalculator(_rateContract);\n        }\n\n        // Set approved borrowers whitelist\n        borrowerWhitelistActive = _isBorrowerWhitelistActive;\n\n        // Set approved lenders whitlist active\n        lenderWhitelistActive = _isLenderWhitelistActive;\n\n        // Set maturity date & penalty interest rate\n        maturityDate = _maturityDate;\n        penaltyRate = _penaltyRate;\n    }\n\n    /// @notice The ```initialize``` function is called immediately after deployment\n    /// @dev This function can only be called by the deployer\n    /// @param _name The name of the contract\n    /// @param _approvedBorrowers An array of approved borrower addresses\n    /// @param _approvedLenders An array of approved lender addresses\n    /// @param _rateInitCallData The configuration data for the Rate Calculator contract\n    function initialize(\n        string calldata _name,\n        address[] calldata _approvedBorrowers,\n        address[] calldata _approvedLenders,\n        bytes calldata _rateInitCallData\n    ) external {\n        if (msg.sender != DEPLOYER_ADDRESS) {\n            revert NotDeployer();\n        }\n        if (bytes(_name).length == 0) {\n            revert NameEmpty();\n        }\n        if (bytes(nameOfContract).length != 0) {\n            revert AlreadyInitialized();\n        }\n\n        // Set name\n        nameOfContract = _name;\n\n        // Set approved borrowers\n        for (uint256 i = 0; i < _approvedBorrowers.length; ++i) {\n            approvedBorrowers[_approvedBorrowers[i]] = true;\n        }\n\n        // Set approved lenders\n        for (uint256 i = 0; i < _approvedLenders.length; ++i) {\n            approvedLenders[_approvedLenders[i]] = true;\n        }\n\n        // Reverts if init data is not valid\n        IRateCalculator(rateContract).requireValidInitData(_rateInitCallData);\n\n        // Set rate init Data\n        rateInitCallData = _rateInitCallData;\n\n        // Instantiate Interest\n        _addInterest();\n\n        // Instantiate Exchange Rate\n        _updateExchangeRate();\n    }\n\n    // ============================================================================================\n    // Internal Helpers\n    // ============================================================================================\n\n    /// @notice The ```_totalAssetAvailable``` function returns the total balance of Asset Tokens in the contract\n    /// @param _totalAsset VaultAccount struct which stores total amount and shares for assets\n    /// @param _totalBorrow VaultAccount struct which stores total amount and shares for borrows\n    /// @return The balance of Asset Tokens held by contract\n    function _totalAssetAvailable(VaultAccount memory _totalAsset, VaultAccount memory _totalBorrow)\n        internal\n        pure\n        returns (uint256)\n    {\n        return _totalAsset.amount - _totalBorrow.amount;\n    }\n\n    /// @notice The ```_isSolvent``` function determines if a given borrower is solvent given an exchange rate\n    /// @param _borrower The borrower address to check\n    /// @param _exchangeRate The exchange rate, i.e. the amount of collateral to buy 1e18 asset\n    /// @return Whether borrower is solvent\n    function _isSolvent(address _borrower, uint256 _exchangeRate) internal view returns (bool) {\n        if (maxLTV == 0) return true;\n        uint256 _borrowerAmount = totalBorrow.toAmount(userBorrowShares[_borrower], true);\n        if (_borrowerAmount == 0) return true;\n        uint256 _collateralAmount = userCollateralBalance[_borrower];\n        if (_collateralAmount == 0) return false;\n\n        uint256 _ltv = (((_borrowerAmount * _exchangeRate) / EXCHANGE_PRECISION) * LTV_PRECISION) / _collateralAmount;\n        return _ltv <= maxLTV;\n    }\n\n    /// @notice The ```_isPastMaturity``` function determines if the current block timestamp is past the maturityDate date\n    /// @return Whether or not the debt is past maturity\n    function _isPastMaturity() internal view returns (bool) {\n        return maturityDate != 0 && block.timestamp > maturityDate;\n    }\n\n    // ============================================================================================\n    // Modifiers\n    // ============================================================================================\n\n    /// @notice Checks for solvency AFTER executing contract code\n    /// @param _borrower The borrower whose solvency we will check\n    modifier isSolvent(address _borrower) {\n        _;\n        if (!_isSolvent(_borrower, exchangeRateInfo.exchangeRate)) {\n            revert Insolvent(\n                totalBorrow.toAmount(userBorrowShares[_borrower], true),\n                userCollateralBalance[_borrower],\n                exchangeRateInfo.exchangeRate\n            );\n        }\n    }\n\n    /// @notice Checks if msg.sender is an approved Borrower\n    modifier approvedBorrower() {\n        if (borrowerWhitelistActive && !approvedBorrowers[msg.sender]) {\n            revert OnlyApprovedBorrowers();\n        }\n        _;\n    }\n\n    /// @notice Checks if msg.sender and _receiver are both an approved Lender\n    /// @param _receiver An additional receiver address to check\n    modifier approvedLender(address _receiver) {\n        if (lenderWhitelistActive && (!approvedLenders[msg.sender] || !approvedLenders[_receiver])) {\n            revert OnlyApprovedLenders();\n        }\n        _;\n    }\n\n    /// @notice Ensure function is not called when passed maturity\n    modifier isNotPastMaturity() {\n        if (_isPastMaturity()) {\n            revert PastMaturity();\n        }\n        _;\n    }\n\n    // ============================================================================================\n    // Functions: Interest Accumulation and Adjustment\n    // ============================================================================================\n\n    /// @notice The ```AddInterest``` event is emitted when interest is accrued by borrowers\n    /// @param _interestEarned The total interest accrued by all borrowers\n    /// @param _rate The interest rate used to calculate accrued interest\n    /// @param _deltaTime The time elapsed since last interest accrual\n    /// @param _feesAmount The amount of fees paid to protocol\n    /// @param _feesShare The amount of shares distributed to protocol\n    event AddInterest(\n        uint256 _interestEarned,\n        uint256 _rate,\n        uint256 _deltaTime,\n        uint256 _feesAmount,\n        uint256 _feesShare\n    );\n\n    /// @notice The ```UpdateRate``` event is emitted when the interest rate is updated\n    /// @param _ratePerSec The old interest rate (per second)\n    /// @param _deltaTime The time elapsed since last update\n    /// @param _utilizationRate The utilization of assets in the Pair\n    /// @param _newRatePerSec The new interest rate (per second)\n    event UpdateRate(uint256 _ratePerSec, uint256 _deltaTime, uint256 _utilizationRate, uint256 _newRatePerSec);\n\n    /// @notice The ```addInterest``` function is a public implementation of _addInterest and allows 3rd parties to trigger interest accrual\n    /// @return _interestEarned The amount of interest accrued by all borrowers\n    function addInterest()\n        external\n        nonReentrant\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            uint64 _newRate\n        )\n    {\n        return _addInterest();\n    }\n\n    /// @notice The ```_addInterest``` function is invoked prior to every external function and is used to accrue interest and update interest rate\n    /// @dev Can only called once per block\n    /// @return _interestEarned The amount of interest accrued by all borrowers\n    function _addInterest()\n        internal\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            uint64 _newRate\n        )\n    {\n        // Add interest only once per block\n        CurrentRateInfo memory _currentRateInfo = currentRateInfo;\n        if (_currentRateInfo.lastTimestamp == block.timestamp) {\n            _newRate = _currentRateInfo.ratePerSec;\n            return (_interestEarned, _feesAmount, _feesShare, _newRate);\n        }\n\n        // Pull some data from storage to save gas\n        VaultAccount memory _totalAsset = totalAsset;\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // If there are no borrows or contract is paused, no interest accrues and we reset interest rate\n        if (_totalBorrow.shares == 0 || paused()) {\n            if (!paused()) {\n                _currentRateInfo.ratePerSec = DEFAULT_INT;\n            }\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\n            _currentRateInfo.lastBlock = uint64(block.number);\n\n            // Effects: write to storage\n            currentRateInfo = _currentRateInfo;\n        } else {\n            // We know totalBorrow.shares > 0\n            uint256 _deltaTime = block.timestamp - _currentRateInfo.lastTimestamp;\n\n            // NOTE: Violates Checks-Effects-Interactions pattern\n            // Be sure to mark external version NONREENTRANT (even though rateContract is trusted)\n            // Calc new rate\n            uint256 _utilizationRate = (UTIL_PREC * _totalBorrow.amount) / _totalAsset.amount;\n            if (_isPastMaturity()) {\n                _newRate = uint64(penaltyRate);\n            } else {\n                bytes memory _rateData = abi.encode(\n                    _currentRateInfo.ratePerSec,\n                    _deltaTime,\n                    _utilizationRate,\n                    block.number - _currentRateInfo.lastBlock\n                );\n                _newRate = IRateCalculator(rateContract).getNewRate(_rateData, rateInitCallData);\n            }\n\n            // Event must be here to use non-mutated values\n            emit UpdateRate(_currentRateInfo.ratePerSec, _deltaTime, _utilizationRate, _newRate);\n\n            // Effects: bookkeeping\n            _currentRateInfo.ratePerSec = _newRate;\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\n            _currentRateInfo.lastBlock = uint64(block.number);\n\n            // Calculate interest accrued\n            _interestEarned = (_deltaTime * _totalBorrow.amount * _currentRateInfo.ratePerSec) / 1e18;\n\n            // Accumulate interest and fees, only if no overflow upon casting\n            if (\n                _interestEarned + _totalBorrow.amount <= type(uint128).max &&\n                _interestEarned + _totalAsset.amount <= type(uint128).max\n            ) {\n                _totalBorrow.amount += uint128(_interestEarned);\n                _totalAsset.amount += uint128(_interestEarned);\n                if (_currentRateInfo.feeToProtocolRate > 0) {\n                    _feesAmount = (_interestEarned * _currentRateInfo.feeToProtocolRate) / FEE_PRECISION;\n\n                    _feesShare = (_feesAmount * _totalAsset.shares) / (_totalAsset.amount - _feesAmount);\n\n                    // Effects: Give new shares to this contract, effectively diluting lenders an amount equal to the fees\n                    // We can safely cast because _feesShare < _feesAmount < interestEarned which is always less than uint128\n                    _totalAsset.shares += uint128(_feesShare);\n\n                    // Effects: write to storage\n                    _mint(address(this), _feesShare);\n                }\n                emit AddInterest(_interestEarned, _currentRateInfo.ratePerSec, _deltaTime, _feesAmount, _feesShare);\n            }\n\n            // Effects: write to storage\n            totalAsset = _totalAsset;\n            currentRateInfo = _currentRateInfo;\n            totalBorrow = _totalBorrow;\n        }\n    }\n\n    // ============================================================================================\n    // Functions: ExchangeRate\n    // ============================================================================================\n    /// @notice The ```UpdateExchangeRate``` event is emitted when the Collateral:Asset exchange rate is updated\n    /// @param _rate The new rate given as the amount of Collateral Token to buy 1e18 Asset Token\n    event UpdateExchangeRate(uint256 _rate);\n\n    /// @notice The ```updateExchangeRate``` function is the external implementation of _updateExchangeRate.\n    /// @dev This function is invoked at most once per block as these queries can be expensive\n    /// @return _exchangeRate The new exchange rate\n    function updateExchangeRate() external nonReentrant returns (uint256 _exchangeRate) {\n        _exchangeRate = _updateExchangeRate();\n    }\n\n    /// @notice The ```_updateExchangeRate``` function retrieves the latest exchange rate. i.e how much collateral to buy 1e18 asset.\n    /// @dev This function is invoked at most once per block as these queries can be expensive\n    /// @return _exchangeRate The new exchange rate\n    function _updateExchangeRate() internal returns (uint256 _exchangeRate) {\n        ExchangeRateInfo memory _exchangeRateInfo = exchangeRateInfo;\n        if (_exchangeRateInfo.lastTimestamp == block.timestamp) {\n            return _exchangeRate = _exchangeRateInfo.exchangeRate;\n        }\n\n        uint256 _price = uint256(1e36);\n        if (oracleMultiply != address(0)) {\n            (, int256 _answer, , , ) = AggregatorV3Interface(oracleMultiply).latestRoundData();\n            if (_answer <= 0) {\n                revert OracleLTEZero(oracleMultiply);\n            }\n            _price = _price * uint256(_answer);\n        }\n\n        if (oracleDivide != address(0)) {\n            (, int256 _answer, , , ) = AggregatorV3Interface(oracleDivide).latestRoundData();\n            if (_answer <= 0) {\n                revert OracleLTEZero(oracleDivide);\n            }\n            _price = _price / uint256(_answer);\n        }\n\n        _exchangeRate = _price / oracleNormalization;\n\n        // write to storage, if no overflow\n        if (_exchangeRate > type(uint224).max) revert PriceTooLarge();\n        _exchangeRateInfo.exchangeRate = uint224(_exchangeRate);\n        _exchangeRateInfo.lastTimestamp = uint32(block.timestamp);\n        exchangeRateInfo = _exchangeRateInfo;\n        emit UpdateExchangeRate(_exchangeRate);\n    }\n\n    // ============================================================================================\n    // Functions: Lending\n    // ============================================================================================\n\n    /// @notice The ```_deposit``` function is the internal implementation for lending assets\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _totalAsset An in memory VaultAccount struct representing the total amounts and shares for the Asset Token\n    /// @param _amount The amount of Asset Token to be transferred\n    /// @param _shares The amount of Asset Shares (fTokens) to be minted\n    /// @param _receiver The address to receive the Asset Shares (fTokens)\n    function _deposit(\n        VaultAccount memory _totalAsset,\n        uint128 _amount,\n        uint128 _shares,\n        address _receiver\n    ) internal {\n        // Effects: bookkeeping\n        _totalAsset.amount += _amount;\n        _totalAsset.shares += _shares;\n\n        // Effects: write back to storage\n        _mint(_receiver, _shares);\n        totalAsset = _totalAsset;\n\n        // Interactions\n        assetContract.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Deposit(msg.sender, _receiver, _amount, _shares);\n    }\n\n    /// @notice The ```deposit``` function allows a user to Lend Assets by specifying the amount of Asset Tokens to lend\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _amount The amount of Asset Token to transfer to Pair\n    /// @param _receiver The address to receive the Asset Shares (fTokens)\n    /// @return _sharesReceived The number of fTokens received for the deposit\n    function deposit(uint256 _amount, address _receiver)\n        external\n        nonReentrant\n        isNotPastMaturity\n        whenNotPaused\n        approvedLender(_receiver)\n        returns (uint256 _sharesReceived)\n    {\n        _addInterest();\n        VaultAccount memory _totalAsset = totalAsset;\n        _sharesReceived = _totalAsset.toShares(_amount, false);\n        _deposit(_totalAsset, _amount.toUint128(), _sharesReceived.toUint128(), _receiver);\n    }\n\n    /// @notice The ```mint``` function allows a user to Lend assets by specifying the number of Assets Shares (fTokens) to mint\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _shares The number of Asset Shares (fTokens) that a user wants to mint\n    /// @param _receiver The address to receive the Asset Shares (fTokens)\n    /// @return _amountReceived The amount of Asset Tokens transferred to the Pair\n    function mint(uint256 _shares, address _receiver)\n        external\n        nonReentrant\n        isNotPastMaturity\n        whenNotPaused\n        approvedLender(_receiver)\n        returns (uint256 _amountReceived)\n    {\n        _addInterest();\n        VaultAccount memory _totalAsset = totalAsset;\n        _amountReceived = _totalAsset.toAmount(_shares, true);\n        _deposit(_totalAsset, _amountReceived.toUint128(), _shares.toUint128(), _receiver);\n    }\n\n    /// @notice The ```_redeem``` function is an internal implementation which allows a Lender to pull their Asset Tokens out of the Pair\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _totalAsset An in-memory VaultAccount struct which holds the total amount of Asset Tokens and the total number of Asset Shares (fTokens)\n    /// @param _amountToReturn The number of Asset Tokens to return\n    /// @param _shares The number of Asset Shares (fTokens) to burn\n    /// @param _receiver The address to which the Asset Tokens will be transferred\n    /// @param _owner The owner of the Asset Shares (fTokens)\n    function _redeem(\n        VaultAccount memory _totalAsset,\n        uint128 _amountToReturn,\n        uint128 _shares,\n        address _receiver,\n        address _owner\n    ) internal {\n        if (msg.sender != _owner) {\n            uint256 allowed = allowance(_owner, msg.sender);\n            // NOTE: This will revert on underflow ensuring that allowance > shares\n            if (allowed != type(uint256).max) _approve(_owner, msg.sender, allowed - _shares);\n        }\n\n        // Check for sufficient withdraw liquidity\n        uint256 _assetsAvailable = _totalAssetAvailable(_totalAsset, totalBorrow);\n        if (_assetsAvailable < _amountToReturn) {\n            revert InsufficientAssetsInContract(_assetsAvailable, _amountToReturn);\n        }\n\n        // Effects: bookkeeping\n        _totalAsset.amount -= _amountToReturn;\n        _totalAsset.shares -= _shares;\n\n        // Effects: write to storage\n        totalAsset = _totalAsset;\n        _burn(_owner, _shares);\n\n        // Interactions\n        assetContract.safeTransfer(_receiver, _amountToReturn);\n        emit Withdraw(msg.sender, _receiver, _owner, _amountToReturn, _shares);\n    }\n\n    /// @notice The ```redeem``` function allows the caller to redeem their Asset Shares for Asset Tokens\n    /// @param _shares The number of Asset Shares (fTokens) to burn for Asset Tokens\n    /// @param _receiver The address to which the Asset Tokens will be transferred\n    /// @param _owner The owner of the Asset Shares (fTokens)\n    /// @return _amountToReturn The amount of Asset Tokens to be transferred\n    function redeem(\n        uint256 _shares,\n        address _receiver,\n        address _owner\n    ) external nonReentrant returns (uint256 _amountToReturn) {\n        _addInterest();\n        VaultAccount memory _totalAsset = totalAsset;\n        _amountToReturn = _totalAsset.toAmount(_shares, false);\n        _redeem(_totalAsset, _amountToReturn.toUint128(), _shares.toUint128(), _receiver, _owner);\n    }\n\n    /// @notice The ```withdraw``` function allows a user to redeem their Asset Shares for a specified amount of Asset Tokens\n    /// @param _amount The amount of Asset Tokens to be transferred in exchange for burning Asset Shares\n    /// @param _receiver The address to which the Asset Tokens will be transferred\n    /// @param _owner The owner of the Asset Shares (fTokens)\n    /// @return _shares The number of Asset Shares (fTokens) burned\n    function withdraw(\n        uint256 _amount,\n        address _receiver,\n        address _owner\n    ) external nonReentrant returns (uint256 _shares) {\n        _addInterest();\n        VaultAccount memory _totalAsset = totalAsset;\n        _shares = _totalAsset.toShares(_amount, true);\n        _redeem(_totalAsset, _amount.toUint128(), _shares.toUint128(), _receiver, _owner);\n    }\n\n    // ============================================================================================\n    // Functions: Borrowing\n    // ============================================================================================\n\n    /// @notice The ```BorrowAsset``` event is emitted when a borrower increases their position\n    /// @param _borrower The borrower whose account was debited\n    /// @param _receiver The address to which the Asset Tokens were transferred\n    /// @param _borrowAmount The amount of Asset Tokens transferred\n    /// @param _sharesAdded The number of Borrow Shares the borrower was debited\n    event BorrowAsset(\n        address indexed _borrower,\n        address indexed _receiver,\n        uint256 _borrowAmount,\n        uint256 _sharesAdded\n    );\n\n    /// @notice The ```_borrowAsset``` function is the internal implementation for borrowing assets\n    /// @param _borrowAmount The amount of the Asset Token to borrow\n    /// @param _receiver The address to receive the Asset Tokens\n    /// @return _sharesAdded The amount of borrow shares the msg.sender will be debited\n    function _borrowAsset(uint128 _borrowAmount, address _receiver) internal returns (uint256 _sharesAdded) {\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // Check available capital\n        uint256 _assetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow);\n        if (_assetsAvailable < _borrowAmount) {\n            revert InsufficientAssetsInContract(_assetsAvailable, _borrowAmount);\n        }\n\n        // Effects: Bookkeeping to add shares & amounts to total Borrow accounting\n        _sharesAdded = _totalBorrow.toShares(_borrowAmount, true);\n        _totalBorrow.amount += _borrowAmount;\n        _totalBorrow.shares += uint128(_sharesAdded);\n        // NOTE: we can safely cast here because shares are always less than amount and _borrowAmount is uint128\n\n        // Effects: write back to storage\n        totalBorrow = _totalBorrow;\n        userBorrowShares[msg.sender] += _sharesAdded;\n\n        // Interac"
    }
  ]
}