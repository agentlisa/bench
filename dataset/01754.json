{
  "Title": "M-1: In case the portfolio makes a loss, the total reserves and reserve ratio will be inflated.",
  "Content": "# Issue M-1: In case the portfolio makes a loss, the total reserves and reserve ratio will be inflated. \n\nSource: https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/16 \n\n## Found by \nast3ros\n## Summary  \n\nThe pool balance is transferred to the portfolio for investment, for example sending USDT to Curve/Aave/Balancer etc. to generate yield. However, there are risks associated with those protocols such as smart contract risks. In case a loss happens, it will not be reflected in the pool balance and the total reserve and reserve ratio will be inflated.\n\n## Vulnerability Detail\n\nThe assets in the pool can be sent to the portfolio account to invest and earn yield. The amount of assets in the insurance pool and Unitas pool is tracked by the `_balance` variable. This amount is used to calculate the total reserve and total collateral, which then are used to calculate the reserve ratio.\n\n            uint256 tokenReserve = _getBalance(token);\n            uint256 tokenCollateral = IInsurancePool(insurancePool).getCollateral(token);\n\nWhen there is a loss to the portfolio, there is no way to write down the `_balance` variable. This leads to an overstatement of the total reserve and reserve ratio.\n\n## Impact\n\nOverstatement of the total reserve and reserve ratio can increase the risk for the protocol because of undercollateralization of assets.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/Unitas.sol#L508-L509\nhttps://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/PoolBalances.sol#L111-L113\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd function to allow admin to write off the `_balance` in case of investment lost. Example:\n\n```javascript\n\nfunction writeOff(address token, uint256 amount) external onlyGuardian {\n\n    uint256 currentBalance = IERC20(token).balanceOf(address(this));\n\n    // Require that the amount to write off is less than or equal to the current balance\n    require(amount <= currentBalance, \"Amount exceeds balance\");\n    _balance[token] -= amount;\n\n    emit WriteOff(token, amount);\n}\n\n```\n\n\n\n## Discussion\n\n**Adityaxrex**\n\nAditya: This will need to be manually updated. The likelyhood is small but can be contained by diversification and risk management.\n\n**SunXrex**\n\nin phase 1, reserve ratio will not impact by portfolio impact\n\n**ctf-sec**\n\n> This will need to be manually updated. The likelyhood is small but can be contained by diversification and risk management.\n\nIntend to maintain the medium severity\n\n**0xffff11**\n\nI agree with a medium. Despite being very unlikely, the risk exists. \n\n**Shogoki**\n\nEscalate for 10 USDC\nI think this should be rated as low, as per the sponsors comments.\nI think it is similiar to #95 the design decision to use the portfolio together with the collateral & accepted risk of the protocol. \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> I think this should be rated as low, as per the sponsors comments.\n> I think it is similiar to #95 the design decision to use the portfolio together with the collateral & accepted risk of the protocol. \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**thangtranth**\n\nEscalate for 10 USDC\n\n@Shogoki thank you for your idea. However those are two different issues:\n\nIn #95, the sponsors explained their design choice of “taking a small portion to invest in delta neutral defi pools.” This implies that there are enough funds for users to withdraw at any time.\n\nIn this issue, the sponsors mention above how to “contain” the risks, meaning how the protocol will try to reduce the financial loss in case of a negative event. However, the loss still happens and the reserve accounting of the protocol contract is incorrect. Therefore this is a valid medium issue.\n\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> @Shogoki thank you for your idea. However those are two different issues:\n> \n> In #95, the sponsors explained their design choice of “taking a small portion to invest in delta neutral defi pools.” This implies that there are enough funds for users to withdraw at any time.\n> \n> In this issue, the sponsors mention above how to “contain” the risks, meaning how the protocol will try to reduce the financial loss in case of a negative event. However, the loss still happens and the reserve accounting of the protocol contract is incorrect. Therefore this is a valid medium issue.\n> \n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\nI think in both cases the sent out fund are not directly available for users to withdraw. \n\n**thangtranth**\n\nNo, it is not. Just one simple example that shows the difference: \n\nAs design, the protocol is at 130% reserve ratio (110% stays in pool for redemption,  20% for yield generation in portfolio). The portfolio makes a loss, which drive the reserve ratio down to 115% (110% still stays in the pool for redemption, 5% left in portfolio). \n\nIn this case, all the funds are still available for users. But the reserve ratio is hugely overstated (130% instead of 115%). \n\n**ctf-sec**\n\nCan keep the medium severity, inflated total reserves can be considered as accounting issue if the invested portfolio make a loss (countless example of rug and hack, certainly we do not hope the protocol, our sponsor deal with such situation)\n\n**jacksanford1**\n\nAgree with Medium. The case for Low is:\n\n> I think this should be rated as low, as per the sponsors comments.\n\nSponsor is not saying it should be low imo. Sponsor is saying it's unlikely, but it can still be a Medium even if that's true. \n\n> I think it is similiar to https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/95 the design decision to use the portfolio together with the collateral & accepted risk of the protocol.\n\nIt seems like the problem is that a loss of assets would not be properly reflected in the pool balance, resulting in bad outcomes. If the pool balance is not functioning properly, I don't think that's an intentional design decision. \n\n**0xffff11**\n\nIt is a complicated issue so I see the case for both. Though I tend more to medium. Imo a medium makes sense on this one.\n\n**jacksanford1**\n\nThis falls into the \"breaks unconditional exit\" category but also points out something novel which is that the _balance variable doesn't reflect a loss in the portfolio. \n\nValid Medium. \n\n**Adityaxrex**\n\n@jacksanford1 Thank you\n\n**hrishibhat**\n\nResult:\nMedium\nUnique \n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [thangtranth](https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/16/#issuecomment-1605243342): accepted\n- [Shogoki](https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/16/#issuecomment-1604539486): rejected\n\n**jacksanford1**\n\nAcknowledged by protocol team (won't fix). \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/73",
  "Code": [
    {
      "filename": "Unitas-Protocol/src/Unitas.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"./interfaces/IERC20Token.sol\";\nimport \"./interfaces/IInsurancePool.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/IUnitas.sol\";\nimport \"./utils/AddressUtils.sol\";\nimport \"./utils/Errors.sol\";\nimport \"./utils/ScalingUtils.sol\";\nimport \"./SwapFunctions.sol\";\nimport \"./PoolBalances.sol\";\n\n/**\n * @title Unitas\n * @notice This contract is primarily used for exchanging tokens and managing reserve assets\n */\ncontract Unitas is\n    Initializable,\n    PausableUpgradeable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable,\n    IUnitas,\n    PoolBalances,\n    SwapFunctions\n{\n    using MathUpgradeable for uint256;\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    bytes32 public constant TIMELOCK_ROLE = keccak256(\"TIMELOCK_ROLE\");\n    bytes32 public constant PORTFOLIO_ROLE = keccak256(\"PORTFOLIO_ROLE\");\n\n    IOracle public oracle;\n    address public surplusPool;\n    address public insurancePool;\n    ITokenManager public tokenManager;\n\n    /**\n     * @notice Emitted when `oracle` is updated\n     */\n    event SetOracle(address indexed newOracle);\n    /**\n     * @notice Emitted when `surplusPool` is updated\n     */\n    event SetSurplusPool(address indexed newSurplusPool);\n    /**\n     * @notice Emitted when `insurancePool` is updated\n     */\n    event SetInsurancePool(address indexed newInsurancePool);\n    /**\n     * @notice Emitted when `tokenManager` is updated\n     */\n    event SetTokenManager(ITokenManager indexed newTokenManager);\n    /**\n     * @notice Emitted when `sender` swap tokens\n     */\n    event Swapped(\n        address indexed tokenIn,\n        address indexed tokenOut,\n        address indexed sender,\n        uint256 amountIn,\n        uint256 amountOut,\n        address feeToken,\n        uint256 fee,\n        uint24 feeNumerator,\n        uint256 price\n    );\n    /**\n     * @notice Emitted when swapping `fee` is sent to `receiver`\n     */\n    event SwapFeeSent(address indexed feeToken, address indexed receiver, uint256 fee);\n\n    // ============================== ERRORS ==============================\n\n    error NotTimelock(address caller);\n    error NotGuardian(address caller);\n    error NotPortfolio(address caller);\n\n    // ============================== MODIFIERS ==============================\n\n    /**\n     * @notice Reverts if `msg.sender` does not have `TIMELOCK_ROLE`\n     */\n    modifier onlyTimelock() {\n        if (!hasRole(TIMELOCK_ROLE, msg.sender))\n            revert NotTimelock(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Reverts if `msg.sender` does not have `GUARDIAN_ROLE`\n     */\n    modifier onlyGuardian() {\n        if (!hasRole(GUARDIAN_ROLE, msg.sender))\n            revert NotGuardian(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Reverts if `account` does not have `PORTFOLIO_ROLE`\n     */\n    modifier onlyPortfolio(address account) {\n        if (!hasRole(PORTFOLIO_ROLE, account)) {\n            revert NotPortfolio(account);\n        }\n        _;\n    }\n\n\n    // ============================== CONSTRUCTOR ==============================\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract\n     * @param config_ `InitializeConfig` to init states\n     */\n    function initialize(InitializeConfig calldata config_) public initializer {\n        __Pausable_init();\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, GUARDIAN_ROLE);\n        _setRoleAdmin(TIMELOCK_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(PORTFOLIO_ROLE, GUARDIAN_ROLE);\n\n        _grantRole(GOVERNOR_ROLE, config_.governor);\n        _grantRole(GUARDIAN_ROLE, config_.guardian);\n        _grantRole(TIMELOCK_ROLE, config_.timelock);\n        _grantRole(PORTFOLIO_ROLE, config_.guardian);\n\n        _setOracle(config_.oracle);\n        _setSurplusPool(config_.surplusPool);\n        _setInsurancePool(config_.insurancePool);\n        _setTokenManager(config_.tokenManager);\n    }\n\n    // ============================== Timelock FUNCTIONS ===========================\n\n    /**\n     * @notice Updates the address of `oracle` by `newOracle`\n     */\n    function setOracle(address newOracle) external onlyTimelock {\n        _setOracle(newOracle);\n    }\n\n    /**\n     * @notice Updates the address of `surplusPool` by `newSurplusPool`\n     */\n    function setSurplusPool(address newSurplusPool) external onlyTimelock {\n        _setSurplusPool(newSurplusPool);\n    }\n\n    /**\n     * @notice Updates the address of `insurancePool` by `newInsurancePool`\n     */\n    function setInsurancePool(address newInsurancePool) external onlyTimelock {\n        _setInsurancePool(newInsurancePool);\n    }\n\n    /**\n     * @notice Updates the address of `tokenManager`\n     */\n    function setTokenManager(ITokenManager newTokenManager) external onlyTimelock {\n        _setTokenManager(newTokenManager);\n    }\n\n    // ============================== GUARDIAN FUNCTIONS ===========================\n\n    /**\n     * @notice Pause token swapping\n     */\n    function pause() public onlyGuardian {\n        _pause();\n    }\n\n    /**\n     * @notice Resume token swapping\n     */\n    function unpause() public onlyGuardian {\n        _unpause();\n    }\n\n    // ============================== EXTERNAL FUNCTIONS ===========================\n\n    /**\n     * @notice Swaps tokens\n     * @param tokenIn The address of the token to be spent\n     * @param tokenOut The address of the token to be obtained\n     * @param amountType The type of the amount\n     * @param amount When `amountType` is `In`, it's the number of `tokenIn` that the user wants to spend.\n     *               When `amountType` is `Out`, it's the number of `tokenOut` that the user wants to obtain.\n     * @return amountIn The amount of `tokenIn` spent\n     * @return amountOut The amount of `tokenOut` obtained\n     */\n    function swap(address tokenIn, address tokenOut, AmountType amountType, uint256 amount)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (uint256 amountIn, uint256 amountOut)\n    {\n        IERC20Token feeToken;\n        uint256 fee;\n        uint24 feeNumerator;\n        uint256 price;\n        ITokenManager.PairConfig memory pair = tokenManager.getPair(tokenIn, tokenOut);\n\n        (amountIn, amountOut, feeToken, fee, feeNumerator, price) = _getSwapResult(pair, tokenIn, tokenOut, amountType, amount);\n\n        _require(IERC20(tokenIn).balanceOf(msg.sender) >= amountIn, Errors.BALANCE_INSUFFICIENT);\n\n        _swapIn(tokenIn, msg.sender, amountIn);\n\n        _swapOut(tokenOut, msg.sender, amountOut);\n\n        if (fee > 0) {\n            address feeReceiver = surplusPool;\n            feeToken.mint(feeReceiver, fee);\n            emit SwapFeeSent(address(feeToken), feeReceiver, fee);\n        }\n\n        _checkReserveRatio(tokenOut == pair.baseToken ? pair.buyReserveRatioThreshold : pair.sellReserveRatioThreshold);\n\n        emit Swapped(tokenIn, tokenOut, msg.sender, amountIn, amountOut, address(feeToken), fee, feeNumerator, price);\n    }\n\n    /**\n     * @notice Receives the portfolio from caller\n     * @param token Address of the token\n     * @param amount Amount of the portfolio\n     */\n    function receivePortfolio(address token, uint256 amount)\n        external\n        onlyPortfolio(msg.sender)\n        nonReentrant\n    {\n        _receivePortfolio(token, msg.sender, amount);\n    }\n\n    /**\n     * @notice Sends the portfolio to the receiver\n     * @param token Address of the token\n     * @param receiver Account to receive the portfolio\n     * @param amount Amount of the portfolio\n     */\n    function sendPortfolio(address token, address receiver, uint256 amount)\n        external\n        onlyTimelock\n        onlyPortfolio(receiver)\n        nonReentrant\n    {\n        _sendPortfolio(token, receiver, amount);\n    }\n\n    /**\n     * @notice Estimates swapping result for quoting\n     * @param tokenIn The address of the token to be spent\n     * @param tokenOut The address of the token to be obtained\n     * @param amountType The type of the amount\n     * @param amount When `amountType` is `In`, it's the number of `tokenIn` that the user wants to spend.\n     *               When `amountType` is `Out`, it's the number of `tokenOut` that the user wants to obtain.\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return feeToken The fee token\n     * @return fee Swapping fee calculated in `feeToken`\n     * @return feeNumerator The numerator of the fee fraction\n     * @return price The price of `tokenIn`/`tokenOut`\n     */\n    function estimateSwapResult(address tokenIn, address tokenOut, AmountType amountType, uint256 amount)\n        external\n        view\n        returns (uint256 amountIn, uint256 amountOut, IERC20Token feeToken, uint256 fee, uint24 feeNumerator, uint256 price)\n    {\n        ITokenManager.PairConfig memory pair = tokenManager.getPair(tokenIn, tokenOut);\n\n        (amountIn, amountOut, feeToken, fee, feeNumerator, price) = _getSwapResult(pair, tokenIn, tokenOut, amountType, amount);\n    }\n\n    // ============================== PUBLIC FUNCTIONS ==============================\n\n    /**\n     * @notice Gets the reserve of `token`\n     */\n    function getReserve(address token) public view returns (uint256) {\n        return _getBalance(token);\n    }\n\n    /**\n     * @notice Gets the portfolio of `token`\n     */\n    function getPortfolio(address token) public view returns (uint256) {\n        return _getPortfolio(token);\n    }\n\n    /**\n     * @notice Gets the reserve status\n     * @return reserveStatus `Undefined` when `reserves`, `collaterals` and `liabilities` are zero.\n                              `Infinite` when `liabilities` is zero.\n                              Otherwise `Finite`.\n     * @return reserves Total reserves denominated in USD1\n     * @return collaterals Total collaterals denominated in USD1\n     * @return liabilities Total liabilities denominated in USD1\n     * @return reserveRatio The numerator of the reserve ratio is expressed in 18 decimal places\n     */\n    function getReserveStatus()\n        public\n        view\n        returns (ReserveStatus reserveStatus, uint256 reserves, uint256 collaterals, uint256 liabilities, uint256 reserveRatio)\n    {\n        (reserves, collaterals) = _getTotalReservesAndCollaterals();\n        liabilities = _getTotalLiabilities();\n\n        (reserveStatus, reserveRatio) = _getReserveStatus(reserves + collaterals, liabilities);\n    }\n\n    // ============================== INTERNAL FUNCTIONS ==============================\n\n    function _setOracle(address newOracle) internal {\n        AddressUtils.checkContract(newOracle);\n        oracle = IOracle(newOracle);\n        emit SetOracle(newOracle);\n    }\n\n    function _setSurplusPool(address newSurplusPool) internal {\n        _require(newSurplusPool != address(0), Errors.ADDRESS_ZERO);\n        surplusPool = newSurplusPool;\n        emit SetSurplusPool(newSurplusPool);\n    }\n\n    function _setInsurancePool(address newInsurancePool) internal {\n        AddressUtils.checkContract(newInsurancePool);\n        insurancePool = newInsurancePool;\n        emit SetInsurancePool(newInsurancePool);\n    }\n\n    function _setTokenManager(ITokenManager newTokenManager) internal {\n        AddressUtils.checkContract(address(newTokenManager));\n        tokenManager = newTokenManager;\n        emit SetTokenManager(newTokenManager);\n    }\n\n    /**\n     * @notice Spends tokens for swapping\n     * @param token The address of the token\n     * @param spender The account to spend tokens\n     * @param amount The amount to be consumed\n     */\n    function _swapIn(address token, address spender, uint256 amount) internal {\n        ITokenManager.TokenType tokenType = tokenManager.getTokenType(token);\n\n        require(tokenType != ITokenManager.TokenType.Undefined);\n\n        if (tokenType == ITokenManager.TokenType.Asset) {\n            _setBalance(token, _getBalance(token) + amount);\n            IERC20(token).safeTransferFrom(spender, address(this), amount);\n        } else {\n            IERC20Token(token).burn(spender, amount);\n        }\n    }\n\n    /**\n     * @notice Receives tokens for swapping\n     * @param token The address of the token\n     * @param receiver The account to receive tokens\n     * @param amount The amount to be obtained\n     */\n    function _swapOut(address token, address receiver, uint256 amount) internal {\n        ITokenManager.TokenType tokenType = tokenManager.getTokenType(token);\n\n        require(tokenType != ITokenManager.TokenType.Undefined);\n\n        if (tokenType == ITokenManager.TokenType.Asset) {\n            uint256 tokenReserve = _getBalance(token);\n            uint256 reserveAmount = amount.min(tokenReserve - _getPortfolio(token));\n\n            if (amount > reserveAmount) {\n                uint256 collateralAmount = amount - reserveAmount;\n\n                // Pull the collateral from insurance pool\n                IInsurancePool(insurancePool).withdrawCollateral(token, collateralAmount);\n            }\n\n            _setBalance(token, tokenReserve - reserveAmount);\n            IERC20(token).safeTransfer(receiver, amount);\n        } else {\n            IERC20Token(token).mint(receiver, amount);\n        }\n    }\n\n    /**\n     * @notice Gets the swapping result\n     * @param pair The setting of the pair\n     * @param tokenIn The address of the token to be spent\n     * @param tokenOut The address of the token to be obtained\n     * @param amountType The type of the amount\n     * @param amount When `amountType` is `In`, it's the number of `tokenIn` that the user wants to spend.\n     *               When `amountType` is `Out`, it's the number of `tokenOut` that the user wants to obtain.\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return feeToken The fee token is always USD1\n     * @return fee Swapping fee calculated in USD1\n     * @return feeNumerator The numerator of the fee fraction\n     * @return price The price of `tokenIn`/`tokenOut`\n     */\n    function _getSwapResult(\n        ITokenManager.PairConfig memory pair,\n        address tokenIn,\n        address tokenOut,\n        AmountType amountType,\n        uint256 amount\n    )\n        internal\n        view\n        returns (uint256 amountIn, uint256 amountOut, IERC20Token feeToken, uint256 fee, uint24 feeNumerator, uint256 price)\n    {\n        _checkAmountPositive(amount);\n\n        // Checks the tokens of the pair config are valid\n        bool isBuy = tokenOut == pair.baseToken;\n        _require(\n            (isBuy && tokenIn == pair.quoteToken) ||\n                (tokenOut == pair.quoteToken && tokenIn == pair.baseToken),\n            Errors.PAIR_INVALID\n        );\n\n        address priceQuoteToken = _getPriceQuoteToken(tokenIn, tokenOut);\n        price = oracle.getLatestPrice(priceQuoteToken);\n        _checkPrice(priceQuoteToken, price);\n\n        feeNumerator = isBuy ? pair.buyFee : pair.sellFee;\n        feeToken = IERC20Token(priceQuoteToken == tokenIn ? tokenOut : tokenIn);\n\n        SwapRequest memory request;\n        request.tokenIn = tokenIn;\n        request.tokenOut = tokenOut;\n        request.amountType = amountType;\n        request.amount = amount;\n        request.feeNumerator = feeNumerator;\n        request.feeBase = tokenManager.SWAP_FEE_BASE();\n        request.feeToken = address(feeToken);\n        request.price = price;\n        request.priceBase = 10 ** oracle.decimals();\n        request.quoteToken = priceQuoteToken;\n\n        (amountIn, amountOut, fee) = _calculateSwapResult(request);\n\n        _require(amountIn > 0 && amountOut > 0, Errors.SWAP_RESULT_INVALID);\n\n        if (tokenIn == priceQuoteToken) {\n            // The base currency of oracle price is USD1, inverts the price when buying USD1\n            price = request.priceBase * request.priceBase / price;\n        }\n    }\n\n    /**\n     * @notice Gets the reserve status and reserve ratio.\n     * @param allReserves Sum of the reserves and the collaterals denominated in USD1\n     * @param liabilities Total liabilities denominated in USD1\n     * @return reserveStatus `Undefined` when `allReserves` and `liabilities` are zero.\n                              `Infinite` when `liabilities` is zero.\n                              Otherwise `Finite`.\n     * @return reserveRatio The numerator of the reserve ratio is expressed in 18 decimal places\n     */\n    function _getReserveStatus(uint256 allReserves, uint256 liabilities)\n        internal\n        view\n        returns (ReserveStatus reserveStatus, uint256 reserveRatio)\n    {\n        if (liabilities == 0) {\n            reserveStatus = allReserves == 0 ? ReserveStatus.Undefined : ReserveStatus.Infinite;\n        } else {\n            reserveStatus = ReserveStatus.Finite;\n\n            // All decimals of parameters are the same as USD1\n            uint256 valueBase = 10 ** tokenManager.usd1().decimals();\n\n            reserveRatio = ScalingUtils.scaleByBases(\n                allReserves * valueBase / liabilities,\n                valueBase,\n                tokenManager.RESERVE_RATIO_BASE()\n            );\n        }\n    }\n\n    /**\n     * @notice Gets total reserves and total collaterals in USD1\n     */\n    function _getTotalReservesAndCollaterals() internal view returns (uint256 reserves, uint256 collaterals) {\n        address baseToken = address(tokenManager.usd1());\n        uint8 tokenTypeValue = uint8(ITokenManager.TokenType.Asset);\n        uint256 tokenCount = tokenManager.tokenLength(tokenTypeValue);\n        uint256 priceBase = 10 ** oracle.decimals();\n\n        for (uint256 i; i < tokenCount; i++) {\n            address token = tokenManager.tokenByIndex(tokenTypeValue, i);\n            uint256 tokenReserve = _getBalance(token);\n            uint256 tokenCollateral = IInsurancePool(insurancePool).getCollateral(token);\n\n            if (tokenReserve > 0 || tokenCollateral > 0) {\n                uint256 price = oracle.getLatestPrice(token);\n\n                reserves += _convert(\n                    token,\n                    baseToken,\n                    tokenReserve,\n                    MathUpgradeable.Rounding.Down,\n                    price,\n                    priceBase,\n                    token\n                );\n\n                collaterals += _convert(\n                    token,\n                    baseToken,\n                    tokenCollateral,\n                    MathUpgradeable.Rounding.Down,\n                    price,\n                    priceBase,\n                    token\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Gets total liabilities in USD1\n     */\n    function _getTotalLiabilities() internal view returns (uint256 liabilities) {\n        address baseToken = address(tokenManager.usd1());\n        uint8 tokenTypeValue = uint8(ITokenManager.TokenType.Stable);\n        uint256 tokenCount = tokenManager.tokenLength(tokenTypeValue);\n        uint256 priceBase = 10 ** oracle.decimals();\n\n        for (uint256 i; i < tokenCount; i++) {\n            address token = tokenManager.tokenByIndex(tokenTypeValue, i);\n            uint256 tokenSupply = IERC20Token(token).totalSupply();\n\n            if (token == baseToken) {\n                // Adds up directly when the token is USD1\n                liabilities += tokenSupply;\n            } else if (tokenSupply > 0) {\n                uint256 price = oracle.getLatestPrice(token);\n\n                liabilities += _convert(\n                    token,\n                    baseToken,\n                    tokenSupply,\n                    MathUpgradeable.Rounding.Down,\n                    price,\n                    priceBase,\n                    token\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Gets the quote token of oracle price by two token addresses.\n     *          Because of the base currencies of all oracle prices are always USD1 (e.g., USD1/USDT and USD1/USD91),\n     *          one of `tokenX` or `tokenY` must be USD1, and the other must not be USD1.\n     * @dev The caller must ensure that both tokens are in the pool\n     * @param tokenX Address of base currency or quote currency\n     * @param tokenY Address of base currency or quote currency\n     * @return quoteToken The quote currency of oracle price\n     */\n    function _getPriceQuoteToken(address tokenX, address tokenY) internal view returns (address quoteToken) {\n        _require(tokenX != tokenY, Errors.PAIR_INVALID);\n\n        address baseToken = address(tokenManager.usd1());\n        _require(baseToken != address(0), Errors.USD1_NOT_SET);\n\n        bool isXBase = tokenX == baseToken;\n        _require(isXBase || tokenY == baseToken, Errors.PAIR_INVALID);\n\n        quoteToken = isXBase ? tokenY : tokenX;\n    }\n\n    /**\n     * @notice Reverts if the price or the tolerance range is invalid\n     * @param quoteToken Address of quote token to get the tolerance range\n     * @param price The price of USD1/`quoteToken`\n     */\n    function _checkPrice(address quoteToken, uint256 price) internal view {\n        (uint256 minPrice, uint256 maxPrice) = tokenManager.getPriceTolerance(quoteToken);\n\n        _require(minPrice > 0 && maxPrice > 0, Errors.PRICE_TOLERANCE_INVALID);\n        _require(minPrice <= price && price <= maxPrice, Errors.PRICE_INVALID);\n    }\n\n    /**\n     * @notice Checks the reserve ratio is sufficient when `reserveRatioThreshold` is greater than zero\n     */\n    function _checkReserveRatio(uint232 reserveRatioThreshold) internal view {\n        if (reserveRatioThreshold == 0) {\n            return;\n        } else {\n            (uint256 reserves, uint256 collaterals) = _getTotalReservesAndCollaterals();\n            uint256 allReserves = reserves + collaterals;\n            uint256 liabilities = _getTotalLiabilities();\n\n            (ReserveStatus reserveStatus, uint256 reserveRatio) = _getReserveStatus(allReserves, liabilities);\n\n            if (reserveStatus != ReserveStatus.Infinite) {\n                _require(reserveRatio > reserveRatioThreshold, Errors.RESERVE_RATIO_NOT_GREATER_THAN_THRESHOLD);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "Unitas-Protocol/src/PoolBalances.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"./utils/AddressUtils.sol\";\nimport \"./utils/Errors.sol\";\n\n/**\n * @title PoolBalances\n * @notice The abstract contract includes some generic functions and states that are used to manage pool assets\n *\n * @custom:storage-size 50\n */\nabstract contract PoolBalances {\n    using MathUpgradeable for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Maps the address to the balance of the token\n     */\n    mapping(address => uint256) internal _balance;\n    /**\n     * @notice Maps the address to the portfolio of the token\n     */\n    mapping(address => uint256) internal _portfolio;\n\n    /**\n     * @notice Emitted when the balance of `token` is updated to `newBalance`\n     */\n    event BalanceUpdated(address indexed token, uint256 newBalance);\n    /**\n     * @notice Emitted when portfolio `amount` of `token` is received from `sender`\n     */\n    event PortfolioReceived(address indexed token, address indexed sender, uint256 amount);\n    /**\n     * @notice Emitted when portfolio `amount` of `token` is sent to `receiver`\n     */\n    event PortfolioSent(address indexed token, address indexed receiver, uint256 amount);\n    /**\n     * @notice Emitted when the portfolio of `token` is updated to `newPortfolio`\n     */\n    event PortfolioUpdated(address indexed token, uint256 newPortfolio);\n\n    /**\n     * @notice Updates the balance of `token` to `newBalance`\n     */\n    function _setBalance(address token, uint256 newBalance) internal virtual {\n        _balance[token] = newBalance;\n        emit BalanceUpdated(token, newBalance);\n    }\n\n    /**\n     * @notice Updates the portfolio of `token` to `newPortfolio`\n     */\n    function _setPortfolio(address token, uint256 newPortfolio) internal virtual {\n        _portfolio[token] = newPortfolio;\n        emit PortfolioUpdated(token, newPortfolio);\n    }\n\n    /**\n     * @notice Receives portfolio `amount` of `token` from `sender`\n     */\n    function _receivePortfolio(address token, address sender, uint256 amount) internal virtual {\n        AddressUtils.checkNotZero(token);\n        AddressUtils.checkNotZero(sender);\n        _checkAmountPositive(amount);\n        _require(sender != address(this), Errors.SENDER_INVALID);\n\n        uint256 portfolio = _getPortfolio(token);\n        _require(amount <= portfolio, Errors.AMOUNT_INVALID);\n\n        _setPortfolio(token, portfolio - amount);\n\n        IERC20(token).safeTransferFrom(sender, address(this), amount);\n\n        emit PortfolioReceived(token, sender, amount);\n    }\n\n    /**\n     * @notice Sends portfolio `amount` of `token` to `receiver`\n     */\n    function _sendPortfolio(address token, address receiver, uint256 amount) internal virtual {\n        AddressUtils.checkNotZero(token);\n        AddressUtils.checkNotZero(receiver);\n        _checkAmountPositive(amount);\n        _require(receiver != address(this), Errors.RECEIVER_INVALID);\n\n        uint256 portfolio = _getPortfolio(token);\n        amount = amount.min(_getBalance(token) - portfolio);\n\n        _require(amount > 0, Errors.POOL_BALANCE_INSUFFICIENT);\n\n        _setPortfolio(token, portfolio + amount);\n\n        IERC20(token).safeTransfer(receiver, amount);\n\n        emit PortfolioSent(token, receiver, amount);\n    }\n\n    /**\n     * @notice Gets the current balance of `token`\n     */\n    function _getBalance(address token) internal view virtual returns (uint256) {\n        return _balance[token];\n    }\n\n    /**\n     * @notice Gets the current portfolio of `token`\n     */\n    function _getPortfolio(address token) internal view virtual returns (uint256) {\n        return _portfolio[token];\n    }\n\n    /**\n     * @notice Reverts if `amount` is zero or negative\n     */\n    function _checkAmountPositive(uint256 amount) internal pure {\n        _require(amount > 0, Errors.AMOUNT_INVALID);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}"
    }
  ]
}