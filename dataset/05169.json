{
  "Title": "[M-04] DoS in `MergingPool::claimRewards` function and potential DoS in `RankedBattle::claimNRN` function if called after a significant amount of rounds passed",
  "Content": "\nThe `MergingPool::claimRewards` function loop through last claimed round ID to the latest round ID ( <https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/MergingPool.sol#L139> ):\n\n```solidity\nfunction claimRewards(\n    string[] calldata modelURIs,\n    string[] calldata modelTypes,\n    uint256[2][] calldata customAttributes\n)\n    external\n{\n    uint256 winnersLength;\n    uint32 claimIndex = 0;\n@->    uint32 lowerBound = numRoundsClaimed[msg.sender];\n@->    for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n        numRoundsClaimed[msg.sender] += 1;\n        winnersLength = winnerAddresses[currentRound].length;\n        for (uint32 j = 0; j < winnersLength; j++) {\n            if (msg.sender == winnerAddresses[currentRound][j]) {\n                _fighterFarmInstance.mintFromMergingPool(\n                    msg.sender,\n                    modelURIs[claimIndex],\n                    modelTypes[claimIndex],\n                    customAttributes[claimIndex]\n                );\n                claimIndex += 1;\n            }\n        }\n    }\n    if (claimIndex > 0) {\n        emit Claimed(msg.sender, claimIndex);\n    }\n}\n```\n\nAlso there's another nested loop which loops through all the winners each round. Thus, it will become very expensive to claim rewards and eventually leads to block gas limit. Due to which some users may never be able to claim their rewards.\n\nTherefore, If user try to claim their rewards after many rounds has passed then due to the above mentioned loops, it will consume a lot of gas and eventually leads to block gas limit.\n\nSimilarly, the `RankedBattle::claimNRN` function loop through last claimed round ID to the latest round ID ( <https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/RankedBattle.sol#L294> ) :\n\n```solidity\nfunction claimNRN() external {\n    require(numRoundsClaimed[msg.sender] < roundId, \"Already claimed NRNs for this period\");\n    uint256 claimableNRN = 0;\n    uint256 nrnDistribution;\n@->    uint32 lowerBound = numRoundsClaimed[msg.sender];\n@->    for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n        nrnDistribution = getNrnDistribution(currentRound);\n        claimableNRN += (\n            accumulatedPointsPerAddress[msg.sender][currentRound] * nrnDistribution\n        ) / totalAccumulatedPoints[currentRound];\n        numRoundsClaimed[msg.sender] += 1;\n    }\n    if (claimableNRN > 0) {\n        amountClaimed[msg.sender] += claimableNRN;\n        _neuronInstance.mint(msg.sender, claimableNRN);\n        emit Claimed(msg.sender, claimableNRN);\n    }\n}\n```\n\nAlthough, it's relatively difficult to reach the block gas limit in `claimNRN` function as compared to `claimRewards` function, but still it's possible.\n\n### Proof of Concept\n\nFor `claimRewards` function, Add the below function in `MergingPool.t.sol`:\n\n<details>\n\n```solidity\nfunction testClaimRewardsDOS() public {\n    address user1 = vm.addr(1);\n    address user2 = vm.addr(2);\n    address user3 = vm.addr(3);\n\n    _mintFromMergingPool(user1);\n    _mintFromMergingPool(user2);\n    _mintFromMergingPool(user3);\n\n    uint offset = 35;\n    uint totalWin = 9;\n\n    uint256[] memory _winnersGeneral = new uint256[](2);\n    _winnersGeneral[0] = 0;\n    _winnersGeneral[1] = 1;\n\n    uint256[] memory _winnersUser = new uint256[](2);\n    _winnersUser[0] = 0;\n    _winnersUser[1] = 2;\n    for (uint i = 0; i < offset * totalWin; i++) {\n        if (i % offset == 0) {\n            _mergingPoolContract.pickWinner(_winnersUser);\n        } else {\n            _mergingPoolContract.pickWinner(_winnersGeneral);\n        }\n    }\n\n    string[] memory _modelURIs = new string[](totalWin);\n    string[] memory _modelTypes = new string[](totalWin);\n    uint256[2][] memory _customAttributes = new uint256[2][](totalWin);\n    for (uint i = 0; i < totalWin; i++) {\n        _modelURIs[\n            i\n        ] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        _modelTypes[i] = \"original\";\n        _customAttributes[i][0] = uint256(1);\n        _customAttributes[i][1] = uint256(80);\n    }\n    vm.prank(user3);\n    uint gasBefore = gasleft();\n    _mergingPoolContract.claimRewards(\n        _modelURIs,\n        _modelTypes,\n        _customAttributes\n    );\n    uint gasAfter = gasleft();\n    uint gasDiff = gasBefore - gasAfter;\n    emit log_uint(gasDiff);\n    uint256 numRewards = _mergingPoolContract.getUnclaimedRewards(user3);\n    assertEq(numRewards, 0);\n    assertGt(gasDiff, 4_000_000);\n}\n```\n</details>\n\nYou can run the test by:\n\n```bash\nforge test --mt testClaimRewardsDOS -vv\n```\n\nHere I had considered 3 users, user1, user2, and user3. After each `offset` rounds, I picked `user3` as a winner. There were total of 315 ( `offset` &ast; `totalWin` ) rounds passed and `user3` won in 9 of them. Then I tried to claim rewards for `user3` and it consumed more than 4M gas.\n\nAlso the more the round in which `user3` has won, the more gas it will consume. Even if `offset` is 1 and `totalWin` is 9 ( i.e total of 9 rounds out of which `user3` won in 9 of them ), it will consume more than 3.4M gas.\n\nAlso, we've considered only 2 winners per round, as the number of winners increases, the gas consumption will also increase due to the nested loop which loops through all the winners each round.\n\nSo if any user claim their rewards after many rounds has passed or if they have won in many rounds, it will consume a lot of gas and eventually leads to block gas limit.\n\nFor `claimNRN` function, Add the below function in `RankedBattle.t.sol`:\n\n<details>\n\n```solidity\nfunction testClaimNRNDoS() public {\n    _neuronContract.addSpender(address(_gameItemsContract));\n    _gameItemsContract.instantiateNeuronContract(address(_neuronContract));\n    _gameItemsContract.createGameItem(\n        \"Battery\",\n        \"https://ipfs.io/ipfs/\",\n        true,\n        true,\n        10_000,\n        1 * 10 ** 18,\n        type(uint16).max\n    );\n    _gameItemsContract.setAllowedBurningAddresses(\n        address(_voltageManagerContract)\n    );\n\n    address staker = vm.addr(3);\n    _mintFromMergingPool(staker);\n    vm.prank(_treasuryAddress);\n    _neuronContract.transfer(staker, 400_000 * 10 ** 18);\n    vm.prank(staker);\n    _rankedBattleContract.stakeNRN(30_000 * 10 ** 18, 0);\n    assertEq(_rankedBattleContract.amountStaked(0), 30_000 * 10 ** 18);\n\n    address claimee = vm.addr(4);\n    _mintFromMergingPool(claimee);\n    vm.prank(_treasuryAddress);\n    _neuronContract.transfer(claimee, 400_000 * 10 ** 18);\n    vm.prank(claimee);\n    _rankedBattleContract.stakeNRN(40_000 * 10 ** 18, 1);\n    assertEq(_rankedBattleContract.amountStaked(1), 40_000 * 10 ** 18);\n\n    uint offset = 35;\n    uint totalWin = 9;\n    for (uint i = 0; i < offset * totalWin; i++) {\n        // 0 win\n        // 1 tie\n        // 2 loss\n        if (i % offset == 0) {\n            uint256 currentVoltage = _voltageManagerContract.ownerVoltage(\n                claimee\n            );\n            if (currentVoltage < 100) {\n                vm.prank(claimee);\n                _gameItemsContract.mint(0, 1); //paying 1 $NRN for 1 batteries\n                vm.prank(claimee);\n                _voltageManagerContract.useVoltageBattery();\n            }\n\n            vm.prank(address(_GAME_SERVER_ADDRESS));\n            _rankedBattleContract.updateBattleRecord(1, 50, 0, 1500, true);\n        } else {\n            uint256 currentVoltage = _voltageManagerContract.ownerVoltage(\n                staker\n            );\n            if (currentVoltage < 100) {\n                vm.prank(staker);\n                _gameItemsContract.mint(0, 1); //paying 1 $NRN for 1 batteries\n                vm.prank(staker);\n                _voltageManagerContract.useVoltageBattery();\n            }\n\n            vm.prank(address(_GAME_SERVER_ADDRESS));\n            _rankedBattleContract.updateBattleRecord(0, 50, 0, 1500, true);\n        }\n        _rankedBattleContract.setNewRound();\n    }\n\n    uint256 gasBefore = gasleft();\n    vm.prank(claimee);\n    _rankedBattleContract.claimNRN();\n    uint256 gasAfter = gasleft();\n    uint256 gasDiff = gasBefore - gasAfter;\n    emit log_uint(gasDiff);\n    assertGt(gasDiff, 1_000_000);\n}\n```\n</details>\n\nYou can run the test by:\n\n```bash\nforge test --mt testClaimNRNDoS -vv\n```\n\nIn the case of `claimNRN` function, it consumed more than 1M gas which is relatively less as compared to `claimRewards` function. But still it has potential to reach block gas limit.\n\nEven for the users for whom these both functions doesn't reach block gas limit, it can be very expensive and difficult for them to claim their rewards if some rounds has passed.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nIt can be fixed by adding a parameter for the number of rounds to consider.\n\nFor `claimRewards` function, so the changes would look like:\n\n<details>\n\n```diff\nfunction claimRewards(\n    string[] calldata modelURIs,\n    string[] calldata modelTypes,\n-    uint256[2][] calldata customAttributes\n+    uint256[2][] calldata customAttributes,\n+    uint32 totalRoundsToConsider\n)\n    external\n{\n    uint256 winnersLength;\n    uint32 claimIndex = 0;\n    uint32 lowerBound = numRoundsClaimed[msg.sender];\n+    require(lowerBound + totalRoundsToConsider < roundId, \"MergingPool: totalRoundsToConsider exceeds the limit\");\n-    for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n+    for (uint32 currentRound = lowerBound; currentRound < lowerBound + totalRoundsToConsider; currentRound++) {\n        numRoundsClaimed[msg.sender] += 1;\n        winnersLength = winnerAddresses[currentRound].length;\n        for (uint32 j = 0; j < winnersLength; j++) {\n            if (msg.sender == winnerAddresses[currentRound][j]) {\n                _fighterFarmInstance.mintFromMergingPool(\n                    msg.sender,\n                    modelURIs[claimIndex],\n                    modelTypes[claimIndex],\n                    customAttributes[claimIndex]\n                );\n                claimIndex += 1;\n            }\n        }\n    }\n    if (claimIndex > 0) {\n        emit Claimed(msg.sender, claimIndex);\n    }\n}\n```\n</details>\n\nFor `claimNRN` function, so the changes would look like:\n\n<details>\n\n```diff\n- function claimNRN() external {\n+ function claimNRN(uint32 totalRoundsToConsider) external {\n    require(numRoundsClaimed[msg.sender] < roundId, \"Already claimed NRNs for this period\");\n    uint256 claimableNRN = 0;\n    uint256 nrnDistribution;\n    uint32 lowerBound = numRoundsClaimed[msg.sender];\n+    require(lowerBound + totalRoundsToConsider < roundId, \"RankedBattle: totalRoundsToConsider exceeds the limit\");\n-    for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n+    for (uint32 currentRound = lowerBound; currentRound < lowerBound + totalRoundsToConsider; currentRound++) {\n        nrnDistribution = getNrnDistribution(currentRound);\n        claimableNRN += (\n            accumulatedPointsPerAddress[msg.sender][currentRound] * nrnDistribution\n        ) / totalAccumulatedPoints[currentRound];\n        numRoundsClaimed[msg.sender] += 1;\n    }\n    if (claimableNRN > 0) {\n        amountClaimed[msg.sender] += claimableNRN;\n        _neuronInstance.mint(msg.sender, claimableNRN);\n        emit Claimed(msg.sender, claimableNRN);\n    }\n}\n```\n</details>\n\n**[brandinho (AI Arena) confirmed](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/868#issuecomment-2018276487)**\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/12\n\n**Status:** Mitigation confirmed. Full details in reports from [niser93](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/11), [fnanni](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/15), and [d3e4](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/49).\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-ai-arena",
  "Code": [
    {
      "filename": "src/MergingPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { FighterFarm } from \"./FighterFarm.sol\";\n\n/// @title MergingPool\n/// @author ArenaX Labs Inc.\n/// @notice This contract allows users to potentially earn a new fighter NFT.\ncontract MergingPool {\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when merging pool points are added.\n    event PointsAdded(uint256 tokenId, uint256 points);\n\n    /// @notice Event emitted when claimed.\n    event Claimed(address claimer, uint32 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of winners per period.\n    uint256 public winnersPerPeriod = 2;\n\n    /// @notice Current roundId.\n    uint256 public roundId = 0;\n\n    /// @notice Total points.\n    uint256 public totalPoints = 0;    \n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /// The address of the ranked battle contract.\n    address _rankedBattleAddress;\n\n    /// @dev The fighter farm contract instance.\n    FighterFarm _fighterFarmInstance;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maps the user address to the number of rounds they've claimed for\n    mapping(address => uint32) public numRoundsClaimed;\n\n    /// @notice Mapping of address to fighter points.\n    mapping(uint256 => uint256) public fighterPoints;\n\n    /// @notice Mapping of roundId to winner addresses list.\n    mapping(uint256 => address[]) public winnerAddresses;    \n\n    /// @notice Mapping of round id to an indication of whether winners have been selected yet.\n    mapping(uint256 => bool) public isSelectionComplete;\n\n    /// @notice Mapping of address to admin status.\n    mapping(address => bool) public isAdmin;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the address for the owner and ranked battle smart contract.\n    /// Instantiates the fighter farm contract and sets the owner to be an admin\n    /// @param ownerAddress Address of contract deployer.\n    /// @param rankedBattleAddress Address of ranked battle contract.\n    /// @param fighterFarmAddress Address of fighter farm contract.\n    constructor(\n        address ownerAddress, \n        address rankedBattleAddress, \n        address fighterFarmAddress\n    ) {\n        _ownerAddress = ownerAddress;\n        _rankedBattleAddress = rankedBattleAddress;\n        _fighterFarmInstance = FighterFarm(fighterFarmAddress);\n        isAdmin[_ownerAddress] = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Adjusts admin access for a user.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param adminAddress The address of the admin.\n    /// @param access Whether the address has admin access or not.\n    function adjustAdminAccess(address adminAddress, bool access) external {\n        require(msg.sender == _ownerAddress);\n        isAdmin[adminAddress] = access;\n    }   \n\n    /// @notice Change the number of winners per competition period.\n    /// @dev Only admins are authorized to call this function.\n    /// @param newWinnersPerPeriodAmount The new number of winners per period.\n    function updateWinnersPerPeriod(uint256 newWinnersPerPeriodAmount) external {\n        require(isAdmin[msg.sender]);\n        winnersPerPeriod = newWinnersPerPeriodAmount;\n    }    \n\n    /// @notice Allows the admin to pick the winners for the current round.\n    /// @dev Only admins are authorized to call this function.\n    /// @dev The number of winners must match the expected number of winners per period.\n    /// @dev The function will check that there are no existing winners for the current round.\n    /// @dev The function will update the winnerAddresses mapping with the addresses of the winners.\n    /// @dev The function will also reset the fighterPoints of the winners to zero.\n    /// @param winners The array of token IDs representing the winners.\n    function pickWinner(uint256[] calldata winners) external {\n        require(isAdmin[msg.sender]);\n        require(winners.length == winnersPerPeriod, \"Incorrect number of winners\");\n        require(!isSelectionComplete[roundId], \"Winners are already selected\");\n        uint256 winnersLength = winners.length;\n        address[] memory currentWinnerAddresses = new address[](winnersLength);\n        for (uint256 i = 0; i < winnersLength; i++) {\n            currentWinnerAddresses[i] = _fighterFarmInstance.ownerOf(winners[i]);\n            totalPoints -= fighterPoints[winners[i]];\n            fighterPoints[winners[i]] = 0;\n        }\n        winnerAddresses[roundId] = currentWinnerAddresses;\n        isSelectionComplete[roundId] = true;\n        roundId += 1;\n    }\n\n    /// @notice Allows the user to batch claim rewards for multiple rounds.\n    /// @dev The user can only claim rewards once for each round.\n    /// @param modelURIs The array of model URIs corresponding to each round and winner address.\n    /// @param modelTypes The array of model types corresponding to each round and winner address.\n    /// @param customAttributes Array with [element, weight] of the newly created fighter.\n    function claimRewards(\n        string[] calldata modelURIs, \n        string[] calldata modelTypes,\n        uint256[2][] calldata customAttributes\n    ) \n        external \n    {\n        uint256 winnersLength;\n        uint32 claimIndex = 0;\n        uint32 lowerBound = numRoundsClaimed[msg.sender];\n        for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n            numRoundsClaimed[msg.sender] += 1;\n            winnersLength = winnerAddresses[currentRound].length;\n            for (uint32 j = 0; j < winnersLength; j++) {\n                if (msg.sender == winnerAddresses[currentRound][j]) {\n                    _fighterFarmInstance.mintFromMergingPool(\n                        msg.sender,\n                        modelURIs[claimIndex],\n                        modelTypes[claimIndex],\n                        customAttributes[claimIndex]\n                    );\n                    claimIndex += 1;\n                }\n            }\n        }\n        if (claimIndex > 0) {\n            emit Claimed(msg.sender, claimIndex);\n        }\n    }\n\n    /// @notice Gets the unclaimed rewards for a specific address.\n    /// @param claimer The address of the claimer.\n    /// @return numRewards The amount of unclaimed fighters.\n    function getUnclaimedRewards(address claimer) external view returns(uint256) {\n        uint256 winnersLength;\n        uint256 numRewards = 0;\n        uint32 lowerBound = numRoundsClaimed[claimer];\n        for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n            winnersLength = winnerAddresses[currentRound].length;\n            for (uint32 j = 0; j < winnersLength; j++) {\n                if (claimer == winnerAddresses[currentRound][j]) {\n                    numRewards += 1;\n                }\n            }\n        }\n        return numRewards;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/    \n\n    /// @notice Add merging pool points to a fighter.\n    /// @dev Only the rankedBattle contract address can call this function.\n    /// @param tokenId The ID of the fighter token.\n    /// @param points The number of points to be added to the fighter.\n    function addPoints(uint256 tokenId, uint256 points) public {\n        require(msg.sender == _rankedBattleAddress, \"Not Ranked Battle contract address\");\n        fighterPoints[tokenId] += points;\n        totalPoints += points;\n        emit PointsAdded(tokenId, points);\n    }\n\n    /// @notice Retrieves the points for multiple fighters up to the specified maximum token ID.\n    /// @param maxId The maximum token ID up to which the points will be retrieved.\n    /// @return An array of points corresponding to the fighters' token IDs.\n    function getFighterPoints(uint256 maxId) public view returns(uint256[] memory) {\n        uint256[] memory points = new uint256[](1);\n        for (uint256 i = 0; i < maxId; i++) {\n            points[i] = fighterPoints[i];\n        }\n        return points;\n    }\n}"
    },
    {
      "filename": "src/RankedBattle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { FighterFarm } from \"./FighterFarm.sol\";\nimport { VoltageManager } from \"./VoltageManager.sol\";\nimport { MergingPool } from \"./MergingPool.sol\";\nimport { Neuron } from \"./Neuron.sol\";\nimport { StakeAtRisk } from \"./StakeAtRisk.sol\";\nimport { FixedPointMathLib } from './FixedPointMathLib.sol';\n\n/// @title RankedBattle\n/// @author ArenaX Labs Inc.\n/// @notice This contract provides functionality for staking NRN tokens on fighters, \n/// tracking battle records, calculating and distributing rewards based on battle outcomes \n/// and staked amounts, and allowing claiming of accumulated rewards.\ncontract RankedBattle {\n\n    /// @dev Extend functionality of the FixedPointMathLib library to the uint data type.\n    using FixedPointMathLib for uint;\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when staked.\n    event Staked(address from, uint256 amount);\n\n    /// @notice Event emitted when unstaked.\n    event Unstaked(address from, uint256 amount);\n\n    /// @notice Event emitted when claimed.\n    event Claimed(address claimer, uint256 amount);\n\n    /// @notice Event emitted when points are added or subtracted from a fighter.\n    event PointsChanged(uint256 tokenId, uint256 points, bool increased);    \n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct for battle record.\n    struct BattleRecord {\n        uint32 wins;\n        uint32 ties;\n        uint32 loses;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Voltage cost per match initiated\n    uint8 public constant VOLTAGE_COST = 10;\n\n    /// @notice Number of total battles.\n    uint256 public totalBattles = 0;\n\n    /// @notice Number of overall staked amount.\n    uint256 public globalStakedAmount = 0;\n\n    /// @notice Current round number.\n    uint256 public roundId = 0;\n\n    /// @notice Amount of basis points that get taken away from a player's stake when they lose in \n    /// a point deficit.\n    uint256 public bpsLostPerLoss = 10;\n\n    /// The StakeAtRisk contract address.\n    address _stakeAtRiskAddress;\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /// @notice The address in charge of updating battle records.\n    address _gameServerAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                            CONTRACT INSTANCES\n    //////////////////////////////////////////////////////////////*/ \n\n    /// @notice The neuron contract instance.\n    Neuron _neuronInstance;\n\n    /// @notice The fighter farm contract instance.\n    FighterFarm _fighterFarmInstance;\n\n    /// @notice The voltage manager contract instance.\n    VoltageManager _voltageManagerInstance;\n\n    /// @notice The merging pool contract instance.\n    MergingPool _mergingPoolInstance;\n\n    /// @notice The stake at risk contract instance.\n    StakeAtRisk _stakeAtRiskInstance;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maps addresses that are admins.\n    mapping(address => bool) public isAdmin;\n\n    /// @notice Mapping of token id to battle record struct.\n    mapping(uint256 => BattleRecord) public fighterBattleRecord;\n\n    /// @notice Mapping of address to the amount of NRNs they have claimed.\n    mapping(address => uint256) public amountClaimed;\n\n    /// @notice Maps the user address to the number of rounds they've claimed for\n    mapping(address => uint32) public numRoundsClaimed;\n\n    /// @notice Maps address to round ID to track accumulated points.\n    mapping(address => mapping(uint256 => uint256)) public accumulatedPointsPerAddress;\n\n    /// @notice Maps token ID to round ID to track accumulated points.\n    mapping(uint256 => mapping(uint256 => uint256)) public accumulatedPointsPerFighter;\n\n    /// @notice Maps round ID to total accumulated points.\n    mapping(uint256 => uint256) public totalAccumulatedPoints;\n\n    /// @notice Mapping of roundID to nrn distribution amount for a ranked period.\n    mapping(uint256 => uint256) public rankedNrnDistribution;\n\n    /// @notice Maps the token ID to the round ID and indicates whether it is Unstaked or not.\n    mapping(uint256 => mapping(uint256 => bool)) public hasUnstaked;\n\n    /// @notice Mapping of token id to staked amount.\n    mapping(uint256 => uint256) public amountStaked;\n\n    /// @notice Mapping of token id to staking factor.\n    mapping(uint256 => uint256) public stakingFactor;\n\n    /// @notice Indicates whether we have calculated the staking factor for a given round and token.\n    mapping(uint256 => mapping(uint256 => bool)) _calculatedStakingFactor;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract by setting various addresses and instantiating \n    /// contract instances. It also designates the owner address as an admin. \n    /// @param ownerAddress Address of contract deployer.\n    /// @param gameServerAddress The game server address.\n    /// @param fighterFarmAddress Address of the FighterFarm contract.\n    /// @param voltageManagerAddress Address of the VoltageManager contract.\n    constructor(\n      address ownerAddress, \n      address gameServerAddress,\n      address fighterFarmAddress,\n      address voltageManagerAddress\n    ) {\n        _ownerAddress = ownerAddress;\n        _gameServerAddress = gameServerAddress;\n        _fighterFarmInstance = FighterFarm(fighterFarmAddress);\n        _voltageManagerInstance = VoltageManager(voltageManagerAddress);\n        isAdmin[_ownerAddress] = true;\n        rankedNrnDistribution[0] = 5000 * 10**18;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Adjusts admin access for a user.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param adminAddress The address of the admin.\n    /// @param access Whether the address has admin access or not.\n    function adjustAdminAccess(address adminAddress, bool access) external {\n        require(msg.sender == _ownerAddress);\n        isAdmin[adminAddress] = access;\n    }  \n\n    /// @notice Sets the game server address.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param gameServerAddress The game server address.\n    function setGameServerAddress(address gameServerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _gameServerAddress = gameServerAddress;\n    }\n\n    /// @notice Sets the Stake at Risk contract address and instantiates the contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param stakeAtRiskAddress The address of the Stake At Risk contract.\n    function setStakeAtRiskAddress(address stakeAtRiskAddress) external {\n        require(msg.sender == _ownerAddress);\n        _stakeAtRiskAddress = stakeAtRiskAddress;\n        _stakeAtRiskInstance = StakeAtRisk(_stakeAtRiskAddress);\n    }\n\n    /// @notice Instantiates the neuron contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param nrnAddress The address of the Neuron contract.\n    function instantiateNeuronContract(address nrnAddress) external {\n        require(msg.sender == _ownerAddress);\n        _neuronInstance = Neuron(nrnAddress);\n    }\n\n    /// @notice Instantiates the merging pool contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param mergingPoolAddress The address of the MergingPool contract.\n    function instantiateMergingPoolContract(address mergingPoolAddress) external {\n        require(msg.sender == _ownerAddress);\n        _mergingPoolInstance = MergingPool(mergingPoolAddress);\n    }\n\n    /// @notice Sets the ranked nrn distribution amount for the current round.\n    /// @dev Only admins are authorized to change the ranked NRN distribution.\n    /// @dev newDistribution is NOT denominated in wei. As such, it is multiplied by 10**18.\n    /// @param newDistribution The new distribution amount.\n    function setRankedNrnDistribution(uint256 newDistribution) external {\n        require(isAdmin[msg.sender]);\n        rankedNrnDistribution[roundId] = newDistribution * 10**18;\n    }\n\n    /// @notice Sets the basis points lost per ranked match lost while in a point deficit.\n    /// @dev Only admins are authorized to call this function.\n    /// @param bpsLostPerLoss_ The basis points lost per loss.\n    function setBpsLostPerLoss(uint256 bpsLostPerLoss_) external {\n        require(isAdmin[msg.sender]);\n        bpsLostPerLoss = bpsLostPerLoss_;\n    }\n\n    /// @notice Sets a new round, making claiming available for that round.\n    /// @dev Only admins are authorized to move the round forward.\n    function setNewRound() external {\n        require(isAdmin[msg.sender]);\n        require(totalAccumulatedPoints[roundId] > 0);\n        roundId += 1;\n        _stakeAtRiskInstance.setNewRound(roundId);\n        rankedNrnDistribution[roundId] = rankedNrnDistribution[roundId - 1];\n    }\n\n    /// @notice Stakes NRN tokens.\n    /// @param amount The amount of NRN tokens to stake.\n    /// @param tokenId The ID of the fighter to stake.\n    function stakeNRN(uint256 amount, uint256 tokenId) external {\n        require(amount > 0, \"Amount cannot be 0\");\n        require(_fighterFarmInstance.ownerOf(tokenId) == msg.sender, \"Caller does not own fighter\");\n        require(_neuronInstance.balanceOf(msg.sender) >= amount, \"Stake amount exceeds balance\");\n        require(hasUnstaked[tokenId][roundId] == false, \"Cannot add stake after unstaking this round\");\n\n        _neuronInstance.approveStaker(msg.sender, address(this), amount);\n        bool success = _neuronInstance.transferFrom(msg.sender, address(this), amount);\n        if (success) {\n            if (amountStaked[tokenId] == 0) {\n                _fighterFarmInstance.updateFighterStaking(tokenId, true);\n            }\n            amountStaked[tokenId] += amount;\n            globalStakedAmount += amount;\n            stakingFactor[tokenId] = _getStakingFactor(\n                tokenId, \n                _stakeAtRiskInstance.getStakeAtRisk(tokenId)\n            );\n            _calculatedStakingFactor[tokenId][roundId] = true;\n            emit Staked(msg.sender, amount);\n        }\n    }\n\n    /// @notice Unstakes NRN tokens.\n    /// @param amount The amount of NRN tokens to unstake.\n    /// @param tokenId The ID of the token to unstake.\n    function unstakeNRN(uint256 amount, uint256 tokenId) external {\n        require(_fighterFarmInstance.ownerOf(tokenId) == msg.sender, \"Caller does not own fighter\");\n        if (amount > amountStaked[tokenId]) {\n            amount = amountStaked[tokenId];\n        }\n        amountStaked[tokenId] -= amount;\n        globalStakedAmount -= amount;\n        stakingFactor[tokenId] = _getStakingFactor(\n            tokenId, \n            _stakeAtRiskInstance.getStakeAtRisk(tokenId)\n        );\n        _calculatedStakingFactor[tokenId][roundId] = true;\n        hasUnstaked[tokenId][roundId] = true;\n        bool success = _neuronInstance.transfer(msg.sender, amount);\n        if (success) {\n            if (amountStaked[tokenId] == 0) {\n                _fighterFarmInstance.updateFighterStaking(tokenId, false);\n            }\n            emit Unstaked(msg.sender, amount);\n        }\n    }\n\n    /// @notice Claims NRN tokens for the specified rounds.\n    /// @dev Caller can only claim once per round.\n    function claimNRN() external {\n        require(numRoundsClaimed[msg.sender] < roundId, \"Already claimed NRNs for this period\");\n        uint256 claimableNRN = 0;\n        uint256 nrnDistribution;\n        uint32 lowerBound = numRoundsClaimed[msg.sender];\n        for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n            nrnDistribution = getNrnDistribution(currentRound);\n            claimableNRN += (\n                accumulatedPointsPerAddress[msg.sender][currentRound] * nrnDistribution   \n            ) / totalAccumulatedPoints[currentRound];\n            numRoundsClaimed[msg.sender] += 1;\n        }\n        if (claimableNRN > 0) {\n            amountClaimed[msg.sender] += claimableNRN;\n            _neuronInstance.mint(msg.sender, claimableNRN);\n            emit Claimed(msg.sender, claimableNRN);\n        }\n    }\n\n    /// @notice Updates the battle record for a fighter.\n    /// @dev Only the game server address is authorized to update the battle record.\n    /// @dev Only the fighter that initiates the battle expends voltage on the match.\n    /// @dev Only fighters that have NRN staked are able to earn points.\n    /// @param tokenId The ID of the fighter.\n    /// @param mergingPortion The portion of points that get redirected to the merging pool.\n    /// @param battleResult The result of the battle.\n    /// @param eloFactor Multiple derived from ELO to be applied to the base points earned.\n    /// @param initiatorBool Whether this was the fighter that initiated the battle or not\n    function updateBattleRecord(\n        uint256 tokenId, \n        uint256 mergingPortion,\n        uint8 battleResult,\n        uint256 eloFactor,\n        bool initiatorBool\n    ) \n        external \n    {   \n        require(msg.sender == _gameServerAddress);\n        require(mergingPortion <= 100);\n        address fighterOwner = _fighterFarmInstance.ownerOf(tokenId);\n        require(\n            !initiatorBool ||\n            _voltageManagerInstance.ownerVoltageReplenishTime(fighterOwner) <= block.timestamp || \n            _voltageManagerInstance.ownerVoltage(fighterOwner) >= VOLTAGE_COST\n        );\n\n        _updateRecord(tokenId, battleResult);\n        uint256 stakeAtRisk = _stakeAtRiskInstance.getStakeAtRisk(tokenId);\n        if (amountStaked[tokenId] + stakeAtRisk > 0) {\n            _addResultPoints(battleResult, tokenId, eloFactor, mergingPortion, fighterOwner);\n        }\n        if (initiatorBool) {\n            _voltageManagerInstance.spendVoltage(fighterOwner, VOLTAGE_COST);\n        }\n        totalBattles += 1;\n    }\n\n    /// @notice Gets the battle record for a token.\n    /// @param tokenId The ID of the token.\n    /// @return Record which is comprised of wins, ties, and losses for the token.\n    function getBattleRecord(uint256 tokenId) external view returns(uint32, uint32, uint32) {\n      return (\n          fighterBattleRecord[tokenId].wins, \n          fighterBattleRecord[tokenId].ties, \n          fighterBattleRecord[tokenId].loses\n      );\n    }\n\n    /// @notice Gets the staking data for a token.\n    /// @return Round id, nrns to be distributed, and total point tally\n    function getCurrentStakingData() external view returns(uint256, uint256, uint256) {\n      return (\n          roundId,\n          rankedNrnDistribution[roundId], \n          totalAccumulatedPoints[roundId]\n      );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/    \n\n    /// @notice Retrieves the nrn distribution amount for the given round ID.\n    /// @param roundId_ The round ID for which to get the nrn distribution.\n    /// @return Distribution amount for the specified round ID.\n    function getNrnDistribution(uint256 roundId_) public view returns(uint256) {\n        return rankedNrnDistribution[roundId_];\n    }\n\n    /// @notice Gets the unclaimed NRN tokens for a specific address.\n    /// @param claimer The address of the claimer.\n    /// @return The amount of unclaimed NRN tokens.\n    function getUnclaimedNRN(address claimer) public view returns(uint256) {\n        uint256 claimableNRN = 0;\n        uint256 nrnDistribution;   \n        uint32 lowerBound = numRoundsClaimed[claimer];\n        for (uint32 i = lowerBound; i < roundId; i++) {\n            nrnDistribution = getNrnDistribution(i);\n            claimableNRN += (\n                accumulatedPointsPerAddress[claimer][i] * nrnDistribution\n            ) / totalAccumulatedPoints[i];\n        }\n        return claimableNRN;\n    } \n\n    /*//////////////////////////////////////////////////////////////\n                            PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Adds result points for a battle, based on the battle result, ELO factor, and merging portion.\n    /// @dev This function is called internally and is not accessible externally.\n    /// @dev There are 5 scenarios to be aware of:\n    /// @dev 1) Win + no stake-at-risk = Increase points balance\n    /// @dev 2) Win + stake-at-risk = Reclaim some of the stake that is at risk\n    /// @dev 3) Lose + positive point balance = Deduct from the point balance\n    /// @dev 4) Lose + no points = Move some of their NRN staked to the Stake At Risk contract\n    /// @dev 5) Tie = no consequence\n    /// @param battleResult The result of the battle (0: win, 1: tie, 2: loss).\n    /// @param tokenId The ID of the token participating in the battle.\n    /// @param eloFactor Multiple derived from ELO to be applied to the base points earned.\n    /// @param mergingPortion The portion of points that get redirected to the merging pool.\n    /// @param fighterOwner The address which owns the fighter whos points are being altered.\n    function _addResultPoints(\n        uint8 battleResult, \n        uint256 tokenId, \n        uint256 eloFactor, \n        uint256 mergingPortion,\n        address fighterOwner\n    ) \n        private \n    {\n        uint256 stakeAtRisk;\n        uint256 curStakeAtRisk;\n        uint256 points = 0;\n\n        /// Check how many NRNs the fighter has at risk\n        stakeAtRisk = _stakeAtRiskInstance.getStakeAtRisk(tokenId);\n\n        /// Calculate the staking factor if it has not already been calculated for this round \n        if (_calculatedStakingFactor[tokenId][roundId] == false) {\n            stakingFactor[tokenId] = _getStakingFactor(tokenId, stakeAtRisk);\n            _calculatedStakingFactor[tokenId][roundId] = true;\n        }\n\n        /// Potential amount of NRNs to put at risk or retrieve from the stake-at-risk contract\n        curStakeAtRisk = (bpsLostPerLoss * (amountStaked[tokenId] + stakeAtRisk)) / 10**4;\n        if (battleResult == 0) {\n            /// If the user won the match\n\n            /// If the user has no NRNs at risk, then they can earn points\n            if (stakeAtRisk == 0) {\n                points = stakingFactor[tokenId] * eloFactor;\n            }\n\n            /// Divert a portion of the points to the merging pool\n            uint256 mergingPoints = (points * mergingPortion) / 100;\n            points -= mergingPoints;\n            _mergingPoolInstance.addPoints(tokenId, mergingPoints);\n\n            /// Do not allow users to reclaim more NRNs than they have at risk\n            if (curStakeAtRisk > stakeAtRisk) {\n                curStakeAtRisk = stakeAtRisk;\n            }\n\n            /// If the user has stake-at-risk for their fighter, reclaim a portion\n            /// Reclaiming stake-at-risk puts the NRN back into their staking pool\n            if (curStakeAtRisk > 0) {\n                _stakeAtRiskInstance.reclaimNRN(curStakeAtRisk, tokenId, fighterOwner);\n                amountStaked[tokenId] += curStakeAtRisk;\n            }\n\n            /// Add points to the fighter for this round\n            accumulatedPointsPerFighter[tokenId][roundId] += points;\n            accumulatedPointsPerAddress[fighterOwner][roundId] += points;\n            totalAccumulatedPoints[roundId] += points;\n            if (points > 0) {\n                emit PointsChanged(tokenId, points, true);\n            }\n        } else if (battleResult == 2) {\n            /// If the user lost the match\n\n            /// Do not allow users to lose more NRNs than they have in their staking pool\n            if (curStakeAtRisk > amountStaked[tokenId]) {\n                curStakeAtRisk = amountStaked[tokenId];\n            }\n            if (accumulatedPointsPerFighter[tokenId][roundId] > 0) {\n                /// If the fighter has a positive point balance for this round, deduct points \n                points = stakingFactor[tokenId] * eloFactor;\n                if (points > accumulatedPointsPerFighter[tokenId][roundId]) {\n                    points = accumulatedPointsPerFighter[tokenId][roundId];\n                }\n                accumulatedPointsPerFighter[tokenId][roundId] -= points;\n                accumulatedPointsPerAddress[fighterOwner][roundId] -= points;\n                totalAccumulatedPoints[roundId] -= points;\n                if (points > 0) {\n                    emit PointsChanged(tokenId, points, false);\n                }\n            } else {\n                /// If the fighter does not have any points for this round, NRNs become at risk of being lost\n                bool success = _neuronInstance.transfer(_stakeAtRiskAddress, curStakeAtRisk);\n                if (success) {\n                    _stakeAtRiskInstance.updateAtRiskRecords(curStakeAtRisk, tokenId, fighterOwner);\n                    amountStaked[tokenId] -= curStakeAtRisk;\n                }\n            }\n        }\n    }\n\n    /// @notice Updates the battle record for a token.\n    /// @param tokenId The ID of the token.\n    /// @param battleResult The result of the battle.\n    function _updateRecord(uint256 tokenId, uint8 battleResult) private {\n        if (battleResult == 0) {\n            fighterBattleRecord[tokenId].wins += 1;\n        } else if (battleResult == 1) {\n            fighterBattleRecord[tokenId].ties += 1;\n        } else if (battleResult == 2) {\n            fighterBattleRecord[tokenId].loses += 1;\n        }\n    }\n\n    /// @notice Gets the staking factor for a token.\n    /// @param tokenId The ID of the token.\n    /// @param stakeAtRisk The amount of stake they have at risk.\n    /// @return Staking factor.\n    function _getStakingFactor(\n        uint256 tokenId, \n        uint256 stakeAtRisk\n    ) \n        private \n        view \n        returns (uint256) \n    {\n      uint256 stakingFactor_ = FixedPointMathLib.sqrt(\n          (amountStaked[tokenId] + stakeAtRisk) / 10**18\n      );\n      if (stakingFactor_ == 0) {\n        stakingFactor_ = 1;\n      }\n      return stakingFactor_;\n    }    \n}"
    }
  ]
}