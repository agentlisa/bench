{
  "Title": "[M-30] `AirdropBroker`: When `block.timestamp == lastEpochUpdate + EPOCH_DURATION`, users can exercise options in the new epoch.",
  "Content": "\nIn AirdropBroker, when a user receives an airdrop, it should only be able to exercise the options in the current epoch.\n\n```solidity\n    function _participatePhase1() internal returns (uint256 oTAPTokenID) {\n        uint256 _eligibleAmount = phase1Users[msg.sender];\n        if (_eligibleAmount == 0) revert NotEligible();\n\n        // Close eligibility\n        phase1Users[msg.sender] = 0;\n\n        // Mint aoTAP\n        uint128 expiry = uint128(lastEpochUpdate + EPOCH_DURATION); // Set expiry to the end of the epoch\n        oTAPTokenID = aoTAP.mint(msg.sender, expiry, uint128(PHASE_1_DISCOUNT), _eligibleAmount);\n    }\n...\n    function exerciseOption(uint256 _aoTAPTokenID, ERC20 _paymentToken, uint256 _tapAmount)\n        external\n        whenNotPaused\n        tapExists\n    {\n        // Load data\n        (, AirdropTapOption memory aoTapOption) = aoTAP.attributes(_aoTAPTokenID);\n        if (aoTapOption.expiry < block.timestamp) revert OptionExpired();\n```\n\nFor example, Alice received the airdrop for epoch 1, then Alice can participate in epoch 1 and exercise the options in epoch 1. When Alice exercises her option, the `TAP` price is determined at the beginning of epoch 1.\n\nThe problem here is that when `block.timestamp == lastEpochUpdate + EPOCH_DURATION`, `newEpoch()` can be called to enter epoch 2, and `exerciseOption()` can also be called to exercise the option of epoch 1. This allows the user to exercise the epoch 1 option at the epoch 2 `TAP` price.\n\n```solidity\n    function newEpoch() external tapExists {\n        if (block.timestamp < lastEpochUpdate + EPOCH_DURATION) {\n            revert TooSoon();\n        }\n...\n    function exerciseOption(uint256 _aoTAPTokenID, ERC20 _paymentToken, uint256 _tapAmount)\n        external\n        whenNotPaused\n        tapExists\n    {\n        // Load data\n        (, AirdropTapOption memory aoTapOption) = aoTAP.attributes(_aoTAPTokenID);\n        if (aoTapOption.expiry < block.timestamp) revert OptionExpired();\n```\n\nConsider the following scenario, Alice receives a 1000 options airdrop for epoch 1.\n\nEpoch 1 starts, `lastEpochUpdate = day 0`, `TAP` price is 5 USD, and `TAP` price is in a downward trend. If Alice exercises the option in epoch 1, she needs to pay `5000 * 0.5 = 2500` USD.\n\nHowever, when `block.timestamp == lastEpochUpdate + EPOCH_DURATION`, the current `TAP` price is 2 USD, Alice can call `newEpoch()` and `exerciseOption()` in one transaction, Alice will exercise the option at the price of epoch 2, and only needs to pay 1000 USD to get 1000 `TAP`.\n\n### Proof of Concept\n\n<https://github.com/Tapioca-DAO/tap-token//blob/20a83b1d2d5577653610a6c3879dff9df4968345/contracts/option-airdrop/AirdropBroker.sol#L226-L233>\n\n<https://github.com/Tapioca-DAO/tap-token//blob/20a83b1d2d5577653610a6c3879dff9df4968345/contracts/option-airdrop/AirdropBroker.sol#L264-L267>\n\n### Recommended Mitigation Steps\n\nIt is recommended that exercise is not allowed when `block.timestamp == lastEpochUpdate + EPOCH_DURATION`.\n\n```diff\n    function exerciseOption(uint256 _aoTAPTokenID, ERC20 _paymentToken, uint256 _tapAmount)\n        external\n        whenNotPaused\n        tapExists\n    {\n        // Load data\n        (, AirdropTapOption memory aoTapOption) = aoTAP.attributes(_aoTAPTokenID);\n-       if (aoTapOption.expiry < block.timestamp) revert OptionExpired();\n+       if (aoTapOption.expiry <= block.timestamp) revert OptionExpired();\n```\n\n### Assessed type\n\nContext\n\n**[0xRektora (Tapioca) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/20#issuecomment-2016904401):**\n > it's a good catch, however this is `informational`. Probability of this happening are very low. The epoch is called with an only owner function, so it can't be done within the same Tx, as for the same block, since this happens on Arbitrum with the fair sequencing and low latency, the chances are close to 0.\n> On top of the incentives are extremely low for the effort being made.\n\n\n**[LSDan (judge) decreased severity to Low](https://github.com/code-423n4/2024-02-tapioca-findings/issues/20#issuecomment-2033055868)**\n\n**[cryptotechmaker (Tapioca) commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/20#issuecomment-2039322466):**\n > PR [here](https://github.com/Tapioca-DAO/tap-token/pull/181).\n\n\n**[cccz (warden) commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/20#issuecomment-2047785922):**\n > @0xRektora - I disagree. `newEpoch()` doesn't have any modifiers like `onlyOwner`, i.e. `newEpoch()` can be called by anyone and immediately follow the `exerciseOption()` call.\n >\n> ```solidity\n>     function newEpoch() external tapExists {\n>         if (block.timestamp < lastEpochUpdate + EPOCH_DURATION) {\n>             revert TooSoon();\n>         }\n> \n>         // Update epoch info\n>         lastEpochUpdate = uint64(block.timestamp);\n>         epoch++;\n> \n>         // At epoch 4, change the epoch duration to 7 days\n>         if (epoch == 4) {\n>             EPOCH_DURATION = 7 days;\n>         }\n> \n>         // Get epoch TAP valuation\n>         (bool success, uint256 _epochTAPValuation) = tapOracle.get(tapOracleData);\n>         if (!success) revert Failed();\n>         epochTAPValuation = uint128(_epochTAPValuation);\n>         emit NewEpoch(epoch, epochTAPValuation);\n>     }\n> ```\n>\n> As POC said, it's highly profitable for attackers.\n\n**[LSDan (Judge) increased severity to Medium and commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/20#issuecomment-2051720467):**\n > On review, I agree with @cccz on the impact an profitability here, due to the lack of `onlyOwner` on the `newEpoch` function.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/option-airdrop/AirdropBroker.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IPearlmit, PearlmitHandler} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {TWAML, FullMath} from \"tap-token/options/twAML.sol\"; // TODO Naming\nimport {TapToken} from \"tap-token/tokens/TapToken.sol\";\nimport {AOTAP, AirdropTapOption} from \"./aoTAP.sol\";\n\n/*\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n*/\n\nstruct PaymentTokenOracle {\n    ITapiocaOracle oracle;\n    bytes oracleData;\n}\n\nstruct Phase2Info {\n    uint8[4] amountsPerUsers;\n    uint8[4] discountsPerUsers;\n}\n\n/**\n * @notice More details found here https://docs.tapioca.xyz/tapioca/launch/option-airdrop\n */\ncontract AirdropBroker is Pausable, Ownable, PearlmitHandler, FullMath, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    bytes public tapOracleData;\n    ITapiocaOracle public tapOracle;\n    TapToken public tapToken;\n    AOTAP public immutable aoTAP;\n    IERC721 public immutable PCNFT;\n\n    uint128 public epochTAPValuation; // TAP price for the current epoch\n    uint64 public lastEpochUpdate; // timestamp of the last epoch update\n    uint64 public epoch; // Represents the number of weeks since the start of the contract\n\n    mapping(ERC20 => PaymentTokenOracle) public paymentTokens; // Token address => PaymentTokenOracle\n    address public paymentTokenBeneficiary; // Where to collect the payment tokens\n\n    mapping(uint256 => mapping(uint256 => uint256)) public aoTAPCalls; // oTAPTokenID => epoch => amountExercised\n\n    /// @notice Record of participation in phase 2 airdrop\n    /// Only applicable for phase 2. To get subphases on phase 2 we do userParticipation[_user][20+roles]\n    mapping(address => mapping(uint256 => bool)) public userParticipation; // user address => phase => participated\n\n    /// =====-------======\n    ///      Phase 1\n    /// =====-------======\n\n    /// @notice user address => eligible TAP amount, 0 means no eligibility\n    mapping(address => uint256) public phase1Users;\n    uint256 public constant PHASE_1_DISCOUNT = 500_000; //50 * 1e4; 50%\n\n    /// =====-------======\n    ///      Phase 2\n    /// =====-------======\n\n    // [OG Pearls, Tapiocans, Oysters, Cassava]\n    bytes32[4] public phase2MerkleRoots; // merkle root of phase 2 airdrop\n    uint8[4] public PHASE_2_AMOUNT_PER_USER = [200, 200, 190, 190];\n    uint24[4] public PHASE_2_DISCOUNT_PER_USER = [500_000, 400_000, 330_000, 250_000];\n\n    /// =====-------======\n    ///      Phase 3\n    /// =====-------======\n\n    uint256 public constant PHASE_3_AMOUNT_PER_USER = 714;\n    uint256 public constant PHASE_3_DISCOUNT = 500_000; //50 * 1e4; 50%\n\n    /// =====-------======\n    ///      Phase 4\n    /// =====-------======\n\n    /// @notice user address => eligible TAP amount, 0 means no eligibility\n    mapping(address => uint256) public phase4Users;\n    uint256 public constant PHASE_4_DISCOUNT = 330_000; //33 * 1e4;\n\n    uint256 public EPOCH_DURATION = 2 days; // Becomes 7 days at the start of the phase 4\n    uint256 public constant LAST_EPOCH = 8; // 8 epochs, 41 days long\n\n    /// =====-------======\n\n    error PaymentTokenNotValid();\n    error OptionExpired();\n    error TooHigh();\n    error TooLow();\n    error NotStarted();\n    error Ended();\n    error NotAuthorized();\n    error TooSoon();\n    error Failed();\n    error NotValid();\n    error TokenBeneficiaryNotSet();\n    error NotEligible();\n    error AlreadyParticipated();\n    error PaymentAmountNotValid();\n    error TapAmountNotValid();\n    error PaymentTokenValuationNotValid();\n    error TapNotSet();\n    error TapOracleNotSet();\n\n    constructor(address _aoTAP, address _pcnft, address _paymentTokenBeneficiary, IPearlmit _pearlmit, address _owner)\n        PearlmitHandler(_pearlmit)\n    {\n        paymentTokenBeneficiary = _paymentTokenBeneficiary;\n        aoTAP = AOTAP(_aoTAP);\n        PCNFT = IERC721(_pcnft);\n\n        _transferOwnership(_owner);\n    }\n\n    // ==========\n    //   EVENTS\n    // ==========\n    event Participate(uint256 indexed epoch, uint256 aoTAPTokenID);\n    event ExerciseOption(\n        uint256 indexed epoch, address indexed to, ERC20 indexed paymentToken, uint256 aoTapTokenID, uint256 amount\n    );\n    event NewEpoch(uint256 indexed epoch, uint256 epochTAPValuation);\n    event SetPaymentToken(ERC20 paymentToken, ITapiocaOracle oracle, bytes oracleData);\n    event SetTapOracle(ITapiocaOracle oracle, bytes oracleData);\n    event Phase2MerkleRootsUpdated();\n\n    modifier tapExists() {\n        if (address(tapOracle) == address(0)) revert TapOracleNotSet();\n        if (address(tapToken) == address(0)) revert TapNotSet();\n        _;\n    }\n\n    // ==========\n    //    READ\n    // ==========\n\n    /// @notice Returns the details of an OTC deal for a given oTAP token ID and a payment token.\n    ///         The oracle uses the last peeked value, and not the latest one, so the payment amount may be different.\n    /// @param _aoTAPTokenID The aoTAP token ID\n    /// @param _paymentToken The payment token\n    /// @param _tapAmount The amount of TAP to be exchanged. If 0 it will use the full amount of TAP eligible for the deal\n    /// @return eligibleTapAmount The amount of TAP eligible for the deal\n    /// @return paymentTokenAmount The amount of payment tokens required for the deal\n    /// @return tapAmount The amount of TAP to be exchanged\n\n    function getOTCDealDetails(uint256 _aoTAPTokenID, ERC20 _paymentToken, uint256 _tapAmount)\n        external\n        view\n        tapExists\n        returns (uint256 eligibleTapAmount, uint256 paymentTokenAmount, uint256 tapAmount)\n    {\n        // Load data\n        (, AirdropTapOption memory aoTapOption) = aoTAP.attributes(_aoTAPTokenID);\n        if (aoTapOption.expiry < block.timestamp) revert OptionExpired();\n\n        uint256 cachedEpoch = epoch;\n\n        PaymentTokenOracle memory paymentTokenOracle = paymentTokens[_paymentToken];\n\n        // Check requirements\n        if (paymentTokenOracle.oracle == ITapiocaOracle(address(0))) {\n            revert PaymentTokenNotValid();\n        }\n\n        eligibleTapAmount = aoTapOption.amount;\n        eligibleTapAmount -= aoTAPCalls[_aoTAPTokenID][cachedEpoch]; // Subtract already exercised amount\n        if (eligibleTapAmount < _tapAmount) revert TooHigh();\n\n        tapAmount = _tapAmount == 0 ? eligibleTapAmount : _tapAmount;\n        if (tapAmount < 1e18) revert TooLow();\n        // Get TAP valuation\n        uint256 otcAmountInUSD = tapAmount * epochTAPValuation; // Divided by TAP decimals\n        // Get payment token valuation\n        (, uint256 paymentTokenValuation) = paymentTokenOracle.oracle.peek(paymentTokenOracle.oracleData);\n        // Get payment token amount\n        paymentTokenAmount = _getDiscountedPaymentAmount(\n            otcAmountInUSD, paymentTokenValuation, aoTapOption.discount, _paymentToken.decimals()\n        );\n    }\n\n    // ===========\n    //    WRITE\n    // ===========\n\n    /// @notice Participate in the airdrop\n    /// @param _data The data to be used for the participation, varies by phases\n    function participate(bytes calldata _data) external whenNotPaused tapExists returns (uint256 aoTAPTokenID) {\n        uint256 cachedEpoch = epoch;\n        if (cachedEpoch == 0) revert NotStarted();\n        if (cachedEpoch > LAST_EPOCH) revert Ended();\n\n        // Phase 1\n        if (cachedEpoch == 1) {\n            aoTAPTokenID = _participatePhase1();\n        } else if (cachedEpoch == 2) {\n            aoTAPTokenID = _participatePhase2(_data); // _data = (uint256 role, bytes32[] _merkleProof)\n        } else if (cachedEpoch == 3) {\n            aoTAPTokenID = _participatePhase3(_data); // _data = (uint256[] _tokenID)\n        } else if (cachedEpoch >= 4) {\n            aoTAPTokenID = _participatePhase4();\n        }\n\n        emit Participate(cachedEpoch, aoTAPTokenID);\n    }\n\n    /// @notice Exercise an aoTAP position\n    /// @param _aoTAPTokenID tokenId of the aoTAP position, position must be active\n    /// @param _paymentToken Address of the payment token to use, must be whitelisted\n    /// @param _tapAmount Amount of TAP to exercise. If 0, the full amount is exercised\n    function exerciseOption(uint256 _aoTAPTokenID, ERC20 _paymentToken, uint256 _tapAmount)\n        external\n        whenNotPaused\n        tapExists\n    {\n        // Load data\n        (, AirdropTapOption memory aoTapOption) = aoTAP.attributes(_aoTAPTokenID);\n        if (aoTapOption.expiry < block.timestamp) revert OptionExpired();\n\n        uint256 cachedEpoch = epoch;\n\n        PaymentTokenOracle memory paymentTokenOracle = paymentTokens[_paymentToken];\n\n        // Check requirements\n        if (paymentTokenOracle.oracle == ITapiocaOracle(address(0))) {\n            revert PaymentTokenNotValid();\n        }\n        if (!aoTAP.isApprovedOrOwner(msg.sender, _aoTAPTokenID)) {\n            revert NotAuthorized();\n        }\n\n        // Get eligible OTC amount\n\n        uint256 eligibleTapAmount = aoTapOption.amount;\n        eligibleTapAmount -= aoTAPCalls[_aoTAPTokenID][cachedEpoch]; // Subtract already exercised amount\n        if (eligibleTapAmount < _tapAmount) revert TooHigh();\n\n        uint256 chosenAmount = _tapAmount == 0 ? eligibleTapAmount : _tapAmount;\n        if (chosenAmount < 1e18) revert TooLow();\n        aoTAPCalls[_aoTAPTokenID][cachedEpoch] += chosenAmount; // Adds up exercised amount to current epoch\n\n        // Finalize the deal\n        _processOTCDeal(_paymentToken, paymentTokenOracle, chosenAmount, aoTapOption.discount);\n\n        emit ExerciseOption(cachedEpoch, msg.sender, _paymentToken, _aoTAPTokenID, chosenAmount);\n    }\n\n    /// @notice Start a new epoch, extract TAP from the tapToken contract,\n    function newEpoch() external tapExists {\n        if (block.timestamp < lastEpochUpdate + EPOCH_DURATION) {\n            revert TooSoon();\n        }\n\n        // Update epoch info\n        lastEpochUpdate = uint64(block.timestamp);\n        epoch++;\n\n        // At epoch 4, change the epoch duration to 7 days\n        if (epoch == 4) {\n            EPOCH_DURATION = 7 days;\n        }\n\n        // Get epoch TAP valuation\n        (bool success, uint256 _epochTAPValuation) = tapOracle.get(tapOracleData);\n        if (!success) revert Failed();\n        epochTAPValuation = uint128(_epochTAPValuation);\n        emit NewEpoch(epoch, epochTAPValuation);\n    }\n\n    /// @notice Claim the Broker role of the aoTAP contract\n    function aoTAPBrokerClaim() external {\n        aoTAP.brokerClaim();\n    }\n\n    // =========\n    //   OWNER\n    // =========\n\n    function setTapToken(address payable _tapToken) external onlyOwner {\n        if (address(tapToken) != address(0)) revert NotValid();\n        tapToken = TapToken(_tapToken);\n    }\n\n    /// @notice Set the tapToken Oracle address and data\n    /// @param _tapOracle The new tapToken Oracle address\n    /// @param _tapOracleData The new tapToken Oracle data\n    function setTapOracle(ITapiocaOracle _tapOracle, bytes calldata _tapOracleData) external onlyOwner {\n        tapOracle = _tapOracle;\n        tapOracleData = _tapOracleData;\n\n        emit SetTapOracle(_tapOracle, _tapOracleData);\n    }\n\n    function setPhase2MerkleRoots(bytes32[4] calldata _merkleRoots) external onlyOwner {\n        if (epoch >= 2) revert NotValid();\n        phase2MerkleRoots = _merkleRoots;\n        emit Phase2MerkleRootsUpdated();\n    }\n\n    /**\n     * @notice Register users for a phase 1 or 4 with their eligible amount.\n     * @param _phase The phase to register the users for\n     * @param _users The users to register\n     * @param _amounts The eligible amount of TAP for each user\n     */\n    function registerUsersForPhase(uint256 _phase, address[] calldata _users, uint256[] calldata _amounts)\n        external\n        onlyOwner\n    {\n        if (_users.length != _amounts.length) revert NotValid();\n\n        if (_phase == 1) {\n            if (epoch >= 1) revert NotValid();\n            for (uint256 i; i < _users.length; i++) {\n                phase1Users[_users[i]] = _amounts[i];\n            }\n        }\n        /// @dev We want to be able to set phase 4 users in the future on subsequent epochs\n        else if (_phase == 4) {\n            for (uint256 i; i < _users.length; i++) {\n                phase4Users[_users[i]] = _amounts[i];\n            }\n        }\n    }\n\n    /// @notice Activate or deactivate a payment token\n    /// @dev set the oracle to address(0) to deactivate, expect the same decimal precision as TAP oracle\n    function setPaymentToken(ERC20 _paymentToken, ITapiocaOracle _oracle, bytes calldata _oracleData)\n        external\n        onlyOwner\n    {\n        paymentTokens[_paymentToken].oracle = _oracle;\n        paymentTokens[_paymentToken].oracleData = _oracleData;\n\n        emit SetPaymentToken(_paymentToken, _oracle, _oracleData);\n    }\n\n    /// @notice Set the payment token beneficiary\n    /// @param _paymentTokenBeneficiary The new payment token beneficiary\n    function setPaymentTokenBeneficiary(address _paymentTokenBeneficiary) external onlyOwner {\n        paymentTokenBeneficiary = _paymentTokenBeneficiary;\n    }\n\n    /// @notice Collect the payment tokens from the OTC deals\n    /// @param _paymentTokens The payment tokens to collect\n    function collectPaymentTokens(address[] calldata _paymentTokens) external onlyOwner nonReentrant {\n        if (paymentTokenBeneficiary == address(0)) {\n            revert TokenBeneficiaryNotSet();\n        }\n        uint256 len = _paymentTokens.length;\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                IERC20 paymentToken = IERC20(_paymentTokens[i]);\n                paymentToken.safeTransfer(paymentTokenBeneficiary, paymentToken.balanceOf(address(this)));\n            }\n        }\n    }\n\n    /// @notice Recover the unclaimed TAP from the contract.\n    /// Should occur after the end of the airdrop, which is 8 epochs, or 41 days long.\n    function daoRecoverTAP() external onlyOwner {\n        if (epoch <= LAST_EPOCH) revert TooSoon();\n\n        tapToken.transfer(msg.sender, tapToken.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Un/Pauses this contract.\n     */\n    function setPause(bool _pauseState) external onlyOwner {\n        if (_pauseState) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    // ============\n    //   INTERNAL\n    // ============\n\n    /// @notice Participate in phase 1 of the Airdrop. LBP users are given aoTAP pro-rata.\n    function _participatePhase1() internal returns (uint256 oTAPTokenID) {\n        uint256 _eligibleAmount = phase1Users[msg.sender];\n        if (_eligibleAmount == 0) revert NotEligible();\n\n        // Close eligibility\n        phase1Users[msg.sender] = 0;\n\n        // Mint aoTAP\n        uint128 expiry = uint128(lastEpochUpdate + EPOCH_DURATION); // Set expiry to the end of the epoch\n        oTAPTokenID = aoTAP.mint(msg.sender, expiry, uint128(PHASE_1_DISCOUNT), _eligibleAmount);\n    }\n\n    /// @notice Participate in phase 2 of the Airdrop. Guild members will receive pre-defined discounts and TAP, based on role.\n    /// @param _data The calldata. Needs to be the address of the user.\n    /// _data = (uint256 role, bytes32[] _merkleProof). Refer to {phase2MerkleRoots} for role.\n    function _participatePhase2(bytes calldata _data) internal returns (uint256 oTAPTokenID) {\n        (uint256 _role, bytes32[] memory _merkleProof) = abi.decode(_data, (uint256, bytes32[]));\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        if (!MerkleProof.verify(_merkleProof, phase2MerkleRoots[_role], leaf)) {\n            revert NotEligible();\n        }\n\n        uint256 subPhase = 20 + _role;\n        if (userParticipation[msg.sender][subPhase]) {\n            revert AlreadyParticipated();\n        }\n        // Close eligibility\n        userParticipation[msg.sender][subPhase] = true;\n\n        // Mint aoTAP\n        uint128 expiry = uint128(lastEpochUpdate + EPOCH_DURATION); // Set expiry to the end of the epoch\n        uint256 eligibleAmount = uint256(PHASE_2_AMOUNT_PER_USER[_role]) * 1e18;\n        uint128 discount = uint128(PHASE_2_DISCOUNT_PER_USER[_role]);\n        oTAPTokenID = aoTAP.mint(msg.sender, expiry, discount, eligibleAmount);\n    }\n\n    /// @notice Participate in phase 3 of the Airdrop. PCNFT holder will receive pre-defined discount and TAP.\n    /// @param _data The calldata. Needs to be an array of PCNFT tokenIDs.\n    /// _data = (uint256 PCNFT tokenID[])\n    function _participatePhase3(bytes calldata _data) internal returns (uint256 oTAPTokenID) {\n        uint256[] memory _tokenIDs = abi.decode(_data, (uint256[]));\n\n        uint256 arrLen = _tokenIDs.length;\n        address tokenIDToAddress;\n        for (uint256 i; i < arrLen;) {\n            if (PCNFT.ownerOf(_tokenIDs[i]) != msg.sender) revert NotEligible();\n\n            // To avoid collision, we cast token ID to an address,\n            // no conflict possible, tokenID goes from 0 ... 714.\n            tokenIDToAddress = address(uint160(_tokenIDs[i]));\n            if (userParticipation[tokenIDToAddress][3]) {\n                revert AlreadyParticipated();\n            }\n\n            // Close eligibility\n            userParticipation[tokenIDToAddress][3] = true;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint128 expiry = uint128(lastEpochUpdate + EPOCH_DURATION); // Set expiry to the end of the epoch\n        uint256 eligibleAmount = arrLen * PHASE_3_AMOUNT_PER_USER * 1e18; // Phase 3 amount multiplied the number of PCNFTs\n        uint128 discount = uint128(PHASE_3_DISCOUNT);\n        oTAPTokenID = aoTAP.mint(msg.sender, expiry, discount, eligibleAmount);\n    }\n\n    /// @notice Participate in phase 4 of the Airdrop. twTAP and Cassava guild's role are given TAP pro-rata.\n    function _participatePhase4() internal returns (uint256 oTAPTokenID) {\n        uint256 _eligibleAmount = phase4Users[msg.sender];\n        if (_eligibleAmount == 0) revert NotEligible();\n\n        // Close eligibility\n        phase4Users[msg.sender] = 0;\n\n        // Mint aoTAP\n        uint128 expiry = uint128(lastEpochUpdate + EPOCH_DURATION); // Set expiry to the end of the epoch\n        oTAPTokenID = aoTAP.mint(msg.sender, expiry, uint128(PHASE_4_DISCOUNT), _eligibleAmount);\n    }\n\n    /// @notice Process the OTC deal, transfer the payment token to the broker and the TAP amount to the user\n    /// @param _paymentToken The payment token\n    /// @param _paymentTokenOracle The oracle of the payment token\n    /// @param tapAmount The amount of TAP that the user has to receive\n    /// @param discount The discount that the user has to apply to the OTC deal\n    function _processOTCDeal(\n        ERC20 _paymentToken,\n        PaymentTokenOracle memory _paymentTokenOracle,\n        uint256 tapAmount,\n        uint256 discount\n    ) internal {\n        if (tapAmount == 0) revert TapAmountNotValid();\n\n        // Get TAP valuation\n        uint256 otcAmountInUSD = tapAmount * epochTAPValuation;\n\n        // Get payment token valuation\n        (bool success, uint256 paymentTokenValuation) = _paymentTokenOracle.oracle.get(_paymentTokenOracle.oracleData);\n        if (!success) revert Failed();\n\n        // Calculate payment amount and initiate the transfers\n        uint256 discountedPaymentAmount =\n            _getDiscountedPaymentAmount(otcAmountInUSD, paymentTokenValuation, discount, _paymentToken.decimals());\n        if (discountedPaymentAmount == 0) revert PaymentAmountNotValid();\n\n        uint256 balBefore = _paymentToken.balanceOf(address(this));\n        // IERC20(address(_paymentToken)).safeTransferFrom(msg.sender, address(this), discountedPaymentAmount);\n        {\n            bool isErr =\n                pearlmit.transferFromERC20(msg.sender, address(this), address(_paymentToken), discountedPaymentAmount);\n            if (isErr) revert Failed();\n        }\n        uint256 balAfter = _paymentToken.balanceOf(address(this));\n        if (balAfter - balBefore != discountedPaymentAmount) revert Failed();\n\n        tapToken.transfer(msg.sender, tapAmount);\n    }\n\n    /// @notice Computes the discounted payment amount for a given OTC amount in USD\n    /// @param _otcAmountInUSD The OTC amount in USD, 18 decimals\n    /// @param _paymentTokenValuation The payment token valuation in USD, 18 decimals\n    /// @param _discount The discount in BPS\n    /// @param _paymentTokenDecimals The payment token decimals\n    /// @return paymentAmount The discounted payment amount\n    function _getDiscountedPaymentAmount(\n        uint256 _otcAmountInUSD,\n        uint256 _paymentTokenValuation,\n        uint256 _discount,\n        uint256 _paymentTokenDecimals\n    ) internal pure returns (uint256 paymentAmount) {\n        if (_paymentTokenValuation == 0) revert PaymentTokenValuationNotValid();\n        // Calculate payment amount\n        uint256 rawPaymentAmount = _otcAmountInUSD / _paymentTokenValuation;\n        paymentAmount = rawPaymentAmount - muldiv(rawPaymentAmount, _discount, 100e4); // 1e4 is discount decimals, 100 is discount percentage\n\n        paymentAmount = paymentAmount / (10 ** (18 - _paymentTokenDecimals));\n    }\n}"
    },
    {
      "filename": "contracts/option-airdrop/AirdropBroker.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IPearlmit, PearlmitHandler} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {TWAML, FullMath} from \"tap-token/options/twAML.sol\"; // TODO Naming\nimport {TapToken} from \"tap-token/tokens/TapToken.sol\";\nimport {AOTAP, AirdropTapOption} from \"./aoTAP.sol\";\n\n/*\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n*/\n\nstruct PaymentTokenOracle {\n    ITapiocaOracle oracle;\n    bytes oracleData;\n}\n\nstruct Phase2Info {\n    uint8[4] amountsPerUsers;\n    uint8[4] discountsPerUsers;\n}\n\n/**\n * @notice More details found here https://docs.tapioca.xyz/tapioca/launch/option-airdrop\n */\ncontract AirdropBroker is Pausable, Ownable, PearlmitHandler, FullMath, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    bytes public tapOracleData;\n    ITapiocaOracle public tapOracle;\n    TapToken public tapToken;\n    AOTAP public immutable aoTAP;\n    IERC721 public immutable PCNFT;\n\n    uint128 public epochTAPValuation; // TAP price for the current epoch\n    uint64 public lastEpochUpdate; // timestamp of the last epoch update\n    uint64 public epoch; // Represents the number of weeks since the start of the contract\n\n    mapping(ERC20 => PaymentTokenOracle) public paymentTokens; // Token address => PaymentTokenOracle\n    address public paymentTokenBeneficiary; // Where to collect the payment tokens\n\n    mapping(uint256 => mapping(uint256 => uint256)) public aoTAPCalls; // oTAPTokenID => epoch => amountExercised\n\n    /// @notice Record of participation in phase 2 airdrop\n    /// Only applicable for phase 2. To get subphases on phase 2 we do userParticipation[_user][20+roles]\n    mapping(address => mapping(uint256 => bool)) public userParticipation; // user address => phase => participated\n\n    /// =====-------======\n    ///      Phase 1\n    /// =====-------======\n\n    /// @notice user address => eligible TAP amount, 0 means no eligibility\n    mapping(address => uint256) public phase1Users;\n    uint256 public constant PHASE_1_DISCOUNT = 500_000; //50 * 1e4; 50%\n\n    /// =====-------======\n    ///      Phase 2\n    /// =====-------======\n\n    // [OG Pearls, Tapiocans, Oysters, Cassava]\n    bytes32[4] public phase2MerkleRoots; // merkle root of phase 2 airdrop\n    uint8[4] public PHASE_2_AMOUNT_PER_USER = [200, 200, 190, 190];\n    uint24[4] public PHASE_2_DISCOUNT_PER_USER = [500_000, 400_000, 330_000, 250_000];\n\n    /// =====-------======\n    ///      Phase 3\n    /// =====-------======\n\n    uint256 public constant PHASE_3_AMOUNT_PER_USER = 714;\n    uint256 public constant PHASE_3_DISCOUNT = 500_000; //50 * 1e4; 50%\n\n    /// =====-------======\n    ///      Phase 4\n    /// =====-------======\n\n    /// @notice user address => eligible TAP amount, 0 means no eligibility\n    mapping(address => uint256) public phase4Users;\n    uint256 public constant PHASE_4_DISCOUNT = 330_000; //33 * 1e4;\n\n    uint256 public EPOCH_DURATION = 2 days; // Becomes 7 days at the start of the phase 4\n    uint256 public constant LAST_EPOCH = 8; // 8 epochs, 41 days long\n\n    /// =====-------======\n\n    error PaymentTokenNotValid();\n    error OptionExpired();\n    error TooHigh();\n    error TooLow();\n    error NotStarted();\n    error Ended();\n    error NotAuthorized();\n    error TooSoon();\n    error Failed();\n    error NotValid();\n    error TokenBeneficiaryNotSet();\n    error NotEligible();\n    error AlreadyParticipated();\n    error PaymentAmountNotValid();\n    error TapAmountNotValid();\n    error PaymentTokenValuationNotValid();\n    error TapNotSet();\n    error TapOracleNotSet();\n\n    constructor(address _aoTAP, address _pcnft, address _paymentTokenBeneficiary, IPearlmit _pearlmit, address _owner)\n        PearlmitHandler(_pearlmit)\n    {\n        paymentTokenBeneficiary = _paymentTokenBeneficiary;\n        aoTAP = AOTAP(_aoTAP);\n        PCNFT = IERC721(_pcnft);\n\n        _transferOwnership(_owner);\n    }\n\n    // ==========\n    //   EVENTS\n    // ==========\n    event Participate(uint256 indexed epoch, uint256 aoTAPTokenID);\n    event ExerciseOption(\n        uint256 indexed epoch, address indexed to, ERC20 indexed paymentToken, uint256 aoTapTokenID, uint256 amount\n    );\n    event NewEpoch(uint256 indexed epoch, uint256 epochTAPValuation);\n    event SetPaymentToken(ERC20 paymentToken, ITapiocaOracle oracle, bytes oracleData);\n    event SetTapOracle(ITapiocaOracle oracle, bytes oracleData);\n    event Phase2MerkleRootsUpdated();\n\n    modifier tapExists() {\n        if (address(tapOracle) == address(0)) revert TapOracleNotSet();\n        if (address(tapToken) == address(0)) revert TapNotSet();\n        _;\n    }\n\n    // ==========\n    //    READ\n    // ==========\n\n    /// @notice Returns the details of an OTC deal for a given oTAP token ID and a payment token.\n    ///         The oracle uses the last peeked value, and not the latest one, so the payment amount may be different.\n    /// @param _aoTAPTokenID The aoTAP token ID\n    /// @param _paymentToken The payment token\n    /// @param _tapAmount The amount of TAP to be exchanged. If 0 it will use the full amount of TAP eligible for the deal\n    /// @return eligibleTapAmount The amount of TAP eligible for the deal\n    /// @return paymentTokenAmount The amount of payment tokens required for the deal\n    /// @return tapAmount The amount of TAP to be exchanged\n\n    function getOTCDealDetails(uint256 _aoTAPTokenID, ERC20 _paymentToken, uint256 _tapAmount)\n        external\n        view\n        tapExists\n        returns (uint256 eligibleTapAmount, uint256 paymentTokenAmount, uint256 tapAmount)\n    {\n        // Load data\n        (, AirdropTapOption memory aoTapOption) = aoTAP.attributes(_aoTAPTokenID);\n        if (aoTapOption.expiry < block.timestamp) revert OptionExpired();\n\n        uint256 cachedEpoch = epoch;\n\n        PaymentTokenOracle memory paymentTokenOracle = paymentTokens[_paymentToken];\n\n        // Check requirements\n        if (paymentTokenOracle.oracle == ITapiocaOracle(address(0))) {\n            revert PaymentTokenNotValid();\n        }\n\n        eligibleTapAmount = aoTapOption.amount;\n        eligibleTapAmount -= aoTAPCalls[_aoTAPTokenID][cachedEpoch]; // Subtract already exercised amount\n        if (eligibleTapAmount < _tapAmount) revert TooHigh();\n\n        tapAmount = _tapAmount == 0 ? eligibleTapAmount : _tapAmount;\n        if (tapAmount < 1e18) revert TooLow();\n        // Get TAP valuation\n        uint256 otcAmountInUSD = tapAmount * epochTAPValuation; // Divided by TAP decimals\n        // Get payment token valuation\n        (, uint256 paymentTokenValuation) = paymentTokenOracle.oracle.peek(paymentTokenOracle.oracleData);\n        // Get payment token amount\n        paymentTokenAmount = _getDiscountedPaymentAmount(\n            otcAmountInUSD, paymentTokenValuation, aoTapOption.discount, _paymentToken.decimals()\n        );\n    }\n\n    // ===========\n    //    WRITE\n    // ===========\n\n    /// @notice Participate in the airdrop\n    /// @param _data The data to be used for the participation, varies by phases\n    function participate(bytes calldata _data) external whenNotPaused tapExists returns (uint256 aoTAPTokenID) {\n        uint256 cachedEpoch = epoch;\n        if (cachedEpoch == 0) revert NotStarted();\n        if (cachedEpoch > LAST_EPOCH) revert Ended();\n\n        // Phase 1\n        if (cachedEpoch == 1) {\n            aoTAPTokenID = _participatePhase1();\n        } else if (cachedEpoch == 2) {\n            aoTAPTokenID = _participatePhase2(_data); // _data = (uint256 role, bytes32[] _merkleProof)\n        } else if (cachedEpoch == 3) {\n            aoTAPTokenID = _participatePhase3(_data); // _data = (uint256[] _tokenID)\n        } else if (cachedEpoch >= 4) {\n            aoTAPTokenID = _participatePhase4();\n        }\n\n        emit Participate(cachedEpoch, aoTAPTokenID);\n    }\n\n    /// @notice Exercise an aoTAP position\n    /// @param _aoTAPTokenID tokenId of the aoTAP position, position must be active\n    /// @param _paymentToken Address of the payment token to use, must be whitelisted\n    /// @param _tapAmount Amount of TAP to exercise. If 0, the full amount is exercised\n    function exerciseOption(uint256 _aoTAPTokenID, ERC20 _paymentToken, uint256 _tapAmount)\n        external\n        whenNotPaused\n        tapExists\n    {\n        // Load data\n        (, AirdropTapOption memory aoTapOption) = aoTAP.attributes(_aoTAPTokenID);\n        if (aoTapOption.expiry < block.timestamp) revert OptionExpired();\n\n        uint256 cachedEpoch = epoch;\n\n        PaymentTokenOracle memory paymentTokenOracle = paymentTokens[_paymentToken];\n\n        // Check requirements\n        if (paymentTokenOracle.oracle == ITapiocaOracle(address(0))) {\n            revert PaymentTokenNotValid();\n        }\n        if (!aoTAP.isApprovedOrOwner(msg.sender, _aoTAPTokenID)) {\n            revert NotAuthorized();\n        }\n\n        // Get eligible OTC amount\n\n        uint256 eligibleTapAmount = aoTapOption.amount;\n        eligibleTapAmount -= aoTAPCalls[_aoTAPTokenID][cachedEpoch]; // Subtract already exercised amount\n        if (eligibleTapAmount < _tapAmount) revert TooHigh();\n\n        uint256 chosenAmount = _tapAmount == 0 ? eligibleTapAmount : _tapAmount;\n        if (chosenAmount < 1e18) revert TooLow();\n        aoTAPCalls[_aoTAPTokenID][cachedEpoch] += chosenAmount; // Adds up exercised amount to current epoch\n\n        // Finalize the deal\n        _processOTCDeal(_paymentToken, paymentTokenOracle, chosenAmount, aoTapOption.discount);\n\n        emit ExerciseOption(cachedEpoch, msg.sender, _paymentToken, _aoTAPTokenID, chosenAmount);\n    }\n\n    /// @notice Start a new epoch, extract TAP from the tapToken contract,\n    function newEpoch() external tapExis"
    }
  ]
}