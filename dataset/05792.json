{
  "Title": "[L-07] Array entry not deleted when removing bridge agent",
  "Content": "\n*There is 1 instance of this issue:*\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchPort.sol#L355\n\nThe function `toggleBridgeAgent()` is only called from [_removeBranchBridgeAgent()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/CoreBranchRouter.sol#L263) in the CoreBranchRouter contract. Thus, the function should delete the `_bridgeAgent` entry from the bridgeAgents array as well to remove stale state.\n\n```solidity\nFile: BranchPort.sol\n359:     function toggleBridgeAgent(address _bridgeAgent) external override requiresCoreRouter {\n360:         isBridgeAgent[_bridgeAgent] = !isBridgeAgent[_bridgeAgent];\n361: \n362:         emit BridgeAgentToggled(_bridgeAgent);\n363:     }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/BranchPort.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IPortStrategy} from \"./interfaces/IPortStrategy.sol\";\nimport {IBranchPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {ERC20hTokenBranch} from \"./token/ERC20hTokenBranch.sol\";\n\n/// @title Branch Port - Omnichain Token Management Contract\n/// @author MaiaDAO\ncontract BranchPort is Ownable, IBranchPort {\n    using SafeTransferLib for address;\n\n    /*///////////////////////////////////////////////////////////////\n                        CORE ROUTER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Core Branch Router Address.\n    address public coreBranchRouterAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address bridgeAgent => bool isActiveBridgeAgent) public isBridgeAgent;\n\n    /// @notice Branch Routers deployed in branch chain.\n    address[] public bridgeAgents;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address bridgeAgentFactory => bool isActiveBridgeAgentFactory) public isBridgeAgentFactory;\n\n    /// @notice Branch Routers deployed in branch chain.\n    address[] public bridgeAgentFactories;\n\n    /*///////////////////////////////////////////////////////////////\n                        STRATEGY TOKENS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping returns true if Strategy Token Address is active for usage in Port Strategies.\n    mapping(address token => bool allowsStrategies) public isStrategyToken;\n\n    /// @notice List of Tokens allowed for usage in Port Strategies.\n    address[] public strategyTokens;\n\n    /// @notice Mapping returns a given token's total debt incurred by Port Strategies.\n    mapping(address token => uint256 debt) public getStrategyTokenDebt;\n\n    /// @notice Mapping returns the minimum ratio of a given Strategy Token the Port should hold.\n    mapping(address token => uint256 minimumReserveRatio) public getMinimumTokenReserveRatio;\n\n    /*///////////////////////////////////////////////////////////////\n                        PORT STRATEGIES STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping returns true if Port Strategy is allowed to manage a given Strategy Token.\n    mapping(address strategy => mapping(address token => bool isActiveStrategy)) public isPortStrategy;\n\n    /// @notice Port Strategy Addresses deployed in the current branch chain.\n    address[] public portStrategies;\n\n    /// @notice Mapping returns the amount of Strategy Token debt a given Port Strategy has.\n    mapping(address strategy => mapping(address token => uint256 debt)) public getPortStrategyTokenDebt;\n\n    /// @notice Mapping returns the last time a given Port Strategy managed a given Strategy Token.\n    mapping(address strategy => mapping(address token => uint256 lastManaged)) public lastManaged;\n\n    /// @notice Mapping returns the time limit a given Port Strategy must wait before managing a Strategy Token.\n    mapping(address strategy => mapping(address token => uint256 dailyLimitAmount)) public strategyDailyLimitAmount;\n\n    /// @notice Mapping returns the amount of a Strategy Token a given Port Strategy can manage.\n    mapping(address strategy => mapping(address token => uint256 dailyLimitRemaining)) public\n        strategyDailyLimitRemaining;\n\n    /*///////////////////////////////////////////////////////////////\n                            REENTRANCY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Reentrancy lock guard state.\n    uint256 internal _unlocked = 1;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant DIVISIONER = 1e4;\n    uint256 internal constant MIN_RESERVE_RATIO = 3e3;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for the Branch Port Contract.\n     *   @param _owner Address of the Owner.\n     */\n    constructor(address _owner) {\n        require(_owner != address(0), \"Owner is zero address\");\n        _initializeOwner(_owner);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        INITIALIZATION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Initializes the Branch Port.\n     *   @param _coreBranchRouter Address of the Core Branch Router.\n     *   @param _bridgeAgentFactory Address of the Bridge Agent Factory.\n     */\n    function initialize(address _coreBranchRouter, address _bridgeAgentFactory) external virtual onlyOwner {\n        require(coreBranchRouterAddress == address(0), \"Contract already initialized\");\n        require(!isBridgeAgentFactory[_bridgeAgentFactory], \"Contract already initialized\");\n\n        require(_coreBranchRouter != address(0), \"CoreBranchRouter is zero address\");\n        require(_bridgeAgentFactory != address(0), \"BridgeAgentFactory is zero address\");\n\n        coreBranchRouterAddress = _coreBranchRouter;\n        isBridgeAgentFactory[_bridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_bridgeAgentFactory);\n    }\n\n    /// @notice Function being overrriden to prevent mistakenly renouncing ownership.\n    function renounceOwnership() public payable override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        PORT STRATEGY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function manage(address _token, uint256 _amount) external override requiresPortStrategy(_token) {\n        // Cache Strategy Token Global Debt\n        uint256 _strategyTokenDebt = getStrategyTokenDebt[_token];\n\n        // Check if request would surpass the tokens minimum reserves\n        if (_amount > _excessReserves(_strategyTokenDebt, _token)) revert InsufficientReserves();\n\n        // Check if request would surpass the Port Strategy's daily limit\n        _checkTimeLimit(_token, _amount);\n\n        // Update Strategy Token Global Debt\n        getStrategyTokenDebt[_token] = _strategyTokenDebt + _amount;\n        // Update Port Strategy Token Debt\n        getPortStrategyTokenDebt[msg.sender][_token] += _amount;\n\n        // Transfer tokens to Port Strategy for management\n        _token.safeTransfer(msg.sender, _amount);\n\n        // Emit DebtCreated event\n        emit DebtCreated(msg.sender, _token, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function replenishReserves(address _token, uint256 _amount) external override lock {\n        // Update Port Strategy Token Debt. Will underflow if not enough debt to repay.\n        getPortStrategyTokenDebt[msg.sender][_token] -= _amount;\n\n        // Update Strategy Token Global Debt. Will underflow if not enough debt to repay.\n        getStrategyTokenDebt[_token] -= _amount;\n\n        // Get current balance of _token\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n\n        // Withdraw tokens from startegy\n        IPortStrategy(msg.sender).withdraw(address(this), _token, _amount);\n\n        // Check if _token balance has increased by _amount\n        require(ERC20(_token).balanceOf(address(this)) - currBalance == _amount, \"Port Strategy Withdraw Failed\");\n\n        // Emit DebtRepaid event\n        emit DebtRepaid(msg.sender, _token, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function replenishReserves(address _strategy, address _token) external override lock {\n        // Cache Strategy Token Global Debt\n        uint256 strategyTokenDebt = getStrategyTokenDebt[_token];\n\n        // Get current balance of _token\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n\n        // Get reserves lacking\n        uint256 reservesLacking = _reservesLacking(strategyTokenDebt, _token, currBalance);\n\n        // Cache Port Strategy Token Debt\n        uint256 portStrategyTokenDebt = getPortStrategyTokenDebt[_strategy][_token];\n\n        // Calculate amount to withdraw. The lesser of reserves lacking or Strategy Token Global Debt.\n        uint256 amountToWithdraw = portStrategyTokenDebt < reservesLacking ? portStrategyTokenDebt : reservesLacking;\n\n        // Update Port Strategy Token Debt\n        getPortStrategyTokenDebt[_strategy][_token] = portStrategyTokenDebt - amountToWithdraw;\n        // Update Strategy Token Global Debt\n        getStrategyTokenDebt[_token] = strategyTokenDebt - amountToWithdraw;\n\n        // Withdraw tokens from startegy\n        IPortStrategy(_strategy).withdraw(address(this), _token, amountToWithdraw);\n\n        // Check if _token balance has increased by _amount\n        require(\n            ERC20(_token).balanceOf(address(this)) - currBalance == amountToWithdraw, \"Port Strategy Withdraw Failed\"\n        );\n\n        // Emit DebtRepaid event\n        emit DebtRepaid(_strategy, _token, amountToWithdraw);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function withdraw(address _recipient, address _underlyingAddress, uint256 _deposit)\n        public\n        virtual\n        override\n        lock\n        requiresBridgeAgent\n    {\n        _underlyingAddress.safeTransfer(_recipient, _deposit);\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeIn(address _recipient, address _localAddress, uint256 _amount)\n        external\n        override\n        requiresBridgeAgent\n    {\n        _bridgeIn(_recipient, _localAddress, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeInMultiple(\n        address _recipient,\n        address[] memory _localAddresses,\n        address[] memory _underlyingAddresses,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits\n    ) external override requiresBridgeAgent {\n        // Cache Length\n        uint256 length = _localAddresses.length;\n\n        // Loop through token inputs\n        for (uint256 i = 0; i < length;) {\n            // Check if hTokens are being bridged in\n            if (_amounts[i] - _deposits[i] > 0) {\n                unchecked {\n                    _bridgeIn(_recipient, _localAddresses[i], _amounts[i] - _deposits[i]);\n                }\n            }\n\n            // Check if underlying tokens are being cleared\n            if (_deposits[i] > 0) {\n                withdraw(_recipient, _underlyingAddresses[i], _deposits[i]);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeOut(\n        address _depositor,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _amount,\n        uint256 _deposit\n    ) external override lock requiresBridgeAgent {\n        _bridgeOut(_depositor, _localAddress, _underlyingAddress, _amount, _deposit);\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeOutMultiple(\n        address _depositor,\n        address[] memory _localAddresses,\n        address[] memory _underlyingAddresses,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits\n    ) external override lock requiresBridgeAgent {\n        // Cache Length\n        uint256 length = _localAddresses.length;\n\n        // Sanity Check input arrays\n        if (length > 255) revert InvalidInputArrays();\n        if (length != _underlyingAddresses.length) revert InvalidInputArrays();\n        if (_underlyingAddresses.length != _amounts.length) revert InvalidInputArrays();\n        if (_amounts.length != _deposits.length) revert InvalidInputArrays();\n\n        // Loop through token inputs and bridge out\n        for (uint256 i = 0; i < length;) {\n            _bridgeOut(_depositor, _localAddresses[i], _underlyingAddresses[i], _amounts[i], _deposits[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function addBridgeAgent(address _bridgeAgent) external override requiresBridgeAgentFactory {\n        if (isBridgeAgent[_bridgeAgent]) revert AlreadyAddedBridgeAgent();\n\n        isBridgeAgent[_bridgeAgent] = true;\n        bridgeAgents.push(_bridgeAgent);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function setCoreRouter(address _newCoreRouter) external override requiresCoreRouter {\n        require(coreBranchRouterAddress != address(0), \"CoreRouter address is zero\");\n        require(_newCoreRouter != address(0), \"New CoreRouter address is zero\");\n        coreBranchRouterAddress = _newCoreRouter;\n    }\n\n    /// @inheritdoc IBranchPort\n    function addBridgeAgentFactory(address _newBridgeAgentFactory) external override requiresCoreRouter {\n        if (isBridgeAgentFactory[_newBridgeAgentFactory]) revert AlreadyAddedBridgeAgentFactory();\n\n        isBridgeAgentFactory[_newBridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_newBridgeAgentFactory);\n\n        emit BridgeAgentFactoryAdded(_newBridgeAgentFactory);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleBridgeAgentFactory(address _newBridgeAgentFactory) external override requiresCoreRouter {\n        isBridgeAgentFactory[_newBridgeAgentFactory] = !isBridgeAgentFactory[_newBridgeAgentFactory];\n\n        emit BridgeAgentFactoryToggled(_newBridgeAgentFactory);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleBridgeAgent(address _bridgeAgent) external override requiresCoreRouter {\n        isBridgeAgent[_bridgeAgent] = !isBridgeAgent[_bridgeAgent];\n\n        emit BridgeAgentToggled(_bridgeAgent);\n    }\n\n    /// @inheritdoc IBranchPort\n    function addStrategyToken(address _token, uint256 _minimumReservesRatio) external override requiresCoreRouter {\n        if (_minimumReservesRatio >= DIVISIONER || _minimumReservesRatio < MIN_RESERVE_RATIO) {\n            revert InvalidMinimumReservesRatio();\n        }\n\n        strategyTokens.push(_token);\n        getMinimumTokenReserveRatio[_token] = _minimumReservesRatio;\n        isStrategyToken[_token] = true;\n\n        emit StrategyTokenAdded(_token, _minimumReservesRatio);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleStrategyToken(address _token) external override requiresCoreRouter {\n        isStrategyToken[_token] = !isStrategyToken[_token];\n\n        emit StrategyTokenToggled(_token);\n    }\n\n    /// @inheritdoc IBranchPort\n    function addPortStrategy(address _portStrategy, address _token, uint256 _dailyManagementLimit)\n        external\n        override\n        requiresCoreRouter\n    {\n        if (!isStrategyToken[_token]) revert UnrecognizedStrategyToken();\n        portStrategies.push(_portStrategy);\n        strategyDailyLimitAmount[_portStrategy][_token] = _dailyManagementLimit;\n        isPortStrategy[_portStrategy][_token] = true;\n\n        emit PortStrategyAdded(_portStrategy, _token, _dailyManagementLimit);\n    }\n\n    /// @inheritdoc IBranchPort\n    function togglePortStrategy(address _portStrategy, address _token) external override requiresCoreRouter {\n        isPortStrategy[_portStrategy][_token] = !isPortStrategy[_portStrategy][_token];\n\n        emit PortStrategyToggled(_portStrategy, _token);\n    }\n\n    /// @inheritdoc IBranchPort\n    function updatePortStrategy(address _portStrategy, address _token, uint256 _dailyManagementLimit)\n        external\n        override\n        requiresCoreRouter\n    {\n        strategyDailyLimitAmount[_portStrategy][_token] = _dailyManagementLimit;\n\n        emit PortStrategyUpdated(_portStrategy, _token, _dailyManagementLimit);\n    }\n\n    /// @inheritdoc IBranchPort\n    function setCoreBranchRouter(address _coreBranchRouter, address _coreBranchBridgeAgent)\n        external\n        override\n        requiresCoreRouter\n    {\n        coreBranchRouterAddress = _coreBranchRouter;\n        isBridgeAgent[_coreBranchBridgeAgent] = true;\n        bridgeAgents.push(_coreBranchBridgeAgent);\n\n        emit CoreBranchSet(_coreBranchRouter, _coreBranchBridgeAgent);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INTERNAL VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns amount of Strategy Tokens\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 excess reserves\n     */\n    function _excessReserves(uint256 _strategyTokenDebt, address _token) internal view returns (uint256) {\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n        uint256 minReserves = _minimumReserves(_strategyTokenDebt, currBalance, _token);\n\n        unchecked {\n            return currBalance > minReserves ? currBalance - minReserves : 0;\n        }\n    }\n\n    /**\n     * @notice Returns amount of Strategy Tokens needed to reach minimum reserves\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 excess reserves\n     */\n    function _reservesLacking(uint256 _strategyTokenDebt, address _token, uint256 currBalance)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 minReserves = _minimumReserves(_strategyTokenDebt, currBalance, _token);\n\n        unchecked {\n            return currBalance < minReserves ? minReserves - currBalance : 0;\n        }\n    }\n\n    /**\n     * @notice Internal function to return the minimum amount of reserves of a given Strategy Token the Port should hold.\n     *   @param _strategyTokenDebt Total token debt incurred by Port Strategies.\n     *   @param _currBalance Current balance of a given Strategy Token.\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 minimum reserves\n     */\n    function _minimumReserves(uint256 _strategyTokenDebt, uint256 _currBalance, address _token)\n        internal\n        view\n        returns (uint256)\n    {\n        return ((_currBalance + _strategyTokenDebt) * getMinimumTokenReserveRatio[_token]) / DIVISIONER;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function to check if a Port Strategy has reached its daily management limit.\n     *   @param _token address being managed.\n     *   @param _amount of token being requested.\n     */\n    function _checkTimeLimit(address _token, uint256 _amount) internal {\n        uint256 dailyLimit = strategyDailyLimitRemaining[msg.sender][_token];\n        if (block.timestamp - lastManaged[msg.sender][_token] >= 1 days) {\n            dailyLimit = strategyDailyLimitAmount[msg.sender][_token];\n            unchecked {\n                lastManaged[msg.sender][_token] = (block.timestamp / 1 days) * 1 days;\n            }\n        }\n        strategyDailyLimitRemaining[msg.sender][_token] = dailyLimit - _amount;\n    }\n\n    /**\n     * @notice Internal function to bridge in hTokens.\n     *   @param _recipient address of the recipient.\n     *   @param _localAddress address of the hToken.\n     *   @param _amount amount of hTokens to bridge in.\n     */\n    function _bridgeIn(address _recipient, address _localAddress, uint256 _amount) internal virtual {\n        ERC20hTokenBranch(_localAddress).mint(_recipient, _amount);\n    }\n\n    /**\n     * @notice Internal function to bridge out hTokens and underlying tokens.\n     *   @param _depositor address of the depositor.\n     *   @param _localAddress address of the hToken.\n     *   @param _underlyingAddress address of the underlying token.\n     *   @param _amount total amount of tokens to bridge out.\n     *   @param _deposit amount of underlying tokens to bridge out.\n     */\n    function _bridgeOut(\n        address _depositor,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _amount,\n        uint256 _deposit\n    ) internal virtual {\n        // Cache hToken amount out\n        uint256 _hTokenAmount = _amount - _deposit;\n\n        // Check if hTokens are being bridged out\n        if (_hTokenAmount > 0) {\n            _localAddress.safeTransferFrom(_depositor, address(this), _hTokenAmount);\n            ERC20hTokenBranch(_localAddress).burn(_hTokenAmount);\n        }\n\n        // Check if underlying tokens are being bridged out\n        if (_deposit > 0) {\n            _underlyingAddress.safeTransferFrom(_depositor, address(this), _deposit);\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is the Branch Chain's Core Root Router.\n    modifier requiresCoreRouter() {\n        if (msg.sender != coreBranchRouterAddress) revert UnrecognizedCore();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent.\n    modifier requiresBridgeAgent() {\n        if (!isBridgeAgent[msg.sender]) revert UnrecognizedBridgeAgent();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent Factory.\n    modifier requiresBridgeAgentFactory() {\n        if (!isBridgeAgentFactory[msg.sender]) revert UnrecognizedBridgeAgentFactory();\n        _;\n    }\n\n    /// @notice Modifier that require msg sender to be an active Port Strategy\n    modifier requiresPortStrategy(address _token) {\n        if (!isStrategyToken[_token]) revert UnrecognizedStrategyToken();\n        if (!isPortStrategy[msg.sender][_token]) revert UnrecognizedPortStrategy();\n        _;\n    }\n\n    /// @notice Modifier for a simple re-entrancy check.\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n}"
    },
    {
      "filename": "src/CoreBranchRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IBranchPort as IPort} from \"./interfaces/IBranchPort.sol\";\nimport {IBranchBridgeAgent as IBridgeAgent, GasParams} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IBranchBridgeAgentFactory as IBridgeAgentFactory} from \"./interfaces/IBranchBridgeAgentFactory.sol\";\nimport {IBranchRouter} from \"./interfaces/IBranchRouter.sol\";\nimport {ICoreBranchRouter} from \"./interfaces/ICoreBranchRouter.sol\";\nimport {IERC20hTokenBranchFactory as ITokenFactory} from \"./interfaces/IERC20hTokenBranchFactory.sol\";\n\nimport {BaseBranchRouter} from \"./BaseBranchRouter.sol\";\nimport {ERC20hTokenBranch as ERC20hToken} from \"./token/ERC20hTokenBranch.sol\";\n\n/// @title Core Branch Router Contract\n/// @author MaiaDAO\ncontract CoreBranchRouter is ICoreBranchRouter, BaseBranchRouter {\n    /// @notice hToken Factory Address.\n    address public immutable hTokenFactoryAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Core Branch Router.\n     * @param _hTokenFactoryAddress Branch hToken Factory Address.\n     */\n    constructor(address _hTokenFactoryAddress) BaseBranchRouter() {\n        hTokenFactoryAddress = _hTokenFactoryAddress;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                 TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice This function is used to add a global token to a branch.\n     * @param _globalAddress Address of the token to be added.\n     * @param _dstChainId Chain Id of the chain to which the deposit is being added.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function addGlobalToken(address _globalAddress, uint256 _dstChainId, GasParams[3] calldata _gParams)\n        external\n        payable\n    {\n        // Encode Call Data\n        bytes memory params = abi.encode(msg.sender, _globalAddress, _dstChainId, [_gParams[1], _gParams[2]]);\n\n        // Pack FuncId\n        bytes memory payload = abi.encodePacked(bytes1(0x01), params);\n\n        // Send Cross-Chain request (System Response/Request)\n        IBridgeAgent(localBridgeAgentAddress).callOut{value: msg.value}(payable(msg.sender), payload, _gParams[0]);\n    }\n\n    /**\n     * @notice This function is used to add a local token to the system.\n     * @param _underlyingAddress Address of the underlying token to be added.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function addLocalToken(address _underlyingAddress, GasParams calldata _gParams) external payable virtual {\n        //Get Token Info\n        uint8 decimals = ERC20(_underlyingAddress).decimals();\n\n        //Create Token\n        ERC20hToken newToken = ITokenFactory(hTokenFactoryAddress).createToken(\n            ERC20(_underlyingAddress).name(), ERC20(_underlyingAddress).symbol(), decimals, true\n        );\n\n        //Encode Data\n        bytes memory params = abi.encode(_underlyingAddress, newToken, newToken.name(), newToken.symbol(), decimals);\n\n        // Pack FuncId\n        bytes memory payload = abi.encodePacked(bytes1(0x02), params);\n\n        //Send Cross-Chain request (System Response/Request)\n        IBridgeAgent(localBridgeAgentAddress).callOutSystem{value: msg.value}(payable(msg.sender), payload, _gParams);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    LAYERZERO EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchRouter\n    function executeNoSettlement(bytes calldata _params) external payable virtual override requiresAgentExecutor {\n        /// _receiveAddGlobalToken\n        if (_params[0] == 0x01) {\n            (\n                address globalAddress,\n                string memory name,\n                string memory symbol,\n                uint8 decimals,\n                address refundee,\n                GasParams memory gParams\n            ) = abi.decode(_params[1:], (address, string, string, uint8, address, GasParams));\n\n            _receiveAddGlobalToken(globalAddress, name, symbol, decimals, refundee, gParams);\n            /// _receiveAddBridgeAgent\n        } else if (_params[0] == 0x02) {\n            (\n                address newBranchRouter,\n                address branchBridgeAgentFactory,\n                address rootBridgeAgent,\n                address rootBridgeAgentFactory,\n                address refundee,\n                GasParams memory gParams\n            ) = abi.decode(_params[1:], (address, address, address, address, address, GasParams));\n\n            _receiveAddBridgeAgent(\n                newBranchRouter, branchBridgeAgentFactory, rootBridgeAgent, rootBridgeAgentFactory, refundee, gParams\n            );\n\n            /// _toggleBranchBridgeAgentFactory\n        } else if (_params[0] == 0x03) {\n            (address bridgeAgentFactoryAddress) = abi.decode(_params[1:], (address));\n\n            _toggleBranchBridgeAgentFactory(bridgeAgentFactoryAddress);\n\n            /// _removeBranchBridgeAgent\n        } else if (_params[0] == 0x04) {\n            (address branchBridgeAgent) = abi.decode(_params[1:], (address));\n\n            _removeBranchBridgeAgent(branchBridgeAgent);\n\n            /// _manageStrategyToken\n        } else if (_params[0] == 0x05) {\n            (address underlyingToken, uint256 minimumReservesRatio) = abi.decode(_params[1:], (address, uint256));\n\n            _manageStrategyToken(underlyingToken, minimumReservesRatio);\n\n            /// _managePortStrategy\n        } else if (_params[0] == 0x06) {\n            (address portStrategy, address underlyingToken, uint256 dailyManagementLimit, bool isUpdateDailyLimit) =\n                abi.decode(_params[1:], (address, address, uint256, bool));\n\n            _managePortStrategy(portStrategy, underlyingToken, dailyManagementLimit, isUpdateDailyLimit);\n\n            /// _setCoreBranchRouter\n        } else if (_params[0] == 0x07) {\n            (address coreBranchRouter, address coreBranchBridgeAgent) = abi.decode(_params[1:], (address, address));\n\n            IPort(localPortAddress).setCoreBranchRouter(coreBranchRouter, coreBranchBridgeAgent);\n\n            /// Unrecognized Function Selector\n        } else {\n            revert UnrecognizedFunctionId();\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                 TOKEN MANAGEMENT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to deploy/add a token already active in the global environment in the Root Chain.\n     *         Must be called from another chain.\n     *  @param _globalAddress the address of the global virtualized token.\n     *  @param _name token name.\n     *  @param _symbol token symbol.\n     *  @param _refundee the address of the excess gas receiver.\n     *  @param _gParams Gas parameters for remote execution.\n     *  @dev FUNC ID: 1\n     *  @dev all hTokens have 18 decimals.\n     */\n    function _receiveAddGlobalToken(\n        address _globalAddress,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _refundee,\n        GasParams memory _gParams\n    ) internal {\n        //Create Token\n        ERC20hToken newToken = ITokenFactory(hTokenFactoryAddress).createToken(_name, _symbol, _decimals, false);\n\n        // Encode Data\n        bytes memory params = abi.encode(_globalAddress, newToken);\n\n        // Pack FuncId\n        bytes memory payload = abi.encodePacked(bytes1(0x03), params);\n\n        //Send Cross-Chain request\n        IBridgeAgent(localBridgeAgentAddress).callOutSystem{value: msg.value}(payable(_refundee), payload, _gParams);\n    }\n\n    /**\n     * @notice Function to deploy/add a token already active in the global environment in the Root Chain.\n     *         Must be called from another chain.\n     *    @param _newBranchRouter the address of the new branch router.\n     *    @param _branchBridgeAgentFactory the address of the branch bridge agent factory.\n     *    @param _rootBridgeAgent the address of the root bridge agent.\n     *    @param _rootBridgeAgentFactory the address of the root bridge agent factory.\n     *    @param _refundee the address of the excess gas receiver.\n     *    @param _gParams Gas parameters for remote execution.\n     *    @dev FUNC ID: 2\n     *    @dev all hTokens have 18 decimals.\n     */\n    function _receiveAddBridgeAgent(\n        address _newBranchRouter,\n        address _branchBridgeAgentFactory,\n        address _rootBridgeAgent,\n        address _rootBridgeAgentFactory,\n        address _refundee,\n        GasParams memory _gParams\n    ) internal virtual {\n        // Save Port Address to memory\n        address _localPortAddress = localPortAddress;\n\n        // Check if msg.sender is a valid BridgeAgentFactory\n        if (!IPort(_localPortAddress).isBridgeAgentFactory(_branchBridgeAgentFactory)) {\n            revert UnrecognizedBridgeAgentFactory();\n        }\n\n        // Create BridgeAgent\n        address newBridgeAgent = IBridgeAgentFactory(_branchBridgeAgentFactory).createBridgeAgent(\n            _newBranchRouter, _rootBridgeAgent, _rootBridgeAgentFactory\n        );\n\n        // Check BridgeAgent Address\n        if (!IPort(_localPortAddress).isBridgeAgent(newBridgeAgent)) {\n            revert UnrecognizedBridgeAgent();\n        }\n\n        // Encode Data\n        bytes memory params = abi.encode(newBridgeAgent, _rootBridgeAgent);\n\n        // Pack FuncId\n        bytes memory payload = abi.encodePacked(bytes1(0x04), params);\n\n        //Send Cross-Chain request"
    }
  ]
}