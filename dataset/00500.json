{
  "Title": "The reward calculation may be blocked until contract upgrade",
  "Content": "##### Description\nCurrently, the `NodeDelegator.initiateWithdrawRewards()` will [revert](https://github.com/Kelp-DAO/LRT-rsETH/blob/e75e9ef168a7b192abf76869977cd2ac8134849c/contracts/NodeDelegator.sol#L232) if the balance of the EigenPod exceeds 16 ETH. This is intended to distinguish between the staking rewards and the stake withdrawal.\n\nIt is expected that rewards will be less than 16 ETH; otherwise, something unexpected has occurred (i.e., the validator initiated the withdrawal) and should be resolved manually. It is an ad-hoc temporary solution that will require a contract upgrade by design.\n\nThis finding is rated HIGH as the reward calculation may be blocked until a manual contract upgrade.\n##### Recommendation\nWe recommend developing and upgrading to a long-term solution that does not lead to the freezing of the rewards.",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/NodeDelegator.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\n\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { IStrategy } from \"./interfaces/IStrategy.sol\";\nimport { IEigenStrategyManager } from \"./interfaces/IEigenStrategyManager.sol\";\nimport { IEigenDelayedWithdrawalRouter } from \"./interfaces/IEigenDelayedWithdrawalRouter.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport { IEigenPodManager } from \"./interfaces/IEigenPodManager.sol\";\nimport { IEigenPod, BeaconChainProofs, IBeaconDeposit } from \"./interfaces/IEigenPod.sol\";\n\n/// @title NodeDelegator Contract\n/// @notice The contract that handles the depositing of assets into strategies\ncontract NodeDelegator is INodeDelegator, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    /// @dev The EigenPod is created and owned by this contract\n    IEigenPod public eigenPod;\n    /// @dev Tracks the balance staked to validators and has yet to have the credentials verified with EigenLayer.\n    /// call verifyWithdrawalCredentialsAndBalance in EL to verify the validator credentials on EigenLayer\n    uint256 public stakedButUnverifiedNativeETH;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    function createEigenPod() external onlyLRTManager {\n        IEigenPodManager eigenPodManager = IEigenPodManager(lrtConfig.getContract(LRTConstants.EIGEN_POD_MANAGER));\n        eigenPodManager.createPod();\n        eigenPod = eigenPodManager.ownerToPod(address(this));\n\n        emit EigenPodCreated(address(eigenPod), address(this));\n    }\n\n    /// @notice Approves the maximum amount of an asset to the eigen strategy manager\n    /// @dev only supported assets can be deposited and only called by the LRT manager\n    /// @param asset the asset to deposit\n    function maxApproveToEigenStrategyManager(address asset)\n        external\n        override\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n        IERC20(asset).approve(eigenlayerStrategyManagerAddress, type(uint256).max);\n    }\n\n    /// @notice Deposits an asset lying in this NDC into its strategy\n    /// @dev only supported assets can be deposited and only called by the LRT manager\n    /// @param asset the asset to deposit\n    function depositAssetIntoStrategy(address asset)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address strategy = lrtConfig.assetStrategy(asset);\n        if (strategy == address(0)) {\n            revert StrategyIsNotSetForAsset();\n        }\n\n        IERC20 token = IERC20(asset);\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n\n        uint256 balance = token.balanceOf(address(this));\n\n        IEigenStrategyManager(eigenlayerStrategyManagerAddress).depositIntoStrategy(IStrategy(strategy), token, balance);\n\n        emit AssetDepositIntoStrategy(asset, strategy, balance);\n    }\n\n    /// @notice Transfers an asset back to the LRT deposit pool\n    /// @dev only supported assets can be transferred and only called by the LRT manager\n    /// @param asset the asset to transfer\n    /// @param amount the amount to transfer\n    function transferBackToLRTDepositPool(\n        address asset,\n        uint256 amount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address lrtDepositPool = lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);\n\n        bool success;\n        if (asset == LRTConstants.ETH_TOKEN) {\n            (success,) = payable(lrtDepositPool).call{ value: amount }(\"\");\n        } else {\n            success = IERC20(asset).transfer(lrtDepositPool, amount);\n        }\n\n        if (!success) {\n            revert TokenTransferFailed();\n        }\n    }\n\n    /// @notice Fetches balance of all assets staked in eigen layer through this contract\n    /// @return assets the assets that the node delegator has deposited into strategies\n    /// @return assetBalances the balances of the assets that the node delegator has deposited into strategies\n    function getAssetBalances()\n        external\n        view\n        override\n        returns (address[] memory assets, uint256[] memory assetBalances)\n    {\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n\n        (IStrategy[] memory strategies,) =\n            IEigenStrategyManager(eigenlayerStrategyManagerAddress).getDeposits(address(this));\n\n        uint256 strategiesLength = strategies.length;\n        assets = new address[](strategiesLength);\n        assetBalances = new uint256[](strategiesLength);\n\n        for (uint256 i = 0; i < strategiesLength;) {\n            assets[i] = address(IStrategy(strategies[i]).underlyingToken());\n            assetBalances[i] = IStrategy(strategies[i]).userUnderlyingView(address(this));\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Returns the balance of an asset that the node delegator has deposited into the strategy\n    /// @param asset the asset to get the balance of\n    /// @return stakedBalance the balance of the asset\n    function getAssetBalance(address asset) external view override returns (uint256) {\n        address strategy = lrtConfig.assetStrategy(asset);\n        if (strategy == address(0)) {\n            return 0;\n        }\n\n        return IStrategy(strategy).userUnderlyingView(address(this));\n    }\n\n    /// @dev Returns the balance of an asset that the node delegator has deposited into its EigenPod strategy\n    function getETHEigenPodBalance() external view override returns (uint256 ethStaked) {\n        // TODO: Implement functionality to manage pending withdrawals and accommodate negative shares once withdrawal\n        // feature is activated. Additionally, ensure verification of both staked but unverified and staked and verified\n        // ETH native supply NDCs as provided to Eigenlayer.\n        ethStaked = stakedButUnverifiedNativeETH;\n    }\n\n    /// @notice Stake ETH from NDC into EigenLayer. it calls the stake function in the EigenPodManager\n    /// which in turn calls the stake function in the EigenPod\n    /// @param pubkey The pubkey of the validator\n    /// @param signature The signature of the validator\n    /// @param depositDataRoot The deposit data root of the validator\n    /// @dev Only LRT Operator should call this function\n    /// @dev Exactly 32 ether is allowed, hence it is hardcoded\n    /// @dev offchain checks withdraw credentials authenticity\n    function stake32Eth(\n        bytes calldata pubkey,\n        bytes calldata signature,\n        bytes32 depositDataRoot\n    )\n        external\n        whenNotPaused\n        onlyLRTOperator\n    {\n        IEigenPodManager eigenPodManager = IEigenPodManager(lrtConfig.getContract(LRTConstants.EIGEN_POD_MANAGER));\n        eigenPodManager.stake{ value: 32 ether }(pubkey, signature, depositDataRoot);\n\n        // tracks staked but unverified native ETH\n        stakedButUnverifiedNativeETH += 32 ether;\n\n        emit ETHStaked(pubkey, 32 ether);\n    }\n\n    /// @notice Stake ETH from NDC into EigenLayer\n    /// @param pubkey The pubkey of the validator\n    /// @param signature The signature of the validator\n    /// @param depositDataRoot The deposit data root of the validator\n    /// @param expectedDepositRoot The expected deposit data root, which is computed offchain\n    /// @dev Only LRT Operator should call this function\n    /// @dev Exactly 32 ether is allowed, hence it is hardcoded\n    /// @dev offchain checks withdraw credentials authenticity\n    /// @dev compares expected deposit root with actual deposit root\n    function stake32EthValidated(\n        bytes calldata pubkey,\n        bytes calldata signature,\n        bytes32 depositDataRoot,\n        bytes32 expectedDepositRoot\n    )\n        external\n        whenNotPaused\n        onlyLRTOperator\n    {\n        IBeaconDeposit depositContract = eigenPod.ethPOS();\n        bytes32 actualDepositRoot = depositContract.get_deposit_root();\n        if (expectedDepositRoot != actualDepositRoot) {\n            revert InvalidDepositRoot(expectedDepositRoot, actualDepositRoot);\n        }\n        IEigenPodManager eigenPodManager = IEigenPodManager(lrtConfig.getContract(LRTConstants.EIGEN_POD_MANAGER));\n        eigenPodManager.stake{ value: 32 ether }(pubkey, signature, depositDataRoot);\n\n        // tracks staked but unverified native ETH\n        stakedButUnverifiedNativeETH += 32 ether;\n\n        emit ETHStaked(pubkey, 32 ether);\n    }\n\n    /// @dev initiate a delayed withdraw of the ETH before the eigenpod is verified\n    /// which will be available to claim after withdrawalDelay blocks\n    function initiateWithdrawRewards() external onlyLRTOperator {\n        uint256 eigenPodBalance = address(eigenPod).balance;\n        uint256 ethValidatorMinBalanceThreshold = 16 ether;\n        if (eigenPodBalance > ethValidatorMinBalanceThreshold) {\n            revert InvalidRewardAmount();\n        }\n\n        eigenPod.withdrawBeforeRestaking();\n        emit ETHRewardsWithdrawInitiated(eigenPodBalance);\n    }\n\n    /// @dev claims back the withdrawal amount initiated to this nodeDelegator contract\n    /// once withdrawal amount is claimable\n    function claimRewards(uint256 maxNumberOfDelayedWithdrawalsToClaim) external onlyLRTOperator {\n        uint256 balanceBefore = address(this).balance;\n        address delayedRouterAddr = eigenPod.delayedWithdrawalRouter();\n        IEigenDelayedWithdrawalRouter elDelayedRouter = IEigenDelayedWithdrawalRouter(delayedRouterAddr);\n        elDelayedRouter.claimDelayedWithdrawals(address(this), maxNumberOfDelayedWithdrawalsToClaim);\n        uint256 balanceAfter = address(this).balance;\n\n        emit ETHRewardsClaimed(balanceAfter - balanceBefore);\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n\n    /// @dev allow NodeDelegator to receive ETH\n    function sendETHFromDepositPoolToNDC() external payable override {\n        // only allow LRT deposit pool to send ETH to this contract\n        address lrtDepositPool = lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);\n        if (msg.sender != lrtDepositPool) {\n            revert InvalidETHSender();\n        }\n\n        emit ETHDepositFromDepositPool(msg.value);\n    }\n\n    /// @dev allow NodeDelegator to receive ETH\n    receive() external payable { }\n}"
    }
  ]
}