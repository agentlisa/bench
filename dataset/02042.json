{
  "Title": "H-1: Funds can be stolen because of incorrect update to `ownerToRollOverQueueIndex` for existing rollovers",
  "Content": "# Issue H-1: Funds can be stolen because of incorrect update to `ownerToRollOverQueueIndex` for existing rollovers \n\nSource: https://github.com/sherlock-audit/2023-03-Y2K-judging/issues/2 \n\n## Found by \n0Kage, 0x52, 0xMojito, 0xPkhatri, 0xRobocop, 0xnirlin, AlexCzm, Aymen0909, Bauer, Ch\\_301, Dug, ElKu, Emmanuel, HonorLt, Junnon, Respx, TrungOre, VAD37, ast3ros, auditor0517, berndartmueller, bin2chen, cccz, charlesjhongc, ck, climber2002, csanuragjain, datapunk, evan, hickuphh3, holyhansss, iglyx, immeas, jasonxiale, joestakey, kenzo, libratus, ltyu, minhtrng, mstpr-brainbot, ne0n, pfapostol, roguereddwarf, shaka, sinarette, spyrosonic10, toshii, twicek, volodya, warRoom, yixxas, zeroknots\n\n## Summary\nIn the case where the owner has an existing rollover, the `ownerToRollOverQueueIndex` incorrectly updates to the last queue index. This causes the `notRollingOver` check to be performed on the incorrect `_id`, which then allows the depositor to withdraw funds that should've been locked.\n\n## Vulnerability Detail\nIn `enlistInRollover()`, if the user has an existing rollover, it overwrites the existing data:\n```solidity\nif (ownerToRollOverQueueIndex[_receiver] != 0) {\n  // if so, update the queue\n  uint256 index = getRolloverIndex(_receiver);\n  rolloverQueue[index].assets = _assets;\n  rolloverQueue[index].epochId = _epochId;\n```\n\nHowever, regardless of whether the user has an existing rollover, the `ownerToRolloverQueueIndex` points to the last item in the queue:\n```solidity\nownerToRollOverQueueIndex[_receiver] = rolloverQueue.length;\n```\n\nThus, the `notRollingOver` modifier will check the incorrect item for users with existing rollovers:\n```solidity\nQueueItem memory item = rolloverQueue[getRolloverIndex(_receiver)];\nif (\n    item.epochId == _epochId &&\n    (balanceOf(_receiver, _epochId) - item.assets) < _assets\n) revert AlreadyRollingOver();\n```\nallowing the user to withdraw assets that should've been locked.\n\n## Impact\nUsers are able to withdraw assets that should've been locked for rollovers.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Carousel/Carousel.sol#L252-L257\nhttps://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Carousel/Carousel.sol#L268\nhttps://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Carousel/Carousel.sol#L755-L760\n\n## Tool used\nManual Review\n\n## Recommendation\nThe `ownerToRollOverQueueIndex` should be pointing to the last item in the queue in the `else` case only: when the user does not have an existing rollover queue item.\n```diff\n} else {\n  // if not, add to queue\n  rolloverQueue.push(\n      QueueItem({\n          assets: _assets,\n          receiver: _receiver,\n          epochId: _epochId\n      })\n  );\n+ ownerToRollOverQueueIndex[_receiver] = rolloverQueue.length;\n}\n- ownerToRollOverQueueIndex[_receiver] = rolloverQueue.length;\n```\n\n\n\n## Discussion\n\n**3xHarry**\n\ngood catch\n\n**3xHarry**\n\nfix PR: https://github.com/Y2K-Finance/Earthquake/pull/128\n\n**IAm0x52**\n\nFix looks good. Assigning index has been moved inside else block\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/57",
  "Code": [
    {
      "filename": "Earthquake/src/v2/Carousel/Carousel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../VaultV2.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\n/// @author Y2K Finance Team\n\ncontract Carousel is VaultV2 {\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint256;\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES AND STORAGE\n    //////////////////////////////////////////////////////////////*/\n    // Earthquake parameters\n    uint256 public relayerFee;\n    uint256 public depositFee;\n    IERC20 public immutable emissionsToken;\n\n    mapping(address => uint256) public ownerToRollOverQueueIndex;\n    QueueItem[] public rolloverQueue;\n    QueueItem[] public depositQueue;\n    mapping(uint256 => uint256) public rolloverAccounting;\n    mapping(uint256 => mapping(address => uint256)) public _emissionsBalances;\n    mapping(uint256 => uint256) public emissions;\n\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice constructor\n        @param _data  Carousel.ConstructorArgs struct containing the data to be used in the constructor;\n     */\n    constructor(ConstructorArgs memory _data)\n        VaultV2(\n            _data.isWETH,\n            _data.assetAddress,\n            _data.name,\n            _data.symbol,\n            _data.tokenURI,\n            _data.token,\n            _data.strike,\n            _data.controller,\n            _data.treasury\n        )\n    {\n        if (_data.relayerFee < 10000) revert RelayerFeeToLow();\n        if (_data.depositFee > 250) revert BPSToHigh();\n        if (_data.emissionsToken == address(0)) revert AddressZero();\n        emissionsToken = IERC20(_data.emissionsToken);\n        relayerFee = _data.relayerFee;\n        depositFee = _data.depositFee;\n\n        // set epoch 0 to be allways available to deposit into Queue\n        epochExists[0] = true;\n        epochConfig[0] = EpochConfig({\n            epochBegin: 10**10 * 40 - 7 days,\n            epochEnd: 10**10 * 40,\n            epochCreation: uint40(block.timestamp)\n        });\n        epochs.push(0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Deposit function\n        @param  _id epoch id\n        @param _assets   uint256 of how many assets you want to deposit;\n        @param _receiver  address of the receiver of the shares provided by this function, that represent the ownership of the deposited asset;\n     */\n    function deposit(\n        uint256 _id,\n        uint256 _assets,\n        address _receiver\n    )\n        public\n        override(VaultV2)\n        epochIdExists(_id)\n        epochHasNotStarted(_id)\n        minRequiredDeposit(_assets)\n        nonReentrant\n    {\n        // make sure that epoch exists\n        // epoch has not started (valid deposit period)\n        // amount is enough to pay for relayer fees in case of queue deposit\n        // function is not reentrant\n        if (_receiver == address(0)) revert AddressZero();\n\n        _asset().safeTransferFrom(msg.sender, address(this), _assets);\n        // handles deposit logic for all cases (direct deposit, late deposit (if activated), queue deposit)\n        _deposit(_id, _assets, _receiver);\n    }\n\n    function depositETH(uint256 _id, address _receiver)\n        external\n        payable\n        override(VaultV2)\n        minRequiredDeposit(msg.value)\n        epochIdExists(_id)\n        epochHasNotStarted(_id)\n        nonReentrant\n    {\n        if (!isWETH) revert CanNotDepositETH();\n        if (_receiver == address(0)) revert AddressZero();\n\n        IWETH(address(asset)).deposit{value: msg.value}();\n\n        uint256 assets = msg.value;\n\n        _deposit(_id, assets, _receiver);\n    }\n\n    /**\n    @notice Withdraw entitled deposited assets, checking if a depeg event\n    @param  _id uint256 identifier of the epoch you want to withdraw from;\n    @param _assets   uint256 of how many assets you want to withdraw, this value will be used to calculate how many assets you are entitle to according the vaults claimTVL;\n    @param _receiver  Address of the receiver of the assets provided by this function, that represent the ownership of the transfered asset;\n    @param _owner    Address of the owner of these said assets;\n    @return shares How many shares the owner is entitled to, according to the conditions;\n     */\n    function withdraw(\n        uint256 _id,\n        uint256 _assets,\n        address _receiver,\n        address _owner\n    )\n        external\n        virtual\n        override(VaultV2)\n        epochIdExists(_id)\n        epochHasEnded(_id)\n        notRollingOver(_owner, _id, _assets)\n        nonReentrant\n        returns (uint256 shares)\n    {\n        // make sure that epoch exists\n        // epoch is resolved\n        // owners funds are not locked in rollover\n        // function is not reentrant\n        if (_receiver == address(0)) revert AddressZero();\n\n        if (\n            msg.sender != _owner &&\n            isApprovedForAll(_owner, msg.sender) == false\n        ) revert OwnerDidNotAuthorize(msg.sender, _owner);\n\n        _burn(_owner, _id, _assets);\n        _burnEmissions(_owner, _id, _assets);\n        uint256 entitledShares;\n        uint256 entitledEmissions = previewEmissionsWithdraw(_id, _assets);\n        if (epochNull[_id] == false) {\n            entitledShares = previewWithdraw(_id, _assets);\n        } else {\n            entitledShares = _assets;\n        }\n        if (entitledShares > 0) {\n            SemiFungibleVault.asset.safeTransfer(_receiver, entitledShares);\n        }\n        if (entitledEmissions > 0) {\n            emissionsToken.safeTransfer(_receiver, entitledEmissions);\n        }\n\n        emit Withdraw(\n            msg.sender,\n            _receiver,\n            _owner,\n            _id,\n            _assets,\n            entitledShares\n        );\n\n        return entitledShares;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        TRANSFER LOGIC\n        add notRollingOver modifier to all transfer functions      \n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public override notRollingOver(from, id, amount) {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n        // emissions transfer\n        uint256 fromBalance = _emissionsBalances[id][from];\n        require(\n            fromBalance >= amount,\n            \"ERC1155: insufficient balance for transfer\"\n        );\n        unchecked {\n            _emissionsBalances[id][from] = fromBalance - amount;\n        }\n        _emissionsBalances[id][to] += amount;\n        emit TransferSingleEmissions(_msgSender(), from, to, id, amount);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address, /*from*/\n        address, /*to*/\n        uint256[] memory, /*ids*/\n        uint256[] memory, /*amounts*/\n        bytes memory /*data*/\n    ) public pure override {\n        revert();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Carousel Rollover Logic\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice enlists in rollover queue\n        @dev user needs to have >= _assets in epoch (_epochId)\n        @param  _epochId epoch id\n        @param _assets   uint256 of how many assets deposited;\n        @param _receiver  address of the receiver of the emissions;\n     */\n    function enlistInRollover(\n        uint256 _epochId,\n        uint256 _assets,\n        address _receiver\n    ) public epochIdExists(_epochId) minRequiredDeposit(_assets) {\n        // check if sender is approved by owner\n        if (\n            msg.sender != _receiver &&\n            isApprovedForAll(_receiver, msg.sender) == false\n        ) revert OwnerDidNotAuthorize(msg.sender, _receiver);\n        // check if user has enough balance\n        if (balanceOf(_receiver, _epochId) < _assets)\n            revert InsufficientBalance();\n\n        // check if user has already queued up a rollover\n        if (ownerToRollOverQueueIndex[_receiver] != 0) {\n            // if so, update the queue\n            uint256 index = getRolloverIndex(_receiver);\n            rolloverQueue[index].assets = _assets;\n            rolloverQueue[index].epochId = _epochId;\n        } else {\n            // if not, add to queue\n            rolloverQueue.push(\n                QueueItem({\n                    assets: _assets,\n                    receiver: _receiver,\n                    epochId: _epochId\n                })\n            );\n        }\n        ownerToRollOverQueueIndex[_receiver] = rolloverQueue.length;\n\n        emit RolloverQueued(_receiver, _assets, _epochId);\n    }\n\n    /** @notice delists from rollover queue\n        @param _owner address that is delisting from rollover queue\n     */\n    function delistInRollover(address _owner) public {\n        // check if user has already queued up a rollover\n        if (ownerToRollOverQueueIndex[_owner] == 0) revert NoRolloverQueued();\n        // check if sender is approved by owner\n        if (\n            msg.sender != _owner &&\n            isApprovedForAll(_owner, msg.sender) == false\n        ) revert OwnerDidNotAuthorize(msg.sender, _owner);\n\n        // swich the last item in the queue with the item to be removed\n        uint256 index = getRolloverIndex(_owner);\n        uint256 length = rolloverQueue.length;\n        if (index == length - 1) {\n            // if only one item in queue\n            rolloverQueue.pop();\n            delete ownerToRollOverQueueIndex[_owner];\n        } else {\n            // overwrite the item to be removed with the last item in the queue\n            rolloverQueue[index] = rolloverQueue[length - 1];\n            // remove the last item in the queue\n            rolloverQueue.pop();\n            // update the index of prev last user ( mapping index is allways array index + 1)\n            ownerToRollOverQueueIndex[rolloverQueue[index].receiver] =\n                index +\n                1;\n            // remove receiver from index mapping\n            delete ownerToRollOverQueueIndex[_owner];\n        }\n    }\n\n    /** @notice mints deposit in rollover queue\n        @param _epochId epoch id\n        @param _operations  uint256 of how many operations to execute;\n     */\n    function mintDepositInQueue(uint256 _epochId, uint256 _operations)\n        external\n        epochIdExists(_epochId)\n        epochHasNotStarted(_epochId)\n        nonReentrant\n    {\n        // make sure there is already a new epoch set\n        // epoch has not started\n        QueueItem[] memory queue = depositQueue;\n        uint256 length = depositQueue.length;\n\n        // dont allow minting if epochId is 0\n        if (_epochId == 0) revert InvalidEpochId();\n\n        if (length == 0) revert OverflowQueue();\n        // relayers can always input a very big number to mint all deposit queues, without the need to read depostQueue length first\n        if (_operations > length) _operations = length;\n\n        // queue is executed from the tail to the head\n        // get last index of queue\n        uint256 i = length - 1;\n        while ((length - _operations) <= i) {\n            // this loop impelements FILO (first in last out) stack to reduce gas cost and improve code readability\n            // changing it to FIFO (first in first out) would require more code changes and would be more expensive\n            _mintShares(\n                queue[i].receiver,\n                _epochId,\n                queue[i].assets - relayerFee\n            );\n            emit Deposit(\n                msg.sender,\n                queue[i].receiver,\n                _epochId,\n                queue[i].assets - relayerFee\n            );\n            depositQueue.pop();\n            if (i == 0) break;\n            unchecked {\n                i--;\n            }\n        }\n\n        emit RelayerMinted(_epochId, _operations);\n\n        asset.safeTransfer(msg.sender, _operations * relayerFee);\n    }\n\n    /** @notice mints for rollovers\n        @param _epochId epoch id\n        @param _operations  uint256 of how many operations to execute;\n     */\n    function mintRollovers(uint256 _epochId, uint256 _operations)\n        external\n        epochIdExists(_epochId)\n        epochHasNotStarted(_epochId)\n        nonReentrant\n    {\n        // epoch has not started\n        // dont allow minting if epochId is 0\n        if (_epochId == 0) revert InvalidEpochId();\n\n        uint256 length = rolloverQueue.length;\n        uint256 index = rolloverAccounting[_epochId];\n\n        // revert if queue is empty or operations are more than queue length\n        if (length == 0) revert OverflowQueue();\n\n        if (_operations > length || (index + _operations) > length)\n            _operations = length - index;\n\n        // prev epoch is resolved\n        if (!epochResolved[epochs[epochs.length - 2]])\n            revert EpochNotResolved();\n\n        // make sure epoch is next epoch\n        if (epochs[epochs.length - 1] != _epochId) revert InvalidEpochId();\n\n        QueueItem[] memory queue = rolloverQueue;\n\n        // account for how many operations have been done\n        uint256 prevIndex = index;\n        uint256 executions = 0;\n\n        while ((index - prevIndex) < (_operations)) {\n            // only roll over if last epoch is resolved\n            if (epochResolved[queue[index].epochId]) {\n                uint256 entitledShares = previewWithdraw(\n                    queue[index].epochId,\n                    queue[index].assets\n                );\n                // mint only if user won epoch he is rolling over\n                if (entitledShares > queue[index].assets) {\n                    // skip the rollover for the user if the assets cannot cover the relayer fee instead of revert.\n                    if (queue[index].assets < relayerFee) {\n                        index++;\n                        continue;\n                    }\n                    // @note we know shares were locked up to this point\n                    _burn(\n                        queue[index].receiver,\n                        queue[index].epochId,\n                        queue[index].assets\n                    );\n                    // transfer emission tokens out of contract otherwise user could not access them as vault shares are burned\n                    _burnEmissions(\n                        queue[index].receiver,\n                        queue[index].epochId,\n                        queue[index].assets\n                    );\n                    // @note emission token is a known token which has no before transfer hooks which makes transfer safer\n                    emissionsToken.safeTransfer(\n                        queue[index].receiver,\n                        previewEmissionsWithdraw(\n                            queue[index].epochId,\n                            queue[index].assets\n                        )\n                    );\n\n                    emit Withdraw(\n                        msg.sender,\n                        queue[index].receiver,\n                        queue[index].receiver,\n                        _epochId,\n                        queue[index].assets,\n                        entitledShares\n                    );\n                    uint256 assetsToMint = queue[index].assets - relayerFee;\n                    _mintShares(queue[index].receiver, _epochId, assetsToMint);\n                    emit Deposit(\n                        msg.sender,\n                        queue[index].receiver,\n                        _epochId,\n                        assetsToMint\n                    );\n                    rolloverQueue[index].assets = assetsToMint;\n                    rolloverQueue[index].epochId = _epochId;\n                    // only pay relayer for successful mints\n                    executions++;\n                }\n            }\n            index++;\n        }\n\n        if (executions > 0) rolloverAccounting[_epochId] = index;\n\n        if (executions * relayerFee > 0)\n            asset.safeTransfer(msg.sender, executions * relayerFee);\n\n        emit RelayerMinted(_epochId, executions);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        INTERNAL MUTATIVE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice deposits assets into epoch\n        @param _id epoch id\n        @param _assets amount of assets to deposit\n        @param _receiver address of receiver\n     */\n    function _deposit(\n        uint256 _id,\n        uint256 _assets,\n        address _receiver\n    ) internal {\n        // mint logic, either in queue or direct deposit\n        if (_id != 0) {\n            uint256 assetsToDeposit = _assets;\n\n            if (depositFee > 0) {\n                (uint256 maxX, , uint256 minX) = getEpochConfig(_id);\n                // deposit fee is calcualted linearly between time of epoch creation and epoch starting (deposit window)\n                // this is because late depositors have an informational advantage\n                uint256 fee = _calculateFeePercent(int256(minX), int256(maxX));\n                // min minRequiredDeposit modifier ensures that _assets has high enough value to not devide by 0\n                // 0.5% = multiply by 10000 then divide by 50\n                uint256 feeAmount = _assets.mulDivDown(fee, 10000);\n                assetsToDeposit = _assets - feeAmount;\n                _asset().safeTransfer(treasury, feeAmount);\n            }\n\n            _mintShares(_receiver, _id, assetsToDeposit);\n\n            emit Deposit(msg.sender, _receiver, _id, _assets);\n        } else {\n            depositQueue.push(\n                QueueItem({assets: _assets, receiver: _receiver, epochId: _id})\n            );\n\n            emit DepositInQueue(msg.sender, _receiver, _id, _assets);\n        }\n    }\n\n    /**\n     * @notice calculates fee percent based on time\n     * @param minX min x value\n     * @param maxX max x value\n     */\n    function _calculateFeePercent(int256 minX, int256 maxX)\n        internal\n        view\n        returns (uint256 _y)\n    {\n        /**\n         * Two Point Form\n         * https://www.cuemath.com/geometry/two-point-form/\n         * https://ethereum.stackexchange.com/a/143172\n         */\n        // minY will always be 0 thats why is (maxY - minY) shorten to maxY\n        int256 maxY = int256(depositFee) * int256(FixedPointMathLib.WAD);\n        _y = uint256( // cast to uint256\n            ((((maxY) / (maxX - minX)) * (int256(block.timestamp) - maxX)) +\n                maxY) / (int256(FixedPointMathLib.WAD)) // two point math // scale down\n        );\n    }\n\n    /** @notice mints shares of vault for user\n        @param to address of receiver\n        @param id epoch id\n        @param amount amount of shares to mint\n     */\n    function _mintShares(\n        address to,\n        uint256 id,\n        uint256 amount\n    ) internal {\n        _mint(to, id, amount, EMPTY);\n        _mintEmissions(to, id, amount);\n    }\n\n    /** @notice mints emission shares based of vault shares for user\n        @param to address of receiver\n        @param id epoch id\n        @param amount amount of shares to mint\n     */\n    function _mintEmissions(\n        address to,\n        uint256 id,\n        uint256 amount\n    ) internal {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        _emissionsBalances[id][to] += amount;\n        emit TransferSingleEmissions(_msgSender(), address(0), to, id, amount);\n    }\n\n    /** @notice burns emission shares of vault for user\n        @param from address of sender\n        @param id epoch id\n        @param amount amount of shares to burn\n     */\n    function _burnEmissions(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        uint256 fromBalance = _emissionsBalances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _emissionsBalances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingleEmissions(\n            _msgSender(),\n            from,\n            address(0),\n            id,\n            amount\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice sets emissions\n     * @param _epochId epoch id\n     * @param _emissionsRate emissions rate\n     */\n    function setEmissions(uint256 _epochId, uint256 _emissionsRate)\n        external\n        onlyFactory\n        epochIdExists(_epochId)\n    {\n        emissions[_epochId] = _emissionsRate;\n    }\n\n    /** @notice changes relayer fee\n     * @param _relayerFee relayer fee\n     */\n    function changeRelayerFee(uint256 _relayerFee) external onlyFactory {\n        relayerFee = _relayerFee;\n    }\n\n    /** @notice changes deposit fee\n     * @param _depositFee deposit fee\n     */\n    function changeDepositFee(uint256 _depositFee) external onlyFactory {\n        depositFee = _depositFee;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Getter Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice returns the rollover index\n     * @param _owner address of the owner\n     * @return rollover index\n     */\n    function getRolloverIndex(address _owner) public view returns (uint256) {\n        return ownerToRollOverQueueIndex[_owner] - 1;\n    }\n\n    /** @notice returns the emissions to withdraw\n     * @param _id epoch id\n     * @param _assets amount of assets to withdraw\n     * @return entitledAmount amount of emissions to withdraw\n     */\n    function previewEmissionsWithdraw(uint256 _id, uint256 _assets)\n        public\n        view\n        returns (uint256 entitledAmount)\n    {\n        entitledAmount = _assets.mulDivDown(emissions[_id], finalTVL[_id]);\n    }\n\n    /** @notice returns the deposit queue length\n     * @return queue length for the deposit\n     */\n    function getDepositQueueLenght() public view returns (uint256) {\n        return depositQueue.length;\n    }\n\n    /** @notice returns the queue length for the rollover\n     * @return queue length for the rollover\n     */\n    function getRolloverQueueLenght() public view returns (uint256) {\n        return rolloverQueue.length;\n    }\n\n    /** @notice returns the total value locked in the rollover queue\n     * @return tvl total value locked in the rollover queue\n     */\n    function getRolloverTVL(uint256 _epochId)\n        public\n        view\n        returns (uint256 tvl)\n    {\n        for (uint256 i = 0; i < rolloverQueue.length; i++) {\n            if (\n                rolloverQueue[i].epochId == _epochId &&\n                (previewWithdraw(\n                    rolloverQueue[i].epochId,\n                    rolloverQueue[i].assets\n                ) > rolloverQueue[i].assets)\n            ) {\n                tvl += rolloverQueue[i].assets;\n            }\n        }\n    }\n\n    /** @notice returns users rollover balance and epoch which is rolling over\n     * @param _owner address of the user\n     * @return balance balance of the user\n     * @return epochId epoch id\n     */\n    function getRolloverBalance(address _owner)\n        public\n        view\n        returns (uint256 balance, uint256 epochId)\n    {\n        balance = rolloverQueue[getRolloverIndex(_owner)].assets;\n        epochId = rolloverQueue[getRolloverIndex(_owner)].epochId;\n    }\n\n    /** @notice returns the total value locked in the deposit queue\n     * @return tvl total value locked in the deposit queue\n     */\n    function getDepositQueueTVL() public view returns (uint256 tvl) {\n        for (uint256 i = 0; i < depositQueue.length; i++) {\n            tvl += depositQueue[i].assets;\n        }\n    }\n\n    /** @notice returns the total emissions balance\n     * @return totalEmissions total emissions balance\n     */\n    function balanceOfEmissions(address _owner, uint256 _id)\n        public\n        view\n        returns (uint256)\n    {\n        return _emissionsBalances[_id][_owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    struct QueueItem {\n        uint256 assets;\n        address receiver;\n        uint256 epochId;\n    }\n\n    struct ConstructorArgs {\n        bool isWETH;\n        address assetAddress;\n        string name;\n        string symbol;\n        string tokenURI;\n        address token;\n        uint256 strike;\n        address controller;\n        address treasury;\n        address emissionsToken;\n        uint256 relayerFee;\n        uint256 depositFee;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice checks if deposit is greater than relayer fee\n     * @param _assets amount of assets to deposit\n     */\n    modifier minRequiredDeposit(uint256 _assets) {\n        if (_assets < relayerFee) revert MinDeposit();\n        _;\n    }\n\n    /** @notice checks if not rolling over\n     * @param _receiver address of the receiver\n     * @param _epochId epoch id\n     * @param _assets amount of assets to deposit\n     */\n    modifier notRollingOver(\n        address _receiver,\n        uint256 _epochId,\n        uint256 _assets\n    ) {\n        if (ownerToRollOverQueueIndex[_receiver] != 0) {\n            QueueItem memory item = rolloverQueue[getRolloverIndex(_receiver)];\n            if (\n                item.epochId == _epochId &&\n                (balanceOf(_receiver, _epochId) - item.assets) < _assets\n            ) revert AlreadyRollingOver();\n        }\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MinDeposit();\n    error OverflowQueue();\n    error AlreadyRollingOver();\n    error InvalidEpochId();\n    error InsufficientBalance();\n    error NoRolloverQueued();\n    error RelayerFeeToLow();\n    error BPSToHigh();\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice emitted when a deposit is queued\n     * @param sender the address of the sender\n     * @param receiver the address of the receiver\n     * @param epochId the epoch id\n     * @param assets the amount of assets\n     */\n    event DepositInQueue(\n        address indexed sender,\n        address indexed receiver,\n        uint256 epochId,\n        uint256 assets\n    );\n\n    /** @notice emitted when shares are minted by relayer\n     * @param epochId the epoch id\n     * @param operations how many positions were minted\n     */\n    event RelayerMinted(uint256 epochId, uint256 operations);\n\n    /** @notice emitted when a rollover is queued\n     * @param sender the address of the sender\n     * @param assets the amount of assets\n     * @param epochId the epoch id\n     */\n    event RolloverQueued(\n        address indexed sender,\n        uint256 assets,\n        uint256 epochId\n    );\n\n    /** @notice emitted when emissions are transfered\n     * @param operator the address of the operator\n     * @param from the address of the sender\n     * @param to the address of the receiver\n     * @param id the id of the emissions\n     * @param value the amount of emissions\n     */\n    event TransferSingleEmissions(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n}"
    },
    {
      "filename": "Earthquake/src/v2/Carousel/Carousel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../VaultV2.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\n/// @author Y2K Finance Team\n\ncontract Carousel is VaultV2 {\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint256;\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES AND STORAGE\n    //////////////////////////////////////////////////////////////*/\n    // Earthquake parameters\n    uint256 public relayerFee;\n    uint256 public depositFee;\n    IERC20 public immutable emissionsToken;\n\n    mapping(address => uint256) public ownerToRollOverQueueIndex;\n    QueueItem[] public rolloverQueue;\n    QueueItem[] public depositQueue;\n    mapping(uint256 => uint256) public rolloverAccounting;\n    mapping(uint256 => mapping(address => uint256)) public _emissionsBalances;\n    mapping(uint256 => uint256) public emissions;\n\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice constructor\n        @param _data  Carousel.ConstructorArgs struct containing the data to be used in the constructor;\n     */\n    constructor(ConstructorArgs memory _data)\n        VaultV2(\n            _data.isWETH,\n            _data.assetAddress,\n            _data.name,\n            _data.symbol,\n            _data.tokenURI,\n            _data.token,\n            _data.strike,\n            _data.controller,\n            _data.treasury\n        )\n    {\n        if (_data.relayerFee < 10000) revert RelayerFeeToLow();\n        if (_data.depositFee > 250) revert BPSToHigh();\n        if (_data.emissionsToken == address(0)) revert AddressZero();\n        emissionsToken = IERC20(_data.emissionsToken);\n        relayerFee = _data.relayerFee;\n        depositFee = _data.depositFee;\n\n        // set epoch 0 to be allways available to deposit into Queue\n        epochExists[0] = true;\n        epochConfig[0] = EpochConfig({\n            epochBegin: 10**10 * 40 - 7 days,\n            epochEnd: 10**10 * 40,\n            epochCreation: uint40(block.timestamp)\n        });\n        epochs.push(0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Deposit function\n        @param  _id epoch id\n        @param _assets   uint256 of how many assets you want to deposit;\n        @param _receiver  address of the receiver of the shares provided by this function, that represent the ownership of the deposited asset;\n     */\n    function deposit(\n        uint256 _id,\n        uint256 _assets,\n        address _receiver\n    )\n        public\n        override(VaultV2)\n        epochIdExists(_id)\n        epochHasNotStarted(_id)\n        minRequiredDeposit(_assets)\n        nonReentrant\n    {\n        // make sure that epoch exists\n        // epoch has not started (valid deposit period)\n        // amount is enough to pay for relayer fees in case of queue deposit\n        // function is not reentrant\n        if (_receiver == address(0)) revert AddressZero();\n\n        _asset().safeTransferFrom(msg.sender, address(this), _assets);\n        // handles deposit logic for all cases (direct deposit, late deposit (if activated), queue deposit)\n        _deposit(_id, _assets, _receiver);\n    }\n\n    function depositETH(uint256 _id, address _receiver)\n        external\n        payable\n        override(VaultV2)\n        minRequiredDeposit(msg.value)\n        epochIdExists(_id)\n        epochHasNotStarted(_id)\n        nonReentrant\n    {\n        if (!isWETH) revert CanNotDepositETH();\n        if (_receiver == address(0)) revert AddressZero();\n\n        IWETH(address(asset)).deposit{value: msg.value}();\n\n        uint256 assets = msg.value;\n\n        _deposit(_id,"
    }
  ]
}