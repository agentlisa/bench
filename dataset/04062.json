{
  "Title": "[M01] contracts addresses in Governed and Directory can get out of sync",
  "Content": "The [`Directory` contract](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/Directory.sol) facilitates storing the addresses and the dependency map of the [core contracts of the system](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/Governed.sol#L26-L31) in the `contracts` data structure, which includes the `Escrow`, `Portfolios` `ERC1155Token`, and `ERC1155Trade` contracts. It also provides functionality for the owner to set these contract addresses in the forementioned core contracts through the [`_setDependencies` function defined in the `Governed` contract](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/Governed.sol#L38), which accesses the `Directory` contract to get relevant addresses as needed.\n\n\nThere are scenarios where the distinct `contracts` data structures in the [`Governed`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/Governed.sol) and [`Directory`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/Directory) contracts can get out of sync, which can cause several inconsistencies in the behavior of the system. This can happen in the following scenarios:\n\n\n* When calling the [`setContract` function](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/Governed.sol#L33) of the `Governed` contract, which is called by the [`setDependencies` function](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/Directory.sol#L29) of the `Directory` contract, it will update the `contracts` variable in the `Governed` contract but not the `contracts` variable in the `Directory` contract. Note that this is inconsistent with, for instance, the behavior of the [`_setDependencies`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/Governed.sol#L38) function called by the [`CashMarket` `initializeDependencies` function](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/CashMarket.sol#L41).\n* When calling the [`setContract` function](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/Directory.sol#L62) of the `Directory` contract, which does not update the `Governed` contract `contracts` variable, but instead relies on calling the [`setDependencies` function](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/Directory.sol#L29) of that same contract afterwards.\n\n\nConsider modifying the system so that there is only a single way for the `contracts` data structure of the `Directory` contract to be set. Additionally, consider enforcing that the `contracts` data structure in the `Governed` contract is appropriately updated when this happens, to avoid desynchronization between the different `contracts` data structures.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/utils/Governed.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../interface/IEscrowCallable.sol\";\nimport \"../interface/IPortfoliosCallable.sol\";\n\nimport \"../upgradeable/Ownable.sol\";\nimport \"../upgradeable/Initializable.sol\";\n\nimport \"./Directory.sol\";\n\n/**\n * @title Governed\n * A base contract to set the contract references on each contract.\n */\ncontract Governed is OpenZeppelinUpgradesOwnable, Initializable {\n    address public DIRECTORY;\n    mapping(uint256 => address) private contracts;\n\n    function initialize(address directory, address owner) public initializer {\n        _owner = owner;\n        DIRECTORY = directory;\n    }\n\n    enum CoreContracts {\n        Escrow,\n        Portfolios,\n        ERC1155Token,\n        ERC1155Trade\n    }\n\n    function setContract(CoreContracts name, address contractAddress) public {\n        require(msg.sender == DIRECTORY, $$(ErrorCode(UNAUTHORIZED_CALLER)));\n        contracts[uint256(name)] = contractAddress;\n    }\n\n    function _setDependencies(CoreContracts[] memory dependencies) internal {\n        address[] memory _contracts = Directory(DIRECTORY).getContracts(dependencies);\n        for (uint256 i; i < _contracts.length; i++) {\n            contracts[uint256(dependencies[i])] = _contracts[i];\n        }\n    }\n\n    function Escrow() internal view returns (IEscrowCallable) {\n        return IEscrowCallable(contracts[uint256(CoreContracts.Escrow)]);\n    }\n\n    function Portfolios() internal view returns (IPortfoliosCallable) {\n        return IPortfoliosCallable(contracts[uint256(CoreContracts.Portfolios)]);\n    }\n\n    function calledByEscrow() internal view returns (bool) {\n        return msg.sender == contracts[(uint256(CoreContracts.Escrow))];\n    }\n\n    function calledByPortfolios() internal view returns (bool) {\n        return msg.sender == contracts[(uint256(CoreContracts.Portfolios))];\n    }\n\n    function calledByERC1155Token() internal view returns (bool) {\n        return msg.sender == contracts[(uint256(CoreContracts.ERC1155Token))];\n    }\n\n    function calledByERC1155Trade() internal view returns (bool) {\n        return msg.sender == contracts[(uint256(CoreContracts.ERC1155Trade))];\n    }\n}"
    },
    {
      "filename": "contracts/utils/Directory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Governed.sol\";\nimport \"../upgradeable/Ownable.sol\";\nimport \"../upgradeable/Initializable.sol\";\n\n/**\n * @title Directory\n * Stores the addresses and the dependency map for the entire Notional system. Allows\n * for the system to upgrade other contracts in the system.\n */\ncontract Directory is OpenZeppelinUpgradesOwnable, Initializable {\n    mapping(uint256 => address) public contracts;\n    event SetContract(Governed.CoreContracts name, address contractAddress);\n\n    function initialize(address owner) external initializer {\n        _owner = owner;\n    }\n\n    /**\n     * Given a list of contracts that depend on \"name\", will set the current address on each one\n     * of those contracts.\n     *\n     * @param name the contract that dependencies depend on\n     * @param dependencies a list of contracts that depend on name\n     */\n    function setDependencies(\n        Governed.CoreContracts name,\n        Governed.CoreContracts[] calldata dependencies\n    ) external onlyOwner {\n        address contractAddress = contracts[uint256(name)];\n        for (uint256 i; i < dependencies.length; i++) {\n            Governed(contracts[uint256(dependencies[i])]).setContract(name, contractAddress);\n        }\n    }\n\n    /**\n     * Returns the addresses for a list of contracts. Used to set dependencies in non-core\n     * contracts. These contracts will have to be updated by governance if core contracts\n     * change.\n     *\n     * @param dependencies a list of core contracts required by the caller\n     * @return a list of addresses corresponding to the dependencies\n     */\n    function getContracts(Governed.CoreContracts[] calldata dependencies) external view returns (address[] memory) {\n        address[] memory contractAddresses = new address[](dependencies.length);\n        for (uint256 i; i < contractAddresses.length; i++) {\n            contractAddresses[i] = contracts[uint256(dependencies[i])];\n        }\n        return contractAddresses;\n    }\n\n    /**\n     * Sets the global contract address for the directory. Must be called before updating\n     * dependencies.\n     *\n     * @param name the enum of the contract\n     * @param contractAddress the address of the contract\n     */\n    function setContract(Governed.CoreContracts name, address contractAddress) external onlyOwner {\n        contracts[uint256(name)] = contractAddress;\n\n        emit SetContract(name, contractAddress);\n    }\n}"
    }
  ]
}