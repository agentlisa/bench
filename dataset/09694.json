{
  "Title": "[H-01] Reliance on `lifiData.receivingAssetId` can cause loss of funds",
  "Content": "_Submitted by 0xDjango, also found by hake, kirk-baird, rayn, and shenwilly_\n\n[GenericSwapFacet.sol#L23-L30](https://github.com/code-423n4/2022-03-lifinance/blob/699c2305fcfb6fe8862b75b26d1d8a2f46a551e6/src/Facets/GenericSwapFacet.sol#L23-L30)<br>\n\nIn the `swapTokensGeneric()` function, an arbitrary number of swaps can be performed from and to various tokens. However, the final balance that is sent to the user relies on `_lifiData.receivingAssetId` which has no use in the swapping functionality. LifiData is claimed to be used purely for analytical reasons per the comments to this function. If this value is input incorrectly, the swapped tokens will simply sit in the contract and be lost to the user.\n\n### Proof of Concept\n\nImagine a call to `swapTokensGeneric()` with the following parameters (excluding unnecessary parameters for this example):\n\n*   LifiData.receivingAssetId = '0xUSDC_ADDRESS'\n\nSingle SwapData array:\n\n*   LibSwap.SwapData.sendingAssetId = '0xWETH_ADDRESS'\n*   LibSwap.SwapData.receivingAssetId = '0xDAI_ADDRESS'\n\nSince the `receivingAssetId` from `SwapData` does not match the `receivingAssetId` from `LifiData`, the final funds will not be sent to the user after the swap is complete, based on the following lines of code:\n\n    uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);\n\n     _executeSwaps(_lifiData, _swapData);\n\n     uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;\n\n     LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);\n\nLines 1, 3, and 4 reference `LifiData.receivingAssetId` and handle the transfer of funds following the swaps. Line 2 performs the swap, referencing `SwapData.receivingAssetId` as can be seen in the `executeSwaps()` function definition:\n\n    function _executeSwaps(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) internal {\n            // Swap\n            for (uint8 i; i < _swapData.length; i++) {\n                require(\n                    ls.dexWhitelist[_swapData[i].approveTo] == true && ls.dexWhitelist[_swapData[i].callTo] == true,\n                    \"Contract call not allowed!\"\n                );\n\n                LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n            }\n        }\n\n### Recommended Mitigation Steps\n\nI recommend adding a check that `_lifiData.receivingAssetId` equals the `receivingAssetId` of the last index of the SwapData array, or simply use the `receivingAssetId` of the last index of the SwapData array for sending the final tokens to the user.\n\n**[H3xept (Li.Fi) commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/75#issuecomment-1088830379):**\n > Fixed in lifinance/lifi-contracts@52aa2b8ea3bc51de3e60784c00201e29103fe250\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/75#issuecomment-1100703191):**\n > Sponsor confirmed with fix.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-03-lifinance",
  "Code": [
    {
      "filename": "src/Facets/GenericSwapFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Generic Swap Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for swapping through ANY DEX\n * @dev Uses calldata to execute arbitrary methods on DEXs\n */\ncontract GenericSwapFacet is ILiFi, Swapper {\n    /* ========== Public Functions ========== */\n\n    /**\n     * @notice Performs a swap and that's it\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     */\n    function swapTokensGeneric(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) public payable {\n        uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;\n\n        LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n}"
    }
  ]
}