{
  "Title": "M-31: There is no price conversion between vault token and provider underlying token amounts in withdrawFromProtocol",
  "Content": "# Issue M-31: There is no price conversion between vault token and provider underlying token amounts in withdrawFromProtocol \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/135 \n\n## Found by \nBobface, HonorLt, Jeiwan, Met, c7e7eff, gogo, hyh, immeas, rvierdiiev, tives\n\n## Summary\n\nVault's withdrawFromProtocol() use its `vaultCurrency` based `_amount` argument without price conversion into Provider's underlying token, which is expected by the calcShares() call. As stablecoin prices can diverge, even massively, it isn't appropriate to assume price equality and use one amount instead of another.\n\nCurrently the final withdrawn amount is converted into `vaultCurrency`, but the withdrawal request is being made as if the `vaultCurrency` and Provider's underlying token are worth exactly the same, which almost always isn't the case.\n\n## Vulnerability Detail\n\nSuppose `vaultCurrency` is USDC, while Provider's underlying currency is USDT, Provider is AaveProvider.\n\nSuppose USDT is went through a major regulatory scrutiny and it is now priced at `0.8 USD`, but this is a locally stable situation and the major USDT Vaults now offer quite attractive returns, so Aave USDT was whitelisted.\n\nwithdrawFromProtocol() being called with `10^12` amount, which is a request to withdraw `10^6 USDC`, while AaveProvider's calcShares() will be called without price conversion, i.e. it will treat USDC amount supplied as USDT amount as it's the underlying token. Upon withdrawal the result will be converted in `vaultCurrency` USDC, always resulting in 20% less value than it was requested.\n\n## Impact\n\nWithdrawal from a protocol is a base functionality of the Vault and it will malfunction whenever vault currency and Provider's underlying currency aren't equally priced, which is the case along with market volatility.\n\nNet impact is ongoing Vault misbalancing, mostly mild, but sometimes substantial, which will alter the effective distribution vs desired and shift actual results from expected, leading to losses for protocol depositors.\n\n## Code Snippet\n\nwithdrawFromProtocol's input argument `_amount` is in `vaultCurrency`, and it is provided after decimals rebase, but without any cross-price conversion to calcShares():\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L303-L316\n\n```solidity\n  /// @notice Withdraw amount from underlying protocol\n  /// @dev shares = amount / PricePerShare\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount in VaultCurrency to withdraw\n  function withdrawFromProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    if (_amount <= 0) return;\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    _amount = (_amount * protocol.uScale) / uScale;\n    uint256 shares = IProvider(protocol.provider).calcShares(_amount, protocol.LPToken);\n    uint256 balance = IProvider(protocol.provider).balance(address(this), protocol.LPToken);\n```\n\nAll calcShares() methods expect `_amount` to be in the Provider underlying token, not in `vaultCurrency`:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/AaveProvider.sol#L88-L96\n\n```solidity\n  /// @notice Calculates how many shares are equal to the amount\n  /// @dev Aave exchangeRate is 1\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @param _aToken Address of protocol LP Token eg aUSDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _amount, address _aToken) external view override returns (uint256) {\n    uint256 shares = _amount / exchangeRate(_aToken);\n    return shares;\n  }\n```\n\n...\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L102-L111\n\n```solidity\n  /// @notice Calculates how many shares are equal to the amount\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _amount, address _cToken) external view override returns (uint256) {\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n    uint256 shares = (_amount * (10 ** (10 + decimals))) / exchangeRate(_cToken);\n    return shares;\n  }\n```\n\nCross-currency prices can vary even in the stablecoins case and whenever rebalancing coincides with cross-rate volatility spike the effective Vault weights will be disturbed.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider correcting for the current vault currency to underlying token exchange rate, for example:\n\n```solidity\nIController.UniswapParams uniParams = controller.getUniswapParams();\nIController.UniswapParams curveParams = controller.getCurveParams();\nunderlyingAmount = Swap.amountOutMultiSwap(\n    Swap.SwapInOut(_amount, address(vaultCurrency), protocol.underlying),\n    uniParams.quoter,\n    0\n);\nunderlyingAmount = (underlyingAmount * (10000 + curveParams.poolFee)) / 10000;\n```\n\nand using the `underlyingAmount` for `shares` estimation via calcShares().\n\n\n\n## Discussion\n\n**sjoerdsommen**\n\nDuplicate with #314 \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./Interfaces/IController.sol\";\nimport \"./Interfaces/IProvider.sol\";\n\nimport \"./VaultToken.sol\";\nimport \"./libraries/Swap.sol\";\n\ncontract Vault is ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  // state 0 Rebalance done and ready for xController to rebalance again\n  // state 1 Allocation amount received and ready to send funds over to xController\n  // state 2 Allocation amount 0 received => will receive funds from xController\n  // state 3 Allocation amount sent or received and ready to rebalance the vault itself\n  enum State {\n    Idle,\n    PushedUnderlying,\n    SendingFundsXChain,\n    WaitingForFunds,\n    RebalanceVault,\n    SendRewardsPerToken\n  }\n\n  IERC20 internal vaultCurrency;\n  IController internal controller;\n  State public state;\n\n  bool public deltaAllocationsReceived;\n\n  address private dao;\n  address private guardian;\n  address public vaultCurrencyAddr;\n  address public xController;\n\n  uint256 public vaultNumber;\n  uint256 public liquidityPerc;\n  uint256 public performanceFee;\n  uint256 public rebalancingPeriod;\n  uint256 public uScale;\n  uint256 public minimumPull;\n  int256 public marginScale;\n\n  // UNIX timestamp\n  uint256 public rebalanceInterval;\n  uint256 public lastTimeStamp;\n\n  // total underlying of all protocols in vault, excluding vault balance\n  uint256 public savedTotalUnderlying;\n\n  // total amount of funds the vault reserved for users that made a withdrawalRequest\n  uint256 internal reservedFunds;\n\n  // total number of allocated Derby tokens currently\n  int256 public totalAllocatedTokens;\n  // delta of the total number of Derby tokens allocated on next rebalancing\n  int256 private deltaAllocatedTokens;\n\n  string internal stateError = \"Wrong state\";\n\n  // (protocolNumber => currentAllocation): current allocations over the protocols\n  mapping(uint256 => int256) internal currentAllocations;\n\n  // (protocolNumber => deltaAllocation): delta of the portfolio on next rebalancing\n  mapping(uint256 => int256) internal deltaAllocations;\n\n  // historical reward per protocol per token, formula: TVL * yield * perfFee / totalLockedTokens\n  // (rebalancingPeriod => protocolId => rewardPerLockedToken)\n  mapping(uint256 => mapping(uint256 => int256)) public rewardPerLockedToken;\n\n  // (protocolNumber => lastPrice): last price of underlying protocol vault\n  mapping(uint256 => uint256) public lastPrices;\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"Vault: only DAO\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"only Guardian\");\n    _;\n  }\n\n  constructor(\n    uint256 _vaultNumber,\n    address _dao,\n    address _controller,\n    address _vaultCurrency,\n    uint256 _uScale\n  ) {\n    controller = IController(_controller);\n    vaultCurrency = IERC20(_vaultCurrency);\n\n    vaultNumber = _vaultNumber;\n    dao = _dao;\n    uScale = _uScale;\n    lastTimeStamp = block.timestamp;\n    minimumPull = 1_000_000;\n  }\n\n  /// @notice Withdraw from protocols on shortage in Vault\n  /// @dev Keeps on withdrawing until the Vault balance > _value\n  /// @param _value The total value of vaultCurrency an user is trying to withdraw.\n  /// @param _value The (value - current underlying value of this vault) is withdrawn from the underlying protocols.\n  function pullFunds(uint256 _value) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n\n      uint256 shortage = _value - vaultCurrency.balanceOf(address(this));\n      uint256 balanceProtocol = balanceUnderlying(i);\n\n      uint256 amountToWithdraw = shortage > balanceProtocol ? balanceProtocol : shortage;\n      savedTotalUnderlying -= amountToWithdraw;\n\n      if (amountToWithdraw < minimumPull) break;\n      withdrawFromProtocol(i, amountToWithdraw);\n\n      if (_value <= vaultCurrency.balanceOf(address(this))) break;\n    }\n  }\n\n  /// @notice Step 7 trigger, end; Vaults rebalance\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\n  /// @dev amountToProtocol = totalAmount * currentAllocation / totalAllocatedTokens\n  /// @dev amountToDeposit = amountToProtocol - currentBalanceProtocol\n  /// @dev if amountToDeposit < 0 => withdraw\n  /// @dev Execute all withdrawals before deposits\n  function rebalance() external nonReentrant {\n    require(state == State.RebalanceVault, stateError);\n    require(deltaAllocationsReceived, \"!Delta allocations\");\n\n    rebalancingPeriod++;\n\n    claimTokens();\n    settleDeltaAllocation();\n\n    uint256 underlyingIncBalance = calcUnderlyingIncBalance();\n    uint256[] memory protocolToDeposit = rebalanceCheckProtocols(underlyingIncBalance);\n\n    executeDeposits(protocolToDeposit);\n    setTotalUnderlying();\n\n    if (reservedFunds > vaultCurrency.balanceOf(address(this))) pullFunds(reservedFunds);\n\n    state = State.SendRewardsPerToken;\n    deltaAllocationsReceived = false;\n  }\n\n  /// @notice Helper to return underlying balance plus totalUnderlying - liquidty for the vault\n  /// @return underlying totalUnderlying - liquidityVault\n  function calcUnderlyingIncBalance() internal view returns (uint256) {\n    uint256 totalUnderlyingInclVaultBalance = savedTotalUnderlying +\n      getVaultBalance() -\n      reservedFunds;\n    uint256 liquidityVault = (totalUnderlyingInclVaultBalance * liquidityPerc) / 100;\n    return totalUnderlyingInclVaultBalance - liquidityVault;\n  }\n\n  /// @notice Adds deltaAllocatedTokens to totalAllocatedTokens\n  function settleDeltaAllocation() internal {\n    totalAllocatedTokens += deltaAllocatedTokens;\n    deltaAllocatedTokens = 0;\n  }\n\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\n  /// @dev Loops over all protocols in ETF, calculate new currentAllocation based on deltaAllocation\n  /// @dev Also calculate the performance fee here. This is an amount, based on the current TVL (before the rebalance),\n  /// @dev the performanceFee and difference between the current exchangeRate and the exchangeRate of the last rebalance of the vault.\n  /// @param _newTotalUnderlying this will be the new total underlying: Totalunderlying = TotalUnderlyingInProtocols - BalanceVault\n  /// @return uint256[] with amounts to deposit in protocols, the index being the protocol number.\n  function rebalanceCheckProtocols(\n    uint256 _newTotalUnderlying\n  ) internal returns (uint256[] memory) {\n    uint256[] memory protocolToDeposit = new uint[](controller.latestProtocolId(vaultNumber));\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      bool isBlacklisted = controller.getProtocolBlacklist(vaultNumber, i);\n\n      storePriceAndRewards(_newTotalUnderlying, i);\n\n      if (isBlacklisted) continue;\n      setAllocation(i);\n\n      int256 amountToProtocol = calcAmountToProtocol(_newTotalUnderlying, i);\n      uint256 currentBalance = balanceUnderlying(i);\n\n      int256 amountToDeposit = amountToProtocol - int(currentBalance);\n      uint256 amountToWithdraw = amountToDeposit < 0 ? currentBalance - uint(amountToProtocol) : 0;\n\n      if (amountToDeposit > marginScale) protocolToDeposit[i] = uint256(amountToDeposit);\n      if (amountToWithdraw > uint(marginScale) || currentAllocations[i] == 0)\n        withdrawFromProtocol(i, amountToWithdraw);\n    }\n\n    return protocolToDeposit;\n  }\n\n  /// @notice Calculates the amount to deposit or withdraw to protocol during a vault rebalance\n  /// @param _totalUnderlying Totalunderlying = TotalUnderlyingInProtocols - BalanceVault\n  /// @param _protocol Protocol id number\n  /// @return amountToProtocol amount to deposit or withdraw to protocol\n  function calcAmountToProtocol(\n    uint256 _totalUnderlying,\n    uint256 _protocol\n  ) internal view returns (int256 amountToProtocol) {\n    if (totalAllocatedTokens == 0) amountToProtocol = 0;\n    else\n      amountToProtocol =\n        (int(_totalUnderlying) * currentAllocations[_protocol]) /\n        totalAllocatedTokens;\n  }\n\n  /// @notice Stores the historical price and the reward per rounded locked token, ignoring decimals.\n  /// @dev formula yield protocol i at time t: y(it) = (P(it) - P(it-1)) / P(it-1).\n  /// @dev formula rewardPerLockedToken for protocol i at time t: r(it) = y(it) * TVL(t) * perfFee(t) / totalLockedTokens(t)\n  /// @dev later, when the total rewards are calculated for a game player we multiply this (r(it)) by the locked tokens on protocol i at time t\n  /// @param _totalUnderlying Totalunderlying = TotalUnderlyingInProtocols - BalanceVault.\n  /// @param _protocolId Protocol id number.\n  function storePriceAndRewards(uint256 _totalUnderlying, uint256 _protocolId) internal {\n    uint256 currentPrice = price(_protocolId);\n    if (lastPrices[_protocolId] == 0) {\n      lastPrices[_protocolId] = currentPrice;\n      return;\n    }\n\n    int256 priceDiff = int256(currentPrice - lastPrices[_protocolId]);\n    int256 nominator = (int256(_totalUnderlying * performanceFee) * priceDiff);\n    int256 totalAllocatedTokensRounded = totalAllocatedTokens / 1E18;\n    int256 denominator = totalAllocatedTokensRounded * int256(lastPrices[_protocolId]) * 100; // * 100 cause perfFee is in percentages\n\n    if (totalAllocatedTokensRounded == 0) {\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = 0;\n    } else {\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = nominator / denominator;\n    }\n\n    lastPrices[_protocolId] = currentPrice;\n  }\n\n  /// @notice Creates array out of the rewardsPerLockedToken mapping to send to the game\n  /// @return rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\n  function rewardsToArray() internal view returns (int256[] memory rewards) {\n    uint256 latestId = controller.latestProtocolId(vaultNumber);\n\n    rewards = new int[](latestId);\n    for (uint256 i = 0; i < latestId; i++) {\n      rewards[i] = rewardPerLockedToken[rebalancingPeriod][i];\n    }\n  }\n\n  /// @notice Helper function to set allocations\n  /// @param _i Protocol number linked to an underlying protocol e.g compound_usdc_01\n  function setAllocation(uint256 _i) internal {\n    currentAllocations[_i] += deltaAllocations[_i];\n    deltaAllocations[_i] = 0;\n    require(currentAllocations[_i] >= 0, \"Allocation underflow\");\n  }\n\n  /// @notice Helper function so the rebalance will execute all withdrawals first\n  /// @dev Executes and resets all deposits set in mapping(protocolToDeposit) by rebalanceETF\n  /// @param protocolToDeposit array with amounts to deposit in protocols, the index being the protocol number.\n  function executeDeposits(uint256[] memory protocolToDeposit) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      uint256 amount = protocolToDeposit[i];\n      if (amount == 0) continue;\n      depositInProtocol(i, amount);\n    }\n  }\n\n  /// @notice Deposit amount to underlying protocol\n  /// @dev Deposits VaultCurrency in Protocol e.g USDC\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount in VaultCurrency to deposit\n  function depositInProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    if (getVaultBalance() < _amount) _amount = getVaultBalance();\n\n    if (protocol.underlying != address(vaultCurrency)) {\n      _amount = Swap.swapStableCoins(\n        Swap.SwapInOut(_amount, address(vaultCurrency), protocol.underlying),\n        uScale,\n        controller.underlyingUScale(protocol.underlying),\n        controller.getCurveParams(address(vaultCurrency), protocol.underlying)\n      );\n    }\n\n    IERC20(protocol.underlying).safeIncreaseAllowance(protocol.provider, _amount);\n    IProvider(protocol.provider).deposit(_amount, protocol.LPToken, protocol.underlying);\n  }\n\n  /// @notice Withdraw amount from underlying protocol\n  /// @dev shares = amount / PricePerShare\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount in VaultCurrency to withdraw\n  function withdrawFromProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    if (_amount <= 0) return;\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    _amount = (_amount * protocol.uScale) / uScale;\n    uint256 shares = IProvider(protocol.provider).calcShares(_amount, protocol.LPToken);\n    uint256 balance = IProvider(protocol.provider).balance(address(this), protocol.LPToken);\n\n    if (shares == 0) return;\n    if (balance < shares) shares = balance;\n\n    IERC20(protocol.LPToken).safeIncreaseAllowance(protocol.provider, shares);\n    uint256 amountReceived = IProvider(protocol.provider).withdraw(\n      shares,\n      protocol.LPToken,\n      protocol.underlying\n    );\n\n    if (protocol.underlying != address(vaultCurrency)) {\n      _amount = Swap.swapStableCoins(\n        Swap.SwapInOut(amountReceived, protocol.underlying, address(vaultCurrency)),\n        controller.underlyingUScale(protocol.underlying),\n        uScale,\n        controller.getCurveParams(protocol.underlying, address(vaultCurrency))\n      );\n    }\n  }\n\n  /// @notice Set total balance in VaultCurrency in all underlying protocols\n  function setTotalUnderlying() public {\n    uint totalUnderlying;\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n      totalUnderlying += balanceUnderlying(i);\n    }\n    savedTotalUnderlying = totalUnderlying;\n  }\n\n  /// @notice Get balance in VaultCurrency in underlying protocol\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @return Balance in VaultCurrency e.g USDC\n  function balanceUnderlying(uint256 _protocolNum) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    uint256 underlyingBalance = (IProvider(protocol.provider).balanceUnderlying(\n      address(this),\n      protocol.LPToken\n    ) * uScale) / protocol.uScale;\n    return underlyingBalance;\n  }\n\n  /// @notice Calculates how many shares are equal to the amount in vault currency\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _protocolNum, uint256 _amount) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    uint256 shares = IProvider(protocol.provider).calcShares(\n      (_amount * protocol.uScale) / uScale,\n      protocol.LPToken\n    );\n\n    return shares;\n  }\n\n  /// @notice Get price for underlying protocol\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @return protocolPrice Price per lp token\n  function price(uint256 _protocolNum) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    return IProvider(protocol.provider).exchangeRate(protocol.LPToken);\n  }\n\n  /// @notice Set the delta allocated tokens by game contract\n  /// @dev Allocation can be negative\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\n  /// @param _allocation Delta allocation in tokens\n  function setDeltaAllocationsInt(uint256 _protocolNum, int256 _allocation) internal {\n    require(!controller.getProtocolBlacklist(vaultNumber, _protocolNum), \"Protocol on blacklist\");\n    deltaAllocations[_protocolNum] += _allocation;\n    deltaAllocatedTokens += _allocation;\n  }\n\n  /// @notice Harvest extra tokens from underlying protocols\n  /// @dev Loops over protocols in ETF and check if they are claimable in controller contract\n  function claimTokens() public {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n      bool claim = controller.claim(vaultNumber, i);\n      if (claim) {\n        address govToken = controller.getGovToken(vaultNumber, i);\n        uint256 tokenBalance = IERC20(govToken).balanceOf(address(this));\n        Swap.swapTokensMulti(\n          Swap.SwapInOut(tokenBalance, govToken, address(vaultCurrency)),\n          controller.getUniswapParams(),\n          false\n        );\n      }\n    }\n  }\n\n  function getVaultBalance() public view returns (uint256) {\n    return vaultCurrency.balanceOf(address(this));\n  }\n\n  /// @notice Checks if a rebalance is needed based on the set interval\n  /// @return bool True of rebalance is needed, false if not\n  function rebalanceNeeded() public view returns (bool) {\n    return (block.timestamp - lastTimeStamp) > rebalanceInterval || msg.sender == guardian;\n  }\n\n  /// @notice Getter for dao address\n  function getDao() public view returns (address) {\n    return dao;\n  }\n\n  /// @notice Getter for guardian address\n  function getGuardian() public view returns (address) {\n    return guardian;\n  }\n\n  /*\n  Only Dao functions\n  */\n\n  /// @notice Set the performanceFee, the percentage of the yield that goes to the game players.\n  /// @dev The actual performanceFee could be a bit more or a bit less than the performanceFee set here due to approximations in the game.\n  /// @param _performanceFee Value at which to set the performanceFee.\n  function setPerformanceFee(uint256 _performanceFee) external onlyDao {\n    require(_performanceFee <= 100);\n    performanceFee = _performanceFee;\n  }\n\n  /// @notice Set the governance address\n  /// @param _dao New address of the governance / DAO\n  function setDao(address _dao) external onlyDao {\n    dao = _dao;\n  }\n\n  /// @notice Setter for guardian address\n  /// @param _guardian new address of the guardian\n  function setGuardian(address _guardian) external onlyDao {\n    guardian = _guardian;\n  }\n\n  /*\n  Only Guardian functions\n  */\n\n  /// @notice Set minimum interval for the rebalance function\n  /// @param _timestampInternal UNIX timestamp\n  function setRebalanceInterval(uint256 _timestampInternal) external onlyGuardian {\n    rebalanceInterval = _timestampInternal;\n  }\n\n  /// @notice The DAO should be able to blacklist protocols, the funds should be sent to the vault.\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\n  function blacklistProtocol(uint256 _protocolNum) external onlyGuardian {\n    uint256 balanceProtocol = balanceUnderlying(_protocolNum);\n    currentAllocations[_protocolNum] = 0;\n    controller.setProtocolBlacklist(vaultNumber, _protocolNum);\n    savedTotalUnderlying -= balanceProtocol;\n    withdrawFromProtocol(_protocolNum, balanceProtocol);\n  }\n\n  /// @notice Set the marginScale, the threshold used for deposits and withdrawals.\n  /// @notice If the threshold is not met the deposit/ withdrawal is not executed.\n  /// @dev Take into account the uScale (scale of the underlying).\n  /// @param _marginScale Value at which to set the marginScale.\n  function setMarginScale(int256 _marginScale) external onlyGuardian {\n    marginScale = _marginScale;\n  }\n\n  /// @notice Set the liquidityPerc, the amount of liquidity which should be held in the vault after rebalancing.\n  /// @dev The actual liquidityPerc could be a bit more or a bit less than the liquidityPerc set here.\n  /// @dev This is because some deposits or withdrawals might not execute because they don't meet the marginScale.\n  /// @param _liquidityPerc Value at which to set the liquidityPerc.\n  function setLiquidityPerc(uint256 _liquidityPerc) external onlyGuardian {\n    require(_liquidityPerc <= 100);\n    liquidityPerc = _liquidityPerc;\n  }\n\n  /// @notice callback to receive Ether from unwrapping WETH\n  receive() external payable {\n    require(msg.sender == Swap.WETH, \"Not WETH\");\n  }\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/AaveProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IAToken.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IALendingPool.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\ncontract AaveProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Aave\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Aave, send aTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _aToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(address(IAToken(_aToken).POOL()), _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    IALendingPool(IAToken(_aToken).POOL()).deposit(\r\n      IAToken(_aToken).UNDERLYING_ASSET_ADDRESS(),\r\n      _amount,\r\n      msg.sender,\r\n      0\r\n    );\r\n\r\n    return _amount;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Aave\r\n  /// @dev Pulls cTokens from Vault, redeem them from Aave, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _aToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    require(\r\n      IAToken(_aToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    uint256 uTokensReceived = IALendingPool(IAToken(_aToken).POOL()).withdraw(\r\n      IAToken(_aToken).UNDERLYING_ASSET_ADDRESS(),\r\n      _amount,\r\n      msg.sender\r\n    );\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in shares i.e LP tokens\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balanceUnderlying(\r\n    address _address,\r\n    address _aToken\r\n  ) public view override returns (uint256) {\r\n    uint256 balanceShares = balance(_address, _aToken);\r\n    return balanceShares;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev Aave exchangeRate is 1\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _aToken) external view override returns (uint256) {\r\n    uint256 shares = _amount / exchangeRate(_aToken);\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get balance of aToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _aToken) public view override returns (uint256) {\r\n    uint256 _balanceShares = IAToken(_aToken).balanceOf(_address);\r\n    return _balanceShares;\r\n  }\r\n\r\n  /// @notice Exchange rate of underyling protocol token\r\n  /// @dev Aave exchangeRate is always 1\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _aToken) public pure override returns (uint256) {\r\n    return 1;\r\n  }\r\n\r\n  function claim(address _aToken, address _claimer) public override returns (bool) {}\r\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../Interfaces/ExternalInterfaces/ICToken.sol\";\nimport \"../Interfaces/ExternalInterfaces/IComptroller.sol\";\nimport \"../Interfaces/IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n  using SafeERC20 for IERC20;\n\n  IComptroller public comptroller;\n\n  constructor(address _comptroller) {\n    comptroller = IComptroller(_comptroller);\n  }\n\n  /// @notice Deposit the underlying asset in Compound\n  /// @dev Pulls underlying asset from Vault, deposit them in Compound, send cTokens back.\n  /// @param _amount Amount to deposit\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Tokens received and sent to vault\n  function deposit(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(_cToken, _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    uint256 cTokenBefore = ICToken(_cToken).balanceOf(address(this));\n    require(ICToken(_cToken).mint(_amount) == 0, \"Error minting Compound\");\n    uint256 cTokenAfter = ICToken(_cToken).balanceOf(address(this));\n\n    uint cTokensReceived = cTokenAfter - cTokenBefore;\n    ICToken(_cToken).transfer(msg.sender, cTokensReceived);\n\n    return cTokensReceived;\n  }\n\n  /// @notice Withdraw the underlying asset from Compound\n  /// @dev Pulls cTokens from Vault, redeem them from Compound, send underlying back.\n  /// @param _amount Amount to withdraw\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Underlying tokens received and sent to vault e.g USDC\n  function withdraw(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\n\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\n\n    require(\n      ICToken(_cToken).transferFrom(msg.sender, address(this), _amount) == true,\n      \"Error: transferFrom\"\n    );\n    // Compound redeem: 0 on success, otherwise an Error code\n    require(ICToken(_cToken).redeem(_amount) == 0, \"Error: compound redeem\");\n\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\n\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\n    require(\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\n      \"Error Withdraw: under/overflow\"\n    );\n\n    return uTokensReceived;\n  }\n\n  /// @notice Get balance from address in underlying token\n  /// @param _address Address to request balance from, most likely a Vault\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return balance in underlying token\n  function balanceUnderlying(\n    address _address,\n    address _cToken\n  ) public view override returns (uint256) {\n    uint256 balanceShares = balance(_address, _cToken);\n    // The returned exchange rate from comp is scaled by 1 * 10^(18 - 8 + Underlying Token Decimals).\n    uint256 price = exchangeRate(_cToken);\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n\n    return (balanceShares * price) / 10 ** (10 + decimals);\n  }\n\n  /// @notice Calculates how many shares are equal to the amount\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _amount, address _cToken) external view override returns (uint256) {\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n    uint256 shares = (_amount * (10 ** (10 + decimals))) / exchangeRate(_cToken);\n    return shares;\n  }\n\n  /// @notice Get balance of cToken from address\n  /// @param _address Address to request balance from\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function balance(address _address, address _cToken) public view override returns (uint256) {\n    uint256 _balanceShares = ICToken(_cToken).balanceOf(_address);\n    return _balanceShares;\n  }\n\n  /// @notice Exchange rate of underyling protocol token\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return price of LP token\n  function exchangeRate(address _cToken) public view override returns (uint256) {\n    uint256 _price = ICToken(_cToken).exchangeRateStored();\n    return _price;\n  }\n\n  /// @notice Claims/harvest COMP tokens from the Comptroller\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  function claim(address _cToken, address _claimer) external override returns (bool) {\n    address[] memory cTokens = new address[](1);\n    cTokens[0] = _cToken;\n    comptroller.claimComp(_claimer, cTokens);\n\n    return true;\n  }\n}"
    }
  ]
}