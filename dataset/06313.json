{
  "Title": "[M-08] Permission escalation by adding the same permission twice",
  "Content": "\nThe function `combinePermissions` adds permission to available permissions.\nIf the same permission is added twice, then this will result in a new and different permission.\nFor example, adding `_PERMISSION_STATICCALL` twice results in `_PERMISSION_SUPER_DELEGATECALL`.\n\nThis way, accidentally dangerous permissions can be set. Once someone has a dangerous permission, for example `_PERMISSION_SUPER_DELEGATECALL`, they can change all storage parameters of the Universion Profile and then steal all the assets.\n\n### Proof of Concept\n\nThe following code shows this. Run with `forge test -vv` to see the console output.\n\n```solidity\npragma solidity ^0.8.13;\n\nimport \"../../contracts/LSP6KeyManager/LSP6KeyManager.sol\";\nimport \"../../contracts/LSP0ERC725Account/LSP0ERC725Account.sol\";\nimport \"../../contracts/LSP2ERC725YJSONSchema/LSP2Utils.sol\";\nimport \"../../contracts/LSP6KeyManager/LSP6Constants.sol\";\nimport \"./UniversalProfileTestsHelper.sol\";\n\ncontract SetDataRestrictedController is UniversalProfileTestsHelper {\n    LSP0ERC725Account public mainUniversalProfile;\n    LSP6KeyManager public keyManagerMainUP;\n    address public mainUniversalProfileOwner;\n    address public combineController;\n\n    function setUp() public {\n        mainUniversalProfileOwner = vm.addr(1);\n        vm.label(mainUniversalProfileOwner, \"mainUniversalProfileOwner\");\n        combineController = vm.addr(10);\n        vm.label(combineController, \"combineController\");\n        mainUniversalProfile = new LSP0ERC725Account(mainUniversalProfileOwner);\n\n        // deploy LSP6KeyManagers\n        keyManagerMainUP = new LSP6KeyManager(address(mainUniversalProfile));\n        transferOwnership(\n            mainUniversalProfile,\n            mainUniversalProfileOwner,\n            address(keyManagerMainUP)\n        );        \n    }\n    \n    function testCombinePermissions() public {       \n        bytes32[] memory ownerPermissions = new bytes32[](3);\n        ownerPermissions[0] = _PERMISSION_STATICCALL;\n        ownerPermissions[1] = _PERMISSION_STATICCALL;\n        givePermissionsToController(\n            mainUniversalProfile,\n            combineController,\n            address(keyManagerMainUP),\n            ownerPermissions\n        );        \n        bytes32 key = LSP2Utils.generateMappingWithGroupingKey(_LSP6KEY_ADDRESSPERMISSIONS_PERMISSIONS_PREFIX,bytes20(combineController));\n        bytes memory r = mainUniversalProfile.getData(key);\n        console.logBytes(r); // 0x00..4000  SUPER_DELEGATECALL\n    }\n}\n```\n\nSee [LSP6Utils.sol#L169-L177](https://github.com/lukso-network/lsp-smart-contracts/blob/v0.10.2/contracts/LSP6KeyManager/LSP6Utils.sol#L169-L177) for the code of `combinePermissions`.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nThe permissions shouldn't be added, but they should be `OR`'d.\nHere is a way to solve this:\n\n```diff\nfunction combinePermissions(bytes32[] memory permissions) internal pure returns (bytes32) {\n    uint256 result = 0;\n    for (uint256 i = 0; i < permissions.length; i++) {\n-      result += uint256(permissions[i]);\n+      result |= uint256(permissions[i]);\n    }\n    return bytes32(result);\n}\n```\n\n### Assessed type\n\nMath\n\n**[CJ42 (LUKSO) disagreed with severity and commented](https://github.com/code-423n4/2023-06-lukso-findings/issues/13#issuecomment-1640217182):**\n > We don't use this function in any of the standards. It is only used in the tests.\n >\n> Because `LSP6Utils` is a `library` contract intended to be used for developer, we consider it is an issue.\n> However, we consider it is unlikely that a developer will add the same permission two times in the array (if they do, it is on the developer end implementing our contracts that the mistakes happen in), we think the severity should be lower.\n\n**[Trust (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-06-lukso-findings/issues/13#issuecomment-1661814215):**\n > Passing multiple identical permissions cannot be viewed as a mistake on the developer's side. They may rightly assume that repeating permissions are ignored and aren't expected to prefilter. \n> The warden has not shown a clear end-to-end scenario where this would occur. Unless a reasonable likelihood can be demonstrated, the impact should be treated as a strong Medium.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lukso",
  "Code": [
    {
      "filename": "contracts/LSP6KeyManager/LSP6Utils.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// interfaces\nimport {\n    IERC725Y\n} from \"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\";\nimport {ILSP6KeyManager} from \"./ILSP6KeyManager.sol\";\n\n// libraries\nimport {LSP2Utils} from \"../LSP2ERC725YJSONSchema/LSP2Utils.sol\";\n\n// constants\nimport \"./LSP6Constants.sol\";\n\nlibrary LSP6Utils {\n    using LSP2Utils for bytes12;\n\n    /**\n     * @dev read the permissions of a `caller` on an ERC725Y `target` contract.\n     * @param target an `IERC725Y` contract where to read the permissions.\n     * @param caller the controller address to read the permissions from.\n     * @return a `bytes32` BitArray containing the permissions of a controller address.\n     */\n    function getPermissionsFor(\n        IERC725Y target,\n        address caller\n    ) internal view returns (bytes32) {\n        bytes memory permissions = target.getData(\n            LSP2Utils.generateMappingWithGroupingKey(\n                _LSP6KEY_ADDRESSPERMISSIONS_PERMISSIONS_PREFIX,\n                bytes20(caller)\n            )\n        );\n\n        return bytes32(permissions);\n    }\n\n    function getAllowedCallsFor(\n        IERC725Y target,\n        address from\n    ) internal view returns (bytes memory) {\n        return\n            target.getData(\n                LSP2Utils.generateMappingWithGroupingKey(\n                    _LSP6KEY_ADDRESSPERMISSIONS_ALLOWEDCALLS_PREFIX,\n                    bytes20(from)\n                )\n            );\n    }\n\n    /**\n     * @dev read the Allowed ERC725Y data keys of a `caller` on an ERC725Y `target` contract.\n     * @param target an `IERC725Y` contract where to read the permissions.\n     * @param caller the controller address to read the permissions from.\n     * @return an abi-encoded array of allowed ERC725 keys that the controller address is allowed to interact with.\n     */\n    function getAllowedERC725YDataKeysFor(\n        IERC725Y target,\n        address caller\n    ) internal view returns (bytes memory) {\n        return\n            target.getData(\n                LSP2Utils.generateMappingWithGroupingKey(\n                    _LSP6KEY_ADDRESSPERMISSIONS_AllowedERC725YDataKeys_PREFIX,\n                    bytes20(caller)\n                )\n            );\n    }\n\n    /**\n     * @dev compare the permissions `addressPermissions` of an address\n     *      to check if they includes the permissions `permissionToCheck`\n     * @param addressPermission the permissions of an address stored on an ERC725 account\n     * @param permissionToCheck the permissions to check\n     * @return true if `addressPermissions` includes `permissionToCheck`, false otherwise\n     */\n    function hasPermission(\n        bytes32 addressPermission,\n        bytes32 permissionToCheck\n    ) internal pure returns (bool) {\n        return (addressPermission & permissionToCheck) == permissionToCheck;\n    }\n\n    /**\n     * @dev same as LSP2Utils.isCompactBytesArray with the additional requirement that each element must be 28 bytes long.\n     *\n     * @param allowedCallsCompacted a compact bytes array of tuples (bytes4,address,bytes4) to check.\n     * @return true if the value passed is a valid compact bytes array of bytes28 elements according to LSP2, false otherwise.\n     */\n    function isCompactBytesArrayOfAllowedCalls(\n        bytes memory allowedCallsCompacted\n    ) internal pure returns (bool) {\n        uint256 pointer = 0;\n\n        while (pointer < allowedCallsCompacted.length) {\n            if (pointer + 1 >= allowedCallsCompacted.length) return false;\n            uint256 elementLength = uint16(\n                bytes2(\n                    abi.encodePacked(\n                        allowedCallsCompacted[pointer],\n                        allowedCallsCompacted[pointer + 1]\n                    )\n                )\n            );\n            // each entries in the allowedCalls (compact) array must be 32 bytes long\n            if (elementLength != 32) return false;\n            pointer += elementLength + 2;\n        }\n        if (pointer == allowedCallsCompacted.length) return true;\n        return false;\n    }\n\n    /**\n     * @dev same as LSP2Utils.isCompactBytesArray with the additional requirement that each element must be from 1 to 32 bytes long.\n     *\n     * @param allowedERC725YDataKeysCompacted a compact bytes array of ERC725Y Data Keys (full bytes32 data keys or bytesN prefix) to check.\n     * @return true if the value passed is a valid compact bytes array of ERC725Y Data Keys, false otherwise.\n     */\n    function isCompactBytesArrayOfAllowedERC725YDataKeys(\n        bytes memory allowedERC725YDataKeysCompacted\n    ) internal pure returns (bool) {\n        uint256 pointer = 0;\n\n        while (pointer < allowedERC725YDataKeysCompacted.length) {\n            if (pointer + 1 >= allowedERC725YDataKeysCompacted.length)\n                return false;\n            uint256 elementLength = uint16(\n                bytes2(\n                    abi.encodePacked(\n                        allowedERC725YDataKeysCompacted[pointer],\n                        allowedERC725YDataKeysCompacted[pointer + 1]\n                    )\n                )\n            );\n            // the length of the allowed data key must be not under 33 bytes and not 0\n            if (elementLength == 0 || elementLength > 32) return false;\n            pointer += elementLength + 2;\n        }\n        if (pointer == allowedERC725YDataKeysCompacted.length) return true;\n        return false;\n    }\n\n    /**\n     * @dev use the `setData(bytes32[],bytes[])` via the KeyManager of the target\n     * @param keyManagerAddress the address of the KeyManager\n     * @param keys the array of data keys\n     * @param values the array of data values\n     */\n    function setDataViaKeyManager(\n        address keyManagerAddress,\n        bytes32[] memory keys,\n        bytes[] memory values\n    ) internal returns (bytes memory result) {\n        bytes memory payload = abi.encodeWithSelector(\n            IERC725Y.setDataBatch.selector,\n            keys,\n            values\n        );\n        result = ILSP6KeyManager(keyManagerAddress).execute(payload);\n    }\n\n    /**\n     * @dev combine multiple permissions into a single bytes32\n     * Make sure that the sum of the values of the input array is less than 2^256-1 to avoid overflow.\n     * @param permissions the array of permissions to combine\n     * @return a bytes32 containing the combined permissions\n     */\n    function combinePermissions(\n        bytes32[] memory permissions\n    ) internal pure returns (bytes32) {\n        uint256 result = 0;\n        for (uint256 i = 0; i < permissions.length; i++) {\n            result += uint256(permissions[i]);\n        }\n        return bytes32(result);\n    }\n\n    /**\n     * @dev Generate a new set of 3 x LSP6 permission data keys to add a new `controller` on `account`\n     * @param account the ERC725Y contract to add the controller into (used to fetch the `LSP6Permissions[]` length)\n     * @param controller the address of the controller to grant permissions to\n     * @param permissions the BitArray of permissions to grant to the controller\n     * @return keys an array of 3 x data keys containing:\n     *  - keys[0] = `AddressPermissions[]` (array length)\n     *  - keys[1] = `AddressPermissions[index]` (where to store the controller address)\n     *  - keys[2] = `AddressPermissions:Permissions:<controller>`\n     *\n     * @return values : an array of 3 x data values containing:\n     *  - values[0] = the new array length of `AddressPermissions[]`\n     *  - values[1] = the address of the controller\n     *  - values[2] = the `permissions` passed as param\n     */\n    function generateNewPermissionsKeys(\n        IERC725Y account,\n        address controller,\n        bytes32 permissions\n    ) internal view returns (bytes32[] memory keys, bytes[] memory values) {\n        keys = new bytes32[](3);\n        values = new bytes[](3);\n\n        uint128 arrayLength = uint128(\n            bytes16(account.getData(_LSP6KEY_ADDRESSPERMISSIONS_ARRAY))\n        );\n        uint128 newArrayLength = arrayLength + 1;\n\n        keys[0] = _LSP6KEY_ADDRESSPERMISSIONS_ARRAY;\n        values[0] = abi.encodePacked(newArrayLength);\n\n        keys[1] = LSP2Utils.generateArrayElementKeyAtIndex(\n            _LSP6KEY_ADDRESSPERMISSIONS_ARRAY,\n            arrayLength\n        );\n        values[1] = abi.encodePacked(controller);\n\n        keys[2] = LSP2Utils.generateMappingWithGroupingKey(\n            _LSP6KEY_ADDRESSPERMISSIONS_PERMISSIONS_PREFIX,\n            bytes20(controller)\n        );\n        values[2] = abi.encodePacked(permissions);\n    }\n\n    /**\n     * @dev returns the name of the permission as a string\n     */\n    function getPermissionName(\n        bytes32 permission\n    ) internal pure returns (string memory errorMessage) {\n        if (permission == _PERMISSION_CHANGEOWNER) return \"TRANSFEROWNERSHIP\";\n        if (permission == _PERMISSION_EDITPERMISSIONS) return \"EDITPERMISSIONS\";\n        if (permission == _PERMISSION_ADDCONTROLLER) return \"ADDCONTROLLER\";\n        if (permission == _PERMISSION_ADDEXTENSIONS) return \"ADDEXTENSIONS\";\n        if (permission == _PERMISSION_CHANGEEXTENSIONS)\n            return \"CHANGEEXTENSIONS\";\n        if (permission == _PERMISSION_ADDUNIVERSALRECEIVERDELEGATE)\n            return \"ADDUNIVERSALRECEIVERDELEGATE\";\n        if (permission == _PERMISSION_CHANGEUNIVERSALRECEIVERDELEGATE)\n            return \"CHANGEUNIVERSALRECEIVERDELEGATE\";\n        if (permission == _PERMISSION_REENTRANCY) return \"REENTRANCY\";\n        if (permission == _PERMISSION_SETDATA) return \"SETDATA\";\n        if (permission == _PERMISSION_CALL) return \"CALL\";\n        if (permission == _PERMISSION_STATICCALL) return \"STATICCALL\";\n        if (permission == _PERMISSION_DELEGATECALL) return \"DELEGATECALL\";\n        if (permission == _PERMISSION_DEPLOY) return \"DEPLOY\";\n        if (permission == _PERMISSION_TRANSFERVALUE) return \"TRANSFERVALUE\";\n        if (permission == _PERMISSION_SIGN) return \"SIGN\";\n    }\n}"
    }
  ]
}