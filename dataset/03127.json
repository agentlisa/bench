{
  "Title": "Disabled scanners and agents may appear to be linked",
  "Content": "Within `Dispatch.sol`, the mappings [`scannerToAgents`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/dispatch/Dispatch.sol#L18) and [`agentToScanners`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/dispatch/Dispatch.sol#L19) should store correct linkages between agents and scanners.\n\n\nIf an agent or scanner is disabled, they are [not allowed to be `link`ed](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/dispatch/Dispatch.sol#L74-L75). Thus, it follows that if scanners or agents which are `link`ed are then disabled, the `link` should be removed. However, this is not enforced – a scanner or agent may be disabled, but the values in `scannerToAgents` and `agentsToScanners` may not reflect this.\n\n\nConsider adding a programmatical way to remove `link`s whenever an agent or scanner is disabled. Consider that, since a single agent or scanner may have multiple instances it is linked to, the `unlink`ing process may involve calling `unlink` multiple times. This may mean adding a limit to the number of links for a single instance. Alternatively, consider documenting this behavior clearly for any 3rd-party developers, and encouraging them to double-check that both the scanner and agent are enabled when querying linked pairs.\n\n\n***Update:** Acknowledge, but will not fix. The Forta team’s statement for the issue:*\n\n\n\n> *Product requirements not clear yet, addressed in the conversation thread but we will not take action yet (since assigner software is doing that labor now).*\n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/components/dispatch/Dispatch.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../BaseComponentUpgradeable.sol\";\nimport \"../agents/AgentRegistry.sol\";\nimport \"../scanners/ScannerRegistry.sol\";\n\ncontract Dispatch is BaseComponentUpgradeable {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    AgentRegistry   private _agents;\n    ScannerRegistry private _scanners;\n\n    string public constant version = \"0.1.1\";\n\n    mapping(uint256 => EnumerableSet.UintSet) private scannerToAgents;\n    mapping(uint256 => EnumerableSet.UintSet) private agentToScanners;\n\n    event Link(uint256 agentId, uint256 scannerId, bool enable);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address forwarder) initializer ForwardedContext(forwarder) {}\n\n    function initialize(\n        address __manager,\n        address __router,\n        address __agents,\n        address __scanners\n    ) public initializer {\n        __AccessManaged_init(__manager);\n        __Routed_init(__router);\n        _agents   = AgentRegistry(__agents);\n        _scanners = ScannerRegistry(__scanners);\n    }\n\n    function agentRegistry() public view returns (AgentRegistry) {\n        return _agents;\n    }\n\n    function scannerRegistry() public view returns (ScannerRegistry) {\n        return _scanners;\n    }\n\n    function agentsFor(uint256 scannerId) public view returns (uint256) {\n        return scannerToAgents[scannerId].length();\n    }\n\n    function scannersFor(uint256 agentId) public view returns (uint256) {\n        return agentToScanners[agentId].length();\n    }\n\n    function agentsAt(uint256 scannerId, uint256 pos) public view returns (uint256) {\n        return scannerToAgents[scannerId].at(pos);\n    }\n\n    function agentRefAt(uint256 scannerId, uint256 pos) external view returns (uint256 agentId, bool enabled, uint256 agentVersion, string memory metadata, uint256[] memory chainIds) {\n        agentId = agentsAt(scannerId, pos);\n        enabled = _agents.isEnabled(agentId);\n        (agentVersion, metadata, chainIds) = _agents.getAgent(agentId);\n    }\n\n    function scannersAt(uint256 agentId, uint256 pos) public view returns (uint256) {\n        return agentToScanners[agentId].at(pos);\n    }\n\n    function scannerRefAt(uint256 agentId, uint256 pos) external view returns (uint256 scannerId, bool enabled) {\n        scannerId = scannersAt(agentId, pos);\n        enabled   = _scanners.isEnabled(agentId);\n    }\n\n    function link(uint256 agentId, uint256 scannerId) public onlyRole(DISPATCHER_ROLE) {\n        require(_agents.isEnabled(agentId), \"Dispatch: Agent disabled\");\n        require(_scanners.isEnabled(scannerId), \"Dispatch: Scanner disabled\");\n\n        scannerToAgents[scannerId].add(agentId);\n        agentToScanners[agentId].add(scannerId);\n\n        emit Link(agentId, scannerId, true);\n    }\n\n    function unlink(uint256 agentId, uint256 scannerId) public onlyRole(DISPATCHER_ROLE) {\n        require(_agents.isCreated(agentId), \"Dispatch: invalid agent id\");\n        require(_scanners.isRegistered(scannerId), \"Dispatch: invalid scanner id\");\n\n        scannerToAgents[scannerId].remove(agentId);\n        agentToScanners[agentId].remove(scannerId);\n\n        emit Link(agentId, scannerId, false);\n    }\n\n    function setAgentRegistry(address newAgentRegistry) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _agents = AgentRegistry(newAgentRegistry);\n    }\n\n    function setScannerRegistry(address newScannerRegistry) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _scanners = ScannerRegistry(newScannerRegistry);\n    }\n\n    function agentHash(uint256 agentId) external view returns (uint256 length, bytes32 manifest) {\n        uint256[] memory scanners = agentToScanners[agentId].values();\n        bool[]    memory enabled = new bool[](scanners.length);\n\n        for (uint256 i = 0; i < scanners.length; ++i) {\n            enabled[i] = _scanners.isEnabled(scanners[i]);\n        }\n\n        return (\n            scanners.length,\n            keccak256(abi.encodePacked(scanners, enabled))\n        );\n    }\n\n    function scannerHash(uint256 scannerId) external view returns (uint256 length, bytes32 manifest) {\n        uint256[] memory agents  = scannerToAgents[scannerId].values();\n        uint256[] memory agentVersion = new uint256[](agents.length);\n        bool[]    memory enabled = new bool[](agents.length);\n\n        for (uint256 i = 0; i < agents.length; ++i) {\n            (agentVersion[i],,) = _agents.getAgent(agents[i]);\n            enabled[i]     = _agents.isEnabled(agents[i]);\n        }\n\n        return (\n            agents.length,\n            keccak256(abi.encodePacked(agents, agentVersion, enabled))\n        );\n    }\n\n    uint256[48] private __gap;\n}"
    },
    {
      "filename": "contracts/components/dispatch/Dispatch.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../BaseComponentUpgradeable.sol\";\nimport \"../agents/AgentRegistry.sol\";\nimport \"../scanners/ScannerRegistry.sol\";\n\ncontract Dispatch is BaseComponentUpgradeable {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    AgentRegistry   private _agents;\n    ScannerRegistry private _scanners;\n\n    string public constant version = \"0.1.1\";\n\n    mapping(uint256 => EnumerableSet.UintSet) private scannerToAgents;\n    mapping(uint256 => EnumerableSet.UintSet) private agentToScanners;\n\n    event Link(uint256 agentId, uint256 scannerId, bool enable);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address forwarder) initializer ForwardedContext(forwarder) {}\n\n    function initialize(\n        address __manager,\n        address __router,\n        address __agents,\n        address __scanners\n    ) public initializer {\n        __AccessManaged_init(__manager);\n        __Routed_init(__router);\n        _agents   = AgentRegistry(__agents);\n        _scanners = ScannerRegistry(__scanners);\n    }\n\n    function agentRegistry() public view returns (AgentRegistry) {\n        return _agents;\n    }\n\n    function scannerRegistry() public view returns (ScannerRegistry) {\n        return _scanners;\n    }\n\n    function agentsFor(uint256 scannerId) public view returns (uint256) {\n        return scannerToAgents[scannerId].length();\n    }\n\n    function scannersFor(uint256 agentId) public view returns (uint256) {\n        return agentToScanners[agentId].length();\n    }\n\n    function agentsAt(uint256 scannerId, uint256 pos) public view returns (uint256) {\n        return scannerToAgents[scannerId].at(pos);\n    }\n\n    function agentRefAt(uint256 scannerId, uint256 pos) external view returns (uint256 agentId, bool enabled, uint256 agentVersion, string memory metadata, uint256[] memory chainIds) {\n        agentId = agentsAt(scannerId, pos);\n        enabled = _agents.isEnabled(agentId);\n        (agentVersion, metadata, chainIds) = _agents.getAgent(agentId);\n    }\n\n    function scannersAt(uint256 agentId, uint256 pos) public view returns (uint256) {\n        return agentToScanners[agentId].at(pos);\n    }\n\n    function scannerRefAt(uint256 agentId, uint256 pos) external view returns (uint256 scannerId, bool enabled) {\n        scannerId = scannersAt(agentId, pos);\n        enabled   = _scanners.isEnabled(agentId);\n    }\n\n    function link(uint256 agentId, uint256 scannerId) public onlyRole(DISPATCHER_ROLE) {\n        require(_agents.isEnabled(agentId), \"Dispatch: Agent disabled\");\n        require(_scanners.isEnabled(scannerId), \"Dispatch: Scanner disabled\");\n\n        scannerToAgents[scannerId].add(agentId);\n        agentToScanners[agentId].add(scannerId);\n\n        emit Link(agentId, scannerId, true);\n    }\n\n    function unlink(uint256 agentId, uint256 scannerId) public onlyRole(DISPATCHER_ROLE) {\n        require(_agents.isCreated(agentId), \"Dispatch: invalid agent id\");\n        require(_scanners.isRegistered(scannerId), \"Dispatch: invalid scanner id\");\n\n        scannerToAgents[scannerId].remove(agentId);\n        agentToScanners[agentId].remove(scannerId);\n\n        emit Link(agentId, scannerId, false);\n    }\n\n    function setAgentRegistry(address newAgentRegistry) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _agents = AgentRegistry(newAgentRegistry);\n    }\n\n    function setScannerRegistry(address newScannerRegistry) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _scanners = ScannerRegistry(newScannerRegistry);\n    }\n\n    function agentHash(uint256 agentId) external view returns (uint256 length, bytes32 manifest) {\n        uint256[] memory scanners = agentToScanners[agentId].values();\n        bool[]    memory enabled = new bool[](scanners.length);\n\n        for (uint256 i = 0; i < scanners.length; ++i) {\n            enabled[i] = _scanners.isEnabled(scanners[i]);\n        }\n\n        return (\n            scanners.length,\n            keccak256(abi.encodePacked(scanners, enabled))\n        );\n    }\n\n    function scannerHash(uint256 scannerId) external view returns (uint256 length, bytes32 manifest) {\n        uint256[] memory agents  = scannerToAgents[scannerId].values();\n        uint256[] memory agentVersion = new uint256[](agents.length);\n        bool[]    memory enabled = new bool[](agents.length);\n\n        for (uint256 i = 0; i < agents.length; ++i) {\n            (agentVersion[i],,) = _agents.getAgent(agents[i]);\n            enabled[i]     = _agents.isEnabled(agents[i]);\n        }\n\n        return (\n            agents.length,\n            keccak256(abi.encodePacked(agents, agentVersion, enabled))\n        );\n    }\n\n    uint256[48] private __gap;\n}"
    }
  ]
}