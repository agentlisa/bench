{
  "Title": "M-26: USDO’s MSG_TAP_EXERCISE compose messages where exercised options must be withdrawn to another chain will always fail due to wrongly requiring sendParam's to address to be whitelisted in the Cluster",
  "Content": "# Issue M-26: USDO’s MSG_TAP_EXERCISE compose messages where exercised options must be withdrawn to another chain will always fail due to wrongly requiring sendParam's to address to be whitelisted in the Cluster \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/124 \n\n## Found by \n0xadrii\n## Summary\n\nWrongly checking for the sendParam's `to` address to be whitelisted when bridging exercised options will make such calls always fail.\n\n## Vulnerability Detail\n\nOne of the compose messages allowed in USDO is `MSG_TAP_EXERCISE`. This type of message will trigger `UsdoOptionReceiverModule`'s `exerciseOptionsReceiver()` function, which allows users to exercise their options and obtain the corresponding exercised tapOFTs.\n\nUsers can choose to obtain their tapOFTs in the chain where `exerciseOptionsReceiver()` is being executed, or they can choose to send a message to a destination chain of their choice. If users decide to bridge the exercised option, the `lzSendParams` fields contained in the `ExerciseOptionsMsg` struct decoded from the `_data` passed as parameter in `exerciseOptionsReceiver()` should be filled with the corresponding data to perform the cross-chain call.\n\nThe problem is that  the `exerciseOptionsReceiver()` performs an unnecessary validation that requires the `to` parameter inside the `lzSendParams` to be whitelisted in the protocol’s cluster:\n\n```solidity\n// UsdoOptionReceiverModule.sol\n\nfunction exerciseOptionsReceiver(address srcChainSender, bytes memory _data) public payable {\n        // Decode received message.\n        ExerciseOptionsMsg memory msg_ = UsdoMsgCodec.decodeExerciseOptionsMsg(_data);\n  \n        _checkWhitelistStatus(msg_.optionsData.target);\n        _checkWhitelistStatus(OFTMsgCodec.bytes32ToAddress(msg_.lzSendParams.sendParam.to)); // <---- This validation is wrong \n        ...\n        \n        \n   }\n```\n\n`msg_.lzSendParams.sendParam.to` corresponds to the address that will obtain the tokens in the destination chain after bridging the exercised option, which can and should actually be any address that the user exercising the option decides, so this address shouldn’t be required to be whitelisted in the protocol’s Cluster (given that the Cluster only whitelists certain protocol-related addresses such as contracts or special addresses).\n\nBecause of this, transactions where users try to bridge the exercised options will always fail because the  `msg_.lzSendParams.sendParam.to` address specified by users will never be whitelisted in the Cluster.\n\n## Impact\n\nHigh. The functionality of exercising options and bridging them in the same transaction is one of the wide range of core functionalities that should be completely functional in Tapioca. However, this functionality will always fail due to the mentioned issue, forcing users to only be able to exercise options in the same chain.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/usdo/modules/UsdoOptionReceiverModule.sol#L72\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRemove the whitelist check against the `msg_.lzSendParams.sendParam.to` param in`exerciseOptionsReceiver()`:\n\n```diff\n// UsdoOptionReceiverModule.sol\n\nfunction exerciseOptionsReceiver(address srcChainSender, bytes memory _data) public payable {\n        // Decode received message.\n        ExerciseOptionsMsg memory msg_ = UsdoMsgCodec.decodeExerciseOptionsMsg(_data);\n  \n        _checkWhitelistStatus(msg_.optionsData.target);\n-        _checkWhitelistStatus(OFTMsgCodec.bytes32ToAddress(msg_.lzSendParams.sendParam.to)); \n        ...\n        \n        \n   }\n```\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  again seem valid; high(1)\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/363.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/usdo/modules/UsdoOptionReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {\n    MessagingReceipt, OFTReceipt, SendParam\n} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {IOAppMsgInspector} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppMsgInspector.sol\";\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {\n    DepositAndSendForLockingData,\n    MagnetarCall,\n    MagnetarAction,\n    IMagnetar,\n    CrossChainMintFromBBAndLendOnSGLData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {\n    ITapiocaOptionBroker, IExerciseOptionsData\n} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {UsdoInitStruct, ExerciseOptionsMsg, LZSendParam} from \"tapioca-periph/interfaces/oft/IUsdo.sol\";\nimport {SafeApprove} from \"tapioca-periph/libraries/SafeApprove.sol\";\nimport {UsdoMsgCodec} from \"../libraries/UsdoMsgCodec.sol\";\nimport {BaseUsdo} from \"../BaseUsdo.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title UsdoOptionReceiverModule\n * @author TapiocaDAO\n * @notice Usdo Option module\n */\ncontract UsdoOptionReceiverModule is BaseUsdo {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeApprove for address;\n\n    error UsdoOptionReceiverModule_NotAuthorized(address invalidAddress);\n\n    event ExerciseOptionsReceived(\n        address indexed user, address indexed target, uint256 indexed oTapTokenId, uint256 paymentTokenAmount\n    );\n\n    constructor(UsdoInitStruct memory _data) BaseUsdo(_data) {}\n\n    /**\n     * @notice Exercise tOB option\n     * @param _data The call data containing info about the operation.\n     *      - optionsData::address: TapiocaOptionsBroker exercise params.\n     *      - lzSendParams::struct: LZ v2 send to source params.\n     *      - composeMsg::bytes: Further compose data.\n     */\n    function exerciseOptionsReceiver(address srcChainSender, bytes memory _data) public payable {\n        // Decode received message.\n        ExerciseOptionsMsg memory msg_ = UsdoMsgCodec.decodeExerciseOptionsMsg(_data);\n\n        _checkWhitelistStatus(msg_.optionsData.target);\n        _checkWhitelistStatus(OFTMsgCodec.bytes32ToAddress(msg_.lzSendParams.sendParam.to));\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n            _options.tapAmount = _toLD(_options.tapAmount.toUint64());\n            _options.paymentTokenAmount = _toLD(_options.paymentTokenAmount.toUint64());\n\n            // @dev retrieve paymentToken amount\n            _internalTransferWithAllowance(_options.from, srcChainSender, _options.paymentTokenAmount);\n\n            /// @dev call exerciseOption() with address(this) as the payment token\n            // _approve(address(this), _options.target, _options.paymentTokenAmount);\n            pearlmit.approve(\n                address(this), 0, _options.target, uint200(_options.paymentTokenAmount), uint48(block.timestamp + 1)\n            ); // Atomic approval\n            _approve(address(this), address(pearlmit), _options.paymentTokenAmount);\n\n            uint256 bBefore = balanceOf(address(this));\n            ITapiocaOptionBroker(_options.target).exerciseOption(\n                _options.oTAPTokenID,\n                address(this), //payment token\n                _options.tapAmount\n            );\n            _approve(address(this), address(pearlmit), 0);\n            uint256 bAfter = balanceOf(address(this));\n\n            // Refund if less was used.\n            if (bBefore > bAfter) {\n                uint256 diff = bBefore - bAfter;\n                if (diff < _options.paymentTokenAmount) {\n                    IERC20(address(this)).safeTransfer(_options.from, _options.paymentTokenAmount - diff);\n                }\n            }\n        }\n\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n            SendParam memory _send = msg_.lzSendParams.sendParam;\n\n            address tapOft = ITapiocaOptionBroker(_options.target).tapOFT();\n            if (msg_.withdrawOnOtherChain) {\n                /// @dev determine the right amount to send back to source\n                uint256 amountToSend = _send.amountLD > _options.tapAmount ? _options.tapAmount : _send.amountLD;\n                if (_send.minAmountLD > amountToSend) {\n                    _send.minAmountLD = amountToSend;\n                }\n\n                // Sends to source and preserve source `msg.sender` (`from` in this case).\n                _sendPacket(msg_.lzSendParams, msg_.composeMsg, _options.from);\n\n                // Refund extra amounts\n                if (_options.tapAmount - amountToSend > 0) {\n                    IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount - amountToSend);\n                }\n            } else {\n                //send on this chain\n                IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount);\n            }\n        }\n    }\n\n    function _checkWhitelistStatus(address _addr) private view {\n        if (_addr != address(0)) {\n            if (!cluster.isWhitelisted(0, _addr)) {\n                revert UsdoOptionReceiverModule_NotAuthorized(_addr);\n            }\n        }\n    }\n\n    function _sendPacket(LZSendParam memory _lzSendParam, bytes memory _composeMsg, address _srcChainSender)\n        private\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        /// @dev Applies the token transfers regarding this send() operation.\n        // - amountDebitedLD is the amount in local decimals that was ACTUALLY debited from the sender.\n        // - amountToCreditLD is the amount in local decimals that will be credited to the recipient on the remote OFT instance.\n        (uint256 amountDebitedLD, uint256 amountToCreditLD) =\n            _debit(_lzSendParam.sendParam.amountLD, _lzSendParam.sendParam.minAmountLD, _lzSendParam.sendParam.dstEid);\n\n        /// @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildOFTMsgAndOptionsMemory(\n            _lzSendParam.sendParam, _lzSendParam.extraOptions, _composeMsg, amountToCreditLD, _srcChainSender\n        );\n\n        /// @dev Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt =\n            _lzSend(_lzSendParam.sendParam.dstEid, message, options, _lzSendParam.fee, _lzSendParam.refundAddress);\n        /// @dev Formulate the OFT receipt.\n        oftReceipt = OFTReceipt(amountDebitedLD, amountToCreditLD);\n\n        emit OFTSent(msgReceipt.guid, _lzSendParam.sendParam.dstEid, msg.sender, amountDebitedLD);\n    }\n    /**\n     * @dev For details about this function, check `BaseTapiocaOmnichainEngine._buildOFTMsgAndOptions()`.\n     * @dev !!!! IMPORTANT !!!! The differences are:\n     *      - memory instead of calldata for parameters.\n     *      - `_msgSender` is used instead of using context `msg.sender`, to preserve context of the OFT call and use `msg.sender` of the source chain.\n     *      - Does NOT combine options, make sure to pass valid options to cover gas costs/value transfers.\n     */\n\n    function _buildOFTMsgAndOptionsMemory(\n        SendParam memory _sendParam,\n        bytes memory _extraOptions,\n        bytes memory _composeMsg,\n        uint256 _amountToCreditLD,\n        address _msgSender\n    ) private view returns (bytes memory message, bytes memory options) {\n        bool hasCompose = _composeMsg.length > 0;\n\n        message = hasCompose\n            ? abi.encodePacked(\n                _sendParam.to, _toSD(_amountToCreditLD), OFTMsgCodec.addressToBytes32(_msgSender), _composeMsg\n            )\n            : abi.encodePacked(_sendParam.to, _toSD(_amountToCreditLD));\n        options = _extraOptions;\n\n        if (msgInspector != address(0)) {\n            IOAppMsgInspector(msgInspector).inspect(message, options);\n        }\n    }\n\n    /**\n     * @dev Performs a transfer with an allowance check and consumption against the xChain msg sender.\n     * @dev Can only transfer to this address.\n     *\n     * @param _owner The account to transfer from.\n     * @param srcChainSender The address of the sender on the source chain.\n     * @param _amount The amount to transfer\n     */\n    function _internalTransferWithAllowance(address _owner, address srcChainSender, uint256 _amount) internal {\n        if (_owner != srcChainSender) {\n            _spendAllowance(_owner, srcChainSender, _amount);\n        }\n\n        _transfer(_owner, address(this), _amount);\n    }\n}"
    }
  ]
}