{
  "Title": "[M-07] OwnableSmartWallet: Multiple approvals can lead to unwanted ownership transfers",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L94\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L105-L106\n\n\n# Vulnerability details\n\n## Impact\nThe `OwnableSmartWallet` contract employs a mechanism for the owner to approve addresses that can then claim ownership ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L94](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L94)) of the contract.  \n\nThe source code has a comment included which states that \"Approval is revoked, in order to avoid unintended transfer allowance if this wallet ever returns to the previous owner\" ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L105-L106](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L105-L106)).  \n\nThis means that when ownership is transferred from User A to User B, the approvals that User A has given should be revoked.  \n\nThe existing code does not however revoke all approvals that User A has given. It only revokes one approval.  \n\nThis can lead to unwanted transfers of ownership.  \n\n## Proof of Concept\n1. User A approves User B and User C to claim ownership\n2. User B claims ownership first\n3. Only User A's approval for User B is revoked, not however User A's approval for User C\n4. User B transfers ownerhsip back to User A\n5. Now User C can claim ownership even though this time User A has not approved User C\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nYou should invalidate all approvals User A has given when another User becomes the owner of the OwnableSmartWallet.  \n\nUnfortunately you cannot use a statement like `delete _isTransferApproved[owner()]`.  \n\nSo you would need an array that keeps track of approvals as pointed out in this StackExchange question: [https://ethereum.stackexchange.com/questions/15553/how-to-delete-a-mapping](https://ethereum.stackexchange.com/questions/15553/how-to-delete-a-mapping)  \n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/smart-wallet/OwnableSmartWallet.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport {IOwnableSmartWallet} from \"./interfaces/IOwnableSmartWallet.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/// @title Ownable smart wallet\n/// @notice Ownable and transferrable smart wallet that allows the owner to\n///         interact with any contracts the same way as from an EOA. The\n///         main intended use is to make non-transferrable positions and assets\n///         liquid and usable in strategies.\n/// @notice Intended to be used with a factory and the cloning pattern.\ncontract OwnableSmartWallet is IOwnableSmartWallet, Ownable, Initializable {\n    using Address for address;\n\n    /// @dev A map from owner and spender to transfer approval. Determines whether\n    ///      the spender can transfer this wallet from the owner. Can be used\n    ///      to put this wallet in possession of a strategy (e.g., as collateral).\n    mapping(address => mapping(address => bool)) internal _isTransferApproved;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc IOwnableSmartWallet\n    function initialize(address initialOwner)\n        external\n        override\n        initializer // F: [OSW-1]\n    {\n        require(\n            initialOwner != address(0),\n            \"OwnableSmartWallet: Attempting to initialize with zero address owner\"\n        );\n        _transferOwnership(initialOwner); // F: [OSW-1]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function execute(address target, bytes memory callData)\n        external\n        override\n        payable\n        onlyOwner // F: [OSW-6A]\n        returns (bytes memory)\n    {\n        return target.functionCallWithValue(callData, msg.value); // F: [OSW-6]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function execute(\n        address target,\n        bytes memory callData,\n        uint256 value\n    )\n        external\n        override\n        payable\n        onlyOwner // F: [OSW-6A]\n        returns (bytes memory)\n    {\n        return target.functionCallWithValue(callData, value); // F: [OSW-6]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function rawExecute(\n        address target,\n        bytes memory callData,\n        uint256 value\n    )\n    external\n    override\n    payable\n    onlyOwner\n    returns (bytes memory)\n    {\n        (bool result, bytes memory message) = target.call{value: value}(callData);\n        require(result, \"Failed to execute\");\n        return message;\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function owner()\n        public\n        view\n        override(IOwnableSmartWallet, Ownable)\n        returns (address)\n    {\n        return Ownable.owner(); // F: [OSW-1]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function transferOwnership(address newOwner)\n        public\n        override(IOwnableSmartWallet, Ownable)\n    {\n        // Only the owner themselves or an address that is approved for transfers\n        // is authorized to do this\n        require(\n            isTransferApproved(owner(), msg.sender),\n            \"OwnableSmartWallet: Transfer is not allowed\"\n        ); // F: [OSW-4]\n\n        // Approval is revoked, in order to avoid unintended transfer allowance\n        // if this wallet ever returns to the previous owner\n        if (msg.sender != owner()) {\n            _setApproval(owner(), msg.sender, false); // F: [OSW-5]\n        }\n        _transferOwnership(newOwner); // F: [OSW-5]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function setApproval(address to, bool status) external onlyOwner override {\n        require(\n            to != address(0),\n            \"OwnableSmartWallet: Approval cannot be set for zero address\"\n        ); // F: [OSW-2A]\n        _setApproval(msg.sender, to, status);\n    }\n\n    /// @dev IMPLEMENTATION: _setApproval\n    /// @param from The owner address\n    /// @param to The spender address\n    /// @param status Status of approval\n    function _setApproval(\n        address from,\n        address to,\n        bool status\n    ) internal {\n        bool statusChanged = _isTransferApproved[from][to] != status;\n        _isTransferApproved[from][to] = status; // F: [OSW-2]\n        if (statusChanged) {\n            emit TransferApprovalChanged(from, to, status); // F: [OSW-2]\n        }\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function isTransferApproved(address from, address to)\n        public\n        override\n        view\n        returns (bool)\n    {\n        return from == to ? true : _isTransferApproved[from][to]; // F: [OSW-2, 3]\n    }\n\n    receive() external payable {\n        // receive ETH\n    }\n}"
    },
    {
      "filename": "contracts/smart-wallet/OwnableSmartWallet.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport {IOwnableSmartWallet} from \"./interfaces/IOwnableSmartWallet.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/// @title Ownable smart wallet\n/// @notice Ownable and transferrable smart wallet that allows the owner to\n///         interact with any contracts the same way as from an EOA. The\n///         main intended use is to make non-transferrable positions and assets\n///         liquid and usable in strategies.\n/// @notice Intended to be used with a factory and the cloning pattern.\ncontract OwnableSmartWallet is IOwnableSmartWallet, Ownable, Initializable {\n    using Address for address;\n\n    /// @dev A map from owner and spender to transfer approval. Determines whether\n    ///      the spender can transfer this wallet from the owner. Can be used\n    ///      to put this wallet in possession of a strategy (e.g., as collateral).\n    mapping(address => mapping(address => bool)) internal _isTransferApproved;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc IOwnableSmartWallet\n    function initialize(address initialOwner)\n        external\n        override\n        initializer // F: [OSW-1]\n    {\n        require(\n            initialOwner != address(0),\n            \"OwnableSmartWallet: Attempting to initialize with zero address owner\"\n        );\n        _transferOwnership(initialOwner); // F: [OSW-1]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function execute(address target, bytes memory callData)\n        external\n        override\n        payable\n        onlyOwner // F: [OSW-6A]\n        returns (bytes memory)\n    {\n        return target.functionCallWithValue(callData, msg.value); // F: [OSW-6]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function execute(\n        address target,\n        bytes memory callData,\n        uint256 value\n    )\n        external\n        override\n        payable\n        onlyOwner // F: [OSW-6A]\n        returns (bytes memory)\n    {\n        return target.functionCallWithValue(callData, value); // F: [OSW-6]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function rawExecute(\n        address target,\n        bytes memory callData,\n        uint256 value\n    )\n    external\n    override\n    payable\n    onlyOwner\n    returns (bytes memory)\n    {\n        (bool result, bytes memory message) = target.call{value: value}(callData);\n        require(result, \"Failed to execute\");\n        return message;\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function owner()\n        public\n        view\n        override(IOwnableSmartWallet, Ownable)\n        returns (address)\n    {\n        return Ownable.owner(); // F: [OSW-1]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function transferOwnership(address newOwner)\n        public\n        override(IOwnableSmartWallet, Ownable)\n    {\n        // Only the owner themselves or an address that is approved for transfers\n        // is authorized to do this\n        require(\n            isTransferApproved(owner(), msg.sender),\n            \"OwnableSmartWallet: Transfer is not allowed\"\n        ); // F: [OSW-4]\n\n        // Approval is revoked, in order to avoid unintended transfer allowance\n        // if this wallet ever returns to the previous owner\n        if (msg.sender != owner()) {\n            _setApproval(owner(), msg.sender, false); // F: [OSW-5]\n        }\n        _transferOwnership(newOwner); // F: [OSW-5]\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function setApproval(address to, bool status) external onlyOwner override {\n        require(\n            to != address(0),\n            \"OwnableSmartWallet: Approval cannot be set for zero address\"\n        ); // F: [OSW-2A]\n        _setApproval(msg.sender, to, status);\n    }\n\n    /// @dev IMPLEMENTATION: _setApproval\n    /// @param from The owner address\n    /// @param to The spender address\n    /// @param status Status of approval\n    function _setApproval(\n        address from,\n        address to,\n        bool status\n    ) internal {\n        bool statusChanged = _isTransferApproved[from][to] != status;\n        _isTransferApproved[from][to] = status; // F: [OSW-2]\n        if (statusChanged) {\n            emit TransferApprovalChanged(from, to, status); // F: [OSW-2]\n        }\n    }\n\n    /// @inheritdoc IOwnableSmartWallet\n    function isTransferApproved(address from, address to)\n        public\n        override\n        view\n        returns (bool)\n    {\n        return from == to ? true : _isTransferApproved[from][to]; // F: [OSW-2, 3]\n    }\n\n    receive() external payable {\n        // receive ETH\n    }\n}"
    }
  ]
}