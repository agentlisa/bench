{
  "Title": "Key generation scheme",
  "Content": "[The key generation scheme proposed](https://gist.github.com/mappum/428dc46afba73b2bf8c38f65272704d2#donation-flow-overview) is not standard, consider using BIP32 and BIP44 to derive COSMOS, Bitcoin and Ethereum keys using standard paths. See [how DFINITY did their key derivations](https://github.com/dfinity/STIFTUNG-DFN-donations/blob/master/app/javascripts/accounts.js#L32) for more info.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "app/javascripts/accounts.js",
      "content": "/**\n *  DFINITY Donation Chrome Extension\n *  (C) 2016 DFINITY Stiftung (http://dfinity.network)\n *\n *  This Chrome extension provides a guided process for user to donate Bitcoin or\n *  Ether, in return for DFINITY Network Participation Token (DFN) recommendation from\n *  DFINITY Stiftung, a Swiss non-profit dedicated to DFINITY Network research,\n *  development and promotion.\n *\n *  This client:\n *    - generates new seed and derive DFN address\n *    - forwards ETH/BTC from a temporary address (which is also derived from the same\n *      seed) to the Foundation Donation Contract(FDC). The FDC is a set of smart\n *      contracts running on Ethereum, which registers the donation and\n *      corresponding DFN token recommendation amount\n *    - requires connecting to a Ethereum node (regardless of Ether or Bitcoin donation)\n *    - requires connecting to a Bitcoin node for Bitcoin donation\n *    - can withdrawal remaining Eth from the temporary withdrawal address\n *\n *  Refer to FDC code for detailed logic on donation.\n *\n */\n\"use strict\";\n\n// if seedStr == null then a new seed is generated, otherwise\n// keys are derived deterministically from the passed seed if it's valid\nvar Accounts = function(seedStr) {\n    this.Mnemonic = require('bitcore-mnemonic');\n    this.bitcore = require('bitcore-lib')\n\n    // single quote == hardened derivation\n    this.HDPathDFN = \"m/44'/223'/0'/0/0\"; // key controlling DFN allocation\n    this.HDPathDFNAccount = \"m/44'/223'/0'\"; // Account level path for DFN allocation\n    this.HDPathETHForwarder = \"m/44'/60'/0'/0/0\"; // ETH key forwarding donation for HDPathDFN key\n    this.HDPathBTCForwarder = \"m/44'/0'/0'/0/0\"; // BTC key forwarding donation for HDPathDFN key\n\n    // this.seed = seedStr;\n    this.DFN = {};\n    this.DFNAccount = {};\n    this.ETH = {};\n    this.BTC = {};\n}\n\n// https://github.com/bitpay/bitcore-lib/blob/master/docs/hierarchical.md\n// keys are compressed and\n// https://github.com/ethereumjs/ethereumjs-util/blob/master/docs/index.md#pubtoaddress\n// expects the 32 bytes without the leading compression-indicating\n// byte (see YP eq 213)\n\nAccounts.prototype.HDPrivKeyToAddr = function(privHex) {\n    /* TODO: verify padding, sometimes we get:\n\n     ethereumjs-util.js:16925 Uncaught RangeError: private key length is invalid(â€¦)\n     exports.isBufferLength @   ethereumjs-util.js:16925\n     publicKeyCreate    @   ethereumjs-util.js:17454\n     exports.privateToPublic    @   ethereumjs-util.js:6400\n     exports.privateToAddress   @   ethereumjs-util.js:6501\n     Accounts.HDPrivKeyToAddr   @   app.js:57286\n     Accounts   @   app.js:57263\n\n     which likely is the common padding bug of privkey being less than 32 bytes\n     */\n    var addrBuf = EthJSUtil.privateToAddress(EthJSUtil.toBuffer(privHex));\n    return EthJSUtil.bufferToHex(addrBuf);\n}\n\n// Generate an HD seed string. Note that we *never* store the seed. With the\n// seed, an attacker can gain access to the user's DFN later.\nAccounts.prototype.generateSeed = function() {\n    var code = new this.Mnemonic(this.Mnemonic.Words.ENGLISH);\n    return code.toString();\n\n    //  return this.Mnemonic(this.Mnemonic.Words.ENGLISH).toString();\n}\n\n// Generate 1. the user's DFINITY address 2. their forwarding addresses, and\n// 3. the private keys for the forwarding addresses. Note that we *never* store\n// the seed. With the seed, an attacker cn gain access to the user's DFN later.\nAccounts.prototype.generateKeys = function(seedStr) {\n    //var code = new this.Mnemonic(this.Mnemonic.Words.ENGLISH);\n    var code = new this.Mnemonic(seedStr);\n    var masterKey = code.toHDPrivateKey();\n    var DFNPriv = masterKey.derive(this.HDPathDFN);\n    var DFNAccount = masterKey.derive(this.HDPathDFNAccount);\n    var ETHPriv = masterKey.derive(this.HDPathETHForwarder);\n    var BTCPriv = masterKey.derive(this.HDPathBTCForwarder);\n    var DFNPrivPadded = \"0x\" + padPrivkey(DFNPriv.toObject().privateKey);\n    this.DFN.addr = this.HDPrivKeyToAddr(DFNPrivPadded);\n    // console.log(seedStr);\n    // console.log(DFNAccount.xpubkey);\n    this.DFNAccount.xpub = DFNAccount.xpubkey;\n\n    this.ETH.priv = \"0x\" + padPrivkey(ETHPriv.toObject().privateKey);\n    this.ETH.addr = this.HDPrivKeyToAddr(this.ETH.priv);\n\n    var BTCAddr = new this.bitcore.Address(BTCPriv.publicKey);\n    this.BTC.addr = BTCAddr.toString();\n    this.BTC.priv = BTCPriv.toObject().privateKey;\n}\n\n// Write the user's keys to storage e.g. Chrome storage\nAccounts.prototype.saveStates = function() {\n    if (this.DFN.addr != undefined &&\n        this.ETH.addr != undefined &&\n        this.ETH.priv != undefined &&\n        this.BTC.addr != undefined &&\n        this.BTC.priv != undefined\n    ) {\n        saveToStorage({\n            \"dfn-address\": this.DFN.addr,\n            \"dfn-account-xpub\": this.DFNAccount.xpub,\n            \"eth-address\": this.ETH.addr,\n            \"eth-private-key\": this.ETH.priv,\n            \"btc-address\": this.BTC.addr,\n            \"btc-private-key\": this.BTC.priv,\n\n        }, function() {\n            // ui.logger(\"DFN, BTC and ETH address successfully saved in Chrome storage.\");\n        });\n    }\n}\n\n// Load the user's keys from storage e.g. Chrome storage. If the operate fails,\n// an exception is thrown. If no keys were previously saved, no keys are loaded\n// and the key values will be undefined\nAccounts.prototype.loadStates = function(successFn) {\n    var self = this;\n    loadfromStorage([\n        \"dfn-address\",\n        \"dfn-account-xpub\",\n        \"eth-address\",\n        \"eth-private-key\",\n        \"btc-address\",\n        \"btc-private-key\",\n    ], function(s) {\n\n        if (s[\"dfn-address\"] != null && s[\"dfn-address\"] != undefined && s[\"eth-address\"] != null &&\n            s[\"eth-private-key\"] != null && s[\"btc-address\"] != null && s[\"btc-private-key\"] !=\n            null\n        ) {\n            self.DFN.addr = s[\"dfn-address\"];\n            self.ETH.addr = s[\"eth-address\"];\n            self.ETH.priv = s[\"eth-private-key\"];\n            self.BTC.addr = s[\"btc-address\"];\n            self.BTC.priv = s[\"btc-private-key\"];\n            self.DFNAccount.xpub = s[\"dfn-account-xpub\"];\n            console.log(\"Loaded DFN addr:\" + self.DFN.addr);\n            successFn();\n        }\n\n        // ui.logger(\"DFN, BTC and ETH address loaded successfully. \");\n    });\n}\n\nfunction padPrivkey(privHex) {\n    return (\"0000000000000000\" + privHex).slice(-64);\n}"
    }
  ]
}