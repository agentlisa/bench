{
  "Title": "M-40: Incorrect chainId comparison in xProvider",
  "Content": "# Issue M-40: Incorrect chainId comparison in xProvider \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/77 \n\n## Found by \nSulpiride\n\n## Summary\n`xProvider.pushTotalUnderlying` and `xProvider.pushRewardsToGame` incorrectly implement chainId comparison.\n\n## Vulnerability Detail\n`xProvider.pushTotalUnderlying` and `xProvider.pushRewardsToGame` incorrectly implement chainId comparison. Instead of comparing the chainId of xProvider with the chainId of the destination chain, the chainId from functions' parameter was used\n\n## Impact\nCalling these two functions will fail in two scenarios:\n1) When `chainId != xControllerChain (or gameChain)` and `xProvider.homeChain == xControllerChain`\n2) When `chainId == xControllerChain` and `xControllerChain != xProvider.homeChain`\n\n* `chainId` = incoming _chainId from functions parameters\n\nIn the first case, the call will fail because you can't xcall to the same chain\nIn the second case, because `xController` and `game` are `address(0)`\n\nThis will prevent some vaults from moving to the next stage, so this just haults them\n\n## Code Snippet\npushTotalUnderlying:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L207-L245\n```solidity\n  function pushTotalUnderlying(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _underlying,\n    uint256 _totalSupply,\n    uint256 _withdrawalRequests\n  ) external payable onlyVaults {\n    if (_chainId == xControllerChain) { // _chainId can be different from homeChain, but equal to xControllerChain\n      return\n        IXChainController(xController).setTotalUnderlying(\n          _vaultNumber,\n          _chainId,\n          _underlying,\n          _totalSupply,\n          _withdrawalRequests\n        );\n    } else {\n      bytes4 selector = bytes4(\n        keccak256(\"receiveTotalUnderlying(uint256,uint32,uint256,uint256,uint256)\")\n      );\n      bytes memory callData = abi.encodeWithSelector(\n        selector,\n        _vaultNumber,\n        _chainId,\n        _underlying,\n        _totalSupply,\n        _withdrawalRequests\n      );\n\n      xSend(xControllerChain, callData, 0);\n    }\n  }\n```\n\npushRewardsToGame:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L427-L445\n```solidity\n  function pushRewardsToGame(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    int256[] memory _rewards\n  ) external payable onlyVaults {\n    if (_chainId == gameChain) {\n      return IGame(game).settleRewards(_vaultNumber, _chainId, _rewards);\n    } else {\n      bytes4 selector = bytes4(keccak256(\"receiveRewardsToGame(uint256,uint32,int256[])\"));\n      bytes memory callData = abi.encodeWithSelector(selector, _vaultNumber, _chainId, _rewards);\n\n      xSend(gameChain, callData, 0);\n    }\n  }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nChange the condition to the following:\n```diff\nfunction pushTotalUnderlying(\n...\n-if (_chainId == xControllerChain) { \n+if (homeChain == xControllerChain) {\n...\n```\n\n```diff\nfunction pushRewardsToGame(\n...\n-if (_chainId == gameChain) {\n+if (homeChain == gameChain) {\n...\n```\n\n\n\n## Discussion\n\n**sjoerdsommen**\n\nCorrect should be (homechain == xChainControllerChain). But medium issue cause no funds are at risk.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/XProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IVault.sol\";\nimport \"./Interfaces/IXChainController.sol\";\nimport \"./Interfaces/IGame.sol\";\nimport \"./Interfaces/ExternalInterfaces/IConnext.sol\";\nimport \"./Interfaces/ExternalInterfaces/IXReceiver.sol\";\n\ncontract XProvider is IXReceiver {\n  using SafeERC20 for IERC20;\n\n  address public immutable connext;\n\n  address private dao;\n  address private guardian;\n  address public xController;\n  address public xControllerProvider;\n  address public game;\n\n  uint32 public homeChain;\n  uint32 public xControllerChain;\n  uint32 public gameChain;\n\n  // (domainID => contract address) mapping domainIDs to trusted remote xProvider on that specific domain\n  mapping(uint32 => address) public trustedRemoteConnext;\n  // (vaultAddress => bool): used for whitelisting vaults\n  mapping(address => bool) public vaultWhitelist;\n  // (vaultNumber => vaultAddress): used for guardian when xCall fails\n  mapping(uint256 => address) public vaults;\n\n  event SetTrustedRemote(uint32 _srcChainId, bytes _srcAddress);\n  event SetTrustedRemoteConnext(uint32 _srcChainId, address _srcAddress);\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"xProvider: only DAO\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"only Guardian\");\n    _;\n  }\n\n  modifier onlyController() {\n    require(msg.sender == xController, \"xProvider: only Controller\");\n    _;\n  }\n\n  modifier onlyVaults() {\n    require(vaultWhitelist[msg.sender], \"xProvider: only vault\");\n    _;\n  }\n\n  modifier onlyGame() {\n    require(msg.sender == game, \"xProvider: only Game\");\n    _;\n  }\n\n  /// @notice Solution for the low-level call in xReceive that is seen as an external call\n  modifier onlySelf() {\n    require(msg.sender == address(this), \"xProvider: only Self\");\n    _;\n  }\n\n  modifier onlySelfOrVault() {\n    require(\n      msg.sender == address(this) || vaultWhitelist[msg.sender],\n      \"xProvider: only Self or Vault\"\n    );\n    _;\n  }\n\n  /** @notice A modifier for authenticated calls.\n   * This is an important security consideration. If the target contract\n   * function should be authenticated, it must check three things:\n   *    1) The originating call comes from the expected origin domain.\n   *    2) The originating call comes from the expected source contract.\n   *    3) The call to this contract comes from Connext.\n   */\n  modifier onlySource(address _originSender, uint32 _origin) {\n    require(_originSender == trustedRemoteConnext[_origin] && msg.sender == connext, \"Not trusted\");\n    _;\n  }\n\n  constructor(\n    address _connext,\n    address _dao,\n    address _guardian,\n    address _game,\n    address _xController,\n    uint32 _homeChain\n  ) {\n    connext = _connext;\n    dao = _dao;\n    guardian = _guardian;\n    game = _game;\n    xController = _xController;\n    homeChain = _homeChain;\n  }\n\n  /// @notice Function to send function selectors crossChain\n  /// @param _destinationDomain chain Id of destination chain\n  /// @param _callData Function selector to call on receiving chain with params\n  /// @param _relayerFee The fee offered to the relayers, if 0 use the complete msg.value\n  function xSend(uint32 _destinationDomain, bytes memory _callData, uint256 _relayerFee) internal {\n    address target = trustedRemoteConnext[_destinationDomain];\n    require(target != address(0), \"XProvider: destination chain not trusted\");\n    uint256 relayerFee = _relayerFee != 0 ? _relayerFee : msg.value;\n\n    IConnext(connext).xcall{value: relayerFee}(\n      _destinationDomain, // _destination: Domain ID of the destination chain\n      target, // _to: address of the target contract\n      address(0), // _asset: use address zero for 0-value transfers\n      msg.sender, // _delegate: address that can revert or forceLocal on destination\n      0, // _amount: 0 because no funds are being transferred\n      0, // _slippage: can be anything between 0-10000 because no funds are being transferred\n      _callData // _callData: the encoded calldata to send\n    );\n  }\n\n  /// @notice Transfers funds from one chain to another.\n  /// @param _token Address of the token on this domain.\n  /// @param _amount The amount to transfer.\n  /// @param _recipient The destination address (e.g. a wallet).\n  /// @param _destinationDomain The destination domain ID.\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\n  /// @param _relayerFee The fee offered to the relayers for confirmation message, msg.value - _relayerFee is what goes to the routers\n  function xTransfer(\n    address _token,\n    uint256 _amount,\n    address _recipient,\n    uint32 _destinationDomain,\n    uint256 _slippage,\n    uint256 _relayerFee\n  ) internal {\n    require(\n      IERC20(_token).allowance(msg.sender, address(this)) >= _amount,\n      \"User must approve amount\"\n    );\n\n    // User sends funds to this contract\n    IERC20(_token).transferFrom(msg.sender, address(this), _amount);\n\n    // This contract approves transfer to Connext\n    IERC20(_token).approve(address(connext), _amount);\n\n    IConnext(connext).xcall{value: (msg.value - _relayerFee)}(\n      _destinationDomain, // _destination: Domain ID of the destination chain\n      _recipient, // _to: address receiving the funds on the destination\n      _token, // _asset: address of the token contract\n      msg.sender, // _delegate: address that can revert or forceLocal on destination\n      _amount, // _amount: amount of tokens to transfer\n      _slippage, // _slippage: the maximum amount of slippage the user will accept in BPS (e.g. 30 = 0.3%)\n      bytes(\"\") // _callData: empty bytes because we're only sending funds\n    );\n  }\n\n  /// @notice function implemented from IXReceive from connext, standard way to receive messages with connext.\n  /// @param _transferId not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _amount not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _asset not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _originSender sender contract.\n  /// @param _origin sender domain id.\n  /// @param _callData calldata, contains function signature which has to be called in this contract as well as the values, hashed and encoded.\n  function xReceive(\n    bytes32 _transferId,\n    uint256 _amount,\n    address _asset,\n    address _originSender,\n    uint32 _origin,\n    bytes memory _callData\n  ) external onlySource(_originSender, _origin) returns (bytes memory) {\n    (bool success, ) = address(this).call(_callData);\n    require(success, \"xReceive: No success\");\n  }\n\n  /// @notice Step 1 push; Game pushes totalDeltaAllocations to xChainController\n  /// @notice Pushes the delta allocations from the game to the xChainController\n  /// @param _vaultNumber number of the vault\n  /// @param _deltas Array with delta Allocations for all chainIds\n  function pushAllocations(\n    uint256 _vaultNumber,\n    int256[] memory _deltas\n  ) external payable onlyGame {\n    if (homeChain == xControllerChain) {\n      return IXChainController(xController).receiveAllocationsFromGame(_vaultNumber, _deltas);\n    }\n    bytes4 selector = bytes4(keccak256(\"receiveAllocations(uint256,int256[])\"));\n    bytes memory callData = abi.encodeWithSelector(selector, _vaultNumber, _deltas);\n\n    xSend(xControllerChain, callData, 0);\n  }\n\n  /// @notice Step 1 receive; Game pushes totalDeltaAllocations to xChainController\n  /// @notice Receives the delta allocations from the game and routes to xChainController\n  /// @param _vaultNumber number of the vault\n  /// @param _deltas Array with delta Allocations for all chainIds\n  function receiveAllocations(uint256 _vaultNumber, int256[] memory _deltas) external onlySelf {\n    return IXChainController(xController).receiveAllocationsFromGame(_vaultNumber, _deltas);\n  }\n\n  /// @notice Step 2 push; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\n  /// @notice Pushes cross chain requests for the totalUnderlying for a vaultNumber on a chainId\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _underlying TotalUnderling plus vault balance in vaultcurrency e.g USDC\n  /// @param _totalSupply Supply of the LP token of the vault on given chainId\n  /// @param _withdrawalRequests Total amount of withdrawal requests from the vault in LP Tokens\n  function pushTotalUnderlying(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _underlying,\n    uint256 _totalSupply,\n    uint256 _withdrawalRequests\n  ) external payable onlyVaults {\n    if (_chainId == xControllerChain) {\n      return\n        IXChainController(xController).setTotalUnderlying(\n          _vaultNumber,\n          _chainId,\n          _underlying,\n          _totalSupply,\n          _withdrawalRequests\n        );\n    } else {\n      bytes4 selector = bytes4(\n        keccak256(\"receiveTotalUnderlying(uint256,uint32,uint256,uint256,uint256)\")\n      );\n      bytes memory callData = abi.encodeWithSelector(\n        selector,\n        _vaultNumber,\n        _chainId,\n        _underlying,\n        _totalSupply,\n        _withdrawalRequests\n      );\n\n      xSend(xControllerChain, callData, 0);\n    }\n  }\n\n  /// @notice Step 2 receive; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\n  /// @notice Receive and set totalUnderlyings from the vaults for every chainId\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _underlying TotalUnderling plus vault balance in vaultcurrency e.g USDC\n  /// @param _totalSupply Supply of the LP token of the vault on given chainId\n  /// @param _withdrawalRequests Total amount of withdrawal requests from the vault in LP Tokens\n  function receiveTotalUnderlying(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _underlying,\n    uint256 _totalSupply,\n    uint256 _withdrawalRequests\n  ) external onlySelf {\n    return\n      IXChainController(xController).setTotalUnderlying(\n        _vaultNumber,\n        _chainId,\n        _underlying,\n        _totalSupply,\n        _withdrawalRequests\n      );\n  }\n\n  /// @notice Step 3 push; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\n  /// @param _vault Address of the Derby Vault on given chainId\n  /// @param _chainId Number of chain used\n  /// @param _amountToSendBack Amount the vault has to send back\n  /// @param _exchangeRate New exchangerate for vaults\n  function pushSetXChainAllocation(\n    address _vault,\n    uint32 _chainId,\n    uint256 _amountToSendBack,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) external payable onlyController {\n    if (_chainId == homeChain) {\n      return IVault(_vault).setXChainAllocation(_amountToSendBack, _exchangeRate, _receivingFunds);\n    } else {\n      bytes4 selector = bytes4(\n        keccak256(\"receiveSetXChainAllocation(address,uint256,uint256,bool)\")\n      );\n      bytes memory callData = abi.encodeWithSelector(\n        selector,\n        _vault,\n        _amountToSendBack,\n        _exchangeRate,\n        _receivingFunds\n      );\n\n      xSend(_chainId, callData, 0);\n    }\n  }\n\n  /// @notice Step 3 receive; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\n  /// @param _vault Address of the Derby Vault on given chainId\n  /// @param _amountToSendBack Amount the vault has to send back\n  /// @param _exchangeRate New exchangerate for vaults\n  function receiveSetXChainAllocation(\n    address _vault,\n    uint256 _amountToSendBack,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) external onlySelf {\n    return IVault(_vault).setXChainAllocation(_amountToSendBack, _exchangeRate, _receivingFunds);\n  }\n\n  /// @notice Step 4 push; Push funds from vaults to xChainController\n  /// @notice Transfers funds from vault to xController for crosschain rebalance\n  /// @param _vaultNumber Address of the Derby Vault on given chainId\n  /// @param _amount Number of the vault\n  /// @param _asset Address of the token to send e.g USDC\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\n  /// @param _relayerFee The fee offered to the relayers\n  function xTransferToController(\n    uint256 _vaultNumber,\n    uint256 _amount,\n    address _asset,\n    uint256 _slippage,\n    uint256 _relayerFee\n  ) external payable onlyVaults {\n    if (homeChain == xControllerChain) {\n      IERC20(_asset).transferFrom(msg.sender, xController, _amount);\n      IXChainController(xController).upFundsReceived(_vaultNumber);\n    } else {\n      xTransfer(_asset, _amount, xController, xControllerChain, _slippage, _relayerFee);\n      pushFeedbackToXController(_vaultNumber, _relayerFee);\n    }\n  }\n\n  /// @notice Step 4 push; Push funds from vaults to xChainController\n  /// @notice Push crosschain feedback to xController to know when the vaultNumber has sent funds\n  /// @param _vaultNumber Number of the vault\n  /// @param _relayerFee The fee offered to the relayers\n  function pushFeedbackToXController(uint256 _vaultNumber, uint256 _relayerFee) internal {\n    bytes4 selector = bytes4(keccak256(\"receiveFeedbackToXController(uint256)\"));\n    bytes memory callData = abi.encodeWithSelector(selector, _vaultNumber);\n\n    xSend(xControllerChain, callData, _relayerFee);\n  }\n\n  /// @notice Step 4 receive; Push funds from vaults to xChainController\n  /// @notice Receive crosschain feedback to xController to know when the vaultNumber has sent funds\n  /// @param _vaultNumber Number of the vault\n  function receiveFeedbackToXController(uint256 _vaultNumber) external onlySelf {\n    return IXChainController(xController).upFundsReceived(_vaultNumber);\n  }\n\n  /// @notice Step 5 push; Push funds from xChainController to vaults\n  /// @notice Transfers funds from xController to vault for crosschain rebalance\n  /// @param _chainId Number of chainId\n  /// @param _amount Amount to send to vault in vaultcurrency\n  /// @param _asset Addres of underlying e.g USDC\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\n  /// @param _relayerFee The fee offered to the relayers\n  function xTransferToVaults(\n    address _vault,\n    uint32 _chainId,\n    uint256 _amount,\n    address _asset,\n    uint256 _slippage,\n    uint256 _relayerFee\n  ) external payable onlyController {\n    if (_chainId == homeChain) {\n      IVault(_vault).receiveFunds();\n      IERC20(_asset).transferFrom(msg.sender, _vault, _amount);\n    } else {\n      pushFeedbackToVault(_chainId, _vault, _relayerFee);\n      xTransfer(_asset, _amount, _vault, _chainId, _slippage, _relayerFee);\n    }\n  }\n\n  /// @notice Step 5 push; Push funds from xChainController to vaults\n  /// @notice Push feedback message so the vault knows it has received funds and is ready to rebalance\n  /// @param _chainId Number of chainId\n  /// @param _vault Address of the vault on given chainId\n  /// @param _relayerFee The fee offered to the relayers\n  function pushFeedbackToVault(uint32 _chainId, address _vault, uint256 _relayerFee) internal {\n    bytes4 selector = bytes4(keccak256(\"receiveFeedbackToVault(address)\"));\n    bytes memory callData = abi.encodeWithSelector(selector, _vault);\n\n    xSend(_chainId, callData, _relayerFee);\n  }\n\n  /// @notice Step 5 receive; Push funds from xChainController to vaults\n  /// @notice Receive feedback message so the vault knows it has received funds and is ready to rebalance\n  /// @param _vault Address of the vault on given chainId\n  function receiveFeedbackToVault(address _vault) external onlySelfOrVault {\n    return IVault(_vault).receiveFunds();\n  }\n\n  /// @notice Step 6 push; Game pushes deltaAllocations to vaults\n  /// @notice Push protocol allocation array from the game to all vaults/chains\n  /// @param _vault Address of the vault on given chainId\n  /// @param _deltas Array with delta allocations where the index matches the protocolId\n  function pushProtocolAllocationsToVault(\n    uint32 _chainId,\n    address _vault,\n    int256[] memory _deltas\n  ) external payable onlyGame {\n    if (_chainId == homeChain) return IVault(_vault).receiveProtocolAllocations(_deltas);\n    else {\n      bytes4 selector = bytes4(keccak256(\"receiveProtocolAllocationsToVault(address,int256[])\"));\n      bytes memory callData = abi.encodeWithSelector(selector, _vault, _deltas);\n\n      xSend(_chainId, callData, 0);\n    }\n  }\n\n  /// @notice Step 6 receive; Game pushes deltaAllocations to vaults\n  /// @notice Receives protocol allocation array from the game to all vaults/chains\n  /// @param _vault Address of the vault on given chainId\n  /// @param _deltas Array with delta allocations where the index matches the protocolId\n  function receiveProtocolAllocationsToVault(\n    address _vault,\n    int256[] memory _deltas\n  ) external onlySelf {\n    return IVault(_vault).receiveProtocolAllocations(_deltas);\n  }\n\n  /// @notice Step 8 push; Vaults push rewardsPerLockedToken to game\n  /// @notice Push price and rewards array from vaults to the game\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\n  function pushRewardsToGame(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    int256[] memory _rewards\n  ) external payable onlyVaults {\n    if (_chainId == gameChain) {\n      return IGame(game).settleRewards(_vaultNumber, _chainId, _rewards);\n    } else {\n      bytes4 selector = bytes4(keccak256(\"receiveRewardsToGame(uint256,uint32,int256[])\"));\n      bytes memory callData = abi.encodeWithSelector(selector, _vaultNumber, _chainId, _rewards);\n\n      xSend(gameChain, callData, 0);\n    }\n  }\n\n  /// @notice Step 8 receive; Vaults push rewardsPerLockedToken to game\n  /// @notice Receives price and rewards array from vaults to the game\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\n  function receiveRewardsToGame(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    int256[] memory _rewards\n  ) external onlySelf {\n    return IGame(game).settleRewards(_vaultNumber, _chainId, _rewards);\n  }\n\n  /// @notice Push feedback to the vault if the vault is set to on or off\n  /// @param _vault Address of the Derby Vault on given chainId\n  /// @param _chainId Number of chain used\n  /// @param _state bool for chainId on or off\n  function pushStateFeedbackToVault(\n    address _vault,\n    uint32 _chainId,\n    bool _state\n  ) external payable onlyController {\n    if (_chainId == homeChain) {\n      return IVault(_vault).toggleVaultOnOff(_state);\n    } else {\n      bytes4 selector = bytes4(keccak256(\"receiveStateFeedbackToVault(address,bool)\"));\n      bytes memory callData = abi.encodeWithSelector(selector, _vault, _state);\n\n      xSend(_chainId, callData, 0);\n    }\n  }\n\n  /// @notice Receive feedback for the vault if the vault is set to on or off\n  /// @param _vault Address of the Derby Vault on given chainId\n  /// @param _state bool for chainId on or off\n  function receiveStateFeedbackToVault(address _vault, bool _state) external onlySelf {\n    return IVault(_vault).toggleVaultOnOff(_state);\n  }\n\n  /// @notice returns number of decimals for the vault\n  function getDecimals(address _vault) external view returns (uint256) {\n    return IVault(_vault).decimals();\n  }\n\n  /// @notice Getter for dao address\n  function getDao() public view returns (address) {\n    return dao;\n  }\n\n  /*\n  Only Dao functions\n  */\n  /// @notice set trusted provider on remote chains, allow owner to set it multiple times.\n  /// @param _srcChainId Chain is for remote xprovider, some as the remote receiving contract chain id (xReceive)\n  /// @param _srcAddress Address of remote xprovider\n  function setTrustedRemoteConnext(uint32 _srcChainId, address _srcAddress) external onlyDao {\n    trustedRemoteConnext[_srcChainId] = _srcAddress;\n    emit SetTrustedRemoteConnext(_srcChainId, _srcAddress);\n  }\n\n  /// @notice Setter for xControlleraddress\n  /// @param _xController New address of _xController\n  function setXController(address _xController) external onlyDao {\n    xController = _xController;\n  }\n\n  /// @notice Setter for xControllerProvider address\n  /// @param _xControllerProvider New address of xProvider for xController chain\n  function setXControllerProvider(address _xControllerProvider) external onlyDao {\n    xControllerProvider = _xControllerProvider;\n  }\n\n  /// @notice Setter for xController chain id\n  /// @param _xControllerChain new xController chainId\n  function setXControllerChainId(uint32 _xControllerChain) external onlyDao {\n    xControllerChain = _xControllerChain;\n  }\n\n  /// @notice Setter for homeChain Id\n  /// @param _homeChain New home chainId\n  function setHomeChain(uint32 _homeChain) external onlyDao {\n    homeChain = _homeChain;\n  }\n\n  /// @notice Setter for gameChain Id\n  /// @param _gameChain New chainId for game contract\n  function setGameChainId(uint32 _gameChain) external onlyDao {\n    gameChain = _gameChain;\n  }\n\n  /// @notice Whitelists vault address for onlyVault modifier\n  function toggleVaultWhitelist(address _vault) external onlyDao {\n    vaultWhitelist[_vault] = !vaultWhitelist[_vault];\n  }\n\n  /// @notice Setter for dao address\n  function setDao(address _dao) external onlyDao {\n    dao = _dao;\n  }\n\n  /// @notice Setter for guardian address\n  /// @param _guardian new address of the guardian\n  function setGuardian(address _guardian) external onlyDao {\n    guardian = _guardian;\n  }\n\n  /// @notice Setter for new game address\n  /// @param _game New address of the game\n  function setGame(address _game) external onlyDao {\n    game = _game;\n  }\n\n  /// @notice Setter for vault address to vaultNumber for guardian\n  function setVaultAddress(uint256 _vaultNumber, address _vault) external onlyDao {\n    vaults[_vaultNumber] = _vault;\n  }\n\n  /*\n  Only Guardian functions\n  */\n\n  /// @notice Guardian function to send funds back to xController when xCall fails\n  function sendFundsToXController(address _token) external onlyGuardian {\n    require(xControllerChain == homeChain, \"No xController on this chain\");\n    require(xController != address(0), \"Zero address\");\n\n    uint256 balance = IERC20(_token).balanceOf(address(this));\n    IERC20(_token).transfer(xController, balance);\n  }\n\n  /// @notice Guardian function to send funds back to vault when xCall fails\n  function sendFundsToVault(uint256 _vaultNumber, address _token) external onlyGuardian {\n    address vault = vaults[_vaultNumber];\n    require(vault != address(0), \"Zero address\");\n\n    uint256 balance = IERC20(_token).balanceOf(address(this));\n    IERC20(_token).transfer(vault, balance);\n  }\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/XProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IVault.sol\";\nimport \"./Interfaces/IXChainController.sol\";\nimport \"./Interfaces/IGame.sol\";\nimport \"./Interfaces/ExternalInterfaces/IConnext.sol\";\nimport \"./Interfaces/ExternalInterfaces/IXReceiver.sol\";\n\ncontract XProvider is IXReceiver {\n  using SafeERC20 for IERC20;\n\n  address public immutable connext;\n\n  address private dao;\n  address private guardian;\n  address public xController;\n  address public xControllerProvider;\n  address public game;\n\n  uint32 public homeChain;\n  uint32 public xControllerChain;\n  uint32 public gameChain;\n\n  // (domainID => contract address) mapping domainIDs to trusted remote xProvider on that specific domain\n  mapping(uint32 => address) public trustedRemoteConnext;\n  // (vaultAddress => bool): used for whitelisting vaults\n  mapping(address => bool) public vaultWhitelist;\n  // (vaultNumber => vaultAddress): used for guardian when xCall fails\n  mapping(uint256 => address) public vaults;\n\n  event SetTrustedRemote(uint32 _srcChainId, bytes _srcAddress);\n  event SetTrustedRemoteConnext(uint32 _srcChainId, address _srcAddress);\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"xProvider: only DAO\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"only Guardian\");\n    _;\n  }\n\n  modifier onlyController() {\n    require(msg.sender == xController, \"xProvider: only Controller\");\n    _;\n  }\n\n  modifier onlyVaults() {\n    require(vaultWhitelist[msg.sender], \"xProvider: only vault\");\n    _;\n  }\n\n  modifier onlyGame() {\n    require(msg.sender == game, \"xProvider: only Game\");\n    _;\n  }\n\n  /// @notice Solution for the low-level call in xReceive that is seen as an external call\n  modifier onlySelf() {\n    require(msg.sender == address(this), \"xProvider: only Self\");\n    _;\n  }\n\n  modifier onlySelfOrVault() {\n    require(\n      msg.sender == address(this) || vaultWhitelist[msg.sender],\n      \"xProvider: only Self or Vault\"\n    );\n    _;\n  }\n\n  /** @notice A modifier for authenticated calls.\n   * This is an important security consideration. If the target contract\n   * function should be authenticated, it must check three things:\n   *    1) The originating call comes from the expected origin domain.\n   *    2) The originating call comes from the expected source contract.\n   *    3) The call to this contract comes from Connext.\n   */\n  modifier onlySource(address _originSender, uint32 _origin) {\n    require(_originSender == trustedRemoteConnext[_origin] && msg.sender == connext, \"Not trusted\");\n    _;\n  }\n\n  constructor(\n    address _connext,\n    address _dao,\n    address _guardian,\n    address _game,\n    address _xController,\n    uint32 _homeChain\n  ) {\n    connext = _connext;\n    dao = _dao;\n    guardian = _guardian;\n    game = _game;\n    xController = _xController;\n    homeChain = _homeChain;\n  }\n\n  /// @notice Function to send function selectors crossChain\n  /// @param _destinationDomain chain Id of destination chain\n  /// @param _callData Function selector to call on receiving chain with params\n  /// @param _relayerFee The fee offered to the relayers, if 0 use the complete msg.value\n  function xSend(uint32 _destinationDomain, bytes memory _callData, uint256 _relayerFee) internal {\n    address target = trustedRemoteConnext[_destinationDomain];\n    require(target != address(0), \"XProvider: destination chain not trusted\");\n    uint256 relayerFee = _relayerFee != 0 ? _relayerFee : msg.value;\n\n    IConnext(connext).xcall{value: relayerFee}(\n      _destinationDomain, // _destination: Domain ID of the destination chain\n      target, // _to: address of the target contract\n      address(0), // _asset: use address zero for 0-value transfers\n      msg.sender, // _delegate: address that can revert or forceLocal on destination\n      0, // _amount: 0 because no funds are being transferred\n      0, // _slippage: can be anything between 0-10000 because no funds are being transferred\n      _callData // _callData: the encoded calldata to send\n    );\n  }\n\n  /// @notice Transfers funds from one chain to another.\n  /// @param _token Address of the token on this domain.\n  /// @param _amount The amount to transfer.\n  /// @param _recipient The destination address (e.g. a wallet).\n  /// @param _destinationDomain The destination domain ID.\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\n  /// @param _relayerFee The fee offered to the relayers for confirmation message, msg.value - _relayerFee is what goes to the routers\n  function xTransfer(\n    address _token,\n    uint256 _amount,\n    address _recipient,\n    uint32 _destinationDomain,\n    uint256 _slippage,\n    uint256 _relayerFee\n  ) internal {\n    require(\n      IERC20(_token).allowance(msg.sender, address(this)) >= _amount,\n      \"User must approve amount\"\n    );\n\n    // User sends funds to this contract\n    IERC20(_token).transferFrom(msg.sender, address(this), _amount);\n\n    // This contract approves transfer to Connext\n    IERC20(_token).approve(address(connext), _amount);\n\n    IConnext(connext).xcall{value: (msg.value - _relayerFee)}(\n      _destinationDomain, // _destination: Domain ID of the destination chain\n      _recipient, // _to: address receiving the funds on the destination\n      _token, // _asset: address of the token contract\n      msg.sender, // _delegate: address that can revert or forceLocal on destination\n      _amount, // _amount: amount of tokens to transfer\n      _slippage, // _slippage: the maximum amount of slippage the user will accept in BPS (e.g. 30 = 0.3%)\n      bytes(\"\") // _callData: empty bytes because we're only sending funds\n    );\n  }\n\n  /// @notice function implemented from IXReceive from connext, standard way to receive messages with connext.\n  /// @param _transferId not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _amount not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _asset not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _originSender sender contract.\n  /// @param _origin sender domain id.\n  /// @param _callData calldata, contains function signature which has to be called in this contract as well as the values, hashed and encoded.\n  function xReceive(\n    bytes32 _transferId,\n    uint256 _amount,\n    address _asset,\n    address _originSender,\n    uint32 _origin,\n    bytes memory _callData\n  ) external onlySource(_originSender, _origin) returns (bytes memory) {\n    (bool success, ) = address(this).call(_callData);\n    require(success, \"xReceive: No success\");\n  }\n\n  /// @notice Step 1 push; Game pushes totalDeltaAllocations to xChainController\n  /// @notice Pushes the delta allocations from the game to the xChainController\n  /// @param _vaultNumber number of the vault\n  /// @param _deltas Array with delta Allocations for all chainIds\n  function pushAllocations(\n    uint256 _vaultNumber,\n    int256[] memory _deltas\n  ) external payable onlyGame {\n    if (homeChain == xControllerChain) {\n      return IXChainController(xController).receiveAllocationsFromGame(_vaultNumber, _deltas);\n    }\n    bytes4 selector = bytes4(keccak256(\"receiveAllocations(uint256,int256[])\"));\n    bytes memory callData = abi.encodeWithSelector(selector, _vaultNumber, _deltas);\n\n    xSend(xControllerChain, callData, 0);\n  }\n\n  /// @notice Step 1 receive; Game pushes totalDeltaAllocations to xChainController\n  /// @notice Receives the delta allocations from the game and routes to xChainController\n  /// @param _vaultNumber number of the vault\n  /// @param _deltas Array with delta Allocations for all chainIds\n  function receiveAllocations(uint256 _vaultNumber, int256[] memory _deltas) external onlySelf {\n    return IXChainController(xController).receiveAllocationsFromGame(_vaultNumber, _deltas);\n  }\n\n  /// @notice Step 2 push; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\n  /// @notice Pushes cross chain requests for the totalUnderlying for a vaultNumber on a chainId\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _underlying TotalUnderling plus vault balance in vaultcurrency e.g USDC\n  /// @param _totalSupply Supply of the LP token of the vault on given chainId\n  /// @param _withdrawalRequests Total amount of withdrawal requests from the vault in LP Tokens\n  function pushTotalUnderlying(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _underlying,\n    uint256 _totalSupply,\n    uint256 _withdrawalRequests\n  ) external payable onlyVaults {\n    if (_chainId == xControllerChain) {\n      return\n        IXChainController(xController).setTotalUnderlying(\n          _vaultNumber,\n          _chainId,\n          _underlying,\n          _totalSupply,\n          _withdrawalRequests\n        );\n    } else {\n      bytes4 selector = bytes4(\n        keccak256(\"receiveTotalUnderlying(uint256,uint32,uint256,uint256,uint256)\")\n      );\n      bytes memory callData = abi.encodeWithSelector(\n        selector,\n        _vaultNumber,\n        _chainId,\n        _underlying,\n        _totalSupply,\n        _withdrawalRequests\n      );\n\n      xSend(xControllerChain, callData, 0);\n    }\n  }\n\n  /// @notice Step 2 receive; Vaults push totalUnderlying, totalSupply and totalWithdrawalReq"
    }
  ]
}