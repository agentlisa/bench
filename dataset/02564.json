{
  "Title": "H-1: Illuminate's PT doesn't respect users' slippage specifications for underlyings",
  "Content": "# Issue H-1: Illuminate's PT doesn't respect users' slippage specifications for underlyings \n\nSource: https://github.com/sherlock-audit/2023-01-illuminate-judging/issues/16 \n\n## Found by \nIllIllI\n\n## Summary\nIlluminate's PT doesn't respect users' slippage specifications for underlyings, and allows more slippage than is requested\n\n## Vulnerability Detail\n`ERC5095.withdraw()`/`redeem()`'s code adds extra underlying slippage on top of what the user requests\n\n## Impact\nAt the end of withdrawal/redemption, the user will end up receiving less underlying than they asked for, due to slippage. If the user had used a external PT to mint the Illuminate PT, they will have lost part of their principal.\n\n\n## Code Snippet\n```solidity\n// File: src/tokens/ERC5095.sol : ERC5095.withdraw()   #1\n\n271                    uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n272                        underlying,\n273                        maturity,\n274                        shares,\n275 @>                     Cast.u128(a - (a / 100))\n276:                   );\n```\nhttps://github.com/sherlock-audit/2023-01-illuminate/blob/main/src/tokens/ERC5095.sol#L271-L276\n\n```solidity\n// File: src/tokens/ERC5095.sol : ERC5095.withdraw()   #2\n\n302                    uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n303                        underlying,\n304                        maturity,\n305                        Cast.u128(shares),\n306 @>                     Cast.u128(a - (a / 100))\n307:                   );\n```\nhttps://github.com/sherlock-audit/2023-01-illuminate/blob/main/src/tokens/ERC5095.sol#L302-L307\n\n`redeem()` has the [same](https://github.com/sherlock-audit/2023-01-illuminate/blob/main/src/tokens/ERC5095.sol#L380-L385) [issue](https://github.com/sherlock-audit/2023-01-illuminate/blob/main/src/tokens/ERC5095.sol#L404-L409)\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\nThis is the same issue that I described in the [last contest](https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/114). In the original issue, the finding was disputed because there wasn't a clean solution for slippage protection on the number of shares burned in order to satisfy the input underlying amount. During the discussion of the issue, it became clear that the `ERC5095` contract was supposed to be cross-compatable with the `ERC4626` standard, and that standard has this to say:\n\n`If implementors intend to support EOA account access directly, they should consider adding an additional function call for deposit/mint/withdraw/redeem with the means to accommodate slippage loss or unexpected deposit/withdrawal limits, since they have no other means to revert the transaction if the exact output amount is not achieved.\n` https://eips.ethereum.org/EIPS/eip-4626\n\nIn other words, it's not up to the `ERC4626`/`ERC5095` contract implementation itself to determine whether too many shares needed to be burned in order to satisfy the request for exactly the provided number of underlying - it's up to the caller to have extra code to determine whether the number is satsifactory itself. Note though that both standards are very clear that the _exact_ number of underlying _must_ be provided back, and the implmentation as it stands does _not_ do this.\n\n\n## Discussion\n\n**sourabhmarathe**\n\nWe believe this issue and its duplicates are related to the same underlying problem of complying with ERC4626. \n\nWe will address this issue and its duplicates altogether in one PR. \n\n**thereksfour**\n\nEscalate for 5 USDC\n\nSlight-moderate incorrect slippage controls historically have been graded as medium not high.\nLook at the Criteria for Issues:\n```\nMedium: There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost. The attack path is possible with assumptions that either mimic on-chain conditions or reflect conditions that have a reasonable chance of becoming true in the future. The more expensive the attack is for an attacker, the less likely it will be included as a Medium (holding all other factors constant). The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n\nHigh: This vulnerability would result in a material loss of funds and the cost of the attack is low (relative to the amount of funds lost). The attack path is possible with reasonable assumptions that mimic on-chain conditions. The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n```\nThe cost to the attacker to exploit this vulnerability is not low\n\n**sherlock-admin**\n\n > Escalate for 5 USDC\n> \n> Slight-moderate incorrect slippage controls historically have been graded as medium not high.\n> Look at the Criteria for Issues:\n> ```\n> Medium: There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost. The attack path is possible with assumptions that either mimic on-chain conditions or reflect conditions that have a reasonable chance of becoming true in the future. The more expensive the attack is for an attacker, the less likely it will be included as a Medium (holding all other factors constant). The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n> \n> High: This vulnerability would result in a material loss of funds and the cost of the attack is low (relative to the amount of funds lost). The attack path is possible with reasonable assumptions that mimic on-chain conditions. The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n> ```\n> The cost to the attacker to exploit this vulnerability is not low\n\nYou've created a valid escalation for 5 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation rejected\n\nThe cost is extremely low for a MEV bot to trigger slippage, and the slippage amount is hard-coded, so the issue exists for all the users every time the protocol is used \n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> The cost is extremely low for a MEV bot to trigger slippage, and the slippage amount is hard-coded, so the issue exists for all the users every time the protocol is used \n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/35",
  "Code": [
    {
      "filename": "src/tokens/ERC5095.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC20Permit.sol';\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IRedeemer.sol';\nimport 'src/interfaces/IMarketPlace.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/lib/Cast.sol';\nimport 'src/lib/Safe.sol';\n\ncontract ERC5095 is ERC20Permit, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public immutable override maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public immutable override underlying;\n    /// @dev address of the minting authority\n    address public immutable lender;\n    /// @dev address of the \"marketplace\" YieldSpace AMM router\n    address public immutable marketplace;\n    ///@dev Interface to interact with the pool\n    address public pool;\n\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    address public immutable redeemer;\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    constructor(\n        address _underlying,\n        uint256 _maturity,\n        address _redeemer,\n        address _lender,\n        address _marketplace,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20Permit(name_, symbol_, decimals_) {\n        underlying = _underlying;\n        maturity = _maturity;\n        redeemer = _redeemer;\n        lender = _lender;\n        marketplace = _marketplace;\n        pool = address(0);\n    }\n\n    /// @notice Allows the marketplace to set the pool\n    /// @param p Address of the pool\n    /// @return bool True if successful\n    function setPool(address p)\n        external\n        authorized(marketplace)\n        returns (bool)\n    {\n        pool = p;\n        return true;\n    }\n\n    /// @notice Post or at maturity, converts an amount of principal tokens to an amount of underlying that would be returned.\n    /// @param s The amount of principal tokens to convert\n    /// @return uint256 The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 s)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewRedeem(s);\n        }\n        return s;\n    }\n\n    /// @notice Post or at maturity, converts a desired amount of underlying tokens returned to principal tokens needed.\n    /// @param a The amount of underlying tokens to convert\n    /// @return uint256 The amount of principal tokens returned by the conversion\n    function convertToShares(uint256 a)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewWithdraw(a);\n        }\n        return a;\n    }\n\n    /// @notice Returns user's PT balance\n    /// @param o The address of the owner for which redemption is calculated\n    /// @return uint256 The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address o) external view override returns (uint256) {\n        return _balanceOf[o];\n    }\n\n    /// @notice Post or at maturity, returns user's PT balance. Prior to maturity, returns a previewRedeem for owner's PT balance.\n    /// @param  o The address of the owner for which withdrawal is calculated\n    /// @return uint256 maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address o) external view override returns (uint256) {\n        if (block.timestamp < maturity) {\n            return previewRedeem(_balanceOf[o]);\n        }\n        return _balanceOf[o];\n    }\n\n    /// @notice Post or at maturity, returns 0. Prior to maturity, returns the amount of `shares` when spending `assets` in underlying on a YieldSpace AMM.\n    /// @param a The amount of underlying spent\n    /// @return uint256 The amount of PT purchased by spending `assets` of underlying\n    function previewDeposit(uint256 a) public view returns (uint256) {\n        if (block.timestamp < maturity) {\n            return IYield(pool).sellBasePreview(Cast.u128(a));\n        }\n        return 0;\n    }\n\n    /// @notice Post or at maturity, returns 0. Prior to maturity, returns the amount of `assets` in underlying spent on a purchase of `shares` in PT on a YieldSpace AMM.\n    /// @param s The amount of principal tokens bought in the simulation\n    /// @return uint256 The amount of underlying spent to purchase `shares` of PT\n    function previewMint(uint256 s) public view returns (uint256) {\n        if (block.timestamp < maturity) {\n            return IYield(pool).buyFYTokenPreview(Cast.u128(s));\n        }\n        return 0;\n    }\n\n    /// @notice Post or at maturity, simulates the effects of redeemption at the current block. Prior to maturity, returns the amount of `assets from a sale of `shares` in PT from a sale of PT on a YieldSpace AMM.\n    /// @param s The amount of principal tokens redeemed in the simulation\n    /// @return uint256 The amount of underlying returned by `shares` of PT redemption\n    function previewRedeem(uint256 s) public view override returns (uint256) {\n        if (block.timestamp >= maturity) {\n            // After maturity, the amount redeemed is based on the Redeemer contract's holdings of the underlying\n            Cast.u128(\n                s *\n                    Cast.u128(\n                        IRedeemer(redeemer).holdings(underlying, maturity)\n                    )\n            ) / _totalSupply;\n            return s;\n        }\n\n        // Prior to maturity, return a a preview of a swap on the pool\n        return IYield(pool).sellFYTokenPreview(Cast.u128(s));\n    }\n\n    /// @notice Post or at maturity, simulates the effects of withdrawal at the current block. Prior to maturity, simulates the amount of PTs necessary to receive `assets` in underlying from the sale of PTs on a YieldSpace AMM.\n    /// @param a The amount of underlying tokens withdrawn in the simulation\n    /// @return uint256 The amount of principal tokens required for the withdrawal of `assets`\n    function previewWithdraw(uint256 a) public view override returns (uint256) {\n        if (block.timestamp >= maturity) {\n            // After maturity, the amount redeemed is based on the Redeemer contract's holdings of the underlying\n            return\n                (a * _totalSupply) /\n                IRedeemer(redeemer).holdings(underlying, maturity);\n        }\n\n        // Prior to maturity, return a a preview of a swap on the pool\n        return IYield(pool).buyBasePreview(Cast.u128(a));\n    }\n\n    /// @notice Before maturity spends `assets` of underlying, and sends `shares` of PTs to `receiver`. Post or at maturity, reverts.\n    /// @param r The receiver of the principal tokens\n    /// @param a The amount of underlying tokens deposited\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function deposit(address r, uint256 a) external override returns (uint256) {\n        // Revert if called at or after maturity\n        if (block.timestamp >= maturity) {\n            revert Exception(\n                21,\n                block.timestamp,\n                maturity,\n                address(0),\n                address(0)\n            );\n        }\n\n        // Preview how many shares are needed to withdraw the desired amount of underlying\n        uint128 shares = Cast.u128(previewDeposit(a));\n\n        // Receive the funds from the sender\n        Safe.transferFrom(IERC20(underlying), msg.sender, address(this), a);\n\n        // consider the hardcoded slippage limit, 4626 compliance requires no minimum param.\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n            underlying,\n            maturity,\n            Cast.u128(a),\n            shares\n        );\n\n        // Ensure the user received at least the amount desired\n        if (returned < a) {\n            revert Exception(16, returned, a, address(0), address(0));\n        }\n\n        // Pass the received shares onto the intended receiver\n        _transfer(address(this), r, returned);\n\n        return returned;\n    }\n\n    /// @notice Before maturity mints `shares` of PTs to `receiver` by spending underlying. Post or at maturity, reverts.\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param s The amount of underlying tokens withdrawn\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function mint(address r, uint256 s) external override returns (uint256) {\n        // Revert if called at or after maturity\n        if (block.timestamp >= maturity) {\n            revert Exception(\n                21,\n                block.timestamp,\n                maturity,\n                address(0),\n                address(0)\n            );\n        }\n\n        // Calculate how much underlying will be needed to mint the desired shares\n        uint128 assets = Cast.u128(previewMint(s));\n\n        // Transfer the underlying to the token\n        Safe.transferFrom(\n            IERC20(underlying),\n            msg.sender,\n            address(this),\n            assets\n        );\n\n        // Swap the underlying for principal tokens via the pool\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n            underlying,\n            maturity,\n            assets,\n            Cast.u128(s - (s / 100))\n        );\n\n        // Transfer the principal tokens to the desired receiver\n        _transfer(address(this), r, returned);\n\n        return returned;\n    }\n\n    /// @notice At or after maturity, burns `a` PTs from owner and sends underlying to `receiver`. Before maturity, sends `assets` by selling shares of PT on a YieldSpace AMM.\n    /// @param a The amount of underlying tokens withdrawn\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o The owner of the underlying tokens\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function withdraw(\n        uint256 a,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Refers to how many shares are needed to withdraw `a` underlying\n        uint128 shares = Cast.u128(previewWithdraw(a));\n\n        // Pre maturity\n        if (block.timestamp < maturity) {\n            // Receive the shares from the caller\n            _transfer(o, address(this), shares);\n\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    shares,\n                    Cast.u128(a - (a / 100))\n                );\n\n                // Transdfer the underlying to the desired receiver\n                Safe.transfer(IERC20(underlying), r, returned);\n\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                // Get the allowance of the user spending the tokens\n                uint256 allowance = _allowance[o][msg.sender];\n\n                // Check for sufficient allowance\n                if (allowance < shares) {\n                    revert Exception(\n                        20,\n                        allowance,\n                        shares,\n                        address(0),\n                        address(0)\n                    );\n                }\n\n                // Update the caller's allowance\n                _allowance[o][msg.sender] = allowance - shares;\n\n                // Sell the principal tokens for underlying\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(shares),\n                    Cast.u128(a - (a / 100))\n                );\n\n                // Transfer the underlying to the desired receiver\n                Safe.transfer(IERC20(underlying), r, returned);\n\n                return returned;\n            }\n        }\n        // Post maturity\n        else {\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                // Execute the redemption to the desired receiver\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        msg.sender,\n                        r,\n                        shares\n                    );\n            } else {\n                // Get the allowance of the user spending the tokens\n                uint256 allowance = _allowance[o][msg.sender];\n\n                // Check for sufficient allowance\n                if (allowance < shares) {\n                    revert Exception(\n                        20,\n                        allowance,\n                        shares,\n                        address(0),\n                        address(0)\n                    );\n                }\n\n                // Update the callers's allowance\n                _allowance[o][msg.sender] = allowance - shares;\n\n                // Execute the redemption to the desired receiver\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        o,\n                        r,\n                        shares\n                    );\n            }\n        }\n    }\n\n    /// @notice At or after maturity, burns exactly `shares` of Principal Tokens from `owner` and sends `assets` of underlying tokens to `receiver`. Before maturity, sends `assets` by selling `shares` of PT on a YieldSpace AMM.\n    /// @param s The number of shares to be burned in exchange for the underlying asset\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o Address of the owner of the shares being burned\n    /// @return uint256 The amount of underlying tokens distributed by the redemption\n    function redeem(\n        uint256 s,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Pre-maturity\n        if (block.timestamp < maturity) {\n            // Receive the funds from the user\n            _transfer(o, address(this), s);\n\n            // Determine how much underlying must be sold to receive desired principal token amount\n            uint128 assets = Cast.u128(previewRedeem(s));\n\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                // Swap principal tokens for the underlying asset\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    assets - (assets / 100)\n                );\n\n                // Transfer underlying to the desired receiver\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                // Get the allowance of the user spending the tokens\n                uint256 allowance = _allowance[o][msg.sender];\n\n                // Check for sufficient allowance\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n\n                // Update the caller's allowance\n                _allowance[o][msg.sender] = allowance - s;\n\n                // Sell the principal tokens for the underlying\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    assets - (assets / 100)\n                );\n\n                // Transfer the underlying to the desired receiver\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n            }\n            // Post-maturity\n        } else {\n            // If owner is the sender, redeem PT without allowance check\n            if (o == msg.sender) {\n                // Execute the redemption to the desired receiver\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        msg.sender,\n                        r,\n                        s\n                    );\n            } else {\n                // Get the allowance of the user spending the tokens\n                uint256 allowance = _allowance[o][msg.sender];\n\n                // Check for sufficient allowance\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n\n                // Update the caller's allowance\n                _allowance[o][msg.sender] = allowance - s;\n\n                // Execute the redemption to the desired receiver\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        o,\n                        r,\n                        s\n                    );\n            }\n        }\n    }\n\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    /// @return bool true if successful\n    function authBurn(address f, uint256 a)\n        external\n        authorized(redeemer)\n        returns (bool)\n    {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    /// @return bool True if successful\n    function authMint(address t, uint256 a)\n        external\n        authorized(lender)\n        returns (bool)\n    {\n        _mint(t, a);\n        return true;\n    }\n\n    /// @param o Address of the owner of the tokens\n    /// @param s Address of the spender\n    /// @param a Amount to be approved\n    function authApprove(\n        address o,\n        address s,\n        uint256 a\n    ) external authorized(redeemer) returns (bool) {\n        _allowance[o][s] = a;\n        return true;\n    }\n}"
    },
    {
      "filename": "src/tokens/ERC5095.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC20Permit.sol';\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IRedeemer.sol';\nimport 'src/interfaces/IMarketPlace.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/lib/Cast.sol';\nimport 'src/lib/Safe.sol';\n\ncontract ERC5095 is ERC20Permit, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public immutable override maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public immutable override underlying;\n    /// @dev address of the minting authority\n    address public immutable lender;\n    /// @dev address of the \"marketplace\" YieldSpace AMM router\n    address public immutable marketplace;\n    ///@dev Interface to interact with the pool\n    address public pool;\n\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    address public immutable redeemer;\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    constructor(\n        address _underlying,\n        uint256 _maturity,\n        address _redeemer,\n        address _lender,\n        address _marketplace,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20Permit(name_, symbol_, decimals_) {\n        underlying = _underlying;\n        maturity = _maturity;\n        redeemer = _redeemer;\n        lender = _lender;\n        marketplace = _marketplace;\n        pool = address(0);\n    }\n\n    /// @notice Allows the marketplace to set the pool\n    /// @param p Address of the pool\n    /// @return bool True if successful\n    function setPool(address p)\n        external\n        authorized(marketplace)\n        returns (bool)\n    {\n        pool = p;\n        return true;\n    }\n\n    /// @notice Post or at maturity, converts an amount of principal tokens to an amount of underlying that would be returned.\n    /// @param s The amount of principal tokens to convert\n    /// @return uint256 The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 s)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewRedeem(s);\n        }\n        return s;\n    }\n\n    /// @notice Post or at maturity, converts a desired amount of underlying tokens returned to principal tokens needed.\n    /// @param a The amount of underlying tokens to convert\n    /// @return uint256 The amount of principal tokens returned by the conversion\n    function convertToShares(uint256 a)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewWithdraw(a);\n        }\n        return a;\n    }\n\n    /// @notice Returns user's PT balance\n    /// @param o The address of the owner for which redemption is calculated\n    /// @return uint256 The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address o) external view override returns (uint256) {\n        return _balanceOf[o];\n    }\n\n    /// @notice Post or at maturity, returns user's PT balance. Prior to maturity, returns a previewRedeem for owner's PT balance.\n    /// @param  o The address of the owner for which withdrawal is calculated\n    /// @return uint256 maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address o) external view override returns (uint256) {\n        if (block.timestamp < maturity) {\n            return previewRedeem(_balanceOf[o]);\n        }\n        return _balanceOf[o];\n    }\n\n    /// @notice Post or at maturity, returns 0. Prior to maturity, returns the amount of `shares` when spending `assets` in underlying on a YieldSpace AMM.\n    /// @param a The amount of underlying spent\n    /// @return uint256 The amount of PT purchased by spending `assets` of underlying\n    function previewDeposit(uint256 a) public view returns (uint256) {\n        if (block.timestamp < maturity) {\n            return IYield(pool).sellBasePreview(Cast.u128(a));\n        }\n        return 0;\n    }\n\n    /// @notice Post or at maturity, returns 0. Prior to maturity, returns the amount of `assets` in underlying spent on a purchase of `shares` in PT on a YieldSpace AMM.\n    /// @param s The amount of principal tokens bought in the simulation\n    /// @return uint256 The amount of underlying spent to purchase `shares` of PT\n    function previewMint(uint256 s) public view returns (uint256) {\n        if (block.timestamp < maturity) {\n            return IYield(pool).buyFYTokenPreview(Cast.u128(s));\n        }\n        return 0;\n    }\n\n    /// @notice Post or at maturity, simulates the effects of redeemption at the current block. Prior to maturity, returns the amount of `assets from a sale of `shares` in PT from a sale of PT on a YieldSpace AMM.\n    /// @param s The amount of principal tokens redeemed in the simulation\n    /// @return uint256 The amount of underlying returned by `shares` of PT redemption\n    function previewRedeem(uint256 s) public view override returns (uint256) {\n        if (block.timestamp >= maturity) {\n            // After maturity, the amount redeemed is based on the Redeemer contract's holdings of the underlying\n            Cast.u128(\n                s *\n                    Cast.u128(\n                        IRedeemer(redeemer).holdings(underlying, maturity)\n                    )\n            ) / _totalSupply;\n            return s;\n        }\n\n        // Prior to maturity, return a a preview of a swap on the pool\n        return IYield(pool).sellFYTokenPreview(Cast.u128(s));\n    }\n\n    /// @notice Post or at maturity, simulates the effects of withdrawal at the current block. Prior to maturity, simulates the amount of PTs necessary to receive `assets` in underlying from the sale of PTs on a YieldSpace AMM.\n    /// @param a The amount of underlying tokens withdrawn in the simulation\n    /// @return uint256 The amount of principal tokens required for the withdrawal of `assets`\n    function previewWithdraw(uint256 a) public view override returns (uint256) {\n        if (block.timestamp >= maturity) {\n            // After maturity, the amount redeemed is based on the Redeemer contract's holdings of the underlying\n            return\n                (a * _totalSupply) /\n                IRedeemer(redeemer).holdings(underlying, maturity);\n        }\n\n        // Prior to maturity, return a a preview of a swap on the pool\n        return IYield(pool).buyBasePreview(Cast.u128(a));\n    }\n\n    /// @notice Before maturity spends `assets` of underlying, and sends `shares` of PTs to `receiver`. Post or at maturity, reverts.\n    /// @param r The receiver of the principal tokens\n    /// @param a The amount of underlying tokens deposited\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function deposit(address r, uint256 a) external override returns (uint256) {\n        // Revert if called at or after maturity\n        if (block.timestamp >= maturity) {\n            revert Exception(\n                21,\n                block.timestamp,\n                maturity,\n                address(0),\n                address(0)\n            );\n        }\n\n        // Preview how many shares are needed to withdraw the desired amount of underlying\n        uint128 shares = Cast.u128(previewDeposit(a));\n\n        // Receive the funds from the sender\n        Safe.transferFrom(IERC20(underlying), msg.sender, address(this), a);\n\n        // consider the hardcoded slippage limit, 4626 compliance requires no minimum param.\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n            underlying,\n            maturity,\n            Cast.u128(a),\n            shares\n        );\n\n        // Ensure the user received at least the amount desired\n        if (returned < a) {\n            revert Exception(16, returned, a, address(0), address(0));\n        }\n\n        // Pass the received shares onto the intended receiver\n        _transfer(address(this), r, returned);\n\n        return returned;\n    }\n\n    /// @notice Before maturity mints `shares` of PTs to `receiver` by spending underlying. Post or at maturity, reverts.\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param s The amount of underlying tokens withdrawn\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function mint(address r, uint256 s) external override returns (uint256) {\n        // Revert if called at or after maturity\n        if (block.timestamp >= maturity) {\n            revert Exception(\n                21,\n                block.timestamp,\n                maturity,\n                address(0),\n                address(0)\n            );\n        }\n\n        // Calculate how much underlying will be needed to mint the desired shares\n        uint128 assets = Cast.u128(previewMint(s));\n\n        // Transfer the underlying to the token\n        Safe.transferFrom(\n            IERC20(underlying),\n            msg.sender,\n            address(this),\n            assets\n        );\n\n        // Swap the underlying for principal tokens via the pool\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n            underlying,\n            maturity,\n            assets,\n            Cast.u128(s - (s / 100))\n        );\n\n        // Transfer the principal tokens to the desired receiver\n        _transfer(address(this), r, returned);\n\n        return returned;\n    }\n\n    /// @notice At or after maturity, burns `a` PTs from owner and sends underlying to `receiver`. Before maturity, sends `assets` by selling shares of PT on a YieldSpace AMM.\n    /// @param a The amount of underlying tokens withdrawn\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o The owner of the underlying tokens\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function withdraw(\n        uint256 a,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Refers to how many shares are needed to withdraw `a` underlying\n        uint128 shares = Cast.u128(previewWithdraw(a));\n\n        // Pre maturity\n        if (block.timestamp < maturity) {\n            // Receive the shares from the caller\n            _transfer(o, address(this), shares);\n\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    shares,\n                    Cast.u128(a - (a / 100))\n                );\n\n                // Transdfer the underlying to the desired receiver\n                Safe.transfer(IERC20(underlying), r, returned);\n\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                // Get the allowance of the user spending the tokens\n                uint256 allowance = _allowance[o][msg.sender];\n\n                // Check for sufficient allowance\n                if (allowance < shares) {\n                    revert Exception(\n                        20,\n                        allowance,\n                        shares,\n                        address(0),\n                        address(0)\n                    );\n                }\n\n                // Update the caller's allowance\n                _allowance[o][msg.sender] = allowance - shares;\n\n                // Sell the principal tokens for underlying\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(shares),\n                    Cast.u128(a - (a / 100))\n                );\n\n                // Transfer the underlying to the desired receiver\n                Safe.transfer(IERC20(underlying), r, returned);\n\n                return returned;\n            }\n        }\n        // Post maturity\n        else {\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                // Execute the redemption to the desired receiver\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        msg.sender,\n                        r,\n                        shares\n                    );\n            } else {\n                // Get the allowance of the user spending the tokens\n                uint256 allowance = _allowance[o][msg.sender];\n\n                // Check for sufficient allowance\n                if (allowance < shares) {\n                    revert Exception(\n                        20,\n                        allowance,\n                        shares,\n                        address(0),\n                        address(0)\n                    );\n                }\n\n                // Update the callers's allowance\n                _allowance[o][msg.sender] = allowance - shares;\n\n                // Execute the redemption to the desired receiver\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        o,\n                        r,\n                        shares\n                    );\n            }\n        }\n    }\n\n    /// @notice At or after maturity, burns exactly `shares` of Principal Tokens from `owner` and sends `assets` of underlying tokens to `receiver`. Before maturity, sends `assets` by selling `shares` of PT on a YieldSpace AMM.\n    /// @param s The number of shares to be burned in exchange for the underlying asset\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o Address of the owner of the share"
    }
  ]
}