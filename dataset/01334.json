{
  "Title": "Potential DoS in `FertilizerFacet::getFertilizers` if enough Fertilizer is added",
  "Content": "It is possible that [`FertilizerFacet::getFertilizers`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/barn/FertilizerFacet.sol#L172-L192) can be susceptible to DoS if enough Fertilizer NFTs are minted, given that it attempts to query all the nodes of a linked list in two separate while loops. This function is not used anywhere else within the protocol and appears for UI/UX purposes only, but any potential third-party integrations should consider this issue carefully.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/barn/FertilizerFacet.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {AppStorage} from \"../AppStorage.sol\";\nimport \"contracts/libraries/Token/LibTransfer.sol\";\nimport \"contracts/libraries/LibFertilizer.sol\";\nimport \"contracts/C.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\n\n/**\n * @author Publius\n * @title Handles Sprouting Beans from Sprout Tokens\n **/\n\ncontract FertilizerFacet {\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n\n    event SetFertilizer(uint128 id, uint128 bpf);\n\n    AppStorage internal s;\n\n    struct Supply {\n        uint128 endBpf;\n        uint256 supply;\n    }\n\n    function claimFertilized(uint256[] calldata ids, LibTransfer.To mode)\n        external\n        payable\n    {\n        uint256 amount = C.fertilizer().beanstalkUpdate(msg.sender, ids, s.bpf);\n        LibTransfer.sendToken(C.bean(), amount, msg.sender, mode);\n    }\n\n    function mintFertilizer(\n        uint128 amount,\n        uint256 minLP,\n        LibTransfer.From mode\n    ) external payable {\n        uint128 remaining = uint128(LibFertilizer.remainingRecapitalization().div(1e6)); // remaining <= 77_000_000 so downcasting is safe.\n        if (amount > remaining) amount = remaining;\n        amount = uint128(LibTransfer.receiveToken(\n            C.usdc(),\n            uint256(amount).mul(1e6),\n            msg.sender,\n            mode\n        ).div(1e6)); // return value <= amount, so downcasting is safe.\n        uint128 id = LibFertilizer.addFertilizer(\n            uint128(s.season.current),\n            amount,\n            minLP\n        );\n        C.fertilizer().beanstalkMint(msg.sender, uint256(id), amount, s.bpf);\n    }\n\n    function addFertilizerOwner(\n        uint128 id,\n        uint128 amount,\n        uint256 minLP\n    ) external payable {\n        LibDiamond.enforceIsContractOwner();\n        C.usdc().transferFrom(\n            msg.sender,\n            address(this),\n            uint256(amount).mul(1e6)\n        );\n        LibFertilizer.addFertilizer(id, amount, minLP);\n    }\n\n    function payFertilizer(address account, uint256 amount) external payable {\n        require(msg.sender == C.fertilizerAddress());\n        LibTransfer.sendToken(\n            C.bean(),\n            amount,\n            account,\n            LibTransfer.To.INTERNAL\n        );\n    }\n\n    function totalFertilizedBeans() external view returns (uint256 beans) {\n        return s.fertilizedIndex;\n    }\n\n    function totalUnfertilizedBeans() external view returns (uint256 beans) {\n        return s.unfertilizedIndex - s.fertilizedIndex;\n    }\n\n    function totalFertilizerBeans() external view returns (uint256 beans) {\n        return s.unfertilizedIndex;\n    }\n\n    function getFertilizer(uint128 id) external view returns (uint256) {\n        return s.fertilizer[id];\n    }\n\n    function getNext(uint128 id) external view returns (uint128) {\n        return LibFertilizer.getNext(id);\n    }\n\n    function getFirst() external view returns (uint128) {\n        return s.fFirst;\n    }\n\n    function getLast() external view returns (uint128) {\n        return s.fLast;\n    }\n\n    function getActiveFertilizer() external view returns (uint256) {\n        return s.activeFertilizer;\n    }\n\n    function isFertilizing() external view returns (bool) {\n        return s.season.fertilizing;\n    }\n\n    function beansPerFertilizer() external view returns (uint128 bpf) {\n        return s.bpf;\n    }\n\n    function getHumidity(uint128 _s) external pure returns (uint128 humidity) {\n        humidity = LibFertilizer.getHumidity(_s);\n    }\n\n    function getCurrentHumidity() external view returns (uint128 humidity) {\n        humidity = LibFertilizer.getHumidity(s.season.current);\n    }\n\n    function getEndBpf() external view returns (uint128 endBpf) {\n        endBpf = s.bpf.add(LibFertilizer.getBpf(uint128(s.season.current)));\n    }\n\n    function remainingRecapitalization() external view returns (uint256) {\n        return LibFertilizer.remainingRecapitalization();\n    }\n\n    function balanceOfUnfertilized(address account, uint256[] memory ids)\n        external\n        view\n        returns (uint256 beans)\n    {\n        return C.fertilizer().balanceOfUnfertilized(account, ids);\n    }\n\n    function balanceOfFertilized(address account, uint256[] memory ids)\n        external\n        view\n        returns (uint256 beans)\n    {\n        return C.fertilizer().balanceOfFertilized(account, ids);\n    }\n\n    function balanceOfFertilizer(address account, uint256 id)\n        external\n        view\n        returns (IFertilizer.Balance memory)\n    {\n        return C.fertilizer().lastBalanceOf(account, id);\n    }\n\n    function balanceOfBatchFertilizer(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) external view returns (IFertilizer.Balance[] memory) {\n        return C.fertilizer().lastBalanceOfBatch(accounts, ids);\n    }\n\n    function getFertilizers()\n        external\n        view\n        returns (Supply[] memory fertilizers)\n    {\n        uint256 numFerts = 0;\n        uint128 idx = s.fFirst;\n        while (idx > 0) {\n            numFerts = numFerts.add(1);\n            idx = LibFertilizer.getNext(idx);\n        }\n        fertilizers = new Supply[](numFerts);\n        numFerts = 0;\n        idx = s.fFirst;\n        while (idx > 0) {\n            fertilizers[numFerts].endBpf = idx;\n            fertilizers[numFerts].supply = LibFertilizer.getAmount(idx);\n            numFerts = numFerts.add(1);\n            idx = LibFertilizer.getNext(idx);\n        }\n    }\n}"
    }
  ]
}