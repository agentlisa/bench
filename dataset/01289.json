{
  "Title": "H-2: `recipientsCounter` should start from 1 in `DonationVotingMerkleDistributionBaseStrategy`",
  "Content": "# Issue H-2: `recipientsCounter` should start from 1 in `DonationVotingMerkleDistributionBaseStrategy` \n\nSource: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/199 \n\n## Found by \n0xkaden, 0xnirlin, GimelSec, Kow, branch\\_indigo, nobody2018\nWhen doing `DonationVotingMerkleDistributionBaseStrategy._registerRecipient`, it checks the current status of the recipient. If the recipient is new to the pool, the status should be `Status.None`. However, `recipientsCounter` starts from 0. The new recipient actually gets the status of first recipient of the pool.\n\n## Vulnerability Detail\n\n`DonationVotingMerkleDistributionBaseStrategy._registerRecipient` calls `_getUintRecipientStatus` to get the current status of the application. The status of the new application should be `Status.None`. Then, the `recipientToStatusIndexes[recipientId]`  to `recipientsCounter` and `recipientsCounter`.\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L580\n```solidity\n    function _registerRecipient(bytes memory _data, address _sender)\n        internal\n        override\n        onlyActiveRegistration\n        returns (address recipientId)\n    {\n        …\n\n        uint8 currentStatus = _getUintRecipientStatus(recipientId);\n\n        if (currentStatus == uint8(Status.None)) {\n            // recipient registering new application\n            recipientToStatusIndexes[recipientId] = recipientsCounter;\n            _setRecipientStatus(recipientId, uint8(Status.Pending));\n\n            bytes memory extendedData = abi.encode(_data, recipientsCounter);\n            emit Registered(recipientId, extendedData, _sender);\n\n            recipientsCounter++;\n        } else {\n            if (currentStatus == uint8(Status.Accepted)) {\n                // recipient updating accepted application\n                _setRecipientStatus(recipientId, uint8(Status.Pending));\n            } else if (currentStatus == uint8(Status.Rejected)) {\n                // recipient updating rejected application\n                _setRecipientStatus(recipientId, uint8(Status.Appealed));\n            }\n            emit UpdatedRegistration(recipientId, _data, _sender, _getUintRecipientStatus(recipientId));\n        }\n    }\n```\n\n`DonationVotingMerkleDistributionBaseStrategy._getUintRecipientStatus` calls `_getStatusRowColumn` to get the column index and current row.\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L819\n```solidity\n    function _getUintRecipientStatus(address _recipientId) internal view returns (uint8 status) {\n        // Get the column index and current row\n        (, uint256 colIndex, uint256 currentRow) = _getStatusRowColumn(_recipientId);\n\n        // Get the status from the 'currentRow' shifting by the 'colIndex'\n        status = uint8((currentRow >> colIndex) & 15);\n\n        // Return the status\n        return status;\n    }\n```\n\n`DonationVotingMerkleDistributionBaseStrategy._getStatusRowColumn` computes indexes from `recipientToStatusIndexes[_recipientId]`. For the new recipient. Those indexes should be zero.\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L833\n```solidity\n    function _getStatusRowColumn(address _recipientId) internal view returns (uint256, uint256, uint256) {\n        uint256 recipientIndex = recipientToStatusIndexes[_recipientId];\n\n        uint256 rowIndex = recipientIndex / 64; // 256 / 4\n        uint256 colIndex = (recipientIndex % 64) * 4;\n\n        return (rowIndex, colIndex, statusesBitMap[rowIndex]);\n    }\n```\n\nThe problem is that `recipientCounter` starts from zero.\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L166\n```solidity\n    /// @notice The total number of recipients.\n    uint256 public recipientsCounter;\n```\n\nConsider the following situation:\n* Alice is the first recipient calls `registerRecipient`\n```solidity\n// in _registerRecipient\nrecipientToStatusIndexes[Alice] = recipientsCounter = 0;\n_setRecipientStatus(Alice, uint8(Status.Pending));\nrecipientCounter++\n```\n* Bob calls `registerRecipient`.\n```solidity\n// in _getStatusRowColumn\nrecipientToStatusIndexes[Bob] = 0 // It would access the status of Alice\n// in _registerRecipient\ncurrentStatus = _getUintRecipientStatus(recipientId) = Status.Pending\ncurrentStatus != uint8(Status.None) -> no new application is recorded in the pool.\n```\n\nThis implementation error makes the pool can only record the first application.\n\n## Impact\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L580\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L819\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L833\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L166\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nMake the counter start from 1. There are two methods to fix the  issue.\n\n1.\n```diff\n    /// @notice The total number of recipients.\n+   uint256 public recipientsCounter;\n-   uint256 public recipientsCounter;\n```\n\n2.\n```diff\n    function _registerRecipient(bytes memory _data, address _sender)\n        internal\n        override\n        onlyActiveRegistration\n        returns (address recipientId)\n    {\n        …\n\n        uint8 currentStatus = _getUintRecipientStatus(recipientId);\n\n        if (currentStatus == uint8(Status.None)) {\n            // recipient registering new application\n+           recipientToStatusIndexes[recipientId] = recipientsCounter + 1;\n-           recipientToStatusIndexes[recipientId] = recipientsCounter;\n            _setRecipientStatus(recipientId, uint8(Status.Pending));\n\n            bytes memory extendedData = abi.encode(_data, recipientsCounter);\n            emit Registered(recipientId, extendedData, _sender);\n\n            recipientsCounter++;\n        …\n    }\n```\n\n\n\n## Discussion\n\n**AhmadDecoded**\n\nEscalate\n\nThis should be upgraded to high, breaks the core functionality of protocol, setting wrong status.\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This should be upgraded to high, breaks the core functionality of protocol, setting wrong status.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**kadenzipfel**\n\nTo clarify impact, adding to @AhmadDecoded's escalation, since every new recipient after the initial registered recipient will have a `currentStatus != Status.None`, we will continually update the status of the initial recipient, never actually correctly marking any recipient statuses. Since the registration process is used to determine distribution, in the worst case, following the on-chain registration statuses as expected to determine distribution, the pool manager may incorrectly distribute the full poolAmount solely to the initial registered recipient. In the best case, the pool will not be usable and a new one will have to be redeployed, causing the pool manager and any registered recipients to lose a material amount of funds due to gas costs _every time_ a pool is created with this strategy.\n\nTo summarize, since the impact is either (perhaps unlikely) significant fund loss by believing contract state to be true or (100% likely) less significant gas loss due to the system completely failing _every time_, this should be classified as high severity.\n\n**neeksec**\n\nAgree with Escalation that this is a high becasue of this impact described by @kadenzipfel,\n\n> in the worst case, following the on-chain registration statuses as expected to determine distribution, the pool manager may incorrectly distribute the full poolAmount solely to the initial registered recipient.\n\n**MLON33**\n\nhttps://github.com/allo-protocol/allo-v2/pull/351\n\n**Evert0x**\n\nPlanning to accept escalation and set severity to high\n\n**Evert0x**\n\nResult:\nHigh\nHas Duplicates \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ahmaddecoded](https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/199/#issuecomment-1762781882): accepted\n\n**jkoppel**\n\nWhy do the duplicates still have the Medium label?\n\n**jack-the-pug**\n\nFixed. Note: `recipientsCounter` is now +1 than the actual count of recipients.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/109",
  "Code": [
    {
      "filename": "allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport {ISignatureTransfer} from \"permit2/ISignatureTransfer.sol\";\nimport {MerkleProof} from \"openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\";\nimport {Multicall} from \"openzeppelin-contracts/contracts/utils/Multicall.sol\";\n// Interfaces\nimport {IAllo} from \"../../core/interfaces/IAllo.sol\";\nimport {IRegistry} from \"../../core/interfaces/IRegistry.sol\";\n// Core Contracts\nimport {BaseStrategy} from \"../BaseStrategy.sol\";\n// Internal Libraries\nimport {Metadata} from \"../../core/libraries/Metadata.sol\";\nimport {Native} from \"../../core/libraries/Native.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Donation Voting Merkle Distribution Strategy\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Strategy for donation voting allocation with a merkle distribution\nabstract contract DonationVotingMerkleDistributionBaseStrategy is Native, BaseStrategy, Multicall {\n    /// ================================\n    /// ========== Struct ==============\n    /// ================================\n\n    /// @notice Struct to hold details of the application status\n    /// @dev Application status is stored in a bitmap. Each 4 bits represents the status of a recipient,\n    /// defined as 'index' here. The first 4 bits of the 256 bits represent the status of the first recipient,\n    /// the second 4 bits represent the status of the second recipient, and so on.\n    ///\n    /// The 'rowIndex' is the index of the row in the bitmap, and the 'statusRow' is the value of the row.\n    /// The 'statusRow' is updated when the status of a recipient changes.\n    ///\n    /// Note: Since we need 4 bits to store a status, one row of the bitmap can hold the status information of 256/4 recipients.\n    ///\n    /// For example, if we have 5 recipients, the bitmap will look like this:\n    /// | recipient1 | recipient2 | recipient3 | recipient4 | recipient5 | 'rowIndex'\n    /// |     0000   |    0001    |    0010    |    0011    |    0100    | 'statusRow'\n    /// |     none   |   pending  |  accepted  |  rejected  |  appealed  | converted status (0, 1, 2, 3, 4)\n    ///\n    struct ApplicationStatus {\n        uint256 index;\n        uint256 statusRow;\n    }\n\n    /// @notice Stores the details of the recipients.\n    struct Recipient {\n        // If false, the recipientAddress is the anchor of the profile\n        bool useRegistryAnchor;\n        address recipientAddress;\n        Metadata metadata;\n    }\n\n    /// @notice Stores the details of the distribution.\n    struct Distribution {\n        uint256 index;\n        address recipientId;\n        uint256 amount;\n        bytes32[] merkleProof;\n    }\n\n    /// @notice Stores the initialize data for the strategy\n    struct InitializeData {\n        bool useRegistryAnchor;\n        bool metadataRequired;\n        uint64 registrationStartTime;\n        uint64 registrationEndTime;\n        uint64 allocationStartTime;\n        uint64 allocationEndTime;\n        address[] allowedTokens;\n    }\n\n    /// @notice Stores the permit2 data for the allocation\n    struct Permit2Data {\n        ISignatureTransfer.PermitTransferFrom permit;\n        bytes signature;\n    }\n\n    /// ===============================\n    /// ========== Events =============\n    /// ===============================\n\n    /// @notice Emitted when a recipient updates their registration\n    /// @param recipientId Id of the recipient\n    /// @param data The encoded data - (address recipientId, address recipientAddress, Metadata metadata)\n    /// @param sender The sender of the transaction\n    /// @param status The updated status of the recipient\n    event UpdatedRegistration(address indexed recipientId, bytes data, address sender, uint8 status);\n\n    /// @notice Emitted when a recipient is registered and the status is updated\n    /// @param rowIndex The index of the row in the bitmap\n    /// @param fullRow The value of the row\n    /// @param sender The sender of the transaction\n    event RecipientStatusUpdated(uint256 indexed rowIndex, uint256 fullRow, address sender);\n\n    /// @notice Emitted when the timestamps are updated\n    /// @param registrationStartTime The start time for the registration\n    /// @param registrationEndTime The end time for the registration\n    /// @param allocationStartTime The start time for the allocation\n    /// @param allocationEndTime The end time for the allocation\n    /// @param sender The sender of the transaction\n    event TimestampsUpdated(\n        uint64 registrationStartTime,\n        uint64 registrationEndTime,\n        uint64 allocationStartTime,\n        uint64 allocationEndTime,\n        address sender\n    );\n\n    /// @notice Emitted when the distribution has been updated with a new merkle root or metadata\n    /// @param merkleRoot The merkle root of the distribution\n    /// @param metadata The metadata of the distribution\n    event DistributionUpdated(bytes32 merkleRoot, Metadata metadata);\n\n    /// @notice Emitted when funds are distributed to a recipient\n    /// @param amount The amount of tokens distributed\n    /// @param grantee The address of the recipient\n    /// @param token The address of the token\n    /// @param recipientId The id of the recipient\n    event FundsDistributed(uint256 amount, address grantee, address indexed token, address indexed recipientId);\n\n    /// @notice Emitted when a batch payout is successful\n    /// @param sender The sender of the transaction\n    event BatchPayoutSuccessful(address indexed sender);\n\n    /// ================================\n    /// ========== Storage =============\n    /// ================================\n\n    /// @notice Metadata containing the distribution data.\n    Metadata public distributionMetadata;\n\n    /// @notice Flag to indicate whether to use the registry anchor or not.\n    bool public useRegistryAnchor;\n\n    /// @notice Flag to indicate whether metadata is required or not.\n    bool public metadataRequired;\n\n    /// @notice Flag to indicate whether the distribution has started or not.\n    bool public distributionStarted;\n\n    /// @notice The timestamps in milliseconds for the start and end times.\n    uint64 public registrationStartTime;\n    uint64 public registrationEndTime;\n    uint64 public allocationStartTime;\n    uint64 public allocationEndTime;\n\n    /// @notice The total amount of tokens allocated to the payout.\n    uint256 public totalPayoutAmount;\n\n    /// @notice The total number of recipients.\n    uint256 public recipientsCounter;\n\n    /// @notice The registry contract interface.\n    IRegistry private _registry;\n\n    /// @notice the permit2 interface\n    ISignatureTransfer public immutable PERMIT2;\n\n    /// @notice The merkle root of the distribution will be set by the pool manager.\n    bytes32 public merkleRoot;\n\n    /// @notice This is a packed array of booleans, 'statuses[0]' is the first row of the bitmap and allows to\n    /// store 256 bits to describe the status of 256 projects. 'statuses[1]' is the second row, and so on\n    /// Instead of using 1 bit for each recipient status, we will use 4 bits for each status\n    /// to allow 5 statuses:\n    /// 0: none\n    /// 1: pending\n    /// 2: accepted\n    /// 3: rejected\n    /// 4: appealed\n    /// Since it's a mapping the storage it's pre-allocated with zero values, so if we check the\n    /// status of an existing recipient, the value is by default 0 (none).\n    /// If we want to check the status of an recipient, we take its index from the `recipients` array\n    /// and convert it to the 2-bits position in the bitmap.\n    mapping(uint256 => uint256) public statusesBitMap;\n\n    /// @notice 'recipientId' => 'statusIndex'\n    /// @dev 'statusIndex' is the index of the recipient in the 'statusesBitMap' bitmap.\n    mapping(address => uint256) public recipientToStatusIndexes;\n\n    /// @notice This is a packed array of booleans to keep track of claims distributed.\n    /// @dev distributedBitMap[0] is the first row of the bitmap and allows to store 256 bits to describe\n    /// the status of 256 claims\n    mapping(uint256 => uint256) private distributedBitMap;\n\n    /// @notice 'token' address => boolean (allowed = true).\n    /// @dev This can be updated by the pool manager.\n    mapping(address => bool) public allowedTokens;\n\n    /// @notice 'recipientId' => 'Recipient' struct.\n    mapping(address => Recipient) internal _recipients;\n\n    /// ================================\n    /// ========== Modifier ============\n    /// ================================\n\n    /// @notice Modifier to check if the registration is active\n    /// @dev This will revert if the registration has not started or if the registration has ended.\n    modifier onlyActiveRegistration() {\n        _checkOnlyActiveRegistration();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation is active\n    /// @dev This will revert if the allocation has not started or if the allocation has ended.\n    modifier onlyActiveAllocation() {\n        _checkOnlyActiveAllocation();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation has ended\n    /// @dev This will revert if the allocation has not ended.\n    modifier onlyAfterAllocation() {\n        _checkOnlyAfterAllocation();\n        _;\n    }\n\n    /// ===============================\n    /// ======== Constructor ==========\n    /// ===============================\n\n    /// @notice Constructor for the Donation Voting Merkle Distribution Strategy\n    /// @param _allo The 'Allo' contract\n    /// @param _name The name of the strategy\n    constructor(address _allo, string memory _name, ISignatureTransfer _permit2) BaseStrategy(_allo, _name) {\n        if (address(_permit2) == address(0)) revert ZERO_ADDRESS();\n        PERMIT2 = _permit2;\n    }\n\n    /// ===============================\n    /// ========= Initialize ==========\n    /// ===============================\n\n    /// @notice Initializes the strategy\n    /// @dev This will revert if the strategy is already initialized and 'msg.sender' is not the 'Allo' contract.\n    /// @param _poolId The 'poolId' to initialize\n    /// @param _data The data to be decoded to initialize the strategy\n    /// @custom:data InitializeData(bool _useRegistryAnchor, bool _metadataRequired, uint64 _registrationStartTime,\n    ///               uint64 _registrationEndTime, uint64 _allocationStartTime, uint64 _allocationEndTime,\n    ///               address[] memory _allowedTokens)\n    function initialize(uint256 _poolId, bytes memory _data) external virtual override onlyAllo {\n        (InitializeData memory initializeData) = abi.decode(_data, (InitializeData));\n        __DonationVotingStrategy_init(_poolId, initializeData);\n    }\n\n    /// @notice Initializes this strategy as well as the BaseStrategy.\n    /// @dev This will revert if the strategy is already initialized. Emits a 'TimestampsUpdated()' event.\n    /// @param _poolId The 'poolId' to initialize\n    /// @param _initializeData The data to be decoded to initialize the strategy\n    function __DonationVotingStrategy_init(uint256 _poolId, InitializeData memory _initializeData) internal {\n        // Initialize the BaseStrategy with the '_poolId'\n        __BaseStrategy_init(_poolId);\n\n        // Initialize required values\n        useRegistryAnchor = _initializeData.useRegistryAnchor;\n        metadataRequired = _initializeData.metadataRequired;\n        _registry = allo.getRegistry();\n\n        // Set the updated timestamps\n        registrationStartTime = _initializeData.registrationStartTime;\n        registrationEndTime = _initializeData.registrationEndTime;\n        allocationStartTime = _initializeData.allocationStartTime;\n        allocationEndTime = _initializeData.allocationEndTime;\n\n        // If the timestamps are invalid this will revert - See details in '_isPoolTimestampValid'\n        _isPoolTimestampValid(registrationStartTime, registrationEndTime, allocationStartTime, allocationEndTime);\n\n        // Emit that the timestamps have been updated with the updated values\n        emit TimestampsUpdated(\n            registrationStartTime, registrationEndTime, allocationStartTime, allocationEndTime, msg.sender\n        );\n\n        uint256 allowedTokensLength = _initializeData.allowedTokens.length;\n\n        // If the length of the allowed tokens is zero, we will allow all tokens\n        if (allowedTokensLength == 0) {\n            // all tokens\n            allowedTokens[address(0)] = true;\n        }\n\n        // Loop through the allowed tokens and set them to true\n        for (uint256 i; i < allowedTokensLength;) {\n            allowedTokens[_initializeData.allowedTokens[i]] = true;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// ===============================\n    /// ============ Views ============\n    /// ===============================\n\n    /// @notice Get a recipient with a '_recipientId'\n    /// @param _recipientId ID of the recipient\n    /// @return recipient The recipient details\n    function getRecipient(address _recipientId) external view returns (Recipient memory recipient) {\n        return _getRecipient(_recipientId);\n    }\n\n    /// @notice Get recipient status\n    /// @dev This will return the 'Status' of the recipient, the 'Status' is used at the strategy\n    ///      level and is different from the 'Status' which is used at the protocol level\n    /// @param _recipientId ID of the recipient\n    /// @return Status of the recipient\n    function _getRecipientStatus(address _recipientId) internal view override returns (Status) {\n        return Status(_getUintRecipientStatus(_recipientId));\n    }\n\n    /// ===============================\n    /// ======= External/Custom =======\n    /// ===============================\n\n    /// @notice Sets recipient statuses.\n    /// @dev The statuses are stored in a bitmap of 4 bits for each recipient. The first 4 bits of the 256 bits represent\n    ///      the status of the first recipient, the second 4 bits represent the status of the second recipient, and so on.\n    ///      'msg.sender' must be a pool manager and the registration must be active.\n    /// Statuses:\n    /// - 0: none\n    /// - 1: pending\n    /// - 2: accepted\n    /// - 3: rejected\n    /// - 4: appealed\n    /// Emits the RecipientStatusUpdated() event.\n    /// @param statuses new statuses\n    function reviewRecipients(ApplicationStatus[] memory statuses)\n        external\n        onlyActiveRegistration\n        onlyPoolManager(msg.sender)\n    {\n        // Loop through the statuses and set the status\n        for (uint256 i; i < statuses.length;) {\n            uint256 rowIndex = statuses[i].index;\n            uint256 fullRow = statuses[i].statusRow;\n\n            statusesBitMap[rowIndex] = fullRow;\n\n            // Emit that the recipient status has been updated with the values\n            emit RecipientStatusUpdated(rowIndex, fullRow, msg.sender);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @notice Sets the start and end dates.\n    /// @dev The timestamps are in milliseconds for the start and end times. The 'msg.sender' must be a pool manager.\n    ///      Emits a 'TimestampsUpdated()' event.\n    /// @param _registrationStartTime The start time for the registration\n    /// @param _registrationEndTime The end time for the registration\n    /// @param _allocationStartTime The start time for the allocation\n    /// @param _allocationEndTime The end time for the allocation\n    function updatePoolTimestamps(\n        uint64 _registrationStartTime,\n        uint64 _registrationEndTime,\n        uint64 _allocationStartTime,\n        uint64 _allocationEndTime\n    ) external onlyPoolManager(msg.sender) {\n        // If the timestamps are invalid this will revert - See details in '_isPoolTimestampValid'\n        _isPoolTimestampValid(_registrationStartTime, _registrationEndTime, _allocationStartTime, _allocationEndTime);\n\n        // Set the updated timestamps\n        registrationStartTime = _registrationStartTime;\n        registrationEndTime = _registrationEndTime;\n        allocationStartTime = _allocationStartTime;\n        allocationEndTime = _allocationEndTime;\n\n        // Emit that the timestamps have been updated with the updated values\n        emit TimestampsUpdated(\n            registrationStartTime, registrationEndTime, allocationStartTime, allocationEndTime, msg.sender\n        );\n    }\n\n    /// @notice Withdraw funds from pool\n    /// @dev This can only be called after the allocation has ended and 30 days have passed. If the\n    ///      '_amount' is greater than the pool amount or if 'msg.sender' is not a pool manager.\n    /// @param _amount The amount to be withdrawn\n    function withdraw(uint256 _amount) external onlyPoolManager(msg.sender) {\n        if (block.timestamp <= allocationEndTime + 30 days) {\n            revert INVALID();\n        }\n\n        IAllo.Pool memory pool = allo.getPool(poolId);\n\n        if (_amount > poolAmount) {\n            revert INVALID();\n        }\n\n        poolAmount -= _amount;\n\n        // Transfer the tokens to the 'msg.sender' (pool manager calling function)\n        _transferAmount(pool.token, msg.sender, _amount);\n    }\n\n    /// ==================================\n    /// ============ Merkle ==============\n    /// ==================================\n\n    /// @notice Invoked by round operator to update the merkle root and distribution Metadata.\n    /// @dev This can only be called after the allocation has ended and 'msg.sender' must be a pool manager and allocation must have ended.\n    ///      Emits a 'DistributionUpdated()' event.\n    /// @param _merkleRoot The merkle root of the distribution\n    /// @param _distributionMetadata The metadata of the distribution\n    function updateDistribution(bytes32 _merkleRoot, Metadata memory _distributionMetadata)\n        external\n        onlyAfterAllocation\n        onlyPoolManager(msg.sender)\n    {\n        // If the distribution has already started this will revert, you can only\n        // update the distribution before it has started\n        if (distributionStarted) {\n            revert INVALID();\n        }\n\n        merkleRoot = _merkleRoot;\n        distributionMetadata = _distributionMetadata;\n\n        // Emit that the distribution has been updated\n        emit DistributionUpdated(merkleRoot, distributionMetadata);\n    }\n\n    /// @notice Checks if distribution is set.\n    /// @return 'true' if distribution is set, otherwise 'false'\n    function isDistributionSet() external view returns (bool) {\n        return merkleRoot != \"\";\n    }\n\n    /// @notice Utility function to check if distribution is done.\n    /// @param _index index of the distribution\n    /// @return 'true' if distribution is completed, otherwise 'false'\n    function hasBeenDistributed(uint256 _index) external view returns (bool) {\n        return _hasBeenDistributed(_index);\n    }\n\n    /// ====================================\n    /// ============ Internal ==============\n    /// ====================================\n\n    /// @notice Checks if the registration is active and reverts if not.\n    /// @dev This will revert if the registration has not started or if the registration has ended.\n    function _checkOnlyActiveRegistration() internal view {\n        if (registrationStartTime > block.timestamp || block.timestamp > registrationEndTime) {\n            revert REGISTRATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Checks if the allocation is active and reverts if not.\n    /// @dev This will revert if the allocation has not started or if the allocation has ended.\n    function _checkOnlyActiveAllocation() internal view {\n        if (allocationStartTime > block.timestamp || block.timestamp > allocationEndTime) {\n            revert ALLOCATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Checks if the allocation has ended and reverts if not.\n    /// @dev This will revert if the allocation has not ended.\n    function _checkOnlyAfterAllocation() internal view {\n        if (block.timestamp < allocationEndTime) {\n            revert ALLOCATION_NOT_ENDED();\n        }\n    }\n\n    /// @notice Checks if address is eligible allocator.\n    /// @return Always returns true for this strategy\n    function _isValidAllocator(address) internal pure override returns (bool) {\n        return true;\n    }\n\n    /// @notice Checks if the timestamps are valid.\n    /// @dev This will revert if any of the timestamps are invalid. This is determined by the strategy\n    /// and may vary from strategy to strategy. Checks if '_registrationStartTime' is less than the\n    /// current 'block.timestamp' or if '_registrationStartTime' is greater than the '_registrationEndTime'\n    /// or if '_registrationStartTime' is greater than the '_allocationStartTime' or if '_registrationEndTime'\n    /// is greater than the '_allocationEndTime' or if '_allocationStartTime' is greater than the '_allocationEndTime'.\n    /// If any of these conditions are true, this will revert.\n    /// @param _registrationStartTime The start time for the registration\n    /// @param _registrationEndTime The end time for the registration\n    /// @param _allocationStartTime The start time for the allocation\n    /// @param _allocationEndTime The end time for the allocation\n    function _isPoolTimestampValid(\n        uint64 _registrationStartTime,\n        uint64 _registrationEndTime,\n        uint64 _allocationStartTime,\n        uint64 _allocationEndTime\n    ) internal view {\n        if (\n            block.timestamp > _registrationStartTime || _registrationStartTime > _registrationEndTime\n                || _registrationStartTime > _allocationStartTime || _allocationStartTime > _allocationEndTime\n                || _registrationEndTime > _allocationEndTime\n        ) {\n            revert INVALID();\n        }\n    }\n\n    /// @notice Checks whether a pool is active or not.\n    /// @dev This will return true if the current 'block timestamp' is greater than or equal to the\n    /// 'registrationStartTime' and less than or equal to the 'registrationEndTime'.\n    /// @return 'true' if pool is active, otherwise 'false'\n    function _isPoolActive() internal view override returns (bool) {\n        if (registrationStartTime <= block.timestamp && block.timestamp <= registrationEndTime) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Submit recipient to pool and set their status.\n    /// @param _data The data to be decoded.\n    /// @custom:data if 'useRegistryAnchor' is 'true' (address recipientId, address recipientAddress, Metadata metadata)\n    /// @custom:data if 'useRegistryAnchor' is 'false' (address recipientAddress, address registryAnchor, Metadata metadata)\n    /// @param _sender The sender of the transaction\n    /// @return recipientId The ID of the recipient\n    function _registerRecipient(bytes memory _data, address _sender)\n        internal\n        override\n        onlyActiveRegistration\n        returns (address recipientId)\n    {\n        bool isUsingRegistryAnchor;\n        address recipientAddress;\n        address registryAnchor;\n        Metadata memory metadata;\n\n        // decode data custom to this strategy\n        if (useRegistryAnchor) {\n            (recipientId, recipientAddress, metadata) = abi.decode(_data, (address, address, Metadata));\n\n            // If the sender is not a profile member this will revert\n            if (!_isProfileMember(recipientId, _sender)) {\n                revert UNAUTHORIZED();\n            }\n        } else {\n            (recipientAddress, registryAnchor, metadata) = abi.decode(_data, (address, address, Metadata));\n\n            // Set this to 'true' if the registry anchor is not the zero address\n            isUsingRegistryAnchor = registryAnchor != address(0);\n\n            // If using the 'registryAnchor' we set the 'recipientId' to the 'registryAnchor', otherwise we set it to the 'msg.sender'\n            recipientId = isUsingRegistryAnchor ? registryAnchor : _sender;\n\n            // Checks if the '_sender' is a member of the profile 'anchor' being used and reverts if not\n            if (isUsingRegistryAnchor && !_isProfileMember(recipientId, _sender)) {\n                revert UNAUTHORIZED();\n            }\n        }\n\n        // If the metadata is required and the metadata is invalid this will revert\n        if (metadataRequired && (bytes(metadata.pointer).length == 0 || metadata.protocol == 0)) {\n            revert INVALID_METADATA();\n        }\n\n        // If the recipient address is the zero address this will revert\n        if (recipientAddress == address(0)) {\n            revert RECIPIENT_ERROR(recipientId);\n        }\n\n        // Get the recipient\n        Recipient storage recipient = _recipients[recipientId];\n\n        // update the recipients data\n        recipient.recipientAddress = recipientAddress;\n        recipient.metadata = metadata;\n        recipient.useRegistryAnchor = useRegistryAnchor ? true : isUsingRegistryAnchor;\n\n        uint8 currentStatus = _getUintRecipientStatus(recipientId);\n\n        if (currentStatus == uint8(Status.None)) {\n            // recipient registering new application\n            recipientToStatusIndexes[recipientId] = recipientsCounter;\n            _setRecipientStatus(recipientId, uint8(Status.Pending));\n\n            bytes memory extendedData = abi.encode(_data, recipientsCounter);\n            emit Registered(recipientId, extendedData, _sender);\n\n            recipientsCounter++;\n        } else {\n            if (currentStatus == uint8(Status.Accepted)) {\n                // recipient updating accepted application\n                _setRecipientStatus(recipientId, uint8(Status.Pending));\n            } else if (currentStatus == uint8(Status.Rejected)) {\n                // recipient updating rejected application\n                _setRecipientStatus(recipientId, uint8(Status.Appealed));\n            }\n            emit UpdatedRegistration(recipientId, _data, _sender, _getUintRecipientStatus(recipientId));\n        }\n    }\n\n    /// @notice Distribute funds to recipients.\n    /// @dev 'distributionStarted' will be set to 'true' when called. Only the pool manager can call.\n    ///      Emits a 'BatchPayoutSuccessful()' event.\n    /// @param _data The data to be decoded\n    /// @custom:data '(Distribution[] distributions)'\n    /// @param _sender The sender of the transaction\n    function _distribute(address[] memory, bytes memory _data, address _sender)\n        internal\n        virtual\n        override\n        onlyPoolManager(_sender)\n    {\n        if (!distributionStarted) {\n            distributionStarted = true;\n        }\n\n        // Decode the '_data' to get the distributions\n        Distribution[] memory distributions = abi.decode(_data, (Distribution[]));\n        uint256 length = distributions.length;\n\n        // Loop through the distributions and distribute the funds\n        for (uint256 i; i < length;) {\n            _distributeSingle(distributions[i]);\n            unchecked {\n                i++;\n            }\n        }\n\n        // Emit that the batch payout was successful\n        emit BatchPayoutSuccessful(_sender);\n    }\n\n    /// @notice Allocate tokens to recipient.\n    /// @dev This can only be called during the allocation period. Emts an 'Allocated()' event.\n    /// @param _data The data to be decoded\n    /// @custom:data (address recipientId, uint256 amount, address token)\n    /// @param _sender The sender of the transaction\n    function _allocate(bytes memory _data, address _sender) internal virtual override onlyActiveAllocation {\n        // Decode the '_data' to get the recipientId, amount and token\n        (address recipientId, Permit2Data memory p2Data) = abi.decode(_data, (address, Permit2Data));\n\n        uint256 amount = p2Data.permit.permitted.amount;\n        address token = p2Data.permit.permitted.token;\n\n        // If the recipient status is not 'Accepted' this will revert, the recipient must be accepted through registration\n        if (Status(_getUintRecipientStatus(recipientId)) != Status.Accepted) {\n            revert RECIPIENT_ERROR(recipientId);\n        }\n\n        // The token must be in the allowed token list and not be native token or zero address\n        if (!allowedTokens[token] && !allowedTokens[address(0)]) {\n            revert INVALID();\n        }\n\n        // If the token is native, the amount must be equal to the value sent, otherwise it reverts\n        if (msg.value > 0 && token != NATIVE || token == NATIVE && msg.value != amount) {\n            revert INVALID();\n        }\n\n        // Emit that the amount has been allocated to the recipient by the sender\n        emit Allocated(recipientId, amount, token, _sender);\n    }\n\n    /// @notice Check if sender is profile owner or member.\n    /// @param _anchor Anchor of the profile\n    /// @param _sender The sender of the transaction\n    /// @return 'true' if the '_sender' is a profile member, otherwise 'false'\n    function _isProfileMember(address _anchor, address _sender) internal view virtual returns (bool) {\n        IRegistry.Profile memory profile = _registry.getProfileByAnchor(_anchor);\n        return _registry.isOwnerOrMemberOfProfile(profile.id, _sender);\n    }\n\n    /// @notice Get the recipient details.\n    /// @param _recipientId Id of the recipient\n    /// @return Recipient details\n    function _getRecipient(address _recipientId) internal view returns (Recipient memory) {\n        return _recipients[_recipientId];\n    }\n\n    /// @notice Returns the payout summary for the accepted recipient.\n    /// @param _data The data to be decoded\n    /// @custom:data '(Distribution)'\n    /// @return 'PayoutSummary' for a recipient\n    function _getPayout(address, bytes memory _data) internal view override returns (PayoutSummary memory) {\n        // Decode the '_data' to get the distribution\n        Distribution memory distribution = abi.decode(_data, (Distribution));\n\n        uint256 index = distribution.index;\n        address recipientId = distribution.recipientId;\n        uint256 amount = distribution.amount;\n        bytes32[] memory merkleProof = distribution.merkleProof;\n\n        address recipientAddress = _getRecipient(recipientId).recipientAddress;\n\n        // Validate the distribution\n        if (_validateDistribution(index, recipientId, recipientAddress, amount, merkleProof)) {\n            // Return a 'PayoutSummary' with the 'recipientAddress' and 'amount'\n            return PayoutSummary(recipientAddress, amount);\n        }\n\n        // If the distribution is not valid, return a payout summary with the amount set to zero\n        return PayoutSummary(recipientAddress, 0);\n    }\n\n    /// @notice Validate the distribution for the payout.\n    /// @param _index index of the distribution\n    /// @param _recipientId Id of the recipient\n    /// @param _recipientAddress Address of the recipient\n    /// @param _amount Amount of tokens to be distributed\n    /// @param _merkleProof Merkle proof of the distribution\n    /// @return 'true' if the distribution is valid, otherwise 'false'\n    function _validateDistribution(\n        uint256 _index,\n        address _recipientId,\n        address _recipientAddress,\n        uint256 _amount,\n        bytes32[] memory _merkleProof\n    ) internal view returns (bool) {"
    }
  ]
}