{
  "Title": "[H-06] StabilizerNode.stabilize uses stale GlobalImpliedCollateralService data, which will make stabilize incorrect",
  "Content": "\nIn StabilizerNode.stabilize, `impliedCollateralService.syncGlobalCollateral()` is called only at the end of the function to synchronize the GlobalImpliedCollateralService data.\n\n```solidity\n    if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {\n      lastStabilize = block.timestamp;\n      impliedCollateralService.syncGlobalCollateral();\n      return;\n    }\n...\n    if (trackAfterStabilize) {\n      maltDataLab.trackPool();\n    }\n    impliedCollateralService.syncGlobalCollateral();\n    lastStabilize = block.timestamp;\n  }\n```\n\nsyncGlobalCollateral will use the data in `getCollateralizedMalt()`, which includes the collateralToken balance in overflowPool/swingTraderManager/liquidityExtension and the malt balance in swingTraderManager.\n\n```solidity\n  function syncGlobalCollateral() public onlyActive {\n    globalIC.sync(getCollateralizedMalt());\n  }\n...\n  function getCollateralizedMalt() public view returns (PoolCollateral memory) {\n    uint256 target = maltDataLab.priceTarget();\n\n    uint256 unity = 10**collateralToken.decimals();\n\n    // Convert all balances to be denominated in units of Malt target price\n    uint256 overflowBalance = maltDataLab.rewardToMaltDecimals((collateralToken.balanceOf(\n      address(overflowPool)\n    ) * unity) / target);\n    uint256 liquidityExtensionBalance = (collateralToken.balanceOf(\n      address(liquidityExtension)\n    ) * unity) / target;\n    (\n      uint256 swingTraderMaltBalance,\n      uint256 swingTraderBalance\n    ) = swingTraderManager.getTokenBalances();\n    swingTraderBalance = (swingTraderBalance * unity) / target;\n```\n\nSince StabilizerNode.stabilize will use the results of maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice to stabilize, and maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice will use `GlobalImpliedCollateralService.collateralRatio`, to ensure correct stabilization, the data in GlobalServiceImpliedCollateralService should be the latest.\n\n```solidity\n  function getActualPriceTarget() external view returns (uint256) {\n    uint256 unity = 10**collateralToken.decimals();\n    uint256 icTotal = maltToRewardDecimals(globalIC.collateralRatio());\n...\n  function getSwingTraderEntryPrice()\n    external\n    view\n    returns (uint256 stEntryPrice)\n  {\n    uint256 unity = 10**collateralToken.decimals();\n    uint256 icTotal = maltToRewardDecimals(globalIC.collateralRatio());\n```\n\nBut since `impliedCollateralService.syncGlobalCollateral()` is not called before StabilizerNode.stabilize calls maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice, this will cause StabilizerNode.stabilize to use stale GlobalImpliedCollateralService data, which will make stabilize incorrect.\n\nA simple example would be:\n\n1.  `impliedCollateralService.syncGlobalCollateral()` is called to synchronize the latest data\n2.  SwingTraderManager.delegateCapital is called, and the collateralToken is taken out from SwingTrader, which will make the `GlobalImpliedCollateralService.collateralRatio` larger than the actual collateralRatio.\n\n```solidity\n  function delegateCapital(uint256 amount, address destination)\n    external\n    onlyRoleMalt(CAPITAL_DELEGATE_ROLE, \"Must have capital delegation privs\")\n    onlyActive\n  {\n    collateralToken.safeTransfer(destination, amount);\n    emit Delegation(amount, destination, msg.sender);\n  }\n...\n  function collateralRatio() public view returns (uint256) {\n    uint256 decimals = malt.decimals();\n    uint256 totalSupply = malt.totalSupply();\n    if (totalSupply == 0) {\n      return 0;\n    }\n    return (collateral.total * (10**decimals)) / totalSupply; // @audit: collateral.total is larger than the actual\n  }\n```\n\n3.  When StabilizerNode.stabilize is called, it will use the stale collateralRatio for calculation. If the collateralRatio is too large, the results of maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice will be incorrect, thus making stabilize incorrect.\n\nSince stabilize is a core function of the protocol, stabilizing with the wrong data is likely to cause malt to be depegged, so the vulnerability should be High risk.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L161-L237> \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/ImpliedCollateralService.sol#L89-L131>\n\n### Recommended Mitigation Steps\n\nCall `impliedCollateralService.syncGlobalCollateral()` before StabilizerNode.stabilize calls maltDataLab.getActualPriceTarget.\n\n```diff\n  function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {\n    // Ensure data consistency\n    maltDataLab.trackPool();\n\n    // Finalize auction if possible before potentially starting a new one\n    auction.checkAuctionFinalization();\n\n+  impliedCollateralService.syncGlobalCollateral();\n\n    require(\n      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),\n      \"Can't call stabilize\"\n    );\n    stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;\n\n    // used in 3 location.\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);\n    bool stabilizeToPeg = onlyStabilizeToPeg; // gas\n\n    if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {\n      lastStabilize = block.timestamp;\n      impliedCollateralService.syncGlobalCollateral();\n      return;\n    }\n\n    emit Stabilize(block.timestamp, exchangeRate);\n\n    (uint256 livePrice, ) = dexHandler.maltMarketPrice();\n\n    uint256 priceTarget = maltDataLab.getActualPriceTarget();\n```\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/9)**\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2023-02-malt-protocol-versus-contest",
  "Code": [
    {
      "filename": "contracts/StabilityPod/StabilizerNode.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"openzeppelin/token/ERC20/ERC20.sol\";\nimport \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin/security/Pausable.sol\";\n\nimport \"../StabilizedPoolExtensions/StabilizedPoolUnit.sol\";\nimport \"../StabilizedPoolExtensions/AuctionExtension.sol\";\nimport \"../StabilizedPoolExtensions/DexHandlerExtension.sol\";\nimport \"../StabilizedPoolExtensions/DataLabExtension.sol\";\nimport \"../StabilizedPoolExtensions/ProfitDistributorExtension.sol\";\nimport \"../StabilizedPoolExtensions/SwingTraderManagerExtension.sol\";\nimport \"../StabilizedPoolExtensions/ImpliedCollateralServiceExtension.sol\";\nimport \"../interfaces/IAuction.sol\";\nimport \"../interfaces/IMaltDataLab.sol\";\nimport \"../interfaces/ITimekeeper.sol\";\nimport \"../interfaces/IRewardThrottle.sol\";\nimport \"../interfaces/IImpliedCollateralService.sol\";\nimport \"../interfaces/IDexHandler.sol\";\nimport \"../interfaces/ISwingTrader.sol\";\nimport \"../interfaces/IBurnMintableERC20.sol\";\nimport \"../interfaces/ISupplyDistributionController.sol\";\nimport \"../interfaces/IAuctionStartController.sol\";\nimport \"../interfaces/IProfitDistributor.sol\";\nimport \"../interfaces/IGlobalImpliedCollateralService.sol\";\n\n/// @title Stabilizer Node\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The backbone of the Malt stability system. In charge of triggering actions to stabilize price\ncontract StabilizerNode is\n  StabilizedPoolUnit,\n  AuctionExtension,\n  DexHandlerExtension,\n  DataLabExtension,\n  ProfitDistributorExtension,\n  SwingTraderManagerExtension,\n  ImpliedCollateralServiceExtension,\n  Pausable\n{\n  using SafeERC20 for ERC20;\n\n  uint256 internal stabilizeWindowEnd;\n  uint256 public stabilizeBackoffPeriod = 5 * 60; // 5 minutes\n  uint256 public upperStabilityThresholdBps = 100; // 1%\n  uint256 public lowerStabilityThresholdBps = 100;\n  uint256 public priceAveragePeriod = 5 minutes;\n  uint256 public fastAveragePeriod = 30; // 30 seconds\n  uint256 public overrideDistanceBps = 200; // 2%\n  uint256 public callerRewardCutBps = 30; // 0.3%\n\n  uint256 public expansionDampingFactor = 1;\n\n  uint256 public defaultIncentive = 100; // in Malt\n  uint256 public trackingIncentive = 20; // in 100ths of a Malt\n\n  uint256 public upperBandLimitBps = 100000; // 1000%\n  uint256 public lowerBandLimitBps = 1000; // 10%\n  uint256 public sampleSlippageBps = 2000; // 20%\n  uint256 public skipAuctionThreshold;\n  uint256 public preferAuctionThreshold;\n\n  uint256 public lastStabilize;\n  uint256 public lastTracking;\n  uint256 public trackingBackoff = 30; // 30 seconds\n  uint256 public primedBlock;\n  uint256 public primedWindow = 10; // blocks\n\n  bool internal trackAfterStabilize = true;\n  bool public onlyStabilizeToPeg = false;\n  bool public usePrimedWindow;\n\n  address public supplyDistributionController;\n  address public auctionStartController;\n\n  event MintMalt(uint256 amount);\n  event Stabilize(uint256 timestamp, uint256 exchangeRate);\n  event SetStabilizeBackoff(uint256 period);\n  event SetDefaultIncentive(uint256 incentive);\n  event SetTrackingIncentive(uint256 incentive);\n  event SetExpansionDamping(uint256 amount);\n  event SetPriceAveragePeriod(uint256 period);\n  event SetOverrideDistance(uint256 distance);\n  event SetFastAveragePeriod(uint256 period);\n  event SetStabilityThresholds(uint256 upper, uint256 lower);\n  event SetSupplyDistributionController(address _controller);\n  event SetAuctionStartController(address _controller);\n  event SetBandLimits(uint256 _upper, uint256 _lower);\n  event SetSlippageBps(uint256 _slippageBps);\n  event SetSkipAuctionThreshold(uint256 _skipAuctionThreshold);\n  event SetEmergencyMintThresholdBps(uint256 thresholdBps);\n  event Tracking();\n  event SetTrackingBackoff(uint256 backoff);\n  event SetCallerCut(uint256 callerCutBps);\n  event SetPreferAuctionThreshold(uint256 preferAuctionThreshold);\n  event SetTrackAfterStabilize(bool track);\n  event SetOnlyStabilizeToPeg(bool stabilize);\n  event SetPrimedWindow(uint256 primedWindow);\n  event SetUsePrimedWindow(bool usePrimedWindow);\n\n  constructor(\n    address timelock,\n    address repository,\n    address poolFactory,\n    uint256 _skipAuctionThreshold,\n    uint256 _preferAuctionThreshold\n  ) StabilizedPoolUnit(timelock, repository, poolFactory) {\n    skipAuctionThreshold = _skipAuctionThreshold;\n    preferAuctionThreshold = _preferAuctionThreshold;\n\n    lastStabilize = block.timestamp;\n  }\n\n  function setupContracts(\n    address _malt,\n    address _collateralToken,\n    address _dexHandler,\n    address _maltDataLab,\n    address _impliedCollateralService,\n    address _auction,\n    address _swingTraderManager,\n    address _profitDistributor,\n    address pool\n  ) external onlyRoleMalt(POOL_FACTORY_ROLE, \"Must have pool factory role\") {\n    require(!contractActive, \"StabilizerNode: Already setup\");\n    require(_malt != address(0), \"StabilizerNode: Malt addr(0)\");\n    require(_collateralToken != address(0), \"StabilizerNode: Col addr(0)\");\n    require(_dexHandler != address(0), \"StabilizerNode: DexHandler addr(0)\");\n    require(_maltDataLab != address(0), \"StabilizerNode: DataLab addr(0)\");\n    require(\n      _swingTraderManager != address(0),\n      \"StabilizerNode: Swing Manager addr(0)\"\n    );\n    require(\n      _impliedCollateralService != address(0),\n      \"StabilizerNode: ImpCol addr(0)\"\n    );\n    require(_auction != address(0), \"StabilizerNode: Auction addr(0)\");\n    require(\n      _profitDistributor != address(0),\n      \"StabilizerNode: ProfitDistributor addr(0)\"\n    );\n\n    contractActive = true;\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    dexHandler = IDexHandler(_dexHandler);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    swingTraderManager = ISwingTrader(_swingTraderManager);\n    impliedCollateralService = IImpliedCollateralService(\n      _impliedCollateralService\n    );\n    auction = IAuction(_auction);\n    profitDistributor = IProfitDistributor(_profitDistributor);\n\n    (, address updater, ) = poolFactory.getPool(pool);\n    _setPoolUpdater(updater);\n  }\n\n  function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {\n    // Ensure data consistency\n    maltDataLab.trackPool();\n\n    // Finalize auction if possible before potentially starting a new one\n    auction.checkAuctionFinalization();\n\n    require(\n      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),\n      \"Can't call stabilize\"\n    );\n    stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;\n\n    // used in 3 location.\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);\n    bool stabilizeToPeg = onlyStabilizeToPeg; // gas\n\n    if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {\n      lastStabilize = block.timestamp;\n      impliedCollateralService.syncGlobalCollateral();\n      return;\n    }\n\n    emit Stabilize(block.timestamp, exchangeRate);\n\n    (uint256 livePrice, ) = dexHandler.maltMarketPrice();\n\n    uint256 priceTarget = maltDataLab.getActualPriceTarget();\n    // The upper and lower bands here avoid any issues with price\n    // descrepency between the TWAP and live market price.\n    // This avoids starting auctions too quickly into a big selloff\n    // and also reduces risk of flashloan vectors\n    address sender = _msgSender();\n    if (exchangeRate > priceTarget) {\n      if (\n        !hasRole(ADMIN_ROLE, sender) &&\n        !hasRole(INTERNAL_WHITELIST_ROLE, sender)\n      ) {\n        uint256 upperBand = exchangeRate +\n          ((exchangeRate * upperBandLimitBps) / 10000);\n        uint256 latestSample = maltDataLab.maltPriceAverage(0);\n        uint256 minThreshold = latestSample -\n          (((latestSample - priceTarget) * sampleSlippageBps) / 10000);\n\n        require(livePrice < upperBand, \"Stabilize: Beyond upper bound\");\n        require(livePrice > minThreshold, \"Stabilize: Slippage threshold\");\n      }\n\n      _distributeSupply(livePrice, priceTarget, stabilizeToPeg);\n    } else {\n      if (\n        !hasRole(ADMIN_ROLE, sender) &&\n        !hasRole(INTERNAL_WHITELIST_ROLE, sender)\n      ) {\n        uint256 lowerBand = exchangeRate -\n          ((exchangeRate * lowerBandLimitBps) / 10000);\n        require(livePrice > lowerBand, \"Stabilize: Beyond lower bound\");\n      }\n\n      uint256 stEntryPrice = maltDataLab.getSwingTraderEntryPrice();\n      if (exchangeRate <= stEntryPrice) {\n        if (_validateSwingTraderTrigger(livePrice, stEntryPrice)) {\n          // Reset primedBlock\n          primedBlock = 0;\n          _triggerSwingTrader(priceTarget, livePrice);\n        }\n      } else {\n        _startAuction(priceTarget);\n      }\n    }\n\n    if (trackAfterStabilize) {\n      maltDataLab.trackPool();\n    }\n    impliedCollateralService.syncGlobalCollateral();\n    lastStabilize = block.timestamp;\n  }\n\n  function endAuctionEarly() external onlyActive whenNotPaused {\n    // This call reverts if the auction isn't ended\n    auction.endAuctionEarly();\n\n    // It hasn't reverted so the auction was ended. Pay the incentive\n    malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n    emit MintMalt(defaultIncentive * (10**malt.decimals()));\n  }\n\n  function trackPool() external onlyActive {\n    require(block.timestamp >= lastTracking + trackingBackoff, \"Too early\");\n    bool success = maltDataLab.trackPool();\n    require(success, \"Too early\");\n    malt.mint(msg.sender, (trackingIncentive * (10**malt.decimals())) / 100); // div 100 because units are cents\n    lastTracking = block.timestamp;\n    emit Tracking();\n  }\n\n  function primedWindowData() public view returns (bool, uint256) {\n    return (usePrimedWindow, primedBlock + primedWindow);\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _stabilityWindowOverride() internal view returns (bool) {\n    address sender = _msgSender();\n    if (\n      hasRole(ADMIN_ROLE, sender) || hasRole(INTERNAL_WHITELIST_ROLE, sender)\n    ) {\n      // Admin can always stabilize\n      return true;\n    }\n    // Must have elapsed at least one period of the moving average before we stabilize again\n    if (block.timestamp < lastStabilize + fastAveragePeriod) {\n      return false;\n    }\n\n    uint256 priceTarget = maltDataLab.getActualPriceTarget();\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(fastAveragePeriod);\n\n    uint256 upperThreshold = (priceTarget * (10000 + overrideDistanceBps)) /\n      10000;\n\n    return exchangeRate >= upperThreshold;\n  }\n\n  function _shouldAdjustSupply(uint256 exchangeRate, bool stabilizeToPeg)\n    internal\n    view\n    returns (bool)\n  {\n    uint256 decimals = collateralToken.decimals();\n    uint256 priceTarget;\n\n    if (stabilizeToPeg) {\n      priceTarget = maltDataLab.priceTarget();\n    } else {\n      priceTarget = maltDataLab.getActualPriceTarget();\n    }\n\n    uint256 upperThreshold = (priceTarget * upperStabilityThresholdBps) / 10000;\n    uint256 lowerThreshold = (priceTarget * lowerStabilityThresholdBps) / 10000;\n\n    return\n      (exchangeRate <= (priceTarget - lowerThreshold) &&\n        !auction.auctionExists(auction.currentAuctionId())) ||\n      exchangeRate >= (priceTarget + upperThreshold);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _validateSwingTraderTrigger(uint256 livePrice, uint256 entryPrice)\n    internal\n    returns (bool)\n  {\n    if (usePrimedWindow) {\n      if (livePrice > entryPrice) {\n        return false;\n      }\n\n      if (block.number > primedBlock + primedWindow) {\n        primedBlock = block.number;\n        malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n        emit MintMalt(defaultIncentive * (10**malt.decimals()));\n        return false;\n      }\n\n      if (primedBlock == block.number) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function _triggerSwingTrader(uint256 priceTarget, uint256 exchangeRate)\n    internal\n  {\n    uint256 decimals = collateralToken.decimals();\n    uint256 unity = 10**decimals;\n    IGlobalImpliedCollateralService globalIC = maltDataLab.globalIC();\n    uint256 icTotal = maltDataLab.maltToRewardDecimals(\n      globalIC.collateralRatio()\n    );\n\n    if (icTotal >= unity) {\n      icTotal = unity;\n    }\n\n    uint256 originalPriceTarget = priceTarget;\n\n    // TODO StabilizerNode.sol these checks won't work when working with pools not pegged to 1 Wed 26 Oct 2022 16:40:25 BST\n    if (exchangeRate < icTotal) {\n      priceTarget = icTotal;\n    }\n\n    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);\n\n    if (purchaseAmount > preferAuctionThreshold) {\n      uint256 capitalUsed = swingTraderManager.buyMalt(purchaseAmount);\n\n      uint256 callerCut = (capitalUsed * callerRewardCutBps) / 10000;\n\n      if (callerCut != 0) {\n        malt.mint(msg.sender, callerCut);\n        emit MintMalt(callerCut);\n      }\n    } else {\n      _startAuction(originalPriceTarget);\n    }\n  }\n\n  function _distributeSupply(\n    uint256 livePrice,\n    uint256 priceTarget,\n    bool stabilizeToPeg\n  ) internal {\n    if (supplyDistributionController != address(0)) {\n      bool success = ISupplyDistributionController(supplyDistributionController)\n        .check();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 pegPrice = maltDataLab.priceTarget();\n\n    uint256 lowerThreshold = (pegPrice * lowerStabilityThresholdBps) / 10000;\n    if (stabilizeToPeg || livePrice >= pegPrice - lowerThreshold) {\n      priceTarget = pegPrice;\n    }\n\n    uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget) /\n      expansionDampingFactor;\n\n    if (tradeSize == 0) {\n      return;\n    }\n\n    uint256 swingAmount = swingTraderManager.sellMalt(tradeSize);\n\n    if (swingAmount >= tradeSize) {\n      return;\n    }\n\n    tradeSize = tradeSize - swingAmount;\n\n    malt.mint(address(dexHandler), tradeSize);\n    emit MintMalt(tradeSize);\n    // Transfer verification ensure any attempt to\n    // sandwhich will trigger stabilize first\n    uint256 rewards = dexHandler.sellMalt(tradeSize, 10000);\n\n    uint256 callerCut = (rewards * callerRewardCutBps) / 10000;\n\n    if (callerCut != 0) {\n      rewards -= callerCut;\n      collateralToken.safeTransfer(msg.sender, callerCut);\n    }\n\n    collateralToken.safeTransfer(address(profitDistributor), rewards);\n\n    profitDistributor.handleProfit(rewards);\n  }\n\n  function _startAuction(uint256 priceTarget) internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController)\n        .checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);\n\n    if (purchaseAmount < skipAuctionThreshold) {\n      return;\n    }\n\n    // TODO StabilizerNode.sol invert priceTarget? Fri 21 Oct 2022 11:02:43 BST\n    bool success = auction.triggerAuction(priceTarget, purchaseAmount);\n\n    if (success) {\n      malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n      emit MintMalt(defaultIncentive * (10**malt.decimals()));\n    }\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n\n  function setStabilizeBackoff(uint256 _period)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Must be greater than 0\");\n    stabilizeBackoffPeriod = _period;\n    emit SetStabilizeBackoff(_period);\n  }\n\n  function setDefaultIncentive(uint256 _incentive)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_incentive != 0 && _incentive <= 1000, \"Incentive out of range\");\n\n    defaultIncentive = _incentive;\n\n    emit SetDefaultIncentive(_incentive);\n  }\n\n  function setTrackingIncentive(uint256 _incentive)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    // Priced in cents. Must be less than 1000 Malt\n    require(_incentive != 0 && _incentive <= 100000, \"Incentive out of range\");\n\n    trackingIncentive = _incentive;\n\n    emit SetTrackingIncentive(_incentive);\n  }\n\n  /// @notice Only callable by Admin address.\n  /// @dev Sets the Expansion Damping units.\n  /// @param amount: Amount to set Expansion Damping units to.\n  function setExpansionDamping(uint256 amount)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(amount > 0, \"No negative damping\");\n\n    expansionDampingFactor = amount;\n    emit SetExpansionDamping(amount);\n  }\n\n  function setStabilityThresholds(uint256 _upper, uint256 _lower)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_upper != 0 && _lower != 0, \"Must be above 0\");\n    require(_lower < 10000, \"Lower to large\");\n\n    upperStabilityThresholdBps = _upper;\n    lowerStabilityThresholdBps = _lower;\n    emit SetStabilityThresholds(_upper, _lower);\n  }\n\n  function setSupplyDistributionController(address _controller)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    supplyDistributionController = _controller;\n    emit SetSupplyDistributionController(_controller);\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n    emit SetAuctionStartController(_controller);\n  }\n\n  function setPriceAveragePeriod(uint256 _period)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    priceAveragePeriod = _period;\n    emit SetPriceAveragePeriod(_period);\n  }\n\n  function setOverrideDistance(uint256 _distance)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(\n      _distance != 0 && _distance < 10000,\n      \"Override must be between 0-100%\"\n    );\n    overrideDistanceBps = _distance;\n    emit SetOverrideDistance(_distance);\n  }\n\n  function setFastAveragePeriod(uint256 _period)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    fastAveragePeriod = _period;\n    emit SetFastAveragePeriod(_period);\n  }\n\n  function setBandLimits(uint256 _upper, uint256 _lower)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_upper != 0 && _lower != 0, \"Cannot have 0 band limit\");\n    upperBandLimitBps = _upper;\n    lowerBandLimitBps = _lower;\n    emit SetBandLimits(_upper, _lower);\n  }\n\n  function setSlippageBps(uint256 _slippageBps)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_slippageBps <= 10000, \"slippage: Must be <= 100%\");\n    sampleSlippageBps = _slippageBps;\n    emit SetSlippageBps(_slippageBps);\n  }\n\n  function setSkipAuctionThreshold(uint256 _skipAuctionThreshold)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    skipAuctionThreshold = _skipAuctionThreshold;\n    emit SetSkipAuctionThreshold(_skipAuctionThreshold);\n  }\n\n  function setPreferAuctionThreshold(uint256 _preferAuctionThreshold)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    preferAuctionThreshold = _preferAuctionThreshold;\n    emit SetPreferAuctionThreshold(_preferAuctionThreshold);\n  }\n\n  function setTrackingBackoff(uint256 _backoff)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_backoff != 0, \"Cannot be 0\");\n    trackingBackoff = _backoff;\n    emit SetTrackingBackoff(_backoff);\n  }\n\n  function setTrackAfterStabilize(bool _track)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    trackAfterStabilize = _track;\n    emit SetTrackAfterStabilize(_track);\n  }\n\n  function setOnlyStabilizeToPeg(bool _stabilize)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    onlyStabilizeToPeg = _stabilize;\n    emit SetOnlyStabilizeToPeg(_stabilize);\n  }\n\n  function setCallerCut(uint256 _callerCut)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_callerCut <= 1000, \"Must be less than 10%\");\n    callerRewardCutBps = _callerCut;\n    emit SetCallerCut(_callerCut);\n  }\n\n  function togglePause()\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    if (paused()) {\n      _unpause();\n    } else {\n      _pause();\n    }\n  }\n\n  function setPrimedWindow(uint256 _primedWindow)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_primedWindow != 0, \"Cannot be 0\");\n    primedWindow = _primedWindow;\n    emit SetPrimedWindow(_primedWindow);\n  }\n\n  function setUsePrimedWindow(bool _usePrimedWindow)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    usePrimedWindow = _usePrimedWindow;\n    emit SetUsePrimedWindow(_usePrimedWindow);\n  }\n\n  function _accessControl()\n    internal\n    override(\n      AuctionExtension,\n      DexHandlerExtension,\n      DataLabExtension,\n      ProfitDistributorExtension,\n      SwingTraderManagerExtension,\n      ImpliedCollateralServiceExtension\n    )\n  {\n    _onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater role\");\n  }\n}"
    },
    {
      "filename": "contracts/StabilityPod/ImpliedCollateralService.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"openzeppelin/token/ERC20/ERC20.sol\";\nimport \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../StabilizedPoolExtensions/StabilizedPoolUnit.sol\";\nimport \"../StabilizedPoolExtensions/DataLabExtension.sol\";\nimport \"../StabilizedPoolExtensions/SwingTraderManagerExtension.sol\";\nimport \"../StabilizedPoolExtensions/LiquidityExtensionExtension.sol\";\nimport \"../StabilizedPoolExtensions/RewardOverflowExtension.sol\";\nimport \"../StabilizedPoolExtensions/AuctionExtension.sol\";\nimport \"../StabilizedPoolExtensions/GlobalICExtension.sol\";\nimport \"../StabilizedPoolExtensions/StabilizerNodeExtension.sol\";\nimport \"../interfaces/IAuction.sol\";\nimport \"../interfaces/IOverflow.sol\";\nimport \"../interfaces/IBurnMintableERC20.sol\";\nimport \"../interfaces/ISwingTrader.sol\";\nimport \"../interfaces/ILiquidityExtension.sol\";\nimport \"../interfaces/IMaltDataLab.sol\";\nimport \"../interfaces/IStabilizerNode.sol\";\nimport \"../interfaces/IGlobalImpliedCollateralService.sol\";\nimport \"../libraries/uniswap/IUniswapV2Pair.sol\";\nimport \"./PoolCollateral.sol\";\n\n\n/// @title Implied Collateral Service\n/// @author 0xScotch <scotch@malt.money>\n/// @notice A contract that provides an abstraction above individual implied collateral sources\ncontract ImpliedCollateralService is\n  StabilizedPoolUnit,\n  DataLabExtension,\n  SwingTraderManagerExtension,\n  LiquidityExtensionExtension,\n  RewardOverflowExtension,\n  AuctionExtension,\n  GlobalICExtension,\n  StabilizerNodeExtension\n{\n  using SafeERC20 for ERC20;\n\n  constructor(\n    address timelock,\n    address repository,\n    address poolFactory\n  ) StabilizedPoolUnit(timelock, repository, poolFactory) {}\n\n  function setupContracts(\n    address _collateralToken,\n    address _malt,\n    address _stakeToken,\n    address _auction,\n    address _rewardOverflow,\n    address _swingTraderManager,\n    address _liquidityExtension,\n    address _maltDataLab,\n    address _stabilizerNode,\n    address _globalIC\n  ) external onlyRoleMalt(POOL_FACTORY_ROLE, \"Must have pool factory role\") {\n    require(!contractActive, \"ImpCol: Already setup\");\n    require(_auction != address(0), \"ImpCol: Auction addr(0)\");\n    require(_rewardOverflow != address(0), \"ImpCol: Overflow addr(0)\");\n    require(_swingTraderManager != address(0), \"ImpCol: Swing addr(0)\");\n    require(_liquidityExtension != address(0), \"ImpCol: LE addr(0)\");\n    require(_maltDataLab != address(0), \"ImpCol: DataLab addr(0)\");\n    require(_stabilizerNode != address(0), \"ImpCol: StablizerNode addr(0)\");\n    require(_globalIC != address(0), \"ImpCol: GlobalIC addr(0)\");\n    require(_collateralToken != address(0), \"ImpCol: ColToken addr(0)\");\n    require(_malt != address(0), \"ImpCol: Malt addr(0)\");\n    require(_stakeToken != address(0), \"ImpCol: Stake Token addr(0)\");\n\n    contractActive = true;\n\n    auction = IAuction(_auction);\n    overflowPool = IOverflow(_rewardOverflow);\n    swingTraderManager = ISwingTrader(_swingTraderManager);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    stabilizerNode = IStabilizerNode(_stabilizerNode);\n    globalIC = IGlobalImpliedCollateralService(_globalIC);\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    stakeToken = IUniswapV2Pair(_stakeToken);\n\n    (, address updater, ) = poolFactory.getPool(_stakeToken);\n    _setPoolUpdater(updater);\n  }\n\n  function syncGlobalCollateral() public onlyActive {\n    globalIC.sync(getCollateralizedMalt());\n  }\n\n  function getCollateralizedMalt() public view returns (PoolCollateral memory) {\n    uint256 target = maltDataLab.priceTarget();\n\n    uint256 unity = 10**collateralToken.decimals();\n\n    // Convert all balances to be denominated in units of Malt target price\n    uint256 overflowBalance = maltDataLab.rewardToMaltDecimals((collateralToken.balanceOf(\n      address(overflowPool)\n    ) * unity) / target);\n    uint256 liquidityExtensionBalance = (collateralToken.balanceOf(\n      address(liquidityExtension)\n    ) * unity) / target;\n    (\n      uint256 swingTraderMaltBalance,\n      uint256 swingTraderBalance\n    ) = swingTraderManager.getTokenBalances();\n    swingTraderBalance = (swingTraderBalance * unity) / target;\n\n    return\n      PoolCollateral({\n        lpPool: address(stakeToken),\n        // Note that swingTraderBalance also includes the overflowBalance\n        // Therefore the total doesn't need to include overflowBalance explicitly\n        total: maltDataLab.rewardToMaltDecimals(\n            liquidityExtensionBalance + swingTraderBalance\n        ),\n        rewardOverflow: overflowBalance,\n        liquidityExtension: maltDataLab.rewardToMaltDecimals(\n          liquidityExtensionBalance\n        ),\n        // This swingTraderBalance value isn't just the capital in the swingTrader\n        // contract but also includes what is in the overflow so we subtract that\n        swingTrader: maltDataLab.rewardToMaltDecimals(swingTraderBalance) - overflowBalance,\n        swingTraderMalt: swingTraderMaltBalance,\n        arbTokens: maltDataLab.rewardToMaltDecimals(\n          auction.unclaimedArbTokens()\n        )\n      });\n  }\n\n  function totalUsefulCollateral() public view returns (uint256 collateral) {\n    uint256 liquidityExtensionBalance = collateralToken.balanceOf(\n      address(liquidityExtension)\n    );\n    (, uint256 swingTraderBalances) = swingTraderManager.getTokenBalances();\n\n    return liquidityExtensionBalance + swingTraderBalances;\n  }\n\n  function collateralRatio() external view returns (uint256 icTotal) {\n    uint256 decimals = collateralToken.decimals();\n    (uint256 reserve0, uint256 reserve1, ) = stakeToken.getReserves();\n\n    uint256 maltInPool = address(malt) < address(collateralToken)\n      ? maltDataLab.maltToRewardDecimals(reserve0)\n      : maltDataLab.maltToRewardDecimals(reserve1);\n\n    icTotal = ((totalUsefulCollateral() * (10**decimals)) / maltInPool);\n  }\n\n  function swingTraderCollateralRatio()\n    external\n    view\n    returns (uint256 icTotal)\n  {\n    uint256 decimals = collateralToken.decimals();\n    uint256 overflowBalance = collateralToken.balanceOf(address(overflowPool));\n\n    // SwingTraderManager will return balance in swing trader as well as overflow\n    // So we need to subtract the overflow balance from the swingTraderBalance\n    (, uint256 swingTraderBalance) = swingTraderManager.getTokenBalances();\n    swingTraderBalance = swingTraderBalance - overflowBalance;\n\n    (uint256 reserve0, uint256 reserve1, ) = stakeToken.getReserves();\n\n    uint256 maltInPool = address(malt) < address(collateralToken)\n      ? maltDataLab.maltToRewardDecimals(reserve0)\n      : maltDataLab.maltToRewardDecimals(reserve1);\n\n    icTotal = ((swingTraderBalance * (10**decimals)) / maltInPool);\n  }\n\n  function _accessControl()\n    internal\n    override(\n      DataLabExtension,\n      SwingTraderManagerExtension,\n      LiquidityExtensionExtension,\n      RewardOverflowExtension,\n      AuctionExtension,\n      GlobalICExtension,\n      StabilizerNodeExtension\n    )\n  {\n    _onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater role\");\n  }\n}"
    }
  ]
}