{
  "Title": "[N-08] Implement some type of version counter that will be incremented automatically for contract upgrades",
  "Content": "\n[PirexRewards.sol#L85](https://github.com/code-423n4/2022-11-redactedcartel/blob/main/src/PirexRewards.sol#L85)\n\nI suggest implementing some kind of version counter that will be incremented automatically when you upgrade the contract.\n\n### Recommended Mitigation Steps\n\n```js\n\nuint256 public authorizeUpgradeCounter;\n\n function upgradeTo(address _newImplementation) external onlyOwner {\n        _setPendingImplementation(_newImplementation);\n       authorizeUpgradeCounter+=1;\n\n    }\n```\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-11-redactedcartel",
  "Code": [
    {
      "filename": "src/PirexRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {OwnableUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {IProducer} from \"src/interfaces/IProducer.sol\";\nimport {GlobalState, UserState} from \"src/Common.sol\";\n\n/**\n    Originally inspired by Flywheel V2 (thank you Tribe team):\n    https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb8/src/FlywheelCore.sol\n*/\ncontract PirexRewards is OwnableUpgradeable {\n    using SafeTransferLib for ERC20;\n    using SafeCastLib for uint256;\n\n    struct ProducerToken {\n        ERC20[] rewardTokens;\n        GlobalState globalState;\n        mapping(address => UserState) userStates;\n        mapping(ERC20 => uint256) rewardStates;\n        mapping(address => mapping(ERC20 => address)) rewardRecipients;\n    }\n\n    // Pirex contract which produces rewards\n    IProducer public producer;\n\n    // Producer tokens mapped to their data\n    mapping(ERC20 => ProducerToken) public producerTokens;\n\n    event SetProducer(address producer);\n    event SetRewardRecipient(\n        address indexed user,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken,\n        address recipient\n    );\n    event UnsetRewardRecipient(\n        address indexed user,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n    event AddRewardToken(\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n    event RemoveRewardToken(ERC20 indexed producerToken, uint256 removalIndex);\n    event GlobalAccrue(\n        ERC20 indexed producerToken,\n        uint256 lastUpdate,\n        uint256 lastSupply,\n        uint256 rewards\n    );\n    event UserAccrue(\n        ERC20 indexed producerToken,\n        address indexed user,\n        uint256 lastUpdate,\n        uint256 lastBalance,\n        uint256 rewards\n    );\n    event Harvest(\n        ERC20[] producerTokens,\n        ERC20[] rewardTokens,\n        uint256[] rewardAmounts\n    );\n    event Claim(ERC20 indexed producerToken, address indexed user);\n    event SetRewardRecipientPrivileged(\n        address indexed lpContract,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken,\n        address recipient\n    );\n    event UnsetRewardRecipientPrivileged(\n        address indexed lpContract,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n\n    error ZeroAddress();\n    error NotContract();\n    error TokenAlreadyAdded();\n\n    function initialize() public initializer {\n        __Ownable_init();\n    }\n\n    /**\n        @notice Set producer\n        @param  _producer  address  Producer contract address\n     */\n    function setProducer(address _producer) external onlyOwner {\n        if (_producer == address(0)) revert ZeroAddress();\n\n        producer = IProducer(_producer);\n\n        emit SetProducer(_producer);\n    }\n\n    /**\n        @notice Set reward recipient for a reward token\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @param  recipient      address  Rewards recipient\n    */\n    function setRewardRecipient(\n        ERC20 producerToken,\n        ERC20 rewardToken,\n        address recipient\n    ) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n        if (recipient == address(0)) revert ZeroAddress();\n\n        producerTokens[producerToken].rewardRecipients[msg.sender][\n            rewardToken\n        ] = recipient;\n\n        emit SetRewardRecipient(\n            msg.sender,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Unset reward recipient for a reward token\n        @param  producerToken  ERC20  Producer token contract\n        @param  rewardToken    ERC20  Reward token contract\n    */\n    function unsetRewardRecipient(ERC20 producerToken, ERC20 rewardToken)\n        external\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        delete producerTokens[producerToken].rewardRecipients[msg.sender][\n            rewardToken\n        ];\n\n        emit UnsetRewardRecipient(msg.sender, producerToken, rewardToken);\n    }\n\n    /**\n        @notice Add a reward token to a producer token's rewardTokens array\n        @param  producerToken  ERC20  Producer token contract\n        @param  rewardToken    ERC20  Reward token contract\n    */\n    function addRewardToken(ERC20 producerToken, ERC20 rewardToken)\n        external\n        onlyOwner\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        // Check if the token has been added previously for the specified producer\n        ProducerToken storage p = producerTokens[producerToken];\n        ERC20[] memory rewardTokens = p.rewardTokens;\n        uint256 len = rewardTokens.length;\n\n        for (uint256 i; i < len; ++i) {\n            if (address(rewardTokens[i]) == address(rewardToken)) {\n                revert TokenAlreadyAdded();\n            }\n        }\n\n        p.rewardTokens.push(rewardToken);\n\n        emit AddRewardToken(producerToken, rewardToken);\n    }\n\n    /**\n        @notice Remove a reward token from a producer token's rewardTokens array\n        @param  producerToken  ERC20    Producer token contract\n        @param  removalIndex   uint256  Index of the element to be removed\n    */\n    function removeRewardToken(ERC20 producerToken, uint256 removalIndex)\n        external\n        onlyOwner\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n\n        ERC20[] storage rewardTokens = producerTokens[producerToken]\n            .rewardTokens;\n        uint256 lastIndex = rewardTokens.length - 1;\n\n        if (removalIndex != lastIndex) {\n            // Set the element at removalIndex to the last element\n            rewardTokens[removalIndex] = rewardTokens[lastIndex];\n        }\n\n        rewardTokens.pop();\n\n        emit RemoveRewardToken(producerToken, removalIndex);\n    }\n\n    /**\n        @notice Getter for a producer token's UserState struct member values\n        @param  producerToken  ERC20    Producer token contract\n        @param  user           address  User\n        @return lastUpdate     uint256  Last update\n        @return lastBalance    uint256  Last balance\n        @return rewards        uint256  Rewards\n    */\n    function getUserState(ERC20 producerToken, address user)\n        external\n        view\n        returns (\n            uint256 lastUpdate,\n            uint256 lastBalance,\n            uint256 rewards\n        )\n    {\n        UserState memory userState = producerTokens[producerToken].userStates[\n            user\n        ];\n\n        return (userState.lastUpdate, userState.lastBalance, userState.rewards);\n    }\n\n    /**\n        @notice Getter for a producer token's accrued amount for a reward token\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @return                uint256  Reward state\n    */\n    function getRewardState(ERC20 producerToken, ERC20 rewardToken)\n        external\n        view\n        returns (uint256)\n    {\n        return producerTokens[producerToken].rewardStates[rewardToken];\n    }\n\n    /**\n        @notice Getter for a producer token's reward tokens\n        @param  producerToken  ERC20    Producer token contract\n        @return                ERC20[]  Reward token contracts\n    */\n    function getRewardTokens(ERC20 producerToken)\n        external\n        view\n        returns (ERC20[] memory)\n    {\n        return producerTokens[producerToken].rewardTokens;\n    }\n\n    /**\n        @notice Get the reward recipient for a user by producer and reward token\n        @param  user           address  User\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @return                address  Reward recipient\n    */\n    function getRewardRecipient(\n        address user,\n        ERC20 producerToken,\n        ERC20 rewardToken\n    ) external view returns (address) {\n        return\n            producerTokens[producerToken].rewardRecipients[user][rewardToken];\n    }\n\n    /**\n        @notice Update global rewards accrual state\n        @param  producerToken  ERC20  Rewards-producing token\n    */\n    function globalAccrue(ERC20 producerToken) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n\n        _globalAccrue(producerTokens[producerToken].globalState, producerToken);\n    }\n\n    /**\n        @notice Update user rewards accrual state\n        @param  producerToken  ERC20    Rewards-producing token\n        @param  user           address  User address\n    */\n    function userAccrue(ERC20 producerToken, address user) public {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (user == address(0)) revert ZeroAddress();\n\n        UserState storage u = producerTokens[producerToken].userStates[user];\n        uint256 balance = producerToken.balanceOf(user);\n\n        // Calculate the amount of rewards accrued by the user up to this call\n        uint256 rewards = u.rewards +\n            u.lastBalance *\n            (block.timestamp - u.lastUpdate);\n\n        u.lastUpdate = block.timestamp.safeCastTo32();\n        u.lastBalance = balance.safeCastTo224();\n        u.rewards = rewards;\n\n        emit UserAccrue(producerToken, user, block.timestamp, balance, rewards);\n    }\n\n    /**\n        @notice Update global accrual state\n        @param  globalState    GlobalState  Global state of the producer token\n        @param  producerToken  ERC20        Producer token contract\n    */\n    function _globalAccrue(GlobalState storage globalState, ERC20 producerToken)\n        internal\n    {\n        uint256 totalSupply = producerToken.totalSupply();\n        uint256 lastUpdate = globalState.lastUpdate;\n        uint256 lastSupply = globalState.lastSupply;\n\n        // Calculate rewards, the product of seconds elapsed and last supply\n        // Only calculate and update states when needed\n        if (block.timestamp != lastUpdate || totalSupply != lastSupply) {\n            uint256 rewards = globalState.rewards +\n                (block.timestamp - lastUpdate) *\n                lastSupply;\n\n            globalState.lastUpdate = block.timestamp.safeCastTo32();\n            globalState.lastSupply = totalSupply.safeCastTo224();\n            globalState.rewards = rewards;\n\n            emit GlobalAccrue(\n                producerToken,\n                block.timestamp,\n                totalSupply,\n                rewards\n            );\n        }\n    }\n\n    /**\n        @notice Harvest rewards\n        @return _producerTokens  ERC20[]  Producer token contracts\n        @return rewardTokens     ERC20[]  Reward token contracts\n        @return rewardAmounts    ERC20[]  Reward token amounts\n    */\n    function harvest()\n        public\n        returns (\n            ERC20[] memory _producerTokens,\n            ERC20[] memory rewardTokens,\n            uint256[] memory rewardAmounts\n        )\n    {\n        (_producerTokens, rewardTokens, rewardAmounts) = producer\n            .claimRewards();\n        uint256 pLen = _producerTokens.length;\n\n        // Iterate over the producer tokens and update reward state\n        for (uint256 i; i < pLen; ++i) {\n            ERC20 p = _producerTokens[i];\n            uint256 r = rewardAmounts[i];\n\n            // Update global reward accrual state and associate with the update of reward state\n            ProducerToken storage producerState = producerTokens[p];\n\n            _globalAccrue(producerState.globalState, p);\n\n            if (r != 0) {\n                producerState.rewardStates[rewardTokens[i]] += r;\n            }\n        }\n\n        emit Harvest(_producerTokens, rewardTokens, rewardAmounts);\n    }\n\n    /**\n        @notice Claim rewards\n        @param  producerToken  ERC20    Producer token contract\n        @param  user           address  User\n    */\n    function claim(ERC20 producerToken, address user) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (user == address(0)) revert ZeroAddress();\n\n        harvest();\n        userAccrue(producerToken, user);\n\n        ProducerToken storage p = producerTokens[producerToken];\n        uint256 globalRewards = p.globalState.rewards;\n        uint256 userRewards = p.userStates[user].rewards;\n\n        // Claim should be skipped and not reverted on zero global/user reward\n        if (globalRewards != 0 && userRewards != 0) {\n            ERC20[] memory rewardTokens = p.rewardTokens;\n            uint256 rLen = rewardTokens.length;\n\n            // Update global and user reward states to reflect the claim\n            p.globalState.rewards = globalRewards - userRewards;\n            p.userStates[user].rewards = 0;\n\n            emit Claim(producerToken, user);\n\n            // Transfer the proportionate reward token amounts to the recipient\n            for (uint256 i; i < rLen; ++i) {\n                ERC20 rewardToken = rewardTokens[i];\n                address rewardRecipient = p.rewardRecipients[user][rewardToken];\n                address recipient = rewardRecipient != address(0)\n                    ? rewardRecipient\n                    : user;\n                uint256 rewardState = p.rewardStates[rewardToken];\n                uint256 amount = (rewardState * userRewards) / globalRewards;\n\n                if (amount != 0) {\n                    // Update reward state (i.e. amount) to reflect reward tokens transferred out\n                    p.rewardStates[rewardToken] = rewardState - amount;\n\n                    producer.claimUserReward(\n                        address(rewardToken),\n                        amount,\n                        recipient\n                    );\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    ⚠️ NOTABLE PRIVILEGED METHODS ⚠️\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Privileged method for setting the reward recipient of a contract\n        @notice This should ONLY be used to forward rewards for Pirex-GMX LP contracts\n        @notice In production, we will have a 2nd multisig which reduces risk of abuse\n        @param  lpContract     address  Pirex-GMX LP contract\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @param  recipient      address  Rewards recipient\n    */\n    function setRewardRecipientPrivileged(\n        address lpContract,\n        ERC20 producerToken,\n        ERC20 rewardToken,\n        address recipient\n    ) external onlyOwner {\n        if (lpContract.code.length == 0) revert NotContract();\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n        if (recipient == address(0)) revert ZeroAddress();\n\n        producerTokens[producerToken].rewardRecipients[lpContract][\n            rewardToken\n        ] = recipient;\n\n        emit SetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Privileged method for unsetting the reward recipient of a contract\n        @param  lpContract     address  Pirex-GMX LP contract\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n    */\n    function unsetRewardRecipientPrivileged(\n        address lpContract,\n        ERC20 producerToken,\n        ERC20 rewardToken\n    ) external onlyOwner {\n        if (lpContract.code.length == 0) revert NotContract();\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        delete producerTokens[producerToken].rewardRecipients[lpContract][\n            rewardToken\n        ];\n\n        emit UnsetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken\n        );\n    }\n}"
    }
  ]
}