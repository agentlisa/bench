{
  "Title": "[L-01] Changing address for `SafeModerator` or `ConsoleFallbackHandler` will break existing `subAccounts`",
  "Content": "\nDuring execution of operations on sub-accounts, the fallback handler and guard are not allowed to change:\n\n[`TransactionValidator::_checkSubAccountSecurityConfig`](https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/TransactionValidator.sol#L182-L191):\n```solidity\nFile: contracts/src/core/TransactionValidator.sol\n\n182:        address guard = SafeHelper._getGuard(_subAccount);\n183:        address fallbackHandler = SafeHelper._getFallbackHandler(_subAccount);\n184:\n185:        // Ensure guard has not been disabled\n186:        if (guard != AddressProviderService._getAuthorizedAddress(_SAFE_MODERATOR_HASH)) revert InvalidGuard();\n187:\n188:        // Ensure fallback handler has not been altered\n189:        if (fallbackHandler != AddressProviderService._getAuthorizedAddress(_CONSOLE_FALLBACK_HANDLER_HASH)) {\n190:            revert InvalidFallbackHandler();\n191:        }\n```\n\nHere, the guard and fallback handler are verified unchanged to what is defined in the address provider service.\n\nThe issue is that if [governance changes](https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/AddressProvider.sol#L77-L90) the implementations of either of these, this check will fail for all existing sub-accounts; since they are created with what was the guard and fallback handler at time of safe creation.\n\nThe sub-accounts are blocked until the console account updates the guard or fallback handler on the sub-account.\n\n### Impact\n\nChanging the address of either `SafeModerator` or `ConsoleFallbackHandler` will break every existing `subAccount`. It also forces the owning console accounts to upgrade to the new implementations without any opt-in.\n\n### Recommendation\n\nConsider storing the values in `pre`-validation and do the comparison against the stored values in `post`-validation. That way, they are independent of any changes from the protocol.\n\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-brahma",
  "Code": [
    {
      "filename": "contracts/src/core/TransactionValidator.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\nimport {IGnosisSafe, Enum} from \"interfaces/external/IGnosisSafe.sol\";\nimport {PolicyValidator} from \"src/core/PolicyValidator.sol\";\nimport {SafeHelper} from \"src/libraries/SafeHelper.sol\";\nimport {AddressProviderService} from \"src/core/AddressProviderService.sol\";\nimport {WalletRegistry} from \"src/core/registries/WalletRegistry.sol\";\n\n/**\n * @title TransactionValidator\n * @author Brahma.fi\n * @notice Allows validation of transactions pre and post execution\n */\ncontract TransactionValidator is AddressProviderService {\n    error TxnUnAuthorized();\n    error InvalidGuard();\n    error InvalidFallbackHandler();\n    error InvalidModule();\n\n    /**\n     * @notice datatype for safe transaction params\n     * @param from address of safe\n     * @param to target address\n     * @param value txn value\n     * @param data txn callData\n     * @param operation type of operation\n     * @param safeTxGas gas that should be used for safe txn\n     * @param baseGas gas cost independent of txn cost\n     * @param gasPrice gas price in current block\n     * @param gasToken address of token used for gas\n     * @param refundReceiver address of receiver of gas payment\n     * @param signatures user signatures appended with validation signature\n     * @param msgSender address of msg.sender of original txn\n     */\n    struct SafeTransactionParams {\n        Enum.Operation operation;\n        address from;\n        address to;\n        address payable refundReceiver;\n        address gasToken;\n        address msgSender;\n        uint256 value;\n        uint256 safeTxGas;\n        uint256 baseGas;\n        uint256 gasPrice;\n        bytes data;\n        bytes signatures;\n    }\n\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   CONSOLE GUARD HOOKS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    /**\n     * @notice Validates a txn on guard before execution, for Brahma console accounts\n     * @dev checks for possible console overrides and then performs policy validation\n     * @param txParams params of transaction\n     */\n    function validatePreTransactionOverridable(SafeTransactionParams memory txParams) external view {\n        // Check if guard or fallback handler is being removed, if yes, skip policy validation\n        if (_isConsoleBeingOverriden(txParams.from, txParams.to, txParams.value, txParams.data, txParams.operation)) {\n            return;\n        }\n\n        // Validate policy otherwise\n        _validatePolicySignature(\n            txParams.from, txParams.to, txParams.value, txParams.data, txParams.operation, txParams.signatures\n        );\n    }\n\n    /* solhint-disable no-empty-blocks */\n    /**\n     * @notice Provides on-chain guarantees on security critical expected states of a Brhma console account\n     * @dev Empty hook available for future use\n     */\n    function validatePostTransactionOverridable(bytes32, /*txHash */ bool, /*success */ address /*console */ )\n        external\n        view\n    {}\n    /* solhint-enable no-empty-blocks */\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   SUBACCOUNT GUARD HOOKS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    /**\n     * @notice Validates a txn on guard before execution, for subAccounts\n     * @dev calls policy validator to check if policy signature is valid\n     * @param txParams params of transaction\n     */\n    function validatePreTransaction(SafeTransactionParams memory txParams) external view {\n        _validatePolicySignature(\n            txParams.from, txParams.to, txParams.value, txParams.data, txParams.operation, txParams.signatures\n        );\n    }\n\n    /**\n     * @notice Provides on-chain guarantees on security critical expected states of subAccount for guard\n     * @param subAccount address of subAccount to validate\n     */\n    function validatePostTransaction(bytes32, /*txHash */ bool, /*success */ address subAccount) external view {\n        _checkSubAccountSecurityConfig(subAccount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EXECUTOR PLUGIN GUARD HOOKS              */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    /**\n     * @notice Validates a module txn before execution\n     * @dev calls policy validator to check if policy signature is valid\n     * @param from address of safe\n     * @param transactionStructHash transaction struct hash\n     * @param signatures user signatures appended with validation signature\n     */\n    function validatePreExecutorTransaction(\n        address, /*msgSender */\n        address from,\n        bytes32 transactionStructHash,\n        bytes memory signatures\n    ) external view {\n        _validatePolicySignature(from, transactionStructHash, signatures);\n    }\n\n    /**\n     * @notice Provides on-chain guarantees on security critical expected states of subAccount for executor plugin\n     * @param subAccount address of subAccount to validate\n     */\n    function validatePostExecutorTransaction(address, /*msgSender */ address subAccount) external view {\n        _checkSubAccountSecurityConfig(subAccount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   INTERNAL METHODS                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    /**\n     * @notice Provides guarantees that the guard and fallback handler can always be removed by the console\n     * @dev This ensures that, if a `ConsoleAccount` wishes to override policy checks, to change the guard or fallback handler, it can do so without any external intervention\n     * @param _from address of sender\n     * @param _to target address\n     * @param _value txn value\n     * @param _data txn callData\n     * @param _operation type of operation\n     * @return isGuardBeingRemoved\n     */\n    function _isConsoleBeingOverriden(\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        Enum.Operation _operation\n    ) internal pure returns (bool) {\n        /**\n         * Following conditions validate if the transaction aims to remove guard or fallback handler on Safe\n         *         from == to (safe sending txn to itself)\n         *         value == 0\n         *         data == abi.encodeCall(IGnosisSafe.setGuard, (address(0))) || abi.encodeCall(IGnosisSafe.setFallbackHandler, (address(0)))\n         *         operation == Enum.Operation.Call\n         *\n         * In case these conditions are met, the guard is being removed, return true\n         */\n        if (_from == _to && _value == 0 && _operation == Enum.Operation.Call) {\n            if (SafeHelper._GUARD_REMOVAL_CALLDATA_HASH == keccak256(_data)) {\n                return true;\n            } else if (SafeHelper._FALLBACK_REMOVAL_CALLDATA_HASH == keccak256(_data)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Internal helper to validate the module, guard and fallback handler for a subaccount\n     * @dev Ensures that guard has not been disabled/updated and the owner console as a module has not been disabled\n     * @param _subAccount address of subAccount\n     */\n    function _checkSubAccountSecurityConfig(address _subAccount) internal view {\n        address guard = SafeHelper._getGuard(_subAccount);\n        address fallbackHandler = SafeHelper._getFallbackHandler(_subAccount);\n\n        // Ensure guard has not been disabled\n        if (guard != AddressProviderService._getAuthorizedAddress(_SAFE_MODERATOR_HASH)) revert InvalidGuard();\n\n        // Ensure fallback handler has not been altered\n        if (fallbackHandler != AddressProviderService._getAuthorizedAddress(_CONSOLE_FALLBACK_HANDLER_HASH)) {\n            revert InvalidFallbackHandler();\n        }\n\n        address ownerConsole =\n            WalletRegistry(AddressProviderService._getRegistry(_WALLET_REGISTRY_HASH)).subAccountToWallet(_subAccount);\n\n        // Ensure owner console as a module has not been disabled\n        if (!IGnosisSafe(_subAccount).isModuleEnabled(ownerConsole)) revert InvalidModule();\n    }\n\n    /**\n     * @notice Internal helper to validate policy signature for a safe txn\n     * @dev Calls policy validator to check if policy signature is valid\n     * @param _from address of safe\n     * @param _to target address\n     * @param _value txn value\n     * @param _data txn callData\n     * @param _operation type of operation\n     * @param _signatures user signatures appended with validation signature\n     */\n    function _validatePolicySignature(\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        Enum.Operation _operation,\n        bytes memory _signatures\n    ) internal view {\n        if (\n            !PolicyValidator(AddressProviderService._getAuthorizedAddress(_POLICY_VALIDATOR_HASH)).isPolicySignatureValid(\n                _from, _to, _value, _data, _operation, _signatures\n            )\n        ) {\n            revert TxnUnAuthorized();\n        }\n    }\n\n    /**\n     * @notice Internal helper to validate policy signature for a module txn\n     * @dev Calls policy validator to check if policy signature is valid\n     * @param _from address of safe\n     * @param _transactionStructHash transaction struct hash\n     * @param _signatures user signatures appended with validation signature\n     */\n    function _validatePolicySignature(address _from, bytes32 _transactionStructHash, bytes memory _signatures)\n        internal\n        view\n    {\n        if (\n            !PolicyValidator(AddressProviderService._getAuthorizedAddress(_POLICY_VALIDATOR_HASH)).isPolicySignatureValid(\n                _from, _transactionStructHash, _signatures\n            )\n        ) {\n            revert TxnUnAuthorized();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/src/core/AddressProvider.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\nimport {IAddressProviderService} from \"interfaces/IAddressProviderService.sol\";\n\n/**\n * @title AddressProvider\n * @author Brahma.fi\n * @notice Single source of truth for resolving addresses of core components and external contracts\n */\ncontract AddressProvider {\n    error RegistryAlreadyExists();\n    error AddressProviderUnsupported();\n    error NotGovernance(address);\n    error NotPendingGovernance(address);\n    error NullAddress();\n\n    event RegistryInitialised(address indexed registry, bytes32 indexed key);\n    event AuthorizedAddressInitialised(address indexed authorizedAddress, bytes32 indexed key);\n    event GovernanceTransferRequested(address indexed previousGovernance, address indexed newGovernance);\n    event GovernanceTransferred(address indexed previousGovernance, address indexed newGovernance);\n\n    /// @notice address of governance\n    address public governance;\n    /// @notice address of pending governance before accepting\n    address public pendingGovernance;\n\n    /**\n     * @notice keccak256 hash of authorizedAddress keys mapped to their addresses\n     * @dev authorizedAddresses are updatable by governance\n     */\n    mapping(bytes32 => address) public authorizedAddresses;\n\n    /**\n     * @notice keccak256 hash of registry keys mapped to their addresses\n     * @dev registries are only set once by governance and immutable\n     */\n    mapping(bytes32 => address) public registries;\n\n    constructor(address _governance) {\n        _notNull(_governance);\n        governance = _governance;\n    }\n\n    /**\n     * @notice Governance setter\n     * @param _newGovernance address of new governance\n     */\n    function setGovernance(address _newGovernance) external {\n        _notNull(_newGovernance);\n        _onlyGov();\n        emit GovernanceTransferRequested(governance, _newGovernance);\n        pendingGovernance = _newGovernance;\n    }\n\n    /**\n     * @notice Governance accepter\n     */\n    function acceptGovernance() external {\n        if (msg.sender != pendingGovernance) {\n            revert NotPendingGovernance(msg.sender);\n        }\n        emit GovernanceTransferred(governance, msg.sender);\n        governance = msg.sender;\n        delete pendingGovernance;\n    }\n\n    /**\n     * @notice Authorized address setter\n     * @param _key key of authorizedAddress\n     * @param _authorizedAddress address to set\n     * @param _overrideCheck overrides check for supported address provider\n     */\n    function setAuthorizedAddress(bytes32 _key, address _authorizedAddress, bool _overrideCheck) external {\n        _onlyGov();\n        _notNull(_authorizedAddress);\n\n        /// @dev skips checks for supported `addressProvider()` if `_overrideCheck` is true\n        if (!_overrideCheck) {\n            /// @dev skips checks for supported `addressProvider()` if `_authorizedAddress` is an EOA\n            if (_authorizedAddress.code.length != 0) _ensureAddressProvider(_authorizedAddress);\n        }\n\n        authorizedAddresses[_key] = _authorizedAddress;\n\n        emit AuthorizedAddressInitialised(_authorizedAddress, _key);\n    }\n\n    /**\n     * @notice Registry address setter\n     * @param _key key of registry address\n     * @param _registry address to set\n     */\n    function setRegistry(bytes32 _key, address _registry) external {\n        _onlyGov();\n        _ensureAddressProvider(_registry);\n\n        if (registries[_key] != address(0)) revert RegistryAlreadyExists();\n        registries[_key] = _registry;\n\n        emit RegistryInitialised(_registry, _key);\n    }\n\n    /**\n     * @notice Authorized address getter\n     * @param _key key of authorized address\n     * @return address of authorized address\n     */\n    function getAuthorizedAddress(bytes32 _key) external view returns (address) {\n        return authorizedAddresses[_key];\n    }\n\n    /**\n     * @notice Registry address getter\n     * @param _key key of registry address\n     * @return address of registry address\n     */\n    function getRegistry(bytes32 _key) external view returns (address) {\n        return registries[_key];\n    }\n\n    /**\n     * @notice Ensures that the new address supports the AddressProviderService interface\n     * and is pointing to this AddressProvider\n     * @param _newAddress address to check\n     */\n    function _ensureAddressProvider(address _newAddress) internal view {\n        if (IAddressProviderService(_newAddress).addressProviderTarget() != address(this)) {\n            revert AddressProviderUnsupported();\n        }\n    }\n\n    /**\n     * @notice Checks if msg.sender is governance\n     */\n    function _onlyGov() internal view {\n        if (msg.sender != governance) revert NotGovernance(msg.sender);\n    }\n\n    /**\n     * @notice Checks and reverts if address is null\n     * @param addr address to check if null\n     */\n    function _notNull(address addr) internal pure {\n        if (addr == address(0)) revert NullAddress();\n    }\n}"
    }
  ]
}