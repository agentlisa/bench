{
  "Title": "H-1: Public vault : Initial depositor can manipulate the price per share value and future depositors are forced to deposit huge value in vault.",
  "Content": "# Issue H-1: Public vault : Initial depositor can manipulate the price per share value and future depositors are forced to deposit huge value in vault. \n\nSource: https://github.com/sherlock-audit/2022-11-sense-judging/issues/50 \n\n## Found by \nak1\n\n## Summary\nMost of the share based vault implementation will face this issue.\nThe vault is based on the ERC4626 where the shares are calculated based on the deposit value.\nBy depositing large amount as initial deposit, initial depositor can influence the future depositors value.\n\n## Vulnerability Detail\n\nShares are minted based on the deposit value.\nhttps://github.com/sherlock-audit/2022-11-sense/blob/main/contracts/src/RollerPeriphery.sol#L59-L79\nPublic vault is based on the ERC4626 where the shares are calculated based on the deposit value.\n\nBy depositing large amount as initial deposit, first depositor can take advantage over other depositors.\n\nI am sharing reference for this type of issue that already reported and acknowledged. This explain how the share price could be manipulated to  large value.\n\nhttps://github.com/sherlock-audit/2022-08-sentiment-judging#issue-h-1-a-malicious-early-userattacker-can-manipulate-the-ltokens-pricepershare-to-take-an-unfair-share-of-future-users-deposits:~:text=Issue%20H%2D1%3A%20A%20malicious%20early%20user/attacker%20can%20manipulate%20the%20LToken%27s%20pricePerShare%20to%20take%20an%20unfair%20share%20of%20future%20users%27%20deposits\n\nERC4626 implementation\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n      function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n\n## Impact\nFuture depositors are forced for huge value of asset to deposit. It is not practically possible for all the users.\nThis could directly affect on the attrition of users towards this system.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-sense/blob/main/contracts/src/RollerPeriphery.sol#L59-L79\n\nERC4626 implementation\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n      function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider requiring a minimal amount of share tokens to be minted for the first minter, and send a portion of the initial mints as a reserve to the DAO/ burn so that the price per share can be more resistant to manipulation.\n\n## Discussion\n\n**Evert0x**\n\nDepositor can bypass this initial deposit https://github.com/sherlock-audit/2022-11-sense/blob/main/contracts/src/AutoRoller.sol#L160\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/19",
  "Code": [
    {
      "filename": "contracts/src/RollerPeriphery.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.13;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { ERC4626 } from \"solmate/mixins/ERC4626.sol\";\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\n\nimport { AutoRoller } from \"./AutoRoller.sol\";\n\n// Inspired by https://github.com/fei-protocol/ERC4626/blob/main/src/ERC4626Router.sol\ncontract RollerPeriphery {\n    using SafeTransferLib for ERC20;\n\n    /// @notice thrown when amount of assets received is below the min set by caller.\n    error MinAssetError();\n\n    /// @notice thrown when amount of shares received is below the min set by caller.\n    error MinSharesError();\n\n    /// @notice thrown when amount of assets received is above the max set by caller.\n    error MaxAssetError();\n\n    /// @notice thrown when amount of shares received is above the max set by caller.\n    error MaxSharesError();\n\n    /// @notice thrown when amount of assets or excess received is below the max set by caller.\n    error MinAssetsOrExcessError();\n\n    /// @notice Redeem vault shares with slippage protection \n    /// @param vault ERC4626 vault\n    /// @param shares Number of shares to redeem\n    /// @param receiver Destination address for the returned assets\n    /// @param minAmountOut Minimum amount of assets returned\n    /// @return assets Amount of asset redeemable by the given number of shares\n    function redeem(ERC4626 vault, uint256 shares, address receiver, uint256 minAmountOut) external returns (uint256 assets) {\n        if ((assets = vault.redeem(shares, receiver, msg.sender)) < minAmountOut) {\n            revert MinAssetError();\n        }\n    }\n\n    /// @notice Withdraw underlying asset from vault with slippage protection \n    /// @param vault ERC4626 vault\n    /// @param assets Amount of asset requested for withdrawal\n    /// @param receiver Destination address for the returned assets\n    /// @param maxSharesOut Maximum amount of shares burned\n    /// @return shares Number of shares to redeem\n    function withdraw(ERC4626 vault, uint256 assets, address receiver, uint256 maxSharesOut) external returns (uint256 shares) {\n        if ((shares = vault.withdraw(assets, receiver, msg.sender)) > maxSharesOut) {\n            revert MaxSharesError();\n        }\n    }\n\n    /// @notice Mint vault shares with slippage protection \n    /// @param vault ERC4626 vault\n    /// @param shares Number of shares to mint\n    /// @param receiver Destination address for the returned shares\n    /// @param maxAmountIn Maximum amount of assets pulled from msg.sender\n    /// @return assets Amount of asset pulled from msg.sender and used to mint vault shares\n    function mint(ERC4626 vault, uint256 shares, address receiver, uint256 maxAmountIn) external returns (uint256 assets) {\n        ERC20(vault.asset()).safeTransferFrom(msg.sender, address(this), vault.previewMint(shares));\n\n        if ((assets = vault.mint(shares, receiver)) > maxAmountIn) {\n            revert MaxAssetError();\n        }\n    }\n\n    /// @notice Deposit underlying asset into vault with slippage protection \n    /// @param vault ERC4626 vault\n    /// @param assets Amount of asset pulled from msg.sender and used to mint vault shares\n    /// @param receiver Destination address for the returned shares\n    /// @param minSharesOut Minimum amount of returned shares\n    /// @return shares Number of shares minted by the vault and returned to msg.sender\n    function deposit(ERC4626 vault, uint256 assets, address receiver, uint256 minSharesOut) external returns (uint256 shares) {\n        ERC20(vault.asset()).safeTransferFrom(msg.sender, address(this), assets);\n\n        if ((shares = vault.deposit(assets, receiver)) < minSharesOut) {\n            revert MinSharesError();\n        }\n    }\n\n    /// @notice Quick exit into the constituent assets with slippage protection\n    /// @param vault ERC4626 vault.\n    /// @param shares Number of shares to eject with.\n    /// @param receiver Destination address for the constituent assets.\n    /// @param minAssetsOut Minimum amount of assets returned\n    /// @param minExcessOut Minimum excess PT/YT returned \n    /// @return assets Amount of asset redeemable by the given number of shares.\n    /// @return excessBal Amount of excess PT or YT redeemable by the given number of shares.\n    /// @return isExcessPTs Whether the excess token is a YT or PT.\n    function eject(ERC4626 vault, uint256 shares, address receiver, uint256 minAssetsOut, uint256 minExcessOut)\n        external returns (uint256 assets, uint256 excessBal, bool isExcessPTs)\n    {\n        (assets, excessBal, isExcessPTs) = AutoRoller(address(vault)).eject(shares, receiver, msg.sender);\n\n        if (assets < minAssetsOut || excessBal < minExcessOut) {\n            revert MinAssetsOrExcessError();\n        }\n    }\n\n    function approve(ERC20 token, address to, uint256 amount) public payable {\n        token.safeApprove(to, amount);\n    }\n}"
    },
    {
      "filename": "contracts/src/RollerPeriphery.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.13;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { ERC4626 } from \"solmate/mixins/ERC4626.sol\";\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\n\nimport { AutoRoller } from \"./AutoRoller.sol\";\n\n// Inspired by https://github.com/fei-protocol/ERC4626/blob/main/src/ERC4626Router.sol\ncontract RollerPeriphery {\n    using SafeTransferLib for ERC20;\n\n    /// @notice thrown when amount of assets received is below the min set by caller.\n    error MinAssetError();\n\n    /// @notice thrown when amount of shares received is below the min set by caller.\n    error MinSharesError();\n\n    /// @notice thrown when amount of assets received is above the max set by caller.\n    error MaxAssetError();\n\n    /// @notice thrown when amount of shares received is above the max set by caller.\n    error MaxSharesError();\n\n    /// @notice thrown when amount of assets or excess received is below the max set by caller.\n    error MinAssetsOrExcessError();\n\n    /// @notice Redeem vault shares with slippage protection \n    /// @param vault ERC4626 vault\n    /// @param shares Number of shares to redeem\n    /// @param receiver Destination address for the returned assets\n    /// @param minAmountOut Minimum amount of assets returned\n    /// @return assets Amount of asset redeemable by the given number of shares\n    function redeem(ERC4626 vault, uint256 shares, address receiver, uint256 minAmountOut) external returns (uint256 assets) {\n        if ((assets = vault.redeem(shares, receiver, msg.sender)) < minAmountOut) {\n            revert MinAssetError();\n        }\n    }\n\n    /// @notice Withdraw underlying asset from vault with slippage protection \n    /// @param vault ERC4626 vault\n    /// @param assets Amount of asset requested for withdrawal\n    /// @param receiver Destination address for the returned assets\n    /// @param maxSharesOut Maximum amount of shares burned\n    /// @return shares Number of shares to redeem\n    function withdraw(ERC4626 vault, uint256 assets, address receiver, uint256 maxSharesOut) external returns (uint256 shares) {\n        if ((shares = vault.withdraw(assets, receiver, msg.sender)) > maxSharesOut) {\n            revert MaxSharesError();\n        }\n    }\n\n    /// @notice Mint vault shares with slippage protection \n    /// @param vault ERC4626 vault\n    /// @param shares Number of shares to mint\n    /// @param receiver Destination address for the returned shares\n    /// @param maxAmountIn Maximum amount of assets pulled from msg.sender\n    /// @return assets Amount of asset pulled from msg.sender and used to mint vault shares\n    function mint(ERC4626 vault, uint256 shares, address receiver, uint256 maxAmountIn) external returns (uint256 assets) {\n        ERC20(vault.asset()).safeTransferFrom(msg.sender, address(this), vault.previewMint(shares));\n\n        if ((assets = vault.mint(shares, receiver)) > maxAmountIn) {\n            revert MaxAssetError();\n        }\n    }\n\n    /// @notice Deposit underlying asset into vault with slippage protection \n    /// @param vault ERC4626 vault\n    /// @param assets Amount of asset pulled from msg.sender and used to mint vault shares\n    /// @param receiver Destination address for the returned shares\n    /// @param minSharesOut Minimum amount of returned shares\n    /// @return shares Number of shares minted by the vault and returned to msg.sender\n    function deposit(ERC4626 vault, uint256 assets, address receiver, uint256 minSharesOut) external returns (uint256 shares) {\n        ERC20(vault.asset()).safeTransferFrom(msg.sender, address(this), assets);\n\n        if ((shares = vault.deposit(assets, receiver)) < minSharesOut) {\n            revert MinSharesError();\n        }\n    }\n\n    /// @notice Quick exit into the constituent assets with slippage protection\n    /// @param vault ERC4626 vault.\n    /// @param shares Number of shares to eject with.\n    /// @param receiver Destination address for the constituent assets.\n    /// @param minAssetsOut Minimum amount of assets returned\n    /// @param minExcessOut Minimum excess PT/YT returned \n    /// @return assets Amount of asset redeemable by the given number of shares.\n    /// @return excessBal Amount of excess PT or YT redeemable by the given number of shares.\n    /// @return isExcessPTs Whether the excess token is a YT or PT.\n    function eject(ERC4626 vault, uint256 shares, address receiver, uint256 minAssetsOut, uint256 minExcessOut)\n        external returns (uint256 assets, uint256 excessBal, bool isExcessPTs)\n    {\n        (assets, excessBal, isExcessPTs) = AutoRoller(address(vault)).eject(shares, receiver, msg.sender);\n\n        if (assets < minAssetsOut || excessBal < minExcessOut) {\n            revert MinAssetsOrExcessError();\n        }\n    }\n\n    function approve(ERC20 token, address to, uint256 amount) public payable {\n        token.safeApprove(to, amount);\n    }\n}"
    },
    {
      "filename": "contracts/src/AutoRoller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.13;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { FixedPointMathLib } from \"solmate/utils/FixedPointMathLib.sol\";\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { ERC4626 } from \"solmate/mixins/ERC4626.sol\";\n\nimport { DateTime } from \"./external/DateTime.sol\";\n\nimport { SafeCast } from \"./SafeCast.sol\";\n\nimport { BalancerVault } from \"./interfaces/BalancerVault.sol\";\nimport { Space } from \"./interfaces/Space.sol\";\n\ninterface SpaceFactoryLike {\n    function divider() external view returns (address);\n    function create(address, uint256) external returns (address);\n    function pools(address, uint256) external view returns (Space);\n}\n\ninterface DividerLike {\n    function series(address, uint256) external returns (address, uint48, address, uint96, address, uint256, uint256, uint256, uint256);\n    function issue(address, uint256, uint256) external returns (uint256);\n    function settleSeries(address, uint256) external;\n    function mscale(address, uint256) external view returns (uint256);\n    function redeem(address, uint256, uint256) external;\n    function combine(address, uint256, uint256) external;\n}\n\ninterface YTLike {\n    function approve(address, uint256) external;\n    function transfer(address, uint256) external;\n    function collect() external;\n    function balanceOf(address) external view returns (uint256);\n}\n\ninterface PeripheryLike {\n    function sponsorSeries(address, uint256, bool) external returns (ERC20, YTLike);\n    function swapYTsForTarget(address, uint256, uint256) external returns (uint256);\n    function create(address, uint256) external returns (address);\n    function spaceFactory() external view returns (SpaceFactoryLike);\n    function MIN_YT_SWAP_IN() external view returns (uint256);\n}\n\ninterface OwnedAdapterLike {\n    function target() external view returns (address);\n    function ifee() external view returns (uint256);\n    function openSponsorWindow() external;\n    function scale() external returns (uint256);\n    function scaleStored() external view returns (uint256);\n    function getStakeAndTarget() external view returns (address,address,uint256);\n    function setIsTrusted(address,bool) external;\n}\n\ncontract AutoRoller is ERC4626 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n    using SafeCast for *;\n\n    /* ========== ERRORS ========== */\n\n    error ActivePhaseOnly();\n    error UnrecognizedParam(bytes32 what);\n    error InsufficientLiquidity();\n    error RollWindowNotOpen();\n    error OnlyAdapter();\n    error InvalidSettler();\n\n    /* ========== CONSTANTS ========== */\n\n    uint32 internal constant MATURITY_NOT_SET = type(uint32).max;\n    int256 internal constant WITHDRAWAL_GUESS_OFFSET = 0.95e18; // Offset from the number of assets in this contract the first withdrawal guess will be made.\n\n    /* ========== IMMUTABLES ========== */\n\n    DividerLike      internal immutable divider;\n    BalancerVault    internal immutable balancerVault;\n    OwnedAdapterLike internal immutable adapter;\n\n    uint256 internal immutable ifee; // Cached issuance fee.\n    uint256 internal immutable minSwapAmount; // Min number of PTs that can be swapped out when exiting.\n    uint256 internal immutable firstDeposit; // Size of the first deposit that gets locked in the contract permanently.\n    uint256 internal immutable maxError; // A conservative buffer for \"rounding\" swap previews that accounts for compounded pow of imprecision.\n    address internal immutable rewardRecipient; // Recipient address for any unexpected tokens that end up in this contract.\n\n    /* ========== MUTABLE STORAGE ========== */\n\n    PeripheryLike    internal periphery;\n    SpaceFactoryLike internal spaceFactory;\n    address          internal owner; // Admin that can set params.\n    RollerUtils      internal utils; // Utility contract with convenience getter functions.\n\n    // Active Series\n    YTLike  internal yt;\n    ERC20   internal pt;\n    Space   internal space;\n    bytes32 internal poolId;\n    address internal lastRoller; // Last address to call roll.\n\n    // Separate slots to meet contract size limits.\n    uint256 internal initScale;\n    uint256 public  maturity = MATURITY_NOT_SET;\n    uint256 internal pti;\n\n    uint256 internal maxRate        = 53144e19; // Max implied rate stretched to Space pool's TS period. (531440% over 12 years ≈ 200% APY)\n    uint256 internal targetedRate   = 2.9e18; // Targeted implied rate stretched to Space pool's TS period. (2.9% over 12 years ≈ 0.12% APY)\n    uint256 internal targetDuration = 3; // Number of months or weeks in the future newly sponsored Series should mature.\n\n    uint256 public cooldown         = 10 days; // Length of mandatory cooldown period during which LPs can withdraw without slippage.\n    uint256 public lastSettle; // Timestamp from when settlement was last called.\n\n    constructor(\n        ERC20 _target,\n        DividerLike _divider,\n        address _periphery,\n        address _spaceFactory,\n        address _balancerVault,\n        OwnedAdapterLike _adapter,\n        RollerUtils _utils,\n        address _rewardRecipient\n    ) ERC4626(\n        _target,\n        string(abi.encodePacked(_target.name(), \" Sense Auto Roller\")),\n        string(abi.encodePacked(_target.symbol(), \"-sAR\"))\n    ) {\n        divider       = _divider;\n        periphery     = PeripheryLike(_periphery);\n        spaceFactory  = SpaceFactoryLike(_spaceFactory);\n        balancerVault = BalancerVault(_balancerVault);\n\n        // Allow the Divder to move this contract's Target for PT/YT issuance.\n        _target.safeApprove(address(_divider), type(uint256).max);\n\n        // Allow Balancer to move this contract's Target for Space pools joins.\n        _target.safeApprove(address(_balancerVault), type(uint256).max);\n\n        uint256 scalingFactor = 10**(18 - decimals);\n\n        minSwapAmount = (periphery.MIN_YT_SWAP_IN() - 1) / scalingFactor + 1; // Rounds up to cover low decimal tokens.\n        maxError      = (1e7 - 1) / scalingFactor + 1;\n        firstDeposit  = (0.01e18 - 1) / scalingFactor + 1;\n\n        adapter = _adapter;\n        ifee    = _adapter.ifee(); // Assumption: ifee will not change. Don't break this assumption and expect good things.\n        owner   = msg.sender;\n        utils   = _utils;\n        rewardRecipient = _rewardRecipient;\n    }\n\n    /* ========== SERIES MANAGEMENT ========== */\n\n    /// @notice Roll into the next Series if there isn't an active series and the cooldown period has elapsed.\n    function roll() external {\n        if (maturity != MATURITY_NOT_SET) revert RollWindowNotOpen();\n\n        if (lastSettle == 0) {\n            // If this is the first roll, lock some shares in by minting them for the zero address.\n            // This prevents the contract from reaching an empty state during future active periods.\n            deposit(firstDeposit, address(0));\n        } else if (lastSettle + cooldown > block.timestamp) {\n            revert RollWindowNotOpen();\n        }\n\n        lastRoller = msg.sender;\n        adapter.openSponsorWindow();\n    }\n\n    /// @notice Sponsor a new Series, issue PTs, and migrate liquidity into the new Space pool.\n    /// @dev We only expect this function to be called by this roller's adapter in the callback triggered within the adapter.openSponsorWindow call.\n    ///      Assumption: all of this Vault's LP shares will have been exited before this function is called.\n    /// @param stake the adapter's stake token address.\n    /// @param stakeSize the adapter's stake size.\n    function onSponsorWindowOpened(ERC20 stake, uint256 stakeSize) external {\n        if (msg.sender != address(adapter)) revert OnlyAdapter();\n\n        stake.safeTransferFrom(lastRoller, address(this), stakeSize);\n\n        // Allow the Periphery to move stake for sponsoring the Series.\n        stake.safeApprove(address(periphery), stakeSize);\n\n        uint256 _maturity = utils.getFutureMaturity(targetDuration);\n\n        // Assign Series data.\n        (ERC20 _pt, YTLike _yt) = periphery.sponsorSeries(address(adapter), _maturity, true);\n        (Space _space, bytes32 _poolId, uint256 _pti, uint256 _initScale) = utils.getSpaceData(periphery, OwnedAdapterLike(msg.sender), _maturity);\n\n        // Allow Balancer to move the new PTs for joins & swaps.\n        _pt.approve(address(balancerVault), type(uint256).max);\n\n        // Allow Periphery to move the new YTs for swaps.\n        _yt.approve(address(periphery), type(uint256).max);\n\n        ERC20 _asset = asset;\n\n        ERC20[] memory tokens = new ERC20[](2);\n        tokens[1 - _pti] = _asset;\n        tokens[_pti] = _pt;\n\n        uint256 targetBal = _asset.balanceOf(address(this));\n\n        // Get the reserve balances that would imply the given targetedRate in the Space pool,\n        // assuming that we we're going to deposit the amount of Target currently in this contract.\n        // In other words, this function simulating the reserve balances that would result from the actions:\n        // 1) Use the some Target to issue PTs/YTs\n        // 2) Deposit some amount of Target\n        // 3) Swap PTs into the pool to initialize the targeted rate\n        // 4) Deposit the rest of the PTs and Target in this contract (which remain in the exact ratio the pool expects)\n        // Since we're determining the resulting reserve balances of these operations, we can issue exactly the amount of PTs we'll need to keep the ratio in the pool.\n        (uint256 eqPTReserves, uint256 eqTargetReserves) = _space.getEQReserves(\n            targetedRate < 0.01e18 ? 0.01e18 : targetedRate, // Don't let the pool start below 0.01% stretched yield\n            _maturity,\n            0, // PT reserves, starting with 0\n            targetBal, // Target reserves, starting with the entire Target balance in this contract.\n            targetBal.mulWadDown(_initScale), // Total supply, starting with Target * initScale, since that's the BPT supply if once deposit all of the Target.\n            _space.g2() // Space fee, g2 because the swap we'll make to initialize these reserve balances is PT -> Target (see https://yield.is/YieldSpace.pdf section \"5 Fees\").\n        );\n\n        // Calculate & issue an amount of PTs, such that all PTs are used to add liquidity while preserving the PT:Target reserve ratio in the Space Pool.\n        uint256 targetForIssuance = _getTargetForIssuance(eqPTReserves, eqTargetReserves, targetBal, _initScale);\n        divider.issue(address(adapter), _maturity, targetForIssuance);\n\n        uint256[] memory balances = new uint256[](2);\n        balances[1 - _pti] = targetBal - targetForIssuance;\n\n        // Initialize the targeted rate in the Space pool with a join, a swap, and another join.\n        _joinPool(\n            _poolId,\n            BalancerVault.JoinPoolRequest({\n                assets: tokens,\n                maxAmountsIn: balances,\n                userData: abi.encode(balances, 0), // No min BPT out: first join.\n                fromInternalBalance: false\n            })\n        );\n        _swap(\n            BalancerVault.SingleSwap({\n                poolId: _poolId,\n                kind: BalancerVault.SwapKind.GIVEN_IN,\n                assetIn: address(_pt),\n                assetOut: address(tokens[1 - _pti]),\n                amount: eqPTReserves.mulDivDown(balances[1 - _pti], targetBal),\n                userData: hex\"\"\n            })\n        );\n\n        balances[_pti    ] = _pt.balanceOf(address(this));\n        balances[1 - _pti] = _asset.balanceOf(address(this));\n\n        _joinPool(\n            _poolId,\n            BalancerVault.JoinPoolRequest({\n                assets: tokens,\n                maxAmountsIn: balances,\n                userData: abi.encode(balances, 0), // No min BPT out: the pool was created in this tx and the join can't be sandwiched.\n                fromInternalBalance: false\n            })\n        );\n\n        // Cache Series data.\n        space  = _space;\n        poolId = _poolId;\n        pt     = _pt;\n        yt     = _yt;\n\n        // Combined single SSTORE.\n        initScale = _initScale;\n        maturity  = _maturity; // OK until Feb 07, 2106\n        pti       = _pti;\n\n        emit Rolled(_maturity, uint256(_initScale), address(_space), msg.sender);\n    }\n\n    /// @notice Settle the active Series, transfer stake and ifees to the settler, and enter a cooldown phase.\n    /// @dev Because the auto-roller is the series sponsor from the Divider's perspective, this.settle is the only entrypoint for athe lastRoller to settle during the series' sponsor window.\n    ///      More info on the series lifecylce: https://docs.sense.finance/docs/series-lifecycle-detail/#phase-3-settling.\n    function settle() public {\n        if(msg.sender != lastRoller) revert InvalidSettler();\n\n        uint256 assetBalPre = asset.balanceOf(address(this));\n        divider.settleSeries(address(adapter), maturity); // Settlement will fail if maturity hasn't been reached.\n        uint256 assetBalPost = asset.balanceOf(address(this));\n\n        asset.safeTransfer(msg.sender, assetBalPost - assetBalPre); // Send issuance fees to the sender.\n\n        (, address stake, uint256 stakeSize) = adapter.getStakeAndTarget();\n        if (stake != address(asset)) {\n            ERC20(stake).safeTransfer(msg.sender, stakeSize);\n        }\n\n        startCooldown();\n    }\n\n    /// @notice Enter a cooldown phase where users can redeem without slippage. Often this will be initiated by this.settle,\n    ///         but it can be called externally if the Series was settled externally.\n    function startCooldown() public {\n        require(divider.mscale(address(adapter), maturity) != 0);\n\n        ERC20[] memory tokens = new ERC20[](2);\n        tokens[1 - pti] = asset;\n        tokens[pti    ] = pt;\n\n        _exitPool(\n            poolId,\n            BalancerVault.ExitPoolRequest({\n                assets: tokens,\n                minAmountsOut: new uint256[](2),\n                userData: abi.encode(space.balanceOf(address(this))),\n                toInternalBalance: false\n            })\n        );\n\n        divider.redeem(address(adapter), maturity, pt.balanceOf(address(this))); // Burns the PTs.\n        yt.collect(); // Burns the YTs.\n\n        // Calculate the initial market fixed rate for the upcoming series, using the historical avg Target rate across the previous series.\n        targetedRate = utils.getNewTargetedRate(targetedRate, address(adapter), maturity, space);\n\n        maturity   = MATURITY_NOT_SET;\n        lastSettle = uint32(block.timestamp);\n        delete pt; delete yt; delete space; delete pti; delete poolId; delete initScale; // Re-set variables to defaults, collect gas refund.\n    }\n\n    /* ========== 4626 SPEC ========== */\n    // see: https://eips.ethereum.org/EIPS/eip-4626\n\n    /// @dev exit LP shares commensurate the given number of shares, and sell the excess PTs or YTs into Target if possible.\n    function beforeWithdraw(uint256, uint256 shares) internal override {\n        if (maturity != MATURITY_NOT_SET) {\n            (uint256 excessBal, bool isExcessPTs) = _exitAndCombine(shares);\n\n            if (excessBal < minSwapAmount) return;\n\n            if (isExcessPTs) {\n                (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n                uint256 maxPTSale = _maxPTSell(ptReserves, targetReserves, space.adjustedTotalSupply());\n\n                if (excessBal > maxPTSale) revert InsufficientLiquidity(); // Need to eject, wait for more liquidity, or wait until a cooldown phase.\n\n                _swap(\n                    BalancerVault.SingleSwap({\n                        poolId: poolId,\n                        kind: BalancerVault.SwapKind.GIVEN_IN,\n                        assetIn: address(pt),\n                        assetOut: address(asset),\n                        amount: excessBal,\n                        userData: hex\"\"\n                    })\n                );\n            } else {\n                periphery.swapYTsForTarget(address(adapter), maturity, excessBal); // Swapping YTs will fail if there isn't enough liquidity.\n            }\n        }\n    }\n\n    /// @dev Joins the Space pool, issuing PTs in order to match the current pool's ratio of Target:PT\n    function afterDeposit(uint256 assets, uint256 shares) internal override {\n        if (maturity != MATURITY_NOT_SET) {\n            uint256 _supply = totalSupply; // Saves extra SLOADs.\n            bytes32 _poolId = poolId;\n            uint256 _pti    = pti;\n\n            (ERC20[] memory tokens, uint256[] memory balances, ) = balancerVault.getPoolTokens(_poolId);\n\n            uint256 previewedLPBal = _supply - shares == 0 ?\n                shares : shares.mulDivUp(space.balanceOf(address(this)), _supply - shares); // _supply - shares b/c this is after minting new shares.\n\n            uint256 targetToJoin = previewedLPBal.mulDivUp(balances[1 - _pti], space.adjustedTotalSupply());\n\n            balances[1 - _pti] = targetToJoin;\n\n            if (assets - targetToJoin > 0) { // Assumption: this is false if Space has only Target liquidity.\n                balances[_pti] = divider.issue(address(adapter), maturity, assets - targetToJoin);\n            }\n\n            _joinPool(\n                _poolId,\n                BalancerVault.JoinPoolRequest({\n                    assets: tokens,\n                    maxAmountsIn: balances,\n                    userData: abi.encode(balances, 0),\n                    fromInternalBalance: false\n                })\n            );\n        }\n    }\n\n    /// @notice Calculates the total assets of this vault using the current spot prices, with no regard for slippage.\n    function totalAssets() public view override returns (uint256) {\n        if (maturity == MATURITY_NOT_SET) {\n            return asset.balanceOf(address(this));\n        } \n        else {\n            Space _space = space;\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n            \n            (uint256 targetBal, uint256 ptBal, uint256 ytBal, ) = _decomposeShares(ptReserves, targetReserves, totalSupply, true);\n\n            uint256 ptSpotPrice = _space.getPriceFromImpliedRate(\n                (ptReserves + _space.adjustedTotalSupply()).divWadDown(targetReserves.mulWadDown(initScale)) - 1e18\n            ); // PT price in Target.\n\n            uint256 scale = adapter.scaleStored();\n\n            if (ptBal >= ytBal) {\n                // Target + combined PTs/YTs + PT spot value in Target.\n                return targetBal + ytBal.divWadDown(scale) + ptSpotPrice.mulWadDown(ptBal - ytBal);\n            } else {\n                uint256 ytSpotPrice = (1e18 - ptSpotPrice.mulWadDown(scale)).divWadDown(scale);\n\n                // Target + combined PTs/YTs + YT spot value in Target.\n                return targetBal + ptBal.divWadDown(scale) + ytSpotPrice.mulWadDown(ytBal - ptBal);\n            }\n        }\n    }\n\n    /// @notice The same as convertToShares, except that slippage is considered.\n    /// @dev Preview the number of new LP shares that would be minted by joining with the given amount of Target, then use that\n    ///      as a percentage of the total number of LP shares held in this contract to preview the number of new roller shares.\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        if (maturity == MATURITY_NOT_SET) {\n            return super.previewDeposit(assets);\n        } else {\n            Space _space = space;\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n\n            // Calculate how much Target we'll end up joining the pool with, and use that to preview minted LP shares.\n            uint256 previewedLPBal = (assets - _getTargetForIssuance(ptReserves, targetReserves, assets, adapter.scaleStored()))\n                .mulDivDown(_space.adjustedTotalSupply(), targetReserves);\n\n            // Shares represent proportional ownership of LP shares the vault holds.\n            return previewedLPBal.mulDivDown(totalSupply, _space.balanceOf(address(this)));\n        }\n    }\n\n    /// @dev Preview the amount of Target needed to mint the given number of shares by determining how much of\n    ///      each asset in this contract the given number of shares represent, then conver that all into Target.\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        if (maturity == MATURITY_NOT_SET) {\n            return super.previewMint(shares);\n        } else {\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n\n            (uint256 targetToJoin, uint256 ptsToJoin, , ) = _decomposeShares(ptReserves, targetReserves, shares, true);\n\n            return targetToJoin + ptsToJoin.divWadUp(adapter.scaleStored().mulWadDown(1e18 - ifee)); // targetToJoin + targetToIssue\n        }\n    }\n\n    /// @notice The same as convertToAssets, except that slippage is considered.\n    function previewRedeem(uint256 shares) public view override returns (uint256) {\n        if (maturity == MATURITY_NOT_SET) {\n            return super.previewRedeem(shares);\n        } else {\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n\n            (uint256 targetBal, uint256 ptBal, uint256 ytBal, uint256 lpBal) = _decomposeShares(ptReserves, targetReserves, shares, false);\n\n            uint256 scale = adapter.scaleStored();\n\n            ptReserves     = ptReserves - ptBal;\n            targetReserves = targetReserves - targetBal;\n\n            uint256 spaceSupply = space.adjustedTotalSupply();\n\n            // Adjust balances for loose asset share.\n            ptBal       = ptBal       + lpBal.mulDivDown(pt.balanceOf(address(this)), spaceSupply);\n            targetBal   = targetBal   + lpBal.mulDivDown(asset.balanceOf(address(this)), spaceSupply);\n            spaceSupply = spaceSupply - lpBal;\n\n            if (ptBal > ytBal) {\n                unchecked {\n                    // Safety: an inequality check is done before ptBal - ytBal.\n                    //         shares must be lte total supply, so ptReserves & targetReserves wil always be gte ptBal & targetBal.\n                    uint256 maxPTSale = _maxPTSell(\n                        ptReserves,\n                        targetReserves,\n                        spaceSupply\n                    );\n\n                    // If there isn't enough liquidity to sell all of the PTs, sell the max that we can and ignore the remaining PTs.\n                    uint256 ptsToSell = _min(ptBal - ytBal, maxPTSale);\n\n                    uint256 targetOut = ptsToSell > minSwapAmount ?\n                        space.onSwapPreview(\n                            true,\n                            true,\n                            ptsToSell,\n                            ptReserves,"
    }
  ]
}