{
  "Title": "Duplicated code between `LibChop` and `LibUnripe`",
  "Content": "Duplicate versions of [`LibUnripe::_getPenalizedUnderlying`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/LibUnripe.sol#L143-L151) and [`LibUnripe::isUnripe`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/LibUnripe.sol#L217-L223) have been added to [`LibChop`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/LibChop.sol#L38-L64). This is not necessary as the logic that executes is identical, so these duplicate versions can be removed in favor of code reuse.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/LibUnripe.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IBean} from \"../interfaces/IBean.sol\";\nimport {AppStorage, LibAppStorage} from \"./LibAppStorage.sol\";\nimport {C} from \"../C.sol\";\nimport {LibWell} from \"./Well/LibWell.sol\";\nimport {Call, IWell} from \"contracts/interfaces/basin/IWell.sol\";\nimport {IWellFunction} from \"contracts/interfaces/basin/IWellFunction.sol\";\nimport {LibLockedUnderlying} from \"./LibLockedUnderlying.sol\";\n\n/**\n * @title LibUnripe\n * @author Publius\n * @notice Library for handling functionality related to Unripe Tokens and their Ripe Tokens.\n */\nlibrary LibUnripe {\n    using SafeMath for uint256;\n\n    event ChangeUnderlying(address indexed token, int256 underlying);\n    event SwitchUnderlyingToken(address indexed token, address indexed underlyingToken);\n\n    uint256 constant DECIMALS = 1e6;\n\n    /**\n     * @notice Returns the percentage that Unripe Beans have been recapitalized.\n     */\n    function percentBeansRecapped() internal view returns (uint256 percent) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return\n            s.u[C.UNRIPE_BEAN].balanceOfUnderlying.mul(DECIMALS).div(C.unripeBean().totalSupply());\n    }\n\n    /**\n     * @notice Returns the percentage that Unripe LP have been recapitalized.\n     */\n    function percentLPRecapped() internal view returns (uint256 percent) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return C.unripeLPPerDollar().mul(s.recapitalized).div(C.unripeLP().totalSupply());\n    }\n\n    /**\n     * @notice Increments the underlying balance of an Unripe Token.\n     * @param token The address of the unripe token.\n     * @param amount The amount of the of the unripe token to be added to the storage reserves\n     */\n    function incrementUnderlying(address token, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.u[token].balanceOfUnderlying = s.u[token].balanceOfUnderlying.add(amount);\n        emit ChangeUnderlying(token, int256(amount));\n    }\n\n    /**\n     * @notice Decrements the underlying balance of an Unripe Token.\n     * @param token The address of the Unripe Token.\n     * @param amount The amount of the of the Unripe Token to be removed from storage reserves\n     */\n    function decrementUnderlying(address token, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.u[token].balanceOfUnderlying = s.u[token].balanceOfUnderlying.sub(amount);\n        emit ChangeUnderlying(token, -int256(amount));\n    }\n\n    /**\n     * @notice Calculates the amount of Ripe Tokens that underly a given amount of Unripe Tokens.\n     * @param unripeToken The address of the Unripe Token\n     * @param unripe The amount of Unripe Tokens.\n     * @return underlying The amount of Ripe Tokens that underly the Unripe Tokens.\n     */\n    function unripeToUnderlying(\n        address unripeToken,\n        uint256 unripe,\n        uint256 supply\n    ) internal view returns (uint256 underlying) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        underlying = s.u[unripeToken].balanceOfUnderlying.mul(unripe).div(supply);\n    }\n\n    /**\n     * @notice Calculates the amount of Unripe Tokens that are underlaid by a given amount of Ripe Tokens.\n     * @param unripeToken The address of the Unripe Tokens.\n     * @param underlying The amount of Ripe Tokens.\n     * @return unripe The amount of the of the Unripe Tokens that are underlaid by the Ripe Tokens.\n     */\n    function underlyingToUnripe(\n        address unripeToken,\n        uint256 underlying\n    ) internal view returns (uint256 unripe) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        unripe = IBean(unripeToken).totalSupply().mul(underlying).div(\n            s.u[unripeToken].balanceOfUnderlying\n        );\n    }\n\n    /**\n     * @notice Adds Ripe Tokens to an Unripe Token. Also, increments the recapitalized\n     * amount proportionally if the Unripe Token is Unripe LP.\n     * @param token The address of the Unripe Token to add Ripe Tokens to.\n     * @param underlying The amount of the of the underlying token to be taken as input.\n     */\n    function addUnderlying(address token, uint256 underlying) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        if (token == C.UNRIPE_LP) {\n            uint256 recapped = underlying.mul(s.recapitalized).div(\n                s.u[C.UNRIPE_LP].balanceOfUnderlying\n            );\n            s.recapitalized = s.recapitalized.add(recapped);\n        }\n        incrementUnderlying(token, underlying);\n    }\n\n    /**\n     * @notice Removes Ripe Tokens from an Unripe Token. Also, decrements the recapitalized\n     * amount proportionally if the Unripe Token is Unripe LP.\n     * @param token The address of the unripe token to be removed.\n     * @param underlying The amount of the of the underlying token to be removed.\n     */\n    function removeUnderlying(address token, uint256 underlying) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        if (token == C.UNRIPE_LP) {\n            uint256 recapped = underlying.mul(s.recapitalized).div(\n                s.u[C.UNRIPE_LP].balanceOfUnderlying\n            );\n            s.recapitalized = s.recapitalized.sub(recapped);\n        }\n        decrementUnderlying(token, underlying);\n    }\n\n    /**\n     * @dev Switches the underlying token of an unripe token.\n     * Should only be called if `s.u[unripeToken].balanceOfUnderlying == 0`.\n     */\n    function switchUnderlyingToken(address unripeToken, address newUnderlyingToken) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.u[unripeToken].underlyingToken = newUnderlyingToken;\n        emit SwitchUnderlyingToken(unripeToken, newUnderlyingToken);\n    }\n\n    function _getPenalizedUnderlying(\n        address unripeToken,\n        uint256 amount,\n        uint256 supply\n    ) internal view returns (uint256 redeem) {\n        require(isUnripe(unripeToken), \"not vesting\");\n        uint256 sharesBeingRedeemed = getRecapPaidPercentAmount(amount);\n        redeem = _getUnderlying(unripeToken, sharesBeingRedeemed, supply);\n    }\n\n    /**\n     * @notice Calculates the the amount of Ripe Tokens that would be paid out if\n     * all Unripe Tokens were Chopped at the current Chop Rate.\n     */\n    function _getTotalPenalizedUnderlying(\n        address unripeToken\n    ) internal view returns (uint256 redeem) {\n        require(isUnripe(unripeToken), \"not vesting\");\n        uint256 supply = IERC20(unripeToken).totalSupply();\n        redeem = _getUnderlying(unripeToken, getRecapPaidPercentAmount(supply), supply);\n    }\n\n    /**\n     * @notice Returns the amount of beans that are locked in the unripe token.\n     * @dev Locked beans are the beans that are forfeited if the unripe token is chopped.\n     * @param reserves the reserves of the LP that underly the unripe token.\n     * @dev reserves are used as a parameter for gas effiency purposes (see LibEvaluate.calcLPToSupplyRatio}.\n     */\n    function getLockedBeans(\n        uint256[] memory reserves\n    ) internal view returns (uint256 lockedAmount) {\n        lockedAmount = LibLockedUnderlying\n            .getLockedUnderlying(C.UNRIPE_BEAN, getRecapPaidPercentAmount(1e6))\n            .add(getLockedBeansFromLP(reserves));\n    }\n\n    /**\n     * @notice Returns the amount of beans that are locked in the unripeLP token.\n     * @param reserves the reserves of the LP that underly the unripe token.\n     */\n    function getLockedBeansFromLP(\n        uint256[] memory reserves\n    ) internal view returns (uint256 lockedBeanAmount) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 lockedLpAmount = LibLockedUnderlying.getLockedUnderlying(\n            C.UNRIPE_LP,\n            getRecapPaidPercentAmount(1e6)\n        );\n        address underlying = s.u[C.UNRIPE_LP].underlyingToken;\n        uint256 beanIndex = LibWell.getBeanIndexFromWell(underlying);\n\n        // lpTokenSupply is calculated rather than calling totalSupply(),\n        // because the Well's lpTokenSupply is not MEV resistant.\n        Call memory wellFunction = IWell(underlying).wellFunction();\n        uint lpTokenSupply = IWellFunction(wellFunction.target).calcLpTokenSupply(\n            reserves,\n            wellFunction.data\n        );\n        lockedBeanAmount = lockedLpAmount.mul(reserves[beanIndex]).div(lpTokenSupply);\n    }\n\n    /**\n     * @notice Calculates the penalized amount based the amount of Sprouts that are Rinsable\n     * or Rinsed (Fertilized).\n     * @param amount The amount of the Unripe Tokens.\n     * @return penalizedAmount The penalized amount of the Ripe Tokens received from Chopping.\n     */\n    function getRecapPaidPercentAmount(\n        uint256 amount\n    ) internal view returns (uint256 penalizedAmount) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.fertilizedIndex.mul(amount).div(s.unfertilizedIndex);\n    }\n\n    /**\n     * @notice Returns true if the token is unripe.\n     */\n    function isUnripe(address unripeToken) internal view returns (bool unripe) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        unripe = s.u[unripeToken].underlyingToken != address(0);\n    }\n\n    /**\n     * @notice Returns the underlying token amount of the unripe token.\n     */\n    function _getUnderlying(\n        address unripeToken,\n        uint256 amount,\n        uint256 supply\n    ) internal view returns (uint256 redeem) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        redeem = s.u[unripeToken].balanceOfUnderlying.mul(amount).div(supply);\n    }\n}"
    }
  ]
}