{
  "Title": "Incorrect Execution Fee Refund address on Failed Deposits or withdrawals in Strategy Vaults",
  "Content": "# Incorrect Execution Fee Refund address on Failed Deposits or withdrawals in Strategy Vaults\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXVault.sol#L301\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXVault.sol#L301</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L68\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L68</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXCallback.sol#L57\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXCallback.sol#L57</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L161\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L161</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L228\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L228</a>\n\n\n## Summary\n\nThe Strategy Vaults within the protocol use a two-step process for handling deposits/withdrawals via GMXv2. A **`createDeposit()`** transaction is followed by a callback function (**`afterDepositExecution()`** or **`afterDepositCancellation()`**) based on the transaction's success. In the event of a failed deposit due to vault health checks, the execution fee refund is mistakenly sent to the depositor instead of the keeper who triggers the deposit failure process.\n\n## Vulnerability Details\n\nThe protocol handles the deposit through the **`deposit`** function, which uses several parameters including an execution fee that refunds any excess fees. \n\n```solidity\nfunction deposit(GMXTypes.DepositParams memory dp) external payable nonReentrant {\n        GMXDeposit.deposit(_store, dp, false);\n    }\n\nstruct DepositParams {\n    // Address of token depositing; can be tokenA, tokenB or lpToken\n    address token;\n    // Amount of token to deposit in token decimals\n    uint256 amt;\n    // Minimum amount of shares to receive in 1e18\n    uint256 minSharesAmt;\n    // Slippage tolerance for adding liquidity; e.g. 3 = 0.03%\n    uint256 slippage;\n    // Execution fee sent to GMX for adding liquidity\n    uint256 executionFee;\n  }\n```\n\nThe refund is intended for the message sender (**`msg.sender`**), which in the initial deposit case, is the depositor. This is established in the **`GMXDeposit.deposit`** function, where **`self.refundee`** is assigned to **`msg.sender`**.\n\n```solidity\nfunction deposit(GMXTypes.Store storage self, GMXTypes.DepositParams memory dp, bool isNative) external {\n        // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n        // it from being considered as part of depositor's assets\n        if (self.tokenA.balanceOf(address(this)) > 0) {\n            self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n        }\n        if (self.tokenB.balanceOf(address(this)) > 0) {\n            self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n        }\n\n        self.refundee = payable(msg.sender);\n\n\t\t...\n\n\t\t_dc.depositKey = GMXManager.addLiquidity(self, _alp);\n\n        self.depositCache = _dc;\n\n        emit DepositCreated(_dc.user, _dc.depositParams.token, _dc.depositParams.amt);\n    }\n```\n\nIf the deposit passes the GMX checks, the **`afterDepositExecution`** callback is triggered, leading to **`vault.processDeposit()`** to check the vault's health. A failure here updates the status to **`GMXTypes.Status.Deposit_Failed`**. The reversal process is then handled by the **`processDepositFailure`** function, which can only be called by keepers. They pay for the transaction's gas costs, including the execution fee.\n\n```solidity\nfunction processDepositFailure(uint256 slippage, uint256 executionFee) external payable onlyKeeper {\n        GMXDeposit.processDepositFailure(_store, slippage, executionFee);\n    }\n```\n\nIn **`GMXDeposit.processDepositFailure`**, **`self.refundee`** is not updated, resulting in any excess execution fees being incorrectly sent to the initial depositor, although the keeper paid for it.\n\n```solidity\nfunction processDepositFailure(GMXTypes.Store storage self, uint256 slippage, uint256 executionFee) external {\n        GMXChecks.beforeProcessAfterDepositFailureChecks(self);\n\n        GMXTypes.RemoveLiquidityParams memory _rlp;\n\n        // If current LP amount is somehow less or equal to amount before, we do not remove any liquidity\n        if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore) {\n            processDepositFailureLiquidityWithdrawal(self);\n        } else {\n            // Remove only the newly added LP amount\n            _rlp.lpAmt = GMXReader.lpAmt(self) - self.depositCache.healthParams.lpAmtBefore;\n\n            // If delta strategy is Long, remove all in tokenB to make it more\n            // efficent to repay tokenB debt as Long strategy only borrows tokenB\n            if (self.delta == GMXTypes.Delta.Long) {\n                address[] memory _tokenASwapPath = new address[](1);\n                _tokenASwapPath[0] = address(self.lpToken);\n                _rlp.tokenASwapPath = _tokenASwapPath;\n\n                (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n                    self, _rlp.lpAmt, address(self.tokenB), address(self.tokenB), slippage\n                );\n            } else {\n                (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n                    self, _rlp.lpAmt, address(self.tokenA), address(self.tokenB), slippage\n                );\n            }\n\n            _rlp.executionFee = executionFee;\n\n            // Remove liqudity\n            self.depositCache.withdrawKey = GMXManager.removeLiquidity(self, _rlp);\n        }\n```\n\nThe same issue occurs in the **`processWithdrawFailure`** function where the excess fees will be sent to the initial user who called withdraw instead of the keeper.\n\n## Impact\n\nThis flaw causes a loss of funds for the keepers, negatively impacting the vaults. Users also inadvertently receive extra fees that are rightfully owed to the keepers\n\n## Tools Used\n\nmanual analysis\n\n## Recommendations\n\nThe **`processDepositFailure`**  and **`processWithdrawFailure`** functions must be modified to update **`self.refundee`** to the current executor of the function, which, in the case of deposit or withdraw failure, is the keeper.\n\n```solidity\nfunction processDepositFailure(GMXTypes.Store storage self, uint256 slippage, uint256 executionFee) external {\n        GMXChecks.beforeProcessAfterDepositFailureChecks(self);\n\n        GMXTypes.RemoveLiquidityParams memory _rlp;\n\n\t\tself.refundee = payable(msg.sender);\n\n\t\t...\n        }\n```\n\n```solidity\nfunction processWithdrawFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureChecks(self);\n\n\tself.refundee = payable(msg.sender);\n\n\t...\n  }\n```\n",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { IWNT } from  \"../../interfaces/tokens/IWNT.sol\";\nimport { IGMXVault } from  \"../../interfaces/strategy/gmx/IGMXVault.sol\";\nimport { IGMXVaultEvents } from  \"../../interfaces/strategy/gmx/IGMXVaultEvents.sol\";\nimport { ILendingVault } from  \"../../interfaces/lending/ILendingVault.sol\";\nimport { IChainlinkOracle } from  \"../../interfaces/oracles/IChainlinkOracle.sol\";\nimport { IGMXOracle } from  \"../../interfaces/oracles/IGMXOracle.sol\";\nimport { IExchangeRouter } from \"../../interfaces/protocols/gmx/IExchangeRouter.sol\";\nimport { ISwap } from \"../../interfaces/swap/ISwap.sol\";\nimport { Errors } from  \"../../utils/Errors.sol\";\nimport { GMXTypes } from  \"./GMXTypes.sol\";\nimport { GMXDeposit } from  \"./GMXDeposit.sol\";\nimport { GMXWithdraw } from  \"./GMXWithdraw.sol\";\nimport { GMXRebalance } from  \"./GMXRebalance.sol\";\nimport { GMXCompound } from  \"./GMXCompound.sol\";\nimport { GMXEmergency } from  \"./GMXEmergency.sol\";\nimport { GMXReader } from  \"./GMXReader.sol\";\n\n/**\n  * @title GMXVault\n  * @author Steadefi\n  * @notice Main point of interaction with a Steadefi leveraged strategy vault\n*/\ncontract GMXVault is ERC20, Ownable2Step, ReentrancyGuard, IGMXVault, IGMXVaultEvents {\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // GMXTypes.Store\n  GMXTypes.Store internal _store;\n\n  /* ======================= MAPPINGS ======================== */\n\n  // Approved keepers\n  mapping(address => bool) public keepers;\n  // Approved tokens for deposit and withdraw\n  mapping(address => bool) public tokens;\n\n  /* ======================= MODIFIERS ======================= */\n\n  // Allow only vault modifier\n  modifier onlyVault() {\n    _onlyVault();\n    _;\n  }\n\n  // Allow only keeper modifier\n  modifier onlyKeeper() {\n    _onlyKeeper();\n    _;\n  }\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @notice Initialize and configure vault's store, token approvals and whitelists\n    * @param name Name of vault\n    * @param symbol Symbol for vault token\n    * @param store_ GMXTypes.Store\n  */\n  constructor (\n    string memory name,\n    string memory symbol,\n    GMXTypes.Store memory store_\n  ) ERC20(name, symbol) Ownable(msg.sender) {\n    _store.leverage = uint256(store_.leverage);\n    _store.delta = store_.delta;\n    _store.feePerSecond = uint256(store_.feePerSecond);\n    _store.treasury = address(store_.treasury);\n\n    _store.debtRatioStepThreshold = uint256(store_.debtRatioStepThreshold);\n    _store.debtRatioUpperLimit = uint256(store_.debtRatioUpperLimit);\n    _store.debtRatioLowerLimit = uint256(store_.debtRatioLowerLimit);\n    _store.deltaUpperLimit = int256(store_.deltaUpperLimit);\n    _store.deltaLowerLimit = int256(store_.deltaLowerLimit);\n    _store.minSlippage = store_.minSlippage;\n    _store.minExecutionFee = store_.minExecutionFee;\n\n    _store.tokenA = IERC20(store_.tokenA);\n    _store.tokenB = IERC20(store_.tokenB);\n    _store.lpToken = IERC20(store_.lpToken);\n    _store.WNT = IWNT(store_.WNT);\n\n    _store.tokenALendingVault = ILendingVault(store_.tokenALendingVault);\n    _store.tokenBLendingVault = ILendingVault(store_.tokenBLendingVault);\n\n    _store.vault = IGMXVault(address(this));\n    _store.trove = store_.trove;\n    _store.callback = store_.callback;\n\n    _store.chainlinkOracle = IChainlinkOracle(store_.chainlinkOracle);\n    _store.gmxOracle = IGMXOracle(store_.gmxOracle);\n\n    _store.exchangeRouter = IExchangeRouter(store_.exchangeRouter);\n    _store.router = store_.router;\n    _store.depositVault = store_.depositVault;\n    _store.withdrawalVault = store_.withdrawalVault;\n    _store.roleStore = store_.roleStore;\n\n    _store.swapRouter = ISwap(store_.swapRouter);\n\n    _store.status = GMXTypes.Status.Open;\n\n    _store.lastFeeCollected = block.timestamp;\n\n    // Set token whitelist for this vault\n    tokens[address(_store.tokenA)] = true;\n    tokens[address(_store.tokenB)] = true;\n    tokens[address(_store.lpToken)] = true;\n\n    // Set token approvals for this vault\n    _store.tokenA.approve(address(_store.router), type(uint256).max);\n    _store.tokenB.approve(address(_store.router), type(uint256).max);\n    _store.lpToken.approve(address(_store.router), type(uint256).max);\n\n    _store.tokenA.approve(address(_store.depositVault), type(uint256).max);\n    _store.tokenB.approve(address(_store.depositVault), type(uint256).max);\n\n    _store.lpToken.approve(address(_store.withdrawalVault), type(uint256).max);\n\n    _store.tokenA.approve(address(_store.tokenALendingVault), type(uint256).max);\n    _store.tokenB.approve(address(_store.tokenBLendingVault), type(uint256).max);\n\n    // Set callback contract as keeper\n    keepers[_store.callback] = true;\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice View vault store data\n    * @return GMXTypes.Store\n  */\n  function store() public view returns (GMXTypes.Store memory) {\n    return _store;\n  }\n\n  /**\n    * @notice Check if token is whitelisted for deposit/withdraw for this vault\n    * @param token Address of token to check\n    * @return Boolean of whether token is whitelisted\n  */\n  function isTokenWhitelisted(address token) public view returns (bool) {\n    return tokens[token];\n  }\n\n  /**\n    * @notice Returns the value of each strategy vault share token; equityValue / totalSupply()\n    * @return svTokenValue  USD value of each share token in 1e18\n  */\n  function svTokenValue() public view returns (uint256) {\n    return GMXReader.svTokenValue(_store);\n  }\n\n  /**\n    * @notice Amount of share pending for minting as a form of management fee\n    * @return pendingFee in 1e18\n  */\n  function pendingFee() public view returns (uint256) {\n    return GMXReader.pendingFee(_store);\n  }\n\n  /**\n    * @notice Conversion of equity value to svToken shares\n    * @param value Equity value change after deposit in 1e18\n    * @param currentEquity Current equity value of vault in 1e18\n    * @return sharesAmt in 1e18\n  */\n  function valueToShares(uint256 value, uint256 currentEquity) public view returns (uint256) {\n    return GMXReader.valueToShares(_store, value, currentEquity);\n  }\n\n  /**\n    * @notice Convert token amount to USD value using price from oracle\n    * @param token Token address\n    * @param amt Amount in token decimals\n    @ @return tokenValue USD value in 1e18\n  */\n  function convertToUsdValue(address token, uint256 amt) public view returns (uint256) {\n    return GMXReader.convertToUsdValue(_store, token, amt);\n  }\n\n  /**\n    * @notice Return token weights (%) in LP\n    @ @return tokenAWeight in 1e18; e.g. 50% = 5e17\n    @ @return tokenBWeight in 1e18; e.g. 50% = 5e17\n  */\n  function tokenWeights() public view returns (uint256, uint256) {\n    return GMXReader.tokenWeights(_store);\n  }\n\n  /**\n    * @notice Returns the total USD value of tokenA & tokenB assets held by the vault\n    * @notice Asset = Debt + Equity\n    * @return assetValue USD value of total assets in 1e18\n  */\n  function assetValue() public view returns (uint256) {\n    return GMXReader.assetValue(_store);\n  }\n\n  /**\n    * @notice Returns the USD value of tokenA & tokenB debt held by the vault\n    * @notice Asset = Debt + Equity\n    * @return tokenADebtValue USD value of tokenA debt in 1e18\n    * @return tokenBDebtValue USD value of tokenB debt in 1e18\n  */\n  function debtValue() public view returns (uint256, uint256) {\n    return GMXReader.debtValue(_store);\n  }\n\n  /**\n    * @notice Returns the USD value of tokenA & tokenB equity held by the vault;\n    * @notice Asset = Debt + Equity\n    * @return equityValue USD value of total equity in 1e18\n  */\n  function equityValue() public view returns (uint256) {\n    return GMXReader.equityValue(_store);\n  }\n\n  /**\n    * @notice Returns the amt of tokenA & tokenB assets held by vault\n    * @return tokenAAssetAmt in tokenA decimals\n    * @return tokenBAssetAmt in tokenB decimals\n  */\n  function assetAmt() public view returns (uint256, uint256) {\n    return GMXReader.assetAmt(_store);\n  }\n\n  /**\n    * @notice Returns the amt of tokenA & tokenB debt held by vault\n    * @return tokenADebtAmt in tokenA decimals\n    * @return tokenBDebtAmt in tokenB decimals\n  */\n  function debtAmt() public view returns (uint256, uint256) {\n    return GMXReader.debtAmt(_store);\n  }\n\n  /**\n    * @notice Returns the amt of LP tokens held by vault\n    * @return lpAmt in 1e18\n  */\n  function lpAmt() public view returns (uint256) {\n    return GMXReader.lpAmt(_store);\n  }\n\n  /**\n    * @notice Returns the current leverage (asset / equity)\n    * @return leverage Current leverage in 1e18\n  */\n  function leverage() public view returns (uint256) {\n    return GMXReader.leverage(_store);\n  }\n\n  /**\n    * @notice Returns the current delta (tokenA equityValue / vault equityValue)\n    * @notice Delta refers to the position exposure of this vault's strategy to the\n    * underlying volatile asset. Delta can be a negative value\n    * @return delta in 1e18 (0 = Neutral, > 0 = Long, < 0 = Short)\n  */\n  function delta() public view returns (int256) {\n    return GMXReader.delta(_store);\n  }\n\n  /**\n    * @notice Returns the debt ratio (tokenA and tokenB debtValue) / (total assetValue)\n    * @notice When assetValue is 0, we assume the debt ratio to also be 0\n    * @return debtRatio % in 1e18\n  */\n  function debtRatio() public view returns (uint256) {\n    return GMXReader.debtRatio(_store);\n  }\n\n  /**\n    * @notice Additional capacity vault that can be deposited to vault based on available lending liquidity\n    @ @return additionalCapacity USD value in 1e18\n  */\n  function additionalCapacity() public view returns (uint256) {\n    return GMXReader.additionalCapacity(_store);\n  }\n\n  /**\n    * @notice Total capacity of vault; additionalCapacity + equityValue\n    @ @return capacity USD value in 1e18\n  */\n  function capacity() public view returns (uint256) {\n    return GMXReader.capacity(_store);\n  }\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice Deposit a whitelisted asset into vault and mint strategy vault share tokens to user\n    * @param dp GMXTypes.DepositParams\n  */\n  function deposit(GMXTypes.DepositParams memory dp) external payable nonReentrant {\n    GMXDeposit.deposit(_store, dp, false);\n  }\n\n  /**\n    * @notice Deposit native asset (e.g. ETH) into vault and mint strategy vault share tokens to user\n    * @notice This function is only function if vault accepts native token\n    * @param dp GMXTypes.DepositParams\n  */\n  function depositNative(GMXTypes.DepositParams memory dp) external payable nonReentrant {\n    GMXDeposit.deposit(_store, dp, true);\n  }\n\n  /**\n    * @notice Withdraws a whitelisted asset from vault and burns strategy vault share tokens from user\n    * @param wp GMXTypes.WithdrawParams\n  */\n  function withdraw(GMXTypes.WithdrawParams memory wp) external payable nonReentrant {\n    GMXWithdraw.withdraw(_store, wp);\n  }\n\n  /**\n    * @notice Emergency withdraw function, enabled only when vault status is Closed, burns\n    svToken from user while withdrawing assets from vault to user\n    * @param shareAmt Amount of vault token shares to withdraw in 1e18\n  */\n  function emergencyWithdraw(uint256 shareAmt) external nonReentrant {\n    GMXEmergency.emergencyWithdraw(_store, shareAmt);\n  }\n\n  /**\n    * @notice Mint vault token shares as management fees to protocol treasury\n  */\n  function mintFee() public {\n    _mint(_store.treasury, GMXReader.pendingFee(_store));\n    _store.lastFeeCollected = block.timestamp;\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Allow only vault\n  */\n  function _onlyVault() internal view {\n    if (msg.sender != address(_store.vault)) revert Errors.OnlyVaultAllowed();\n  }\n\n  /**\n    * @notice Allow only keeper\n  */\n  function _onlyKeeper() internal view {\n    if (!keepers[msg.sender]) revert Errors.OnlyKeeperAllowed();\n  }\n\n  /* ================= RESTRICTED FUNCTIONS ================== */\n\n  /**\n    * @notice Post deposit operations if adding liquidity is successful to GMX\n    * @dev Should be called only after deposit() / depositNative() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processDeposit() external onlyKeeper {\n    GMXDeposit.processDeposit(_store);\n  }\n\n  /**\n    * @notice Post deposit operations if adding liquidity has been cancelled by GMX\n    * @dev To be called only after deposit()/depositNative() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processDepositCancellation() external onlyKeeper {\n    GMXDeposit.processDepositCancellation(_store);\n  }\n\n  /**\n    * @notice Post deposit operations if after deposit checks failed by GMXChecks.afterDepositChecks()\n    * @dev Should be called by approved Keeper after error event is picked up\n    * @param slippage Slippage for liquidity removal\n    * @param executionFee Execution fee passed in to remove liquidity\n  */\n  function processDepositFailure(\n    uint256 slippage,\n    uint256 executionFee\n  ) external payable onlyKeeper {\n    GMXDeposit.processDepositFailure(_store, slippage, executionFee);\n  }\n\n  /**\n    * @notice Post deposit failure operations\n    * @dev To be called after processDepositFailure()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processDepositFailureLiquidityWithdrawal() external onlyKeeper {\n    GMXDeposit.processDepositFailureLiquidityWithdrawal(_store);\n  }\n\n  /**\n    * @notice Post withdraw operations if removing liquidity is successful from GMX\n    * @dev Should be called only after withdraw() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processWithdraw() external onlyKeeper {\n    GMXWithdraw.processWithdraw(_store);\n  }\n\n  /**\n    * @notice Post withdraw operations if removing liquidity has been cancelled by GMX\n    * @dev To be called only after withdraw() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processWithdrawCancellation() external onlyKeeper {\n    GMXWithdraw.processWithdrawCancellation(_store);\n  }\n\n  /**\n    * @notice Post withdraw operations if after withdraw checks failed by GMXChecks.afterWithdrawChecks()\n    * @dev Should be called by approved Keeper after error event is picked up\n    * @param slippage Slippage for liquidity removal\n    * @param executionFee Execution fee passed in to remove liquidity\n  */\n  function processWithdrawFailure(\n    uint256 slippage,\n    uint256 executionFee\n  ) external payable onlyKeeper {\n    GMXWithdraw.processWithdrawFailure(_store, slippage, executionFee);\n  }\n\n  /**\n    * @notice Post withdraw failure operations\n    * @dev To be called after processWithdrawFailure()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processWithdrawFailureLiquidityAdded() external onlyKeeper {\n    GMXWithdraw.processWithdrawFailureLiquidityAdded(_store);\n  }\n\n  /**\n    * @notice Rebalance vault's delta and/or debt ratio by adding liquidity\n    * @dev Should be called by approved Keeper\n    * @param rap GMXTypes.RebalanceAddParams\n  */\n  function rebalanceAdd(\n    GMXTypes.RebalanceAddParams memory rap\n  ) external payable nonReentrant onlyKeeper {\n    GMXRebalance.rebalanceAdd(_store, rap);\n  }\n\n  /**\n    * @notice Post rebalance add operations if adding liquidity is successful to GMX\n    * @dev To be called after rebalanceAdd()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processRebalanceAdd() external nonReentrant onlyKeeper {\n    GMXRebalance.processRebalanceAdd(_store);\n  }\n\n  /**\n    * @notice Post rebalance add operations if adding liquidity has been cancelled by GMX\n    * @dev To be called only after rebalanceAdd() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processRebalanceAddCancellation() external nonReentrant onlyKeeper {\n    GMXRebalance.processRebalanceAddCancellation(_store);\n  }\n\n  /**\n    * @notice Rebalance vault's delta and/or debt ratio by removing liquidity\n    * @dev Should be called by approved Keeper\n    * @param rrp GMXTypes.RebalanceRemoveParams\n  */\n  function rebalanceRemove(\n    GMXTypes.RebalanceRemoveParams memory rrp\n  ) external payable nonReentrant onlyKeeper {\n    GMXRebalance.rebalanceRemove(_store, rrp);\n  }\n\n  /**\n    * @notice Post rebalance remove operations if removing liquidity is successful to GMX\n    * @dev To be called after rebalanceRemove()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processRebalanceRemove() external onlyKeeper {\n    GMXRebalance.processRebalanceRemove(_store);\n  }\n\n  /**\n    * @notice Post rebalance remove operations if removing liquidity has been cancelled by GMX\n    * @dev To be called only after rebalanceRemove() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processRebalanceRemoveCancellation() external nonReentrant onlyKeeper {\n    GMXRebalance.processRebalanceRemoveCancellation(_store);\n  }\n\n  /**\n    * @notice Compounds ERC20 token rewards and convert to more LP\n    * @dev Assumes that reward tokens are already in vault\n    * @dev Should be called by approved Keeper\n    * @param cp GMXTypes.CompoundParams\n  */\n  function compound(GMXTypes.CompoundParams memory cp) external payable onlyKeeper {\n    GMXCompound.compound(_store, cp);\n  }\n\n  /**\n    * @notice Post compound operations if adding liquidity is successful to GMX\n    * @dev To be called after processCompound()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processCompound() external onlyKeeper {\n    GMXCompound.processCompound(_store);\n  }\n\n  /**\n    * @notice Post compound operations if adding liquidity has been cancelled by GMX\n    * @dev To be called after processCompound()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processCompoundCancellation() external onlyKeeper {\n    GMXCompound.processCompoundCancellation(_store);\n  }\n\n  /**\n    * @notice Withdraws LP for all underlying assets to vault and set vault status to Paused\n    * @dev To be called only in an emergency situation. Can be called in ANY vault status\n    * @dev Should be called by approved Keeper\n  */\n  function emergencyPause() external payable onlyKeeper {\n    GMXEmergency.emergencyPause(_store);\n  }\n\n  /**\n    * @notice Re-add all assets for liquidity for LP in anticipation of vault resuming\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n  */\n  function emergencyResume() external payable onlyOwner {\n    GMXEmergency.emergencyResume(_store);\n  }\n\n  /**\n    * @notice Post emergency resume operations if re-adding liquidity is successful\n    * @dev To be called after emergencyResume()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processEmergencyResume() external payable onlyKeeper {\n    GMXEmergency.processEmergencyResume(_store);\n  }\n\n  /**\n    * @notice Repays all debt owed by vault and shut down vault, allowing emergency withdrawals\n    * @dev Note that this is a one-way irreversible action\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param deadline Timestamp of swap deadline\n  */\n  function emergencyClose(uint256 deadline) external onlyOwner {\n    GMXEmergency.emergencyClose(_store, deadline);\n  }\n\n  /**\n    * @notice Approve or revoke address to be a keeper for this vault\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param keeper Keeper address\n    * @param approval Boolean to approve keeper or not\n  */\n  function updateKeeper(address keeper, bool approval) external onlyOwner {\n    keepers[keeper] = approval;\n    emit KeeperUpdated(keeper, approval);\n  }\n\n  /**\n    * @notice Update treasury address\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param treasury Treasury address\n  */\n  function updateTreasury(address treasury) external onlyOwner {\n    _store.treasury = treasury;\n    emit TreasuryUpdated(treasury);\n  }\n\n  /**\n    * @notice Update swap router address\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param swapRouter Swap router address\n  */\n  function updateSwapRouter(address swapRouter) external onlyOwner {\n    _store.swapRouter = ISwap(swapRouter);\n    emit SwapRouterUpdated(swapRouter);\n  }\n\n  /**\n    * @notice Update trove address\n    * @dev Should only be called once on vault initialization\n    * @param trove Trove address\n  */\n  function updateTrove(address trove) external onlyOwner {\n    _store.trove = trove;\n    emit TroveUpdated(trove);\n  }\n\n  /**\n    * @notice Update callback address\n    * @dev Should only be called once on vault initialization\n    * @param callback Callback address\n  */\n  function updateCallback(address callback) external onlyOwner {\n    _store.callback = callback;\n    emit CallbackUpdated(callback);\n  }\n\n  /**\n    * @notice Update management fee per second\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param feePerSecond fee per second in 1e18\n  */\n  function updateFeePerSecond(uint256 feePerSecond) external onlyOwner {\n    _store.feePerSecond = feePerSecond;\n    emit FeePerSecondUpdated(feePerSecond);\n  }\n\n  /**\n    * @notice Update strategy parameter limits and guard checks\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param debtRatioStepThreshold threshold change for debt ratio allowed in 1e4\n    * @param debtRatioUpperLimit upper limit of debt ratio in 1e18\n    * @param debtRatioLowerLimit lower limit of debt ratio in 1e18\n    * @param deltaUpperLimit upper limit of delta in 1e18\n    * @param deltaLowerLimit lower limit of delta in 1e18\n  */\n  function updateParameterLimits(\n    uint256 debtRatioStepThreshold,\n    uint256 debtRatioUpperLimit,\n    uint256 debtRatioLowerLimit,\n    int256 deltaUpperLimit,\n    int256 deltaLowerLimit\n  ) external onlyOwner {\n    _store.debtRatioStepThreshold = debtRatioStepThreshold;\n    _store.debtRatioUpperLimit = debtRatioUpperLimit;\n    _store.debtRatioLowerLimit = debtRatioLowerLimit;\n    _store.deltaUpperLimit = deltaUpperLimit;\n    _store.deltaLowerLimit = deltaLowerLimit;\n\n    emit ParameterLimitsUpdated(\n      debtRatioStepThreshold,\n      debtRatioUpperLimit,\n      debtRatioLowerLimit,\n      deltaUpperLimit,\n      deltaLowerLimit\n    );\n  }\n\n  /**\n    * @notice Update minimum slippage\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param minSlippage minimum slippage value in 1e4\n  */\n  function updateMinSlippage(uint256 minSlippage) external onlyOwner {\n    _store.minSlippage = minSlippage;\n    emit MinSlippageUpdated(minSlippage);\n  }\n\n  /**\n    * @notice Update minimum execution fee for GMX\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param minExecutionFee minimum execution fee value in 1e18\n  */\n  function updateMinExecutionFee(uint256 minExecutionFee) external onlyOwner {\n    _store.minExecutionFee = minExecutionFee;\n    emit MinExecutionFeeUpdated(minExecutionFee);\n  }\n\n  /**\n    * @notice Mints vault token shares to user\n    * @dev Should only be called by vault\n    * @param to Receiver of the minted vault tokens\n    * @param amt Amount of minted vault tokens\n  */\n  function mint(address to, uint256 amt) external onlyVault {\n    _mint(to, amt);\n  }\n\n  /**\n    * @notice Burns vault token shares from user\n    * @dev Should only be called by vault\n    * @param to Address's vault tokens to burn\n    * @param amt Amount of vault tokens to burn\n  */\n  function burn(address to, uint256 amt) external onlyVault {\n    _burn(to, amt);\n  }\n\n  /* ================== FALLBACK FUNCTIONS =================== */\n\n  /**\n    * @notice Fallback function to receive native token sent to this contract\n    * @dev To refund refundee any ETH received from GMX for unused execution fees\n  */\n  receive() external payable {\n    if (msg.sender == _store.depositVault || msg.sender == _store.withdrawalVault) {\n      (bool success, ) = _store.refundee.call{value: address(this).balance}(\"\");\n      require(success, \"Transfer failed.\");\n    }\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXDeposit.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessDeposit } from \"./GMXProcessDeposit.sol\";\n\n/**\n  * @title GMXDeposit\n  * @author Steadefi\n  * @notice Re-usable library functions for deposit operations for Steadefi leveraged vaults\n*/\nlibrary GMXDeposit {\n  using SafeERC20 for IERC20;\n\n  /* ======================= CONSTANTS ======================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event DepositCreated(\n    address indexed user,\n    address asset,\n    uint256 assetAmt\n  );\n  event DepositCompleted(\n    address indexed user,\n    uint256 shareAmt,\n    uint256 equityBefore,\n    uint256 equityAfter\n  );\n  event DepositCancelled(\n    address indexed user\n  );\n  event DepositFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n    * @param isNative Boolean as to whether user is depositing native asset (e.g. ETH, AVAX, etc.)\n  */\n  function deposit(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp,\n    bool isNative\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of depositor's assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    // Transfer assets from user to vault\n    if (isNative) {\n      GMXChecks.beforeNativeDepositChecks(self, dp);\n\n      self.WNT.deposit{ value: dp.amt }();\n    } else {\n      IERC20(dp.token).safeTransferFrom(msg.sender, address(this), dp.amt);\n    }\n\n    GMXTypes.DepositCache memory _dc;\n\n    _dc.user = payable(msg.sender);\n\n    if (dp.token == address(self.lpToken)) {\n      // If LP token deposited\n      _dc.depositValue = self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      * dp.amt\n      / SAFE_MULTIPLIER;\n    } else {\n      // If tokenA or tokenB deposited\n      _dc.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(dp.token),\n        dp.amt\n      );\n    }\n    _dc.depositParams = dp;\n    _dc.healthParams = _hp;\n\n    self.depositCache = _dc;\n\n    GMXChecks.beforeDepositChecks(self, _dc.depositValue);\n\n    self.status = GMXTypes.Status.Deposit;\n\n    self.vault.mintFee();\n\n    // Borrow assets and create deposit in GMX\n    (\n      uint256 _borrowTokenAAmt,\n      uint256 _borrowTokenBAmt\n    ) = GMXManager.calcBorrow(self, _dc.depositValue);\n\n    _dc.borrowParams.borrowTokenAAmt = _borrowTokenAAmt;\n    _dc.borrowParams.borrowTokenBAmt = _borrowTokenBAmt;\n\n    GMXManager.borrow(self, _borrowTokenAAmt, _borrowTokenBAmt);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _dc.depositValue,\n      dp.slippage\n    );\n    _alp.executionFee = dp.executionFee;\n\n    _dc.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n\n    self.depositCache = _dc;\n\n    emit DepositCreated(\n      _dc.user,\n      _dc.depositParams.token,\n      _dc.depositParams.amt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDeposit(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessDeposit.processDeposit()\n    // to allow try/catch here to catch for any issues or any checks in afterDepositChecks() failing.\n    // If there are any issues, a DepositFailed event will be emitted and processDepositFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessDeposit.processDeposit(self) {\n      // Mint shares to depositor\n      self.vault.mint(self.depositCache.user, self.depositCache.sharesToUser);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit DepositCompleted(\n        self.depositCache.user,\n        self.depositCache.sharesToUser,\n        self.depositCache.healthParams.equityBefore,\n        self.depositCache.healthParams.equityAfter\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Deposit_Failed;\n\n      emit DepositFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositCancellationChecks(self);\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      self.depositCache.borrowParams.borrowTokenAAmt,\n      self.depositCache.borrowParams.borrowTokenBAmt\n    );\n\n    // Return user's deposited asset\n    // If native token is being withdrawn, we convert wrapped to native\n    if (self.depositCache.depositParams.token == address(self.WNT)) {\n      self.WNT.withdraw(self.WNT.balanceOf(address(this)));\n      (bool success, ) = self.depositCache.user.call{value: address(this).balance}(\"\");\n      require(success, \"Transfer failed.\");\n    } else {\n      // Transfer requested withdraw asset to user\n      IERC20(self.depositCache.depositParams.token).safeTransfer(\n        self.depositCache.user,\n        self.depositCache.depositParams.amt\n      );\n    }\n\n    self.status = GMXTypes.Status.Open;\n\n    emit DepositCancelled(self.depositCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterDepositFailureChecks(self);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If current LP amount is somehow less or equal to amount before, we do not remove any liquidity\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore) {\n      processDepositFailureLiquidityWithdrawal(self);\n    } else {\n      // Remove only the newly added LP amount\n      _rlp.lpAmt = GMXReader.lpAmt(self) - self.depositCache.healthParams.lpAmtBefore;\n\n      // If delta strategy is Long, remove all in tokenB to make it more\n      // efficent to repay tokenB debt as Long strategy only borrows tokenB\n      if (self.delta == GMXTypes.Delta.Long) {\n        address[] memory _tokenASwapPath = new address[](1);\n        _tokenASwapPath[0] = address(self.lpToken);\n        _rlp.tokenASwapPath = _tokenASwapPath;\n\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address"
    }
  ]
}