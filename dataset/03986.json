{
  "Title": "[L04] Lack of indexed parameters in events",
  "Content": "Throughout the codebase, there are events defined without any indexed parameters. Some examples are:\n\n\n* [Lines 17-18](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/TransferWhitelist.sol#L17-L18) in the `TransferWhitelist` contract.\n* [Lines 34-36](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/stability/StableToken.sol#L34-L36) in the `StableToken` contract.\n\n\nConsider [indexing event parameters](https://solidity.readthedocs.io/en/v0.5.3/contracts.html#events) when appropriate, to avoid hindering the task of off-chain services searching and filtering for specific events.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/TransferWhitelist.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./UsingRegistry.sol\";\n\n/**\n * @title Holds a whitelist of addresses for which transfers should not be\n * frozen so that network initialization can take place.\n */\ncontract TransferWhitelist is Ownable, UsingRegistry {\n  using SafeMath for uint256;\n\n  address[] public whitelist;\n  bytes32[] public registeredContracts;\n\n  event WhitelistedAddress(address addr);\n  event WhitelistedRegistryId(bytes32 registryId);\n\n  constructor(address registryAddress) public {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Add an address to the whitelist.\n   * @param newAddress The address to add.\n   */\n  function addAddress(address newAddress) external onlyOwner {\n    whitelist.push(newAddress);\n    emit WhitelistedAddress(newAddress);\n  }\n\n  /**\n   * @notice Adds the registry id of a whitelisted contract.\n   * @param registryId The id of the contract to be added.\n   */\n  function addRegisteredContract(bytes32 registryId) external onlyOwner {\n    require(\n      registry.getAddressFor(registryId) != address(0),\n      \"registryId does not corespond to a registered address\"\n    );\n    registeredContracts.push(registryId);\n    emit WhitelistedRegistryId(registryId);\n  }\n\n  /**\n   * @notice Gets the number of registered contracts\n   * @return The length of registeredContracts\n   */\n  function getRegisteredContractsLength() external view returns (uint256 length) {\n    return registeredContracts.length;\n  }\n\n  /**\n   * @notice Set the whitelist of addresses.\n   * @param  _whitelist The new whitelist of addresses.\n   */\n  function setWhitelist(address[] calldata _whitelist) external onlyOwner {\n    whitelist = _whitelist;\n  }\n\n  /**\n   * @notice Set the whitelist of registered contracts.\n   * @param  _registeredContracts The new whitelist of registered contract ids.\n   */\n  function setRegisteredContracts(bytes32[] calldata _registeredContracts) external onlyOwner {\n    registeredContracts = _registeredContracts;\n  }\n\n  /**\n   * @notice Appends the addresses of registered contracts to the\n   * whitelist before returning the list.\n   * @dev If a registry id is not yet registered, the null address\n   * will be appended to the list instead.\n   * @return  The full whitelist of addresses.\n   */\n  function getWhitelist() external view returns (address[] memory) {\n    uint256 len = whitelist.length.add(registeredContracts.length);\n    address[] memory _whitelist = new address[](len);\n    uint256 i = 0;\n    while (i < whitelist.length) {\n      _whitelist[i] = whitelist[i];\n      i = i.add(1);\n    }\n    for (uint256 j = 0; j < registeredContracts.length; j = j.add(1)) {\n      _whitelist[i] = registry.getAddressFor(registeredContracts[j]);\n      i = i.add(1);\n    }\n    return _whitelist;\n  }\n\n  /**\n   * @notice Clears all data (storage and bytecode) at this contract's address.\n   * @dev The balance of this contract is returned to the owner.\n   */\n  function selfDestruct() external onlyOwner {\n    selfdestruct(msg.sender);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/stability/StableToken.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IStableToken.sol\";\nimport \"../common/interfaces/ICeloToken.sol\";\nimport \"../common/CalledByVm.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Freezable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\n/**\n * @title An ERC20 compliant token with adjustable supply.\n */\n// solhint-disable-next-line max-line-length\ncontract StableToken is\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  UsingPrecompiles,\n  Freezable,\n  CalledByVm,\n  IStableToken,\n  IERC20,\n  ICeloToken\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  event InflationFactorUpdated(uint256 factor, uint256 lastUpdated);\n\n  event InflationParametersUpdated(uint256 rate, uint256 updatePeriod, uint256 lastUpdated);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event TransferComment(string comment);\n\n  string internal name_;\n  string internal symbol_;\n  uint8 internal decimals_;\n\n  // Stored as units. Value can be found using unitsToValue().\n  mapping(address => uint256) internal balances;\n  uint256 internal totalSupply_;\n\n  // Stored as values. Units can be found using valueToUnits().\n  mapping(address => mapping(address => uint256)) internal allowed;\n\n  // STABILITY FEE PARAMETERS\n\n  // The `rate` is how much the `factor` is adjusted by per `updatePeriod`.\n  // The `factor` describes units/value of StableToken, and is greater than or equal to 1.\n  // The `updatePeriod` governs how often the `factor` is updated.\n  // `factorLastUpdated` indicates when the inflation factor was last updated.\n  struct InflationState {\n    FixidityLib.Fraction rate;\n    FixidityLib.Fraction factor;\n    uint256 updatePeriod;\n    uint256 factorLastUpdated;\n  }\n\n  InflationState inflationState;\n\n  /**\n   * @notice recomputes and updates inflation factor if more than `updatePeriod`\n   * has passed since last update.\n   */\n  modifier updateInflationFactor() {\n    FixidityLib.Fraction memory updatedInflationFactor;\n    uint256 lastUpdated;\n\n    (updatedInflationFactor, lastUpdated) = getUpdatedInflationFactor();\n\n    if (lastUpdated != inflationState.factorLastUpdated) {\n      inflationState.factor = updatedInflationFactor;\n      inflationState.factorLastUpdated = lastUpdated;\n      emit InflationFactorUpdated(inflationState.factor.unwrap(), inflationState.factorLastUpdated);\n    }\n    _;\n  }\n\n  /**\n   * @param _name The name of the stable token (English)\n   * @param _symbol A short symbol identifying the token (e.g. \"cUSD\")\n   * @param _decimals Tokens are divisible to this many decimal places.\n   * @param registryAddress Address of the Registry contract.\n   * @param inflationRate weekly inflation rate.\n   * @param inflationFactorUpdatePeriod how often the inflation factor is updated.\n   */\n  function initialize(\n    string calldata _name,\n    string calldata _symbol,\n    uint8 _decimals,\n    address registryAddress,\n    uint256 inflationRate,\n    uint256 inflationFactorUpdatePeriod,\n    address[] calldata initialBalanceAddresses,\n    uint256[] calldata initialBalanceValues\n  ) external initializer {\n    require(inflationRate != 0, \"Must provide a non-zero inflation rate\");\n    require(inflationFactorUpdatePeriod > 0, \"inflationFactorUpdatePeriod must be > 0\");\n\n    _transferOwnership(msg.sender);\n\n    totalSupply_ = 0;\n    name_ = _name;\n    symbol_ = _symbol;\n    decimals_ = _decimals;\n\n    inflationState.rate = FixidityLib.wrap(inflationRate);\n    inflationState.factor = FixidityLib.fixed1();\n    inflationState.updatePeriod = inflationFactorUpdatePeriod;\n    // solhint-disable-next-line not-rely-on-time\n    inflationState.factorLastUpdated = now;\n\n    require(initialBalanceAddresses.length == initialBalanceValues.length, \"Array length mismatch\");\n    for (uint256 i = 0; i < initialBalanceAddresses.length; i = i.add(1)) {\n      _mint(initialBalanceAddresses[i], initialBalanceValues[i]);\n    }\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Updates Inflation Parameters.\n   * @param rate new rate.\n   * @param updatePeriod how often inflationFactor is updated.\n   */\n  function setInflationParameters(uint256 rate, uint256 updatePeriod)\n    external\n    onlyOwner\n    updateInflationFactor\n  {\n    require(rate != 0, \"Must provide a non-zero inflation rate.\");\n    require(updatePeriod > 0, \"updatePeriod must be > 0\");\n    inflationState.rate = FixidityLib.wrap(rate);\n    inflationState.updatePeriod = updatePeriod;\n\n    emit InflationParametersUpdated(\n      rate,\n      updatePeriod,\n      // solhint-disable-next-line not-rely-on-time\n      now\n    );\n  }\n\n  /**\n   * @notice Increase the allowance of another user.\n   * @param spender The address which is being approved to spend StableToken.\n   * @param value The increment of the amount of StableToken approved to the spender.\n   * @return True if the transaction succeeds.\n   */\n  function increaseAllowance(address spender, uint256 value)\n    external\n    updateInflationFactor\n    returns (bool)\n  {\n    require(spender != address(0), \"reserved address 0x0 cannot have allowance\");\n    uint256 oldValue = allowed[msg.sender][spender];\n    uint256 newValue = oldValue.add(value);\n    allowed[msg.sender][spender] = newValue;\n    emit Approval(msg.sender, spender, newValue);\n    return true;\n  }\n\n  /**\n   * @notice Decrease the allowance of another user.\n   * @param spender The address which is being approved to spend StableToken.\n   * @param value The decrement of the amount of StableToken approved to the spender.\n   * @return True if the transaction succeeds.\n   */\n  function decreaseAllowance(address spender, uint256 value)\n    external\n    updateInflationFactor\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][spender];\n    uint256 newValue = oldValue.sub(value);\n    allowed[msg.sender][spender] = newValue;\n    emit Approval(msg.sender, spender, newValue);\n    return true;\n  }\n\n  /**\n   * @notice Approve a user to transfer StableToken on behalf of another user.\n   * @param spender The address which is being approved to spend StableToken.\n   * @param value The amount of StableToken approved to the spender.\n   * @return True if the transaction succeeds.\n   */\n  function approve(address spender, uint256 value) external updateInflationFactor returns (bool) {\n    require(spender != address(0), \"reserved address 0x0 cannot have allowance\");\n    allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @notice Mints new StableToken and gives it to 'to'.\n   * @param to The account for which to mint tokens.\n   * @param value The amount of StableToken to mint.\n   */\n  function mint(address to, uint256 value) external updateInflationFactor returns (bool) {\n    require(\n      msg.sender == registry.getAddressFor(EXCHANGE_REGISTRY_ID) ||\n        msg.sender == registry.getAddressFor(VALIDATORS_REGISTRY_ID),\n      \"Only the Exchange and Validators contracts are authorized to mint\"\n    );\n    return _mint(to, value);\n  }\n\n  /**\n   * @notice Mints new StableToken and gives it to 'to'.\n   * @param to The account for which to mint tokens.\n   * @param value The amount of StableToken to mint.\n   */\n  function _mint(address to, uint256 value) private returns (bool) {\n    require(to != address(0), \"0 is a reserved address\");\n    require(value > 0, \"mint value must be > 0\");\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    totalSupply_ = totalSupply_.add(units);\n    balances[to] = balances[to].add(units);\n    emit Transfer(address(0), to, value);\n    return true;\n  }\n\n  /**\n   * @notice Transfer token for a specified address\n   * @param to The address to transfer to.\n   * @param value The amount to be transferred.\n   * @param comment The transfer comment.\n   * @return True if the transaction succeeds.\n   */\n  function transferWithComment(address to, uint256 value, string calldata comment)\n    external\n    updateInflationFactor\n    onlyWhenNotFrozen\n    returns (bool)\n  {\n    bool succeeded = transfer(to, value);\n    emit TransferComment(comment);\n    return succeeded;\n  }\n\n  /**\n   * @notice Burns StableToken from the balance of msg.sender.\n   * @param value The amount of StableToken to burn.\n   */\n  function burn(uint256 value)\n    external\n    onlyRegisteredContract(EXCHANGE_REGISTRY_ID)\n    updateInflationFactor\n    returns (bool)\n  {\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    require(units <= balances[msg.sender], \"value exceeded balance of sender\");\n    totalSupply_ = totalSupply_.sub(units);\n    balances[msg.sender] = balances[msg.sender].sub(units);\n    emit Transfer(msg.sender, address(0), units);\n    return true;\n  }\n\n  /**\n   * @notice Transfers StableToken from one address to another on behalf of a user.\n   * @param from The address to transfer StableToken from.\n   * @param to The address to transfer StableToken to.\n   * @param value The amount of StableToken to transfer.\n   * @return True if the transaction succeeds.\n   */\n  function transferFrom(address from, address to, uint256 value)\n    external\n    updateInflationFactor\n    onlyWhenNotFrozen\n    returns (bool)\n  {\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    require(to != address(0), \"transfer attempted to reserved address 0x0\");\n    require(units <= balances[from], \"transfer value exceeded balance of sender\");\n    require(\n      value <= allowed[from][msg.sender],\n      \"transfer value exceeded sender's allowance for recipient\"\n    );\n\n    balances[to] = balances[to].add(units);\n    balances[from] = balances[from].sub(units);\n    allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n    emit Transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @return The name of the stable token.\n   */\n  function name() external view returns (string memory) {\n    return name_;\n  }\n\n  /**\n   * @return The symbol of the stable token.\n   */\n  function symbol() external view returns (string memory) {\n    return symbol_;\n  }\n\n  /**\n   * @return The number of decimal places to which StableToken is divisible.\n   */\n  function decimals() external view returns (uint8) {\n    return decimals_;\n  }\n\n  /**\n   * @notice Gets the amount of owner's StableToken allowed to be spent by spender.\n   * @param accountOwner The owner of the StableToken.\n   * @param spender The spender of the StableToken.\n   * @return The amount of StableToken owner is allowing spender to spend.\n   */\n  function allowance(address accountOwner, address spender) external view returns (uint256) {\n    return allowed[accountOwner][spender];\n  }\n\n  /**\n   * @notice Gets the balance of the specified address using the presently stored inflation factor.\n   * @param accountOwner The address to query the balance of.\n   * @return The balance of the specified address.\n   */\n  function balanceOf(address accountOwner) external view returns (uint256) {\n    return unitsToValue(balances[accountOwner]);\n  }\n\n  /**\n   * @return The total value of StableToken in existence\n   * @dev Though totalSupply_ is stored in units, this returns value.\n   */\n  function totalSupply() external view returns (uint256) {\n    return unitsToValue(totalSupply_);\n  }\n\n  /**\n   * @notice gets inflation parameters.\n   * @return rate\n   * @return factor\n   * @return updatePeriod\n   * @return factorLastUpdated\n   */\n  function getInflationParameters() external view returns (uint256, uint256, uint256, uint256) {\n    return (\n      inflationState.rate.unwrap(),\n      inflationState.factor.unwrap(),\n      inflationState.updatePeriod,\n      inflationState.factorLastUpdated\n    );\n  }\n\n  /**\n   * @notice Returns the units for a given value given the current inflation factor.\n   * @param value The value to convert to units.\n   * @return The units corresponding to `value` given the current inflation factor.\n   * @dev We don't compute the updated inflationFactor here because\n   * we assume any function calling this will have updated the inflation factor.\n   */\n  function valueToUnits(uint256 value) external view returns (uint256) {\n    FixidityLib.Fraction memory updatedInflationFactor;\n\n    (updatedInflationFactor, ) = getUpdatedInflationFactor();\n    return _valueToUnits(updatedInflationFactor, value);\n  }\n\n  /**\n   * @notice Returns the value of a given number of units given the current inflation factor.\n   * @param units The units to convert to value.\n   * @return The value corresponding to `units` given the current inflation factor.\n   */\n  function unitsToValue(uint256 units) public view returns (uint256) {\n    FixidityLib.Fraction memory updatedInflationFactor;\n\n    (updatedInflationFactor, ) = getUpdatedInflationFactor();\n\n    // We're ok using FixidityLib.divide here because updatedInflationFactor is\n    // not going to surpass maxFixedDivisor any time soon.\n    // Quick upper-bound estimation: if annual inflation were 5% (an order of\n    // magnitude more than the initial proposal of 0.5%), in 500 years, the\n    // inflation factor would be on the order of 10**10, which is still a safe\n    // divisor.\n    return FixidityLib.newFixed(units).divide(updatedInflationFactor).fromFixed();\n  }\n\n  /**\n   * @notice Returns the units for a given value given the current inflation factor.\n   * @param value The value to convert to units.\n   * @return The units corresponding to `value` given the current inflation factor.\n   * @dev we assume any function calling this will have updated the inflation factor.\n   */\n  function _valueToUnits(FixidityLib.Fraction memory inflationFactor, uint256 value)\n    private\n    pure\n    returns (uint256)\n  {\n    return inflationFactor.multiply(FixidityLib.newFixed(value)).fromFixed();\n  }\n\n  /**\n   * @notice Computes the up-to-date inflation factor.\n   * @return current inflation factor.\n   * @return lastUpdated time when the returned inflation factor went into effect.\n   */\n  function getUpdatedInflationFactor() private view returns (FixidityLib.Fraction memory, uint256) {\n    /* solhint-disable not-rely-on-time */\n    if (now < inflationState.factorLastUpdated.add(inflationState.updatePeriod)) {\n      return (inflationState.factor, inflationState.factorLastUpdated);\n    }\n\n    uint256 numerator;\n    uint256 denominator;\n\n    // TODO: handle retroactive updates given decreases to updatePeriod\n    uint256 timesToApplyInflation = now.sub(inflationState.factorLastUpdated).div(\n      inflationState.updatePeriod\n    );\n\n    (numerator, denominator) = fractionMulExp(\n      inflationState.factor.unwrap(),\n      FixidityLib.fixed1().unwrap(),\n      inflationState.rate.unwrap(),\n      FixidityLib.fixed1().unwrap(),\n      timesToApplyInflation,\n      decimals_\n    );\n\n    // This should never happen. If something went wrong updating the\n    // inflation factor, keep the previous factor\n    if (numerator == 0 || denominator == 0) {\n      return (inflationState.factor, inflationState.factorLastUpdated);\n    }\n\n    FixidityLib.Fraction memory currentInflationFactor = FixidityLib.wrap(numerator).divide(\n      FixidityLib.wrap(denominator)\n    );\n    uint256 lastUpdated = inflationState.factorLastUpdated.add(\n      inflationState.updatePeriod.mul(timesToApplyInflation)\n    );\n\n    return (currentInflationFactor, lastUpdated);\n    /* solhint-enable not-rely-on-time */\n  }\n\n  /**\n   * @notice Transfers `value` from `msg.sender` to `to`\n   * @param to The address to transfer to.\n   * @param value The amount to be transferred.\n   */\n  // solhint-disable-next-line no-simple-event-func-name\n  function transfer(address to, uint256 value)\n    public\n    updateInflationFactor\n    onlyWhenNotFrozen\n    returns (bool)\n  {\n    return _transfer(to, value);\n  }\n\n  /**\n   * @notice Transfers StableToken from one address to another\n   * @param to The address to transfer StableToken to.\n   * @param value The amount of StableToken to be transferred.\n   */\n  function _transfer(address to, uint256 value) internal returns (bool) {\n    require(to != address(0), \"transfer attempted to reserved address 0x0\");\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    require(balances[msg.sender] >= units, \"transfer value exceeded balance of sender\");\n    balances[msg.sender] = balances[msg.sender].sub(units);\n    balances[to] = balances[to].add(units);\n    emit Transfer(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n   * @notice Reserve balance for making payments for gas in this StableToken currency.\n   * @param from The account to reserve balance from\n   * @param value The amount of balance to reserve\n   */\n  function debitGasFees(address from, uint256 value)\n    external\n    onlyVm\n    onlyWhenNotFrozen\n    updateInflationFactor\n  {\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    balances[from] = balances[from].sub(units);\n    totalSupply_ = totalSupply_.sub(units);\n  }\n\n  /**\n   * @notice Alternative function to credit balance after making payments\n   * for gas in this StableToken currency.\n   * @param from The account to debit balance from\n   * @param feeRecipient Coinbase address\n   * @param gatewayFeeRecipient Gateway address\n   * @param communityFund Community fund address\n   * @param tipTxFee Coinbase fee\n   * @param baseTxFee Community fund fee\n   * @param gatewayFee Gateway fee\n   */\n  function creditGasFees(\n    address from,\n    address feeRecipient,\n    address gatewayFeeRecipient,\n    address communityFund,\n    uint256 refund,\n    uint256 tipTxFee,\n    uint256 gatewayFee,\n    uint256 baseTxFee\n  ) external onlyVm onlyWhenNotFrozen {\n    uint256 units = _valueToUnits(inflationState.factor, refund);\n    balances[from] = balances[from].add(units);\n\n    units = units.add(_creditGas(from, communityFund, baseTxFee));\n    units = units.add(_creditGas(from, feeRecipient, tipTxFee));\n    units = units.add(_creditGas(from, gatewayFeeRecipient, gatewayFee));\n    totalSupply_ = totalSupply_.add(units);\n  }\n\n  function _creditGas(address from, address to, uint256 value) internal returns (uint256) {\n    if (to == address(0)) {\n      return 0;\n    }\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    balances[to] = balances[to].add(units);\n    emit Transfer(from, to, value);\n    return units;\n  }\n\n}"
    }
  ]
}