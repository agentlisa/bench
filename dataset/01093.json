{
  "Title": "Owner Can Only Sweep Tracked Assets From Risk Fund",
  "Content": "The risk fund's [sweep](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/ProtocolReserve/RiskFundV2.sol#L114) function only allows the owner to transfer funds that have been [deposited by the risk fund converter](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/ProtocolReserve/RiskFundV2.sol#L134-L136) and tracked in the internal state. There is no functionality to sweep tokens that have been mistakenly sent to the contract, as exists in the token converter.\n\n\nConsider adding arbitrary token sweeps to the risk fund to prevent donated tokens from becoming irrecoverable.\n\n\n***Update:** Resolved at commit [a842667](https://github.com/VenusProtocol/protocol-reserve/pull/24/commits/a8426677df622b6c59b62196eecf8d168f0ff2f8).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/ProtocolReserve/RiskFundV2.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { AccessControlledV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport { IRiskFund } from \"../Interfaces/IRiskFund.sol\";\nimport { ensureNonzeroAddress } from \"../Utils/Validators.sol\";\nimport { RiskFundV2Storage } from \"./RiskFundStorage.sol\";\n\n/// @title RiskFundV2\n/// @author Venus\n/// @notice Contract with basic features to hold base asset for different Comptrollers\n/// @dev This contract does not support BNB\ncontract RiskFundV2 is AccessControlledV8, RiskFundV2Storage, IRiskFund {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice Emitted when convertible base asset address is updated\n    event ConvertibleBaseAssetUpdated(address indexed oldConvertibleBaseAsset, address indexed newConvertibleBaseAsset);\n\n    /// @notice Emitted when risk fund converter address is updated\n    event RiskFundConverterUpdated(address indexed oldRiskFundConverter, address indexed newRiskFundConverter);\n\n    /// @notice Emitted when shortfall contract address is updated\n    event ShortfallContractUpdated(address indexed oldShortfallContract, address indexed newShortfallContract);\n\n    /// @notice Emitted when reserves are transferred for auction\n    event TransferredReserveForAuction(address indexed comptroller, uint256 amount);\n\n    /// @notice Emitted when pool states is updated with amount transferred to this contract\n    event PoolStateUpdated(address indexed comptroller, address indexed asset, uint256 amount);\n\n    /// @notice Event emitted when tokens are swept\n    event SweepToken(address indexed comptroller, address indexed asset, uint256 amount);\n\n    /// @notice Error is thrown when updatePoolState is not called by riskFundConverter\n    error InvalidRiskFundConverter();\n\n    /// @notice Error is thrown when transferReserveForAuction is called by non shortfall address\n    error InvalidShortfallAddress();\n\n    /// @notice Error is thrown when pool reserve is less than the amount needed\n    error InsufficientPoolReserve(address comptroller, uint256 amount, uint256 poolReserve);\n\n    /// @dev Convertible base asset setter\n    /// @param convertibleBaseAsset_ Address of the convertible base asset\n    /// @custom:event ConvertibleBaseAssetUpdated emit on success\n    /// @custom:error ZeroAddressNotAllowed is thrown when risk fund converter address is zero\n    function setConvertibleBaseAsset(address convertibleBaseAsset_) external onlyOwner {\n        ensureNonzeroAddress(convertibleBaseAsset_);\n        emit ConvertibleBaseAssetUpdated(convertibleBaseAsset, convertibleBaseAsset_);\n        convertibleBaseAsset = convertibleBaseAsset_;\n    }\n\n    /// @dev Risk fund converter setter\n    /// @param riskFundConverter_ Address of the risk fund converter\n    /// @custom:event RiskFundConverterUpdated emit on success\n    /// @custom:error ZeroAddressNotAllowed is thrown when risk fund converter address is zero\n    function setRiskFundConverter(address riskFundConverter_) external onlyOwner {\n        ensureNonzeroAddress(riskFundConverter_);\n        emit RiskFundConverterUpdated(riskFundConverter, riskFundConverter_);\n        riskFundConverter = riskFundConverter_;\n    }\n\n    /// @dev Shortfall contract address setter\n    /// @param shortfallContractAddress_ Address of the auction contract\n    /// @custom:error ZeroAddressNotAllowed is thrown when shortfall contract address is zero\n    function setShortfallContractAddress(address shortfallContractAddress_) external onlyOwner {\n        ensureNonzeroAddress(shortfallContractAddress_);\n        emit ShortfallContractUpdated(shortfall, shortfallContractAddress_);\n        shortfall = shortfallContractAddress_;\n    }\n\n    /// @dev Transfer tokens for auction\n    /// @param comptroller Comptroller of the pool\n    /// @param bidder Amount transferred to bidder address\n    /// @param amount Amount to be transferred to auction contract\n    /// @return Number reserved tokens.\n    /// @custom:error InvalidShortfallAddress is thrown on invalid shortfall address\n    /// @custom:error InsufficientPoolReserve is thrown when pool reserve is less than the amount needed\n    function transferReserveForAuction(\n        address comptroller,\n        address bidder,\n        uint256 amount\n    ) external override returns (uint256) {\n        uint256 poolReserve = poolAssetsFunds[comptroller][convertibleBaseAsset];\n\n        if (msg.sender != shortfall) {\n            revert InvalidShortfallAddress();\n        }\n        if (amount > poolReserve) {\n            revert InsufficientPoolReserve(comptroller, amount, poolReserve);\n        }\n\n        unchecked {\n            poolAssetsFunds[comptroller][convertibleBaseAsset] = poolReserve - amount;\n        }\n\n        IERC20Upgradeable(convertibleBaseAsset).safeTransfer(bidder, amount);\n        emit TransferredReserveForAuction(comptroller, amount);\n\n        return amount;\n    }\n\n    /// @notice Function to sweep baseAsset for pool, Tokens are sent to admin (timelock)\n    /// @param comptroller The address of the pool for the amount need to be sweeped\n    /// @param asset Address of the asset(token)\n    /// @param amount Amount need to sweep for the pool\n    /// @custom:event Emits SweepToken event on success\n    /// @custom:error ZeroAddressNotAllowed is thrown when tokenAddress/to address is zero\n    /// @custom:error InsufficientPoolReserve is thrown when pool reserve is less than the amount needed\n    /// @custom:access Only Governance\n    function sweepToken(address comptroller, address asset, uint256 amount) external onlyOwner nonReentrant {\n        ensureNonzeroAddress(comptroller);\n\n        uint256 poolReserve = poolAssetsFunds[comptroller][asset];\n        if (amount > poolReserve) {\n            revert InsufficientPoolReserve(comptroller, amount, poolReserve);\n        }\n        poolAssetsFunds[comptroller][asset] = poolReserve - amount;\n\n        IERC20Upgradeable token = IERC20Upgradeable(asset);\n        token.safeTransfer(owner(), amount);\n\n        emit SweepToken(comptroller, asset, amount);\n    }\n\n    /// @dev Update the reserve of the asset for the specific pool after transferring to risk fund\n    /// @param comptroller Comptroller address (pool)\n    /// @param asset Address of the asset(token)\n    /// @param amount Amount transferred for the pool\n    function updatePoolState(address comptroller, address asset, uint256 amount) public {\n        if (msg.sender != riskFundConverter) {\n            revert InvalidRiskFundConverter();\n        }\n\n        poolAssetsFunds[comptroller][asset] += amount;\n        emit PoolStateUpdated(comptroller, asset, amount);\n    }\n}"
    }
  ]
}