{
  "Title": "H-8: Trade fees can be avoided in limit orders",
  "Content": "# Issue H-8: Trade fees can be avoided in limit orders \n\nSource: https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/212 \n\n## Found by \n0xLogos, LTDingZhen, jennifer37, nobody2018, santipu\\_, shaka\n## Summary\n\nOn limit order announcement the trade fee is calculated based on the current size of the position and its value is used on the execution of the limit order. However, it is not taken into account that the value of `additionalSize` in the position can have changed since the limit order was announced, so users can avoid paying trade fees for closing leveraged positions at the expense of LPs.\n\n## Vulnerability Detail\n\nWhen a user announces a limit order to close a leveraged position the trade fee [is calculated](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LimitOrder.sol#L62-L64) based on the current trade fee rate and the `additionalSize` of the position and [stored](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LimitOrder.sol#L69) in the `_limitOrderClose` mapping.\n\nOn the execution of the limit order, the value of the trade fee recorded in the `_limitOrderClose` mapping is [used to build the `AnnoundedLeverageClose` struct](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LimitOrder.sol#L166-L172) that is sent to the `LeverageModule:executeClose` function. In this function the trade fee is [used to pay the stable LPs](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LeverageModule.sol#L310) and [subtracted from the total amount](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LeverageModule.sol#L314) received by the user closing the position.\n\nHowever, it is not taken into account that the value of `additionalSize` in the position can have changed since the limit order was announced [via the `LeverageModule:executeAdjust` function](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LeverageModule.sol#L196).\n\nAs a result, users that want to open a limit order can do so using the minimum `additionalSize` possible and then increase it after the limit order is announced, avoiding paying the trade fee for the additional size adjustment.\n\nIt is also worth mentioning that the trade fee rate can change between the announcement and the execution of the limit order, so the trade fee calculated at the announcement time can be different from the one used at the execution time. Although this scenario is much less likely to happen (requires the governance to change the trade fee rate) and its impact is much lower (the trade fee rate is not likely to change significantly).\n\n\n## Impact\n\nUsers can avoid paying trade fees for closing leveraged positions at the expense of UNIT LPs, that should have received the trade fee.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LimitOrder.sol#L62-L64\n\n## Proof of concept\n\n<details>\n\n<summary>Tests</summary>\n\nThe following tests show the example of a user that opens a limit order to be executed when the price doubles. \n\nThe operations performed in both tests are identical, but the order of the operations is different, so we can see how a user can exploit the system to avoid paying trade fees.\n\nTo reproduce it add the following code to `AdjustPositionTest` contract and run `forge test --mt test_LimitTradeFee -vv`:\n\n```solidity\n    function test_LimitTradeFee_ExpectedBehaviour() public {\n        uint256 aliceCollateralBalanceBefore = WETH.balanceOf(alice);\n        uint256 collateralPrice = 1000e8;\n\n        announceAndExecuteDeposit({\n            traderAccount: bob,\n            keeperAccount: keeper,\n            depositAmount: 10000e18,\n            oraclePrice: collateralPrice,\n            keeperFeeAmount: 0\n        });\n\n        // Create small leverage position\n        uint256 initialMargin = 0.05e18;\n        uint256 initialSize = 0.1e18;\n        uint256 tokenId = announceAndExecuteLeverageOpen({\n            traderAccount: alice,\n            keeperAccount: keeper,\n            margin: initialMargin,\n            additionalSize: initialSize,\n            oraclePrice: collateralPrice,\n            keeperFeeAmount: 0\n        });\n\n        // Increase margin and size in position\n        uint256 adjustmentTradeFee = announceAndExecuteLeverageAdjust({\n            tokenId: tokenId,\n            traderAccount: alice,\n            keeperAccount: keeper,\n            marginAdjustment: 100e18,\n            additionalSizeAdjustment: 2400e18,\n            oraclePrice: collateralPrice,\n            keeperFeeAmount: 0\n        });\n\n        // Anounce limit order to close position at 2x price\n        vm.startPrank(alice);\n        limitOrderProxy.announceLimitOrder({\n            tokenId: tokenId,\n            priceLowerThreshold: 0,\n            priceUpperThreshold: collateralPrice * 2\n        });\n\n        // Collateral price doubles after 1 month and the order is executed\n        skip(4 weeks);\n        collateralPrice = collateralPrice * 2;\n        setWethPrice(collateralPrice);\n        bytes[] memory priceUpdateData = getPriceUpdateData(collateralPrice);\n        vm.startPrank(keeper);\n        limitOrderProxy.executeLimitOrder{value: 1}(tokenId, priceUpdateData);\n\n        uint256 aliceCollateralBalanceAfter = WETH.balanceOf(alice);\n        console2.log(\"profit:\", aliceCollateralBalanceAfter - aliceCollateralBalanceBefore);\n    }\n\n    function test_LimitTradeFee_PayLessFees() public {\n        uint256 aliceCollateralBalanceBefore = WETH.balanceOf(alice);\n        uint256 collateralPrice = 1000e8;\n\n        announceAndExecuteDeposit({\n            traderAccount: bob,\n            keeperAccount: keeper,\n            depositAmount: 10000e18,\n            oraclePrice: collateralPrice,\n            keeperFeeAmount: 0\n        });\n\n        // Create small leverage position\n        uint256 initialMargin = 0.05e18;\n        uint256 initialSize = 0.1e18;\n        uint256 tokenId = announceAndExecuteLeverageOpen({\n            traderAccount: alice,\n            keeperAccount: keeper,\n            margin: initialMargin,\n            additionalSize: initialSize,\n            oraclePrice: collateralPrice,\n            keeperFeeAmount: 0\n        });\n\n        // Anounce limit order to close position at 2x price\n        vm.startPrank(alice);\n        limitOrderProxy.announceLimitOrder({\n            tokenId: tokenId,\n            priceLowerThreshold: 0,\n            priceUpperThreshold: collateralPrice * 2\n        });\n\n        // Increase margin and size in position\n        uint256 adjustmentTradeFee = announceAndExecuteLeverageAdjust({\n            tokenId: tokenId,\n            traderAccount: alice,\n            keeperAccount: keeper,\n            marginAdjustment: 100e18,\n            additionalSizeAdjustment: 2400e18,\n            oraclePrice: collateralPrice,\n            keeperFeeAmount: 0\n        });\n\n        // Collateral price doubles after 1 month and the order is executed\n        skip(4 weeks);\n        collateralPrice = collateralPrice * 2;\n        setWethPrice(collateralPrice);\n        bytes[] memory priceUpdateData = getPriceUpdateData(collateralPrice);\n        vm.startPrank(keeper);\n        limitOrderProxy.executeLimitOrder{value: 1}(tokenId, priceUpdateData);\n\n        uint256 aliceCollateralBalanceAfter = WETH.balanceOf(alice);\n        console2.log(\"profit:\", aliceCollateralBalanceAfter - aliceCollateralBalanceBefore);\n    }\n```\n\n</details>\n\n\n<details>\n\n<summary>Result</summary>\n\n```js\n[PASS] test_LimitTradeFee_ExpectedBehaviour() (gas: 2457623)\nLogs:\n  profit: 1195246800000000000000\n\n[PASS] test_LimitTradeFee_PayLessFees() (gas: 2441701)\nLogs:\n  profit: 1197646800000000000000\n\nTest result: ok. 2 passed; 0 failed; 0 skipped; finished in 21.23ms\n```\n\nAs we can see, in the second case the user was able to get a profit 2.4 rETH higher, corresponding to the trade fee avoided for the additional size adjustment done after creating the limit order (2,400 rETH * 0.1% fee). That higher profit has come at the expense of LPs, who should have received the trade fee.\n\n</details>\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCalculate the trade fee at the execution time of the limit order, in the same way it is done for stable withdrawals for the withdrawal fee.\n\n```diff\nFile: LimitOrder.sol\n\n+       uint256 tradeFee = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).getTradeFee(\n+           vault.getPosition(tokenId).additionalSize\n+       );\n+\n        order.orderData = abi.encode(\n            FlatcoinStructs.AnnouncedLeverageClose({\n                tokenId: tokenId,\n                minFillPrice: minFillPrice,\n-               tradeFee: _limitOrder.tradeFee\n+               tradeFee: tradeFee\n            })\n        );\n```\n\nA `maxTradeFee` parameter can also be added at the announcement time to avoid the trade fee being higher than a certain value.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: \n\n\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dhedge/flatcoin-v1/pull/274.\n\n**ydspa**\n\nEscalate\n\nFee loss in certain circumstance is a Medium issue\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Fee loss in certain circumstance is a Medium issue\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**xiaoming9090**\n\nEscalate.\n\nThe impact of this issue is that the LPs will not receive the trade fee. This is similar to other issues where the protocol did not receive their entitled trade fee due to some error and should be categorized as loss of fee OR loss of earning, and thus should be a Medium.\n\nAlso, note that the LPs gain/earn when the following event happens:\n\n- Loss of the long trader. This is because LP is the short side. The loss of a long trader is the gain of a short trader.\n- Open, adjust, close long position - (0.1% fee)\n- Open limit order - (0.1% fee)\n- Borrow Rate Fees (aka Funding Rate)\n- Liquidation Fees\n- ETH Staking Yield\n\nStatically, the bulk of the LP gain comes from the loss of the long trader in such a long-short prep protocol in the real world. The uncollected trading fee due to certain malicious users opening limit orders only makes up a very small portion of the earnings and does not materially impact the LPs or protocols. Also, this is not a bug that would drain the protocol, directly steal the assets of LPs, or lead to the protocol being insolvent. Thus, this issue should not be High. A risk rating of Medium would be more appropriate in this case.\n\n**sherlock-admin2**\n\n> Escalate.\n> \n> The impact of this issue is that the LPs will not receive the trade fee. This is similar to other issues where the protocol did not receive their entitled trade fee due to some error and should be categorized as loss of fee OR loss of earning, and thus should be a Medium.\n> \n> Also, note that the LPs gain/earn when the following event happens:\n> \n> - Loss of the long trader. This is because LP is the short side. The loss of a long trader is the gain of a short trader.\n> - Open, adjust, close long position - (0.1% fee)\n> - Open limit order - (0.1% fee)\n> \n> Statically, the bulk of the LP gain comes from the loss of the long trader in such a long-short prep protocol in the real world. The uncollected trading fee due to certain malicious users opening limit orders only makes up a very small portion of the earnings and does not materially impact the LPs or protocols. Also, this is not a bug that would drain the protocol, directly steal the assets of LPs, or lead to the protocol being insolvent. Thus, this issue should not be High. A risk rating of Medium would be more appropriate in this case.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\nI think I agree with medium and @xiaoming9090 analysis, my initial thoughts were that fees make up a core part of the LPs earnings and should never be allowed to be side stepped. \n\nI want to note though if this can be performed repeatedly by an user grieving fees for a LP, wouldn't it be meeting the following criteria? But depending on what is deemed as material loss of funds for sherlock, I will let @Czar102 decide on severity, but I can agree with medium severity.\n\n> Definite loss of funds without (extensive) limitations of external conditions\n\n\n\n**0xjuaan**\n\nTo counter @xiaoming9090 's analysis (for this issue and also for issue #75) - \n\n> Statically, the bulk of the LP gain comes from the loss of the long trader in such a long-short prep protocol in the real world.\n\nIs the above really true? Since the protocol is designed to be delta neutral, the expected PnL from the above avenue would be zero. LPs cant affect whether traders win or lose.\nHowever, the trading fee is the only feature that guarantees some gains for the LPs, and with users bypassing this- LPs are much less incentivised to participate. \n\nBecause of the above, I think that fees still make up a core part of the LPs earnings, but you can correct me if I am wrong.\n\n\n \n\n**xiaoming9090**\n\nI have updated my original escalation with a more comprehensive list of avenues from which the LPs earn their yield, so that the judge can have a more complete picture.\n\n**shaka0x**\n\n> Also, note that the LPs gain/earn when the following event happens:\n> \n> * Loss of the long trader. This is because LP is the short side. The loss of a long trader is the gain of a short trader.\n> * Open, adjust, close long position - (0.1% fee)\n> * Open limit order - (0.1% fee)\n> * Borrow Rate Fees (aka Funding Rate)\n> * Liquidation Fees\n> * ETH Staking Yield\n>\n> Statically, the bulk of the LP gain comes from the loss of the long trader in such a long-short prep protocol in the real world.\n\nI respectfully disagree. The position of the UNIT holders will not always be short, and even the when they are the long trader might not necessarily have losses. \n\nThe sponsor clarified this in a [Discord message](https://discord.com/channels/812037309376495636/1199005620536356874/1199695736430927902), regarding the comment regarding the LSD yield as a source of yield for UNIT holders:\n\n```\nThe LSD yield is a little more complex because UNIT holders are technically long and short rETH. \n```\n\nAnd [confirmed](https://discord.com/channels/812037309376495636/1199005620536356874/1199681390829125674) that the sources of UNIT yield come from funding rate, trading fees and liquidations.\n\n```\nUNIT is delta neutral. But yield is earned from:\n1. Funding rate (which is historically usually being paid to the short positions). Ie. Leverage long traders are typically happy to pay a funding fee to shorts (but not always the case). This goes to UNIT holders or is paid by UNIT holders if funding rate is negative\n2. Trading fees on each trade\n3. Liquidation remaining margin when leverage traders get liquidated\n```\n\nThus, the trade fees are a fundamental incentive for the UNIT holders.\n\n\n**Czar102**\n\nNot being able to gather protocol fees is a Medium severity issue as there is no loss of funds.\n\nIn this case though, I think High severity is justified, because the fee is what LPs are paid for traders to trade against, and there are value extraction strategies like multi-block #216 if the market is giving any additional information than the oracle states (always).\nIt's like selling an option, but not receiving the premium. This is a severe loss of funds, even though the notional wasn't impacted.\n\nIs my way of thinking about this issue accurate? If yes, planning to reject the escalations and leave the issue as is.\n\n**Czar102**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ydspa](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/212/#issuecomment-1955898121): rejected\n- [xiaoming9090](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/212/#issuecomment-1959561951): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/132",
  "Code": [
    {
      "filename": "flatcoin-v1/src/LimitOrder.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/interfaces/IERC20Upgradeable.sol\";\nimport {SignedMath} from \"openzeppelin-contracts/contracts/utils/math/SignedMath.sol\";\n\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\nimport {OracleModifiers} from \"./abstracts/OracleModifiers.sol\";\nimport {InvariantChecks} from \"./misc/InvariantChecks.sol\";\n\nimport {ILimitOrder} from \"./interfaces/ILimitOrder.sol\";\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {IStableModule} from \"./interfaces/IStableModule.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {IKeeperFee} from \"./interfaces/IKeeperFee.sol\";\n\n/// @title LimitOrder\n/// @author dHEDGE\n/// @notice Module to create limit orders.\ncontract LimitOrder is ILimitOrder, ModuleUpgradeable, ReentrancyGuardUpgradeable, InvariantChecks, OracleModifiers {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeERC20Upgradeable for IStableModule;\n    using SignedMath for int256;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    mapping(uint256 tokenId => FlatcoinStructs.Order order) internal _limitOrderClose;\n\n    /// @notice Function to initialize this contract.\n    function initialize(IFlatcoinVault _vault) external initializer {\n        __Module_init(FlatcoinModuleKeys._LIMIT_ORDER_KEY, _vault);\n        __ReentrancyGuard_init();\n    }\n\n    /////////////////////////////////////////////\n    //         Trader Write Functions          //\n    /////////////////////////////////////////////\n\n    /// @notice Announces a limit order to close a position\n    /// @param tokenId The position to close\n    /// @param priceLowerThreshold The stop-loss price\n    /// @param priceUpperThreshold The profit-take price\n    /// @dev Currently can only be used for closing existing orders\n    ///      The keeper fee will be determined at execution time, and the trader takes this risk.\n    ///      This is because there could be a large time difference between limit order announcement and execution.\n    function announceLimitOrder(uint256 tokenId, uint256 priceLowerThreshold, uint256 priceUpperThreshold) external {\n        uint64 executableAtTime = _prepareAnnouncementOrder();\n        address positionOwner = _checkPositionOwner(tokenId);\n        _checkThresholds(priceLowerThreshold, priceUpperThreshold);\n        uint256 tradeFee = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).getTradeFee(\n            vault.getPosition(tokenId).additionalSize\n        );\n\n        _limitOrderClose[tokenId] = FlatcoinStructs.Order({\n            orderType: FlatcoinStructs.OrderType.LimitClose,\n            orderData: abi.encode(\n                FlatcoinStructs.LimitClose(tokenId, priceLowerThreshold, priceUpperThreshold, tradeFee)\n            ),\n            keeperFee: 0, // Not applicable for limit orders. Keeper fee will be determined at execution time.\n            executableAtTime: executableAtTime\n        });\n\n        // Lock the NFT belonging to this position so that it can't be transferred to someone else.\n        ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).lock(tokenId);\n\n        emit FlatcoinEvents.OrderAnnounced({\n            account: positionOwner,\n            orderType: FlatcoinStructs.OrderType.LimitClose,\n            keeperFee: 0\n        });\n    }\n\n    /// @notice Cancels a limit order\n    /// @param tokenId The position to close\n    function cancelLimitOrder(uint256 tokenId) external {\n        address positionOwner = _checkPositionOwner(tokenId);\n        _checkLimitCloseOrder(tokenId);\n\n        delete _limitOrderClose[tokenId];\n\n        // Unlock the ERC721 position NFT to allow for transfers.\n        ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).unlock(tokenId);\n\n        emit FlatcoinEvents.OrderCancelled({account: positionOwner, orderType: FlatcoinStructs.OrderType.LimitClose});\n    }\n\n    /// @notice Cancel limit order called by other modules\n    /// @dev Used by the LeverageModule to cancel any existing limit order when the position is closed.\n    function cancelExistingLimitOrder(uint256 tokenId) external onlyAuthorizedModule returns (bool cancelled) {\n        if (_limitOrderClose[tokenId].orderType == FlatcoinStructs.OrderType.LimitClose) {\n            delete _limitOrderClose[tokenId];\n\n            cancelled = true;\n\n            // Unlock the ERC721 position NFT to allow for transfers.\n            ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).unlock(tokenId);\n\n            emit FlatcoinEvents.OrderCancelled({\n                account: ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).ownerOf(tokenId),\n                orderType: FlatcoinStructs.OrderType.LimitClose\n            });\n        }\n    }\n\n    /// @notice Function to execute a limit order\n    /// @dev This function is typically called by the keeper\n    function executeLimitOrder(\n        uint256 tokenId,\n        bytes[] calldata priceUpdateData\n    ) external payable nonReentrant updatePythPrice(vault, msg.sender, priceUpdateData) orderInvariantChecks(vault) {\n        _checkLimitCloseOrder(tokenId);\n\n        vault.settleFundingFees();\n\n        _closePosition(tokenId);\n    }\n\n    /////////////////////////////////////////////\n    //           Internal Functions            //\n    /////////////////////////////////////////////\n\n    function _closePosition(uint256 tokenId) internal {\n        ILeverageModule leverageModule = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY));\n        FlatcoinStructs.Order memory order = _limitOrderClose[tokenId];\n        FlatcoinStructs.LimitClose memory _limitOrder = abi.decode(\n            _limitOrderClose[tokenId].orderData,\n            (FlatcoinStructs.LimitClose)\n        );\n        address account = leverageModule.ownerOf(tokenId);\n\n        (uint256 price, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        // Check that the minimum time delay is reached before execution\n        if (block.timestamp < order.executableAtTime)\n            revert FlatcoinErrors.ExecutableTimeNotReached(order.executableAtTime);\n\n        uint256 minFillPrice;\n\n        if (price <= _limitOrder.priceLowerThreshold) {\n            minFillPrice = 0; // can execute below lower limit price threshold\n        } else if (price >= _limitOrder.priceUpperThreshold) {\n            minFillPrice = _limitOrder.priceUpperThreshold;\n        } else {\n            revert FlatcoinErrors.LimitOrderPriceNotInRange(\n                price,\n                _limitOrder.priceLowerThreshold,\n                _limitOrder.priceUpperThreshold\n            );\n        }\n\n        // Delete the order tracker from storage.\n        delete _limitOrderClose[tokenId];\n\n        order.orderData = abi.encode(\n            FlatcoinStructs.AnnouncedLeverageClose({\n                tokenId: tokenId,\n                minFillPrice: minFillPrice,\n                tradeFee: _limitOrder.tradeFee\n            })\n        );\n        order.keeperFee = IKeeperFee(vault.moduleAddress(FlatcoinModuleKeys._KEEPER_FEE_MODULE_KEY)).getKeeperFee();\n        leverageModule.executeClose({account: account, keeper: msg.sender, order: order});\n\n        emit FlatcoinEvents.OrderExecuted({account: account, orderType: order.orderType, keeperFee: order.keeperFee});\n    }\n\n    function _checkPositionOwner(uint256 tokenId) internal view returns (address positionOwner) {\n        positionOwner = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).ownerOf(tokenId);\n\n        if (positionOwner != msg.sender) revert FlatcoinErrors.NotTokenOwner(tokenId, msg.sender);\n    }\n\n    function _checkThresholds(uint256 priceLowerThreshold, uint256 priceUpperThreshold) internal pure {\n        if (priceLowerThreshold >= priceUpperThreshold)\n            revert FlatcoinErrors.InvalidThresholds(priceLowerThreshold, priceUpperThreshold);\n    }\n\n    function _checkLimitCloseOrder(uint256 tokenId) internal view {\n        FlatcoinStructs.Order memory _limitOrder = _limitOrderClose[tokenId];\n\n        if (_limitOrder.orderType != FlatcoinStructs.OrderType.LimitClose)\n            revert FlatcoinErrors.LimitOrderInvalid(tokenId);\n    }\n\n    /// @dev This function HAS to be called as soon as the transaction flow enters an announce function.\n    function _prepareAnnouncementOrder() internal returns (uint64 executableAtTime) {\n        // Settle funding fees to not encounter the `MaxSkewReached` error.\n        // This error could happen if the funding fees are not settled for a long time and the market is skewed long\n        // for a long time.\n        vault.settleFundingFees();\n\n        executableAtTime = uint64(block.timestamp + vault.minExecutabilityAge());\n    }\n\n    /////////////////////////////////////////////\n    //              View Functions             //\n    /////////////////////////////////////////////\n\n    function getLimitOrder(uint256 tokenId) external view returns (FlatcoinStructs.Order memory order) {\n        return _limitOrderClose[tokenId];\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/LimitOrder.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/interfaces/IERC20Upgradeable.sol\";\nimport {SignedMath} from \"openzeppelin-contracts/contracts/utils/math/SignedMath.sol\";\n\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\nimport {OracleModifiers} from \"./abstracts/OracleModifiers.sol\";\nimport {InvariantChecks} from \"./misc/InvariantChecks.sol\";\n\nimport {ILimitOrder} from \"./interfaces/ILimitOrder.sol\";\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {IStableModule} from \"./interfaces/IStableModule.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {IKeeperFee} from \"./interfaces/IKeeperFee.sol\";\n\n/// @title LimitOrder\n/// @author dHEDGE\n/// @notice Module to create limit orders.\ncontract LimitOrder is ILimitOrder, ModuleUpgradeable, ReentrancyGuardUpgradeable, InvariantChecks, OracleModifiers {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeERC20Upgradeable for IStableModule;\n    using SignedMath for int256;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    mapping(uint256 tokenId => FlatcoinStructs.Order order) internal _limitOrderClose;\n\n    /// @notice Function to initialize this contract.\n    function initialize(IFlatcoinVault _vault) external initializer {\n        __Module_init(FlatcoinModuleKeys._LIMIT_ORDER_KEY, _vault);\n        __ReentrancyGuard_init();\n    }\n\n    /////////////////////////////////////////////\n    //         Trader Write Functions          //\n    /////////////////////////////////////////////\n\n    /// @notice Announces a limit order to close a position\n    /// @param tokenId The position to close\n    /// @param priceLowerThreshold The stop-loss price\n    /// @param priceUpperThreshold The profit-take price\n    /// @dev Currently can only be used for closing existing orders\n    ///      The keeper fee will be determined at execution time, and the trader takes this risk.\n    ///      This is because there could be a large time difference between limit order announcement and execution.\n    function announceLimitOrder(uint256 tokenId, uint256 priceLowerThreshold, uint256 priceUpperThreshold) external {\n        uint64 executableAtTime = _prepareAnnouncementOrder();\n        address positionOwner = _checkPositionOwner(tokenId);\n        _checkThresholds(priceLowerThreshold, priceUpperThreshold);\n        uint256 tradeFee = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).getTradeFee(\n            vault.getPosition(tokenId).additionalSize\n        );\n\n        _limitOrderClose[tokenId] = FlatcoinStructs.Order({\n            orderType: FlatcoinStructs.OrderType.LimitClose,\n            orderData: abi.encode(\n                FlatcoinStructs.LimitClose(tokenId, priceLowerThreshold, priceUpperThreshold, tradeFee)\n            ),\n            keeperFee: 0, // Not applicable for limit orders. Keeper fee will be determined at execution time.\n            executableAtTime: executableAtTime\n        });\n\n        // Lock the NFT belonging to this position so that it can't be transferred to someone else.\n        ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).lock(tokenId);\n\n        emit FlatcoinEvents.OrderAnnounced({\n            account: positionOwner,\n            orderType: FlatcoinStructs.OrderType.LimitClose,\n            keeperFee: 0\n        });\n    }\n\n    /// @notice Cancels a limit order\n    /// @param tokenId The position to close\n    function cancelLimitOrder(uint256 tokenId) external {\n        address positionOwner = _checkPositionOwner(tokenId);\n        _checkLimitCloseOrder(tokenId);\n\n        delete _limitOrderClose[tokenId];\n\n        // Unlock the ERC721 position NFT to allow for transfers.\n        ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).unlock(tokenId);\n\n        emit FlatcoinEvents.OrderCancelled({account: positionOwner, orderType: FlatcoinStructs.OrderType.LimitClose});\n    }\n\n    /// @notice Cancel limit order called by other modules\n    /// @dev Used by the LeverageModule to cancel any existing limit order when the position is closed.\n    function cancelExistingLimitOrder(uint256 tokenId) external onlyAuthorizedModule returns (bool cancelled) {\n        if (_limitOrderClose[tokenId].orderType == FlatcoinStructs.OrderType.LimitClose) {\n            delete _limitOrderClose[tokenId];\n\n            cancelled = true;\n\n            // Unlock the ERC721 position NFT to allow for transfers.\n            ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).unlock(tokenId);\n\n            emit FlatcoinEvents.OrderCancelled({\n                account: ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).ownerOf(tokenId),\n                orderType: FlatcoinStructs.OrderType.LimitClose\n            });\n        }\n    }\n\n    /// @notice Function to execute a limit order\n    /// @dev This function is typically called by the keeper\n    function executeLimitOrder(\n        uint256 tokenId,\n        bytes[] calldata priceUpdateData\n    ) external payable nonReentrant updatePythPrice(vault, msg.sender, priceUpdateData) orderInvariantChecks(vault) {\n        _checkLimitCloseOrder(tokenId);\n\n        vault.settleFundingFees();\n\n        _closePosition(tokenId);\n    }\n\n    /////////////////////////////////////////////\n    //           Internal Functions            //\n    /////////////////////////////////////////////\n\n    function _closePosition(uint256 tokenId) internal {\n        ILeverageModule leverageModule = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY));\n        FlatcoinStructs.Order memory order = _limitOrderClose[tokenId];\n        FlatcoinStructs.LimitClose memory _limitOrder = abi.decode(\n            _limitOrderClose[tokenId].orderData,\n            (FlatcoinStructs.LimitClose)\n        );\n        address account = leverageModule.ownerOf(tokenId);\n\n        (uint256 price, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        // Check that the minimum time delay is reached before execution\n        if (block.timestamp < order.executableAtTime)\n            revert FlatcoinErrors.ExecutableTimeNotReached(order.executableAtTime);\n\n        uint256 minFillPrice;\n\n        if (price <= _limitOrder.priceLowerThreshold) {\n            minFillPrice = 0; // can execute below lower limit price threshold\n        } else if (price >= _limitOrder.priceUpperThreshold) {\n            minFillPrice = _limitOrder.priceUpperThreshold;\n        } else {\n            revert FlatcoinErrors.LimitOrderPriceNotInRange(\n                price,\n                _limitOrder.priceLowerThreshold,\n                _limitOrder.priceUpperThreshold\n            );\n        }\n\n        // Delete the order tracker from storage.\n        delete _limitOrderClose[tokenId];\n\n        order.orderData = abi.encode(\n            FlatcoinStructs.AnnouncedLeverageClose({\n                tokenId: tokenId,\n                minFillPrice: minFillPrice,\n                tradeFee: _limitOrder.tradeFee\n            })\n        );\n        order.keeperFee = IKeeperFee(vault.moduleAddress(FlatcoinModuleKeys._KEEPER_FEE_MODULE_KEY)).getKeeperFee();\n        leverageModule.executeClose({account: account, keeper: msg.sender, order: order});\n\n        emit FlatcoinEvents.OrderExecuted({account: account, orderType: order.orderType, keeperFee: order.keeperFee});\n    }\n\n    function _checkPositionOwner(uint256 tokenId) internal view returns (address positionOwner) {\n        positionOwner = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).ownerOf(tokenId);\n\n        if (positionOwner != msg.sender) revert FlatcoinErrors.NotTokenOwner(tokenId, msg.sender);\n    }\n\n    function _checkThresholds(uint256 priceLowerThreshold, uint256 priceUpperThreshold) internal pure {\n        if (priceLowerThreshold >= priceUpperThreshold)\n            revert FlatcoinErrors.InvalidThresholds(priceLowerThreshold, priceUpperThreshold);\n    }\n\n    function _checkLimitCloseOrder(uint256 tokenId) internal view {\n        FlatcoinStructs.Order memory _limitOrder = _limitOrderClose[tokenId];\n\n        if (_limitOrder.orderType != FlatcoinStructs.OrderType.LimitClose)\n            revert FlatcoinErrors.LimitOrderInvalid(tokenId);\n    }\n\n    /// @dev This function HAS to be called as soon as the transaction flow enters an announce function.\n    function _prepareAnnouncementOrder() internal returns (uint64 executableAtTime) {\n        // Settle funding fees to not encounter the `MaxSkewReached` error.\n        // This error could happen if the funding fees are not settled for a long time and the market is skewed long\n        // for a long time.\n        vault.settleFundingFees();\n\n        executableAtTime = uint64(block.timestamp + vault.minExecutabilityAge());\n    }\n\n    /////////////////////////////////////////////\n    //              View Functions             //\n    /////////////////////////////////////////////\n\n    function getLimitOrder(uint256 tokenId) external view returns (FlatcoinStructs.Order memory order) {\n        return _limitOrderClose[tokenId];\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/LeverageModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {SafeCastUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/math/SafeCastUpgradeable.sol\";\nimport {ERC721LockableEnumerableUpgradeable} from \"./misc/ERC721LockableEnumerableUpgradeable.sol\";\n\nimport {DecimalMath} from \"./libraries/DecimalMath.sol\";\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {ILiquidationModule} from \"./interfaces/ILiquidationModule.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {IPointsModule} from \"./interfaces/IPointsModule.sol\";\nimport {ILimitOrder} from \"./interfaces/ILimitOrder.sol\";\n\n/// @title LeverageModule\n/// @author dHEDGE\n/// @notice Contains functions to create/manage leverage positions.\n/// @dev This module shouldn't hold any funds but can direct the vault to transfer funds.\ncontract LeverageModule is ILeverageModule, ModuleUpgradeable, ERC721LockableEnumerableUpgradeable {\n    using SafeCastUpgradeable for *;\n    using DecimalMath for uint256;\n\n    /// @notice ERC721 token ID increment on mint.\n    uint256 public tokenIdNext;\n\n    /// @notice Leverage trading fee. Charged for opening, adjusting or closing a position.\n    /// @dev 1e18 = 100%\n    uint256 public levTradingFee; // Fee for leverage position open/close. 1e18 = 100%\n\n    /// @notice Leverage position criteria limits\n    /// @notice A minimum margin limit adds a cost to create a position and ensures it can be liquidated at high leverage\n    uint256 public marginMin;\n\n    /// @notice Minimum leverage limit ensures that the position is valuable and adds long open interest\n    uint256 public leverageMin;\n\n    /// @notice Maximum leverage limit ensures that the position is safely liquidatable by keepers\n    uint256 public leverageMax;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(\n        IFlatcoinVault _vault,\n        uint256 _levTradingFee,\n        uint256 _marginMin,\n        uint256 _leverageMin,\n        uint256 _leverageMax\n    ) external initializer {\n        __Module_init(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY, _vault);\n        __ERC721_init(\"Flatmoney Leveraged Positions\", \"LEV\");\n\n        setLevTradingFee(_levTradingFee);\n        setLeverageCriteria(_marginMin, _leverageMin, _leverageMax);\n    }\n\n    /////////////////////////////////////////////\n    //         External Write Functions         //\n    /////////////////////////////////////////////\n\n    /// @notice Leverage open function. Mints ERC721 token receipt.\n    /// @dev Has to be used in conjunction with the DelayedOrder module.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param _account The user account which has a pending open leverage order.\n    /// @param _keeper The address of the keeper executing the order.\n    /// @param _order The order to be executed.\n    /// @return _newTokenId The ERC721 token ID of the new leverage position.\n    function executeOpen(\n        address _account,\n        address _keeper,\n        FlatcoinStructs.Order calldata _order\n    ) external whenNotPaused onlyAuthorizedModule returns (uint256 _newTokenId) {\n        // Make sure the oracle price is after the order executability time\n        uint32 maxAge = _getMaxAge(_order.executableAtTime);\n\n        FlatcoinStructs.AnnouncedLeverageOpen memory announcedOpen = abi.decode(\n            _order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageOpen)\n        );\n\n        // Check that buy price doesn't exceed requested price.\n        (uint256 entryPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice({\n            maxAge: maxAge\n        });\n\n        if (entryPrice > announcedOpen.maxFillPrice)\n            revert FlatcoinErrors.HighSlippage(entryPrice, announcedOpen.maxFillPrice);\n\n        vault.checkSkewMax({additionalSkew: announcedOpen.additionalSize});\n\n        {\n            // The margin change is equal to funding fees accrued to longs and the margin deposited by the trader.\n            vault.updateGlobalPositionData({\n                price: entryPrice,\n                marginDelta: int256(announcedOpen.margin),\n                additionalSizeDelta: int256(announcedOpen.additionalSize)\n            });\n\n            _newTokenId = _mint(_account);\n\n            vault.setPosition(\n                FlatcoinStructs.Position({\n                    lastPrice: entryPrice,\n                    marginDeposited: announcedOpen.margin,\n                    additionalSize: announcedOpen.additionalSize,\n                    entryCumulativeFunding: vault.cumulativeFundingRate()\n                }),\n                _newTokenId\n            );\n        }\n\n        // Check that the new position isn't immediately liquidatable.\n        if (\n            ILiquidationModule(vault.moduleAddress(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY)).canLiquidate(\n                _newTokenId\n            )\n        ) revert FlatcoinErrors.PositionCreatesBadDebt();\n\n        // Mint points\n        IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n        pointsModule.mintLeverageOpen(_account, announcedOpen.additionalSize);\n\n        // Settle the collateral\n        vault.updateStableCollateralTotal(int256(announcedOpen.tradeFee)); // pay the trade fee to stable LPs\n        vault.sendCollateral({to: _keeper, amount: _order.keeperFee}); // pay the keeper their fee\n\n        emit FlatcoinEvents.LeverageOpen(_account, _newTokenId);\n    }\n\n    /// @notice Leverage adjust function.\n    /// @dev Needs to be used in conjunction with the DelayedOrder module.\n    /// @param _account The user account which has a pending adjust leverage order.\n    /// @param _keeper The address of the keeper executing the order.\n    /// @param _order The order to be executed.\n    function executeAdjust(\n        address _account,\n        address _keeper,\n        FlatcoinStructs.Order calldata _order\n    ) external whenNotPaused onlyAuthorizedModule {\n        uint32 maxAge = _getMaxAge(_order.executableAtTime);\n\n        FlatcoinStructs.AnnouncedLeverageAdjust memory announcedAdjust = abi.decode(\n            _order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageAdjust)\n        );\n\n        (uint256 adjustPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice({\n            maxAge: maxAge\n        });\n\n        if (announcedAdjust.additionalSizeAdjustment >= 0) {\n            // Given that the size of a position is being increased, it's necessary to check that\n            // it doesn't exceed the max skew limit.\n            vault.checkSkewMax(uint256(announcedAdjust.additionalSizeAdjustment));\n\n            if (adjustPrice > announcedAdjust.fillPrice)\n                revert FlatcoinErrors.HighSlippage(adjustPrice, announcedAdjust.fillPrice);\n        } else {\n            if (adjustPrice < announcedAdjust.fillPrice)\n                revert FlatcoinErrors.HighSlippage(adjustPrice, announcedAdjust.fillPrice);\n        }\n\n        FlatcoinStructs.Position memory position = vault.getPosition(announcedAdjust.tokenId);\n\n        // Fees come out from the margin if the margin is being reduced or remains unchanged (meaning the size is being modified).\n        int256 marginAdjustment = (announcedAdjust.marginAdjustment > 0)\n            ? announcedAdjust.marginAdjustment\n            : announcedAdjust.marginAdjustment - int256(announcedAdjust.totalFee);\n\n        vault.updateGlobalPositionData({\n            price: adjustPrice,\n            marginDelta: marginAdjustment,\n            additionalSizeDelta: announcedAdjust.additionalSizeAdjustment\n        });\n\n        int256 cumulativeFunding = vault.cumulativeFundingRate();\n\n        // This accounts for the profit loss and funding fees accrued till now.\n        uint256 newMargin = (marginAdjustment +\n            PerpMath\n                ._getPositionSummary({position: position, nextFundingEntry: cumulativeFunding, price: adjustPrice})\n                .marginAfterSettlement).toUint256();\n\n        uint256 newAdditionalSize = (int256(position.additionalSize) + announcedAdjust.additionalSizeAdjustment)\n            .toUint256();\n\n        // Check that the new position isn't immediately liquidatable.\n        if (\n            newMargin <=\n            ILiquidationModule(vault.moduleAddress(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY)).getLiquidationMargin(\n                newAdditionalSize,\n                adjustPrice\n            )\n        ) revert FlatcoinErrors.PositionCreatesBadDebt();\n\n        // Check that the leverage isn't too high.\n        checkLeverageCriteria(newMargin, newAdditionalSize);\n\n        vault.setPosition(\n            FlatcoinStructs.Position({\n                lastPrice: adjustPrice,\n                marginDeposited: newMargin,\n                additionalSize: newAdditionalSize,\n                entryCumulativeFunding: cumulativeFunding\n            }),\n            announcedAdjust.tokenId\n        );\n\n        // Unlock the position token to allow for transfers.\n        _unlock(announcedAdjust.tokenId);\n\n        // Mint points.\n        if (announcedAdjust.additionalSizeAdjustment > 0) {\n            address positionOwner = ownerOf(announcedAdjust.tokenId);\n            IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n\n            pointsModule.mintLeverageOpen(positionOwner, uint256(announcedAdjust.additionalSizeAdjustment));\n        }\n\n        if (announcedAdjust.tradeFee > 0) vault.updateStableCollateralTotal(int256(announcedAdjust.tradeFee));\n\n        // Sending keeper fee from order contract to the executor.\n        vault.sendCollateral({to: _keeper, amount: _order.keeperFee});\n\n        if (announcedAdjust.marginAdjustment < 0) {\n            // We send the user that much margin they requested during announceLeverageAdjust().\n            // However their remaining margin is reduced by the fees.\n            // It is accounted in announceLeverageAdjust().\n            uint256 marginToWithdraw = uint256(announcedAdjust.marginAdjustment * -1);\n\n            // Withdrawing margin from the vault and sending it to the user.\n            vault.sendCollateral({to: _account, amount: marginToWithdraw});\n        }\n\n        emit FlatcoinEvents.LeverageAdjust(announcedAdjust.tokenId);\n    }\n\n    /// @notice Leverage close function.\n    /// @dev Needs to be used in conjunction with the DelayedOrder module.\n    /// @param _account The user account which has a pending close leverage order.\n    /// @param _keeper The address of the keeper executing the order.\n    /// @param _order The order to be executed.\n    function executeClose(\n        address _account,\n        address _keeper,\n        FlatcoinStructs.Order calldata _order\n    ) external whenNotPaused onlyAuthorizedModule returns (int256 settledMargin) {\n        FlatcoinStructs.AnnouncedLeverageClose memory announcedClose = abi.decode(\n            _order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageClose)\n        );\n        FlatcoinStructs.Position memory position = vault.getPosition(announcedClose.tokenId);\n\n        // Make sure the oracle price is after the order executability time\n        uint32 maxAge = _getMaxAge(_order.executableAtTime);\n\n        // check that sell price doesn't exceed requested price\n        (uint256 exitPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice({\n            maxAge: maxAge\n        });\n        if (exitPrice < announcedClose.minFillPrice)\n            revert FlatcoinErrors.HighSlippage(exitPrice, announcedClose.minFillPrice);\n\n        uint256 totalFee;\n        {\n            FlatcoinStructs.PositionSummary memory positionSummary = PerpM"
    }
  ]
}