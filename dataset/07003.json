{
  "Title": "[H-05] `_distributeProfit` will use the stale `globalIC.swingTraderCollateralDeficit()/swingTraderCollateralRatio()`, which will result in incorrect profit distribution",
  "Content": "\nThe `\\_distributeProfit()` (called by handleProfit()) will use `globalIC.swingTraderCollateralDeficit()/swingTraderCollateralRatio()` when distributing profits, and the latest `globalIC.swingTraderCollateralDeficit()/swingTraderCollateralRatio()` needs to be used to ensure that profits are distributed correctly.\n\n```solidity\n    uint256 globalSwingTraderDeficit = (maltDataLab.maltToRewardDecimals(\n      globalIC.swingTraderCollateralDeficit()\n    ) * maltDataLab.priceTarget()) / (10**collateralToken.decimals());\n\n    // this is already in collateralToken.decimals()\n    uint256 lpCut;\n    uint256 swingTraderCut;\n\n    if (globalSwingTraderDeficit == 0) {\n      lpCut = distributeCut;\n    } else {\n      uint256 runwayDeficit = rewardThrottle.runwayDeficit();\n\n      if (runwayDeficit == 0) {\n        swingTraderCut = distributeCut;\n      } else {\n        uint256 totalDeficit = runwayDeficit + globalSwingTraderDeficit;\n```\n\nHowever, the two calls to handleProfit in the contract do not call syncGlobalCollateral to synchronize the data in globalIC.\n\nsyncGlobalCollateral will use the data in `getCollateralizedMalt()`, including the collateralToken balance in overflowPool/swingTraderManager/liquidityExtension and the malt balance in swingTraderManager.\n\n      function syncGlobalCollateral() public onlyActive {\n        globalIC.sync(getCollateralizedMalt());\n      }\n\n      function getCollateralizedMalt() public view returns (PoolCollateral memory) {\n        uint256 target = maltDataLab.priceTarget(); // 是否选用  getActualPriceTarget()\n\n        uint256 unity = 10**collateralToken.decimals();\n\n        // Convert all balances to be denominated in units of Malt target price\n        uint256 overflowBalance = maltDataLab.rewardToMaltDecimals((collateralToken.balanceOf(\n          address(overflowPool)\n        ) * unity) / target);\n        uint256 liquidityExtensionBalance = (collateralToken.balanceOf(\n          address(liquidityExtension)\n        ) * unity) / target;\n        (\n          uint256 swingTraderMaltBalance,\n          uint256 swingTraderBalance\n        ) = swingTraderManager.getTokenBalances();\n        swingTraderBalance = (swingTraderBalance * unity) / target;\n\n1.  Before handleProfit is called by StabilizerNode.stabilize.\n\n```solidity\n    profitDistributor.handleProfit(rewards);\n```\n\na. checkAuctionFinalization is called to liquidityExtension.allocateBurnBudget, which transfers the collateralToken from liquidityExtension to swingTrader. The increase of collateralToken in swingTrader will make the data in globalIC stale.\n\n```solidity\nfunction allocateBurnBudget(uint256 amount)\n    external\n    onlyRoleMalt(AUCTION_ROLE, \"Must have auction privs\")\n    onlyActive\n    returns (uint256 purchased)\n  {\n    // Send the burnable amount to the swing trader so it can be used to burn more malt if required\n    require(\n      collateralToken.balanceOf(address(this)) >= amount,\n      \"LE: Insufficient balance\"\n    );\n    collateralToken.safeTransfer(address(swingTrader), amount);\n\n    emit AllocateBurnBudget(amount);\n  }\n```\n\nb. swingTraderManager.sellMalt will exchange malt for collateralToken, and the increase of collateralToken in swingTrader will also make the data in globalIC stale.\n\n```solidity\n    uint256 swingAmount = swingTraderManager.sellMalt(tradeSize);\n```\n\n2.  Before SwingTrader.sellMalt is called to handleProfit.\n\n```solidity\n  function _handleProfitDistribution(uint256 profit) internal virtual {\n    if (profit != 0) {\n      collateralToken.safeTransfer(address(profitDistributor), profit);\n      profitDistributor.handleProfit(profit);\n    }\n  }\n```\n\na. dexHandler.sellMalt will exchange malt for collateralToken, and the increase of collateralToken in swingTrader will also make the data in globalIC stale.\n\n```solidity\n    malt.safeTransfer(address(dexHandler), maxAmount);\n    uint256 rewards = dexHandler.sellMalt(maxAmount, 10000);\n\n```\n\nOne obvious effect is that as the collateralToken in swingTrader increases, collateral.swingTrade will be smaller than it actually is, and the result of `globalIC.swingTraderCollateralDeficit()` will be larger than it should be.\n\n```solidity\n  function swingTraderCollateralDeficit() public view returns (uint256) {\n    // Note that collateral.swingTrader is already denominated in malt.decimals()\n    uint256 maltSupply = malt.totalSupply();\n    uint256 collateral = collateral.swingTrader; // gas\n\n    if (collateral >= maltSupply) {\n      return 0;\n    }\n\n    return maltSupply - collateral;\n  }\n```\n\nthus making lpCut larger:\n\n```solidity\n    uint256 globalSwingTraderDeficit = (maltDataLab.maltToRewardDecimals(\n      globalIC.swingTraderCollateralDeficit()\n    ) * maltDataLab.priceTarget()) / (10**collateralToken.decimals());\n\n    // this is already in collateralToken.decimals()\n    uint256 lpCut;\n    uint256 swingTraderCut;\n\n    if (globalSwingTraderDeficit == 0) {\n      lpCut = distributeCut;\n    } else {\n      uint256 runwayDeficit = rewardThrottle.runwayDeficit();\n\n      if (runwayDeficit == 0) {\n        swingTraderCut = distributeCut;\n      } else {\n        uint256 totalDeficit = runwayDeficit + globalSwingTraderDeficit;\n\n        uint256 globalSwingTraderRatio = maltDataLab.maltToRewardDecimals(\n          globalIC.swingTraderCollateralRatio()\n        );\n\n        // Already in collateralToken.decimals\n        uint256 poolSwingTraderRatio = impliedCollateralService\n          .swingTraderCollateralRatio();\n\n        if (poolSwingTraderRatio < globalSwingTraderRatio) {\n          swingTraderCut = (distributeCut * swingTraderPreferenceBps) / 10000;\n          lpCut = distributeCut - swingTraderCut;\n        } else {\n          lpCut =\n            (((distributeCut * runwayDeficit) / totalDeficit) *\n              (10000 - lpThrottleBps)) /\n            10000;\n```\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/ProfitDistributor.sol#L164-L184> \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L423-L424> \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTrader.sol#L176-L181>\n\n### Recommended Mitigation Steps\n\nCall syncGlobalCollateral to synchronize the data in globalIC before calling handleProfit.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/9)**\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2023-02-malt-protocol-versus-contest",
  "Code": [
    {
      "filename": "contracts/StabilityPod/ProfitDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"openzeppelin/token/ERC20/ERC20.sol\";\nimport \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IRewardThrottle.sol\";\nimport \"../interfaces/ILiquidityExtension.sol\";\nimport \"../interfaces/IMaltDataLab.sol\";\nimport \"../interfaces/IAuction.sol\";\nimport \"../interfaces/IBurnMintableERC20.sol\";\nimport \"../interfaces/IGlobalImpliedCollateralService.sol\";\nimport \"../interfaces/IImpliedCollateralService.sol\";\nimport \"../StabilizedPoolExtensions/StabilizedPoolUnit.sol\";\nimport \"../StabilizedPoolExtensions/LiquidityExtensionExtension.sol\";\nimport \"../StabilizedPoolExtensions/RewardThrottleExtension.sol\";\nimport \"../StabilizedPoolExtensions/SwingTraderExtension.sol\";\nimport \"../StabilizedPoolExtensions/ImpliedCollateralServiceExtension.sol\";\nimport \"../StabilizedPoolExtensions/GlobalICExtension.sol\";\nimport \"../StabilizedPoolExtensions/DataLabExtension.sol\";\nimport \"../StabilizedPoolExtensions/AuctionExtension.sol\";\n\n/// @title Profit Distributor\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Any profit generated by the pool is pushed here and then sent to where it needs to go\ncontract ProfitDistributor is\n  StabilizedPoolUnit,\n  LiquidityExtensionExtension,\n  RewardThrottleExtension,\n  SwingTraderExtension,\n  ImpliedCollateralServiceExtension,\n  GlobalICExtension,\n  DataLabExtension,\n  AuctionExtension\n{\n  using SafeERC20 for ERC20;\n\n  address public dao;\n  address payable public treasury;\n\n  uint256 public daoRewardCutBps;\n  uint256 public distributeBps = 9200; // 92%\n  uint256 public swingTraderPreferenceBps = 8000; // 80% to ST when pool is underperforming\n  uint256 public lpThrottleBps = 2500; // 25%\n\n  uint256 public maxLEContributionBps = 7000;\n\n  event SetDaoCut(uint256 daoCut);\n  event SetDao(address dao);\n  event RewardDistribution(\n    uint256 swingTraderCut,\n    uint256 lpCut,\n    uint256 daoCut,\n    uint256 treasuryCut\n  );\n  event SetTreasury(address newTreasury);\n  event SetMaxContribution(uint256 maxContribution);\n  event SetLpThrottleBps(uint256 bps);\n  event SetSwingTraderPreferenceBps(uint256 bps);\n  event SetDistributeBps(uint256 bps);\n\n  constructor(\n    address timelock,\n    address repository,\n    address poolFactory,\n    address _dao,\n    address payable _treasury\n  ) StabilizedPoolUnit(timelock, repository, poolFactory) {\n    require(_treasury != address(0), \"StabilizerNode: Treasury addr(0)\");\n    require(_dao != address(0), \"StabilizerNode: DAO addr(0)\");\n\n    treasury = _treasury;\n    dao = _dao;\n  }\n\n  /// @notice Admin only method that can only be called once and will set up all the initial contract properties\n  /// @param _malt The address of an instance of Malt token\n  /// @param _collateralToken The address of an instance of Collateral Token ERC20\n  /// @param _globalIC The address of an instance of GlobalImpliedCollateralService\n  /// @param _rewardThrottle The address of an instance of RewardThrottle\n  /// @param _swingTrader The address of an instance of SwingTrader\n  /// @param _liquidityExtension The address of an instance of LiquidityExtension\n  /// @param _auction The address of an instance of Auction\n  /// @param _maltDataLab The address of an instance of MaltDataLab\n  /// @param _impliedCollateralService The address of an instance of ImpliedCollateralService\n  function setupContracts(\n    address _malt,\n    address _collateralToken,\n    address _globalIC,\n    address _rewardThrottle,\n    address _swingTrader,\n    address _liquidityExtension,\n    address _auction,\n    address _maltDataLab,\n    address _impliedCollateralService,\n    address pool\n  ) external onlyRoleMalt(POOL_FACTORY_ROLE, \"Must have pool factory role\") {\n    require(!contractActive, \"StabilizerNode: Already setup\");\n    require(_malt != address(0), \"ProfitDist: Malt addr(0)\");\n    require(_collateralToken != address(0), \"ProfitDist: Reward addr(0)\");\n    require(_globalIC != address(0), \"ProfitDist: GlobalIC addr(0)\");\n    require(_rewardThrottle != address(0), \"StabilizerNode: Throttle addr(0)\");\n    require(_swingTrader != address(0), \"StabilizerNode: Swing addr(0)\");\n    require(_liquidityExtension != address(0), \"StabilizerNode: LE addr(0)\");\n    require(_auction != address(0), \"StabilizerNode: Auction addr(0)\");\n    require(_maltDataLab != address(0), \"StabilizerNode: MaltDataLab addr(0)\");\n    require(\n      _impliedCollateralService != address(0),\n      \"StabilizerNode: ImpColSvc addr(0)\"\n    );\n\n    contractActive = true;\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    globalIC = IGlobalImpliedCollateralService(_globalIC);\n    rewardThrottle = IRewardThrottle(_rewardThrottle);\n    swingTrader = ISwingTrader(_swingTrader);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    auction = IAuction(_auction);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    impliedCollateralService = IImpliedCollateralService(\n      _impliedCollateralService\n    );\n\n    (, address updater, ) = poolFactory.getPool(pool);\n    _setPoolUpdater(updater);\n  }\n\n  /// @notice Handles distributing collateralToken profit to LPs etc\n  /// @param profit The amount of profit to be distributed\n  /// @dev It is assumed that the profit is sent here first before handleProfit is called. The balance is verified before proceeding\n  function handleProfit(uint256 profit) external onlyActive {\n    uint256 balance = collateralToken.balanceOf(address(this));\n    require(profit <= balance, \"ProfitDist: Insufficient balance\");\n\n    _distributeProfit(profit);\n  }\n\n  function _distributeProfit(uint256 rewarded) internal {\n    if (rewarded == 0) {\n      return;\n    }\n    rewarded = _replenishLiquidityExtension(rewarded);\n    if (rewarded == 0) {\n      return;\n    }\n    // Ensure starting at 0\n    collateralToken.safeApprove(address(auction), 0);\n    collateralToken.safeApprove(address(auction), rewarded);\n    rewarded = auction.allocateArbRewards(rewarded);\n    // Reset approval\n    collateralToken.safeApprove(address(auction), 0);\n\n    if (rewarded == 0) {\n      return;\n    }\n\n    uint256 distributeCut = (rewarded * distributeBps) / 10000;\n    uint256 daoCut = (distributeCut * daoRewardCutBps) / 10000;\n    distributeCut -= daoCut;\n\n    // globaIC value comes back in malt.decimals(). Convert to collateralToken.decimals\n    uint256 globalSwingTraderDeficit = (maltDataLab.maltToRewardDecimals(\n      globalIC.swingTraderCollateralDeficit()\n    ) * maltDataLab.priceTarget()) / (10**collateralToken.decimals());\n\n    // this is already in collateralToken.decimals()\n    uint256 lpCut;\n    uint256 swingTraderCut;\n\n    if (globalSwingTraderDeficit == 0) {\n      lpCut = distributeCut;\n    } else {\n      uint256 runwayDeficit = rewardThrottle.runwayDeficit();\n\n      if (runwayDeficit == 0) {\n        swingTraderCut = distributeCut;\n      } else {\n        uint256 totalDeficit = runwayDeficit + globalSwingTraderDeficit;\n\n        uint256 globalSwingTraderRatio = maltDataLab.maltToRewardDecimals(\n          globalIC.swingTraderCollateralRatio()\n        );\n\n        // Already in collateralToken.decimals\n        uint256 poolSwingTraderRatio = impliedCollateralService\n          .swingTraderCollateralRatio();\n\n        if (poolSwingTraderRatio < globalSwingTraderRatio) {\n          swingTraderCut = (distributeCut * swingTraderPreferenceBps) / 10000;\n          lpCut = distributeCut - swingTraderCut;\n        } else {\n          lpCut =\n            (((distributeCut * runwayDeficit) / totalDeficit) *\n              (10000 - lpThrottleBps)) /\n            10000;\n          swingTraderCut = distributeCut - lpCut;\n        }\n      }\n    }\n\n    // Treasury gets paid after everyone else\n    uint256 treasuryCut = rewarded - daoCut - lpCut - swingTraderCut;\n\n    assert(treasuryCut <= rewarded);\n\n    if (swingTraderCut > 0) {\n      collateralToken.safeTransfer(address(swingTrader), swingTraderCut);\n    }\n\n    if (treasuryCut > 0) {\n      collateralToken.safeTransfer(treasury, treasuryCut);\n    }\n\n    if (daoCut > 0) {\n      collateralToken.safeTransfer(dao, daoCut);\n    }\n\n    if (lpCut > 0) {\n      collateralToken.safeTransfer(address(rewardThrottle), lpCut);\n      rewardThrottle.handleReward();\n    }\n\n    emit RewardDistribution(swingTraderCut, lpCut, daoCut, treasuryCut);\n  }\n\n  function _replenishLiquidityExtension(uint256 rewards)\n    internal\n    returns (uint256 remaining)\n  {\n    if (rewards == 0) {\n      return rewards;\n    }\n\n    (uint256 deficit, ) = liquidityExtension.collateralDeficit();\n\n    if (deficit == 0) {\n      return rewards;\n    }\n\n    uint256 maxContrib = (rewards * maxLEContributionBps) / 10000;\n\n    if (deficit >= maxContrib) {\n      collateralToken.safeTransfer(address(liquidityExtension), maxContrib);\n      return rewards - maxContrib;\n    }\n\n    collateralToken.safeTransfer(address(liquidityExtension), deficit);\n\n    return rewards - deficit;\n  }\n\n  /// @notice Admin only method for setting the cut of profit that goes to the DAO\n  /// @param _daoCut The % of profit to be sent to the DAO. Denominated in basis points ie 100 = 1%\n  function setDaoCut(uint256 _daoCut)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_daoCut <= 10000, \"Reward cut must be <= 100%\");\n    daoRewardCutBps = _daoCut;\n\n    emit SetDaoCut(_daoCut);\n  }\n\n  /// @notice Admin only method for setting the preference for sending to swing trader when local pool collateral ratio is less than global ratio\n  /// @param _pref The % of profit to be sent to SwingTrader. Represented in basis points ie 100 = 1%\n  function setSwingTraderPreferenceBps(uint256 _pref)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_pref <= 10000, \"Must be <= 100%\");\n    swingTraderPreferenceBps = _pref;\n\n    emit SetSwingTraderPreferenceBps(_pref);\n  }\n\n  /// @notice Admin only method for setting the amount LP share of profit should be throttled\n  /// @dev The lp throttle is used to skew system in favor of replenishing SwingTrader when all else is equal\n  /// @param _bps The % of LP profit that should be throttled represented in basis points ie 100 = 1%\n  function setLpThrottleBps(uint256 _bps)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_bps <= 10000, \"Must be <= 100%\");\n    lpThrottleBps = _bps;\n\n    emit SetLpThrottleBps(_bps);\n  }\n\n  /// @notice Admin only method for setting the amount of profit that should be distributed vs retained for protocol development\n  /// @param _bps The % of profit that should be distributed represented in basis points ie 100 = 1%\n  function setDistributeBps(uint256 _bps)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_bps <= 10000, \"Must be <= 100%\");\n    distributeBps = _bps;\n\n    emit SetDistributeBps(_bps);\n  }\n\n  /// @notice Admin only method for setting max % of profit that can be used to replenish LiquidityExtension\n  /// @param _maxContribution The % of profit that can be used represented in basis points ie 100 = 1%\n  function setMaxLEContribution(uint256 _maxContribution)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(\n      _maxContribution != 0 && _maxContribution <= 10000,\n      \"Must be between 0 and 100\"\n    );\n\n    maxLEContributionBps = _maxContribution;\n    emit SetMaxContribution(_maxContribution);\n  }\n\n  /*\n   * Contract Pointers\n   */\n  /// @notice Admin only method for setting the address of the Malt DAO\n  /// @param _dao The contract address of the Malt DAO\n  function setDAO(address _dao)\n    external\n    onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater role\")\n  {\n    require(_dao != address(0), \"Not address 0\");\n    dao = _dao;\n    emit SetDao(_dao);\n  }\n\n  /// @notice Admin only method for setting the address of the treasury\n  /// @param _newTreasury The address of the treasury multisig\n  function setTreasury(address payable _newTreasury)\n    external\n    onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater role\")\n  {\n    treasury = _newTreasury;\n    emit SetTreasury(_newTreasury);\n  }\n\n  function _accessControl()\n    internal\n    override(\n      LiquidityExtensionExtension,\n      RewardThrottleExtension,\n      SwingTraderExtension,\n      ImpliedCollateralServiceExtension,\n      GlobalICExtension,\n      DataLabExtension,\n      AuctionExtension\n    )\n  {\n    _onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater role\");\n  }\n}"
    },
    {
      "filename": "contracts/StabilityPod/StabilizerNode.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"openzeppelin/token/ERC20/ERC20.sol\";\nimport \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin/security/Pausable.sol\";\n\nimport \"../StabilizedPoolExtensions/StabilizedPoolUnit.sol\";\nimport \"../StabilizedPoolExtensions/AuctionExtension.sol\";\nimport \"../StabilizedPoolExtensions/DexHandlerExtension.sol\";\nimport \"../StabilizedPoolExtensions/DataLabExtension.sol\";\nimport \"../StabilizedPoolExtensions/ProfitDistributorExtension.sol\";\nimport \"../StabilizedPoolExtensions/SwingTraderManagerExtension.sol\";\nimport \"../StabilizedPoolExtensions/ImpliedCollateralServiceExtension.sol\";\nimport \"../interfaces/IAuction.sol\";\nimport \"../interfaces/IMaltDataLab.sol\";\nimport \"../interfaces/ITimekeeper.sol\";\nimport \"../interfaces/IRewardThrottle.sol\";\nimport \"../interfaces/IImpliedCollateralService.sol\";\nimport \"../interfaces/IDexHandler.sol\";\nimport \"../interfaces/ISwingTrader.sol\";\nimport \"../interfaces/IBurnMintableERC20.sol\";\nimport \"../interfaces/ISupplyDistributionController.sol\";\nimport \"../interfaces/IAuctionStartController.sol\";\nimport \"../interfaces/IProfitDistributor.sol\";\nimport \"../interfaces/IGlobalImpliedCollateralService.sol\";\n\n/// @title Stabilizer Node\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The backbone of the Malt stability system. In charge of triggering actions to stabilize price\ncontract StabilizerNode is\n  StabilizedPoolUnit,\n  AuctionExtension,\n  DexHandlerExtension,\n  DataLabExtension,\n  ProfitDistributorExtension,\n  SwingTraderManagerExtension,\n  ImpliedCollateralServiceExtension,\n  Pausable\n{\n  using SafeERC20 for ERC20;\n\n  uint256 internal stabilizeWindowEnd;\n  uint256 public stabilizeBackoffPeriod = 5 * 60; // 5 minutes\n  uint256 public upperStabilityThresholdBps = 100; // 1%\n  uint256 public lowerStabilityThresholdBps = 100;\n  uint256 public priceAveragePeriod = 5 minutes;\n  uint256 public fastAveragePeriod = 30; // 30 seconds\n  uint256 public overrideDistanceBps = 200; // 2%\n  uint256 public callerRewardCutBps = 30; // 0.3%\n\n  uint256 public expansionDampingFactor = 1;\n\n  uint256 public defaultIncentive = 100; // in Malt\n  uint256 public trackingIncentive = 20; // in 100ths of a Malt\n\n  uint256 public upperBandLimitBps = 100000; // 1000%\n  uint256 public lowerBandLimitBps = 1000; // 10%\n  uint256 public sampleSlippageBps = 2000; // 20%\n  uint256 public skipAuctionThreshold;\n  uint256 public preferAuctionThreshold;\n\n  uint256 public lastStabilize;\n  uint256 public lastTracking;\n  uint256 public trackingBackoff = 30; // 30 seconds\n  uint256 public primedBlock;\n  uint256 public primedWindow = 10; // blocks\n\n  bool internal trackAfterStabilize = true;\n  bool public onlyStabilizeToPeg = false;\n  bool public usePrimedWindow;\n\n  address public supplyDistributionController;\n  address public auctionStartController;\n\n  event MintMalt(uint256 amount);\n  event Stabilize(uint256 timestamp, uint256 exchangeRate);\n  event SetStabilizeBackoff(uint256 period);\n  event SetDefaultIncentive(uint256 incentive);\n  event SetTrackingIncentive(uint256 incentive);\n  event SetExpansionDamping(uint256 amount);\n  event SetPriceAveragePeriod(uint256 period);\n  event SetOverrideDistance(uint256 distance);\n  event SetFastAveragePeriod(uint256 period);\n  event SetStabilityThresholds(uint256 upper, uint256 lower);\n  event SetSupplyDistributionController(address _controller);\n  event SetAuctionStartController(address _controller);\n  event SetBandLimits(uint256 _upper, uint256 _lower);\n  event SetSlippageBps(uint256 _slippageBps);\n  event SetSkipAuctionThreshold(uint256 _skipAuctionThreshold);\n  event SetEmergencyMintThresholdBps(uint256 thresholdBps);\n  event Tracking();\n  event SetTrackingBackoff(uint256 backoff);\n  event SetCallerCut(uint256 callerCutBps);\n  event SetPreferAuctionThreshold(uint256 preferAuctionThreshold);\n  event SetTrackAfterStabilize(bool track);\n  event SetOnlyStabilizeToPeg(bool stabilize);\n  event SetPrimedWindow(uint256 primedWindow);\n  event SetUsePrimedWindow(bool usePrimedWindow);\n\n  constructor(\n    address timelock,\n    address repository,\n    address poolFactory,\n    uint256 _skipAuctionThreshold,\n    uint256 _preferAuctionThreshold\n  ) StabilizedPoolUnit(timelock, repository, poolFactory) {\n    skipAuctionThreshold = _skipAuctionThreshold;\n    preferAuctionThreshold = _preferAuctionThreshold;\n\n    lastStabilize = block.timestamp;\n  }\n\n  function setupContracts(\n    address _malt,\n    address _collateralToken,\n    address _dexHandler,\n    address _maltDataLab,\n    address _impliedCollateralService,\n    address _auction,\n    address _swingTraderManager,\n    address _profitDistributor,\n    address pool\n  ) external onlyRoleMalt(POOL_FACTORY_ROLE, \"Must have pool factory role\") {\n    require(!contractActive, \"StabilizerNode: Already setup\");\n    require(_malt != address(0), \"StabilizerNode: Malt addr(0)\");\n    require(_collateralToken != address(0), \"StabilizerNode: Col addr(0)\");\n    require(_dexHandler != address(0), \"StabilizerNode: DexHandler addr(0)\");\n    require(_maltDataLab != address(0), \"StabilizerNode: DataLab addr(0)\");\n    require(\n      _swingTraderManager != address(0),\n      \"StabilizerNode: Swing Manager addr(0)\"\n    );\n    require(\n      _impliedCollateralService != address(0),\n      \"StabilizerNode: ImpCol addr(0)\"\n    );\n    require(_auction != address(0), \"StabilizerNode: Auction addr(0)\");\n    require(\n      _profitDistributor != address(0),\n      \"StabilizerNode: ProfitDistributor addr(0)\"\n    );\n\n    contractActive = true;\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    dexHandler = IDexHandler(_dexHandler);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    swingTraderManager = ISwingTrader(_swingTraderManager);\n    impliedCollateralService = IImpliedCollateralService(\n      _impliedCollateralService\n    );\n    auction = IAuction(_auction);\n    profitDistributor = IProfitDistributor(_profitDistributor);\n\n    (, address updater, ) = poolFactory.getPool(pool);\n    _setPoolUpdater(updater);\n  }\n\n  function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {\n    // Ensure data consistency\n    maltDataLab.trackPool();\n\n    // Finalize auction if possible before potentially starting a new one\n    auction.checkAuctionFinalization();\n\n    require(\n      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),\n      \"Can't call stabilize\"\n    );\n    stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;\n\n    // used in 3 location.\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);\n    bool stabilizeToPeg = onlyStabilizeToPeg; // gas\n\n    if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {\n      lastStabilize = block.timestamp;\n      impliedCollateralService.syncGlobalCollateral();\n      return;\n    }\n\n    emit Stabilize(block.timestamp, exchangeRate);\n\n    (uint256 livePrice, ) = dexHandler.maltMarketPrice();\n\n    uint256 priceTarget = maltDataLab.getActualPriceTarget();\n    // The upper and lower bands here avoid any issues with price\n    // descrepency between the TWAP and live market price.\n    // This avoids starting auctions too quickly into a big selloff\n    // and also reduces risk of flashloan vectors\n    address sender = _msgSender();\n    if (exchangeRate > priceTarget) {\n      if (\n        !hasRole(ADMIN_ROLE, sender) &&\n        !hasRole(INTERNAL_WHITELIST_ROLE, sender)\n      ) {\n        uint256 upperBand = exchangeRate +\n          ((exchangeRate * upperBandLimitBps) / 10000);\n        uint256 latestSample = maltDataLab.maltPriceAverage(0);\n        uint256 minThreshold = latestSample -\n          (((latestSample - priceTarget) * sampleSlippageBps) / 10000);\n\n        require(livePrice < upperBand, \"Stabilize: Beyond upper bound\");\n        require(livePrice > minThreshold, \"Stabilize: Slippage threshold\");\n      }\n\n      _distributeSupply(livePrice, priceTarget, stabilizeToPeg);\n    } else {\n      if (\n        !hasRole(ADMIN_ROLE, sender) &&\n        !hasRole(INTERNAL_WHITELIST_ROLE, sender)\n      ) {\n        uint256 lowerBand = exchangeRate -\n          ((exchangeRate * lowerBandLimitBps) / 10000);\n        require(livePrice > lowerBand, \"Stabilize: Beyond lower bound\");\n      }\n\n      uint256 stEntryPrice = maltDataLab.getSwingTraderEntryPrice();\n      if (exchangeRate <= stEntryPrice) {\n        if (_validateSwingTraderTrigger(livePrice, stEntryPrice)) {\n          // Reset primedBlock\n          primedBlock = 0;\n          _triggerSwingTrader(priceTarget, livePrice);\n        }\n      } else {\n        _startAuction(priceTarget);\n      }\n    }\n\n    if (trackAfterStabilize) {\n      maltDataLab.trackPool();\n    }\n    impliedCollateralService.syncGlobalCollateral();\n    lastStabilize = block.timestamp;\n  }\n\n  function endAuctionEarly() external onlyActive whenNotPaused {\n    // This call reverts if the auction isn't ended\n    auction.endAuctionEarly();\n\n    // It hasn't reverted so the auction was ended. Pay the incentive\n    malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n    emit MintMalt(defaultIncentive * (10**malt.decimals()));\n  }\n\n  function trackPool() external onlyActive {\n    require(block.timestamp >= lastTracking + trackingBackoff, \"Too early\");\n    bool success = maltDataLab.trackPool();\n    require(success, \"Too early\");\n    malt.mint(msg.sender, (trackingIncentive * (10**malt.decimals())) / 100); // div 100 because units are cents\n    lastTracking = block.timestamp;\n    emit Tracking();\n  }\n\n  function primedWindowData() public view returns (bool, uint256) {\n    return (usePrimedWindow, primedBlock + primedWindow);\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _stabilityWindowOverride() internal view returns (bool) {\n    address sender = _msgSender();\n    if (\n      hasRole(ADMIN_ROLE, sender) || hasRole(INTERNAL_WHITELIST_ROLE, sender)\n    ) {\n      // Admin can always stabilize\n      return true;\n    }\n    // Must have elapsed at least one period of the moving average before we stabilize again\n    if (block.timestamp < lastStabilize + fastAveragePeriod) {\n      return false;\n    }\n\n    uint256 priceTarget = maltDataLab.getActualPriceTarget();\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(fastAveragePeriod);\n\n    uint256 upperThreshold = (priceTarget * (10000 + overrideDistanceBps)) /\n      10000;\n\n    return exchangeRate >= upperThreshold;\n  }\n\n  function _shouldAdjustSupply(uint256 exchangeRate, bool stabilizeToPeg)\n    internal\n    view\n    returns (bool)\n  {\n    uint256 decimals = collateralToken.decimals();\n    uint256 priceTarget;\n\n    if (stabilizeToPeg) {\n      priceTarget = maltDataLab.priceTarget();\n    } else {\n      priceTarget = maltDataLab.getActualPriceTarget();\n    }\n\n    uint256 upperThreshold = (priceTarget * upperStabilityThresholdBps) / 10000;\n    uint256 lowerThreshold = (priceTarget * lowerStabilityThresholdBps) / 10000;\n\n    return\n      (exchangeRate <= (priceTarget - lowerThreshold) &&\n        !auction.auctionExists(auction.currentAuctionId())) ||\n      exchangeRate >= (priceTarget + upperThreshold);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _validateSwingTraderTrigger(uint256 livePrice, uint256 entryPrice)\n    internal\n    returns (bool)\n  {\n    if (usePrimedWindow) {\n      if (livePrice > entryPrice) {\n        return false;\n      }\n\n      if (block.number > primedBlock + primedWindow) {\n        primedBlock = block.number;\n        malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n        emit MintMalt(defaultIncentive * (10**malt.decimals()));\n        return false;\n      }\n\n      if (primedBlock == block.number) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function _triggerSwingTrader(uint256 priceTarget, uint256 exchangeRate)\n    internal\n  {\n    uint256 decimals = collateralToken.decimals();\n    uint256 unity = 10**decimals;\n    IGlobalImpliedCollateralService globalIC = maltDataLab.globalIC();\n    uint256 icTotal = maltDataLab.maltToRewardDecimals(\n      globalIC.collateralRatio()\n    );\n\n    if (icTotal >= unity) {\n      icTotal = unity;\n    }\n\n    uint256 originalPriceTarget = priceTarget;\n\n    // TODO StabilizerNode.sol these checks won't work when working with pools not pegged to 1 Wed 26 Oct 2022 16:40:25 BST\n    if (exchangeRate < icTotal) {\n      priceTarget = icTotal;\n    }\n\n    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);\n\n    if (purchaseAmount > preferAuctionThreshold) {\n      uint256 capitalUsed = swingTraderManager.buyMalt(purchaseAmount);\n\n      uint256 callerCut = (capitalUsed * callerRewardCutBps) / 10000;\n\n      if (callerCut != 0) {\n        malt.mint(msg.sender, callerCut);\n        emit MintMalt(callerCut);\n      }\n    } else {\n      _startAuction(originalPriceTarget);\n    }\n  }\n\n  function _distributeSupply(\n    uint256 livePrice,\n    uint256 priceTarget,\n    bool stabilizeToPeg\n  ) internal {\n    if (supplyDistributionController != address(0)) {\n      bool success = ISupplyDistributionController(supplyDistributionController)\n        .check();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 pegPrice = maltDataLab.priceTarget();\n\n    uint256 lowerThreshold = (pegPrice * lowerStabilityThresholdBps) / 10000;\n    if (stabilizeToPeg || livePrice >= pegPrice - lowerThreshold) {\n      priceTarget = pegPrice;\n    }\n\n    uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget) /\n      expansionDampingFactor;\n\n    if (tradeSize == 0) {\n      return;\n    }\n\n    uint256 swingAmount = swingTraderManager.sellMalt(tradeSize);\n\n    if (swingAmount >= tradeSize) {\n      return;\n    }\n\n    tradeSize = tradeSize - swingAmount;\n\n    malt.mint(address(dexHandler), tradeSize);\n    emit MintMalt(tradeSize);\n    // Transfer verification ensure any attempt to\n    // sandwhich will trigger stabilize first\n    uint256 rewards = dexHandler.sellMalt(tradeSize, 10000);\n\n    uint256 callerCut = (rewards * callerRewardCutBps) / 10000;\n\n    if (callerCut != 0) {\n      rewards -= callerCut;\n      collateralToken.safeTransfer(msg.sender, callerCut);\n    }\n\n    collateralToken.safeTransfer(address(profitDistributor), rewards);\n\n    profitDistributor.handleProfit(rewards);\n  }\n\n  function _startAuction(uint256 priceTarget) internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController)\n        .checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);\n\n    if (purchaseAmount < skipAuctionThreshold) {\n      return;\n    }\n\n    // TODO StabilizerNode.sol invert priceTarget? Fri 21 Oct 2022 11:02:43 BST\n    bool success = auction.triggerAuction(priceTarget, purchaseAmount);\n\n    if (success) {\n      malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n      emit MintMalt(defaultIncentive * (10**malt.decimals()));\n    }\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n\n  function setStabilizeBackoff(uint256 _period)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Must be greater than 0\");\n    stabilizeBackoffPeriod = _period;\n    emit SetStabilizeBackoff(_period);\n  }\n\n  function setDefaultIncentive(uint256 _incentive)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_incentive != 0 && _incentive <= 1000, \"Incentive out of range\");\n\n    defaultIncentive = _incentive;\n\n    emit SetDefaultIncentive(_incentive);\n  }\n\n  function setTrackingIncentive(uint256 _incentive)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    // Priced in cents. Must be less than 1000 Malt\n    require(_incentive != 0 && _incentive <= 100000, \"Incentive out of range\");\n\n    trackingIncentive = _incentive;\n\n    emit SetTrackingIncentive(_incentive);\n  }\n\n  /// @notice Only callable by Admin address.\n  /// @dev Sets the Expansion Damping units.\n  /// @param amount: Amount to set Expansion Damping units to.\n  function setExpansionDamping(uint256 amount)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(amount > 0, \"No negative damping\");\n\n    expansionDampingFactor = amount;\n    emit SetExpansionDamping(amount);\n  }\n\n  function setStabilityThresholds(uint256 _upper, uint256 _lower)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_upper != 0 && _lower != 0, \"Must be above 0\");\n    require(_lower < 10000, \"Lower to large\");\n\n    upperStabilityThresholdBps = _upper;\n    lowerStabilityThresholdBps = _lower;\n    emit SetStabilityThresholds(_upper, _lower);\n  }\n\n  function setSupplyDistributionController(address _controller)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    supplyDistributionController = _controller;\n    emit SetSupplyDistributionController(_controller);\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n    emit SetAuctionStartController(_controller);\n  }\n\n  function setPriceAveragePeriod(uint256 _period)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    priceAveragePeriod = _period;\n    emit SetPriceAveragePeriod(_period);\n  }\n\n  function setOverrideDistance(uint256 _distance)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(\n      _distance != 0 && _distance < 10000,\n      \"Override must be between 0-100%\"\n    );\n    overrideDistanceBps = _distance;\n    emit SetOverrideDistance(_distance);\n  }\n\n  function setFastAveragePeriod(uint256 _period)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    fastAveragePeriod = _period;\n    emit SetFastAveragePeriod(_period);\n  }\n\n  function setBandLimits(uint256 _upper, uint256 _lower)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_upper != 0 && _lower != 0, \"Cannot have 0 band limit\");\n    upperBandLimitBps = _upper;\n    lowerBandLimitBps = _lower;\n    emit SetBandLimits(_upper, _lower);\n  }\n\n  function setSlippageBps(uint256 _slippageBps)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_slippageBps <= 10000, \"slippage: Must be <= 100%\");\n    sampleSlippageBps = _slippageBps;\n    emit SetSlippageBps(_slippageBps);\n  }\n\n  function setSkipAuctionThreshold(uint256 _skipAuctionThreshold)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    skipAuctionThreshold = _skipAuctionThreshold;\n    emit SetSkipAuctionThreshold(_skipAuctionThreshold);\n  }\n\n  function setPreferAuctionThreshold(uint256 _preferAuctionThreshold)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    preferAuctionThreshold = _preferAuctionThreshold;\n    emit SetPreferAuctionThreshold(_preferAuctionThreshold);\n  }\n\n  function setTrackingBackoff(uint256 _backoff)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_backoff != 0, \"Cannot be 0\");\n    trackingBackoff = _backoff;\n    emit SetTrackingBackoff(_backoff);\n  }\n\n  function setTrackAfterStabilize(bool _track)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    trackAfterStabilize = _track;\n    emit SetTrackAfterStabilize(_track);\n  }\n\n  function setOnlyStabilizeToPeg(bool _stabilize)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    onlyStabilizeToPeg = _stabilize;\n    emit SetOnlyStabilizeToPeg(_stabilize);\n  }\n\n  function setCallerCut(uint256 _callerCut)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_callerCut <= 1000, \"Must be less than 10%\");\n    callerRewardCutBps = _callerCut;\n    emit SetCallerCut(_callerCut);\n  }\n\n  function togglePause()\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    if (paused()) {\n      _unpause();\n    } else {\n      _pause();"
    }
  ]
}