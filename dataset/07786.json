{
  "Title": "[G-07] Gas saving using `immutable`",
  "Content": "\nIt's possible to avoid storage access a save gas using `immutable` keyword for the following variables:\n\nIt's also better to remove the initial values, because they will be set during the constructor.\n\n**Affected source code:**\n\n*   [L2ERC20Bridge.sol:19](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/bridge/L2ERC20Bridge.sol#L19)\n*   [L2ERC20Bridge.sol:23](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/bridge/L2ERC20Bridge.sol#L23)\n*   [L2ERC20Bridge.sol:26](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/bridge/L2ERC20Bridge.sol#L26)\n*   [L2ETHBridge.sol:22](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/bridge/L2ETHBridge.sol#L22)\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-10-zksync-v2-contest",
  "Code": [
    {
      "filename": "zksync/contracts/bridge/L2ERC20Bridge.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\n\nimport \"./interfaces/IL1Bridge.sol\";\nimport \"./interfaces/IL2Bridge.sol\";\nimport \"./interfaces/IL2StandardToken.sol\";\n\nimport \"./L2StandardERC20.sol\";\nimport {L2ContractHelper} from \"../L2ContractHelper.sol\";\n\n/// @author Matter Labs\n/// @notice The \"default\" bridge implementation for the ERC20 tokens.\ncontract L2ERC20Bridge is IL2Bridge {\n    /// @dev The address of the L1 bridge counterpart.\n    address public override l1Bridge;\n\n    /// @dev Contract that store the implementation address for token.\n    /// @dev For more details see https://docs.openzeppelin.com/contracts/3.x/api/proxy#UpgradeableBeacon.\n    UpgradeableBeacon public l2TokenFactory;\n\n    /// @dev Bytecode hash of the proxy for tokens deployed by the bridge.\n    bytes32 l2TokenProxyBytecodeHash;\n\n    /// @dev A mapping l2 token address => l1 token address\n    mapping(address => address) public override l1TokenAddress;\n\n    constructor(\n        address _l1Bridge,\n        bytes32 _l2TokenProxyBytecodeHash,\n        address _governor\n    ) {\n        l1Bridge = _l1Bridge;\n\n        l2TokenProxyBytecodeHash = _l2TokenProxyBytecodeHash;\n        address l2StandardToken = address(new L2StandardERC20{salt: bytes32(0)}());\n        l2TokenFactory = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n        l2TokenFactory.transferOwnership(_governor);\n    }\n\n    /// @notice Finalize the deposit and mint funds\n    /// @param _l1Sender The account address that initiate the deposit on L1\n    /// @param _l2Receiver The account address that would receive minted ether\n    /// @param _l1Token The address of the token that was locked on the L1. Always should be equal to zero (conventional value)\n    /// @param _amount Total amount of tokens deposited from L1\n    /// @param _data The additional data that user can pass with the deposit\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override {\n        // Only L1 bridge counterpart can initiate and finalize the deposit\n        require(msg.sender == l1Bridge, \"mq\");\n\n        address expectedL2Token = l2TokenAddress(_l1Token);\n        if (l1TokenAddress[expectedL2Token] == address(0)) {\n            address deployedToken = _deployL2Token(_l1Token, _data);\n            require(deployedToken == expectedL2Token, \"mt\");\n            l1TokenAddress[expectedL2Token] = _l1Token;\n        }\n\n        IL2StandardToken(expectedL2Token).bridgeMint(_l2Receiver, _amount);\n\n        emit FinalizeDeposit(_l1Sender, _l2Receiver, expectedL2Token, _amount);\n    }\n\n    /// @dev Deploys and initialize the L2 token for the L1 counterpart\n    function _deployL2Token(address _l1Token, bytes calldata _data) internal returns (address) {\n        bytes32 salt = _getCreate2Salt(_l1Token);\n\n        BeaconProxy l2Token = new BeaconProxy{salt: salt}(address(l2TokenFactory), \"\");\n        L2StandardERC20(address(l2Token)).bridgeInitialize(_l1Token, _data);\n\n        return address(l2Token);\n    }\n\n    /// @notice Initiates a withdrawal by burning funds on the contract and sending the message to L1\n    /// where tokens would be unlocked\n    /// @param _l1Receiver The account address that should receive funds on L1\n    /// @param _l2Token The L2 token address which is withdrawn\n    /// @param _amount The total amount of tokens to be withdrawn\n    function withdraw(\n        address _l1Receiver,\n        address _l2Token,\n        uint256 _amount\n    ) external override {\n        IL2StandardToken(_l2Token).bridgeBurn(msg.sender, _amount);\n\n        address l1Token = l1TokenAddress[_l2Token];\n        require(l1Token != address(0), \"yh\");\n\n        bytes memory message = _getL1WithdrawMessage(_l1Receiver, l1Token, _amount);\n        L2ContractHelper.sendMessageToL1(message);\n\n        emit WithdrawalInitiated(msg.sender, _l1Receiver, _l2Token, _amount);\n    }\n\n    /// @dev Encode the message for l2ToL1log sent with withdraw initialization\n    function _getL1WithdrawMessage(\n        address _to,\n        address _l1Token,\n        uint256 _amount\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(IL1Bridge.finalizeWithdrawal.selector, _to, _l1Token, _amount);\n    }\n\n    /// @return Address of an L2 token counterpart\n    function l2TokenAddress(address _l1Token) public view override returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenFactory), \"\"));\n        bytes32 salt = _getCreate2Salt(_l1Token);\n\n        return\n            L2ContractHelper.computeCreate2Address(address(this), salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n\n    /// @dev Convert the L1 token address to the create2 salt of deployed L2 token\n    function _getCreate2Salt(address _l1Token) internal pure returns (bytes32 salt) {\n        salt = bytes32(uint256(uint160(_l1Token)));\n    }\n}"
    },
    {
      "filename": "zksync/contracts/bridge/L2ERC20Bridge.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\n\nimport \"./interfaces/IL1Bridge.sol\";\nimport \"./interfaces/IL2Bridge.sol\";\nimport \"./interfaces/IL2StandardToken.sol\";\n\nimport \"./L2StandardERC20.sol\";\nimport {L2ContractHelper} from \"../L2ContractHelper.sol\";\n\n/// @author Matter Labs\n/// @notice The \"default\" bridge implementation for the ERC20 tokens.\ncontract L2ERC20Bridge is IL2Bridge {\n    /// @dev The address of the L1 bridge counterpart.\n    address public override l1Bridge;\n\n    /// @dev Contract that store the implementation address for token.\n    /// @dev For more details see https://docs.openzeppelin.com/contracts/3.x/api/proxy#UpgradeableBeacon.\n    UpgradeableBeacon public l2TokenFactory;\n\n    /// @dev Bytecode hash of the proxy for tokens deployed by the bridge.\n    bytes32 l2TokenProxyBytecodeHash;\n\n    /// @dev A mapping l2 token address => l1 token address\n    mapping(address => address) public override l1TokenAddress;\n\n    constructor(\n        address _l1Bridge,\n        bytes32 _l2TokenProxyBytecodeHash,\n        address _governor\n    ) {\n        l1Bridge = _l1Bridge;\n\n        l2TokenProxyBytecodeHash = _l2TokenProxyBytecodeHash;\n        address l2StandardToken = address(new L2StandardERC20{salt: bytes32(0)}());\n        l2TokenFactory = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n        l2TokenFactory.transferOwnership(_governor);\n    }\n\n    /// @notice Finalize the deposit and mint funds\n    /// @param _l1Sender The account address that initiate the deposit on L1\n    /// @param _l2Receiver The account address that would receive minted ether\n    /// @param _l1Token The address of the token that was locked on the L1. Always should be equal to zero (conventional value)\n    /// @param _amount Total amount of tokens deposited from L1\n    /// @param _data The additional data that user can pass with the deposit\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override {\n        // Only L1 bridge counterpart can initiate and finalize the deposit\n        require(msg.sender == l1Bridge, \"mq\");\n\n        address expectedL2Token = l2TokenAddress(_l1Token);\n        if (l1TokenAddress[expectedL2Token] == address(0)) {\n            address deployedToken = _deployL2Token(_l1Token, _data);\n            require(deployedToken == expectedL2Token, \"mt\");\n            l1TokenAddress[expectedL2Token] = _l1Token;\n        }\n\n        IL2StandardToken(expectedL2Token).bridgeMint(_l2Receiver, _amount);\n\n        emit FinalizeDeposit(_l1Sender, _l2Receiver, expectedL2Token, _amount);\n    }\n\n    /// @dev Deploys and initialize the L2 token for the L1 counterpart\n    function _deployL2Token(address _l1Token, bytes calldata _data) internal returns (address) {\n        bytes32 salt = _getCreate2Salt(_l1Token);\n\n        BeaconProxy l2Token = new BeaconProxy{salt: salt}(address(l2TokenFactory), \"\");\n        L2StandardERC20(address(l2Token)).bridgeInitialize(_l1Token, _data);\n\n        return address(l2Token);\n    }\n\n    /// @notice Initiates a withdrawal by burning funds on the contract and sending the message to L1\n    /// where tokens would be unlocked\n    /// @param _l1Receiver The account address that should receive funds on L1\n    /// @param _l2Token The L2 token address which is withdrawn\n    /// @param _amount The total amount of tokens to be withdrawn\n    function withdraw(\n        address _l1Receiver,\n        address _l2Token,\n        uint256 _amount\n    ) external override {\n        IL2StandardToken(_l2Token).bridgeBurn(msg.sender, _amount);\n\n        address l1Token = l1TokenAddress[_l2Token];\n        require(l1Token != address(0), \"yh\");\n\n        bytes memory message = _getL1WithdrawMessage(_l1Receiver, l1Token, _amount);\n        L2ContractHelper.sendMessageToL1(message);\n\n        emit WithdrawalInitiated(msg.sender, _l1Receiver, _l2Token, _amount);\n    }\n\n    /// @dev Encode the message for l2ToL1log sent with withdraw initialization\n    function _getL1WithdrawMessage(\n        address _to,\n        address _l1Token,\n        uint256 _amount\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(IL1Bridge.finalizeWithdrawal.selector, _to, _l1Token, _amount);\n    }\n\n    /// @return Address of an L2 token counterpart\n    function l2TokenAddress(address _l1Token) public view override returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenFactory), \"\"));\n        bytes32 salt = _getCreate2Salt(_l1Token);\n\n        return\n            L2ContractHelper.computeCreate2Address(address(this), salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n\n    /// @dev Convert the L1 token address to the create2 salt of deployed L2 token\n    function _getCreate2Salt(address _l1Token) internal pure returns (bytes32 salt) {\n        salt = bytes32(uint256(uint160(_l1Token)));\n    }\n}"
    },
    {
      "filename": "zksync/contracts/bridge/L2ERC20Bridge.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\n\nimport \"./interfaces/IL1Bridge.sol\";\nimport \"./interfaces/IL2Bridge.sol\";\nimport \"./interfaces/IL2StandardToken.sol\";\n\nimport \"./L2StandardERC20.sol\";\nimport {L2ContractHelper} from \"../L2ContractHelper.sol\";\n\n/// @author Matter Labs\n/// @notice The \"default\" bridge implementation for the ERC20 tokens.\ncontract L2ERC20Bridge is IL2Bridge {\n    /// @dev The address of the L1 bridge counterpart.\n    address public override l1Bridge;\n\n    /// @dev Contract that store the implementation address for token.\n    /// @dev For more details see https://docs.openzeppelin.com/contracts/3.x/api/proxy#UpgradeableBeacon.\n    UpgradeableBeacon public l2TokenFactory;\n\n    /// @dev Bytecode hash of the proxy for tokens deployed by the bridge.\n    bytes32 l2TokenProxyBytecodeHash;\n\n    /// @dev A mapping l2 token address => l1 token address\n    mapping(address => address) public override l1TokenAddress;\n\n    constructor(\n        address _l1Bridge,\n        bytes32 _l2TokenProxyBytecodeHash,\n        address _governor\n    ) {\n        l1Bridge = _l1Bridge;\n\n        l2TokenProxyBytecodeHash = _l2TokenProxyBytecodeHash;\n        address l2StandardToken = address(new L2StandardERC20{salt: bytes32(0)}());\n        l2TokenFactory = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n        l2TokenFactory.transferOwnership(_governor);\n    }\n\n    /// @notice Finalize the deposit and mint funds\n    /// @param _l1Sender The account address that initiate the deposit on L1\n    /// @param _l2Receiver The account address that would receive minted ether\n    /// @param _l1Token The address of the token that was locked on the L1. Always should be equal to zero (conventional value)\n    /// @param _amount Total amount of tokens deposited from L1\n    /// @param _data The additional data that user can pass with the deposit\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override {\n        // Only L1 bridge counterpart can initiate and finalize the deposit\n        require(msg.sender == l1Bridge, \"mq\");\n\n        address expectedL2Token = l2TokenAddress(_l1Token);\n        if (l1TokenAddress[expectedL2Token] == address(0)) {\n            address deployedToken = _deployL2Token(_l1Token, _data);\n            require(deployedToken == expectedL2Token, \"mt\");\n            l1TokenAddress[expectedL2Token] = _l1Token;\n        }\n\n        IL2StandardToken(expectedL2Token).bridgeMint(_l2Receiver, _amount);\n\n        emit FinalizeDeposit(_l1Sender, _l2Receiver, expectedL2Token, _amount);\n    }\n\n    /// @dev Deploys and initialize the L2 token for the L1 counterpart\n    function _deployL2Token(address _l1Token, bytes calldata _data) internal returns (address) {\n        bytes32 salt = _getCreate2Salt(_l1Token);\n\n        BeaconProxy l2Token = new BeaconProxy{salt: salt}(address(l2TokenFactory), \"\");\n        L2StandardERC20(address(l2Token)).bridgeInitialize(_l1Token, _data);\n\n        return address(l2Token);\n    }\n\n    /// @notice Initiates a withdrawal by burning funds on the contract and sending the message to L1\n    /// where tokens would be unlocked\n    /// @param _l1Receiver The account address that should receive funds on L1\n    /// @param _l2Token The L2 token address which is withdrawn\n    /// @param _amount The total amount of tokens to be withdrawn\n    function withdraw(\n        address _l1Receiver,\n        address _l2Token,\n        uint256 _amount\n    ) external override {\n        IL2StandardToken(_l2Token).bridgeBurn(msg.sender, _amount);\n\n        address l1Token = l1TokenAddress[_l2Token];\n        require(l1Token != address(0), \"yh\");\n\n        bytes memory message = _getL1WithdrawMessage(_l1Receiver, l1Token, _amount);\n        L2ContractHelper.sendMessageToL1(message);\n\n        emit WithdrawalInitiated(msg.sender, _l1Receiver, _l2Token, _amount);\n    }\n\n    /// @dev Encode the message for l2ToL1log sent with withdraw initialization\n    function _getL1WithdrawMessage(\n        address _to,\n        address _l1Token,\n        uint256 _amount\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(IL1Bridge.finalizeWithdrawal.selector, _to, _l1Token, _amount);\n    }\n\n    /// @return Address of an L2 token counterpart\n    function l2TokenAddress(address _l1Token) public view override returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenFactory), \"\"));\n        bytes32 salt = _getCreate2Salt(_l1Token);\n\n        return\n            L2ContractHelper.computeCreate2Address(address(this), salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n\n    /// @dev Convert the L1 token address to the create2 salt of deployed L2 token\n    function _getCreate2Salt(address _l1Token) internal pure returns (bytes32 salt) {\n        salt = bytes32(uint256(uint160(_l1Token)));\n    }\n}"
    },
    {
      "filename": "zksync/contracts/bridge/L2ETHBridge.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport {L2ContractHelper} from \"../L2ContractHelper.sol\";\n\nimport \"./interfaces/IL1Bridge.sol\";\nimport \"./interfaces/IL2Bridge.sol\";\nimport \"./interfaces/IL2EthInitializable.sol\";\nimport \"./interfaces/IL2StandardToken.sol\";\n\n/// @author Matter Labs\n/// @dev This contract is used for bridging the ether from L1.\ncontract L2ETHBridge is IL2Bridge {\n    /// @dev The total amount of tokens that have been minted\n    uint256 public totalSupply;\n\n    /// @dev Mapping of address to the balance\n    mapping(address => uint256) public balanceOf;\n\n    /// @dev Address of the L1 bridge counterpart\n    address public override l1Bridge;\n\n    /// @dev System contract that is responsible for storing and changing ether balances\n    IL2StandardToken constant ETH_TOKEN_SYSTEM_CONTRACT_ADDRESS = IL2StandardToken(address(0x800a));\n\n    /// @dev Ether native coin has no real address on L1, so a conventional zero address is used\n    address constant CONVENTIONAL_ETH_ADDRESS = address(0);\n\n    constructor(address _l1Bridge) {\n        l1Bridge = _l1Bridge;\n\n        IL2EthInitializable(address(ETH_TOKEN_SYSTEM_CONTRACT_ADDRESS)).initialization(address(this));\n    }\n\n    /// @dev Finalize the deposit and mint ether to the deposited address\n    /// @param _l1Sender The account address that initiate the deposit on L1\n    /// @param _l2Receiver The account address that would receive minted ether\n    /// @param _l1Token The address of the token that was locked on the L1. Always should be equal to zero (conventional value)\n    /// @param _amount Total amount of ether deposited from L1\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata // _data\n    ) external {\n        // Only L1 bridge counterpart can initiate and finalize the deposit\n        require(msg.sender == l1Bridge, \"ni\");\n        require(_l1Token == CONVENTIONAL_ETH_ADDRESS);\n\n        ETH_TOKEN_SYSTEM_CONTRACT_ADDRESS.bridgeMint(_l2Receiver, _amount);\n\n        emit FinalizeDeposit(_l1Sender, _l2Receiver, CONVENTIONAL_ETH_ADDRESS, _amount);\n    }\n\n    /// @dev Initiate withdrawal ethers from L2 contract to the L1\n    /// NOTE: In order to get funds on L1, receiver should finalise deposit on L1 counterpart\n    function withdraw(\n        address _l1Receiver,\n        address _l2Token,\n        uint256 _amount\n    ) external override {\n        require(_l2Token == CONVENTIONAL_ETH_ADDRESS, \"zn\");\n\n        ETH_TOKEN_SYSTEM_CONTRACT_ADDRESS.bridgeBurn(msg.sender, _amount);\n        bytes memory message = _getL1WithdrawMessage(_l1Receiver, _amount);\n        L2ContractHelper.sendMessageToL1(message);\n\n        emit WithdrawalInitiated(msg.sender, _l1Receiver, CONVENTIONAL_ETH_ADDRESS, _amount);\n    }\n\n    /// @dev Get the \"withdrawal initialized\" fact message to be sent on L1\n    function _getL1WithdrawMessage(address _to, uint256 _amount) internal pure returns (bytes memory) {\n        return abi.encodePacked(IL1Bridge.finalizeWithdrawal.selector, _to, _amount);\n    }\n\n    /// @notice Address of the L2 token by its L1 couterpart\n    function l2TokenAddress(address) public pure returns (address) {\n        return CONVENTIONAL_ETH_ADDRESS;\n    }\n\n    /// @notice Address of the L1 token by its L2 couterpart\n    function l1TokenAddress(address) public pure override returns (address) {\n        return CONVENTIONAL_ETH_ADDRESS;\n    }\n}"
    }
  ]
}