{
  "Title": "Missing Docstrings",
  "Content": "Throughout the codebase, there are several parts that do not have docstrings.\n\n\n* The [`IRollupVerifier` interface](https://github.com/scroll-tech/scroll/blob/8bd4277c13ec17670963848a24e4e1b135504f3f/contracts/src/libraries/verifier/IRollupVerifier.sol#L5-L27) in `IRollupVerifier.sol`\n* The [`IScrollChain` interface](https://github.com/scroll-tech/scroll/blob/8bd4277c13ec17670963848a24e4e1b135504f3f/contracts/src/L1/rollup/IScrollChain.sol#L5-L123) in `IScrollChain.sol`\n* The [`MultipleVersionRollupVerifier` contract](https://github.com/scroll-tech/scroll/blob/8bd4277c13ec17670963848a24e4e1b135504f3f/contracts/src/L1/rollup/MultipleVersionRollupVerifier.sol#L11-L174) in `MultipleVersionRollupVerifier.sol`\n\n\nNote that, for example, the `ScrollChain` contract can inherit the docstrings from the `IScrollChain` interface using the [`@inheritdoc` tag](https://docs.soliditylang.org/en/latest/natspec-format.html#tags) .\n\n\nConsider thoroughly documenting all contracts, interfaces, events, and functions that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/latest/natspec-format.html) (NatSpec).\n\n\n***Update:** Resolved in [pull request #1256](https://github.com/scroll-tech/scroll/pull/1256) at commit [5425ce7](https://github.com/scroll-tech/scroll/pull/1256/commits/5425ce725cc60d154e112610ee380d05e23689e5).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/libraries/verifier/IRollupVerifier.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\ninterface IRollupVerifier {\n    /// @notice Verify aggregate zk proof.\n    /// @param batchIndex The batch index to verify.\n    /// @param aggrProof The aggregated proof.\n    /// @param publicInputHash The public input hash.\n    function verifyAggregateProof(\n        uint256 batchIndex,\n        bytes calldata aggrProof,\n        bytes32 publicInputHash\n    ) external view;\n\n    /// @notice Verify aggregate zk proof.\n    /// @param version The version of verifier to use.\n    /// @param batchIndex The batch index to verify.\n    /// @param aggrProof The aggregated proof.\n    /// @param publicInputHash The public input hash.\n    function verifyAggregateProof(\n        uint256 version,\n        uint256 batchIndex,\n        bytes calldata aggrProof,\n        bytes32 publicInputHash\n    ) external view;\n}"
    },
    {
      "filename": "contracts/src/L1/rollup/IScrollChain.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\ninterface IScrollChain {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new batch is committed.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch.\n    event CommitBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice revert a pending batch.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    event RevertBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice Emitted when a batch is finalized.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    /// @param stateRoot The state root on layer 2 after this batch.\n    /// @param withdrawRoot The merkle root on layer2 after this batch.\n    event FinalizeBatch(uint256 indexed batchIndex, bytes32 indexed batchHash, bytes32 stateRoot, bytes32 withdrawRoot);\n\n    /// @notice Emitted when owner updates the status of sequencer.\n    /// @param account The address of account updated.\n    /// @param status The status of the account updated.\n    event UpdateSequencer(address indexed account, bool status);\n\n    /// @notice Emitted when owner updates the status of prover.\n    /// @param account The address of account updated.\n    /// @param status The status of the account updated.\n    event UpdateProver(address indexed account, bool status);\n\n    /// @notice Emitted when the value of `maxNumTxInChunk` is updated.\n    /// @param oldMaxNumTxInChunk The old value of `maxNumTxInChunk`.\n    /// @param newMaxNumTxInChunk The new value of `maxNumTxInChunk`.\n    event UpdateMaxNumTxInChunk(uint256 oldMaxNumTxInChunk, uint256 newMaxNumTxInChunk);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The latest finalized batch index.\n    function lastFinalizedBatchIndex() external view returns (uint256);\n\n    /// @notice Return the batch hash of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function committedBatches(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the state root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function finalizedStateRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the message root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function withdrawRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return whether the batch is finalized by batch index.\n    /// @param batchIndex The index of the batch.\n    function isBatchFinalized(uint256 batchIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Commit a batch of transactions on layer 1.\n    ///\n    /// @param version The version of current batch.\n    /// @param parentBatchHeader The header of parent batch, see the comments of `BatchHeaderV0Codec`.\n    /// @param chunks The list of encoded chunks, see the comments of `ChunkCodec`.\n    /// @param skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    function commitBatch(\n        uint8 version,\n        bytes calldata parentBatchHeader,\n        bytes[] memory chunks,\n        bytes calldata skippedL1MessageBitmap\n    ) external;\n\n    /// @notice Revert a pending batch.\n    /// @dev one can only revert unfinalized batches.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch`.\n    /// @param count The number of subsequent batches to revert, including current batch.\n    function revertBatch(bytes calldata batchHeader, uint256 count) external;\n\n    /// @notice Finalize a committed batch on layer 1.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch.\n    /// @param prevStateRoot The state root of parent batch.\n    /// @param postStateRoot The state root of current batch.\n    /// @param withdrawRoot The withdraw trie root of current batch.\n    /// @param aggrProof The aggregation proof for current batch.\n    function finalizeBatchWithProof(\n        bytes calldata batchHeader,\n        bytes32 prevStateRoot,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata aggrProof\n    ) external;\n\n    /// @notice Finalize a committed batch (with blob) on layer 1.\n    ///\n    /// @dev Memory layout of `blobDataProof`:\n    /// |    z    |    y    | kzg_commitment | kzg_proof |\n    /// |---------|---------|----------------|-----------|\n    /// | bytes32 | bytes32 |    bytes48     |  bytes48  |\n    ///\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch.\n    /// @param prevStateRoot The state root of parent batch.\n    /// @param postStateRoot The state root of current batch.\n    /// @param withdrawRoot The withdraw trie root of current batch.\n    /// @param blobDataProof The proof for blob data.\n    /// @param aggrProof The aggregation proof for current batch.\n    function finalizeBatchWithProof4844(\n        bytes calldata batchHeader,\n        bytes32 prevStateRoot,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata blobDataProof,\n        bytes calldata aggrProof\n    ) external;\n}"
    },
    {
      "filename": "contracts/src/L1/rollup/MultipleVersionRollupVerifier.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.24;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IScrollChain} from \"./IScrollChain.sol\";\nimport {IRollupVerifier} from \"../../libraries/verifier/IRollupVerifier.sol\";\nimport {IZkEvmVerifier} from \"../../libraries/verifier/IZkEvmVerifier.sol\";\n\ncontract MultipleVersionRollupVerifier is IRollupVerifier, Ownable {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of verifier is updated.\n    /// @param version The version of the verifier.\n    /// @param startBatchIndex The start batch index when the verifier will be used.\n    /// @param verifier The address of new verifier.\n    event UpdateVerifier(uint256 version, uint256 startBatchIndex, address verifier);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /// @dev Thrown when the given start batch index is finalized.\n    error ErrorStartBatchIndexFinalized();\n\n    /// @dev Thrown when the given start batch index is smaller than `latestVerifier.startBatchIndex`.\n    error ErrorStartBatchIndexTooSmall();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of ScrollChain contract.\n    address immutable scrollChain;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct Verifier {\n        // The start batch index for the verifier.\n        uint64 startBatchIndex;\n        // The address of zkevm verifier.\n        address verifier;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from verifier version to the list of legacy zkevm verifiers.\n    /// The verifiers are sorted by batchIndex in increasing order.\n    mapping(uint256 => Verifier[]) public legacyVerifiers;\n\n    /// @notice Mapping from verifier version to the lastest used zkevm verifier.\n    mapping(uint256 => Verifier) public latestVerifier;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _scrollChain,\n        uint256[] memory _versions,\n        address[] memory _verifiers\n    ) {\n        if (_scrollChain == address(0)) revert ErrorZeroAddress();\n        scrollChain = _scrollChain;\n\n        for (uint256 i = 0; i < _versions.length; i++) {\n            if (_verifiers[i] == address(0)) revert ErrorZeroAddress();\n            latestVerifier[_versions[i]].verifier = _verifiers[i];\n\n            emit UpdateVerifier(_versions[i], 0, _verifiers[i]);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the number of legacy verifiers.\n    function legacyVerifiersLength(uint256 _version) external view returns (uint256) {\n        return legacyVerifiers[_version].length;\n    }\n\n    /// @notice Compute the verifier should be used for specific batch.\n    /// @param _version The version of verifier to query.\n    /// @param _batchIndex The batch index to query.\n    function getVerifier(uint256 _version, uint256 _batchIndex) public view returns (address) {\n        // Normally, we will use the latest verifier.\n        Verifier memory _verifier = latestVerifier[_version];\n\n        if (_verifier.startBatchIndex > _batchIndex) {\n            uint256 _length = legacyVerifiers[_version].length;\n            // In most case, only last few verifier will be used by `ScrollChain`.\n            // So, we use linear search instead of binary search.\n            unchecked {\n                for (uint256 i = _length; i > 0; --i) {\n                    _verifier = legacyVerifiers[_version][i - 1];\n                    if (_verifier.startBatchIndex <= _batchIndex) break;\n                }\n            }\n        }\n\n        return _verifier.verifier;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IRollupVerifier\n    function verifyAggregateProof(\n        uint256 _batchIndex,\n        bytes calldata _aggrProof,\n        bytes32 _publicInputHash\n    ) external view override {\n        address _verifier = getVerifier(0, _batchIndex);\n\n        IZkEvmVerifier(_verifier).verify(_aggrProof, _publicInputHash);\n    }\n\n    /// @inheritdoc IRollupVerifier\n    function verifyAggregateProof(\n        uint256 _version,\n        uint256 _batchIndex,\n        bytes calldata _aggrProof,\n        bytes32 _publicInputHash\n    ) external view override {\n        address _verifier = getVerifier(_version, _batchIndex);\n\n        IZkEvmVerifier(_verifier).verify(_aggrProof, _publicInputHash);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of zkevm verifier.\n    /// @param _startBatchIndex The start batch index when the verifier will be used.\n    /// @param _verifier The address of new verifier.\n    function updateVerifier(\n        uint256 _version,\n        uint64 _startBatchIndex,\n        address _verifier\n    ) external onlyOwner {\n        if (_startBatchIndex <= IScrollChain(scrollChain).lastFinalizedBatchIndex())\n            revert ErrorStartBatchIndexFinalized();\n\n        Verifier memory _latestVerifier = latestVerifier[_version];\n        if (_startBatchIndex < _latestVerifier.startBatchIndex) revert ErrorStartBatchIndexTooSmall();\n        if (_verifier == address(0)) revert ErrorZeroAddress();\n\n        if (_latestVerifier.startBatchIndex < _startBatchIndex) {\n            // don't push when it is the first update of the version.\n            if (_latestVerifier.verifier != address(0)) {\n                legacyVerifiers[_version].push(_latestVerifier);\n            }\n            _latestVerifier.startBatchIndex = _startBatchIndex;\n        }\n        _latestVerifier.verifier = _verifier;\n\n        latestVerifier[_version] = _latestVerifier;\n\n        emit UpdateVerifier(_version, _startBatchIndex, _verifier);\n    }\n}"
    }
  ]
}