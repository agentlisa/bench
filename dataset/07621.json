{
  "Title": "[N-10] For functions, follow Solidity standard naming conventions",
  "Content": "\n[AutoPxGlp.sol#L487](https://github.com/code-423n4/2022-11-redactedcartel/blob/main/src/vaults/AutoPxGlp.sol#L487)\n\n[AutoPxGlp.sol#L501](https://github.com/code-423n4/2022-11-redactedcartel/blob/main/src/vaults/AutoPxGlp.sol#L501)\n\n[AutoPxGlp.sol#L474](https://github.com/code-423n4/2022-11-redactedcartel/blob/main/src/vaults/AutoPxGlp.sol#L474)\n\n[AutoPxGlp.sol#L462](https://github.com/code-423n4/2022-11-redactedcartel/blob/main/src/vaults/AutoPxGlp.sol#L462)\n\nThe above codes don't follow Solidity's standard naming convention:\n\ninternal and private functions: the mixedCase format starting with an underscore (_mixedCase starting with an underscore)\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-11-redactedcartel",
  "Code": [
    {
      "filename": "src/vaults/AutoPxGlp.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {PxGmxReward} from \"src/vaults/PxGmxReward.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\n\ncontract AutoPxGlp is PirexERC4626, PxGmxReward, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n    uint256 public constant EXPANDED_DECIMALS = 1e30;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    // GMX protocol base reward (e.g. WETH)\n    ERC20 public immutable gmxBaseReward;\n\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint256 minGlp,\n        uint256 gmxBaseRewardAmount,\n        uint256 pxGmxAmountOut,\n        uint256 pxGlpAmountOut,\n        uint256 totalPxGlpFee,\n        uint256 totalPxGmxFee,\n        uint256 pxGlpIncentive,\n        uint256 pxGmxIncentive\n    );\n\n    error ZeroAmount();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _asset          address  Asset address (vault asset, e.g. pxGLP)\n        @param  _pxGmx          address  pxGMX address (as secondary reward)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGLP)\n        @param  _symbol         string   Asset symbol (e.g. apxGLP)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _asset,\n        address _pxGmx,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) PxGmxReward(_pxGmx) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(_platform), type(uint256).max);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGLP custodied by the AutoPxGlp contract\n        @return uint256  Amount of pxGLP custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares   uint256  Shares amount\n        @return          uint256  Assets amount\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets   uint256  Assets amount\n        @return          uint256  Shares amount\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGLP (and additionally pxGMX) rewards\n        @param  minUsdg                uint256  Minimum USDG amount used when minting GLP\n        @param  minGlp                 uint256  Minimum GLP amount received from the WETH deposit\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  WETH inbound amount\n        @return pxGmxAmountOut         uint256  pxGMX outbound amount\n        @return pxGlpAmountOut         uint256  pxGLP outbound amount\n        @return totalPxGlpFee          uint256  Total platform fee for pxGLP\n        @return totalPxGmxFee          uint256  Total platform fee for pxGMX\n        @return pxGlpIncentive         uint256  Compound incentive for pxGLP\n        @return pxGmxIncentive         uint256  Compound incentive for pxGMX\n     */\n    function compound(\n        uint256 minUsdg,\n        uint256 minGlp,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 pxGmxAmountOut,\n            uint256 pxGlpAmountOut,\n            uint256 totalPxGlpFee,\n            uint256 totalPxGmxFee,\n            uint256 pxGlpIncentive,\n            uint256 pxGmxIncentive\n        )\n    {\n        if (minUsdg == 0) revert InvalidParam();\n        if (minGlp == 0) revert InvalidParam();\n\n        uint256 preClaimTotalAssets = asset.balanceOf(address(this));\n        uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n        PirexRewards(rewardsModule).claim(pxGmx, address(this));\n\n        // Track the amount of rewards received\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            // Deposit received rewards for pxGLP\n            (, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(\n                address(gmxBaseReward),\n                gmxBaseRewardAmountIn,\n                minUsdg,\n                minGlp,\n                address(this)\n            );\n        }\n\n        // Distribute fees if the amount of vault assets increased\n        uint256 newAssets = totalAssets() - preClaimTotalAssets;\n        if (newAssets != 0) {\n            totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;\n            pxGlpIncentive = optOutIncentive\n                ? 0\n                : (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGlpIncentive != 0)\n                asset.safeTransfer(msg.sender, pxGlpIncentive);\n\n            asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);\n        }\n\n        // Track the amount of pxGMX received\n        pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;\n\n        if (pxGmxAmountOut != 0) {\n            // Calculate and distribute pxGMX fees if the amount of pxGMX increased\n            totalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;\n            pxGmxIncentive = optOutIncentive\n                ? 0\n                : (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGmxIncentive != 0)\n                pxGmx.safeTransfer(msg.sender, pxGmxIncentive);\n\n            pxGmx.safeTransfer(owner, totalPxGmxFee - pxGmxIncentive);\n\n            // Update the pxGmx reward accrual\n            _harvest(pxGmxAmountOut - totalPxGmxFee);\n        } else {\n            // Required to keep the globalState up-to-date\n            _globalAccrue();\n        }\n\n        emit Compounded(\n            msg.sender,\n            minGlp,\n            gmxBaseRewardAmountIn,\n            pxGmxAmountOut,\n            pxGlpAmountOut,\n            totalPxGlpFee,\n            totalPxGmxFee,\n            pxGlpIncentive,\n            pxGmxIncentive\n        );\n    }\n\n    /**\n        @notice Internal deposit handler\n        @param  assets    uint256  pxGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return shares    uint256  Vault shares (i.e. apxGLP)\n     */\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        uint256 supply = totalSupply;\n\n        if (\n            (shares = supply == 0\n                ? assets\n                : assets.mulDivDown(supply, totalAssets() - assets)) == 0\n        ) revert ZeroShares();\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    /**\n        @notice Deposit fsGLP for apxGLP\n        @param  amount    uint256  fsGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositFsGlp(uint256 amount, address receiver)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        ERC20 stakedGlp = ERC20(address(PirexGmx(platform).stakedGlp()));\n\n        // Transfer fsGLP from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        stakedGlp.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve as needed here since the stakedGlp address is mutable in PirexGmx\n        stakedGlp.safeApprove(platform, amount);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositFsGlp(\n            amount,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ERC20 tokens) for apxGLP\n        @param  token        address  GMX-whitelisted token for minting GLP\n        @param  tokenAmount  uint256  Whitelisted token amount\n        @param  minUsdg      uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp       uint256  Minimum GLP amount minted from ERC20 tokens\n        @param  receiver     address  apxGLP receiver\n        @return              uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external nonReentrant returns (uint256) {\n        if (token == address(0)) revert ZeroAddress();\n        if (tokenAmount == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        // PirexGmx will do the check whether the token is whitelisted or not\n        ERC20 erc20Token = ERC20(token);\n\n        // Transfer token from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        erc20Token.safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n        // Approve as needed here since it can be a new whitelisted token (unless it's the baseReward)\n        if (erc20Token != gmxBaseReward) {\n            erc20Token.safeApprove(platform, tokenAmount);\n        }\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ETH) for apxGLP\n        @param  minUsdg   uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp    uint256  Minimum GLP amount minted from ETH\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlpETH(\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external payable nonReentrant returns (uint256) {\n        if (msg.value == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlpETH{\n            value: msg.value\n        }(minUsdg, minGlp, address(this));\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Override the withdrawal method to make sure compound is called before withdrawing\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        compound(1, 1, true);\n\n        shares = PirexERC4626.withdraw(assets, receiver, owner);\n    }\n\n    /**\n        @notice Override the redemption method to make sure compound is called before redeeming\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        compound(1, 1, true);\n\n        assets = PirexERC4626.redeem(shares, receiver, owner);\n    }\n\n    /**\n        @notice Compound and internally update pxGMX reward accrual before deposit\n     */\n    function beforeDeposit(\n        address,\n        uint256,\n        uint256\n    ) internal override {\n        compound(1, 1, true);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual after deposit\n        @param  receiver  address  Receiver of the vault shares\n     */\n    function afterDeposit(\n        address receiver,\n        uint256,\n        uint256\n    ) internal override {\n        _globalAccrue();\n        _userAccrue(receiver);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual after withdrawal\n        @param  owner  address  Owner of the vault shares\n     */\n    function afterWithdraw(\n        address owner,\n        uint256,\n        uint256\n    ) internal override {\n        _globalAccrue();\n        _userAccrue(owner);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual for both sender and receiver after transfer\n        @param  owner     address  Owner of the vault shares\n        @param  receiver  address  Receiver of the vault shares\n     */\n    function afterTransfer(\n        address owner,\n        address receiver,\n        uint256\n    ) internal override {\n        _userAccrue(owner);\n        _userAccrue(receiver);\n    }\n}"
    },
    {
      "filename": "src/vaults/AutoPxGlp.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {PxGmxReward} from \"src/vaults/PxGmxReward.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\n\ncontract AutoPxGlp is PirexERC4626, PxGmxReward, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n    uint256 public constant EXPANDED_DECIMALS = 1e30;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    // GMX protocol base reward (e.g. WETH)\n    ERC20 public immutable gmxBaseReward;\n\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint256 minGlp,\n        uint256 gmxBaseRewardAmount,\n        uint256 pxGmxAmountOut,\n        uint256 pxGlpAmountOut,\n        uint256 totalPxGlpFee,\n        uint256 totalPxGmxFee,\n        uint256 pxGlpIncentive,\n        uint256 pxGmxIncentive\n    );\n\n    error ZeroAmount();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _asset          address  Asset address (vault asset, e.g. pxGLP)\n        @param  _pxGmx          address  pxGMX address (as secondary reward)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGLP)\n        @param  _symbol         string   Asset symbol (e.g. apxGLP)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _asset,\n        address _pxGmx,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) PxGmxReward(_pxGmx) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(_platform), type(uint256).max);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGLP custodied by the AutoPxGlp contract\n        @return uint256  Amount of pxGLP custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares   uint256  Shares amount\n        @return          uint256  Assets amount\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets   uint256  Assets amount\n        @return          uint256  Shares amount\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGLP (and additionally pxGMX) rewards\n        @param  minUsdg                uint256  Minimum USDG amount used when minting GLP\n        @param  minGlp                 uint256  Minimum GLP amount received from the WETH deposit\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  WETH inbound amount\n        @return pxGmxAmountOut         uint256  pxGMX outbound amount\n        @return pxGlpAmountOut         uint256  pxGLP outbound amount\n        @return totalPxGlpFee          uint256  Total platform fee for pxGLP\n        @return totalPxGmxFee          uint256  Total platform fee for pxGMX\n        @return pxGlpIncentive         uint256  Compound incentive for pxGLP\n        @return pxGmxIncentive         uint256  Compound incentive for pxGMX\n     */\n    function compound(\n        uint256 minUsdg,\n        uint256 minGlp,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 pxGmxAmountOut,\n            uint256 pxGlpAmountOut,\n            uint256 totalPxGlpFee,\n            uint256 totalPxGmxFee,\n            uint256 pxGlpIncentive,\n            uint256 pxGmxIncentive\n        )\n    {\n        if (minUsdg == 0) revert InvalidParam();\n        if (minGlp == 0) revert InvalidParam();\n\n        uint256 preClaimTotalAssets = asset.balanceOf(address(this));\n        uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n        PirexRewards(rewardsModule).claim(pxGmx, address(this));\n\n        // Track the amount of rewards received\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            // Deposit received rewards for pxGLP\n            (, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(\n                address(gmxBaseReward),\n                gmxBaseRewardAmountIn,\n                minUsdg,\n                minGlp,\n                address(this)\n            );\n        }\n\n        // Distribute fees if the amount of vault assets increased\n        uint256 newAssets = totalAssets() - preClaimTotalAssets;\n        if (newAssets != 0) {\n            totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;\n            pxGlpIncentive = optOutIncentive\n                ? 0\n                : (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGlpIncentive != 0)\n                asset.safeTransfer(msg.sender, pxGlpIncentive);\n\n            asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);\n        }\n\n        // Track the amount of pxGMX received\n        pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;\n\n        if (pxGmxAmountOut != 0) {\n            // Calculate and distribute pxGMX fees if the amount of pxGMX increased\n            totalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;\n            pxGmxIncentive = optOutIncentive\n                ? 0\n                : (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGmxIncentive != 0)\n                pxGmx.safeTransfer(msg.sender, pxGmxIncentive);\n\n            pxGmx.safeTransfer(owner, totalPxGmxFee - pxGmxIncentive);\n\n            // Update the pxGmx reward accrual\n            _harvest(pxGmxAmountOut - totalPxGmxFee);\n        } else {\n            // Required to keep the globalState up-to-date\n            _globalAccrue();\n        }\n\n        emit Compounded(\n            msg.sender,\n            minGlp,\n            gmxBaseRewardAmountIn,\n            pxGmxAmountOut,\n            pxGlpAmountOut,\n            totalPxGlpFee,\n            totalPxGmxFee,\n            pxGlpIncentive,\n            pxGmxIncentive\n        );\n    }\n\n    /**\n        @notice Internal deposit handler\n        @param  assets    uint256  pxGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return shares    uint256  Vault shares (i.e. apxGLP)\n     */\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        uint256 supply = totalSupply;\n\n        if (\n            (shares = supply == 0\n                ? assets\n                : assets.mulDivDown(supply, totalAssets() - assets)) == 0\n        ) revert ZeroShares();\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    /**\n        @notice Deposit fsGLP for apxGLP\n        @param  amount    uint256  fsGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositFsGlp(uint256 amount, address receiver)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        ERC20 stakedGlp = ERC20(address(PirexGmx(platform).stakedGlp()));\n\n        // Transfer fsGLP from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        stakedGlp.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve as needed here since the stakedGlp address is mutable in PirexGmx\n        stakedGlp.safeApprove(platform, amount);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositFsGlp(\n            amount,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ERC20 tokens) for apxGLP\n        @param  token        address  GMX-whitelisted token for minting GLP\n        @param  tokenAmount  uint256  Whitelisted token amount\n        @param  minUsdg      uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp       uint256  Minimum GLP amount minted from ERC20 tokens\n        @param  receiver     address  apxGLP receiver\n        @return              uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external nonReentrant returns (uint256) {\n        if (token == address(0)) revert ZeroAddress();\n        if (tokenAmount == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        // PirexGmx will do the check whether the token is whitelisted or not\n        ERC20 erc20Token = ERC20(token);\n\n        // Transfer token from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        erc20Token.safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n        // Approve as needed here since it can be a new whitelisted token (unless it's the baseReward)\n        if (erc20Token != gmxBaseReward) {\n            erc20Token.safeApprove(platform, tokenAmount);\n        }\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ETH) for apxGLP\n        @param  minUsdg   uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp    uint256  Minimum GLP amount minted from ETH\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlpETH(\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external payable nonReentrant returns (uint256) {\n        if (msg.value == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlpETH{\n            value: msg.value\n        }(minUsdg, minGlp, address(this));\n\n        // Handle vault deposit after minting pxGLP"
    }
  ]
}