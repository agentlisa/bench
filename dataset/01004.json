{
  "Title": "Error-Prone and Inconsistent Definition of Gap Variables",
  "Content": "The `L2MessageService` contract defines [gap variables](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/messageService/l2/L2MessageService.sol#L17) to support the future addition of state variables when upgrading.\n\n\nHowever, while most gaps in the codebase are defined [after](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/messageService/l1/L1MessageManager.sol#L29) the other storage variables, the `L2MessageService` contract defines this gap before. This makes it inconsistent with the rest of the codebase in addition to being error-prone for future updates. New variables cannot be added to the end of the existing storage variables without resulting in a storage collision.\n\n\nConsider defining the gap variable after other storage definitions in the `L2MessageService` contract to be consistent with the rest of the codebase. If this is impossible, consider documenting this issue thoroughly to ensure storage variables are added to the front of the storage definitions in this file to avoid storage collisions.\n\n\n***Update:** Resolved in [pull request #9](https://github.com/Consensys/linea-contracts-fix/pull/9) at commit [2a3c0b0](https://github.com/Consensys/linea-contracts-fix/pull/9/commits/2a3c0b05343730073c6b84d8fc6a16151a30dc2a).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/messageService/l2/L2MessageService.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { CodecV2 } from \"../lib/Codec.sol\";\nimport { IMessageService } from \"../../interfaces/IMessageService.sol\";\nimport { IGenericErrors } from \"../../interfaces/IGenericErrors.sol\";\nimport { RateLimiter } from \"../lib/RateLimiter.sol\";\nimport { L2MessageManager } from \"./L2MessageManager.sol\";\n\n/**\n * @title Contract to manage cross-chain messaging on L2.\n * @author ConsenSys Software Inc.\n */\ncontract L2MessageService is Initializable, RateLimiter, L2MessageManager, IMessageService, IGenericErrors {\n  // Keep free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap_L2MessageService;\n\n  bytes32 public constant MINIMUM_FEE_SETTER_ROLE = keccak256(\"MINIMUM_FEE_SETTER_ROLE\");\n\n  address private _messageSender;\n\n  // @dev initialise to save user cost with existing slot.\n  uint256 public nextMessageNumber;\n\n  // @dev initialise minimumFeeInWei variable.\n  uint256 public minimumFeeInWei;\n\n  // @dev adding these should not affect storage as they are constants and are store in bytecode\n  uint256 private constant REFUND_OVERHEAD_IN_GAS = 45000;\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initialises underlying message service dependencies.\n   * @param _securityCouncil The address owning the security council role.\n   * @param _l1l2MessageSetter The address owning the add L1L2MessageHashes functionality.\n   * @param _rateLimitPeriod The period to rate limit against.\n   * @param _rateLimitAmount The limit allowed for withdrawing the period.\n   **/\n  function initialize(\n    address _securityCouncil,\n    address _l1l2MessageSetter,\n    uint256 _rateLimitPeriod,\n    uint256 _rateLimitAmount\n  ) public initializer {\n    if (_securityCouncil == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_l1l2MessageSetter == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    __ERC165_init();\n    __Context_init();\n    __AccessControl_init();\n    __RateLimiter_init(_rateLimitPeriod, _rateLimitAmount);\n    __L2MessageManager_init(_l1l2MessageSetter);\n\n    nextMessageNumber = 1;\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(MINIMUM_FEE_SETTER_ROLE, _securityCouncil);\n    _grantRole(RATE_LIMIT_SETTER_ROLE, _securityCouncil);\n    _grantRole(PAUSE_MANAGER_ROLE, _securityCouncil);\n\n    _messageSender = address(123456789);\n  }\n\n  /**\n   * @notice Adds a message for sending cross-chain and emits a relevant event.\n   * @dev The message number is preset and only incremented at the end if successful for the next caller.\n   * @param _to The address the message is intended for.\n   * @param _fee The fee being paid for the message delivery.\n   * @param _calldata The calldata to pass to the recipient.\n   **/\n  function sendMessage(address _to, uint256 _fee, bytes calldata _calldata) external payable {\n    _requireTypeNotPaused(L2_L1_PAUSE_TYPE);\n    _requireTypeNotPaused(GENERAL_PAUSE_TYPE);\n\n    if (_to == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_fee > msg.value) {\n      revert ValueSentTooLow();\n    }\n\n    uint256 coinbaseFee = minimumFeeInWei;\n\n    if (_fee < coinbaseFee) {\n      revert FeeTooLow();\n    }\n\n    uint256 postmanFee;\n    uint256 valueSent;\n\n    unchecked {\n      postmanFee = _fee - coinbaseFee;\n      valueSent = msg.value - _fee;\n    }\n\n    uint256 messageNumber = nextMessageNumber;\n    /// @dev Rate limit and revert is in the rate limiter.\n    _addUsedAmount(valueSent + postmanFee);\n\n    bytes32 messageHash = keccak256(abi.encode(msg.sender, _to, postmanFee, valueSent, messageNumber, _calldata));\n\n    nextMessageNumber++;\n\n    (bool success, ) = block.coinbase.call{ value: coinbaseFee }(\"\");\n    if (!success) {\n      revert FeePaymentFailed(block.coinbase);\n    }\n\n    emit MessageSent(msg.sender, _to, postmanFee, valueSent, messageNumber, _calldata, messageHash);\n  }\n\n  /**\n   * @notice Claims and delivers a cross-chain message.\n   * @dev _feeRecipient Can be set to address(0) to receive as msg.sender.\n   * @dev messageSender Is set temporarily when claiming and reset post.\n   * @param _from The address of the original sender.\n   * @param _to The address the message is intended for.\n   * @param _fee The fee being paid for the message delivery.\n   * @param _value The value to be transferred to the destination address.\n   * @param _feeRecipient The recipient for the fee.\n   * @param _calldata The calldata to pass to the recipient.\n   * @param _nonce The unique auto generated message number used when sending the message.\n   **/\n  function claimMessage(\n    address _from,\n    address _to,\n    uint256 _fee,\n    uint256 _value,\n    address payable _feeRecipient,\n    bytes calldata _calldata,\n    uint256 _nonce\n  ) external distributeFees(_fee, _to, _calldata, _feeRecipient) {\n    _requireTypeNotPaused(L1_L2_PAUSE_TYPE);\n    _requireTypeNotPaused(GENERAL_PAUSE_TYPE);\n\n    bytes32 messageHash = keccak256(abi.encode(_from, _to, _fee, _value, _nonce, _calldata));\n\n    /// @dev Status check and revert is in the message manager.\n    _updateL1L2MessageStatusToClaimed(messageHash);\n\n    _messageSender = _from;\n\n    (bool callSuccess, bytes memory returnData) = _to.call{ value: _value }(_calldata);\n    if (!callSuccess) {\n      if (returnData.length > 0) {\n        assembly {\n          let data_size := mload(returnData)\n          revert(add(32, returnData), data_size)\n        }\n      } else {\n        revert MessageSendingFailed(_to);\n      }\n    }\n\n    _messageSender = address(123456789);\n    emit MessageClaimed(messageHash);\n  }\n\n  /**\n   * @notice The Fee Manager sets a minimum fee to address DOS protection.\n   * @param _feeInWei New minimum fee in Wei.\n   **/\n  function setMinimumFee(uint256 _feeInWei) external onlyRole(MINIMUM_FEE_SETTER_ROLE) {\n    minimumFeeInWei = _feeInWei;\n  }\n\n  /**\n   * @dev The _messageSender address is set temporarily when claiming.\n   * @return _messageSender address.\n   **/\n  function sender() external view returns (address) {\n    return _messageSender;\n  }\n\n  /**\n   * @notice Function to receive funds for liquidity purposes.\n   **/\n  receive() external payable virtual {}\n\n  /**\n   * @notice The unspent fee is refunded if applicable.\n   * @param _feeInWei The fee paid for delivery in Wei.\n   * @param _to The recipient of the message and gas refund.\n   * @param _calldata The calldata of the message.\n   **/\n  modifier distributeFees(\n    uint256 _feeInWei,\n    address _to,\n    bytes calldata _calldata,\n    address _feeRecipient\n  ) {\n    //pre-execution\n    uint256 startingGas = gasleft();\n    _;\n    //post-execution\n\n    // we have a fee\n    if (_feeInWei > 0) {\n      // default postman fee\n      uint256 deliveryFee = _feeInWei;\n\n      // do we have empty calldata?\n      if (_calldata.length == 0) {\n        bool isDestinationEOA;\n\n        assembly {\n          isDestinationEOA := iszero(extcodesize(_to))\n        }\n\n        // are we calling an EOA\n        if (isDestinationEOA) {\n          // initial + cost to call and refund minus gasleft\n          deliveryFee = (startingGas + REFUND_OVERHEAD_IN_GAS - gasleft()) * tx.gasprice;\n\n          if (_feeInWei > deliveryFee) {\n            _to.call{ value: (_feeInWei - deliveryFee) }(\"\");\n          } else {\n            deliveryFee = _feeInWei;\n          }\n        }\n      }\n\n      address feeReceiver = _feeRecipient == address(0) ? msg.sender : _feeRecipient;\n      (bool callSuccess, ) = feeReceiver.call{ value: deliveryFee }(\"\");\n      if (!callSuccess) {\n        revert FeePaymentFailed(feeReceiver);\n      }\n    }\n  }\n}"
    },
    {
      "filename": "contracts/messageService/l1/L1MessageManager.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport { IL1MessageManager } from \"../../interfaces/IL1MessageManager.sol\";\n\n/**\n * @title Contract to manage cross-chain message hashes storage and status on L1.\n * @author ConsenSys Software Inc.\n */\nabstract contract L1MessageManager is IL1MessageManager {\n  uint8 public constant INBOX_STATUS_UNKNOWN = 0;\n  uint8 public constant INBOX_STATUS_RECEIVED = 1;\n\n  uint8 public constant OUTBOX_STATUS_UNKNOWN = 0;\n  uint8 public constant OUTBOX_STATUS_SENT = 1;\n  uint8 public constant OUTBOX_STATUS_RECEIVED = 2;\n\n  /// @dev There is a uint216 worth of storage layout here.\n\n  /// @dev Mapping to store L1->L2 message hashes status.\n  /// @dev messageHash => messageStatus (0: unknown, 1: sent, 2: received).\n  mapping(bytes32 => uint256) public outboxL1L2MessageStatus;\n\n  /// @dev Mapping to store L2->L1 message hashes status.\n  /// @dev messageHash => messageStatus (0: unknown, 1: received).\n  mapping(bytes32 => uint256) public inboxL2L1MessageStatus;\n\n  /// @dev Keep free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap;\n\n  /**\n   * @notice Add a cross-chain L2->L1 message hash in storage.\n   * @dev Once the event is emitted, it should be ready for claiming (post block finalization).\n   * @param  _messageHash Hash of the message.\n   */\n  function _addL2L1MessageHash(bytes32 _messageHash) internal {\n    if (inboxL2L1MessageStatus[_messageHash] != INBOX_STATUS_UNKNOWN) {\n      revert MessageAlreadyReceived(_messageHash);\n    }\n\n    inboxL2L1MessageStatus[_messageHash] = INBOX_STATUS_RECEIVED;\n\n    emit L2L1MessageHashAddedToInbox(_messageHash);\n  }\n\n  /**\n   * @notice Update the status of L2->L1 message when a user claims a message on L1.\n   * @dev The L2->L1 message is removed from storage.\n   * @dev Due to the nature of the rollup, we should not get a second entry of this.\n   * @param  _messageHash Hash of the message.\n   */\n  function _updateL2L1MessageStatusToClaimed(bytes32 _messageHash) internal {\n    if (inboxL2L1MessageStatus[_messageHash] != INBOX_STATUS_RECEIVED) {\n      revert MessageDoesNotExistOrHasAlreadyBeenClaimed();\n    }\n\n    delete inboxL2L1MessageStatus[_messageHash];\n  }\n\n  /**\n   * @notice Add L1->L2 message hash in storage when a message is sent on L1.\n   * @param  _messageHash Hash of the message.\n   */\n  function _addL1L2MessageHash(bytes32 _messageHash) internal {\n    outboxL1L2MessageStatus[_messageHash] = OUTBOX_STATUS_SENT;\n  }\n\n  /**\n   * @notice Update the status of L1->L2 messages as received when messages has been stored on L2.\n   * @dev The expectation here is that the rollup is limited to 100 hashes being added here - array is not open ended.\n   * @param  _messageHashes List of message hashes.\n   */\n  function _updateL1L2MessageStatusToReceived(bytes32[] memory _messageHashes) internal {\n    uint256 messageHashArrayLength = _messageHashes.length;\n\n    for (uint256 i; i < messageHashArrayLength; ) {\n      bytes32 messageHash = _messageHashes[i];\n      uint256 existingStatus = outboxL1L2MessageStatus[messageHash];\n\n      if (existingStatus == OUTBOX_STATUS_UNKNOWN) {\n        revert L1L2MessageNotSent(messageHash);\n      }\n\n      if (existingStatus != OUTBOX_STATUS_RECEIVED) {\n        outboxL1L2MessageStatus[messageHash] = OUTBOX_STATUS_RECEIVED;\n      }\n\n      unchecked {\n        i++;\n      }\n    }\n\n    emit L1L2MessagesReceivedOnL2(_messageHashes);\n  }\n}"
    }
  ]
}