{
  "Title": "M-16: ChainlinkAdapterOracle will return the wrong price for asset if underlying aggregator hits minAnswer",
  "Content": "# Issue M-16: ChainlinkAdapterOracle will return the wrong price for asset if underlying aggregator hits minAnswer \n\nSource: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/18 \n\n## Found by \n0x52\n\n## Summary\n\nChainlink aggregators have a built in circuit breaker if the price of an asset goes outside of a predetermined price band. The result is that if an asset experiences a huge drop in value (i.e. LUNA crash) the price of the oracle will continue to return the minPrice instead of the actual price of the asset. This would allow user to continue borrowing with the asset but at the wrong price. This is exactly what happened to [Venus on BSC when LUNA imploded](https://rekt.news/venus-blizz-rekt/). \n\n## Vulnerability Detail\n\nChainlinkAdapterOracle uses the [ChainlinkFeedRegistry](https://etherscan.io/address/0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf) to obtain the price of the requested tokens.\n\n    function latestRoundData(\n      address base,\n      address quote\n    )\n      external\n      view\n      override\n      checkPairAccess()\n      returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n      )\n    {\n      uint16 currentPhaseId = s_currentPhaseId[base][quote];\n      //@audit this pulls the Aggregator for the requested pair\n      AggregatorV2V3Interface aggregator = _getFeed(base, quote);\n      require(address(aggregator) != address(0), \"Feed not found\");\n      (\n        roundId,\n        answer,\n        startedAt,\n        updatedAt,\n        answeredInRound\n      ) = aggregator.latestRoundData();\n      return _addPhaseIds(roundId, answer, startedAt, updatedAt, answeredInRound, currentPhaseId);\n    }\n\nChainlinkFeedRegistry#latestRoundData pulls the associated aggregator and requests round data from it. ChainlinkAggregators have minPrice and maxPrice circuit breakers built into them. This means that if the price of the asset drops below the minPrice, the protocol will continue to value the token at minPrice instead of it's actual value. This will allow users to take out huge amounts of bad debt and bankrupt the protocol.\n\nExample:\nTokenA has a minPrice of $1. The price of TokenA drops to $0.10. The aggregator still returns $1 allowing the user to borrow against TokenA as if it is $1 which is 10x it's actual value.\n\nNote:\nChainlink oracles are used a just one piece of the OracleAggregator system and it is assumed that using a combination of other oracles, a scenario like this can be avoided. However this is not the case because the other oracles also have their flaws that can still allow this to be exploited. As an example if the chainlink oracle is being used with a UniswapV3Oracle which uses a long TWAP then this will be exploitable when the TWAP is near the minPrice on the way down. In a scenario like that it wouldn't matter what the third oracle was because it would be bypassed with the two matching oracles prices. If secondary oracles like Band are used a malicious user could DDOS relayers to prevent update pricing. Once the price becomes stale the chainlink oracle would be the only oracle left and it's price would be used.\n\n## Impact\n\nIn the event that an asset crashes (i.e. LUNA) the protocol can be manipulated to give out loans at an inflated price\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/ChainlinkAdapterOracle.sol#L66-L84\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChainlinkAdapterOracle should check the returned answer against the minPrice/maxPrice and revert if the answer is outside of the bounds:\n\n        (, int256 answer, , uint256 updatedAt, ) = registry.latestRoundData(\n            token,\n            USD\n        );\n        \n    +   if (answer >= maxPrice or answer <= minPrice) revert();\n    \n    \n\n## Discussion\n\n**Gornutz**\n\nThe aggregator is responding with answers from the multiple of oracle sources\n\n**IAm0x52**\n\nEscalate for 50 USDC\n\nThis is not a dupe of #94\n\n```The aggregator is responding with answers from the multiple of oracle sources```\n\nThis comment is true but in my submission I address this exact issue and why it's still an issue even if the aggregator has multiple sources:\n\n> Note:\n> Chainlink oracles are used a just one piece of the OracleAggregator system and it is assumed that using a combination of other oracles, a scenario like this can be avoided. However this is not the case because the other oracles also have their flaws that can still allow this to be exploited. As an example if the chainlink oracle is being used with a UniswapV3Oracle which uses a long TWAP then this will be exploitable when the TWAP is near the minPrice on the way down. In a scenario like that it wouldn't matter what the third oracle was because it would be bypassed with the two matching oracles prices. If secondary oracles like Band are used a malicious user could DDOS relayers to prevent update pricing. Once the price becomes stale the chainlink oracle would be the only oracle left and it's price would be used.```\n\nEven with the structure of aggregator there are still lots of scenarios where this could cause an issue. The chainlink oracle needs to revert at min/max answer because otherwise it risk returning the wrong price and causing the collateral to be overvalued leading to huge amounts of abuse.\n\n**sherlock-admin**\n\n > Escalate for 50 USDC\n> \n> This is not a dupe of #94\n> \n> ```The aggregator is responding with answers from the multiple of oracle sources```\n> \n> This comment is true but in my submission I address this exact issue and why it's still an issue even if the aggregator has multiple sources:\n> \n> > Note:\n> > Chainlink oracles are used a just one piece of the OracleAggregator system and it is assumed that using a combination of other oracles, a scenario like this can be avoided. However this is not the case because the other oracles also have their flaws that can still allow this to be exploited. As an example if the chainlink oracle is being used with a UniswapV3Oracle which uses a long TWAP then this will be exploitable when the TWAP is near the minPrice on the way down. In a scenario like that it wouldn't matter what the third oracle was because it would be bypassed with the two matching oracles prices. If secondary oracles like Band are used a malicious user could DDOS relayers to prevent update pricing. Once the price becomes stale the chainlink oracle would be the only oracle left and it's price would be used.```\n> \n> Even with the structure of aggregator there are still lots of scenarios where this could cause an issue. The chainlink oracle needs to revert at min/max answer because otherwise it risk returning the wrong price and causing the collateral to be overvalued leading to huge amounts of abuse.\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Gornutz**\n\nGiven the multi-aggregator setup we will use, once price hits Chainlink's oracles will at their min value. The other oracles will respond with a price well below that min value and will have a large enough deviation to cause a revert. Since the assets will be pooling from Chainlink / Band / Twap. Think setting a min / max inside of the chainlink oracle directly will potentially cause additional attack vectors to be created.\n\n**hrishibhat**\n\nEscalation accepted\n\nNot a duplicate of #94 \nThis issue is a valid medium\nGiven the unlikely edge case of Chainlink hitting minimum value as a result of a serious price movement and resulting in undercollateralized borrowing. \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> This issue is a valid medium\n> Given the unlikely edge case of Chainlink hitting minimum value as a result of a serious price movement and resulting in undercollateralized borrowing. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/41",
  "Code": [
    {
      "filename": "contracts/oracle/ChainlinkAdapterOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BaseAdapter.sol\";\nimport \"../utils/BlueBerryErrors.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/chainlink/IFeedRegistry.sol\";\n\ncontract ChainlinkAdapterOracle is IBaseOracle, BaseAdapter {\n    using SafeCast for int256;\n\n    // Chainlink denominations\n    // (source: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/Denominations.sol)\n    IFeedRegistry public registry;\n    address public constant USD = address(840);\n\n    /// @dev Mapping from original token to remapped token for price querying (e.g. WBTC -> BTC, renBTC -> BTC)\n    mapping(address => address) public remappedTokens;\n\n    event SetRegistry(address registry);\n    event SetTokenRemapping(\n        address indexed token,\n        address indexed remappedToken\n    );\n\n    constructor(IFeedRegistry registry_) {\n        if (address(registry_) == address(0)) revert ZERO_ADDRESS();\n\n        registry = registry_;\n    }\n\n    /// @dev Set chainlink feed registry source\n    /// @param _registry Chainlink feed registry source\n    function setFeedRegistry(IFeedRegistry _registry) external onlyOwner {\n        if (address(_registry) == address(0)) revert ZERO_ADDRESS();\n        registry = _registry;\n        emit SetRegistry(address(_registry));\n    }\n\n    /// @dev Set token remapping\n    /// @param _tokens List of tokens to set remapping\n    /// @param _remappedTokens List of tokens to set remapping to\n    /// @notice Token decimals of the original and remapped tokens should be the same\n    function setTokenRemappings(\n        address[] calldata _tokens,\n        address[] calldata _remappedTokens\n    ) external onlyOwner {\n        if (_remappedTokens.length != _tokens.length)\n            revert INPUT_ARRAY_MISMATCH();\n        for (uint256 idx = 0; idx < _tokens.length; idx++) {\n            if (_remappedTokens[idx] == address(0)) revert ZERO_ADDRESS();\n            if (_tokens[idx] == address(0)) revert ZERO_ADDRESS();\n            remappedTokens[_tokens[idx]] = _remappedTokens[idx];\n            emit SetTokenRemapping(_tokens[idx], _remappedTokens[idx]);\n        }\n    }\n\n    /**\n     * @notice Returns the USD based price of given token, price value has 18 decimals\n     * @param _token Token address to get price of\n     * @return price USD price of token in 18 decimal\n     */\n    function getPrice(address _token) external view override returns (uint256) {\n        // remap token if possible\n        address token = remappedTokens[_token];\n        if (token == address(0)) token = _token;\n\n        uint256 maxDelayTime = maxDelayTimes[token];\n        if (maxDelayTime == 0) revert NO_MAX_DELAY(_token);\n\n        // try to get token-USD price\n        uint256 decimals = registry.decimals(token, USD);\n        (, int256 answer, , uint256 updatedAt, ) = registry.latestRoundData(\n            token,\n            USD\n        );\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert PRICE_OUTDATED(_token);\n\n        return (answer.toUint256() * 1e18) / 10**decimals;\n    }\n}"
    }
  ]
}