{
  "Title": "[N-02] `OperationExecuted` event is defined but never emitted",
  "Content": "In the `OperatorProposal` contract the [`OperationExecuted`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/OperatorProposal.sol#L20) event is defined but it is never emitted.  \n\nTherefore I recommend to emit this event when the operation is executed successfully.  \n\nFix:  \n```diff\ndiff --git a/contracts/proposals/OperatorProposal.sol b/contracts/proposals/OperatorProposal.sol\nindex 23e2897..5899bec 100644\n--- a/contracts/proposals/OperatorProposal.sol\n+++ b/contracts/proposals/OperatorProposal.sol\n@@ -44,6 +44,8 @@ contract OperatorProposal {\n         // Execute the operation.\n         data.operator.execute{ value: data.operatorValue }(data.operatorData, executionData);\n \n+        emit OperationExecuted(msg.sender);\n+        \n         // Nothing left to do.\n         return \"\";\n     }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-04-party",
  "Code": [
    {
      "filename": "contracts/proposals/OperatorProposal.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IProposalExecutionEngine.sol\";\nimport \"../operators/IOperator.sol\";\n\ncontract OperatorProposal {\n    struct OperatorProposalData {\n        // Addresses that are allowed to execute the proposal and decide what\n        // calldata used by the operator proposal at the time of execution.\n        address[] allowedExecutors;\n        // The operator contract that will be used to execute the proposal.\n        IOperator operator;\n        // Amount of ETH to send to the operator contract for executing the proposal.\n        uint96 operatorValue;\n        // The calldata that will be used by the operator contract to execute the proposal.\n        bytes operatorData;\n    }\n\n    event OperationExecuted(address executor);\n\n    error NotAllowedToExecute(address executor, address[] allowedExecutors);\n    error NotEnoughEthError(uint256 operatorValue, uint256 ethAvailable);\n\n    function _executeOperation(\n        IProposalExecutionEngine.ExecuteProposalParams memory params,\n        bool allowOperatorsToSpendPartyEth\n    ) internal returns (bytes memory nextProgressData) {\n        // Decode the proposal data.\n        OperatorProposalData memory data = abi.decode(params.proposalData, (OperatorProposalData));\n        (uint256 allowedExecutorsIndex, bytes memory executionData) = abi.decode(\n            params.extraData,\n            (uint256, bytes)\n        );\n\n        // Check that the caller is an allowed executor.\n        _assertCallerIsAllowedToExecute(msg.sender, data.allowedExecutors, allowedExecutorsIndex);\n\n        // Check whether operator can spend party's ETH balance.\n        if (!allowOperatorsToSpendPartyEth && data.operatorValue > msg.value) {\n            revert NotEnoughEthError(data.operatorValue, msg.value);\n        }\n\n        // Execute the operation.\n        data.operator.execute{ value: data.operatorValue }(data.operatorData, executionData);\n\n        // Nothing left to do.\n        return \"\";\n    }\n\n    function _assertCallerIsAllowedToExecute(\n        address caller,\n        address[] memory allowedExecutors,\n        uint256 allowedExecutorsIndex\n    ) private pure {\n        // If there are no allowed executors, then anyone can execute.\n        if (allowedExecutors.length == 0) return;\n\n        // Check if the caller is an allowed executor.\n        if (caller != allowedExecutors[allowedExecutorsIndex])\n            revert NotAllowedToExecute(caller, allowedExecutors);\n    }\n}"
    }
  ]
}