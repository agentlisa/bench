{
  "Title": "[M11] Possible compromised storage due to hierarchy composition",
  "Content": "The design chosen for the upgradeability of certain contracts, such as the `Reserve` and the `Stabilizer` contracts, consists of composing those contracts by means of smaller ones and use an upgradeable proxy pattern with the resulting contract.\n\n\nFor this reason, the storage variables of both modules are stored respectively in the `ReserveState` and the `StabilizerState` contracts.\n\n\nThe intention is to have a unique contract for all the state variables of each module and have less overhead when upgrading through proxy patterns. This can be a good design decision whenever the composition of the contracts is strictly followed in order.\n\n\nHowever, there are several cases where some contracts extend and import the same contracts multiple times and in different orders. Some examples are:\n\n\n* The [`StabilizerImpl` contract](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/stabilizer/StabilizerImpl.sol#L30) extends the `Implementation` contract, however it is already been inherited by the [`StabilizerAdmin` contract](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/stabilizer/StabilizerState.sol#L114) through the `StabilizerComptroller` contract.\n* The `StabilizerState.sol` file [has duplicated imports](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/stabilizer/StabilizerState.sol#L23-L24). Moreover the `Implementation` contract already imports the `IImplementation` interface.\n* The `ReserveImpl` contract [imports](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveImpl.sol#L20-L21) are already imported in `ReserveIssuer` and `ReserveSwapper` contracts. Moreover, the `Implementation` import is not used.\n* [All imports](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveSwapper.sol#L20-L27) of the `ReserveSwapper`, except for the `ReserveComptroller` import, are already imported in the `ReserveComptroller`.\n* The `Dollar` contract [imports](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/token/Dollar.sol#L20) the `ERC20Detailed` contract but this is already imported by the [`Permittable` contract](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/token/Permittable.sol#L21).\n\n\nChanging the order of the composition can result in different contracts layouts if imports are mixed in different orders. However this is unlikely to happens since the storage is centralized in one unique contract.\n\n\nConsider reviewing all orders imports and duplications to ensure a clear composition order and reduce the possibility of compromising storage when upgrading the `Reserve` or the `Stabilizer` implementations.\n\n\n***Update**: Fixed on [pull request 11](https://github.com/emptysetsquad/emptyset/pull/11/commits/b3f8865fdd520d13ea3bc8bceb88536c6d068759).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/src/stabilizer/StabilizerImpl.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"./StabilizerState.sol\";\nimport \"./StabilizerComptroller.sol\";\nimport \"./StabilizerToken.sol\";\nimport \"../common/Implementation.sol\";\n\n/**\n * @title StabilizerImpl\n * @notice Top-level Stabilizer contract that extends all other stabilizer sub-contracts\n * @dev This contract should be used an implementation contract for an AdminUpgradeabilityProxy\n */\ncontract StabilizerImpl is Implementation, StabilizerToken, StabilizerComptroller { }"
    },
    {
      "filename": "protocol/contracts/src/stabilizer/StabilizerState.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/Decimal.sol\";\nimport \"../Interfaces.sol\";\nimport \"../common/IImplementation.sol\";\nimport \"../common/Implementation.sol\";\nimport \"../common/Implementation.sol\";\n\n/**\n * @title StabilizerTypes\n * @notice Contains all stabilizer state structs\n */\ncontract StabilizerTypes {\n\n    /**\n     * @notice Stores state for the sESD ERC20 implementation\n     */\n    struct Token {\n        /**\n         * @notice account to sESD balance mapping\n         */\n        mapping (address => uint256) balances;\n\n        /**\n         * @notice sESD allowance data\n         */\n        mapping (address => mapping (address => uint256)) allowances;\n\n        /**\n         * @notice total supply of sESD\n         */\n        uint256 totalSupply;\n    }\n\n    /**\n     * @notice Stores state for the EMA oracle\n     */\n    struct Oracle {\n        /**\n         * @notice Exponential Moving Average ESD price\n         */\n        Decimal.D256 ema;\n        /**\n         * @notice Rate of decay for the EMA algorithm\n         */\n        Decimal.D256 decayRate;\n        /**\n         * @notice Maximum ratio that the EMA is allowed to be updated in a single settlement\n         */\n        Decimal.D256 maxAlpha;\n    }\n\n    /**\n     * @notice Stores state for the entire stabilizer\n     */\n    struct State {\n        /**\n         * @notice Common state for upgradeable, ownable, implementation contracts\n         */\n        IImplementation.ImplementationState implementation;\n\n        /**\n         * @notice State for the sESD ERC20 implementation\n         */\n        StabilizerTypes.Token token;\n\n        /**\n         * @notice State for the EMA oracle\n         */\n        StabilizerTypes.Oracle oracle;\n\n        /**\n         * @notice Parameter determining the rate at which rewards accrue\n         * @dev    Denoted as a % of totalUnderlying per day, assuming 100% off-peg (0.00 price)\n         */\n        Decimal.D256 rewardRate;\n    }\n}\n\n/**\n * @title StabilizerState\n * @notice Stabilizer state\n */\ncontract StabilizerState {\n\n    /**\n     * @notice Entirety of the stabilizer contract state\n     * @dev To upgrade state, append additional state variables at the end of this contract\n     */\n    StabilizerTypes.State internal _state;\n}\n\n/**\n * @title StabilizerAdmin\n * @notice Stabilizer admin state accessor helpers\n */\ncontract StabilizerAdmin is StabilizerState, Implementation {\n\n    /**\n     * @notice Cap decay at a 100% per day rate\n     */\n    uint256 private constant DECAY_RATE_CAP = 1e18;\n\n    /**\n     * @notice Alpha must by capped no higher than a 100% per day rate\n     */\n    uint256 private constant MAX_ALPHA_CAP = 1e18;\n\n    /**\n     * @notice Cap effective rate at (1.00 - price) * 2.5% per day\n     * @dev Corresponds to 31.5% APY at 0.97 price\n     */\n    uint256 private constant REWARD_RATE_CAP = 0.025e18;\n\n    /**\n     * @notice Emitted when {decayRate} is updated with `newDecayRate`\n     */\n    event DecayRateUpdate(uint256 newDecayRate);\n\n    /**\n     * @notice Emitted when {maxAlpha} is updated with `newMaxAlpha`\n     */\n    event MaxAlphaUpdate(uint256 newMaxAlpha);\n\n    /**\n     * @notice Emitted when {rewardRate} is updated with `newRewardRate`\n     */\n    event RewardRateUpdate(uint256 newRewardRate);\n\n    // COMPTROLLER\n\n    /**\n     * @notice Rate of decay for the EMA algorithm\n     * @return Decay rate\n     */\n    function decayRate() public view returns (Decimal.D256 memory) {\n        return _state.oracle.decayRate;\n    }\n\n    /**\n     * @notice Sets the decay rate to `newDecayRate`\n     * @dev Owner only - governance hook\n     * @param newDecayRate New decay rate\n     */\n    function setDecayRate(uint256 newDecayRate) external onlyOwner {\n        require(newDecayRate <= DECAY_RATE_CAP, \"StabilizerAdmin: too large\");\n\n        _state.oracle.decayRate = Decimal.D256({value: newDecayRate});\n\n        emit DecayRateUpdate(newDecayRate);\n    }\n\n    /**\n     * @notice Maximum ratio that the EMA is allowed to be updated in a single settlement\n     * @return Max alpha\n     */\n    function maxAlpha() public view returns (Decimal.D256 memory) {\n        return _state.oracle.maxAlpha;\n    }\n\n    /**\n     * @notice Sets the maximum alpha to `newMaxAlpha`\n     * @dev Owner only - governance hook\n     * @param newMaxAlpha New max alpha\n     */\n    function setMaxAlpha(uint256 newMaxAlpha) external onlyOwner {\n        require(newMaxAlpha <= MAX_ALPHA_CAP, \"StabilizerAdmin: too large\");\n\n        _state.oracle.maxAlpha = Decimal.D256({value: newMaxAlpha});\n\n        emit MaxAlphaUpdate(newMaxAlpha);\n    }\n\n    /**\n     * @notice Parameter determining the rate at which rewards accrue\n     * @dev    Denoted as a % of totalUnderlying per day, assuming 100% off-peg (0.00 price)\n     * @return Reward rate\n     */\n    function rewardRate() public view returns (Decimal.D256 memory) {\n        return _state.rewardRate;\n    }\n\n    /**\n     * @notice Sets the reward rate to `newRewardRate`\n     * @dev Owner only - governance hook\n     * @param newRewardRate New reward rate\n     */\n    function setRewardRate(uint256 newRewardRate) external onlyOwner {\n        require(newRewardRate <= REWARD_RATE_CAP, \"StabilizerAdmin: too large\");\n\n        _state.rewardRate = Decimal.D256({value: newRewardRate});\n\n        emit RewardRateUpdate(newRewardRate);\n    }\n}\n\n/**\n * @title StabilizerAccessors\n * @notice Reserve state accessor helpers\n */\ncontract StabilizerAccessors is IImplementation, StabilizerAdmin {\n    using SafeMath for uint256;\n    using Decimal for Decimal.D256;\n\n    // TOKEN\n\n    /**\n     * @notice Total supply of sESD tokens\n     * @return sESD total supply\n     */\n    function totalSupply() public view returns (uint256) {\n        return _state.token.totalSupply;\n    }\n\n    /**\n     * @notice The sESD balance for `account`\n     * @param account Account to retrieve balance for\n     * @return sESD balance\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _state.token.balances[account];\n    }\n\n    /**\n     * @notice The sESD allowance from `owner` for `spender`\n     * @param owner Account that is allowing\n     * @param spender Account that is being allowed\n     * @return sESD allowance\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _state.token.allowances[owner][spender];\n    }\n\n    /**\n     * @notice Transfers `amount` from `sender` to `recipient`\n     * @dev Internal only - helper\n     *      Reverts with `reason` when insufficient funds\n     * @param sender Account that is sending sESD\n     * @param recipient Account this is receiving sESD\n     * @param amount Amount of sESD that is being transferred\n     * @param reason Revert reason\n     */\n    function _transferBalance(address sender, address recipient, uint256 amount, string memory reason) internal {\n        _state.token.balances[sender] = _state.token.balances[sender].sub(amount, reason);\n        _state.token.balances[recipient] = _state.token.balances[recipient].add(amount);\n    }\n\n    /**\n     * @notice Increments the sESD balance of `account` by `amount`\n     * @dev Internal only - helper\n     * @param account Account that will receive the minted sESD\n     * @param amount Amount of sESD that is being minted\n     */\n    function _incrementBalance(address account, uint256 amount) internal {\n        _state.token.totalSupply = _state.token.totalSupply.add(amount);\n        _state.token.balances[account] = _state.token.balances[account].add(amount);\n    }\n\n    /**\n     * @notice Decrements the sESD balance of `account` by `amount`\n     * @dev Internal only - helper\n     *      Reverts with `reason` when insufficient funds\n     * @param account Account that will lose the burned sESD\n     * @param amount Amount of sESD that is being burned\n     * @param reason Revert reason\n     */\n    function _decrementBalance(address account, uint256 amount, string memory reason) internal {\n        _state.token.balances[account] = _state.token.balances[account].sub(amount, reason);\n        _state.token.totalSupply = _state.token.totalSupply.sub(amount);\n    }\n\n    /**\n     * @notice Updates the allowance from `owner` for `spender` to `amount`\n     * @dev Internal only - helper\n     * @param owner Account that is allowing\n     * @param spender Account that is being allowed\n     * @param amount Amount of sESD that is being allowed\n     */\n    function _updateAllowance(address owner, address spender, uint256 amount) internal {\n        _state.token.allowances[owner][spender] = amount;\n    }\n\n    // COMPTROLLER\n\n    /**\n     * @notice Current EMA oracle price\n     * @return EMA price\n     */\n    function ema() public view returns (Decimal.D256 memory) {\n        return _state.oracle.ema;\n    }\n\n    /**\n     * @notice Updates the EMA price\n     * @dev Internal only - helper\n     * @param newEma New EMA value\n     */\n    function _updateEma(Decimal.D256 memory newEma) internal {\n        _state.oracle.ema = newEma;\n    }\n\n    // IMPLEMENTATION\n\n    /**\n     * @notice Registry containing mappings for all protocol contracts\n     * @return Protocol registry\n     */\n    function registry() public view returns (IRegistry) {\n        return IRegistry(_state.implementation.registry);\n    }\n\n    /**\n     * @notice Updates the registry contract\n     * @dev Internal only\n     * @param newRegistry New registry contract\n     */\n    function _setRegistry(address newRegistry) internal {\n        _state.implementation.registry = newRegistry;\n    }\n\n    /**\n     * @notice Owner contract with admin permission over this contract\n     * @return Owner contract\n     */\n    function owner() public view returns (address) {\n        return _state.implementation.owner;\n    }\n\n    /**\n     * @notice Updates the owner contract\n     * @dev Internal only\n     * @param newOwner New owner contract\n     */\n    function _setOwner(address newOwner) internal {\n        _state.implementation.owner = newOwner;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/src/reserve/ReserveImpl.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"./ReserveState.sol\";\nimport \"./ReserveComptroller.sol\";\nimport \"./ReserveSwapper.sol\";\nimport \"../common/Implementation.sol\";\nimport \"./ReserveIssuer.sol\";\n\n/**\n * @title ReserveImpl\n * @notice Top-level Reserve contract that extends all other reserve sub-contracts\n * @dev This contract should be used an implementation contract for an AdminUpgradeabilityProxy\n */\ncontract ReserveImpl is IReserve, ReserveComptroller, ReserveIssuer, ReserveSwapper { }"
    },
    {
      "filename": "protocol/contracts/src/reserve/ReserveSwapper.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../Interfaces.sol\";\nimport \"./ReserveComptroller.sol\";\nimport \"./ReserveState.sol\";\n\n/**\n * @title ReserveSwapper\n * @notice Logic for managing outstanding limit orders, allow the reserve to swap its held tokens\n */\ncontract ReserveSwapper is ReentrancyGuard, ReserveComptroller {\n    using SafeMath for uint256;\n    using Decimal for Decimal.D256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Emitted when `amount` of the `makerToken`-`takerToken` order is registered with price `price`\n     */\n    event OrderRegistered(address indexed makerToken, address indexed takerToken, uint256 price, uint256 amount);\n\n    /**\n     * @notice Emitted when the reserve pays `takerAmount` of `takerToken` in exchange for `makerAmount` of `makerToken`\n     */\n    event Swap(address indexed makerToken, address indexed takerToken, uint256 takerAmount, uint256 makerAmount);\n\n    /**\n     * @notice Sets the `price` and `amount` of the specified `makerToken`-`takerToken` order\n     * @dev Owner only - governance hook\n     *      uint256(-1) indicates an unlimited order amount\n     * @param makerToken Token that the reserve wishes to sell\n     * @param takerToken Token that the reserve wishes to buy\n     * @param price Price as a ratio of takerAmount:makerAmount times 10^18\n     * @param amount Amount to decrement in ESD\n     */\n    function registerOrder(address makerToken, address takerToken, uint256 price, uint256 amount) external onlyOwner {\n        _updateOrder(makerToken, takerToken, price, amount);\n\n        emit OrderRegistered(makerToken, takerToken, price, amount);\n    }\n\n    /**\n     * @notice Purchases `makerToken` from the reserve in exchange for `takerAmount` of `takerToken`\n     * @dev Non-reentrant\n     *      Uses the state-defined price for the `makerToken`-`takerToken` order\n     *      Maker and taker tokens must be different\n     *      Cannot swap ESD\n     *      uint256(-1) indicates an unlimited order amount\n     * @param makerToken Token that the caller wishes to buy\n     * @param takerToken Token that the caller wishes to sell\n     * @param takerAmount Amount of takerToken to sell\n     */\n    function swap(address makerToken, address takerToken, uint256 takerAmount) external nonReentrant {\n        address dollar = registry().dollar();\n        require(makerToken != dollar, \"ReserveSwapper: unsupported token\");\n        require(takerToken != dollar, \"ReserveSwapper: unsupported token\");\n        require(makerToken != takerToken, \"ReserveSwapper: tokens equal\");\n\n        ReserveTypes.Order memory order = order(makerToken, takerToken);\n        uint256 makerAmount = Decimal.from(takerAmount).div(order.price, \"ReserveSwapper: no order\").asUint256();\n\n        if (order.amount != uint256(-1))\n            _decrementOrderAmount(makerToken, takerToken, makerAmount, \"ReserveSwapper: insufficient amount\");\n\n        _transferFrom(takerToken, msg.sender, address(this), takerAmount);\n        _transfer(makerToken, msg.sender, makerAmount);\n\n        emit Swap(makerToken, takerToken, takerAmount, makerAmount);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/src/token/Dollar.sol",
      "content": "/*\n    Copyright 2020, 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"./Permittable.sol\";\nimport \"../Interfaces.sol\";\n\n/**\n * @title Dollar\n * @notice ESD stablecoin ERC20 token\n * @dev Owned by the reserve, which is solely allowed to mint ESD to itself and to burn its held ESD\n */\ncontract Dollar is IManagedToken, Ownable, ERC20Detailed, Permittable {\n\n    /**\n     * @notice Constructs the Dollar contract\n     */\n    constructor()\n    ERC20Detailed(\"Empty Set Dollar\", \"ESD\", 18)\n    Permittable()\n    public\n    { }\n\n    // ADMIN\n\n    /**\n     * @notice Mints `amount` ESD tokens to the {owner}\n     * @dev Owner only\n     * @param amount Amount of ESD to mint\n     */\n    function mint(uint256 amount) public onlyOwner {\n        _mint(owner(), amount);\n    }\n\n    /**\n     * @notice Burns `amount` ESD tokens from the {owner}\n     * @dev Owner only\n     * @param amount Amount of ESD to burn\n     */\n    function burn(uint256 amount) public onlyOwner {\n        _burn(owner(), amount);\n    }\n\n    // INFINITE APPROVAL\n\n    /**\n     * @notice Transfer `amount` ESD from the `sender` to the `recipient`\n     * @dev Extended to support infinite approval\n     * @param sender Account to send ESD from\n     * @param sender Account to receive the sent ESD\n     * @param amount Amount of ESD to transfer\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        if (allowance(sender, _msgSender()) != uint256(-1)) {\n            _approve(\n                sender,\n                _msgSender(),\n                allowance(sender, _msgSender()).sub(amount, \"Dollar: transfer amount exceeds allowance\"));\n        }\n        return true;\n    }\n}"
    }
  ]
}