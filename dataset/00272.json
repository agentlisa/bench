{
  "Title": "M-3: Attacker can steal LPs funds by using different oracle prices in the same transaction",
  "Content": "# Issue M-3: Attacker can steal LPs funds by using different oracle prices in the same transaction \n\nSource: https://github.com/sherlock-audit/2024-03-flat-money-fix-review-contest-judging/issues/27 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nbareli, santipu\\_, xiaoming90\n## Summary\n\nIn the previous audit, there was an [issue](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/216) that pointed out that the PYTH oracle can return different prices within the same transaction. The fix implemented was to prevent the attack path described there, but a malicious LP can steal funds using a similar attack path. \n\n## Vulnerability Detail\n\nThe attack path is as follows:\n1. The attacker has some liquidity deposited as an LP with address A.\n2. The attacker announces the withdrawal of all liquidity with address A.\n3. In the same txn, the attacker announces the deposit of liquidity (same amount as the withdrawal) with address B.\n4. After the minimum execution time has elapsed, retrieve two prices from the Pyth oracle where the second price is lower than the first one.\n5. Execute the withdrawal of address A sending the higher price.\n6. Execute the deposit of address B sending the lower price. \n\nAs a result, the attacker will have the same deposited liquidity in the protocol, plus a profit from the price deviation. \n\nEven though the withdrawal may reduce the profits of this attack, it doesn't completely prevent it. Moreover, if the attacker is the only LP on the market, there's not going to be a withdrawal fee, increasing the profits of such an attack at the expense of the traders. \n\nThe requirements of this attack are the same as the ones described in the [original issue](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/216), hence the medium severity. \n\n**Sidenote:**\nNow that I'm checking better the fixes on the previous audit, I think that the second attack path described by the [original issue](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/216) is still not fixed:\n\n> Another possible strategy would pass through the following steps:\n>- Create a leverage position.\n>- Announce another leverage position with the same size.\n>- In the same block, announce a limit close order.\n>- After the minimum execution time has elapsed, retrieve two prices from the Pyth oracle where the second price is lower than the first one.\n>- Execute the limit close order sending the first price.\n>- Execute the open order sending the second price.\n>\n>The result in this case is having a position with the same size as the original one, but having either lowered the position.lastPrice or getting a profit from the original position, depending on how the price has moved since the original position was opened.\n\nI don't have access to the [exact pull request of the fix](https://github.com/dhedge/flatcoin-v1/pull/276) but I'm pretty sure the attack path described above is still feasible. \n\n## Impact\n\nDifferent oracle prices can be fetched in the same transaction, which can be used to create arbitrage opportunities that can make a profit with no risk at the expense of users on the other side of the trade.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-03-flat-money-fix-review-contest/blob/main/flatcoin-v1/src/OracleModule.sol#L63\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nGiven the time constraints of this contest, I haven't been able to think about a quick fix for this issue. Even if the protocol team doesn't allow to update the price feeds within the same block, an attacker can still update them by directly calling the PYTH contract. \n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**santipu_** commented:\n> Medium\n\n\n\n**rashtrakoff**\n\nThe original [scenario](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/216) is not possible imo because the limit order's execution time is changed when a delayed order adjusts a position. However, I think other variations like the one you described is still possible.\n\nI think to only solution would be to use the same price in a block for all orders. This would still allow for multi-block arbitrage attacks but that will be incredibly difficult to perform and probably will result in losses mostly.\n\n**itsermin**\n\nI think this scenario is part of a range of oracle frontrunning issues. It doesn't neccesarily require 2 prices in a single block to profit.\n\nIn a simpler example issue, the attacker:\n- Announces a leverage open\n- Fetches 2 Pyth prices\n- Executes open on the lower price\n\n- Announces a close\n- Fetches 2 Pyth prices\n- Executes close on the higher price\n\nJust like the original example, this example is profitable over time if it wasn't for the trading fee that the attacker has to pay on each order. Whether the original example steps 5 and 6 are done in a single block or consecutive blocks is also not critical either.\n\nThe trading fee mitigates any of these types of oracle frontrunning issues from being profitable.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/287",
  "Code": [
    {
      "filename": "flatcoin-v1/src/OracleModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.20;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {SignedMath} from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {PythStructs} from \"pyth-sdk-solidity/PythStructs.sol\";\n\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {IChainlinkAggregatorV3} from \"./interfaces/IChainlinkAggregatorV3.sol\";\n\n/// @title OracleModule\n/// @author dHEDGE\n/// @notice Can query collateral oracle price.\n/// @dev Interfaces with onchain and offchain oracles (eg. Chainlink and Pyth network).\ncontract OracleModule is IOracleModule, ModuleUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeCast for *;\n    using SignedMath for int256;\n\n    address public asset; // Asset to price\n\n    FlatcoinStructs.OnchainOracle public onchainOracle; // Onchain Chainlink oracle\n\n    FlatcoinStructs.OffchainOracle public offchainOracle; // Offchain Pyth network oracle\n\n    // Max difference between onchain and offchain oracle. 1e18 = 100%\n    uint256 public maxDiffPercent;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    ///      function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(\n        IFlatcoinVault _vault,\n        address _asset,\n        FlatcoinStructs.OnchainOracle calldata _onchainOracle,\n        FlatcoinStructs.OffchainOracle calldata _offchainOracle,\n        uint256 _maxDiffPercent\n    ) external initializer {\n        __Module_init(FlatcoinModuleKeys._ORACLE_MODULE_KEY, _vault);\n        __ReentrancyGuard_init();\n\n        setAssetAndOracles(_asset, _onchainOracle, _offchainOracle);\n        setMaxDiffPercent(_maxDiffPercent);\n    }\n\n    function updatePythPrice(address sender, bytes[] calldata priceUpdateData) external payable nonReentrant {\n        // Get fee amount to pay to Pyth\n        uint256 fee = offchainOracle.oracleContract.getUpdateFee(priceUpdateData);\n\n        // Update the price data (and pay the fee)\n        offchainOracle.oracleContract.updatePriceFeeds{value: fee}(priceUpdateData);\n\n        if (msg.value - fee > 0) {\n            // Need to refund caller. Try to return unused value, or revert if failed\n            (bool success, ) = sender.call{value: msg.value - fee}(\"\");\n            if (success == false) revert FlatcoinErrors.RefundFailed();\n        }\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Returns the latest 18 decimal price of asset from either Pyth network or Chainlink.\n    /// @dev The oldest pricestamp will be the Chainlink oracle `maxAge` setting. Otherwise the call will revert.\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    function getPrice() public view returns (uint256 price, uint256 timestamp) {\n        (price, timestamp) = _getPrice(type(uint32).max, false);\n    }\n\n    /// @notice The same as getPrice() but it includes maximum acceptable oracle timestamp input parameter.\n    /// @param maxAge Oldest acceptable oracle price.\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    function getPrice(uint32 maxAge, bool priceDiffCheck) public view returns (uint256 price, uint256 timestamp) {\n        (price, timestamp) = _getPrice(maxAge, priceDiffCheck);\n    }\n\n    /////////////////////////////////////////////\n    //            Internal Functions           //\n    /////////////////////////////////////////////\n\n    /// @notice Returns the latest 18 decimal price of asset from either Pyth network or Chainlink.\n    /// @dev It verifies the Pyth network price against Chainlink price (ensure that it is within a threshold).\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    function _getPrice(uint32 maxAge, bool priceDiffCheck) internal view returns (uint256 price, uint256 timestamp) {\n        (uint256 onchainPrice, uint256 onchainTime) = _getOnchainPrice(); // will revert if invalid\n        (uint256 offchainPrice, uint256 offchainTime, bool offchainInvalid) = _getOffchainPrice();\n        bool offchain;\n\n        if (offchainInvalid == false) {\n            if (priceDiffCheck) {\n                // If the price is not time sensitive (not used for order exeucution),\n                // then we don't need to check the price difference between onchain and offchain\n                uint256 priceDiff = (int256(onchainPrice) - int256(offchainPrice)).abs();\n                uint256 diffPercent = (priceDiff * 1e18) /\n                    (onchainPrice < offchainPrice ? onchainPrice : offchainPrice);\n                if (diffPercent > maxDiffPercent) revert FlatcoinErrors.PriceMismatch(diffPercent);\n            }\n\n            // return the freshest price\n            if (offchainTime >= onchainTime) {\n                price = offchainPrice;\n                timestamp = offchainTime;\n                offchain = true;\n            } else {\n                price = onchainPrice;\n                timestamp = onchainTime;\n            }\n        } else {\n            price = onchainPrice;\n            timestamp = onchainTime;\n        }\n\n        // Check that the timestamp is within the required age\n        if (maxAge < type(uint32).max && timestamp + maxAge < block.timestamp) {\n            revert FlatcoinErrors.PriceStale(\n                offchain ? FlatcoinErrors.PriceSource.OffChain : FlatcoinErrors.PriceSource.OnChain\n            );\n        }\n    }\n\n    /// @notice Fetches the price of collateral from Chainlink oracle.\n    /// @dev Will revert on any issue. This is because the Onchain price is critical\n    ///      Mind the Chainlink oracle price decimals if switching to ETH pair (18 decimals)\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    function _getOnchainPrice() internal view returns (uint256 price, uint256 timestamp) {\n        IChainlinkAggregatorV3 oracle = onchainOracle.oracleContract;\n        if (address(oracle) == address(0)) revert FlatcoinErrors.ZeroAddress(\"oracle\");\n\n        (, int256 _price, , uint256 updatedAt, ) = oracle.latestRoundData();\n        timestamp = updatedAt;\n        // check Chainlink oracle price updated within `maxAge` time.\n        if (block.timestamp > timestamp + onchainOracle.maxAge)\n            revert FlatcoinErrors.PriceStale(FlatcoinErrors.PriceSource.OnChain);\n\n        if (_price > 0) {\n            price = uint256(_price) * (10 ** 10); // convert Chainlink oracle decimals 8 -> 18\n        } else {\n            // Issue with onchain oracle indicates a serious problem\n            revert FlatcoinErrors.PriceInvalid(FlatcoinErrors.PriceSource.OnChain);\n        }\n    }\n\n    /// @notice Fetches the price of collateral from Pyth network price feed.\n    /// @dev `_getPrice` can fall back to the Onchain oracle.\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    /// @return invalid True if the price is invalid.\n    function _getOffchainPrice() internal view returns (uint256 price, uint256 timestamp, bool invalid) {\n        if (address(offchainOracle.oracleContract) == address(0)) revert FlatcoinErrors.ZeroAddress(\"oracle\");\n\n        try offchainOracle.oracleContract.getPriceNoOlderThan(offchainOracle.priceId, offchainOracle.maxAge) returns (\n            PythStructs.Price memory priceData\n        ) {\n            timestamp = priceData.publishTime;\n\n            // Check that Pyth price and confidence is a positive value\n            // Check that the exponential param is negative (eg -8 for 8 decimals)\n            if (priceData.price > 0 && priceData.conf > 0 && priceData.expo < 0) {\n                price = ((priceData.price).toUint256()) * (10 ** (18 + priceData.expo).toUint256()); // convert oracle expo/decimals eg 8 -> 18\n\n                // Check that Pyth price confidence meets minimum\n                if (priceData.price / int64(priceData.conf) < int32(offchainOracle.minConfidenceRatio)) {\n                    invalid = true; // price confidence is too low\n                }\n            } else {\n                invalid = true;\n            }\n        } catch {\n            invalid = true; // couldn't fetch the price with the asked input param\n        }\n    }\n\n    /// @dev Sets the asset to price.\n    /// @param _asset The asset to price.\n    function _setAsset(address _asset) internal {\n        if (_asset == address(0)) revert FlatcoinErrors.ZeroAddress(\"asset\");\n\n        asset = _asset;\n        emit FlatcoinEvents.SetAsset(_asset);\n    }\n\n    /// @notice Setting a Chainlink price feed push oracle.\n    /// @param newOracle The Chainlink aggregator oracle address.\n    function _setOnchainOracle(FlatcoinStructs.OnchainOracle calldata newOracle) internal {\n        if (address(newOracle.oracleContract) == address(0) || newOracle.maxAge <= 0)\n            revert FlatcoinErrors.OracleConfigInvalid();\n\n        onchainOracle = newOracle;\n        emit FlatcoinEvents.SetOnChainOracle(newOracle);\n    }\n\n    /// @notice Setting a Pyth Network price feed pull oracle.\n    /// @param newOracle The new onchain oracle configuration.\n    function _setOffchainOracle(FlatcoinStructs.OffchainOracle calldata newOracle) internal {\n        if (\n            address(newOracle.oracleContract) == address(0) ||\n            newOracle.priceId == bytes32(0) ||\n            newOracle.maxAge <= 0 ||\n            newOracle.minConfidenceRatio <= 0\n        ) revert FlatcoinErrors.OracleConfigInvalid();\n\n        offchainOracle = FlatcoinStructs.OffchainOracle(\n            newOracle.oracleContract,\n            newOracle.priceId,\n            newOracle.maxAge,\n            newOracle.minConfidenceRatio\n        );\n        emit FlatcoinEvents.SetOffChainOracle(newOracle);\n    }\n\n    /////////////////////////////////////////////\n    //             Owner Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Sets the asset and oracles (onchain and offchain).\n    /// @dev Changes should be handled with care as it's possible to misconfigure.\n    /// @param _asset The asset to price.\n    /// @param _onchainOracle The onchain oracle configuration.\n    /// @param _offchainOracle The offchain oracle configuration.\n    function setAssetAndOracles(\n        address _asset,\n        FlatcoinStructs.OnchainOracle calldata _onchainOracle,\n        FlatcoinStructs.OffchainOracle calldata _offchainOracle\n    ) public onlyOwner {\n        _setAsset(_asset);\n        _setOnchainOracle(_onchainOracle);\n        _setOffchainOracle(_offchainOracle);\n    }\n\n    /// @notice Setting the maximum percentage between onchain and offchain oracle.\n    /// @dev Max diff percent must be between 0 and (or equal to) 100%.\n    ///      0 means that we don't ever expect the oracle prices to differ.\n    ///      1e18 means that we don't care if the oracle prices differ.\n    /// @param _maxDiffPercent The maximum percentage between onchain and offchain oracle.\n    function setMaxDiffPercent(uint256 _maxDiffPercent) public onlyOwner {\n        if (_maxDiffPercent == 0 || _maxDiffPercent > 1e18) revert FlatcoinErrors.OracleConfigInvalid();\n\n        maxDiffPercent = _maxDiffPercent;\n\n        emit FlatcoinEvents.SetMaxDiffPercent(_maxDiffPercent);\n    }\n}"
    }
  ]
}