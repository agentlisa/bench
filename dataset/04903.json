{
  "Title": "[M-07] Incorrect __Essential_init() function is used in TaikoToken making snapshooter devoid of calling snapshot()",
  "Content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L34> <br><https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52>\n\nThe EssentialContract.sol contract is inherited by the TaikoToken contract. This essential contract contains two \\__Essential_init() functions, one with an owner parameter only (see [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L109)) and the other with owner and address manager parameters (see [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L95)).\n\nThe issue with the current code is that it uses the [\\__Essential_init()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L109) function with the owner parameter only. This would cause the [onlyFromOwnerOrNamed(\"snapshooter\")](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52) modifier on the [snapshot](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52) function to not be able to resolve the snapshooter role since the address manager contract was never set during initialization, thus causing a revert.\n\nDue to this:\n\n1.  Snapshooter role is denied from taking snapshots.\n2.  Timely snapshots for certain periods could have failed by the snapshooter since they would have required the owner to jump in by the time the issue was realized.\n3.  Correct/Intended functionality of the protocol is affected i.e. the snapshooter role assigned to an address cannot ever perform its tasks validly.\n\n### Proof of Concept\n\nHere is the whole process:\n\n1.  Snapshooter address calls the [snapshot()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52) function. The [onlyFromOwnerOrNamed(\"snapshooter\")](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52) modifier is encountered first.\n\n```solidity\nFile: TaikoToken.sol\n57:     function snapshot() public onlyFromOwnerOrNamed(\"snapshooter\") {\n58:         _snapshot();\n59:     }\n```\n\n2.  In the second condition, the [modifier](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L41) calls the [resolve()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/AddressResolver.sol#L30) function with the \"snapshooter\" role as `_name` in order to check if the caller (msg.sender) is indeed the address approved by the owner.\n\n```solidity\nFile: EssentialContract.sol\n46:     modifier onlyFromOwnerOrNamed(bytes32 _name) {\n47:         if (msg.sender != owner() && msg.sender != resolve(_name, true))\n48:             revert RESOLVER_DENIED();\n49:         _;\n50:     }\n```\n\n3.  The [resolve()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/AddressResolver.sol#L30) function is called which internally calls the function [\\_resolve()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/AddressResolver.sol#L72). In the function \\_resolve(), the condition on Line 69 evaluates to true and we revert. This is because the addressManager address was never set during initialization using the [\\__Essential_init()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L95) function with the owner and address manager parameters. Due to this, the snapshooter address is denied from performing it's allocated tasks.\n\n```solidity\nFile: AddressResolver.sol\n64:     function _resolve(\n65:         uint64 _chainId,\n66:         bytes32 _name,\n67:         bool _allowZeroAddress\n68:     ) private view returns (address payable addr_) {\n69:         if (addressManager == address(0)) revert RESOLVER_INVALID_MANAGER();\n70: \n71:         addr_ = payable(\n72:             IAddressManager(addressManager).getAddress(_chainId, _name)\n73:         );\n74: \n75:         if (!_allowZeroAddress && addr_ == address(0)) {\n76:             revert RESOLVER_ZERO_ADDR(_chainId, _name);\n77:         }\n78:     }\n```\n\n### Recommended Mitigation Steps\n\nIn the [init()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L25) function, consider using the [\\__Essential_init()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L95) function with the owner and address manager parameters instead of the [\\__Essential_init()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L109) function with the owner parameter. This would allow the snapshooter address to proceed with taking snapshots as expected.\n\n\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/261#issuecomment-2031678339):**\n > This is a valid bug report. The bug is fixed by https://github.com/taikoxyz/taiko-mono/commit/c64ec193c95113a4c33692289e23e8d9fa864073\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/L1/TaikoToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"../common/EssentialContract.sol\";\n\n/// @title TaikoToken\n/// @notice The TaikoToken (TKO), in the protocol is used for prover collateral\n/// in the form of bonds. It is an ERC20 token with 18 decimal places of\n/// precision.\n/// @dev Labeled in AddressResolver as \"taiko_token\"\n/// @custom:security-contact security@taiko.xyz\ncontract TaikoToken is EssentialContract, ERC20SnapshotUpgradeable, ERC20VotesUpgradeable {\n    uint256[50] private __gap;\n\n    error TKO_INVALID_ADDR();\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _name The name of the token.\n    /// @param _symbol The symbol of the token.\n    /// @param _recipient The address to receive initial token minting.\n    function init(\n        address _owner,\n        string calldata _name,\n        string calldata _symbol,\n        address _recipient\n    )\n        public\n        initializer\n    {\n        __Essential_init(_owner);\n        __ERC20_init(_name, _symbol);\n        __ERC20Snapshot_init();\n        __ERC20Votes_init();\n        __ERC20Permit_init(_name);\n\n        // Mint 1 billion tokens\n        _mint(_recipient, 1_000_000_000 ether);\n    }\n\n    /// @notice Burns tokens from the specified address.\n    /// @param _from The address to burn tokens from.\n    /// @param _amount The amount of tokens to burn.\n    function burn(address _from, uint256 _amount) public onlyOwner {\n        _burn(_from, _amount);\n    }\n\n    /// @notice Creates a new token snapshot.\n    function snapshot() public onlyFromOwnerOrNamed(\"snapshooter\") {\n        _snapshot();\n    }\n\n    /// @notice Transfers tokens to a specified address.\n    /// @param _to The address to transfer tokens to.\n    /// @param _amount The amount of tokens to transfer.\n    /// @return A boolean indicating whether the transfer was successful or not.\n    function transfer(address _to, uint256 _amount) public override returns (bool) {\n        if (_to == address(this)) revert TKO_INVALID_ADDR();\n        return super.transfer(_to, _amount);\n    }\n\n    /// @notice Transfers tokens from one address to another.\n    /// @param _from The address to transfer tokens from.\n    /// @param _to The address to transfer tokens to.\n    /// @param _amount The amount of tokens to transfer.\n    /// @return A boolean indicating whether the transfer was successful or not.\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        public\n        override\n        returns (bool)\n    {\n        if (_to == address(this)) revert TKO_INVALID_ADDR();\n        return super.transferFrom(_from, _to, _amount);\n    }\n\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20SnapshotUpgradeable)\n    {\n        super._beforeTokenTransfer(_from, _to, _amount);\n    }\n\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._afterTokenTransfer(_from, _to, _amount);\n    }\n\n    function _mint(\n        address _to,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._mint(_to, _amount);\n    }\n\n    function _burn(\n        address _from,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._burn(_from, _amount);\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/EssentialContract.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"./AddressResolver.sol\";\n\n/// @title EssentialContract\n/// @custom:security-contact security@taiko.xyz\nabstract contract EssentialContract is UUPSUpgradeable, Ownable2StepUpgradeable, AddressResolver {\n    uint8 private constant _FALSE = 1;\n\n    uint8 private constant _TRUE = 2;\n\n    /// @dev The slot in transient storage of the reentry lock. This is the keccak256 hash\n    /// of \"ownerUUPS.reentry_slot\"\n    bytes32 private constant _REENTRY_SLOT =\n        0xa5054f728453d3dbe953bdc43e4d0cb97e662ea32d7958190f3dc2da31d9721a;\n\n    /// @dev Slot 1.\n    uint8 private __reentry;\n\n    uint8 private __paused;\n\n    uint256[49] private __gap;\n\n    /// @notice Emitted when the contract is paused.\n    /// @param account The account that paused the contract.\n    event Paused(address account);\n\n    /// @notice Emitted when the contract is unpaused.\n    /// @param account The account that unpaused the contract.\n    event Unpaused(address account);\n\n    error REENTRANT_CALL();\n    error INVALID_PAUSE_STATUS();\n    error ZERO_ADDR_MANAGER();\n\n    /// @dev Modifier that ensures the caller is the owner or resolved address of a given name.\n    /// @param _name The name to check against.\n    modifier onlyFromOwnerOrNamed(bytes32 _name) {\n        if (msg.sender != owner() && msg.sender != resolve(_name, true)) revert RESOLVER_DENIED();\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (_loadReentryLock() == _TRUE) revert REENTRANT_CALL();\n        _storeReentryLock(_TRUE);\n        _;\n        _storeReentryLock(_FALSE);\n    }\n\n    modifier whenPaused() {\n        if (!paused()) revert INVALID_PAUSE_STATUS();\n        _;\n    }\n\n    modifier whenNotPaused() {\n        if (paused()) revert INVALID_PAUSE_STATUS();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Pauses the contract.\n    function pause() public virtual whenNotPaused {\n        __paused = _TRUE;\n        emit Paused(msg.sender);\n        // We call the authorize function here to avoid:\n        // Warning (5740): Unreachable code.\n        _authorizePause(msg.sender);\n    }\n\n    /// @notice Unpauses the contract.\n    function unpause() public virtual whenPaused {\n        __paused = _FALSE;\n        emit Unpaused(msg.sender);\n        // We call the authorize function here to avoid:\n        // Warning (5740): Unreachable code.\n        _authorizePause(msg.sender);\n    }\n\n    /// @notice Returns true if the contract is paused, and false otherwise.\n    /// @return True if paused, false otherwise.\n    function paused() public view returns (bool) {\n        return __paused == _TRUE;\n    }\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    function __Essential_init(\n        address _owner,\n        address _addressManager\n    )\n        internal\n        virtual\n        onlyInitializing\n    {\n        __Essential_init(_owner);\n\n        if (_addressManager == address(0)) revert ZERO_ADDR_MANAGER();\n        __AddressResolver_init(_addressManager);\n    }\n\n    function __Essential_init(address _owner) internal virtual {\n        _transferOwnership(_owner == address(0) ? msg.sender : _owner);\n        __paused = _FALSE;\n    }\n\n    function _authorizeUpgrade(address) internal virtual override onlyOwner { }\n\n    function _authorizePause(address) internal virtual onlyOwner { }\n\n    // Stores the reentry lock\n    function _storeReentryLock(uint8 _reentry) internal virtual {\n        if (block.chainid == 1) {\n            assembly {\n                tstore(_REENTRY_SLOT, _reentry)\n            }\n        } else {\n            __reentry = _reentry;\n        }\n    }\n\n    // Loads the reentry lock\n    function _loadReentryLock() internal view virtual returns (uint8 reentry_) {\n        if (block.chainid == 1) {\n            assembly {\n                reentry_ := tload(_REENTRY_SLOT)\n            }\n        } else {\n            reentry_ = __reentry;\n        }\n    }\n\n    function _inNonReentrant() internal view returns (bool) {\n        return _loadReentryLock() == _TRUE;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/EssentialContract.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"./AddressResolver.sol\";\n\n/// @title EssentialContract\n/// @custom:security-contact security@taiko.xyz\nabstract contract EssentialContract is UUPSUpgradeable, Ownable2StepUpgradeable, AddressResolver {\n    uint8 private constant _FALSE = 1;\n\n    uint8 private constant _TRUE = 2;\n\n    /// @dev The slot in transient storage of the reentry lock. This is the keccak256 hash\n    /// of \"ownerUUPS.reentry_slot\"\n    bytes32 private constant _REENTRY_SLOT =\n        0xa5054f728453d3dbe953bdc43e4d0cb97e662ea32d7958190f3dc2da31d9721a;\n\n    /// @dev Slot 1.\n    uint8 private __reentry;\n\n    uint8 private __paused;\n\n    uint256[49] private __gap;\n\n    /// @notice Emitted when the contract is paused.\n    /// @param account The account that paused the contract.\n    event Paused(address account);\n\n    /// @notice Emitted when the contract is unpaused.\n    /// @param account The account that unpaused the contract.\n    event Unpaused(address account);\n\n    error REENTRANT_CALL();\n    error INVALID_PAUSE_STATUS();\n    error ZERO_ADDR_MANAGER();\n\n    /// @dev Modifier that ensures the caller is the owner or resolved address of a given name.\n    /// @param _name The name to check against.\n    modifier onlyFromOwnerOrNamed(bytes32 _name) {\n        if (msg.sender != owner() && msg.sender != resolve(_name, true)) revert RESOLVER_DENIED();\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (_loadReentryLock() == _TRUE) revert REENTRANT_CALL();\n        _storeReentryLock(_TRUE);\n        _;\n        _storeReentryLock(_FALSE);\n    }\n\n    modifier whenPaused() {\n        if (!paused()) revert INVALID_PAUSE_STATUS();\n        _;\n    }\n\n    modifier whenNotPaused() {\n        if (paused()) revert INVALID_PAUSE_STATUS();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Pauses the contract.\n    function pause() public virtual whenNotPaused {\n        __paused = _TRUE;\n        emit Paused(msg.sender);\n        // We call the authorize function here to avoid:\n        // Warning (5740): Unreachable code.\n        _authorizePause(msg.sender);\n    }\n\n    /// @notice Unpauses the contract.\n    function unpause() public virtual whenPaused {\n        __paused = _FALSE;\n        emit Unpaused(msg.sender);\n        // We call the authorize function here to avoid:\n        // Warning (5740): Unreachable code.\n        _authorizePause(msg.sender);\n    }\n\n    /// @notice Returns true if the contract is paused, and false otherwise.\n    /// @return True if paused, false otherwise.\n    function paused() public view returns (bool) {\n        return __paused == _TRUE;\n    }\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    function __Essential_init(\n        address _owner,\n        address _addressManager\n    )\n        internal\n        virtual\n        onlyInitializing\n    {\n        __Essential_init(_owner);\n\n        if (_addressManager == address(0)) revert ZERO_ADDR_MANAGER();\n        __AddressResolver_init(_addressManager);\n    }\n\n    function __Essential_init(address _owner) internal virtual {\n        _transferOwnership(_owner == address(0) ? msg.sender : _owner);\n        __paused = _FALSE;\n    }\n\n    function _authorizeUpgrade(address) internal virtual override onlyOwner { }\n\n    function _authorizePause(address) internal virtual onlyOwner { }\n\n    // Stores the reentry lock\n    function _storeReentryLock(uint8 _reentry) internal virtual {\n        if (block.chainid == 1) {\n            assembly {\n                tstore(_REENTRY_SLOT, _reentry)\n            }\n        } else {\n            __reentry = _reentry;\n        }\n    }\n\n    // Loads the reentry lock\n    function _loadReentryLock() internal view virtual returns (uint8 reentry_) {\n        if (block.chainid == 1) {\n            assembly {\n                reentry_ := tload(_REENTRY_SLOT)\n            }\n        } else {\n            reentry_ = __reentry;\n        }\n    }\n\n    function _inNonReentrant() internal view returns (bool) {\n        return _loadReentryLock() == _TRUE;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L1/TaikoToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"../common/EssentialContract.sol\";\n\n/// @title TaikoToken\n/// @notice The TaikoToken (TKO), in the protocol is used for prover collateral\n/// in the form of bonds. It is an ERC20 token with 18 decimal places of\n/// precision.\n/// @dev Labeled in AddressResolver as \"taiko_token\"\n/// @custom:security-contact security@taiko.xyz\ncontract TaikoToken is EssentialContract, ERC20SnapshotUpgradeable, ERC20VotesUpgradeable {\n    uint256[50] private __gap;\n\n    error TKO_INVALID_ADDR();\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _name The name of the token.\n    /// @param _symbol The symbol of the token.\n    /// @param _recipient The address to receive initial token minting.\n    function init(\n        address _owner,\n        string calldata _name,\n        string calldata _symbol,\n        address _recipient\n    )\n        public\n        initializer\n    {\n        __Essential_init(_owner);\n        __ERC20_init(_name, _symbol);\n        __ERC20Snapshot_init();\n        __ERC20Votes_init();\n        __ERC20Permit_init(_name);\n\n        // Mint 1 billion tokens\n        _mint(_recipient, 1_000_000_000 ether);\n    }\n\n    /// @notice Burns tokens from the specified address.\n    /// @param _from The address to burn tokens from.\n    /// @param _amount The amount of tokens to burn.\n    function burn(address _from, uint256 _amount) public onlyOwner {\n        _burn(_from, _amount);\n    }\n\n    /// @notice Creates a new token snapshot.\n    function snapshot() public onlyFromOwnerOrNamed(\"snapshooter\") {\n        _snapshot();\n    }\n\n    /// @notice Transfers tokens to a specified address.\n    /// @param _to The address to transfer tokens to.\n    /// @param _amount The amount of tokens to transfer.\n    /// @return A boolean indicating whether the transfer was successful or not.\n    function transfer(address _to, uint256 _amount) public override returns (bool) {\n        if (_to == address(this)) revert TKO_INVALID_ADDR();\n        return super.transfer(_to, _amount);\n    }\n\n    /// @notice Transfers tokens from one address to another.\n    /// @param _from The address to transfer tokens from.\n    /// @param _to The address to transfer tokens to.\n    /// @param _amount The amount of tokens to transfer.\n    /// @return A boolean indicating whether the transfer was successful or not.\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        public\n        override\n        returns (bool)\n    {\n        if (_to == address(this)) revert TKO_INVALID_ADDR();\n        return super.transferFrom(_from, _to, _amount);\n    }\n\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20SnapshotUpgradeable)\n    {\n        super._beforeTokenTransfer(_from, _to, _amount);\n    }\n\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._afterTokenTransfer(_from, _to, _amount);\n    }\n\n    function _mint(\n        address _to,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._mint(_to, _amount);\n    }\n\n    function _burn(\n        address _from,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._burn(_from, _amount);\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/EssentialContract.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"./AddressResolver.sol\";\n\n/// @title EssentialContract\n/// @custom:security-contact security@taiko.xyz\nabstract contract EssentialContract is UUPSUpgradeable, Ownable2StepUpgradeable, AddressResolver {\n    uint8 private constant _FALSE = 1;\n\n    uint8 private constant _TRUE = 2;\n\n    /// @dev The slot in transient storage of the reentry lock. This is the keccak256 hash\n    /// of \"ownerUUPS.reentry_slot\"\n    bytes32 private constant _REENTRY_SLOT =\n        0xa5054f728453d3dbe953bdc43e4d0cb97e662ea32d7958190f3dc2da31d9721a;\n\n    /// @dev Slot 1.\n    uint8 private __reentry;\n\n    uint8 private __paused;\n\n    uint256[49] private __gap;\n\n    /// @notice Emitted when the contract is paused.\n    /// @param account The account that paused the contract.\n    event Paused(address account);\n\n    /// @notice Emitted when the contract is unpaused.\n    /// @param account The account that unpaused the contract.\n    event Unpaused(address account);\n\n    error REENTRANT_CALL();\n    error INVALID_PAUSE_STATUS();\n    error ZERO_ADDR_MANAGER();\n\n    /// @dev Modifier that ensures the caller is the owner or resolved address of a given name.\n    /// @param _name The name to check against.\n    modifier onlyFromOwnerOrNamed(bytes32 _name) {\n        if (msg.sender != owner() && msg.sender != resolve(_name, true)) revert RESOLVER_DENIED();\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (_loadReentryLock() == _TRUE) revert REENTRANT_CALL();\n        _storeReentryLock(_TRUE);\n        _;\n        _storeReentryLock(_FALSE);\n    }\n\n    modifier whenPaused() {\n        if (!paused()) revert INVALID_PAUSE_STATUS();\n        _;\n    }\n\n    modifier whenNotPaused() {\n        if (paused()) revert INVALID_PAUSE_STATUS();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Pauses the contract.\n    function pause() public virtual whenNotPaused {\n        __paused = _TRUE;\n        emit Paused(msg.sender);\n        // We call the authorize function here to avoid:\n        // Warning (5740): Unreachable code.\n        _authorizePause(msg.sender);\n    }\n\n    /// @notice Unpauses the contract.\n    function unpause() public virtual whenPaused {\n        __paused = _FALSE;\n        emit Unpaused(msg.sender);\n        // We call the authorize function here to avoid:\n        // Warning (5740): Unreachable code.\n        _authorizePause(msg.sender);\n    }\n\n    /// @notice Returns true if the contract is paused, and false otherwise.\n    /// @return True if paused, false otherwise.\n    function paused() public view returns (bool) {\n        return __paused == _TRUE;\n    }\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    function __Essential_init(\n        address _owner,\n        address _addressManager\n    )\n        internal\n        virtual\n        onlyInitializing\n    {\n        __Essential_init(_owner);\n\n        if (_addressManager == address(0)) revert ZERO_ADDR_MANAGER();\n        __AddressResolver_init(_addressManager);\n    }\n\n    function __Essential_init(address _owner) internal virtual {\n        _transferOwnership(_owner == address(0) ? msg.sender : _owner);\n        __paused = _FALSE;\n    }\n\n    function _authorizeUpgrade(address) internal virtual override onlyOwner { }\n\n    function _authorizePause(address) internal virtual onlyOwner { }\n\n    // Stores the reentry lock\n    function _storeReentryLock(uint8 _reentry) internal virtual {\n        if (block.chainid == 1) {\n            assembly {\n                tstore(_REENTRY_SLOT, _reentry)\n            }\n        } else {\n            __reentry = _reentry;\n        }\n    }\n\n    // Loads the reentry lock\n    function _loadReentryLock() internal view virtual returns (uint8 reentry_) {\n        if (block.chainid == 1) {\n            assembly {\n                reentry_ := tload(_REENTRY_SLOT)\n            }\n        } else {\n            reentry_ = __reentry;\n        }\n    }\n\n    function _inNonReentrant() internal view returns (bool) {\n        return _loadReentryLock() == _TRUE;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/AddressResolver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./IAddressManager.sol\";\nimport \"./IAddressResolver.sol\";\n\n/// @title AddressResolver\n/// @notice See the documentation in {IAddressResolver}.\n/// @custom:security-contact security@taiko.xyz\nabstract contract AddressResolver is IAddressResolver, Initializable {\n    /// @notice Address of the AddressManager.\n    address public addressManager;\n    uint256[49] private __gap;\n\n    error RESOLVER_DENIED();\n    error RESOLVER_INVALID_MANAGER();\n    error RESOLVER_UNEXPECTED_CHAINID();\n    error RESOLVER_ZERO_ADDR(uint64 chainId, bytes32 name);\n\n    /// @dev Modifier that ensures the caller is the resolved address of a given\n    /// name.\n    /// @param _name The name to check against.\n    modifier onlyFromNamed(bytes32 _name) {\n        if (msg.sender != resolve(_name, true)) revert RESOLVER_DENIED();\n        _;\n    }\n\n    /// @inheritdoc IAddressResolver\n    function resolve(\n        bytes32 _name,\n        bool _allowZeroAddress\n    )\n        public\n        view\n        virtual\n        returns (address payable)\n    {\n        return _resolve(uint64(block.chainid), _name, _allowZeroAddress);\n    }\n\n    /// @inheritdoc IAddressResolver\n    function resolve(\n        uint64 _chainId,\n        bytes32 _name,\n        bool _allowZeroAddress\n    )\n        public\n        view\n        virtual\n        returns (address payable)\n    {\n        return _resolve(_chainId, _name, _allowZeroAddress);\n    }\n\n    /// @dev Initialization method for setting up AddressManager reference.\n    /// @param _addressManager Address of the AddressManager.\n    function __AddressResolver_init(address _addressManager) internal virtual onlyInitializing {\n        if (block.chainid > type(uint64).max) {\n            revert RESOLVER_UNEXPECTED_CHAINID();\n        }\n        addressManager = _addressManager;\n    }\n\n    /// @dev Helper method to resolve name-to-address.\n    /// @param _chainId The chainId of interest.\n    /// @param _name Name whose address is to be resolved.\n    /// @param _allowZeroAddress If set to true, does not throw if the resolved\n    /// address is `address(0)`.\n    /// @return addr_ Address associated with the given name on the specified\n    /// chain.\n    function _resolve(\n        uint64 _chainId,\n        bytes32 _name,\n        bool _allowZeroAddress\n    )\n        private\n        view\n        returns (address payable addr_)\n    {\n        if (addressManager == address(0)) revert RESOLVER_INVALID_MANAGER();\n\n        addr_ = payable(IAddressManager(addressManager).getAddress(_chainId, _name));\n\n        if (!_allowZeroAddress && addr_ == address(0)) {\n            revert RESOLVER_ZERO_ADDR(_chainId, _name);\n        }\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L1/TaikoToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"../common/EssentialContract.sol\";\n\n/// @title TaikoToken\n/// @notice The TaikoToken (TKO), in the protocol is used for prover collateral\n/// in the form of bonds. It is an ERC20 token with 18 decimal places of\n/// precision.\n/// @dev Labeled in AddressResolver as \"taiko_token\"\n/// @custom:security-contact security@taiko.xyz\ncontract TaikoToken is EssentialContract, ERC20SnapshotUpgradeable, ERC20VotesUpgradeable {\n    uint256[50] private __gap;\n\n    error TKO_INVALID_ADDR();\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _name The name of the token.\n    /// @param _symbol The symbol of the token.\n    /// @param _recipient The address to receive initial token minting.\n    function init(\n        address _owner,\n        string calldata _name,\n        string calldata _symbol,\n        address _recipient\n    )\n        public\n        initializer\n    {\n        __Essential_init(_owner);\n        __ERC20_init(_name, _symbol);\n        __ERC20Snapshot_init();\n        __ERC20Votes_init();\n        __ERC20Permit_init(_name);\n\n        // Mint 1 billion tokens\n        _mint(_recipient, 1_000_000_000 ether);\n    }\n\n    /// @notice Burns tokens from the specified address.\n    /// @param _from The address to burn tokens from.\n    /// @param _amount The amount of tokens to burn.\n    function burn(address _from, uint256 _amount) public onlyOwner {\n        _burn(_from, _amount);\n    }\n\n    /// @notice Creates a new token snapshot.\n    function snapshot() public onlyFromOwnerOrNamed(\"snapshooter\") {\n        _snapshot();\n    }\n\n    /// @notice Transfers tokens to a specified address.\n    /// @param _to The address to transfer tokens to.\n    /// @param _amount The amount of tokens to transfer.\n    /// @return A boolean indicating whether the transfer was successful or not.\n    function transfer(address _to, uint256 _amount) public override returns (bool) {\n        if (_to == address(this)) revert TKO_INVALID_ADDR();\n        return super.transfer(_to, _amount);\n    }\n\n    /// @notice Transfers tokens from one address to another.\n    /// @param _from The address to transfer tokens from.\n    /// @param _to The address to transfer tokens to.\n    /// @param _amount The amount of tokens to transfer.\n    /// @return A boolean indicating whether the transfer was successful or not.\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        public\n        override\n        returns (bool)\n    {\n        if (_to == address(this)) revert TKO_INVALID_ADDR();\n        return super.transferFrom(_from, _to, _amount);\n    }\n\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20SnapshotUpgradeable)\n    {\n        super._beforeTokenTransfer(_from, _to, _amount);\n    }\n\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._afterTokenTransfer(_from, _to, _amount);\n    }\n\n    function _mint(\n        address _to,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._mint(_to, _amount);\n    }\n\n    function _burn(\n        address _from,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._burn(_from, _amount);\n    }\n}"
    }
  ]
}