{
  "Title": "`SablierV2Lockup.sol` - The caller of withdraw and renounce can skip callbacks, by sending less gas",
  "Content": "# `SablierV2Lockup.sol` - The caller of withdraw and renounce can skip callbacks, by sending less gas\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-core/src/abstracts/SablierV2Lockup.sol#L394-L400\">https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-core/src/abstracts/SablierV2Lockup.sol#L394-L400</a>\n\n\n## Summary\nBoth `withdraw` and `renounce` implement a total of 3 callbacks.\nIn the case of `withdraw` there is a callback to the recipient and to the sender and in the case of `renounce`, only a callback to the recipient.\nThe issue here is that the caller of the function chooses how much gas he uses for the transaction, because of this he can specify an amount of gas that would be enough to execute the entire transaction, but not enough to execute the callbacks.\n## Vulnerability Details\nSince `withdraw` is called by either the owner of the NFT or an approved operator, either one can call withdraw with an amount of gas that won't be enough for the sender callback to execute.\nIn the case of `renounce`, the sender can specify an amount of gas that won't be enough to execute the callback of the recipient.\n\nSince the callback is wrapped in a `try/catch`, the caller can send enough gas so that the callback won't have enough to execute, reverting and entering the catch block, but the whole transaction will still have enough to execute. This happens because of the 63/64 rule, when an external call is made only 63/64 gas is forwarded to it, meaning there is always some leftover gas so the rest of the transaction can execute.\n\nIn our case, only an event is emitted after the callbacks, so we only need around 1600 gas left over.\nThis means that sender may calculate the gas, so the callback will recieve `63 * 1600 = 100800`, which may not be enough for the complex operations inside the callback. This would result in failed callback execution, but success in `_withdraw`, function, because we have a `catch` block and another 1600 gas to emit the event after the callback:\n```\n        if (msg.sender != sender && sender.code.length > 0 && sender != recipient) {\n            try ISablierV2Sender(sender).onLockupStreamWithdrawn({\n                streamId: streamId,\n                caller: msg.sender,\n                to: to,\n                amount: amount\n            }) { } catch { }\n        }\n```\n\nAs stated by the protocol, the callbacks can be complex and vital to both the `sender` and the `recipient`, so skipping them is not good, as logic that might be vital to them, won't execute and those 100800 units of gas may not be enough.\n\nREADME statement: \n```\nIn SablierV2Lockup, when onLockupStreamCanceled(), onLockupStreamWithdrawn() and onLockupStreamRenounced() hooks are called, there could be gas bomb attacks because we do not limit the gas transferred to the external contract. This is intended to support complex transactions implemented in those hooks.\n```\n\n__NOTE__\nNote that this issue differs from one, which enforces function caller to send more gas, because of the event emission after the callback. The fix for that, would even make the current attack path easier to implement for malicious actor, because he could make callback function receive even less gas and still accomplish successful `withdraw` transaction \n## Impact\nSkipping important logic, breaking the atomicity of the system.\n\n## Tools Used\nManual Review\n\n## Recommendations\n\nNot sure what is the best solution here. \nThe best would be to remove the callback functionality. Only events could be emitted and if partyes are interested in taking executing actions on those events, they will implement off-chain listeners with event emittion as triggeres. ",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clvb9njmy00012dqjyaavpl44",
  "Code": [
    {
      "filename": "v2-core/src/abstracts/SablierV2Lockup.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.22;\n\nimport { IERC4906 } from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC721Metadata } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport { UD60x18 } from \"@prb/math/src/UD60x18.sol\";\n\nimport { ISablierV2Recipient } from \"../interfaces/hooks/ISablierV2Recipient.sol\";\nimport { ISablierV2Sender } from \"../interfaces/hooks/ISablierV2Sender.sol\";\nimport { ISablierV2Lockup } from \"../interfaces/ISablierV2Lockup.sol\";\nimport { ISablierV2NFTDescriptor } from \"../interfaces/ISablierV2NFTDescriptor.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport { Lockup } from \"../types/DataTypes.sol\";\nimport { Adminable } from \"./Adminable.sol\";\nimport { NoDelegateCall } from \"./NoDelegateCall.sol\";\n\n/// @title SablierV2Lockup\n/// @notice See the documentation in {ISablierV2Lockup}.\nabstract contract SablierV2Lockup is\n    NoDelegateCall, // 0 inherited components\n    Adminable, // 1 inherited components\n    IERC4906, // 2 inherited components\n    ISablierV2Lockup, // 4 inherited components\n    ERC721 // 6 inherited components\n{\n    using SafeERC20 for IERC20;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                  STATE VARIABLES\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    UD60x18 public constant override MAX_BROKER_FEE = UD60x18.wrap(0.1e18);\n\n    /// @inheritdoc ISablierV2Lockup\n    uint256 public override nextStreamId;\n\n    /// @inheritdoc ISablierV2Lockup\n    ISablierV2NFTDescriptor public override nftDescriptor;\n\n    /// @dev Sablier V2 Lockup streams mapped by unsigned integers.\n    mapping(uint256 id => Lockup.Stream stream) internal _streams;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Emits a {TransferAdmin} event.\n    /// @param initialAdmin The address of the initial contract admin.\n    /// @param initialNFTDescriptor The address of the initial NFT descriptor.\n    constructor(address initialAdmin, ISablierV2NFTDescriptor initialNFTDescriptor) {\n        admin = initialAdmin;\n        nftDescriptor = initialNFTDescriptor;\n        emit TransferAdmin({ oldAdmin: address(0), newAdmin: initialAdmin });\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      MODIFIERS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks that `streamId` does not reference a null stream.\n    modifier notNull(uint256 streamId) {\n        if (!_streams[streamId].isStream) {\n            revert Errors.SablierV2Lockup_Null(streamId);\n        }\n        _;\n    }\n\n    /// @dev Emits an ERC-4906 event to trigger an update of the NFT metadata.\n    modifier updateMetadata(uint256 streamId) {\n        _;\n        emit MetadataUpdate({ _tokenId: streamId });\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           USER-FACING CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    function getAsset(uint256 streamId) external view override notNull(streamId) returns (IERC20 asset) {\n        asset = _streams[streamId].asset;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getDepositedAmount(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 depositedAmount)\n    {\n        depositedAmount = _streams[streamId].amounts.deposited;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getEndTime(uint256 streamId) external view override notNull(streamId) returns (uint40 endTime) {\n        endTime = _streams[streamId].endTime;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getRecipient(uint256 streamId) external view override returns (address recipient) {\n        // Check the stream NFT exists and return the owner, which is the stream's recipient.\n        recipient = _requireOwned({ tokenId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getRefundedAmount(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 refundedAmount)\n    {\n        refundedAmount = _streams[streamId].amounts.refunded;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getSender(uint256 streamId) external view override notNull(streamId) returns (address sender) {\n        sender = _streams[streamId].sender;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getStartTime(uint256 streamId) external view override notNull(streamId) returns (uint40 startTime) {\n        startTime = _streams[streamId].startTime;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getWithdrawnAmount(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 withdrawnAmount)\n    {\n        withdrawnAmount = _streams[streamId].amounts.withdrawn;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isCancelable(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        if (_statusOf(streamId) != Lockup.Status.SETTLED) {\n            result = _streams[streamId].isCancelable;\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isCold(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        Lockup.Status status = _statusOf(streamId);\n        result = status == Lockup.Status.SETTLED || status == Lockup.Status.CANCELED || status == Lockup.Status.DEPLETED;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isDepleted(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        result = _streams[streamId].isDepleted;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isStream(uint256 streamId) external view override returns (bool result) {\n        result = _streams[streamId].isStream;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isTransferable(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        result = _streams[streamId].isTransferable;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isWarm(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        Lockup.Status status = _statusOf(streamId);\n        result = status == Lockup.Status.PENDING || status == Lockup.Status.STREAMING;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function refundableAmountOf(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 refundableAmount)\n    {\n        // These checks are needed because {_calculateStreamedAmount} does not look up the stream's status. Note that\n        // checking for `isCancelable` also checks if the stream `wasCanceled` thanks to the protocol invariant that\n        // canceled streams are not cancelable anymore.\n        if (_streams[streamId].isCancelable && !_streams[streamId].isDepleted) {\n            refundableAmount = _streams[streamId].amounts.deposited - _calculateStreamedAmount(streamId);\n        }\n        // Otherwise, the result is implicitly zero.\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function statusOf(uint256 streamId) external view override notNull(streamId) returns (Lockup.Status status) {\n        status = _statusOf(streamId);\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function streamedAmountOf(uint256 streamId)\n        public\n        view\n        override\n        notNull(streamId)\n        returns (uint128 streamedAmount)\n    {\n        streamedAmount = _streamedAmountOf(streamId);\n    }\n\n    /// @inheritdoc ERC721\n    function tokenURI(uint256 streamId) public view override(IERC721Metadata, ERC721) returns (string memory uri) {\n        // Check: the stream NFT exists.\n        _requireOwned({ tokenId: streamId });\n\n        // Generate the URI describing the stream NFT.\n        uri = nftDescriptor.tokenURI({ sablier: this, streamId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function wasCanceled(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        result = _streams[streamId].wasCanceled;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawableAmountOf(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 withdrawableAmount)\n    {\n        withdrawableAmount = _withdrawableAmountOf(streamId);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                         USER-FACING NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    function burn(uint256 streamId) external override noDelegateCall notNull(streamId) {\n        // Check: only depleted streams can be burned.\n        if (!_streams[streamId].isDepleted) {\n            revert Errors.SablierV2Lockup_StreamNotDepleted(streamId);\n        }\n\n        // Check:\n        // 1. NFT exists (see {IERC721.getApproved}).\n        // 2. `msg.sender` is either the owner of the NFT or an approved third party.\n        if (!_isCallerStreamRecipientOrApproved(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Effect: burn the NFT.\n        _burn({ tokenId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function cancel(uint256 streamId) public override noDelegateCall notNull(streamId) {\n        // Check: the stream is neither depleted nor canceled.\n        if (_streams[streamId].isDepleted) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        } else if (_streams[streamId].wasCanceled) {\n            revert Errors.SablierV2Lockup_StreamCanceled(streamId);\n        }\n\n        // Check: `msg.sender` is the stream's sender.\n        if (!_isCallerStreamSender(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Checks, Effects and Interactions: cancel the stream.\n        _cancel(streamId);\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function cancelMultiple(uint256[] calldata streamIds) external override noDelegateCall {\n        // Iterate over the provided array of stream IDs and cancel each stream.\n        uint256 count = streamIds.length;\n        for (uint256 i = 0; i < count; ++i) {\n            // Effects and Interactions: cancel the stream.\n            cancel(streamIds[i]);\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function renounce(uint256 streamId) external override noDelegateCall notNull(streamId) updateMetadata(streamId) {\n        // Check: the stream is not cold.\n        Lockup.Status status = _statusOf(streamId);\n        if (status == Lockup.Status.DEPLETED) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        } else if (status == Lockup.Status.CANCELED) {\n            revert Errors.SablierV2Lockup_StreamCanceled(streamId);\n        } else if (status == Lockup.Status.SETTLED) {\n            revert Errors.SablierV2Lockup_StreamSettled(streamId);\n        }\n\n        // Check: `msg.sender` is the stream's sender.\n        if (!_isCallerStreamSender(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Checks and Effects: renounce the stream.\n        _renounce(streamId);\n\n        // Log the renouncement.\n        emit ISablierV2Lockup.RenounceLockupStream(streamId);\n\n        // Interaction: if the recipient is a contract, try to invoke the renounce hook on the recipient without\n        // reverting if the hook is not implemented, and also without bubbling up any potential revert.\n        address recipient = _ownerOf(streamId);\n        if (recipient.code.length > 0) {\n            try ISablierV2Recipient(recipient).onLockupStreamRenounced(streamId) { } catch { }\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function setNFTDescriptor(ISablierV2NFTDescriptor newNFTDescriptor) external override onlyAdmin {\n        // Effect: set the NFT descriptor.\n        ISablierV2NFTDescriptor oldNftDescriptor = nftDescriptor;\n        nftDescriptor = newNFTDescriptor;\n\n        // Log the change of the NFT descriptor.\n        emit ISablierV2Lockup.SetNFTDescriptor({\n            admin: msg.sender,\n            oldNFTDescriptor: oldNftDescriptor,\n            newNFTDescriptor: newNFTDescriptor\n        });\n\n        // Refresh the NFT metadata for all streams.\n        emit BatchMetadataUpdate({ _fromTokenId: 1, _toTokenId: nextStreamId - 1 });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdraw(\n        uint256 streamId,\n        address to,\n        uint128 amount\n    )\n        public\n        override\n        noDelegateCall\n        notNull(streamId)\n        updateMetadata(streamId)\n    {\n        // Check: the stream is not depleted.\n        if (_streams[streamId].isDepleted) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        }\n\n        // Check: the withdrawal address is not zero.\n        if (to == address(0)) {\n            revert Errors.SablierV2Lockup_WithdrawToZeroAddress(streamId);\n        }\n\n        // Check: the withdraw amount is not zero.\n        if (amount == 0) {\n            revert Errors.SablierV2Lockup_WithdrawAmountZero(streamId);\n        }\n\n        // Retrieve the recipient from storage.\n        address recipient = _ownerOf(streamId);\n\n        // Check: if `msg.sender` is neither the stream's recipient nor an approved third party, the withdrawal address\n        // must be the recipient.\n        if (to != recipient && !_isCallerStreamRecipientOrApproved(streamId)) {\n            revert Errors.SablierV2Lockup_WithdrawalAddressNotRecipient(streamId, msg.sender, to);\n        }\n\n        // Check: the withdraw amount is not greater than the withdrawable amount.\n        uint128 withdrawableAmount = _withdrawableAmountOf(streamId);\n        if (amount > withdrawableAmount) {\n            revert Errors.SablierV2Lockup_Overdraw(streamId, amount, withdrawableAmount);\n        }\n\n        // Retrieve the sender from storage.\n        address sender = _streams[streamId].sender;\n\n        // Effects and Interactions: make the withdrawal.\n        _withdraw(streamId, to, amount);\n\n        // Interaction: if `msg.sender` is not the recipient and the recipient is a contract, try to invoke the\n        // withdraw hook on it without reverting if the hook is not implemented, and also without bubbling up\n        // any potential revert.\n        if (msg.sender != recipient && recipient.code.length > 0) {\n            try ISablierV2Recipient(recipient).onLockupStreamWithdrawn({\n                streamId: streamId,\n                caller: msg.sender,\n                to: to,\n                amount: amount\n            }) { } catch { }\n        }\n\n        // Interaction: if `msg.sender` is not the sender, the sender is a contract and is different from the\n        // recipient, try to invoke the withdraw hook on it without reverting if the hook is not implemented, and also\n        // without bubbling up any potential revert.\n        if (msg.sender != sender && sender.code.length > 0 && sender != recipient) {\n            try ISablierV2Sender(sender).onLockupStreamWithdrawn({\n                streamId: streamId,\n                caller: msg.sender,\n                to: to,\n                amount: amount\n            }) { } catch { }\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMax(uint256 streamId, address to) external override {\n        withdraw({ streamId: streamId, to: to, amount: _withdrawableAmountOf(streamId) });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMaxAndTransfer(\n        uint256 streamId,\n        address newRecipient\n    )\n        external\n        override\n        noDelegateCall\n        notNull(streamId)\n    {\n        // Check: the caller is the current recipient. This also checks that the NFT was not burned.\n        address currentRecipient = _ownerOf(streamId);\n        if (msg.sender != currentRecipient) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Skip the withdrawal if the withdrawable amount is zero.\n        uint128 withdrawableAmount = _withdrawableAmountOf(streamId);\n        if (withdrawableAmount > 0) {\n            withdraw({ streamId: streamId, to: currentRecipient, amount: withdrawableAmount });\n        }\n\n        // Checks and Effects: transfer the NFT.\n        _transfer({ from: currentRecipient, to: newRecipient, tokenId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMultiple(\n        uint256[] calldata streamIds,\n        uint128[] calldata amounts\n    )\n        external\n        override\n        noDelegateCall\n    {\n        // Check: there is an equal number of `streamIds` and `amounts`.\n        uint256 streamIdsCount = streamIds.length;\n        uint256 amountsCount = amounts.length;\n        if (streamIdsCount != amountsCount) {\n            revert Errors.SablierV2Lockup_WithdrawArrayCountsNotEqual(streamIdsCount, amountsCount);\n        }\n\n        // Iterate over the provided array of stream IDs, and withdraw from each stream to the recipient.\n        for (uint256 i = 0; i < streamIdsCount; ++i) {\n            // Checks, Effects and Interactions: check the parameters and make the withdrawal.\n            withdraw({ streamId: streamIds[i], to: _ownerOf(streamIds[i]), amount: amounts[i] });\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                             INTERNAL CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Calculates the streamed amount of the stream without looking up the stream's status.\n    /// @dev This function is implemented by child contracts, so the logic varies depending on the model.\n    function _calculateStreamedAmount(uint256 streamId) internal view virtual returns (uint128);\n\n    /// @notice Checks whether `msg.sender` is the stream's recipient or an approved third party.\n    /// @param streamId The stream ID for the query.\n    function _isCallerStreamRecipientOrApproved(uint256 streamId) internal view returns (bool) {\n        address recipient = _ownerOf(streamId);\n        return msg.sender == recipient || isApprovedForAll({ owner: recipient, operator: msg.sender })\n            || getApproved(streamId) == msg.sender;\n    }\n\n    /// @notice Checks whether `msg.sender` is the stream's sender.\n    /// @param streamId The stream ID for the query.\n    function _isCallerStreamSender(uint256 streamId) internal view returns (bool) {\n        return msg.sender == _streams[streamId].sender;\n    }\n\n    /// @dev Retrieves the stream's status without performing a null check.\n    function _statusOf(uint256 streamId) internal view returns (Lockup.Status) {\n        if (_streams[streamId].isDepleted) {\n            return Lockup.Status.DEPLETED;\n        } else if (_streams[streamId].wasCanceled) {\n            return Lockup.Status.CANCELED;\n        }\n\n        if (block.timestamp < _streams[streamId].startTime) {\n            return Lockup.Status.PENDING;\n        }\n\n        if (_calculateStreamedAmount(streamId) < _streams[streamId].amounts.deposited) {\n            return Lockup.Status.STREAMING;\n        } else {\n            return Lockup.Status.SETTLED;\n        }\n    }\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _streamedAmountOf(uint256 streamId) internal view returns (uint128) {\n        Lockup.Amounts memory amounts = _streams[streamId].amounts;\n\n        if (_streams[streamId].isDepleted) {\n            return amounts.withdrawn;\n        } else if (_streams[streamId].wasCanceled) {\n            return amounts.deposited - amounts.refunded;\n        }\n\n        return _calculateStreamedAmount(streamId);\n    }\n\n    /// @notice Overrides the {ERC-721._update} function to check that the stream is transferable, and emits an\n    /// ERC-4906 event.\n    /// @dev There are two cases when the transferable flag is ignored:\n    /// - If the current owner is 0, then the update is a mint and is allowed.\n    /// - If `to` is 0, then the update is a burn and is also allowed.\n    /// @param to The address of the new recipient of the stream.\n    /// @param streamId ID of the stream to update.\n    /// @param auth Optional parameter. If the value is not zero, the overridden implementation will check that\n    /// `auth` is either the recipient of the stream, or an approved third party.\n    /// @return The original recipient of the `streamId` before the update.\n    function _update(\n        address to,\n        uint256 streamId,\n        address auth\n    )\n        internal\n        override\n        updateMetadata(streamId)\n        returns (address)\n    {\n        address from = _ownerOf(streamId);\n\n        if (from != address(0) && to != address(0) && !_streams[streamId].isTransferable) {\n            revert Errors.SablierV2Lockup_NotTransferable(streamId);\n        }\n\n        return super._update(to, streamId, auth);\n    }\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _withdrawableAmountOf(uint256 streamId) internal view returns (uint128) {\n        return _streamedAmountOf(streamId) - _streams[streamId].amounts.withdrawn;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           INTERNAL NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _cancel(uint256 streamId) internal {\n        // Calculate the streamed amount.\n        uint128 streamedAmount = _calculateStreamedAmount(streamId);\n\n        // Retrieve the amounts from storage.\n        Lockup.Amounts memory amounts = _streams[streamId].amounts;\n\n        // Check: the stream is not settled.\n        if (streamedAmount >= amounts.deposited) {\n            revert Errors.SablierV2Lockup_StreamSettled(streamId);\n        }\n\n        // Check: the stream is cancelable.\n        if (!_streams[streamId].isCancelable) {\n            revert Errors.SablierV2Lockup_StreamNotCancelable(streamId);\n        }\n\n        // Calculate the sender's amount.\n        uint128 senderAmount;\n        unchecked {\n            senderAmount = amounts.deposited - streamedAmount;\n        }\n\n        // Calculate the recipient's amount.\n        uint128 recipientAmount = streamedAmount - amounts.withdrawn;\n\n        // Effect: mark the stream as canceled.\n        _streams[streamId].wasCanceled = true;\n\n        // Effect: make the stream not cancelable anymore, because a stream can only be canceled once.\n        _streams[streamId].isCancelable = false;\n\n        // Effect: if there are no assets left for the recipient to withdraw, mark the stream as depleted.\n        if (recipientAmount == 0) {\n            _streams[streamId].isDepleted = true;\n        }\n\n        // Effect: set the refunded amount.\n        _streams[streamId].amounts.refunded = senderAmount;\n\n        // Retrieve the sender and the recipient from storage.\n        address sender = _streams[streamId].sender;\n        address recipient = _ownerOf(streamId);\n\n        // Retrieve the ERC-20 asset from storage.\n        IERC20 asset = _streams[streamId].asset;\n\n        // Interaction: refund the sender.\n        asset.safeTransfer({ to: sender, value: senderAmount });\n\n        // Log the cancellation.\n        emit ISablierV2Lockup.CancelLockupStream(streamId, sender, recipient, asset, senderAmount, recipientAmount);\n\n        // Emits an ERC-4906 event to trigger an update of the NFT metadata.\n        emit MetadataUpdate({ _tokenId: streamId });\n\n        // Interaction: if the recipient is a contract, try to invoke the cancel hook on the recipient without\n        // reverting if the hook is not implemented, and without bubbling up any potential revert.\n        if (recipient.code.length > 0) {\n            try ISablierV2Recipient(recipient).onLockupStreamCanceled({\n                streamId: streamId,\n                sender: sender,\n                senderAmount: senderAmount,\n                recipientAmount: recipientAmount\n            }) { } catch { }\n        }\n    }\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _renounce(uint256 streamId) internal {\n        // Check: the stream is cancelable.\n        if (!_streams[streamId].isCancelable) {\n            revert Errors.SablierV2Lockup_StreamNotCancelable(streamId);\n        }\n\n        // Effect: renounce the stream by making it not cancelable.\n        _streams[streamId].isCancelable = false;\n    }\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _withdraw(uint256 streamId, address to, uint128 amount) internal {\n        // Effect: update the withdrawn amount.\n        _streams[streamId].amounts.withdrawn = _streams[streamId].amounts.withdrawn + amount;\n\n        // Retrieve the amounts from storage.\n        Lockup.Amounts memory amounts = _streams[streamId].amounts;\n\n        // Using \">=\" instead of \"==\" for additional safety reasons. In the event of an unforeseen increase in the\n        // withdrawn amount, the stream will still be marked as depleted.\n        if (amounts.withdrawn >= amounts.deposited - amounts.refunded) {\n            // Effect: mark the stream as depleted.\n            _streams[streamId].isDepleted = true;\n\n            // Effect: make the stream not cancelable anymore, because a depleted stream cannot be canceled.\n            _streams[streamId].isCancelable = false;\n        }\n\n        // Retrieve the ERC-20 asset from storage.\n        IERC20 asset = _streams[streamId].asset;\n\n        // Interaction: perform the ERC-20 transfer.\n        asset.safeTransfer({ to: to, value: amount });\n\n        // Log the withdrawal.\n        emit ISablierV2Lockup.WithdrawFromLockupStream(streamId, to, asset, amount);\n    }\n}"
    }
  ]
}