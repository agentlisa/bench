{
  "Title": "H-1: claimCOMPAndTransfer() COMP may be locked into the contract",
  "Content": "# Issue H-1: claimCOMPAndTransfer() COMP may be locked into the contract \n\nSource: https://github.com/sherlock-audit/2023-03-notional-judging/issues/168 \n\n## Found by \nbin2chen, lemonmon, xiaoming90\n## Summary\nMalicious users can keep front-run `claimCOMPAndTransfer() ` to trigger `COMPTROLLER.claimComp() ` first, causing `netBalance` in `claimCOMPAndTransfer() ` to be 0 all the time, resulting in `COMP` not being transferred out and locked in the contract\n## Vulnerability Detail\n`claimCOMPAndTransfer()` use for \"Claims COMP incentives earned and transfers to the treasury manager contract\"\nThe code is as follows:\n```solidity\n    function claimCOMPAndTransfer(address[] calldata cTokens)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 balanceBefore = COMP.balanceOf(address(this));\n        COMPTROLLER.claimComp(address(this), cTokens);\n        uint256 balanceAfter = COMP.balanceOf(address(this));\n\n        // NOTE: the onlyManagerContract modifier prevents a transfer to address(0) here\n        uint256 netBalance = balanceAfter.sub(balanceBefore);   //<-------@only transfer out `netBalance`\n        if (netBalance > 0) {\n            COMP.safeTransfer(msg.sender, netBalance);\n        }\n\n        // NOTE: TreasuryManager contract will emit a COMPHarvested event\n        return netBalance;\n```\n\nFrom the above code, we can see that this method only turns out the difference value `netBalance`\nBut `COMPTROLLER.claimComp()` can be called by anyone, if there is a malicious user front-run this transcation to triggers `COMPTROLLER.claimComp()` first \nThis will cause the`netBalance` to be 0 all the time, resulting in `COMP` not being transferred out and being locked in the contract.\n\nThe following code is from `Comptroller.sol`\n\nhttps://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol\n\n```solidity\n    function claimComp(address holder, CToken[] memory cTokens) public { //<----------anyone can call it\n        address[] memory holders = new address[](1);\n        holders[0] = holder;\n        claimComp(holders, cTokens, true, true);\n    }\n```\n\n## Impact\n\n`COMP ` may be locked into the contract\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/external/actions/TreasuryAction.sol#L118C4-L123\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTransfer all balances, not using `netBalance`\n\n\n\n## Discussion\n\n**Jiaren-tang**\n\n.\n\n**Jiaren-tang**\n\nEscalate for 10 USDC. do not think this can be a high vulnerability because of the following reason\n\nthis is a medium because first, the protocol can use flashbot to avoid frontrunning\n\nthis is loss of reward not lose of user fund\n\nthis griefing attack has no gain from attacker at all\n\nhttps://docs.sherlock.xyz/audits/judging/judging\n\n> Medium: There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost. The attack path is possible with assumptions that either mimic on-chain conditions or reflect conditions that have a reasonable chance of becoming true in the future. The more expensive the attack is for an attacker, the less likely it will be included as a Medium (holding all other factors constant). The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n\nwe consider the attack is cost high becaues the attacker needs to monitor the pending claim transaction from notional side while has no economic gain\n\n**sherlock-admin**\n\n > Escalate for 10 USDC. do not think this can be a high vulnerability because of the following reason\n> \n> this is a medium because first, the protocol can use flashbot to avoid frontrunning\n> \n> this is loss of reward not lose of user fund\n> \n> this griefing attack has no gain from attacker at all\n> \n> https://docs.sherlock.xyz/audits/judging/judging\n> \n> > Medium: There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost. The attack path is possible with assumptions that either mimic on-chain conditions or reflect conditions that have a reasonable chance of becoming true in the future. The more expensive the attack is for an attacker, the less likely it will be included as a Medium (holding all other factors constant). The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n> \n> we consider the attack is cost high becaues the attacker needs to monitor the pending claim transaction from notional side while has no economic gain\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xleastwood**\n\n> Escalate for 10 USDC. do not think this can be a high vulnerability because of the following reason\n> \n> this is a medium because first, the protocol can use flashbot to avoid frontrunning\n> \n> this is loss of reward not lose of user fund\n> \n> this griefing attack has no gain from attacker at all\n> \n> https://docs.sherlock.xyz/audits/judging/judging\n> \n> > Medium: There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost. The attack path is possible with assumptions that either mimic on-chain conditions or reflect conditions that have a reasonable chance of becoming true in the future. The more expensive the attack is for an attacker, the less likely it will be included as a Medium (holding all other factors constant). The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n> \n> we consider the attack is cost high becaues the attacker needs to monitor the pending claim transaction from notional side while has no economic gain\n\nI disagree, `COMP` rewards continuously accrue over time and hence this function can be called at any time to lose rewards. This attack is not expensive at all to perform and can be profitable in other ways that aren't immediately apparent. The difference between `high` and `medium` risk within the context of Sherlock's judging is `There is a viable scenario (even if unlikely)` vs `This vulnerability would result in a material loss of funds, and the cost of the attack is low (relative to the amount of funds lost)`. It is clear that this fits the criteria of the latter.\n\n**Trumpero**\n\nAgree with the comment by Leastwood, this issue should be high\n\n**hrishibhat**\n\nResult:\nHigh\nHas duplicates\nGiven that the rewards are an integral part of protocol these would be stuck in the contract due to the exploit considering this as a valid high\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ShadowForce](https://github.com/sherlock-audit/2023-03-notional-judging/issues/168/#issuecomment-1570489952): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/59",
  "Code": [
    {
      "filename": "contracts-v2/contracts/external/actions/TreasuryAction.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    Token,\n    PrimeRate,\n    PrimeCashFactors,\n    RebalancingContextStorage\n} from \"../../global/Types.sol\";\nimport {StorageLayoutV2} from \"../../global/StorageLayoutV2.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\n\nimport {BalanceHandler} from \"../../internal/balances/BalanceHandler.sol\";\nimport {PrimeRateLib} from \"../../internal/pCash/PrimeRateLib.sol\";\nimport {TokenHandler} from \"../../internal/balances/TokenHandler.sol\";\nimport {nTokenHandler} from \"../../internal/nToken/nTokenHandler.sol\";\nimport {nTokenSupply} from \"../../internal/nToken/nTokenSupply.sol\";\nimport {PrimeCashExchangeRate, PrimeCashFactors} from \"../../internal/pCash/PrimeCashExchangeRate.sol\";\nimport {GenericToken} from \"../../internal/balances/protocols/GenericToken.sol\";\n\nimport {ActionGuards} from \"./ActionGuards.sol\";\nimport {NotionalTreasury} from \"../../../interfaces/notional/NotionalTreasury.sol\";\nimport {Comptroller} from \"../../../interfaces/compound/ComptrollerInterface.sol\";\nimport {CErc20Interface} from \"../../../interfaces/compound/CErc20Interface.sol\";\nimport {IPrimeCashHoldingsOracle, DepositData, RedeemData} from \"../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\";\nimport {IRebalancingStrategy, RebalancingData} from \"../../../interfaces/notional/IRebalancingStrategy.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract TreasuryAction is StorageLayoutV2, ActionGuards, NotionalTreasury {\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n    using SafeERC20 for IERC20;\n    using TokenHandler for Token;\n\n    IERC20 public immutable COMP;\n    Comptroller public immutable COMPTROLLER;\n    IRebalancingStrategy public immutable REBALANCING_STRATEGY;\n\n    /// @dev Harvest methods are only callable by the authorized treasury manager contract\n    modifier onlyManagerContract() {\n        require(treasuryManagerContract == msg.sender, \"Treasury manager required\");\n        _;\n    }\n\n    constructor(Comptroller _comptroller, IRebalancingStrategy _rebalancingStrategy) {\n        COMPTROLLER = _comptroller;\n        COMP = IERC20(_comptroller.getCompAddress());\n        REBALANCING_STRATEGY = _rebalancingStrategy;\n    }\n\n    /// @notice Sets the new treasury manager contract\n    function setTreasuryManager(address manager) external override onlyOwner {\n        emit TreasuryManagerChanged(treasuryManagerContract, manager);\n        treasuryManagerContract = manager;\n    }\n\n    /// @notice Sets the reserve buffer. This is the amount of reserve balance to keep denominated in 1e8\n    /// The reserve cannot be harvested if it's below this amount. This portion of the reserve will remain on\n    /// the contract to act as a buffer against potential insolvency.\n    /// @param currencyId refers to the currency of the reserve\n    /// @param bufferAmount reserve buffer amount to keep in internal token precision (1e8)\n    function setReserveBuffer(uint16 currencyId, uint256 bufferAmount) external override onlyOwner {\n        _checkValidCurrency(currencyId);\n        reserveBuffer[currencyId] = bufferAmount;\n        emit ReserveBufferUpdated(currencyId, bufferAmount);\n    }\n\n    /// @notice Updates the emission rate of incentives for a given currency\n    /// @dev emit:UpdateIncentiveEmissionRate\n    /// @param currencyId the currency id that the nToken references\n    /// @param newEmissionRate Target total incentives to emit for an nToken over an entire year\n    /// denominated in WHOLE TOKENS (i.e. setting this to 1 means 1e8 tokens). The rate will not be\n    /// exact due to multiplier effects and fluctuating token supply.\n    function updateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate)\n        external\n        override\n        onlyOwner\n    {\n        _checkValidCurrency(currencyId);\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(nTokenAddress != address(0));\n        // Sanity check that emissions rate is not specified in 1e8 terms.\n        require(newEmissionRate < Constants.INTERNAL_TOKEN_PRECISION, \"Invalid rate\");\n\n        nTokenSupply.setIncentiveEmissionRate(nTokenAddress, newEmissionRate, block.timestamp);\n        emit UpdateIncentiveEmissionRate(currencyId, newEmissionRate);\n    }\n\n\n    /// @notice This is used in the case of insolvency. It allows the owner to re-align the reserve with its correct balance.\n    /// @param currencyId refers to the currency of the reserve\n    /// @param newBalance new reserve balance to set, must be less than the current balance\n    function setReserveCashBalance(uint16 currencyId, int256 newBalance)\n        external\n        override\n        onlyOwner\n    {\n        _checkValidCurrency(currencyId);\n        // newBalance cannot be negative and is checked inside BalanceHandler.setReserveCashBalance\n        BalanceHandler.setReserveCashBalance(currencyId, newBalance);\n    }\n\n    /// @notice Claims COMP incentives earned and transfers to the treasury manager contract.\n    /// @param cTokens a list of cTokens to claim incentives for\n    /// @return the balance of COMP claimed\n    function claimCOMPAndTransfer(address[] calldata cTokens)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 balanceBefore = COMP.balanceOf(address(this));\n        COMPTROLLER.claimComp(address(this), cTokens);\n        uint256 balanceAfter = COMP.balanceOf(address(this));\n\n        // NOTE: the onlyManagerContract modifier prevents a transfer to address(0) here\n        uint256 netBalance = balanceAfter.sub(balanceBefore);\n        if (netBalance > 0) {\n            COMP.safeTransfer(msg.sender, netBalance);\n        }\n\n        // NOTE: TreasuryManager contract will emit a COMPHarvested event\n        return netBalance;\n    }\n\n    /// @notice redeems and transfers tokens to the treasury manager contract\n    function _redeemAndTransfer(uint16 currencyId, int256 primeCashRedeemAmount) private returns (uint256) {\n        PrimeRate memory primeRate = PrimeRateLib.buildPrimeRateStateful(currencyId);\n        int256 actualTransferExternal = TokenHandler.withdrawPrimeCash(\n            treasuryManagerContract,\n            currencyId,\n            primeCashRedeemAmount.neg(),\n            primeRate,\n            true // if ETH, transfers it as WETH\n        );\n\n        require(actualTransferExternal > 0);\n        return uint256(actualTransferExternal);\n    }\n\n    /// @notice Transfers some amount of reserve assets to the treasury manager contract to be invested\n    /// into the sNOTE pool.\n    /// @param currencies an array of currencies to transfer from Notional\n    function transferReserveToTreasury(uint16[] calldata currencies)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256[] memory)\n    {\n        uint256[] memory amountsTransferred = new uint256[](currencies.length);\n\n        for (uint256 i; i < currencies.length; ++i) {\n            // Prevents duplicate currency IDs\n            if (i > 0) require(currencies[i] > currencies[i - 1], \"IDs must be sorted\");\n\n            uint16 currencyId = currencies[i];\n\n            _checkValidCurrency(currencyId);\n\n            // Reserve buffer amount in INTERNAL_TOKEN_PRECISION\n            int256 bufferInternal = SafeInt256.toInt(reserveBuffer[currencyId]);\n\n            // Reserve requirement not defined\n            if (bufferInternal == 0) continue;\n\n            int256 reserveInternal = BalanceHandler.getPositiveCashBalance(Constants.FEE_RESERVE, currencyId);\n\n            // Do not withdraw anything if reserve is below or equal to reserve requirement\n            if (reserveInternal <= bufferInternal) continue;\n\n            // Actual reserve amount allowed to be redeemed and transferred\n            // NOTE: overflow not possible with the check above\n            int256 primeCashRedeemed = reserveInternal - bufferInternal;\n\n            // Redeems prime cash and transfer underlying to treasury manager contract\n            amountsTransferred[i] = _redeemAndTransfer(currencyId, primeCashRedeemed);\n\n            // Updates the reserve balance\n            BalanceHandler.harvestExcessReserveBalance(\n                currencyId,\n                reserveInternal,\n                primeCashRedeemed\n            );\n        }\n\n        // NOTE: TreasuryManager contract will emit an AssetsHarvested event\n        return amountsTransferred;\n    }\n\n    function setRebalancingTargets(uint16 currencyId, RebalancingTargetConfig[] calldata targets) external override onlyOwner {\n        IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n        address[] memory holdings = oracle.holdings();\n\n        require(targets.length == holdings.length);\n\n        mapping(address => uint8) storage rebalancingTargets = LibStorage.getRebalancingTargets()[currencyId];\n        uint256 totalPercentage;\n        for (uint256 i; i < holdings.length; ++i) {\n            RebalancingTargetConfig calldata config = targets[i];\n            address holding = holdings[i];\n\n            require(config.holding == holding);\n            totalPercentage = totalPercentage.add(config.target);\n            rebalancingTargets[holding] = config.target;\n        }\n        require(totalPercentage <= uint256(Constants.PERCENTAGE_DECIMALS));\n\n        emit RebalancingTargetsUpdated(currencyId, targets);\n    }\n\n    function setRebalancingCooldown(uint16 currencyId, uint40 cooldownTimeInSeconds) external override onlyOwner {\n        mapping(uint16 => RebalancingContextStorage) storage store = LibStorage.getRebalancingContext();\n        store[currencyId].rebalancingCooldownInSeconds = cooldownTimeInSeconds;\n        emit RebalancingCooldownUpdated(currencyId, cooldownTimeInSeconds);\n    }\n\n    function rebalance(uint16[] calldata currencyId) external override onlyManagerContract {\n        for (uint256 i; i < currencyId.length; ++i) {\n            _rebalanceCurrency(currencyId[i]);\n        }\n    }\n\n    function _rebalanceCurrency(uint16 currencyId) private {\n        RebalancingContextStorage memory context = LibStorage.getRebalancingContext()[currencyId];\n\n        require(\n            uint256(context.lastRebalanceTimestampInSeconds).add(context.rebalancingCooldownInSeconds) < block.timestamp, \n            \"Rebalancing cooldown\"\n        );\n\n        // Accrues interest up to the current block before any rebalancing is executed\n        PrimeRateLib.buildPrimeRateStateful(currencyId);\n\n        PrimeCashFactors memory factors = PrimeCashExchangeRate.getPrimeCashFactors(currencyId);\n        _executeRebalance(currencyId);\n\n        // if previous underlying scalar at rebalance == 0, then it is the first rebalance and\n        // annualized interest rate will be left as zero. The previous underlying scalar will\n        // be set to the new factors.underlyingScalar.\n        uint256 annualizedInterestRate;\n        if (context.previousUnderlyingScalarAtRebalance != 0) {\n            uint256 interestRate = factors.underlyingScalar\n                .mul(Constants.SCALAR_PRECISION)\n                .div(context.previousUnderlyingScalarAtRebalance)\n                .sub(Constants.SCALAR_PRECISION) \n                .div(uint256(Constants.RATE_PRECISION));\n\n            annualizedInterestRate = interestRate\n                .mul(Constants.YEAR)\n                .div(block.timestamp.sub(context.lastRebalanceTimestampInSeconds));\n        }\n\n        _saveRebalancingContext(currencyId, factors.underlyingScalar, annualizedInterestRate);\n\n        emit CurrencyRebalanced(currencyId, factors.underlyingScalar, annualizedInterestRate);\n    }\n\n    function _saveRebalancingContext(uint16 currencyId, uint256 underlyingScalar, uint256 annualizedInterestRate) private {\n        mapping(uint16 => RebalancingContextStorage) storage store = LibStorage.getRebalancingContext();\n        store[currencyId].lastRebalanceTimestampInSeconds = block.timestamp.toUint40();\n        store[currencyId].previousUnderlyingScalarAtRebalance = underlyingScalar.toUint80();\n        store[currencyId].oracleMoneyMarketRate = annualizedInterestRate.toUint32();\n    }\n\n    function _getRebalancingTargets(uint16 currencyId, address[] memory holdings) private view returns (uint8[] memory targets) {\n        mapping(address => uint8) storage rebalancingTargets = LibStorage.getRebalancingTargets()[currencyId];\n        targets = new uint8[](holdings.length);\n        uint256 totalPercentage;\n        for (uint256 i; i < holdings.length; ++i) {\n            uint8 target = rebalancingTargets[holdings[i]];\n            targets[i] = target;\n            totalPercentage = totalPercentage.add(target);\n        }\n        require(totalPercentage <= uint256(Constants.PERCENTAGE_DECIMALS));\n    }\n\n    function _executeRebalance(uint16 currencyId) private {\n        IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n        uint8[] memory rebalancingTargets = _getRebalancingTargets(currencyId, oracle.holdings());\n        (RebalancingData memory data) = REBALANCING_STRATEGY.calculateRebalance(oracle, rebalancingTargets);\n\n        (/* */, uint256 totalUnderlyingValueBefore) = oracle.getTotalUnderlyingValueStateful();\n\n        // Process redemptions first\n        Token memory underlyingToken = TokenHandler.getUnderlyingToken(currencyId);\n        TokenHandler.executeMoneyMarketRedemptions(underlyingToken, data.redeemData);\n\n        // Process deposits\n        _executeDeposits(underlyingToken, data.depositData);\n\n        (/* */, uint256 totalUnderlyingValueAfter) = oracle.getTotalUnderlyingValueStateful();\n\n        int256 underlyingDelta = totalUnderlyingValueBefore.toInt().sub(totalUnderlyingValueAfter.toInt());\n        require(underlyingDelta.abs() < Constants.REBALANCING_UNDERLYING_DELTA);\n    }\n\n    function _executeDeposits(Token memory underlyingToken, DepositData[] memory deposits) private {\n        uint256 totalUnderlyingDepositAmount;\n        \n        for (uint256 i; i < deposits.length; i++) {\n            DepositData memory depositData = deposits[i];\n            // Measure the token balance change if the `assetToken` value is set in the\n            // current deposit data struct. \n            uint256 oldAssetBalance = IERC20(depositData.assetToken).balanceOf(address(this));\n\n            // Measure the underlying balance change before and after the call.\n            uint256 oldUnderlyingBalance = underlyingToken.balanceOf(address(this));\n\n            for (uint256 j; j < depositData.targets.length; ++j) {\n                // This will revert if the individual call reverts.\n                GenericToken.executeLowLevelCall(\n                    depositData.targets[j], \n                    depositData.msgValue[j], \n                    depositData.callData[j]\n                );\n            }\n\n            // Ensure that the underlying balance change matches the deposit amount\n            uint256 newUnderlyingBalance = underlyingToken.balanceOf(address(this));\n            uint256 underlyingBalanceChange = oldUnderlyingBalance.sub(newUnderlyingBalance);\n            // If the call is not the final deposit, then underlyingDepositAmount should\n            // be set to zero.\n            require(underlyingBalanceChange <= depositData.underlyingDepositAmount);\n        \n            // Measure and update the asset token\n            uint256 newAssetBalance = IERC20(depositData.assetToken).balanceOf(address(this));\n            require(oldAssetBalance <= newAssetBalance);\n            TokenHandler.updateStoredTokenBalance(depositData.assetToken, oldAssetBalance, newAssetBalance);\n\n            // Update the total value with the net change\n            totalUnderlyingDepositAmount = totalUnderlyingDepositAmount.add(underlyingBalanceChange);\n\n            // totalUnderlyingDepositAmount needs to be subtracted from the underlying balance because\n            // we are trading underlying cash for asset cash\n            TokenHandler.updateStoredTokenBalance(underlyingToken.tokenAddress, oldUnderlyingBalance, newUnderlyingBalance);\n        }\n    }\n}"
    }
  ]
}