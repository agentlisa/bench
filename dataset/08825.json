{
  "Title": "[H-01] Rounding Issues In Certain Functions",
  "Content": "_Submitted by xiaoming90, also found by berndartmueller, GreyArt, jonah1005, kenzo, and minhquanym_\n\n<https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L52>\n\n<https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L134>\n\n### Background\n\nPer EIP 4626's Security Considerations (<https://eips.ethereum.org/EIPS/eip-4626>)\n\n> Finally, ERC-4626 Vault implementers should be aware of the need for specific, opposing rounding directions across the different mutable and view methods, as it is considered most secure to favor the Vault itself during calculations over its users:\n>\n> *   If (1) it’s calculating how many shares to issue to a user for a certain amount of the underlying tokens they provide or (2) it’s determining the amount of the underlying tokens to transfer to them for returning a certain amount of shares, it should round *down*.\n> *   If (1) it’s calculating the amount of shares a user has to supply to receive a given amount of the underlying tokens or (2) it’s calculating the amount of underlying tokens a user has to provide to receive a certain amount of shares, it should round *up*.\n\nThus, the result of the `previewMint` and `previewWithdraw` should be rounded up.\n\n### Proof of Concept\n\nThe current implementation of `convertToShares` function will round down the number of shares returned due to how solidity handles Integer Division. ERC4626 expects the returned value of `convertToShares` to be rounded down. Thus, this function behaves as expected.\n\n<https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L52>\n\n```solidity\nfunction convertToShares(uint256 assets) public view override returns (uint256 shares) {\n    uint256 supply = totalSupply();\n    if (supply == 0) {\n        // Scales assets by the value of a single unit of fCash\n        uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));\n        return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;\n    }\n\n    return (assets * totalSupply()) / totalAssets();\n}\n```\n\nERC 4626 expects the result returned from `previewWithdraw` function to be rounded up. However, within the `previewWithdraw` function, it calls the `convertToShares` function. Recall earlier that the `convertToShares` function returned a rounded down value,  thus `previewWithdraw` will return a rounded down value instead of round up value. Thus, this function does not behave as expected.\n\n<https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L134>\n\n```solidity\nfunction previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n    if (hasMatured()) {\n        shares = convertToShares(assets);\n    } else {\n        // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(\n            currencyId,\n            assets,\n            maturity,\n            0,\n            block.timestamp,\n            true\n        );\n    }\n}\n```\n\n`previewWithdraw` and `previewMint` functions rely on `NotionalV2.getfCashBorrowFromPrincipal` and `NotionalV2.getDepositFromfCashLend` functions. Due to the nature of time-boxed contest, I was unable to verify if `NotionalV2.getfCashBorrowFromPrincipal` and `NotionalV2.getDepositFromfCashLend` functions return a rounded down or up value. If a rounded down value is returned from these functions, `previewWithdraw` and `previewMint` functions would not behave as expected.\n\n### Impact\n\nOther protocols that integrate with Notional's fCash wrapper might wrongly assume that the functions handle rounding as per ERC4626 expectation. Thus, it might cause some intergration problem in the future that can lead to wide range of issues for both parties.\n\n### Recommended Mitigation Steps\n\nEnsure that the rounding of vault's functions behave as expected. Following are the expected rounding direction for each vault function:\n\n*   previewMint(uint256 shares) - Round Up ⬆\n\n*   previewWithdraw(uint256 assets) - Round Up ⬆\n\n*   previewRedeem(uint256 shares) - Round Down ⬇\n\n*   previewDeposit(uint256 assets) - Round Down ⬇\n\n*   convertToAssets(uint256 shares) - Round Down ⬇\n\n*   convertToShares(uint256 assets) - Round Down ⬇\n\n`previewMint` returns the  amount of assets that would be deposited to mint specific amount of shares. Thus, the amount of assets must be rounded up, so that the vault won't be shortchanged.\n\n`previewWithdraw` returns the amount of shares that would be burned to withdraw specific amount of asset. Thus, the amount of shares must to be rounded up, so that the vault won't be shortchanged.\n\nFollowing is the OpenZeppelin's vault implementation for rounding reference:\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20TokenizedVault.sol>\n\nAlternatively, if such alignment of rounding could not be achieved due to technical limitation, at the minimum, document this limitation in the comment so that the developer performing the integration is aware of this.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2022-06-notional-coop-findings/issues/155)**\n\n**[gzeoneth (judge) increased severity to High and commented](https://github.com/code-423n4/2022-06-notional-coop-findings/issues/155#issuecomment-1166534716):**\n> Judging this and all duplicate regarding EIP4626 implementation as High Risk. \n\n> EIP4626 is aimed to create a consistent and robust implementation patterns for Tokenized Vaults. A slight deviation from 4626 would broke composability and potentially lead to loss of fund (POC in https://github.com/code-423n4/2022-06-notional-coop-findings/issues/88 can be an example). It is counterproductive to implement EIP4626 but does not conform to it fully. Especially it does seem that most of the time `deposit` would be successful but not `withdraw`, making it even more dangerous when an immutable consumer application mistakenly used the wfcash contract.\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-06-notional-coop",
  "Code": [
    {
      "filename": "notional-wrapped-fcash/contracts/wfCashERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./wfCashLogic.sol\";\nimport \"../interfaces/IERC4626.sol\";\n\ncontract wfCashERC4626 is IERC4626, wfCashLogic {\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashLogic(_notional, _weth) {}\n\n    /** @dev See {IERC4626-asset} */\n    function asset() public view override returns (address) {\n        (IERC20 underlyingToken, bool isETH) = getToken(true);\n        return isETH ? address(WETH) : address(underlyingToken);\n    }\n\n    function _getMaturedValue() private view returns (uint256) {\n        // If the fCash has matured we use the cash balance instead.\n        uint16 currencyId = getCurrencyId();\n        // We cannot settle an account in a view method, so this may fail if the account has not been settled\n        // after maturity. This can be done by anyone so it should not be an issue\n        (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\n        int256 underlyingExternal = NotionalV2.convertCashBalanceToExternal(currencyId, cashBalance, true);\n        require(underlyingExternal > 0, \"Must Settle\");\n\n        return uint256(underlyingExternal);\n    }\n\n    function _getPresentValue(uint256 fCashAmount) private view returns (uint256) {\n        (/* */, int256 precision) = getUnderlyingToken();\n        // Get the present value of the fCash held by the contract, this is returned in 8 decimal precision\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        int256 pvInternal = NotionalV2.getPresentfCashValue(\n            currencyId,\n            maturity,\n            int256(fCashAmount), // total supply cannot overflow as fCash overflows at uint88\n            block.timestamp,\n            false\n        );\n\n        int256 pvExternal = (pvInternal * precision) / Constants.INTERNAL_TOKEN_PRECISION;\n        // PV should always be >= 0 since we are lending\n        require(pvExternal >= 0);\n        return uint256(pvExternal);\n    }\n\n    /** @dev See {IERC4626-totalAssets} */\n    function totalAssets() public view override returns (uint256) {\n        return hasMatured() ?  _getMaturedValue() : _getPresentValue(totalSupply());\n    }\n\n    /** @dev See {IERC4626-convertToShares} */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Scales assets by the value of a single unit of fCash\n            uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));\n            return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;\n        }\n\n        return (assets * totalSupply()) / totalAssets();\n    }\n\n    /** @dev See {IERC4626-convertToAssets} */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Catch the edge case where totalSupply causes a divide by zero error\n            return _getPresentValue(shares);\n        }\n\n        return (shares * totalAssets()) / supply;\n    }\n\n    /** @dev See {IERC4626-maxDeposit} */\n    function maxDeposit(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint} */\n    function maxMint(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint88).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw} */\n    function maxWithdraw(address owner) public view override returns (uint256) {\n        return previewWithdraw(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4626-maxRedeem} */\n    function maxRedeem(address owner) public view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit} */\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 fCashAmount, /* */, /* */) = NotionalV2.getfCashLendFromDeposit(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n\n            return fCashAmount;\n        }\n    }\n\n    /** @dev See {IERC4626-previewMint} */\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 depositAmountUnderlying, /* */, /* */, /* */) = NotionalV2.getDepositFromfCashLend(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n\n            return depositAmountUnderlying;\n        }\n    }\n\n    /** @dev See {IERC4626-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        if (hasMatured()) {\n            shares = convertToShares(assets);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-previewRedeem} */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        if (hasMatured()) {\n            assets = convertToAssets(shares);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (assets, /* */, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-deposit} */\n    function deposit(uint256 assets, address receiver) public override returns (uint256) {\n        uint256 shares = previewDeposit(assets);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint} */\n    function mint(uint256 shares, address receiver) public override returns (uint256) {\n        uint256 assets = previewMint(shares);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw} */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        uint256 shares = previewWithdraw(assets);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem} */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        // It is more accurate and gas efficient to check the balance of the\n        // receiver here than rely on the previewRedeem method.\n        uint256 balanceBefore = IERC20(asset()).balanceOf(receiver);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        uint256 balanceAfter = IERC20(asset()).balanceOf(receiver);\n        uint256 assets = balanceAfter - balanceBefore;\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n        return assets;\n    }\n\n    function _redeemInternal(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) private {\n        bytes memory userData = abi.encode(\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: 0\n            })\n        );\n\n        // No operator data\n        _burn(owner, shares, userData, \"\");\n    }\n\n    function _safeNegInt88(uint256 x) private pure returns (int88) {\n        int256 y = -int256(x);\n        require(int256(type(int88).min) <= y);\n        return int88(y);\n    }\n}"
    },
    {
      "filename": "notional-wrapped-fcash/contracts/wfCashERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./wfCashLogic.sol\";\nimport \"../interfaces/IERC4626.sol\";\n\ncontract wfCashERC4626 is IERC4626, wfCashLogic {\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashLogic(_notional, _weth) {}\n\n    /** @dev See {IERC4626-asset} */\n    function asset() public view override returns (address) {\n        (IERC20 underlyingToken, bool isETH) = getToken(true);\n        return isETH ? address(WETH) : address(underlyingToken);\n    }\n\n    function _getMaturedValue() private view returns (uint256) {\n        // If the fCash has matured we use the cash balance instead.\n        uint16 currencyId = getCurrencyId();\n        // We cannot settle an account in a view method, so this may fail if the account has not been settled\n        // after maturity. This can be done by anyone so it should not be an issue\n        (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\n        int256 underlyingExternal = NotionalV2.convertCashBalanceToExternal(currencyId, cashBalance, true);\n        require(underlyingExternal > 0, \"Must Settle\");\n\n        return uint256(underlyingExternal);\n    }\n\n    function _getPresentValue(uint256 fCashAmount) private view returns (uint256) {\n        (/* */, int256 precision) = getUnderlyingToken();\n        // Get the present value of the fCash held by the contract, this is returned in 8 decimal precision\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        int256 pvInternal = NotionalV2.getPresentfCashValue(\n            currencyId,\n            maturity,\n            int256(fCashAmount), // total supply cannot overflow as fCash overflows at uint88\n            block.timestamp,\n            false\n        );\n\n        int256 pvExternal = (pvInternal * precision) / Constants.INTERNAL_TOKEN_PRECISION;\n        // PV should always be >= 0 since we are lending\n        require(pvExternal >= 0);\n        return uint256(pvExternal);\n    }\n\n    /** @dev See {IERC4626-totalAssets} */\n    function totalAssets() public view override returns (uint256) {\n        return hasMatured() ?  _getMaturedValue() : _getPresentValue(totalSupply());\n    }\n\n    /** @dev See {IERC4626-convertToShares} */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Scales assets by the value of a single unit of fCash\n            uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));\n            return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;\n        }\n\n        return (assets * totalSupply()) / totalAssets();\n    }\n\n    /** @dev See {IERC4626-convertToAssets} */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Catch the edge case where totalSupply causes a divide by zero error\n            return _getPresentValue(shares);\n        }\n\n        return (shares * totalAssets()) / supply;\n    }\n\n    /** @dev See {IERC4626-maxDeposit} */\n    function maxDeposit(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint} */\n    function maxMint(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint88).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw} */\n    function maxWithdraw(address owner) public view override returns (uint256) {\n        return previewWithdraw(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4626-maxRedeem} */\n    function maxRedeem(address owner) public view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit} */\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 fCashAmount, /* */, /* */) = NotionalV2.getfCashLendFromDeposit(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n\n            return fCashAmount;\n        }\n    }\n\n    /** @dev See {IERC4626-previewMint} */\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 depositAmountUnderlying, /* */, /* */, /* */) = NotionalV2.getDepositFromfCashLend(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n\n            return depositAmountUnderlying;\n        }\n    }\n\n    /** @dev See {IERC4626-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        if (hasMatured()) {\n            shares = convertToShares(assets);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-previewRedeem} */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        if (hasMatured()) {\n            assets = convertToAssets(shares);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (assets, /* */, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-deposit} */\n    function deposit(uint256 assets, address receiver) public override returns (uint256) {\n        uint256 shares = previewDeposit(assets);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint} */\n    function mint(uint256 shares, address receiver) public override returns (uint256) {\n        uint256 assets = previewMint(shares);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw} */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        uint256 shares = previewWithdraw(assets);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem} */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        // It is more accurate and gas efficient to check the balance of the\n        // receiver here than rely on the previewRedeem method.\n        uint256 balanceBefore = IERC20(asset()).balanceOf(receiver);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        uint256 balanceAfter = IERC20(asset()).balanceOf(receiver);\n        uint256 assets = balanceAfter - balanceBefore;\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n        return assets;\n    }\n\n    function _redeemInternal(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) private {\n        bytes memory userData = abi.encode(\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: 0\n            })\n        );\n\n        // No operator data\n        _burn(owner, shares, userData, \"\");\n    }\n\n    function _safeNegInt88(uint256 x) private pure returns (int88) {\n        int256 y = -int256(x);\n        require(int256(type(int88).min) <= y);\n        return int88(y);\n    }\n}"
    },
    {
      "filename": "notional-wrapped-fcash/contracts/wfCashERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./wfCashLogic.sol\";\nimport \"../interfaces/IERC4626.sol\";\n\ncontract wfCashERC4626 is IERC4626, wfCashLogic {\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashLogic(_notional, _weth) {}\n\n    /** @dev See {IERC4626-asset} */\n    function asset() public view override returns (address) {\n        (IERC20 underlyingToken, bool isETH) = getToken(true);\n        return isETH ? address(WETH) : address(underlyingToken);\n    }\n\n    function _getMaturedValue() private view returns (uint256) {\n        // If the fCash has matured we use the cash balance instead.\n        uint16 currencyId = getCurrencyId();\n        // We cannot settle an account in a view method, so this may fail if the account has not been settled\n        // after maturity. This can be done by anyone so it should not be an issue\n        (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\n        int256 underlyingExternal = NotionalV2.convertCashBalanceToExternal(currencyId, cashBalance, true);\n        require(underlyingExternal > 0, \"Must Settle\");\n\n        return uint256(underlyingExternal);\n    }\n\n    function _getPresentValue(uint256 fCashAmount) private view returns (uint256) {\n        (/* */, int256 precision) = getUnderlyingToken();\n        // Get the present value of the fCash held by the contract, this is returned in 8 decimal precision\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        int256 pvInternal = NotionalV2.getPresentfCashValue(\n            currencyId,\n            maturity,\n            int256(fCashAmount), // total supply cannot overflow as fCash overflows at uint88\n            block.timestamp,\n            false\n        );\n\n        int256 pvExternal = (pvInternal * precision) / Constants.INTERNAL_TOKEN_PRECISION;\n        // PV should always be >= 0 since we are lending\n        require(pvExternal >= 0);\n        return uint256(pvExternal);\n    }\n\n    /** @dev See {IERC4626-totalAssets} */\n    function totalAssets() public view override returns (uint256) {\n        return hasMatured() ?  _getMaturedValue() : _getPresentValue(totalSupply());\n    }\n\n    /** @dev See {IERC4626-convertToShares} */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Scales assets by the value of a single unit of fCash\n            uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));\n            return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;\n        }\n\n        return (assets * totalSupply()) / totalAssets();\n    }\n\n    /** @dev See {IERC4626-convertToAssets} */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Catch the edge case where totalSupply causes a divide by zero error\n            return _getPresentValue(shares);\n        }\n\n        return (shares * totalAssets()) / supply;\n    }\n\n    /** @dev See {IERC4626-maxDeposit} */\n    function maxDeposit(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint} */\n    function maxMint(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint88).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw} */\n    function maxWithdraw(address owner) public view override returns (uint256) {\n        return previewWithdraw(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4626-maxRedeem} */\n    function maxRedeem(address owner) public view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit} */\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 fCashAmount, /* */, /* */) = NotionalV2.getfCashLendFromDeposit(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n\n            return fCashAmount;\n        }\n    }\n\n    /** @dev See {IERC4626-previewMint} */\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 depositAmountUnderlying, /* */, /* */, /* */) = NotionalV2.getDepositFromfCashLend(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n\n            return depositAmountUnderlying;\n        }\n    }\n\n    /** @dev See {IERC4626-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        if (hasMatured()) {\n            shares = convertToShares(assets);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-previewRedeem} */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        if (hasMatured()) {\n            assets = convertToAssets(shares);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (assets, /* */, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-deposit} */\n    function deposit(uint256 assets, address receiver) public override returns (uint256) {\n        uint256 shares = previewDeposit(assets);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint} */\n    function mint(uint256 shares, address receiver) public override returns (uint256) {\n        uint256 assets = previewMint(shares);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw} */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        uint256 shares = previewWithdraw(assets);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem} */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        // It is more accurate and gas efficient to check the balance of the\n        // receiver here than rely on the previewRedeem method.\n        uint256 balanceBefore = IERC20(asset()).balanceOf(receiver);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        uint256 balanceAfter = IERC20(asset()).balanceOf(receiver);\n        uint256 assets = balanceAfter - balanceBefore;\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n        return assets;\n    }\n\n    function _redeemInternal(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) private {\n        bytes memory userData = abi.encode(\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: 0\n            })\n        );\n\n        // No operator data\n        _burn(owner, shares, userData, \"\");\n    }\n\n    function _safeNegInt88(uint256 x) private pure returns (int88) {\n        int256 y = -int256(x);\n        require(int256(type(int88).min) <= y);\n        return int88(y);\n    }\n}"
    },
    {
      "filename": "notional-wrapped-fcash/contracts/wfCashERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./wfCashLogic.sol\";\nimport \"../interfaces/IERC4626.sol\";\n\ncontract wfCashERC4626 is IERC4626, wfCashLogic {\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashLogic(_notional, _weth) {}\n\n    /** @dev See {IERC4626-asset} */\n    function asset() public view override returns (address) {\n        (IERC20 underlyingToken, bool isETH) = getToken(true);\n        return isETH ? address(WETH) : address(underlyingToken);\n    }\n\n    function _getMaturedValue() private view returns (uint256) {\n        // If the fCash has matured we use the cash balance instead.\n        uint16 currencyId = getCurrencyId();\n        // We cannot settle an account in a view method, so this may fail if the account has not been settled\n        // after maturity. This can be done by anyone so it should not be an issue\n        (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\n        int256 underlyingExternal = NotionalV2.convertCashBalanceToExternal(currencyId, cashBalance, true);\n        require(underlyingExternal > 0, \"Must Settle\");\n\n        return uint256(underlyingExternal);\n    }\n\n    function _getPresentValue(uint256 fCashAmount) private view returns (uint256) {\n        (/* */, int256 precision) = getUnderlyingToken();\n        // Get the present value of the fCash held by the contract, this is returned in 8 decimal precision\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        int256 pvInternal = NotionalV2.getPresentfCashValue(\n            currencyId,\n            maturity,\n            int256(fCashAmount), // total supply cannot overflow as fCash overflows at uint88\n            block.timestamp,\n            false\n        );\n\n        int256 pvExternal = (pvInternal * precision) / Constants.INTERNAL_TOKEN_PRECISION;\n        // PV should always be >= 0 since we are lending\n        require(pvExternal >= 0);\n        return uint256(pvExternal);\n    }\n\n    /** @dev See {IERC4626-totalAssets} */\n    function totalAssets() public view override returns (uint256) {\n        return hasMatured() ?  _getMaturedValue() : _getPresentValue(totalSupply());\n    }\n\n    /** @dev See {IERC4626-convertToShares} */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Scales assets by the value of a single unit of fCash\n            uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));\n            return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;\n        }\n\n        return (assets * totalSupply()) / totalAssets();\n    }\n\n    /** @dev See {IERC4626-convertToAssets} */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Catch the edge case where totalSupply causes a divide by zero error\n            return _getPresentValue(shares);\n        }\n\n        return (shares * totalAssets()) / supply;\n    }\n\n    /** @dev See {IERC4626-maxDeposit} */\n    function maxDeposit(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint} */\n    function maxMint(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint88).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw} */\n    function maxWithdraw(address owner) public view override returns (uint256) {\n        return previewWithdraw(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4626-maxRedeem} */\n    function maxRedeem(address owner) public view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit} */\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 fCashAmount, /* */, /* */) = NotionalV2.getfCashLendFromDeposit(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n\n            return fCashAmount;\n        }\n    }\n\n    /** @dev See {IERC4626-previewMint} */\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 depositAmountUnderlying, /* */, /* */, /* */) = NotionalV2.getDepositFromfCashLend(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n\n            return depositAmountUnderlying;\n        }\n    }\n\n    /** @dev See {IERC4626-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        if (hasMatured()) {\n            shares = convertToShares(assets);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(\n                currencyId,\n                assets,"
    }
  ]
}