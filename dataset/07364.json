{
  "Title": "[M-01] GroupBuy may purchase NFT not in the allowed list",
  "Content": "\nWhen `_purchaseProof.length == 0`, GroupBuy.purchase compare the tokenId with the merkleRoot. This allows any tokenId that matches the merkleRoot to be purchased, even if they are not included in the allow list during setup.\n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L186-L188>\n\n```solidity\n        if (_purchaseProof.length == 0) {\n            // Hashes tokenId to verify merkle root if proof is empty\n            if (bytes32(_tokenId) != merkleRoot) revert InvalidProof();\n```\n\n### Proof of Concept\n\nAdd the following to GroupBuy.t.sol. It would still revert (since no such nft existed) but not as expected.\n\n        // modified from testPurchaseRevertInvalidProof\n        function testPurchaseRevertInvalidTokenIdZeroLength() public {\n            // setup\n            testContributeSuccess();\n            // exploit\n            uint256 invalidPunkId = uint256(nftMerkleRoot);\n            bytes32[] memory invalidPurchaseProof = new bytes32[](0);\n            // expect\n            vm.expectRevert(INVALID_PROOF_ERROR);\n            // execute\n            _purchase(\n                address(this),\n                currentId,\n                address(punksBuyer),\n                address(punks),\n                invalidPunkId,\n                minValue,\n                purchaseOrder,\n                invalidPurchaseProof\n            );\n        }\n\n### Tools Used\n\nFoundry\n\n#### Recommended Mitigation Steps\n\nHash the tokenId even if there is only when length is 1.\n\n\n**[stevennevins (Tessera) disagreed with severity](https://github.com/code-423n4/2022-12-tessera-findings/issues/11)**\n\n**[HickupHH3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/14#issuecomment-1378156253):**\n > Best report because Foundry POC.\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-tessera-versus-contest",
  "Code": [
    {
      "filename": "src/modules/GroupBuy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ERC165Checker} from \"openzeppelin-contracts/utils/introspection/ERC165Checker.sol\";\nimport {MerkleBase} from \"../utils/MerkleBase.sol\";\nimport {MerkleProof} from \"openzeppelin-contracts/utils/cryptography/MerkleProof.sol\";\nimport {MinPriorityQueue, Bid} from \"../lib/MinPriorityQueue.sol\";\nimport {Minter} from \"../modules/Minter.sol\";\n\nimport {ICryptoPunk} from \"../punks/interfaces/ICryptoPunk.sol\";\nimport {IERC721} from \"../interfaces/IERC721.sol\";\nimport {IGroupBuy, PoolInfo} from \"../interfaces/IGroupBuy.sol\";\nimport {IMarketBuyer} from \"../interfaces/IMarketBuyer.sol\";\n\n/// @title GroupBuy\n/// @author Tessera\n/// @notice Module contract for pooling group funds to purchase and vault NFTs\n/// - The bidding mechanism used here is a slightly modified implementation of the\n///   Smart Batched Auction: https://github.com/FrankieIsLost/smart-batched-auction\ncontract GroupBuy is IGroupBuy, MerkleBase, Minter {\n    /// @dev Use MinPriorityQueue library for Queue types\n    using MinPriorityQueue for MinPriorityQueue.Queue;\n    /// @dev Interface ID for ERC-721 tokens\n    bytes4 constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n    /// @notice Current pool ID\n    uint256 public currentId;\n    /// @notice Mapping of pool ID to vault address\n    mapping(uint256 => address) public poolToVault;\n    /// @notice Mapping of pool ID to PoolInfo struct\n    mapping(uint256 => PoolInfo) public poolInfo;\n    /// @notice Mapping of pool ID to the priority queue of valid bids\n    mapping(uint256 => MinPriorityQueue.Queue) public bidPriorityQueues;\n    /// @notice Mapping of pool ID to amount of Raes currently filled for the pool\n    mapping(uint256 => uint256) public filledQuantities;\n    /// @notice Mapping of pool ID to minimum ether price of any bid\n    mapping(uint256 => uint256) public minBidPrices;\n    /// @notice Mapping of pool ID to minimum reserve prices\n    mapping(uint256 => uint256) public minReservePrices;\n    /// @notice Mapping of pool ID to total amount of ether contributed\n    mapping(uint256 => uint256) public totalContributions;\n    /// @notice Mapping of pool ID to user address to total amount of ether contributed\n    mapping(uint256 => mapping(address => uint256)) public userContributions;\n    /// @notice Mapping of user address to pending balance available for withdrawal\n    mapping(address => uint256) public pendingBalances;\n\n    /// @dev Initializes supply contract and minimum bid price\n    constructor(address _supply) Minter(_supply) {}\n\n    /// @notice Creates a new pool\n    /// @param _nftContract Address of the NFT contract\n    /// @param _tokenIds List of tokenIds permitted to be purchased\n    /// @param _initialPrice Initial price of the NFT(s)\n    /// @param _totalSupply Total amount of Raes to be minted\n    /// @param _duration Time period of pool existing before termination\n    /// @param _quantity Amount of Raes being bid on\n    /// @param _raePrice Ether price per Rae\n    function createPool(\n        address _nftContract,\n        uint256[] calldata _tokenIds,\n        uint256 _initialPrice,\n        uint48 _totalSupply,\n        uint40 _duration,\n        uint256 _quantity,\n        uint256 _raePrice\n    ) external payable {\n        // Reverts if list of tokenIds is empty\n        uint256 length = _tokenIds.length;\n        if (length == 0) revert InsufficientTokenIds();\n\n        // Generates merkle root based on list size of tokenIds\n        bytes32 merkleRoot = (length == 1) ? bytes32(_tokenIds[0]) : _generateRoot(_tokenIds);\n\n        // Sets mapping of poolId to PoolInfo\n        poolInfo[++currentId] = PoolInfo(\n            _nftContract,\n            _totalSupply,\n            uint40(block.timestamp) + _duration,\n            false,\n            merkleRoot\n        );\n\n        // Calculates minimum bid price based on initial price of NFT and desired total supply\n        minBidPrices[currentId] = _initialPrice / _totalSupply;\n\n        // Initializes first bid in queue\n        bidPriorityQueues[currentId].initialize();\n\n        // Emits event for creating new pool\n        emit Create(currentId, _nftContract, _tokenIds, msg.sender, _totalSupply, _duration);\n\n        // Contributes ether into new pool\n        contribute(currentId, _quantity, _raePrice);\n    }\n\n    /// @notice Contributes to an existing pool\n    /// @param _poolId ID of the pool\n    /// @param _quantity Amount of Raes being bid on\n    /// @param _price Ether price per Rae\n    function contribute(\n        uint256 _poolId,\n        uint256 _quantity,\n        uint256 _price\n    ) public payable {\n        // Reverts if pool ID is not valid\n        _verifyPool(_poolId);\n        // Reverts if NFT has already been purchased OR termination period has passed\n        (, uint48 totalSupply, , , ) = _verifyUnsuccessfulState(_poolId);\n        // Reverts if ether contribution amount per Rae is less than minimum bid price per Rae\n        if (msg.value < _quantity * minBidPrices[_poolId] || _quantity == 0)\n            revert InvalidContribution();\n        // Reverts if ether payment amount is not equal to total amount being contributed\n        if (msg.value != _quantity * _price) revert InvalidPayment();\n\n        // Updates user and pool contribution amounts\n        userContributions[_poolId][msg.sender] += msg.value;\n        totalContributions[_poolId] += msg.value;\n\n        // Calculates remaining supply based on total possible supply and current filled quantity amount\n        uint256 remainingSupply = totalSupply - filledQuantities[_poolId];\n        // Calculates quantity amount being filled at any price\n        uint256 fillAtAnyPriceQuantity = remainingSupply < _quantity ? remainingSupply : _quantity;\n\n        // Checks if quantity amount being filled is greater than 0\n        if (fillAtAnyPriceQuantity > 0) {\n            // Inserts bid into end of queue\n            bidPriorityQueues[_poolId].insert(msg.sender, _price, fillAtAnyPriceQuantity);\n            // Increments total amount of filled quantities\n            filledQuantities[_poolId] += fillAtAnyPriceQuantity;\n        }\n\n        // Calculates unfilled quantity amount based on desired quantity and actual filled quantity amount\n        uint256 unfilledQuantity = _quantity - fillAtAnyPriceQuantity;\n        // Processes bids in queue to recalculate unfilled quantity amount\n        unfilledQuantity = processBidsInQueue(_poolId, unfilledQuantity, _price);\n\n        // Recalculates filled quantity amount based on updated unfilled quantity amount\n        uint256 filledQuantity = _quantity - unfilledQuantity;\n        // Updates minimum reserve price if filled quantity amount is greater than 0\n        if (filledQuantity > 0) minReservePrices[_poolId] = getMinPrice(_poolId);\n\n        // Emits event for contributing ether to pool based on desired quantity amount and price per Rae\n        emit Contribute(\n            _poolId,\n            msg.sender,\n            msg.value,\n            _quantity,\n            _price,\n            minReservePrices[_poolId]\n        );\n    }\n\n    /// @notice Purchases NFT once contribution amount has been met\n    /// @param _poolId ID of the pool\n    /// @param _market Address of the market buyer contract\n    /// @param _nftContract Address of the NFT contract\n    /// @param _tokenId ID of the token\n    /// @param _price Total ether price of the listed NFT\n    /// @param _purchaseOrder Bytes data of the purchase order parameters\n    /// @param _purchaseProof Merkle proof of the tokenId in the list of permitted tokenIds\n    function purchase(\n        uint256 _poolId,\n        address _market,\n        address _nftContract,\n        uint256 _tokenId,\n        uint256 _price,\n        bytes memory _purchaseOrder,\n        bytes32[] memory _purchaseProof\n    ) external {\n        // Reverts if pool ID is not valid\n        _verifyPool(_poolId);\n        // Reverts if NFT has already been purchased OR termination period has passed\n        (\n            address nftContract,\n            uint48 totalSupply,\n            ,\n            ,\n            bytes32 merkleRoot\n        ) = _verifyUnsuccessfulState(_poolId);\n        // Reverts if NFT contract is not equalt to NFT contract set on pool creation\n        if (_nftContract != nftContract) revert InvalidContract();\n        // Reverts if price is greater than total contribution amount of pool\n        if (_price > minReservePrices[_poolId] * filledQuantities[_poolId])\n            revert InvalidPurchase();\n\n        // Checks merkle proof based on size of array\n        if (_purchaseProof.length == 0) {\n            // Hashes tokenId to verify merkle root if proof is empty\n            if (bytes32(_tokenId) != merkleRoot) revert InvalidProof();\n        } else {\n            // Verifies merkle proof based on position of leaf node in tree\n            bytes32 leaf = keccak256(abi.encode(_tokenId));\n            if (!MerkleProof.verify(_purchaseProof, merkleRoot, leaf)) revert InvalidProof();\n        }\n\n        // Decrements actual price from total pool contributions\n        totalContributions[_poolId] -= _price;\n\n        // Encodes NFT contract and tokenId into purchase order\n        bytes memory nftData = abi.encode(_nftContract, _tokenId);\n        // Encodes arbitrary amount of data based on market buyer to execute purchase\n        _purchaseOrder = abi.encodePacked(nftData, _purchaseOrder);\n\n        // Executes purchase order transaction through market buyer contract and deploys new vault\n        address vault = IMarketBuyer(_market).execute{value: _price}(_purchaseOrder);\n\n        // Checks if NFT contract supports ERC165 and interface ID of ERC721 tokens\n        if (ERC165Checker.supportsInterface(_nftContract, _INTERFACE_ID_ERC721)) {\n            // Verifes vault is owner of ERC-721 token\n            if (IERC721(_nftContract).ownerOf(_tokenId) != vault) revert UnsuccessfulPurchase();\n        } else {\n            // Verifies vault is owner of CryptoPunk token\n            if (ICryptoPunk(_nftContract).punkIndexToAddress(_tokenId) != vault)\n                revert UnsuccessfulPurchase();\n        }\n\n        // Stores mapping value of poolId to newly deployed vault\n        poolToVault[_poolId] = vault;\n        // Sets pool state to successful\n        poolInfo[_poolId].success = true;\n\n        // Emits event for purchasing NFT at given price\n        emit Purchase(_poolId, vault, _nftContract, _tokenId, _price);\n    }\n\n    /// @notice Mints Raes based on contribution amount and refunds remaining ether\n    /// @param _poolId ID of the pool\n    /// @param _mintProof Merkle proof for executing minting of Rae tokens\n    function claim(uint256 _poolId, bytes32[] calldata _mintProof) external {\n        // Reverts if pool ID is not valid\n        _verifyPool(_poolId);\n        // Reverts if purchase has not been made AND termination period has not passed\n        (, , , bool success, ) = _verifySuccessfulState(_poolId);\n        // Reverts if contribution balance of user is insufficient\n        uint256 contribution = userContributions[_poolId][msg.sender];\n        if (contribution == 0) revert InsufficientBalance();\n\n        // Deletes user contribution from storage\n        delete userContributions[_poolId][msg.sender];\n\n        // Set up scoped values for iteration\n        uint256 totalQty;\n        uint256 reservePrice = minReservePrices[_poolId];\n        uint256[] memory bidIds = getOwnerToBidIds(_poolId, msg.sender);\n        uint256 length = bidIds.length;\n\n        // Iterates through all active bidIds of the caller\n        if (success) {\n            for (uint256 i; i < length; ++i) {\n                // Gets bid quantity from storage\n                Bid storage bid = bidPriorityQueues[_poolId].bidIdToBidMap[bidIds[i]];\n                uint256 quantity = bid.quantity;\n                // Resets bid quantity amount\n                bid.quantity = 0;\n                // Increments total quantity of Raes to be minted\n                totalQty += quantity;\n                // Decrements quantity price from total user contribution balance\n                contribution -= quantity * reservePrice;\n            }\n\n            // Mints total quantity of Raes to caller\n            _mintRaes(poolToVault[_poolId], msg.sender, totalQty, _mintProof);\n        }\n\n        // Transfers remaining contribution balance back to caller\n        payable(msg.sender).call{value: contribution}(\"\");\n\n        // Withdraws pending balance of caller if available\n        if (pendingBalances[msg.sender] > 0) withdrawBalance();\n\n        // Emits event for claiming tokens and receiving ether refund\n        emit Claim(_poolId, msg.sender, totalQty, contribution);\n    }\n\n    function withdrawBalance() public {\n        // Reverts if caller balance is insufficient\n        uint256 balance = pendingBalances[msg.sender];\n        if (balance == 0) revert InsufficientBalance();\n\n        // Resets pending balance amount\n        delete pendingBalances[msg.sender];\n\n        // Transfers pending ether balance to caller\n        payable(msg.sender).call{value: balance}(\"\");\n    }\n\n    /// @notice Attempts to accept bid for specifc quantity and price\n    /// @param _poolId ID of the pool\n    /// @param _quantity Amount of Raes being filled\n    /// @param _price Price of ether per Rae token\n    /// @return quantity Unfilled quantity amount\n    function processBidsInQueue(\n        uint256 _poolId,\n        uint256 _quantity,\n        uint256 _price\n    ) private returns (uint256 quantity) {\n        quantity = _quantity;\n        while (quantity > 0) {\n            // Retrieves lowest bid in queue\n            Bid storage lowestBid = bidPriorityQueues[_poolId].getMin();\n            // Breaks out of while loop if given price is less than than lowest bid price\n            if (_price < lowestBid.price) {\n                break;\n            }\n\n            uint256 lowestBidQuantity = lowestBid.quantity;\n            // Checks if lowest bid quantity amount is greater than given quantity amount\n            if (lowestBidQuantity > quantity) {\n                // Decrements given quantity amount from lowest bid quantity\n                lowestBid.quantity -= quantity;\n                // Calculates partial contribution of bid by quantity amount and price\n                uint256 contribution = quantity * lowestBid.price;\n\n                // Decrements partial contribution amount of lowest bid from total and user contributions\n                totalContributions[_poolId] -= contribution;\n                userContributions[_poolId][lowestBid.owner] -= contribution;\n                // Increments pending balance of lowest bid owner\n                pendingBalances[lowestBid.owner] += contribution;\n\n                // Inserts new bid with given quantity amount into proper position of queue\n                bidPriorityQueues[_poolId].insert(msg.sender, _price, quantity);\n                // Resets quantity amount to exit while loop\n                quantity = 0;\n            } else {\n                // Calculates total contribution of bid by quantity amount and price\n                uint256 contribution = lowestBid.quantity * lowestBid.price;\n\n                // Decrements full contribution amount of lowest bid from total and user contributions\n                totalContributions[_poolId] -= contribution;\n                userContributions[_poolId][lowestBid.owner] -= contribution;\n                // Increments pending balance of lowest bid owner\n                pendingBalances[lowestBid.owner] += contribution;\n\n                // Removes lowest bid in queue\n                bidPriorityQueues[_poolId].delMin();\n                // Inserts new bid with lowest bid quantity amount into proper position of queue\n                bidPriorityQueues[_poolId].insert(msg.sender, _price, lowestBidQuantity);\n                // Decrements lowest bid quantity from total quantity amount\n                quantity -= lowestBidQuantity;\n            }\n        }\n    }\n\n    /// @notice Gets bid values in queue of given pool\n    /// @param _poolId ID of the pool\n    /// @param _bidId ID of the bid in queue\n    function getBidInQueue(uint256 _poolId, uint256 _bidId)\n        public\n        view\n        returns (\n            uint256 bidId,\n            address owner,\n            uint256 price,\n            uint256 quantity\n        )\n    {\n        Bid storage bid = bidPriorityQueues[_poolId].bidIdToBidMap[_bidId];\n        bidId = bid.bidId;\n        owner = bid.owner;\n        price = bid.price;\n        quantity = bid.quantity;\n    }\n\n    /// @notice Gets minimum bid price of queue for given pool\n    /// @param _poolId ID of the pool\n    function getMinPrice(uint256 _poolId) public view returns (uint256) {\n        return bidPriorityQueues[_poolId].getMin().price;\n    }\n\n    /// @notice Gets next bidId in queue of given pool\n    /// @param _poolId ID of the pool\n    function getNextBidId(uint256 _poolId) public view returns (uint256) {\n        return bidPriorityQueues[_poolId].nextBidId;\n    }\n\n    /// @notice Gets total number of bids in queue for given pool\n    /// @param _poolId ID of the pool\n    function getNumBids(uint256 _poolId) public view returns (uint256) {\n        return bidPriorityQueues[_poolId].numBids;\n    }\n\n    /// @notice Gets quantity of Raes for bid of given pool\n    /// @param _poolId ID of the pool\n    /// @param _bidId ID of the bid in queue\n    function getBidQuantity(uint256 _poolId, uint256 _bidId) public view returns (uint256) {\n        return bidPriorityQueues[_poolId].bidIdToBidMap[_bidId].quantity;\n    }\n\n    /// @notice Gets list of bidIds for address of given pool\n    /// @param _poolId ID of the pool\n    /// @param _owner Address of the owner\n    function getOwnerToBidIds(uint256 _poolId, address _owner)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return bidPriorityQueues[_poolId].ownerToBidIds[_owner];\n    }\n\n    /// @notice Logs entire queue of given pool\n    /// @dev Must include console log to debug\n    /// @param _poolId ID of the pool\n    function printQueue(uint256 _poolId) public view {\n        uint256 counter;\n        uint256 index = 1;\n        MinPriorityQueue.Queue storage queue = bidPriorityQueues[_poolId];\n        uint256 numBids = queue.numBids;\n        while (counter < numBids) {\n            Bid memory bid = queue.bidIdToBidMap[index];\n            if (bid.bidId == 0) {\n                ++index;\n                continue;\n            }\n            ++index;\n            ++counter;\n        }\n    }\n\n    /// @dev Generates merkle root for list of tokenIds\n    function _generateRoot(uint256[] calldata _tokenIds)\n        internal\n        pure\n        returns (bytes32 merkleRoot)\n    {\n        // Creates empty leaf nodes array based on size of tokenIds\n        uint256 length = _tokenIds.length;\n        bytes32[] memory leaves = new bytes32[](length);\n        unchecked {\n            for (uint256 i; i < length; ++i) {\n                // Hashes each tokenId into leaf node and set at index position of array\n                leaves[i] = keccak256(abi.encode(_tokenIds[i]));\n            }\n        }\n        // Generates merkle root from given leaf nodes\n        merkleRoot = getRoot(leaves);\n    }\n\n    /// @dev Reverts if pool ID is not valid\n    function _verifyPool(uint256 _poolId) internal view {\n        if (_poolId == 0 || _poolId > currentId) revert InvalidPool();\n    }\n\n    // Reverts if NFT has already been purchased OR termination period has passed\n    function _verifyUnsuccessfulState(uint256 _poolId)\n        internal\n        view\n        returns (\n            address,\n            uint48,\n            uint40,\n            bool,\n            bytes32\n        )\n    {\n        PoolInfo memory pool = poolInfo[_poolId];\n        if (pool.success || block.timestamp > pool.terminationPeriod) revert InvalidState();\n        return (\n            pool.nftContract,\n            pool.totalSupply,\n            pool.terminationPeriod,\n            pool.success,\n            pool.merkleRoot\n        );\n    }\n\n    // Reverts if NFT has not been purchased AND termination period has not passed\n    function _verifySuccessfulState(uint256 _poolId)\n        internal\n        view\n        returns (\n            address,\n            uint48,\n            uint40,\n            bool,\n            bytes32\n        )\n    {\n        PoolInfo memory pool = poolInfo[_poolId];\n        if (!pool.success && block.timestamp < pool.terminationPeriod) revert InvalidState();\n        return (\n            pool.nftContract,\n            pool.totalSupply,\n            pool.terminationPeriod,\n            pool.success,\n            pool.merkleRoot\n        );\n    }\n}"
    }
  ]
}