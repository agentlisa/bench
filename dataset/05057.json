{
  "Title": "[M-29] `AirdropBroker`: Airdrops in epoch 4 can participate and exercise options in subsequent epochs",
  "Content": "\nIn `AirdropBroker`, the owner calls `registerUsersForPhase` with `_phase = 4` to airdrop to users in epoch 4 to 8.\n\n```solidity\n        else if (_phase == 4) {\n            for (uint256 i; i < _users.length; i++) {\n                phase4Users[_users[i]] = _amounts[i];\n            }\n        }\n```\n\nAnd the documentation says:\n\n> Phase Four will have five sub phases, each bearing one week epochs. Four of the sub phases will be rewarded to `twTAP` lockers each weekly epoch over four weeks. Unclaimed `aoTAP` in each epoch will roll over to the next epoch, until the final sub phase.\n\nThe problem here is that `phase4Users` is not cleared before the start of the 5 sub-phases of phase 4, which results in users being able to participate and exercise the epoch 4 options in epoch 5.\n\n```solidity\n        } else if (cachedEpoch >= 4) {\n            aoTAPTokenID = _participatePhase4();\n        }\n...\n    function _participatePhase4() internal returns (uint256 oTAPTokenID) {\n        uint256 _eligibleAmount = phase4Users[msg.sender];\n        if (_eligibleAmount == 0) revert NotEligible();\n\n        // Close eligibility\n        phase4Users[msg.sender] = 0;\n\n```\n\nConsider the following scenario. There are 10,000 `aoTAPs` in phase 4, which means that epoch 4, 5, 6, and 7 will receive 2,500 `aoTAPs` respectively, and the remaining unclaimed `aoTAPs` will be rolled over to the next epoch.\n\n- In epoch 4, Alice received 1000 airdrops, but Alice did not participate.\n- At epoch 5, the total airdrop will become `2500 + 1000 = 3500` and distributed.\n\nHowever. Alice can participate and exercise the epoch 4 options in epoch 5, and making the total airdrop in epoch 5 become `3500 + 1000 = 4500`.\n\n### Proof of Concept\n\n<https://github.com/Tapioca-DAO/tap-token//blob/20a83b1d2d5577653610a6c3879dff9df4968345/contracts/option-airdrop/AirdropBroker.sol#L321-L339>\n\n<https://github.com/Tapioca-DAO/tap-token//blob/20a83b1d2d5577653610a6c3879dff9df4968345/contracts/option-airdrop/AirdropBroker.sol#L203-L220>\n\n### Recommended Mitigation Steps\n\nIt is recommended to delete `phase4Users` in `newEpoch()`.\n\n<https://ethereum.stackexchange.com/questions/15553/how-to-delete-a-mapping>\n\nOr, add `phase4Users1`/`phase4Users2`/`phase4Users3`/`phase4Users4`/`phase4Users5` mappings to store the airdrops for epochs 4 through 8, respectively.\n\n### Assessed type\n\nContext\n\n**[LSDan (judge) decreased severity to Low](https://github.com/code-423n4/2024-02-tapioca-findings/issues/21#issuecomment-2033054397)**\n\n**[cccz (warden) commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/21#issuecomment-2047811014):**\n > I believe this is a valid M. It's not any admin error stuff. It's a code level error, the code uses the same variables to manage airdrops at different epochs.\n> \n> The only way to get rid of it is if the admin calls `newEpoch()` to enter a new epoch while resetting all the `phase4Users` variables, but `newEpoch()` is a public function and anyone can call it, which makes it hard for the admin to get rid of it.\n>\n> ```solidity\n>     function newEpoch() external tapExists {\n>         if (block.timestamp < lastEpochUpdate + EPOCH_DURATION) {\n>             revert TooSoon();\n>         }\n> \n>         // Update epoch info\n>         lastEpochUpdate = uint64(block.timestamp);\n>         epoch++;\n> \n>         // At epoch 4, change the epoch duration to 7 days\n>         if (epoch == 4) {\n>             EPOCH_DURATION = 7 days;\n>         }\n> \n>         // Get epoch TAP valuation\n>         (bool success, uint256 _epochTAPValuation) = tapOracle.get(tapOracleData);\n>         if (!success) revert Failed();\n>         epochTAPValuation = uint128(_epochTAPValuation);\n>         emit NewEpoch(epoch, epochTAPValuation);\n>     }\n> ```\n>\n> And as the report says, using different variables to manage airdrops for different epochs is the right way.\n\n**[LSDan (judge) increased severity to Medium and commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/21#issuecomment-2051717720):**\n > Agreed. This makes sense as a Medium.\n\n**[0xWeiss (Tapioca) confirmed](https://github.com/code-423n4/2024-02-tapioca-findings/issues/21#issuecomment-2125610255)**\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-02-tapioca-findings/issues/21).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/option-airdrop/AirdropBroker.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IPearlmit, PearlmitHandler} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {TWAML, FullMath} from \"tap-token/options/twAML.sol\"; // TODO Naming\nimport {TapToken} from \"tap-token/tokens/TapToken.sol\";\nimport {AOTAP, AirdropTapOption} from \"./aoTAP.sol\";\n\n/*\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n*/\n\nstruct PaymentTokenOracle {\n    ITapiocaOracle oracle;\n    bytes oracleData;\n}\n\nstruct Phase2Info {\n    uint8[4] amountsPerUsers;\n    uint8[4] discountsPerUsers;\n}\n\n/**\n * @notice More details found here https://docs.tapioca.xyz/tapioca/launch/option-airdrop\n */\ncontract AirdropBroker is Pausable, Ownable, PearlmitHandler, FullMath, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    bytes public tapOracleData;\n    ITapiocaOracle public tapOracle;\n    TapToken public tapToken;\n    AOTAP public immutable aoTAP;\n    IERC721 public immutable PCNFT;\n\n    uint128 public epochTAPValuation; // TAP price for the current epoch\n    uint64 public lastEpochUpdate; // timestamp of the last epoch update\n    uint64 public epoch; // Represents the number of weeks since the start of the contract\n\n    mapping(ERC20 => PaymentTokenOracle) public paymentTokens; // Token address => PaymentTokenOracle\n    address public paymentTokenBeneficiary; // Where to collect the payment tokens\n\n    mapping(uint256 => mapping(uint256 => uint256)) public aoTAPCalls; // oTAPTokenID => epoch => amountExercised\n\n    /// @notice Record of participation in phase 2 airdrop\n    /// Only applicable for phase 2. To get subphases on phase 2 we do userParticipation[_user][20+roles]\n    mapping(address => mapping(uint256 => bool)) public userParticipation; // user address => phase => participated\n\n    /// =====-------======\n    ///      Phase 1\n    /// =====-------======\n\n    /// @notice user address => eligible TAP amount, 0 means no eligibility\n    mapping(address => uint256) public phase1Users;\n    uint256 public constant PHASE_1_DISCOUNT = 500_000; //50 * 1e4; 50%\n\n    /// =====-------======\n    ///      Phase 2\n    /// =====-------======\n\n    // [OG Pearls, Tapiocans, Oysters, Cassava]\n    bytes32[4] public phase2MerkleRoots; // merkle root of phase 2 airdrop\n    uint8[4] public PHASE_2_AMOUNT_PER_USER = [200, 200, 190, 190];\n    uint24[4] public PHASE_2_DISCOUNT_PER_USER = [500_000, 400_000, 330_000, 250_000];\n\n    /// =====-------======\n    ///      Phase 3\n    /// =====-------======\n\n    uint256 public constant PHASE_3_AMOUNT_PER_USER = 714;\n    uint256 public constant PHASE_3_DISCOUNT = 500_000; //50 * 1e4; 50%\n\n    /// =====-------======\n    ///      Phase 4\n    /// =====-------======\n\n    /// @notice user address => eligible TAP amount, 0 means no eligibility\n    mapping(address => uint256) public phase4Users;\n    uint256 public constant PHASE_4_DISCOUNT = 330_000; //33 * 1e4;\n\n    uint256 public EPOCH_DURATION = 2 days; // Becomes 7 days at the start of the phase 4\n    uint256 public constant LAST_EPOCH = 8; // 8 epochs, 41 days long\n\n    /// =====-------======\n\n    error PaymentTokenNotValid();\n    error OptionExpired();\n    error TooHigh();\n    error TooLow();\n    error NotStarted();\n    error Ended();\n    error NotAuthorized();\n    error TooSoon();\n    error Failed();\n    error NotValid();\n    error TokenBeneficiaryNotSet();\n    error NotEligible();\n    error AlreadyParticipated();\n    error PaymentAmountNotValid();\n    error TapAmountNotValid();\n    error PaymentTokenValuationNotValid();\n    error TapNotSet();\n    error TapOracleNotSet();\n\n    constructor(address _aoTAP, address _pcnft, address _paymentTokenBeneficiary, IPearlmit _pearlmit, address _owner)\n        PearlmitHandler(_pearlmit)\n    {\n        paymentTokenBeneficiary = _paymentTokenBeneficiary;\n        aoTAP = AOTAP(_aoTAP);\n        PCNFT = IERC721(_pcnft);\n\n        _transferOwnership(_owner);\n    }\n\n    // ==========\n    //   EVENTS\n    // ==========\n    event Participate(uint256 indexed epoch, uint256 aoTAPTokenID);\n    event ExerciseOption(\n        uint256 indexed epoch, address indexed to, ERC20 indexed paymentToken, uint256 aoTapTokenID, uint256 amount\n    );\n    event NewEpoch(uint256 indexed epoch, uint256 epochTAPValuation);\n    event SetPaymentToken(ERC20 paymentToken, ITapiocaOracle oracle, bytes oracleData);\n    event SetTapOracle(ITapiocaOracle oracle, bytes oracleData);\n    event Phase2MerkleRootsUpdated();\n\n    modifier tapExists() {\n        if (address(tapOracle) == address(0)) revert TapOracleNotSet();\n        if (address(tapToken) == address(0)) revert TapNotSet();\n        _;\n    }\n\n    // ==========\n    //    READ\n    // ==========\n\n    /// @notice Returns the details of an OTC deal for a given oTAP token ID and a payment token.\n    ///         The oracle uses the last peeked value, and not the latest one, so the payment amount may be different.\n    /// @param _aoTAPTokenID The aoTAP token ID\n    /// @param _paymentToken The payment token\n    /// @param _tapAmount The amount of TAP to be exchanged. If 0 it will use the full amount of TAP eligible for the deal\n    /// @return eligibleTapAmount The amount of TAP eligible for the deal\n    /// @return paymentTokenAmount The amount of payment tokens required for the deal\n    /// @return tapAmount The amount of TAP to be exchanged\n\n    function getOTCDealDetails(uint256 _aoTAPTokenID, ERC20 _paymentToken, uint256 _tapAmount)\n        external\n        view\n        tapExists\n        returns (uint256 eligibleTapAmount, uint256 paymentTokenAmount, uint256 tapAmount)\n    {\n        // Load data\n        (, AirdropTapOption memory aoTapOption) = aoTAP.attributes(_aoTAPTokenID);\n        if (aoTapOption.expiry < block.timestamp) revert OptionExpired();\n\n        uint256 cachedEpoch = epoch;\n\n        PaymentTokenOracle memory paymentTokenOracle = paymentTokens[_paymentToken];\n\n        // Check requirements\n        if (paymentTokenOracle.oracle == ITapiocaOracle(address(0))) {\n            revert PaymentTokenNotValid();\n        }\n\n        eligibleTapAmount = aoTapOption.amount;\n        eligibleTapAmount -= aoTAPCalls[_aoTAPTokenID][cachedEpoch]; // Subtract already exercised amount\n        if (eligibleTapAmount < _tapAmount) revert TooHigh();\n\n        tapAmount = _tapAmount == 0 ? eligibleTapAmount : _tapAmount;\n        if (tapAmount < 1e18) revert TooLow();\n        // Get TAP valuation\n        uint256 otcAmountInUSD = tapAmount * epochTAPValuation; // Divided by TAP decimals\n        // Get payment token valuation\n        (, uint256 paymentTokenValuation) = paymentTokenOracle.oracle.peek(paymentTokenOracle.oracleData);\n        // Get payment token amount\n        paymentTokenAmount = _getDiscountedPaymentAmount(\n            otcAmountInUSD, paymentTokenValuation, aoTapOption.discount, _paymentToken.decimals()\n        );\n    }\n\n    // ===========\n    //    WRITE\n    // ===========\n\n    /// @notice Participate in the airdrop\n    /// @param _data The data to be used for the participation, varies by phases\n    function participate(bytes calldata _data) external whenNotPaused tapExists returns (uint256 aoTAPTokenID) {\n        uint256 cachedEpoch = epoch;\n        if (cachedEpoch == 0) revert NotStarted();\n        if (cachedEpoch > LAST_EPOCH) revert Ended();\n\n        // Phase 1\n        if (cachedEpoch == 1) {\n            aoTAPTokenID = _participatePhase1();\n        } else if (cachedEpoch == 2) {\n            aoTAPTokenID = _participatePhase2(_data); // _data = (uint256 role, bytes32[] _merkleProof)\n        } else if (cachedEpoch == 3) {\n            aoTAPTokenID = _participatePhase3(_data); // _data = (uint256[] _tokenID)\n        } else if (cachedEpoch >= 4) {\n            aoTAPTokenID = _participatePhase4();\n        }\n\n        emit Participate(cachedEpoch, aoTAPTokenID);\n    }\n\n    /// @notice Exercise an aoTAP position\n    /// @param _aoTAPTokenID tokenId of the aoTAP position, position must be active\n    /// @param _paymentToken Address of the payment token to use, must be whitelisted\n    /// @param _tapAmount Amount of TAP to exercise. If 0, the full amount is exercised\n    function exerciseOption(uint256 _aoTAPTokenID, ERC20 _paymentToken, uint256 _tapAmount)\n        external\n        whenNotPaused\n        tapExists\n    {\n        // Load data\n        (, AirdropTapOption memory aoTapOption) = aoTAP.attributes(_aoTAPTokenID);\n        if (aoTapOption.expiry < block.timestamp) revert OptionExpired();\n\n        uint256 cachedEpoch = epoch;\n\n        PaymentTokenOracle memory paymentTokenOracle = paymentTokens[_paymentToken];\n\n        // Check requirements\n        if (paymentTokenOracle.oracle == ITapiocaOracle(address(0))) {\n            revert PaymentTokenNotValid();\n        }\n        if (!aoTAP.isApprovedOrOwner(msg.sender, _aoTAPTokenID)) {\n            revert NotAuthorized();\n        }\n\n        // Get eligible OTC amount\n\n        uint256 eligibleTapAmount = aoTapOption.amount;\n        eligibleTapAmount -= aoTAPCalls[_aoTAPTokenID][cachedEpoch]; // Subtract already exercised amount\n        if (eligibleTapAmount < _tapAmount) revert TooHigh();\n\n        uint256 chosenAmount = _tapAmount == 0 ? eligibleTapAmount : _tapAmount;\n        if (chosenAmount < 1e18) revert TooLow();\n        aoTAPCalls[_aoTAPTokenID][cachedEpoch] += chosenAmount; // Adds up exercised amount to current epoch\n\n        // Finalize the deal\n        _processOTCDeal(_paymentToken, paymentTokenOracle, chosenAmount, aoTapOption.discount);\n\n        emit ExerciseOption(cachedEpoch, msg.sender, _paymentToken, _aoTAPTokenID, chosenAmount);\n    }\n\n    /// @notice Start a new epoch, extract TAP from the tapToken contract,\n    function newEpoch() external tapExists {\n        if (block.timestamp < lastEpochUpdate + EPOCH_DURATION) {\n            revert TooSoon();\n        }\n\n        // Update epoch info\n        lastEpochUpdate = uint64(block.timestamp);\n        epoch++;\n\n        // At epoch 4, change the epoch duration to 7 days\n        if (epoch == 4) {\n            EPOCH_DURATION = 7 days;\n        }\n\n        // Get epoch TAP valuation\n        (bool success, uint256 _epochTAPValuation) = tapOracle.get(tapOracleData);\n        if (!success) revert Failed();\n        epochTAPValuation = uint128(_epochTAPValuation);\n        emit NewEpoch(epoch, epochTAPValuation);\n    }\n\n    /// @notice Claim the Broker role of the aoTAP contract\n    function aoTAPBrokerClaim() external {\n        aoTAP.brokerClaim();\n    }\n\n    // =========\n    //   OWNER\n    // =========\n\n    function setTapToken(address payable _tapToken) external onlyOwner {\n        if (address(tapToken) != address(0)) revert NotValid();\n        tapToken = TapToken(_tapToken);\n    }\n\n    /// @notice Set the tapToken Oracle address and data\n    /// @param _tapOracle The new tapToken Oracle address\n    /// @param _tapOracleData The new tapToken Oracle data\n    function setTapOracle(ITapiocaOracle _tapOracle, bytes calldata _tapOracleData) external onlyOwner {\n        tapOracle = _tapOracle;\n        tapOracleData = _tapOracleData;\n\n        emit SetTapOracle(_tapOracle, _tapOracleData);\n    }\n\n    function setPhase2MerkleRoots(bytes32[4] calldata _merkleRoots) external onlyOwner {\n        if (epoch >= 2) revert NotValid();\n        phase2MerkleRoots = _merkleRoots;\n        emit Phase2MerkleRootsUpdated();\n    }\n\n    /**\n     * @notice Register users for a phase 1 or 4 with their eligible amount.\n     * @param _phase The phase to register the users for\n     * @param _users The users to register\n     * @param _amounts The eligible amount of TAP for each user\n     */\n    function registerUsersForPhase(uint256 _phase, address[] calldata _users, uint256[] calldata _amounts)\n        external\n        onlyOwner\n    {\n        if (_users.length != _amounts.length) revert NotValid();\n\n        if (_phase == 1) {\n            if (epoch >= 1) revert NotValid();\n            for (uint256 i; i < _users.length; i++) {\n                phase1Users[_users[i]] = _amounts[i];\n            }\n        }\n        /// @dev We want to be able to set phase 4 users in the future on subsequent epochs\n        else if (_phase == 4) {\n            for (uint256 i; i < _users.length; i++) {\n                phase4Users[_users[i]] = _amounts[i];\n            }\n        }\n    }\n\n    /// @notice Activate or deactivate a payment token\n    /// @dev set the oracle to address(0) to deactivate, expect the same decimal precision as TAP oracle\n    function setPaymentToken(ERC20 _paymentToken, ITapiocaOracle _oracle, bytes calldata _oracleData)\n        external\n        onlyOwner\n    {\n        paymentTokens[_paymentToken].oracle = _oracle;\n        paymentTokens[_paymentToken].oracleData = _oracleData;\n\n        emit SetPaymentToken(_paymentToken, _oracle, _oracleData);\n    }\n\n    /// @notice Set the payment token beneficiary\n    /// @param _paymentTokenBeneficiary The new payment token beneficiary\n    function setPaymentTokenBeneficiary(address _paymentTokenBeneficiary) external onlyOwner {\n        paymentTokenBeneficiary = _paymentTokenBeneficiary;\n    }\n\n    /// @notice Collect the payment tokens from the OTC deals\n    /// @param _paymentTokens The payment tokens to collect\n    function collectPaymentTokens(address[] calldata _paymentTokens) external onlyOwner nonReentrant {\n        if (paymentTokenBeneficiary == address(0)) {\n            revert TokenBeneficiaryNotSet();\n        }\n        uint256 len = _paymentTokens.length;\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                IERC20 paymentToken = IERC20(_paymentTokens[i]);\n                paymentToken.safeTransfer(paymentTokenBeneficiary, paymentToken.balanceOf(address(this)));\n            }\n        }\n    }\n\n    /// @notice Recover the unclaimed TAP from the contract.\n    /// Should occur after the end of the airdrop, which is 8 epochs, or 41 days long.\n    function daoRecoverTAP() external onlyOwner {\n        if (epoch <= LAST_EPOCH) revert TooSoon();\n\n        tapToken.transfer(msg.sender, tapToken.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Un/Pauses this contract.\n     */\n    function setPause(bool _pauseState) external onlyOwner {\n        if (_pauseState) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    // ============\n    //   INTERNAL\n    // ============\n\n    /// @notice Participate in phase 1 of the Airdrop. LBP users are given aoTAP pro-rata.\n    function _participatePhase1() internal returns (uint256 oTAPTokenID) {\n        uint256 _eligibleAmount = phase1Users[msg.sender];\n        if (_eligibleAmount == 0) revert NotEligible();\n\n        // Close eligibility\n        phase1Users[msg.sender] = 0;\n\n        // Mint aoTAP\n        uint128 expiry = uint128(lastEpochUpdate + EPOCH_DURATION); // Set expiry to the end of the epoch\n        oTAPTokenID = aoTAP.mint(msg.sender, expiry, uint128(PHASE_1_DISCOUNT), _eligibleAmount);\n    }\n\n    /// @notice Participate in phase 2 of the Airdrop. Guild members will receive pre-defined discounts and TAP, based on role.\n    /// @param _data The calldata. Needs to be the address of the user.\n    /// _data = (uint256 role, bytes32[] _merkleProof). Refer to {phase2MerkleRoots} for role.\n    function _participatePhase2(bytes calldata _data) internal returns (uint256 oTAPTokenID) {\n        (uint256 _role, bytes32[] memory _merkleProof) = abi.decode(_data, (uint256, bytes32[]));\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        if (!MerkleProof.verify(_merkleProof, phase2MerkleRoots[_role], leaf)) {\n            revert NotEligible();\n        }\n\n        uint256 subPhase = 20 + _role;\n        if (userParticipation[msg.sender][subPhase]) {\n            revert AlreadyParticipated();\n        }\n        // Close eligibility\n        userParticipation[msg.sender][subPhase] = true;\n\n        // Mint aoTAP\n        uint128 expiry = uint128(lastEpochUpdate + EPOCH_DURATION); // Set expiry to the end of the epoch\n        uint256 eligibleAmount = uint256(PHASE_2_AMOUNT_PER_USER[_role]) * 1e18;\n        uint128 discount = uint128(PHASE_2_DISCOUNT_PER_USER[_role]);\n        oTAPTokenID = aoTAP.mint(msg.sender, expiry, discount, eligibleAmount);\n    }\n\n    /// @notice Participate in phase 3 of the Airdrop. PCNFT holder will receive pre-defined discount and TAP.\n    /// @param _data The calldata. Needs to be an array of PCNFT tokenIDs.\n    /// _data = (uint256 PCNFT tokenID[])\n    function _participatePhase3(bytes calldata _data) internal returns (uint256 oTAPTokenID) {\n        uint256[] memory _tokenIDs = abi.decode(_data, (uint256[]));\n\n        uint256 arrLen = _tokenIDs.length;\n        address tokenIDToAddress;\n        for (uint256 i; i < arrLen;) {\n            if (PCNFT.ownerOf(_tokenIDs[i]) != msg.sender) revert NotEligible();\n\n            // To avoid collision, we cast token ID to an address,\n            // no conflict possible, tokenID goes from 0 ... 714.\n            tokenIDToAddress = address(uint160(_tokenIDs[i]));\n            if (userParticipation[tokenIDToAddress][3]) {\n                revert AlreadyParticipated();\n            }\n\n            // Close eligibility\n            userParticipation[tokenIDToAddress][3] = true;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint128 expiry = uint128(lastEpochUpdate + EPOCH_DURATION); // Set expiry to the end of the epoch\n        uint256 eligibleAmount = arrLen * PHASE_3_AMOUNT_PER_USER * 1e18; // Phase 3 amount multiplied the number of PCNFTs\n        uint128 discount = uint128(PHASE_3_DISCOUNT);\n        oTAPTokenID = aoTAP.mint(msg.sender, expiry, discount, eligibleAmount);\n    }\n\n    /// @notice Participate in phase 4 of the Airdrop. twTAP and Cassava guild's role are given TAP pro-rata.\n    function _participatePhase4() internal returns (uint256 oTAPTokenID) {\n        uint256 _eligibleAmount = phase4Users[msg.sender];\n        if (_eligibleAmount == 0) revert NotEligible();\n\n        // Close eligibility\n        phase4Users[msg.sender] = 0;\n\n        // Mint aoTAP\n        uint128 expiry = uint128(lastEpochUpdate + EPOCH_DURATION); // Set expiry to the end of the epoch\n        oTAPTokenID = aoTAP.mint(msg.sender, expiry, uint128(PHASE_4_DISCOUNT), _eligibleAmount);\n    }\n\n    /// @notice Process the OTC deal, transfer the payment token to the broker and the TAP amount to the user\n    /// @param _paymentToken The payment token\n    /// @param _paymentTokenOracle The oracle of the payment token\n    /// @param tapAmount The amount of TAP that the user has to receive\n    /// @param discount The discount that the user has to apply to the OTC deal\n    function _processOTCDeal(\n        ERC20 _paymentToken,\n        PaymentTokenOracle memory _paymentTokenOracle,\n        uint256 tapAmount,\n        uint256 discount\n    ) internal {\n        if (tapAmount == 0) revert TapAmountNotValid();\n\n        // Get TAP valuation\n        uint256 otcAmountInUSD = tapAmount * epochTAPValuation;\n\n        // Get payment token valuation\n        (bool success, uint256 paymentTokenValuation) = _paymentTokenOracle.oracle.get(_paymentTokenOracle.oracleData);\n        if (!success) revert Failed();\n\n        // Calculate payment amount and initiate the transfers\n        uint256 discountedPaymentAmount =\n            _getDiscountedPaymentAmount(otcAmountInUSD, paymentTokenValuation, discount, _paymentToken.decimals());\n        if (discountedPaymentAmount == 0) revert PaymentAmountNotValid();\n\n        uint256 balBefore = _paymentToken.balanceOf(address(this));\n        // IERC20(address(_paymentToken)).safeTransferFrom(msg.sender, address(this), discountedPaymentAmount);\n        {\n            bool isErr =\n                pearlmit.transferFromERC20(msg.sender, address(this), address(_paymentToken), discountedPaymentAmount);\n            if (isErr) revert Failed();\n        }\n        uint256 balAfter = _paymentToken.balanceOf(address(this));\n        if (balAfter - balBefore != discountedPaymentAmount) revert Failed();\n\n        tapToken.transfer(msg.sender, tapAmount);\n    }\n\n    /// @notice Computes the discounted payment amount for a given OTC amount in USD\n    /// @param _otcAmountInUSD The OTC amount in USD, 18 decimals\n    /// @param _paymentTokenValuation The payment token valuation in USD, 18 decimals\n    /// @param _discount The discount in BPS\n    /// @param _paymentTokenDecimals The payment token decimals\n    /// @return paymentAmount The discounted payment amount\n    function _getDiscountedPaymentAmount(\n        uint256 _otcAmountInUSD,\n        uint256 _paymentTokenValuation,\n        uint256 _discount,\n        uint256 _paymentTokenDecimals\n    ) internal pure returns (uint256 paymentAmount) {\n        if (_paymentTokenValuation == 0) revert PaymentTokenValuationNotValid();\n        // Calculate payment amount\n        uint256 rawPaymentAmount = _otcAmountInUSD / _paymentTokenValuation;\n        paymentAmount = rawPaymentAmount - muldiv(rawPaymentAmount, _discount, 100e4); // 1e4 is discount decimals, 100 is discount percentage\n\n        paymentAmount = paymentAmount / (10 ** (18 - _paymentTokenDecimals));\n    }\n}"
    },
    {
      "filename": "contracts/option-airdrop/AirdropBroker.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IPearlmit, PearlmitHandler} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {TWAML, FullMath} from \"tap-token/options/twAML.sol\"; // TODO Naming\nimport {TapToken} from \"tap-token/tokens/TapToken.sol\";\nimport {AOTAP, AirdropTapOption} from \"./aoTAP.sol\";\n\n/*\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n*/\n\nstruct PaymentTokenOracle {\n    ITapiocaOracle oracle;\n    bytes oracleData;\n}\n\nstruct Phase2Info {\n    uint8[4] amountsPerUsers;\n    uint8[4] discountsPerUsers;\n}\n\n/**\n * @notice More details found here https://docs.tapioca.xyz/tapioca/launch/option-airdrop\n */\ncontract AirdropBroker is Pausable, Ownable, PearlmitHandler, FullMath, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    bytes public tapOracleData;\n    ITapiocaOracle public tapOracle;\n    TapToken public tapToken;\n    AOTAP public immutable aoTAP;\n    IERC721 public immutable PCNFT;\n\n    uint128 public epochTAPValuation; // TAP price for the current epoch\n    uint64 public lastEpochUpdate; // timestamp of the last epoch update\n    uint64 public epoch; // Represents the number of weeks since the start of the contract\n\n    mapping(ERC20 => PaymentTokenOracle) public paymentTokens; // Token address => PaymentTokenOracle\n    address public paymentTokenBeneficiary; // Where to collect the payment tokens\n\n    mapping(uint256 => mapping(uint256 => uint256)) public aoTAPCalls; // oTAPTokenID => epoch => amountExercised\n\n    /// @notice Record of participation in phase 2 airdrop\n    /// Only applicable for phase 2. To get subphases on phase 2 we do userParticipation[_user][20+roles]\n    mapping(address => mapping(uint256 => bool)) public userParticipation; // user address => phase => participated\n\n    /// =====-------======\n    ///      Phase 1\n    /// =====-------======\n\n    /// @notice user address => eligible TAP amount, 0 means no eligibility\n    mapping(address => uint256) public phase1Users;\n    uint256 public constant PHASE_1_DISCOUNT = 500_000; //50 * 1e4; 50%\n\n    /// =====-------======\n    ///      Phase 2\n    /// =====-------======\n\n    // [OG Pearls, Tapiocans, Oysters, Cassava]\n    bytes32[4] public phase2MerkleRoots; // merkle root of phase 2 airdrop\n    uint8[4] public PHASE_2_AMOUNT_PER_USER = [200, 200, 190, 190];\n    uint24[4] public PHASE_2_DISCOUNT_PER_USER = [500_000, 400_000, 330_000, 250_000];\n\n    /// =====-------======\n    ///      Phase 3\n    /// =====-------======\n\n    uint256 public constant PHASE_3_AMOUNT_PER_USER = 714;\n    uint256 public constant PHASE_3_DISCOUNT = 500_000; //50 * 1e4; 50%\n\n    /// =====-------======\n    ///      Phase 4\n    /// =====-------======\n\n    /// @notice user address => eligible TAP amount, 0 means no eligibility\n    mapping(address => uint256) public phase4Users;\n    uint256 public constant PHASE_4_DISCOUNT = 330_000; //33 * 1e4;\n\n    uint256 public EPOCH_DURATION = 2 days; // Becomes 7 days at the start of the phase 4\n    uint256 public constant LAST_EPOCH = 8; // 8 epochs, 41 days long\n\n    /// =====-------======\n\n    error PaymentTokenNotValid();\n    error OptionExpired();\n    error TooHigh();\n    error TooLow();\n    error NotStarted();\n    error Ended();\n    error NotAuthorized();\n    error TooSoon();\n    error Failed();\n    error NotValid();\n    error TokenBeneficiaryNotSet();\n    error NotEligible();\n    error AlreadyParticipated();\n    error PaymentAmountNotValid();\n    error TapAmountNotValid();\n    error PaymentTokenValuationNotValid();\n    error TapNotSet();\n    error TapOracleNotSet();\n\n    constructor(address _aoTAP, address _pcnft, address _paymentTokenBeneficiary, IPearlmit _pearlmit, address _owner)\n        PearlmitHandler(_pearlmit)\n    {\n        paymentTokenBeneficiary = _paymentTokenBeneficiary;\n        aoTAP = AOTAP(_aoTAP);\n        PCNFT = IERC721(_pcnft);\n\n        _transferOwnership(_owner);\n    }\n\n    // ==========\n    //   EVENTS\n    // ==========\n    event Participate(uint256 indexed epoch, uint256 aoTAPTokenID);\n    event ExerciseOption(\n        uint256 indexed epoch, address indexed to, ERC20 indexed paymentToken, uint256 aoTapTokenID, uint256 amount\n    );\n    event NewEpoch(uint256 indexed epoch, uint256 epochTAPValuation);\n    event SetPaymentToken(ERC20 paymentToken, ITapiocaOracle oracle, bytes oracleData);\n    event SetTapOracle(ITapiocaOracle oracle, bytes oracleData);\n    event Phase2MerkleRootsUpdated();\n\n    modifier tapExists() {\n        if (address(tapOracle) == address(0)) revert TapOracleNotSet();\n        if (address(tapToken) == address(0)) revert TapNotSet();\n        _;\n    }\n\n    // ==========\n    //    READ\n    // ==========\n\n    /// @notice Returns the details of an OTC deal for a given oTAP token ID and a payment token.\n    ///         The oracle uses the last peeked value, and not the latest one, so the payment amount may be different.\n    /// @param _aoTAPTokenID The aoTAP token ID\n    /// @param _paymentToken The payment token\n    /// @param _tapAmount The amount of TAP to be exchanged. If 0 it will use the full amount of TAP eligible for the deal\n    /// @return eligibleTapAmount The amount of TAP eligible for the deal\n    /// @return paymentTokenAmount The amount of payment tokens required for the deal\n    /// @return tapAmount The amount of TAP to be exchanged\n\n    function getOTCDealDetails(uint256 _aoTAPTokenID, ERC20 _paymentToken, uint256 _tapAmount)\n        external\n        view\n        tapExists\n        returns (uint256 eligibleTapAmount, uint256 paymentTokenAmount, uint256 tapAmount)\n    {\n        // Load data\n        (, AirdropTapOption memory aoTapOption) = aoTAP.attributes(_aoTAPTokenID);\n        if (aoTapOption.expiry < block.timestamp) revert OptionExpired();\n\n        uint256 cachedEpoch = epoch;\n\n        PaymentTokenOracle memory paymentTokenOracle = paymentTokens[_paymentToken];\n\n        // Check requirements\n        if (paymentTokenOracle.oracle == ITapiocaOracle(address(0))) {\n            revert PaymentTokenNotValid();\n        }\n\n        eligibleTapAmount = aoTapOption.amount;\n        eligibleTapAmount -= aoTAPCalls[_aoTAPTokenID][cachedEpoch]; // Subtract already exercised amount\n        if (eligibleTapAmount < _tapAmount) revert TooHigh();\n\n        tapAmount = _tapAmount == 0 ? eligibleTapAmount : _tapAmount;\n        if (tapAmount < 1e18) revert TooLow();\n        // Get TAP valuation\n        uint256 otcAmountInUSD = tapAmount * epochTAPValuation; // Divided by TAP decimals\n        // Get payment token valuation\n        (, uint256 paymentTokenValuation) = paymentTokenOracle.oracle.peek(paymentTokenOracle.oracleData);\n        // Get payment token amount\n        paymentTokenAmount = _getDiscountedPaymentAmount(\n            otcAmountInUSD, paymentTokenValuation, aoTapOption.discount, _paymentToken.decimals()\n        );\n    }\n\n    // ===========\n    //    WRITE\n    // ===========\n\n    /// @notice Participate in the airdrop\n    /// @param _data The data to be used for the participation, varies by phases\n    function participate(bytes calldata _data) external whenNotPaused tapExists returns (uint256 aoTAPTokenID) {\n        uint256 cachedEpoch = epoch;\n        if (cachedEpoch == 0) revert NotStarted();\n        if (cachedEpoch > LAST_EPOCH) revert Ended();\n\n        // Phase 1\n        if (cachedEpoch == 1) {\n            aoTAPTokenID = _participatePhase1();\n        } else if (cachedEpoch == 2) {\n            aoTAPTokenID = _participatePhase2(_data); // _data = (uint256 role, bytes32[] _merkleProof)\n        } else if (cachedEpoch == 3) {\n            aoTAPTokenID = _participatePhase3(_data); // _data = (uint256[] _tokenID)\n        } else if (cachedEpoch >= 4) {\n            aoTAPTokenID = _participatePhase4();\n        }\n\n        emit Participate(cachedEpoch, aoTAPTokenID);\n    }\n\n    /// @notice Exercise an aoTAP position\n    /// @param _aoTAPTokenID tokenId of the aoTAP position, position must be active\n    /// @param _paymentToken Address of the payment token to use, must be whitelisted\n    /// @param _tapAmount Amount of TAP to exercise. If 0, the full amount is exercised\n    function exerciseOption(uint256 _aoTAPTokenID, ERC20 _paymentToken, uint256 _tapAmount)\n        external\n        whenNotPaused\n        tapExists\n    {\n        // Load data\n        (, AirdropTapOption memory aoTapOption) = aoTAP.attributes(_aoTAPTokenID);\n        if (aoTapOption.expiry < block.timestamp) revert OptionExpired();\n\n        uint256 cachedEpoch = epoch;\n\n        PaymentTokenOracle memory paymentTokenOracle = paymentTokens[_paymentToken];\n\n        // Check requirements\n        if (paymentTokenOracle.oracle == ITapiocaOracle(address(0))) {\n            revert PaymentTokenNotValid();\n        }\n        if (!aoTAP.isApprovedOrOwner(msg.sender, _aoTAPTokenID)) {\n            revert NotAuthorized();\n        }\n\n        // Get eligible OTC amount\n\n        uint256 eligibleTapAmount = aoTapOption.amount;\n        eligibleTapAmount -= aoTAPCalls[_aoTAPTokenID][cachedEpoch]; // Subtract already exercised amount\n        if (eligibleTapAmount < _tapAmount) revert TooHigh();\n\n        uint256 chosenAmount = _tapAmount == 0 ? eligibleTapAmount : _tapAmount;\n        if (chosenAmount < 1e18) revert TooLow();\n        aoTAPCalls[_aoTAPTokenID][cachedEpoch] += chosenAmount; // Adds up exercised amount to current epoch\n\n        // Finalize the deal\n        _processOTCDeal(_paymentToken, paymentTokenOracle, chosenAmount, aoTapOption.discount);\n\n        emit ExerciseOption(cachedEpoch, msg.sender, _paymentToken, _aoTAPTokenID, chosenAmount);\n    }\n\n    /// @notice Start a new epoch, extract TAP from the tapToken contract,\n    function newEpoch() external tapExis"
    }
  ]
}