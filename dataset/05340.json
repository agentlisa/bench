{
  "Title": "[G-13] Refactor functions to combine events to reduce gas cost",
  "Content": "In scenarios where a function emits multiple event but these events are only emitted by that function we can combine these events to a single event in doing this we would save at least 1 `Glog0` `375` gas units\n\n\n### Instances\n1. ### Combine the events in `Depository.changeManagers()` to reduce gas cost\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Depository.sol#L143-#L159\n\nThe `Depository.changeManagers()` function emits two events `TokenomicsUpdated` and `TreasuryUpdated` but these events are only emitted in this function. We can make the `Depository.changeManagers()` function more gas efficient if we combine these `TokenomicsUpdated` and `TreasuryUpdated` events to a single event. The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: tokenomics/contracts/Depository.sol\n\n143:    function changeManagers(address _tokenomics, address _treasury) external {\n144:        // Check for the contract ownership\n145:        if (msg.sender != owner) {\n146:            revert OwnerOnly(msg.sender, owner);\n147:        }\n148:\n149:        // Change Tokenomics contract address\n150:        if (_tokenomics != address(0)) {\n151:            tokenomics = _tokenomics;\n152:            emit TokenomicsUpdated(_tokenomics);\n153:        }\n154:        // Change Treasury contract address\n155:        if (_treasury != address(0)) {\n156:            treasury = _treasury;\n157:            emit TreasuryUpdated(_treasury);\n158:        }\n159:    }\n```\n\n```diff\ndiff --git a/tokenomics/contracts/Depository.sol b/tokenomics/contracts/Depository.sol\nindex f9c7d64..e9ac51c 100644\n--- a/tokenomics/contracts/Depository.sol\n+++ b/tokenomics/contracts/Depository.sol\n@@ -61,8 +61,7 @@ struct Product {\n /// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\n contract Depository is IErrorsTokenomics {\n     event OwnerUpdated(address indexed owner);\n-    event TokenomicsUpdated(address indexed tokenomics);\n-    event TreasuryUpdated(address indexed treasury);\n+    event TokenomicsAndTreasuryUpdated(address indexed tokenomics, address indexed treasury);\n     event BondCalculatorUpdated(address indexed bondCalculator);\n     event CreateBond(address indexed token, uint256 indexed productId, address indexed owner, uint256 bondId,\n         uint256 amountOLAS, uint256 tokenAmount, uint256 maturity);\n@@ -146,16 +145,13 @@ contract Depository is IErrorsTokenomics {\n             revert OwnerOnly(msg.sender, owner);\n         }\n\n-        // Change Tokenomics contract address\n-        if (_tokenomics != address(0)) {\n+        // Change Tokenomics contract address and Treasury contract address\n+        if (_tokenomics != address(0) && _treasury != address(0)) {\n             tokenomics = _tokenomics;\n-            emit TokenomicsUpdated(_tokenomics);\n-        }\n-        // Change Treasury contract address\n-        if (_treasury != address(0)) {\n             treasury = _treasury;\n-            emit TreasuryUpdated(_treasury);\n+            emit TokenomicsAndTreasuryUpdated(_tokenomics, _treasury);\n         }\n```\n```\nEstimated gas saved: 375 gas units\n```\n\n</details>\n\n2. ### Combine the events in `Dispenser.changeManagers()` to reduce gas cost\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Dispenser.sol#L64-#L80\n\nThe `Dispenser.changeManagers()` function emits two events `TokenomicsUpdated` and `TreasuryUpdated` but these events are only emitted in this function. We can make the `Dispenser.changeManagers()` function more gas efficient if we combine these `TokenomicsUpdated` and `TreasuryUpdated` events to a single event. The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: tokenomics/contracts/Dispenser.sol\n\n64:    function changeManagers(address _tokenomics, address _treasury) external {\n65:        // Check for the contract ownership\n66:        if (msg.sender != owner) {\n67:            revert OwnerOnly(msg.sender, owner);\n68:        }\n69:\n70:        // Change Tokenomics contract address\n71:        if (_tokenomics != address(0)) {\n72:            tokenomics = _tokenomics;\n73:            emit TokenomicsUpdated(_tokenomics);\n74:        }\n75:        // Change Treasury contract address\n76:        if (_treasury != address(0)) {\n77:            treasury = _treasury;\n78:            emit TreasuryUpdated(_treasury);\n79:        }\n80:    }\n```\n\n```diff\ndiff --git a/tokenomics/contracts/Dispenser.sol b/tokenomics/contracts/Dispenser.sol             \nindex 9b8f4f5..79e9173 100644                                                                    \n--- a/tokenomics/contracts/Dispenser.sol                                                         \n+++ b/tokenomics/contracts/Dispenser.sol                                                         \n@@ -10,8 +10,7 @@ import \"./interfaces/ITreasury.sol\";                                           \n /// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>                                \n contract Dispenser is IErrorsTokenomics {                                                       \n     event OwnerUpdated(address indexed owner);                                                  \n-    event TokenomicsUpdated(address indexed tokenomics);                                        \n-    event TreasuryUpdated(address indexed treasury);                                            \n+    event TokenomicsAndTreasuryUpdated(address indexed tokenomics, address indexed treasury);   \n     event IncentivesClaimed(address indexed owner, uint256 reward, uint256 topUp);              \n                                                                                                 \n     // Owner address                                                                            \n@@ -67,16 +66,13 @@ contract Dispenser is IErrorsTokenomics {                                    \n             revert OwnerOnly(msg.sender, owner);                                                \n         }                                                                                       \n                                                                                                 \n-        // Change Tokenomics contract address                                                   \n-        if (_tokenomics != address(0)) {                                                        \n+        // Change Tokenomics contract address and Treasury contract address                     \n+        if (_tokenomics != address(0) && _treasury != address(0)) {                             \n             tokenomics = _tokenomics;                                                           \n-            emit TokenomicsUpdated(_tokenomics);                                                \n-        }                                                                                       \n-        // Change Treasury contract address                                                     \n-        if (_treasury != address(0)) {                                                          \n             treasury = _treasury;                                                               \n-            emit TreasuryUpdated(_treasury);                                                    \n+            emit TokenomicsAndTreasuryUpdated(_tokenomics, _treasury);                          \n         }                                                                                       \n+                                                                                                \n```\n```\nEstimated gas saved: 375 gas units\n```\n\n</details>\n\n3. ### Combine the events in `Tokenomics.changeManagers()` to reduce gas cost\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L423-#L444\n\n\nThe `Tokenomics.changeManagers()` function emits three events `DepositoryUpdated`, `DispenserUpdated` and `TreasuryUpdated` but these events are only emitted in this function. We can make the `Tokenomics.changeManagers()` function more gas efficient if we combine these `DepositoryUpdated`, `DispenserUpdated` and `TreasuryUpdated` events to a single event. The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: tokenomics/contracts/Tokenomics.sol\n\n423:    function changeManagers(address _treasury, address _depository, address _dispenser) external {\n424:        // Check for the contract ownership\n425:        if (msg.sender != owner) {\n426:            revert OwnerOnly(msg.sender, owner);\n427:        }\n428:\n429:        // Change Treasury contract address\n430:        if (_treasury != address(0)) {\n431:            treasury = _treasury;\n432:            emit TreasuryUpdated(_treasury);\n433:        }\n434:        // Change Depository contract address\n435:        if (_depository != address(0)) {\n436:            depository = _depository;\n437:            emit DepositoryUpdated(_depository);\n438:        }\n439:        // Change Dispenser contract address\n440:        if (_dispenser != address(0)) {\n441:            dispenser = _dispenser;\n442:            emit DispenserUpdated(_dispenser);\n443:        }\n444:    }\n```\n\n```diff\ndiff --git a/tokenomics/contracts/Tokenomics.sol b/tokenomics/contracts/Tokenomics.sol\nindex 2ef2708..5b30142 100644\n--- a/tokenomics/contracts/Tokenomics.sol\n+++ b/tokenomics/contracts/Tokenomics.sol\n@@ -117,9 +117,7 @@ struct IncentiveBalances {\n /// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\n contract Tokenomics is TokenomicsConstants, IErrorsTokenomics {\n     event OwnerUpdated(address indexed owner);\n-    event TreasuryUpdated(address indexed treasury);\n-    event DepositoryUpdated(address indexed depository);\n-    event DispenserUpdated(address indexed dispenser);\n+    event TreasuryDepositoryAndDispenserUpdated(address indexed treasury, address indexed depository, address indexed dispenser);\n     event EpochLengthUpdated(uint256 epochLen);\n     event EffectiveBondUpdated(uint256 effectiveBond);\n     event IDFUpdated(uint256 idf);\n@@ -426,21 +424,14 @@ contract Tokenomics is TokenomicsConstants, IErrorsTokenomics {\n             revert OwnerOnly(msg.sender, owner);\n         }\n\n-        // Change Treasury contract address\n-        if (_treasury != address(0)) {\n+        // Change Treasury contract address, Depository contract address and Dispenser contract address\n+        if (_treasury != address(0) && _depository != address(0) && _dispenser != address(0)) {\n             treasury = _treasury;\n-            emit TreasuryUpdated(_treasury);\n-        }\n-        // Change Depository contract address\n-        if (_depository != address(0)) {\n             depository = _depository;\n-            emit DepositoryUpdated(_depository);\n-        }\n-        // Change Dispenser contract address\n-        if (_dispenser != address(0)) {\n             dispenser = _dispenser;\n-            emit DispenserUpdated(_dispenser);\n+            emit TreasuryDepositoryAndDispenserUpdated(_treasury, _depository, _dispenser);\n         }\n+\n     }\n```\n```\nEstimated Gas saved: 750 gas units\n```\n\n</details>\n\n4. ### Combine the events in `Tokenomics.changeRegistries()` to reduce gas cost\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L450-#L469\n\nThe `Tokenomics.changeRegistries()` function emits three events `ComponentRegistryUpdated`, `AgentRegistryUpdated` and `ServiceRegistryUpdated` but these events are only emitted in this function. We can make the `Tokenomics.changeManagers()` function more gas efficient if we combine these `ComponentRegistryUpdated`, `AgentRegistryUpdated` and `ServiceRegistryUpdated` events to a single event. The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: tokenomics/contracts/Tokenomics.sol\n\n450:    function changeRegistries(address _componentRegistry, address _agentRegistry, address _serviceRegistry) external {\n451:        // Check for the contract ownership\n452:        if (msg.sender != owner) {\n453:            revert OwnerOnly(msg.sender, owner);\n454:        }\n455:\n456:        // Check for registries addresses\n457:        if (_componentRegistry != address(0)) {\n458:            componentRegistry = _componentRegistry;\n459:            emit ComponentRegistryUpdated(_componentRegistry);\n460:        }\n461:        if (_agentRegistry != address(0)) {\n462:            agentRegistry = _agentRegistry;\n463:            emit AgentRegistryUpdated(_agentRegistry);\n464:        }\n465:        if (_serviceRegistry != address(0)) {\n466:            serviceRegistry = _serviceRegistry;\n467:            emit ServiceRegistryUpdated(_serviceRegistry);\n468:        }\n469:    }\n```\n\n```diff\ndiff --git a/tokenomics/contracts/Tokenomics.sol b/tokenomics/contracts/Tokenomics.sol\nindex 2ef2708..28e3bfb 100644\n--- a/tokenomics/contracts/Tokenomics.sol\n+++ b/tokenomics/contracts/Tokenomics.sol\n@@ -129,9 +129,7 @@ contract Tokenomics is TokenomicsConstants, IErrorsTokenomics {\n     event IncentiveFractionsUpdateRequested(uint256 indexed epochNumber, uint256 rewardComponentFraction,\n         uint256 rewardAgentFraction, uint256 maxBondFraction, uint256 topUpComponentFraction, uint256 topUpAgentFraction);\n     event IncentiveFractionsUpdated(uint256 indexed epochNumber);\n-    event ComponentRegistryUpdated(address indexed componentRegistry);\n-    event AgentRegistryUpdated(address indexed agentRegistry);\n-    event ServiceRegistryUpdated(address indexed serviceRegistry);\n+    event ComponentRegistryAgentRegistryAndServiceRegistryUpdated(address indexed componentRegistry, address indexed agentRegistry, address indexed serviceRegistry);\n     event DonatorBlacklistUpdated(address indexed blacklist);\n     event EpochSettled(uint256 indexed epochCounter, uint256 treasuryRewards, uint256 accountRewards, uint256 accountTopUps);\n     event TokenomicsImplementationUpdated(address indexed implementation);\n@@ -454,17 +452,11 @@ contract Tokenomics is TokenomicsConstants, IErrorsTokenomics {\n         }\n\n         // Check for registries addresses\n-        if (_componentRegistry != address(0)) {\n+        if (_componentRegistry != address(0) && _agentRegistry != address(0) && _serviceRegistry != address(0)) {\n             componentRegistry = _componentRegistry;\n-            emit ComponentRegistryUpdated(_componentRegistry);\n-        }\n-        if (_agentRegistry != address(0)) {\n             agentRegistry = _agentRegistry;\n-            emit AgentRegistryUpdated(_agentRegistry);\n-        }\n-        if (_serviceRegistry != address(0)) {\n             serviceRegistry = _serviceRegistry;\n-            emit ServiceRegistryUpdated(_serviceRegistry);\n+            emit ComponentRegistryAgentRegistryAndServiceRegistryUpdated(_componentRegistry, _agentRegistry, _serviceRegistry)\n         }\n     }\n```\n```\nEstimated gas saved: 750 gas units\n```\n</details>\n\n5. ### Combine the events in `Treasury.changeManagers()` to reduce gas cost\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L156-#L177\n\nThe `Treasury.changeManagers()` function emits three events `TokenomicsUpdated`, `DepositoryUpdated` and `DispenserUpdated` but these events are only emitted in this function. We can make the `Treasury.changeManagers()` function more gas efficient if we combine these `TokenomicsUpdated`, `DepositoryUpdated` and `DispenserUpdated` events to a single event. The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: tokenomics/contracts/Treasury.sol\n\n156:    function changeManagers(address _tokenomics, address _depository, address _dispenser) external {\n157:        // Check for the contract ownership\n158:        if (msg.sender != owner) {\n159:            revert OwnerOnly(msg.sender, owner);\n160:        }\n161:\n162:        // Change Tokenomics contract address\n163:        if (_tokenomics != address(0)) {\n164:            tokenomics = _tokenomics;\n165:            emit TokenomicsUpdated(_tokenomics);\n166:        }\n167:        // Change Depository contract address\n168:        if (_depository != address(0)) {\n169:            depository = _depository;\n170:            emit DepositoryUpdated(_depository);\n171:        }\n172:        // Change Dispenser contract address\n173:        if (_dispenser != address(0)) {\n174:            dispenser = _dispenser;\n175:            emit DispenserUpdated(_dispenser);\n176:        }\n177:    }\n```\n\n```diff\ndiff --git a/tokenomics/contracts/Treasury.sol b/tokenomics/contracts/Treasury.sol\nindex 516c631..cc28ac9 100644\n--- a/tokenomics/contracts/Treasury.sol\n+++ b/tokenomics/contracts/Treasury.sol\n@@ -38,9 +38,7 @@ import \"./interfaces/ITokenomics.sol\";\n /// invariant {:msg \"broken conservation law\"} address(this).balance == ETHFromServices + ETHOwned;\n contract Treasury is IErrorsTokenomics {\n     event OwnerUpdated(address indexed owner);\n-    event TokenomicsUpdated(address indexed tokenomics);\n-    event DepositoryUpdated(address indexed depository);\n-    event DispenserUpdated(address indexed dispenser);\n+    event TokenomicsDepositoryAndDispenserUpdated(address indexed tokenomics, address indexed depository, address indexed dispenser);\n     event DepositTokenFromAccount(address indexed account, address indexed token, uint256 tokenAmount, uint256 olasAmount);\n     event DonateToServicesETH(address indexed sender, uint256[] serviceIds, uint256[] amounts, uint256 donation);\n     event Withdraw(address indexed token, address indexed to, uint256 tokenAmount);\n@@ -159,20 +157,12 @@ contract Treasury is IErrorsTokenomics {\n             revert OwnerOnly(msg.sender, owner);\n         }\n\n-        // Change Tokenomics contract address\n-        if (_tokenomics != address(0)) {\n+        // Change Tokenomics contract address, Depository contract address and Dispenser contract address\n+        if (_tokenomics != address(0) && depository != address(0) && dispenser != address(0)) {\n             tokenomics = _tokenomics;\n-            emit TokenomicsUpdated(_tokenomics);\n-        }\n-        // Change Depository contract address\n-        if (_depository != address(0)) {\n             depository = _depository;\n-            emit DepositoryUpdated(_depository);\n-        }\n-        // Change Dispenser contract address\n-        if (_dispenser != address(0)) {\n             dispenser = _dispenser;\n-            emit DispenserUpdated(_dispenser);\n+            TokenomicsDepositoryAndDispenserUpdated(_tokenomics, _depository,_dispenser);\n         }\n```\n```\nEstimated gas saved: 750 gas units\n```\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "tokenomics/contracts/Depository.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IErrorsTokenomics} from \"./interfaces/IErrorsTokenomics.sol\";\nimport {IGenericBondCalculator} from \"./interfaces/IGenericBondCalculator.sol\";\nimport {IToken} from \"./interfaces/IToken.sol\";\nimport {ITokenomics} from \"./interfaces/ITokenomics.sol\";\nimport {ITreasury} from \"./interfaces/ITreasury.sol\";\n\n/*\n* In this contract we consider OLAS tokens. The initial numbers will be as follows:\n*  - For the first 10 years there will be the cap of 1 billion (1e27) tokens;\n*  - After 10 years, the inflation rate is capped at 2% per year.\n* Starting from a year 11, the maximum number of tokens that can be reached per the year x is 1e27 * (1.02)^x.\n* To make sure that a unit(n) does not overflow the total supply during the year x, we have to check that\n* 2^n - 1 >= 1e27 * (1.02)^x. We limit n by 96, thus it would take 220+ years to reach that total supply.\n*\n* We then limit each time variable to last until the value of 2^32 - 1 in seconds.\n* 2^32 - 1 gives 136+ years counted in seconds starting from the year 1970.\n* Thus, this counter is safe until the year 2106.\n*\n* The number of blocks cannot be practically bigger than the number of seconds, since there is more than one second\n* in a block. Thus, it is safe to assume that uint32 for the number of blocks is also sufficient.\n*\n* In conclusion, this contract is only safe to use until 2106.\n*/\n\n// The size of the struct is 160 + 96 + 32 * 2 = 256 + 64 (2 slots)\nstruct Bond {\n    // Account address\n    address account;\n    // OLAS remaining to be paid out\n    // After 10 years, the OLAS inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1\n    uint96 payout;\n    // Bond maturity time\n    // 2^32 - 1 is enough to count 136 years starting from the year of 1970. This counter is safe until the year of 2106\n    uint32 maturity;\n    // Product Id of a bond\n    // We assume that the number of products will not be bigger than the number of seconds\n    uint32 productId;\n}\n\n// The size of the struct is 160 + 32 + 160 + 96 = 256 + 192 (2 slots)\nstruct Product {\n    // priceLP (reserve0 / totalSupply or reserve1 / totalSupply) with 18 additional decimals\n    // priceLP = 2 * r0/L * 10^18 = 2*r0*10^18/sqrt(r0*r1) ~= 61 + 96 - sqrt(96 * 112) ~= 53 bits (if LP is balanced)\n    // or 2* r0/sqrt(r0) * 10^18 => 87 bits + 60 bits = 147 bits (if LP is unbalanced)\n    uint160 priceLP;\n    // Bond vesting time\n    // 2^32 - 1 is enough to count 136 years starting from the year of 1970. This counter is safe until the year of 2106\n    uint32 vesting;\n    // Token to accept as a payment\n    address token;\n    // Supply of remaining OLAS tokens\n    // After 10 years, the OLAS inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1\n    uint96 supply;\n}\n\n/// @title Bond Depository - Smart contract for OLAS Bond Depository\n/// @author AL\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\ncontract Depository is IErrorsTokenomics {\n    event OwnerUpdated(address indexed owner);\n    event TokenomicsUpdated(address indexed tokenomics);\n    event TreasuryUpdated(address indexed treasury);\n    event BondCalculatorUpdated(address indexed bondCalculator);\n    event CreateBond(address indexed token, uint256 indexed productId, address indexed owner, uint256 bondId,\n        uint256 amountOLAS, uint256 tokenAmount, uint256 maturity);\n    event RedeemBond(uint256 indexed productId, address indexed owner, uint256 bondId);\n    event CreateProduct(address indexed token, uint256 indexed productId, uint256 supply, uint256 priceLP,\n        uint256 vesting);\n    event CloseProduct(address indexed token, uint256 indexed productId, uint256 supply);\n\n    // Minimum bond vesting value\n    uint256 public constant MIN_VESTING = 1 days;\n    // Depository version number\n    string public constant VERSION = \"1.0.1\";\n    \n    // Owner address\n    address public owner;\n    // Individual bond counter\n    // We assume that the number of bonds will not be bigger than the number of seconds\n    uint32 public bondCounter;\n    // Bond product counter\n    // We assume that the number of products will not be bigger than the number of seconds\n    uint32 public productCounter;\n\n    // OLAS token address\n    address public immutable olas;\n    // Tkenomics contract address\n    address public tokenomics;\n    // Treasury contract address\n    address public treasury;\n    // Bond Calculator contract address\n    address public bondCalculator;\n\n    // Mapping of bond Id => account bond instance\n    mapping(uint256 => Bond) public mapUserBonds;\n    // Mapping of product Id => bond product instance\n    mapping(uint256 => Product) public mapBondProducts;\n\n    /// @dev Depository constructor.\n    /// @param _olas OLAS token address.\n    /// @param _treasury Treasury address.\n    /// @param _tokenomics Tokenomics address.\n    constructor(address _olas, address _tokenomics, address _treasury, address _bondCalculator)\n    {\n        owner = msg.sender;\n\n        // Check for at least one zero contract address\n        if (_olas == address(0) || _tokenomics == address(0) || _treasury == address(0) || _bondCalculator == address(0)) {\n            revert ZeroAddress();\n        }\n        olas = _olas;\n        tokenomics = _tokenomics;\n        treasury = _treasury;\n        bondCalculator = _bondCalculator;\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    /// #if_succeeds {:msg \"Changing owner\"} old(owner) == msg.sender ==> owner == newOwner;\n    function changeOwner(address newOwner) external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for the zero address\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Changes various managing contract addresses.\n    /// @param _tokenomics Tokenomics address.\n    /// @param _treasury Treasury address.\n    /// #if_succeeds {:msg \"tokenomics changed\"} _tokenomics != address(0) ==> tokenomics == _tokenomics;\n    /// #if_succeeds {:msg \"treasury changed\"} _treasury != address(0) ==> treasury == _treasury;\n    function changeManagers(address _tokenomics, address _treasury) external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Change Tokenomics contract address\n        if (_tokenomics != address(0)) {\n            tokenomics = _tokenomics;\n            emit TokenomicsUpdated(_tokenomics);\n        }\n        // Change Treasury contract address\n        if (_treasury != address(0)) {\n            treasury = _treasury;\n            emit TreasuryUpdated(_treasury);\n        }\n    }\n\n    /// @dev Changes Bond Calculator contract address\n    /// #if_succeeds {:msg \"bondCalculator changed\"} _bondCalculator != address(0) ==> bondCalculator == _bondCalculator;\n    function changeBondCalculator(address _bondCalculator) external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        if (_bondCalculator != address(0)) {\n            bondCalculator = _bondCalculator;\n            emit BondCalculatorUpdated(_bondCalculator);\n        }\n    }\n\n    /// @dev Creates a new bond product.\n    /// @param token LP token to be deposited for pairs like OLAS-DAI, OLAS-ETH, etc.\n    /// @param priceLP LP token price with 18 additional decimals.\n    /// @param supply Supply in OLAS tokens.\n    /// @param vesting Vesting period (in seconds).\n    /// @return productId New bond product Id.\n    /// #if_succeeds {:msg \"productCounter increases\"} productCounter == old(productCounter) + 1;\n    /// #if_succeeds {:msg \"isActive\"} mapBondProducts[productId].supply > 0 && mapBondProducts[productId].vesting == vesting;\n    function create(address token, uint256 priceLP, uint256 supply, uint256 vesting) external returns (uint256 productId) {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for the pool liquidity as the LP price being greater than zero\n        if (priceLP == 0) {\n            revert ZeroValue();\n        }\n\n        // Check the priceLP limit value\n        if (priceLP > type(uint160).max) {\n            revert Overflow(priceLP, type(uint160).max);\n        }\n\n        // Check that the supply is greater than zero\n        if (supply == 0) {\n            revert ZeroValue();\n        }\n\n        // Check the supply limit value\n        if (supply > type(uint96).max) {\n            revert Overflow(supply, type(uint96).max);\n        }\n\n        // Check the vesting minimum limit value\n        if (vesting < MIN_VESTING) {\n            revert LowerThan(vesting, MIN_VESTING);\n        }\n\n        // Check for the maturity time overflow for the current timestamp\n        uint256 maturity = block.timestamp + vesting;\n        if (maturity > type(uint32).max) {\n            revert Overflow(maturity, type(uint32).max);\n        }\n\n        // Check if the LP token is enabled\n        if (!ITreasury(treasury).isEnabled(token)) {\n            revert UnauthorizedToken(token);\n        }\n\n        // Check if the bond amount is beyond the limits\n        if (!ITokenomics(tokenomics).reserveAmountForBondProgram(supply)) {\n            revert LowerThan(ITokenomics(tokenomics).effectiveBond(), supply);\n        }\n\n        // Push newly created bond product into the list of products\n        productId = productCounter;\n        mapBondProducts[productId] = Product(uint160(priceLP), uint32(vesting), token, uint96(supply));\n        // Even if we create a bond product every second, 2^32 - 1 is enough for the next 136 years\n        productCounter = uint32(productId + 1);\n        emit CreateProduct(token, productId, supply, priceLP, vesting);\n    }\n\n    /// @dev Closes bonding products.\n    /// @notice This will terminate programs regardless of their vesting time.\n    /// @param productIds Set of product Ids.\n    /// @return closedProductIds Set of closed product Ids.\n    /// #if_succeeds {:msg \"productCounter not touched\"} productCounter == old(productCounter);\n    /// #if_succeeds {:msg \"success closed\"} forall (uint k in productIds) mapBondProducts[productIds[k]].vesting == 0 && mapBondProducts[productIds[k]].supply == 0;\n    function close(uint256[] memory productIds) external returns (uint256[] memory closedProductIds) {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Calculate the number of closed products\n        uint256 numProducts = productIds.length;\n        uint256[] memory ids = new uint256[](numProducts);\n        uint256 numClosedProducts;\n        // Traverse to close all possible products\n        for (uint256 i = 0; i < numProducts; ++i) {\n            uint256 productId = productIds[i];\n            // Check if the product is still open by getting its supply amount\n            uint256 supply = mapBondProducts[productId].supply;\n            // The supply is greater than zero only if the product is active, otherwise it is already closed\n            if (supply > 0) {\n                // Refund unused OLAS supply from the product if it was not used by the product completely\n                ITokenomics(tokenomics).refundFromBondProgram(supply);\n                address token = mapBondProducts[productId].token;\n                delete mapBondProducts[productId];\n\n                ids[numClosedProducts] = productIds[i];\n                ++numClosedProducts;\n                emit CloseProduct(token, productId, supply);\n            }\n        }\n\n        // Get the correct array size of closed product Ids\n        closedProductIds = new uint256[](numClosedProducts);\n        for (uint256 i = 0; i < numClosedProducts; ++i) {\n            closedProductIds[i] = ids[i];\n        }\n    }\n\n    /// @dev Deposits tokens in exchange for a bond from a specified product.\n    /// @param productId Product Id.\n    /// @param tokenAmount Token amount to deposit for the bond.\n    /// @return payout The amount of OLAS tokens due.\n    /// @return maturity Timestamp for payout redemption.\n    /// @return bondId Id of a newly created bond.\n    /// #if_succeeds {:msg \"token is valid\"} mapBondProducts[productId].token != address(0);\n    /// #if_succeeds {:msg \"input supply is non-zero\"} old(mapBondProducts[productId].supply) > 0 && mapBondProducts[productId].supply <= type(uint96).max;\n    /// #if_succeeds {:msg \"vesting is non-zero\"} mapBondProducts[productId].vesting > 0 && mapBondProducts[productId].vesting + block.timestamp <= type(uint32).max;\n    /// #if_succeeds {:msg \"bond Id\"} bondCounter == old(bondCounter) + 1 && bondCounter <= type(uint32).max;\n    /// #if_succeeds {:msg \"payout\"} old(mapBondProducts[productId].supply) == mapBondProducts[productId].supply + payout;\n    /// #if_succeeds {:msg \"OLAS balances\"} IToken(mapBondProducts[productId].token).balanceOf(treasury) == old(IToken(mapBondProducts[productId].token).balanceOf(treasury)) + tokenAmount;\n    function deposit(uint256 productId, uint256 tokenAmount) external\n        returns (uint256 payout, uint256 maturity, uint256 bondId)\n    {\n        // Check the token amount\n        if (tokenAmount == 0) {\n            revert ZeroValue();\n        }\n\n        // Get the bonding product\n        Product storage product = mapBondProducts[productId];\n\n        // Check for the product supply, which is zero if the product was closed or never existed\n        uint256 supply = product.supply;\n        if (supply == 0) {\n            revert ProductClosed(productId);\n        }\n\n        // Calculate the bond maturity based on its vesting time\n        maturity = block.timestamp + product.vesting;\n        // Check for the time limits\n        if (maturity > type(uint32).max) {\n            revert Overflow(maturity, type(uint32).max);\n        }\n\n        // Get the LP token address\n        address token = product.token;\n\n        // Calculate the payout in OLAS tokens based on the LP pair with the discount factor (DF) calculation\n        // Note that payout cannot be zero since the price LP is non-zero, otherwise the product would not be created\n        payout = IGenericBondCalculator(bondCalculator).calculatePayoutOLAS(tokenAmount, product.priceLP);\n\n        // Check for the sufficient supply\n        if (payout > supply) {\n            revert ProductSupplyLow(token, productId, payout, supply);\n        }\n\n        // Decrease the supply for the amount of payout\n        supply -= payout;\n        product.supply = uint96(supply);\n\n        // Create and add a new bond, update the bond counter\n        bondId = bondCounter;\n        mapUserBonds[bondId] = Bond(msg.sender, uint96(payout), uint32(maturity), uint32(productId));\n        bondCounter = uint32(bondId + 1);\n\n        // Deposit that token amount to mint OLAS tokens in exchange\n        ITreasury(treasury).depositTokenForOLAS(msg.sender, tokenAmount, token, payout);\n\n        // Close the product if the supply becomes zero\n        if (supply == 0) {\n            delete mapBondProducts[productId];\n            emit CloseProduct(token, productId, supply);\n        }\n\n        emit CreateBond(token, productId, msg.sender, bondId, payout, tokenAmount, maturity);\n    }\n\n    /// @dev Redeems account bonds.\n    /// @param bondIds Bond Ids to redeem.\n    /// @return payout Total payout sent in OLAS tokens.\n    /// #if_succeeds {:msg \"payout > 0\"} payout > 0;\n    /// #if_succeeds {:msg \"msg.sender is the only owner\"} old(forall (uint k in bondIds) mapUserBonds[bondIds[k]].account == msg.sender);\n    /// #if_succeeds {:msg \"accounts deleted\"} forall (uint k in bondIds) mapUserBonds[bondIds[k]].account == address(0);\n    /// #if_succeeds {:msg \"payouts are zeroed\"} forall (uint k in bondIds) mapUserBonds[bondIds[k]].payout == 0;\n    /// #if_succeeds {:msg \"maturities are zeroed\"} forall (uint k in bondIds) mapUserBonds[bondIds[k]].maturity == 0;\n    function redeem(uint256[] memory bondIds) external returns (uint256 payout) {\n        for (uint256 i = 0; i < bondIds.length; ++i) {\n            // Get the amount to pay and the maturity status\n            uint256 pay = mapUserBonds[bondIds[i]].payout;\n            bool matured = block.timestamp >= mapUserBonds[bondIds[i]].maturity;\n\n            // Revert if the bond does not exist or is not matured yet\n            if (pay == 0 || !matured) {\n                revert BondNotRedeemable(bondIds[i]);\n            }\n\n            // Check that the msg.sender is the owner of the bond\n            if (mapUserBonds[bondIds[i]].account != msg.sender) {\n                revert OwnerOnly(msg.sender, mapUserBonds[bondIds[i]].account);\n            }\n\n            // Increase the payout\n            payout += pay;\n\n            // Get the productId\n            uint256 productId = mapUserBonds[bondIds[i]].productId;\n\n            // Delete the Bond struct and release the gas\n            delete mapUserBonds[bondIds[i]];\n            emit RedeemBond(productId, msg.sender, bondIds[i]);\n        }\n\n        // Check for the non-zero payout\n        if (payout == 0) {\n            revert ZeroValue();\n        }\n\n        // No reentrancy risk here since it's the last operation, and originated from the OLAS token\n        // No need to check for the return value, since it either reverts or returns true, see the ERC20 implementation\n        IToken(olas).transfer(msg.sender, payout);\n    }\n\n    /// @dev Gets an array of active or inactive product Ids.\n    /// @param active Flag to select active or inactive products.\n    /// @return productIds Product Ids.\n    function getProducts(bool active) external view returns (uint256[] memory productIds) {\n        // Calculate the number of existing products\n        uint256 numProducts = productCounter;\n        bool[] memory positions = new bool[](numProducts);\n        uint256 numSelectedProducts;\n        // Traverse to find requested products\n        for (uint256 i = 0; i < numProducts; ++i) {\n            // Product is always active if its supply is not zero, and inactive otherwise\n            if ((active && mapBondProducts[i].supply > 0) || (!active && mapBondProducts[i].supply == 0)) {\n                positions[i] = true;\n                ++numSelectedProducts;\n            }\n        }\n\n        // Form active or inactive products index array\n        productIds = new uint256[](numSelectedProducts);\n        uint256 numPos;\n        for (uint256 i = 0; i < numProducts; ++i) {\n            if (positions[i]) {\n                productIds[numPos] = i;\n                ++numPos;\n            }\n        }\n    }\n\n    /// @dev Gets activity information about a given product.\n    /// @param productId Product Id.\n    /// @return status True if the product is active.\n    function isActiveProduct(uint256 productId) external view returns (bool status) {\n        status = (mapBondProducts[productId].supply > 0);\n    }\n\n    /// @dev Gets bond Ids for the account address.\n    /// @param account Account address to query bonds for.\n    /// @param matured Flag to get matured bonds only or all of them.\n    /// @return bondIds Bond Ids.\n    /// @return payout Cumulative expected OLAS payout.\n    /// #if_succeeds {:msg \"matured bonds\"} matured == true ==> forall (uint k in bondIds)\n    /// mapUserBonds[bondIds[k]].account == account && block.timestamp >= mapUserBonds[bondIds[k]].maturity;\n    function getBonds(address account, bool matured) external view\n        returns (uint256[] memory bondIds, uint256 payout)\n    {\n        // Check the address\n        if (account == address(0)) {\n            revert ZeroAddress();\n        }\n\n        uint256 numAccountBonds;\n        // Calculate the number of pending bonds\n        uint256 numBonds = bondCounter;\n        bool[] memory positions = new bool[](numBonds);\n        // Record the bond number if it belongs to the account address and was not yet redeemed\n        for (uint256 i = 0; i < numBonds; ++i) {\n            // Check if the bond belongs to the account\n            // If not and the address is zero, the bond was redeemed or never existed\n            if (mapUserBonds[i].account == account) {\n                // Check if requested bond is not matured but owned by the account address\n                if (!matured ||\n                    // Or if the requested bond is matured, i.e., the bond maturity timestamp passed\n                    block.timestamp >= mapUserBonds[i].maturity)\n                {\n                    positions[i] = true;\n                    ++numAccountBonds;\n                    // The payout is always bigger than zero if the bond exists\n                    payout += mapUserBonds[i].payout;\n                }\n            }\n        }\n\n        // Form pending bonds index array\n        bondIds = new uint256[](numAccountBonds);\n        uint256 numPos;\n        for (uint256 i = 0; i < numBonds; ++i) {\n            if (positions[i]) {\n                bondIds[numPos] = i;\n                ++numPos;\n            }\n        }\n    }\n\n    /// @dev Calculates the maturity and payout to claim for a single bond.\n    /// @param bondId The account bond Id.\n    /// @return payout The payout amount in OLAS.\n    /// @return matured True if the payout can be redeemed.\n    function getBondStatus(uint256 bondId) external view returns (uint256 payout, bool matured) {\n        payout = mapUserBonds[bondId].payout;\n        // If payout is zero, the bond has been redeemed or never existed\n        if (payout > 0) {\n            matured = block.timestamp >= mapUserBonds[bondId].maturity;\n        }\n    }\n\n    /// @dev Gets current reserves of OLAS / totalSupply of LP tokens.\n    /// @param token Token address.\n    /// @return priceLP Resulting reserveX / totalSupply ratio with 18 decimals.\n    function getCurrentPriceLP(address token) external view returns (uint256 priceLP) {\n        return IGenericBondCalculator(bondCalculator).getCurrentPriceLP(token);\n    }\n}"
    },
    {
      "filename": "tokenomics/contracts/Dispenser.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./interfaces/IErrorsTokenomics.sol\";\nimport \"./interfaces/ITokenomics.sol\";\nimport \"./interfaces/ITreasury.sol\";\n\n/// @title Dispenser - Smart contract for distributing incentives\n/// @author AL\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\ncontract Dispenser is IErrorsTokenomics {\n    event OwnerUpdated(address indexed owner);\n    event TokenomicsUpdated(address indexed tokenomics);\n    event TreasuryUpdated(address indexed treasury);\n    event IncentivesClaimed(address indexed owner, uint256 reward, uint256 topUp);\n\n    // Owner address\n    address public owner;\n    // Reentrancy lock\n    uint8 internal _locked;\n\n    // Tokenomics contract address\n    address public tokenomics;\n    // Treasury contract address\n    address public treasury;\n\n    /// @dev Dispenser constructor.\n    /// @param _tokenomics Tokenomics address.\n    /// @param _treasury Treasury address.\n    constructor(address _tokenomics, address _treasury)\n    {\n        owner = msg.sender;\n        _locked = 1;\n\n        // Check for at least one zero contract address\n        if (_tokenomics == address(0) || _treasury == address(0)) {\n            revert ZeroAddress();\n        }\n\n        tokenomics = _tokenomics;\n        treasury = _treasury;\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for the zero address\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Changes various managing contract addresses.\n    /// @param _tokenomics Tokenomics address.\n    /// @param _treasury Treasury address.\n    function changeManagers(address _tokenomics, address _treasury) external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Change Tokenomics contract address\n        if (_tokenomics != address(0)) {\n            tokenomics = _tokenomics;\n            emit TokenomicsUpdated(_tokenomics);\n        }\n        // Change Treasury contract address\n        if (_treasury != address(0)) {\n            treasury = _treasury;\n            emit TreasuryUpdated(_treasury);\n        }\n    }\n\n    /// @dev Claims incentives for the owner of components / agents.\n    /// @notice `msg.sender` must be the owner of components / agents they are passing, otherwise the function will revert.\n    /// @notice If not all `unitIds` belonging to `msg.sender` were provided, they will be untouched and keep accumulating.\n    /// @param unitTypes Set of unit types (component / agent).\n    /// @param unitIds Set of corresponding unit Ids where account is the owner.\n    /// @return reward Reward amount in ETH.\n    /// @return topUp Top-up amount in OLAS.\n    function claimOwnerIncentives(uint256[] memory unitTypes, uint256[] memory unitIds) external\n        returns (uint256 reward, uint256 topUp)\n    {\n        // Reentrancy guard\n        if (_locked > 1) {\n            revert ReentrancyGuard();\n        }\n        _locked = 2;\n\n        // Calculate incentives\n        (reward, topUp) = ITokenomics(tokenomics).accountOwnerIncentives(msg.sender, unitTypes, unitIds);\n\n        bool success;\n        // Request treasury to transfer funds to msg.sender if reward > 0 or topUp > 0\n        if ((reward + topUp) > 0) {\n            success = ITreasury(treasury).withdrawToAccount(msg.sender, reward, topUp);\n        }\n\n        // Check if the claim is successful and has at least one non-zero incentive.\n        if (!success) {\n            revert ClaimIncentivesFailed(msg.sender, reward, topUp);\n        }\n\n        emit IncentivesClaimed(msg.sender, reward, topUp);\n\n        _locked = 1;\n    }\n}"
    },
    {
      "filename": "tokenomics/contracts/Tokenomics.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./TokenomicsConstants.sol\";\nimport \"./interfaces/IDonatorBlacklist.sol\";\nimport \"./interfaces/IErrorsTokenomics.sol\";\nimport \"./interfaces/IOLAS.sol\";\nimport \"./interfaces/IServiceRegistry.sol\";\nimport \"./interfaces/IToken.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\n\n/*\n* In this contract we consider both ETH and OLAS tokens.\n* For ETH tokens, there are currently about 121 million tokens.\n* Even if the ETH inflation rate is 5% per year, it would take 130+ years to reach 2^96 - 1 of ETH total supply.\n* Lately the inflation rate was lower and could actually be deflationary.\n*\n* For OLAS tokens, the initial numbers will be as follows:\n*  - For the first 10 years there will be the cap of 1 billion (1e27) tokens;\n*  - After 10 years, the inflation rate is capped at 2% per year.\n* Starting from a year 11, the maximum number of tokens that can be reached per the year x is 1e27 * (1.02)^x.\n* To make sure that a unit(n) does not overflow the total supply during the year x, we have to check that\n* 2^n - 1 >= 1e27 * (1.02)^x. We limit n by 96, thus it would take 220+ years to reach that total supply.\n*\n* We then limit each time variable to last until the value of 2^32 - 1 in seconds.\n* 2^32 - 1 gives 136+ years counted in seconds starting from the year 1970.\n* Thus, this counter is safe until the year 2106.\n*\n* The number of blocks cannot be practically bigger than the number of seconds, since there is more than one second\n* in a block. Thus, it is safe to assume that uint32 for the number of blocks is also sufficient.\n*\n* We also limit the number of registry units by the value of 2^32 - 1.\n* We assume that the system is expected to support no more than 2^32-1 units.\n*\n* Lastly, we assume that the coefficients from tokenomics factors calculation are bound by 2^16 - 1.\n*\n* In conclusion, this contract is only safe to use until 2106.\n*/\n\n// Structure for component / agent point with tokenomics-related statistics\n// The size of the struct is 96 + 32 + 8 * 2 = 144 (1 slot)\nstruct UnitPoint {\n    // Summation of all the relative OLAS top-ups accumulated by each component / agent in a service\n    // After 10 years, the OLAS inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1\n    uint96 sumUnitTopUpsOLAS;\n    // Number of new units\n    // This number cannot be practically bigger than the total number of supported units\n    uint32 numNewUnits;\n    // Reward component / agent fraction\n    // This number cannot be practically bigger than 100 as the summation with other fractions gives at most 100 (%)\n    uint8 rewardUnitFraction;\n    // Top-up component / agent fraction\n    // This number cannot be practically bigger than 100 as the summation with other fractions gives at most 100 (%)\n    uint8 topUpUnitFraction;\n}\n\n// Structure for epoch point with tokenomics-related statistics during each epoch\n// The size of the struct is 96 * 2 + 64 + 32 * 2 + 8 * 2 = 256 + 80 (2 slots)\nstruct EpochPoint {\n    // Total amount of ETH donations accrued by the protocol during one epoch\n    // Even if the ETH inflation rate is 5% per year, it would take 130+ years to reach 2^96 - 1 of ETH total supply\n    uint96 totalDonationsETH;\n    // Amount of OLAS intended to fund top-ups for the epoch based on the inflation schedule\n    // After 10 years, the OLAS inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1\n    uint96 totalTopUpsOLAS;\n    // Inverse of the discount factor\n    // IDF is bound by a factor of 18, since (2^64 - 1) / 10^18 > 18\n    // IDF uses a multiplier of 10^18 by default, since it is a rational number and must be accounted for divisions\n    // The IDF depends on the epsilonRate value, idf = 1 + epsilonRate, and epsilonRate is bound by 17 with 18 decimals\n    uint64 idf;\n    // Number of new owners\n    // Each unit has at most one owner, so this number cannot be practically bigger than numNewUnits\n    uint32 numNewOwners;\n    // Epoch end timestamp\n    // 2^32 - 1 gives 136+ years counted in seconds starting from the year 1970, which is safe until the year of 2106\n    uint32 endTime;\n    // Parameters for rewards and top-ups (in percentage)\n    // Each of these numbers cannot be practically bigger than 100 as they sum up to 100%\n    // treasuryFraction + rewardComponentFraction + rewardAgentFraction = 100%\n    // Treasury fraction\n    uint8 rewardTreasuryFraction;\n    // maxBondFraction + topUpComponentFraction + topUpAgentFraction <= 100%\n    // Amount of OLAS (in percentage of inflation) intended to fund bonding incentives during the epoch\n    uint8 maxBondFraction;\n}\n\n// Structure for tokenomics point\n// The size of the struct is 256 * 2 + 256 * 2 = 256 * 4 (4 slots)\nstruct TokenomicsPoint {\n    // Two unit points in a representation of mapping and not on array to save on gas\n    // One unit point is for component (key = 0) and one is for agent (key = 1)\n    mapping(uint256 => UnitPoint) unitPoints;\n    // Epoch point\n    EpochPoint epochPoint;\n}\n\n// Struct for component / agent incentive balances\nstruct IncentiveBalances {\n    // Reward in ETH\n    // Even if the ETH inflation rate is 5% per year, it would take 130+ years to reach 2^96 - 1 of ETH total supply\n    uint96 reward;\n    // Pending relative reward in ETH\n    uint96 pendingRelativeReward;\n    // Top-up in OLAS\n    // After 10 years, the OLAS inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1\n    uint96 topUp;\n    // Pending relative top-up\n    uint96 pendingRelativeTopUp;\n    // Last epoch number the information was updated\n    // This number cannot be practically bigger than the number of blocks\n    uint32 lastEpoch;\n}\n\n/// @title Tokenomics - Smart contract for tokenomics logic with incentives for unit owners and discount factor regulations for bonds.\n/// @author AL\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\ncontract Tokenomics is TokenomicsConstants, IErrorsTokenomics {\n    event OwnerUpdated(address indexed owner);\n    event TreasuryUpdated(address indexed treasury);\n    event DepositoryUpdated(address indexed depository);\n    event DispenserUpdated(address indexed dispenser);\n    event EpochLengthUpdated(uint256 epochLen);\n    event EffectiveBondUpdated(uint256 effectiveBond);\n    event IDFUpdated(uint256 idf);\n    event TokenomicsParametersUpdateRequested(uint256 indexed epochNumber, uint256 devsPerCapital, uint256 codePerDev,"
    }
  ]
}