{
  "Title": "H-3: Incorrect handling of PnL during liquidation",
  "Content": "# Issue H-3: Incorrect handling of PnL during liquidation \n\nSource: https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/180 \n\n## Found by \nsantipu\\_, xiaoming90\n## Summary\n\nThe incorrect handling of PnL during liquidation led to an error in the protocol's accounting mechanism, which might result in various issues, such as the loss of assets and the stable collateral total being inflated.\n\n## Vulnerability Detail\n\n#### First Example\n\nAssume a long position with the following state:\n\n- Margin Deposited = +20\n- Accrued Funding = -100\n- Profit & Loss (PnL) = +100\n- Liquidation Margin = 30\n- Liquidation Fee = 25\n- Settled Margin = Margin Deposited + Accrued Funding + PnL = 20\n\nLet the current `StableCollateralTotal` be $x$ and `marginDepositedTotal` be $y$ at the start of the liquidation.\n\nFirstly, the `settleFundingFees()` function will be executed at the start of the liquidation process. The effect of the `settleFundingFees()` function is shown below. The long trader's `marginDepositedTotal` will be reduced by 100, while the LP's `stableCollateralTotal` will increase by 100.\n\n```solidity\nsettleFundingFees() = Short/LP need to pay Long 100\n\nmarginDepositedTotal = marginDepositedTotal + funding fee\nmarginDepositedTotal = y + (-100) = (y - 100)\n\nstableCollateralTotal = x + (-(-100)) = (x + 100)\n```\n\nSince the position's settle margin is below the liquidation margin, the position will be liquidated.\n\nAt Line 109, the condition `(settledMargin > 0)` will be evaluated as `True`. At Line 123:\n\n```solidity\nif (uint256(settledMargin) > expectedLiquidationFee)\nif (+20 > +25) => False\nliquidatorFee = settledMargin\nliquidatorFee = +20\n```\n\nThe `liquidationFee` will be to +20 at Line 127 below. This basically means that all the remaining margin of 20 will be given to the liquidator, and there should be no remaining margin for the LPs.\n\nAt Line 133 below, the `vault.updateStableCollateralTotal` function will be executed:\n\n```solidity\nvault.updateStableCollateralTotal(remainingMargin - positionSummary.profitLoss);\nvault.updateStableCollateralTotal(0 - (+100));\nvault.updateStableCollateralTotal(-100);\n\nstableCollateralTotal = (x + 100) - 100 = x\n```\n\nWhen `vault.updateStableCollateralTotal` is set to `-100`, `stableCollateralTotal` is equal to $x$.\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LiquidationModule.sol#L85\n\n```solidity\nFile: LiquidationModule.sol\n085:     function liquidate(uint256 tokenId) public nonReentrant whenNotPaused liquidationInvariantChecks(vault, tokenId) {\n..SNIP..\n102:         // Check that the total margin deposited by the long traders is not -ve.\n103:         // To get this amount, we will have to account for the PnL and funding fees accrued.\n104:         int256 settledMargin = positionSummary.marginAfterSettlement;\n105: \n106:         uint256 liquidatorFee;\n107: \n108:         // If the settled margin is greater than 0, send a portion (or all) of the margin to the liquidator and LPs.\n109:         if (settledMargin > 0) {\n110:             // Calculate the liquidation fees to be sent to the caller.\n111:             uint256 expectedLiquidationFee = PerpMath._liquidationFee(\n112:                 position.additionalSize,\n113:                 liquidationFeeRatio,\n114:                 liquidationFeeLowerBound,\n115:                 liquidationFeeUpperBound,\n116:                 currentPrice\n117:             );\n118: \n119:             uint256 remainingMargin;\n120: \n121:             // Calculate the remaining margin after accounting for liquidation fees.\n122:             // If the settled margin is less than the liquidation fee, then the liquidator fee is the settled margin.\n123:             if (uint256(settledMargin) > expectedLiquidationFee) {\n124:                 liquidatorFee = expectedLiquidationFee;\n125:                 remainingMargin = uint256(settledMargin) - expectedLiquidationFee;\n126:             } else {\n127:                 liquidatorFee = uint256(settledMargin);\n128:             }\n129: \n130:             // Adjust the stable collateral total to account for user's remaining margin.\n131:             // If the remaining margin is greater than 0, this goes to the LPs.\n132:             // Note that {`remainingMargin` - `profitLoss`} is the same as {`marginDeposited` + `accruedFunding`}.\n133:             vault.updateStableCollateralTotal(int256(remainingMargin) - positionSummary.profitLoss);\n134: \n135:             // Send the liquidator fee to the caller of the function.\n136:             // If the liquidation fee is greater than the remaining margin, then send the remaining margin.\n137:             vault.sendCollateral(msg.sender, liquidatorFee);\n138:         } else {\n139:             // If the settled margin is -ve then the LPs have to bear the cost.\n140:             // Adjust the stable collateral total to account for user's profit/loss and the negative margin.\n141:             // Note: We are adding `settledMargin` and `profitLoss` instead of subtracting because of their sign (which will be -ve).\n142:             vault.updateStableCollateralTotal(settledMargin - positionSummary.profitLoss);\n143:         }\n```\n\nNext, the `vault.updateGlobalPositionData` function [here](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LiquidationModule.sol#L159) will be executed.\n\n```solidity\nvault.updateGlobalPositionData({marginDelta: -(position.marginDeposited + positionSummary.accruedFunding)})\nvault.updateGlobalPositionData({marginDelta: -(20 + (-100))})\nvault.updateGlobalPositionData({marginDelta: 80})\n\nprofitLossTotal = 100\nnewMarginDepositedTotal = globalPositions.marginDepositedTotal + marginDelta + profitLossTotal\nnewMarginDepositedTotal = (y - 100) + 80 + 100 = (y + 80)\n\nstableCollateralTotal = stableCollateralTotal + -PnL\nstableCollateralTotal = x + (-100) = (x - 100)\n```\n\nThe final `newMarginDepositedTotal` is $y + 80$ and `stableCollateralTotal` is $x -100$, which is incorrect. In this scenario\n\n- There is no remaining margin for the LPs, as all the remaining margin has been sent to the liquidator as a fee. The remaining margin (settled margin) is also not negative. Thus, there should not be any loss on the `stableCollateralTotal`. The correct final `stableCollateralTotal` should be $x$.\n- The final `newMarginDepositedTotal` is $y + 80$, which is incorrect as this indicates that the long trader's pool has gained 80 ETH, which should not be the case when a long position is being liquidated.\n\n#### Second Example\n\nThe current price of rETH is \\$1000.\n\nLet's say there is a user A (Alice) who makes a deposit of 5 rETH as collateral for LP.\n\nLet's say another user, Bob (B), comes up, deposits 2 rETH as a margin, and creates a position with a size of 5 rETH, basically creating a perfectly hedged market. Since this is a perfectly hedged market, the accrued funding fee will be zero for the context of this example.\n\nTotal collateral in the system = 5 rETH + 2 rETH = 7 rETH\n\nAfter some time, the price of rETH drop to \\$500. As a result, Bob's position is liquidated as its settled margin is less than zero.\n\n$$\nsettleMargin = 2\\  rETH + \\frac{5 \\times (500 - 1000)}{500}\n= 2\\ rETH - 5\\ rETH = -3\\ rETH\n$$\n\nDuring the liquidation, the following code is executed to update the LP's stable collateral total:\n\n```solidity\nvault.updateStableCollateralTotal(settledMargin - positionSummary.profitLoss);\nvault.updateStableCollateralTotal(-3 rETH - (-5 rETH));\nvault.updateStableCollateralTotal(+2);\n```\n\nLP's stable collateral total increased by 2 rETH.\n\nSubsequently, the `updateGlobalPositionData` function will be executed.\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LiquidationModule.sol#L159\n\n```solidity\nFile: LiquidationModule.sol\n85:     function liquidate(uint256 tokenId) public nonReentrant whenNotPaused liquidationInvariantChecks(vault, tokenId) {\n..SNIP..\n159:         vault.updateGlobalPositionData({\n160:             price: position.lastPrice,\n161:             marginDelta: -(int256(position.marginDeposited) + positionSummary.accruedFunding),\n162:             additionalSizeDelta: -int256(position.additionalSize) // Since position is being closed, additionalSizeDelta should be negative.\n163:         });\n```\n\nWithin the `updateGlobalPositionData` function, the `profitLossTotal` at Line 179 will be -5 rETH. This means that the long trader (Bob) has lost 5 rETH.\n\nAt Line 205 below, the PnL of the long traders (-5 rETH) will be transferred to the LP's stable collateral total. In this case, the LPs gain 5 rETH.\n\nNote that the LP's stable collateral total has been increased by 2 rETH earlier and now we are increasing it by 5 rETH again. Thus, the total gain by LPs is 7 rETH. If we add 7 rETH to the original stable collateral total, it will be 7 rETH + 5 rETH = 12 rETH. However, this is incorrect because we only have 7 rETH collateral within the system, as shown at the start.\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/FlatcoinVault.sol#L173\n\n```solidity\nFile: FlatcoinVault.sol\n173:     function updateGlobalPositionData(\n174:         uint256 _price,\n175:         int256 _marginDelta,\n176:         int256 _additionalSizeDelta\n177:     ) external onlyAuthorizedModule {\n178:         // Get the total profit loss and update the margin deposited total.\n179:         int256 profitLossTotal = PerpMath._profitLossTotal({globalPosition: _globalPositions, price: _price});\n180: \n181:         // Note that technically, even the funding fees should be accounted for when computing the margin deposited total.\n182:         // However, since the funding fees are settled at the same time as the global position data is updated,\n183:         // we can ignore the funding fees here.\n184:         int256 newMarginDepositedTotal = int256(_globalPositions.marginDepositedTotal) + _marginDelta + profitLossTotal;\n185: \n186:         // Check that the sum of margin of all the leverage traders is not negative.\n187:         // Rounding errors shouldn't result in a negative margin deposited total given that\n188:         // we are rounding down the profit loss of the position.\n189:         // If anything, after closing the last position in the system, the `marginDepositedTotal` should can be positive.\n190:         // The margin may be negative if liquidations are not happening in a timely manner.\n191:         if (newMarginDepositedTotal < 0) {\n192:             revert FlatcoinErrors.InsufficientGlobalMargin();\n193:         }\n194: \n195:         _globalPositions = FlatcoinStructs.GlobalPositions({\n196:             marginDepositedTotal: uint256(newMarginDepositedTotal),\n197:             sizeOpenedTotal: (int256(_globalPositions.sizeOpenedTotal) + _additionalSizeDelta).toUint256(),\n198:             lastPrice: _price\n199:         });\n200: \n201:         // Profit loss of leverage traders has to be accounted for by adjusting the stable collateral total.\n202:         // Note that technically, even the funding fees should be accounted for when computing the stable collateral total.\n203:         // However, since the funding fees are settled at the same time as the global position data is updated,\n204:         // we can ignore the funding fees here\n205:         _updateStableCollateralTotal(-profitLossTotal);\n206:     }\n```\n\n#### Third Example\n\nAt $T0$, the marginDepositedTotal = 70 ETH, stableCollateralTotal = 100 ETH, vault's balance = 170 ETH\n\n| Bob's Long Position                                          | Alice (LP)          |\n| ------------------------------------------------------------ | ------------------- |\n| Margin = 70 ETH<br />Position Size = 500 ETH<br />Leverage = (500 + 20) / 20 = 26x<br />Liquidation Fee = 50 ETH<br />Liquidation Margin = 60 ETH<br />Entry Price = \\$1000 per ETH | Deposited = 100 ETH |\n\nAt $T1$​, the position's settled margin falls to 60 ETH (margin = +70, accrued fee = -5, PnL = -5) and is subjected to liquidation.\n\nFirstly, the `settleFundingFees()` function will be executed at the start of the liquidation process. The effect of the `settleFundingFees()` function is shown below. The long trader's `marginDepositedTotal` will be reduced by 5, while the LP's `stableCollateralTotal` will increase by 5.\n\n```solidity\nsettleFundingFees() = Long need to pay short 5\n\nmarginDepositedTotal = marginDepositedTotal + funding fee\nmarginDepositedTotal = 70 + (-5) = 65\n\nstableCollateralTotal = 100 + (-(-5)) = 105\n```\n\nNext, [this part](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LiquidationModule.sol#L109) of the code will be executed to send a portion of the liquidated position's margin to the liquidator and LPs.\n\n```solidity\nsettledMargin > 0 => True\n(settledMargin > expectedLiquidationFee) => (+60 > +50) => True\nremainingMargin = uint256(settledMargin) - expectedLiquidationFee = 60 - 50 = 10\n```\n\n50 ETH will be sent to the liquidator and the remaining 10 ETH should goes to the LPs.\n\n```solidity\nvault.updateStableCollateralTotal(remainingMargin - positionSummary.profitLoss) =>\nstableCollateralTotal = 105 ETH + (remaining margin - PnL)\nstableCollateralTotal = 105 ETH + (10 ETH - (-5 ETH))\nstableCollateralTotal = 105 ETH + (15 ETH) = 120 ETH\n```\n\nNext, the `vault.updateGlobalPositionData` function [here](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LiquidationModule.sol#L159) will be executed.\n\n```solidity\nvault.updateGlobalPositionData({marginDelta: -(position.marginDeposited + positionSummary.accruedFunding)})\nvault.updateGlobalPositionData({marginDelta: -(70 + (-5))})\nvault.updateGlobalPositionData({marginDelta: -65})\n\nprofitLossTotal = -5\nnewMarginDepositedTotal = globalPositions.marginDepositedTotal + marginDelta + profitLossTotal\nnewMarginDepositedTotal = 70 + (-65) + (-5) = 0\n\nstableCollateralTotal = stableCollateralTotal + -PnL\nstableCollateralTotal = 120 + (-(5)) = 125\n```\n\nThe reason why the profitLossTotal = -5 is because there is only one (1) position in the system. So, this loss actually comes from the loss of Bob's position.\n\nThe `newMarginDepositedTotal = 0` is correct. This is because the system only has 1 position, which is Bob's position; once the position is liquidated, there should be no margin deposited left in the system.\n\nHowever, `stableCollateralTotal = 125` is incorrect. Because the vault's collateral balance now is 170 - 50 (send to liquidator) = 120. Thus, the tracked balance and actual collateral balance are not in sync.\n\n## Impact\n\nThe following is a list of potential impacts of this issue:\n\n- First Example: LPs incur unnecessary losses during liquidation, which would be avoidable if the calculations were correctly implemented from the start.\n- Second Example: An error in the protocol's accounting mechanism led to an inflated increase in the LPs' stable collateral total, which in turn inflated the number of tokens users can withdraw from the system.\n- Third Example: The accounting error led to the tracked balance and actual collateral balance not being in sync.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LiquidationModule.sol#L85\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo remediate the issue, the `profitLossTotal` should be excluded within the `updateGlobalPositionData` function during liquidation. \n\n```diff\n- profitLossTotal = PerpMath._profitLossTotal(...)\n\n- newMarginDepositedTotal = globalPositions.marginDepositedTotal + _marginDelta + profitLossTotal\n+ newMarginDepositedTotal = globalPositions.marginDepositedTotal + _marginDelta\n\nif (newMarginDepositedTotal < 0) {\n    revert FlatcoinErrors.InsufficientGlobalMargin();\n}\n\n_globalPositions = FlatcoinStructs.GlobalPositions({\n    marginDepositedTotal: uint256(newMarginDepositedTotal),\n    sizeOpenedTotal: (int256(_globalPositions.sizeOpenedTotal) + _additionalSizeDelta).toUint256(),\n    lastPrice: _price\n});\n        \n- _updateStableCollateralTotal(-profitLossTotal);\n```\n\nThe existing `updateGlobalPositionData` function still needs to be used for other functions besides liquidation. As such, consider creating a separate new function (e.g., updateGlobalPositionDataDuringLiquidation) solely for use during the liquidation that includes the above fixes.\n\nThe following attempts to apply the above fix to the three (3) examples described in the report to verify that it is working as intended.\n\n#### First Example\n\nLet the current `StableCollateralTotal` be $x$ and `marginDepositedTotal` be $y$ at the start of the liquidation.\n\n- **During funding settlement:** \n\nStableCollateralTotal = $x$​​ + 100\n\nmarginDepositedTotal = $y$ - 100\n\n- **During updateStableCollateralTotal:**\n\n```solidity\nvault.updateStableCollateralTotal(int256(remainingMargin) - positionSummary.profitLoss);\nvault.updateStableCollateralTotal(0 - (+100));\nvault.updateStableCollateralTotal(-100);\n```\n\nStableCollateralTotal = ($x$ + 100) - 100 = $x$\n\n- **During Global Position Update:** \n\nmarginDelta = -(position.marginDeposited + positionSummary.accruedFunding) = -(20 + (-100)) = 80\n\nnewMarginDepositedTotal = marginDepositedTotal + marginDelta = ($y$ - 100) + 80 = ($y$ - 20)\n\nNo change to StableCollateralTotal here. Remain at $x$\n\n- **Conclusion:** \n\n1) The LPs should not gain or lose in this scenario. Thus, the fact that the StableCollateralTotal remains as $x$ before and after the liquidation is correct.\n2) The `marginDepositedTotal` is ($y$ - 20) is correct because the liquidated position's remaining margin is 20 ETH. Thus, when this position is liquidated, 20 ETH should be deducted from the `marginDepositedTotal`\n3) No revert during the execution.\n\n#### Second Example\n\n- **During updateStableCollateralTotal:**\n\n```solidity\nvault.updateStableCollateralTotal(settledMargin - positionSummary.profitLoss);\nvault.updateStableCollateralTotal(-3 rETH - (-5 rETH));\nvault.updateStableCollateralTotal(+2);\n```\n\nStableCollateralTotal = 5 + 2 = 7 ETH\n\n- **During Global Position Update:**\n\nmarginDelta = -(position.marginDeposited + positionSummary.accruedFunding) = -(2 + 0) = -2\n\nmarginDepositedTotal = marginDepositedTotal + marginDelta = 2 + (-2) = 0\n\n- **Conclusion:**\n\nStableCollateralTotal = 7 ETH, marginDepositedTotal = 0 (Total 7 ETH tracked in the system)\n\nBalance of collateral in the system = 7 ETH. Thus, both values are in sync. No revert.\n\n#### Third Example\n\n- **During funding settlement (Transfer 5 from Long to LP):** \n\nmarginDepositedTotal = 70 + (-5) = 65\n\nStableCollateralTotal = 100 + 5 = 105\n\n- **Transfer fee to Liquidator**\n\n50 ETH sent to the liquidator from the system: Balance of collateral in the system = 170 ETH - 50 ETH = 120 ETH\n\n- **During updateStableCollateralTotal:**\n\n```solidity\nvault.updateStableCollateralTotal(remainingMargin - positionSummary.profitLoss) =>\nstableCollateralTotal = 105 ETH + (remaining margin - PnL)\nstableCollateralTotal = 105 ETH + (10 ETH - (-5 ETH))\nstableCollateralTotal = 105 ETH + (15 ETH) = 120 ETH\n```\n\nStableCollateralTotal = 120 ETH\n\n- **During Global Position Update:** \n\nmarginDelta= -(position.marginDeposited + positionSummary.accruedFunding) = -(70 + (-5)) = -65\n\nmarginDepositedTotal = 65 + (-65) = 0\n\n- **Conclusion:**\n\nStableCollateralTotal = 120 ETH, marginDepositedTotal = 0 (Total 120 ETH tracked in the system)\n\nBalance of collateral in the system = 120 ETH. Thus, both values are in sync. No revert.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: whole lot of lessons taught here; high(3)\n\n\n\n**rashtrakoff**\n\nWow, this is a detailed explanation. We did find this issue during the audit and glad that you have found it as well!\n\n**itsermin**\n\nI believe this type of scenario is also fixed in the PR for #186:\nhttps://github.com/dhedge/flatcoin-v1/pull/266/commits/3a95a5b932fb9dcd770afd589751ecfd151360a8\n\nIt appears that this issue #186 and #192 are covering the same ground.\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dhedge/flatcoin-v1/pull/266.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/132",
  "Code": [
    {
      "filename": "flatcoin-v1/src/LiquidationModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {Initializable} from \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\nimport {OracleModifiers} from \"./abstracts/OracleModifiers.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\nimport {InvariantChecks} from \"./misc/InvariantChecks.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {ILiquidationModule} from \"./interfaces/ILiquidationModule.sol\";\nimport {ILimitOrder} from \"./interfaces/ILimitOrder.sol\";\n\n/// @title LiquidationModule\n/// @author dHEDGE\n/// @notice Module for liquidating leveraged positions.\ncontract LiquidationModule is\n    ILiquidationModule,\n    Initializable,\n    ModuleUpgradeable,\n    OracleModifiers,\n    ReentrancyGuardUpgradeable,\n    InvariantChecks\n{\n    /// @notice Liquidation fee basis points paid to liquidator.\n    /// @dev Note that this needs to be used together with keeper fee bounds.\n    /// @dev Should include 18 decimals i.e, 0.2% => 0.002e18 => 2e15\n    uint128 public liquidationFeeRatio;\n\n    /// @notice Liquidation price buffer in basis points to prevent negative margin on liquidation.\n    /// @dev Should include 18 decimals i.e, 0.75% => 0.0075e18 => 75e14\n    uint128 public liquidationBufferRatio;\n\n    /// @notice Upper bound for the liquidation fee.\n    /// @dev Denominated in USD.\n    uint256 public liquidationFeeUpperBound;\n\n    /// @notice Lower bound for the liquidation fee.\n    /// @dev Denominated in USD.\n    uint256 public liquidationFeeLowerBound;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IFlatcoinVault _vault,\n        uint128 _liquidationFeeRatio,\n        uint128 _liquidationBufferRatio,\n        uint256 _liquidationFeeLowerBound,\n        uint256 _liquidationFeeUpperBound\n    ) external initializer {\n        __Module_init(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY, _vault);\n\n        setLiquidationFeeRatio(_liquidationFeeRatio);\n        setLiquidationBufferRatio(_liquidationBufferRatio);\n        setLiquidationFeeBounds(_liquidationFeeLowerBound, _liquidationFeeUpperBound);\n    }\n\n    /////////////////////////////////////////////\n    //         Public Write Functions          //\n    /////////////////////////////////////////////\n\n    function liquidate(\n        uint256 tokenID,\n        bytes[] calldata priceUpdateData\n    ) external payable whenNotPaused updatePythPrice(vault, msg.sender, priceUpdateData) {\n        liquidate(tokenID);\n    }\n\n    /// @notice Function to liquidate a position.\n    /// @dev One could directly call this method instead of `liquidate(uint256, bytes[])` if they don't want to update the Pyth price.\n    /// @param tokenId The token ID of the leverage position.\n    function liquidate(uint256 tokenId) public nonReentrant whenNotPaused liquidationInvariantChecks(vault, tokenId) {\n        FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        // Settle funding fees accrued till now.\n        vault.settleFundingFees();\n\n        // Check if the position can indeed be liquidated.\n        if (!canLiquidate(tokenId)) revert FlatcoinErrors.CannotLiquidate(tokenId);\n\n        FlatcoinStructs.PositionSummary memory positionSummary = PerpMath._getPositionSummary(\n            position,\n            vault.cumulativeFundingRate(),\n            currentPrice\n        );\n\n        // Check that the total margin deposited by the long traders is not -ve.\n        // To get this amount, we will have to account for the PnL and funding fees accrued.\n        int256 settledMargin = positionSummary.marginAfterSettlement;\n\n        uint256 liquidatorFee;\n\n        // If the settled margin is greater than 0, send a portion (or all) of the margin to the liquidator and LPs.\n        if (settledMargin > 0) {\n            // Calculate the liquidation fees to be sent to the caller.\n            uint256 expectedLiquidationFee = PerpMath._liquidationFee(\n                position.additionalSize,\n                liquidationFeeRatio,\n                liquidationFeeLowerBound,\n                liquidationFeeUpperBound,\n                currentPrice\n            );\n\n            uint256 remainingMargin;\n\n            // Calculate the remaining margin after accounting for liquidation fees.\n            // If the settled margin is less than the liquidation fee, then the liquidator fee is the settled margin.\n            if (uint256(settledMargin) > expectedLiquidationFee) {\n                liquidatorFee = expectedLiquidationFee;\n                remainingMargin = uint256(settledMargin) - expectedLiquidationFee;\n            } else {\n                liquidatorFee = uint256(settledMargin);\n            }\n\n            // Adjust the stable collateral total to account for user's remaining margin.\n            // If the remaining margin is greater than 0, this goes to the LPs.\n            // Note that {`remainingMargin` - `profitLoss`} is the same as {`marginDeposited` + `accruedFunding`}.\n            vault.updateStableCollateralTotal(int256(remainingMargin) - positionSummary.profitLoss);\n\n            // Send the liquidator fee to the caller of the function.\n            // If the liquidation fee is greater than the remaining margin, then send the remaining margin.\n            vault.sendCollateral(msg.sender, liquidatorFee);\n        } else {\n            // If the settled margin is -ve then the LPs have to bear the cost.\n            // Adjust the stable collateral total to account for user's profit/loss and the negative margin.\n            // Note: We are adding `settledMargin` and `profitLoss` instead of subtracting because of their sign (which will be -ve).\n            vault.updateStableCollateralTotal(settledMargin - positionSummary.profitLoss);\n        }\n\n        // Update the global position data.\n        // Note that we are only accounting for `globalMarginDelta`, `marginDeposited` and `userAccruedFunding`.\n        // and not the PnL of the user when altering `marginDepositedTotal`.\n        // This is because the PnL is already accounted for in the `stableCollateralTotal`.\n        // So when the PnL is +ve (the trader made profits), the trader takes the profit along with the margin deposited.\n        // When the PnL is -ve, the trader loses a portion of the margin deposited to the LPs and the rest is again taken along.\n        // In neither case, the PnL is added/subtracted to/from the `marginDepositedTotal`.\n        // Now we are subtracting `userAccruedFunding` in the below function call because:\n        //      `globalMarginDelta` = `userAccruedFunding` + Funding accrued by the rest of the long traders.\n        // And this accrued funding is being taken away from the system (if +ve) or given to LPs (if -ve).\n        // When the `userAccruedFunding` is +ve, the user takes away the funding fees earned.\n        // When it's negative, the user pays the funding fees to the LPs and their margin is reduced.\n        // So the `marginDepositedTotal` is added with `userAccruedFunding` in the below function call as the user has paid for their share\n        // of funding fees.\n        vault.updateGlobalPositionData({\n            price: position.lastPrice,\n            marginDelta: -(int256(position.marginDeposited) + positionSummary.accruedFunding),\n            additionalSizeDelta: -int256(position.additionalSize) // Since position is being closed, additionalSizeDelta should be negative.\n        });\n\n        // Delete position storage\n        vault.deletePosition(tokenId);\n\n        // Cancel any limit orders associated with the position\n        ILimitOrder(vault.moduleAddress(FlatcoinModuleKeys._LIMIT_ORDER_KEY)).cancelExistingLimitOrder(tokenId);\n\n        // If the position token is locked because of an announced order, it should still be liquidatable\n        ILeverageModule leverageModule = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY));\n        leverageModule.unlock(tokenId);\n        leverageModule.burn(tokenId);\n\n        emit FlatcoinEvents.PositionLiquidated(tokenId, msg.sender, liquidatorFee);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Function to calculate liquidation price for a given position.\n    /// @dev Note that liquidation price is influenced by the funding rates and also the current price.\n    /// @param tokenId The token ID of the leverage position.\n    /// @return liqPrice The liquidation price in $ terms.\n    function liquidationPrice(uint256 tokenId) public view returns (uint256 liqPrice) {\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return liquidationPrice(tokenId, currentPrice);\n    }\n\n    /// @notice Function to calculate liquidation price for a given position at a given price.\n    /// @dev Note that liquidation price is influenced by the funding rates and also the current price.\n    /// @param tokenId The token ID of the leverage position.\n    /// @param price The price at which the liquidation price is to be calculated.\n    /// @return liqPrice The liquidation price in $ terms.\n    function liquidationPrice(uint256 tokenId, uint256 price) public view returns (uint256 liqPrice) {\n        FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n\n        int256 nextFundingEntry = _accountFundingFees();\n\n        return\n            PerpMath._approxLiquidationPrice({\n                position: position,\n                nextFundingEntry: nextFundingEntry,\n                liquidationFeeRatio: liquidationFeeRatio,\n                liquidationBufferRatio: liquidationBufferRatio,\n                liquidationFeeLowerBound: liquidationFeeLowerBound,\n                liquidationFeeUpperBound: liquidationFeeUpperBound,\n                currentPrice: price\n            });\n    }\n\n    /// @notice Function which determines if a leverage position can be liquidated or not.\n    /// @param tokenId The token ID of the leverage position.\n    /// @return liquidatable True if the position can be liquidated, false otherwise.\n    function canLiquidate(uint256 tokenId) public view returns (bool liquidatable) {\n        // Get the current price from the oracle module.\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return canLiquidate(tokenId, currentPrice);\n    }\n\n    function canLiquidate(uint256 tokenId, uint256 price) public view returns (bool liquidatable) {\n        FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n\n        int256 nextFundingEntry = _accountFundingFees();\n\n        return\n            PerpMath._canLiquidate({\n                position: position,\n                liquidationFeeRatio: liquidationFeeRatio,\n                liquidationBufferRatio: liquidationBufferRatio,\n                liquidationFeeLowerBound: liquidationFeeLowerBound,\n                liquidationFeeUpperBound: liquidationFeeUpperBound,\n                nextFundingEntry: nextFundingEntry,\n                currentPrice: price\n            });\n    }\n\n    /// @notice Function to calculate the liquidation fee awarded for a liquidating a given position.\n    /// @param tokenId The token ID of the leverage position.\n    /// @return liquidationFee The liquidation fee in collateral units.\n    function getLiquidationFee(uint256 tokenId) public view returns (uint256 liquidationFee) {\n        // Get the latest price from the oracle module.\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return\n            PerpMath._liquidationFee(\n                vault.getPosition(tokenId).additionalSize,\n                liquidationFeeRatio,\n                liquidationFeeLowerBound,\n                liquidationFeeUpperBound,\n                currentPrice\n            );\n    }\n\n    /// @notice Function to calculate the liquidation margin for a given additional size amount.\n    /// @param additionalSize The additional size amount for which the liquidation margin is to be calculated.\n    /// @return liquidationMargin The liquidation margin in collateral units.\n    function getLiquidationMargin(uint256 additionalSize) public view returns (uint256 liquidationMargin) {\n        // Get the latest price from the oracle module.\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return getLiquidationMargin(additionalSize, currentPrice);\n    }\n\n    /// @notice Function to calculate the liquidation margin for a given additional size amount and price.\n    /// @param additionalSize The additional size amount for which the liquidation margin is to be calculated.\n    /// @param price The price at which the liquidation margin is to be calculated.\n    /// @return liquidationMargin The liquidation margin in collateral units.\n    function getLiquidationMargin(\n        uint256 additionalSize,\n        uint256 price\n    ) public view returns (uint256 liquidationMargin) {\n        return\n            PerpMath._liquidationMargin(\n                additionalSize,\n                liquidationFeeRatio,\n                liquidationBufferRatio,\n                liquidationFeeLowerBound,\n                liquidationFeeUpperBound,\n                price\n            );\n    }\n\n    /////////////////////////////////////////////\n    //            Owner Functions              //\n    /////////////////////////////////////////////\n\n    function setLiquidationFeeRatio(uint128 _newLiquidationFeeRatio) public onlyOwner {\n        if (_newLiquidationFeeRatio == 0) revert FlatcoinErrors.ZeroValue(\"newLiquidationFeeRatio\");\n\n        emit FlatcoinEvents.LiquidationFeeRatioModified(liquidationFeeRatio, _newLiquidationFeeRatio);\n\n        liquidationFeeRatio = _newLiquidationFeeRatio;\n    }\n\n    function setLiquidationBufferRatio(uint128 _newLiquidationBufferRatio) public onlyOwner {\n        if (_newLiquidationBufferRatio == 0) revert FlatcoinErrors.ZeroValue(\"newLiquidationBufferRatio\");\n\n        emit FlatcoinEvents.LiquidationBufferRatioModified(liquidationBufferRatio, _newLiquidationBufferRatio);\n\n        liquidationBufferRatio = _newLiquidationBufferRatio;\n    }\n\n    function setLiquidationFeeBounds(\n        uint256 _newLiquidationFeeLowerBound,\n        uint256 _newLiquidationFeeUpperBound\n    ) public onlyOwner {\n        if (_newLiquidationFeeUpperBound == 0 || _newLiquidationFeeLowerBound == 0)\n            revert FlatcoinErrors.ZeroValue(\"newLiquidationFee\");\n        if (_newLiquidationFeeUpperBound < _newLiquidationFeeLowerBound)\n            revert FlatcoinErrors.InvalidBounds(_newLiquidationFeeLowerBound, _newLiquidationFeeUpperBound);\n\n        emit FlatcoinEvents.LiquidationFeeBoundsModified(\n            liquidationFeeLowerBound,\n            liquidationFeeUpperBound,\n            _newLiquidationFeeLowerBound,\n            _newLiquidationFeeUpperBound\n        );\n\n        liquidationFeeLowerBound = _newLiquidationFeeLowerBound;\n        liquidationFeeUpperBound = _newLiquidationFeeUpperBound;\n    }\n\n    /////////////////////////////////////////////\n    //           Internal Functions            //\n    /////////////////////////////////////////////\n\n    /// @dev Accounts for the funding fees based on the market state.\n    /// @return nextFundingEntry The cumulative funding rate based on the latest market state.\n    function _accountFundingFees() internal view returns (int256 nextFundingEntry) {\n        uint256 stableCollateralTotal = vault.stableCollateralTotal();\n        int256 currMarketSkew = int256(vault.getGlobalPositions().sizeOpenedTotal) - int256(stableCollateralTotal);\n\n        int256 currentFundingRate = PerpMath._currentFundingRate({\n            proportionalSkew: PerpMath._proportionalSkew({\n                skew: currMarketSkew,\n                stableCollateralTotal: stableCollateralTotal\n            }),\n            lastRecomputedFundingRate: vault.lastRecomputedFundingRate(),\n            lastRecomputedFundingTimestamp: vault.lastRecomputedFundingTimestamp(),\n            maxFundingVelocity: vault.maxFundingVelocity(),\n            maxVelocitySkew: vault.maxVelocitySkew()\n        });\n\n        int256 unrecordedFunding = PerpMath._unrecordedFunding(\n            currentFundingRate,\n            vault.lastRecomputedFundingRate(),\n            vault.lastRecomputedFundingTimestamp()\n        );\n\n        return PerpMath._nextFundingEntry(unrecordedFunding, vault.cumulativeFundingRate());\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/LiquidationModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {Initializable} from \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\nimport {OracleModifiers} from \"./abstracts/OracleModifiers.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\nimport {InvariantChecks} from \"./misc/InvariantChecks.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {ILiquidationModule} from \"./interfaces/ILiquidationModule.sol\";\nimport {ILimitOrder} from \"./interfaces/ILimitOrder.sol\";\n\n/// @title LiquidationModule\n/// @author dHEDGE\n/// @notice Module for liquidating leveraged positions.\ncontract LiquidationModule is\n    ILiquidationModule,\n    Initializable,\n    ModuleUpgradeable,\n    OracleModifiers,\n    ReentrancyGuardUpgradeable,\n    InvariantChecks\n{\n    /// @notice Liquidation fee basis points paid to liquidator.\n    /// @dev Note that this needs to be used together with keeper fee bounds.\n    /// @dev Should include 18 decimals i.e, 0.2% => 0.002e18 => 2e15\n    uint128 public liquidationFeeRatio;\n\n    /// @notice Liquidation price buffer in basis points to prevent negative margin on liquidation.\n    /// @dev Should include 18 decimals i.e, 0.75% => 0.0075e18 => 75e14\n    uint128 public liquidationBufferRatio;\n\n    /// @notice Upper bound for the liquidation fee.\n    /// @dev Denominated in USD.\n    uint256 public liquidationFeeUpperBound;\n\n    /// @notice Lower bound for the liquidation fee.\n    /// @dev Denominated in USD.\n    uint256 public liquidationFeeLowerBound;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IFlatcoinVault _vault,\n        uint128 _liquidationFeeRatio,\n        uint128 _liquidationBufferRatio,\n        uint256 _liquidationFeeLowerBound,\n        uint256 _liquidationFeeUpperBound\n    ) external initializer {\n        __Module_init(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY, _vault);\n\n        setLiquidationFeeRatio(_liquidationFeeRatio);\n        setLiquidationBufferRatio(_liquidationBufferRatio);\n        setLiquidationFeeBounds(_liquidationFeeLowerBound, _liquidationFeeUpperBound);\n    }\n\n    /////////////////////////////////////////////\n    //         Public Write Functions          //\n    /////////////////////////////////////////////\n\n    function liquidate(\n        uint256 tokenID,\n        bytes[] calldata priceUpdateData\n    ) external payable whenNotPaused updatePythPrice(vault, msg.sender, priceUpdateData) {\n        liquidate(tokenID);\n    }\n\n    /// @notice Function to liquidate a position.\n    /// @dev One could directly call this method instead of `liquidate(uint256, bytes[])` if they don't want to update the Pyth price.\n    /// @param tokenId The token ID of the leverage position.\n    function liquidate(uint256 tokenId) public nonReentrant whenNotPaused liquidationInvariantChecks(vault, tokenId) {\n        FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        // Settle funding fees accrued till now.\n        vault.settleFundingFees();\n\n        // Check if the position can indeed be liquidated.\n        if (!canLiquidate(tokenId)) revert FlatcoinErrors.CannotLiquidate(tokenId);\n\n        FlatcoinStructs.PositionSummary memory positionSummary = PerpMath._getPositionSummary(\n            position,\n            vault.cumulativeFundingRate(),\n            currentPrice\n        );\n\n        // Check that the total margin deposited by the long traders is not -ve.\n        // To get this amount, we will have to account for the PnL and funding fees accrued.\n        int256 settledMargin = positionSummary.marginAfterSettlement;\n\n        uint256 liquidatorFee;\n\n        // If the settled margin is greater than 0, send a portion (or all) of the margin to the liquidator and LPs.\n        if (settledMargin > 0) {\n            // Calculate the liquidation fees to be sent to the caller.\n            uint256 expectedLiquidationFee = PerpMath._liquidationFee(\n                position.additionalSize,\n                liquidationFeeRatio,\n                liquidationFeeLowerBound,\n                liquidationFeeUpperBound,\n                currentPrice\n            );\n\n            uint256 remainingMargin;\n\n            // Calculate the remaining margin after accounting for liquidation fees.\n            // If the settled margin is less than the liquidation fee, then the liquidator fee is the settled margin.\n            if (uint256(settledMargin) > expectedLiquidationFee) {\n                liquidatorFee = expectedLiquidationFee;\n                remainingMargin = uint256(settledMargin) - expectedLiquidationFee;\n            } else {\n                liquidatorFee = uint256(settledMargin);\n            }\n\n            // Adjust the stable collateral total to account for user's remaining margin.\n            // If the remaining margin is greater than 0, this goes to the LPs.\n            // Note that {`remainingMargin` - `profitLoss`} is the same as {`marginDeposited` + `accruedFunding`}.\n            vault.updateStableCollateralTotal(int256(remainingMargin) - positionSummary.profitLoss);\n\n            // Send the liquidator fee to the caller of the function.\n            // If the liquidation fee is greater than the remaining margin, then send the remaining margin.\n            vault.sendCollateral(msg.sender, liquidatorFee);\n        } else {\n            // If the settled margin is -ve then the LPs have to bear the cost.\n            // Adjust the stable collateral total to account for user's profit/loss and the negative margin.\n            // Note: We are adding `settledMargin` and `profitLoss` instead of subtracting because of their sign (which will be -ve).\n            vault.updateStableCollateralTotal(settledMargin - positionSummary.profitLoss);\n        }\n\n        // Update the global position data.\n        // Note that we are only accounting for `globalMarginDelta`, `marginDeposited` and `userAccruedFunding`.\n        // and not the PnL of the user when altering `marginDepositedTotal`.\n        // This is because the PnL is already accounted for in the `stableCollateralTotal`.\n        // So when the PnL is +ve (the trader made profits), the trader takes the profit along with the margin deposited.\n        // When the PnL is -ve, the trader loses a portion of the margin deposited to the LPs and the rest is again taken along.\n        // In neither case, the PnL is added/subtracted to/from the `marginDepositedTotal`.\n        // Now we are subtracting `userAccruedFunding` in the below function call because:\n        //      `globalMarginDelta` = `userAccruedFunding` + Funding accrued by the rest of the long traders.\n        // And this accrued funding is being taken away from the system (if +ve) or given to LPs (if -ve).\n        // When the `userAccruedFunding` is +ve, the user takes away the funding fees earned.\n        // When it's negative, the user pays the funding fees to the LPs and their margin is reduced.\n        // So the `marginDepositedTotal` is added with `userAccruedFunding` in the below function call as the user has paid for their share\n        // of funding fees.\n        vault.updateGlobalPositionData({\n            price: position.lastPrice,\n            marginDelta: -(int256(position.marginDeposited) + positionSummary.accruedFunding),\n            additionalSizeDelta: -int256(position.additionalSize) // Since position is being closed, additionalSizeDelta should be negative.\n        });\n\n        // Delete position storage\n        vault.deletePosition(tokenId);\n\n        // Cancel any limit orders associated with the position\n        ILimitOrder(vault.moduleAddress(FlatcoinModuleKeys._LIMIT_ORDER_KEY)).cancelExistingLimitOrder(tokenId);\n\n        // If the position token is locked because of an announced order, it should still be liquidatable\n        ILeverageModule leverageModule = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY));\n        leverageModule.unlock(tokenId);\n        leverageModule.burn(tokenId);\n\n        emit FlatcoinEvents.PositionLiquidated(tokenId, msg.sender, liquidatorFee);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Function to calculate liquidation price for a given position.\n    /// @dev Note that liquidation price is influenced by the funding rates and also the current price.\n    /// @param tokenId The token ID of the leverage position.\n    /// @return liqPrice The liquidation price in $ terms.\n    function liquidationPrice(uint256 tokenId) public view returns (uint256 liqPrice) {\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return liquidationPrice(tokenId, currentPrice);\n    }\n\n    /// @notice Function to calculate liquidation price for a given position at a given price.\n    /// @dev Note that liquidation price is influenced by the funding rates and also the current price.\n    /// @param tokenId The token ID of the leverage position.\n    /// @param price The price at which the liquidation price is to be calculated.\n    /// @return liqPrice The liquidation price in $ terms.\n    function liquidationPrice(uint256 tokenId, uint256 price) public view returns (uint256 liqPrice) {\n        FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n\n        int256 nextFundingEntry = _accountFundingFees();\n\n        return\n            PerpMath._approxLiquidationPrice({\n                position: position,\n                nextFundingEntry: nextFundingEntry,\n                liquidationFeeRatio: liquidationFeeRatio,\n                liquidationBufferRatio: liquidationBufferRatio,\n                liquidationFeeLowerBound: liquidationFeeLowerBound,\n                liquidationFeeUpperBound: liquidationFeeUpperBound,\n                currentPrice: price\n            });\n    }\n\n    /// @notice Function which determines if a leverage position can be liquidated or not.\n    /// @param tokenId The token ID of the leverage position.\n    /// @return liquidatable True if the position can be liquidated, false otherwise.\n    function canLiquidate(uint256 tokenId) public view returns (bool liquidatable) {\n        // Get the current price from the oracle module.\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return canLiquidate(tokenId, currentPrice);\n    }\n\n    function canLiquidate(uint256 tokenId, uint256 price) public view returns (bool liquidatable) {\n        FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n\n        int256 nextFundingEntry = _accountFundingFees();\n\n        return\n            PerpMath._canLiquidate({\n                position: position,\n                liquidationFeeRatio: liquidationFeeRatio,\n                liquidationBufferRatio: liquidationBufferRatio,\n                liquidationFeeLowerBound: liquidationFeeLowerBound,\n                liquidationFeeUpperBound: liquidationFeeUpperBound,\n                nextFundingEntry: nextFundingEntry,\n                currentPrice: price\n            });\n    }\n\n    /// @notice Function to calculate the liquidation fee awarded for a liquidating a given position.\n    /// @param tokenId The token ID of the leverage position.\n    /// @return liquidationFee The liquidation fee in collateral units.\n    function getLiquidationFee(uint256 tokenId) public view returns (uint256 liquidationFee) {\n        // Get the latest price from the oracle module.\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return\n            PerpMath._liquidationFee(\n                vault.getPosition(tokenId).additionalSize,\n                liquidationFeeRatio,\n                liquidationFeeLowerBound,\n                liquidationFeeUpperBound,\n                currentPrice\n            );\n    }\n\n    /// @notice Function to calculate the liquidation margin for a given additional size amount.\n    /// @param additionalSize The additional size amount for which the liquidation margin is to be calculated.\n    /// @return liquidationMargin The liquidation margin in collateral units.\n    function getLiquidationMargin(uint256 additionalSize) public view returns (uint256 liquidationMargin) {\n        // Get the latest price from the oracle module.\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return getLiquidationMargin(additionalSize, currentPrice);\n    }\n\n    /// @notice Function to calculate the liquidation margin for a given additional size amount and price.\n    /// @param additionalSize The additional size amount for which the liquidation margin is to be calculated.\n    /// @param price The price at which the liquidation margin is to be calculated.\n    /// @return liquidationMargin The liquidation margin in collateral units.\n    function getLiquidationMargin(\n        uint256 additionalSize,\n        uint256 price\n    ) public view returns (uint256 liquidationMargin) {\n        return\n            PerpMath._liquidationMargin(\n                additionalSize,\n                liquidationFeeRatio,\n                liquidationBufferRatio,\n                liquidationFeeLowerBound,\n                liquidationFeeUpperBound,\n                price\n            );\n    }\n\n    /////////////////////////////////////////////\n    //            Owner Functions              //\n    /////////////////////////////////////////////\n\n    function setLiquidationFeeRatio(uint128 _newLiquidationFeeRatio) public onlyOwner {\n        if (_newLiquidationFeeRatio == 0) revert FlatcoinErrors.ZeroValue(\"newLiquidationFeeRatio\");\n\n        emit FlatcoinEvents.LiquidationFeeRatioModified(liquidationFeeRatio, _newLiquidationFeeRatio);\n\n        liquidationFeeRatio = _newLiquidationFeeRatio;\n    }\n\n    function setLiquidationBufferRatio(uint128 _newLiquidationBufferRatio) public onlyOwner {\n        if (_newLiquidationBufferRatio == 0) revert FlatcoinErrors.ZeroValue(\"newLiquidationBufferRatio\");"
    }
  ]
}