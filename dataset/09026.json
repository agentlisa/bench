{
  "Title": "[N-01] `approveMax` variable causes problems",
  "Content": "\nThe `approveMax` variable controls whether the liquidity value is used, or the maximum is used. If the result of that check doesn't match what was provided during signature generation, the `permit()` call will fail, so in the best case the variable has no effect. In the worst case it leads to incorrect state handling\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/contracts/Router.sol   #1\n\n290              uint value = approveMax ? type(uint).max : liquidity;\n291:             IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n```\n\n<https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Router.sol#L290-L291>\n\n```solidity\nFile: contracts/contracts/Router.sol   #2\n\n308          uint value = approveMax ? type(uint).max : liquidity;\n309:         IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n```\n\n<https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Router.sol#L308-L309>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-velodrome",
  "Code": [
    {
      "filename": "contracts/contracts/Router.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPair.sol';\nimport './interfaces/IPairFactory.sol';\nimport './interfaces/IWETH.sol';\n\ncontract Router {\n\n    struct route {\n        address from;\n        address to;\n        bool stable;\n    }\n\n    address public immutable factory;\n    IWETH public immutable weth;\n    uint internal constant MINIMUM_LIQUIDITY = 10**3;\n    bytes32 immutable pairCodeHash;\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'Router: EXPIRED');\n        _;\n    }\n\n    constructor(address _factory, address _weth) {\n        factory = _factory;\n        pairCodeHash = IPairFactory(_factory).pairCodeHash();\n        weth = IWETH(_weth);\n    }\n\n    receive() external payable {\n        assert(msg.sender == address(weth)); // only accept ETH via fallback from the WETH contract\n    }\n\n    function sortTokens(address tokenA, address tokenB) public pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'Router: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'Router: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address tokenA, address tokenB, bool stable) public view returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\n            hex'ff',\n            factory,\n            keccak256(abi.encodePacked(token0, token1, stable)),\n            pairCodeHash // init code hash\n        )))));\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quoteLiquidity(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'Router: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'Router: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA * reserveB / reserveA;\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address tokenA, address tokenB, bool stable) public view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IPair(pairFor(tokenA, tokenB, stable)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountOut(uint amountIn, address tokenIn, address tokenOut) external view returns (uint amount, bool stable) {\n        address pair = pairFor(tokenIn, tokenOut, true);\n        uint amountStable;\n        uint amountVolatile;\n        if (IPairFactory(factory).isPair(pair)) {\n            amountStable = IPair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        pair = pairFor(tokenIn, tokenOut, false);\n        if (IPairFactory(factory).isPair(pair)) {\n            amountVolatile = IPair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        return amountStable > amountVolatile ? (amountStable, true) : (amountVolatile, false);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(uint amountIn, route[] memory routes) public view returns (uint[] memory amounts) {\n        require(routes.length >= 1, 'Router: INVALID_PATH');\n        amounts = new uint[](routes.length+1);\n        amounts[0] = amountIn;\n        for (uint i = 0; i < routes.length; i++) {\n            address pair = pairFor(routes[i].from, routes[i].to, routes[i].stable);\n            if (IPairFactory(factory).isPair(pair)) {\n                amounts[i+1] = IPair(pair).getAmountOut(amounts[i], routes[i].from);\n            }\n        }\n    }\n\n    function isPair(address pair) external view returns (bool) {\n        return IPairFactory(factory).isPair(pair);\n    }\n\n    function quoteAddLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired\n    ) external view returns (uint amountA, uint amountB, uint liquidity) {\n        // create the pair if it doesn't exist yet\n        address _pair = IPairFactory(factory).getPair(tokenA, tokenB, stable);\n        (uint reserveA, uint reserveB) = (0,0);\n        uint _totalSupply = 0;\n        if (_pair != address(0)) {\n            _totalSupply = IERC20(_pair).totalSupply();\n            (reserveA, reserveB) = getReserves(tokenA, tokenB, stable);\n        }\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n            liquidity = Math.sqrt(amountA * amountB) - MINIMUM_LIQUIDITY;\n        } else {\n\n            uint amountBOptimal = quoteLiquidity(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n                liquidity = Math.min(amountA * _totalSupply / reserveA, amountB * _totalSupply / reserveB);\n            } else {\n                uint amountAOptimal = quoteLiquidity(amountBDesired, reserveB, reserveA);\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n                liquidity = Math.min(amountA * _totalSupply / reserveA, amountB * _totalSupply / reserveB);\n            }\n        }\n    }\n\n    function quoteRemoveLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity\n    ) external view returns (uint amountA, uint amountB) {\n        // create the pair if it doesn't exist yet\n        address _pair = IPairFactory(factory).getPair(tokenA, tokenB, stable);\n\n        if (_pair == address(0)) {\n            return (0,0);\n        }\n\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, stable);\n        uint _totalSupply = IERC20(_pair).totalSupply();\n\n        amountA = liquidity * reserveA / _totalSupply; // using balances ensures pro-rata distribution\n        amountB = liquidity * reserveB / _totalSupply; // using balances ensures pro-rata distribution\n\n    }\n\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal returns (uint amountA, uint amountB) {\n        require(amountADesired >= amountAMin);\n        require(amountBDesired >= amountBMin);\n        // create the pair if it doesn't exist yet\n        address _pair = IPairFactory(factory).getPair(tokenA, tokenB, stable);\n        if (_pair == address(0)) {\n            _pair = IPairFactory(factory).createPair(tokenA, tokenB, stable);\n        }\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, stable);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = quoteLiquidity(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = quoteLiquidity(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, stable, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = pairFor(tokenA, tokenB, stable);\n        _safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        _safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IPair(pair).mint(to);\n    }\n\n    function addLiquidityETH(\n        address token,\n        bool stable,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            address(weth),\n            stable,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = pairFor(token, address(weth), stable);\n        _safeTransferFrom(token, msg.sender, pair, amountToken);\n        weth.deposit{value: amountETH}();\n        assert(weth.transfer(pair, amountETH));\n        liquidity = IPair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) _safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = pairFor(tokenA, tokenB, stable);\n        require(IPair(pair).transferFrom(msg.sender, pair, liquidity)); // send liquidity to pair\n        (uint amount0, uint amount1) = IPair(pair).burn(to);\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\n    }\n\n    function removeLiquidityETH(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public ensure(deadline) returns (uint amountToken, uint amountETH) {\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            address(weth),\n            stable,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        _safeTransfer(token, to, amountToken);\n        weth.withdraw(amountETH);\n        _safeTransferETH(to, amountETH);\n    }\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB) {\n        address pair = pairFor(tokenA, tokenB, stable);\n        {\n            uint value = approveMax ? type(uint).max : liquidity;\n            IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        }\n\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, stable, liquidity, amountAMin, amountBMin, to, deadline);\n    }\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH) {\n        address pair = pairFor(token, address(weth), stable);\n        uint value = approveMax ? type(uint).max : liquidity;\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(token, stable, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, route[] memory routes, address _to) internal virtual {\n        for (uint i = 0; i < routes.length; i++) {\n            (address token0,) = sortTokens(routes[i].from, routes[i].to);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = routes[i].from == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < routes.length - 1 ? pairFor(routes[i+1].from, routes[i+1].to, routes[i+1].stable) : _to;\n            IPair(pairFor(routes[i].from, routes[i].to, routes[i].stable)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    function swapExactTokensForTokensSimple(\n        uint amountIn,\n        uint amountOutMin,\n        address tokenFrom,\n        address tokenTo,\n        bool stable,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory amounts) {\n        route[] memory routes = new route[](1);\n        routes[0].from = tokenFrom;\n        routes[0].to = tokenTo;\n        routes[0].stable = stable;\n        amounts = getAmountsOut(amountIn, routes);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        _safeTransferFrom(\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory amounts) {\n        amounts = getAmountsOut(amountIn, routes);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        _safeTransferFrom(\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactETHForTokens(uint amountOutMin, route[] calldata routes, address to, uint deadline)\n    external\n    payable\n    ensure(deadline)\n    returns (uint[] memory amounts)\n    {\n        require(routes[0].from == address(weth), 'Router: INVALID_PATH');\n        amounts = getAmountsOut(msg.value, routes);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        weth.deposit{value: amounts[0]}();\n        assert(weth.transfer(pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]));\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, route[] calldata routes, address to, uint deadline)\n    external\n    ensure(deadline)\n    returns (uint[] memory amounts)\n    {\n        require(routes[routes.length - 1].to == address(weth), 'Router: INVALID_PATH');\n        amounts = getAmountsOut(amountIn, routes);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        _safeTransferFrom(\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\n        );\n        _swap(amounts, routes, address(this));\n        weth.withdraw(amounts[amounts.length - 1]);\n        _safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n\n    function UNSAFE_swapExactTokensForTokens(\n        uint[] memory amounts,\n        route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory) {\n        _safeTransferFrom(routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]);\n        _swap(amounts, routes, to);\n        return amounts;\n    }\n\n    function _safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}"
    },
    {
      "filename": "contracts/contracts/Router.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPair.sol';\nimport './interfaces/IPairFactory.sol';\nimport './interfaces/IWETH.sol';\n\ncontract Router {\n\n    struct route {\n        address from;\n        address to;\n        bool stable;\n    }\n\n    address public immutable factory;\n    IWETH public immutable weth;\n    uint internal constant MINIMUM_LIQUIDITY = 10**3;\n    bytes32 immutable pairCodeHash;\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'Router: EXPIRED');\n        _;\n    }\n\n    constructor(address _factory, address _weth) {\n        factory = _factory;\n        pairCodeHash = IPairFactory(_factory).pairCodeHash();\n        weth = IWETH(_weth);\n    }\n\n    receive() external payable {\n        assert(msg.sender == address(weth)); // only accept ETH via fallback from the WETH contract\n    }\n\n    function sortTokens(address tokenA, address tokenB) public pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'Router: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'Router: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address tokenA, address tokenB, bool stable) public view returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\n            hex'ff',\n            factory,\n            keccak256(abi.encodePacked(token0, token1, stable)),\n            pairCodeHash // init code hash\n        )))));\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quoteLiquidity(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'Router: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'Router: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA * reserveB / reserveA;\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address tokenA, address tokenB, bool stable) public view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IPair(pairFor(tokenA, tokenB, stable)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountOut(uint amountIn, address tokenIn, address tokenOut) external view returns (uint amount, bool stable) {\n        address pair = pairFor(tokenIn, tokenOut, true);\n        uint amountStable;\n        uint amountVolatile;\n        if (IPairFactory(factory).isPair(pair)) {\n            amountStable = IPair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        pair = pairFor(tokenIn, tokenOut, false);\n        if (IPairFactory(factory).isPair(pair)) {\n            amountVolatile = IPair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        return amountStable > amountVolatile ? (amountStable, true) : (amountVolatile, false);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(uint amountIn, route[] memory routes) public view returns (uint[] memory amounts) {\n        require(routes.length >= 1, 'Router: INVALID_PATH');\n        amounts = new uint[](routes.length+1);\n        amounts[0] = amountIn;\n        for (uint i = 0; i < routes.length; i++) {\n            address pair = pairFor(routes[i].from, routes[i].to, routes[i].stable);\n            if (IPairFactory(factory).isPair(pair)) {\n                amounts[i+1] = IPair(pair).getAmountOut(amounts[i], routes[i].from);\n            }\n        }\n    }\n\n    function isPair(address pair) external view returns (bool) {\n        return IPairFactory(factory).isPair(pair);\n    }\n\n    function quoteAddLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired\n    ) external view returns (uint amountA, uint amountB, uint liquidity) {\n        // create the pair if it doesn't exist yet\n        address _pair = IPairFactory(factory).getPair(tokenA, tokenB, stable);\n        (uint reserveA, uint reserveB) = (0,0);\n        uint _totalSupply = 0;\n        if (_pair != address(0)) {\n            _totalSupply = IERC20(_pair).totalSupply();\n            (reserveA, reserveB) = getReserves(tokenA, tokenB, stable);\n        }\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n            liquidity = Math.sqrt(amountA * amountB) - MINIMUM_LIQUIDITY;\n        } else {\n\n            uint amountBOptimal = quoteLiquidity(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n                liquidity = Math.min(amountA * _totalSupply / reserveA, amountB * _totalSupply / reserveB);\n            } else {\n                uint amountAOptimal = quoteLiquidity(amountBDesired, reserveB, reserveA);\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n                liquidity = Math.min(amountA * _totalSupply / reserveA, amountB * _totalSupply / reserveB);\n            }\n        }\n    }\n\n    function quoteRemoveLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity\n    ) external view returns (uint amountA, uint amountB) {\n        // create the pair if it doesn't exist yet\n        address _pair = IPairFactory(factory).getPair(tokenA, tokenB, stable);\n\n        if (_pair == address(0)) {\n            return (0,0);\n        }\n\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, stable);\n        uint _totalSupply = IERC20(_pair).totalSupply();\n\n        amountA = liquidity * reserveA / _totalSupply; // using balances ensures pro-rata distribution\n        amountB = liquidity * reserveB / _totalSupply; // using balances ensures pro-rata distribution\n\n    }\n\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal returns (uint amountA, uint amountB) {\n        require(amountADesired >= amountAMin);\n        require(amountBDesired >= amountBMin);\n        // create the pair if it doesn't exist yet\n        address _pair = IPairFactory(factory).getPair(tokenA, tokenB, stable);\n        if (_pair == address(0)) {\n            _pair = IPairFactory(factory).createPair(tokenA, tokenB, stable);\n        }\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, stable);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = quoteLiquidity(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = quoteLiquidity(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, stable, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = pairFor(tokenA, tokenB, stable);\n        _safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        _safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IPair(pair).mint(to);\n    }\n\n    function addLiquidityETH(\n        address token,\n        bool stable,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            address(weth),\n            stable,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = pairFor(token, address(weth), stable);\n        _safeTransferFrom(token, msg.sender, pair, amountToken);\n        weth.deposit{value: amountETH}();\n        assert(weth.transfer(pair, amountETH));\n        liquidity = IPair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) _safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = pairFor(tokenA, tokenB, stable);\n        require(IPair(pair).transferFrom(msg.sender, pair, liquidity)); // send liquidity to pair\n        (uint amount0, uint amount1) = IPair(pair).burn(to);\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\n    }\n\n    function removeLiquidityETH(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public ensure(deadline) returns (uint amountToken, uint amountETH) {\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            address(weth),\n            stable,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        _safeTransfer(token, to, amountToken);\n        weth.withdraw(amountETH);\n        _safeTransferETH(to, amountETH);\n    }\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB) {\n        address pair = pairFor(tokenA, tokenB, stable);\n        {\n            uint value = approveMax ? type(uint).max : liquidity;\n            IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        }\n\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, stable, liquidity, amountAMin, amountBMin, to, deadline);\n    }\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH) {\n        address pair = pairFor(token, address(weth), stable);\n        uint value = approveMax ? type(uint).max : liquidity;\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(token, stable, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, route[] memory routes, address _to) internal virtual {\n        for (uint i = 0; i < routes.length; i++) {\n            (address token0,) = sortTokens(routes[i].from, routes[i].to);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = routes[i].from == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < routes.length - 1 ? pairFor(routes[i+1].from, routes[i+1].to, routes[i+1].stable) : _to;\n            IPair(pairFor(routes[i].from, routes[i].to, routes[i].stable)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    function swapExactTokensForTokensSimple(\n        uint amountIn,\n        uint amountOutMin,\n        address tokenFrom,\n        address tokenTo,\n        bool stable,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory amounts) {\n        route[] memory routes = new route[](1);\n        routes[0].from = tokenFrom;\n        routes[0].to = tokenTo;\n        routes[0].stable = stable;\n        amounts = getAmountsOut(amountIn, routes);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        _safeTransferFrom(\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory amounts) {\n        amounts = getAmountsOut(amountIn, routes);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        _safeTransferFrom(\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactETHForTokens(uint amountOutMin, route[] calldata routes, address to, uint deadline)\n    external\n    payable\n    ensure(deadline)\n    returns (uint[] memory amounts)\n    {\n        require(routes[0].from == address(weth), 'Router: INVALID_PATH');\n        amounts = getAmountsOut(msg.value, routes);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        weth.deposit{value: amounts[0]}();\n        assert(weth.transfer(pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]));\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, route[] calldata routes, address to, uint deadline)\n    external\n    ensure(deadline)\n    returns (uint[] memory amounts)\n    {\n        require(routes[routes.length - 1].to == address(weth), 'Router: INVALID_PATH');\n        amounts = getAmountsOut(amountIn, routes);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        _safeTransferFrom(\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\n        );\n        _swap(amounts, routes, address(this));\n        weth.withdraw(amounts[amounts.length - 1]);\n        _safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n\n    function UNSAFE_swapExactTokensForTokens(\n        uint[] m"
    }
  ]
}