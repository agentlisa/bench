{
  "Title": "Redundant memory allocation for asset index type",
  "Content": "\n`getMostPremium()` function (in here: [strategy-curve-scrv-v4_1.sol#L81](https://github.com/pickle-finance/protocol/blob/master/src/strategies/curve/strategy-curve-scrv-v4_1.sol#L81)\nreturns tuple `(address, uint256)`, which\ncontains unnecessarily huge asset index type `uint256`. Since the function \nstructure would require to update the contract anyway in case new stablecoins\nwould be added, there is no need in reserving index type sized for enormously \nhuge amount of assets. \n\nStoring asset index in a type like `uint8` would be more appropriate for now.\n\n*This issue was resolved with the following PR: https://github.com/pickle-finance/protocol/pull/6.*\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/strategies/curve/strategy-curve-scrv-v4_1.sol",
      "content": "// https://etherscan.io/address/0x594a198048501a304267e63b3bad0f0638da7628#code\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\nimport \"../../lib/erc20.sol\";\nimport \"../../lib/safe-math.sol\";\n\nimport \"./scrv-voter.sol\";\nimport \"./crv-locker.sol\";\n\nimport \"../../interfaces/jar.sol\";\nimport \"../../interfaces/curve.sol\";\nimport \"../../interfaces/uniswapv2.sol\";\nimport \"../../interfaces/controller.sol\";\n\nimport \"../strategy-base.sol\";\n\ncontract StrategyCurveSCRVv4_1 is StrategyBase {\n    // Curve\n    address public scrv = 0xC25a3A3b969415c80451098fa907EC722572917F;\n    address public susdv2_gauge = 0xA90996896660DEcC6E997655E065b23788857849;\n    address public susdv2_pool = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\n    address public escrow = 0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2;\n\n    // curve dao\n    address public gauge;\n    address public curve;\n    address public mintr = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;\n\n    // tokens we're farming\n    address public constant crv = 0xD533a949740bb3306d119CC777fa900bA034cd52;\n    address public constant snx = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n\n    // stablecoins\n    address public dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address public usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address public susd = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\n\n    // How much CRV tokens to keep\n    uint256 public keepCRV = 500;\n    uint256 public keepCRVMax = 10000;\n\n    // crv-locker and voter\n    address public scrvVoter;\n    address public crvLocker;\n\n    constructor(\n        address _scrvVoter,\n        address _crvLocker,\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    )\n        public\n        StrategyBase(scrv, _governance, _strategist, _controller, _timelock)\n    {\n        curve = susdv2_pool;\n        gauge = susdv2_gauge;\n\n        scrvVoter = _scrvVoter;\n        crvLocker = _crvLocker;\n    }\n\n    // **** Getters ****\n\n    function balanceOfPool() public override view returns (uint256) {\n        return SCRVVoter(scrvVoter).balanceOf(gauge);\n    }\n\n    function getName() external override pure returns (string memory) {\n        return \"StrategyCurveSCRVv4_1\";\n    }\n\n    function getHarvestable() external returns (uint256) {\n        return ICurveGauge(gauge).claimable_tokens(crvLocker);\n    }\n\n    function getMostPremium() public view returns (address, uint8) {\n        uint256[] memory balances = new uint256[](4);\n        balances[0] = ICurveFi_4(curve).balances(0); // DAI\n        balances[1] = ICurveFi_4(curve).balances(1).mul(10**12); // USDC\n        balances[2] = ICurveFi_4(curve).balances(2).mul(10**12); // USDT\n        balances[3] = ICurveFi_4(curve).balances(3); // sUSD\n\n        // DAI\n        if (\n            balances[0] < balances[1] &&\n            balances[0] < balances[2] &&\n            balances[0] < balances[3]\n        ) {\n            return (dai, 0);\n        }\n\n        // USDC\n        if (\n            balances[1] < balances[0] &&\n            balances[1] < balances[2] &&\n            balances[1] < balances[3]\n        ) {\n            return (usdc, 1);\n        }\n\n        // USDT\n        if (\n            balances[2] < balances[0] &&\n            balances[2] < balances[1] &&\n            balances[2] < balances[3]\n        ) {\n            return (usdt, 2);\n        }\n\n        // SUSD\n        if (\n            balances[3] < balances[0] &&\n            balances[3] < balances[1] &&\n            balances[3] < balances[2]\n        ) {\n            return (susd, 3);\n        }\n\n        // If they're somehow equal, we just want DAI\n        return (dai, 0);\n    }\n\n    // **** Setters ****\n\n    function setKeepCRV(uint256 _keepCRV) external {\n        require(msg.sender == governance, \"!governance\");\n        keepCRV = _keepCRV;\n    }\n\n    // **** State Mutations ****\n\n    function deposit() public override {\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            IERC20(want).safeTransfer(scrvVoter, _want);\n            SCRVVoter(scrvVoter).deposit(gauge, want);\n        }\n    }\n\n    function _withdrawSome(uint256 _amount)\n        internal\n        override\n        returns (uint256)\n    {\n        return SCRVVoter(scrvVoter).withdraw(gauge, want, _amount);\n    }\n\n    function harvest() public override onlyBenevolent {\n        // Anyone can harvest it at any given time.\n        // I understand the possibility of being frontrun / sandwiched\n        // But ETH is a dark forest, and I wanna see how this plays out\n        // i.e. will be be heavily frontrunned/sandwiched?\n        //      if so, a new strategy will be deployed.\n\n        // stablecoin we want to convert to\n        (address to, uint256 toIndex) = getMostPremium();\n\n        // Collects crv tokens\n        // Don't bother voting in v1\n        SCRVVoter(scrvVoter).harvest(gauge);\n        uint256 _crv = IERC20(crv).balanceOf(address(this));\n        if (_crv > 0) {\n            // How much CRV to keep to restake?\n            uint256 _keepCRV = _crv.mul(keepCRV).div(keepCRVMax);\n            IERC20(crv).safeTransfer(address(crvLocker), _keepCRV);\n\n            // How much CRV to swap?\n            _crv = _crv.sub(_keepCRV);\n            _swapUniswap(crv, to, _crv);\n        }\n\n        // Collects SNX tokens\n        SCRVVoter(scrvVoter).claimRewards();\n        uint256 _snx = IERC20(snx).balanceOf(address(this));\n        if (_snx > 0) {\n            _swapUniswap(snx, to, _snx);\n        }\n\n        // Adds liquidity to curve.fi's susd pool\n        // to get back want (scrv)\n        uint256 _to = IERC20(to).balanceOf(address(this));\n        if (_to > 0) {\n            IERC20(to).safeApprove(curve, 0);\n            IERC20(to).safeApprove(curve, _to);\n            uint256[4] memory liquidity;\n            liquidity[toIndex] = _to;\n            ICurveFi_4(curve).add_liquidity(liquidity, 0);\n        }\n\n        // We want to get back sCRV\n        _distributePerformanceFeesAndDeposit();\n    }\n}"
    }
  ]
}