{
  "Title": "Variable not needed",
  "Content": "\n[crv-locker.sol#L87](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/crv-locker.sol#L87)\n\nThe variable `success` will always be true.\nWe recommend removing this variable.\n\nStatus: *Fixed at https://github.com/pickle-finance/protocol/pull/18*\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/strategies/curve/crv-locker.sol",
      "content": "// CurveYCRVVoter: https://etherscan.io/address/0xF147b8125d2ef93FB6965Db97D6746952a133934#code\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\nimport \"../../lib/erc20.sol\";\nimport \"../../lib/safe-math.sol\";\n\nimport \"../../interfaces/curve.sol\";\n\ncontract CRVLocker {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public constant mintr = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;\n    address public constant crv = 0xD533a949740bb3306d119CC777fa900bA034cd52;\n\n    address public constant escrow = 0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2;\n\n    address public governance;\n    mapping(address => bool) public voters;\n\n    constructor(address _governance) public {\n        governance = _governance;\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"CRVLocker\";\n    }\n\n    function addVoter(address _voter) external {\n        require(msg.sender == governance, \"!governance\");\n        voters[_voter] = true;\n    }\n\n    function removeVoter(address _voter) external {\n        require(msg.sender == governance, \"!governance\");\n        voters[_voter] = false;\n    }\n\n    function withdraw(address _asset) external returns (uint256 balance) {\n        require(voters[msg.sender], \"!voter\");\n        balance = IERC20(_asset).balanceOf(address(this));\n        IERC20(_asset).safeTransfer(msg.sender, balance);\n    }\n\n    function createLock(uint256 _value, uint256 _unlockTime) external {\n        require(voters[msg.sender] || msg.sender == governance, \"!authorized\");\n        IERC20(crv).safeApprove(escrow, 0);\n        IERC20(crv).safeApprove(escrow, _value);\n        ICurveVotingEscrow(escrow).create_lock(_value, _unlockTime);\n    }\n\n    function increaseAmount(uint256 _value) external {\n        require(voters[msg.sender] || msg.sender == governance, \"!authorized\");\n        IERC20(crv).safeApprove(escrow, 0);\n        IERC20(crv).safeApprove(escrow, _value);\n        ICurveVotingEscrow(escrow).increase_amount(_value);\n    }\n\n    function increaseUnlockTime(uint256 _unlockTime) external {\n        require(voters[msg.sender] || msg.sender == governance, \"!authorized\");\n        ICurveVotingEscrow(escrow).increase_unlock_time(_unlockTime);\n    }\n\n    function release() external {\n        require(voters[msg.sender] || msg.sender == governance, \"!authorized\");\n        ICurveVotingEscrow(escrow).withdraw();\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    function execute(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bool, bytes memory) {\n        require(voters[msg.sender] || msg.sender == governance, \"!governance\");\n\n        (bool success, bytes memory result) = to.call{value: value}(data);\n        require(success, \"!execute-success\");\n\n        return (success, result);\n    }\n}"
    }
  ]
}