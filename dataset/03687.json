{
  "Title": "[L03] Events missing or not well indexed",
  "Content": "There are instances in the codebase where storage is modified, but events are not emitted. For instance, all of the functions that modify the governor and pending governor in the [`Governable` contract](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/Governable.sol).\n\n\nWhere there are events, many of their definitions are lacking indexed parameters. Some examples include:\n\n\n* The [events in `ProxyOracle`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/ProxyOracle.sol#L15-L19)\n* The [`SetRoute` event in `CoreOracle`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/CoreOracle.sol#L7)\n\n\nBecause it may be of particular interests to outside observers, consider indexing the `token` argument in events, as is done in the [`AggregatorOracle` contract](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/AggregatorOracle.sol#L12).\n\n\nAs event emissions and properly indexed parameters assist off-chain observers watch, search, and filter on-chain activity, consider emitting events whenever on-chain storage modifications occur and consider ensuring that all events in the codebase have indexed parameters.\n\n\n***Update:** Fixed in [PR#99](https://github.com/AlphaFinanceLab/homora-v2/pull/99).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/oracle/ProxyOracle.sol",
      "content": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\n\nimport '../Governable.sol';\nimport '../../interfaces/IOracle.sol';\nimport '../../interfaces/IBaseOracle.sol';\nimport '../../interfaces/IERC20Wrapper.sol';\n\ncontract ProxyOracle is IOracle, Governable {\n  using SafeMath for uint;\n\n  /// The governor sets oracle information for a token.\n  event SetOracle(address token, Oracle info);\n  /// The governor unsets oracle information for a token.\n  event UnsetOracle(address token);\n  /// The governor sets token whitelist for an ERC1155 token.\n  event SetWhitelist(address token, bool ok);\n\n  struct Oracle {\n    uint16 borrowFactor; // The borrow factor for this token, multiplied by 1e4.\n    uint16 collateralFactor; // The collateral factor for this token, multiplied by 1e4.\n    uint16 liqIncentive; // The liquidation incentive, multiplied by 1e4.\n  }\n\n  IBaseOracle public immutable source; // Main oracle source\n  mapping(address => Oracle) public oracles; // Mapping from token address to oracle info.\n  mapping(address => bool) public whitelistERC1155; // Mapping from token address to whitelist status\n\n  /// @dev Create the contract and initialize the first governor.\n  constructor(IBaseOracle _source) public {\n    source = _source;\n    __Governable__init();\n  }\n\n  /// @dev Set oracle information for the given list of token addresses.\n  /// @param tokens List of tokens to set info\n  /// @param info List of oracle info\n  function setOracles(address[] memory tokens, Oracle[] memory info) external onlyGov {\n    require(tokens.length == info.length, 'inconsistent length');\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      require(info[idx].borrowFactor >= 10000, 'borrow factor must be at least 100%');\n      require(info[idx].collateralFactor <= 10000, 'collateral factor must be at most 100%');\n      require(info[idx].liqIncentive >= 10000, 'incentive must be at least 100%');\n      require(info[idx].liqIncentive <= 20000, 'incentive must be at most 200%');\n      oracles[tokens[idx]] = info[idx];\n      emit SetOracle(tokens[idx], info[idx]);\n    }\n  }\n\n  /// @dev Unset oracle information for the given list of token addresses\n  /// @param tokens List of tokens to unset info\n  function unsetOracles(address[] memory tokens) external onlyGov {\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      oracles[tokens[idx]] = Oracle(0, 0, 0);\n      emit UnsetOracle(tokens[idx]);\n    }\n  }\n\n  /// @dev Set whitelist status for the given list of token addresses.\n  /// @param tokens List of tokens to set whitelist status\n  /// @param ok Whitelist status\n  function setWhitelistERC1155(address[] memory tokens, bool ok) external onlyGov {\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      whitelistERC1155[tokens[idx]] = ok;\n      emit SetWhitelist(tokens[idx], ok);\n    }\n  }\n\n  /// @dev Return whether the oracle supports evaluating collateral value of the given token.\n  /// @param token Token address to check for support\n  /// @param id Token id to check for support\n  function support(address token, uint id) external view override returns (bool) {\n    if (!whitelistERC1155[token]) return false;\n    address tokenUnderlying = IERC20Wrapper(token).getUnderlyingToken(id);\n    return oracles[tokenUnderlying].liqIncentive != 0;\n  }\n\n  /// @dev Return the amount of token out as liquidation reward for liquidating token in.\n  /// @param tokenIn Input ERC20 token\n  /// @param tokenOut Output ERC1155 token\n  /// @param tokenOutId Output ERC1155 token id\n  /// @param amountIn Input ERC20 token amount\n  function convertForLiquidation(\n    address tokenIn,\n    address tokenOut,\n    uint tokenOutId,\n    uint amountIn\n  ) external view override returns (uint) {\n    require(whitelistERC1155[tokenOut], 'bad token');\n    address tokenOutUnderlying = IERC20Wrapper(tokenOut).getUnderlyingToken(tokenOutId);\n    uint rateUnderlying = IERC20Wrapper(tokenOut).getUnderlyingRate(tokenOutId);\n    Oracle memory oracleIn = oracles[tokenIn];\n    Oracle memory oracleOut = oracles[tokenOutUnderlying];\n    require(oracleIn.liqIncentive != 0, 'bad underlying in');\n    require(oracleOut.liqIncentive != 0, 'bad underlying out');\n    uint pxIn = source.getETHPx(tokenIn);\n    uint pxOut = source.getETHPx(tokenOutUnderlying);\n    uint amountOut = amountIn.mul(pxIn).div(pxOut);\n    amountOut = amountOut.mul(2**112).div(rateUnderlying);\n    return amountOut.mul(oracleIn.liqIncentive).mul(oracleOut.liqIncentive).div(10000 * 10000);\n  }\n\n  /// @dev Return the value of the given input as ETH for collateral purpose.\n  /// @param token ERC1155 token address to get collateral value\n  /// @param id ERC1155 token id to get collateral value\n  /// @param amount Token amount to get collateral value\n  /// @param owner Token owner address (currently unused by this implementation)\n  function asETHCollateral(\n    address token,\n    uint id,\n    uint amount,\n    address owner\n  ) external view override returns (uint) {\n    require(whitelistERC1155[token], 'bad token');\n    address tokenUnderlying = IERC20Wrapper(token).getUnderlyingToken(id);\n    uint rateUnderlying = IERC20Wrapper(token).getUnderlyingRate(id);\n    uint amountUnderlying = amount.mul(rateUnderlying).div(2**112);\n    Oracle memory oracle = oracles[tokenUnderlying];\n    require(oracle.liqIncentive != 0, 'bad underlying collateral');\n    uint ethValue = source.getETHPx(tokenUnderlying).mul(amountUnderlying).div(2**112);\n    return ethValue.mul(oracle.collateralFactor).div(10000);\n  }\n\n  /// @dev Return the value of the given input as ETH for borrow purpose.\n  /// @param token ERC1155 token address to get borrow value\n  /// @param amount ERC1155 token amount to get borrow value\n  /// @param owner Token owner address (currently unused by this implementation)\n  function asETHBorrow(\n    address token,\n    uint amount,\n    address owner\n  ) external view override returns (uint) {\n    Oracle memory oracle = oracles[token];\n    require(oracle.liqIncentive != 0, 'bad underlying borrow');\n    uint ethValue = source.getETHPx(token).mul(amount).div(2**112);\n    return ethValue.mul(oracle.borrowFactor).div(10000);\n  }\n}"
    },
    {
      "filename": "contracts/oracle/CoreOracle.sol",
      "content": "pragma solidity 0.6.12;\n\nimport '../../interfaces/IBaseOracle.sol';\nimport '../Governable.sol';\n\ncontract CoreOracle is IBaseOracle, Governable {\n  event SetRoute(address token, address route);\n  mapping(address => address) public routes; // Mapping from token to oracle source\n\n  constructor() public {\n    __Governable__init();\n  }\n\n  /// @dev Set oracle source routes for tokens\n  /// @param tokens List of tokens\n  /// @param targets List of oracle source routes\n  function setRoute(address[] calldata tokens, address[] calldata targets) external onlyGov {\n    require(tokens.length == targets.length, 'inconsistent length');\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      routes[tokens[idx]] = targets[idx];\n      emit SetRoute(tokens[idx], targets[idx]);\n    }\n  }\n\n  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.\n  /// @param token The ERC-20 token to check the value.\n  function getETHPx(address token) external view override returns (uint) {\n    uint px = IBaseOracle(routes[token]).getETHPx(token);\n    require(px != 0, 'no px');\n    return px;\n  }\n}"
    },
    {
      "filename": "contracts/oracle/AggregatorOracle.sol",
      "content": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\n\nimport '../Governable.sol';\nimport '../../interfaces/IBaseOracle.sol';\n\ncontract AggregatorOracle is IBaseOracle, Governable {\n  using SafeMath for uint;\n\n  event SetPrimarySource(address indexed token, uint maxPriceDeviation, IBaseOracle[] oracles);\n\n  mapping(address => uint) public primarySourceCount; // Mapping from token to number of sources\n  mapping(address => mapping(uint => IBaseOracle)) public primarySources; // Mapping from token to (mapping from index to oracle source)\n  mapping(address => uint) public maxPriceDeviations; // Mapping from token to max price deviation (in bps)\n\n  constructor() public {\n    __Governable__init();\n  }\n\n  /// @dev Set oracle primary sources for the token\n  /// @param token Token address to set oracle sources\n  /// @param maxPriceDeviation Max price deviation (in bps) for token\n  /// @param sources Oracle sources for the token\n  function setPrimarySources(\n    address token,\n    uint maxPriceDeviation,\n    IBaseOracle[] memory sources\n  ) external onlyGov {\n    _setPrimarySources(token, maxPriceDeviation, sources);\n  }\n\n  /// @dev Set oracle primary sources for multiple tokens\n  /// @param tokens List of token addresses to set oracle sources\n  /// @param maxPriceDeviationList List of max price deviations (in bps) for tokens\n  /// @param allSources List of oracle sources for tokens\n  function setMultiPrimarySources(\n    address[] memory tokens,\n    uint[] memory maxPriceDeviationList,\n    IBaseOracle[][] memory allSources\n  ) external onlyGov {\n    require(tokens.length == allSources.length, 'inconsistent length');\n    require(tokens.length == maxPriceDeviationList.length, 'inconsistent length');\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      _setPrimarySources(tokens[idx], maxPriceDeviationList[idx], allSources[idx]);\n    }\n  }\n\n  /// @dev Set oracle primary sources for tokens\n  /// @param token Token to set oracle sources\n  /// @param maxPriceDeviation Max price deviation (in bps) for token\n  /// @param sources Oracle sources for the token\n  function _setPrimarySources(\n    address token,\n    uint maxPriceDeviation,\n    IBaseOracle[] memory sources\n  ) internal {\n    primarySourceCount[token] = sources.length;\n    require(maxPriceDeviation >= 1e18 && maxPriceDeviation <= 1.5e18, 'bad max deviation value');\n    maxPriceDeviations[token] = maxPriceDeviation;\n    for (uint idx = 0; idx < sources.length; idx++) {\n      primarySources[token][idx] = sources[idx];\n    }\n    emit SetPrimarySource(token, maxPriceDeviation, sources);\n  }\n\n  /// @dev Return token price relative to ETH, multiplied by 2**112\n  /// @param token Token to get price of\n  /// NOTE: Support at most 3 oracle sources per token\n  function getETHPx(address token) external view override returns (uint) {\n    uint candidateSourceCount = primarySourceCount[token];\n    require(candidateSourceCount > 0, 'no primary source');\n    uint[] memory prices = new uint[](candidateSourceCount);\n\n    // Get valid oracle sources\n    uint validSourceCount = 0;\n    for (uint idx = 0; idx < candidateSourceCount; idx++) {\n      try primarySources[token][idx].getETHPx(token) returns (uint px) {\n        prices[validSourceCount++] = px;\n      } catch {}\n    }\n    require(validSourceCount > 0, 'no valid source');\n    for (uint i = 0; i < validSourceCount - 1; i++) {\n      for (uint j = 0; j < validSourceCount - i - 1; j++) {\n        if (prices[j] > prices[j + 1]) {\n          (prices[j], prices[j + 1]) = (prices[j + 1], prices[j]);\n        }\n      }\n    }\n    uint maxPriceDeviation = maxPriceDeviations[token];\n    require(maxPriceDeviation >= 1e18 && maxPriceDeviation <= 1.5e18, 'bad max deviation value');\n\n    // Algo:\n    // - 1 valid source --> return price\n    // - 2 valid sources\n    //     --> if the prices within deviation threshold, return average\n    //     --> else revert\n    // - 3 valid sources --> check deviation threshold of each pair\n    //     --> if all within threshold, return median\n    //     --> if one pair within threshold, return average of the pair\n    //     --> if none, revert\n    // - revert otherwise\n    if (validSourceCount == 1) {\n      return prices[0]; // if 1 valid source, return\n    } else if (validSourceCount == 2) {\n      require(\n        prices[1].mul(1e18) / prices[0] <= maxPriceDeviation,\n        'too much deviation (2 valid sources)'\n      );\n      return prices[0].add(prices[1]) / 2; // if 2 valid sources, return average\n    } else if (validSourceCount == 3) {\n      bool midMinOk = prices[1].mul(1e18) / prices[0] <= maxPriceDeviation;\n      bool maxMidOk = prices[2].mul(1e18) / prices[1] <= maxPriceDeviation;\n      if (midMinOk && maxMidOk) {\n        return prices[1]; // if 3 valid sources, and each pair is within thresh, return median\n      } else if (midMinOk) {\n        return prices[0].add(prices[1]) / 2; // return average of pair within thresh\n      } else if (maxMidOk) {\n        return prices[1].add(prices[2]) / 2; // return average of pair within thresh\n      } else {\n        revert('too much deviation (3 valid sources)');\n      }\n    } else {\n      revert('more than 3 valid sources not supported');\n    }\n  }\n}"
    }
  ]
}