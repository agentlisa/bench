{
  "Title": "[G-06] Refactor external/internal functions to avoid unnecessary SLOAD",
  "Content": "The functions below read storage slots that are previously read in the functions that invoke them. We can refactor the external/internal functions to pass cached storage variables as stack variables and avoid the extra storage reads that would otherwise take place in the internal functions.\n\n### 1 Instance\n1. ### Refactor `stopRent()`, `stopRentBatch()` and `_removeHooks()` to avoid  `SLOAD` in `_removeHooks()`\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L194-#L365\n\nThe external functions `stopRent()`, `stopRentBatch()` reads the variable `STORE` from state but they also invoke function `_removeHooks()` which also read the variable `STORE` from state. We can a avoid an `SLOAD(Gwarmaccess)` in the `_removeHooks()` function if we cache the `STORE` state variable in the `stopRent()` and `stopRentBatch()` functions then pass the cached value as a parameter to the `_removeHooks()` function: The diff below shows how the code should be refactored: \n\n<details>\n\n```solidity\nfile: src/policies/Stop.sol\n\n194:    function _removeHooks(\n195:        Hook[] calldata hooks,\n196:        Item[] calldata rentalItems,\n197:        address rentalWallet\n198:    ) internal {\n199:        // Define hook target, item index, and item.\n200:        address target;\n201:        uint256 itemIndex;\n202:        Item memory item;\n203:\n204:        // Loop through each hook in the payload.\n205:        for (uint256 i = 0; i < hooks.length; ++i) {\n206:            // Get the hook address.\n207:            target = hooks[i].target;\n208:\n209:            // Check that the hook is reNFT-approved to execute on rental stop.\n210:            if (!STORE.hookOnStop(target)) {     //@audit STORE state variable read\n211:                revert Errors.Shared_DisabledHook(target);\n212:            }\n.\n.\n.\n250:    }\n\n\n\n265:    function stopRent(RentalOrder calldata order) external {\n.\n.\n.\n288:        if (order.hooks.length > 0) {\n289:            _removeHooks(order.hooks, order.items, order.rentalWallet); //@audit STORE state variable read in _removeHooks function\n290:        }\n291:\n292:        // Interaction: Transfer rentals from the renter back to lender.\n293:        _reclaimRentedItems(order);\n294:\n295:        // Interaction: Transfer ERC20 payments from the escrow contract to the respective recipients.\n296:        ESCRW.settlePayment(order);\n297:\n298:        // Interaction: Remove rentals from storage by computing the order hash.\n299:        STORE.removeRentals(     //@audit STORE state variable read\n300:            _deriveRentalOrderHash(order),\n301:            _convertToStatic(rentalAssetUpdates)\n302:        );\n303:\n304:        // Emit rental order stopped.\n305:        _emitRentalOrderStopped(order.seaportOrderHash, msg.sender);\n306:    }\n\n\n\n313:    function stopRentBatch(RentalOrder[] calldata orders) external {\n.\n.\n.\n348:            if (orders[i].hooks.length > 0) {\n349:                _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet); //@audit STORE state variable read in _removeHooks function\n350:            }\n351:\n352:            // Interaction: Transfer rental assets from the renter back to lender.\n353:            _reclaimRentedItems(orders[i]);\n354:\n355:            // Emit rental order stopped.\n356:            _emitRentalOrderStopped(orderHashes[i], msg.sender);\n357:        }\n358:\n359:        // Interaction: Transfer ERC20 payments from the escrow contract to the respective recipients.\n360:        ESCRW.settlePaymentBatch(orders);\n361:\n362:        // Interaction: Remove all rentals from storage.\n363:        STORE.removeRentalsBatch(orderHashes, _convertToStatic(rentalAssetUpdates)); //@audit STORE state variable read\n364:    }\n```\n```diff\ndiff --git a/src/policies/Stop.sol b/src/policies/Stop.sol\nindex ab240ba..cbc0d12 100644\n--- a/src/policies/Stop.sol\n+++ b/src/policies/Stop.sol\n@@ -194,7 +194,8 @@ contract Stop is Policy, Signer, Reclaimer, Accumulator {\n     function _removeHooks(\n         Hook[] calldata hooks,\n         Item[] calldata rentalItems,\n-        address rentalWallet\n+        address rentalWallet,\n+        Storage _store\n     ) internal {\n         // Define hook target, item index, and item.\n         address target;\n@@ -283,10 +284,10 @@ contract Stop is Policy, Signer, Reclaimer, Accumulator {\n                 );\n             }\n         }\n-\n+        Storage _store = STORE;\n         // Interaction: process hooks so they no longer exist for the renter.\n         if (order.hooks.length > 0) {\n-            _removeHooks(order.hooks, order.items, order.rentalWallet);\n+            _removeHooks(order.hooks, order.items, order.rentalWallet, _store);\n         }\n\n         // Interaction: Transfer rentals from the renter back to lender.\n@@ -296,7 +297,7 @@ contract Stop is Policy, Signer, Reclaimer, Accumulator {\n         ESCRW.settlePayment(order);\n\n         // Interaction: Remove rentals from storage by computing the order hash.\n-        STORE.removeRentals(\n+        _store.removeRentals(\n             _deriveRentalOrderHash(order),\n             _convertToStatic(rentalAssetUpdates)\n         );\n@@ -343,10 +344,10 @@ contract Stop is Policy, Signer, Reclaimer, Accumulator {\n\n             // Add the order hash to an array.\n             orderHashes[i] = _deriveRentalOrderHash(orders[i]);\n-\n+            Storage _store = STORE;\n             // Interaction: Process hooks so they no longer exist for the renter.\n             if (orders[i].hooks.length > 0) {\n-                _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet);\n+                _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet, _store);\n             }\n\n             // Interaction: Transfer rental assets from the renter back to lender.\n```\n</details>\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/policies/Stop.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {Enum} from \"@safe-contracts/common/Enum.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {ISafe} from \"@src/interfaces/ISafe.sol\";\nimport {IHook} from \"@src/interfaces/IHook.sol\";\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\nimport {Signer} from \"@src/packages/Signer.sol\";\nimport {Reclaimer} from \"@src/packages/Reclaimer.sol\";\nimport {Accumulator} from \"@src/packages/Accumulator.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\nimport {\n    Item,\n    RentalOrder,\n    Hook,\n    OrderType,\n    ItemType,\n    RentalId,\n    RentalAssetUpdate\n} from \"@src/libraries/RentalStructs.sol\";\n\n/**\n * @title Stop\n * @notice Acts as an interface for all behavior related to stoping a rental.\n */\ncontract Stop is Policy, Signer, Reclaimer, Accumulator {\n    using RentalUtils for Item;\n    using RentalUtils for Item[];\n    using RentalUtils for OrderType;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) Signer() Reclaimer() {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n        dependencies[1] = toKeycode(\"ESCRW\");\n        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](4);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.removeRentals.selector);\n        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.removeRentalsBatch.selector);\n        requests[2] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePayment.selector);\n        requests[3] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePaymentBatch.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Helper function to emit an event which signals a rental order has stopped.\n     *\n     * @param seaportOrderHash Order hash of the seaport order.\n     * @param stopper Address which stopped the rental order.\n     */\n    function _emitRentalOrderStopped(bytes32 seaportOrderHash, address stopper) internal {\n        // Wmit the event.\n        emit Events.RentalOrderStopped(seaportOrderHash, stopper);\n    }\n\n    /**\n     * @dev Validates that a rental order can be stopped. Whether an order\n     *      can be stopped is dependent on the type of order. BASE orders can\n     *      be stopped only when the rental has expired. PAY orders can be stopped\n     *      by the lender at any point in the time.\n     *\n     * @param orderType Order type of the rental order to stop.\n     * @param endTimestamp Timestamp that the rental will end.\n     * @param expectedLender Address of the initial lender in the order.\n     */\n    function _validateRentalCanBeStoped(\n        OrderType orderType,\n        uint256 endTimestamp,\n        address expectedLender\n    ) internal view {\n        // Determine if the order has expired.\n        bool hasExpired = endTimestamp <= block.timestamp;\n\n        // Determine if the fulfiller is the lender of the order.\n        bool isLender = expectedLender == msg.sender;\n\n        // BASE orders processing.\n        if (orderType.isBaseOrder()) {\n            // check that the period for the rental order has expired.\n            if (!hasExpired) {\n                revert Errors.StopPolicy_CannotStopOrder(block.timestamp, msg.sender);\n            }\n        }\n        // PAY order processing.\n        else if (orderType.isPayOrder()) {\n            // If the stopper is the lender, then it doesnt matter whether the rental\n            // has expired. But if the stopper is not the lender, then the rental must have expired.\n            if (!isLender && (!hasExpired)) {\n                revert Errors.StopPolicy_CannotStopOrder(block.timestamp, msg.sender);\n            }\n        }\n        // Revert if given an invalid order type.\n        else {\n            revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n        }\n    }\n\n    /**\n     * @dev Since the stop policy is an enabled Gnosis Safe module on all rental safes, it\n     *      can be used to execute a transaction directly from the rental safe which retrieves\n     *      the rented assets. This call bypasses the guard that prevents the assets from being\n     *      transferred.\n     *\n     * @param order Rental order to reclaim the items for.\n     */\n    function _reclaimRentedItems(RentalOrder memory order) internal {\n        // Transfer ERC721s from the renter back to lender.\n        bool success = ISafe(order.rentalWallet).execTransactionFromModule(\n            // Stop policy inherits the reclaimer package.\n            address(this),\n            // value.\n            0,\n            // The encoded call to the `reclaimRentalOrder` function.\n            abi.encodeWithSelector(this.reclaimRentalOrder.selector, order),\n            // Safe must delegate call to the stop policy so that it is the msg.sender.\n            Enum.Operation.DelegateCall\n        );\n\n        // Assert that the transfer back to the lender was successful.\n        if (!success) {\n            revert Errors.StopPolicy_ReclaimFailed();\n        }\n    }\n\n    /**\n     * @dev When a rental order is stopped, process each hook one by one but only if\n     *      the hook's status is set to execute on a rental stop.\n     *\n     * @param hooks        Array of hooks to process for the order.\n     * @param rentalItems  Array of rental items which are referenced by the hooks\n     * @param rentalWallet Address of the rental wallet which is the current owner\n     *                     of the rented assets.\n     */\n    function _removeHooks(\n        Hook[] calldata hooks,\n        Item[] calldata rentalItems,\n        address rentalWallet\n    ) internal {\n        // Define hook target, item index, and item.\n        address target;\n        uint256 itemIndex;\n        Item memory item;\n\n        // Loop through each hook in the payload.\n        for (uint256 i = 0; i < hooks.length; ++i) {\n            // Get the hook address.\n            target = hooks[i].target;\n\n            // Check that the hook is reNFT-approved to execute on rental stop.\n            if (!STORE.hookOnStop(target)) {\n                revert Errors.Shared_DisabledHook(target);\n            }\n\n            // Get the rental item index for this hook.\n            itemIndex = hooks[i].itemIndex;\n\n            // Get the rental item for this hook.\n            item = rentalItems[itemIndex];\n\n            // Make sure the item is a rented item.\n            if (!item.isRental()) {\n                revert Errors.Shared_NonRentalHookItem(itemIndex);\n            }\n\n            // Call the hook with data about the rented item.\n            try\n                IHook(target).onStop(\n                    rentalWallet,\n                    item.token,\n                    item.identifier,\n                    item.amount,\n                    hooks[i].extraData\n                )\n            {} catch Error(string memory revertReason) {\n                // Revert with reason given.\n                revert Errors.Shared_HookFailString(revertReason);\n            } catch Panic(uint256 errorCode) {\n                // Convert solidity panic code to string.\n                string memory stringErrorCode = LibString.toString(errorCode);\n\n                // Revert with panic code.\n                revert Errors.Shared_HookFailString(\n                    string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n                );\n            } catch (bytes memory revertData) {\n                // Fallback to an error that returns the byte data.\n                revert Errors.Shared_HookFailBytes(revertData);\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Stops a rental by providing a `RentalOrder` struct. This data does not\n     *         exist in protocol storage, only the hash of the rental order. However,\n     *         during rental creation, all data needed to construct the rental order\n     *         is emitted as an event. A check is then made to ensure that the passed\n     *         in rental order matches the hash of a rental order in storage.\n     *\n     * @param order Rental order to stop.\n     */\n    function stopRent(RentalOrder calldata order) external {\n        // Check that the rental can be stopped.\n        _validateRentalCanBeStoped(order.orderType, order.endTimestamp, order.lender);\n\n        // Create an accumulator which will hold all of the rental asset updates, consisting of IDs and\n        // the rented amount. From this point on, new memory cannot be safely allocated until the\n        // accumulator no longer needs to include elements.\n        bytes memory rentalAssetUpdates = new bytes(0);\n\n        // Check if each item in the order is a rental. If so, then generate the rental asset update.\n        // Memory will become safe again after this block.\n        for (uint256 i; i < order.items.length; ++i) {\n            if (order.items[i].isRental()) {\n                // Insert the rental asset update into the dynamic array.\n                _insert(\n                    rentalAssetUpdates,\n                    order.items[i].toRentalId(order.rentalWallet),\n                    order.items[i].amount\n                );\n            }\n        }\n\n        // Interaction: process hooks so they no longer exist for the renter.\n        if (order.hooks.length > 0) {\n            _removeHooks(order.hooks, order.items, order.rentalWallet);\n        }\n\n        // Interaction: Transfer rentals from the renter back to lender.\n        _reclaimRentedItems(order);\n\n        // Interaction: Transfer ERC20 payments from the escrow contract to the respective recipients.\n        ESCRW.settlePayment(order);\n\n        // Interaction: Remove rentals from storage by computing the order hash.\n        STORE.removeRentals(\n            _deriveRentalOrderHash(order),\n            _convertToStatic(rentalAssetUpdates)\n        );\n\n        // Emit rental order stopped.\n        _emitRentalOrderStopped(order.seaportOrderHash, msg.sender);\n    }\n\n    /**\n     * @notice Stops a batch of rentals by providing an array of `RentalOrder` structs.\n     *\n     * @param orders Array of rental orders to stop.\n     */\n    function stopRentBatch(RentalOrder[] calldata orders) external {\n        // Create an array of rental order hashes which will be removed from storage.\n        bytes32[] memory orderHashes = new bytes32[](orders.length);\n\n        // Create an accumulator which will hold all of the rental asset updates, consisting of IDs and\n        // the rented amount. From this point on, new memory cannot be safely allocated until the\n        // accumulator no longer needs to include elements.\n        bytes memory rentalAssetUpdates = new bytes(0);\n\n        // Process each rental order.\n        // Memory will become safe after this block.\n        for (uint256 i = 0; i < orders.length; ++i) {\n            // Check that the rental can be stopped.\n            _validateRentalCanBeStoped(\n                orders[i].orderType,\n                orders[i].endTimestamp,\n                orders[i].lender\n            );\n\n            // Check if each item in the order is a rental. If so, then generate the rental asset update.\n            for (uint256 j = 0; j < orders[i].items.length; ++j) {\n                // Insert the rental asset update into the dynamic array.\n                if (orders[i].items[j].isRental()) {\n                    _insert(\n                        rentalAssetUpdates,\n                        orders[i].items[j].toRentalId(orders[i].rentalWallet),\n                        orders[i].items[j].amount\n                    );\n                }\n            }\n\n            // Add the order hash to an array.\n            orderHashes[i] = _deriveRentalOrderHash(orders[i]);\n\n            // Interaction: Process hooks so they no longer exist for the renter.\n            if (orders[i].hooks.length > 0) {\n                _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet);\n            }\n\n            // Interaction: Transfer rental assets from the renter back to lender.\n            _reclaimRentedItems(orders[i]);\n\n            // Emit rental order stopped.\n            _emitRentalOrderStopped(orderHashes[i], msg.sender);\n        }\n\n        // Interaction: Transfer ERC20 payments from the escrow contract to the respective recipients.\n        ESCRW.settlePaymentBatch(orders);\n\n        // Interaction: Remove all rentals from storage.\n        STORE.removeRentalsBatch(orderHashes, _convertToStatic(rentalAssetUpdates));\n    }\n}"
    }
  ]
}