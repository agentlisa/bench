{
  "Title": "M-30: Deposits/Withdrawals/Orders will be canceled if created before feature is disabled and attempted to be executed after",
  "Content": "# Issue M-30: Deposits/Withdrawals/Orders will be canceled if created before feature is disabled and attempted to be executed after \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/124 \n\n## Found by \n0xdeadbeef, IllIllI, csanuragjain, rvierdiiev\n\n## Summary\n\nThe protocol has the ability to enable/disable operations such as deposits, withdrawals and orders. \n\nIf the the above operations are disabled:\n1. Users will not be able to create/cancel the operations\n2. Keepers will not be able to execute the operations\n\nHowever - on execution failure, cancellation will succeed even if the feature is disabled.\n\nTherefore - keepers executing operations that are disabled will cancel them and make the user pay execution fees. (loss of funds) \n \n\n## Vulnerability Detail\n\nLet us use deposits as an example. Other operations behave in a similar way. \n\nConsider the following scenario:\n1. Bob creates a deposit using `createDeposit`\n2. GMX disabled deposits because of maintenance.\n3. Keeper executed Bobs deposit\n4. Bobs deposit is cancelled and the execution fee is paid to the keeper from Bobs pocket.\n5. GMX finished maintenance and enables again the deposits\n\nExecution will fail in the following check:\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/DepositHandler.sol#L144-L150 \n\nThe revert will be caught in the catch statement and `_handleDepositError` will be called:\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/DepositHandler.sol#L102-L113\n\n`_handleDepositError` will call `DepositUtils.cancelDeposit` which does not have feature validation:\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/DepositHandler.sol#L181-L203\n\n## Impact\n\nUsers lose execution fee funds and have to deposit again.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFor each operation:\n1. add a customer error to catch and revert the feature disable reason, like empty price is caught: https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/DepositHandler.sol#L190\n2. Add the feature check in the internal `DepositUtils.cancelDeposit` functions \n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/commit/51d1a7f161ab1b5081dc7cc5172ae30dfa063e1f\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/exchange/DepositHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/GlobalReentrancyGuard.sol\";\n\nimport \"./ExchangeUtils.sol\";\nimport \"../role/RoleModule.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../feature/FeatureUtils.sol\";\n\nimport \"../market/Market.sol\";\nimport \"../market/MarketToken.sol\";\n\nimport \"../deposit/Deposit.sol\";\nimport \"../deposit/DepositVault.sol\";\nimport \"../deposit/DepositUtils.sol\";\nimport \"../deposit/ExecuteDepositUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleModule.sol\";\n\n// @title DepositHandler\n// @dev Contract to handle creation, execution and cancellation of deposits\ncontract DepositHandler is GlobalReentrancyGuard, RoleModule, OracleModule {\n    using Deposit for Deposit.Props;\n\n    EventEmitter public immutable eventEmitter;\n    DepositVault public immutable depositVault;\n    Oracle public immutable oracle;\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        DepositVault _depositVault,\n        Oracle _oracle\n    ) RoleModule(_roleStore) GlobalReentrancyGuard(_dataStore) {\n        eventEmitter = _eventEmitter;\n        depositVault = _depositVault;\n        oracle = _oracle;\n    }\n\n    // @dev creates a deposit in the deposit store\n    // @param account the depositing account\n    // @param params DepositUtils.CreateDepositParams\n    function createDeposit(\n        address account,\n        DepositUtils.CreateDepositParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createDepositFeatureDisabledKey(address(this)));\n\n        return DepositUtils.createDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            account,\n            params\n        );\n    }\n\n    // @dev cancels a deposit\n    // @param key the deposit key\n    function cancelDeposit(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Deposit.Props memory deposit = DepositStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelDepositFeatureDisabledKey(address(this)));\n\n        ExchangeUtils.validateRequestCancellation(\n            _dataStore,\n            deposit.updatedAtBlock(),\n            \"Deposit\"\n        );\n\n        DepositUtils.cancelDeposit(\n            _dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            deposit.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev executes a deposit\n    // @param key the key of the deposit to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleDepositError(\n                key,\n                startingGas,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev simulate execution of a deposit to check for any errors\n    // @param key the deposit key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteDeposit(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n\n        uint256 startingGas = gasleft();\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    }\n\n    // @dev executes a deposit\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the deposit\n    // @param startingGas the starting gas\n    function _executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper,\n        uint256 startingGas\n    ) external onlySelf {\n        FeatureUtils.validateFeature(dataStore, Keys.executeDepositFeatureDisabledKey(address(this)));\n\n        uint256[] memory minOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMinOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        uint256[] memory maxOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMaxOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        ExecuteDepositUtils.ExecuteDepositParams memory params = ExecuteDepositUtils.ExecuteDepositParams(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            oracle,\n            key,\n            minOracleBlockNumbers,\n            maxOracleBlockNumbers,\n            keeper,\n            startingGas\n        );\n\n        ExecuteDepositUtils.executeDeposit(params);\n    }\n\n    // @dev handle errors from deposits\n    // @param key the deposit key\n    // @param startingGas the starting gas of the txn\n    // @param reasonBytes the reason bytes of the error\n    function _handleDepositError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n        if (OracleUtils.isEmptyPriceError(errorSelector)) {\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n        DepositUtils.cancelDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            msg.sender,\n            startingGas,\n            reason,\n            reasonBytes\n        );\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/exchange/DepositHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/GlobalReentrancyGuard.sol\";\n\nimport \"./ExchangeUtils.sol\";\nimport \"../role/RoleModule.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../feature/FeatureUtils.sol\";\n\nimport \"../market/Market.sol\";\nimport \"../market/MarketToken.sol\";\n\nimport \"../deposit/Deposit.sol\";\nimport \"../deposit/DepositVault.sol\";\nimport \"../deposit/DepositUtils.sol\";\nimport \"../deposit/ExecuteDepositUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleModule.sol\";\n\n// @title DepositHandler\n// @dev Contract to handle creation, execution and cancellation of deposits\ncontract DepositHandler is GlobalReentrancyGuard, RoleModule, OracleModule {\n    using Deposit for Deposit.Props;\n\n    EventEmitter public immutable eventEmitter;\n    DepositVault public immutable depositVault;\n    Oracle public immutable oracle;\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        DepositVault _depositVault,\n        Oracle _oracle\n    ) RoleModule(_roleStore) GlobalReentrancyGuard(_dataStore) {\n        eventEmitter = _eventEmitter;\n        depositVault = _depositVault;\n        oracle = _oracle;\n    }\n\n    // @dev creates a deposit in the deposit store\n    // @param account the depositing account\n    // @param params DepositUtils.CreateDepositParams\n    function createDeposit(\n        address account,\n        DepositUtils.CreateDepositParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createDepositFeatureDisabledKey(address(this)));\n\n        return DepositUtils.createDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            account,\n            params\n        );\n    }\n\n    // @dev cancels a deposit\n    // @param key the deposit key\n    function cancelDeposit(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Deposit.Props memory deposit = DepositStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelDepositFeatureDisabledKey(address(this)));\n\n        ExchangeUtils.validateRequestCancellation(\n            _dataStore,\n            deposit.updatedAtBlock(),\n            \"Deposit\"\n        );\n\n        DepositUtils.cancelDeposit(\n            _dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            deposit.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev executes a deposit\n    // @param key the key of the deposit to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleDepositError(\n                key,\n                startingGas,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev simulate execution of a deposit to check for any errors\n    // @param key the deposit key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteDeposit(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n\n        uint256 startingGas = gasleft();\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    }\n\n    // @dev executes a deposit\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the deposit\n    // @param startingGas the starting gas\n    function _executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper,\n        uint256 startingGas\n    ) external onlySelf {\n        FeatureUtils.validateFeature(dataStore, Keys.executeDepositFeatureDisabledKey(address(this)));\n\n        uint256[] memory minOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMinOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        uint256[] memory maxOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMaxOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        ExecuteDepositUtils.ExecuteDepositParams memory params = ExecuteDepositUtils.ExecuteDepositParams(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            oracle,\n            key,\n            minOracleBlockNumbers,\n            maxOracleBlockNumbers,\n            keeper,\n            startingGas\n        );\n\n        ExecuteDepositUtils.executeDeposit(params);\n    }\n\n    // @dev handle errors from deposits\n    // @param key the deposit key\n    // @param startingGas the starting gas of the txn\n    // @param reasonBytes the reason bytes of the error\n    function _handleDepositError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n        if (OracleUtils.isEmptyPriceError(errorSelector)) {\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n        DepositUtils.cancelDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            msg.sender,\n            startingGas,\n            reason,\n            reasonBytes\n        );\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/exchange/DepositHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/GlobalReentrancyGuard.sol\";\n\nimport \"./ExchangeUtils.sol\";\nimport \"../role/RoleModule.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../feature/FeatureUtils.sol\";\n\nimport \"../market/Market.sol\";\nimport \"../market/MarketToken.sol\";\n\nimport \"../deposit/Deposit.sol\";\nimport \"../deposit/DepositVault.sol\";\nimport \"../deposit/DepositUtils.sol\";\nimport \"../deposit/ExecuteDepositUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleModule.sol\";\n\n// @title DepositHandler\n// @dev Contract to handle creation, execution and cancellation of deposits\ncontract DepositHandler is GlobalReentrancyGuard, RoleModule, OracleModule {\n    using Deposit for Deposit.Props;\n\n    EventEmitter public immutable eventEmitter;\n    DepositVault public immutable depositVault;\n    Oracle public immutable oracle;\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        DepositVault _depositVault,\n        Oracle _oracle\n    ) RoleModule(_roleStore) GlobalReentrancyGuard(_dataStore) {\n        eventEmitter = _eventEmitter;\n        depositVault = _depositVault;\n        oracle = _oracle;\n    }\n\n    // @dev creates a deposit in the deposit store\n    // @param account the depositing account\n    // @param params DepositUtils.CreateDepositParams\n    function createDeposit(\n        address account,\n        DepositUtils.CreateDepositParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createDepositFeatureDisabledKey(address(this)));\n\n        return DepositUtils.createDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            account,\n            params\n        );\n    }\n\n    // @dev cancels a deposit\n    // @param key the deposit key\n    function cancelDeposit(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Deposit.Props memory deposit = DepositStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelDepositFeatureDisabledKey(address(this)));\n\n        ExchangeUtils.validateRequestCancellation(\n            _dataStore,\n            deposit.updatedAtBlock(),\n            \"Deposit\"\n        );\n\n        DepositUtils.cancelDeposit(\n            _dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            deposit.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev executes a deposit\n    // @param key the key of the deposit to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleDepositError(\n                key,\n                startingGas,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev simulate execution of a deposit to check for any errors\n    // @param key the deposit key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteDeposit(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n\n        uint256 startingGas = gasleft();\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    }\n\n    // @dev executes a deposit\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the deposit\n    // @param startingGas the starting gas\n    function _executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper,\n        uint256 startingGas\n    ) external onlySelf {\n        FeatureUtils.validateFeature(dataStore, Keys.executeDepositFeatureDisabledKey(address(this)));\n\n        uint256[] memory minOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMinOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        uint256[] memory maxOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMaxOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        ExecuteDepositUtils.ExecuteDepositParams memory params = ExecuteDepositUtils.ExecuteDepositParams(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            oracle,\n            key,\n            minOracleBlockNumbers,\n            maxOracleBlockNumbers,\n            keeper,\n            startingGas\n        );\n\n        ExecuteDepositUtils.executeDeposit(params);\n    }\n\n    // @dev handle errors from deposits\n    // @param key the deposit key\n    // @param startingGas the starting gas of the txn\n    // @param reasonBytes the reason bytes of the error\n    function _handleDepositError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n        if (OracleUtils.isEmptyPriceError(errorSelector)) {\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n        DepositUtils.cancelDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            msg.sender,\n            startingGas,\n            reason,\n            reasonBytes\n        );\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/exchange/DepositHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/GlobalReentrancyGuard.sol\";\n\nimport \"./ExchangeUtils.sol\";\nimport \"../role/RoleModule.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../feature/FeatureUtils.sol\";\n\nimport \"../market/Market.sol\";\nimport \"../market/MarketToken.sol\";\n\nimport \"../deposit/Deposit.sol\";\nimport \"../deposit/DepositVault.sol\";\nimport \"../deposit/DepositUtils.sol\";\nimport \"../deposit/ExecuteDepositUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleModule.sol\";\n\n// @title DepositHandler\n// @dev Contract to handle creation, execution and cancellation of deposits\ncontract DepositHandler is GlobalReentrancyGuard, RoleModule, OracleModule {\n    using Deposit for Deposit.Props;\n\n    EventEmitter public immutable eventEmitter;\n    DepositVault public immutable depositVault;\n    Oracle public immutable oracle;\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        DepositVault _depositVault,\n        Oracle _oracle\n    ) RoleModule(_roleStore) GlobalReentrancyGuard(_dataStore) {\n        eventEmitter = _eventEmitter;\n        depositVault = _depositVault;\n        oracle = _oracle;\n    }\n\n    // @dev creates a deposit in the deposit store\n    // @param account the depositing account\n    // @param params DepositUtils.CreateDepositParams\n    function createDeposit(\n        address account,\n        DepositUtils.CreateDepositParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createDepositFeatureDisabledKey(address(this)));\n\n        return DepositUtils.createDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            account,\n            params\n        );\n    }\n\n    // @dev cancels a deposit\n    // @param key the deposit key\n    function cancelDeposit(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Deposit.Props memory deposit = DepositStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelDepositFeatureDisabledKey(address(this)));\n\n        ExchangeUtils.validateRequestCancellation(\n            _dataStore,\n            deposit.updatedAtBlock(),\n            \"Deposit\"\n        );\n\n        DepositUtils.cancelDeposit(\n            _dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            deposit.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev executes a deposit\n    // @param key the key of the deposit to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleDepositError(\n                key,\n                startingGas,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev simulate execution of a deposit to check for any errors\n    // @param key the deposit key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteDeposit(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n\n        uint256 startingGas = gasleft();\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    }\n\n    // @dev executes a deposit\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the deposit\n    // @param startingGas the starting gas\n    function _executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper,\n        uint256 startingGas\n    ) external onlySelf {\n        FeatureUtils.validateFeature(dataStore, Keys.executeDepositFeatureDisabledKey(address(this)));\n\n        uint256[] memory minOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMinOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        uint256[] memory maxOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMaxOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        ExecuteDepositUtils.ExecuteDepositParams memory params = ExecuteDepositUtils.ExecuteDepositParams(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            oracle,\n            key,\n            minOracleBlockNumbers,\n            maxOracleBlockNumbers,\n            keeper,\n            startingGas\n        );\n\n        ExecuteDepositUtils.executeDeposit(params);\n    }\n\n    // @dev handle errors from deposits\n    // @param key the deposit key\n    // @param startingGas the starting gas of the txn\n    // @param reasonBytes the reason bytes of the error\n    function _handleDepositError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n        if (OracleUtils.isEmptyPriceError(errorSelector)) {\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n        DepositUtils.cancelDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            msg.sender,\n            startingGas,\n            reason,\n            reasonBytes\n        );\n    }\n}"
    }
  ]
}