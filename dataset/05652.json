{
  "Title": "[M-02] If `dt` is not updated accurately, `timeWeightedWeeklyPositionInRangeConcLiquidity_` might be updated incorrectly",
  "Content": "\nIn the function `accrueConcentratedPositionTimeWeightedLiquidity`, inside the while block, `dt` is initialised as:\n\n        uint32 dt = uint32(\n           nextWeek < block.timestamp\n           ? nextWeek - time\n           : block.timestamp - time\n       );\n\n<https://github.com/code-423n4/2023-10-canto/blob/40edbe0c9558b478c84336aaad9b9626e5d99f34/canto_ambient/contracts/mixins/LiquidityMining.sol#L98-L102>\n\nIf `tickTracking.exitTimestamp != 0` then the following else block is executed on line 117:\n\n    else {\n       // Tick is no longer active\n       if (tickTracking.exitTimestamp < nextWeek) {\n          // Exit was in this week, continue with next tick\n          tickActiveEnd = tickTracking.exitTimestamp;\n          tickTrackingIndex++;\n          dt = tickActiveEnd - tickActiveStart;\n       } else {\n         // Exit was in next week, we need to consider the current tick there (i.e. not increase the index)\n         tickActiveEnd = nextWeek;\n        }\n     }\n\n<https://github.com/code-423n4/2023-10-canto/blob/40edbe0c9558b478c84336aaad9b9626e5d99f34/canto_ambient/contracts/mixins/LiquidityMining.sol#L117-L128>\n\n`dt` is now updated to `tickActiveEnd - tickActiveStart;` when `tickTracking.exitTimestamp < nextWeek` as seen in the if block of the outer else block above.\n\nBut, when `tickTracking.exitTimestamp > nextWeek`, in the inner else block the value of `dt` is not updated:\n\n     else {\n         // Exit was in next week, we need to consider the current tick there (i.e. not increase the index)\n         tickActiveEnd = nextWeek;\n         //@audit - No update on dt value\n        }\n\nInside this else block as well, `dt` must equal `tickActiveEnd - tickActiveStart;`, where `tickActiveEnd = nextWeek;`. Without this update, if `tickTracking.exitTimestamp > nextWeek`, then `dt = nextWeek - time` or `dt = block.timestamp - time` as it was declared initially. For example, let's say that it was the former, that is, `dt = nextWeek - time` (according to the initial declaration). Assume that `tickActiveStart = tickTracking.enterTimestamp` (this is possible when [tickTracking.enterTimestamp > time](https://github.com/code-423n4/2023-10-canto/blob/40edbe0c9558b478c84336aaad9b9626e5d99f34/canto_ambient/contracts/mixins/LiquidityMining.sol#L110-L113)). Had the else block above (check @audit tag), updated `dt`, then `dt = tickActiveEnd - tickActiveStart;` => `dt = nextWeek - tickTracking.enterTimestamp`\n\nSo, on comparing again, initially -> `dt = nextWeek - time` and had there been an update on `dt` at the audit tag, `dt` would now be -> `dt = nextWeek - tickTracking.enterTimestamp`. Note that here, `tickTracking.enterTimestamp > time` (check the above para). So, `nextWeek - tickTracking.enterTimestamp < nextWeek - time`. That means `dt` would be a smaller value had it been equal to `nextWeek - tickTracking.enterTimestamp`. But, since it's not updated, `dt` equals `nextWeek - time`, which is a bigger value.\n\n`dt` is used to increase the value of time (used as an iterator in while loop). Since `dt` is a bigger value than required, the number of iterations of the while loop would be less than what it should be. This means that fewer iterations would be used to update `timeWeightedWeeklyPositionInRangeConcLiquidity_` on line [129](https://github.com/code-423n4/2023-10-canto/blob/40edbe0c9558b478c84336aaad9b9626e5d99f34/canto_ambient/contracts/mixins/LiquidityMining.sol#L129)\n\n    timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][currWeek][i] +=\n                                (tickActiveEnd - tickActiveStart) * liquidity;\n\n`timeWeightedWeeklyPositionInRangeConcLiquidity_` is used to calculate the `rewardsToSend` value in `claimConcentratedRewards` function. If `timeWeightedWeeklyPositionInRangeConcLiquidity_` is incorrect, then the rewards to be sent to the user will be calculated incorrectly.\n\n<https://github.com/code-423n4/2023-10-canto/blob/40edbe0c9558b478c84336aaad9b9626e5d99f34/canto_ambient/contracts/mixins/LiquidityMining.sol#L181-L188>\n\n    uint256 overallInRangeLiquidity = timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][week];\n       if (overallInRangeLiquidity > 0) {\n          uint256 inRangeLiquidityOfPosition;\n          for (int24 j = lowerTick + 10; j <= upperTick - 10; ++j) {\n             inRangeLiquidityOfPosition += timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][week][j];\n           }\n           // Percentage of this weeks overall in range liquidity that was provided by the user times the overall weekly rewards\n           rewardsToSend += inRangeLiquidityOfPosition * concRewardPerWeek_[poolIdx][week] / overallInRangeLiquidity; //@audit - rewards to send will be less\n\nAlso, due to fewer number of iterations, `tickTrackingIndexAccruedUpTo_` might not be updated correctly.\n\n    if (tickTrackingIndex != origIndex) {\n      tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = tickTrackingIndex;\n    }\n\n### Proof of Concept\n\n        /// @notice Accrues the in-range time-weighted concentrated liquidity for a position by going over the tick entry / exit history\n        /// @dev Needs to be called whenever a position is modified\n        function accrueConcentratedPositionTimeWeightedLiquidity(\n            address payable owner,\n            bytes32 poolIdx,\n            int24 lowerTick,\n            int24 upperTick\n        ) internal {\n            RangePosition72 storage pos = lookupPosition(\n                owner,\n                poolIdx,\n                lowerTick,\n                upperTick\n            );\n            bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n            uint32 lastAccrued = timeWeightedWeeklyPositionConcLiquidityLastSet_[\n                poolIdx\n            ][posKey];\n            // Only set time on first call\n            if (lastAccrued != 0) {\n                uint256 liquidity = pos.liquidity_;\n                for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                    uint32 tickTrackingIndex = tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i];\n                    uint32 origIndex = tickTrackingIndex;\n                    uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                    uint32 time = lastAccrued;\n                    // Loop through all in-range time spans for the tick or up to the current time (if it is still in range)\n                    while (time < block.timestamp && tickTrackingIndex < numTickTracking) {\n                        TickTracking memory tickTracking = tickTracking_[poolIdx][i][tickTrackingIndex];\n                        uint32 currWeek = uint32((time / WEEK) * WEEK);\n                        uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                        uint32 dt = uint32(\n                            nextWeek < block.timestamp\n                                ? nextWeek - time\n                                : block.timestamp - time\n                        );\n                        uint32 tickActiveStart; // Timestamp to use for the liquidity addition\n                        uint32 tickActiveEnd;\n                        if (tickTracking.enterTimestamp < nextWeek) {\n                            // Tick was active before next week, need to add the liquidity\n                            if (tickTracking.enterTimestamp < time) {\n                                // Tick was already active when last claim happened, only accrue from last claim timestamp\n                                tickActiveStart = time;\n                            } else {\n                                // Tick has become active this week\n                                tickActiveStart = tickTracking.enterTimestamp;\n                            }\n                            if (tickTracking.exitTimestamp == 0) {\n                                // Tick still active, do not increase index because we need to continue from here\n                                tickActiveEnd = uint32(nextWeek < block.timestamp ? nextWeek : block.timestamp);\n                            } else {\n                                // Tick is no longer active\n                                if (tickTracking.exitTimestamp < nextWeek) {\n                                    // Exit was in this week, continue with next tick\n                                    tickActiveEnd = tickTracking.exitTimestamp;\n                                    tickTrackingIndex++;\n                                    dt = tickActiveEnd - tickActiveStart;\n                                } else {\n                                    // Exit was in next week, we need to consider the current tick there (i.e. not increase the index)\n                                    tickActiveEnd = nextWeek;\n                                }\n                            }\n                            timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][currWeek][i] +=\n                                (tickActiveEnd - tickActiveStart) * liquidity;\n                        }\n                        time += dt;\n                    }\n                    if (tickTrackingIndex != origIndex) {\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = tickTrackingIndex;\n                    }\n                }\n            } else {\n                for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                    uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                    if (numTickTracking > 0) {\n                        if (tickTracking_[poolIdx][i][numTickTracking - 1].exitTimestamp == 0) {\n                            // Tick currently active\n                            tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking - 1;\n                        } else {\n                            tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking;\n                        }\n                    }\n                }\n            }\n            timeWeightedWeeklyPositionConcLiquidityLastSet_[poolIdx][\n                posKey\n            ] = uint32(block.timestamp);\n        }\n\n### Recommended Mitigation Steps\n\nAdd the line `dt = tickActiveEnd - tickActiveStart` in the place of the @audit tag, as shown above.\n\n**[OpenCoreCH (Canto) confirmed and commented](https://github.com/code-423n4/2023-10-canto-findings/issues/290#issuecomment-1757581037):**\n > Note that if the mentioned `else` branch is reached, `dt` is necessarily set to `nextWeek - time`, it cannot be `block.timestamp - time` (if the tick was exited in the next week, the next week cannot be in the future and greater than the block timestamp). So the only possible difference is regarding `tickActiveStart`, namely when `tickActiveStart = tickTracking.enterTimestamp` (in the other case, when `tickActiveStart = time`, we have `dt = nextWeek - time = tickActiveEnd - tickActiveStart`).\n> \n> I agree with the warden that in this particular case, the logic for updating `dt` is different in the `if` and `else` branch, which should not be the case. However, I think the logic in the `if` branch is wrong, not in the `else`: We want to set `dt` such that the next `time` value is equal to `tickActiveEnd` (because we accrued up to `tickActiveEnd`). To achieve this in all cases, we need to set `dt = tickActiveEnd - time` in the `if` block. Otherwise, when `tickTracking.enterTimestamp > time` we only add the time where the tick was in range to `time` (but not the time before that where the tick was out of range). Because we are also increasing the tick tracking index, this should not cause any problems in practice (the next enter timestamp will be greater than `time` by definition and we will only start accruing from there on again), but I think it should still be changed.\n\n*Note: for full discussion, see [here](https://github.com/code-423n4/2023-10-canto-findings/issues/290)*.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-canto",
  "Code": [
    {
      "filename": "canto_ambient/contracts/mixins/LiquidityMining.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"./PositionRegistrar.sol\";\nimport \"./StorageLayout.sol\";\nimport \"./PoolRegistry.sol\";\n\n/* @title Liquidity mining mixin\n * @notice Contains the functions related to liquidity mining claiming. */\ncontract LiquidityMining is PositionRegistrar {\n    uint256 constant WEEK = 604800; // Week in seconds 604800\n\n    /// @notice Initialize the tick tracking for the first tick of a pool\n    function initTickTracking(bytes32 poolIdx, int24 tick) internal {\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][tick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the tick crossings\n    /// @dev Needs to be called whenever a tick is crossed\n    function crossTicks(\n        bytes32 poolIdx,\n        int24 exitTick,\n        int24 entryTick\n    ) internal {\n        uint256 numElementsExit = tickTracking_[poolIdx][exitTick].length;\n        tickTracking_[poolIdx][exitTick][numElementsExit - 1]\n            .exitTimestamp = uint32(block.timestamp);\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][entryTick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the global in-range time-weighted concentrated liquidity per week\n    /// @dev Needs to be called whenever the concentrated liquidity is modified (tick crossed, positions changed)\n    function accrueConcentratedGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalConcLiquidityLastSet_[\n            poolIdx\n        ];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.concLiq_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalConcLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    /// @notice Accrues the in-range time-weighted concentrated liquidity for a position by going over the tick entry / exit history\n    /// @dev Needs to be called whenever a position is modified\n    function accrueConcentratedPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick\n    ) internal {\n        RangePosition72 storage pos = lookupPosition(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint32 lastAccrued = timeWeightedWeeklyPositionConcLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = pos.liquidity_;\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 tickTrackingIndex = tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i];\n                uint32 origIndex = tickTrackingIndex;\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                uint32 time = lastAccrued;\n                // Loop through all in-range time spans for the tick or up to the current time (if it is still in range)\n                while (time < block.timestamp && tickTrackingIndex < numTickTracking) {\n                    TickTracking memory tickTracking = tickTracking_[poolIdx][i][tickTrackingIndex];\n                    uint32 currWeek = uint32((time / WEEK) * WEEK);\n                    uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                    uint32 dt = uint32(\n                        nextWeek < block.timestamp\n                            ? nextWeek - time\n                            : block.timestamp - time\n                    );\n                    uint32 tickActiveStart; // Timestamp to use for the liquidity addition\n                    uint32 tickActiveEnd;\n                    if (tickTracking.enterTimestamp < nextWeek) {\n                        // Tick was active before next week, need to add the liquidity\n                        if (tickTracking.enterTimestamp < time) {\n                            // Tick was already active when last claim happened, only accrue from last claim timestamp\n                            tickActiveStart = time;\n                        } else {\n                            // Tick has become active this week\n                            tickActiveStart = tickTracking.enterTimestamp;\n                        }\n                        if (tickTracking.exitTimestamp == 0) {\n                            // Tick still active, do not increase index because we need to continue from here\n                            tickActiveEnd = uint32(nextWeek < block.timestamp ? nextWeek : block.timestamp);\n                        } else {\n                            // Tick is no longer active\n                            if (tickTracking.exitTimestamp < nextWeek) {\n                                // Exit was in this week, continue with next tick\n                                tickActiveEnd = tickTracking.exitTimestamp;\n                                tickTrackingIndex++;\n                                dt = tickActiveEnd - tickActiveStart;\n                            } else {\n                                // Exit was in next week, we need to consider the current tick there (i.e. not increase the index)\n                                tickActiveEnd = nextWeek;\n                            }\n                        }\n                        timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][currWeek][i] +=\n                            (tickActiveEnd - tickActiveStart) * liquidity;\n                    }\n                    time += dt;\n                }\n                if (tickTrackingIndex != origIndex) {\n                    tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = tickTrackingIndex;\n                }\n            }\n        } else {\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                if (numTickTracking > 0) {\n                    if (tickTracking_[poolIdx][i][numTickTracking - 1].exitTimestamp == 0) {\n                        // Tick currently active\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking - 1;\n                    } else {\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking;\n                    }\n                }\n            }\n        }\n        timeWeightedWeeklyPositionConcLiquidityLastSet_[poolIdx][\n            posKey\n        ] = uint32(block.timestamp);\n    }\n\n    function claimConcentratedRewards(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick,\n        uint32[] memory weeksToClaim\n    ) internal {\n        accrueConcentratedPositionTimeWeightedLiquidity(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        CurveMath.CurveState memory curve = curves_[poolIdx];\n        // Need to do a global accrual in case the current tick was already in range for a long time without any modifications that triggered an accrual\n        accrueConcentratedGlobalTimeWeightedLiquidity(poolIdx, curve);\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint256 rewardsToSend;\n        for (uint256 i; i < weeksToClaim.length; ++i) {\n            uint32 week = weeksToClaim[i];\n            require(week + WEEK < block.timestamp, \"Week not over yet\");\n            require(\n                !concLiquidityRewardsClaimed_[poolIdx][posKey][week],\n                \"Already claimed\"\n            );\n            uint256 overallInRangeLiquidity = timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][week];\n            if (overallInRangeLiquidity > 0) {\n                uint256 inRangeLiquidityOfPosition;\n                for (int24 j = lowerTick + 10; j <= upperTick - 10; ++j) {\n                    inRangeLiquidityOfPosition += timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][week][j];\n                }\n                // Percentage of this weeks overall in range liquidity that was provided by the user times the overall weekly rewards\n                rewardsToSend += inRangeLiquidityOfPosition * concRewardPerWeek_[poolIdx][week] / overallInRangeLiquidity;\n            }\n            concLiquidityRewardsClaimed_[poolIdx][posKey][week] = true;\n        }\n        if (rewardsToSend > 0) {\n            (bool sent, ) = owner.call{value: rewardsToSend}(\"\");\n            require(sent, \"Sending rewards failed\");\n        }\n    }\n\n    function accrueAmbientGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalAmbLiquidityLastSet_[poolIdx];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.ambientSeeds_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalAmbLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalAmbLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    function accrueAmbientPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx\n    ) internal {\n        bytes32 posKey = encodePosKey(owner, poolIdx);\n        uint32 lastAccrued = timeWeightedWeeklyPositionAmbLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only init time on first call\n        if (lastAccrued != 0) {\n            AmbientPosition storage pos = lookupPosition(owner, poolIdx);\n            uint256 liquidity = pos.seeds_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyPositionAmbLiquidity_[poolIdx][posKey][\n                    currWeek\n                ] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyPositionAmbLiquidityLastSet_[poolIdx][\n            posKey\n        ] = uint32(block.timestamp);\n    }\n\n    function claimAmbientRewards(\n        address owner,\n        bytes32 poolIdx,\n        uint32[] memory weeksToClaim\n    ) internal {\n        CurveMath.CurveState memory curve = curves_[poolIdx];\n        accrueAmbientPositionTimeWeightedLiquidity(payable(owner), poolIdx);\n        accrueAmbientGlobalTimeWeightedLiquidity(poolIdx, curve);\n        bytes32 posKey = encodePosKey(owner, poolIdx);\n        uint256 rewardsToSend;\n        for (uint256 i; i < weeksToClaim.length; ++i) {\n            uint32 week = weeksToClaim[i];\n            require(week + WEEK < block.timestamp, \"Week not over yet\");\n            require(\n                !ambLiquidityRewardsClaimed_[poolIdx][posKey][week],\n                \"Already claimed\"\n            );\n            uint256 overallTimeWeightedLiquidity = timeWeightedWeeklyGlobalAmbLiquidity_[\n                    poolIdx\n                ][week];\n            if (overallTimeWeightedLiquidity > 0) {\n                uint256 rewardsForWeek = (timeWeightedWeeklyPositionAmbLiquidity_[\n                    poolIdx\n                ][posKey][week] * ambRewardPerWeek_[poolIdx][week]) /\n                    overallTimeWeightedLiquidity;\n                rewardsToSend += rewardsForWeek;\n            }\n            ambLiquidityRewardsClaimed_[poolIdx][posKey][week] = true;\n        }\n        if (rewardsToSend > 0) {\n            (bool sent, ) = owner.call{value: rewardsToSend}(\"\");\n            require(sent, \"Sending rewards failed\");\n        }\n    }\n}"
    },
    {
      "filename": "canto_ambient/contracts/mixins/LiquidityMining.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"./PositionRegistrar.sol\";\nimport \"./StorageLayout.sol\";\nimport \"./PoolRegistry.sol\";\n\n/* @title Liquidity mining mixin\n * @notice Contains the functions related to liquidity mining claiming. */\ncontract LiquidityMining is PositionRegistrar {\n    uint256 constant WEEK = 604800; // Week in seconds 604800\n\n    /// @notice Initialize the tick tracking for the first tick of a pool\n    function initTickTracking(bytes32 poolIdx, int24 tick) internal {\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][tick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the tick crossings\n    /// @dev Needs to be called whenever a tick is crossed\n    function crossTicks(\n        bytes32 poolIdx,\n        int24 exitTick,\n        int24 entryTick\n    ) internal {\n        uint256 numElementsExit = tickTracking_[poolIdx][exitTick].length;\n        tickTracking_[poolIdx][exitTick][numElementsExit - 1]\n            .exitTimestamp = uint32(block.timestamp);\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][entryTick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the global in-range time-weighted concentrated liquidity per week\n    /// @dev Needs to be called whenever the concentrated liquidity is modified (tick crossed, positions changed)\n    function accrueConcentratedGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalConcLiquidityLastSet_[\n            poolIdx\n        ];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.concLiq_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalConcLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    /// @notice Accrues the in-range time-weighted concentrated liquidity for a position by going over the tick entry / exit history\n    /// @dev Needs to be called whenever a position is modified\n    function accrueConcentratedPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick\n    ) internal {\n        RangePosition72 storage pos = lookupPosition(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint32 lastAccrued = timeWeightedWeeklyPositionConcLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = pos.liquidity_;\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 tickTrackingIndex = tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i];\n                uint32 origIndex = tickTrackingIndex;\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                uint32 time = lastAccrued;\n                // Loop through all in-range time spans for the tick or up to the current time (if it is still in range)\n                while (time < block.timestamp && tickTrackingIndex < numTickTracking) {\n                    TickTracking memory tickTracking = tickTracking_[poolIdx][i][tickTrackingIndex];\n                    uint32 currWeek = uint32((time / WEEK) * WEEK);\n                    uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                    uint32 dt = uint32(\n                        nextWeek < block.timestamp\n                            ? nextWeek - time\n                            : block.timestamp - time\n                    );\n                    uint32 tickActiveStart; // Timestamp to use for the liquidity addition\n                    uint32 tickActiveEnd;\n                    if (tickTracking.enterTimestamp < nextWeek) {\n                        // Tick was active before next week, need to add the liquidity\n                        if (tickTracking.enterTimestamp < time) {\n                            // Tick was already active when last claim happened, only accrue from last claim timestamp\n                            tickActiveStart = time;\n                        } else {\n                            // Tick has become active this week\n                            tickActiveStart = tickTracking.enterTimestamp;\n                        }\n                        if (tickTracking.exitTimestamp == 0) {\n                            // Tick still active, do not increase index because we need to continue from here\n                            tickActiveEnd = uint32(nextWeek < block.timestamp ? nextWeek : block.timestamp);\n                        } else {\n                            // Tick is no longer active\n                            if (tickTracking.exitTimestamp < nextWeek) {\n                                // Exit was in this week, continue with next tick\n                                tickActiveEnd = tickTracking.exitTimestamp;\n                                tickTrackingIndex++;\n                                dt = tickActiveEnd - tickActiveStart;\n                            } else {\n                                // Exit was in next week, we need to consider the current tick there (i.e. not increase the index)\n                                tickActiveEnd = nextWeek;\n                            }\n                        }\n                        timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][currWeek][i] +=\n                            (tickActiveEnd - tickActiveStart) * liquidity;\n                    }\n                    time += dt;\n                }\n                if (tickTrackingIndex != origIndex) {\n                    tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = tickTrackingIndex;\n                }\n            }\n        } else {\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                if (numTickTracking > 0) {\n                    if (tickTracking_[poolIdx][i][numTickTracking - 1].exitTimestamp == 0) {\n                        // Tick currently active\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking - 1;\n                    } else {\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking;\n                    }\n                }\n            }\n        }\n        timeWeightedWeeklyPositionConcLiquidityLastSet_[poolIdx][\n            posKey\n        ] = uint32(block.timestamp);\n    }\n\n    function claimConcentratedRewards(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick,\n        uint32[] memory weeksToClaim\n    ) internal {\n        accrueConcentratedPositionTimeWeightedLiquidity(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        CurveMath.CurveState memory curve = curves_[poolIdx];\n        // Need to do a global accrual in case the current tick was already in range for a long time without any modifications that triggered an accrual\n        accrueConcentratedGlobalTimeWeightedLiquidity(poolIdx, curve);\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint256 rewardsToSend;\n        for (uint256 i; i < weeksToClaim.length; ++i) {\n            uint32 week = weeksToClaim[i];\n            require(week + WEEK < block.timestamp, \"Week not over yet\");\n            require(\n                !concLiquidityRewardsClaimed_[poolIdx][posKey][week],\n                \"Already claimed\"\n            );\n            uint256 overallInRangeLiquidity = timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][week];\n            if (overallInRangeLiquidity > 0) {\n                uint256 inRangeLiquidityOfPosition;\n                for (int24 j = lowerTick + 10; j <= upperTick - 10; ++j) {\n                    inRangeLiquidityOfPosition += timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][week][j];\n                }\n                // Percentage of this weeks overall in range liquidity that was provided by the user times the overall weekly rewards\n                rewardsToSend += inRangeLiquidityOfPosition * concRewardPerWeek_[poolIdx][week] / overallInRangeLiquidity;\n            }\n            concLiquidityRewardsClaimed_[poolIdx][posKey][week] = true;\n        }\n        if (rewardsToSend > 0) {\n            (bool sent, ) = owner.call{value: rewardsToSend}(\"\");\n            require(sent, \"Sending rewards failed\");\n        }\n    }\n\n    function accrueAmbientGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalAmbLiquidityLastSet_[poolIdx];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.ambientSeeds_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalAmbLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalAmbLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    function accrueAmbientPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx\n    ) internal {\n        bytes32 posKey = encodePosKey(owner, poolIdx);\n        uint32 lastAccrued = timeWeightedWeeklyPositionAmbLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only init time on first call\n        if (lastAccrued != 0) {\n            AmbientPosition storage pos = lookupPosition(owner, poolIdx);\n            uint256 liquidity = pos.seeds_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyPositionAmbLiquidity_[poolIdx][posKey][\n                    currWeek\n                ] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyPositionAmbLiquidityLastSet_[poolIdx][\n            posKey\n        ] = uint32(block.timestamp);\n    }\n\n    function claimAmbientRewards(\n        address owner,\n        bytes32 poolIdx,\n        uint32[] memory weeksToClaim\n    ) internal {\n        CurveMath.CurveState memory curve = curves_[poolIdx];\n        accrueAmbientPositionTimeWeightedLiquidity(payable(owner), poolIdx);\n        accrueAmbientGlobalTimeWeightedLiquidity(poolIdx, curve);\n        bytes32 posKey = encodePosKey(owner, poolIdx);\n        uint256 rewardsToSend;\n        for (uint256 i; i < weeksToClaim.length; ++i) {\n            uint32 week = weeksToClaim[i];\n            require(week + WEEK < block.timestamp, \"Week not over yet\");\n            require(\n                !ambLiquidityRewardsClaimed_[poolIdx][posKey][week],\n                \"Already claimed\"\n            );\n            uint256 overallTimeWeightedLiquidity = timeWeightedWeeklyGlobalAmbLiquidity_[\n                    poolIdx\n                ][week];\n            if (overallTimeWeightedLiquidity > 0) {\n                uint256 rewardsForWeek = (timeWeightedWeeklyPositionAmbLiquidity_[\n                    poolIdx\n                ][posKey][week] * ambRewardPerWeek_[poolIdx][week]) /\n                    overallTimeWeightedLiquidity;\n                rewardsToSend += rewardsForWeek;\n            }\n            ambLiquidityRewardsClaimed_[poolIdx][posKey][week] = true;\n        }\n        if (rewardsToSend > 0) {\n            (bool sent, ) = owner.call{value: rewardsToSend}(\"\");\n            require(sent, \"Sending rewards failed\");\n        }\n    }\n}"
    },
    {
      "filename": "canto_ambient/contracts/mixins/LiquidityMining.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"./PositionRegistrar.sol\";\nimport \"./StorageLayout.sol\";\nimport \"./PoolRegistry.sol\";\n\n/* @title Liquidity mining mixin\n * @notice Contains the functions related to liquidity mining claiming. */\ncontract LiquidityMining is PositionRegistrar {\n    uint256 constant WEEK = 604800; // Week in seconds 604800\n\n    /// @notice Initialize the tick tracking for the first tick of a pool\n    function initTickTracking(bytes32 poolIdx, int24 tick) internal {\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][tick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the tick crossings\n    /// @dev Needs to be called whenever a tick is crossed\n    function crossTicks(\n        bytes32 poolIdx,\n        int24 exitTick,\n        int24 entryTick\n    ) internal {\n        uint256 numElementsExit = tickTracking_[poolIdx][exitTick].length;\n        tickTracking_[poolIdx][exitTick][numElementsExit - 1]\n            .exitTimestamp = uint32(block.timestamp);\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][entryTick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the global in-range time-weighted concentrated liquidity per week\n    /// @dev Needs to be called whenever the concentrated liquidity is modified (tick crossed, positions changed)\n    function accrueConcentratedGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalConcLiquidityLastSet_[\n            poolIdx\n        ];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.concLiq_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalConcLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    /// @notice Accrues the in-range time-weighted concentrated liquidity for a position by going over the tick entry / exit history\n    /// @dev Needs to be called whenever a position is modified\n    function accrueConcentratedPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick\n    ) internal {\n        RangePosition72 storage pos = lookupPosition(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint32 lastAccrued = timeWeightedWeeklyPositionConcLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = pos.liquidity_;\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 tickTrackingIndex = tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i];\n                uint32 origIndex = tickTrackingIndex;\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                uint32 time = lastAccrued;\n                // Loop through all in-range time spans for the tick or up to the current time (if it is still in range)\n                while (time < block.timestamp && tickTrackingIndex < numTickTracking) {\n                    TickTracking memory tickTracking = tickTracking_[poolIdx][i][tickTrackingIndex];\n                    uint32 currWeek = uint32((time / WEEK) * WEEK);\n                    uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                    uint32 dt = uint32(\n                        nextWeek < block.timestamp\n                            ? nextWeek - time\n                            : block.timestamp - time\n                    );\n                    uint32 tickActiveStart; // Timestamp to use for the liquidity addition\n                    uint32 tickActiveEnd;\n                    if (tickTracking.enterTimestamp < nextWeek) {\n                        // Tick was active before next week, need to add the liquidity\n                        if (tickTracking.enterTimestamp < time) {\n                            // Tick was already active when last claim happened, only accrue from last claim timestamp\n                            tickActiveStart = time;\n                        } else {\n                            // Tick has become active this week\n                            tickActiveStart = tickTracking.enterTimestamp;\n                        }\n                        if (tickTracking.exitTimestamp == 0) {\n                            // Tick still active, do not increase index because we need to continue from here\n                            tickActiveEnd = uint32(nextWeek < block.timestamp ? nextWeek : block.timestamp);\n                        } else {\n                            // Tick is no longer active\n                            if (tickTracking.exitTimestamp < nextWeek) {\n                                // Exit was in this week, continue with next tick\n                                tickActiveEnd = tickTracking.exitTimestamp;\n                                tickTrackingIndex++;\n                                dt = tickActiveEnd - tickActiveStart;\n                            } else {\n                                // Exit was in next week, we need to consider the current tick there (i.e. not increase the index)\n                                tickActiveEnd = nextWeek;\n                            }\n                        }\n                        timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][currWeek][i] +="
    }
  ]
}