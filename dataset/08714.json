{
  "Title": "[G-13] Constructor parameters should be avoided when possible",
  "Content": "\nConstructor parameters are expensive. The contract deployment will be cheaper in gas if they are hard coded instead of using constructor parameters. With the compilers parameters in `hardhat.config.ts`, deployment costs approximately `400` more gas per variable written via a constructor parameter.\n\n### Proof of Concept\n\nInstances include:\n\nYearnCurveVaultOperator.sol\n\n[eth = _eth](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L48)\n\n[withdrawer = _withdrawer](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L50)\n\n### Recommended Mitigation\n\nHardcode storage variables with their initial value instead of writing it during contract deployment with constructor parameters.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-06-nested-finance-contest",
  "Code": [
    {
      "filename": "contracts/operators/Yearn/YearnCurveVaultOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./../../Withdrawer.sol\";\nimport \"./YearnVaultStorage.sol\";\n\nimport \"./../../libraries/OperatorHelpers.sol\";\nimport \"./../../libraries/ExchangeHelpers.sol\";\nimport \"./../../interfaces/external/IWETH.sol\";\nimport \"../../libraries/StakingLPVaultHelpers.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./../../libraries/CurveHelpers/CurveHelpers.sol\";\nimport \"./../../interfaces/external/ICurvePool/ICurvePoolETH.sol\";\nimport \"./../../interfaces/external/IStakingVault/IYearnVault.sol\";\nimport \"./../../interfaces/external/ICurvePool/ICurvePoolNonETH.sol\";\n\n/// @title Yearn Curve Vault Operator\n/// @notice Deposit/Withdraw in a Yearn Curve vault.\ncontract YearnCurveVaultOperator {\n    YearnVaultStorage public immutable operatorStorage;\n\n    /// @dev ETH address\n    address public immutable eth;\n\n    /// @dev WETH contract\n    IWETH private immutable weth;\n\n    /// @dev Withdrawer\n    Withdrawer private immutable withdrawer;\n\n    constructor(\n        address[] memory vaults,\n        CurvePool[] memory pools,\n        Withdrawer _withdrawer,\n        address _eth,\n        address _weth\n    ) {\n        uint256 vaultsLength = vaults.length;\n        require(vaultsLength == pools.length, \"YCVO: INVALID_VAULTS_LENGTH\");\n        operatorStorage = new YearnVaultStorage();\n\n        for (uint256 i; i < vaultsLength; i++) {\n            operatorStorage.addVault(vaults[i], pools[i]);\n        }\n\n        operatorStorage.transferOwnership(msg.sender);\n\n        eth = _eth;\n        weth = IWETH(_weth);\n        withdrawer = _withdrawer;\n    }\n\n    /// @notice Add liquidity in a Curve pool that includes ETH,\n    ///         deposit the LP token in a Yearn vault and receive\n    ///         the Yearn vault shares\n    /// @param vault The Yearn vault address to deposit into\n    /// @param amount The amount of token to add liquidity\n    /// @param minVaultAmount The minimum of Yearn vault shares expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function depositETH(\n        address vault,\n        uint256 amount,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 ethBalanceBefore = weth.balanceOf(address(this));\n\n        ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer));\n\n        // withdraw ETH from WETH\n        withdrawer.withdraw(amount);\n\n        StakingLPVaultHelpers._addLiquidityAndDepositETH(\n            vault,\n            ICurvePoolETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            eth,\n            amount\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(address(weth)),\n            ethBalanceBefore,\n            amount,\n            IERC20(vault),\n            vaultBalanceBefore,\n            minVaultAmount\n        );\n    }\n\n    /// @notice Add liquidity in a Curve pool, deposit\n    ///         the LP token in a Yearn vault and receive\n    ///         the Yearn vault shares\n    /// @param vault The Yearn vault address to deposit into\n    /// @param token The token to add liquidity\n    /// @param amount The amount of token to add liquidity\n    /// @param minVaultAmount The minimum of Yearn vault shares expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function deposit(\n        address vault,\n        address token,\n        uint256 amount,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = IERC20(token).balanceOf(address(this));\n\n        StakingLPVaultHelpers._addLiquidityAndDeposit(\n            vault,\n            ICurvePoolNonETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            token,\n            amount\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(token),\n            tokenBalanceBefore,\n            amount,\n            IERC20(vault),\n            vaultBalanceBefore,\n            minVaultAmount\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove ETH liquidity from the Curve pool\n    ///         and receive one of the curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdrawETH(\n        address vault,\n        uint256 amount,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = weth.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity128(\n            vault,\n            amount,\n            ICurvePool(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            eth\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            IERC20(address(weth)),\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove the liquidity from the Curve pool\n    ///         (using int128 for the curvePool.remove_liquidity_one_coin\n    ///         coin index parameter) and receive one of the\n    ///         curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param outputToken Output token to receive\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw128(\n        address vault,\n        uint256 amount,\n        IERC20 outputToken,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = outputToken.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity128(\n            vault,\n            amount,\n            ICurvePool(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            address(outputToken)\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            outputToken,\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove the liquidity from the Curve pool\n    ///         (using uint256 for the curvePool.remove_liquidity_one_coin\n    ///         coin index parameter) and receive one of the\n    ///         curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param outputToken Output token to receive\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw256(\n        address vault,\n        uint256 amount,\n        IERC20 outputToken,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = outputToken.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity256(\n            vault,\n            amount,\n            ICurvePoolNonETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            address(outputToken)\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            outputToken,\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n}"
    },
    {
      "filename": "contracts/operators/Yearn/YearnCurveVaultOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./../../Withdrawer.sol\";\nimport \"./YearnVaultStorage.sol\";\n\nimport \"./../../libraries/OperatorHelpers.sol\";\nimport \"./../../libraries/ExchangeHelpers.sol\";\nimport \"./../../interfaces/external/IWETH.sol\";\nimport \"../../libraries/StakingLPVaultHelpers.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./../../libraries/CurveHelpers/CurveHelpers.sol\";\nimport \"./../../interfaces/external/ICurvePool/ICurvePoolETH.sol\";\nimport \"./../../interfaces/external/IStakingVault/IYearnVault.sol\";\nimport \"./../../interfaces/external/ICurvePool/ICurvePoolNonETH.sol\";\n\n/// @title Yearn Curve Vault Operator\n/// @notice Deposit/Withdraw in a Yearn Curve vault.\ncontract YearnCurveVaultOperator {\n    YearnVaultStorage public immutable operatorStorage;\n\n    /// @dev ETH address\n    address public immutable eth;\n\n    /// @dev WETH contract\n    IWETH private immutable weth;\n\n    /// @dev Withdrawer\n    Withdrawer private immutable withdrawer;\n\n    constructor(\n        address[] memory vaults,\n        CurvePool[] memory pools,\n        Withdrawer _withdrawer,\n        address _eth,\n        address _weth\n    ) {\n        uint256 vaultsLength = vaults.length;\n        require(vaultsLength == pools.length, \"YCVO: INVALID_VAULTS_LENGTH\");\n        operatorStorage = new YearnVaultStorage();\n\n        for (uint256 i; i < vaultsLength; i++) {\n            operatorStorage.addVault(vaults[i], pools[i]);\n        }\n\n        operatorStorage.transferOwnership(msg.sender);\n\n        eth = _eth;\n        weth = IWETH(_weth);\n        withdrawer = _withdrawer;\n    }\n\n    /// @notice Add liquidity in a Curve pool that includes ETH,\n    ///         deposit the LP token in a Yearn vault and receive\n    ///         the Yearn vault shares\n    /// @param vault The Yearn vault address to deposit into\n    /// @param amount The amount of token to add liquidity\n    /// @param minVaultAmount The minimum of Yearn vault shares expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function depositETH(\n        address vault,\n        uint256 amount,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 ethBalanceBefore = weth.balanceOf(address(this));\n\n        ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer));\n\n        // withdraw ETH from WETH\n        withdrawer.withdraw(amount);\n\n        StakingLPVaultHelpers._addLiquidityAndDepositETH(\n            vault,\n            ICurvePoolETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            eth,\n            amount\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(address(weth)),\n            ethBalanceBefore,\n            amount,\n            IERC20(vault),\n            vaultBalanceBefore,\n            minVaultAmount\n        );\n    }\n\n    /// @notice Add liquidity in a Curve pool, deposit\n    ///         the LP token in a Yearn vault and receive\n    ///         the Yearn vault shares\n    /// @param vault The Yearn vault address to deposit into\n    /// @param token The token to add liquidity\n    /// @param amount The amount of token to add liquidity\n    /// @param minVaultAmount The minimum of Yearn vault shares expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function deposit(\n        address vault,\n        address token,\n        uint256 amount,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = IERC20(token).balanceOf(address(this));\n\n        StakingLPVaultHelpers._addLiquidityAndDeposit(\n            vault,\n            ICurvePoolNonETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            token,\n            amount\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(token),\n            tokenBalanceBefore,\n            amount,\n            IERC20(vault),\n            vaultBalanceBefore,\n            minVaultAmount\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove ETH liquidity from the Curve pool\n    ///         and receive one of the curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdrawETH(\n        address vault,\n        uint256 amount,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = weth.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity128(\n            vault,\n            amount,\n            ICurvePool(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            eth\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            IERC20(address(weth)),\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove the liquidity from the Curve pool\n    ///         (using int128 for the curvePool.remove_liquidity_one_coin\n    ///         coin index parameter) and receive one of the\n    ///         curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param outputToken Output token to receive\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw128(\n        address vault,\n        uint256 amount,\n        IERC20 outputToken,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = outputToken.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity128(\n            vault,\n            amount,\n            ICurvePool(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            address(outputToken)\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            outputToken,\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove the liquidity from the Curve pool\n    ///         (using uint256 for the curvePool.remove_liquidity_one_coin\n    ///         coin index parameter) and receive one of the\n    ///         curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param outputToken Output token to receive\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw256(\n        address vault,\n        uint256 amount,\n        IERC20 outputToken,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = outputToken.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity256(\n            vault,\n            amount,\n            ICurvePoolNonETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            address(outputToken)\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            outputToken,\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n}"
    }
  ]
}