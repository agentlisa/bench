{
  "Title": "[N-04] Numeric values having to do with time should use time units for readability",
  "Content": "\nThere are [units](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units) for seconds, minutes, hours, days, and weeks\n\n*There is 1 instance of this issue:*\n\n```\nFile: contracts/VeAssetDepositor.sol   \\#1\n\n/// @audit 86400\n18:       uint256 private constant WEEK = 7 * 86400;\n```\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeAssetDepositor.sol#L18>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-vetoken",
  "Code": [
    {
      "filename": "contracts/VeAssetDepositor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IStaker.sol\";\nimport \"./Interfaces/ITokenMinter.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\ncontract VeAssetDepositor {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant WEEK = 7 * 86400;\n\n    uint256 public lockIncentive = 10; //incentive to users who spend gas to lock veAsset\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public immutable veAsset;\n    address public immutable escrow;\n    address public feeManager;\n    address public immutable staker;\n    address public immutable minter;\n    uint256 public incentiveVeAsset = 0;\n    uint256 public unlockTime;\n    uint256 private maxTime;\n\n    event FeeManagerUpdated(address indexed feeManager);\n    event FeesUpdated(uint256 lockIncentive);\n    event InitialLockCreated(uint256 veAssetBalanceStaker, uint256 unlockInWeeks);\n    event LockUpdated(uint256 veAssetBalanceStaker, uint256 unlockInWeeks);\n    event Deposited(address indexed user, uint256 amount, bool lock);\n\n    constructor(\n        address _staker,\n        address _minter,\n        address _veAsset,\n        address _escrow,\n        uint256 _maxTime\n    ) {\n        staker = _staker;\n        minter = _minter;\n        veAsset = _veAsset;\n        escrow = _escrow;\n        feeManager = msg.sender;\n        maxTime = _maxTime;\n    }\n\n    function setFeeManager(address _feeManager) external {\n        require(msg.sender == feeManager, \"!auth\");\n        feeManager = _feeManager;\n        emit FeeManagerUpdated(_feeManager);\n    }\n\n    function setFees(uint256 _lockIncentive) external {\n        require(msg.sender == feeManager, \"!auth\");\n\n        if (_lockIncentive >= 0 && _lockIncentive <= 30) {\n            lockIncentive = _lockIncentive;\n            emit FeesUpdated(_lockIncentive);\n        }\n    }\n\n    function initialLock() external {\n        require(msg.sender == feeManager, \"!auth\");\n\n        uint256 veVeAsset = IERC20(escrow).balanceOf(staker);\n        if (veVeAsset == 0) {\n            uint256 unlockAt = block.timestamp + maxTime;\n            uint256 unlockInWeeks = (unlockAt / WEEK) * WEEK;\n\n            //release old lock if exists\n            IStaker(staker).release();\n            //create new lock\n            uint256 veAssetBalanceStaker = IERC20(veAsset).balanceOf(staker);\n            IStaker(staker).createLock(veAssetBalanceStaker, unlockAt);\n            unlockTime = unlockInWeeks;\n            emit InitialLockCreated(veAssetBalanceStaker, unlockInWeeks);\n        }\n    }\n\n    //lock veAsset\n    function _lockVeAsset() internal {\n        uint256 veAssetBalance = IERC20(veAsset).balanceOf(address(this));\n        if (veAssetBalance > 0) {\n            IERC20(veAsset).safeTransfer(staker, veAssetBalance);\n        }\n\n        //increase ammount\n        uint256 veAssetBalanceStaker = IERC20(veAsset).balanceOf(staker);\n        if (veAssetBalanceStaker == 0) {\n            return;\n        }\n\n        //increase amount\n        IStaker(staker).increaseAmount(veAssetBalanceStaker);\n\n        uint256 unlockAt = block.timestamp + maxTime;\n        uint256 unlockInWeeks = (unlockAt / WEEK) * WEEK;\n\n        //increase time too if over 2 week buffer\n        if (unlockInWeeks.sub(unlockTime) > 2) {\n            IStaker(staker).increaseTime(unlockAt);\n            unlockTime = unlockInWeeks;\n        }\n        emit LockUpdated(veAssetBalanceStaker, unlockTime);\n    }\n\n    function lockVeAsset() external {\n        _lockVeAsset();\n\n        //mint incentives\n        if (incentiveVeAsset > 0) {\n            ITokenMinter(minter).mint(msg.sender, incentiveVeAsset);\n            incentiveVeAsset = 0;\n        }\n    }\n\n    //deposit veAsset for ve3Token\n    //can locking immediately or defer locking to someone else by paying a fee.\n    //while users can choose to lock or defer, this is mostly in place so that\n    //the vetoken reward contract isnt costly to claim rewards\n    function deposit(\n        uint256 _amount,\n        bool _lock,\n        address _stakeAddress\n    ) public {\n        require(_amount > 0, \"!>0\");\n\n        if (_lock) {\n            //lock immediately, transfer directly to staker to skip an erc20 transfer\n            IERC20(veAsset).safeTransferFrom(msg.sender, staker, _amount);\n            _lockVeAsset();\n            if (incentiveVeAsset > 0) {\n                //add the incentive tokens here so they can be staked together\n                _amount = _amount.add(incentiveVeAsset);\n                incentiveVeAsset = 0;\n            }\n        } else {\n            //move tokens here\n            IERC20(veAsset).safeTransferFrom(msg.sender, address(this), _amount);\n            //defer lock cost to another user\n            uint256 callIncentive = _amount.mul(lockIncentive).div(FEE_DENOMINATOR);\n            _amount = _amount.sub(callIncentive);\n\n            //add to a pool for lock caller\n            incentiveVeAsset = incentiveVeAsset.add(callIncentive);\n        }\n\n        bool depositOnly = _stakeAddress == address(0);\n        if (depositOnly) {\n            //mint for msg.sender\n            ITokenMinter(minter).mint(msg.sender, _amount);\n        } else {\n            //mint here\n            ITokenMinter(minter).mint(address(this), _amount);\n            //stake for msg.sender\n            IERC20(minter).safeApprove(_stakeAddress, _amount);\n            IRewards(_stakeAddress).stakeFor(msg.sender, _amount);\n        }\n\n        emit Deposited(msg.sender, _amount, _lock);\n    }\n\n    function deposit(uint256 _amount, bool _lock) external {\n        deposit(_amount, _lock, address(0));\n    }\n\n    function depositAll(bool _lock, address _stakeAddress) external {\n        uint256 veAssetBal = IERC20(veAsset).balanceOf(msg.sender);\n        deposit(veAssetBal, _lock, _stakeAddress);\n    }\n}"
    }
  ]
}