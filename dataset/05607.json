{
  "Title": "[M-02] Blocked accounts keep earning interest contrary to the WhitePaper",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/market/WildcatMarketConfig.sol#L79><br>\n<https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/market/WildcatMarketBase.sol#L178>\n\n### Proof of Concept\n\nLenders might be flagged as sanctioned by the ChainAnalysis oracle and these lenders can be blocked with the `nukeFromOrbit()` function or during a withdrawal execution. Both of these functions will call the internal `_blockAccount()` function.\n\n<https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/market/WildcatMarketBase.sol#L163>\n\n```solidity\n  function _blockAccount(MarketState memory state, address accountAddress) internal {\n\n      // skipped for brevity\n@>    if (scaledBalance > 0) {\n        account.scaledBalance = 0;\n        address escrow = IWildcatSanctionsSentinel(sentinel).createEscrow(\n          accountAddress,\n          borrower,\n          address(this)\n        );\n        emit Transfer(accountAddress, escrow, state.normalizeAmount(scaledBalance));\n@>      _accounts[escrow].scaledBalance += scaledBalance;\n        \n      // skipped for brevity\n    }\n  }\n```\n\nAs we can see above, if the user's scaled balance is greater than zero, an escrow contract is created for market tokens and the scaled token balance is transferred to the escrow contract.\n\nIn this protocol, there are two types of tokens: Underlying tokens, and market tokens. Market tokens are used for internal balance accounting and it is tracked with `scaled balances`. Underlying tokens are tracked with `normalized balances`. `scaleFactor` is the value that provides accumulated interest, and increment with every state update. `scaled balances` are multiplied by the `scaleFactor` and this will provide the `normalized balances`.\n\n- Scaled balances do earn interest.\n- Normalized balances do not earn interest.\n\nAccording to the protocol's [WhitePaper](https://github.com/wildcat-finance/wildcat-whitepaper/blob/main/whitepaper_v0.2.pdf) (*page 16*), blocked accounts should not earn interest. \n> \"The effect of this would be that an auxiliary escrow contract is deployed and the debt obligation of the borrower towards the lender is transferred to this new contract. ***Interest does not accrue within this contract*** *from the time the debt is transferred, and the borrower is expected to immediately return the balance of funds due up to that time to the escrow contract.\"*\n\nHowever, because the escrow contract holds scaled balances, these funds will keep earning interest. These scaled balances will be normalized when the funds are released (after the sanction is removed) according to that date's `scaleFactor`.\n\nNote: There might be two escrow contracts for the same lender if it is triggered during a withdrawal request. One with market tokens and the other with underlying tokens. The one with underlying tokens does not earn interest as expected. However, the escrow with the market tokens will still keep earning interest. I believe a blocked account earning interest contradicts the idea of the blocking.\n\n### Recommended Mitigation Steps\n\nI think all of the scaled balances should be normalized before transferring to the escrow contract to stop earning interest.\n\n### Assessed type\n\nContext\n\n**[laurenceday (Wildcat) commented](https://github.com/code-423n4/2023-10-wildcat-findings/issues/550#issuecomment-1803381902):**\n > Error in whitepaper. Acknowledged (and embarrassing) but won't fix.\n> \n> Needs to account for growth in the event that the sanction is performed by a hostile (read: non-Chainalysis) actor in control of the oracle. Borrowers affected by this that are concerned about growth potential can close the market.\n\n**[laurenceday (Wildcat) acknowledged](https://github.com/code-423n4/2023-10-wildcat-findings/issues/550#issuecomment-1810809810)**\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-10-wildcat-findings/issues/550).*\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/market/WildcatMarketConfig.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../interfaces/IWildcatSanctionsSentinel.sol';\nimport '../libraries/FeeMath.sol';\nimport '../libraries/SafeCastLib.sol';\nimport './WildcatMarketBase.sol';\n\ncontract WildcatMarketConfig is WildcatMarketBase {\n  using SafeCastLib for uint256;\n  using BoolUtils for bool;\n\n  // ===================================================================== //\n  //                      External Config Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Returns the maximum amount of underlying asset that can\n   *      currently be deposited to the market.\n   */\n  function maximumDeposit() external view returns (uint256) {\n    MarketState memory state = currentState();\n    return state.maximumDeposit();\n  }\n\n  /**\n   * @dev Returns the maximum supply the market can reach via\n   *      deposits (does not apply to interest accrual).\n   */\n  function maxTotalSupply() external view returns (uint256) {\n    return _state.maxTotalSupply;\n  }\n\n  /**\n   * @dev Returns the annual interest rate earned by lenders\n   *      in bips.\n   */\n  function annualInterestBips() external view returns (uint256) {\n    return _state.annualInterestBips;\n  }\n\n  function reserveRatioBips() external view returns (uint256) {\n    return _state.reserveRatioBips;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                  Sanctions                                 */\n  /* -------------------------------------------------------------------------- */\n\n  /// @dev Block a sanctioned account from interacting with the market\n  ///      and transfer its balance to an escrow contract.\n  // ******************************************************************\n  //          *  |\\**/|  *          *                                *\n  //          *  \\ == /  *          *                                *\n  //          *   | b|   *          *                                *\n  //          *   | y|   *          *                                *\n  //          *   \\ e/   *          *                                *\n  //          *    \\/    *          *                                *\n  //          *          *          *                                *\n  //          *          *          *                                *\n  //          *          *  |\\**/|  *                                *\n  //          *          *  \\ == /  *         _.-^^---....,,--       *\n  //          *          *   | b|   *    _--                  --_    *\n  //          *          *   | y|   *   <                        >)  *\n  //          *          *   \\ e/   *   |         O-FAC!          |  *\n  //          *          *    \\/    *    \\._                   _./   *\n  //          *          *          *       ```--. . , ; .--'''      *\n  //          *          *          *   üí∏        | |   |            *\n  //          *          *          *          .-=||  | |=-.    üí∏   *\n  //  üí∞ü§ëüí∞ *   üòÖ    *    üòê    *    üí∏    `-=#$%&%$#=-'         *\n  //   \\|/    *   /|\\    *   /|\\    *  üå™         | ;  :|    üå™       *\n  //   /\\     * üí∞/\\ üí∞ * üí∞/\\ üí∞ *    _____.,-#%&$@%#&#~,._____    *\n  // ******************************************************************\n  function nukeFromOrbit(address accountAddress) external nonReentrant {\n    if (!IWildcatSanctionsSentinel(sentinel).isSanctioned(borrower, accountAddress)) {\n      revert BadLaunchCode();\n    }\n    MarketState memory state = _getUpdatedState();\n    _blockAccount(state, accountAddress);\n    _writeState(state);\n  }\n\n  /**\n   * @dev Unblock an account that was previously sanctioned and blocked\n   *      and has since been removed from the sanctions list or had\n   *      their sanctioned status overridden by the borrower.\n   */\n  function stunningReversal(address accountAddress) external nonReentrant {\n    Account memory account = _accounts[accountAddress];\n    if (account.approval != AuthRole.Blocked) {\n      revert AccountNotBlocked();\n    }\n\n    if (IWildcatSanctionsSentinel(sentinel).isSanctioned(borrower, accountAddress)) {\n      revert NotReversedOrStunning();\n    }\n\n    account.approval = AuthRole.Null;\n    emit AuthorizationStatusUpdated(accountAddress, account.approval);\n\n    _accounts[accountAddress] = account;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                           External Config Setters                          */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Updates an account's authorization status based on whether the controller\n   *      has it marked as approved.\n   */\n  function updateAccountAuthorization(\n    address _account,\n    bool _isAuthorized\n  ) external onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    Account memory account = _getAccount(_account);\n    if (_isAuthorized) {\n      account.approval = AuthRole.DepositAndWithdraw;\n    } else {\n      account.approval = AuthRole.WithdrawOnly;\n    }\n    _accounts[_account] = account;\n    _writeState(state);\n    emit AuthorizationStatusUpdated(_account, account.approval);\n  }\n\n  /**\n   * @dev Sets the maximum total supply - this only limits deposits and\n   *      does not affect interest accrual.\n   *\n   *      Can not be set lower than current total supply.\n   */\n  function setMaxTotalSupply(uint256 _maxTotalSupply) external onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n\n    if (_maxTotalSupply < state.totalSupply()) {\n      revert NewMaxSupplyTooLow();\n    }\n\n    state.maxTotalSupply = _maxTotalSupply.toUint128();\n    _writeState(state);\n    emit MaxTotalSupplyUpdated(_maxTotalSupply);\n  }\n\n  /**\n   * @dev Sets the annual interest rate earned by lenders in bips.\n   */\n  function setAnnualInterestBips(uint16 _annualInterestBips) public onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n\n    if (_annualInterestBips > BIP) {\n      revert InterestRateTooHigh();\n    }\n\n    state.annualInterestBips = _annualInterestBips;\n    _writeState(state);\n    emit AnnualInterestBipsUpdated(_annualInterestBips);\n  }\n\n  /**\n   * @dev Adjust the market's reserve ratio.\n   *\n   *      If the new ratio is lower than the old ratio,\n   *      asserts that the market is not currently delinquent.\n   *\n   *      If the new ratio is higher than the old ratio,\n   *      asserts that the market will not become delinquent\n   *      because of the change.\n   */\n  function setReserveRatioBips(uint16 _reserveRatioBips) public onlyController nonReentrant {\n    if (_reserveRatioBips > BIP) {\n      revert ReserveRatioBipsTooHigh();\n    }\n\n    MarketState memory state = _getUpdatedState();\n\n    uint256 initialReserveRatioBips = state.reserveRatioBips;\n\n    if (_reserveRatioBips < initialReserveRatioBips) {\n      if (state.liquidityRequired() > totalAssets()) {\n        revert InsufficientReservesForOldLiquidityRatio();\n      }\n    }\n    state.reserveRatioBips = _reserveRatioBips;\n    if (_reserveRatioBips > initialReserveRatioBips) {\n      if (state.liquidityRequired() > totalAssets()) {\n        revert InsufficientReservesForNewLiquidityRatio();\n      }\n    }\n    _writeState(state);\n    emit ReserveRatioBipsUpdated(_reserveRatioBips);\n  }\n}"
    },
    {
      "filename": "src/market/WildcatMarketBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../libraries/FeeMath.sol';\nimport '../libraries/Withdrawal.sol';\nimport { queryName, querySymbol } from '../libraries/StringQuery.sol';\nimport '../interfaces/IMarketEventsAndErrors.sol';\nimport '../interfaces/IWildcatMarketController.sol';\nimport '../interfaces/IWildcatSanctionsSentinel.sol';\nimport { IERC20, IERC20Metadata } from '../interfaces/IERC20Metadata.sol';\nimport '../ReentrancyGuard.sol';\nimport '../libraries/BoolUtils.sol';\n\ncontract WildcatMarketBase is ReentrancyGuard, IMarketEventsAndErrors {\n  using WithdrawalLib for MarketState;\n  using SafeCastLib for uint256;\n  using MathUtils for uint256;\n  using BoolUtils for bool;\n\n  // ==================================================================== //\n  //                       Market Config (immutable)                       //\n  // ==================================================================== //\n\n  string public constant version = '1.0';\n\n  /// @dev Account with blacklist control, used for blocking sanctioned addresses.\n  address public immutable sentinel;\n\n  /// @dev Account with authority to borrow assets from the market.\n  address public immutable borrower;\n\n  /// @dev Account that receives protocol fees.\n  address public immutable feeRecipient;\n\n  /// @dev Protocol fee added to interest paid by borrower.\n  uint256 public immutable protocolFeeBips;\n\n  /// @dev Penalty fee added to interest earned by lenders, does not affect protocol fee.\n  uint256 public immutable delinquencyFeeBips;\n\n  /// @dev Time after which delinquency incurs penalty fee.\n  uint256 public immutable delinquencyGracePeriod;\n\n  /// @dev Address of the Market Controller.\n  address public immutable controller;\n\n  /// @dev Address of the underlying asset.\n  address public immutable asset;\n\n  /// @dev Time before withdrawal batches are processed.\n  uint256 public immutable withdrawalBatchDuration;\n\n  /// @dev Token decimals (same as underlying asset).\n  uint8 public immutable decimals;\n\n  /// @dev Token name (prefixed name of underlying asset).\n  string public name;\n\n  /// @dev Token symbol (prefixed symbol of underlying asset).\n  string public symbol;\n\n  // ===================================================================== //\n  //                             Market State                               //\n  // ===================================================================== //\n\n  MarketState internal _state;\n\n  mapping(address => Account) internal _accounts;\n\n  WithdrawalData internal _withdrawalData;\n\n  // ===================================================================== //\n  //                             Constructor                               //\n  // ===================================================================== //\n\n  constructor() {\n    MarketParameters memory parameters = IWildcatMarketController(msg.sender).getMarketParameters();\n\n    if ((parameters.protocolFeeBips > 0).and(parameters.feeRecipient == address(0))) {\n      revert FeeSetWithoutRecipient();\n    }\n    if (parameters.annualInterestBips > BIP) {\n      revert InterestRateTooHigh();\n    }\n    if (parameters.reserveRatioBips > BIP) {\n      revert ReserveRatioBipsTooHigh();\n    }\n    if (parameters.protocolFeeBips > BIP) {\n      revert InterestFeeTooHigh();\n    }\n    if (parameters.delinquencyFeeBips > BIP) {\n      revert PenaltyFeeTooHigh();\n    }\n\n    // Set asset metadata\n    asset = parameters.asset;\n    name = string.concat(parameters.namePrefix, queryName(parameters.asset));\n    symbol = string.concat(parameters.symbolPrefix, querySymbol(parameters.asset));\n    decimals = IERC20Metadata(parameters.asset).decimals();\n\n    _state = MarketState({\n      isClosed: false,\n      maxTotalSupply: parameters.maxTotalSupply,\n      accruedProtocolFees: 0,\n      normalizedUnclaimedWithdrawals: 0,\n      scaledTotalSupply: 0,\n      scaledPendingWithdrawals: 0,\n      pendingWithdrawalExpiry: 0,\n      isDelinquent: false,\n      timeDelinquent: 0,\n      annualInterestBips: parameters.annualInterestBips,\n      reserveRatioBips: parameters.reserveRatioBips,\n      scaleFactor: uint112(RAY),\n      lastInterestAccruedTimestamp: uint32(block.timestamp)\n    });\n\n    sentinel = parameters.sentinel;\n    borrower = parameters.borrower;\n    controller = parameters.controller;\n    feeRecipient = parameters.feeRecipient;\n    protocolFeeBips = parameters.protocolFeeBips;\n    delinquencyFeeBips = parameters.delinquencyFeeBips;\n    delinquencyGracePeriod = parameters.delinquencyGracePeriod;\n    withdrawalBatchDuration = parameters.withdrawalBatchDuration;\n  }\n\n  // ===================================================================== //\n  //                              Modifiers                                //\n  // ===================================================================== //\n\n  modifier onlyBorrower() {\n    if (msg.sender != borrower) revert NotApprovedBorrower();\n    _;\n  }\n\n  modifier onlyController() {\n    if (msg.sender != controller) revert NotController();\n    _;\n  }\n\n  // ===================================================================== //\n  //                       Internal State Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Retrieve an account from storage.\n   *\n   *      Reverts if account is blocked.\n   */\n  function _getAccount(address accountAddress) internal view returns (Account memory account) {\n    account = _accounts[accountAddress];\n    if (account.approval == AuthRole.Blocked) {\n      revert AccountBlacklisted();\n    }\n  }\n\n  /**\n   * @dev Block an account and transfer its balance of market tokens\n   *      to an escrow contract.\n   *\n   *      If the account is already blocked, this function does nothing.\n   */\n  function _blockAccount(MarketState memory state, address accountAddress) internal {\n    Account memory account = _accounts[accountAddress];\n    if (account.approval != AuthRole.Blocked) {\n      uint104 scaledBalance = account.scaledBalance;\n      account.approval = AuthRole.Blocked;\n      emit AuthorizationStatusUpdated(accountAddress, AuthRole.Blocked);\n\n      if (scaledBalance > 0) {\n        account.scaledBalance = 0;\n        address escrow = IWildcatSanctionsSentinel(sentinel).createEscrow(\n          accountAddress,\n          borrower,\n          address(this)\n        );\n        emit Transfer(accountAddress, escrow, state.normalizeAmount(scaledBalance));\n        _accounts[escrow].scaledBalance += scaledBalance;\n        emit SanctionedAccountAssetsSentToEscrow(\n          accountAddress,\n          escrow,\n          state.normalizeAmount(scaledBalance)\n        );\n      }\n      _accounts[accountAddress] = account;\n    }\n  }\n\n  /**\n   * @dev Retrieve an account from storage and assert that it has at\n   *      least the required role.\n   *\n   *      If the account's role is not set, queries the controller to\n   *      determine if it is an approved lender; if it is, its role\n   *      is initialized to DepositAndWithdraw.\n   */\n  function _getAccountWithRole(\n    address accountAddress,\n    AuthRole requiredRole\n  ) internal returns (Account memory account) {\n    account = _getAccount(accountAddress);\n    // If account role is null, see if it is authorized on controller.\n    if (account.approval == AuthRole.Null) {\n      if (IWildcatMarketController(controller).isAuthorizedLender(accountAddress)) {\n        account.approval = AuthRole.DepositAndWithdraw;\n        emit AuthorizationStatusUpdated(accountAddress, AuthRole.DepositAndWithdraw);\n      }\n    }\n    // If account role is insufficient, revert.\n    if (uint256(account.approval) < uint256(requiredRole)) {\n      revert NotApprovedLender();\n    }\n  }\n\n  // ===================================================================== //\n  //                       External State Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Returns the amount of underlying assets the borrower is obligated\n   *      to maintain in the market to avoid delinquency.\n   */\n  function coverageLiquidity() external view nonReentrantView returns (uint256) {\n    return currentState().liquidityRequired();\n  }\n\n  /**\n   * @dev Returns the scale factor (in ray) used to convert scaled balances\n   *      to normalized balances.\n   */\n  function scaleFactor() external view nonReentrantView returns (uint256) {\n    return currentState().scaleFactor;\n  }\n\n  /**\n   * @dev Total balance in underlying asset.\n   */\n  function totalAssets() public view returns (uint256) {\n    return IERC20(asset).balanceOf(address(this));\n  }\n\n  /**\n   * @dev Returns the amount of underlying assets the borrower is allowed\n   *      to borrow.\n   *\n   *      This is the balance of underlying assets minus:\n   *      - pending (unpaid) withdrawals\n   *      - paid withdrawals\n   *      - reserve ratio times the portion of the supply not pending withdrawal\n   *      - protocol fees\n   */\n  function borrowableAssets() external view nonReentrantView returns (uint256) {\n    return currentState().borrowableAssets(totalAssets());\n  }\n\n  /**\n   * @dev Returns the amount of protocol fees (in underlying asset amount)\n   *      that have accrued and are pending withdrawal.\n   */\n  function accruedProtocolFees() external view nonReentrantView returns (uint256) {\n    return currentState().accruedProtocolFees;\n  }\n\n  /**\n   * @dev Returns the state of the market as of the last update.\n   */\n  function previousState() external view returns (MarketState memory) {\n    return _state;\n  }\n\n  /**\n   * @dev Return the state the market would have at the current block after applying\n   *      interest and fees accrued since the last update and processing the pending\n   *      withdrawal batch if it is expired.\n   */\n  function currentState() public view nonReentrantView returns (MarketState memory state) {\n    (state, , ) = _calculateCurrentState();\n  }\n\n  /**\n   * @dev Returns the scaled total supply the vaut would have at the current block\n   *      after applying interest and fees accrued since the last update and burning\n   *      market tokens for the pending withdrawal batch if it is expired.\n   */\n  function scaledTotalSupply() external view nonReentrantView returns (uint256) {\n    return currentState().scaledTotalSupply;\n  }\n\n  /**\n   * @dev Returns the scaled balance of `account`\n   */\n  function scaledBalanceOf(address account) external view nonReentrantView returns (uint256) {\n    return _accounts[account].scaledBalance;\n  }\n\n  /**\n   * @dev Returns current role of `account`.\n   */\n  function getAccountRole(address account) external view nonReentrantView returns (AuthRole) {\n    return _accounts[account].approval;\n  }\n\n  /**\n   * @dev Returns the amount of protocol fees that are currently\n   *      withdrawable by the fee recipient.\n   */\n  function withdrawableProtocolFees() external view returns (uint128) {\n    return currentState().withdrawableProtocolFees(totalAssets());\n  }\n\n  /**\n   * @dev Calculate effective interest rate currently paid by borrower.\n   *      Borrower pays base APR, protocol fee (on base APR) and delinquency\n   *      fee (if delinquent beyond grace period).\n   *\n   * @return apr paid by borrower in ray\n   */\n  function effectiveBorrowerAPR() external view returns (uint256) {\n    MarketState memory state = currentState();\n    // apr + (apr * protocolFee)\n    uint256 apr = MathUtils.bipToRay(state.annualInterestBips).bipMul(BIP + protocolFeeBips);\n    if (state.timeDelinquent > delinquencyGracePeriod) {\n      apr += MathUtils.bipToRay(delinquencyFeeBips);\n    }\n    return apr;\n  }\n\n  /**\n   * @dev Calculate effective interest rate currently earned by lenders.\n   *     Lenders earn base APR and delinquency fee (if delinquent beyond grace period)\n   *\n   * @return apr earned by lender in ray\n   */\n  function effectiveLenderAPR() external view returns (uint256) {\n    MarketState memory state = currentState();\n    uint256 apr = state.annualInterestBips;\n    if (state.timeDelinquent > delinquencyGracePeriod) {\n      apr += delinquencyFeeBips;\n    }\n    return MathUtils.bipToRay(apr);\n  }\n\n  // /*//////////////////////////////////////////////////////////////\n  //                     Internal State Handlers\n  // //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @dev Returns cached MarketState after accruing interest and delinquency / protocol fees\n   *      and processing expired withdrawal batch, if any.\n   *\n   *      Used by functions that make additional changes to `state`.\n   *\n   *      NOTE: Returned `state` does not match `_state` if interest is accrued\n   *            Calling function must update `_state` or revert.\n   *\n   * @return state Market state after interest is accrued.\n   */\n  function _getUpdatedState() internal returns (MarketState memory state) {\n    state = _state;\n    // Handle expired withdrawal batch\n    if (state.hasPendingExpiredBatch()) {\n      uint256 expiry = state.pendingWithdrawalExpiry;\n      // Only accrue interest if time has passed since last update.\n      // This will only be false if withdrawalBatchDuration is 0.\n      if (expiry != state.lastInterestAccruedTimestamp) {\n        (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n          .updateScaleFactorAndFees(\n            protocolFeeBips,\n            delinquencyFeeBips,\n            delinquencyGracePeriod,\n            expiry\n          );\n        emit ScaleFactorUpdated(state.scaleFactor, baseInterestRay, delinquencyFeeRay, protocolFee);\n      }\n      _processExpiredWithdrawalBatch(state);\n    }\n    // Apply interest and fees accrued since last update (expiry or previous tx)\n    if (block.timestamp != state.lastInterestAccruedTimestamp) {\n      (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n        .updateScaleFactorAndFees(\n          protocolFeeBips,\n          delinquencyFeeBips,\n          delinquencyGracePeriod,\n          block.timestamp\n        );\n      emit ScaleFactorUpdated(state.scaleFactor, baseInterestRay, delinquencyFeeRay, protocolFee);\n    }\n  }\n\n  /**\n   * @dev Calculate the current state, applying fees and interest accrued since\n   *      the last state update as well as the effects of withdrawal batch expiry\n   *      on the market state.\n   *      Identical to _getUpdatedState() except it does not modify storage or\n   *      or emit events.\n   *      Returns expired batch data, if any, so queries against batches have\n   *      access to the most recent data.\n   */\n  function _calculateCurrentState()\n    internal\n    view\n    returns (\n      MarketState memory state,\n      uint32 expiredBatchExpiry,\n      WithdrawalBatch memory expiredBatch\n    )\n  {\n    state = _state;\n    // Handle expired withdrawal batch\n    if (state.hasPendingExpiredBatch()) {\n      expiredBatchExpiry = state.pendingWithdrawalExpiry;\n      // Only accrue interest if time has passed since last update.\n      // This will only be false if withdrawalBatchDuration is 0.\n      if (expiredBatchExpiry != state.lastInterestAccruedTimestamp) {\n        state.updateScaleFactorAndFees(\n          protocolFeeBips,\n          delinquencyFeeBips,\n          delinquencyGracePeriod,\n          expiredBatchExpiry\n        );\n      }\n\n      expiredBatch = _withdrawalData.batches[expiredBatchExpiry];\n      uint256 availableLiquidity = expiredBatch.availableLiquidityForPendingBatch(\n        state,\n        totalAssets()\n      );\n      if (availableLiquidity > 0) {\n        _applyWithdrawalBatchPaymentView(expiredBatch, state, availableLiquidity);\n      }\n      state.pendingWithdrawalExpiry = 0;\n    }\n\n    if (state.lastInterestAccruedTimestamp != block.timestamp) {\n      state.updateScaleFactorAndFees(\n        protocolFeeBips,\n        delinquencyFeeBips,\n        delinquencyGracePeriod,\n        block.timestamp\n      );\n    }\n  }\n\n  /**\n   * @dev Writes the cached MarketState to storage and emits an event.\n   *      Used at the end of all functions which modify `state`.\n   */\n  function _writeState(MarketState memory state) internal {\n    bool isDelinquent = state.liquidityRequired() > totalAssets();\n    state.isDelinquent = isDelinquent;\n    _state = state;\n    emit StateUpdated(state.scaleFactor, isDelinquent);\n  }\n\n  /**\n   * @dev Handles an expired withdrawal batch:\n   *      - Retrieves the amount of underlying assets that can be used to pay for the batch.\n   *      - If the amount is sufficient to pay the full amount owed to the batch, the batch\n   *        is closed and the total withdrawal amount is reserved.\n   *      - If the amount is insufficient to pay the full amount owed to the batch, the batch\n   *        is recorded as an unpaid batch and the available assets are reserved.\n   *      - The assets reserved for the batch are scaled by the current scale factor and that\n   *        amount of scaled tokens is burned, ensuring borrowers do not continue paying interest\n   *        on withdrawn assets.\n   */\n  function _processExpiredWithdrawalBatch(MarketState memory state) internal {\n    uint32 expiry = state.pendingWithdrawalExpiry;\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n    // Burn as much of the withdrawal batch as possible with available liquidity.\n    uint256 availableLiquidity = batch.availableLiquidityForPendingBatch(state, totalAssets());\n    if (availableLiquidity > 0) {\n      _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n    }\n\n    emit WithdrawalBatchExpired(\n      expiry,\n      batch.scaledTotalAmount,\n      batch.scaledAmountBurned,\n      batch.normalizedAmountPaid\n    );\n\n    if (batch.scaledAmountBurned < batch.scaledTotalAmount) {\n      _withdrawalData.unpaidBatches.push(expiry);\n    } else {\n      emit WithdrawalBatchClosed(expiry);\n    }\n\n    state.pendingWithdrawalExpiry = 0;\n\n    _withdrawalData.batches[expiry] = batch;\n  }\n\n  /**\n   * @dev Process withdrawal payment, burning market tokens and reserving\n   *      underlying assets so they are only available for withdrawals.\n   */\n  function _applyWithdrawalBatchPayment(\n    WithdrawalBatch memory batch,\n    MarketState memory state,\n    uint32 expiry,\n    uint256 availableLiquidity\n  ) internal {\n    uint104 scaledAvailableLiquidity = state.scaleAmount(availableLiquidity).toUint104();\n    uint104 scaledAmountOwed = batch.scaledTotalAmount - batch.scaledAmountBurned;\n    // Do nothing if batch is already paid\n    if (scaledAmountOwed == 0) {\n      return;\n    }\n    uint104 scaledAmountBurned = uint104(MathUtils.min(scaledAvailableLiquidity, scaledAmountOwed));\n    uint128 normalizedAmountPaid = state.normalizeAmount(scaledAmountBurned).toUint128();\n\n    batch.scaledAmountBurned += scaledAmountBurned;\n    batch.normalizedAmountPaid += normalizedAmountPaid;\n    state.scaledPendingWithdrawals -= scaledAmountBurned;\n\n    // Update normalizedUnclaimedWithdrawals so the tokens are only accessible for withdrawals.\n    state.normalizedUnclaimedWithdrawals += normalizedAmountPaid;\n\n    // Burn market tokens to stop interest accrual upon withdrawal payment.\n    state.scaledTotalSupply -= scaledAmountBurned;\n\n    // Emit transfer for external trackers to indicate burn.\n    emit Transfer(address(this), address(0), normalizedAmountPaid);\n    emit WithdrawalBatchPayment(expiry, scaledAmountBurned, normalizedAmountPaid);\n  }\n\n  function _applyWithdrawalBatchPaymentView(\n    WithdrawalBatch memory batch,\n    MarketState memory state,\n    uint256 availableLiquidity\n  ) internal pure {\n    uint104 scaledAvailableLiquidity = state.scaleAmount(availableLiquidity).toUint104();\n    uint104 scaledAmountOwed = batch.scaledTotalAmount - batch.scaledAmountBurned;\n    // Do nothing if batch is already paid\n    if (scaledAmountOwed == 0) {\n      return;\n    }\n    uint104 scaledAmountBurned = uint104(MathUtils.min(scaledAvailableLiquidity, scaledAmountOwed));\n    uint128 normalizedAmountPaid = state.normalizeAmount(scaledAmountBurned).toUint128();\n\n    batch.scaledAmountBurned += scaledAmountBurned;\n    batch.normalizedAmountPaid += normalizedAmountPaid;\n    state.scaledPendingWithdrawals -= scaledAmountBurned;\n\n    // Update normalizedUnclaimedWithdrawals so the tokens are only accessible for withdrawals.\n    state.normalizedUnclaimedWithdrawals += normalizedAmountPaid;\n\n    // Burn market tokens to stop interest accrual upon withdrawal payment.\n    state.scaledTotalSupply -= scaledAmountBurned;\n  }\n}"
    },
    {
      "filename": "src/market/WildcatMarketBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../libraries/FeeMath.sol';\nimport '../libraries/Withdrawal.sol';\nimport { queryName, querySymbol } from '../libraries/StringQuery.sol';\nimport '../interfaces/IMarketEventsAndErrors.sol';\nimport '../interfaces/IWildcatMarketController.sol';\nimport '../interfaces/IWildcatSanctionsSentinel.sol';\nimport { IERC20, IERC20Metadata } from '../interfaces/IERC20Metadata.sol';\nimport '../ReentrancyGuard.sol';\nimport '../libraries/BoolUtils.sol';\n\ncontract WildcatMarketBase is ReentrancyGuard, IMarketEventsAndErrors {\n  using WithdrawalLib for MarketState;\n  using SafeCastLib for uint256;\n  using MathUtils for uint256;\n  using BoolUtils for bool;\n\n  // ==================================================================== //\n  //                       Market Config (immutable)                       //\n  // ==================================================================== //\n\n  string public constant version = '1.0';\n\n  /// @dev Account with blacklist control, used for blocking sanctioned addresses.\n  address public immutable sentinel;\n\n  /// @dev Account with authority to borrow assets from the market.\n  address public immutable borrower;\n\n  /// @dev Account that receives protocol fees.\n  address public immutable feeRecipient;\n\n  /// @dev Protocol fee added to interest paid by borrower.\n  uint256 public immutable protocolFeeBips;\n\n  /// @dev Penalty fee added to interest earned by lenders, does not affect protocol fee.\n  uint256 public immutable delinquencyFeeBips;\n\n  /// @dev Time after which delinquency incurs penalty fee.\n  uint256 public immutable delinquencyGracePeriod;\n\n  /// @dev Address of the Market Controller.\n  address public immutable controller;\n\n  /// @dev Address of the underlying asset.\n  address public immutable asset;\n\n  /// @dev Time before withdrawal batches are processed.\n  uint256 public immutable withdrawalBatchDuration;\n\n  /// @dev Token decimals (same as underlying asset).\n  uint8 public immutable decimals;\n\n  /// @dev Token name (prefixed name of underlying asset).\n  string public name;\n\n  /// @dev Token symbol (prefixed symbol of underlying asset).\n  string public symbol;\n\n  // ===================================================================== //\n  //                             Market State                               //\n  // ===================================================================== //\n\n  MarketState internal _state;\n\n  mapping(address => Account) internal _accounts;\n\n  WithdrawalData internal _withdrawalData;\n\n  // ===================================================================== //\n  //                             Constructor                               //\n  // ===================================================================== //\n\n  constructor() {\n    MarketParameters memory parameters = IWildcatMarketController(msg.sender).getMarketParameters();\n\n    if ((parameters.protocolFeeBips > 0).and(parameters.feeRecipient == address(0))) {\n      revert FeeSetWithoutRecipient();\n    }\n    if (parameters.annualInterestBips > BIP) {\n      revert InterestRateTooHigh();\n    }\n    if (parameters.reserveRatioBips > BIP) {\n      revert ReserveRatioBipsTooHigh();\n    }\n    if (parameters.protocolFeeBips > BIP) {\n      revert InterestFeeTooHigh();\n    }\n    if (parameters.delinquencyFeeBips > BIP) {\n      revert PenaltyFeeTooHigh();\n    }\n\n    // Set asset metadata\n    asset = parameters.asset;\n    name = string.concat(parameters.namePrefix, queryName(parameters.asset));\n    symbol = string.concat(parameters.symbolPrefix, querySymbol(parameters.asset));\n    decimals = IERC20Metadata(parameters.asset).decimals();\n\n    _state = MarketState({\n      isClosed: false,\n      maxTotalSupply: parameters.maxTotalSupply,\n      accruedProtocolFees: 0,\n      normalizedUnclaimedWithdrawals: 0,\n      scaledTotalSupply: 0,\n      scaledPendingWithdrawals: 0,\n      pendingWithdrawalExpiry: 0,\n      isDelinquent: false,\n      timeDelinquent: 0,\n      annualInterestBips: parameters.annualInterestBips,\n      reserveRatioBips: parameters.reserveRatioBips,\n      scaleFactor: uint112(RAY),\n      lastInterestAccruedTimestamp: uint32(block.timestamp)\n    });\n\n    sentinel = parameters.sentinel;\n    borrower = parameters.borrower;\n    controller = parameters.controller;\n    feeRecipient = parameters.feeRecipient;\n    protocolFeeBips = parameters.protocolFeeBips;\n    delinquencyFeeBips = parameters.delinquencyFeeBips;\n    delinquencyGracePeriod = parameters.delinquencyGracePeriod;\n    withdrawalBatchDuration = parameters.withdrawalBatchDuration;\n  }\n\n  // ===================================================================== //\n  //                              Modifiers                                /"
    }
  ]
}