{
  "Title": "[G-09] Functions guaranteed to revert when called by normal users can be marked `payable`",
  "Content": "\nIf a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are\n`CALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2)`, which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost.\n\n*There are 27 instances of this issue:*\n\n```solidity\nFile: contracts/operators/Beefy/BeefyVaultStorage.sol\n\n24:       function addVault(address vault, address tokenOrZapper) external onlyOwner {\n\n34:       function removeVault(address vault) external onlyOwner {\n```\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L24\n\n```solidity\nFile: contracts/operators/Yearn/YearnVaultStorage.sol\n\n29:       function addVault(address vault, CurvePool calldata curvePool) external onlyOwner {\n\n41:       function removeVault(address vault) external onlyOwner {\n```\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L29\n\n```solidity\nFile: contracts/governance/OwnerProxy.sol\n\n16:       function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) {\n```\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L16\n\n```solidity\nFile: contracts/governance/TimelockControllerEmergency.sol\n\n199       function schedule(\n200           address target,\n201           uint256 value,\n202           bytes calldata data,\n203           bytes32 predecessor,\n204           bytes32 salt,\n205           uint256 delay\n206:      ) public virtual onlyRole(PROPOSER_ROLE) {\n\n221       function scheduleBatch(\n222           address[] calldata targets,\n223           uint256[] calldata values,\n224           bytes[] calldata datas,\n225           bytes32 predecessor,\n226           bytes32 salt,\n227           uint256 delay\n228:      ) public virtual onlyRole(PROPOSER_ROLE) {\n\n255:      function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n\n274       function execute(\n275           address target,\n276           uint256 value,\n277           bytes calldata data,\n278           bytes32 predecessor,\n279           bytes32 salt\n280:      ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n\n295       function executeEmergency(\n296           address target,\n297           uint256 value,\n298           bytes calldata data\n299:      ) public payable onlyRole(EMERGENCY_ROLE) {\n\n312       function executeBatch(\n313           address[] calldata targets,\n314           uint256[] calldata values,\n315           bytes[] calldata datas,\n316           bytes32 predecessor,\n317           bytes32 salt\n318:      ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n```\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L199-L206\n\n```solidity\nFile: contracts/abstracts/OwnableProxyDelegation.sol\n\n50:       function renounceOwnership() public virtual onlyOwner {\n\n56:       function transferOwnership(address newOwner) public virtual onlyOwner {\n```\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L50\n\n```solidity\nFile: contracts/OperatorResolver.sol\n\n52        function importOperators(\n53            bytes32[] calldata names,\n54            Operator[] calldata operatorsToImport,\n55            MixinOperatorResolver[] calldata destinations\n56:       ) external override onlyOwner {\n\n74:       function rebuildCaches(MixinOperatorResolver[] calldata destinations) public onlyOwner {\n```\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L52-L56\n\n```solidity\n\nFile: contracts/NestedFactory.sol\n\n121:      function addOperator(bytes32 operator) external override onlyOwner {\n\n133:      function removeOperator(bytes32 operator) external override onlyOwner {\n\n152:      function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n\n159:      function setEntryFees(uint256 _entryFees) external override onlyOwner {\n\n167:      function setExitFees(uint256 _exitFees) external override onlyOwner {\n\n175:      function unlockTokens(IERC20 _token) external override onlyOwner {\n\n205       function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n206           external\n207           payable\n208           override\n209           nonReentrant\n210           onlyTokenOwner(_nftId)\n211:          isUnlocked(_nftId)\n\n219       function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n220           external\n221           override\n222           nonReentrant\n223           onlyTokenOwner(_nftId)\n224:          isUnlocked(_nftId)\n\n231       function processInputAndOutputOrders(\n232           uint256 _nftId,\n233           BatchedInputOrders[] calldata _batchedInputOrders,\n234           BatchedOutputOrders[] calldata _batchedOutputOrders\n235:      ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n\n243       function destroy(\n244           uint256 _nftId,\n245           IERC20 _buyToken,\n246           Order[] calldata _orders\n247:      ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n\n278       function withdraw(uint256 _nftId, uint256 _tokenIndex)\n279           external\n280           override\n281           nonReentrant\n282           onlyTokenOwner(_nftId)\n283:          isUnlocked(_nftId)\n\n301:      function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n```\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L121\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-06-nested-finance-contest",
  "Code": [
    {
      "filename": "contracts/operators/Beefy/BeefyVaultStorage.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title BeefyVaultOperator storage contract\ncontract BeefyVaultStorage is Ownable {\n    /// @dev Emitted when a vault is added\n    /// @param vault The vault address\n    /// @param tokenOrZapper The underlying token address or zapper\n    event VaultAdded(address vault, address tokenOrZapper);\n\n    /// @dev Emitted when a vault is removed\n    /// @param vault The removed vault address\n    event VaultRemoved(address vault);\n\n    /// @dev Map of vault address with underlying token address or zapper\n    mapping(address => address) public vaults;\n\n    /// @notice Add a beefy single asset vault\n    /// @param vault The vault address\n    /// @param tokenOrZapper The underlying token address or zapper (used to deposit)\n    function addVault(address vault, address tokenOrZapper) external onlyOwner {\n        require(vault != address(0), \"BVS: INVALID_VAULT_ADDRESS\");\n        require(tokenOrZapper != address(0), \"BVS: INVALID_UNDERLYING_ADDRESS\");\n        require(vaults[vault] == address(0), \"BVS: ALREADY_EXISTENT_VAULT\");\n        vaults[vault] = tokenOrZapper;\n        emit VaultAdded(vault, tokenOrZapper);\n    }\n\n    /// @notice Remove a beefy vault\n    /// @param vault The vault address to remove\n    function removeVault(address vault) external onlyOwner {\n        require(vaults[vault] != address(0), \"BVS: NON_EXISTENT_VAULT\");\n        delete vaults[vault];\n        emit VaultRemoved(vault);\n    }\n}"
    },
    {
      "filename": "contracts/operators/Yearn/YearnVaultStorage.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nstruct CurvePool {\n    address poolAddress;\n    uint96 poolCoinAmount;\n    address lpToken;\n}\n\n/// @title YearnVaultStorage storage contract\ncontract YearnVaultStorage is Ownable {\n    /// @dev Emitted when a vault is added\n    /// @param vault The vault address\n    /// @param pool The underlying CurvePool\n    event VaultAdded(address vault, CurvePool pool);\n\n    /// @dev Emitted when a vault is removed\n    /// @param vault The removed vault address\n    event VaultRemoved(address vault);\n\n    /// @dev Map of vault address with underlying CurvePool\n    mapping(address => CurvePool) public vaults;\n\n    /// @notice Add a Yearn Curve vault\n    /// @param vault The vault address\n    /// @param curvePool The underlying CurvePool (used to add liquidity)\n    function addVault(address vault, CurvePool calldata curvePool) external onlyOwner {\n        require(vault != address(0), \"YVS: INVALID_VAULT_ADDRESS\");\n        require(curvePool.poolAddress != address(0), \"YVS: INVALID_POOL_ADDRESS\");\n        require(curvePool.lpToken != address(0), \"YVS: INVALID_TOKEN_ADDRESS\");\n        require(vaults[vault].poolAddress == address(0), \"YVS: VAULT_ALREADY_HAS_POOL\");\n        require(vaults[vault].lpToken == address(0), \"YVS: VAULT_ALREADY_HAS_LP\");\n        vaults[vault] = curvePool;\n        emit VaultAdded(vault, curvePool);\n    }\n\n    /// @notice Remove a Yearn vault\n    /// @param vault The vault address to remove\n    function removeVault(address vault) external onlyOwner {\n        require(vaults[vault].poolAddress != address(0), \"YVS: NON_EXISTENT_VAULT\");\n        delete vaults[vault];\n        emit VaultRemoved(vault);\n    }\n}"
    },
    {
      "filename": "contracts/governance/OwnerProxy.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Owner proxy to run atomic actions.\n/// @notice DSProxy-like contract without a cache to simply run\n///         a sequence of atomic actions.\ncontract OwnerProxy is Ownable {\n    /// @notice Execute atomic actions. Only the owner can call this function (e.g. the timelock)\n    /// @param _target Address of the \"script\" to perform a delegatecall\n    /// @param _data The bytes calldata\n    /// @return response The delegatecall response\n    /// @dev Fork from https://github.com/dapphub/ds-proxy/blob/e17a2526ad5c9877ba925ff25c1119f519b7369b/src/proxy.sol#L53\n    /// @dev bytes4 selector must be included in the calldata (_data)\n    function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) {\n        require(_target != address(0), \"OP: INVALID_TARGET\");\n\n        // call contract in current context\n        assembly {\n            let succeeded := delegatecall(sub(gas(), 5000), _target, add(_data, 0x20), mload(_data), 0, 0)\n            let size := returndatasize()\n\n            response := mload(0x40)\n            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response, size)\n            returndatacopy(add(response, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                revert(add(response, 0x20), size)\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/governance/TimelockControllerEmergency.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * This version introduces the \"Emergency\" role bypassing the timelock process.\n * The emergency role should be a multisig with more members than the operational to\n * use when the delay is a problem (critical vulnerability to fix).\n *\n */\ncontract TimelockControllerEmergency is AccessControl {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant EMERGENCY_ROLE = keccak256(\"EMERGENCY_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with a given `minDelay`.\n     */\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors,\n        address emergency\n    ) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EMERGENCY_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // register emergency\n        _setupRole(EMERGENCY_ROLE, emergency);\n\n        // register proposers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, datas, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _beforeCall(id, predecessor);\n        _call(id, 0, target, value, data);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute a single transaction without scheduling.\n     *\n     * Emits a {CallExecuted} event (id will be zero).\n     *\n     * Requirements:\n     * - the caller must have the 'emergency' role (emergency multisig)\n     */\n    function executeEmergency(\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) public payable onlyRole(EMERGENCY_ROLE) {\n        _call(0, 0, target, value, data);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            _call(id, i, targets[i], values[i], datas[i]);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     *\n     * Emits a {CallExecuted} event.\n     */\n    function _call(\n        bytes32 id,\n        uint256 index,\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) private {\n        (bool success, ) = target.call{ value: value }(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n\n        emit CallExecuted(id, index, target, value, data);\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n}"
    },
    {
      "filename": "contracts/abstracts/OwnableProxyDelegation.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\n\n/// @notice Ownable re-implementation to initialize the owner in the\n///         proxy storage after an \"upgradeToAndCall()\" (delegatecall).\n/// @dev The implementation contract owner will be address zero (by removing the constructor)\nabstract contract OwnableProxyDelegation is Context {\n    /// @dev The contract owner\n    address private _owner;\n\n    /// @dev Storage slot with the proxy admin (see TransparentUpgradeableProxy from OZ)\n    bytes32 internal constant _ADMIN_SLOT = bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1);\n\n    /// @dev True if the owner is setted\n    bool public initialized;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Initialize the owner (by the proxy admin)\n    /// @param ownerAddr The owner address\n    function initialize(address ownerAddr) external {\n        require(ownerAddr != address(0), \"OPD: INVALID_ADDRESS\");\n        require(!initialized, \"OPD: INITIALIZED\");\n        require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, \"OPD: FORBIDDEN\");\n\n        _setOwner(ownerAddr);\n\n        initialized = true;\n    }\n\n    /// @dev Returns the address of the current owner.\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /// @dev Throws if called by any account other than the owner.\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"OPD: NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Leaves the contract without owner. It will not be possible to call\n    /// `onlyOwner` functions anymore. Can only be called by the current owner.\n    ///\n    /// NOTE: Renouncing ownership will leave the contract without an owner,\n    /// thereby removing any functionality that is only available to the owner.\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Transfers ownership of the contract to a new account (`newOwner`).\n    /// Can only be called by the current owner.\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"OPD: INVALID_ADDRESS\");\n        _setOwner(newOwner);\n    }\n\n    /// @dev Update the owner address\n    /// @param newOwner The new owner address\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"
    },
    {
      "filename": "contracts/OperatorResolver.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./interfaces/IOperatorResolver.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Operator Resolver implementation\n/// @notice Resolve the operators address\ncontract OperatorResolver is IOperatorResolver, Ownable {\n    /// @dev Operators map of the name and address\n    mapping(bytes32 => Operator) public operators;\n\n    /// @inheritdoc IOperatorResolver\n    function getOperator(bytes32 name) external view override returns (Operator memory) {\n        return operators[name];\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function requireAndGetOperator(bytes32 name, string calldata reason)\n        external\n        view\n        override\n        returns (Operator memory)\n    {\n        Operator memory _foundOperator = operators[name];\n        require(_foundOperator.implementation != address(0), reason);\n        return _foundOperator;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)\n        external\n        view\n        override\n        returns (bool)\n    {\n        uint256 namesLength = names.length;\n        require(namesLength == destinations.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        for (uint256 i = 0; i < namesLength; i++) {\n            if (\n                operators[names[i]].implementation != destinations[i].implementation ||\n                operators[names[i]].selector != destinations[i].selector\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function importOperators(\n        bytes32[] calldata names,\n        Operator[] calldata operatorsToImport,\n        MixinOperatorResolver[] calldata destinations\n    ) external override onlyOwner {\n        require(names.length == operatorsToImport.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        bytes32 name;\n        Operator calldata destination;\n        for (uint256 i = 0; i < names.length; i++) {\n            name = names[i];\n            destination = operatorsToImport[i];\n            operators[name] = destination;\n            emit OperatorImported(name, destination);\n        }\n\n        // rebuild caches atomically\n        // see. https://github.com/code-423n4/2021-11-nested-findings/issues/217\n        rebuildCaches(destinations);\n    }\n\n    /// @notice rebuild the caches of mixin smart contracts\n    /// @param destinations The list of mixinOperatorResolver to rebuild\n    function rebuildCaches(MixinOperatorResolver[] calldata destinations) public onlyOwner {\n        for (uint256 i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/NestedFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\nimport \"./Withdrawer.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /// @dev Helper to withdraw native tokens from wrapper\n    Withdrawer private immutable withdrawer;\n\n    /// @dev Fees when funds stay in portfolios\n    ///      From 1 to 10,000 (0.01% to 100%)\n    uint256 public entryFees;\n\n    /// @dev Fees when funds are withdrawed\n    ///      From 1 to 10,000 (0.01% to 100%)\n    uint256 public exitFees;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver,\n        Withdrawer _withdrawer\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset) != address(0) &&\n                address(_nestedRecords) != address(0) &&\n                address(_reserve) != address(0) &&\n                address(_feeSplitter) != address(0) &&\n                address(_weth) != address(0) &&\n                _operatorResolver != address(0) &&\n                address(_withdrawer) != address(0),\n            \"NF: INVALID_ADDRESS\"\n        );\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        reserve = _reserve;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n        withdrawer = _withdrawer;\n    }\n\n    /// @dev Receive function that will wrap the ether if\n    ///      an address other than the withdrawer sends ether to\n    ///      to the contract. The factory cannot handle ether but\n    ///      has functions to withdraw ERC20 tokens if needed.\n    receive() external payable {\n        if (msg.sender != address(withdrawer)) {\n            weth.deposit{ value: msg.value }();\n        }\n    }\n\n    /* ------------------------------ MODIFIERS ---------------------------- */\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NF: CALLER_NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NF: LOCKED_NFT\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the required operators\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\n        return operators;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n        bytes32[] memory operatorsCache = operators;\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\n            require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n        }\n        operators.push(operator);\n        rebuildCache();\n        emit OperatorAdded(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        bytes32[] storage operatorsCache = operators;\n        uint256 operatorsLength = operatorsCache.length;\n        for (uint256 i = 0; i < operatorsLength; i++) {\n            if (operatorsCache[i] == operator) {\n                operatorsCache[i] = operators[operatorsLength - 1];\n                operatorsCache.pop();\n                if (operatorCache[operator].implementation != address(0)) {\n                    delete operatorCache[operator]; // remove from cache\n                }\n                rebuildCache();\n                emit OperatorRemoved(operator);\n                return;\n            }\n        }\n        revert(\"NF: NON_EXISTENT_OPERATOR\");\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NF: INVALID_FEE_SPLITTER_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function setEntryFees(uint256 _entryFees) external override onlyOwner {\n        require(_entryFees != 0, \"NF: ZERO_FEES\");\n        require(_entryFees <= 10000, \"NF: FEES_OVERFLOW\");\n        entryFees = _entryFees;\n        emit EntryFeesUpdated(_entryFees);\n    }\n\n    /// @inheritdoc INestedFactory\n    function setExitFees(uint256 _exitFees) external override onlyOwner {\n        require(_exitFees != 0, \"NF: ZERO_FEES\");\n        require(_exitFees <= 10000, \"NF: FEES_OVERFLOW\");\n        exitFees = _exitFees;\n        emit ExitFeesUpdated(_exitFees);\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        uint256 amount = _token.balanceOf(address(this));\n        SafeERC20.safeTransfer(_token, msg.sender, amount);\n        emit TokensUnlocked(address(_token), amount);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n\n        _checkMsgValue(_batchedOrders);\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _batchedOrders[i], false);\n            _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        }\n\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _checkMsgValue(_batchedOrders);\n        _processInputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _processOutputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputAndOutputOrders(\n        uint256 _nftId,\n        BatchedInputOrders[] calldata _batchedInputOrders,\n        BatchedOutputOrders[] calldata _batchedOutputOrders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        _checkMsgValue(_batchedInputOrders);\n        _processInputOrders(_nftId, _batchedInputOrders);\n        _processOutputOrders(_nftId, _batchedOutputOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        uint256 tokensLength = tokens.length;\n        require(_orders.length != 0, \"NF: INVALID_ORDERS\");\n        require(tokensLength == _o"
    }
  ]
}