{
  "Title": "[M-04] Malicious user can populate `rewards` array with tokens of their interest reaching limits of `MAX_REWARD_TOKENS`",
  "Content": "_Submitted by 0xf15ers, also found by 0x52, berndartmueller, cccz, horsefacts, hyh, minhquanym, pauliax, Ruhum, and WatchPug_\n\nMalicious user can populate `rewards` array with different tokens early reaching limit of `MAX_REWARD_TOKENS` sending very small amount of different tokens. It will restrict any other tokens to be used as `rewards` in [Bribe.sol#notifyRewardAmount()](https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L41)\n\n### Proof of Concept\n\nA custom malicious contract can be created that can make multiple calls to `notifyRewardAmount()` sending very small amounts of different tokens to populate the array `rewards` and fulfill the total of `MAX_REWARD_TOKENS` . This will restrict any other person from adding to `rewards` array.\n\n**[pooltypes (Velodrome) confirmed and commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/182#issuecomment-1154086709):**\n > Fixed. We added a whitelist check for reward tokens for our mainnet deployment.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/182#issuecomment-1169357731):**\n > Given that the deployer can re-deploy contracts at any time, and they also can multi-call, I don't believe a realistic DOS can happen.\n> \n> I do, however, agree that any additional reward beside the first token (which can be automatically added via a deploy + initialize + distribute), may end up being denied.\n> \n> Additionally the `team` can use `swapOutBribeRewardToken` to change to a real reward token.\n> \n> Because of this, I believe the finding to be valid and of Medium Severity.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-05-velodrome",
  "Code": [
    {
      "filename": "contracts/contracts/Bribe.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGauge.sol';\n\ncontract Bribe is IBribe {\n  uint internal constant DURATION = 5 days; // rewards are released over the voting period\n  uint internal constant BRIBE_LAG = 1 days;\n  uint internal constant COOLDOWN = 12 hours;\n  uint internal constant MAX_REWARD_TOKENS = 16;\n\n  address public gauge;\n  mapping(address => mapping(uint => uint)) public tokenRewardsPerEpoch;\n  address[] public rewards;\n  mapping(address => bool) public isReward;\n\n  event NotifyReward(address indexed from, address indexed reward, uint epoch, uint amount);\n\n  // simple re-entrancy check\n  uint internal _unlocked = 1;\n  modifier lock() {\n      require(_unlocked == 1);\n      _unlocked = 2;\n      _;\n      _unlocked = 1;\n  }\n\n  function setGauge(address _gauge) external {\n    require(gauge == address(0), \"gauge already set\");\n    gauge = _gauge;\n  }\n\n  function getEpochStart(uint timestamp) public view returns (uint) {\n    uint bribeStart = timestamp - (timestamp % (7 days)) + BRIBE_LAG;\n    uint bribeEnd = bribeStart + DURATION - COOLDOWN;\n    return timestamp < bribeEnd ? bribeStart : bribeStart + 7 days;\n  }\n\n  function notifyRewardAmount(address token, uint amount) external lock {\n      require(amount > 0);\n      if (!isReward[token]) {\n        require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n      }\n      // bribes kick in at the start of next bribe period\n      uint adjustedTstamp = getEpochStart(block.timestamp);\n      uint epochRewards = tokenRewardsPerEpoch[token][adjustedTstamp];\n\n      _safeTransferFrom(token, msg.sender, address(this), amount);\n      tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + amount;\n\n      if (!isReward[token]) {\n          isReward[token] = true;\n          rewards.push(token);\n          IGauge(gauge).addBribeRewardToken(token);\n      }\n\n      emit NotifyReward(msg.sender, token, adjustedTstamp, amount);\n  }\n\n  function rewardsListLength() external view returns (uint) {\n      return rewards.length;\n  }\n\n  function addRewardToken(address token) external {\n    require(msg.sender == gauge);\n    if (!isReward[token]) {\n      require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n      isReward[token] = true;\n      rewards.push(token);\n    }\n  }\n\n  function swapOutRewardToken(uint i, address oldToken, address newToken) external {\n    require(msg.sender == gauge);\n    require(rewards[i] == oldToken);\n    isReward[oldToken] = false;\n    isReward[newToken] = true;\n    rewards[i] = newToken;\n  }\n\n  function deliverReward(address token, uint epochStart) external lock returns (uint) {\n    require(msg.sender == gauge);\n    uint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];\n    if (rewardPerEpoch > 0) {\n      _safeTransfer(token, address(gauge), rewardPerEpoch);\n    }\n    return rewardPerEpoch;\n  }\n\n  function _safeTransfer(address token, address to, uint256 value) internal {\n      require(token.code.length > 0);\n      (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n      require(success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n\n  function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n      require(token.code.length > 0);\n      (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n      require(success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n}"
    }
  ]
}