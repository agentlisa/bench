{
  "Title": "Remove unused/unnecessary constants in `LibIncentive`",
  "Content": "`LibIncentive` currently defines a [`PERIOD`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibIncentive.sol#L23-L24) constant for the Uniswap Oracle lookback window, which is both unused and incorrect – this should be removed. This library also defines [`BASE_FEE_CONTRACT`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibIncentive.sol#L45-L46), which shadows a constant of the same name and value in `C.sol` – this can also be removed in favor of the [definition](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/C.sol#L75-L76) in `C.sol`.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/LibIncentive.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {OracleLibrary} from \"@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol\";\nimport {LibBeanEthWellOracle} from \"contracts/libraries/Oracle/LibBeanEthWellOracle.sol\";\nimport {IBlockBasefee} from \"../interfaces/IBlockBasefee.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"../C.sol\";\nimport \"./Curve/LibCurve.sol\";\n\n/**\n * @title LibIncentive\n * @author Publius, Chaikitty, Brean\n * @notice Calculates the reward offered for calling Sunrise, adjusts for current gas & ETH prices,\n * and scales the reward up when the Sunrise is called late.\n */\nlibrary LibIncentive {\n    using SafeMath for uint256;\n\n    /// @dev The time range over which to consult the Uniswap V3 ETH:USDC pool oracle. Measured in seconds.\n    uint32 internal constant PERIOD = 1800; // 30 minutes\n\n    /// @dev The Sunrise reward reaches its maximum after this many blocks elapse.\n    uint256 internal constant MAX_BLOCKS_LATE = 25;\n\n    /// @dev Base BEAN reward to cover cost of operating a bot.\n    uint256 internal constant BASE_REWARD = 3e6; // 3 BEAN\n\n    /// @dev Max BEAN reward for calling Sunrise.\n    uint256 internal constant MAX_REWARD = 100e6; // 100 BEAN\n\n    /// @dev Wei buffer to account for the priority fee.\n    uint256 internal constant PRIORITY_FEE_BUFFER = 5e9; // 5e9 wei = 5 gwei\n\n    /// @dev The maximum gas which Beanstalk will pay for a Sunrise transaction.\n    uint256 internal constant MAX_SUNRISE_GAS = 500_000; // 500k gas\n\n    /// @dev Accounts for extra gas overhead for completing a Sunrise tranasaction.\n    // 21k gas (base cost for a transction) + ~79k gas for other overhead\n    uint256 internal constant SUNRISE_GAS_OVERHEAD = 100_000; // 100k gas\n\n    /// @dev Use external contract for block.basefee as to avoid upgrading existing contracts to solidity v8\n    address private constant BASE_FEE_CONTRACT = 0x84292919cB64b590C0131550483707E43Ef223aC;\n\n    /// @dev `sunriseReward` is precomputed in {fracExp} using this precision.\n    uint256 private constant FRAC_EXP_PRECISION = 1e18;\n\n    //////////////////// CALCULATE REWARD ////////////////////\n\n    /**\n     * @param initialGasLeft The amount of gas left at the start of the transaction\n     * @param blocksLate The number of blocks late that {sunrise()} was called.\n     * @dev Calculates Sunrise incentive amount based on current gas prices and a computed\n     * BEAN:ETH price. This function is called at the end of {sunriseTo()} after all\n     * \"step\" functions have been executed.\n     *\n     * Price calculation:\n     * `X := BEAN / USD`\n     * `Y := ETH / USDC`\n     * `Y / X := (ETH/USDC)/(BEAN/USD) := ETH / BEAN` (assuming 1 USD == 1 USDC)\n     */\n    function determineReward(uint256 initialGasLeft, uint256 blocksLate)\n        internal\n        returns (uint256)\n    {\n\n        // Cap the maximum number of blocks late. If the sunrise is later than\n        // this, Beanstalk will pay the same amount. Prevents unbounded return value.\n        if (blocksLate > MAX_BLOCKS_LATE) {\n            blocksLate = MAX_BLOCKS_LATE;\n        }\n\n        // Read the Bean / Eth price calculated by the Minting Well.\n        uint256 beanEthPrice = LibBeanEthWellOracle.getBeanEthWellPrice();\n\n        // If the Bean Eth pool couldn't calculate a valid price, use the max reward value.\n        if (beanEthPrice <= 1) {\n            return fracExp(MAX_REWARD, blocksLate);\n        }\n\n        // Sunrise gas overhead includes:\n        //  - 21K for base transaction cost\n        //  - 29K for calculations following the below line, like {fracExp}\n        // Max gas which Beanstalk will pay for = 500K.\n        uint256 gasUsed = Math.min(initialGasLeft.sub(gasleft()) + SUNRISE_GAS_OVERHEAD, MAX_SUNRISE_GAS);\n\n        // Calculate the current cost in Wei of `gasUsed` gas.\n        // {block_basefee()} returns the base fee of the current block in Wei.\n        // Adds a buffer for priority fee.\n        uint256 gasCostWei = IBlockBasefee(BASE_FEE_CONTRACT).block_basefee().add(PRIORITY_FEE_BUFFER).mul(gasUsed); // (BASE_FEE\n            // + PRIORITY_FEE_BUFFER)\n            // * GAS_USED\n\n        // Calculates the Sunrise reward to pay in BEAN.\n        uint256 sunriseReward = Math.min(\n            BASE_REWARD + gasCostWei.mul(beanEthPrice).div(1e18), // divide by 1e18 to convert wei to eth\n            MAX_REWARD\n        );\n\n        // Scale the reward up as the number of blocks after expected sunrise increases.\n        // `sunriseReward * (1 + 1/100)^(blocks late * seconds per block)`\n        // NOTE: 1.01^(25 * 12) = 19.78, This is the maximum multiplier.\n        return fracExp(sunriseReward, blocksLate);\n    }\n\n    //////////////////// MATH UTILITIES ////////////////////\n\n    /**\n     * @dev fraxExp scales up the bean reward based on the blocks late.\n     * the formula is beans * (1.01)^(Blocks Late * 12 second block time).\n     * since block time is capped at 25 blocks,\n     * we only need to check cases 0 - 25\n     */\n    function fracExp(uint256 beans, uint256 blocksLate) internal pure returns (uint256 scaledSunriseReward) {\n        // check most likely case first\n        if (blocksLate == 0) {\n            return beans;\n        }\n\n        // Binary Search\n        if (blocksLate < 13) {\n            if (blocksLate < 7) {\n                if (blocksLate < 4) {\n                    if (blocksLate < 2) {\n                        // blocksLate == 0 is already checked, thus\n                        // blocksLate = 1, 1.01^(1*12)\n                        return _scaleReward(beans, 1_126_825_030_131_969_720);\n                    }\n                    if (blocksLate == 2) {\n                        // 1.01^(2*12)\n                        return _scaleReward(beans, 1_269_734_648_531_914_468);\n                    } else {\n                        // blocksLate == 3, 1.01^(3*12)\n                        return _scaleReward(beans, 1_430_768_783_591_580_504);\n                    }\n                }\n                if (blocksLate < 6) {\n                    if (blocksLate == 4) {\n                        return _scaleReward(beans, 1_612_226_077_682_464_366);\n                    } else {\n                        // blocksLate == 5\n                        return _scaleReward(beans, 1_816_696_698_564_090_264);\n                    }\n                } else {\n                    // blocksLate == 6\n                    return _scaleReward(beans, 2_047_099_312_100_130_925);\n                }\n            }\n            if (blocksLate < 10) {\n                if (blocksLate < 9) {\n                    if (blocksLate == 7) {\n                        return _scaleReward(beans, 2_306_722_744_040_364_517);\n                    } else {\n                        // blocksLate == 8\n                        return _scaleReward(beans, 2_599_272_925_559_383_624);\n                    }\n                } else {\n                    // blocksLate == 9\n                    return _scaleReward(beans, 2_928_925_792_664_665_541);\n                }\n            }\n            if (blocksLate < 12) {\n                if (blocksLate == 10) {\n                    return _scaleReward(beans, 3_300_386_894_573_665_047);\n                } else {\n                    // blocksLate == 11\n                    return _scaleReward(beans, 3_718_958_561_925_128_091);\n                }\n            } else {\n                // blocksLate == 12\n                return _scaleReward(beans, 4_190_615_593_600_829_241);\n            }\n        }\n        if (blocksLate < 19) {\n            if (blocksLate < 16) {\n                if (blocksLate < 15) {\n                    if (blocksLate == 13) {\n                        return _scaleReward(beans, 4_722_090_542_530_756_587);\n                    } else {\n                        // blocksLate == 14\n                        return _scaleReward(beans, 5_320_969_817_873_109_037);\n                    }\n                } else {\n                    // blocksLate == 15\n                    return _scaleReward(beans, 5_995_801_975_356_167_528);\n                }\n            }\n            if (blocksLate < 18) {\n                if (blocksLate == 16) {\n                    return _scaleReward(beans, 6_756_219_741_546_037_047);\n                } else {\n                    // blocksLate == 17\n                    return _scaleReward(beans, 7_613_077_513_845_821_874);\n                }\n            }\n            return _scaleReward(beans, 8_578_606_298_936_339_361); // blocksLate == 18\n        }\n        if (blocksLate < 22) {\n            if (blocksLate < 21) {\n                if (blocksLate == 19) {\n                    return _scaleReward(beans, 9_666_588_301_289_245_846);\n                } else {\n                    // blocksLate == 20\n                    return _scaleReward(beans, 10_892_553_653_873_600_447);\n                }\n            }\n            return _scaleReward(beans, 12_274_002_099_240_216_703); // blocksLate == 21\n        }\n        if (blocksLate <= 23) {\n            if (blocksLate == 22) {\n                return _scaleReward(beans, 13_830_652_785_316_216_792);\n            } else {\n                // blocksLate == 23\n                return _scaleReward(beans, 15_584_725_741_558_756_931);\n            }\n        }\n        if (blocksLate >= 25) {\n            // block rewards are capped at 25 (MAX_BLOCKS_LATE)\n            return _scaleReward(beans, 19_788_466_261_924_388_319);\n        } else {\n            // blocksLate == 24\n            return _scaleReward(beans, 17_561_259_053_330_430_428);\n        }\n    }\n\n    function _scaleReward(uint256 beans, uint256 scaler) private pure returns (uint256) {\n        return beans.mul(scaler).div(FRAC_EXP_PRECISION);\n    }\n}"
    }
  ]
}