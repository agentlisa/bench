{
  "Title": "[L04] Remove commented out code",
  "Content": "On [lines 29 and 30 of `proxy-utils.ts`](https://github.com/celo-org/celo-monorepo/blob/0e876e5cad0e93f5dd1fff853f4be3c9a0e5c2a7/packages/protocol/lib/proxy-utils.ts#L29-L30), there exists a comment suggesting that line 30 should be un-commented for future use.\n\n\nThe [`verifyProxyStorageProof` function](https://github.com/celo-org/celo-monorepo/blob/0e876e5cad0e93f5dd1fff853f4be3c9a0e5c2a7/packages/protocol/lib/proxy-utils.ts#L20) checks that the [storage trie of `proxy`](https://github.com/celo-org/celo-monorepo/blob/0e876e5cad0e93f5dd1fff853f4be3c9a0e5c2a7/packages/protocol/lib/proxy-utils.ts#L33) only contains [`owner` in the correct position](https://github.com/celo-org/celo-monorepo/blob/0e876e5cad0e93f5dd1fff853f4be3c9a0e5c2a7/packages/protocol/lib/proxy-utils.ts#L28). If lines 29 and 30 are uncommented, the function will then check that the storage trie contains `owner` and [`implementation`](https://github.com/celo-org/celo-monorepo/blob/0e876e5cad0e93f5dd1fff853f4be3c9a0e5c2a7/packages/protocol/lib/proxy-utils.ts#L30), and will return `false` if not. \n\n\nWhen `verifyProxyStorageProof` is [called within `verify-bytecode.ts`](https://github.com/celo-org/celo-monorepo/blob/0e876e5cad0e93f5dd1fff853f4be3c9a0e5c2a7/packages/protocol/lib/compatibility/verify-bytecode.ts#L99), it is with the understanding that the proxy should be deployed (`owner` is set) but the proxy should NOT have an implementation set. If the mentioned lines are uncommented, it will break the current usage of `verifyProxyStorageProof`, and the code will need significant changes to function correctly again. \n\n\nIf it is desired to have a function which includes the code [on line 30 of `proxy-utils.ts`](https://github.com/celo-org/celo-monorepo/blob/0e876e5cad0e93f5dd1fff853f4be3c9a0e5c2a7/packages/protocol/lib/proxy-utils.ts), consider implementing it as a separate function with a new name. Alternatively, consider removing the lines, or adding comments to specify the conditions under which to implement the mentioned code.\n\n\n**Update**: *Fixed in [PR#6491](https://github.com/celo-org/celo-monorepo/pull/6491)*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/lib/proxy-utils.ts",
      "content": "import { Address, bufferToHex, hexToBuffer } from '@celo/base/lib/address'\nimport { SecureTrie } from 'merkle-patricia-tree'\nimport prompts from 'prompts'\nimport { encode as rlpEncode } from 'rlp'\nimport { ProxyInstance } from 'types'\nimport Web3 from 'web3'\n\n// from Proxy.sol\n\n// bytes32 private constant OWNER_POSITION = bytes32(\n//   uint256(keccak256(\"eip1967.proxy.admin\")) - 1\n// );\nconst OWNER_POSITION = '0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103'\n\n// bytes32 private constant IMPLEMENTATION_POSITION = bytes32(\n//   uint256(keccak256(\"eip1967.proxy.implementation\")) - 1\n// );\nconst IMPLEMENTATION_POSITION = '0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc'\n\nexport async function verifyProxyStorageProof(web3: Web3, proxy: string, owner: string) {\n  const proof = await web3.eth.getProof(\n    web3.utils.toChecksumAddress(proxy),\n    [OWNER_POSITION, IMPLEMENTATION_POSITION],\n    'latest'\n  )\n\n  const trie = new SecureTrie()\n  await trie.put(hexToBuffer(OWNER_POSITION), rlpEncode(owner))\n  // for future use\n  // await trie.put(hexToBuffer(IMPLEMENTATION_POSITION), rlpEncode(implementation))\n\n  // @ts-ignore\n  return proof.storageHash === bufferToHex(trie.root)\n}\n\nexport async function retryTx(fn: any, args: any[]) {\n  while (true) {\n    try {\n      const rvalue = await fn(...args)\n      return rvalue\n    } catch (e) {\n      console.error(e)\n      // @ts-ignore\n      const { confirmation } = await prompts({\n        type: 'confirm',\n        name: 'confirmation',\n        // @ts-ignore: typings incorrectly only accept string.\n        initial: true,\n        message: 'Error while sending tx. Try again?',\n      })\n      if (!confirmation) {\n        throw e\n      }\n    }\n  }\n}\nexport async function setAndInitializeImplementation(\n  web3: Web3,\n  proxy: ProxyInstance,\n  implementationAddress: string,\n  initializerAbi: any,\n  txOptions: {\n    from?: Address\n    value?: string\n  },\n  ...args: any[]\n) {\n  const callData = web3.eth.abi.encodeFunctionCall(initializerAbi, args)\n  if (txOptions.from != null) {\n    // The proxied contract needs to be funded prior to initialization\n    if (txOptions.value != null) {\n      // Proxy's fallback fn expects the contract's implementation to be set already\n      // So we set the implementation first, send the funding, and then set and initialize again.\n      await retryTx(proxy._setImplementation, [implementationAddress, { from: txOptions.from }])\n      await retryTx(web3.eth.sendTransaction, [\n        {\n          from: txOptions.from,\n          to: proxy.address,\n          value: txOptions.value,\n        },\n      ])\n    }\n    return retryTx(proxy._setAndInitializeImplementation, [\n      implementationAddress,\n      callData as any,\n      { from: txOptions.from },\n    ])\n  } else {\n    return retryTx(proxy._setAndInitializeImplementation, [implementationAddress, callData as any])\n  }\n}"
    },
    {
      "filename": "packages/protocol/lib/proxy-utils.ts",
      "content": "import { Address, bufferToHex, hexToBuffer } from '@celo/base/lib/address'\nimport { SecureTrie } from 'merkle-patricia-tree'\nimport prompts from 'prompts'\nimport { encode as rlpEncode } from 'rlp'\nimport { ProxyInstance } from 'types'\nimport Web3 from 'web3'\n\n// from Proxy.sol\n\n// bytes32 private constant OWNER_POSITION = bytes32(\n//   uint256(keccak256(\"eip1967.proxy.admin\")) - 1\n// );\nconst OWNER_POSITION = '0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103'\n\n// bytes32 private constant IMPLEMENTATION_POSITION = bytes32(\n//   uint256(keccak256(\"eip1967.proxy.implementation\")) - 1\n// );\nconst IMPLEMENTATION_POSITION = '0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc'\n\nexport async function verifyProxyStorageProof(web3: Web3, proxy: string, owner: string) {\n  const proof = await web3.eth.getProof(\n    web3.utils.toChecksumAddress(proxy),\n    [OWNER_POSITION, IMPLEMENTATION_POSITION],\n    'latest'\n  )\n\n  const trie = new SecureTrie()\n  await trie.put(hexToBuffer(OWNER_POSITION), rlpEncode(owner))\n  // for future use\n  // await trie.put(hexToBuffer(IMPLEMENTATION_POSITION), rlpEncode(implementation))\n\n  // @ts-ignore\n  return proof.storageHash === bufferToHex(trie.root)\n}\n\nexport async function retryTx(fn: any, args: any[]) {\n  while (true) {\n    try {\n      const rvalue = await fn(...args)\n      return rvalue\n    } catch (e) {\n      console.error(e)\n      // @ts-ignore\n      const { confirmation } = await prompts({\n        type: 'confirm',\n        name: 'confirmation',\n        // @ts-ignore: typings incorrectly only accept string.\n        initial: true,\n        message: 'Error while sending tx. Try again?',\n      })\n      if (!confirmation) {\n        throw e\n      }\n    }\n  }\n}\nexport async function setAndInitializeImplementation(\n  web3: Web3,\n  proxy: ProxyInstance,\n  implementationAddress: string,\n  initializerAbi: any,\n  txOptions: {\n    from?: Address\n    value?: string\n  },\n  ...args: any[]\n) {\n  const callData = web3.eth.abi.encodeFunctionCall(initializerAbi, args)\n  if (txOptions.from != null) {\n    // The proxied contract needs to be funded prior to initialization\n    if (txOptions.value != null) {\n      // Proxy's fallback fn expects the contract's implementation to be set already\n      // So we set the implementation first, send the funding, and then set and initialize again.\n      await retryTx(proxy._setImplementation, [implementationAddress, { from: txOptions.from }])\n      await retryTx(web3.eth.sendTransaction, [\n        {\n          from: txOptions.from,\n          to: proxy.address,\n          value: txOptions.value,\n        },\n      ])\n    }\n    return retryTx(proxy._setAndInitializeImplementation, [\n      implementationAddress,\n      callData as any,\n      { from: txOptions.from },\n    ])\n  } else {\n    return retryTx(proxy._setAndInitializeImplementation, [implementationAddress, callData as any])\n  }\n}"
    },
    {
      "filename": "packages/protocol/lib/compatibility/verify-bytecode.ts",
      "content": "// tslint:disable: no-console\nimport { ensureLeading0x } from '@celo/base/lib/address'\nimport {\n  LibraryAddresses,\n  LibraryPositions,\n  linkLibraries,\n  stripMetadata,\n  verifyAndStripLibraryPrefix,\n} from '@celo/protocol/lib/bytecode'\nimport { verifyProxyStorageProof } from '@celo/protocol/lib/proxy-utils'\nimport { ProposalTx } from '@celo/protocol/scripts/truffle/make-release'\nimport { BuildArtifacts } from '@openzeppelin/upgrades'\nimport { ProxyInstance, RegistryInstance } from 'types'\nimport Web3 from 'web3'\n\nconst ignoredContracts = [\n  // This contract is not proxied\n  'TransferWhitelist',\n\n  // These contracts are not in the Registry (before release 1)\n  'ReserveSpenderMultiSig',\n  'GovernanceApproverMultiSig',\n]\n\ninterface VerificationContext {\n  artifacts: BuildArtifacts\n  libraryAddresses: LibraryAddresses\n  registry: RegistryInstance\n  governanceAddress: string\n  proposal: ProposalTx[]\n  Proxy: Truffle.Contract<ProxyInstance>\n  web3: Web3\n  network: string\n}\ninterface InitializationData {\n  [contractName: string]: any[]\n}\n\nconst ContractNameExtractorRegex = new RegExp(/(.*)Proxy/)\n\n// Checks if the given transaction is a repointing of the Proxy for the given\n// contract.\nconst isProxyRepointTransaction = (tx: ProposalTx) =>\n  tx.contract.endsWith('Proxy') &&\n  (tx.function === '_setImplementation' || tx.function === '_setAndInitializeImplementation')\n\nconst isProxyRepointAndInitializeTransaction = (tx: ProposalTx) =>\n  tx.contract.endsWith('Proxy') && tx.function === '_setAndInitializeImplementation'\n\nconst isProxyRepointForIdTransaction = (tx: ProposalTx, contract: string) =>\n  tx.contract === `${contract}Proxy` && isProxyRepointTransaction(tx)\n\nconst isImplementationChanged = (contract: string, context: VerificationContext): boolean =>\n  context.proposal.some((tx: ProposalTx) => isProxyRepointForIdTransaction(tx, contract))\n\nconst getProposedImplementationAddress = (contract: string, context: VerificationContext) =>\n  context.proposal.find((tx: ProposalTx) => isProxyRepointForIdTransaction(tx, contract)).args[0]\n\n// Checks if the given transaction is a repointing of the Registry entry for the\n// given registryId.\nconst isRegistryRepointTransaction = (tx: ProposalTx) =>\n  tx.contract === `Registry` && tx.function === 'setAddressFor'\n\nconst isRegistryRepointForIdTransaction = (tx: ProposalTx, registryId: string) =>\n  isRegistryRepointTransaction(tx) && tx.args[0] === registryId\n\nconst isProxyChanged = (contract: string, context: VerificationContext): boolean => {\n  return context.proposal.some((tx) => isRegistryRepointForIdTransaction(tx, contract))\n}\n\nconst getProposedProxyAddress = (contract: string, context: VerificationContext): string => {\n  const relevantTx = context.proposal.find((tx) => isRegistryRepointForIdTransaction(tx, contract))\n  return relevantTx.args[1]\n}\n\nconst getSourceBytecodeFromArtifacts = (contract: string, artifacts: BuildArtifacts): string =>\n  stripMetadata(artifacts.getArtifactByName(contract).deployedBytecode)\n\nconst getSourceBytecode = (contract: string, context: VerificationContext): string =>\n  getSourceBytecodeFromArtifacts(contract, context.artifacts)\n\nconst getOnchainBytecode = async (address: string, context: VerificationContext) =>\n  stripMetadata(await context.web3.eth.getCode(address))\n\nconst isLibrary = (contract: string, context: VerificationContext) =>\n  contract in context.libraryAddresses.addresses\n\nconst dfsStep = async (queue: string[], visited: Set<string>, context: VerificationContext) => {\n  const contract = queue.pop()\n  // mark current DFS node as visited\n  visited.add(contract)\n\n  // check proxy deployment\n  if (isProxyChanged(contract, context)) {\n    const proxyAddress = getProposedProxyAddress(contract, context)\n    // ganache does not support eth_getProof\n    if (\n      context.network !== 'development' &&\n      !(await verifyProxyStorageProof(context.web3, proxyAddress, context.governanceAddress))\n    ) {\n      throw new Error(`Proposed ${contract}Proxy has impure storage`)\n    }\n\n    const onchainProxyBytecode = await getOnchainBytecode(proxyAddress, context)\n    const sourceProxyBytecode = getSourceBytecode(`${contract}Proxy`, context)\n    if (onchainProxyBytecode !== sourceProxyBytecode) {\n      throw new Error(`Proposed ${contract}Proxy does not match compiled proxy bytecode`)\n    }\n\n    console.log(`Proxy deployed at ${proxyAddress} matches ${contract}Proxy (bytecode and storage)`)\n  }\n\n  // check implementation deployment\n  const sourceBytecode = getSourceBytecode(contract, context)\n  const sourceLibraryPositions = new LibraryPositions(sourceBytecode)\n\n  let implementationAddress: string\n  if (isImplementationChanged(contract, context)) {\n    implementationAddress = getProposedImplementationAddress(contract, context)\n  } else if (isLibrary(contract, context)) {\n    implementationAddress = ensureLeading0x(context.libraryAddresses.addresses[contract])\n  } else {\n    const proxyAddress = await context.registry.getAddressForString(contract)\n    const proxy = await context.Proxy.at(proxyAddress) // necessary await\n    implementationAddress = await proxy._getImplementation()\n  }\n\n  let onchainBytecode = await getOnchainBytecode(implementationAddress, context)\n  context.libraryAddresses.collect(onchainBytecode, sourceLibraryPositions)\n\n  let linkedSourceBytecode = linkLibraries(sourceBytecode, context.libraryAddresses.addresses)\n\n  // normalize library bytecodes\n  if (isLibrary(contract, context)) {\n    linkedSourceBytecode = verifyAndStripLibraryPrefix(linkedSourceBytecode)\n    onchainBytecode = verifyAndStripLibraryPrefix(onchainBytecode, implementationAddress)\n  }\n\n  if (onchainBytecode !== linkedSourceBytecode) {\n    throw new Error(`${contract}'s onchain and compiled bytecodes do not match`)\n  } else {\n    console.log(\n      `${\n        isLibrary(contract, context) ? 'Library' : 'Contract'\n      } deployed at ${implementationAddress} matches ${contract}`\n    )\n  }\n\n  // push unvisited libraries to DFS queue\n  queue.push(\n    ...Object.keys(sourceLibraryPositions.positions).filter((library) => !visited.has(library))\n  )\n}\n\nconst assertValidProposalTransactions = (proposal: ProposalTx[]) => {\n  const invalidTransactions = proposal.filter(\n    (tx) => !isProxyRepointTransaction(tx) && !isRegistryRepointTransaction(tx)\n  )\n  if (invalidTransactions.length > 0) {\n    throw new Error(`Proposal contains invalid release transactions ${invalidTransactions}`)\n  }\n\n  console.info('Proposal contains only valid release transactions!')\n}\n\nconst assertValidInitializationData = (\n  artifacts: BuildArtifacts,\n  proposal: ProposalTx[],\n  web3: Web3,\n  initializationData: InitializationData\n) => {\n  const initializingProposals = proposal.filter(isProxyRepointAndInitializeTransaction)\n  const contractsInitialized = new Set()\n  for (const proposalTx of initializingProposals) {\n    const contractName = ContractNameExtractorRegex.exec(proposalTx.contract)[1]\n\n    if (!initializationData[contractName]) {\n      throw new Error(\n        `Initialization Data for ${contractName} could not be found in reference file`\n      )\n    }\n\n    const contract = artifacts.getArtifactByName(contractName)\n    const initializeAbi = contract.abi.find(\n      (abi: any) => abi.type === 'function' && abi.name === 'initialize'\n    )\n    const args = initializationData[contractName]\n    const callData = web3.eth.abi.encodeFunctionCall(initializeAbi, args)\n\n    if (callData !== proposalTx.args[1]) {\n      throw new Error(\n        `Intialization Data for ${contractName} in proposal does not match reference file ${initializationData[contractName]}`\n      )\n    }\n\n    contractsInitialized.add(contractName)\n  }\n\n  for (const referenceContractName of Object.keys(initializationData)) {\n    if (!contractsInitialized.has(referenceContractName)) {\n      throw new Error(\n        `Reference file has initialization data for ${referenceContractName}, but proposal does not specify initialization`\n      )\n    }\n  }\n\n  console.info('Initialization Data was verified!')\n}\n\n/*\n * This function will visit all contracts in `contracts` as well as any\n * linked libraries and verify that the compiled and linked source code matches\n * the deployed bytecode registered or proposed.\n */\nexport const verifyBytecodes = async (\n  contracts: string[],\n  artifacts: BuildArtifacts,\n  registry: RegistryInstance,\n  proposal: ProposalTx[],\n  Proxy: Truffle.Contract<ProxyInstance>,\n  _web3: Web3,\n  initializationData: InitializationData = {},\n  network = 'development'\n) => {\n  assertValidProposalTransactions(proposal)\n  assertValidInitializationData(artifacts, proposal, _web3, initializationData)\n\n  const queue = contracts.filter((contract) => !ignoredContracts.includes(contract))\n  const visited: Set<string> = new Set(queue)\n\n  // truffle web3 version does not have getProof\n  const web3 = new Web3(_web3.currentProvider)\n\n  const governanceAddress = await registry.getAddressForString('Governance')\n  const context: VerificationContext = {\n    artifacts,\n    libraryAddresses: new LibraryAddresses(),\n    registry,\n    governanceAddress,\n    proposal,\n    Proxy,\n    web3,\n    network,\n  }\n\n  while (queue.length > 0) {\n    await dfsStep(queue, visited, context)\n  }\n}"
    }
  ]
}