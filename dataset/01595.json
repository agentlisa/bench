{
  "Title": "M-3: Setting stable price in oracle can result in arbitrate opportunities and significant bad debt if the stable depegs",
  "Content": "# Issue M-3: Setting stable price in oracle can result in arbitrate opportunities and significant bad debt if the stable depegs \n\nSource: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/69 \n\n## Found by \nBauchibred, dirk\\_y, kutugu, lil.eth, minhtrng, n1punp, oakcobalt, p12473, rogue-lion-0619\n## Summary\nIn `Oracle.sol` there is the ability for governance to manually specify the price of an underlying asset (designed for stable coins). However, when the given stable coin depegs there is now the opportunity for arbitrage and even the possibility that Hubble becomes insolvent.\n\n## Vulnerability Detail\nFirstly, it is worth noting that stable coins depeg relatively frequently. For the sake of argument let's say that a stable coin is pegged to the US Dollar and the price is set by governance to `1000000` (to 6 decimal places) in the oracle.\n\nProbably the most important place in the protocol where the price of an asset is used is in `MarginAccount` in the `weightedAndSpotCollateral` method. This method is used under the hood to check whether a user can withdraw from the margin account and whether the user is able to be liquidated. It is also used in the AMM logic but I'll focus on the margin account case as I think that is the easiest to exploit.\n\nLet's now say that the stable coin depegs from its $1 price. Now, a user that has already used this stable coin as collateral in the margin account should have a lower value of collateral and therefore could be at risk of being liquidated. However, because the price of the stable coin is manually pegged to $1, the unhealthy trader's position will still appear healthy. If the stable coin failed to return to it's previous $1 value then even if the price of the stable coin was changed by governance to reflect the new lower value, the amount of bad debt accrued by Hubble would be huge at the time of liquidation/settlement.\n\nThe other scenario that will be used more actively by malicious users is that they will acquire the depegged stable coin from another source at its depegged value (e.g. $0.9). The malicious user can then deposit this stable coin into the Hubble margin account at the hard coded value of $1, and open positions with a value that should ordinarily put the trader into a bad debt position.\n\n## Impact\nA short term stable coin depeg event will result in accounts not being liquidated when they should be, and it will allow users to gain from arbitrage trades where they purchase a stable coin at its depegged price and are offered a higher price in Hubble.\n\nA permanent depeg will result in a huge amount of bad debt in Hubble and would likely cause the protocol to become insolvent due to the inability to perform liquidations during the downward price movement.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/Oracle.sol#L30-L32\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/Oracle.sol#L172\n\n## Tool used\nManual Review\n\n## Recommendation\nI would recommend not having the option to manually set and read the price of a stable coin. Yes, you protect accounts from being liquidated from a short term depeg event, however it is precisely in these volatile market periods that accounts should be able to be liquidated to prevent Hubble from accruing too much bad debt, particularly if the depeg is permanent, in which case it will likely cause Hubble to become insolvent.\n\n\n\n## Discussion\n\n**asquare08**\n\nWe are using stable price mechanism just for our testnet. We will use actual USDC price for the mainnet.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/72",
  "Code": [
    {
      "filename": "hubble-protocol/contracts/Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { Governable } from \"./legos/Governable.sol\";\nimport { AggregatorV3Interface } from \"./Interfaces.sol\";\n\ncontract Oracle is Governable {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    mapping(address => address) public chainLinkAggregatorMap;\n    mapping(address => int256) public stablePrice;\n\n    uint256[50] private __gap;\n\n    function initialize(address _governance) external initializer {\n        _setGovernace(_governance);\n    }\n\n    function getUnderlyingPrice(address underlying)\n        virtual\n        external\n        view\n        returns(int256 answer)\n    {\n        if (stablePrice[underlying] != 0) {\n            return stablePrice[underlying];\n        }\n        (,answer,,,) = AggregatorV3Interface(chainLinkAggregatorMap[underlying]).latestRoundData();\n        require(answer > 0, \"Oracle.getUnderlyingPrice.non_positive\");\n        answer /= 100;\n    }\n\n    function getUnderlyingTwapPrice(address underlying, uint256 intervalInSeconds)\n        virtual\n        public\n        view\n        returns (int256)\n    {\n        if (stablePrice[underlying] != 0) {\n            return stablePrice[underlying];\n        }\n        AggregatorV3Interface aggregator = AggregatorV3Interface(chainLinkAggregatorMap[underlying]);\n        requireNonEmptyAddress(address(aggregator));\n        require(intervalInSeconds != 0, \"interval can't be 0\");\n\n        // 3 different timestamps, `previous`, `current`, `target`\n        // `base` = now - intervalInSeconds\n        // `current` = current round timestamp from aggregator\n        // `previous` = previous round timestamp from aggregator\n        // now >= previous > current > = < base\n        //\n        //  while loop i = 0\n        //  --+------+-----+-----+-----+-----+-----+\n        //         base                 current  now(previous)\n        //\n        //  while loop i = 1\n        //  --+------+-----+-----+-----+-----+-----+\n        //         base           current previous now\n\n        (uint80 round, uint256 latestPrice, uint256 latestTimestamp) = getLatestRoundData(aggregator);\n        uint256 baseTimestamp = _blockTimestamp() - intervalInSeconds;\n        // if latest updated timestamp is earlier than target timestamp, return the latest price.\n        if (latestTimestamp < baseTimestamp || round == 0) {\n            return formatPrice(latestPrice);\n        }\n\n        // rounds are like snapshots, latestRound means the latest price snapshot. follow chainlink naming\n        uint256 previousTimestamp = latestTimestamp;\n        uint256 cumulativeTime = _blockTimestamp() - previousTimestamp;\n        uint256 weightedPrice = latestPrice * cumulativeTime;\n        while (true) {\n            if (round == 0) {\n                // if cumulative time is less than requested interval, return current twap price\n                return formatPrice(weightedPrice / cumulativeTime);\n            }\n\n            round = round - 1; // check round sanity\n            (, uint256 currentPrice, uint256 currentTimestamp) = getRoundData(aggregator, round);\n\n            // check if current round timestamp is earlier than target timestamp\n            if (currentTimestamp <= baseTimestamp) {\n                // weighted time period will be (target timestamp - previous timestamp). For example,\n                // now is 1000, intervalInSeconds is 100, then target timestamp is 900. If timestamp of current round is 970,\n                // and timestamp of NEXT round is 880, then the weighted time period will be (970 - 900) = 70,\n                // instead of (970 - 880)\n                weightedPrice = weightedPrice + (currentPrice * (previousTimestamp - baseTimestamp));\n                break;\n            }\n\n            uint256 timeFraction = previousTimestamp - currentTimestamp;\n            weightedPrice = weightedPrice + (currentPrice * timeFraction);\n            cumulativeTime = cumulativeTime + timeFraction;\n            previousTimestamp = currentTimestamp;\n        }\n        return formatPrice(weightedPrice / intervalInSeconds);\n    }\n\n    //\n    // INTERNAL VIEW FUNCTIONS\n    //\n\n    function getLatestRoundData(AggregatorV3Interface _aggregator)\n        internal\n        view\n        returns (\n            uint80,\n            uint256 finalPrice,\n            uint256\n        )\n    {\n        (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.latestRoundData();\n        finalPrice = uint256(latestPrice);\n        if (latestPrice <= 0) {\n            requireEnoughHistory(round);\n            (round, finalPrice, latestTimestamp) = getRoundData(_aggregator, round - 1);\n        }\n        return (round, finalPrice, latestTimestamp);\n    }\n\n    function getRoundData(AggregatorV3Interface _aggregator, uint80 _round)\n        internal\n        view\n        returns (\n            uint80,\n            uint256,\n            uint256\n        )\n    {\n        (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.getRoundData(_round);\n        while (latestPrice <= 0) {\n            requireEnoughHistory(round);\n            round = round - 1;\n            (, latestPrice, , latestTimestamp, ) = _aggregator.getRoundData(round);\n        }\n        return (round, uint256(latestPrice), latestTimestamp);\n    }\n\n    function formatPrice(uint256 _price) internal pure returns (int256) {\n        return (_price / 100).toInt256(); // 6 decimals\n    }\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    // Internal\n\n    function requireEnoughHistory(uint80 _round) internal pure {\n        require(_round > 0, \"Not enough history\");\n    }\n\n    function requireNonEmptyAddress(address _addr) internal pure {\n        require(_addr != address(0), \"empty address\");\n    }\n\n    // Governance\n\n    function setAggregator(address underlying, address aggregator) external onlyGovernance {\n        requireNonEmptyAddress(underlying);\n        requireNonEmptyAddress(aggregator);\n        // oracle answer should be in 8 decimals\n        require(AggregatorV3Interface(aggregator).decimals() == 8, 'Expected oracle to have 8 decimals');\n        chainLinkAggregatorMap[underlying] = aggregator;\n        // AggregatorV3Interface(chainLinkAggregatorMap[underlying]).latestRoundData(); // sanity check\n    }\n\n    function setStablePrice(address underlying, int256 price) external onlyGovernance {\n        requireNonEmptyAddress(underlying);\n        require(price > 0, \"stablePrice=0\");\n        stablePrice[underlying] = price;\n    }\n}"
    },
    {
      "filename": "hubble-protocol/contracts/Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { Governable } from \"./legos/Governable.sol\";\nimport { AggregatorV3Interface } from \"./Interfaces.sol\";\n\ncontract Oracle is Governable {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    mapping(address => address) public chainLinkAggregatorMap;\n    mapping(address => int256) public stablePrice;\n\n    uint256[50] private __gap;\n\n    function initialize(address _governance) external initializer {\n        _setGovernace(_governance);\n    }\n\n    function getUnderlyingPrice(address underlying)\n        virtual\n        external\n        view\n        returns(int256 answer)\n    {\n        if (stablePrice[underlying] != 0) {\n            return stablePrice[underlying];\n        }\n        (,answer,,,) = AggregatorV3Interface(chainLinkAggregatorMap[underlying]).latestRoundData();\n        require(answer > 0, \"Oracle.getUnderlyingPrice.non_positive\");\n        answer /= 100;\n    }\n\n    function getUnderlyingTwapPrice(address underlying, uint256 intervalInSeconds)\n        virtual\n        public\n        view\n        returns (int256)\n    {\n        if (stablePrice[underlying] != 0) {\n            return stablePrice[underlying];\n        }\n        AggregatorV3Interface aggregator = AggregatorV3Interface(chainLinkAggregatorMap[underlying]);\n        requireNonEmptyAddress(address(aggregator));\n        require(intervalInSeconds != 0, \"interval can't be 0\");\n\n        // 3 different timestamps, `previous`, `current`, `target`\n        // `base` = now - intervalInSeconds\n        // `current` = current round timestamp from aggregator\n        // `previous` = previous round timestamp from aggregator\n        // now >= previous > current > = < base\n        //\n        //  while loop i = 0\n        //  --+------+-----+-----+-----+-----+-----+\n        //         base                 current  now(previous)\n        //\n        //  while loop i = 1\n        //  --+------+-----+-----+-----+-----+-----+\n        //         base           current previous now\n\n        (uint80 round, uint256 latestPrice, uint256 latestTimestamp) = getLatestRoundData(aggregator);\n        uint256 baseTimestamp = _blockTimestamp() - intervalInSeconds;\n        // if latest updated timestamp is earlier than target timestamp, return the latest price.\n        if (latestTimestamp < baseTimestamp || round == 0) {\n            return formatPrice(latestPrice);\n        }\n\n        // rounds are like snapshots, latestRound means the latest price snapshot. follow chainlink naming\n        uint256 previousTimestamp = latestTimestamp;\n        uint256 cumulativeTime = _blockTimestamp() - previousTimestamp;\n        uint256 weightedPrice = latestPrice * cumulativeTime;\n        while (true) {\n            if (round == 0) {\n                // if cumulative time is less than requested interval, return current twap price\n                return formatPrice(weightedPrice / cumulativeTime);\n            }\n\n            round = round - 1; // check round sanity\n            (, uint256 currentPrice, uint256 currentTimestamp) = getRoundData(aggregator, round);\n\n            // check if current round timestamp is earlier than target timestamp\n            if (currentTimestamp <= baseTimestamp) {\n                // weighted time period will be (target timestamp - previous timestamp). For example,\n                // now is 1000, intervalInSeconds is 100, then target timestamp is 900. If timestamp of current round is 970,\n                // and timestamp of NEXT round is 880, then the weighted time period will be (970 - 900) = 70,\n                // instead of (970 - 880)\n                weightedPrice = weightedPrice + (currentPrice * (previousTimestamp - baseTimestamp));\n                break;\n            }\n\n            uint256 timeFraction = previousTimestamp - currentTimestamp;\n            weightedPrice = weightedPrice + (currentPrice * timeFraction);\n            cumulativeTime = cumulativeTime + timeFraction;\n            previousTimestamp = currentTimestamp;\n        }\n        return formatPrice(weightedPrice / intervalInSeconds);\n    }\n\n    //\n    // INTERNAL VIEW FUNCTIONS\n    //\n\n    function getLatestRoundData(AggregatorV3Interface _aggregator)\n        internal\n        view\n        returns (\n            uint80,\n            uint256 finalPrice,\n            uint256\n        )\n    {\n        (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.latestRoundData();\n        finalPrice = uint256(latestPrice);\n        if (latestPrice <= 0) {\n            requireEnoughHistory(round);\n            (round, finalPrice, latestTimestamp) = getRoundData(_aggregator, round - 1);\n        }\n        return (round, finalPrice, latestTimestamp);\n    }\n\n    function getRoundData(AggregatorV3Interface _aggregator, uint80 _round)\n        internal\n        view\n        returns (\n            uint80,\n            uint256,\n            uint256\n        )\n    {\n        (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.getRoundData(_round);\n        while (latestPrice <= 0) {\n            requireEnoughHistory(round);\n            round = round - 1;\n            (, latestPrice, , latestTimestamp, ) = _aggregator.getRoundData(round);\n        }\n        return (round, uint256(latestPrice), latestTimestamp);\n    }\n\n    function formatPrice(uint256 _price) internal pure returns (int256) {\n        return (_price / 100).toInt256(); // 6 decimals\n    }\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    // Internal\n\n    function requireEnoughHistory(uint80 _round) internal pure {\n        require(_round > 0, \"Not enough history\");\n    }\n\n    function requireNonEmptyAddress(address _addr) internal pure {\n        require(_addr != address(0), \"empty address\");\n    }\n\n    // Governance\n\n    function setAggregator(address underlying, address aggregator) external onlyGovernance {\n        requireNonEmptyAddress(underlying);\n        requireNonEmptyAddress(aggregator);\n        // oracle answer should be in 8 decimals\n        require(AggregatorV3Interface(aggregator).decimals() == 8, 'Expected oracle to have 8 decimals');\n        chainLinkAggregatorMap[underlying] = aggregator;\n        // AggregatorV3Interface(chainLinkAggregatorMap[underlying]).latestRoundData(); // sanity check\n    }\n\n    function setStablePrice(address underlying, int256 price) external onlyGovernance {\n        requireNonEmptyAddress(underlying);\n        require(price > 0, \"stablePrice=0\");\n        stablePrice[underlying] = price;\n    }\n}"
    }
  ]
}