{
  "Title": "[M-05] NFT not minted when contributed via a supported payment terminal",
  "Content": "\nA contributor won't get an NFT they're eligible for if the payment is made through a payment terminal that's supported by the project but not by the NFT delegate.\n\n### Proof of Concept\n\nA Juicebox project can use multiple [payment terminals](https://info.juicebox.money/dev/learn/glossary/payment-terminal) to receive contributions ([JBController.sol#L441-L442](https://github.com/jbx-protocol/juice-contracts-v3/blob/main/contracts/JBController.sol#L441-L442)).  Payment terminals are single token payment terminals ([JBPayoutRedemptionPaymentTerminal.sol#L310](https://github.com/jbx-protocol/juice-contracts-v3/blob/main/contracts/abstract/JBPayoutRedemptionPaymentTerminal.sol#L310)) that support only one currency ([JBSingleTokenPaymentTerminal.sol#L124-L132](https://github.com/jbx-protocol/juice-contracts-v3/blob/main/contracts/abstract/JBSingleTokenPaymentTerminal.sol#L124-L132)). Since projects can have multiple terminals, they can receive payments in multiple currencies.\n\nHowever, the NFT delegate supports only one currency ([JBTiered721Delegate.sol#L225](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721Delegate.sol#L225)):\n\n```solidity\nfunction initialize(\n  uint256 _projectId,\n  IJBDirectory _directory,\n  string memory _name,\n  string memory _symbol,\n  IJBFundingCycleStore _fundingCycleStore,\n  string memory _baseUri,\n  IJBTokenUriResolver _tokenUriResolver,\n  string memory _contractUri,\n  JB721PricingParams memory _pricing,\n  IJBTiered721DelegateStore _store,\n  JBTiered721Flags memory _flags\n) public override {\n  // Make the original un-initializable.\n  require(address(this) != codeOrigin);\n  // Stop re-initialization.\n  require(address(store) == address(0));\n\n  // Initialize the sub class.\n  JB721Delegate._initialize(_projectId, _directory, _name, _symbol);\n\n  fundingCycleStore = _fundingCycleStore;\n  store = _store;\n  pricingCurrency = _pricing.currency; // @audit only one currency is supported\n  pricingDecimals = _pricing.decimals;\n  prices = _pricing.prices;\n\n  ...\n}\n```\n\nWhen a payment is made in a currency that's supported by the project (via one of its terminals) but not by the NFT delegate, there's an attempt to convert the currency to a supported one ([JBTiered721Delegate.sol#L527-L534](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721Delegate.sol#L527-L534)):\n\n```solidity\nif (_data.amount.currency == pricingCurrency) _value = _data.amount.value;\nelse if (prices != IJBPrices(address(0)))\n  _value = PRBMath.mulDiv(\n    _data.amount.value,\n    10**pricingDecimals,\n    prices.priceFor(_data.amount.currency, pricingCurrency, _data.amount.decimals)\n  );\nelse return;\n```\n\nHowever, since `prices` is optional (it can be set to the zero address, as seen from the snippet), the conversion step can be skipped. When this happens, the contributor gets no NFT due to the early `return` even though the amount of their contribution might still be eligible for a tiered NFT.\n\n### Recommended Mitigation Steps\n\nShort term, consider reverting when a different currency is used and `prices` is not set. Long term, consider supporting multiple currencies in the NFT delegate.\n\n**[drgorillamd (Juicebox DAO) disputed](https://github.com/code-423n4/2022-10-juicebox-findings/issues/124)**\n> This is poor project management from the project owner (not adding the appropriate price feed), not a vulnerability\n> \n> And there is no revert here as to not freeze the Juicebox project (NFT reward is an add-on, there is a full project running behind)\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2022-10-juicebox-findings/issues/124#issuecomment-1305939427):**\n > As this finding:\n>  - would lead to a leak of value\n>  - is conditional on the project owner's mistake (that seems not so unlikely as they may think that one currency is enough and that they don't need to set `prices`)\n>  - but ultimately lead to a loss of funds for users\n>  \n>  I believe Medium severity to be appropriate\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-juicebox-contest",
  "Code": [
    {
      "filename": "contracts/JBController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {ERC165} from '@openzeppelin/contracts/utils/introspection/ERC165.sol';\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/math/SafeCast.sol';\nimport {PRBMath} from '@paulrberg/contracts/math/PRBMath.sol';\nimport {JBOperatable} from './abstract/JBOperatable.sol';\nimport {JBBallotState} from './enums/JBBallotState.sol';\nimport {IJBController} from './interfaces/IJBController.sol';\nimport {IJBDirectory} from './interfaces/IJBDirectory.sol';\nimport {IJBFundingCycleStore} from './interfaces/IJBFundingCycleStore.sol';\nimport {IJBMigratable} from './interfaces/IJBMigratable.sol';\nimport {IJBOperatable} from './interfaces/IJBOperatable.sol';\nimport {IJBOperatorStore} from './interfaces/IJBOperatorStore.sol';\nimport {IJBPaymentTerminal} from './interfaces/IJBPaymentTerminal.sol';\nimport {IJBProjects} from './interfaces/IJBProjects.sol';\nimport {IJBSplitAllocator} from './interfaces/IJBSplitAllocator.sol';\nimport {IJBSplitsStore} from './interfaces/IJBSplitsStore.sol';\nimport {IJBTokenStore} from './interfaces/IJBTokenStore.sol';\nimport {JBConstants} from './libraries/JBConstants.sol';\nimport {JBFundingCycleMetadataResolver} from './libraries/JBFundingCycleMetadataResolver.sol';\nimport {JBOperations} from './libraries/JBOperations.sol';\nimport {JBSplitsGroups} from './libraries/JBSplitsGroups.sol';\nimport {JBSplitAllocationData} from './structs/JBSplitAllocationData.sol';\nimport {JBFundAccessConstraints} from './structs/JBFundAccessConstraints.sol';\nimport {JBFundingCycle} from './structs/JBFundingCycle.sol';\nimport {JBFundingCycleData} from './structs/JBFundingCycleData.sol';\nimport {JBFundingCycleMetadata} from './structs/JBFundingCycleMetadata.sol';\nimport {JBGroupedSplits} from './structs/JBGroupedSplits.sol';\nimport {JBProjectMetadata} from './structs/JBProjectMetadata.sol';\nimport {JBSplit} from './structs/JBSplit.sol';\n\n/// @notice Stitches together funding cycles and project tokens, making sure all activity is accounted for and correct.\ncontract JBController is JBOperatable, ERC165, IJBController, IJBMigratable {\n  // A library that parses the packed funding cycle metadata into a more friendly format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n  error FUNDING_CYCLE_ALREADY_LAUNCHED();\n  error INVALID_BALLOT_REDEMPTION_RATE();\n  error INVALID_DISTRIBUTION_LIMIT();\n  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n  error INVALID_OVERFLOW_ALLOWANCE();\n  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n  error INVALID_REDEMPTION_RATE();\n  error INVALID_RESERVED_RATE();\n  error MIGRATION_NOT_ALLOWED();\n  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n  error NO_BURNABLE_TOKENS();\n  error NOT_CURRENT_CONTROLLER();\n  error ZERO_TOKENS_TO_MINT();\n\n  //*********************************************************************//\n  // --------------------- internal stored properties ------------------ //\n  //*********************************************************************//\n\n  /// @notice The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.\n  /// @custom:param _projectId The ID of the project to get the tracker of.\n  mapping(uint256 => int256) internal _processedTokenTrackerOf;\n\n  /// @notice Data regarding the distribution limit of a project during a configuration.\n  /// @dev bits 0-231: The amount of token that a project can distribute per funding cycle.\n  /// @dev bits 232-255: The currency of amount that a project can distribute.\n  /// @custom:param _projectId The ID of the project to get the packed distribution limit data of.\n  /// @custom:param _configuration The configuration during which the packed distribution limit data applies.\n  /// @custom:param _terminal The terminal from which distributions are being limited.\n  /// @custom:param _token The token for which distributions are being limited.\n  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))\n    internal _packedDistributionLimitDataOf;\n\n  /// @notice Data regarding the overflow allowance of a project during a configuration.\n  /// @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.\n  /// @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.\n  /// @custom:param _projectId The ID of the project to get the packed overflow allowance data of.\n  /// @custom:param _configuration The configuration during which the packed overflow allowance data applies.\n  /// @custom:param _terminal The terminal managing the overflow.\n  /// @custom:param _token The token for which overflow is being allowed.\n  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))\n    internal _packedOverflowAllowanceDataOf;\n\n  //*********************************************************************//\n  // --------------- public immutable stored properties ---------------- //\n  //*********************************************************************//\n\n  /// @notice Mints ERC-721's that represent project ownership.\n  IJBProjects public immutable override projects;\n\n  /// @notice The contract storing all funding cycle configurations.\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  /// @notice The contract that manages token minting and burning.\n  IJBTokenStore public immutable override tokenStore;\n\n  /// @notice The contract that stores splits for each project.\n  IJBSplitsStore public immutable override splitsStore;\n\n  /// @notice The directory of terminals and controllers for projects.\n  IJBDirectory public immutable override directory;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /// @notice The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.\n  /// @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.\n  /// @param _projectId The ID of the project to get the distribution limit of.\n  /// @param _configuration The configuration during which the distribution limit applies.\n  /// @param _terminal The terminal from which distributions are being limited.\n  /// @param _token The token for which the distribution limit applies.\n  /// @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.\n  /// @return The currency of the distribution limit.\n  function distributionLimitOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The limit is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data >> 232);\n  }\n\n  /// @notice The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.\n  /// @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.\n  /// @param _projectId The ID of the project to get the overflow allowance of.\n  /// @param _configuration The configuration of the during which the allowance applies.\n  /// @param _terminal The terminal managing the overflow.\n  /// @param _token The token for which the overflow allowance applies.\n  /// @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.\n  /// @return The currency of the overflow allowance.\n  function overflowAllowanceOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The allowance is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data >> 232);\n  }\n\n  /// @notice Gets the amount of reserved tokens that a project has available to distribute.\n  /// @param _projectId The ID of the project to get a reserved token balance of.\n  /// @param _reservedRate The reserved rate to use when making the calculation.\n  /// @return The current amount of reserved tokens.\n  function reservedTokenBalanceOf(\n    uint256 _projectId,\n    uint256 _reservedRate\n  ) external view override returns (uint256) {\n    return\n      _reservedTokenAmountFrom(\n        _processedTokenTrackerOf[_projectId],\n        _reservedRate,\n        tokenStore.totalSupplyOf(_projectId)\n      );\n  }\n\n  /// @notice Gets the current total amount of outstanding tokens for a project, given a reserved rate.\n  /// @param _projectId The ID of the project to get total outstanding tokens of.\n  /// @param _reservedRate The reserved rate to use when making the calculation.\n  /// @return The current total amount of outstanding tokens for the project.\n  function totalOutstandingTokensOf(\n    uint256 _projectId,\n    uint256 _reservedRate\n  ) external view override returns (uint256) {\n    // Get the total number of tokens in circulation.\n    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);\n\n    // Get the number of reserved tokens the project has.\n    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _reservedRate,\n      _totalSupply\n    );\n\n    // Add the reserved tokens to the total supply.\n    return _totalSupply + _reservedTokenAmount;\n  }\n\n  /// @notice A project's funding cycle for the specified configuration along with its metadata.\n  /// @param _projectId The ID of the project to which the funding cycle belongs.\n  /// @return fundingCycle The funding cycle.\n  /// @return metadata The funding cycle's metadata.\n  function getFundingCycleOf(\n    uint256 _projectId,\n    uint256 _configuration\n  )\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.get(_projectId, _configuration);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  /// @notice A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.\n  /// @param _projectId The ID of the project to which the funding cycle belongs.\n  /// @return fundingCycle The latest configured funding cycle.\n  /// @return metadata The latest configured funding cycle's metadata.\n  /// @return ballotState The state of the configuration.\n  function latestConfiguredFundingCycleOf(\n    uint256 _projectId\n  )\n    external\n    view\n    override\n    returns (\n      JBFundingCycle memory fundingCycle,\n      JBFundingCycleMetadata memory metadata,\n      JBBallotState ballotState\n    )\n  {\n    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  /// @notice A project's current funding cycle along with its metadata.\n  /// @param _projectId The ID of the project to which the funding cycle belongs.\n  /// @return fundingCycle The current funding cycle.\n  /// @return metadata The current funding cycle's metadata.\n  function currentFundingCycleOf(\n    uint256 _projectId\n  )\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  /// @notice A project's queued funding cycle along with its metadata.\n  /// @param _projectId The ID of the project to which the funding cycle belongs.\n  /// @return fundingCycle The queued funding cycle.\n  /// @return metadata The queued funding cycle's metadata.\n  function queuedFundingCycleOf(\n    uint256 _projectId\n  )\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.queuedOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  //*********************************************************************//\n  // -------------------------- public views --------------------------- //\n  //*********************************************************************//\n\n  /// @notice Indicates if this contract adheres to the specified interface.\n  /// @dev See {IERC165-supportsInterface}.\n  /// @param _interfaceId The ID of the interface to check for adherance to.\n  /// @return A flag indicating if the provided interface ID is supported.\n  function supportsInterface(\n    bytes4 _interfaceId\n  ) public view virtual override(ERC165, IERC165) returns (bool) {\n    return\n      _interfaceId == type(IJBController).interfaceId ||\n      _interfaceId == type(IJBMigratable).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //*********************************************************************//\n  // ---------------------------- constructor -------------------------- //\n  //*********************************************************************//\n\n  /// @param _operatorStore A contract storing operator assignments.\n  /// @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n  /// @param _directory A contract storing directories of terminals and controllers for each project.\n  /// @param _fundingCycleStore A contract storing all funding cycle configurations.\n  /// @param _tokenStore A contract that manages token minting and burning.\n  /// @param _splitsStore A contract that stores splits for each project.\n  constructor(\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBTokenStore _tokenStore,\n    IJBSplitsStore _splitsStore\n  ) JBOperatable(_operatorStore) {\n    projects = _projects;\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    tokenStore = _tokenStore;\n    splitsStore = _splitsStore;\n  }\n\n  //*********************************************************************//\n  // --------------------- external transactions ----------------------- //\n  //*********************************************************************//\n\n  /// @notice Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.\n  /// @dev Each operation within this transaction can be done in sequence separately.\n  /// @dev Anyone can deploy a project on an owner's behalf.\n  /// @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.\n  /// @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.\n  /// @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n  /// @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n  /// @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n  /// @param _groupedSplits An array of splits to set for any number of groups.\n  /// @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.\n  /// @param _terminals Payment terminals to add for the project.\n  /// @param _memo A memo to pass along to the emitted event.\n  /// @return projectId The ID of the project.\n  function launchProjectFor(\n    address _owner,\n    JBProjectMetadata calldata _projectMetadata,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  ) external virtual override returns (uint256 projectId) {\n    // Keep a reference to the directory.\n    IJBDirectory _directory = directory;\n\n    // Mint the project into the wallet of the owner.\n    projectId = projects.createFor(_owner, _projectMetadata);\n\n    // Set this contract as the project's controller in the directory.\n    _directory.setControllerOf(projectId, address(this));\n\n    // Configure the first funding cycle.\n    uint256 _configuration = _configure(\n      projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length > 0) _directory.setTerminalsOf(projectId, _terminals);\n\n    emit LaunchProject(_configuration, projectId, _memo, msg.sender);\n  }\n\n  /// @notice Creates a funding cycle for an already existing project ERC-721.\n  /// @dev Each operation within this transaction can be done in sequence separately.\n  /// @dev Only a project owner or operator can launch its funding cycles.\n  /// @param _projectId The ID of the project to launch funding cycles for.\n  /// @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n  /// @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n  /// @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n  /// @param _groupedSplits An array of splits to set for any number of groups.\n  /// @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.\n  /// @param _terminals Payment terminals to add for the project.\n  /// @param _memo A memo to pass along to the emitted event.\n  /// @return configuration The configuration of the funding cycle that was successfully created.\n  function launchFundingCyclesFor(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead\n    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)\n      revert FUNDING_CYCLE_ALREADY_LAUNCHED();\n\n    // Set this contract as the project's controller in the directory.\n    directory.setControllerOf(_projectId, address(this));\n\n    // Configure the first funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);\n\n    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  /// @notice Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.\n  /// @dev Only a project's owner or a designated operator can configure its funding cycles.\n  /// @param _projectId The ID of the project whose funding cycles are being reconfigured.\n  /// @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.\n  /// @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n  /// @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n  /// @param _groupedSplits An array of splits to set for any number of groups.\n  /// @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.\n  /// @param _memo A memo to pass along to the emitted event.\n  /// @return configuration The configuration of the funding cycle that was successfully reconfigured.\n  function reconfigureFundingCyclesOf(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    string calldata _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // Configure the next funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  /// @notice Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.\n  /// @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.\n  /// @param _projectId The ID of the project to which the tokens being minted belong.\n  /// @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.\n  /// @param _beneficiary The account that the tokens are being minted for.\n  /// @param _memo A memo to pass along to the emitted event.\n  /// @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.\n  /// @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.\n  /// @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.\n  function mintTokensOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _beneficiary,\n    string calldata _memo,\n    bool _preferClaimedTokens,\n    bool _useReservedRate\n  ) external virtual override returns (uint256 beneficiaryTokenCount) {\n    // There should be tokens to mint.\n    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();\n\n    // Define variables that will be needed outside scoped section below.\n    // Keep a reference to the reserved rate to use\n    uint256 _reservedRate;\n\n    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.\n    {\n      // Get a reference to the project's current funding cycle.\n      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source\n      _requirePermissionAllowingOverride(\n        projects.ownerOf(_projectId),\n        _projectId,\n        JBOperations.MINT,\n        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||\n          msg.sender == address(_fundingCycle.dataSource())\n      );\n\n      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.\n      if (\n        !_fundingCycle.mintingAllowed() &&\n        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&\n        msg.sender != address(_fundingCycle.dataSource())\n      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n\n      // Determine the reserved rate to use.\n      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;\n\n      // Override the claimed token preference with the funding cycle value.\n      _preferClaimedTokens = _preferClaimedTokens == true\n        ? _preferClaimedTokens\n        : _fundingCycle.preferClaimedTokenOverride();\n    }\n\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)\n      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.\n      _processedTokenTrackerOf[_projectId] =\n        _processedTokenTrackerOf[_projectId] -\n        SafeCast.toInt256(_tokenCount);\n    else {\n      // The unreserved token count that will be minted for the beneficiary.\n      beneficiaryTokenCount = PRBMath.mulDiv(\n        _tokenCount,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate,\n        JBConstants.MAX_RESERVED_RATE\n      );\n\n      if (_reservedRate == 0)\n        // If there's no reserved rate, increment the tracker with the newly minted tokens.\n        _processedTokenTrackerOf[_projectId] =\n          _processedTokenTrackerOf[_projectId] +\n          SafeCast.toInt256(beneficiaryTokenCount);\n\n      // Mint the tokens.\n      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);\n    }\n\n    emit MintTokens(\n      _beneficiary,\n      _projectId,\n      _tokenCount,\n      beneficiaryTokenCount,\n      _memo,\n      _reservedRate,\n      msg.sender\n    );\n  }\n\n  /// @notice Burns a token holder's supply.\n  /// @dev Only a token's holder, a designated operator, or a project's terminal can burn it.\n  /// @param _holder The account that is having its tokens burned.\n  /// @param _projectId The ID of the project to which the tokens being burned belong.\n  /// @param _tokenCount The number of tokens to burn.\n  /// @param _memo A memo to pass along to the emitted event.\n  /// @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.\n  function burnTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string calldata _memo,\n    bool _preferClaimedTokens\n  )\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      _holder,\n      _projectId,\n      JBOperations.BURN,\n      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    )\n  {\n    // There should be tokens to burn\n    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // If the message sender is a terminal, the current funding cycle must not be paused.\n    if (\n      _fundingCycle.burnPaused() &&\n      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n\n    // Update the token tracker so that reserved tokens will still be correctly mintable.\n    _processedTokenTrackerOf[_projectId] =\n      _processedTokenTrackerOf[_projectId] -\n      SafeCast.toInt256(_tokenCount);\n\n    // Burn the tokens.\n    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);\n\n    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);\n  }\n\n  /// @notice Distributes all outstanding reserved tokens for a project.\n  /// @param _projectId The ID of the project to which the reserved tokens belong.\n  /// @param _memo A memo to pass along to the emitted event.\n  /// @return The amount of minted reserved tokens.\n  function distributeReservedTokensOf(\n    uint256 _projectId,\n    string calldata _memo\n  ) external virtual override returns (uint256) {\n    return _distributeReservedTokensOf(_projectId, _memo);\n  }\n\n  /// @notice Allows other controllers to signal to this one that a migration is expected for the specified project.\n  /// @dev This controller should not yet be the project's controller.\n  /// @param _projectId The ID of the project that will be migrated to this controller.\n  /// @param _from The controller being migrated from.\n  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {\n    // This controller must not be the project's current controller.\n    if (directory.controllerOf(_projectId) == address(this))\n      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n\n    // Set the tracker as the total supply.\n    _processedTokenTrackerOf[_projectId] = SafeCast.toInt256(tokenStore.totalSupplyOf(_projectId));\n\n    emit PrepMigration(_projectId, _from, msg.sender);\n  }\n\n  /// @notice Allows a project to migrate from this controller to another.\n  /// @dev Only a project's owner or a designated operator can migrate it.\n  /// @param _projectId The ID of the project that will be migrated from this controller.\n  /// @param _to The controller to which the project is migrating.\n  function migrate(\n    uint256 _projectId,\n    IJBMigratable _to\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)\n  {\n    // Keep a reference to the directory.\n    IJBDirectory _directory = directory;\n\n    // This controller must be the project's current controller.\n    if (_directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Migration must be allowed.\n    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();\n\n    // All reserved tokens must be minted before migrating.\n    if (\n      _processedTokenTrackerOf[_projectId] < 0 ||\n      uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId)\n    ) _distributeReservedTokensOf(_projectId, '');\n\n    // Make sure the new controller is prepped for the migration.\n    _to.prepForMigrationOf(_projectId, address(this));\n\n    // Set the new controller.\n    _directory.setControllerOf(_projectId, address(_to));\n\n    emit Migrate(_projectId, _to, msg.sender);\n  }\n\n  //*********************************************************************//\n  // ------------------------ internal functions ----------------------- //\n  //*********************************************************************//\n\n  /// @notice Distributes all outstanding reserved tokens for a project.\n  /// @param _projectId The ID of the project to which the reserved tokens belong.\n  /// @param _memo A memo to pass along to the emitted event.\n  /// @return tokenCount The amount of minted reserved tokens.\n  function _distributeReservedTokensOf(\n    uint256 _projectId,\n    string memory _memo\n  ) internal returns (uint256 tokenCount) {\n    // Keep a reference to the token store.\n    IJBTokenStore _tokenStore = tokenStore;\n\n    // Get the current funding cycle to read the reserved rate from.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get a reference to new total supply of tokens before minting reserved tokens.\n    uint256 _totalTokens = _tokenStore.totalSupplyOf(_projectId);\n\n    // Get a reference to the number of tokens that need to be minted.\n    tokenCount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _fundingCycle.reservedRate(),\n      _totalTokens\n    );\n\n    // Set the tracker to be the new total supply.\n    _processedTokenTrackerOf[_projectId] = SafeCast.toInt256(_totalTokens + tokenCount);\n\n    // Get a reference to the"
    }
  ]
}