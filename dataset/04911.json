{
  "Title": "[L-02]  __ERC1155Receiver_init() not initialized in ERC1155Vault",
  "Content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L29)\n\nConsider initializing these functions in an init() function in the ERC1155Vault contract.\n```solidity\nFile: ERC1155ReceiverUpgradeable.sol\n14:     function __ERC1155Receiver_init() internal onlyInitializing {\n15:     }\n16: \n17:     function __ERC1155Receiver_init_unchained() internal onlyInitializing {\n18:     }\n```\n\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/tokenvault/ERC1155Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol\";\nimport \"../bridge/IBridge.sol\";\nimport \"../libs/LibAddress.sol\";\nimport \"./BaseNFTVault.sol\";\nimport \"./BridgedERC1155.sol\";\n\n/// @title IERC1155NameAndSymbol\n/// @notice Interface for ERC1155 contracts that provide name() and symbol()\n/// functions. These functions may not be part of the official interface but are\n/// used by some contracts.\n/// @custom:security-contact security@taiko.xyz\ninterface IERC1155NameAndSymbol {\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n}\n\n/// @title ERC1155Vault\n/// @dev Labeled in AddressResolver as \"erc1155_vault\"\n/// @notice This vault holds all ERC1155 tokens that users have deposited.\n/// It also manages the mapping between canonical tokens and their bridged\n/// tokens.\ncontract ERC1155Vault is BaseNFTVault, ERC1155ReceiverUpgradeable {\n    using LibAddress for address;\n\n    uint256[50] private __gap;\n\n    /// @notice Transfers ERC1155 tokens to this vault and sends a message to\n    /// the destination chain so the user can receive the same (bridged) tokens\n    /// by invoking the message call.\n    /// @param _op Option for sending the ERC1155 token.\n    /// @return message_ The constructed message.\n    function sendToken(BridgeTransferOp memory _op)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n        withValidOperation(_op)\n        returns (IBridge.Message memory message_)\n    {\n        for (uint256 i; i < _op.amounts.length; ++i) {\n            if (_op.amounts[i] == 0) revert VAULT_INVALID_AMOUNT();\n        }\n        // Check token interface support\n        if (!_op.token.supportsInterface(ERC1155_INTERFACE_ID)) {\n            revert VAULT_INTERFACE_NOT_SUPPORTED();\n        }\n\n        (bytes memory data, CanonicalNFT memory ctoken) = _handleMessage(msg.sender, _op);\n\n        // Create a message to send to the destination chain\n        IBridge.Message memory message = IBridge.Message({\n            id: 0, // will receive a new value\n            from: address(0), // will receive a new value\n            srcChainId: 0, // will receive a new value\n            destChainId: _op.destChainId,\n            srcOwner: msg.sender,\n            destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,\n            to: resolve(_op.destChainId, name(), false),\n            refundTo: _op.refundTo,\n            value: msg.value - _op.fee,\n            fee: _op.fee,\n            gasLimit: _op.gasLimit,\n            data: data,\n            memo: _op.memo\n        });\n\n        // Send the message and obtain the message hash\n        bytes32 msgHash;\n        (msgHash, message_) =\n            IBridge(resolve(\"bridge\", false)).sendMessage{ value: msg.value }(message);\n\n        // Emit TokenSent event\n        emit TokenSent({\n            msgHash: msgHash,\n            from: message_.srcOwner,\n            to: _op.to,\n            destChainId: message_.destChainId,\n            ctoken: ctoken.addr,\n            token: _op.token,\n            tokenIds: _op.tokenIds,\n            amounts: _op.amounts\n        });\n    }\n\n    /// @inheritdoc IMessageInvocable\n    function onMessageInvocation(bytes calldata data) external payable nonReentrant whenNotPaused {\n        (\n            CanonicalNFT memory ctoken,\n            address from,\n            address to,\n            uint256[] memory tokenIds,\n            uint256[] memory amounts\n        ) = abi.decode(data, (CanonicalNFT, address, address, uint256[], uint256[]));\n\n        // Check context validity\n        // `onlyFromBridge` checked in checkProcessMessageContext\n        IBridge.Context memory ctx = checkProcessMessageContext();\n\n        // Don't allow sending to disallowed addresses.\n        // Don't send the tokens back to `from` because `from` is on the source chain.\n        if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO();\n\n        // Transfer the ETH and the tokens to the `to` address\n        address token = _transferTokens(ctoken, to, tokenIds, amounts);\n        to.sendEther(msg.value);\n\n        emit TokenReceived({\n            msgHash: ctx.msgHash,\n            from: from,\n            to: to,\n            srcChainId: ctx.srcChainId,\n            ctoken: ctoken.addr,\n            token: token,\n            tokenIds: tokenIds,\n            amounts: amounts\n        });\n    }\n\n    /// @inheritdoc IRecallableSender\n    function onMessageRecalled(\n        IBridge.Message calldata message,\n        bytes32 msgHash\n    )\n        external\n        payable\n        override\n        nonReentrant\n        whenNotPaused\n    {\n        // `onlyFromBridge` checked in checkRecallMessageContext\n        checkRecallMessageContext();\n\n        (bytes memory data) = abi.decode(message.data[4:], (bytes));\n        (CanonicalNFT memory ctoken,,, uint256[] memory tokenIds, uint256[] memory amounts) =\n            abi.decode(data, (CanonicalNFT, address, address, uint256[], uint256[]));\n\n        // Transfer the ETH and tokens back to the owner\n        address token = _transferTokens(ctoken, message.srcOwner, tokenIds, amounts);\n        message.srcOwner.sendEther(message.value);\n\n        // Emit TokenReleased event\n        emit TokenReleased({\n            msgHash: msgHash,\n            from: message.srcOwner,\n            ctoken: ctoken.addr,\n            token: token,\n            tokenIds: tokenIds,\n            amounts: amounts\n        });\n    }\n\n    /// @notice See {ERC1155ReceiverUpgradeable-onERC1155BatchReceived}.\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    )\n        external\n        pure\n        returns (bytes4)\n    {\n        return IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector;\n    }\n\n    /// @notice See {ERC1155ReceiverUpgradeable-onERC1155Received}.\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    )\n        external\n        pure\n        returns (bytes4)\n    {\n        return IERC1155ReceiverUpgradeable.onERC1155Received.selector;\n    }\n\n    /// @dev See {BaseVault-supportsInterface}.\n    /// @param interfaceId The interface identifier.\n    /// @return true if supports, else otherwise.\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(BaseVault, ERC1155ReceiverUpgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(ERC1155ReceiverUpgradeable).interfaceId\n            || BaseVault.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc BaseVault\n    function name() public pure override returns (bytes32) {\n        return \"erc1155_vault\";\n    }\n\n    /// @dev Transfers ERC1155 tokens to the `to` address.\n    /// @param ctoken CanonicalNFT data.\n    /// @param to The address to transfer the tokens to.\n    /// @param tokenIds The token IDs to transfer.\n    /// @param amounts The amounts to transfer.\n    /// @return token The address of the token.\n    function _transferTokens(\n        CanonicalNFT memory ctoken,\n        address to,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts\n    )\n        private\n        returns (address token)\n    {\n        if (ctoken.chainId == block.chainid) {\n            // Token lives on this chain\n            token = ctoken.addr;\n            IERC1155(token).safeBatchTransferFrom(address(this), to, tokenIds, amounts, \"\");\n        } else {\n            // Token does not live on this chain\n            token = _getOrDeployBridgedToken(ctoken);\n            BridgedERC1155(token).mintBatch(to, tokenIds, amounts);\n        }\n    }\n\n    /// @dev Handles the message on the source chain and returns the encoded\n    /// call on the destination call.\n    /// @param _user The user's address.\n    /// @param _op BridgeTransferOp data.\n    /// @return msgData_ Encoded message data.\n    /// @return ctoken_ The canonical token.\n    function _handleMessage(\n        address _user,\n        BridgeTransferOp memory _op\n    )\n        private\n        returns (bytes memory msgData_, CanonicalNFT memory ctoken_)\n    {\n        unchecked {\n            // is a btoken, meaning, it does not live on this chain\n            if (bridgedToCanonical[_op.token].addr != address(0)) {\n                ctoken_ = bridgedToCanonical[_op.token];\n                for (uint256 i; i < _op.tokenIds.length; ++i) {\n                    BridgedERC1155(_op.token).burn(_user, _op.tokenIds[i], _op.amounts[i]);\n                }\n            } else {\n                // is a ctoken token, meaning, it lives on this chain\n                ctoken_ = CanonicalNFT({\n                    chainId: uint64(block.chainid),\n                    addr: _op.token,\n                    symbol: \"\",\n                    name: \"\"\n                });\n                IERC1155NameAndSymbol t = IERC1155NameAndSymbol(_op.token);\n                try t.name() returns (string memory _name) {\n                    ctoken_.name = _name;\n                } catch { }\n                try t.symbol() returns (string memory _symbol) {\n                    ctoken_.symbol = _symbol;\n                } catch { }\n                for (uint256 i; i < _op.tokenIds.length; ++i) {\n                    IERC1155(_op.token).safeTransferFrom({\n                        from: msg.sender,\n                        to: address(this),\n                        id: _op.tokenIds[i],\n                        amount: _op.amounts[i],\n                        data: \"\"\n                    });\n                }\n            }\n        }\n        msgData_ = abi.encodeCall(\n            this.onMessageInvocation, abi.encode(ctoken_, _user, _op.to, _op.tokenIds, _op.amounts)\n        );\n    }\n\n    /// @dev Retrieve or deploy a bridged ERC1155 token contract.\n    /// @param _ctoken CanonicalNFT data.\n    /// @return btoken_ Address of the bridged token contract.\n    function _getOrDeployBridgedToken(CanonicalNFT memory _ctoken)\n        private\n        returns (address btoken_)\n    {\n        btoken_ = canonicalToBridged[_ctoken.chainId][_ctoken.addr];\n        if (btoken_ == address(0)) {\n            btoken_ = _deployBridgedToken(_ctoken);\n        }\n    }\n\n    /// @dev Deploy a new BridgedNFT contract and initialize it.\n    /// This must be called before the first time a bridged token is sent to\n    /// this chain.\n    /// @param _ctoken CanonicalNFT data.\n    /// @return btoken_ Address of the deployed bridged token contract.\n    function _deployBridgedToken(CanonicalNFT memory _ctoken) private returns (address btoken_) {\n        bytes memory data = abi.encodeCall(\n            BridgedERC1155.init,\n            (owner(), addressManager, _ctoken.addr, _ctoken.chainId, _ctoken.symbol, _ctoken.name)\n        );\n\n        btoken_ = address(new ERC1967Proxy(resolve(\"bridged_erc1155\", false), data));\n\n        bridgedToCanonical[btoken_] = _ctoken;\n        canonicalToBridged[_ctoken.chainId][_ctoken.addr] = btoken_;\n\n        emit BridgedTokenDeployed({\n            chainId: _ctoken.chainId,\n            ctoken: _ctoken.addr,\n            btoken: btoken_,\n            ctokenSymbol: _ctoken.symbol,\n            ctokenName: _ctoken.name\n        });\n    }\n}"
    }
  ]
}