{
  "Title": "M-8: Malicious borrower can pay each payment and make its own loan default 1 month later",
  "Content": "# Issue M-8: Malicious borrower can pay each payment and make its own loan default 1 month later \n\nSource: https://github.com/sherlock-audit/2024-04-teller-finance-judging/issues/116 \n\nThe protocol has acknowledged this issue.\n\n## Found by \njovi\n## Summary\nThere's an edge case in which NextDueDate calculation will yield a due date much longer than what it ought to.\n## Vulnerability Detail\nIf the user repays a portion of its loan exactly one day and one second after the accepted timestamp, the next due date will not be 1 month later, but two.\nTake a look at the calculateNextDueDate function at the V2Calculations library, notice the following snippet:\n```solidity\nif (\n                BPBDTL.getDay(_lastRepaidTimestamp) >\n                BPBDTL.getDay(_acceptedTimestamp)\n            ) {\n                lastPaymentCycle += 2;\n            } else {\n                lastPaymentCycle += 1;\n            }\n```\n\nSince one lastPaymentCycle unit will be summed to the due date as the equivalent of one month, lastRepaidTimestamp just has to be on the further day after the accepted timestamp to yield not 1 month but a 2 month due date. This can be used by malicious parties to avoid defaults and to repay loans with much smaller rates.\n\nThere's also a second case in which it fails:\n```solidity\ndueDate_ = _acceptedTimestamp + _paymentCycle;\n            // Calculate the cycle number the last repayment was made\n            uint32 delta = _lastRepaidTimestamp - _acceptedTimestamp;\n            if (delta > 0) {\n                uint32 repaymentCycle = uint32(\n                    Math.ceilDiv(delta, _paymentCycle)\n                );\n                dueDate_ += (repaymentCycle * _paymentCycle);\n            }\n```\nThe due date can be of two cycles if the borrower pays back a little later than 1 payment cycle duration. \n\nThe following POC utilizes the second case to exemplify\n\n**POC**\nPaste the following code snippet at the TellerV2_bids.sol contract:\n```solidity\nfunction test_repay_loan_minimum2_a() public {\n        uint256 bidId = 1;\n        setMockBid(bidId);\n\n        tellerV2.mock_setBidState(bidId, BidState.ACCEPTED);\n        vm.warp(2 days + block.timestamp);\n\n        //set the account that will be paying the loan off\n        tellerV2.setMockMsgSenderForMarket(address(this));\n\n        tellerV2.calculateNextDueDate(bidId);\n        //need to get some weth\n\n        lendingToken.approve(address(tellerV2), 1e20);\n\n        tellerV2.calculateAmountOwed(bidId, block.timestamp);\n        vm.warp( 28 days + block.timestamp );\n        tellerV2.repayLoan(bidId, 100);\n\n        tellerV2.calculateAmountOwed(bidId, block.timestamp);\n        assertEq(tellerV2.calculateNextDueDate(bidId), 5184100);\n    }\n\n    function test_repay_loan_minimum2_b() public {\n        uint256 bidId = 1;\n        setMockBid(bidId);\n\n        tellerV2.mock_setBidState(bidId, BidState.ACCEPTED);\n        vm.warp(2 days + block.timestamp);\n\n        //set the account that will be paying the loan off\n        tellerV2.setMockMsgSenderForMarket(address(this));\n\n        tellerV2.calculateNextDueDate(bidId);\n        //need to get some weth\n\n        lendingToken.approve(address(tellerV2), 1e20);\n\n        tellerV2.calculateAmountOwed(bidId, block.timestamp);\n        vm.warp( 28 days + block.timestamp + 1 hours);\n        tellerV2.repayLoan(bidId, 100);\n\n        tellerV2.calculateAmountOwed(bidId, block.timestamp);\n        assertEq(tellerV2.calculateNextDueDate(bidId), 7776100);\n    }\n```\n\n\nBefore running the tests, make sure to alter the following snippets:\nTellerV2_bids.sol setMockBid function:\n```solidity\nfunction setMockBid(uint256 bidId) public {\n        tellerV2.mock_setBid(\n            bidId,\n            Bid({\n                borrower: address(borrower),\n                lender: address(lender),\n                receiver: address(receiver),\n                marketplaceId: marketplaceId,\n                _metadataURI: \"0x1234\",\n                loanDetails: LoanDetails({\n                    lendingToken: lendingToken,\n                    principal: 100000,\n                    timestamp: 100,\n                    acceptedTimestamp: 100,\n                    lastRepaidTimestamp: 0,\n                    loanDuration: 365 days,\n                    totalRepaid: Payment({ principal: 0, interest: 0 })\n                }),\n                terms: Terms({\n                    paymentCycleAmount: 10,\n                    paymentCycle: 30 days,\n                    APR: 10\n                }),\n                state: BidState.PENDING,\n                paymentType: PaymentType.EMI\n            })\n        );\n    }\n```\n\nTellerV2_Override.sol repayLoan function:\n```solidity\nfunction _repayLoan(\n        uint256 _bidId,\n        Payment memory _payment,\n        uint256 _owedAmount,\n        bool _shouldWithdrawCollateral\n    ) internal override {\n        Bid storage bid = bids[_bidId];\n\n        bid.loanDetails.totalRepaid.principal += _payment.principal;\n        bid.loanDetails.totalRepaid.interest += _payment.interest;\n        bid.loanDetails.lastRepaidTimestamp = uint32(block.timestamp);\n        \n    }\n```\n\nRun the tests with the following command:\n```shell\nforge test --match-test test_repay_loan_minimum2 -vvvvv \n```\n\nTake a look at the execution traces, the test b ends up with a calculateNextDueDate resulting in 7776100 and test a resulting in 5184100 while having the same amount owed. This effectively means a borrower can partially delay his/her payment to get much later dates for the next payment.\n## Impact\nBorrowers can avoid defaults and repayments by arbitrarily paying on certain timestamps. In the worst case a borrower can make multiple monthly payments every two months, essentially halving the borrow APY.\nThis issue is IN-SCOPE as these calculations are utilized by TellerV2.sol.\nAs it is a very easy to setup attack vector, the likelihood is high. As it doesn't incur loss of funds, but decreases the earnings for lenders, the impact is medium.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2.sol#L1036\n[2024-04-teller-finance/teller-protocol-v2-audit-2024/packages/contracts/contracts/libraries/V2Calculations.sol at main · sherlock-audit/2024-04-teller-finance (github.com)](https://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/libraries/V2Calculations.sol#L199)\n[2024-04-teller-finance/teller-protocol-v2-audit-2024/packages/contracts/contracts/libraries/V2Calculations.sol at main · sherlock-audit/2024-04-teller-finance (github.com)](https://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/libraries/V2Calculations.sol#L185)\n\n## Tool used\n\nManual Review\n\n## Recommendation\nInstead of the possibility of adding two months delay as the next payment, a better option would be to always enable a 1 month delay:\n```solidity\nFROM:\nif (\n                BPBDTL.getDay(_lastRepaidTimestamp) >\n                BPBDTL.getDay(_acceptedTimestamp)\n            ) {\n                lastPaymentCycle += 2;\n            } else {\n                lastPaymentCycle += 1;\n            }\nTO:\n                lastPaymentCycle += 1;\n\n\n```\n\nFor the second case, the next payment should always be after a single payment cycle, so the following dueDate should be as follows:\n```solidity\nif (delta > 0) {\n                uint32 repaymentCycle = uint32(\n                    Math.ceilDiv(delta, _paymentCycle)\n                );\n                // no repayment cycle multiplication as that will round in favour of the borrower and make the next repayment happen on a much later time period\n                dueDate_ += _paymentCycle;\n            }\n```\n\n\n\n## Discussion\n\n**ethereumdegen**\n\nIn the vast majority of our cases, loans are 'seconds' instead of 'monthly' type.  This does seem to be a valid, although minor, concern so thank you for bringing it to our attention, i think this is a wont-fix at this point . \n\n**nevillehuang**\n\n@ethereumdegen Since there is a non-zero chance of this occuring I believe medium is appropriate here given the unlikeliness of offering monthly loans.\n\n**pkqs90**\n\n\nEscalate\n\nThough this is a valid issue, the error lies in `V2Calculations.sol` contract, which is not in scope of the contest. The original scope is the following.\n```\nteller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/SmartCommitmentForwarder.sol\nteller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/FlashRolloverLoan_G5.sol\nteller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/LenderCommitmentGroup/LenderCommitmentGroupShares.sol\nteller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/LenderCommitmentGroup/LenderCommitmentGroup_Smart.sol\nteller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2.sol\nteller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2MarketForwarder_G2.sol\nteller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2MarketForwarder_G3.sol\n```\n\nThus I think this issue should be OOS, specifically for this contest.\n\n**sherlock-admin3**\n\n> \n> Escalate\n> \n> Though this is a valid issue, the error lies in `V2Calculations.sol` contract, which is not in scope of the contest. The original scope is the following.\n> ```\n> teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/SmartCommitmentForwarder.sol\n> teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/FlashRolloverLoan_G5.sol\n> teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/LenderCommitmentGroup/LenderCommitmentGroupShares.sol\n> teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/LenderCommitmentGroup/LenderCommitmentGroup_Smart.sol\n> teller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2.sol\n> teller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2MarketForwarder_G2.sol\n> teller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2MarketForwarder_G3.sol\n> ```\n> \n> Thus I think this issue should be OOS, specifically for this contest.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0jovi0**\n\nAccording to the rules at https://docs.sherlock.xyz/audits/judging/judging#iii.-sherlocks-standards - section \"7. Contract Scope\", subsection 2: \"In case the vulnerability exists in a library and an in-scope contract uses it and is affected by this bug this is a valid issue.\" \n\nAs TellerV2.sol [utilizes the library for the calculations](https://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2.sol#L1036), the issue is in scope.\n\n\n**nevillehuang**\n\nAgree with @0jovi0, the escalation should be rejected\n\n**cvetanovv**\n\nI disagree with the escalation. \n\n@0jovi0 is right. According to Sherlock rules, this issue is in the audit scope.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [pkqs90](https://github.com/sherlock-audit/2024-04-teller-finance-judging/issues/116/#issuecomment-2119243049): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/295",
  "Code": [
    {
      "filename": "teller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2.sol",
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\n// Contracts\nimport \"./ProtocolFee.sol\";\nimport \"./TellerV2Storage.sol\";\nimport \"./TellerV2Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\n\n// Interfaces\nimport \"./interfaces/IMarketRegistry.sol\";\nimport \"./interfaces/IReputationManager.sol\";\nimport \"./interfaces/ITellerV2.sol\";\nimport { Collateral } from \"./interfaces/escrow/ICollateralEscrowV1.sol\";\nimport \"./interfaces/IEscrowVault.sol\";\n\nimport { ILoanRepaymentCallbacks } from \"./interfaces/ILoanRepaymentCallbacks.sol\";\nimport \"./interfaces/ILoanRepaymentListener.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./libraries/NumbersLib.sol\";\n\nimport { V2Calculations, PaymentCycleType } from \"./libraries/V2Calculations.sol\";\n\n/* Errors */\n/**\n * @notice This error is reverted when the action isn't allowed\n * @param bidId The id of the bid.\n * @param action The action string (i.e: 'repayLoan', 'cancelBid', 'etc)\n * @param message The message string to return to the user explaining why the tx was reverted\n */\nerror ActionNotAllowed(uint256 bidId, string action, string message);\n\n/**\n * @notice This error is reverted when repayment amount is less than the required minimum\n * @param bidId The id of the bid the borrower is attempting to repay.\n * @param payment The payment made by the borrower\n * @param minimumOwed The minimum owed value\n */\nerror PaymentNotMinimum(uint256 bidId, uint256 payment, uint256 minimumOwed);\n\ncontract TellerV2 is\n    ITellerV2,\n    ILoanRepaymentCallbacks,\n    OwnableUpgradeable,\n    ProtocolFee,\n    PausableUpgradeable,\n    TellerV2Storage,\n    TellerV2Context\n{\n    using Address for address;\n    using SafeERC20 for IERC20;\n    using NumbersLib for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    //the first 20 bytes of keccak256(\"lender manager\")\n    address constant USING_LENDER_MANAGER =\n        0x84D409EeD89F6558fE3646397146232665788bF8;\n\n    /** Events */\n\n    /**\n     * @notice This event is emitted when a new bid is submitted.\n     * @param bidId The id of the bid submitted.\n     * @param borrower The address of the bid borrower.\n     * @param metadataURI URI for additional bid information as part of loan bid.\n     */\n    event SubmittedBid(\n        uint256 indexed bidId,\n        address indexed borrower,\n        address receiver,\n        bytes32 indexed metadataURI\n    );\n\n    /**\n     * @notice This event is emitted when a bid has been accepted by a lender.\n     * @param bidId The id of the bid accepted.\n     * @param lender The address of the accepted bid lender.\n     */\n    event AcceptedBid(uint256 indexed bidId, address indexed lender);\n\n    /**\n     * @notice This event is emitted when a previously submitted bid has been cancelled.\n     * @param bidId The id of the cancelled bid.\n     */\n    event CancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when market owner has cancelled a pending bid in their market.\n     * @param bidId The id of the bid funded.\n     *\n     * Note: The `CancelledBid` event will also be emitted.\n     */\n    event MarketOwnerCancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a payment is made towards an active loan.\n     * @param bidId The id of the bid/loan to which the payment was made.\n     */\n    event LoanRepayment(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanRepaid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been closed by a lender to claim collateral.\n     * @param bidId The id of the bid accepted.\n     */\n    event LoanClosed(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanLiquidated(uint256 indexed bidId, address indexed liquidator);\n\n    /**\n     * @notice This event is emitted when a fee has been paid related to a bid.\n     * @param bidId The id of the bid.\n     * @param feeType The name of the fee being paid.\n     * @param amount The amount of the fee being paid.\n     */\n    event FeePaid(\n        uint256 indexed bidId,\n        string indexed feeType,\n        uint256 indexed amount\n    );\n\n    /** Modifiers */\n\n    /**\n     * @notice This modifier is used to check if the state of a bid is pending, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier pendingBid(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.PENDING) {\n            revert ActionNotAllowed(_bidId, _action, \"Bid must be pending\");\n        }\n\n        _;\n    }\n\n    /**\n     * @notice This modifier is used to check if the state of a loan has been accepted, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier acceptedLoan(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.ACCEPTED) {\n            revert ActionNotAllowed(_bidId, _action, \"Loan must be accepted\");\n        }\n\n        _;\n    }\n\n    /** Constant Variables **/\n\n    uint8 public constant CURRENT_CODE_VERSION = 10;\n\n    uint32 public constant LIQUIDATION_DELAY = 86400; //ONE DAY IN SECONDS\n\n    /** Constructor **/\n\n    constructor(address trustedForwarder) TellerV2Context(trustedForwarder) {}\n\n    /** External Functions **/\n\n    /**\n     * @notice Initializes the proxy.\n     * @param _protocolFee The fee collected by the protocol for loan processing.\n     * @param _marketRegistry The address of the market registry contract for the protocol.\n     * @param _reputationManager The address of the reputation manager contract.\n     * @param _lenderCommitmentForwarder The address of the lender commitment forwarder contract.\n     * @param _collateralManager The address of the collateral manager contracts.\n     * @param _lenderManager The address of the lender manager contract for loans on the protocol.\n     */\n    function initialize(\n        uint16 _protocolFee,\n        address _marketRegistry,\n        address _reputationManager,\n        address _lenderCommitmentForwarder,\n        address _collateralManager,\n        address _lenderManager,\n        address _escrowVault\n    ) external initializer {\n        __ProtocolFee_init(_protocolFee);\n\n        __Pausable_init();\n\n        require(\n            _lenderCommitmentForwarder.isContract(),\n            \"LenderCommitmentForwarder must be a contract\"\n        );\n        lenderCommitmentForwarder = _lenderCommitmentForwarder;\n\n        require(\n            _marketRegistry.isContract(),\n            \"MarketRegistry must be a contract\"\n        );\n        marketRegistry = IMarketRegistry(_marketRegistry);\n\n        require(\n            _reputationManager.isContract(),\n            \"ReputationManager must be a contract\"\n        );\n        reputationManager = IReputationManager(_reputationManager);\n\n        require(\n            _collateralManager.isContract(),\n            \"CollateralManager must be a contract\"\n        );\n        collateralManager = ICollateralManager(_collateralManager);\n\n        _setLenderManager(_lenderManager);\n        _setEscrowVault(_escrowVault);\n    }\n\n    /* function setEscrowVault(address _escrowVault) external reinitializer(9) {\n        _setEscrowVault(_escrowVault);\n    }\n    */\n\n    function _setLenderManager(address _lenderManager)\n        internal\n        onlyInitializing\n    {\n        require(\n            _lenderManager.isContract(),\n            \"LenderManager must be a contract\"\n        );\n        lenderManager = ILenderManager(_lenderManager);\n    }\n\n    function _setEscrowVault(address _escrowVault) internal onlyInitializing {\n        require(_escrowVault.isContract(), \"EscrowVault must be a contract\");\n        escrowVault = IEscrowVault(_escrowVault);\n    }\n\n    /**\n     * @notice Gets the metadataURI for a bidId.\n     * @param _bidId The id of the bid to return the metadataURI for\n     * @return metadataURI_ The metadataURI for the bid, as a string.\n     */\n    function getMetadataURI(uint256 _bidId)\n        public\n        view\n        returns (string memory metadataURI_)\n    {\n        // Check uri mapping first\n        metadataURI_ = uris[_bidId];\n        // If the URI is not present in the mapping\n        if (\n            keccak256(abi.encodePacked(metadataURI_)) ==\n            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 // hardcoded constant of keccak256('')\n        ) {\n            // Return deprecated bytes32 uri as a string\n            uint256 convertedURI = uint256(bids[_bidId]._metadataURI);\n            metadataURI_ = StringsUpgradeable.toHexString(convertedURI, 32);\n        }\n    }\n\n    /**\n     * @notice Function for a borrower to create a bid for a loan without Collateral.\n     * @param _lendingToken The lending token asset requested to be borrowed.\n     * @param _marketplaceId The unique id of the marketplace for the bid.\n     * @param _principal The principal amount of the loan bid.\n     * @param _duration The recurrent length of time before which a payment is due.\n     * @param _APR The proposed interest rate for the loan bid.\n     * @param _metadataURI The URI for additional borrower loan information as part of loan bid.\n     * @param _receiver The address where the loan amount will be sent to.\n     */\n    function submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver\n    ) public override whenNotPaused returns (uint256 bidId_) {\n        bidId_ = _submitBid(\n            _lendingToken,\n            _marketplaceId,\n            _principal,\n            _duration,\n            _APR,\n            _metadataURI,\n            _receiver\n        );\n    }\n\n    /**\n     * @notice Function for a borrower to create a bid for a loan with Collateral.\n     * @param _lendingToken The lending token asset requested to be borrowed.\n     * @param _marketplaceId The unique id of the marketplace for the bid.\n     * @param _principal The principal amount of the loan bid.\n     * @param _duration The recurrent length of time before which a payment is due.\n     * @param _APR The proposed interest rate for the loan bid.\n     * @param _metadataURI The URI for additional borrower loan information as part of loan bid.\n     * @param _receiver The address where the loan amount will be sent to.\n     * @param _collateralInfo Additional information about the collateral asset.\n     */\n    function submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver,\n        Collateral[] calldata _collateralInfo\n    ) public override whenNotPaused returns (uint256 bidId_) {\n        bidId_ = _submitBid(\n            _lendingToken,\n            _marketplaceId,\n            _principal,\n            _duration,\n            _APR,\n            _metadataURI,\n            _receiver\n        );\n\n        bool validation = collateralManager.commitCollateral(\n            bidId_,\n            _collateralInfo\n        );\n\n        require(\n            validation == true,\n            \"Collateral balance could not be validated\"\n        );\n    }\n\n    function _submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver\n    ) internal virtual returns (uint256 bidId_) {\n        address sender = _msgSenderForMarket(_marketplaceId);\n\n        (bool isVerified, ) = marketRegistry.isVerifiedBorrower(\n            _marketplaceId,\n            sender\n        );\n\n        require(isVerified, \"Not verified borrower\");\n\n        require(\n            marketRegistry.isMarketOpen(_marketplaceId),\n            \"Market is not open\"\n        );\n\n        // Set response bid ID.\n        bidId_ = bidId;\n\n        // Create and store our bid into the mapping\n        Bid storage bid = bids[bidId];\n        bid.borrower = sender;\n        bid.receiver = _receiver != address(0) ? _receiver : bid.borrower;\n        bid.marketplaceId = _marketplaceId;\n        bid.loanDetails.lendingToken = IERC20(_lendingToken);\n        bid.loanDetails.principal = _principal;\n        bid.loanDetails.loanDuration = _duration;\n        bid.loanDetails.timestamp = uint32(block.timestamp);\n\n        // Set payment cycle type based on market setting (custom or monthly)\n        (bid.terms.paymentCycle, bidPaymentCycleType[bidId]) = marketRegistry\n            .getPaymentCycle(_marketplaceId);\n\n        bid.terms.APR = _APR;\n\n        bidDefaultDuration[bidId] = marketRegistry.getPaymentDefaultDuration(\n            _marketplaceId\n        );\n\n        bidExpirationTime[bidId] = marketRegistry.getBidExpirationTime(\n            _marketplaceId\n        );\n\n        bid.paymentType = marketRegistry.getPaymentType(_marketplaceId);\n\n        bid.terms.paymentCycleAmount = V2Calculations\n            .calculatePaymentCycleAmount(\n                bid.paymentType,\n                bidPaymentCycleType[bidId],\n                _principal,\n                _duration,\n                bid.terms.paymentCycle,\n                _APR\n            );\n\n        uris[bidId] = _metadataURI;\n        bid.state = BidState.PENDING;\n\n        emit SubmittedBid(\n            bidId,\n            bid.borrower,\n            bid.receiver,\n            keccak256(abi.encodePacked(_metadataURI))\n        );\n\n        // Store bid inside borrower bids mapping\n        borrowerBids[bid.borrower].push(bidId);\n\n        // Increment bid id counter\n        bidId++;\n    }\n\n    /**\n     * @notice Function for a borrower to cancel their pending bid.\n     * @param _bidId The id of the bid to cancel.\n     */\n    function cancelBid(uint256 _bidId) external {\n        if (\n            _msgSenderForMarket(bids[_bidId].marketplaceId) !=\n            bids[_bidId].borrower\n        ) {\n            revert ActionNotAllowed({\n                bidId: _bidId,\n                action: \"cancelBid\",\n                message: \"Only the bid owner can cancel!\"\n            });\n        }\n        _cancelBid(_bidId);\n    }\n\n    /**\n     * @notice Function for a market owner to cancel a bid in the market.\n     * @param _bidId The id of the bid to cancel.\n     */\n    function marketOwnerCancelBid(uint256 _bidId) external {\n        if (\n            _msgSender() !=\n            marketRegistry.getMarketOwner(bids[_bidId].marketplaceId)\n        ) {\n            revert ActionNotAllowed({\n                bidId: _bidId,\n                action: \"marketOwnerCancelBid\",\n                message: \"Only the market owner can cancel!\"\n            });\n        }\n        _cancelBid(_bidId);\n        emit MarketOwnerCancelledBid(_bidId);\n    }\n\n    /**\n     * @notice Function for users to cancel a bid.\n     * @param _bidId The id of the bid to be cancelled.\n     */\n    function _cancelBid(uint256 _bidId)\n        internal\n        virtual\n        pendingBid(_bidId, \"cancelBid\")\n    {\n        // Set the bid state to CANCELLED\n        bids[_bidId].state = BidState.CANCELLED;\n\n        // Emit CancelledBid event\n        emit CancelledBid(_bidId);\n    }\n\n    /**\n     * @notice Function for a lender to accept a proposed loan bid.\n     * @param _bidId The id of the loan bid to accept.\n     */\n    function lenderAcceptBid(uint256 _bidId)\n        external\n        override\n        pendingBid(_bidId, \"lenderAcceptBid\")\n        whenNotPaused\n        returns (\n            uint256 amountToProtocol,\n            uint256 amountToMarketplace,\n            uint256 amountToBorrower\n        )\n    {\n        // Retrieve bid\n        Bid storage bid = bids[_bidId];\n\n        address sender = _msgSenderForMarket(bid.marketplaceId);\n\n        (bool isVerified, ) = marketRegistry.isVerifiedLender(\n            bid.marketplaceId,\n            sender\n        );\n        require(isVerified, \"Not verified lender\");\n\n        require(\n            !marketRegistry.isMarketClosed(bid.marketplaceId),\n            \"Market is closed\"\n        );\n\n        require(!isLoanExpired(_bidId), \"Bid has expired\");\n\n        // Set timestamp\n        bid.loanDetails.acceptedTimestamp = uint32(block.timestamp);\n        bid.loanDetails.lastRepaidTimestamp = uint32(block.timestamp);\n\n        // Mark borrower's request as accepted\n        bid.state = BidState.ACCEPTED;\n\n        // Declare the bid acceptor as the lender of the bid\n        bid.lender = sender;\n\n        // Tell the collateral manager to deploy the escrow and pull funds from the borrower if applicable\n        collateralManager.deployAndDeposit(_bidId);\n\n        // Transfer funds to borrower from the lender\n        amountToProtocol = bid.loanDetails.principal.percent(protocolFee());\n        amountToMarketplace = bid.loanDetails.principal.percent(\n            marketRegistry.getMarketplaceFee(bid.marketplaceId)\n        );\n        amountToBorrower =\n            bid.loanDetails.principal -\n            amountToProtocol -\n            amountToMarketplace;\n\n        //transfer fee to protocol\n        if (amountToProtocol > 0) {\n            bid.loanDetails.lendingToken.safeTransferFrom(\n                sender,\n                owner(),\n                amountToProtocol\n            );\n        }\n\n        //transfer fee to marketplace\n        if (amountToMarketplace > 0) {\n            bid.loanDetails.lendingToken.safeTransferFrom(\n                sender,\n                marketRegistry.getMarketFeeRecipient(bid.marketplaceId),\n                amountToMarketplace\n            );\n        }\n\n        //transfer funds to borrower\n        if (amountToBorrower > 0) {\n            bid.loanDetails.lendingToken.safeTransferFrom(\n                sender,\n                bid.receiver,\n                amountToBorrower\n            );\n        }\n\n        // Record volume filled by lenders\n        lenderVolumeFilled[address(bid.loanDetails.lendingToken)][sender] += bid\n            .loanDetails\n            .principal;\n        totalVolumeFilled[address(bid.loanDetails.lendingToken)] += bid\n            .loanDetails\n            .principal;\n\n        // Add borrower's active bid\n        _borrowerBidsActive[bid.borrower].add(_bidId);\n\n        // Emit AcceptedBid\n        emit AcceptedBid(_bidId, sender);\n\n        emit FeePaid(_bidId, \"protocol\", amountToProtocol);\n        emit FeePaid(_bidId, \"marketplace\", amountToMarketplace);\n    }\n\n    function claimLoanNFT(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"claimLoanNFT\")\n        whenNotPaused\n    {\n        // Retrieve bid\n        Bid storage bid = bids[_bidId];\n\n        address sender = _msgSenderForMarket(bid.marketplaceId);\n        require(sender == bid.lender, \"only lender can claim NFT\");\n\n        // set lender address to the lender manager so we know to check the owner of the NFT for the true lender\n        bid.lender = address(USING_LENDER_MANAGER);\n\n        // mint an NFT with the lender manager\n        lenderManager.registerLoan(_bidId, sender);\n    }\n\n    /**\n     * @notice Function for users to make the minimum amount due for an active loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function repayLoanMinimum(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        (\n            uint256 owedPrincipal,\n            uint256 duePrincipal,\n            uint256 interest\n        ) = V2Calculations.calculateAmountOwed(\n                bids[_bidId],\n                block.timestamp,\n                _getBidPaymentCycleType(_bidId),\n                _getBidPaymentCycleDuration(_bidId)\n            );\n        _repayLoan(\n            _bidId,\n            Payment({ principal: duePrincipal, interest: interest }),\n            owedPrincipal + interest,\n            true\n        );\n    }\n\n    /**\n     * @notice Function for users to repay an active loan in full.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function repayLoanFull(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        _repayLoanFull(_bidId, true);\n    }\n\n    // function that the borrower (ideally) sends to repay the loan\n    /**\n     * @notice Function for users to make a payment towards an active loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     * @param _amount The amount of the payment.\n     */\n    function repayLoan(uint256 _bidId, uint256 _amount)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        _repayLoanAtleastMinimum(_bidId, _amount, true);\n    }\n\n    /**\n     * @notice Function for users to repay an active loan in full.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function repayLoanFullWithoutCollateralWithdraw(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        _repayLoanFull(_bidId, false);\n    }\n\n    function repayLoanWithoutCollateralWithdraw(uint256 _bidId, uint256 _amount)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        _repayLoanAtleastMinimum(_bidId, _amount, false);\n    }\n\n    function _repayLoanFull(uint256 _bidId, bool withdrawCollateral) internal {\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(\n                bids[_bidId],\n                block.timestamp,\n                _getBidPaymentCycleType(_bidId),\n                _getBidPaymentCycleDuration(_bidId)\n            );\n        _repayLoan(\n            _bidId,\n            Payment({ principal: owedPrincipal, interest: interest }),\n            owedPrincipal + interest,\n            withdrawCollateral\n        );\n    }\n\n    function _repayLoanAtleastMinimum(\n        uint256 _bidId,\n        uint256 _amount,\n        bool withdrawCollateral\n    ) internal {\n        (\n            uint256 owedPrincipal,\n            uint256 duePrincipal,\n            uint256 interest\n        ) = V2Calculations.calculateAmountOwed(\n                bids[_bidId],\n                block.timestamp,\n                _getBidPaymentCycleType(_bidId),\n                _getBidPaymentCycleDuration(_bidId)\n            );\n        uint256 minimumOwed = duePrincipal + interest;\n\n        // If amount is less than minimumOwed, we revert\n        if (_amount < minimumOwed) {\n            revert PaymentNotMinimum(_bidId, _amount, minimumOwed);\n        }\n\n        _repayLoan(\n            _bidId,\n            Payment({ principal: _amount - interest, interest: interest }),\n            owedPrincipal + interest,\n            withdrawCollateral\n        );\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol implement an emergency stop mechanism.\n     */\n    function pauseProtocol() public virtual onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol undo a previously implemented emergency stop.\n     */\n    function unpauseProtocol() public virtual onlyOwner whenPaused {\n        _unpause();\n    }\n\n    function lenderCloseLoan(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"lenderClaimCollateral\")\n    {\n        Bid storage bid = bids[_bidId];\n        address _collateralRecipient = bid.lender;\n\n        _lenderCloseLoanWithRecipient(_bidId, _collateralRecipient);\n    }\n\n    /**\n     * @notice Function for lender to claim collateral for a defaulted loan. The only purpose of a CLOSED loan is to make collateral claimable by lender.\n     * @param _bidId The id of the loan to set to CLOSED status.\n     */\n    function lenderCloseLoanWithRecipient(\n        uint256 _bidId,\n        address _collateralRecipient\n    ) external {\n        _lenderCloseLoanWithRecipient(_bidId, _collateralRecipient);\n    }\n\n    function _lenderCloseLoanWithRecipient(\n        uint256 _bidId,\n        address _collateralRecipient\n    ) internal acceptedLoan(_bidId, \"lenderClaimCollateral\") {\n        require(isLoanDefaulted(_bidId), \"Loan must be defaulted.\");\n\n        Bid storage bid = bids[_bidId];\n        bid.state = BidState.CLOSED;\n\n        address sender = _msgSenderForMarket(bid.marketplaceId);\n        require(sender == bid.lender, \"only lender can close loan\");\n\n        /*\n\n\n          address collateralManagerForBid = address(_getCollateralManagerForBid(_bidId)); \n\n          if( collateralManagerForBid == address(collateralManagerV2) ){\n             ICollateralManagerV2(collateralManagerForBid).lenderClaimCollateral(_bidId,_collateralRecipient);\n          }else{\n             require( _collateralRecipient == address(bid.lender));\n             ICollateralManager(collateralManagerForBid).lenderClaimCollateral(_bidId );\n          }\n          \n          */\n\n        collateralManager.lenderClaimCollateral(_bidId);\n\n        emit LoanClosed(_bidId);\n    }\n\n    /**\n     * @notice Function for users to liquidate a defaulted loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function liquidateLoanFull(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"liquidateLoan\")\n    {\n        Bid storage bid = bids[_bidId];\n\n        // If loan is backed by collateral, withdraw and send to the liquidator\n        address recipient = _msgSenderForMarket(bid.marketplaceId);\n\n        _liquidateLoanFull(_bidId, recipient);\n    }\n\n    function liquidateLoanFullWithRecipient(uint256 _bidId, address _recipient)\n        external\n        acceptedLoan(_bidId, \"liquidateLoan\")\n    {\n        _liquidateLoanFull(_bidId, _recipient);\n    }\n\n    /**\n     * @notice Function for users to liquidate a defaulted loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function _liquidateLoanFull(uint256 _bidId, address _recipient)\n        internal\n        acceptedLoan(_bidId, \"liquidateLoan\")\n    {\n        require(isLoanLiquidateable(_bidId), \"Loan must be liquidateable.\");\n\n        Bid storage bid = bids[_bidId];\n\n        // change state here to prevent re-entrancy\n        bid.state = BidState.LIQUIDATED;\n\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(\n                bid,\n                block.timestamp,\n                _getBidPaymentCycleType(_bidId),\n                _getBidPaymentCycleDuration(_bidId)\n            );\n\n        //this sets the state to 'repaid'\n        _repayLoan(\n            _bidId,\n            Payment({ principal: owedPrincipal, interest: interest }),\n            owedPrincipal + interest,\n            false\n        );\n\n        /*\n         _getCollateralManagerForBid(_bidId).liquidateCollateral(\n            _bidId,\n            _recipient\n        ); \n      */\n\n        collateralManager.liquidateCollateral(_bidId, _recipient);\n\n        address liquidator = _msgSenderForMarket(bid.marketplaceId);\n\n        emit LoanLiquidated(_bidId, liquidator);\n    }\n\n    /**\n     * @notice Internal function to make a loan payment.\n     * @dev Updates the bid's `status` to `PAID` only if it is not already marked as `LIQUIDATED`\n     * @param _bidId The id of the loan to make the payment towards.\n     * @param _payment The Payment struct with payments amounts towards principal and interest respectively.\n     * @param _owedAmount The total amount owed on the loan.\n     */\n    function _repayLoan(\n        uint256 _bidId,\n        Payment memory _payment,\n        uint256 _owedAmount,\n        bool _shouldWithdrawCollateral\n    ) internal virtual {\n        Bid storage bid = bids[_bidId];\n        uint256 paymentAmount = _payment.principal + _payment.interest;\n\n        RepMark mark = reputationManager.updateAccountReputation(\n            bid.borrower,\n            _bidId\n        );\n\n        // Check if we are sending a payment or amount remaining\n        if (paymentAmount >= _owedAmount) {\n            paymentAmount = _owedAmount;\n\n            if (bid.state != BidState.LIQUIDATED) {\n                bid.state = BidState.PAID;\n            }\n\n            // Remove borrower's active bid\n            _borrowerBidsActive[bid.borrower].remove(_bidId);\n\n            // If loan is is being liquidated and backed by collateral, withdraw and send to borrower\n            if (_shouldWithdrawCollateral) {\n                //   _getCollateralManagerForBid(_bidId).withdraw(_bidId);\n                collateralManager.withdraw(_bidId);\n            }\n\n            emit LoanRepaid(_bidId);\n        } else {\n            emit LoanRepayment(_bidId);\n        }\n\n        _sendOrEscrowFunds(_bidId, _payment); //send or escrow the funds\n\n        // update our mappings\n        bid.loanDetails.totalRepaid.principal += _payment.principal;\n        bid.loanDetails.totalRepaid.interest += _payment.interest;\n        bid.loanDetails.lastRepaidTimestamp = uint32(block.timestamp);\n\n        // If the loan is paid in full and has a mark, we should update the current reputation\n        if (mark != RepMark.Good) {\n            reputationManager.updateAccountReputation(bid.borrower, _bidId);\n        }\n    }\n\n\n    function _sendOrEscrowFunds(uint256 _bidId, Payment memory _payment)\n        internal\n    {\n        Bid storage bid = bids[_bidId];\n        address lender = getLoanLender(_bidId);\n\n        uint256 _paymentAmount = _payment.principal + _payment.interest;\n\n        try \n\n            bid.loanDetails.lendingToken.transferFrom{ gas: 100000 }(\n                _msgSenderForMarket(bid.marketplaceId),\n                lender,\n                _paymentAmount\n            )\n        {} catch {\n            address sender = _msgSenderForMarket(bid.marketplaceId);\n\n            uint256 balanceBefore = bid.loanDetails.lendingToken.balanceOf(\n                address(this)\n            ); \n\n            //if unable, pay to escrow\n            bid.loanDetails.lendingToken.safeTransferFrom(\n                sender,\n                address(this),\n                _paymentAmount\n            );\n\n            uint256 balanceAfter = bid.loanDetails.lendingToken.balanceOf(\n                address(this)\n            );\n\n            //used for fee-on-send tokens\n            uint256 paymentAmountReceived = balanceAfter - balanceBefore;\n\n            bid.loanDetails.lendingToken.approve(\n                address(escrowVault),\n                paymentAmountReceived\n            );\n\n            IEscrowVault(escrowVault).deposit(\n                lender,\n                address(bid.loanDetails.lendingToken),\n                paymentAmountReceived\n            );\n        }\n\n        address loanRepaymentListener = repaymentListenerForBid[_bidId];\n\n        if (loanRepaymentListener != address(0)) {\n            try\n                ILoanRepaymentListener(loanRepaymentListener).repayLoanCallback{\n                    gas: 80000\n                }( //limit gas costs to prevent lender griefing repayments\n                    _bidId,\n                    _msgSenderForMarket(bid.marketplaceId),\n                    _payment.principal,\n                    _payment.interest\n                )\n            {} catch {}\n        }\n    }\n\n\n\n\n    /**\n     * @notice Calculates the total amount owed for a loan bid at a specific timestamp.\n     * @param _bidId The id of the loan bid to calculate the owed amount for.\n     * @param _timestamp The timestamp at which to calculate the loan owed amount at.\n     */\n    function calculateAmountOwed(uint256 _bidId, uint256 _timestamp)\n        public\n        view\n        returns (Payment memory owed)\n    {\n        Bid storage bid = bids[_bidId];\n        if (\n            bid.state != BidState.ACCEPTED ||\n            bid.loanDetails.acceptedTimestamp >= _timestamp\n        ) return owed;\n\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(\n                bid,\n                _timestamp,\n                _getBidPaymentCycleType(_bidId),\n                _getBidPaymentCycleDuration(_bidId)\n            );\n\n        owed.principal = owedPrincipal;\n        owed.interest = interest;\n    }\n\n    /**\n     * @notice Calculates the minimum payment amount due"
    }
  ]
}