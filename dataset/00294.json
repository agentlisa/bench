{
  "Title": "Incorrect conditions of enabling collateral tokens",
  "Content": "##### Description\nIn favor of gas optimization, the current implementation aims to maintain a token amount equal to 1 instead of 0. According to this rule, a token amount of 1 should be interpreted as having zero value, and consequently, the use of this token as collateral should not be enabled. However, the current implementation incorrectly handles corner cases where the token amount is incremented multiple times - the token may remain in a disabled state even when the amount is greater than 1.\n\nThis issue is rated as MEDIUM severity because it may cause unexpected behavior in smart contracts in corner cases. However, it is unlikely that it can be exploited in the current code base.\n\nRelated code:\n- add_liquidity in Curve: https://github.com/Gearbox-protocol/integrations-v3/blob/2575396b2c933953483dd85cb2d5900134349f80/contracts/adapters/curve/CurveV1_StableNG.sol#L39-L40\n- remove_liquidity_imbalance in Curve integration: https://github.com/Gearbox-protocol/integrations-v3/blob/2575396b2c933953483dd85cb2d5900134349f80/contracts/adapters/curve/CurveV1_StableNG.sol#L92-L94\n\n##### Recommendation\nWe recommend refining the conditions for enabling tokens as collateral, considering the corner case described above.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/adapters/curve/CurveV1_StableNG.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2023.\npragma solidity ^0.8.17;\n\nimport {AdapterType} from \"@gearbox-protocol/sdk-gov/contracts/AdapterType.sol\";\nimport {IAdapter} from \"@gearbox-protocol/core-v2/contracts/interfaces/IAdapter.sol\";\n\nimport {ICurvePoolStableNG} from \"../../integrations/curve/ICurvePool_StableNG.sol\";\nimport {ICurveV1_StableNGAdapter} from \"../../interfaces/curve/ICurveV1_StableNGAdapter.sol\";\nimport {CurveV1AdapterBase} from \"./CurveV1_Base.sol\";\n\n/// @title Curve Stable NG adapter\n/// @notice Implements logic allowing to interact with Curve StableNG pools\ncontract CurveV1AdapterStableNG is CurveV1AdapterBase, ICurveV1_StableNGAdapter {\n    function _gearboxAdapterType() external pure virtual override returns (AdapterType) {\n        return AdapterType.CURVE_STABLE_NG;\n    }\n\n    /// @notice Constructor\n    /// @param _creditManager Credit manager address\n    /// @param _curvePool Target Curve pool address\n    /// @param _lp_token Pool LP token address\n    /// @param _metapoolBase Base pool address (for metapools only) or zero address\n    constructor(address _creditManager, address _curvePool, address _lp_token, address _metapoolBase)\n        CurveV1AdapterBase(_creditManager, _curvePool, _lp_token, _metapoolBase, ICurvePoolStableNG(_curvePool).N_COINS())\n    {}\n\n    /// @notice Add liquidity to the pool\n    /// @param amounts Amounts of tokens to add\n    /// @dev `min_mint_amount` parameter is ignored because calldata is passed directly to the target contract\n    function add_liquidity(uint256[] calldata amounts, uint256)\n        external\n        override\n        creditFacadeOnly\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        uint256 len = amounts.length;\n        (tokensToEnable, tokensToDisable) =\n            _add_liquidity(amounts[0] > 1, amounts[1] > 1, len > 2 && amounts[2] > 1, len > 3 && amounts[3] > 1);\n    }\n\n    /// @dev Returns calldata for adding liquidity in coin `i`\n    function _getAddLiquidityOneCoinCallData(uint256 i, uint256 amount, uint256 minAmount)\n        internal\n        view\n        override\n        returns (bytes memory)\n    {\n        uint256[] memory amounts = new uint256[](nCoins);\n        amounts[i] = amount;\n        return abi.encodeCall(ICurvePoolStableNG.add_liquidity, (amounts, minAmount));\n    }\n\n    /// @dev Returns calldata for calculating the result of adding liquidity in coin `i`\n    function _getCalcAddOneCoinCallData(uint256 i, uint256 amount)\n        internal\n        view\n        override\n        returns (bytes memory, bytes memory)\n    {\n        uint256[] memory amounts = new uint256[](nCoins);\n        amounts[i] = amount;\n        return (\n            abi.encodeCall(ICurvePoolStableNG.calc_token_amount, (amounts, true)),\n            abi.encodeWithSignature(\"calc_token_amount(uint256[])\", amounts)\n        );\n    }\n\n    /// @notice Remove liquidity from the pool\n    /// @dev '_amount' and 'min_amounts' parameters are ignored because calldata is directly passed to the target contract\n    function remove_liquidity(uint256, uint256[] calldata)\n        external\n        virtual\n        creditFacadeOnly\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        (tokensToEnable, tokensToDisable) = _remove_liquidity();\n    }\n\n    /// @notice Withdraw exact amounts of tokens from the pool\n    /// @param amounts Amounts of tokens to withdraw\n    /// @dev `max_burn_amount` parameter is ignored because calldata is directly passed to the target contract\n    function remove_liquidity_imbalance(uint256[] calldata amounts, uint256)\n        external\n        virtual\n        override\n        creditFacadeOnly\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        uint256 len = amounts.length;\n        (tokensToEnable, tokensToDisable) = _remove_liquidity_imbalance(\n            amounts[0] > 1, amounts[1] > 1, len > 2 && amounts[2] > 1, len > 3 && amounts[3] > 1\n        );\n    }\n}"
    },
    {
      "filename": "contracts/adapters/curve/CurveV1_StableNG.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2023.\npragma solidity ^0.8.17;\n\nimport {AdapterType} from \"@gearbox-protocol/sdk-gov/contracts/AdapterType.sol\";\nimport {IAdapter} from \"@gearbox-protocol/core-v2/contracts/interfaces/IAdapter.sol\";\n\nimport {ICurvePoolStableNG} from \"../../integrations/curve/ICurvePool_StableNG.sol\";\nimport {ICurveV1_StableNGAdapter} from \"../../interfaces/curve/ICurveV1_StableNGAdapter.sol\";\nimport {CurveV1AdapterBase} from \"./CurveV1_Base.sol\";\n\n/// @title Curve Stable NG adapter\n/// @notice Implements logic allowing to interact with Curve StableNG pools\ncontract CurveV1AdapterStableNG is CurveV1AdapterBase, ICurveV1_StableNGAdapter {\n    function _gearboxAdapterType() external pure virtual override returns (AdapterType) {\n        return AdapterType.CURVE_STABLE_NG;\n    }\n\n    /// @notice Constructor\n    /// @param _creditManager Credit manager address\n    /// @param _curvePool Target Curve pool address\n    /// @param _lp_token Pool LP token address\n    /// @param _metapoolBase Base pool address (for metapools only) or zero address\n    constructor(address _creditManager, address _curvePool, address _lp_token, address _metapoolBase)\n        CurveV1AdapterBase(_creditManager, _curvePool, _lp_token, _metapoolBase, ICurvePoolStableNG(_curvePool).N_COINS())\n    {}\n\n    /// @notice Add liquidity to the pool\n    /// @param amounts Amounts of tokens to add\n    /// @dev `min_mint_amount` parameter is ignored because calldata is passed directly to the target contract\n    function add_liquidity(uint256[] calldata amounts, uint256)\n        external\n        override\n        creditFacadeOnly\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        uint256 len = amounts.length;\n        (tokensToEnable, tokensToDisable) =\n            _add_liquidity(amounts[0] > 1, amounts[1] > 1, len > 2 && amounts[2] > 1, len > 3 && amounts[3] > 1);\n    }\n\n    /// @dev Returns calldata for adding liquidity in coin `i`\n    function _getAddLiquidityOneCoinCallData(uint256 i, uint256 amount, uint256 minAmount)\n        internal\n        view\n        override\n        returns (bytes memory)\n    {\n        uint256[] memory amounts = new uint256[](nCoins);\n        amounts[i] = amount;\n        return abi.encodeCall(ICurvePoolStableNG.add_liquidity, (amounts, minAmount));\n    }\n\n    /// @dev Returns calldata for calculating the result of adding liquidity in coin `i`\n    function _getCalcAddOneCoinCallData(uint256 i, uint256 amount)\n        internal\n        view\n        override\n        returns (bytes memory, bytes memory)\n    {\n        uint256[] memory amounts = new uint256[](nCoins);\n        amounts[i] = amount;\n        return (\n            abi.encodeCall(ICurvePoolStableNG.calc_token_amount, (amounts, true)),\n            abi.encodeWithSignature(\"calc_token_amount(uint256[])\", amounts)\n        );\n    }\n\n    /// @notice Remove liquidity from the pool\n    /// @dev '_amount' and 'min_amounts' parameters are ignored because calldata is directly passed to the target contract\n    function remove_liquidity(uint256, uint256[] calldata)\n        external\n        virtual\n        creditFacadeOnly\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        (tokensToEnable, tokensToDisable) = _remove_liquidity();\n    }\n\n    /// @notice Withdraw exact amounts of tokens from the pool\n    /// @param amounts Amounts of tokens to withdraw\n    /// @dev `max_burn_amount` parameter is ignored because calldata is directly passed to the target contract\n    function remove_liquidity_imbalance(uint256[] calldata amounts, uint256)\n        external\n        virtual\n        override\n        creditFacadeOnly\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        uint256 len = amounts.length;\n        (tokensToEnable, tokensToDisable) = _remove_liquidity_imbalance(\n            amounts[0] > 1, amounts[1] > 1, len > 2 && amounts[2] > 1, len > 3 && amounts[3] > 1\n        );\n    }\n}"
    }
  ]
}