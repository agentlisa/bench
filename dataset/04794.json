{
  "Title": "[11] Users funds could still be stuck due to lack of access to `ETH` on the `L2` through `L1->L2 `transactions so this should be clearly documented",
  "Content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L258-L286\n\n```solidity\n    function _requestL2Transaction(\n        uint256 _mintValue,\n        WritePriorityOpParams memory _params,\n        bytes memory _calldata,\n        bytes[] memory _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"uj\");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        // Using a new scope to prevent \"stack too deep\" error\n\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, _params.l2GasPricePerPubdata);\n        uint256 baseCost = _params.l2GasPrice * _params.l2GasLimit;\n        //@audit\n        require(_mintValue >= baseCost + _params.l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        address refundRecipient = _params.refundRecipient == address(0) ? _params.sender : _params.refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n        _params.refundRecipient = refundRecipient;\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n        _params.valueToMint = _mintValue;\n\n        canonicalTxHash = _writePriorityOp(_params, _calldata, _factoryDeps);\n    }\n```\n\nThis function eventually gets called when requesting transactions from the L2, note that there is an enforcement that `mintVaue` is always larger than `baseCost + _params.l2Value`, note that from [here](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L283-L286) we can see that the msg.value of the L1->L2 transaction must only be part of ETH to be minted inside of transaction processing on the L2, the same thing can be [confirmed in the bootloader](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L1818-L1822)\n\nNow, the [DefaultAccount.sol mistakenly assumes that L1->L2 transactions initiated by external owned accounts (EOAs) provide all necessary functionality](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/DefaultAccount.sol#L118-L127), leading to its `executeTransactionFromOutside()` function being left unimplemented.\n\nThis oversight means users cannot access their ETH on L2 if a malicious operator selectively processes only L1->L2 transactions. This scenario not only restricts access to ETH on L2 but also breaches the security principle that guarantees users can initiate transactions from L1 to L2, enabling them to withdraw their assets in anticipation of a potentially harmful upgrade.\n\n### Impact\n\n- Users cannot access their L2 ETH if the operator acts maliciously.\n- Compromises the security guarantee that allows fund withdrawals before executing a malicious upgrade.\n\n> NB: Submitting as QA cause whereas sponsors \"confirmed\" this bug from the previous audit, they tagged it as a `disagree with severity`... but still of the opinion that this is a borderline medium severity bug and leaving at the discretion of the judge.\n\n### Recommended Mitigation Steps\n\nEnable the creation of L1->L2 transactions that can draw upon ETH in the L2 balance as part of the transaction value. Alternatively, implement functionality in the `DefaultAccount::executeTransactionFromOutside` function to ensure it operates as initially intended or this should be clearly documented\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {IMailbox} from \"../../chain-interfaces/IMailbox.sol\";\nimport {Merkle} from \"../../libraries/Merkle.sol\";\nimport {PriorityQueue, PriorityOperation} from \"../../libraries/PriorityQueue.sol\";\nimport {TransactionValidator} from \"../../libraries/TransactionValidator.sol\";\nimport {WritePriorityOpParams, L2CanonicalTransaction, L2Message, L2Log, TxStatus, BridgehubL2TransactionRequest} from \"../../../common/Messaging.sol\";\nimport {FeeParams, PubdataPricingMode} from \"../ZkSyncStateTransitionStorage.sol\";\nimport {UncheckedMath} from \"../../../common/libraries/UncheckedMath.sol\";\nimport {UnsafeBytes} from \"../../../common/libraries/UnsafeBytes.sol\";\nimport {L2ContractHelper} from \"../../../common/libraries/L2ContractHelper.sol\";\nimport {AddressAliasHelper} from \"../../../vendor/AddressAliasHelper.sol\";\nimport {ZkSyncStateTransitionBase} from \"./ZkSyncStateTransitionBase.sol\";\nimport {REQUIRED_L2_GAS_PRICE_PER_PUBDATA, L1_GAS_PER_PUBDATA_BYTE, L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, PRIORITY_OPERATION_L2_TX_TYPE, PRIORITY_EXPIRATION, MAX_NEW_FACTORY_DEPS, ETH_TOKEN_ADDRESS, ERA_CHAIN_ID} from \"../../../common/Config.sol\";\nimport {L2_BOOTLOADER_ADDRESS, L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR, L2_BASE_TOKEN_SYSTEM_CONTRACT_ADDR} from \"../../../common/L2ContractAddresses.sol\";\n\nimport {IBridgehub} from \"../../../bridgehub/IBridgehub.sol\";\nimport {IL1SharedBridge} from \"../../../bridge/interfaces/IL1SharedBridge.sol\";\n\n// While formally the following import is not used, it is needed to inherit documentation from it\nimport {IZkSyncStateTransitionBase} from \"../../chain-interfaces/IZkSyncStateTransitionBase.sol\";\n\n/// @title zkSync Mailbox contract providing interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract MailboxFacet is ZkSyncStateTransitionBase, IMailbox {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncStateTransitionBase\n    string public constant override getName = \"MailboxFacet\";\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, \"transferEthToSharedBridge only available for Era on mailbox\");\n\n        uint256 amount = address(this).balance;\n        address sharedBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(sharedBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest memory _request\n    ) external payable onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, \"xx\");\n\n        bytes32 hashedLog = keccak256(\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, \"tw\");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in ETH to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in ETH\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, \"Mailbox: baseTokenGasPriceDenominator not set\");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, \"finalizeEthWithdrawal only available for Era on mailbox\");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal(\n            ERA_CHAIN_ID,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _message,\n            _merkleProof\n        );\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, \"legacy interface only available for era token\");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        address l2Sender = _request.sender;\n        if (l2Sender != tx.origin) {\n            l2Sender = AddressAliasHelper.applyL1ToL2Alias(_request.sender);\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using \"exotic\" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, \"qp\");\n\n        // Here we manually assign fields for the struct to prevent \"stack too deep\" error\n        WritePriorityOpParams memory params;\n\n        params.sender = l2Sender;\n        params.l2Value = _request.l2Value;\n        params.contractAddressL2 = _request.contractL2;\n        params.l2GasLimit = _request.l2GasLimit;\n        params.l2GasPricePerPubdata = _request.l2GasPerPubdataByteLimit;\n        params.refundRecipient = _request.refundRecipient;\n\n        canonicalTxHash = _requestL2Transaction(_request.mintValue, params, _request.l2Calldata, _request.factoryDeps);\n    }\n\n    function _requestL2Transaction(\n        uint256 _mintValue,\n        WritePriorityOpParams memory _params,\n        bytes memory _calldata,\n        bytes[] memory _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"uj\");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        // Using a new scope to prevent \"stack too deep\" error\n\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, _params.l2GasPricePerPubdata);\n        uint256 baseCost = _params.l2GasPrice * _params.l2GasLimit;\n        require(_mintValue >= baseCost + _params.l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        address refundRecipient = _params.refundRecipient == address(0) ? _params.sender : _params.refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n        _params.refundRecipient = refundRecipient;\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n        _params.valueToMint = _mintValue;\n\n        canonicalTxHash = _writePriorityOp(_params, _calldata, _factoryDeps);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams,\n        bytes memory _calldata,\n        bytes[] memory _factoryDeps\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(_priorityOpParams.sender)),\n            to: uint256(uint160(_priorityOpParams.contractAddressL2)),\n            gasLimit: _priorityOpParams.l2GasLimit,\n            gasPerPubdataByteLimit: _priorityOpParams.l2GasPricePerPubdata,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: _priorityOpParams.l2Value,\n            reserved: [_priorityOpParams.valueToMint, uint256(uint160(_priorityOpParams.refundRecipient)), 0, 0],\n            data: _calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(_factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams,\n        bytes memory _calldata,\n        bytes[] memory _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams, _calldata, _factoryDeps);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {IMailbox} from \"../../chain-interfaces/IMailbox.sol\";\nimport {Merkle} from \"../../libraries/Merkle.sol\";\nimport {PriorityQueue, PriorityOperation} from \"../../libraries/PriorityQueue.sol\";\nimport {TransactionValidator} from \"../../libraries/TransactionValidator.sol\";\nimport {WritePriorityOpParams, L2CanonicalTransaction, L2Message, L2Log, TxStatus, BridgehubL2TransactionRequest} from \"../../../common/Messaging.sol\";\nimport {FeeParams, PubdataPricingMode} from \"../ZkSyncStateTransitionStorage.sol\";\nimport {UncheckedMath} from \"../../../common/libraries/UncheckedMath.sol\";\nimport {UnsafeBytes} from \"../../../common/libraries/UnsafeBytes.sol\";\nimport {L2ContractHelper} from \"../../../common/libraries/L2ContractHelper.sol\";\nimport {AddressAliasHelper} from \"../../../vendor/AddressAliasHelper.sol\";\nimport {ZkSyncStateTransitionBase} from \"./ZkSyncStateTransitionBase.sol\";\nimport {REQUIRED_L2_GAS_PRICE_PER_PUBDATA, L1_GAS_PER_PUBDATA_BYTE, L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, PRIORITY_OPERATION_L2_TX_TYPE, PRIORITY_EXPIRATION, MAX_NEW_FACTORY_DEPS, ETH_TOKEN_ADDRESS, ERA_CHAIN_ID} from \"../../../common/Config.sol\";\nimport {L2_BOOTLOADER_ADDRESS, L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR, L2_BASE_TOKEN_SYSTEM_CONTRACT_ADDR} from \"../../../common/L2ContractAddresses.sol\";\n\nimport {IBridgehub} from \"../../../bridgehub/IBridgehub.sol\";\nimport {IL1SharedBridge} from \"../../../bridge/interfaces/IL1SharedBridge.sol\";\n\n// While formally the following import is not used, it is needed to inherit documentation from it\nimport {IZkSyncStateTransitionBase} from \"../../chain-interfaces/IZkSyncStateTransitionBase.sol\";\n\n/// @title zkSync Mailbox contract providing interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract MailboxFacet is ZkSyncStateTransitionBase, IMailbox {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncStateTransitionBase\n    string public constant override getName = \"MailboxFacet\";\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, \"transferEthToSharedBridge only available for Era on mailbox\");\n\n        uint256 amount = address(this).balance;\n        address sharedBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(sharedBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest memory _request\n    ) external payable onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, \"xx\");\n\n        bytes32 hashedLog = keccak256(\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, \"tw\");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in ETH to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in ETH\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, \"Mailbox: baseTokenGasPriceDenominator not set\");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, \"finalizeEthWithdrawal only available for Era on mailbox\");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal(\n            ERA_CHAIN_ID,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _message,\n            _merkleProof\n        );\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, \"legacy interface only available for era token\");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        address l2Sender = _request.sender;\n        if (l2Sender != tx.origin) {\n            l2Sender = AddressAliasHelper.applyL1ToL2Alias(_request.sender);\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using \"exotic\" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, \"qp\");\n\n        // Here we manually assign fields for the struct to prevent \"stack too deep\" error\n        WritePriorityOpParams memory params;\n\n        params.sender = l2Sender;\n        params.l2Value = _request.l2Value;\n        params.contractAddressL2 = _request.contractL2;\n        params.l2GasLimit = _request.l2GasLimit;\n        params.l2GasPricePerPubdata = _request.l2GasPerPubdataByteLimit;\n        params.refundRecipient = _request.refundRecipient;\n\n        canonicalTxHash = _requestL2Transaction(_request.mintValue, params, _request.l2Calldata, _request.factoryDeps);\n    }\n\n    function _requestL2Transaction(\n        uint256 _mintValue,\n        WritePriorityOpParams memory _params,\n        bytes memory _calldata,\n        bytes[] memory _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"uj\");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        // Using a new scope to prevent \"stack too deep\" error\n\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, _params.l2GasPricePerPubdata);\n        uint256 baseCost = _params.l2GasPrice * _params.l2GasLimit;\n        require(_mintValue >= baseCost + _params.l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        address refundRecipient = _params.refundRecipient == address(0) ? _params.sender : _params.refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n        _params.refundRecipient = refundRecipient;\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n        _params.valueToMint = _mintValue;\n\n        canonicalTxHash = _writePriorityOp(_params, _calldata, _factoryDeps);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams,\n        bytes memory _calldata,\n        bytes[] memory _factoryDeps\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(_priorityOpParams.sender)),\n            to: uint256(uint160(_priorityOpParams.contractAddressL2)),\n            gasLimit: _priorityOpParams.l2GasLimit,\n            gasPerPubdataByteLimit: _priorityOpParams.l2GasPricePerPubdata,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: _priorityOpParams.l2Value,\n            reserved: [_priorityOpParams.valueToMint, uint256(uint160(_priorityOpParams.refundRecipient)), 0, 0],\n            data: _calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(_factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams,\n        bytes memory _calldata,\n        bytes[] memory _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams, _calldata, _factoryDeps);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is n"
    }
  ]
}