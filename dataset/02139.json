{
  "Title": "M-5: Multiple functions may leave excess funds in the contract that should be returned",
  "Content": "# Issue M-5: Multiple functions may leave excess funds in the contract that should be returned \n\nSource: https://github.com/sherlock-audit/2023-03-sense-judging/issues/29 \n\n## Found by \n0x52, Bauer, spyrosonic10\n\n## Summary\n\nPeriphery#combine may leave excess underlying in the contract due to _fromTarget unwrapping to underlying and the quote may not swap them all.\n\nWhen using arbitrary tokens to swap to underlying the contract always moves in the full amount specified. There is no guarantee that the quote will consume all tokens. As a result the contract may leave excess sell tokens in the contract but it should return then to the receiver.\n\nThese functions include:\n\nRollerPeriphery\n1) deposit\n\nPeriphery\n1) swapForPTs\n2) addLiquidity\n3) issue\n\nRollerPeriphery#RollermintFromUnderlying uses adapter.scale and previewMint to determine the amount of underlying to transfer. The roller code will mean that previewMint will always perfectly reflect the exact exchange rate into the roller. However adapter.scale varies by adapter and isn't guaranteed to be exact. The result is that _transferFrom may take too much underlying. Since this underlying is wrapped to target the contract should return all excess target to receiver.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nToken may be left in the contract and lost\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-sense/blob/main/auto-roller/src/RollerPeriphery.sol#L175-L186\n\nhttps://github.com/sherlock-audit/2023-03-sense/blob/main/auto-roller/src/RollerPeriphery.sol#L196\n\nhttps://github.com/sherlock-audit/2023-03-sense/blob/main/sense-v1/pkg/core/src/Periphery.sol#L178\n\nhttps://github.com/sherlock-audit/2023-03-sense/blob/main/sense-v1/pkg/core/src/Periphery.sol#L325\n\nhttps://github.com/sherlock-audit/2023-03-sense/blob/main/sense-v1/pkg/core/src/Periphery.sol#L409\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReturn excess tokens at the end of the function\n\n\n\n## Discussion\n\n**jparklev**\n\nWe have this feature, for example, on `_swapSenseToken`, but not on the cases mentioned.\n\nOur fix will be: Transfer non-used tokens back to the user.\n\n**jparklev**\n\nFixed here for sense-v1: https://github.com/sense-finance/sense-v1/pull/346\nAnd here for the auto-roller: https://github.com/sense-finance/auto-roller/pull/32\n\nWe returned excess `sellTokens` funds in the from and to target functions\n\n**IAm0x52**\n\nFixes look good. Excess sell tokens are now returned inside _toTarget and _fromTarget for both periphery and rollerPeriphery\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/58",
  "Code": [
    {
      "filename": "auto-roller/src/RollerPeriphery.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { ERC4626 } from \"solmate/mixins/ERC4626.sol\";\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { FixedPointMathLib } from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport { Trust } from \"sense-v1-utils/Trust.sol\";\n\nimport { AutoRoller } from \"./AutoRoller.sol\";\n\nimport { IPermit2 } from \"./interfaces/IPermit2.sol\";\n\ninterface AdapterLike {\n    function scale() external view returns (uint256);\n    function underlying() external view returns (address);\n    function target() external view returns (address);\n    function wrapUnderlying(uint256) external returns (uint256);\n    function unwrapTarget(uint256) external returns (uint256);\n}\n\n// Inspired by https://github.com/fei-protocol/ERC4626/blob/main/src/ERC4626Router.sol\ncontract RollerPeriphery is Trust {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /* ========== PUBLIC CONSTANTS ========== */\n\n    /// @notice ETH address\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /* ========== PUBLIC IMMUTABLES ========== */\n\n    /// @notice Permit2 contract\n    IPermit2 public immutable permit2;\n\n    // 0x ExchangeProxy address. See https://docs.0x.org/developer-resources/contract-addresses\n    address public immutable exchangeProxy;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct PermitData {\n        IPermit2.PermitTransferFrom msg;\n        bytes sig;\n    }\n\n    struct SwapQuote {\n        ERC20 sellToken;\n        ERC20 buyToken;\n        address spender;\n        address payable swapTarget;\n        bytes swapCallData;\n    }\n\n    /* ========== ERRORS ========== */\n\n    /// @notice thrown when amount of assets received is below the min set by caller.\n    error MinAssetError();\n\n    /// @notice thrown when amount of underlying received is below the min set by caller.\n    error MinUnderlyingError();\n\n    /// @notice thrown when amount of shares received is below the min set by caller.\n    error MinSharesError();\n\n    /// @notice thrown when amount of assets received is above the max set by caller.\n    error MaxAssetError();\n\n    /// @notice thrown when amount of underlying received is above the max set by caller.\n    error MaxUnderlyingError();\n\n    /// @notice thrown when amount of shares received is above the max set by caller.\n    error MaxSharesError();\n\n    /// @notice thrown when amount of assets or excess received is below the max set by caller.\n    error MinAssetsOrExcessError();\n\n    /// @notice thrown when amount out received is below the min set by caller.\n    error MinAmountOutError();\n\n    /// @notice thrown when swap on 0x returns false.\n    error ZeroExSwapFailed(bytes res);\n\n    /// @notice thrown when swap on 0x succeeds but either the sellAmount or they buyAmount are zero.\n    error ZeroSwapAmt();\n\n    /// @notice thrown if swapTarget is not the exchange proxy.\n    error InvalidExchangeProxy();\n\n    constructor(IPermit2 _permit2, address _exchangeProxy) Trust(msg.sender) {\n        permit2 = _permit2;\n        exchangeProxy = _exchangeProxy;\n    }\n\n    /// @notice Redeem vault shares to any token, with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param shares Number of shares to redeem\n    /// @param receiver Destination address for the returned assets\n    /// @param minAmountOut Minimum amount of tokens returned\n    /// @param permit Permit message to pull shares from caller\n    /// @param quote Swap quote for converting underlying to token\n    /// @return amtOut Amount of tokens redeemed by the given number of shares\n    function redeem(AutoRoller roller, uint256 shares, address receiver, uint256 minAmountOut, PermitData calldata permit, SwapQuote calldata quote) external returns (uint256 amtOut) {\n        _transferFrom(permit, address(roller), shares);\n\n        if ((amtOut = _fromTarget(address(roller.adapter()), roller.redeem(shares, address(this), address(this)), quote)) < minAmountOut) {\n            revert MinAmountOutError();\n        }\n        address(quote.buyToken) == ETH\n            ? payable(receiver).transfer(amtOut)\n            : ERC20(address(quote.buyToken)).safeTransfer(receiver, amtOut); // transfer bought tokens to receiver\n\n        _transferRemainingUnderlying(roller, receiver);\n    }\n\n    /// @notice Withdraw asset from vault with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param assets Amount of asset requested for withdrawal\n    /// @param receiver Destination address for the returned assets\n    /// @param maxSharesOut Maximum amount of shares burned\n    /// @param permit Permit message to pull shares from caller\n    /// @return shares Number of shares to redeem\n    function withdrawTarget(AutoRoller roller, uint256 assets, address receiver, uint256 maxSharesOut, PermitData calldata permit) external returns (uint256 shares) {\n        _transferFrom(permit, address(roller), roller.previewWithdraw(assets));\n        \n        if ((shares = roller.withdraw(assets, receiver, address(this))) > maxSharesOut) {\n            revert MaxSharesError();\n        }\n    }\n\n    /// @notice Withdraw asset from vault and convert to underlying, with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param underlyingOut Amount of underlying requested for withdrawal\n    /// @param receiver Destination address for the returned underlying\n    /// @param maxSharesOut Maximum amount of shared burned\n    /// @param permit Permit message to pull shares from caller\n    /// @return shares Number of shares to redeem\n    function withdrawUnderlying(AutoRoller roller, uint256 underlyingOut, address receiver, uint256 maxSharesOut, PermitData calldata permit) external returns (uint256 shares) {\n        AdapterLike adapter = AdapterLike(address(roller.adapter()));\n\n        // asset converted from underlying (round down)\n        uint256 assetOut = underlyingOut.divWadDown(adapter.scale());\n\n        _transferFrom(permit, address(roller), roller.previewWithdraw(assetOut));\n\n        if ((shares = roller.withdraw(assetOut, address(this), address(this))) > maxSharesOut) {\n            revert MaxSharesError();\n        }\n\n        uint256 underlyingOut = adapter.unwrapTarget(roller.asset().balanceOf(address(this)));\n        ERC20(adapter.underlying()).safeTransfer(receiver, underlyingOut);\n    }\n\n    /// @notice Mint vault shares with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param shares Number of shares to mint\n    /// @param receiver Destination address for the returned shares\n    /// @param maxAmountIn Maximum amount of assets pulled from msg.sender\n    /// @return assets Amount of asset pulled from msg.sender and used to mint vault shares\n    function mintFromTarget(AutoRoller roller, uint256 shares, address receiver, uint256 maxAmountIn, PermitData calldata permit) external returns (uint256 assets) {\n        _transferFrom(permit, address(roller.asset()), roller.previewMint(shares));\n\n        if ((assets = roller.mint(shares, receiver)) > maxAmountIn) {\n            revert MaxAssetError();\n        }\n    }\n\n    /// @notice Convert underlying to asset and mint vault shares with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param shares Number of shares to mint\n    /// @param receiver Destination address for the returned shares\n    /// @param maxAmountIn Maximum amount of underlying pulled from msg.sender\n    /// @return underlyingIn Amount of underlying pulled from msg.sender and used to mint vault shares\n    function mintFromUnderlying(AutoRoller roller, uint256 shares, address receiver, uint256 maxAmountIn, PermitData calldata permit) external returns (uint256 underlyingIn) {\n        AdapterLike adapter = AdapterLike(address(roller.adapter()));\n\n        _transferFrom(permit, adapter.underlying(), underlyingIn = roller.previewMint(shares).mulWadUp(adapter.scale()));\n\n        adapter.wrapUnderlying(underlyingIn); // convert underlying to asset\n\n        uint256 assetIn = roller.mint(shares, receiver);\n        if ((underlyingIn = assetIn.mulWadDown(adapter.scale())) > maxAmountIn) {\n            revert MaxUnderlyingError();\n        }\n    }\n\n    /// @notice Convert token to asset and deposit into vault with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param tokenIn Amount of token pulled from msg.sender and used to mint vault shares\n    /// @param receiver Destination address for the returned shares\n    /// @param minSharesOut Minimum amount of returned shares\n    /// @param permit Permit message to pull token from caller\n    /// @param quote Swap quote for converting token to underlying\n    /// @return shares Number of shares minted by the vault and returned to msg.sender\n    function deposit(AutoRoller roller, uint256 tokenIn, address receiver, uint256 minSharesOut, PermitData calldata permit, SwapQuote calldata quote) external payable returns (uint256 shares) {\n        AdapterLike adapter = AdapterLike(address(roller.adapter()));\n\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, address(quote.sellToken), tokenIn);\n        uint256 toTarget = _toTarget(address(adapter), tokenIn, quote);\n        if ((shares = roller.deposit(toTarget, receiver)) < minSharesOut) {\n            revert MinSharesError();\n        }\n    }\n\n    /// @notice Quick exit into the constituent assets with slippage protection\n    /// @param roller AutoRoller vault.\n    /// @param shares Number of shares to eject with.\n    /// @param receiver Destination address for the constituent assets.\n    /// @param minAssetsOut Minimum amount of assets returned\n    /// @param minExcessOut Minimum excess PT/YT returned\n    /// @return assets Amount of asset redeemable by the given number of shares.\n    /// @return excessBal Amount of excess PT or YT redeemable by the given number of shares.\n    /// @return isExcessPTs Whether the excess token is a YT or PT.\n    function eject(AutoRoller roller, uint256 shares, address receiver, uint256 minAssetsOut, uint256 minExcessOut)\n        external returns (uint256 assets, uint256 excessBal, bool isExcessPTs)\n    {\n        (assets, excessBal, isExcessPTs) = roller.eject(shares, receiver, msg.sender);\n\n        if (assets < minAssetsOut || excessBal < minExcessOut) {\n            revert MinAssetsOrExcessError();\n        }\n    }\n\n    function approve(ERC20 token, address to) public payable requiresTrust {\n        token.safeApprove(to, type(uint256).max);\n    }\n\n    /* ========== INTERNAL UTILS ========== */\n\n    // @dev Swaps ETH->ERC20, ERC20->ERC20 or ERC20->ETH held by this contract using a 0x-API quote\n    function _fillQuote(SwapQuote calldata quote) internal returns (uint256 boughtAmount) {\n        if (quote.sellToken == quote.buyToken) return 0; // No swap if the tokens are the same.\n        if (quote.swapTarget != exchangeProxy) revert InvalidExchangeProxy();\n\n        // Give `spender` an infinite allowance to spend this contract's `sellToken`.\n        if (address(quote.sellToken) != ETH)\n            ERC20(address(quote.sellToken)).safeApprove(quote.spender, type(uint256).max);\n\n        uint256 sellAmount = address(quote.sellToken) == ETH\n            ? address(this).balance\n            : quote.sellToken.balanceOf(address(this));\n\n        // Call the encoded swap function call on the contract at `swapTarget`,\n        // passing along any ETH attached to this function call to cover protocol fees.\n        (bool success, bytes memory res) = quote.swapTarget.call{ value: msg.value }(quote.swapCallData);\n        // if (!success) revert(_getRevertMsg(res));\n        if (!success) revert ZeroExSwapFailed(res);\n\n        // We assume the Periphery does not hold tokens so boughtAmount is always it's balance\n        boughtAmount = address(quote.buyToken) == ETH ? address(this).balance : quote.buyToken.balanceOf(address(this));\n        sellAmount =\n            sellAmount -\n            (address(quote.sellToken) == ETH ? address(this).balance : quote.sellToken.balanceOf(address(this)));\n        if (boughtAmount == 0 || sellAmount == 0) revert ZeroSwapAmt();\n\n        // Refund any unspent protocol fees (paid in ether) to the sender.\n        uint256 refundAmt = address(this).balance;\n        if (address(quote.buyToken) == ETH) refundAmt = refundAmt - boughtAmount;\n        payable(msg.sender).transfer(refundAmt);\n        emit BoughtTokens(address(quote.sellToken), address(quote.buyToken), sellAmount, boughtAmount);\n    }\n\n    /// @notice Given an amount and a quote, decides whether it needs to wrap and make a swap on 0x,\n    /// simply wrap tokens or do nothing\n    function _toTarget(\n        address adapter,\n        uint256 _amt,\n        SwapQuote calldata quote\n    ) internal returns (uint256 amt) {\n        if (address(quote.sellToken) == AdapterLike(adapter).underlying()) {\n            amt = AdapterLike(adapter).wrapUnderlying(_amt);\n        } else if (address(quote.sellToken) != AdapterLike(adapter).target()) {\n            // sell tokens for underlying and wrap into target\n            amt = AdapterLike(adapter).wrapUnderlying(_fillQuote(quote));\n        } else {\n            amt = _amt;\n        }\n    }\n\n    /// @notice Given an amount and a quote, decides whether it needs to unwrap and make a swap on 0x,\n    /// simply unwrap tokens or do nothing\n    /// @dev when using zaps, the amount of underlying to swap for quote.buyToken (on 0x) is calculated off-chain\n    function _fromTarget(\n        address adapter,\n        uint256 _amt,\n        SwapQuote calldata quote\n    ) internal returns (uint256 amt) {\n        if (address(quote.buyToken) == AdapterLike(adapter).underlying()) {\n            amt = AdapterLike(adapter).unwrapTarget(_amt);\n        } else if (address(quote.buyToken) != AdapterLike(adapter).target()) {\n            AdapterLike(adapter).unwrapTarget(_amt);\n            // sell underlying for quote.buyToken\n            amt = _fillQuote(quote);\n        } else {\n            amt = _amt;\n        }\n    }\n    \n    function _transferFrom(\n        PermitData calldata permit,\n        address token,\n        uint256 amt\n    ) internal {\n        // Generate calldata for a standard safeTransferFrom call.\n        bytes memory inputData = abi.encodeCall(ERC20.transferFrom, (msg.sender, address(this), amt));\n\n        bool success; // Call the token contract as normal, capturing whether it succeeded.\n        assembly {\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(eq(mload(0), 1), iszero(returndatasize())),\n                // Counterintuitively, this call() must be positioned after the or() in the\n                // surrounding and() because and() evaluates its arguments from right to left.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the first slot of scratch space.\n                call(gas(), token, 0, add(inputData, 32), mload(inputData), 0, 32)\n            )\n        }\n\n        // We'll fall back to using Permit2 if calling transferFrom on the token directly reverted.\n        if (!success)\n            permit2.permitTransferFrom(\n                permit.msg,\n                IPermit2.SignatureTransferDetails({ to: address(this), requestedAmount: amt }),\n                msg.sender,\n                permit.sig\n            );\n    }\n\n    function _transferRemainingUnderlying(AutoRoller roller, address receiver) internal {\n        // transfer any remaining underlying to receiver\n        ERC20 underlying = ERC20(roller.adapter().underlying());\n        uint256 remaining = underlying.balanceOf(address(this));\n        if (remaining > 0) underlying.safeTransfer(receiver, remaining);\n    }\n\n    // required for refunds\n    receive() external payable {}\n\n    /* ========== LOGS ========== */\n\n    event BoughtTokens(\n        address indexed sellToken,\n        address indexed buyToken,\n        uint256 sellAmount,\n        uint256 indexed boughtAmount\n    );\n}"
    },
    {
      "filename": "auto-roller/src/RollerPeriphery.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { ERC4626 } from \"solmate/mixins/ERC4626.sol\";\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { FixedPointMathLib } from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport { Trust } from \"sense-v1-utils/Trust.sol\";\n\nimport { AutoRoller } from \"./AutoRoller.sol\";\n\nimport { IPermit2 } from \"./interfaces/IPermit2.sol\";\n\ninterface AdapterLike {\n    function scale() external view returns (uint256);\n    function underlying() external view returns (address);\n    function target() external view returns (address);\n    function wrapUnderlying(uint256) external returns (uint256);\n    function unwrapTarget(uint256) external returns (uint256);\n}\n\n// Inspired by https://github.com/fei-protocol/ERC4626/blob/main/src/ERC4626Router.sol\ncontract RollerPeriphery is Trust {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /* ========== PUBLIC CONSTANTS ========== */\n\n    /// @notice ETH address\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /* ========== PUBLIC IMMUTABLES ========== */\n\n    /// @notice Permit2 contract\n    IPermit2 public immutable permit2;\n\n    // 0x ExchangeProxy address. See https://docs.0x.org/developer-resources/contract-addresses\n    address public immutable exchangeProxy;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct PermitData {\n        IPermit2.PermitTransferFrom msg;\n        bytes sig;\n    }\n\n    struct SwapQuote {\n        ERC20 sellToken;\n        ERC20 buyToken;\n        address spender;\n        address payable swapTarget;\n        bytes swapCallData;\n    }\n\n    /* ========== ERRORS ========== */\n\n    /// @notice thrown when amount of assets received is below the min set by caller.\n    error MinAssetError();\n\n    /// @notice thrown when amount of underlying received is below the min set by caller.\n    error MinUnderlyingError();\n\n    /// @notice thrown when amount of shares received is below the min set by caller.\n    error MinSharesError();\n\n    /// @notice thrown when amount of assets received is above the max set by caller.\n    error MaxAssetError();\n\n    /// @notice thrown when amount of underlying received is above the max set by caller.\n    error MaxUnderlyingError();\n\n    /// @notice thrown when amount of shares received is above the max set by caller.\n    error MaxSharesError();\n\n    /// @notice thrown when amount of assets or excess received is below the max set by caller.\n    error MinAssetsOrExcessError();\n\n    /// @notice thrown when amount out received is below the min set by caller.\n    error MinAmountOutError();\n\n    /// @notice thrown when swap on 0x returns false.\n    error ZeroExSwapFailed(bytes res);\n\n    /// @notice thrown when swap on 0x succeeds but either the sellAmount or they buyAmount are zero.\n    error ZeroSwapAmt();\n\n    /// @notice thrown if swapTarget is not the exchange proxy.\n    error InvalidExchangeProxy();\n\n    constructor(IPermit2 _permit2, address _exchangeProxy) Trust(msg.sender) {\n        permit2 = _permit2;\n        exchangeProxy = _exchangeProxy;\n    }\n\n    /// @notice Redeem vault shares to any token, with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param shares Number of shares to redeem\n    /// @param receiver Destination address for the returned assets\n    /// @param minAmountOut Minimum amount of tokens returned\n    /// @param permit Permit message to pull shares from caller\n    /// @param quote Swap quote for converting underlying to token\n    /// @return amtOut Amount of tokens redeemed by the given number of shares\n    function redeem(AutoRoller roller, uint256 shares, address receiver, uint256 minAmountOut, PermitData calldata permit, SwapQuote calldata quote) external returns (uint256 amtOut) {\n        _transferFrom(permit, address(roller), shares);\n\n        if ((amtOut = _fromTarget(address(roller.adapter()), roller.redeem(shares, address(this), address(this)), quote)) < minAmountOut) {\n            revert MinAmountOutError();\n        }\n        address(quote.buyToken) == ETH\n            ? payable(receiver).transfer(amtOut)\n            : ERC20(address(quote.buyToken)).safeTransfer(receiver, amtOut); // transfer bought tokens to receiver\n\n        _transferRemainingUnderlying(roller, receiver);\n    }\n\n    /// @notice Withdraw asset from vault with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param assets Amount of asset requested for withdrawal\n    /// @param receiver Destination address for the returned assets\n    /// @param maxSharesOut Maximum amount of shares burned\n    /// @param permit Permit message to pull shares from caller\n    /// @return shares Number of shares to redeem\n    function withdrawTarget(AutoRoller roller, uint256 assets, address receiver, uint256 maxSharesOut, PermitData calldata permit) external returns (uint256 shares) {\n        _transferFrom(permit, address(roller), roller.previewWithdraw(assets));\n        \n        if ((shares = roller.withdraw(assets, receiver, address(this))) > maxSharesOut) {\n            revert MaxSharesError();\n        }\n    }\n\n    /// @notice Withdraw asset from vault and convert to underlying, with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param underlyingOut Amount of underlying requested for withdrawal\n    /// @param receiver Destination address for the returned underlying\n    /// @param maxSharesOut Maximum amount of shared burned\n    /// @param permit Permit message to pull shares from caller\n    /// @return shares Number of shares to redeem\n    function withdrawUnderlying(AutoRoller roller, uint256 underlyingOut, address receiver, uint256 maxSharesOut, PermitData calldata permit) external returns (uint256 shares) {\n        AdapterLike adapter = AdapterLike(address(roller.adapter()));\n\n        // asset converted from underlying (round down)\n        uint256 assetOut = underlyingOut.divWadDown(adapter.scale());\n\n        _transferFrom(permit, address(roller), roller.previewWithdraw(assetOut));\n\n        if ((shares = roller.withdraw(assetOut, address(this), address(this))) > maxSharesOut) {\n            revert MaxSharesError();\n        }\n\n        uint256 underlyingOut = adapter.unwrapTarget(roller.asset().balanceOf(address(this)));\n        ERC20(adapter.underlying()).safeTransfer(receiver, underlyingOut);\n    }\n\n    /// @notice Mint vault shares with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param shares Number of shares to mint\n    /// @param receiver Destination address for the returned shares\n    /// @param maxAmountIn Maximum amount of assets pulled from msg.sender\n    /// @return assets Amount of asset pulled from msg.sender and used to mint vault shares\n    function mintFromTarget(AutoRoller roller, uint256 shares, address receiver, uint256 maxAmountIn, PermitData calldata permit) external returns (uint256 assets) {\n        _transferFrom(permit, address(roller.asset()), roller.previewMint(shares));\n\n        if ((assets = roller.mint(shares, receiver)) > maxAmountIn) {\n            revert MaxAssetError();\n        }\n    }\n\n    /// @notice Convert underlying to asset and mint vault shares with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param shares Number of shares to mint\n    /// @param receiver Destination address for the returned shares\n    /// @param maxAmountIn Maximum amount of underlying pulled from msg.sender\n    /// @return underlyingIn Amount of underlying pulled from msg.sender and used to mint vault shares\n    function mintFromUnderlying(AutoRoller roller, uint256 shares, address receiver, uint256 maxAmountIn, PermitData calldata permit) external returns (uint256 underlyingIn) {\n        AdapterLike adapter = AdapterLike(address(roller.adapter()));\n\n        _transferFrom(permit, adapter.underlying(), underlyingIn = roller.previewMint(shares).mulWadUp(adapter.scale()));\n\n        adapter.wrapUnderlying(underlyingIn); // convert underlying to asset\n\n        uint256 assetIn = roller.mint(shares, receiver);\n        if ((underlyingIn = assetIn.mulWadDown(adapter.scale())) > maxAmountIn) {\n            revert MaxUnderlyingError();\n        }\n    }\n\n    /// @notice Convert token to asset and deposit into vault with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param tokenIn Amount of token pulled from msg.sender and used to mint vault shares\n    /// @param receiver Destination address for the returned shares\n    /// @param minSharesOut Minimum amount of returned shares\n    /// @param permit Permit message to pull token from caller\n    /// @param quote Swap quote for converting token to underlying\n    /// @return shares Number of shares minted by the vault and returned to msg.sender\n    function deposit(AutoRoller roller, uint256 tokenIn, address receiver, uint256 minSharesOut, PermitData calldata permit, SwapQuote calldata quote) external payable returns (uint256 shares) {\n        AdapterLike adapter = AdapterLike(address(roller.adapter()));\n\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, address(quote.sellToken), tokenIn);\n        uint256 toTarget = _toTarget(address(adapter), tokenIn, quote);\n        if ((shares = roller.deposit(toTarget, receiver)) < minSharesOut) {\n            revert MinSharesError();\n        }\n    }\n\n    /// @notice Quick exit into the constituent assets with slippage protection\n    /// @param roller AutoRoller vault.\n    /// @param shares Number of shares to eject with.\n    /// @param receiver Destination address for the constituent assets.\n    /// @param minAssetsOut Minimum amount of assets returned\n    /// @param minExcessOut Minimum excess PT/YT returned\n    /// @return assets Amount of asset redeemable by the given number of shares.\n    /// @return excessBal Amount of excess PT or YT redeemable by the given number of shares.\n    /// @return isExcessPTs Whether the excess token is a YT or PT.\n    function eject(AutoRoller roller, uint256 shares, address receiver, uint256 minAssetsOut, uint256 minExcessOut)\n        external returns (uint256 assets, uint256 excessBal, bool isExcessPTs)\n    {\n        (assets, excessBal, isExcessPTs) = roller.eject(shares, receiver, msg.sender);\n\n        if (assets < minAssetsOut || excessBal < minExcessOut) {\n            revert MinAssetsOrExcessError();\n        }\n    }\n\n    function approve(ERC20 token, address to) public payable requiresTrust {\n        token.safeApprove(to, type(uint256).max);\n    }\n\n    /* ========== INTERNAL UTILS ========== */\n\n    // @dev Swaps ETH->ERC20, ERC20->ERC20 or ERC20->ETH held by this contract using a 0x-API quote\n    function _fillQuote(SwapQuote calldata quote) internal returns (uint256 boughtAmount) {\n        if (quote.sellToken == quote.buyToken) return 0; // No swap if the tokens are the same.\n        if (quote.swapTarget != exchangeProxy) revert InvalidExchangeProxy();\n\n        // Give `spender` an infinite allowance to spend this contract's `sellToken`.\n        if (address(quote.sellToken) != ETH)\n            ERC20(address(quote.sellToken)).safeApprove(quote.spender, type(uint256).max);\n\n        uint256 sellAmount = address(quote.sellToken) == ETH\n            ? address(this).balance\n            : quote.sellToken.balanceOf(address(this));\n\n        // Call the encoded swap function call on the contract at `swapTarget`,\n        // passing along any ETH attached to this function call to cover protocol fees.\n        (bool success, bytes memory res) = quote.swapTarget.call{ value: msg.value }(quote.swapCallData);\n        // if (!success) revert(_getRevertMsg(res));\n        if (!success) revert ZeroExSwapFailed(res);\n\n        // We assume the Periphery does not hold tokens so boughtAmount is always it's balance\n        boughtAmount = address(quote.buyToken) == ETH ? address(this).balance : quote.buyToken.balanceOf(address(this));\n        sellAmount =\n            sellAmount -\n            (address(quote.sellToken) == ETH ? address(this).balance : quote.sellToken.balanceOf(address(this)));\n        if (boughtAmount == 0 || sellAmount == 0) revert ZeroSwapAmt();\n\n        // Refund any unspent protocol fees (paid in ether) to the sender.\n        uint256 refundAmt = address(this).balance;\n        if (address(quote.buyToken) == ETH) refundAmt = refundAmt - boughtAmount;\n        payable(msg.sender).transfer(refundAmt);\n        emit BoughtTokens(address(quote.sellToken), address(quote.buyToken), sellAmount, boughtAmount);\n    }\n\n    /// @notice Given an amount and a quote, decides whether it needs to wrap and make a swap on 0x,\n    /// simply wrap tokens or do nothing\n    function _toTarget(\n        address adapter,\n        uint256 _amt,\n        SwapQuote calldata quote\n    ) internal returns (uint256 amt) {\n        if (address(quote.sellToken) == AdapterLike(adapter).underlying()) {\n            amt = AdapterLike(adapter).wrapUnderlying(_amt);\n        } else if (address(quote.sellToken) != AdapterLike(adapter).target()) {\n            // sell tokens for underlying and wrap into target\n            amt = AdapterLike(adapter).wrapUnderlying(_fillQuote(quote));\n        } else {\n            amt = _amt;\n        }\n    }\n\n    /// @notice Given an amount and a quote, decides whether it needs to unwrap and make a swap on 0x,\n    /// simply unwrap tokens or do nothing\n    /// @dev when using zaps, the amount of underlying to swap for quote.buyToken (on 0x) is calculated off-chain\n    function _fromTarget(\n        address adapter,\n        uint256 _amt,\n        SwapQuote calldata quote\n    ) internal returns (uint256 amt) {\n        if (address(quote.buyToken) == AdapterLike(adapter).underlying()) {\n            amt = AdapterLike(adapter).unwrapTarget(_amt);\n        } else if (address(quote.buyToken) != AdapterLike(adapter).target()) {\n            AdapterLike(adapter).unwrapTarget(_amt);\n            // sell underlying for quote.buyToken\n            amt = _fillQuote(quote);\n        } else {\n            amt = _amt;\n        }\n    }\n    \n    function _transferFrom(\n        PermitData calldata permit,\n        address token,\n        uint256 amt\n    ) internal {\n        // Generate calldata for a standard safeTransferFrom call.\n        bytes memory inputData = abi.encodeCall(ERC20.transferFrom, (msg.sender, address(this), amt));\n\n        bool success; // Call the token contract as normal, capturing whether it succeeded.\n        assembly {\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(eq(mload(0), 1), iszero(returndatasize())),\n                // Counterintuitively, this call() must be positioned after the or() in the\n                // surrounding and() because and() evaluates its arguments from right to left.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the first slot of scratch space.\n                call(gas(), token, 0, add(inputData, 32), mload(inputData), 0, 32)\n            )\n        }\n\n        // We'll fall back to using Permit2 if calling transferFrom on the token directly reverted.\n        if (!success)\n            permit2.permitTransferFrom(\n                permit.msg,\n                IPermit2.SignatureTransferDetails({ to: address(this), requestedAmount: amt }),\n                msg.sender,\n                permit.sig\n            );\n    }\n\n    function _transferRemainingUnderlying(AutoRoller roller, address receiver) internal {\n        // transfer any remaining underlying to receiver\n        ERC20 underlying = ERC20(roller.adapter().underlying());\n        uint256 remaining = underlying.balanceOf(address(this));\n        if (remaining > 0) underlying.safeTransfer(receiver, remaining);\n    }\n\n    // required for refunds\n    receive() external payable {}\n\n    /* ========== LOGS ========== */\n\n    event BoughtTokens(\n        address indexed sellToken,\n        address indexed buyToken,\n        uint256 sellAmount,\n        uint256 indexed boughtAmount\n    );\n}"
    },
    {
      "filename": "sense-v1/pkg/core/src/Periphery.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { FixedMath } from \"./external/FixedMath.sol\";\nimport { BalancerVault, IAsset } from \"./external/balancer/Vault.sol\";\nimport { BalancerPool } from \"./ex"
    }
  ]
}