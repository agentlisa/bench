{
  "Title": "[4] contracts/NFTCollection.sol",
  "Content": "\n### 4.1 Shorter inheritance list\n\nThe inheritance contracts on line [29-40](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollection.sol#L29-L40) can be consolidated into a shorter list:\n\n```solidity\ncontract NFTCollection is\n  INFTCollectionInitializer,\n  ContractFactory,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n```\n\nThen you would need to adjust the overrides on lines [255](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollection.sol#L255) and [316](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollection.sol#L316)\n\n### 4.2 `CID` need to be unique per `tokenID`\n\nDifferent `tokenID`s can not share the same `CID` by design. Although it is possible to design the contract so that some tokens share the same `CID` to save storage and also server space for off-chain contents.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-08-foundation",
  "Code": [
    {
      "filename": "contracts/NFTCollection.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IGetRoyalties.sol\";\nimport \"./interfaces/ITokenCreator.sol\";\nimport \"./interfaces/IGetFees.sol\";\nimport \"./interfaces/IRoyaltyInfo.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\n\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A collection of NFTs by a single creator.\n * @notice All NFTs from this contract are minted by the same creator.\n * A 10% royalty to the creator is included which may be split with collaborators on a per-NFT basis.\n */\ncontract NFTCollection is\n  INFTCollectionInitializer,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ERC165Upgradeable,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using AddressLibrary for address;\n  using AddressUpgradeable for address;\n\n  /**\n   * @notice The baseURI to use for the tokenURI, if undefined then `ipfs://` is used.\n   */\n  string private baseURI_;\n\n  /**\n   * @dev Stores hashes minted to prevent duplicates.\n   */\n  mapping(string => bool) private cidToMinted;\n\n  /**\n   * @dev Stores an optional alternate address to receive creator revenue and royalty payments.\n   * The target address may be a contract which could split or escrow payments.\n   */\n  mapping(uint256 => address payable) private tokenIdToCreatorPaymentAddress;\n\n  /**\n   * @dev Stores a CID for each NFT.\n   */\n  mapping(uint256 => string) private _tokenCIDs;\n\n  /**\n   * @notice Emitted when the owner changes the base URI to be used for NFTs in this collection.\n   * @param baseURI The new base URI to use.\n   */\n  event BaseURIUpdated(string baseURI);\n  /**\n   * @notice Emitted when a new NFT is minted.\n   * @param creator The address of the collection owner at this time this NFT was minted.\n   * @param tokenId The tokenId of the newly minted NFT.\n   * @param indexedTokenCID The CID of the newly minted NFT, indexed to enable watching for mint events by the tokenCID.\n   * @param tokenCID The actual CID of the newly minted NFT.\n   */\n  event Minted(address indexed creator, uint256 indexed tokenId, string indexed indexedTokenCID, string tokenCID);\n  /**\n   * @notice Emitted when the payment address for creator royalties is set.\n   * @param fromPaymentAddress The original address used for royalty payments.\n   * @param toPaymentAddress The new address used for royalty payments.\n   * @param tokenId The NFT which had the royalty payment address updated.\n   */\n  event TokenCreatorPaymentAddressSet(\n    address indexed fromPaymentAddress,\n    address indexed toPaymentAddress,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   */\n  function initialize(\n    address payable _creator,\n    string memory _name,\n    string memory _symbol\n  ) external initializer onlyContractFactory {\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, 0);\n  }\n\n  /**\n   * @notice Allows the creator to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyCreator` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyCreator {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mint(string calldata tokenCID) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintAndApprove(string calldata tokenCID, address operator) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddress(string calldata tokenCID, address payable tokenCreatorPaymentAddress)\n    public\n    returns (uint256 tokenId)\n  {\n    require(tokenCreatorPaymentAddress != address(0), \"NFTCollection: tokenCreatorPaymentAddress is required\");\n    tokenId = _mint(tokenCID);\n    tokenIdToCreatorPaymentAddress[tokenId] = tokenCreatorPaymentAddress;\n    emit TokenCreatorPaymentAddressSet(address(0), tokenCreatorPaymentAddress, tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddressAndApprove(\n    string calldata tokenCID,\n    address payable tokenCreatorPaymentAddress,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactory(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData\n  ) public returns (uint256 tokenId) {\n    address payable tokenCreatorPaymentAddress = paymentAddressFactory.callAndReturnContractAddress(\n      paymentAddressCallData\n    );\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactoryAndApprove(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentFactory(tokenCID, paymentAddressFactory, paymentAddressCallData);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Allows the collection creator to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyCreator {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to assign a baseURI to use for the tokenURI instead of the default `ipfs://`.\n   * @param baseURIOverride The new base URI to use for all NFTs in this collection.\n   */\n  function updateBaseURI(string calldata baseURIOverride) external onlyCreator {\n    baseURI_ = baseURIOverride;\n\n    emit BaseURIUpdated(baseURIOverride);\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract, if applicable.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyCreator {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    delete cidToMinted[_tokenCIDs[tokenId]];\n    delete tokenIdToCreatorPaymentAddress[tokenId];\n    delete _tokenCIDs[tokenId];\n    super._burn(tokenId);\n  }\n\n  function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {\n    require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\n    require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\n    unchecked {\n      // Number of tokens cannot overflow 256 bits.\n      tokenId = ++latestTokenId;\n      require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\n      cidToMinted[tokenCID] = true;\n      _tokenCIDs[tokenId] = tokenCID;\n      _mint(msg.sender, tokenId);\n      emit Minted(msg.sender, tokenId, tokenCID, tokenCID);\n    }\n  }\n\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `tokenCID` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for a token with the `tokenCID`: \"foo\" and `baseURI`: \"ipfs://\" is \"ipfs://foo\".\n   * @return uri The base URI used by this collection.\n   */\n  function baseURI() external view returns (string memory uri) {\n    uri = _baseURI();\n  }\n\n  /**\n   * @notice Checks if the creator has already minted a given NFT using this collection contract.\n   * @param tokenCID The CID to check for.\n   * @return hasBeenMinted True if the creator has already minted an NFT with this CID.\n   */\n  function getHasMintedCID(string calldata tokenCID) external view returns (bool hasBeenMinted) {\n    hasBeenMinted = cidToMinted[tokenCID];\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(uint256 tokenId)\n    public\n    view\n    override\n    returns (address payable creatorPaymentAddress)\n  {\n    creatorPaymentAddress = tokenIdToCreatorPaymentAddress[tokenId];\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    // This is a no-op function required to avoid compile errors.\n    interfaceSupported = super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    require(_exists(tokenId), \"NFTCollection: URI query for nonexistent token\");\n\n    uri = string.concat(_baseURI(), _tokenCIDs[tokenId]);\n  }\n\n  function _baseURI() internal view override returns (string memory) {\n    if (bytes(baseURI_).length != 0) {\n      return baseURI_;\n    }\n    return \"ipfs://\";\n  }\n}"
    },
    {
      "filename": "contracts/NFTCollection.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IGetRoyalties.sol\";\nimport \"./interfaces/ITokenCreator.sol\";\nimport \"./interfaces/IGetFees.sol\";\nimport \"./interfaces/IRoyaltyInfo.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\n\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A collection of NFTs by a single creator.\n * @notice All NFTs from this contract are minted by the same creator.\n * A 10% royalty to the creator is included which may be split with collaborators on a per-NFT basis.\n */\ncontract NFTCollection is\n  INFTCollectionInitializer,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ERC165Upgradeable,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using AddressLibrary for address;\n  using AddressUpgradeable for address;\n\n  /**\n   * @notice The baseURI to use for the tokenURI, if undefined then `ipfs://` is used.\n   */\n  string private baseURI_;\n\n  /**\n   * @dev Stores hashes minted to prevent duplicates.\n   */\n  mapping(string => bool) private cidToMinted;\n\n  /**\n   * @dev Stores an optional alternate address to receive creator revenue and royalty payments.\n   * The target address may be a contract which could split or escrow payments.\n   */\n  mapping(uint256 => address payable) private tokenIdToCreatorPaymentAddress;\n\n  /**\n   * @dev Stores a CID for each NFT.\n   */\n  mapping(uint256 => string) private _tokenCIDs;\n\n  /**\n   * @notice Emitted when the owner changes the base URI to be used for NFTs in this collection.\n   * @param baseURI The new base URI to use.\n   */\n  event BaseURIUpdated(string baseURI);\n  /**\n   * @notice Emitted when a new NFT is minted.\n   * @param creator The address of the collection owner at this time this NFT was minted.\n   * @param tokenId The tokenId of the newly minted NFT.\n   * @param indexedTokenCID The CID of the newly minted NFT, indexed to enable watching for mint events by the tokenCID.\n   * @param tokenCID The actual CID of the newly minted NFT.\n   */\n  event Minted(address indexed creator, uint256 indexed tokenId, string indexed indexedTokenCID, string tokenCID);\n  /**\n   * @notice Emitted when the payment address for creator royalties is set.\n   * @param fromPaymentAddress The original address used for royalty payments.\n   * @param toPaymentAddress The new address used for royalty payments.\n   * @param tokenId The NFT which had the royalty payment address updated.\n   */\n  event TokenCreatorPaymentAddressSet(\n    address indexed fromPaymentAddress,\n    address indexed toPaymentAddress,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   */\n  function initialize(\n    address payable _creator,\n    string memory _name,\n    string memory _symbol\n  ) external initializer onlyContractFactory {\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, 0);\n  }\n\n  /**\n   * @notice Allows the creator to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyCreator` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyCreator {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mint(string calldata tokenCID) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintAndApprove(string calldata tokenCID, address operator) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddress(string calldata tokenCID, address payable tokenCreatorPaymentAddress)\n    public\n    returns (uint256 tokenId)\n  {\n    require(tokenCreatorPaymentAddress != address(0), \"NFTCollection: tokenCreatorPaymentAddress is required\");\n    tokenId = _mint(tokenCID);\n    tokenIdToCreatorPaymentAddress[tokenId] = tokenCreatorPaymentAddress;\n    emit TokenCreatorPaymentAddressSet(address(0), tokenCreatorPaymentAddress, tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddressAndApprove(\n    string calldata tokenCID,\n    address payable tokenCreatorPaymentAddress,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactory(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData\n  ) public returns (uint256 tokenId) {\n    address payable tokenCreatorPaymentAddress = paymentAddressFactory.callAndReturnContractAddress(\n      paymentAddressCallData\n    );\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactoryAndApprove(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentFactory(tokenCID, paymentAddressFactory, paymentAddressCallData);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Allows the collection creator to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyCreator {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to assign a baseURI to use for the tokenURI instead of the default `ipfs://`.\n   * @param baseURIOverride The new base URI to use for all NFTs in this collection.\n   */\n  function updateBaseURI(string calldata baseURIOverride) external onlyCreator {\n    baseURI_ = baseURIOverride;\n\n    emit BaseURIUpdated(baseURIOverride);\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract, if applicable.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyCreator {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    delete cidToMinted[_tokenCIDs[tokenId]];\n    delete tokenIdToCreatorPaymentAddress[tokenId];\n    delete _tokenCIDs[tokenId];\n    super._burn(tokenId);\n  }\n\n  function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {\n    require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\n    require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\n    unchecked {\n      // Number of tokens cannot overflow 256 bits.\n      tokenId = ++latestTokenId;\n      require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\n      cidToMinted[tokenCID] = true;\n      _tokenCIDs[tokenId] = tokenCID;\n      _mint(msg.sender, tokenId);\n      emit Minted(msg.sender, tokenId, tokenCID, tokenCID);\n    }\n  }\n\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `tokenCID` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for a token with the `tokenCID`: \"foo\" and `baseURI`: \"ipfs://\" is \"ipfs://foo\".\n   * @return uri The base URI used by this collection.\n   */\n  function baseURI() external view returns (string memory uri) {\n    uri = _baseURI();\n  }\n\n  /**\n   * @notice Checks if the creator has already minted a given NFT using this collection contract.\n   * @param tokenCID The CID to check for.\n   * @return hasBeenMinted True if the creator has already minted an NFT with this CID.\n   */\n  function getHasMintedCID(string calldata tokenCID) external view returns (bool hasBeenMinted) {\n    hasBeenMinted = cidToMinted[tokenCID];\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(uint256 tokenId)\n    public\n    view\n    override\n    returns (address payable creatorPaymentAddress)\n  {\n    creatorPaymentAddress = tokenIdToCreatorPaymentAddress[tokenId];\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    // This is a no-op function required to avoid compile errors.\n    interfaceSupported = super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    require(_exists(tokenId), \"NFTCollection: URI query for nonexistent token\");\n\n    uri = string.concat(_baseURI(), _tokenCIDs[tokenId]);\n  }\n\n  function _baseURI() internal view override returns (string memory) {\n    if (bytes(baseURI_).length != 0) {\n      return baseURI_;\n    }\n    return \"ipfs://\";\n  }\n}"
    }
  ]
}