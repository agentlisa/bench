{
  "Title": "[N-02] immutable should be uppercase",
  "Content": "\n```solidity\nFILE : 2023-04-ens/contracts/dnsregistrar/OffchainDNSResolver.sol\n\n37: ENS public immutable ens;\n38: DNSSEC public immutable oracle;\n\n```\n[OffchainDNSResolver.sol#L37-L38](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/OffchainDNSResolver.sol#L37-L38)\n\n### Recommended Mitigation\n\n```solidity\n- 38: DNSSEC public immutable oracle;\n+ 38: DNSSEC public immutable ORACLE;\n```\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSRegistrar.sol#L26-L27\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSRegistrar.sol#L29-L30\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-04-ens",
  "Code": [
    {
      "filename": "contracts/dnsregistrar/OffchainDNSResolver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../contracts/resolvers/profiles/IAddrResolver.sol\";\nimport \"../../contracts/resolvers/profiles/IExtendedResolver.sol\";\nimport \"../../contracts/resolvers/profiles/IExtendedDNSResolver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../dnssec-oracle/BytesUtils.sol\";\nimport \"../dnssec-oracle/DNSSEC.sol\";\nimport \"../dnssec-oracle/RRUtils.sol\";\nimport \"../registry/ENSRegistry.sol\";\nimport \"../utils/HexUtils.sol\";\n\nerror OffchainLookup(\n    address sender,\n    string[] urls,\n    bytes callData,\n    bytes4 callbackFunction,\n    bytes extraData\n);\n\ninterface IDNSGateway {\n    function resolve(\n        bytes memory name,\n        uint16 qtype\n    ) external returns (DNSSEC.RRSetWithSignature[] memory);\n}\n\nuint16 constant CLASS_INET = 1;\nuint16 constant TYPE_TXT = 16;\n\ncontract OffchainDNSResolver is IExtendedResolver {\n    using RRUtils for *;\n    using BytesUtils for bytes;\n    using HexUtils for bytes;\n\n    ENS public immutable ens;\n    DNSSEC public immutable oracle;\n    string public gatewayURL;\n\n    error CouldNotResolve(bytes name);\n\n    constructor(ENS _ens, DNSSEC _oracle, string memory _gatewayURL) {\n        ens = _ens;\n        oracle = _oracle;\n        gatewayURL = _gatewayURL;\n    }\n\n    function resolve(\n        bytes calldata name,\n        bytes calldata data\n    ) external view returns (bytes memory) {\n        string[] memory urls = new string[](1);\n        urls[0] = gatewayURL;\n\n        revert OffchainLookup(\n            address(this),\n            urls,\n            abi.encodeCall(IDNSGateway.resolve, (name, TYPE_TXT)),\n            OffchainDNSResolver.resolveCallback.selector,\n            abi.encode(name, data)\n        );\n    }\n\n    function resolveCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    ) external view returns (bytes memory) {\n        (bytes memory name, bytes memory query) = abi.decode(\n            extraData,\n            (bytes, bytes)\n        );\n        DNSSEC.RRSetWithSignature[] memory rrsets = abi.decode(\n            response,\n            (DNSSEC.RRSetWithSignature[])\n        );\n\n        (bytes memory data, ) = oracle.verifyRRSet(rrsets);\n        for (\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n            !iter.done();\n            iter.next()\n        ) {\n            // Ignore records with wrong name, type, or class\n            bytes memory rrname = RRUtils.readName(iter.data, iter.offset);\n            if (\n                !rrname.equals(name) ||\n                iter.class != CLASS_INET ||\n                iter.dnstype != TYPE_TXT\n            ) {\n                continue;\n            }\n\n            // Look for a valid ENS-DNS TXT record\n            (address dnsresolver, bytes memory context) = parseRR(\n                iter.data,\n                iter.rdataOffset,\n                iter.nextOffset\n            );\n\n            // If we found a valid record, try to resolve it\n            if (dnsresolver != address(0)) {\n                if (\n                    IERC165(dnsresolver).supportsInterface(\n                        IExtendedDNSResolver.resolve.selector\n                    )\n                ) {\n                    return\n                        IExtendedDNSResolver(dnsresolver).resolve(\n                            name,\n                            query,\n                            context\n                        );\n                } else if (\n                    IERC165(dnsresolver).supportsInterface(\n                        IExtendedResolver.resolve.selector\n                    )\n                ) {\n                    return IExtendedResolver(dnsresolver).resolve(name, query);\n                } else {\n                    (bool ok, bytes memory ret) = address(dnsresolver)\n                        .staticcall(query);\n                    if (ok) {\n                        return ret;\n                    } else {\n                        revert CouldNotResolve(name);\n                    }\n                }\n            }\n        }\n\n        // No valid records; revert.\n        revert CouldNotResolve(name);\n    }\n\n    function parseRR(\n        bytes memory data,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address, bytes memory) {\n        bytes memory txt = readTXT(data, idx, lastIdx);\n\n        // Must start with the magic word\n        if (txt.length < 5 || !txt.equals(0, \"ENS1 \", 0, 5)) {\n            return (address(0), \"\");\n        }\n\n        // Parse the name or address\n        uint256 lastTxtIdx = txt.find(5, txt.length - 5, \" \");\n        if (lastTxtIdx > txt.length) {\n            address dnsResolver = parseAndResolve(txt, 5, txt.length);\n            return (dnsResolver, \"\");\n        } else {\n            address dnsResolver = parseAndResolve(txt, 5, lastTxtIdx);\n            return (\n                dnsResolver,\n                txt.substring(lastTxtIdx + 1, txt.length - lastTxtIdx - 1)\n            );\n        }\n    }\n\n    function readTXT(\n        bytes memory data,\n        uint256 startIdx,\n        uint256 lastIdx\n    ) internal pure returns (bytes memory) {\n        // TODO: Concatenate multiple text fields\n        uint256 fieldLength = data.readUint8(startIdx);\n        assert(startIdx + fieldLength < lastIdx);\n        return data.substring(startIdx + 1, fieldLength);\n    }\n\n    function parseAndResolve(\n        bytes memory nameOrAddress,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address) {\n        if (nameOrAddress[idx] == \"0\" && nameOrAddress[idx + 1] == \"x\") {\n            (address ret, bool valid) = nameOrAddress.hexToAddress(\n                idx + 2,\n                lastIdx\n            );\n            if (valid) {\n                return ret;\n            }\n        }\n        return resolveName(nameOrAddress, idx, lastIdx);\n    }\n\n    function resolveName(\n        bytes memory name,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address) {\n        bytes32 node = textNamehash(name, idx, lastIdx);\n        address resolver = ens.resolver(node);\n        if (resolver == address(0)) {\n            return address(0);\n        }\n        return IAddrResolver(resolver).addr(node);\n    }\n\n    /**\n     * @dev Namehash function that operates on dot-separated names (not dns-encoded names)\n     * @param name Name to hash\n     * @param idx Index to start at\n     * @param lastIdx Index to end at\n     */\n    function textNamehash(\n        bytes memory name,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (bytes32) {\n        uint256 separator = name.find(idx, name.length - idx, bytes1(\".\"));\n        bytes32 parentNode = bytes32(0);\n        if (separator < lastIdx) {\n            parentNode = textNamehash(name, separator + 1, lastIdx);\n        } else {\n            separator = lastIdx;\n        }\n        return\n            keccak256(\n                abi.encodePacked(parentNode, name.keccak(idx, separator - idx))\n            );\n    }\n}"
    },
    {
      "filename": "contracts/dnsregistrar/DNSRegistrar.sol",
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\nimport \"../dnssec-oracle/BytesUtils.sol\";\nimport \"../dnssec-oracle/DNSSEC.sol\";\nimport \"../dnssec-oracle/RRUtils.sol\";\nimport \"../registry/ENSRegistry.sol\";\nimport \"../root/Root.sol\";\nimport \"../resolvers/profiles/AddrResolver.sol\";\nimport \"./DNSClaimChecker.sol\";\nimport \"./PublicSuffixList.sol\";\nimport \"./IDNSRegistrar.sol\";\n\n/**\n * @dev An ENS registrar that allows the owner of a DNS name to claim the\n *      corresponding name in ENS.\n */\ncontract DNSRegistrar is IDNSRegistrar, IERC165 {\n    using BytesUtils for bytes;\n    using Buffer for Buffer.buffer;\n    using RRUtils for *;\n\n    ENS public immutable ens;\n    DNSSEC public immutable oracle;\n    PublicSuffixList public suffixes;\n    address public immutable previousRegistrar;\n    address public immutable resolver;\n    // A mapping of the most recent signatures seen for each claimed domain.\n    mapping(bytes32 => uint32) public inceptions;\n\n    error NoOwnerRecordFound();\n    error PermissionDenied(address caller, address owner);\n    error PreconditionNotMet();\n    error StaleProof();\n    error InvalidPublicSuffix(bytes name);\n\n    struct OwnerRecord {\n        bytes name;\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    event Claim(\n        bytes32 indexed node,\n        address indexed owner,\n        bytes dnsname,\n        uint32 inception\n    );\n    event NewPublicSuffixList(address suffixes);\n\n    constructor(\n        address _previousRegistrar,\n        address _resolver,\n        DNSSEC _dnssec,\n        PublicSuffixList _suffixes,\n        ENS _ens\n    ) {\n        previousRegistrar = _previousRegistrar;\n        resolver = _resolver;\n        oracle = _dnssec;\n        suffixes = _suffixes;\n        emit NewPublicSuffixList(address(suffixes));\n        ens = _ens;\n    }\n\n    /**\n     * @dev This contract's owner-only functions can be invoked by the owner of the ENS root.\n     */\n    modifier onlyOwner() {\n        Root root = Root(ens.owner(bytes32(0)));\n        address owner = root.owner();\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setPublicSuffixList(PublicSuffixList _suffixes) public onlyOwner {\n        suffixes = _suffixes;\n        emit NewPublicSuffixList(address(suffixes));\n    }\n\n    /**\n     * @dev Submits proofs to the DNSSEC oracle, then claims a name using those proofs.\n     * @param name The name to claim, in DNS wire format.\n     * @param input A chain of signed DNS RRSETs ending with a text record.\n     */\n    function proveAndClaim(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input\n    ) public override {\n        (bytes32 rootNode, bytes32 labelHash, address addr) = _claim(\n            name,\n            input\n        );\n        ens.setSubnodeOwner(rootNode, labelHash, addr);\n    }\n\n    function proveAndClaimWithResolver(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input,\n        address resolver,\n        address addr\n    ) public override {\n        (bytes32 rootNode, bytes32 labelHash, address owner) = _claim(\n            name,\n            input\n        );\n        if (msg.sender != owner) {\n            revert PermissionDenied(msg.sender, owner);\n        }\n        ens.setSubnodeRecord(rootNode, labelHash, owner, resolver, 0);\n        if (addr != address(0)) {\n            if (resolver == address(0)) {\n                revert PreconditionNotMet();\n            }\n            bytes32 node = keccak256(abi.encodePacked(rootNode, labelHash));\n            // Set the resolver record\n            AddrResolver(resolver).setAddr(node, addr);\n        }\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure override returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IDNSRegistrar).interfaceId;\n    }\n\n    function _claim(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input\n    ) internal returns (bytes32 parentNode, bytes32 labelHash, address addr) {\n        (bytes memory data, uint32 inception) = oracle.verifyRRSet(input);\n\n        // Get the first label\n        uint256 labelLen = name.readUint8(0);\n        labelHash = name.keccak(1, labelLen);\n\n        bytes memory parentName = name.substring(\n            labelLen + 1,\n            name.length - labelLen - 1\n        );\n\n        // Make sure the parent name is enabled\n        parentNode = enableNode(parentName);\n\n        bytes32 node = keccak256(abi.encodePacked(parentNode, labelHash));\n        if (!RRUtils.serialNumberGte(inception, inceptions[node])) {\n            revert StaleProof();\n        }\n        inceptions[node] = inception;\n\n        bool found;\n        (addr, found) = DNSClaimChecker.getOwnerAddress(name, data);\n        if (!found) {\n            revert NoOwnerRecordFound();\n        }\n\n        emit Claim(node, addr, name, inception);\n    }\n\n    function enableNode(bytes memory domain) public returns (bytes32 node) {\n        // Name must be in the public suffix list.\n        if (!suffixes.isPublicSuffix(domain)) {\n            revert InvalidPublicSuffix(domain);\n        }\n        return _enableNode(domain, 0);\n    }\n\n    function _enableNode(\n        bytes memory domain,\n        uint256 offset\n    ) internal returns (bytes32 node) {\n        uint256 len = domain.readUint8(offset);\n        if (len == 0) {\n            return bytes32(0);\n        }\n\n        bytes32 parentNode = _enableNode(domain, offset + len + 1);\n        bytes32 label = domain.keccak(offset + 1, len);\n        node = keccak256(abi.encodePacked(parentNode, label));\n        address owner = ens.owner(node);\n        if (owner == address(0) || owner == previousRegistrar) {\n            if (parentNode == bytes32(0)) {\n                Root root = Root(ens.owner(bytes32(0)));\n                root.setSubnodeOwner(label, address(this));\n                ens.setResolver(node, resolver);\n            } else {\n                ens.setSubnodeRecord(\n                    parentNode,\n                    label,\n                    address(this),\n                    resolver,\n                    0\n                );\n            }\n        } else if (owner != address(this)) {\n            revert PreconditionNotMet();\n        }\n        return node;\n    }\n}"
    },
    {
      "filename": "contracts/dnsregistrar/DNSRegistrar.sol",
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\nimport \"../dnssec-oracle/BytesUtils.sol\";\nimport \"../dnssec-oracle/DNSSEC.sol\";\nimport \"../dnssec-oracle/RRUtils.sol\";\nimport \"../registry/ENSRegistry.sol\";\nimport \"../root/Root.sol\";\nimport \"../resolvers/profiles/AddrResolver.sol\";\nimport \"./DNSClaimChecker.sol\";\nimport \"./PublicSuffixList.sol\";\nimport \"./IDNSRegistrar.sol\";\n\n/**\n * @dev An ENS registrar that allows the owner of a DNS name to claim the\n *      corresponding name in ENS.\n */\ncontract DNSRegistrar is IDNSRegistrar, IERC165 {\n    using BytesUtils for bytes;\n    using Buffer for Buffer.buffer;\n    using RRUtils for *;\n\n    ENS public immutable ens;\n    DNSSEC public immutable oracle;\n    PublicSuffixList public suffixes;\n    address public immutable previousRegistrar;\n    address public immutable resolver;\n    // A mapping of the most recent signatures seen for each claimed domain.\n    mapping(bytes32 => uint32) public inceptions;\n\n    error NoOwnerRecordFound();\n    error PermissionDenied(address caller, address owner);\n    error PreconditionNotMet();\n    error StaleProof();\n    error InvalidPublicSuffix(bytes name);\n\n    struct OwnerRecord {\n        bytes name;\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    event Claim(\n        bytes32 indexed node,\n        address indexed owner,\n        bytes dnsname,\n        uint32 inception\n    );\n    event NewPublicSuffixList(address suffixes);\n\n    constructor(\n        address _previousRegistrar,\n        address _resolver,\n        DNSSEC _dnssec,\n        PublicSuffixList _suffixes,\n        ENS _ens\n    ) {\n        previousRegistrar = _previousRegistrar;\n        resolver = _resolver;\n        oracle = _dnssec;\n        suffixes = _suffixes;\n        emit NewPublicSuffixList(address(suffixes));\n        ens = _ens;\n    }\n\n    /**\n     * @dev This contract's owner-only functions can be invoked by the owner of the ENS root.\n     */\n    modifier onlyOwner() {\n        Root root = Root(ens.owner(bytes32(0)));\n        address owner = root.owner();\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setPublicSuffixList(PublicSuffixList _suffixes) public onlyOwner {\n        suffixes = _suffixes;\n        emit NewPublicSuffixList(address(suffixes));\n    }\n\n    /**\n     * @dev Submits proofs to the DNSSEC oracle, then claims a name using those proofs.\n     * @param name The name to claim, in DNS wire format.\n     * @param input A chain of signed DNS RRSETs ending with a text record.\n     */\n    function proveAndClaim(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input\n    ) public override {\n        (bytes32 rootNode, bytes32 labelHash, address addr) = _claim(\n            name,\n            input\n        );\n        ens.setSubnodeOwner(rootNode, labelHash, addr);\n    }\n\n    function proveAndClaimWithResolver(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input,\n        address resolver,\n        address addr\n    ) public override {\n        (bytes32 rootNode, bytes32 labelHash, address owner) = _claim(\n            name,\n            input\n        );\n        if (msg.sender != owner) {\n            revert PermissionDenied(msg.sender, owner);\n        }\n        ens.setSubnodeRecord(rootNode, labelHash, owner, resolver, 0);\n        if (addr != address(0)) {\n            if (resolver == address(0)) {\n                revert PreconditionNotMet();\n            }\n            bytes32 node = keccak256(abi.encodePacked(rootNode, labelHash));\n            // Set the resolver record\n            AddrResolver(resolver).setAddr(node, addr);\n        }\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure override returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IDNSRegistrar).interfaceId;\n    }\n\n    function _claim(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input\n    ) internal returns (bytes32 parentNode, bytes32 labelHash, address addr) {\n        (bytes memory data, uint32 inception) = oracle.verifyRRSet(input);\n\n        // Get the first label\n        uint256 labelLen = name.readUint8(0);\n        labelHash = name.keccak(1, labelLen);\n\n        bytes memory parentName = name.substring(\n            labelLen + 1,\n            name.length - labelLen - 1\n        );\n\n        // Make sure the parent name is enabled\n        parentNode = enableNode(parentName);\n\n        bytes32 node = keccak256(abi.encodePacked(parentNode, labelHash));\n        if (!RRUtils.serialNumberGte(inception, inceptions[node])) {\n            revert StaleProof();\n        }\n        inceptions[node] = inception;\n\n        bool found;\n        (addr, found) = DNSClaimChecker.getOwnerAddress(name, data);\n        if (!found) {\n            revert NoOwnerRecordFound();\n        }\n\n        emit Claim(node, addr, name, inception);\n    }\n\n    function enableNode(bytes memory domain) public returns (bytes32 node) {\n        // Name must be in the public suffix list.\n        if (!suffixes.isPublicSuffix(domain)) {\n            revert InvalidPublicSuffix(domain);\n        }\n        return _enableNode(domain, 0);\n    }\n\n    function _enableNode(\n        bytes memory domain,\n        uint256 offset\n    ) internal returns (bytes32 node) {\n        uint256 len = domain.readUint8(offset);\n        if (len == 0) {\n            return bytes32(0);\n        }\n\n        bytes32 parentNode = _enableNode(domain, offset + len + 1);\n        bytes32 label = domain.keccak(offset + 1, len);\n        node = keccak256(abi.encodePacked(parentNode, label));\n        address owner = ens.owner(node);\n        if (owner == address(0) || owner == previousRegistrar) {\n            if (parentNode == bytes32(0)) {\n                Root root = Root(ens.owner(bytes32(0)));\n                root.setSubnodeOwner(label, address(this));\n                ens.setResolver(node, resolver);\n            } else {\n                ens.setSubnodeRecord(\n                    parentNode,\n                    label,\n                    address(this),\n                    resolver,\n                    0\n                );\n            }\n        } else if (owner != address(this)) {\n            revert PreconditionNotMet();\n        }\n        return node;\n    }\n}"
    }
  ]
}