{
  "Title": "M-10: ChainlinkFactory will pay non-requested versions keeper fees",
  "Content": "# Issue M-10: ChainlinkFactory will pay non-requested versions keeper fees \n\nSource: https://github.com/sherlock-audit/2024-02-perennial-v2-3-judging/issues/32 \n\n## Found by \nbin2chen\n## Summary\nProtocol definition: `Requested versions will pay out a keeper fee, non-requested versions will not.`\nBut ChainlinkFactory ignores `numRequested`, which pays for both.\n## Vulnerability Details\nProtocol definition: `Requested versions will pay out a keeper fee, non-requested versions will not.`\n\n```solidity\n    /// @notice Commits the price to specified version\n    /// @dev Accepts both requested and non-requested versions.\n    ///      Requested versions will pay out a keeper fee, non-requested versions will not.\n    ///      Accepts any publish time in the underlying price message, as long as it is within the validity window,\n    ///      which means its possible for publish times to be slightly out of order with respect to versions.\n    ///      Batched updates are supported by passing in a list of price feed ids along with a valid batch update data.\n    /// @param ids The list of price feed ids to commit\n    /// @param version The oracle version to commit\n    /// @param data The update data to commit\n    function commit(bytes32[] memory ids, uint256 version, bytes calldata data) external payable {\n```\n`commit()`->`_handleKeeperFee()`->`_applicableValue()`\n`ChainlinkFactory._applicableValue ()` implements the following:\n```solidity\n    function _applicableValue(uint256, bytes memory data) internal view override returns (uint256) {\n        bytes[] memory payloads = abi.decode(data, (bytes[]));\n        uint256 totalFeeAmount = 0;\n        for (uint256 i = 0; i < payloads.length; i++) {\n            (, bytes memory report) = abi.decode(payloads[i], (bytes32[3], bytes));\n            (Asset memory fee, ,) = feeManager.getFeeAndReward(address(this), report, feeTokenAddress);\n            totalFeeAmount += fee.amount;\n        }\n        return totalFeeAmount;\n    }\n```\n\nThe above method ignores the first parameter `numRequested`.\nThis way, whether it is `Requested versions` or not, you will pay `keeper fees`.\nViolating `non-requested versions will not pay`\n\n## Impact\nIf `non-requested versions` will pay as well, it is easy to maliciously submit `non-requested` maliciously consume `ChainlinkFactory` fees balance\n(Note that needs at least one numRequested  to call `_handleKeeperFee()` )\n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial-oracle/contracts/chainlink/ChainlinkFactory.sol#L71\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is recommended that only `Requested versions`  keeper fees'\n\n```diff\n-   function _applicableValue(uint256 , bytes memory data) internal view override returns (uint256) {\n+   function _applicableValue(uint256 numRequested, bytes memory data) internal view override returns (uint256) {\n        bytes[] memory payloads = abi.decode(data, (bytes[]));\n        uint256 totalFeeAmount = 0;\n        for (uint256 i = 0; i < payloads.length; i++) {\n            (, bytes memory report) = abi.decode(payloads[i], (bytes32[3], bytes));\n            (Asset memory fee, ,) = feeManager.getFeeAndReward(address(this), report, feeTokenAddress);\n            totalFeeAmount += fee.amount;\n        }\n-       return totalFeeAmount;\n+       return totalFeeAmount * numRequested / payloads.length ;\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> valid medium, the attacker will have to commit requested along with unrequested which might not be easy to do due to competition\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/equilibria-xyz/perennial-v2/pull/293\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/254",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/chainlink/ChainlinkFactory.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"../interfaces/IChainlinkFactory.sol\";\nimport \"../keeper/KeeperFactory.sol\";\n\n/// @title ChainlinkFactory\n/// @notice Factory contract for creating and managing Chainlink oracles\ncontract ChainlinkFactory is IChainlinkFactory, KeeperFactory {\n    /// @dev Chainlink verifier contract\n    IVerifierProxy public immutable chainlink;\n\n    /// @dev Chainlink fee manager contract\n    IFeeManager public immutable feeManager;\n\n    /// @dev Fee token address\n    address public immutable feeTokenAddress;\n\n    /// @notice Initializes the immutable contract state\n    /// @param chainlink_ Chainlink verifier contract\n    /// @param feeTokenAddress_ Fee token address\n    /// @param implementation_ IKeeperOracle implementation contract\n    /// @param validFrom_ The minimum time after a version that a keeper update can be valid\n    /// @param validTo_ The maximum time after a version that a keeper update can be valid\n    /// @param commitKeepConfig_ Parameter configuration for commit keeper incentivization\n    /// @param settleKeepConfig_ Parameter configuration for settle keeper incentivization\n    constructor(\n        IVerifierProxy chainlink_,\n        IFeeManager feeManager_,\n        address feeTokenAddress_,\n        address implementation_,\n        uint256 validFrom_,\n        uint256 validTo_,\n        KeepConfig memory commitKeepConfig_,\n        KeepConfig memory settleKeepConfig_,\n        uint256 keepCommitIncrementalBufferData_\n    ) KeeperFactory(implementation_, validFrom_, validTo_, commitKeepConfig_, settleKeepConfig_, keepCommitIncrementalBufferData_) {\n        chainlink = chainlink_;\n        feeManager = feeManager_;\n        feeTokenAddress = feeTokenAddress_;\n    }\n\n    /// @notice Validates and parses the update data payload against the specified version\n    /// @param ids The list of price feed ids validate against\n    /// @param data The update data to validate\n    /// @return prices The parsed price list if valid\n    function _parsePrices(\n        bytes32[] memory ids,\n        bytes calldata data\n    ) internal override returns (PriceRecord[] memory prices) {\n        bytes[] memory verifiedReports = chainlink.verifyBulk{value: msg.value}(\n            abi.decode(data, (bytes[])),\n            abi.encode(feeTokenAddress)\n        );\n        if (verifiedReports.length != ids.length) revert ChainlinkFactoryInputLengthMismatchError();\n\n        prices = new PriceRecord[](ids.length);\n        for (uint256 i = 0; i < verifiedReports.length; i++) {\n            (bytes32 feedId, , uint32 observationsTimestamp, , , , uint192 price) =\n                abi.decode(verifiedReports[i], (bytes32, uint32, uint32, uint192, uint192, uint32, uint192));\n\n            if (feedId != toUnderlyingId[ids[i]]) revert ChainlinkFactoryInvalidFeedIdError(feedId);\n\n            prices[i] = PriceRecord(observationsTimestamp, Fixed18Lib.from(UFixed18.wrap(price)));\n        }\n    }\n\n    /// @notice Returns the applicable value for the keeper fee\n    /// @param data The update data to validate\n    /// @return The applicable value for the keeper fee\n    function _applicableValue(uint256, bytes memory data) internal view override returns (uint256) {\n        bytes[] memory payloads = abi.decode(data, (bytes[]));\n        uint256 totalFeeAmount = 0;\n        for (uint256 i = 0; i < payloads.length; i++) {\n            (, bytes memory report) = abi.decode(payloads[i], (bytes32[3], bytes));\n            (Asset memory fee, ,) = feeManager.getFeeAndReward(address(this), report, feeTokenAddress);\n            totalFeeAmount += fee.amount;\n        }\n        return totalFeeAmount;\n    }\n}"
    }
  ]
}