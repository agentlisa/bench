{
  "Title": "[N-14]  Use a more recent version of solidity",
  "Content": "Use a solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(<str>,<str>)`\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n3:    pragma solidity 0.8.11;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L3\n\n```solidity\nFile: contracts/vote-escrow/TokenUriHelper.sol\n\n3:    pragma solidity 0.8.11;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/TokenUriHelper.sol#L3\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-07-golom",
  "Code": [
    {
      "filename": "contracts/core/GolomTrader.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\ninterface ERC721 {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n\ninterface ERC1155 {\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n}\n\ninterface ERC20 {\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n}\n\ninterface Distributor {\n    function addFee(address[2] calldata addr, uint256 fee) external;\n}\n\ncontract GolomTrader is Ownable, ReentrancyGuard {\n    bytes32 public immutable EIP712_DOMAIN_TYPEHASH;\n    mapping(address => uint256) public nonces; // all nonces other then this nonce\n    mapping(bytes32 => uint256) public filled;\n\n    ERC20 WETH = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    struct Order {\n        address collection; // NFT contract address\n        uint256 tokenId; // order for which tokenId of the collection\n        address signer; // maker of order address\n        uint256 orderType; // 0 if selling nft for eth , 1 if offering weth for nft,2 if offering weth for collection with special criteria root\n        uint256 totalAmt; // price value of the trade // total amt maker is willing to give up per unit of amount\n        Payment exchange; // payment agreed by maker of the order to pay on succesful filling of trade this amt is subtracted from totalamt\n        Payment prePayment; // another payment , can be used for royalty, facilating trades\n        bool isERC721; // standard of the collection , if 721 then true , if 1155 then false\n        uint256 tokenAmt; // token amt useful if standard is 1155 if >1 means whole order can be filled tokenAmt times\n        uint256 refererrAmt; // amt to pay to the address that helps in filling your order\n        bytes32 root; // A merkle root derived from each valid tokenId â€” set to 0 to indicate a collection-level or tokenId-specific order.\n        address reservedAddress; // if not address(0) , only this address can fill the order\n        uint256 nonce; // nonce of order usefull for cancelling in bulk\n        uint256 deadline; // timestamp till order is valid epoch timestamp in secs\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct Payment {\n        uint256 paymentAmt;\n        address paymentAddress;\n    }\n\n    address public governance;\n\n    Distributor public distributor;\n    address public pendingDistributor;\n    uint256 public distributorEnableDate;\n\n    // events\n    event NonceIncremented(address indexed maker, uint256 newNonce);\n\n    event OrderFilled(\n        address indexed maker,\n        address indexed taker,\n        uint256 indexed orderType,\n        bytes32 orderHash,\n        uint256 price\n    );\n\n    event OrderCancelled(bytes32 indexed orderHash);\n\n    /// @param _governance Address of the governance, responsible for setting distributor\n    constructor(address _governance) {\n        // sets governance as owner\n        _transferOwnership(_governance);\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n\n        EIP712_DOMAIN_TYPEHASH = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes('GOLOM.IO')),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function hashPayment(Payment calldata p) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256('payment(uint256 paymentAmt,address paymentAddress)'),\n                    p.paymentAmt,\n                    p.paymentAddress\n                )\n            );\n    }\n\n    function _hashOrder(Order calldata o) private pure returns (bytes32) {\n        return _hashOrderinternal(o, [o.nonce, o.deadline]);\n    }\n\n    function _hashOrderinternal(Order calldata o, uint256[2] memory extra) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        'order(address collection,uint256 tokenId,address signer,uint256 orderType,uint256 totalAmt,payment exchange,payment prePayment,bool isERC721,uint256 tokenAmt,uint256 refererrAmt,bytes32 root,address reservedAddress,uint256 nonce,uint256 deadline)payment(uint256 paymentAmt,address paymentAddress)'\n                    ),\n                    o.collection,\n                    o.tokenId,\n                    o.signer,\n                    o.orderType,\n                    o.totalAmt,\n                    hashPayment(o.exchange),\n                    hashPayment(o.prePayment),\n                    o.isERC721,\n                    o.tokenAmt,\n                    o.refererrAmt,\n                    o.root,\n                    o.reservedAddress,\n                    extra\n                )\n            );\n    }\n\n    function payEther(uint256 payAmt, address payAddress) internal {\n        if (payAmt > 0) {\n            // if royalty has to be paid\n            payable(payAddress).transfer(payAmt); // royalty transfer to royaltyaddress\n        }\n    }\n\n    /// @dev Validates Order and returns OrderStatus, hashedorder, amountRemaining to be filled\n    ///      OrderStatus = 0 , if signature is invalid\n    ///      OrderStatus = 1 , if deadline has been\n    ///      OrderStatus = 2 , order is filled or cancelled\n    ///      OrderStatus = 3 , valid order\n    /// @param o the Order struct to be validated\n    function validateOrder(Order calldata o)\n        public\n        view\n        returns (\n            uint256,\n            bytes32,\n            uint256\n        )\n    {\n        // match signature\n        bytes32 hashStruct = _hashOrder(o);\n        bytes32 hash = keccak256(abi.encodePacked('\\x19\\x01', EIP712_DOMAIN_TYPEHASH, hashStruct));\n        address signaturesigner = ecrecover(hash, o.v, o.r, o.s);\n        require(signaturesigner == o.signer, 'invalid signature');\n        if (signaturesigner != o.signer) {\n            return (0, hashStruct, 0);\n        }\n        //deadline\n        if (block.timestamp > o.deadline) {\n            return (1, hashStruct, 0);\n        }\n        // not cancelled by nonce or by hash\n        if (o.nonce != nonces[o.signer]) {\n            return (2, hashStruct, 0);\n        }\n        if (filled[hashStruct] >= o.tokenAmt) {\n            // handles erc1155\n            return (2, hashStruct, 0);\n        }\n        return (3, hashStruct, o.tokenAmt - filled[hashStruct]);\n    }\n\n    /// @dev function to fill a signed order of ordertype 0, also has a payment param in case the taker wants\n    ///      to send ether to that address on filling the order\n    /// @param o the Order struct to be filled must be orderType 0\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    /// @param receiver address which will receive the NFT\n    function fillAsk(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p,\n        address receiver\n    ) public payable nonReentrant {\n        // check if the signed total amount has all the amounts as well as 50 basis points fee\n        require(\n            o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt + (o.totalAmt * 50) / 10000,\n            'amt not matching'\n        );\n\n        // attached ETH value should be greater than total value of one NFT * total number of NFTs + any extra payment to be given\n        require(msg.value >= o.totalAmt * amount + p.paymentAmt, 'mgmtm');\n\n        if (o.reservedAddress != address(0)) {\n            require(msg.sender == o.reservedAddress);\n        }\n        require(o.orderType == 0, 'invalid orderType');\n\n        (uint256 status, bytes32 hashStruct, uint256 amountRemaining) = validateOrder(o);\n\n        require(status == 3, 'order not valid');\n        require(amountRemaining >= amount, 'order already filled');\n\n        filled[hashStruct] = filled[hashStruct] + amount;\n\n        if (receiver == address(0)) {\n            receiver = msg.sender;\n        }\n        if (o.isERC721) {\n            require(amount == 1, 'only 1 erc721 at 1 time');\n            ERC721(o.collection).transferFrom(o.signer, receiver, o.tokenId);\n        } else {\n            ERC1155(o.collection).safeTransferFrom(o.signer, receiver, o.tokenId, amount, '');\n        }\n\n        // pay fees of 50 basis points to the distributor\n        payEther(((o.totalAmt * 50) / 10000) * amount, address(distributor));\n\n        // pay the exchange share\n        payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);\n\n        // pay the pre payment\n        payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);\n\n        if (o.refererrAmt > 0 && referrer != address(0)) {\n            payEther(o.refererrAmt * amount, referrer);\n            payEther(\n                (o.totalAmt -\n                    (o.totalAmt * 50) /\n                    10000 -\n                    o.exchange.paymentAmt -\n                    o.prePayment.paymentAmt -\n                    o.refererrAmt) * amount,\n                o.signer\n            );\n        } else {\n            payEther(\n                (o.totalAmt - (o.totalAmt * 50) / 10000 - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount,\n                o.signer\n            );\n        }\n        payEther(p.paymentAmt, p.paymentAddress);\n\n        distributor.addFee([o.signer, o.exchange.paymentAddress], ((o.totalAmt * 50) / 10000) * amount);\n        emit OrderFilled(o.signer, msg.sender, 0, hashStruct, o.totalAmt * amount);\n    }\n\n    /// @dev function to fill a signed order of ordertype 1 also has a payment param in case the taker wants\n    ///      to send ether to that address on filling the order\n    /// @param o the Order struct to be filled must be orderType 1\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    function fillBid(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p\n    ) public nonReentrant {\n        require(\n            o.totalAmt * amount >\n                (o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt) * amount + p.paymentAmt\n        ); // cause bidder eth is paying for seller payment p , dont take anything extra from seller\n        // require eth amt is sufficient\n        if (o.reservedAddress != address(0)) {\n            require(msg.sender == o.reservedAddress);\n        }\n        require(o.orderType == 1);\n        (uint256 status, bytes32 hashStruct, uint256 amountRemaining) = validateOrder(o);\n        require(status == 3);\n        require(amountRemaining >= amount);\n        filled[hashStruct] = filled[hashStruct] + amount;\n        if (o.isERC721) {\n            require(amount == 1, 'only 1 erc721 at 1 time');\n            ERC721 nftcontract = ERC721(o.collection);\n            nftcontract.transferFrom(msg.sender, o.signer, o.tokenId);\n        } else {\n            ERC1155 nftcontract = ERC1155(o.collection);\n            nftcontract.safeTransferFrom(msg.sender, o.signer, o.tokenId, amount, '');\n        }\n        emit OrderFilled(msg.sender, o.signer, 1, hashStruct, o.totalAmt * amount);\n        _settleBalances(o, amount, referrer, p);\n    }\n\n    // cancel by nonce and by individual order\n\n    function cancelOrder(Order calldata o) public nonReentrant {\n        require(o.signer == msg.sender);\n        (, bytes32 hashStruct, ) = validateOrder(o);\n        filled[hashStruct] = o.tokenAmt + 1;\n        emit OrderCancelled(hashStruct);\n    }\n\n    /**\n     * Increment a particular maker's nonce, thereby invalidating all orders that were not signed\n     * with the original nonce.\n     */\n    function incrementNonce() external nonReentrant {\n        uint256 newNonce = ++nonces[msg.sender];\n        emit NonceIncremented(msg.sender, newNonce);\n    }\n\n    /// @dev function to fill a signed order of ordertype 2 also has a payment param in case the taker wants\n    ///      to send ether to that address on filling the order, Match an criteria order, ensuring that the supplied proof demonstrates inclusion of the tokenId in the associated merkle root, if root is 0 then any token can be used to fill the order\n    /// @param o the Order struct to be filled must be orderType 2\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    function fillCriteriaBid(\n        Order calldata o,\n        uint256 amount,\n        uint256 tokenId,\n        bytes32[] calldata proof,\n        address referrer,\n        Payment calldata p\n    ) public nonReentrant {\n        require(o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt);\n        // require eth amt is sufficient\n        if (o.reservedAddress != address(0)) {\n            require(msg.sender == o.reservedAddress);\n        }\n        require(o.orderType == 2);\n        (uint256 status, bytes32 hashStruct, uint256 amountRemaining) = validateOrder(o);\n        require(status == 3);\n        require(amountRemaining >= amount);\n\n        filled[hashStruct] = filled[hashStruct] + amount;\n        // Proof verification is performed when there's a non-zero root.\n        if (o.root != bytes32(0)) {\n            _verifyProof(tokenId, o.root, proof);\n        }\n\n        if (o.isERC721) {\n            require(amount == 1, 'only 1 erc721 at 1 time');\n            ERC721 nftcontract = ERC721(o.collection);\n            nftcontract.transferFrom(msg.sender, o.signer, tokenId);\n        } else {\n            ERC1155 nftcontract = ERC1155(o.collection);\n            nftcontract.safeTransferFrom(msg.sender, o.signer, tokenId, amount, '');\n        }\n        emit OrderFilled(msg.sender, o.signer, 2, hashStruct, o.totalAmt * amount);\n        _settleBalances(o, amount, referrer, p);\n    }\n\n    /// @dev function to settle balances when a bid is filled succesfully\n    /// @param o the Order struct to be filled must be orderType 1\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    function _settleBalances(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p\n    ) internal {\n        uint256 protocolfee = ((o.totalAmt * 50) / 10000) * amount;\n        WETH.transferFrom(o.signer, address(this), o.totalAmt * amount);\n        WETH.withdraw(o.totalAmt * amount);\n        payEther(protocolfee, address(distributor));\n        payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);\n        payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);\n        if (o.refererrAmt > 0 && referrer != address(0)) {\n            payEther(o.refererrAmt * amount, referrer);\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *\n                    amount -\n                    p.paymentAmt,\n                msg.sender\n            );\n        } else {\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,\n                msg.sender\n            );\n        }\n        payEther(p.paymentAmt, p.paymentAddress);\n        distributor.addFee([msg.sender, o.exchange.paymentAddress], protocolfee);\n    }\n\n    /// @dev Ensure that a given tokenId is contained within a supplied merkle root using a supplied proof.\n    /// @param leaf The tokenId.\n    /// @param root A merkle root derived from each valid tokenId.\n    /// @param proof A proof that the supplied tokenId is contained within the associated merkle root.\n    function _verifyProof(\n        uint256 leaf,\n        bytes32 root,\n        bytes32[] memory proof\n    ) public pure {\n        bytes32 computedHash = keccak256(abi.encode(leaf));\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        if (computedHash != root) {\n            revert('invalid proof');\n        }\n    }\n\n    /// @dev Efficiently hash two bytes32 elements using memory scratch space.\n    /// @param a The first element included in the hash.\n    /// @param b The second element included in the hash.\n    /// @return value The resultant hash of the two bytes32 elements.\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @notice Sets the distributor contract\n    /// @param _distributor Address of the distributor\n    function setDistributor(address _distributor) external onlyOwner {\n        if (address(distributor) == address(0)) {\n            distributor = Distributor(_distributor);\n        } else {\n            pendingDistributor = _distributor;\n            distributorEnableDate = block.timestamp + 1 days;\n        }\n    }\n\n    /// @notice Executes the set distributor function after the timelock\n    function executeSetDistributor() external onlyOwner {\n        require(distributorEnableDate <= block.timestamp, 'not allowed');\n        distributor = Distributor(pendingDistributor);\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/vote-escrow/TokenUriHelper.sol",
      "content": "/// [MIT License]\n\npragma solidity 0.8.11;\n\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\nlibrary Base64 {\n    bytes internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n    /// @notice Encodes some bytes to the base64 representation\n    function encode(bytes memory data) internal pure returns (string memory) {\n        uint256 len = data.length;\n        if (len == 0) return '';\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((len + 2) / 3);\n\n        // Add some extra buffer at the end\n        bytes memory result = new bytes(encodedLen + 32);\n\n        bytes memory table = TABLE;\n\n        assembly {\n            let tablePtr := add(table, 1)\n            let resultPtr := add(result, 32)\n\n            for {\n                let i := 0\n            } lt(i, len) {\n\n            } {\n                i := add(i, 3)\n                let input := and(mload(add(data, i)), 0xffffff)\n\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n                out := shl(224, out)\n\n                mstore(resultPtr, out)\n\n                resultPtr := add(resultPtr, 4)\n            }\n\n            switch mod(len, 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n\n            mstore(result, encodedLen)\n        }\n\n        return string(result);\n    }\n}\n\nlibrary TokenUriHelper {\n    function _tokenURI(\n        uint256 _tokenId,\n        uint256 _balanceOf,\n        uint256 _locked_end,\n        uint256 _value\n    ) public pure returns (string memory output) {\n        output = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"512\" height=\"468\" viewBox=\"0 0 512 468\" fill=\"none\"><g clip-path=\"url(#clip0_2_190)\"><rect width=\"512\" height=\"468\" rx=\"40\" fill=\"#232323\"/><g filter=\"url(#filter0_f_2_190)\"><ellipse cx=\"256.5\" cy=\"-132\" rx=\"164\" ry=\"381.5\" transform=\"rotate(-90 256.5 -132)\" fill=\"#FF8982\"/></g>';\n        output = string(\n            abi.encodePacked(\n                output,\n                '<text y=\"128px\" x=\"60px\" fill=\"white\" font-family=\"Lexend Deca, sans-serif\" font-weight=\"400\" font-size=\"64px\">#',\n                toString(_tokenId),\n                '</text><text y=\"318px\" x=\"54px\" fill=\"white\" font-family=\"Lexend Deca, sans-serif\" font-weight=\"400\" font-size=\"24px\" fill-opacity=\"0.64\">Locked Till</text>'\n            )\n        );\n        output = string(\n            abi.encodePacked(\n                output,\n                '<text y=\"320px\" x=\"445px\" fill=\"white\" font-family=\"Lexend Deca, sans-serif\" font-weight=\"400\" font-size=\"24px\" text-anchor=\"end\">',\n                toString(_locked_end),\n                '</text><text y=\"248px\" x=\"54px\" fill=\"white\" font-family=\"Lexend Deca, sans-serif\" font-weight=\"400\" font-size=\"24px\" fill-opacity=\"0.64\">Voting Power</text>'\n            )\n        );\n        output = string(\n            abi.encodePacked(\n                output,\n                '<text y=\"248px\" x=\"445px\" fill=\"white\" font-family=\"Lexend Deca, sans-serif\" font-weight=\"400\" font-size=\"24px\" text-anchor=\"end\">',\n                toString(_balanceOf),\n                '</text><text y=\"391px\" x=\"54px\" fill=\"white\" font-family=\"Lexend Deca, sans-serif\" font-weight=\"400\" font-size=\"24px\" fill-opacity=\"0.64\">Value</text>'\n            )\n        );\n        output = string(\n            abi.encodePacked(\n                output,\n                '<text y=\"392px\" x=\"447px\" fill=\"white\" font-family=\"Lexend Deca, sans-serif\" font-weight=\"400\" font-size=\"24px\" text-anchor=\"end\">',\n                toString(_value),\n                '</text><mask id=\"mask0_2_190\" style=\"mask-type:alpha\" maskUnits=\"userSpaceOnUse\" x=\"399\" y=\"73\" width=\"58\" height=\"58\"><path d=\"M456.543 102.091C456.543 117.884 443.74 130.686 427.948 130.686C412.155 130.686 399.352 117.884 399.352 102.091C399.352 86.2981 412.155 73.4955 427.948 73.4955C443.74 73.4955 456.543 86.2981 456.543 102.091ZM405.91 102.091C405.91 114.262 415.777 124.128 427.948 124.128C440.118 124.128 449.985 114.262 449.985 102.091C449.985 89.9201 440.118 80.0537 427.948 80.0537C415.777 80.0537 405.91 89.9201 405.91 102.091Z\" fill=\"#C4C4C4\"/></mask><g mask=\"url(#mask0_2_190)\"><path d=\"M458.138 73.4955H396.962V133.076H458.138V73.4955Z\" fill=\"#FD7A7A\"/><path d=\"M396.962 76.7614H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 80.266H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 83.7708H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 87.2754H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 90.7802H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 94.2848H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 97.7897H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 101.294H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 104.799H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 108.304H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 111.808H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 115.313H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 118.818H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 122.323H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 125.827H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 129.332H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/></g><mask id=\"mask1_2_190\" style=\"mask-type:alpha\" maskUnits=\"userSpaceOnUse\" x=\"399\" y=\"73\" width=\"58\" height=\"58\"><path d=\"M456.543 102.091C456.543 117.884 443.74 130.686 427.948 130.686C412.155 130.686 399.352 117.884 399.352 102.091C399.352 86.2981 412.155 73.4955 427.948 73.4955C443.74 73.4955 456.543 86.2981 456.543 102.091ZM405.91 102.091C405.91 114.262 415.777 124.128 427.948 124.128C440.118 124.128 449.985 114.262 449.985 102.091C449.985 89.9201 440.118 80.0537 427.948 80.0537C415.777 80.0537 405.91 89.9201 405.91 102.091Z\" fill=\"white\"/></mask><g mask=\"url(#mask1_2_190)\"><path d=\"M456.543 102.091C456.543 117.884 443.74 130.686 427.948 130.686C412.155 130.686 399.352 117.884 399.352 102.091C399.352 86.2981 412.155 73.4955 427.948 73.4955C443.74 73.4955 456.543 86.2981 456.543 102.091ZM405.91 102.091C405.91 114.262 415.777 124.128 427.948 124.128C440.118 124.128 449.985 114.262 449.985 102.091C449.985 89.9201 440.118 80.0537 427.948 80.0537C415.777 80.0537 405.91 89.9201 405.91 102.091Z\" stroke=\"black\" stroke-width=\"0.876179\"/><path d=\"M422.132 130.606H428.026\" stroke=\"black\" stroke-width=\"0.109522\"/><path d=\"M422.132 73.5752H428.026\" stroke=\"black\" stroke-width=\"0.109522\"/></g><mask id=\"mask2_2_190\" style=\"mask-type:alpha\" maskUnits=\"userSpaceOnUse\" x=\"393\" y=\"73\" width=\"58\" height=\"58\"><path d=\"M450.648 102.091C450.648 117.884 437.845 130.686 422.053 130.686C406.26 130.686 393.457 117.884 393.457 102.091C393.457 86.2981 406.26 73.4955 422.053 73.4955C437.845 73.4955 450.648 86.2981 450.648 102.091ZM400.015 102.091C400.015 114.262 409.882 124.128 422.053 124.128C434.223 124.128 444.09 114.262 444.09 102.091C444.09 89.9201 434.223 80.0537 422.053 80.0537C409.882 80.0537 400.015 89.9201 400.015 102.091Z\" fill=\"white\"/></mask><g mask=\"url(#mask2_2_190)\"><path d=\"M450.648 102.091C450.648 117.884 437.845 130.686 422.053 130.686C406.26 130.686 393.457 117.884 393.457 102.091C393.457 86.2981 406.26 73.4955 422.053 73.4955C437.845 73.4955 450.648 86.2981 450.648 102.091ZM400.015 102.091C400.015 114.262 409.882 124.128 422.053 124.128C434.223 124.128 444.09 114.262 444.09 102.091C444.09 89.9201 434.223 80.0537 422.053 80.0537C409.882 80.0537 400.015 89.9201 400.015 102.091Z\" fill=\"white\" stroke=\"black\" stroke-width=\"0.876179\"/></g></g><defs><filter id=\"filter0_f_2_190\" x=\"-381\" y=\"-552\" width=\"1275\" height=\"840\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\"><feFlood flood-opacity=\"0\" result=\"BackgroundImageFix\"/><feBlend mode=\"normal\" in=\"SourceGraphic\" in2=\"BackgroundImageFix\" result=\"shape\"/><feGaussianBlur stdDeviation=\"128\" result=\"effect1_foregroundBlur_2_190\"/></filter><clipPath id=\"clip0_2_190\"><rect width=\"512\" height=\"468\" rx=\"40\" fill=\"white\"/></clipPath></defs></svg>'\n            )\n        );\n\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"name\": \"Lock #',\n                        toString(_tokenId),\n                        '\", \"description\": \"Golom locks, can be used to claim protocol fees and token emission\", \"attributes\": [{\"trait_type\":\"Lock End\",\"value\":\"',\n                        toString(_locked_end),\n                        '\"},{\"trait_type\":\"Power\",\"value\":\"',\n                        toString(_balanceOf),\n                        '\"},{\"trait_type\":\"Value\",\"value\":\"',\n                        toString(_value),\n                        '\"}], \"image\": \"data:image/svg+xml;base64,',\n                        Base64.encode(bytes(output)),\n                        '\"}'\n                    )\n                )\n            )\n        );\n        output = string(abi.encodePacked('data:application/json;base64,', json));\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT license\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return '0';\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}"
    }
  ]
}