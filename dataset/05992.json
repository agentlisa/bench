{
  "Title": "[10] Enhanced reward distribution to safeguard against reserve depletion in auction calculations",
  "Content": "The `rewards` function in the provided `RewardLib` library calculates the rewards for a series of auctions based on a given reserve. A potential issue is that midway through the calculations, the `remainingReserve` might become insufficient to provide the required reward for an auction, potentially causing underflows or incorrect behavior. To address this concern, it's recommended to implement a check to ensure that each reward doesn't exceed the `remainingReserve`, and if it does, the function should gracefully exit the loop to avoid unexpected results.\n\nHere's a suggested fix:\n\nhttps://github.com/GenerationSoftware/pt-v5-draw-auction/blob/f1c6d14a1772d6609de1870f8713fb79977d51c1/src/libraries/RewardLib.sol#L58-L70\n\n```diff\n  function rewards(\n    AuctionResult[] memory _auctionResults,\n    uint256 _reserve\n  ) internal pure returns (uint256[] memory) {\n    uint256 remainingReserve = _reserve;\n    uint256 _auctionResultsLength = _auctionResults.length;\n    uint256[] memory _rewards = new uint256[](_auctionResultsLength);\n    for (uint256 i; i < _auctionResultsLength; i++) {\n-      _rewards[i] = reward(_auctionResults[i], remainingReserve);\n-      remainingReserve = remainingReserve - _rewards[i];\n\n+      uint256 calculatedReward = reward(_auctionResults[i], remainingReserve);\n+      if (calculatedReward > remainingReserve) {\n+            break; // Stop if there's not enough remaining reserve.\n+        }\n+      _rewards[i] = calculatedReward;\n+      remainingReserve = remainingReserve - calculatedReward;\n    }\n    return _rewards;\n  }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-08-pooltogether",
  "Code": [
    {
      "filename": "src/libraries/RewardLib.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { UD2x18 } from \"prb-math/UD2x18.sol\";\nimport { UD60x18, convert } from \"prb-math/UD60x18.sol\";\n\nimport { AuctionResult } from \"../interfaces/IAuction.sol\";\n\n/// @title RewardLib\n/// @author G9 Software Inc.\n/// @notice Library for calculating auction rewards.\n/// @dev This library uses a parabolic fractional dutch auction (PFDA) to calculate rewards. For more details see https://dev.pooltogether.com/protocol/next/design/draw-auction#parabolic-fractional-dutch-auction-pfda\nlibrary RewardLib {\n  /* ============ Internal Functions ============ */\n\n  /**\n   * @notice Calculates the fractional reward using a Parabolic Fractional Dutch Auction (PFDA)\n   * given the elapsed time, auction time, and target sale parameters.\n   * @param _elapsedTime The elapsed time since the start of the auction in seconds\n   * @param _auctionDuration The auction duration in seconds\n   * @param _targetTimeFraction The target sale time as a fraction of the total auction duration (0.0,1.0]\n   * @param _targetRewardFraction The target fractional sale price\n   * @return The reward fraction as a UD2x18 fraction\n   */\n  function fractionalReward(\n    uint64 _elapsedTime,\n    uint64 _auctionDuration,\n    UD2x18 _targetTimeFraction,\n    UD2x18 _targetRewardFraction\n  ) internal pure returns (UD2x18) {\n    UD60x18 x = convert(_elapsedTime).div(convert(_auctionDuration));\n    UD60x18 t = UD60x18.wrap(_targetTimeFraction.unwrap());\n    UD60x18 r = UD60x18.wrap(_targetRewardFraction.unwrap());\n    UD60x18 rewardFraction;\n    if (x.gt(t)) {\n      UD60x18 tDelta = x.sub(t);\n      UD60x18 oneMinusT = convert(1).sub(t);\n      rewardFraction = r.add(\n        convert(1).sub(r).mul(tDelta).mul(tDelta).div(oneMinusT).div(oneMinusT)\n      );\n    } else {\n      UD60x18 tDelta = t.sub(x);\n      rewardFraction = r.sub(r.mul(tDelta).mul(tDelta).div(t).div(t));\n    }\n    return UD2x18.wrap(uint64(rewardFraction.unwrap()));\n  }\n\n  /**\n   * @notice Calculates rewards to distribute given the available reserve and completed\n   * auction results.\n   * @dev Each auction takes a fraction of the remaining reserve. This means that if the\n   * reserve is equal to 100 and the first auction takes 50% and the second takes 50%, then\n   * the first reward will be equal to 50 while the second will be 25.\n   * @param _auctionResults Auction results to get rewards for\n   * @param _reserve Reserve available for the rewards\n   * @return Rewards in the same order as the auction results they correspond to\n   */\n  function rewards(\n    AuctionResult[] memory _auctionResults,\n    uint256 _reserve\n  ) internal pure returns (uint256[] memory) {\n    uint256 remainingReserve = _reserve;\n    uint256 _auctionResultsLength = _auctionResults.length;\n    uint256[] memory _rewards = new uint256[](_auctionResultsLength);\n    for (uint256 i; i < _auctionResultsLength; i++) {\n      _rewards[i] = reward(_auctionResults[i], remainingReserve);\n      remainingReserve = remainingReserve - _rewards[i];\n    }\n    return _rewards;\n  }\n\n  /**\n   * @notice Calculates the reward for the given auction result and available reserve.\n   * @dev If the auction reward recipient is the zero address, no reward will be given.\n   * @param _auctionResult Auction result to get reward for\n   * @param _reserve Reserve available for the reward\n   * @return Reward amount\n   */\n  function reward(\n    AuctionResult memory _auctionResult,\n    uint256 _reserve\n  ) internal pure returns (uint256) {\n    if (_auctionResult.recipient == address(0)) return 0;\n    if (_reserve == 0) return 0;\n    return\n      convert(\n        UD60x18.wrap(UD2x18.unwrap(_auctionResult.rewardFraction)).mul(convert(_reserve))\n      );\n  }\n}"
    }
  ]
}