{
  "Title": "[G-12]  Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
  "Content": "When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having `memory` arguments, it's still valid for implementation contracs to use `calldata` arguments instead. \n\nIf the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one\n\nNote that I've also flagged instances where the function is `public` but can be marked as `external` since it's not called by the contract, and cases where a constructor is involved\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: src/ReservoirOracleUnderwriter.sol\n\n/// @audit oracleInfo - (valid but excluded finding)\n64        function underwritePriceForCollateral(ERC721 asset, PriceKind priceKind, OracleInfo memory oracleInfo)\n65            public\n66:           returns (uint256)\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/ReservoirOracleUnderwriter.sol#L64-L66\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-12-backed",
  "Code": [
    {
      "filename": "src/ReservoirOracleUnderwriter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {ReservoirOracle} from \"@reservoir/ReservoirOracle.sol\";\n\ncontract ReservoirOracleUnderwriter {\n    /// @notice The kind of floor price to use from the oracle\n    /// @dev SPOT is the floor price at the time of the oracle message\n    /// @dev TWAP is the average weighted floor price over the last TWAP_SECONDS\n    /// @dev LOWER is the minimum of SPOT and TWAP\n    /// @dev UPPER is the maximum of SPOT and TWAP\n    /// @dev see https://docs.reservoir.tools/reference/getoraclecollectionsflooraskv4 for more details\n    enum PriceKind {\n        SPOT,\n        TWAP,\n        LOWER,\n        UPPER\n    }\n\n    /// @notice The signature of a message from our oracle signer\n    struct Sig {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @notice The message and signature from our oracle signer\n    struct OracleInfo {\n        ReservoirOracle.Message message;\n        Sig sig;\n    }\n\n    /// @notice the amount of time to use for the TWAP\n    uint256 constant TWAP_SECONDS = 30 days;\n\n    /// @notice the maximum time a given signed oracle message is valid for\n    uint256 constant VALID_FOR = 20 minutes;\n\n    /// @notice the signing address the contract expects from the oracle message\n    address public immutable oracleSigner;\n\n    /// @notice address of the currency we are receiving oracle prices in\n    address public immutable quoteCurrency;\n\n    error IncorrectOracleSigner();\n    error WrongIdentifierFromOracleMessage();\n    error WrongCurrencyFromOracleMessage();\n    error OracleMessageTooOld();\n\n    constructor(address _oracleSigner, address _quoteCurrency) {\n        oracleSigner = _oracleSigner;\n        quoteCurrency = _quoteCurrency;\n    }\n\n    /// @notice returns the price of an asset from a signed oracle message\n    /// @param asset the address of the ERC721 asset to underwrite the price for\n    /// @param priceKind the kind of price the function expects the oracle message to contain\n    /// @param oracleInfo the message and signature from our oracle signer\n    /// @return oraclePrice the price of the asset, expressed in quoteCurrency units\n    /// @dev reverts if the signer of the oracle message is incorrect\n    /// @dev reverts if the oracle message was signed longer than VALID_FOR ago\n    /// @dev reverts if the oracle message is for the wrong ERC721 asset, wrong price kind, or wrong quote currency\n    function underwritePriceForCollateral(ERC721 asset, PriceKind priceKind, OracleInfo memory oracleInfo)\n        public\n        returns (uint256)\n    {\n        address signerAddress = ecrecover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    // EIP-712 structured-data hash\n                    keccak256(\n                        abi.encode(\n                            keccak256(\"Message(bytes32 id,bytes payload,uint256 timestamp)\"),\n                            oracleInfo.message.id,\n                            keccak256(oracleInfo.message.payload),\n                            oracleInfo.message.timestamp\n                        )\n                    )\n                )\n            ),\n            oracleInfo.sig.v,\n            oracleInfo.sig.r,\n            oracleInfo.sig.s\n        );\n\n        if (signerAddress != oracleSigner) {\n            revert IncorrectOracleSigner();\n        }\n\n        bytes32 expectedId = keccak256(\n            abi.encode(\n                keccak256(\"ContractWideCollectionPrice(uint8 kind,uint256 twapSeconds,address contract)\"),\n                priceKind,\n                TWAP_SECONDS,\n                asset\n            )\n        );\n\n        if (oracleInfo.message.id != expectedId) {\n            revert WrongIdentifierFromOracleMessage();\n        }\n\n        if (\n            oracleInfo.message.timestamp > block.timestamp || oracleInfo.message.timestamp + VALID_FOR < block.timestamp\n        ) {\n            revert OracleMessageTooOld();\n        }\n\n        (address oracleQuoteCurrency, uint256 oraclePrice) = abi.decode(oracleInfo.message.payload, (address, uint256));\n        if (oracleQuoteCurrency != quoteCurrency) {\n            revert WrongCurrencyFromOracleMessage();\n        }\n\n        return oraclePrice;\n    }\n}"
    }
  ]
}