{
  "Title": "Ignore failure status for `CToken`",
  "Content": "##### Description\nThere are many reasons for failure `CToken`, but Lenders contracts ignore it in the all places.\nInterface methods of `CToken`:\nFor \n```\nfunction mint(uint256 mintAmount) external returns (uint256);\n```\n- https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/GenericCompound.sol#L140\n-  https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/GenericCream.sol#L119\n\nFor \n```\nfunction redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n```\n- https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/GenericCompound.sol#L85\n- https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/GenericCompound.sol#L113\n- https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/GenericCompound.sol#L116\n\n-  https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/GenericCream.sol#L78\n-  https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/GenericCream.sol#L106\n-  https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/GenericCream.sol#L109\n\n\nReturn value (`uint256`) is enum of errors which may be:\n\n```\nenum Error {\n    NO_ERROR,\n    UNAUTHORIZED,\n    COMPTROLLER_MISMATCH,\n    INSUFFICIENT_SHORTFALL,\n    INSUFFICIENT_LIQUIDITY,\n    INVALID_CLOSE_FACTOR,\n    INVALID_COLLATERAL_FACTOR,\n    INVALID_LIQUIDATION_INCENTIVE,\n    MARKET_NOT_ENTERED, // no longer possible\n    MARKET_NOT_LISTED,\n    MARKET_ALREADY_LISTED,\n    MATH_ERROR,\n    NONZERO_BORROW_BALANCE,\n    PRICE_ERROR,\n    REJECTION,\n    SNAPSHOT_ERROR,\n    TOO_MANY_ASSETS,\n    TOO_MUCH_REPAY\n}\n```\n\n##### Recommendation\nWe recommend to validate return of every method for `CToken`. If method returns no `NO_ERROR` â€” revert it.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/GenericLender/GenericCompound.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces/Compound/CErc20I.sol\";\nimport \"../Interfaces/Compound/InterestRateModel.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../Interfaces/UniswapInterfaces/IUniswapV2Router02.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for any erc20 asset on compound (not eth)\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericDyDx/GenericCompound.sol\n *\n ********************* */\n\ncontract GenericCompound is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant blocksPerYear = 2_300_000;\n    address public constant uniswapRouter = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address public constant comp = address(0xc00e94Cb662C3520282E6f5717214004A7f26888);\n    address public constant weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    uint256 public minCompToSell = 0.5 ether;\n\n    CErc20I public cToken;\n\n    constructor(\n        address _strategy,\n        string memory name,\n        address _cToken\n    ) public GenericLenderBase(_strategy, name) {\n        cToken = CErc20I(_cToken);\n\n        require(cToken.underlying() == address(want), \"WRONG CTOKEN\");\n\n        want.approve(_cToken, uint256(-1));\n    }\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)).add(underlyingBalanceStored());\n    }\n\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        uint256 currentCr = cToken.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            balance = currentCr.mul(cToken.exchangeRateStored()).div(1e18);\n        }\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    function _apr() internal view returns (uint256) {\n        return cToken.supplyRatePerBlock().mul(blocksPerYear);\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        cToken.redeemUnderlying(amount);\n\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //withdraw an amount including any want balance\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = cToken.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying.add(looseBalance);\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(cToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount.sub(looseBalance);\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                cToken.redeemUnderlying(toWithdraw);\n            } else {\n                //take all we can\n                cToken.redeemUnderlying(liquidity);\n            }\n        }\n        _disposeOfComp();\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    function _disposeOfComp() internal {\n        uint256 _comp = IERC20(comp).balanceOf(address(this));\n\n        if (_comp > minCompToSell) {\n            address[] memory path = new address[](3);\n            path[0] = comp;\n            path[1] = weth;\n            path[2] = address(want);\n\n            IUniswapV2Router02(uniswapRouter).swapExactTokensForTokens(_comp, uint256(0), path, address(this), now);\n        }\n    }\n\n    function deposit() external override management {\n        uint256 balance = want.balanceOf(address(this));\n        cToken.mint(balance);\n    }\n\n    function withdrawAll() external override management returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    //think about this\n    function enabled() external view override returns (bool) {\n        return true;\n    }\n\n    function hasAssets() external view override returns (bool) {\n        //return cToken.balanceOf(address(this)) > 0;\n        return cToken.balanceOf(address(this)) > 0 || want.balanceOf(address(this)) > 0;\n    }\n\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        uint256 cashPrior = want.balanceOf(address(cToken));\n\n        uint256 borrows = cToken.totalBorrows();\n\n        uint256 reserves = cToken.totalReserves();\n\n        uint256 reserverFactor = cToken.reserveFactorMantissa();\n\n        InterestRateModel model = cToken.interestRateModel();\n\n        //the supply rate is derived from the borrow rate, reserve factor and the amount of total borrows.\n        uint256 supplyRate = model.getSupplyRate(cashPrior.add(amount), borrows, reserves, reserverFactor);\n\n        return supplyRate.mul(blocksPerYear);\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](3);\n        protected[0] = address(want);\n        protected[1] = address(cToken);\n        protected[2] = comp;\n        return protected;\n    }\n}"
    },
    {
      "filename": "contracts/GenericLender/GenericCream.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces/Compound/CErc20I.sol\";\nimport \"../Interfaces/Compound/InterestRateModel.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for any erc20 asset on Cream (not eth)\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericLender/GenericCream.sol\n *\n ********************* */\n\ncontract GenericCream is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant blocksPerYear = 2_300_000;\n\n    CErc20I public cToken;\n\n    constructor(\n        address _strategy,\n        string memory name,\n        address _cToken\n    ) public GenericLenderBase(_strategy, name) {\n        cToken = CErc20I(_cToken);\n\n        require(cToken.underlying() == address(want), \"WRONG CTOKEN\");\n\n        want.approve(_cToken, uint256(-1));\n    }\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)).add(underlyingBalanceStored());\n    }\n\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        uint256 currentCr = cToken.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            balance = currentCr.mul(cToken.exchangeRateStored()).div(1e18);\n        }\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    function _apr() internal view returns (uint256) {\n        return cToken.supplyRatePerBlock().mul(blocksPerYear);\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        cToken.redeemUnderlying(amount);\n\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //withdraw an amount including any want balance\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = cToken.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying.add(looseBalance);\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(cToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount.sub(looseBalance);\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                cToken.redeemUnderlying(toWithdraw);\n            } else {\n                //take all we can\n                cToken.redeemUnderlying(liquidity);\n            }\n        }\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    function deposit() external override management {\n        uint256 balance = want.balanceOf(address(this));\n        cToken.mint(balance);\n    }\n\n    function withdrawAll() external override management returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    //think about this\n    function enabled() external view override returns (bool) {\n        return true;\n    }\n\n    function hasAssets() external view override returns (bool) {\n        return cToken.balanceOf(address(this)) > 0;\n    }\n\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        uint256 cashPrior = want.balanceOf(address(cToken));\n\n        uint256 borrows = cToken.totalBorrows();\n        uint256 reserves = cToken.totalReserves();\n\n        uint256 reserverFactor = cToken.reserveFactorMantissa();\n        InterestRateModel model = cToken.interestRateModel();\n\n        //the supply rate is derived from the borrow rate, reserve factor and the amount of total borrows.\n        uint256 supplyRate = model.getSupplyRate(cashPrior.add(amount), borrows, reserves, reserverFactor);\n\n        return supplyRate.mul(blocksPerYear);\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](2);\n        protected[0] = address(want);\n        protected[1] = address(cToken);\n        return protected;\n    }\n}"
    },
    {
      "filename": "contracts/GenericLender/GenericCompound.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces/Compound/CErc20I.sol\";\nimport \"../Interfaces/Compound/InterestRateModel.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../Interfaces/UniswapInterfaces/IUniswapV2Router02.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for any erc20 asset on compound (not eth)\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericDyDx/GenericCompound.sol\n *\n ********************* */\n\ncontract GenericCompound is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant blocksPerYear = 2_300_000;\n    address public constant uniswapRouter = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address public constant comp = address(0xc00e94Cb662C3520282E6f5717214004A7f26888);\n    address public constant weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    uint256 public minCompToSell = 0.5 ether;\n\n    CErc20I public cToken;\n\n    constructor(\n        address _strategy,\n        string memory name,\n        address _cToken\n    ) public GenericLenderBase(_strategy, name) {\n        cToken = CErc20I(_cToken);\n\n        require(cToken.underlying() == address(want), \"WRONG CTOKEN\");\n\n        want.approve(_cToken, uint256(-1));\n    }\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)).add(underlyingBalanceStored());\n    }\n\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        uint256 currentCr = cToken.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            balance = currentCr.mul(cToken.exchangeRateStored()).div(1e18);\n        }\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    function _apr() internal view returns (uint256) {\n        return cToken.supplyRatePerBlock().mul(blocksPerYear);\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        cToken.redeemUnderlying(amount);\n\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //withdraw an amount including any want balance\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = cToken.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying.add(looseBalance);\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(cToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount.sub(looseBalance);\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                cToken.redeemUnderlying(toWithdraw);\n            } else {\n                //take all we can\n                cToken.redeemUnderlying(liquidity);\n            }\n        }\n        _disposeOfComp();\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    function _disposeOfComp() internal {\n        uint256 _comp = IERC20(comp).balanceOf(address(this));\n\n        if (_comp > minCompToSell) {\n            address[] memory path = new address[](3);\n            path[0] = comp;\n            path[1] = weth;\n            path[2] = address(want);\n\n            IUniswapV2Router02(uniswapRouter).swapExactTokensForTokens(_comp, uint256(0), path, address(this), now);\n        }\n    }\n\n    function deposit() external override management {\n        uint256 balance = want.balanceOf(address(this));\n        cToken.mint(balance);\n    }\n\n    function withdrawAll() external override management returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    //think about this\n    function enabled() external view override returns (bool) {\n        return true;\n    }\n\n    function hasAssets() external view override returns (bool) {\n        //return cToken.balanceOf(address(this)) > 0;\n        return cToken.balanceOf(address(this)) > 0 || want.balanceOf(address(this)) > 0;\n    }\n\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        uint256 cashPrior = want.balanceOf(address(cToken));\n\n        uint256 borrows = cToken.totalBorrows();\n\n        uint256 reserves = cToken.totalReserves();\n\n        uint256 reserverFactor = cToken.reserveFactorMantissa();\n\n        InterestRateModel model = cToken.interestRateModel();\n\n        //the supply rate is derived from the borrow rate, reserve factor and the amount of total borrows.\n        uint256 supplyRate = model.getSupplyRate(cashPrior.add(amount), borrows, reserves, reserverFactor);\n\n        return supplyRate.mul(blocksPerYear);\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](3);\n        protected[0] = address(want);\n        protected[1] = address(cToken);\n        protected[2] = comp;\n        return protected;\n    }\n}"
    },
    {
      "filename": "contracts/GenericLender/GenericCompound.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces/Compound/CErc20I.sol\";\nimport \"../Interfaces/Compound/InterestRateModel.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../Interfaces/UniswapInterfaces/IUniswapV2Router02.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for any erc20 asset on compound (not eth)\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericDyDx/GenericCompound.sol\n *\n ********************* */\n\ncontract GenericCompound is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant blocksPerYear = 2_300_000;\n    address public constant uniswapRouter = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address public constant comp = address(0xc00e94Cb662C3520282E6f5717214004A7f26888);\n    address public constant weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    uint256 public minCompToSell = 0.5 ether;\n\n    CErc20I public cToken;\n\n    constructor(\n        address _strategy,\n        string memory name,\n        address _cToken\n    ) public GenericLenderBase(_strategy, name) {\n        cToken = CErc20I(_cToken);\n\n        require(cToken.underlying() == address(want), \"WRONG CTOKEN\");\n\n        want.approve(_cToken, uint256(-1));\n    }\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)).add(underlyingBalanceStored());\n    }\n\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        uint256 currentCr = cToken.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            balance = currentCr.mul(cToken.exchangeRateStored()).div(1e18);\n        }\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    function _apr() internal view returns (uint256) {\n        return cToken.supplyRatePerBlock().mul(blocksPerYear);\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        cToken.redeemUnderlying(amount);\n\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //withdraw an amount including any want balance\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = cToken.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying.add(looseBalance);\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(cToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount.sub(looseBalance);\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                cToken.redeemUnderlying(toWithdraw);\n            } else {\n                //take all we can\n                cToken.redeemUnderlying(liquidity);\n            }\n        }\n        _disposeOfComp();\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    function _disposeOfComp() internal {\n        uint256 _comp = IERC20(comp).balanceOf(address(this));\n\n        if (_comp > minCompToSell) {\n            address[] memory path = new address[](3);\n            path[0] = comp;\n            path[1] = weth;\n            path[2] = address(want);\n\n            IUniswapV2Router02(uniswapRouter).swapExactTokensForTokens(_comp, uint256(0), path, address(this), now);\n        }\n    }\n\n    function deposit() external override management {\n        uint256 balance = want.balanceOf(address(this));\n        cToken.mint(balance);\n    }\n\n    function withdrawAll() external override management returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    //think about this\n    function enabled() external view override returns (bool) {\n        return true;\n    }\n\n    function hasAssets() external view override returns (bool) {\n        //return cToken.balanceOf(address(this)) > 0;\n        return cToken.balanceOf(address(this)) > 0 || want.balanceOf(address(this)) > 0;\n    }\n\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        uint256 cashPrior = want.balanceOf(address(cToken));\n\n        uint256 borrows = cToken.totalBorrows();\n\n        uint256 reserves = cToken.totalReserves();\n\n        uint256 reserverFactor = cToken.reserveFactorMantissa();\n\n        InterestRateModel model = cToken.interestRateModel();\n\n        //the supply rate is derived from the borrow rate, reserve factor and the amount of total borrows.\n        uint256 supplyRate = model.getSupplyRate(cashPrior.add(amount), borrows, reserves, reserverFactor);\n\n        return supplyRate.mul(blocksPerYear);\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](3);\n        protected[0] = address(want);\n        protected[1] = address(cToken);\n        protected[2] = comp;\n        return protected;\n    }\n}"
    },
    {
      "filename": "contracts/GenericLender/GenericCompound.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces/Compound/CErc20I.sol\";\nimport \"../Interfaces/Compound/InterestRateModel.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../Interfaces/UniswapInterfaces/IUniswapV2Router02.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for any erc20 asset on compound (not eth)\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericDyDx/GenericCompound.sol\n *\n ********************* */\n\ncontract GenericCompound is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant blocksPerYear = 2_300_000;\n    address public constant uniswapRouter = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address public constant comp = address(0xc00e94Cb662C3520282E6f5717214004A7f26888);\n    address public constant weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    uint256 public minCompToSell = 0.5 ether;\n\n    CErc20I public cToken;\n\n    constructor(\n        address _strategy,\n        string memory name,\n        address _cToken\n    ) public GenericLenderBase(_strategy, name) {\n        cToken = CErc20I(_cToken);\n\n        require(cToken.underlying() == address(want), \"WRONG CTOKEN\");\n\n        want.approve(_cToken, uint256(-1));\n    }\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)).add(underlyingBalanceStored());\n    }\n\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        uint256 currentCr = cToken.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            balance = currentCr.mul(cToken.exchangeRateStored()).div(1e18);\n        }\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    function _apr() internal view returns (uint256) {\n        return cToken.supplyRatePerBlock().mul(blocksPerYear);\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        cToken.redeemUnderlying(amount);\n\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //withdraw an amount including any want balance\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = cToken.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying.add(looseBalance);\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(cToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount.sub(looseBalance);\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                cToken.redeemUnderlying(toWithdraw);\n            } else {\n                //take all we can\n                cToken.redeemUnderlying(liquidity);\n            }\n        }\n        _disposeOfComp();\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    function _disposeOfComp() internal {\n        uint256 _comp = IERC20(comp).balanceOf(address(this));\n\n        if (_comp > minCompToSell) {\n            address[] memory path = new address[](3);\n            path[0] = comp;\n            path[1] = weth;\n            path[2] = address(want);\n\n            IUniswapV2Router02(uniswapRouter).swapExactTokensForTokens(_comp, uint256(0), path, address(this), now);\n        }\n    }\n\n    function deposit() external override management {\n        uint256 balance = want.balanceOf(address(this));\n        cToken.mint(balance);\n    }\n\n    function withdrawAll() external override management returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    //think about this\n    function enabled() external view override returns (bool) {\n        return true;\n    }\n\n    function hasAssets() external view override returns (bool) {\n        //return cToken.balanceOf(address(this)) > 0;\n        return cToken.balanceOf(address(this)) > 0 || want.balanceOf(address(this)) > 0;\n    }\n\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        uint256 cashPrior = want.balanceOf(address(cToken));\n\n        uint256 borrows = cToken.totalBorrows();\n\n        uint256 reserves = cToken.totalReserves();\n\n        uint256 reserverFactor = cToken.reserveFactorMantissa();\n\n        InterestRateModel model = cToken.interestRateModel();\n\n        //the supply rate is derived from the borrow rate, reserve factor and the amount of total borrows.\n        uint256 supplyRate = model.getSupplyRate(cashPrior.add(amount), borrows, reserves, reserverFactor);\n\n        return supplyRate.mul(blocksPerYear);\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](3);\n        protected[0] = address(want);\n        protected[1] = address(cToken);\n        protected[2] = comp;\n        return protected;\n    }\n}"
    },
    {
      "filename": "contracts/GenericLender/GenericCream.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces/Compound/CErc20I.sol\";\nimport \"../Interfaces/Compound/InterestRateModel.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for any erc20 asset on Cream (not eth)\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericLender/GenericCream.sol\n *\n ********************* */\n\ncontract GenericCream is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant blocksPerYear = 2_300_000;\n\n    CErc20I public cToken;\n\n    constructor(\n        address _strategy,\n        string memory name,\n        address _cToken\n    ) public GenericLenderBase(_strategy, name) {\n        cToken = CErc20I(_cToken);\n\n        require(cToken.underlying() == address(want), \"WRONG CTOKEN\");\n\n        want.approve(_cToken, uint256(-1));\n    }\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)).add(underlyingBalanceStored());\n    }\n\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        uint256 currentCr = cToken.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            balance = currentCr.mul(cToken.exchangeRateStored()).div(1e18);\n        }\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    function _apr() internal view returns (uint256) {\n        return cToken.supplyRatePerBlock().mul(blocksPerYear);\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        cToken.redeemUnderlying(amount);\n\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //withdraw an amount i"
    }
  ]
}