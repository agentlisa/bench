{
  "Title": "[07] Consistent usage of require vs custom error",
  "Content": "\nConsider using the same approach throughout the codebase to improve the consistency of the code.\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/VToken.sol#L396\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/VToken.sol#L489-L490\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-venus",
  "Code": [
    {
      "filename": "contracts/VToken.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./VTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./ExponentialNoError.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport \"./RiskFund/IProtocolShareReserve.sol\";\n\n/**\n * @title Venus VToken Contract\n * @author Venus Dev Team\n */\ncontract VToken is\n    Ownable2StepUpgradeable,\n    AccessControlledV8,\n    VTokenInterface,\n    ExponentialNoError,\n    TokenErrorReporter\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\n        // to set the state variables.\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     * @param riskManagement Addresses of risk fund contracts\n     */\n    function initialize(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        uint256 initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address admin_,\n        address accessControlManager_,\n        RiskManagementInit memory riskManagement,\n        uint256 reserveFactorMantissa_\n    ) external initializer {\n        require(admin_ != address(0), \"invalid admin address\");\n\n        // Initialize the market\n        _initialize(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_,\n            accessControlManager_,\n            riskManagement,\n            reserveFactorMantissa_\n        );\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return success True if the transfer suceeded, reverts otherwise\n     * @custom:event Emits Transfer event on success\n     * @custom:error TransferNotAllowed is thrown if trying to transfer to self\n     * @custom:access Not restricted\n     */\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        _transferTokens(msg.sender, msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return success True if the transfer suceeded, reverts otherwise\n     * @custom:event Emits Transfer event on success\n     * @custom:error TransferNotAllowed is thrown if trying to transfer to self\n     * @custom:access Not restricted\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external override nonReentrant returns (bool) {\n        _transferTokens(msg.sender, src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (uint256.max means infinite)\n     * @return success Whether or not the approval succeeded\n     * @custom:event Emits Approval event\n     * @custom:access Not restricted\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        require(spender != address(0), \"invalid spender address\");\n\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return amount The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint256) {\n        Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return totalBorrows The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override nonReentrant returns (uint256) {\n        accrueInterest();\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return borrowBalance The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        return _borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits Mint and Transfer events; may emit AccrueInterest\n     * @custom:access Not restricted\n     */\n    function mint(uint256 mintAmount) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // _mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        _mintFresh(msg.sender, msg.sender, mintAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender calls on-behalf of minter. minter supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits Mint and Transfer events; may emit AccrueInterest\n     * @custom:access Not restricted\n     */\n    function mintBehalf(address minter, uint256 mintAmount) external override nonReentrant returns (uint256) {\n        require(minter != address(0), \"invalid minter address\");\n\n        accrueInterest();\n        // _mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        _mintFresh(msg.sender, minter, mintAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits Redeem and Transfer events; may emit AccrueInterest\n     * @custom:error RedeemTransferOutNotPossible is thrown when the protocol has insufficient cash\n     * @custom:access Not restricted\n     */\n    function redeem(uint256 redeemTokens) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // _redeemFresh emits redeem-specific logs on errors, so we don't need to\n        _redeemFresh(msg.sender, redeemTokens, 0);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming vTokens\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     */\n    function redeemUnderlying(uint256 redeemAmount) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // _redeemFresh emits redeem-specific logs on errors, so we don't need to\n        _redeemFresh(msg.sender, 0, redeemAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits Borrow event; may emit AccrueInterest\n     * @custom:error BorrowCashNotAvailable is thrown when the protocol has insufficient cash\n     * @custom:access Not restricted\n     */\n    function borrow(uint256 borrowAmount) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        _borrowFresh(msg.sender, borrowAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits RepayBorrow event; may emit AccrueInterest\n     * @custom:access Not restricted\n     */\n    function repayBorrow(uint256 repayAmount) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // _repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        _repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits RepayBorrow event; may emit AccrueInterest\n     * @custom:access Not restricted\n     */\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // _repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        _repayBorrowFresh(msg.sender, borrower, repayAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits LiquidateBorrow event; may emit AccrueInterest\n     * @custom:error LiquidateAccrueCollateralInterestFailed is thrown when it is not possible to accrue interest on the collateral vToken\n     * @custom:error LiquidateCollateralFreshnessCheck is thrown when interest has not been accrued on the collateral vToken\n     * @custom:error LiquidateLiquidatorIsBorrower is thrown when trying to liquidate self\n     * @custom:error LiquidateCloseAmountIsZero is thrown when repayment amount is zero\n     * @custom:error LiquidateCloseAmountIsUintMax is thrown when repayment amount is UINT_MAX\n     * @custom:access Not restricted\n     */\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external override returns (uint256) {\n        _liquidateBorrow(msg.sender, borrower, repayAmount, vTokenCollateral, false);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice sets protocol share accumulated from liquidations\n     * @dev must be less than liquidation incentive - 1\n     * @param newProtocolSeizeShareMantissa_ new protocol share mantissa\n     * @custom:event Emits NewProtocolSeizeShare event on success\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\n     * @custom:error ProtocolSeizeShareTooBig is thrown when the new seize share is too high\n     * @custom:access Controlled by AccessControlManager\n     */\n    function setProtocolSeizeShare(uint256 newProtocolSeizeShareMantissa_) external {\n        _checkAccessAllowed(\"setProtocolSeizeShare(uint256)\");\n        uint256 liquidationIncentive = ComptrollerViewInterface(address(comptroller)).liquidationIncentiveMantissa();\n        if (newProtocolSeizeShareMantissa_ + 1e18 > liquidationIncentive) {\n            revert ProtocolSeizeShareTooBig();\n        }\n\n        uint256 oldProtocolSeizeShareMantissa = protocolSeizeShareMantissa;\n        protocolSeizeShareMantissa = newProtocolSeizeShareMantissa_;\n        emit NewProtocolSeizeShare(oldProtocolSeizeShareMantissa, newProtocolSeizeShareMantissa_);\n    }\n\n    /**\n     * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n     * @dev Admin function to accrue interest and set a new reserve factor\n     * @custom:event Emits NewReserveFactor event; may emit AccrueInterest\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\n     * @custom:error SetReserveFactorBoundsCheck is thrown when the new reserve factor is too high\n     * @custom:access Controlled by AccessControlManager\n     */\n    function setReserveFactor(uint256 newReserveFactorMantissa) external override nonReentrant {\n        _checkAccessAllowed(\"setReserveFactor(uint256)\");\n\n        accrueInterest();\n        _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to the protocol reserve contract\n     * @param reduceAmount Amount of reduction to reserves\n     * @custom:event Emits ReservesReduced event; may emit AccrueInterest\n     * @custom:error ReduceReservesCashNotAvailable is thrown when the vToken does not have sufficient cash\n     * @custom:error ReduceReservesCashValidation is thrown when trying to withdraw more cash than the reserves have\n     * @custom:access Not restricted\n     */\n    function reduceReserves(uint256 reduceAmount) external override nonReentrant {\n        accrueInterest();\n        _reduceReservesFresh(reduceAmount);\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @custom:event Emits ReservesAdded event; may emit AccrueInterest\n     * @custom:access Not restricted\n     */\n    function addReserves(uint256 addAmount) external override nonReentrant {\n        accrueInterest();\n        _addReservesFresh(addAmount);\n    }\n\n    /**\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @custom:event Emits NewMarketInterestRateModel event; may emit AccrueInterest\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\n     * @custom:access Controlled by AccessControlManager\n     */\n    function setInterestRateModel(InterestRateModel newInterestRateModel) external override {\n        _checkAccessAllowed(\"setInterestRateModel(address)\");\n\n        accrueInterest();\n        _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    /**\n     * @notice Repays a certain amount of debt, treats the rest of the borrow as bad debt, essentially\n     *   \"forgiving\" the borrower. Healing is a situation that should rarely happen. However, some pools\n     *   may list risky assets or be configured improperly â€“ we want to still handle such cases gracefully.\n     *   We assume that Comptroller does the seizing, so this function is only available to Comptroller.\n     * @dev This function does not call any Comptroller hooks (like \"healAllowed\"), because we assume\n     *   the Comptroller does all the necessary checks before calling this function.\n     * @param payer account who repays the debt\n     * @param borrower account to heal\n     * @param repayAmount amount to repay\n     * @custom:event Emits RepayBorrow, BadDebtIncreased events; may emit AccrueInterest\n     * @custom:error HealBorrowUnauthorized is thrown when the request does not come from Comptroller\n     * @custom:access Only Comptroller\n     */\n    function healBorrow(\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external override nonReentrant {\n        if (msg.sender != address(comptroller)) {\n            revert HealBorrowUnauthorized();\n        }\n\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\n        uint256 totalBorrowsNew = totalBorrows;\n\n        uint256 actualRepayAmount;\n        if (repayAmount != 0) {\n            // _doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n            // We violate checks-effects-interactions here to account for tokens that take transfer fees\n            actualRepayAmount = _doTransferIn(payer, repayAmount);\n            totalBorrowsNew = totalBorrowsNew - actualRepayAmount;\n            emit RepayBorrow(payer, borrower, actualRepayAmount, 0, totalBorrowsNew);\n        }\n\n        // The transaction will fail if trying to repay too much\n        uint256 badDebtDelta = accountBorrowsPrev - actualRepayAmount;\n        if (badDebtDelta != 0) {\n            uint256 badDebtOld = badDebt;\n            uint256 badDebtNew = badDebtOld + badDebtDelta;\n            totalBorrowsNew = totalBorrowsNew - badDebtDelta;\n            badDebt = badDebtNew;\n\n            // We treat healing as \"repayment\", where vToken is the payer\n            emit RepayBorrow(address(this), borrower, badDebtDelta, accountBorrowsPrev - badDebtDelta, totalBorrowsNew);\n            emit BadDebtIncreased(borrower, badDebtDelta, badDebtOld, badDebtNew);\n        }\n\n        accountBorrows[borrower].principal = 0;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n\n        emit HealBorrow(payer, borrower, repayAmount);\n    }\n\n    /**\n     * @notice The extended version of liquidations, callable only by Comptroller. May skip\n     *  the close factor check. The collateral seized is transferred to the liquidator.\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param skipLiquidityCheck If set to true, allows to liquidate up to 100% of the borrow\n     *   regardless of the account liquidity\n     * @custom:event Emits LiquidateBorrow event; may emit AccrueInterest\n     * @custom:error ForceLiquidateBorrowUnauthorized is thrown when the request does not come from Comptroller\n     * @custom:error LiquidateAccrueCollateralInterestFailed is thrown when it is not possible to accrue interest on the collateral vToken\n     * @custom:error LiquidateCollateralFreshnessCheck is thrown when interest has not been accrued on the collateral vToken\n     * @custom:error LiquidateLiquidatorIsBorrower is thrown when trying to liquidate self\n     * @custom:error LiquidateCloseAmountIsZero is thrown when repayment amount is zero\n     * @custom:error LiquidateCloseAmountIsUintMax is thrown when repayment amount is UINT_MAX\n     * @custom:access Only Comptroller\n     */\n    function forceLiquidateBorrow(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        VTokenInterface vTokenCollateral,\n        bool skipLiquidityCheck\n    ) external override {\n        if (msg.sender != address(comptroller)) {\n            revert ForceLiquidateBorrowUnauthorized();\n        }\n        _liquidateBorrow(liquidator, borrower, repayAmount, vTokenCollateral, skipLiquidityCheck);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another vToken during the process of liquidation.\n     *  It's absolutely critical to use msg.sender as the borrowed vToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of vTokens to seize\n     * @custom:event Emits Transfer, ReservesAdded events\n     * @custom:error LiquidateSeizeLiquidatorIsBorrower is thrown when trying to liquidate self\n     * @custom:access Not restricted\n     */\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external override nonReentrant {\n        _seize(msg.sender, liquidator, borrower, seizeTokens);\n    }\n\n    /**\n     * @notice Updates bad debt\n     * @dev Called only when bad debt is recovered from auction\n     * @param recoveredAmount_ The amount of bad debt recovered\n     * @custom:event Emits BadDebtRecovered event\n     * @custom:access Only Shortfall contract\n     */\n    function badDebtRecovered(uint256 recoveredAmount_) external {\n        require(msg.sender == shortfall, \"only shortfall contract can update bad debt\");\n        require(recoveredAmount_ <= badDebt, \"more than bad debt recovered from auction\");\n\n        uint256 badDebtOld = badDebt;\n        uint256 badDebtNew = badDebtOld - recoveredAmount_;\n        badDebt = badDebtNew;\n\n        emit BadDebtRecovered(badDebtOld, badDebtNew);\n    }\n\n    /**\n     * @notice Sets protocol share reserve contract address\n     * @param protocolShareReserve_ The address of the protocol share reserve contract\n     * @custom:error ZeroAddressNotAllowed is thrown when protocol share reserve address is zero\n     * @custom:access Only Governance\n     */\n    function setProtocolShareReserve(address payable protocolShareReserve_) external onlyOwner {\n        _setProtocolShareReserve(protocolShareReserve_);\n    }\n\n    /**\n     * @notice Sets shortfall contract address\n     * @param shortfall_ The address of the shortfall contract\n     * @custom:error ZeroAddressNotAllowed is thrown when shortfall contract address is zero\n     * @custom:access Only Governance\n     */\n    function setShortfallContract(address shortfall_) external onlyOwner {\n        _setShortfallContract(shortfall_);\n    }\n\n    /**\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\n     * @param token The address of the ERC-20 token to sweep\n     * @custom:access Only Governance\n     */\n    function sweepToken(IERC20Upgradeable token) external override {\n        require(msg.sender == owner(), \"VToken::sweepToken: only admin can sweep tokens\");\n        require(address(token) != underlying, \"VToken::sweepToken: can not sweep underlying token\");\n        uint256 balance = token.balanceOf(address(this));\n        token.safeTransfer(owner(), balance);\n\n        emit SweepToken(address(token));\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return amount The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return amount The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view override returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @return vTokenBalance User's balance of vTokens\n     * @return borrowBalance Amount owed in terms of underlying\n     * @return exchangeRate Stored exchange rate\n     */\n    function getAccountSnapshot(address account)\n        external\n        view\n        override\n        returns (\n            uint256 error,\n            uint256 vTokenBalance,\n            uint256 borrowBalance,\n            uint256 exchangeRate\n        )\n    {\n        return (NO_ERROR, accountTokens[account], _borrowBalanceStored(account), _exchangeRateStored());\n    }\n\n    /**\n     * @notice Get cash balance of this vToken in the underlying asset\n     * @return cash The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view override returns (uint256) {\n        return _getCashPrior();\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this vToken\n     * @return rate The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view override returns (uint256) {\n        return interestRateModel.getBorrowRate(_getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this v\n     * @return rate The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view override returns (uint256) {\n        return interestRateModel.getSupplyRate(_getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return borrowBalance The calculated balance\n     */\n    function borrowBalanceStored(address account) external view override returns (uint256) {\n        return _borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the VToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return exchangeRate Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() external view override returns (uint256) {\n        return _exchangeRateStored();\n    }\n\n    /**\n     * @notice Increase approval for `spender`\n     * @param spender The address of the account which may transfer tokens\n     * @param addedValue The number of tokens additional tokens spender can transfer\n     * @return success Whether or not the approval succeeded\n     * @custom:event Emits Approval event\n     * @custom:access Not restricted\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0), \"invalid spender address\");\n\n        address src = msg.sender;\n        uint256 newAllowance = transferAllowances[src][spender];\n        newAllowance += addedValue;\n        transferAllowances[src][spender] = newAllowance;\n\n        emit Approval(src, spender, newAllowance);\n        return true;\n    }\n\n    /**\n     * @notice Decreases approval for `spender`\n     * @param spender The address of the account which may transfer tokens\n     * @param subtractedValue The number of tokens tokens to remove from total approval\n     * @return success Whether or not the approval succeeded\n     * @custom:event Emits Approval event\n     * @custom:access Not restricted\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        require(spender != address(0), \"invalid spender address\");\n\n        address src = msg.sender;\n        uint256 currentAllowance = transferAllowances[src][spender];\n        require(currentAllowance >= subtractedValue, \"decreased allowance below zero\");\n        unchecked {\n            currentAllowance -= subtractedValue;\n        }\n\n        transferAllowances[src][spender] = currentAllowance;\n\n        emit Approval(src, spender, currentAllowance);\n        return true;\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return exchangeRate Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override nonReentrant returns (uint256) {\n        accrueInterest();\n        return _exchangeRateStored();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     * @return Always NO_ERROR\n     * @custom:event Emits AccrueInterest event on success\n     * @custom:access Not restricted\n     */\n    function accrueInterest() public virtual override returns (uint256) {\n        /* Remember the initial block number */\n        uint256 currentBlockNumber = _getBlockNumber();\n        uint256 accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return NO_ERROR;\n        }\n\n        /* Read the previous values out of storage */\n        uint256 cashPrior = _getCashPrior();\n        uint256 borrowsPrior = totalBorrows;\n        uint256 reservesPrior = totalReserves;\n        uint256 borrowIndexPrior = borrowIndex;\n\n        /* Calculate the current borrow interest rate */\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumberPrior;\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor = mul_(Exp({ mantissa: borrowRateMantissa }), blockDelta);\n        uint256 interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\n        uint256 totalBorrowsNew = interestAccumulated + borrowsPrior;\n        uint256 totalReservesNew = mul_ScalarTruncateAddUInt(\n            Exp({ mantissa: reserveFactorMantissa }),\n            interestAccumulated,\n            reservesPrior\n        );\n        uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, t"
    }
  ]
}