{
  "Title": "[H-24] Incorrect formula used in function `Market.computeClosingFactor()`",
  "Content": "\nIncorrect amount of assets that will be liquidated\n\n### Proof of Concept\n\nFunction `BigBang._liquidateUser()` is used to liquidate an under-collateralization position in the market. This function calls `BigBang._updateBorrowAndCollateralShare()` to calculate the amount of `borrowPart` and `collateralShare` that will be removed from the user's position and update the storage.\n\nThe amount of `borrowPart` to be removed can be calculated using the function `Market.computeClosingFactor()`. This amount will then be converted to `borrowAmount`, which is the corresponding elastic amount, and be used to determine the amount of `collateralShare` that needs to be removed.\n\n*   [Link to function](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L790-L815)\n\nHowever, the returned value from `Market.computeClosingFactor()` is incorrect, which leads to the wrong update for the user's position.\n\nTo prove the statement above, let's denote:\n\n*   `x`: The elastic amount that will be removed to execute the liquidation.\n*   `userElastic` and `userElastic'`: The elastic amount corresponding to `userBorrowPart[user]` before and after the liquidation.\n*   `collateralShare` and `collateralShare'`: The value of `userCollateralShare[user]` before and after the liquidation.\n*   Following the implementation of [`yieldBox.toAmount()`](https://github.com/Tapioca-DAO/YieldBox/blob/f5ad271b2dcab8b643b7cf622c2d6a128e109999/contracts/YieldBoxRebase.sol#L41-L60) and [`yieldBox.toShare()`](https://github.com/Tapioca-DAO/YieldBox/blob/f5ad271b2dcab8b643b7cf622c2d6a128e109999/contracts/YieldBoxRebase.sol#L18-L38), in one transaction we can denote that:\n    *   `yieldBox.toAmount()`: A multiplication expression with a constant `C`.\n    *   `yieldBox.toShare()`: A division expression with constant `C`.\n\nFollowing the update of these variables depicted in the function `BigBang._updateBorrowAndCollateralShare()`, we have:\n\n*   $userElastic' = userElastic - x$\n*   $collateralShare' = collateralShare - \\frac{x \\times (1+liquidationMultiplier)&ast;\\frac{exchangeRate}{10^{18}}}{C}$\n\nAfter the liquidation, the function `Market._isSolvent(user)` must return true. In other words, at least the following [equation](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L414-L424) should hold:\n\n*   $C \\times (collateralShare' \\times \\frac{collateralRate}{10^5} \\times \\frac{10^{18}}{exchangeRate}) = userElastic'$\n\nSolving the equation, we get:\n\n1.  $C \\times (collateralShare' \\times \\frac{collateralRate}{10^5} \\times \\frac{10^{18}}{exchangeRate}) = userElastic'$\n2.  $C \\times collateralShare \\times \\frac{collateralRate}{10^5} \\times \\frac{10^{18}}{exchangeRate} - x \\times (1 + \\frac{liquidationMultiplier}{10^5}) \\times \\frac{collateralizationRate}{10^5} = userElastic - x$\n3.  $x = \\frac{userElastic - C \\times collateralShare \\times \\frac{collateralRate}{10^5} \\times \\frac{10^{18}}{exchangeRate}}{1 - (1 + \\frac{liquidationMultiplier}{10^5}) &ast; \\frac{collateralizationRate}{10^5}}$\n\nSo, the returned value of the function `Market.computeClosingFactor()` should be the corresponding base amount of `x` (`totalBorrow.toBase(x, false)`).\n\nComparing it to the current [implementation](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L256-L297) of `computeClosingFactor()`, we can see the issues are:\n\n*   The implementation uses the `borrowPart` in the numerator instead of the corresponding elastic amount of `borrowPart`.\n*   The multiplication with `borrowPartDecimals` and `collateralPartDecimals` doesn't make sense since these decimals can be different and may cause the numerator to underflow.\n\n### Recommended Mitigation Steps\n\nCorrect the formula of function `computeClosingFactor()` following the section \"Proof of Concept\".\n\n**[cryptotechmaker (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1145#issuecomment-1707775040)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/markets/bigBang/BigBang.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\nimport \"tapioca-periph/contracts/interfaces/IBigBang.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISendFrom.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISwapper.sol\";\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\n\nimport \"../Market.sol\";\n\n// solhint-disable max-line-length\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\n\n/// @title BigBang market\n/// @notice Adaptation of the Singularity contract\n/// @dev owner of the contract is Penrose\n///     - the borrow action performs a mint on USDO\n///     - the repay action performs a burn on USDO\n///     - interest rate is not fixed, but dynamic based on the main BigBang market, minDebtRate, maxDebtRate and debtRateAgainstEthMarket\n///         - BigBang markets can either be main or secondary markets; the main market is set on Penrose and has a fixed rate\n///         - BigBang secondary markets has a dynamic interest rate which is starts from `minDebtRate` to `maxDebtRate`\n///             - if current debt is over _maxDebtPoint = (_ethMarketTotalDebt * debtRateAgainstEthMarket) / 1e18, the interest rate is automatically `maxDebtRate`\n///         - simulation: https://dotnetfiddle.net/cuKVpf\ncontract BigBang is BoringOwnable, Market {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    mapping(address => mapping(address => bool)) public operators;\n\n    IBigBang.AccrueInfo public accrueInfo;\n\n    uint256 public totalFees;\n\n    bool private _isEthMarket;\n    uint256 public maxDebtRate;\n    uint256 public minDebtRate;\n    uint256 public debtRateAgainstEthMarket;\n    uint256 public debtStartPoint;\n    uint256 private constant DEBT_PRECISION = 1e18;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when accrue is called\n    event LogAccrue(uint256 accruedAmount, uint64 rate);\n    /// @notice event emitted when collateral is added\n    event LogAddCollateral(\n        address indexed from,\n        address indexed to,\n        uint256 share\n    );\n    /// @notice event emitted when collateral is removed\n    event LogRemoveCollateral(\n        address indexed from,\n        address indexed to,\n        uint256 share\n    );\n    /// @notice event emitted when borrow is performed\n    event LogBorrow(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        uint256 feeAmount,\n        uint256 part\n    );\n    /// @notice event emitted when a repay operation is performed\n    event LogRepay(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        uint256 part\n    );\n    /// @notice event emitted when the minimum debt rate is updated\n    event MinDebtRateUpdated(uint256 oldVal, uint256 newVal);\n    /// @notice event emitted when the maximum debt rate is updated\n    event MaxDebtRateUpdated(uint256 oldVal, uint256 newVal);\n    /// @notice event emitted when the debt rate against the main market is updated\n    event DebtRateAgainstEthUpdated(uint256 oldVal, uint256 newVal);\n\n    constructor() MarketERC20(\"Tapioca BigBang\") {}\n\n    /// @notice The init function that acts as a constructor\n    function init(bytes calldata data) external onlyOnce {\n        (\n            IPenrose tapiocaBar_,\n            IERC20 _collateral,\n            uint256 _collateralId,\n            IOracle _oracle,\n            uint256 _exchangeRatePrecision,\n            uint256 _debtRateAgainstEth,\n            uint256 _debtRateMin,\n            uint256 _debtRateMax,\n            uint256 _debtStartPoint\n        ) = abi.decode(\n                data,\n                (\n                    IPenrose,\n                    IERC20,\n                    uint256,\n                    IOracle,\n                    uint256,\n                    uint256,\n                    uint256,\n                    uint256,\n                    uint256\n                )\n            );\n\n        penrose = tapiocaBar_;\n        yieldBox = YieldBox(tapiocaBar_.yieldBox());\n        owner = address(penrose);\n\n        address _asset = penrose.usdoToken();\n\n        require(\n            address(_collateral) != address(0) &&\n                address(_asset) != address(0) &&\n                address(_oracle) != address(0),\n            \"BigBang: bad pair\"\n        );\n\n        asset = IERC20(_asset);\n        assetId = penrose.usdoAssetId();\n        collateral = _collateral;\n        collateralId = _collateralId;\n        oracle = _oracle;\n\n        updateExchangeRate();\n\n        callerFee = 90000; // 90%\n        protocolFee = 10000; // 10%\n        collateralizationRate = 75000; // 75%\n\n        EXCHANGE_RATE_PRECISION = _exchangeRatePrecision > 0\n            ? _exchangeRatePrecision\n            : 1e18;\n\n        _isEthMarket = collateralId == penrose.wethAssetId();\n        if (!_isEthMarket) {\n            debtRateAgainstEthMarket = _debtRateAgainstEth;\n            maxDebtRate = _debtRateMax;\n            minDebtRate = _debtRateMin;\n            debtStartPoint = _debtStartPoint;\n        }\n\n        minLiquidatorReward = 1e3;\n        maxLiquidatorReward = 1e4;\n        liquidationBonusAmount = 1e4;\n        borrowOpeningFee = 50; // 0.05%\n        liquidationMultiplier = 12000; //12%\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns total market debt\n    function getTotalDebt() external view returns (uint256) {\n        return totalBorrow.elastic;\n    }\n\n    /// @notice returns the current debt rate\n    function getDebtRate() public view returns (uint256) {\n        if (_isEthMarket) return penrose.bigBangEthDebtRate(); // default 0.5%\n        if (totalBorrow.elastic == 0) return minDebtRate;\n\n        uint256 _ethMarketTotalDebt = BigBang(penrose.bigBangEthMarket())\n            .getTotalDebt();\n        uint256 _currentDebt = totalBorrow.elastic;\n        uint256 _maxDebtPoint = (_ethMarketTotalDebt *\n            debtRateAgainstEthMarket) / 1e18;\n\n        if (_currentDebt >= _maxDebtPoint) return maxDebtRate;\n\n        uint256 debtPercentage = ((_currentDebt - debtStartPoint) *\n            DEBT_PRECISION) / (_maxDebtPoint - debtStartPoint);\n        uint256 debt = ((maxDebtRate - minDebtRate) * debtPercentage) /\n            DEBT_PRECISION +\n            minDebtRate;\n\n        if (debt > maxDebtRate) return maxDebtRate;\n\n        return debt;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Allows batched call to BingBang.\n    /// @param calls An array encoded call data.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    function execute(\n        bytes[] calldata calls,\n        bool revertOnFail\n    ) external returns (bool[] memory successes, string[] memory results) {\n        successes = new bool[](calls.length);\n        results = new string[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                calls[i]\n            );\n            require(success || !revertOnFail, _getRevertMsg(result));\n            successes[i] = success;\n            results[i] = _getRevertMsg(result);\n        }\n    }\n\n    /// @notice allows 'operator' to act on behalf of the sender\n    /// @param status true/false\n    function updateOperator(address operator, bool status) external {\n        operators[msg.sender][operator] = status;\n    }\n\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() public {\n        _accrue();\n    }\n\n    /// @notice Sender borrows `amount` and transfers it to `to`.\n    /// @param from Account to borrow for.\n    /// @param to The receiver of borrowed tokens.\n    /// @param amount Amount to borrow.\n    /// @return part Total part of the debt held by borrowers.\n    /// @return share Total amount in shares borrowed.\n    function borrow(\n        address from,\n        address to,\n        uint256 amount\n    ) public notPaused solvent(from) returns (uint256 part, uint256 share) {\n        uint256 allowanceShare = _computeAllowanceAmountInAsset(\n            from,\n            exchangeRate,\n            amount,\n            asset.safeDecimals()\n        );\n        _allowedBorrow(from, allowanceShare);\n        (part, share) = _borrow(from, to, amount);\n    }\n\n    /// @notice Repays a loan.\n    /// @dev The bool param is not used but we added it to respect the ISingularity interface for MarketsHelper compatibility\n    /// @param from Address to repay from.\n    /// @param to Address of the user this payment should go.\n    /// @param part The amount to repay. See `userBorrowPart`.\n    /// @return amount The total amount repayed.\n    function repay(\n        address from,\n        address to,\n        bool,\n        uint256 part\n    ) public notPaused allowedBorrow(from, part) returns (uint256 amount) {\n        updateExchangeRate();\n\n        accrue();\n\n        amount = _repay(from, to, part);\n    }\n\n    /// @notice Adds `collateral` from msg.sender to the account `to`.\n    /// @param from Account to transfer shares from.\n    /// @param to The receiver of the tokens.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param share The amount of shares to add for `to`.\n    function addCollateral(\n        address from,\n        address to,\n        bool skim,\n        uint256 amount,\n        uint256 share\n    ) public allowedBorrow(from, share) notPaused {\n        _addCollateral(from, to, skim, amount, share);\n    }\n\n    /// @notice Removes `share` amount of collateral and transfers it to `to`.\n    /// @param from Account to debit collateral from.\n    /// @param to The receiver of the shares.\n    /// @param share Amount of shares to remove.\n    function removeCollateral(\n        address from,\n        address to,\n        uint256 share\n    ) public notPaused solvent(from) allowedBorrow(from, share) {\n        _removeCollateral(from, to, share);\n    }\n\n    /// @notice Entry point for liquidations.\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\n    /// @param swapper Contract address of the `MultiSwapper` implementation. See `setSwapper`.\n    /// @param collateralToAssetSwapData Extra swap data\n    function liquidate(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        ISwapper swapper,\n        bytes calldata collateralToAssetSwapData\n    ) external notPaused {\n        // Oracle can fail but we still need to allow liquidations\n        (, uint256 _exchangeRate) = updateExchangeRate();\n        _accrue();\n\n        _closedLiquidation(\n            users,\n            maxBorrowParts,\n            swapper,\n            _exchangeRate,\n            collateralToAssetSwapData\n        );\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param minAmountOut Mininal collateral amount to receive\n    /// @param swapper Swapper to execute the purchase\n    /// @param dexData Additional data to pass to the swapper\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(\n        address from,\n        uint256 borrowAmount,\n        uint256 supplyAmount,\n        uint256 minAmountOut,\n        ISwapper swapper,\n        bytes calldata dexData\n    ) external notPaused solvent(from) returns (uint256 amountOut) {\n        require(penrose.swappers(swapper), \"SGL: Invalid swapper\");\n\n        // Let this fail first to save gas:\n        uint256 supplyShare = yieldBox.toShare(assetId, supplyAmount, true);\n        if (supplyShare > 0) {\n            yieldBox.transfer(from, address(swapper), assetId, supplyShare);\n        }\n\n        uint256 borrowShare;\n        (, borrowShare) = _borrow(from, address(swapper), borrowAmount);\n\n        ISwapper.SwapData memory swapData = swapper.buildSwapData(\n            assetId,\n            collateralId,\n            0,\n            supplyShare + borrowShare,\n            true,\n            true\n        );\n\n        uint256 collateralShare;\n        (amountOut, collateralShare) = swapper.swap(\n            swapData,\n            minAmountOut,\n            from,\n            dexData\n        );\n        require(amountOut >= minAmountOut, \"SGL: not enough\");\n\n        _allowedBorrow(from, collateralShare);\n        _addCollateral(from, from, false, 0, collateralShare);\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param minAmountOut Mininal proceeds required for the sale\n    /// @param swapper Swapper to execute the sale\n    /// @param dexData Additional data to pass to the swapper\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(\n        address from,\n        uint256 share,\n        uint256 minAmountOut,\n        ISwapper swapper,\n        bytes calldata dexData\n    ) external notPaused solvent(from) returns (uint256 amountOut) {\n        require(penrose.swappers(swapper), \"SGL: Invalid swapper\");\n\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(swapper), share);\n        ISwapper.SwapData memory swapData = swapper.buildSwapData(\n            collateralId,\n            assetId,\n            0,\n            share,\n            true,\n            true\n        );\n        uint256 shareOut;\n        (amountOut, shareOut) = swapper.swap(\n            swapData,\n            minAmountOut,\n            from,\n            dexData\n        );\n        // As long as the ratio is correct, we trust `amountOut` resp.\n        // `shareOut`, because all money received by the swapper gets used up\n        // one way or another, or the transaction will revert.\n        require(amountOut >= minAmountOut, \"SGL: not enough\");\n        uint256 partOwed = userBorrowPart[from];\n        uint256 amountOwed = totalBorrow.toElastic(partOwed, true);\n        uint256 shareOwed = yieldBox.toShare(assetId, amountOwed, true);\n        if (shareOwed <= shareOut) {\n            _repay(from, from, partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, partOut);\n        }\n    }\n\n    function transfer(\n        address to,\n        uint256 amount\n    ) public override returns (bool) {}\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override returns (bool) {}\n\n    // ************************* //\n    // *** OWNER FUNCTIONS ***** //\n    // ************************* //\n\n    /// @notice Transfers fees to penrose\n    function refreshPenroseFees(\n        address\n    ) external onlyOwner notPaused returns (uint256 feeShares) {\n        uint256 balance = asset.balanceOf(address(this));\n        totalFees += balance;\n        feeShares = yieldBox.toShare(assetId, totalFees, false);\n\n        if (totalFees > 0) {\n            asset.approve(address(yieldBox), totalFees);\n\n            yieldBox.depositAsset(\n                assetId,\n                address(this),\n                msg.sender,\n                totalFees,\n                0\n            );\n\n            totalFees = 0;\n        }\n    }\n\n    /// @notice sets BigBang specific configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    function setBigBangConfig(\n        uint256 _minDebtRate,\n        uint256 _maxDebtRate,\n        uint256 _debtRateAgainstEthMarket,\n        uint256 _liquidationMultiplier\n    ) external onlyOwner {\n        _isEthMarket = collateralId == penrose.wethAssetId();\n\n        if (!_isEthMarket) {\n            if (_minDebtRate > 0) {\n                require(_minDebtRate < maxDebtRate, \"BigBang: not valid\");\n                emit MinDebtRateUpdated(minDebtRate, _minDebtRate);\n                minDebtRate = _minDebtRate;\n            }\n\n            if (_maxDebtRate > 0) {\n                require(_maxDebtRate > minDebtRate, \"BigBang: not valid\");\n                emit MaxDebtRateUpdated(maxDebtRate, _maxDebtRate);\n                maxDebtRate = _maxDebtRate;\n            }\n\n            if (_debtRateAgainstEthMarket > 0) {\n                emit DebtRateAgainstEthUpdated(\n                    debtRateAgainstEthMarket,\n                    _debtRateAgainstEthMarket\n                );\n                debtRateAgainstEthMarket = _debtRateAgainstEthMarket;\n            }\n\n            if (_liquidationMultiplier > 0) {\n                require(\n                    _liquidationMultiplier < FEE_PRECISION,\n                    \"BigBang: not valid\"\n                );\n                emit LiquidationMultiplierUpdated(\n                    liquidationMultiplier,\n                    _liquidationMultiplier\n                );\n                liquidationMultiplier = _liquidationMultiplier;\n            }\n        }\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _accrue() internal override {\n        IBigBang.AccrueInfo memory _accrueInfo = accrueInfo;\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return;\n        }\n        //update debt rate\n        uint256 annumDebtRate = getDebtRate();\n        _accrueInfo.debtRate = uint64(annumDebtRate / 31536000); //per second\n\n        _accrueInfo.lastAccrued = uint64(block.timestamp);\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 extraAmount = 0;\n\n        // Calculate fees\n        extraAmount =\n            (uint256(_totalBorrow.elastic) *\n                _accrueInfo.debtRate *\n                elapsedTime) /\n            1e18;\n        _totalBorrow.elastic += uint128(extraAmount);\n\n        totalBorrow = _totalBorrow;\n        accrueInfo = _accrueInfo;\n\n        emit LogAccrue(extraAmount, _accrueInfo.debtRate);\n    }\n\n    function _addCollateral(\n        address from,\n        address to,\n        bool skim,\n        uint256 amount,\n        uint256 share\n    ) internal {\n        if (share == 0) {\n            share = yieldBox.toShare(collateralId, amount, false);\n        }\n        userCollateralShare[to] += share;\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        totalCollateralShare = oldTotalCollateralShare + share;\n        _addTokens(from, collateralId, share, oldTotalCollateralShare, skim);\n        emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n    }\n\n    function _liquidateUser(\n        address user,\n        uint256 maxBorrowPart,\n        ISwapper swapper,\n        uint256 _exchangeRate,\n        bytes calldata _dexData\n    ) private {\n        if (_isSolvent(user, _exchangeRate)) return;\n\n        (\n            uint256 startTVLInAsset,\n            uint256 maxTVLInAsset\n        ) = _computeMaxAndMinLTVInAsset(\n                userCollateralShare[user],\n                _exchangeRate\n            );\n        uint256 callerReward = _getCallerReward(\n            userBorrowPart[user],\n            startTVLInAsset,\n            maxTVLInAsset\n        );\n\n        (\n            uint256 borrowAmount,\n            uint256 borrowPart,\n            uint256 collateralShare\n        ) = _updateBorrowAndCollateralShare(user, maxBorrowPart, _exchangeRate);\n        emit LogRemoveCollateral(user, address(swapper), collateralShare);\n        emit LogRepay(address(swapper), user, borrowAmount, borrowPart);\n\n        uint256 borrowShare = yieldBox.toShare(assetId, borrowAmount, true);\n\n        // Closed liquidation using a pre-approved swapper\n        require(penrose.swappers(swapper), \"BigBang: Invalid swapper\");\n\n        // Swaps the users collateral for the borrowed asset\n        yieldBox.transfer(\n            address(this),\n            address(swapper),\n            collateralId,\n            collateralShare\n        );\n\n        uint256 minAssetMount = 0;\n        if (_dexData.length > 0) {\n            minAssetMount = abi.decode(_dexData, (uint256));\n        }\n\n        uint256 balanceBefore = yieldBox.balanceOf(address(this), assetId);\n\n        ISwapper.SwapData memory swapData = swapper.buildSwapData(\n            collateralId,\n            assetId,\n            0,\n            collateralShare,\n            true,\n            true\n        );\n        swapper.swap(swapData, minAssetMount, address(this), \"\");\n        uint256 balanceAfter = yieldBox.balanceOf(address(this), assetId);\n\n        uint256 returnedShare = balanceAfter - balanceBefore;\n        (uint256 feeShare, uint256 callerShare) = _extractLiquidationFees(\n            returnedShare,\n            borrowShare,\n            callerReward\n        );\n        address[] memory _users = new address[](1);\n        _users[0] = user;\n        emit Liquidated(\n            msg.sender,\n            _users,\n            callerShare,\n            feeShare,\n            borrowAmount,\n            collateralShare\n        );\n    }\n\n    function _extractLiquidationFees(\n        uint256 returnedShare,\n        uint256 borrowShare,\n        uint256 callerReward\n    ) private returns (uint256 feeShare, uint256 callerShare) {\n        uint256 extraShare = returnedShare - borrowShare;\n        feeShare = (extraShare * protocolFee) / FEE_PRECISION; // x% of profit goes to fee.\n        callerShare = (extraShare * callerReward) / FEE_PRECISION; //  y%  of profit goes to caller.\n\n        yieldBox.transfer(address(this), penrose.feeTo(), assetId, feeShare);\n        yieldBox.transfer(address(this), msg.sender, assetId, callerShare);\n    }\n\n    /// @notice Handles the liquidation of users' balances, once the users' amount of collateral is too low.\n    /// @dev Closed liquidations Only, 90% of extra shares goes to caller and 10% to protocol\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\n    /// @param swapper Contract address of the `MultiSwapper` implementation. See `setSwapper`.\n    /// @param swapData Swap necessar data\n    function _closedLiquidation(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        ISwapper swapper,\n        uint256 _exchangeRate,\n        bytes calldata swapData\n    ) private {\n        uint256 liquidatedCount = 0;\n        for (uint256 i = 0; i < users.length; i++) {\n            address user = users[i];\n            if (!_isSolvent(user, _exchangeRate)) {\n                liquidatedCount++;\n                _liquidateUser(\n                    user,\n                    maxBorrowParts[i],\n                    swapper,\n                    _exchangeRate,\n                    swapData\n                );\n            }\n        }\n\n        require(liquidatedCount > 0, \"SGL: no users found\");\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param from Account to debit tokens from, in `yieldBox`.\n    /// @param _tokenId The ERC-20 token asset ID in yieldBox.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    function _addTokens(\n        address from,\n        uint256 _tokenId,\n        uint256 share,\n        uint256 total,\n        bool skim\n    ) internal {\n        if (skim) {\n            require(\n                share <= yieldBox.balanceOf(address(this), _tokenId) - total,\n                \"BigBang: too much\"\n            );\n        } else {\n            yieldBox.transfer(from, address(this), _tokenId, share);\n        }\n    }\n\n    /// @dev Concrete implementation of `removeCollateral`.\n    function _removeCollateral(\n        address from,\n        address to,\n        uint256 share\n    ) internal {\n        userCollateralShare[from] -= share;\n        totalCollateralShare -= share;\n        emit LogRemoveCollateral(from, to, share);\n        yieldBox.transfer(address(this), to, collateralId, share);\n    }\n\n    /// @dev Concrete implementation of `repay`.\n    function _repay(\n        address from,\n        address to,\n        uint256 part\n    ) internal returns (uint256 amount) {\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\n\n        userBorrowPart[to] -= part;\n\n        uint256 toWithdraw = (amount - part); //acrrued\n        uint256 toBurn = amount - toWithdraw;\n        yieldBox.withdraw(assetId, from, address(this), amount, 0);\n        //burn USDO\n        if (toBurn > 0) {\n            IUSDOBase(address(asset)).burn(address(this), toBurn);\n        }\n\n        emit LogRepay(from, to, amount, part);\n    }\n\n    /// @dev Concrete implementation of `borrow`.\n    function _borrow(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256 part, uint256 share) {\n        uint256 feeAmount = (amount * borrowOpeningFee) / FEE_PRECISION; // A flat % fee is charged for any borrow\n\n        (totalBorrow, part) = totalBorrow.add(amount + feeAmount, true);\n        require(\n            totalBorrowCap == 0 || totalBorrow.elastic <= totalBorrowCap,\n            \"BigBang: borrow cap reached\"\n        );\n\n        userBorrowPart[from] += part;\n\n        //mint USDO\n        IUSDOBase(address(asset)).mint(address(this), amount);\n\n        //deposit borrowed amount to user\n        asset.approve(address(yieldBox), amount);\n        yieldBox.depositAsset(assetId, address(this), to, amount, 0);\n\n        share = yieldBox.toShare(assetId, amount, false);\n\n        emit LogBorrow(from, to, amount, feeAmount, part);\n    }\n\n    function _updateBorrowAndCollateralShare(\n        address user,\n        uint256 maxBorrowPart,\n        uint256 _exchangeRate\n    )\n        private\n        returns (\n            uint256 borrowAmount,\n            uint256 borrowPart,\n            uint256 collateralShare\n        )\n    {\n        uint256 collateralPartInAsset = (yieldBox.toAmount(\n            collateralId,\n            userCollateralShare[user],\n            false\n        ) * EXCHANGE_RATE_PRECISION) / _exchangeRate;\n\n        uint256 borrowAssetDecimals = asset.safeDecimals();\n        uint256 collateralDecimals = collateral.safeDecimals();\n\n        uint256 availableBorrowPart = computeClosingFactor(\n            userBorrowPart[user],\n            collateralPartInAsset,\n            borrowAssetDecimals,\n            collateralDecimals,\n            FEE_PRECISION_DECIMALS\n        );\n        borrowPart = maxBorrowPart > availableBorrowPart\n            ? availableBorrowPart\n            : maxBorrowPart;\n\n        if (borrowPart > userBorrowPart[user]) {\n            borrowPart = userBorrowPart[user];\n        }\n\n        userBorrowPart[user] = userBorrowPart[user] - borrowPart;\n\n        borrowAmount = totalBorrow.toElastic(borrowPart, false);\n        uint256 amountWithBonus = borrowAmount +\n            (borrowAmount * liquidationMultiplier) /\n            FEE_PRECISION;\n        collateralShare = yieldBox.toShare(\n            collateralId,\n            (amountWithBonus * _exchangeRate) / EXCHANGE_RATE_PRECISION,\n            false\n        );\n        if (collateralShare > userCollateralShare[user]) {\n            collateralShare = userCollateralShare[user];\n        }\n        userCollateralShare[user] -= collateralShare;\n        require(borrowAmount != 0, \"SGL: solvent\");\n\n        totalBorrow.elastic -= uint128(borrowAmount);\n        totalBorrow.base -= uint128(borrowPart);\n    }\n}"
    },
    {
      "filename": "contracts/YieldBoxRebase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\nimport \"./interfaces/IStrategy.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC1155.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/Base64.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringAddress.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/Domain.sol\";\nimport \"./ERC1155TokenReceiver.sol\";\nimport \"./ERC1155.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringBatchable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringFactory.sol\";\n\nlibrary YieldBoxRebase {\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function _toShares(\n        uint256 amount,\n        uint256 totalShares_,\n        uint256 totalAmount,\n        bool roundUp\n    ) internal pure returns (uint256 share) {\n        // To prevent reseting the ratio due to withdrawal of all shares, we start with\n        // 1 amount/1e8 shares already burned. This also starts with a 1 : 1e8 ratio which\n        // functions like 8 decimal fixed point math. This prevents ratio attacks or inaccuracy\n        // due to 'gifting' or rebasing tokens. (Up to a certain degree)\n        totalAmount++;\n        totalShares_ += 1e8;\n\n        // Calculte the shares using te current amount to share ratio\n        share = (amount * totalShares_) / totalAmount;\n\n        // Default is to round down (Solidity), round up if required\n        if (roundUp && (share * totalAmount) / totalShares_ < amount) {\n            share++;\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function _toAmount(\n        uint256 share,\n        uint256 totalShares_,\n        uint256 totalAmount,\n        bool roundUp\n    ) internal pure returns (uint256 amount) {\n        // To prevent reseting the ratio due to withdrawal of all shares, we start with\n        // 1 amount/1e8 shares already burned. This also starts with a 1 : 1e8 ratio which\n        // functions like 8 decimal fixed point math. This prevents ratio attacks or inaccuracy\n        // due to 'gifting' or rebasing tokens. (Up to a certain degree)\n        totalAmount++;\n        totalShares_ += 1e8;\n\n        // Calculte the amount using te current amount to share ratio\n        amount = (share * totalAmount) / totalShares_;\n\n        // Default is to round down (Solidity), round up if required\n        if (roundUp && (amount * totalShares_) / totalAmount < share) {\n            amount++;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/markets/Market.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\n\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/YieldBox.sol\";\nimport \"tapioca-periph/contracts/interfaces/IOracle.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPenrose.sol\";\nimport \"./MarketERC20.sol\";\n\n/// @title Market contract\n/// @notice Market contract implemented by Singularity & BigBang\nabstract contract Market is MarketERC20, BoringOwnable {\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS"
    }
  ]
}