{
  "Title": "[H01] Resolution upgrade inconsistency",
  "Content": "The OUSD token achieves its rebasing functionality by tracking credit balances and scaling them by a conversion factor to retrieve the corresponding OUSD token balances. The `OUSDResolutionUpgrade` contract is designed as a temporary logic contract that replaces the token functionality with mechanisms to increase the precision of the conversion factors. In particular, there is [a function](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/token/OUSDResolutionUpgrade.sol#L8) to update the global parameters and [a separate function](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/token/OUSDResolutionUpgrade.sol#L17) to upgrade the individual user accounts in batches.\n\n\nTo avoid upgrading the same account multiple times, [an upgrade flag is set](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/token/OUSDResolutionUpgrade.sol#L21) for each account. Similarly, [the upgrade flag is set](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/token/OUSDResolutionUpgrade.sol#L10) for the zero address to indicate that the global parameters have been updated. There is no access control on either of these functions. This means that an attacker can include the zero address in a batch of account upgrades, which will set its flag and prevent anyone from upgrading the global state. This could produce an inconsistent state where a subset of the accounts use the new resolution, while the global parameters remain unchanged.\n\n\nConsider restricting the `upgradeAccounts` function to non-zero account.\n\n\n**Update:** *Fixed in [commit 95e8c90](https://github.com/OriginProtocol/origin-dollar/commit/95e8c90afbe9103d14e2dfba875acce08f108d3c).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/token/OUSDResolutionUpgrade.sol",
      "content": "pragma solidity 0.5.11;\n\nimport { OUSDStorage } from \"./OUSDStorage.sol\";\n\ncontract OUSDResolutionUpgrade is OUSDStorage {\n    uint256 private constant RESOLUTION_INCREASE = 1e9;\n\n    function upgradeGlobals() external {\n        require(isUpgraded[address(0)] == 0);\n        isUpgraded[address(0)] = 1;\n        rebasingCredits = rebasingCredits.mul(RESOLUTION_INCREASE);\n        rebasingCreditsPerToken = rebasingCreditsPerToken.mul(\n            RESOLUTION_INCREASE\n        );\n    }\n\n    function upgradeAccounts(address[] calldata accounts) external {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            address account = accounts[i];\n            require(isUpgraded[account] == 0);\n            isUpgraded[account] = 1;\n\n            // Is the account non-rebasing\n            uint256 nrc = nonRebasingCreditsPerToken[account];\n            if (nrc > 1e19) {\n                // Account has already been created at high resolution\n                continue;\n            }\n\n            if (nrc > 0) {\n                nonRebasingCreditsPerToken[account] = nrc.mul(\n                    RESOLUTION_INCREASE\n                );\n            }\n            _creditBalances[account] = _creditBalances[account].mul(\n                RESOLUTION_INCREASE\n            );\n        }\n    }\n\n    // We have to fill the ERC20 interface in order to not be an abstract\n    // contract that cannot be deployed.\n\n    function totalSupply() external view returns (uint256) {\n        revert(\"OUSD: Upgrading\");\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        revert(\"OUSD: Upgrading\");\n    }\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool)\n    {\n        revert(\"OUSD: Upgrading\");\n    }\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256)\n    {\n        revert(\"OUSD: Upgrading\");\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        revert(\"OUSD: Upgrading\");\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        revert(\"OUSD: Upgrading\");\n    }\n}"
    },
    {
      "filename": "contracts/contracts/token/OUSDResolutionUpgrade.sol",
      "content": "pragma solidity 0.5.11;\n\nimport { OUSDStorage } from \"./OUSDStorage.sol\";\n\ncontract OUSDResolutionUpgrade is OUSDStorage {\n    uint256 private constant RESOLUTION_INCREASE = 1e9;\n\n    function upgradeGlobals() external {\n        require(isUpgraded[address(0)] == 0);\n        isUpgraded[address(0)] = 1;\n        rebasingCredits = rebasingCredits.mul(RESOLUTION_INCREASE);\n        rebasingCreditsPerToken = rebasingCreditsPerToken.mul(\n            RESOLUTION_INCREASE\n        );\n    }\n\n    function upgradeAccounts(address[] calldata accounts) external {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            address account = accounts[i];\n            require(isUpgraded[account] == 0);\n            isUpgraded[account] = 1;\n\n            // Is the account non-rebasing\n            uint256 nrc = nonRebasingCreditsPerToken[account];\n            if (nrc > 1e19) {\n                // Account has already been created at high resolution\n                continue;\n            }\n\n            if (nrc > 0) {\n                nonRebasingCreditsPerToken[account] = nrc.mul(\n                    RESOLUTION_INCREASE\n                );\n            }\n            _creditBalances[account] = _creditBalances[account].mul(\n                RESOLUTION_INCREASE\n            );\n        }\n    }\n\n    // We have to fill the ERC20 interface in order to not be an abstract\n    // contract that cannot be deployed.\n\n    function totalSupply() external view returns (uint256) {\n        revert(\"OUSD: Upgrading\");\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        revert(\"OUSD: Upgrading\");\n    }\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool)\n    {\n        revert(\"OUSD: Upgrading\");\n    }\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256)\n    {\n        revert(\"OUSD: Upgrading\");\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        revert(\"OUSD: Upgrading\");\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        revert(\"OUSD: Upgrading\");\n    }\n}"
    }
  ]
}