{
  "Title": "H-2: LockingPositionDelegate::manageOwnedAndDelegated unchecked duplicate tokenId allow metaGovernance manipulation",
  "Content": "# Issue H-2: LockingPositionDelegate::manageOwnedAndDelegated unchecked duplicate tokenId allow metaGovernance manipulation \n\nSource: https://github.com/sherlock-audit/2023-11-convergence-judging/issues/126 \n\n## Found by \nbughuntoor, cawfree, cergyk, hash, lemonmon, r0ck3tz\n## Summary\n\nA malicious user can multiply his share of meta governance delegation for a tokenId by adding that token multiple times when calling `manageOwnedAndDelegated`\n\n## Vulnerability Detail\n\nWithout checks to prevent the addition of duplicate token IDs, a user can artificially inflate their voting power and their metaGovernance delegations. \n\nA malicious user can add the same tokenId multiple times, and thus multiply his own share of meta governance delegation with regards to that tokenId.\n\nScenario:\n\n1. Bob delegates a part of metaGovernance to Mallory - he allocates 10% to her and 90% to Alice.\n2. Mallory calls `manageOwnedAndDelegated` and adds the same `tokenId` 10 times, each time allocating 10% of the voting power to herself.\n3. Mallory now has 100% of the voting power for the `tokenId`, fetched by calling `mgCvgVotingPowerPerAddress`, harming Bob and Alice metaGovernance voting power.\n\n## Impact\n\nThe lack of duplicate checks can be exploited by a malicious user to manipulate the metaGovernance system, allowing her to gain illegitimate voting power (up to 100%) on a delegated tokenId, harming the delegator and the other delegations of the same `tokenId`.\n\n## Code Snippet\n\n```solidity\n    function manageOwnedAndDelegated(OwnedAndDelegated calldata _ownedAndDelegatedTokens) external {\n        ...\n\n❌      for (uint256 i; i < _ownedAndDelegatedTokens.owneds.length;) { //@audit no duplicate check\n        ...\n        }\n\n❌      for (uint256 i; i < _ownedAndDelegatedTokens.mgDelegateds.length;) { //@audit no duplicate check\n        ...\n        }\n\n❌      for (uint256 i; i < _ownedAndDelegatedTokens.veDelegateds.length;) { //@audit no duplicate check\n        ...\n        }\n    }\n\n```\n\n```solidity\nfunction mgCvgVotingPowerPerAddress(address _user) public view returns (uint256) {\n        uint256 _totalMetaGovernance;\n        ...\n        /** @dev Sum voting power from delegated (allowed) tokenIds to _user. */\n        for (uint256 i; i < tokenIdsDelegateds.length; ) {\n            uint256 _tokenId = tokenIdsDelegateds[i];\n            (uint256 _toPercentage, , uint256 _toIndex) = _lockingPositionDelegate.getMgDelegateeInfoPerTokenAndAddress(\n                _tokenId,\n                _user\n            );\n            /** @dev Check if is really delegated, if not mg voting power for this tokenId is 0. */\n            if (_toIndex < 999) {\n                uint256 _tokenBalance = balanceOfMgCvg(_tokenId);\n                _totalMetaGovernance += (_tokenBalance * _toPercentage) / MAX_PERCENTAGE;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        ...\n❌    return _totalMetaGovernance; //@audit total voting power for the tokenID which will be inflated by adding the same tokenID multiple times\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Locking/LockingPositionDelegate.sol#L330\n\n### PoC\n\nAdd in balance-delegation.spec.ts:\n\n```ts\n    it(\"Manage tokenIds for user10 with dupes\", async () => {\n        let tokenIds = {owneds: [], mgDelegateds: [1, 1], veDelegateds: []};\n        await lockingPositionDelegate.connect(user10).manageOwnedAndDelegated(tokenIds);\n    });\n\n    it(\"Checks mgCVG balances of user10 (delegatee)\", async () => {\n        const tokenBalance = await lockingPositionService.balanceOfMgCvg(1);\n\n        // USER 10\n        const delegatedPercentage = 70n;\n\n        //@audit: The voting power is multiplied by 2 due to the duplicate\n        const exploit_multiplier = 2n;\n        const expectedVotingPower = (exploit_multiplier * tokenBalance * delegatedPercentage) / 100n;\n        const votingPower = await lockingPositionService.mgCvgVotingPowerPerAddress(user10);\n\n        // take solidity rounding down into account\n        expect(votingPower).to.be.approximately(expectedVotingPower, 1);\n    });\n\n```\n## Tool used\n\n## Recommendation\n\nEnsuring the array of token IDs is sorted and contains no duplicates. This can be achieved by verifying that each tokenId in the array is strictly greater than the previous one, it ensures uniqueness without additional data structures.\n\n\n\n## Discussion\n\n**shalbe-cvg**\n\nHello,\n\nThanks a lot for your attention.\n\nAfter an in-depth review, we have to consider your issue as Confirmed.\nWe will add a check on the values contained in the 3 arrays to ensure duplicates are taken away before starting the process.\n\nRegards,\nConvergence Team\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/126",
  "Code": [
    {
      "filename": "sherlock-cvg/contracts/Locking/LockingPositionDelegate.sol",
      "content": "// SPDX-License-Identifier: MIT\n/**\n _____\n/  __ \\\n| /  \\/ ___  _ ____   _____ _ __ __ _  ___ _ __   ___ ___\n| |    / _ \\| '_ \\ \\ / / _ \\ '__/ _` |/ _ \\ '_ \\ / __/ _ \\\n| \\__/\\ (_) | | | \\ V /  __/ | | (_| |  __/ | | | (_|  __/\n \\____/\\___/|_| |_|\\_/ \\___|_|  \\__, |\\___|_| |_|\\___\\___|\n                                 __/ |\n                                |___/\n */\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ICvgControlTower.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n* @title Cvg-Finance - LockingPositionDelegate\n* @notice Manage the lock delegation for 3 types of tokens : VeCvg, YsCvg and MgCvg.\n* @dev VeCvg : Vote for the governance of the protocol (DAO vote on snapshot  and Vote for inflation distribution  via the gauge system.\n*  | MgCvg : Vote for meta-governance of substrate protocols( DAO vote on snapshot ).\n*  | YsCVg : Share of the distribution of treasury rewards.\n*/\ncontract LockingPositionDelegate is Initializable {\n    struct MgCvgDelegatee {\n        address delegatee;\n        uint96 percentage;\n    }\n\n    struct OwnedAndDelegated {\n        uint256[] owneds;\n        uint256[] mgDelegateds;\n        uint256[] veDelegateds;\n    }\n\n    /** @dev Convergence ControlTower. */\n    ICvgControlTower public cvgControlTower;\n    /** @notice Maximum number of delegatees for MGcVg of a locking position. */\n    uint256 public maxMgDelegatees;\n    /** @notice Maximum number of tokenIds delegated for an address. */\n    uint256 public maxTokenIdsDelegated;\n    /** @notice Returns the delegated address of veCvg for a locking position . This address can, on behalf of the holder : vote on the GaugeController , vote on the Convergence Snapshot. */\n    mapping(uint256 => address) public delegatedVeCvg;\n    /** @notice Returns the tokenIds delegating their veCVG to an address. */\n    mapping(address => uint256[]) public veCvgDelegatees;\n    /** @notice Returns the delegated address of ysCvg for a tokenId, this address can claim the rewards from the YsDistributor on behalf of the owner. */\n    mapping(uint256 => address) public delegatedYsCvg;\n    /** @notice Returns the delegated addresses and the percentage of mgCVG for a tokenId. This address can, on behalf of the holder, vote on the Snapshot meta-governance proposal. */\n    mapping(uint256 => MgCvgDelegatee[]) public delegatedMgCvg;\n    /** @notice Returns the tokenIds delegating their mgCvg to an address. */\n    mapping(address => uint256[]) public mgCvgDelegatees;\n    /** @notice Keep track of the token usable by an address. */\n    mapping(address => OwnedAndDelegated) internal tokenOwnedAndDelegated;\n\n    event DelegateVeCvg(uint256 indexed tokenId, address to);\n    event DelegateShare(uint256 indexed tokenId, address delegatee);\n    event DelegateMetagovernance(uint256 indexed tokenId, address indexed to, uint256 percentage);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(ICvgControlTower _cvgControlTower) external initializer {\n        cvgControlTower = _cvgControlTower;\n        maxMgDelegatees = 5;\n        maxTokenIdsDelegated = 25;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        MODIFIERS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    modifier onlyTokenOwner(uint256 tokenId) {\n        require(msg.sender == cvgControlTower.lockingPositionManager().ownerOf(tokenId), \"TOKEN_NOT_OWNED\");\n        _;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        ONLY LOCKING OWNER\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /**\n    * @notice Set the maximum number of delegation that can be set for a token on the MetaGovernance.\n    * @dev this limit is set to avoid oog when calculating or managing the voting power\n    * @param _maxMgDelegatees is the maximum number of mg delegatees for a token.\n    */\n    function setMaxMgDelegatees(uint256 _maxMgDelegatees) external {\n        require(cvgControlTower.lockingPositionManager().owner() == msg.sender, \"NOT_OWNER\");\n        maxMgDelegatees = _maxMgDelegatees;\n    }\n\n    /**\n    * @notice Set the maximum number of tokenIds that can be delegated to an address.\n    * @dev this limit is set to avoid oog when calculating or managing the voting power, and spamming user.\n    * @param _maxTokenIdsDelegated is the maximum number of tokenIds delegated for an address.\n    */\n    function setMaxTokenIdsDelegated(uint256 _maxTokenIdsDelegated) external {\n        require(cvgControlTower.lockingPositionManager().owner() == msg.sender, \"NOT_OWNER\");\n        maxTokenIdsDelegated = _maxTokenIdsDelegated;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            GETTERS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /**\n    * @notice Obtain the veCvg delegated tokens identifiers for a delegatee.\n    * @param account is the address of the delegatee.\n    */\n    function getVeCvgDelegatees(address account) external view returns (uint256[] memory) {\n        return veCvgDelegatees[account];\n    }\n\n    /**\n    * @notice Obtain the mgCvg delegated token(NFT) for a delegatee.\n    * @param account is the address of the delegatee.\n    */\n    function getMgCvgDelegatees(address account) external view returns (uint256[] memory) {\n        return mgCvgDelegatees[account];\n    }\n\n    /**\n    * @notice  Obtain the delegatee for a token (NFT).\n    * @param _tokenId is the ID of the token (NFT) targeted.\n    */\n    function getDelegatedMgCvg(uint256 _tokenId) external view returns (MgCvgDelegatee[] memory) {\n        return delegatedMgCvg[_tokenId];\n    }\n\n    /**\n    * @notice Obtain all the token containing mgCvg and veCvg (owned and delegated) for an address.\n    * @param _addr is the targeted address\n    */\n    function getTokenOwnedAndDelegated(address _addr) external view returns (OwnedAndDelegated memory) {\n        return tokenOwnedAndDelegated[_addr];\n    }\n\n    /**\n    * @notice Obtain all the token containing mgCvg (owned and delegated) for an address.\n    * @param _addr is the targeted address\n    */\n    function getTokenMgOwnedAndDelegated(address _addr) external view returns (uint256[] memory, uint256[] memory) {\n        return (tokenOwnedAndDelegated[_addr].owneds, tokenOwnedAndDelegated[_addr].mgDelegateds);\n    }\n\n    /**\n    * @notice Obtain all the token containing veCvg (owned and delegated) for an address.\n    * @param _addr is the targeted address\n    */\n    function getTokenVeOwnedAndDelegated(address _addr) external view returns (uint256[] memory, uint256[] memory) {\n        return (tokenOwnedAndDelegated[_addr].owneds, tokenOwnedAndDelegated[_addr].veDelegateds);\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            PUBLICS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /**\n    * @notice Get the information about a MgCvg delegatee for a token.\n    * @param _tokenId is the ID of the token (NFT) targeted.\n    * @param _to is the address we want to get information from for the token.\n    * @return _toPercentage is the percentage of mgCVG delegated to the address, _totalPercentage is the total percentage of mgCVG delegated for the token, _toIndex is the index of the delegatee in the array of delegatees.\n    */\n    function getMgDelegateeInfoPerTokenAndAddress(\n        uint256 _tokenId,\n        address _to\n    ) public view returns (uint256, uint256, uint256) {\n        MgCvgDelegatee[] memory _delegatees = delegatedMgCvg[_tokenId];\n        uint256 _delegateesLength = _delegatees.length;\n\n        uint256 _totalPercentage;\n        uint256 _toPercentage;\n        uint256 _toIndex = 999;\n        /** @dev Loop through all delegatees to find  _to params.*/\n        for (uint256 i; i < _delegateesLength;) {\n            if (_delegatees[i].delegatee == _to) {\n                _toPercentage = _delegatees[i].percentage;\n                _toIndex = i;\n            }\n\n            _totalPercentage += _delegatees[i].percentage;\n            unchecked {\n                i++;\n            }\n        }\n\n        return (_toPercentage, _totalPercentage, _toIndex);\n    }\n    /**\n    * @notice Get the tokenId index in the array of delegated veCVG tokens for an user.\n    * @dev   Use to find the old delegatee of a token , in order to remove this delegation\n    *       when an update or a clean occurs.\n    * @param _delegatee is the address of the delegatee\n    * @param _tokenId is the ID of the token (NFT) targeted\n    */\n    function getIndexForVeDelegatee(address _delegatee, uint256 _tokenId) public view returns (uint256) {\n        uint256[] memory _tokenIds = veCvgDelegatees[_delegatee];\n        uint256 _length = _tokenIds.length;\n\n        for (uint256 i; i < _length;) {\n            if (_tokenIds[i] == _tokenId) return i;\n            unchecked {\n                ++i;\n            }\n        }\n\n        return 0;\n    }\n\n    /**\n    * @notice Get the tokenId index in the array of delegated mgCVG tokens for an user.\n    * @dev    Use to find the index of delegatee, when an update or a clean occurs.\n    * @param _delegatee is the address of the delegatee.\n    * @param _tokenId is the ID of the token (NFT) targeted.\n    */\n    function getIndexForMgCvgDelegatee(address _delegatee, uint256 _tokenId) public view returns (uint256) {\n        uint256[] memory _tokenIds = mgCvgDelegatees[_delegatee];\n        uint256 _length = _tokenIds.length;\n\n        for (uint256 i; i < _length;) {\n            if (_tokenIds[i] == _tokenId) return i;\n            unchecked {\n                ++i;\n            }\n        }\n\n        return 0;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            EXTERNALS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /**\n     *  @notice Delegates ysCVG for a tokenId to another address, this delegatee can claim the TDE rewards on behalf of the owner.\n     *  @dev Only the owner of the Locking position can delegate.\n     *  @param _tokenId is the ID of the token (NFT) targeted.\n     *  @param _to is the address of the delegatee.\n    */\n    function delegateYsCvg(uint256 _tokenId, address _to) external onlyTokenOwner(_tokenId) {\n        delegatedYsCvg[_tokenId] = _to;\n        emit DelegateShare(_tokenId, _to);\n    }\n\n    /**\n    * @notice Delegates veCVG for a tokenId to another address.\n    * @dev Address 0x0 can be used to  remove the delegation, the previous delegatee will be removed.\n    * @param _tokenId is the ID of the token (NFT) targeted.\n    * @param _to is the address of the delegatee.\n    */\n    function delegateVeCvg(uint256 _tokenId, address _to) external onlyTokenOwner(_tokenId) {\n        require(veCvgDelegatees[_to].length < maxTokenIdsDelegated, \"TOO_MUCH_VE_TOKEN_ID_DELEGATED\");\n        /** @dev Find if this tokenId is already delegated to an address. */\n        address previousOwner = delegatedVeCvg[_tokenId];\n        if (previousOwner != address(0)) {\n            /** @dev If it is  we remove the previous delegation.*/\n            uint256 _toIndex = getIndexForVeDelegatee(previousOwner, _tokenId);\n            uint256 _delegateesLength = veCvgDelegatees[previousOwner].length;\n            /** @dev Removing delegation.*/\n            veCvgDelegatees[previousOwner][_toIndex] = veCvgDelegatees[previousOwner][_delegateesLength - 1];\n            veCvgDelegatees[previousOwner].pop();\n        }\n\n        /** @dev Associate tokenId to a new delegated address.*/\n        delegatedVeCvg[_tokenId] = _to;\n\n        if (_to != address(0)) {\n            /** @dev Add delegation to the new address.*/\n            veCvgDelegatees[_to].push(_tokenId);\n        }\n        emit DelegateVeCvg(_tokenId, _to);\n    }\n\n    /**\n     * @notice Delegates a percentage of the mgCvG for a tokenId to another address (the mgCvg can be delegated to several addresses).\n     * @dev Percentage=0 can be used to remove a delegation.\n     * @param _tokenId is the ID of the token (NFT) to delegate voting power.\n     * @param _to is the address we want to delegate to.\n     * @param _percentage is the percentage we want to delegate to the address.\n     */\n    function delegateMgCvg(uint256 _tokenId, address _to, uint96 _percentage) external onlyTokenOwner(_tokenId) {\n        require(_percentage <= 100, \"INVALID_PERCENTAGE\");\n\n        uint256 _delegateesLength = delegatedMgCvg[_tokenId].length;\n        require(_delegateesLength < maxMgDelegatees, \"TOO_MUCH_DELEGATEES\");\n\n        uint256 tokenIdsDelegated = mgCvgDelegatees[_to].length;\n        require(tokenIdsDelegated < maxTokenIdsDelegated, \"TOO_MUCH_MG_TOKEN_ID_DELEGATED\");\n\n        (uint256 _toPercentage, uint256 _totalPercentage, uint256 _toIndex) = getMgDelegateeInfoPerTokenAndAddress(\n            _tokenId,\n            _to\n        );\n        bool _isUpdate = _toIndex != 999;\n        uint256 _newTotalPercentage = _isUpdate\n            ? (_totalPercentage + _percentage - _toPercentage)\n            : (_totalPercentage + _percentage);\n        require(_newTotalPercentage <= 100, \"TOO_MUCH_PERCENTAGE\");\n\n        require(_isUpdate || _percentage > 0, \"CANNOT_REMOVE_NOT_DELEGATEE\");\n\n        /** @dev Delegating.*/\n        if (_percentage > 0) {\n            MgCvgDelegatee memory delegatee = MgCvgDelegatee({delegatee: _to, percentage: _percentage});\n\n            /** @dev Updating delegatee.*/\n            if (_isUpdate) {\n                delegatedMgCvg[_tokenId][_toIndex] = delegatee;\n            } else {\n                /** @dev Adding new delegatee.*/\n                delegatedMgCvg[_tokenId].push(delegatee);\n                mgCvgDelegatees[_to].push(_tokenId);\n            }\n        } else {\n            /** @dev Removing delegation.*/\n            delegatedMgCvg[_tokenId][_toIndex] = delegatedMgCvg[_tokenId][_delegateesLength - 1];\n            delegatedMgCvg[_tokenId].pop();\n\n            uint256 _tokenIdIndex = getIndexForMgCvgDelegatee(_to, _tokenId);\n            mgCvgDelegatees[_to][_tokenIdIndex] = mgCvgDelegatees[_to][tokenIdsDelegated - 1];\n            mgCvgDelegatees[_to].pop();\n        }\n\n        emit DelegateMetagovernance(_tokenId, _to, _percentage);\n    }\n\n    /**\n    * @notice Allow a user to manage the tokens id (owned and delegated) used to represent their voting power.\n    *   @dev This prevents bad actors who will spam an address by transferring or delegating a lot of VE/MG positions.\n    *          | This will prevent the oog when the voting/metagovernance power is calculated.\n    *  @param _ownedAndDelegatedTokens array of owned/veDelegated/mgDelegated tokenIds allowed\n    */\n    function manageOwnedAndDelegated(OwnedAndDelegated calldata _ownedAndDelegatedTokens) external {\n        /** @dev Clear the struct owneds and delegateds tokenId allowed for this user.*/\n        delete tokenOwnedAndDelegated[msg.sender];\n\n        /** @dev Add new owned tokenIds allowed for this user.*/\n        for (uint256 i; i < _ownedAndDelegatedTokens.owneds.length;) {\n            /** @dev Check if tokenId is owned by the user.*/\n            require(\n                msg.sender == cvgControlTower.lockingPositionManager().ownerOf(_ownedAndDelegatedTokens.owneds[i]),\n                \"TOKEN_NOT_OWNED\"\n            );\n            tokenOwnedAndDelegated[msg.sender].owneds.push(_ownedAndDelegatedTokens.owneds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        /** @dev Add new mgCvg delegated tokenIds allowed for this user.*/\n        for (uint256 i; i < _ownedAndDelegatedTokens.mgDelegateds.length;) {\n            /** @dev Check if the user is a mgCvg delegatee for this tokenId.*/\n            (, , uint256 _toIndex) = getMgDelegateeInfoPerTokenAndAddress(\n                _ownedAndDelegatedTokens.mgDelegateds[i],\n                msg.sender\n            );\n            require(_toIndex != 999, \"NFT_NOT_MG_DELEGATED\");\n            tokenOwnedAndDelegated[msg.sender].mgDelegateds.push(_ownedAndDelegatedTokens.mgDelegateds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        /** @dev Add new veCvg delegated tokenIds allowed for this user.*/\n        for (uint256 i; i < _ownedAndDelegatedTokens.veDelegateds.length;) {\n            /** @dev Check if the user is the veCvg delegatee for this tokenId.*/\n            require(msg.sender == delegatedVeCvg[_ownedAndDelegatedTokens.veDelegateds[i]], \"NFT_NOT_VE_DELEGATED\");\n            tokenOwnedAndDelegated[msg.sender].veDelegateds.push(_ownedAndDelegatedTokens.veDelegateds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n    * @notice Method for a delegatee to remove a tokenId delegated at his address.\n    * @param _tokenId to remove\n    * @param removeVeDelegated boolean if user wants to remove VeCvgDelegation\n    * @param removeMgDelegated boolean if user wants to remove MgCvgDelegation\n    */\n    function removeTokenIdDelegated(uint256 _tokenId, bool removeVeDelegated, bool removeMgDelegated) external {\n        if (removeVeDelegated) {\n            _cleanVeDelegatee(_tokenId, true);\n        }\n        if (removeMgDelegated) {\n            _removeMgTokenIdDelegated(_tokenId);\n        }\n    }\n    /**\n    *   @notice Method for an owner of tokenId to clean all associated delegatees.\n    *   @param _tokenId to remove\n    *   @param cleanMgDelegatees boolean if user wants to clean all MgCvgDelegatees\n    *   @param cleanVeDelegatees boolean if user wants to clean all VeCvgDelegatees\n    */\n\n    function cleanDelegatees(\n        uint256 _tokenId,\n        bool cleanVeDelegatees,\n        bool cleanMgDelegatees\n    ) external onlyTokenOwner(_tokenId) {\n        if (cleanVeDelegatees) {\n            _cleanVeDelegatee(_tokenId, false);\n        }\n        if (cleanMgDelegatees) {\n            _cleanMgDelegatees(_tokenId);\n        }\n    }\n\n    /**\n    * @notice when a lock position is minted, this method can  automatically add this token take into account for Snapshot.\n    * @dev can only be called by lockingPositionService\n    * @param _tokenId to remove\n    */\n    function addTokenAtMint(uint256 _tokenId, address minter) external {\n        require(address(cvgControlTower.lockingPositionService()) == msg.sender, \"NOT_LOCKING_SERVICE\");\n        tokenOwnedAndDelegated[minter].owneds.push(_tokenId);\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            INTERNALS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /*\n    * @dev Clean the veCvg delegation  for the tokenId.\n    * @param _tokenId is the ID of the token (NFT) targeted\n    * @param isRemoveByDelegatee is a boolean to check if the function is called by the delegatee\n    */\n    function _cleanVeDelegatee(uint256 _tokenId, bool isRemoveByDelegatee) internal {\n        address previousOwner = delegatedVeCvg[_tokenId];\n        if (isRemoveByDelegatee) {\n            require(msg.sender == previousOwner, \"NOT_VE_DELEGATEE\");\n        }\n        /** @dev Find index for the previous owner.*/\n        uint256 _toIndex = getIndexForVeDelegatee(previousOwner, _tokenId);\n        /** @dev Get length of delegatees.*/\n        uint256 _delegateesLength = veCvgDelegatees[previousOwner].length;\n        /** @dev Removing delegation.*/\n        veCvgDelegatees[previousOwner][_toIndex] = veCvgDelegatees[previousOwner][_delegateesLength - 1];\n        veCvgDelegatees[previousOwner].pop();\n\n        /** @dev Set zero address for delegatee of this tokenId.*/\n        delegatedVeCvg[_tokenId] = address(0);\n\n        emit DelegateVeCvg(_tokenId, address(0));\n    }\n\n    /**\n    *  @notice Clean the mgCvg delegation for the tokenId call by the delegatee.\n    *  @param _tokenId is the ID of the token (NFT) targeted.\n    */\n    function _cleanMgDelegatees(uint256 _tokenId) internal {\n        MgCvgDelegatee[] memory mgCvgDelegatee = delegatedMgCvg[_tokenId];\n        for (uint256 i; i < mgCvgDelegatee.length;) {\n            address _to = mgCvgDelegatee[i].delegatee;\n            uint256 _tokenIdIndex = getIndexForMgCvgDelegatee(_to, _tokenId);\n            mgCvgDelegatees[_to][_tokenIdIndex] = mgCvgDelegatees[_to][mgCvgDelegatees[_to].length - 1];\n            mgCvgDelegatees[_to].pop();\n\n            emit DelegateMetagovernance(_tokenId, _to, 0);\n\n            unchecked {\n                ++i;\n            }\n        }\n        delete delegatedMgCvg[_tokenId];\n    }\n\n    /**\n    * @dev Clean the mgCvg delegation for the tokenId call by the delegatee.\n    * @param _tokenId is the ID of the token (NFT) targeted\n    */\n    function _removeMgTokenIdDelegated(uint256 _tokenId) internal {\n        (, , uint256 _toIndex) = getMgDelegateeInfoPerTokenAndAddress(_tokenId, msg.sender);\n        /** @dev Check if msg.sender is the delegatee.*/\n        require(_toIndex != 999, \"NOT_MG_DELEGATEE\");\n        uint256 _delegateesLength = delegatedMgCvg[_tokenId].length;\n\n        /** @dev Removing delegation.*/\n        delegatedMgCvg[_tokenId][_toIndex] = delegatedMgCvg[_tokenId][_delegateesLength - 1];\n        delegatedMgCvg[_tokenId].pop();\n\n        uint256 _tokenIdIndex = getIndexForMgCvgDelegatee(msg.sender, _tokenId);\n        mgCvgDelegatees[msg.sender][_tokenIdIndex] = mgCvgDelegatees[msg.sender][\n            mgCvgDelegatees[msg.sender].length - 1\n            ];\n        mgCvgDelegatees[msg.sender].pop();\n\n        emit DelegateMetagovernance(_tokenId, address(0), 0);\n    }\n}"
    }
  ]
}