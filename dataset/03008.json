{
  "Title": "M-3: getGetAmplificationParameter() precision is not used, which result in accounting issue in MetaStable2TokenAuraHelper.sol and in Boosted3TokenAuraHelper.sol",
  "Content": "# Issue M-3: getGetAmplificationParameter() precision is not used, which result in accounting issue in MetaStable2TokenAuraHelper.sol and in Boosted3TokenAuraHelper.sol \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/124 \n\n## Found by \nctf\\_sec\n\n## Summary\n\ngetGetAmplificationParameter() precision is not used, which result in accounting issue in MetaStable2TokenAuraHelper.sol and in Boosted3TokenAuraHelper.sol\n\n## Vulnerability Detail\n\nThis report has two part, \n\n**part one trace the accounting issue in MetaStable2TokenAuraHelper.sol,**\n\n**part two trace the accounting issue in Boosted3TokenAuraHelper.sol,**\n\nboth issue rooted in not handling the getGetAmplificationParameter() precision\n\nAccording to the Balancer documentation\n\nhttps://dev.balancer.fi/resources/pool-interfacing/stable-pool#amplification-parameter\n\npool.getGetAmplificationParameter()\n\nreturns something resembling\n\nvalue :  620000\nisUpdating :  False\nprecision :  1000\n\nwhere the amplification parameter is 620000 / 1000 = 620\n\nbut in the code, the isUpdating and precision returned is ignored and not used.\n\n### Part One\n\nLet's trace the function reinvestReward in MetaStable2TokenAuraHelper.sol\n\n```solidity\n    function reinvestReward(\n        MetaStable2TokenAuraStrategyContext calldata context,\n        ReinvestRewardParams calldata params\n    )\n```\n\nIt calls\n\n```solidity\n// Make sure we are joining with the right proportion to minimize slippage\n        oracleContext._validateSpotPriceAndPairPrice({\n            poolContext: poolContext,\n            strategyContext: strategyContext,\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount\n        });\n```\n\nthen it calls\n\n```solidity\nuint256 spotPrice = _getSpotPrice(oracleContext, poolContext, 0);\n```\n\nthen it calls\n\nInsite the function \n\n```solidity\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n            (poolContext.primaryBalance, poolContext.secondaryBalance) :\n            (poolContext.secondaryBalance, poolContext.primaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: balanceX,\n            balanceY: balanceY\n        });\n```\n\nWhat's wrong with this, I believe the precision has issue for ampParam\n\nBecause When we get the oracleContext.ampParam from MetaStable2TokenVaultMixin.sol\n\nWe did not use the precision returned from the pool\n\n```solidity\n      (\n            uint256 value,\n            /* bool isUpdating */,\n            /* uint256 precision */\n        ) = IMetaStablePool(address(BALANCER_POOL_TOKEN)).getAmplificationParameter();\n```\n\nAccording to the Balancer documentation\n\nhttps://dev.balancer.fi/resources/pool-interfacing/stable-pool#amplification-parameter\n\npool.getGetAmplificationParameter()\n\nreturns something resembling\n\nvalue :  620000\nisUpdating :  False\nprecision :  1000\n\nwhere the amplification parameter is 620000 / 1000 = 620\n\nThe formula that calculate the spot price is \n\n       /**************************************************************************************************************\n        //                                                                                                           //\n        //                             2.a.x.y + a.y^2 + b.y                                                         //\n        // spot price Y/X = - dx/dy = -----------------------                                                        //\n        //                             2.a.x.y + a.x^2 + b.x                                                         //\n        //                                                                                                           //\n        // n = 2                                                                                                     //\n        // a = amp param * n                                                                                         //\n        // b = D + a.(S - D)                                                                                         //\n        // D = invariant                                                                                             //\n        // S = sum of balances but x,y = 0 since x  and y are the only tokens                                        //\n        **************************************************************************************************************/\n\nthe function _calcSpotPrice hardcode the amp precision to 1e3;\n\n```solidity\n   uint256 internal constant _AMP_PRECISION = 1e3;\n```\n\nand implement\n\n```solidity\nuint256 a = (amplificationParameter * 2) / _AMP_PRECISION;\n```\n\nif the pool's ampParameter is not equal to _AMP_PRECISION, the math will break.\n\n## Part Two\n\nLet's trace the call in Boosted3TokenPoolUtils.sol\n\nFirst the function reinvestReward in Boosted3TokenAuraHelper.sol is called\n\n```solidity\n    function reinvestReward(\n        Boosted3TokenAuraStrategyContext calldata context,\n        ReinvestRewardParams calldata params\n    ) \n```\n\nThen we call\n\n```solidity\n   uint256 minBPT = context.poolContext._getMinBPT(\n      oracleContext, strategyContext, primaryAmount\n   );\n```\n\nthen we call \n\n```solidity\n\tminBPT = StableMath._calcBptOutGivenExactTokensIn({\n\t\tamp: oracleContext.ampParam,\n\t\tbalances: balances,\n\t\tamountsIn: amountsIn,\n\t\tbptTotalSupply: virtualSupply,\n\t\tswapFeePercentage: 0,\n\t\tcurrentInvariant: invariant\n\t});\n```\n\nthen we call\n\n```solidity\n // Get current and new invariants, taking swap fees into account\n\tuint256 newInvariant = _calculateInvariant(amp, newBalances, false);\n\tuint256 invariantRatio = newInvariant.divDown(currentInvariant);\n```\n\nthen we call\n\n```solidity\n  uint256 ampTimesTotal = amplificationParameter * numTokens;\n```\n\nwe just use the amplificationParameter without handling the precision.\n\nThe amplificationParameter comes from BoostedTokenPoolMixin.sol\n\n```solidity\n\t(\n\t\tuint256 value,\n\t\t/* bool isUpdating */,\n\t\t/* uint256 precision */\n\t) = pool.getAmplificationParameter();\n```\n\nthe isUpdating and precision is not used,\n\nhowever, according to the documentation\n\nAccording to the Balancer documentation\n\nhttps://dev.balancer.fi/resources/pool-interfacing/stable-pool#amplification-parameter\n\npool.getGetAmplificationParameter()\n\nreturns something resembling\n\nvalue :  620000\nisUpdating :  False\nprecision :  1000\n\nwhere the amplification parameter is 620000 / 1000 = 620\n\n## Impact\n\nThe amplificationParameter has precision, ignoring the precision will result in accounting issue.\n\nIf the precision of the amplificationParameter is not equal to hardcoded 1e3, the spot price is invalid.\n\nthe code\n\n```solidity\n   uint256 ampTimesTotal = amplificationParameter * numTokens;\n```\n\nwill be overvalued because we did not divide the value by the precision.\n\n## Code Snippet\n\n## For part one\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/external/MetaStable2TokenAuraHelper.sol#L114-L153\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L16-L41\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/MetaStable2TokenVaultMixin.sol#L22-L33\n\n## For part two\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol#L379\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/math/StableMath.sol#L320-L324\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/math/StableMath.sol#L28-L56\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/Boosted3TokenPoolMixin.sol#L103-L117\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the project use the precision returned from getGetAmplificationParameter()\n\n```solidity\n      (\n            uint256 value,\n            bool isUpdating */,\n            uint256 precision */\n        ) = IMetaStablePool(address(BALANCER_POOL_TOKEN)).getAmplificationParameter();\n        return value / precision;\n```\n\n## Discussion\n\n**jeffywu**\n\n@weitianjie2000, although I do believe in the meta stable vaults the AMP precision is hardcoded to 1e3 in practice. We should go with the value that is returned from the method.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/external/MetaStable2TokenAuraHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    MetaStable2TokenAuraStrategyContext,\n    StableOracleContext,\n    StrategyContext,\n    TwoTokenPoolContext,\n    RedeemParams,\n    ReinvestRewardParams,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../BalancerVaultTypes.sol\";\nimport {BalancerEvents} from \"../BalancerEvents.sol\";\nimport {SettlementUtils} from \"../internal/settlement/SettlementUtils.sol\";\nimport {StrategyUtils} from \"../internal/strategy/StrategyUtils.sol\";\nimport {TwoTokenPoolUtils} from \"../internal/pool/TwoTokenPoolUtils.sol\";\nimport {TwoTokenAuraRewardUtils} from \"../internal/reward/TwoTokenAuraRewardUtils.sol\";\nimport {Stable2TokenOracleMath} from \"../internal/math/Stable2TokenOracleMath.sol\";\nimport {BalancerVaultStorage} from \"../internal/BalancerVaultStorage.sol\";\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\n\nlibrary MetaStable2TokenAuraHelper {\n    using TwoTokenAuraRewardUtils for TwoTokenPoolContext;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using Stable2TokenOracleMath for StableOracleContext;\n    using StrategyUtils for StrategyContext;\n    using SettlementUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n\n    function settleVault(\n        MetaStable2TokenAuraStrategyContext calldata context,\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        RedeemParams memory params\n    ) external {\n        uint256 bptToSettle = context.baseStrategy._convertStrategyTokensToBPTClaim(strategyTokensToRedeem);\n        \n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            bptToSettle: bptToSettle,\n            redeemStrategyTokenAmount: strategyTokensToRedeem,\n            params: params\n        });\n\n        emit BalancerEvents.VaultSettlement(maturity, bptToSettle, strategyTokensToRedeem);\n    }\n\n    function settleVaultEmergency(\n        MetaStable2TokenAuraStrategyContext calldata context, \n        uint256 maturity, \n        bytes calldata data\n    ) external {\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.emergencySettlementSlippageLimitPercent,\n            data\n        );\n\n        uint256 bptToSettle = context.baseStrategy._getEmergencySettlementParams({\n            poolContext: context.poolContext.basePool, \n            maturity: maturity, \n            totalBPTSupply: IERC20(context.poolContext.basePool.pool).totalSupply()\n        });\n\n        uint256 redeemStrategyTokenAmount = \n            context.baseStrategy._convertBPTClaimToStrategyTokens(bptToSettle);\n\n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            bptToSettle: bptToSettle,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n\n        emit BalancerEvents.EmergencyVaultSettlement(maturity, bptToSettle, redeemStrategyTokenAmount);\n    }\n\n    function _executeSettlement(\n        StrategyContext calldata strategyContext,\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        uint256 maturity,\n        uint256 bptToSettle,\n        uint256 redeemStrategyTokenAmount,\n        RedeemParams memory params\n    ) private {\n        /// @notice params.minPrimary and params.minSecondary are not required for this strategy vault\n        (params.minPrimary, params.minSecondary) = oracleContext._getMinExitAmounts({\n            poolContext: poolContext,\n            strategyContext: strategyContext,\n            bptAmount: bptToSettle\n        });\n\n        int256 expectedUnderlyingRedeemed = poolContext._convertStrategyToUnderlying({\n            strategyContext: strategyContext,\n            oracleContext: oracleContext.baseOracle,\n            strategyTokenAmount: redeemStrategyTokenAmount\n        });\n\n        strategyContext._executeSettlement({\n            maturity: maturity,\n            expectedUnderlyingRedeemed: expectedUnderlyingRedeemed,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n    }\n\n    function reinvestReward(\n        MetaStable2TokenAuraStrategyContext calldata context,\n        ReinvestRewardParams calldata params\n    ) external {\n        StrategyContext calldata strategyContext = context.baseStrategy;\n        TwoTokenPoolContext calldata poolContext = context.poolContext; \n        StableOracleContext calldata oracleContext = context.oracleContext;\n\n        (\n            address rewardToken, \n            uint256 primaryAmount, \n            uint256 secondaryAmount\n        ) = poolContext._executeRewardTrades(\n            context.stakingContext,\n            strategyContext.tradingModule,\n            params.tradeData,\n            strategyContext.vaultSettings.maxRewardTradeSlippageLimitPercent\n        );\n\n        // Make sure we are joining with the right proportion to minimize slippage\n        oracleContext._validateSpotPriceAndPairPrice({\n            poolContext: poolContext,\n            strategyContext: strategyContext,\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount\n        });\n\n        uint256 bptAmount = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: context.stakingContext,\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount,\n            /// @notice minBPT is not required to be set by the caller because primaryAmount\n            /// and secondaryAmount are already validated\n            minBPT: params.minBPT        \n        });\n\n        emit BalancerEvents.RewardReinvested(rewardToken, primaryAmount, secondaryAmount, bptAmount); \n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {StableOracleContext, TwoTokenPoolContext, StrategyContext} from \"../../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {IPriceOracle} from \"../../../../../interfaces/balancer/IPriceOracle.sol\";\nimport {StableMath} from \"./StableMath.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary Stable2TokenOracleMath {\n    using TypeConvert for int256;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    function _getSpotPrice(\n        StableOracleContext memory oracleContext, \n        TwoTokenPoolContext memory poolContext, \n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        // Prevents overflows, we don't expect tokens to be greater than 18 decimals, don't use\n        // equal sign for minor gas optimization\n        require(poolContext.primaryDecimals < 19); /// @dev primaryDecimals overflow\n        require(poolContext.secondaryDecimals < 19); /// @dev secondaryDecimals overflow\n        require(tokenIndex < 2); /// @dev invalid token index\n\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n            (poolContext.primaryBalance, poolContext.secondaryBalance) :\n            (poolContext.secondaryBalance, poolContext.primaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: balanceX,\n            balanceY: balanceY\n        });\n    }\n\n    function _checkPriceLimit(\n        StrategyContext calldata strategyContext,\n        TwoTokenPoolContext memory poolContext,\n        uint256 poolPrice\n    ) private view returns (bool) {\n        (\n            int256 answer, int256 decimals\n        ) = strategyContext.tradingModule.getOraclePrice(poolContext.secondaryToken, poolContext.primaryToken);\n\n        require(decimals == int256(BalancerConstants.BALANCER_PRECISION));\n\n        uint256 oraclePairPrice = answer.toUint();\n        uint256 lowerLimit = (oraclePairPrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePairPrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePairPrice, poolPrice);\n        }\n    }\n\n    /// @notice calculates the expected min exit amounts for a given BPT amount\n    function _getMinExitAmounts(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        uint256 spotPrice = _getSpotPrice(oracleContext, poolContext, 0);\n        _checkPriceLimit(strategyContext, poolContext, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        minPrimary = (poolContext.primaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice(oracleContext, poolContext, 0);\n        _checkPriceLimit(strategyContext, poolContext, spotPrice);\n\n        // We always validate in terms of the primary here so it is the first value in the _balances array\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(primaryAmount, secondaryAmount), true // round up\n        );\n\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n        primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n        secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n        uint256 calculatedPairPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: primaryAmount,\n            balanceY: secondaryAmount\n        });\n\n        _checkPriceLimit(strategyContext, poolContext, calculatedPairPrice);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/mixins/MetaStable2TokenVaultMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {IMetaStablePool} from \"../../../../interfaces/balancer/IBalancerPool.sol\";\nimport {StableOracleContext} from \"../BalancerVaultTypes.sol\";\nimport {BalancerOracleMixin} from \"./BalancerOracleMixin.sol\";\nimport {TwoTokenPoolMixin} from \"./TwoTokenPoolMixin.sol\";\nimport {AuraVaultDeploymentParams} from \"../BalancerVaultTypes.sol\";\nimport {NotionalProxy} from \"../../../../interfaces/notional/NotionalProxy.sol\";\n\nabstract contract MetaStable2TokenVaultMixin is TwoTokenPoolMixin, BalancerOracleMixin {\n    constructor(NotionalProxy notional_, AuraVaultDeploymentParams memory params)\n        TwoTokenPoolMixin(notional_, params)\n        BalancerOracleMixin(params.baseParams.balancerPoolId) \n    {\n        // The oracle is required for the vault to behave properly\n        (/* */, /* */, /* */, /* */, bool oracleEnabled) = \n            IMetaStablePool(address(BALANCER_POOL_TOKEN)).getOracleMiscData();\n        require(oracleEnabled);\n    }\n\n    function _stableOracleContext() internal view returns (StableOracleContext memory) {\n        (\n            uint256 value,\n            /* bool isUpdating */,\n            /* uint256 precision */\n        ) = IMetaStablePool(address(BALANCER_POOL_TOKEN)).getAmplificationParameter();\n        \n        return StableOracleContext({\n            ampParam: value,\n            baseOracle: _oracleContext()\n        });\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {\n    ThreeTokenPoolContext,\n    TwoTokenPoolContext,\n    BoostedOracleContext,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"../pool/Boosted3TokenPoolUtils.sol\";\nimport {StableMath} from \"../math/StableMath.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {IBoostedPool} from \"../../../../../interfaces/balancer/IBalancerPool.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TwoTokenPoolUtils} from \"./TwoTokenPoolUtils.sol\";\nimport {FixedPoint} from \"../math/FixedPoint.sol\";\n\nlibrary Boosted3TokenPoolUtils {\n    using TypeConvert for uint256;\n    using FixedPoint for uint256;\n    using TypeConvert for int256;\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using Boosted3TokenPoolUtils for ThreeTokenPoolContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using StrategyUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n\n    // Preminted BPT is sometimes called Phantom BPT, as the preminted BPT (which is deposited in the Vault as balance of\n    // the Pool) doesn't belong to any entity until transferred out of the Pool. The Pool's arithmetic behaves as if it\n    // didn't exist, and the BPT total supply is not a useful value: we rely on the 'virtual supply' (how much BPT is\n    // actually owned by some entity) instead.\n    uint256 private constant _MAX_TOKEN_BALANCE = 2**(112) - 1;\n\n    function _getSpotPrice(\n        uint256 ampParam,\n        uint256 invariant,\n        uint256[] memory balances, \n        uint8 tokenIndexIn, \n        uint8 tokenIndexOut\n    ) private pure returns (uint256 spotPrice) {\n        // Trade 1 unit of tokenIn for tokenOut to get the spot price\n        uint256 amountIn = BalancerConstants.BALANCER_PRECISION;\n        uint256 amountOut = StableMath._calcOutGivenIn({\n            amplificationParameter: ampParam,\n            balances: balances,\n            tokenIndexIn: tokenIndexIn,\n            tokenIndexOut: tokenIndexOut,\n            tokenAmountIn: amountIn,\n            invariant: invariant\n        });\n        spotPrice = amountOut;\n    }\n\n    function _validateSpotPrice(\n        StrategyContext memory context,\n        address tokenIn,\n        uint8 tokenIndexIn,\n        address tokenOut,\n        uint8 tokenIndexOut,\n        uint256[] memory balances,\n        uint256 ampParam,\n        uint256 invariant\n    ) private view {\n        (int256 answer, int256 decimals) = context.tradingModule.getOraclePrice(tokenOut, tokenIn);\n        require(decimals == int256(BalancerConstants.BALANCER_PRECISION));\n        \n        uint256 spotPrice = _getSpotPrice({\n            ampParam: ampParam,\n            invariant: invariant,\n            balances: balances, \n            tokenIndexIn: tokenIndexIn, // Primary index\n            tokenIndexOut: tokenIndexOut // Secondary index\n        }); \n\n        uint256 oraclePrice = answer.toUint();\n        uint256 lowerLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - context.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + context.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        // Check spot price against oracle price to make sure it hasn't been manipulated\n        if (spotPrice < lowerLimit || upperLimit < spotPrice) {\n            revert Errors.InvalidPrice(oraclePrice, spotPrice);\n        }\n    }\n\n    function _validateTokenPrices(\n        ThreeTokenPoolContext memory poolContext, \n        StrategyContext memory strategyContext,\n        uint256[] memory balances,\n        uint256 ampParam,\n        uint256 invariant\n    ) private view {\n        address primaryUnderlying = IBoostedPool(address(poolContext.basePool.primaryToken)).getMainToken();\n        address secondaryUnderlying = IBoostedPool(address(poolContext.basePool.secondaryToken)).getMainToken();\n        address tertiaryUnderlying = IBoostedPool(address(poolContext.tertiaryToken)).getMainToken();\n\n        _validateSpotPrice({\n            context: strategyContext,\n            tokenIn: primaryUnderlying,\n            tokenIndexIn: 0, // primary index\n            tokenOut: secondaryUnderlying,\n            tokenIndexOut: 1, // secondary index\n            balances: balances,\n            ampParam: ampParam,\n            invariant: invariant\n        });\n\n        _validateSpotPrice({\n            context: strategyContext,\n            tokenIn: primaryUnderlying,\n            tokenIndexIn: 0, // primary index\n            tokenOut: tertiaryUnderlying,\n            tokenIndexOut: 2, // secondary index\n            balances: balances,\n            ampParam: ampParam,\n            invariant: invariant\n        });\n    }\n\n    function _getVirtualSupply(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext\n    ) internal pure returns (uint256 virtualSupply) {\n        // The initial amount of BPT pre-minted is _MAX_TOKEN_BALANCE and it goes entirely to the pool balance in the\n        // vault. So the virtualSupply (the actual supply in circulation) is defined as:\n        // virtualSupply = totalSupply() - (_balances[_bptIndex] - _dueProtocolFeeBptAmount)\n        //\n        // However, since this Pool never mints or burns BPT outside of the initial supply (except in the event of an\n        // emergency pause), we can simply use `_MAX_TOKEN_BALANCE` instead of `totalSupply()` and save\n        // gas.\n        virtualSupply = _MAX_TOKEN_BALANCE - oracleContext.bptBalance + oracleContext.dueProtocolFeeBptAmount;\n    }\n\n    function _getVirtualSupplyAndBalances(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext\n    ) private pure returns (uint256 virtualSupply, uint256[] memory amountsWithoutBpt) {\n        virtualSupply = _getVirtualSupply(poolContext, oracleContext);\n\n        amountsWithoutBpt = new uint256[](3);\n        amountsWithoutBpt[0] = poolContext.basePool.primaryBalance;\n        amountsWithoutBpt[1] = poolContext.basePool.secondaryBalance;\n        amountsWithoutBpt[2] = poolContext.tertiaryBalance;\n    }\n\n    function _getValidatedPoolData(\n        ThreeTokenPoolContext memory poolContext,\n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext\n    ) internal view returns (uint256 virtualSupply, uint256[] memory balances, uint256 invariant) {\n        (virtualSupply, balances) = \n            _getVirtualSupplyAndBalances(poolContext, oracleContext);\n\n        // Get the current and new invariants. Since we need a bigger new invariant, we round the current one up.\n        invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, balances, true // roundUp = true\n        );\n\n        // validate spot prices against oracle prices\n        _validateTokenPrices({\n            poolContext: poolContext,\n            strategyContext: strategyContext,\n            balances: balances,\n            ampParam: oracleContext.ampParam,\n            invariant: invariant\n        });\n    }\n\n    /// @notice Gets the time-weighted primary token balance for a given bptAmount\n    /// @dev Boosted pool can't use the Balancer oracle, using Chainlink instead\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param bptAmount amount of balancer pool lp tokens\n    /// @return primaryAmount primary token balance\n    function _getTimeWeightedPrimaryBalance(\n        ThreeTokenPoolContext memory poolContext,\n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 primaryAmount) {\n        (\n           uint256 virtualSupply, \n           uint256[] memory balances, \n           uint256 invariant\n        ) = _getValidatedPoolData(poolContext, oracleContext, strategyContext);\n\n        // NOTE: For Boosted 3 token pools, the LP token (BPT) is just another\n        // token in the pool. So, we first use _calcTokenOutGivenExactBptIn\n        // to calculate the value of 1 BPT. Then, we scale it to the BPT\n        // amount to get the value in terms of the primary currency.\n        // Use virtual total supply and zero swap fees for joins\n        primaryAmount = StableMath._calcTokenOutGivenExactBptIn({\n            amp: oracleContext.ampParam, \n            balances: balances, \n            tokenIndex: 0, \n            bptAmountIn: BalancerConstants.BALANCER_PRECISION, // 1 BPT \n            bptTotalSupply: virtualSupply, \n            swapFeePercentage: 0, \n            currentInvariant: invariant\n        });\n\n        uint256 primaryPrecision = 10 ** poolContext.basePool.primaryDecimals;\n        primaryAmount = (primaryAmount * bptAmount * primaryPrecision) / BalancerConstants.BALANCER_PRECISION_SQUARED;\n    }\n\n    function _approveBalancerTokens(ThreeTokenPoolContext memory poolContext, address bptSpender) internal {\n        poolContext.basePool._approveBalancerTokens(bptSpender);\n\n        IERC20(poolContext.tertiaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n\n        // For boosted pools, the tokens inside pool context are AaveLinearPool tokens.\n        // So, we need to approve the _underlyingToken (primary borrow currency) for trading.\n        IBoostedPool underlyingPool = IBoostedPool(poolContext.basePool.primaryToken);\n        address primaryUnderlyingAddress = BalancerUtils.getTokenAddress(underlyingPool.getMainToken());\n        IERC20(primaryUnderlyingAddress).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n    }\n\n    function _joinPoolExactTokensIn(ThreeTokenPoolContext memory context, uint256 primaryAmount, uint256 minBPT)\n        private returns (uint256 bptAmount) {\n        IBoostedPool underlyingPool = IBoostedPool(address(context.basePool.primaryToken));\n\n        // Swap underlyingToken for LinearPool BPT\n        uint256 linearPoolBPT = BalancerUtils._swapGivenIn({\n            poolId: underlyingPool.getPoolId(),\n            tokenIn: underlyingPool.getMainToken(),\n            tokenOut: address(underlyingPool),\n            amountIn: primaryAmount,\n            limit: 0 // slippage checked on the second swap\n        });\n\n        // Swap LinearPool BPT for Boosted BPT\n        bptAmount = BalancerUtils._swapGivenIn({\n            poolId: context.basePool.basePool.poolId,\n            tokenIn: address(underlyingPool),\n            tokenOut: address(context.basePool.basePool.pool), // Boosted pool\n            amountIn: linearPoolBPT,\n            limit: minBPT\n        });\n    }\n\n    function _exitPoolExactBPTIn(ThreeTokenPoolContext memory context, uint256 bptExitAmount, uint256 minPrimary)\n        private returns (uint256 primaryBalance) {\n        IBoostedPool underlyingPool = IBoostedPool(address(context.basePool.primaryToken));\n\n        // Swap Boosted BPT for LinearPool BPT\n        uint256 linearPoolBPT = BalancerUtils._swapGivenIn({\n            poolId: context.basePool.basePool.poolId,\n            tokenIn: address(context.basePool.basePool.pool), // Boosted pool\n            tokenOut: address(underlyingPool),\n            amountIn: bptExitAmount,\n            limit: 0 // slippage checked on the second swap\n        });\n\n        // Swap LinearPool BPT for underlyingToken\n        primaryBalance = BalancerUtils._swapGivenIn({\n            poolId: underlyingPool.getPoolId(),\n            tokenIn: address(underlyingPool),\n            tokenOut: underlyingPool.getMainToken(),\n            amountIn: linearPoolBPT,\n            limit: minPrimary\n        }); \n    }\n\n    function _deposit(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 deposit,\n        uint256 minBPT\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 bptMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            oracleContext: oracleContext,\n            deposit: deposit,\n            minBPT: minBPT\n        });\n\n        strategyTokensMinted = strategyContext._convertBPTClaimToStrategyTokens(bptMinted);\n\n        // Update global supply count\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _redeem(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 strategyTokens,\n        uint256 minPrimary\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n        if (bptClaim == 0) return 0;\n\n        finalPrimaryBalance = _unstakeAndExitPool({\n            stakingContext: stakingContext,\n            poolContext: poolContext,\n            bptClaim: bptClaim,\n            minPrimary: minPrimary\n        });\n\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _joinPoolAndStake(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 deposit,\n        uint256 minBPT\n    ) internal returns (uint256 bptMinted) {\n        bptMinted = _joinPoolExactTokensIn(poolContext, deposit, minBPT);\n\n        // Check BPT threshold to make sure our share of the pool is\n        // below maxBalancerPoolShare\n        uint256 bptThreshold = strategyContext.vaultSettings._bptThreshold(\n            poolContext._getVirtualSupply(oracleContext)\n        );\n        uint256 bptHeldAfterJoin = strategyContext.totalBPTHeld + bptMinted;\n        if (bptHeldAfterJoin > bptThreshold)\n            revert Errors.BalancerPoolShareTooHigh(bptHeldAfterJoin, bptThreshold);\n\n        // Transfer token to Aura protocol for boosted staking\n        stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n    }\n\n    function _unstakeAndExitPool(\n        ThreeTokenPoolContext memory poolContext,\n        AuraStakingContext memory stakingContext,\n        uint256 bptClaim,\n        uint256 minPrimary\n    ) internal returns (uint256 primaryBalance) {\n        // Withdraw BPT tokens back to the vault for redemption\n        stakingContext.auraRewardPool.withdrawAndUnwrap(bptClaim, false); // claimRewards = false\n\n        primaryBalance = _exitPoolExactBPTIn(poolContext, bptClaim, minPrimary);    \n    }\n\n    /// @notice We value strategy tokens in terms of the primary balance. The time weighted\n    /// primary balance is used in order to prevent pool manipulation.\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param strategyTokenAmount amount of strategy tokens\n    /// @return underlyingValue underlying value of strategy tokens\n    function _convertStrategyToUnderlying(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 strategyTokenAmount\n    ) internal view returns (int256 underlyingValue) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokenAmount);\n        \n        underlyingValue = poolContext._getTimeWeightedPrimaryBalance(\n            oracleContext, strategyContext, bptClaim\n        ).toInt();\n    }\n\n    function _getMinBPT(\n        ThreeTokenPoolContext calldata poolContext,\n        BoostedOracleContext calldata oracleContext,\n        StrategyContext calldata strategyContext,\n        uint256 primaryAmount\n    ) internal view returns (uint256 minBPT) {\n        // Calculate minBPT to minimize slippage\n        (\n            uint256 virtualSupply, \n            uint256[] memory balances, \n            uint256 invariant\n        ) = poolContext._getValidatedPoolData(oracleContext, strategyContext);\n\n        uint256[] memory amountsIn = new uint256[](3);\n        // _getValidatedPoolData rearranges the balances so that primary is always in the\n        // zero index spot\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.basePool.primaryDecimals;\n        amountsIn[0] = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n\n        minBPT = StableMath._calcBptOutGivenExactTokensIn({\n            amp: oracleContext.ampParam,\n            balances: balances,\n            amountsIn: amountsIn,\n            bptTotalSupply: virtualSupply,\n            swapFeePercentage: 0,\n            currentInvariant: invariant\n        });\n\n        uint256 swapFeePercentage = IBoostedPool(address(poolContext.basePool.basePool.pool))\n            .getCachedProtocolSwapFeePercentage();\n\n        if (swapFeePercentage > 0) {\n            minBPT -= _getDueProtocolFeeByBpt(minBPT, swapFeePercentage);\n        }\n\n        minBPT = minBPT * strategyContext.vaultSettings.balancerPoolSlippageLimitPercent / \n            uint256(BalancerConstants.VAULT_PERCENT_BASIS);\n    }\n\n    function _addSwapFeeAmount(uint256 amount, uint256 protocolSwapFeePercentage) private view returns (uint256) {\n        // This returns amount + fee amount, so we round up (favoring a higher fee amount).\n        return amount.divUp(FixedPoint.ONE.sub(protocolSwapFeePercentage));\n    }\n\n    function _getDueProtocolFeeByBpt(\n        uint256 bptAmount,\n        uint256 protocolSwapFeePercentage\n    ) private view returns (uint256) {\n        uint256 feeAmount = _addSwapFeeAmount(bptAmount, protocolSwapFeePercentage).sub(bptAmount);\n\n        uint256 protocolFeeAmount = feeAmount.mulDown(protocolSwapFeePercentage);\n        return protocolFeeAmount;\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/math/StableMath.sol",
      "content": "// SPDX-License-Ide"
    }
  ]
}