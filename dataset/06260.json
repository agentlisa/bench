{
  "Title": "[01] Reserve price not fully taken care of",
  "Content": "It is possible for an active auction to close at a price lower than the newly increased reserve price. This is undesirable especially when preventing a Noun auctioned off at the lower than expected price could be out of control in a bear market. Consider adding a check alleging that the contract balance needing to exceed the reserve price. Else, the last bidder will be refunded prior to having the Noun burned. Here's a refactored code logic that will take care of the suggestion.\n\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol#L236-L256\n\n```solidity\n/**\n * @notice Settle an auction, finalizing the bid and paying out to the owner.\n * @dev If there are no bids, the Noun is burned.\n */\nfunction _settleAuction() internal {\n    INounsAuctionHouse.Auction memory _auction = auction;\n\n    require(_auction.startTime != 0, \"Auction hasn't begun\");\n    require(!_auction.settled, 'Auction has already been settled');\n    require(block.timestamp >= _auction.endTime, \"Auction hasn't completed\");\n\n    auction.settled = true;\n\n    // Check if contract balance is greater than reserve price\n    if (address(this).balance < reservePrice) {\n        // If contract balance is less than reserve price, refund to the last bidder\n        if (_auction.bidder != address(0)) {\n            _safeTransferETHWithFallback(_auction.bidder, _auction.amount);\n        }\n\n        // And then burn the Noun\n        nouns.burn(_auction.nounId);\n    } else {\n        if (_auction.bidder == address(0)) {\n            nouns.burn(_auction.nounId);\n        } else {\n            nouns.transferFrom(address(this), _auction.bidder, _auction.nounId);\n        }\n\n        if (_auction.amount > 0) {\n            _safeTransferETHWithFallback(owner(), _auction.amount);\n        }\n    }\n\n    emit AuctionSettled(_auction.nounId, _auction.bidder, _auction.amount);\n}\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-nounsdao",
  "Code": [
    {
      "filename": "packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The Nouns DAO auction house, supporting UUPS upgrades\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// NounsAuctionHouseFork.sol is a modified version of NounsAuctionHouse.sol.\n// NounsAuctionHouse.sol is a modified version of Zora's AuctionHouse.sol:\n// https://github.com/ourzora/auction-house/blob/54a12ec1a6cf562e49f0a4917990474b11350a2d/contracts/AuctionHouse.sol\n//\n// AuctionHouse.sol source code Copyright Zora licensed under the GPL-3.0 license.\n// With modifications by Nounders DAO.\n//\n// NounsAuctionHouseFork.sol Modifications:\n// - Proxy pattern changed from Transparent to UUPS.\n// - Owner is set in the initialize function, instead of in a follow-up transaction.\n\npragma solidity ^0.8.19;\n\nimport { PausableUpgradeable } from '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport { ReentrancyGuardUpgradeable } from '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport { OwnableUpgradeable } from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { INounsAuctionHouse } from '../../../interfaces/INounsAuctionHouse.sol';\nimport { INounsToken } from '../../../interfaces/INounsToken.sol';\nimport { IWETH } from '../../../interfaces/IWETH.sol';\nimport { UUPSUpgradeable } from '@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol';\n\ncontract NounsAuctionHouseFork is\n    INounsAuctionHouse,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    UUPSUpgradeable\n{\n    string public constant NAME = 'NounsAuctionHouseFork';\n\n    // The Nouns ERC721 token contract\n    INounsToken public nouns;\n\n    // The address of the WETH contract\n    address public weth;\n\n    // The minimum amount of time left in an auction after a new bid is created\n    uint256 public timeBuffer;\n\n    // The minimum price accepted in an auction\n    uint256 public reservePrice;\n\n    // The minimum percentage difference between the last bid amount and the current bid\n    uint8 public minBidIncrementPercentage;\n\n    // The duration of a single auction\n    uint256 public duration;\n\n    // The active auction\n    INounsAuctionHouse.Auction public auction;\n\n    /**\n     * @notice Initialize the auction house and base contracts,\n     * populate configuration values, and pause the contract.\n     * @dev This function can only be called once.\n     */\n    function initialize(\n        address _owner,\n        INounsToken _nouns,\n        address _weth,\n        uint256 _timeBuffer,\n        uint256 _reservePrice,\n        uint8 _minBidIncrementPercentage,\n        uint256 _duration\n    ) external initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        _transferOwnership(_owner);\n\n        _pause();\n\n        nouns = _nouns;\n        weth = _weth;\n        timeBuffer = _timeBuffer;\n        reservePrice = _reservePrice;\n        minBidIncrementPercentage = _minBidIncrementPercentage;\n        duration = _duration;\n    }\n\n    /**\n     * @notice Settle the current auction, mint a new Noun, and put it up for auction.\n     */\n    function settleCurrentAndCreateNewAuction() external override nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /**\n     * @notice Settle the current auction.\n     * @dev This function can only be called when the contract is paused.\n     */\n    function settleAuction() external override whenPaused nonReentrant {\n        _settleAuction();\n    }\n\n    /**\n     * @notice Create a bid for a Noun, with a given amount.\n     * @dev This contract only accepts payment in ETH.\n     */\n    function createBid(uint256 nounId) external payable override nonReentrant {\n        INounsAuctionHouse.Auction memory _auction = auction;\n\n        require(_auction.nounId == nounId, 'Noun not up for auction');\n        require(block.timestamp < _auction.endTime, 'Auction expired');\n        require(msg.value >= reservePrice, 'Must send at least reservePrice');\n        require(\n            msg.value >= _auction.amount + ((_auction.amount * minBidIncrementPercentage) / 100),\n            'Must send more than last bid by minBidIncrementPercentage amount'\n        );\n\n        address payable lastBidder = _auction.bidder;\n\n        // Refund the last bidder, if applicable\n        if (lastBidder != address(0)) {\n            _safeTransferETHWithFallback(lastBidder, _auction.amount);\n        }\n\n        auction.amount = msg.value;\n        auction.bidder = payable(msg.sender);\n\n        // Extend the auction if the bid was received within `timeBuffer` of the auction end time\n        bool extended = _auction.endTime - block.timestamp < timeBuffer;\n        if (extended) {\n            auction.endTime = _auction.endTime = block.timestamp + timeBuffer;\n        }\n\n        emit AuctionBid(_auction.nounId, msg.sender, msg.value, extended);\n\n        if (extended) {\n            emit AuctionExtended(_auction.nounId, _auction.endTime);\n        }\n    }\n\n    /**\n     * @notice Pause the Nouns auction house.\n     * @dev This function can only be called by the owner when the\n     * contract is unpaused. While no new auctions can be started when paused,\n     * anyone can settle an ongoing auction.\n     */\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the Nouns auction house.\n     * @dev This function can only be called by the owner when the\n     * contract is paused. If required, this function will start a new auction.\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n\n        if (auction.startTime == 0 || auction.settled) {\n            _createAuction();\n        }\n    }\n\n    /**\n     * @notice Set the auction time buffer.\n     * @dev Only callable by the owner.\n     */\n    function setTimeBuffer(uint256 _timeBuffer) external override onlyOwner {\n        timeBuffer = _timeBuffer;\n\n        emit AuctionTimeBufferUpdated(_timeBuffer);\n    }\n\n    /**\n     * @notice Set the auction reserve price.\n     * @dev Only callable by the owner.\n     */\n    function setReservePrice(uint256 _reservePrice) external override onlyOwner {\n        reservePrice = _reservePrice;\n\n        emit AuctionReservePriceUpdated(_reservePrice);\n    }\n\n    /**\n     * @notice Set the auction minimum bid increment percentage.\n     * @dev Only callable by the owner.\n     */\n    function setMinBidIncrementPercentage(uint8 _minBidIncrementPercentage) external override onlyOwner {\n        minBidIncrementPercentage = _minBidIncrementPercentage;\n\n        emit AuctionMinBidIncrementPercentageUpdated(_minBidIncrementPercentage);\n    }\n\n    /**\n     * @notice Create an auction.\n     * @dev Store the auction details in the `auction` state variable and emit an AuctionCreated event.\n     * If the mint reverts, the minter was updated without pausing this contract first. To remedy this,\n     * catch the revert and pause this contract.\n     */\n    function _createAuction() internal {\n        try nouns.mint() returns (uint256 nounId) {\n            uint256 startTime = block.timestamp;\n            uint256 endTime = startTime + duration;\n\n            auction = Auction({\n                nounId: nounId,\n                amount: 0,\n                startTime: startTime,\n                endTime: endTime,\n                bidder: payable(0),\n                settled: false\n            });\n\n            emit AuctionCreated(nounId, startTime, endTime);\n        } catch Error(string memory) {\n            _pause();\n        }\n    }\n\n    /**\n     * @notice Settle an auction, finalizing the bid and paying out to the owner.\n     * @dev If there are no bids, the Noun is burned.\n     */\n    function _settleAuction() internal {\n        INounsAuctionHouse.Auction memory _auction = auction;\n\n        require(_auction.startTime != 0, \"Auction hasn't begun\");\n        require(!_auction.settled, 'Auction has already been settled');\n        require(block.timestamp >= _auction.endTime, \"Auction hasn't completed\");\n\n        auction.settled = true;\n\n        if (_auction.bidder == address(0)) {\n            nouns.burn(_auction.nounId);\n        } else {\n            nouns.transferFrom(address(this), _auction.bidder, _auction.nounId);\n        }\n\n        if (_auction.amount > 0) {\n            _safeTransferETHWithFallback(owner(), _auction.amount);\n        }\n\n        emit AuctionSettled(_auction.nounId, _auction.bidder, _auction.amount);\n    }\n\n    /**\n     * @notice Transfer ETH. If the ETH transfer fails, wrap the ETH and try send it as WETH.\n     */\n    function _safeTransferETHWithFallback(address to, uint256 amount) internal {\n        if (!_safeTransferETH(to, amount)) {\n            IWETH(weth).deposit{ value: amount }();\n            IERC20(weth).transfer(to, amount);\n        }\n    }\n\n    /**\n     * @notice Transfer ETH and return the success status.\n     * @dev This function only forwards 30,000 gas to the callee.\n     */\n    function _safeTransferETH(address to, uint256 value) internal returns (bool) {\n        (bool success, ) = to.call{ value: value, gas: 30_000 }(new bytes(0));\n        return success;\n    }\n\n    /**\n     * @dev Reverts when `msg.sender` is not the owner of this contract; in the case of Noun DAOs it should be the\n     * DAO's treasury contract.\n     */\n    function _authorizeUpgrade(address) internal view override onlyOwner {}\n}"
    }
  ]
}