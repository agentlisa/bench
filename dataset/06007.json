{
  "Title": "[N-02] Missing check to make sure added tokens corresponds to the oracle/pool",
  "Content": "### Summary\n\nIn the `LPOracle.sol` and `RoeRouter.sol` files, there are functions that don't verify if the tokens sent in the params are part of the oracle/pool address also sent in the params. That can allow human mistakes that lead to wrong price calculations. \n\n### Vulnerability Details\n\nThere is no check to make sure that the tokens constituting the LP/oracle are the same as the chainlink price tokens. Due to human error, a mistake can be made and you end up with a price for token 0 with decimals of token 1, which would completely destroy any price calculations.\n\n### Impact\n\nPotential wrong price calculations if the wrong tokens or the right tokens but in a wrong order are submitted when deploying the oracle.\n\n### Proof of Concept\n\n- https://github.com/code-423n4/2023-08-goodentry/blob/4b785d455fff04629d8675f21ef1d1632749b252/contracts/helper/LPOracle.sol#L28-L29\n- https://github.com/code-423n4/2023-08-goodentry/blob/4b785d455fff04629d8675f21ef1d1632749b252/contracts/RoeRouter.sol#L54-L79\n\n### Recommended Mitigation Steps\n\nImplement a check to verify the tokens added in the params are the same (and in the same order) as the one used in the LP/oracle added also in the params.\n\n---\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-08-goodentry",
  "Code": [
    {
      "filename": "contracts/helper/LPOracle.sol",
      "content": "// SPDX-License-Identifier: none\npragma solidity 0.8.19;\n\nimport \"../../interfaces/AggregatorV3Interface.sol\";\n\ninterface UniswapV2Pair {\n  function totalSupply() external view returns (uint);\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n  function token0() external view returns (address);\n  function token1() external view returns (address);\n}\n\ninterface IERC20 {\n  function decimals() external view returns (uint8);\n}\n\ncontract LPOracle {\n  /* Matic Network Settings */\n  AggregatorV3Interface public immutable CL_TOKENA;\n  AggregatorV3Interface public immutable CL_TOKENB;\n  UniswapV2Pair public immutable LP_TOKEN;\n\tuint8 public immutable decimalsA;\n\tuint8 public immutable decimalsB;\n\n\t/// @param lpToken UNI-LP token\n\t/// @param clToken0 Underlying token0 ChainLink feed\n\t/// @param clToken1 Underlying token1 ChainLink feed\n\tconstructor (address lpToken, address clToken0, address clToken1 ){\n    require(lpToken != address(0x0) && clToken0 != address(0x0) && clToken1 != address(0x0), \"Invalid address\");\n\t\tLP_TOKEN = UniswapV2Pair(lpToken);\n\t\tCL_TOKENA = AggregatorV3Interface(clToken0);\n\t\tCL_TOKENB = AggregatorV3Interface(clToken1);\n\t\tdecimalsA = IERC20(UniswapV2Pair(lpToken).token0()).decimals();\n\t\tdecimalsB = IERC20(UniswapV2Pair(lpToken).token1()).decimals();\n\t}\n\n  /// @notice Get oracle decimals\n  function decimals() external pure returns (uint8) {\n    return 8;\n  }\n\n  /// @notice Calculate a square root \n  /// @param y Square root variable\n  function sqrt(uint x) internal pure returns (uint y) {\n    uint z = (x + 1) / 2;\n    y = x;\n    while (z < y) {\n      y = z;\n      z = (x / z + z) / 2;\n    }\n  }\n\n  /// @notice Get the price for the latest available round of a feed\n  /// @param priceFeed Price feed\n  /// @return Latest price\n  function getAnswer(AggregatorV3Interface priceFeed) internal view returns (int256) {\n    (\n      , \n      int price,\n      ,\n      uint timeStamp,\n    ) = priceFeed.latestRoundData();\n    require(timeStamp > 0, \"Round not complete\");\n    return price;\n  }\n\n  /// @notice Get the oracle price for the latest available round\n  /// @return Latest price\n  function latestAnswer() external view returns (int256) {\n    (uint a, uint b,) = LP_TOKEN.getReserves();\n\n    uint priceA = uint(getAnswer(CL_TOKENA));\n    uint priceB = uint(getAnswer(CL_TOKENB));\n    /*\n      a and b represents the amounts of asset0 and asset1 in the LP\n      In the uniswap AMM model, a*b is always a constant k (ignoring fees)\n      norm_a, norm_b represents a, b adjusted along the k curve such that it represents the amounts the uniswap pool will contain at the Chainlink oracle price \n  \n      a*b = k = norm_a*norm_b\n      norm_a * cl_price_a / decimals_a = norm_b * cl_price_b / decimals_b\n      norm_b^2 = a*b * cl_price_a / decimals_a * decimals_b / cl_price_b\n    */\n    \n    // Below line may potentially overflow, e.g. for TRIBE-FEI pair, where numA * numB *priceA * 10**18 > 2**256-1\n    // uint norm_b = sqrt( a * b * priceA * 10**decimalsB / 10**decimalsA / priceB ); \n    \n    // Code below attempts to relief some common overflow potential\n    uint norm_b;\n    if (decimalsB >= decimalsA) {\n      norm_b = sqrt( a * b * priceA * 10**(decimalsB-decimalsA) / priceB );\n    } else {\n      norm_b = sqrt( a * b * priceA / 10**(decimalsA-decimalsB) / priceB );\n    }\n    uint norm_a = a * b / norm_b;\n\n    /*\n      The normalised positions (18 decimals) are multiplied with the chainlink value (8 decimals), giving val.\n      val is divided by LP_TOKEN.totalSupply(), which has 18 decimals, and casted to an int\n      The return value represents the value * 10**8 of a single LP token \n    */\n    require(decimalsA <= 18 && decimalsB <= 18, \"Incorrect tokens\");\n    uint val = norm_a * priceA * 10**(18-decimalsA) + norm_b * 10**(18-decimalsB) * priceB;\n    return int(val / LP_TOKEN.totalSupply());\n  }\n}"
    },
    {
      "filename": "contracts/RoeRouter.sol",
      "content": "// SPDX-License-Identifier: none\npragma solidity 0.8.19;\n\nimport \"./openzeppelin-solidity/contracts/access/Ownable.sol\";\n\n\n/**\n * Contract RoeRouter holds a list of whitelisted ROE lending pools and important parameters\n */\ncontract RoeRouter is Ownable {\n  /// EVENTS\n  event AddPool(uint poolId, address lendingPoolAddressProvider);\n  event DeprecatePool(uint poolId);\n  event UpdateTreasury(address treasury);\n\n  /// ROE treasury\n  address public treasury;\n\n  /// List of pools\n  RoePool[] public pools;\n\n  /// Lending pool structure\n  struct RoePool {\n    address lendingPoolAddressProvider;\n    address token0;\n    address token1;\n    address ammRouter;\n    bool isDeprecated;\n  }\n  \n  \n  /// @notice constructor\n  constructor (address treasury_) {\n    require(treasury_ != address(0x0), \"Invalid address\");\n    treasury = treasury_;\n  }\n  \n  \n  /// @notice Return pool list length\n  function getPoolsLength() public view returns (uint poolLength) {\n    poolLength = pools.length;\n  }\n  \n  \n  /// @notice Deprecate a pool\n  /// @param poolId pool ID\n  /// @dev isDeprecated is a statement about the pool record, and does not imply anything about the pool itself\n  function deprecatePool(uint poolId) public onlyOwner {\n    pools[poolId].isDeprecated = true;\n    emit DeprecatePool(poolId);\n  }\n  \n  \n  /// @notice Add a new pool parameters\n  /// @param lendingPoolAddressProvider address of a ROE Aave-compatible lending pool address provider\n  /// @param token0 address of the one token of the pair \n  /// @param token1 address of the second token of the pair\n  /// @param ammRouter address of the AMMv2 such that the LP pair ammRouter.factory.getPair(token0, token1) is supported by the lending pool\n  function addPool(\n    address lendingPoolAddressProvider, \n    address token0, \n    address token1, \n    address ammRouter\n  ) \n    public onlyOwner \n    returns (uint poolId)\n  {\n    require (\n      lendingPoolAddressProvider != address(0x0) \n      && token0 != address(0x0) \n      && token1 != address(0x0) \n      && ammRouter != address(0x0), \n      \"Invalid Address\"\n    );\n    require(token0 < token1, \"Invalid Order\");\n    pools.push(RoePool(lendingPoolAddressProvider, token0, token1, ammRouter, false));\n    poolId = pools.length - 1;\n    emit AddPool(poolId, lendingPoolAddressProvider);\n  }\n  \n  /// @notice Modify treaury address\n  /// @param newTreasury New treasury address\n  function setTreasury(address newTreasury) public onlyOwner {\n    require(newTreasury != address(0x0), \"Invalid address\");\n    treasury = newTreasury;\n    emit UpdateTreasury(newTreasury);\n  }\n}"
    }
  ]
}