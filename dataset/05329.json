{
  "Title": "[G-02] Redundant state variable getters",
  "Content": "Getters for public state variables are automatically generated by the solidity compiler so there is no need to code them manually as this increases deployment cost.\n### Please note these instances were not included in the bot reports.\n\n### 2 Instances\n1. ### Make `mapUnits` mapping variable `private` or `internal` since a getter function was defined for it.\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/UnitRegistry.sol#L33\n\nThe solidity compiler would automatically create a getter function for the `mapUnits` mapping since it is declared as a `public` variable but a getter function `getUnit()` was also declared in the contract for the same variable thereby making it two getter functions for the same variable in the contract. We could rectify this issue by making the `mapUnits` variable private or internal (if the variable is to be inherited). The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: registries/contracts/UnitRegistry.sol\n\n33:     mapping(uint256 => Unit) public mapUnits;      //@audit make private or internal\n.\n.\n.\n152:    function getUnit(uint256 unitId) external view virtual returns (Unit memory unit) {\n153:        unit = mapUnits[unitId];\n154:    }\n```\n\n```diff\ndiff --git a/registries/contracts/UnitRegistry.sol b/registries/contracts/UnitRegistry.sol\nindex 80b3235..afb54b9 100644\n--- a/registries/contracts/UnitRegistry.sol\n+++ b/registries/contracts/UnitRegistry.sol\n@@ -30,7 +30,7 @@ abstract contract UnitRegistry is GenericRegistry {\n     // Map of unit Id => set of subcomponents (possible to derive from any registry)\n     mapping(uint256 => uint32[]) public mapSubComponents;\n     // Map of unit Id => unit\n-    mapping(uint256 => Unit) public mapUnits;\n+    mapping(uint256 => Unit) internal mapUnits;\n\n     constructor(UnitType _unitType) {\n         unitType = _unitType;\n```\n</details>\n\n2. ### Make `mapBlacklistedDonators` mapping variable `private` or `internal` since a getter function was defined for it.\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/DonatorBlacklist.sol#L82-#L84\n\nThe solidity compiler would automatically create a getter function for the `mapBlacklistedDonators` mapping since it is declared as a `public` variable but a getter function `isDonatorBlacklisted()` was also declared in the contract for the same variable thereby making it two getter functions for the same variable in the contract. We could rectify this issue by making the `mapBlacklistedDonators` variable private or internal (if the variable is to be inherited). The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: tokenomics/contracts/DonatorBlacklist.sol\n\n27:    mapping(address => bool) public mapBlacklistedDonators;      //@audit make private or internal\n.\n.\n.\n82:    function isDonatorBlacklisted(address account) external view returns (bool status) {\n83:        status = mapBlacklistedDonators[account];\n84:    }\n```\n\n```diff\ndiff --git a/tokenomics/contracts/DonatorBlacklist.sol b/tokenomics/contracts/DonatorBlacklist.sol\nindex 00d84f4..f173321 100644\n--- a/tokenomics/contracts/DonatorBlacklist.sol\n+++ b/tokenomics/contracts/DonatorBlacklist.sol\n@@ -24,7 +24,7 @@ contract DonatorBlacklist {\n     // Owner address\n     address public owner;\n     // Mapping account address => blacklisting status\n-    mapping(address => bool) public mapBlacklistedDonators;\n+    mapping(address => bool) internal mapBlacklistedDonators;\n\n     /// @dev DonatorBlacklist constructor.\n     constructor() {\n```\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "registries/contracts/UnitRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"./GenericRegistry.sol\";\n\n/// @title Unit Registry - Smart contract for registering generalized units / units\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\nabstract contract UnitRegistry is GenericRegistry {\n    event CreateUnit(uint256 unitId, UnitType uType, bytes32 unitHash);\n    event UpdateUnitHash(uint256 unitId, UnitType uType, bytes32 unitHash);\n\n    enum UnitType {\n        Component,\n        Agent\n    }\n\n    // Unit parameters\n    struct Unit {\n        // Primary IPFS hash of the unit\n        bytes32 unitHash;\n        // Set of component dependencies (agents are also based on components)\n        // We assume that the system is expected to support no more than 2^32-1 components\n        uint32[] dependencies;\n    }\n\n    // Type of the unit: component or unit\n    UnitType public immutable unitType;\n    // Map of unit Id => set of updated IPFS hashes\n    mapping(uint256 => bytes32[]) public mapUnitIdHashes;\n    // Map of unit Id => set of subcomponents (possible to derive from any registry)\n    mapping(uint256 => uint32[]) public mapSubComponents;\n    // Map of unit Id => unit\n    mapping(uint256 => Unit) public mapUnits;\n\n    constructor(UnitType _unitType) {\n        unitType = _unitType;\n    }\n\n    /// @dev Checks the provided component dependencies.\n    /// @param dependencies Set of component dependencies.\n    /// @param maxUnitId Maximum unit Id.\n    function _checkDependencies(uint32[] memory dependencies, uint32 maxUnitId) internal virtual;\n\n    /// @dev Creates unit.\n    /// @param unitOwner Owner of the unit.\n    /// @param unitHash IPFS CID hash of the unit.\n    /// @param dependencies Set of unit dependencies in a sorted ascending order (unit Ids).\n    /// @return unitId The id of a minted unit.\n    function create(address unitOwner, bytes32 unitHash, uint32[] memory dependencies)\n        external virtual returns (uint256 unitId)\n    {\n        // Reentrancy guard\n        if (_locked > 1) {\n            revert ReentrancyGuard();\n        }\n        _locked = 2;\n\n        // Check for the manager privilege for a unit creation\n        if (manager != msg.sender) {\n            revert ManagerOnly(msg.sender, manager);\n        }\n\n        // Checks for a non-zero owner address\n        if(unitOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        // Check for the non-zero hash value\n        if (unitHash == 0) {\n            revert ZeroValue();\n        }\n        \n        // Check for dependencies validity: must be already allocated, must not repeat\n        unitId = totalSupply;\n        _checkDependencies(dependencies, uint32(unitId));\n\n        // Unit with Id = 0 is left empty not to do additional checks for the index zero\n        unitId++;\n\n        // Initialize the unit and mint its token\n        Unit storage unit = mapUnits[unitId];\n        unit.unitHash = unitHash;\n        unit.dependencies = dependencies;\n\n        // Update the map of subcomponents with calculated subcomponents for the new unit Id\n        // In order to get the correct set of subcomponents, we need to differentiate between the callers of this function\n        // Self contract (unit registry) can only call subcomponents calculation from the component level\n        uint32[] memory subComponentIds = _calculateSubComponents(UnitType.Component, dependencies);\n        // We need to add a current component Id to the set of subcomponents if the unit is a component\n        // For example, if component 3 (c3) has dependencies of [c1, c2], then the subcomponents will return [c1, c2].\n        // The resulting set will be [c1, c2, c3]. So we write into the map of component subcomponents: c3=>[c1, c2, c3].\n        // This is done such that the subcomponents start getting explored, and when the agent calls its subcomponents,\n        // it would have [c1, c2, c3] right away instead of adding c3 manually and then (for services) checking\n        // if another agent also has c3 as a component dependency. The latter will consume additional computation.\n        if (unitType == UnitType.Component) {\n            uint256 numSubComponents = subComponentIds.length;\n            uint32[] memory addSubComponentIds = new uint32[](numSubComponents + 1);\n            for (uint256 i = 0; i < numSubComponents; ++i) {\n                addSubComponentIds[i] = subComponentIds[i];\n            }\n            // Adding self component Id\n            addSubComponentIds[numSubComponents] = uint32(unitId);\n            subComponentIds = addSubComponentIds;\n        }\n        mapSubComponents[unitId] = subComponentIds;\n\n        // Set total supply to the unit Id number\n        totalSupply = unitId;\n        // Safe mint is needed since contracts can create units as well\n        _safeMint(unitOwner, unitId);\n\n        emit CreateUnit(unitId, unitType, unitHash);\n        _locked = 1;\n    }\n\n    /// @dev Updates the unit hash.\n    /// @param unitOwner Owner of the unit.\n    /// @param unitId Unit Id.\n    /// @param unitHash Updated IPFS hash of the unit.\n    /// @return success True, if function executed successfully.\n    function updateHash(address unitOwner, uint256 unitId, bytes32 unitHash) external virtual\n        returns (bool success)\n    {\n        // Check the manager privilege for a unit modification\n        if (manager != msg.sender) {\n            revert ManagerOnly(msg.sender, manager);\n        }\n\n        // Checking the unit ownership\n        if (ownerOf(unitId) != unitOwner) {\n            if (unitType == UnitType.Component) {\n                revert ComponentNotFound(unitId);\n            } else {\n                revert AgentNotFound(unitId);\n            }\n        }\n\n        // Check for the hash value\n        if (unitHash == 0) {\n            revert ZeroValue();\n        }\n\n        mapUnitIdHashes[unitId].push(unitHash);\n        success = true;\n\n        emit UpdateUnitHash(unitId, unitType, unitHash);\n    }\n\n    /// @dev Gets the unit instance.\n    /// @param unitId Unit Id.\n    /// @return unit Corresponding Unit struct.\n    function getUnit(uint256 unitId) external view virtual returns (Unit memory unit) {\n        unit = mapUnits[unitId];\n    }\n\n    /// @dev Gets unit dependencies.\n    /// @param unitId Unit Id.\n    /// @return numDependencies The number of units in the dependency list.\n    /// @return dependencies The list of unit dependencies.\n    function getDependencies(uint256 unitId) external view virtual\n        returns (uint256 numDependencies, uint32[] memory dependencies)\n    {\n        Unit memory unit = mapUnits[unitId];\n        return (unit.dependencies.length, unit.dependencies);\n    }\n\n    /// @dev Gets updated unit hashes.\n    /// @param unitId Unit Id.\n    /// @return numHashes Number of hashes.\n    /// @return unitHashes The list of updated unit hashes (without the primary one).\n    function getUpdatedHashes(uint256 unitId) external view virtual\n        returns (uint256 numHashes, bytes32[] memory unitHashes)\n    {\n        unitHashes = mapUnitIdHashes[unitId];\n        return (unitHashes.length, unitHashes);\n    }\n\n    /// @dev Gets the set of subcomponent Ids from a local map of subcomponent.\n    /// @param unitId Component Id.\n    /// @return subComponentIds Set of subcomponent Ids.\n    /// @return numSubComponents Number of subcomponents.\n    function getLocalSubComponents(uint256 unitId) external view\n        returns (uint32[] memory subComponentIds, uint256 numSubComponents)\n    {\n        subComponentIds = mapSubComponents[uint256(unitId)];\n        numSubComponents = subComponentIds.length;\n    }\n\n    /// @dev Gets subcomponents of a provided unit Id.\n    /// @param subcomponentsFromType Type of the unit: component or agent.\n    /// @param unitId Unit Id.\n    /// @return subComponentIds Set of subcomponents.\n    function _getSubComponents(UnitType subcomponentsFromType, uint32 unitId) internal view virtual\n        returns (uint32[] memory subComponentIds);\n\n    /// @dev Calculates the set of subcomponent Ids.\n    /// @param subcomponentsFromType Type of the unit: component or agent.\n    /// @param unitIds Unit Ids.\n    /// @return subComponentIds Subcomponent Ids.\n    function _calculateSubComponents(UnitType subcomponentsFromType, uint32[] memory unitIds) internal view virtual\n        returns (uint32[] memory subComponentIds)\n    {\n        uint32 numUnits = uint32(unitIds.length);\n        // Array of numbers of components per each unit Id\n        uint32[] memory numComponents = new uint32[](numUnits);\n        // 2D array of all the sets of components per each unit Id\n        uint32[][] memory components = new uint32[][](numUnits);\n\n        // Get total possible number of components and lists of components\n        uint32 maxNumComponents;\n        for (uint32 i = 0; i < numUnits; ++i) {\n            // Get subcomponents for each unit Id based on the subcomponentsFromType\n            components[i] = _getSubComponents(subcomponentsFromType, unitIds[i]);\n            numComponents[i] = uint32(components[i].length);\n            maxNumComponents += numComponents[i];\n        }\n\n        // Lists of components are sorted, take unique values in ascending order\n        uint32[] memory allComponents = new uint32[](maxNumComponents);\n        // Processed component counter\n        uint32[] memory processedComponents = new uint32[](numUnits);\n        // Minimal component Id\n        uint32 minComponent;\n        // Overall component counter\n        uint32 counter;\n        // Iterate until we process all components, at the maximum of the sum of all the components in all units\n        for (counter = 0; counter < maxNumComponents; ++counter) {\n            // Index of a minimal component\n            uint32 minIdxComponent;\n            // Amount of components identified as the next minimal component number\n            uint32 numComponentsCheck;\n            uint32 tryMinComponent = type(uint32).max;\n            // Assemble an array of all first components from each component array\n            for (uint32 i = 0; i < numUnits; ++i) {\n                // Either get a component that has a higher id than the last one ore reach the end of the processed Ids\n                for (; processedComponents[i] < numComponents[i]; ++processedComponents[i]) {\n                    if (minComponent < components[i][processedComponents[i]]) {\n                        // Out of those component Ids that are higher than the last one, pick the minimal one\n                        if (components[i][processedComponents[i]] < tryMinComponent) {\n                            tryMinComponent = components[i][processedComponents[i]];\n                            minIdxComponent = i;\n                        }\n                        // If we found a minimal component Id, we increase the counter and break to start the search again\n                        numComponentsCheck++;\n                        break;\n                    }\n                }\n            }\n            minComponent = tryMinComponent;\n\n            // If minimal component Id is greater than the last one, it should be added, otherwise we reached the end\n            if (numComponentsCheck > 0) {\n                allComponents[counter] = minComponent;\n                processedComponents[minIdxComponent]++;\n            } else {\n                break;\n            }\n        }\n\n        // Return the exact set of found subcomponents with the counter length\n        subComponentIds = new uint32[](counter);\n        for (uint32 i = 0; i < counter; ++i) {\n            subComponentIds[i] = allComponents[i];\n        }\n    }\n\n    /// @dev Gets the hash of the unit.\n    /// @param unitId Unit Id.\n    /// @return Unit hash.\n    function _getUnitHash(uint256 unitId) internal view override returns (bytes32) {\n        return mapUnits[unitId].unitHash;\n    }\n}"
    },
    {
      "filename": "tokenomics/contracts/DonatorBlacklist.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/// @dev Only `owner` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param owner Required sender address as an owner.\nerror OwnerOnly(address sender, address owner);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n/// @dev Wrong length of two arrays.\n/// @param numValues1 Number of values in a first array.\n/// @param numValues2 Number of values in a second array.\nerror WrongArrayLength(uint256 numValues1, uint256 numValues2);\n\n/// @title DonatorBlacklist - Smart contract for donator address blacklisting\n/// @author AL\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\ncontract DonatorBlacklist {\n    event OwnerUpdated(address indexed owner);\n    event DonatorBlacklistStatus(address indexed account, bool status);\n\n    // Owner address\n    address public owner;\n    // Mapping account address => blacklisting status\n    mapping(address => bool) public mapBlacklistedDonators;\n\n    /// @dev DonatorBlacklist constructor.\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for the zero address\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Controls donators blacklisting statuses.\n    /// @notice Donator is considered blacklisted if its status is set to true.\n    /// @param accounts Set of account addresses.\n    /// @param statuses Set blacklisting statuses.\n    /// @return success True, if the function executed successfully.\n    function setDonatorsStatuses(address[] memory accounts, bool[] memory statuses) external returns (bool success) {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for the array length\n        if (accounts.length != statuses.length) {\n            revert WrongArrayLength(accounts.length, statuses.length);\n        }\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            // Check for the zero address\n            if (accounts[i] == address(0)) {\n                revert ZeroAddress();\n            }\n            // Set the account blacklisting status\n            mapBlacklistedDonators[accounts[i]] = statuses[i];\n            emit DonatorBlacklistStatus(accounts[i], statuses[i]);\n        }\n        success = true;\n    }\n\n    /// @dev Gets account blacklisting status.\n    /// @param account Account address.\n    /// @return status Blacklisting status.\n    function isDonatorBlacklisted(address account) external view returns (bool status) {\n        status = mapBlacklistedDonators[account];\n    }\n}"
    }
  ]
}