{
  "Title": "[L-02] A users tokens can be stolen if they don't control `msg.sender` address on all chains",
  "Content": "\nWhen a user wants to register a token for use across chains they first call [`InterchainTokenService::deployAndRegisterStandardizedToken`](https://github.com/code-423n4/2023-07-axelar/blob/main/contracts/its/interchain-token-service/InterchainTokenService.sol#L388-L402) on the \"local\" chain. This will use a user provided salt together with the `msg.sender` to [create the `tokenId`](https://github.com/code-423n4/2023-07-axelar/blob/main/contracts/its/interchain-token-service/InterchainTokenService.sol#L396) which is used as the salt to create both the [`StandardizedToken`](https://github.com/code-423n4/2023-07-axelar/blob/main/contracts/its/interchain-token-service/InterchainTokenService.sol#L397) and the [`TokenManager`](https://github.com/code-423n4/2023-07-axelar/blob/main/contracts/its/interchain-token-service/InterchainTokenService.sol#L401).\n\nThey can then use this to deploy their token to any chain that Axelar supports.\n\nRelying on `msg.sender` across chain comes with some security considerations though. If the user/protocol don't control the address used as `msg.sender` across all chains that are supported by Axelar ITS, they are susceptible to the same hack that affected [wintermute](https://rekt.news/wintermute-rekt/); where an old gnosis wallet was used that had an address that could be stolen on another chain.\n\nIf an attacker controls the `msg.sender` address on another chain, they can simply create a token and manager with the same salt that they control. This will give them the same `tokenId`. They can then send a message to the chain where the real token is and get funded real tokens. All they've done is burn/lock their fake token on their `sourceChain`. \n\n### Recommendation\nI recommend this is highlighted as a risk in the documentation so third party protocols building on top of Axelar are aware of this risk. \n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/its/interchain-token-service/InterchainTokenService.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarGateway } from '../../gmp-sdk/interfaces/IAxelarGateway.sol';\nimport { IAxelarGasService } from '../../gmp-sdk/interfaces/IAxelarGasService.sol';\nimport { AxelarExecutable } from '../../gmp-sdk/executable/AxelarExecutable.sol';\nimport { SafeTokenTransferFrom } from '../../gmp-sdk/util/SafeTransfer.sol';\nimport { IERC20 } from '../../gmp-sdk/interfaces/IERC20.sol';\n\nimport { IInterchainTokenService } from '../interfaces/IInterchainTokenService.sol';\nimport { ITokenManagerDeployer } from '../interfaces/ITokenManagerDeployer.sol';\nimport { IStandardizedTokenDeployer } from '../interfaces/IStandardizedTokenDeployer.sol';\nimport { IRemoteAddressValidator } from '../interfaces/IRemoteAddressValidator.sol';\nimport { IInterchainTokenExpressExecutable } from '../interfaces/IInterchainTokenExpressExecutable.sol';\nimport { ITokenManager } from '../interfaces/ITokenManager.sol';\nimport { ITokenManagerProxy } from '../interfaces/ITokenManagerProxy.sol';\nimport { IERC20Named } from '../interfaces/IERC20Named.sol';\n\nimport { AddressBytesUtils } from '../libraries/AddressBytesUtils.sol';\nimport { StringToBytes32, Bytes32ToString } from '../../gmp-sdk/util/Bytes32String.sol';\n\nimport { Upgradable } from '../../gmp-sdk/upgradable/Upgradable.sol';\nimport { Create3Deployer } from '../../gmp-sdk/deploy/Create3Deployer.sol';\n\nimport { ExpressCallHandler } from '../utils/ExpressCallHandler.sol';\nimport { Pausable } from '../utils/Pausable.sol';\nimport { Operatable } from '../utils/Operatable.sol';\nimport { Multicall } from '../utils/Multicall.sol';\n\n/**\n * @title The Interchain Token Service\n * @notice This contract is responsible for facilitating cross chain token transfers.\n * It (mostly) does not handle tokens, but is responsible for the messaging that needs to occur for cross chain transfers to happen.\n * @dev The only storage used here is for ExpressCalls\n */\ncontract InterchainTokenService is\n    IInterchainTokenService,\n    AxelarExecutable,\n    Upgradable,\n    Operatable,\n    ExpressCallHandler,\n    Pausable,\n    Multicall\n{\n    using StringToBytes32 for string;\n    using Bytes32ToString for bytes32;\n    using AddressBytesUtils for bytes;\n    using AddressBytesUtils for address;\n\n    address internal immutable implementationLockUnlock;\n    address internal immutable implementationMintBurn;\n    address internal immutable implementationLiquidityPool;\n    IAxelarGasService public immutable gasService;\n    IRemoteAddressValidator public immutable remoteAddressValidator;\n    address public immutable tokenManagerDeployer;\n    address public immutable standardizedTokenDeployer;\n    Create3Deployer internal immutable deployer;\n    bytes32 internal immutable chainNameHash;\n    bytes32 internal immutable chainName;\n\n    bytes32 internal constant PREFIX_CUSTOM_TOKEN_ID = keccak256('its-custom-token-id');\n    bytes32 internal constant PREFIX_STANDARDIZED_TOKEN_ID = keccak256('its-standardized-token-id');\n    bytes32 internal constant PREFIX_STANDARDIZED_TOKEN_SALT = keccak256('its-standardized-token-salt');\n\n    uint256 private constant SELECTOR_SEND_TOKEN = 1;\n    uint256 private constant SELECTOR_SEND_TOKEN_WITH_DATA = 2;\n    uint256 private constant SELECTOR_DEPLOY_TOKEN_MANAGER = 3;\n    uint256 private constant SELECTOR_DEPLOY_AND_REGISTER_STANDARDIZED_TOKEN = 4;\n\n    bytes32 private constant CONTRACT_ID = keccak256('interchain-token-service');\n\n    /**\n     * @dev All of the varaibles passed here are stored as immutable variables.\n     * @param tokenManagerDeployer_ the address of the TokenManagerDeployer.\n     * @param standardizedTokenDeployer_ the address of the StandardizedTokenDeployer.\n     * @param gateway_ the address of the AxelarGateway.\n     * @param gasService_ the address of the AxelarGasService.\n     * @param remoteAddressValidator_ the address of the RemoteAddressValidator.\n     * @param tokenManagerImplementations this need to have exactly 3 implementations in the following order: Lock/Unlock, mint/burn and then liquidity pool.\n     * @param chainName_ the name of the current chain.\n     */\n    constructor(\n        address tokenManagerDeployer_,\n        address standardizedTokenDeployer_,\n        address gateway_,\n        address gasService_,\n        address remoteAddressValidator_,\n        address[] memory tokenManagerImplementations,\n        string memory chainName_\n    ) AxelarExecutable(gateway_) {\n        if (\n            remoteAddressValidator_ == address(0) ||\n            gasService_ == address(0) ||\n            tokenManagerDeployer_ == address(0) ||\n            standardizedTokenDeployer_ == address(0)\n        ) revert ZeroAddress();\n        remoteAddressValidator = IRemoteAddressValidator(remoteAddressValidator_);\n        gasService = IAxelarGasService(gasService_);\n        tokenManagerDeployer = tokenManagerDeployer_;\n        standardizedTokenDeployer = standardizedTokenDeployer_;\n        deployer = ITokenManagerDeployer(tokenManagerDeployer_).deployer();\n\n        if (tokenManagerImplementations.length != uint256(type(TokenManagerType).max) + 1) revert LengthMismatch();\n\n        implementationLockUnlock = _sanitizeTokenManagerImplementation(tokenManagerImplementations, TokenManagerType.LOCK_UNLOCK);\n        implementationMintBurn = _sanitizeTokenManagerImplementation(tokenManagerImplementations, TokenManagerType.MINT_BURN);\n        implementationLiquidityPool = _sanitizeTokenManagerImplementation(tokenManagerImplementations, TokenManagerType.LIQUIDITY_POOL);\n\n        chainName = chainName_.toBytes32();\n        chainNameHash = keccak256(bytes(chainName_));\n    }\n\n    /*******\\\n    MODIFIERS\n    \\*******/\n\n    /**\n     * @notice This modifier is used to ensure that only a remote InterchainTokenService can _execute this one.\n     * @param sourceChain the source of the contract call.\n     * @param sourceAddress the address that the call came from.\n     */\n    modifier onlyRemoteService(string calldata sourceChain, string calldata sourceAddress) {\n        if (!remoteAddressValidator.validateSender(sourceChain, sourceAddress)) revert NotRemoteService();\n        _;\n    }\n\n    /**\n     * @notice This modifier is used to ensure certain functions can only be called by TokenManagers.\n     * @param tokenId the `tokenId` of the TokenManager trying to perform the call.\n     */\n    modifier onlyTokenManager(bytes32 tokenId) {\n        if (msg.sender != getTokenManagerAddress(tokenId)) revert NotTokenManager();\n        _;\n    }\n\n    /*****\\\n    GETTERS\n    \\*****/\n\n    /**\n     * @notice Getter for the contract id.\n     */\n    function contractId() external pure returns (bytes32) {\n        return CONTRACT_ID;\n    }\n\n    /**\n     * @notice Getter for the chain name.\n     * @return name the name of the chain\n     */\n    function getChainName() public view returns (string memory name) {\n        name = chainName.toTrimmedString();\n    }\n\n    /**\n     * @notice Calculates the address of a TokenManager from a specific tokenId. The TokenManager does not need to exist already.\n     * @param tokenId the tokenId.\n     * @return tokenManagerAddress deployement address of the TokenManager.\n     */\n    function getTokenManagerAddress(bytes32 tokenId) public view returns (address tokenManagerAddress) {\n        tokenManagerAddress = deployer.deployedAddress(address(this), tokenId);\n    }\n\n    /**\n     * @notice Returns the address of a TokenManager from a specific tokenId. The TokenManager needs to exist already.\n     * @param tokenId the tokenId.\n     * @return tokenManagerAddress deployment address of the TokenManager.\n     */\n    function getValidTokenManagerAddress(bytes32 tokenId) public view returns (address tokenManagerAddress) {\n        tokenManagerAddress = getTokenManagerAddress(tokenId);\n        if (ITokenManagerProxy(tokenManagerAddress).tokenId() != tokenId) revert TokenManagerDoesNotExist(tokenId);\n    }\n\n    /**\n     * @notice Returns the address of the token that an existing tokenManager points to.\n     * @param tokenId the tokenId.\n     * @return tokenAddress the address of the token.\n     */\n    function getTokenAddress(bytes32 tokenId) external view returns (address tokenAddress) {\n        address tokenManagerAddress = getValidTokenManagerAddress(tokenId);\n        tokenAddress = ITokenManager(tokenManagerAddress).tokenAddress();\n    }\n\n    /**\n     * @notice Returns the address of the standardized token that would be deployed with a given tokenId.\n     * The token does not need to exist.\n     * @param tokenId the tokenId.\n     * @return tokenAddress the address of the standardized token.\n     */\n    function getStandardizedTokenAddress(bytes32 tokenId) public view returns (address tokenAddress) {\n        tokenId = _getStandardizedTokenSalt(tokenId);\n        tokenAddress = deployer.deployedAddress(address(this), tokenId);\n    }\n\n    /**\n     * @notice Calculates the tokenId that would correspond to a canonical link for a given token.\n     * This will depend on what chain it is called from, unlike custom tokenIds.\n     * @param tokenAddress the address of the token.\n     * @return tokenId the tokenId that the canonical TokenManager would get (or has gotten) for the token.\n     */\n    function getCanonicalTokenId(address tokenAddress) public view returns (bytes32 tokenId) {\n        tokenId = keccak256(abi.encode(PREFIX_STANDARDIZED_TOKEN_ID, chainNameHash, tokenAddress));\n    }\n\n    /**\n     * @notice Calculates the tokenId that would correspond to a custom link for a given deployer with a specified salt.\n     * This will not depend on what chain it is called from, unlike canonical tokenIds.\n     * @param sender the address of the TokenManager deployer.\n     * @param salt the salt that the deployer uses for the deployment.\n     * @return tokenId the tokenId that the custom TokenManager would get (or has gotten).\n     */\n    function getCustomTokenId(address sender, bytes32 salt) public pure returns (bytes32 tokenId) {\n        tokenId = keccak256(abi.encode(PREFIX_CUSTOM_TOKEN_ID, sender, salt));\n    }\n\n    /**\n     * @notice Getter function for TokenManager implementations. This will mainly be called by TokenManagerProxies\n     * to figure out their implementations\n     * @param tokenManagerType the type of the TokenManager.\n     * @return tokenManagerAddress the address of the TokenManagerImplementation.\n     */\n    function getImplementation(uint256 tokenManagerType) external view returns (address tokenManagerAddress) {\n        // There could be a way to rewrite the following using assembly switch statements, which would be more gas efficient,\n        // but accessing immutable variables and/or enum values seems to be tricky, and would reduce code readability.\n        if (TokenManagerType(tokenManagerType) == TokenManagerType.LOCK_UNLOCK) {\n            return implementationLockUnlock;\n        } else if (TokenManagerType(tokenManagerType) == TokenManagerType.MINT_BURN) {\n            return implementationMintBurn;\n        } else if (TokenManagerType(tokenManagerType) == TokenManagerType.LIQUIDITY_POOL) {\n            return implementationLiquidityPool;\n        }\n    }\n\n    /**\n     * @notice Getter function for the parameters of a lock/unlock TokenManager. Mainly to be used by frontends.\n     * @param operator the operator of the TokenManager.\n     * @param tokenAddress the token to be managed.\n     * @return params the resulting params to be passed to custom TokenManager deployments.\n     */\n    function getParamsLockUnlock(bytes memory operator, address tokenAddress) public pure returns (bytes memory params) {\n        params = abi.encode(operator, tokenAddress);\n    }\n\n    /**\n     * @notice Getter function for the parameters of a mint/burn TokenManager. Mainly to be used by frontends.\n     * @param operator the operator of the TokenManager.\n     * @param tokenAddress the token to be managed.\n     * @return params the resulting params to be passed to custom TokenManager deployments.\n     */\n    function getParamsMintBurn(bytes memory operator, address tokenAddress) public pure returns (bytes memory params) {\n        params = abi.encode(operator, tokenAddress);\n    }\n\n    /**\n     * @notice Getter function for the parameters of a liquidity pool TokenManager. Mainly to be used by frontends.\n     * @param operator the operator of the TokenManager.\n     * @param tokenAddress the token to be managed.\n     * @param liquidityPoolAddress the liquidity pool to be used to store the bridged tokens.\n     * @return params the resulting params to be passed to custom TokenManager deployments.\n     */\n    function getParamsLiquidityPool(\n        bytes memory operator,\n        address tokenAddress,\n        address liquidityPoolAddress\n    ) public pure returns (bytes memory params) {\n        params = abi.encode(operator, tokenAddress, liquidityPoolAddress);\n    }\n\n    /**\n     * @notice Getter function for the flow limit of an existing token manager with a give token ID.\n     * @param tokenId the token ID of the TokenManager.\n     * @return flowLimit the flow limit.\n     */\n    function getFlowLimit(bytes32 tokenId) external view returns (uint256 flowLimit) {\n        ITokenManager tokenManager = ITokenManager(getValidTokenManagerAddress(tokenId));\n        flowLimit = tokenManager.getFlowLimit();\n    }\n\n    /**\n     * @notice Getter function for the flow out amount of an existing token manager with a give token ID.\n     * @param tokenId the token ID of the TokenManager.\n     * @return flowOutAmount the flow out amount.\n     */\n    function getFlowOutAmount(bytes32 tokenId) external view returns (uint256 flowOutAmount) {\n        ITokenManager tokenManager = ITokenManager(getValidTokenManagerAddress(tokenId));\n        flowOutAmount = tokenManager.getFlowOutAmount();\n    }\n\n    /**\n     * @notice Getter function for the flow in amount of an existing token manager with a give token ID.\n     * @param tokenId the token ID of the TokenManager.\n     * @return flowInAmount the flow in amount.\n     */\n    function getFlowInAmount(bytes32 tokenId) external view returns (uint256 flowInAmount) {\n        ITokenManager tokenManager = ITokenManager(getValidTokenManagerAddress(tokenId));\n        flowInAmount = tokenManager.getFlowInAmount();\n    }\n\n    /************\\\n    USER FUNCTIONS\n    \\************/\n\n    /**\n     * @notice Used to register canonical tokens. Caller does not matter.\n     * @param tokenAddress the token to be bridged.\n     * @return tokenId the tokenId that was used for this canonical token.\n     */\n    function registerCanonicalToken(address tokenAddress) external payable notPaused returns (bytes32 tokenId) {\n        (, string memory tokenSymbol, ) = _validateToken(tokenAddress);\n        if (gateway.tokenAddresses(tokenSymbol) == tokenAddress) revert GatewayToken();\n        tokenId = getCanonicalTokenId(tokenAddress);\n        _deployTokenManager(tokenId, TokenManagerType.LOCK_UNLOCK, abi.encode(address(this).toBytes(), tokenAddress));\n    }\n\n    /**\n     * @notice Used to deploy remote TokenManagers and standardized tokens for a canonical token. This needs to be\n     * called from the chain that registered the canonical token, and anyone can call it.\n     * @param tokenId the tokenId of the canonical token.\n     * @param destinationChain the name of the chain to deploy the TokenManager and standardized token to.\n     * @param gasValue the amount of native tokens to be used to pay for gas for the remote deployment.\n     * At least the amount specified needs to be passed to the call\n     * @dev `gasValue` exists because this function can be part of a multicall involving multiple functions that could make remote contract calls.\n     */\n    function deployRemoteCanonicalToken(\n        bytes32 tokenId,\n        string calldata destinationChain,\n        uint256 gasValue\n    ) public payable notPaused {\n        address tokenAddress = getValidTokenManagerAddress(tokenId);\n        tokenAddress = ITokenManager(tokenAddress).tokenAddress();\n        if (getCanonicalTokenId(tokenAddress) != tokenId) revert NotCanonicalTokenManager();\n        (string memory tokenName, string memory tokenSymbol, uint8 tokenDecimals) = _validateToken(tokenAddress);\n        _deployRemoteStandardizedToken(tokenId, tokenName, tokenSymbol, tokenDecimals, '', '', destinationChain, gasValue);\n    }\n\n    /**\n     * @notice Used to deploy custom TokenManagers with the specified salt. Different callers would result in different tokenIds.\n     * @param salt the salt to be used.\n     * @param tokenManagerType the type of TokenManager to be deployed.\n     * @param params the params that will be used to initialize the TokenManager.\n     */\n    function deployCustomTokenManager(\n        bytes32 salt,\n        TokenManagerType tokenManagerType,\n        bytes memory params\n    ) public payable notPaused returns (bytes32 tokenId) {\n        address deployer_ = msg.sender;\n        tokenId = getCustomTokenId(deployer_, salt);\n        _deployTokenManager(tokenId, tokenManagerType, params);\n        emit CustomTokenIdClaimed(tokenId, deployer_, salt);\n    }\n\n    /**\n     * @notice Used to deploy remote custom TokenManagers.\n     * @param salt the salt to be used.\n     * @param destinationChain the name of the chain to deploy the TokenManager and standardized token to.\n     * @param tokenManagerType the type of TokenManager to be deployed.\n     * @param params the params that will be used to initialize the TokenManager.\n     * @param gasValue the amount of native tokens to be used to pay for gas for the remote deployment. At least\n     * the amount specified needs to be passed to the call\n     * @dev `gasValue` exists because this function can be part of a multicall involving multiple functions\n     * that could make remote contract calls.\n     */\n    function deployRemoteCustomTokenManager(\n        bytes32 salt,\n        string calldata destinationChain,\n        TokenManagerType tokenManagerType,\n        bytes calldata params,\n        uint256 gasValue\n    ) external payable notPaused returns (bytes32 tokenId) {\n        address deployer_ = msg.sender;\n        tokenId = getCustomTokenId(deployer_, salt);\n        _deployRemoteTokenManager(tokenId, destinationChain, gasValue, tokenManagerType, params);\n        emit CustomTokenIdClaimed(tokenId, deployer_, salt);\n    }\n\n    /**\n     * @notice Used to deploy a standardized token alongside a TokenManager. If the `distributor` is the address of the TokenManager (which\n     * can be calculated ahead of time) then a mint/burn TokenManager is used. Otherwise a lock/unlcok TokenManager is used.\n     * @param salt the salt to be used.\n     * @param name the name of the token to be deployed.\n     * @param symbol the symbol of the token to be deployed.\n     * @param decimals the decimals of the token to be deployed.\n     * @param mintAmount the amount of token to be mint during deployment to msg.sender.\n     * @param distributor the address that will be able to mint and burn the deployed token.\n     */\n    function deployAndRegisterStandardizedToken(\n        bytes32 salt,\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals,\n        uint256 mintAmount,\n        address distributor\n    ) external payable notPaused {\n        bytes32 tokenId = getCustomTokenId(msg.sender, salt);\n        _deployStandardizedToken(tokenId, distributor, name, symbol, decimals, mintAmount, msg.sender);\n        address tokenManagerAddress = getTokenManagerAddress(tokenId);\n        TokenManagerType tokenManagerType = distributor == tokenManagerAddress ? TokenManagerType.MINT_BURN : TokenManagerType.LOCK_UNLOCK;\n        address tokenAddress = getStandardizedTokenAddress(tokenId);\n        _deployTokenManager(tokenId, tokenManagerType, abi.encode(msg.sender.toBytes(), tokenAddress));\n    }\n\n    /**\n     * @notice Used to deploy a standardized token alongside a TokenManager in another chain. If the `distributor` is empty\n     * bytes then a mint/burn TokenManager is used. Otherwise a lock/unlcok TokenManager is used.\n     * @param salt the salt to be used.\n     * @param name the name of the token to be deployed.\n     * @param symbol the symbol of the token to be deployed.\n     * @param decimals the decimals of the token to be deployed.\n     * @param distributor the address that will be able to mint and burn the deployed token.\n     * @param destinationChain the name of the destination chain to deploy to.\n     * @param gasValue the amount of native tokens to be used to pay for gas for the remote deployment. At least the amount\n     * specified needs to be passed to the call\n     * @dev `gasValue` exists because this function can be part of a multicall involving multiple functions that could make remote contract calls.\n     */\n    function deployAndRegisterRemoteStandardizedToken(\n        bytes32 salt,\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals,\n        bytes memory distributor,\n        bytes memory operator,\n        string calldata destinationChain,\n        uint256 gasValue\n    ) external payable notPaused {\n        bytes32 tokenId = getCustomTokenId(msg.sender, salt);\n        _deployRemoteStandardizedToken(tokenId, name, symbol, decimals, distributor, operator, destinationChain, gasValue);\n    }\n\n    /**\n     * @notice Uses the caller's tokens to fullfill a sendCall ahead of time. Use this only if you have detected an outgoing\n     * sendToken that matches the parameters passed here.\n     * @param tokenId the tokenId of the TokenManager used.\n     * @param destinationAddress the destinationAddress for the sendToken.\n     * @param amount the amount of token to give.\n     * @param commandId the sendHash detected at the sourceChain.\n     */\n    function expressReceiveToken(\n        bytes32 tokenId,\n        address destinationAddress,\n        uint256 amount,\n        bytes32 commandId\n    ) external {\n        if (gateway.isCommandExecuted(commandId)) revert AlreadyExecuted(commandId);\n\n        address caller = msg.sender;\n        ITokenManager tokenManager = ITokenManager(getValidTokenManagerAddress(tokenId));\n        IERC20 token = IERC20(tokenManager.tokenAddress());\n\n        SafeTokenTransferFrom.safeTransferFrom(token, caller, destinationAddress, amount);\n\n        _setExpressReceiveToken(tokenId, destinationAddress, amount, commandId, caller);\n    }\n\n    /**\n     * @notice Uses the caller's tokens to fullfill a callContractWithInterchainToken ahead of time. Use this only if you have\n     * detected an outgoing sendToken that matches the parameters passed here.\n     * @param tokenId the tokenId of the TokenManager used.\n     * @param sourceChain the name of the chain where the call came from.\n     * @param sourceAddress the caller of callContractWithInterchainToken.\n     * @param destinationAddress the destinationAddress for the sendToken.\n     * @param amount the amount of token to give.\n     * @param data the data to be passed to destinationAddress after giving them the tokens specified.\n     * @param commandId the sendHash detected at the sourceChain.\n     */\n    function expressReceiveTokenWithData(\n        bytes32 tokenId,\n        string memory sourceChain,\n        bytes memory sourceAddress,\n        address destinationAddress,\n        uint256 amount,\n        bytes calldata data,\n        bytes32 commandId\n    ) external {\n        if (gateway.isCommandExecuted(commandId)) revert AlreadyExecuted(commandId);\n\n        address caller = msg.sender;\n        ITokenManager tokenManager = ITokenManager(getValidTokenManagerAddress(tokenId));\n        IERC20 token = IERC20(tokenManager.tokenAddress());\n\n        SafeTokenTransferFrom.safeTransferFrom(token, caller, destinationAddress, amount);\n\n        _expressExecuteWithInterchainTokenToken(tokenId, destinationAddress, sourceChain, sourceAddress, data, amount);\n\n        _setExpressReceiveTokenWithData(tokenId, sourceChain, sourceAddress, destinationAddress, amount, data, commandId, caller);\n    }\n\n    /*********************\\\n    TOKEN MANAGER FUNCTIONS\n    \\*********************/\n\n    /**\n     * @notice Transmit a sendTokenWithData for the given tokenId. Only callable by a token manager.\n     * @param tokenId the tokenId of the TokenManager (which must be the msg.sender).\n     * @param sourceAddress the address where the token is coming from, which will also be used for reimburment of gas.\n     * @param destinationChain the name of the chain to send tokens to.\n     * @param destinationAddress the destinationAddress for the sendToken.\n     * @param amount the amount of token to give.\n     * @param metadata the data to be passed to the destiantion.\n     */\n    function transmitSendToken(\n        bytes32 tokenId,\n        address sourceAddress,\n        string calldata destinationChain,\n        bytes memory destinationAddress,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable onlyTokenManager(tokenId) notPaused {\n        bytes memory payload;\n        if (metadata.length < 4) {\n            payload = abi.encode(SELECTOR_SEND_TOKEN, tokenId, destinationAddress, amount);\n            _callContract(destinationChain, payload, msg.value, sourceAddress);\n            emit TokenSent(tokenId, destinationChain, destinationAddress, amount);\n            return;\n        }\n        uint32 version;\n        (version, metadata) = _decodeMetadata(metadata);\n        if (version > 0) revert InvalidMetadataVersion(version);\n        payload = abi.encode(SELECTOR_SEND_TOKEN_WITH_DATA, tokenId, destinationAddress, amount, sourceAddress.toBytes(), metadata);\n        _callContract(destinationChain, payload, msg.value, sourceAddress);\n        emit TokenSentWithData(tokenId, destinationChain, destinationAddress, amount, sourceAddress, metadata);\n    }\n\n    /*************\\\n    OWNER FUNCTIONS\n    \\*************/\n\n    /**\n     * @notice Used to set a flow limit for a token manager that has the service as its operator.\n     * @param tokenIds an array of the token Ids of the tokenManagers to set the flow limit of.\n     * @param flowLimits the flowLimits to set\n     */\n    function setFlowLimit(bytes32[] calldata tokenIds, uint256[] calldata flowLimits) external onlyOperator {\n        uint256 length = tokenIds.length;\n        if (length != flowLimits.length) revert LengthMismatch();\n        for (uint256 i; i < length; ++i) {\n            ITokenManager tokenManager = ITokenManager(getValidTokenManagerAddress(tokenIds[i]));\n            tokenManager.setFlowLimit(flowLimits[i]);\n        }\n    }\n\n    /**\n     * @notice Used to pause the entire service.\n     * @param paused what value to set paused to.\n     */\n    function setPaused(bool paused) external onlyOwner {\n        _setPaused(paused);\n    }\n\n    /****************\\\n    INTERNAL FUNCTIONS\n    \\****************/\n\n    function _setup(bytes calldata params) internal override {\n        _setOperator(params.toAddress());\n    }\n\n    function _sanitizeTokenManagerImplementation(address[] memory implementaions, TokenManagerType tokenManagerType)\n        internal\n        pure\n        returns (address implementation)\n    {\n        implementation = implementaions[uint256(tokenManagerType)];\n        if (implementation == address(0)) revert ZeroAddress();\n        if (ITokenManager(implementation).implementationType() != uint256(tokenManagerType)) revert InvalidTokenManagerImplementation();\n    }\n\n    /**\n     * @notice Executes operations based on the payload and selector.\n     * @param sourceChain The chain where the transaction originates from\n     * @param sourceAddress The address where the transaction originates from\n     * @param payload The encoded data payload for the transaction\n     */\n    function _execute(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal override onlyRemoteService(sourceChain, sourceAddress) notPaused {\n        uint256 selector = abi.decode(payload, (uint256));\n        if (selector == SELECTOR_SEND_TOKEN) {\n            _processSendTokenPayload(sourceChain, payload);\n        } else if (selector == SELECTOR_SEND_TOKEN_WITH_DATA) {\n            _processSendTokenWithDataPayload(sourceChain, payload);\n        } else if (selector == SELECTOR_DEPLOY_TOKEN_MANAGER) {\n            _processDeployTokenManagerPayload(payload);\n        } else if (selector == SELECTOR_DEPLOY_AND_REGISTER_STANDARDIZED_TOKEN) {\n            _processDeployStandardizedTokenAndManagerPayload(payload);\n        } else {\n            revert SelectorUnknown();\n        }\n    }\n\n    /**\n     * @notice Processes the payload data for a send token call\n     * @param sourceChain The chain where the transaction originates from\n     * @param payload The encoded data payload to be processed\n     */\n    function _processSendTokenPayload(string calldata sourceChain, bytes calldata payload) internal {\n        (, bytes32 tokenId, bytes memory destinationAddressBytes, uint256 amount) = abi.decode(payload, (uint256, bytes32, bytes, uint256));\n        bytes32 commandId;\n\n        assembly {\n            commandId := calldataload(4)\n        }\n        address destinationAddress = destinationAddressBytes.toAddress();\n        ITokenManager tokenManager = ITokenManager(getValidTokenManagerAddress(tokenId));\n        address expressCaller = _popExpressReceiveToken(tokenId, destinationAddress, amount, commandId);\n        if (expressCaller == address(0)) {\n            amount = tokenManager.giveToken(destinationAddress, amount);\n            emit TokenReceived(tokenId, sourceChain, destinationAddress, amount);\n        } else {\n            amount = tokenManager.giveToken(expressCaller, amount);\n        }\n    }\n\n    /**\n     * @notice Processes a send token with data payload.\n     * @param sourceChain The chain where the transaction originates from\n     * @param payload The encoded data payload to be processed\n     */\n    function _processSendTokenWithDataPayload(string calldata sourceChain, bytes calldata payload) internal {\n        bytes32 tokenId;\n        uint256 amount;\n        bytes memory sourceAddress;\n        bytes memory data;\n        address destinationAddress;\n        bytes32 commandId;\n\n        assembly {\n            commandId := calldataload(4)\n        }\n        {\n            bytes memory destinationAddressBytes;\n            (, tokenId, destinationAddressBytes, amount, sourceAddress, data) = abi.decode(\n                payload,\n                (uint256, bytes32, bytes, uint256, bytes, bytes)\n            );\n            destinationAddress = destinationAddressBytes.toAddress();\n        }\n        ITokenManager tokenManager = ITokenManager(getTokenManagerAddress(tokenId));\n        {\n            address expressCaller = _popExpressReceiveTokenWithData(\n                tokenId,\n                sourceChain,\n                sourceAddress,\n                destinationAddress,\n                amount,\n                data,\n                commandId\n            );\n            if (expressCaller != address(0)) {\n                amount = tokenManager.giveToken(expressCaller, amount);\n                return;\n            }\n        }\n        amount = tokenManager.giveToken(destinationAddress, amount);\n        IInterchainTokenExpressExecutable(destinationAddress).executeWithInterchainToken(sourceChain, sourceAddress, data, tokenId, amount);\n        emit TokenReceivedWithData(tokenId, sourceChain, destinationAddress, amount, sourceAddress, data);\n    }\n\n    /**\n     * @notice Processes a deploy token manager payload.\n     * @param payload The encoded data payload to be processed\n     */\n    function _processDeployTokenManagerPayload(bytes calldata payload) internal {\n        (, bytes32 tokenId, TokenManagerType tokenManagerType, bytes memory params) = abi.decode(\n            payload,\n            (uint256, bytes32, TokenManagerType, bytes)\n        );\n        _deployTokenManager(tokenId, tokenManagerType, params);\n    }\n\n    /**\n     * @notice Process a deploy standardized token and manager payload.\n     * @param payload The encoded data payload to be processed\n     */\n    function _processDeployStandardizedTokenAndManagerPayload(bytes calldata payload) internal {\n        (\n            ,\n            bytes32 tokenId,\n            string memory name,\n            string memory symbol,\n            uint8 decimals,\n            bytes memory distributorBytes,\n            bytes memory operatorBytes\n        ) = abi.decode(payload, (uint256, bytes32, string, string, uint8, bytes, bytes));\n        address tokenAddress = getStandardizedTokenAddress(tokenId);\n        address tokenManagerAddress = getTokenManagerAddress(tokenId);\n        address distributor = distributorBytes.length > 0 ? distributorBytes.toAddress() : tokenManage"
    }
  ]
}