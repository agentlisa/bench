{
  "Title": "`vm.prank()` before nested function call in tests does not work as intended",
  "Content": "Foundry's prank cheat code applies to the next external call only. [Nested](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/test/base/VeryFastRouterAllSwapTypes.sol#L1090-L1092) [calls](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/test/base/VeryFastRouterWithRoyalties.sol#L1108-L1110) are evaluated right-to-left, and so the prank is not applied as intended. Either cache necessary function calls as local variables or use `vm.startPrank(addr)` and `vm.stopPrank()`. Extending tests to assert for expected event emissions is recommended and should help to catch cases like this.\n\n**Sudoswap:**\nAcknowledged.\n\n**Cyfrin:**\nAcknowledged.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/test/base/VeryFastRouterAllSwapTypes.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {RoyaltyRegistry} from \"manifoldxyz/RoyaltyRegistry.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {ERC1155Holder} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\n\nimport {Test721} from \"../../mocks/Test721.sol\";\nimport {Test1155} from \"../../mocks/Test1155.sol\";\n\nimport {ConfigurableWithRoyalties} from \"../mixins/ConfigurableWithRoyalties.sol\";\n\nimport {IMintable} from \"../interfaces/IMintable.sol\";\nimport {ICurve} from \"../../bonding-curves/ICurve.sol\";\nimport {IERC721Mintable} from \"../interfaces/IERC721Mintable.sol\";\nimport {IERC1155Mintable} from \"../interfaces/IERC1155Mintable.sol\";\nimport {IPropertyChecker} from \"../../property-checking/IPropertyChecker.sol\";\nimport {RangePropertyChecker} from \"../../property-checking/RangePropertyChecker.sol\";\nimport {MerklePropertyChecker} from \"../../property-checking/MerklePropertyChecker.sol\";\nimport {PropertyCheckerFactory} from \"../../property-checking/PropertyCheckerFactory.sol\";\n\nimport {LSSVMPair} from \"../../LSSVMPair.sol\";\nimport {ILSSVMPair} from \"../../ILSSVMPair.sol\";\nimport {LSSVMRouter} from \"../../LSSVMRouter.sol\";\nimport {RoyaltyEngine} from \"../../RoyaltyEngine.sol\";\nimport {VeryFastRouter} from \"../../VeryFastRouter.sol\";\nimport {LSSVMPairFactory} from \"../../LSSVMPairFactory.sol\";\n\nabstract contract VeryFastRouterAllSwapTypes is Test, ERC721Holder, ERC1155Holder, ConfigurableWithRoyalties {\n    ICurve bondingCurve;\n    RoyaltyEngine royaltyEngine;\n    LSSVMPairFactory pairFactory;\n    PropertyCheckerFactory propertyCheckerFactory;\n    VeryFastRouter router;\n\n    address constant ROUTER_CALLER = address(1);\n    address constant TOKEN_RECIPIENT = address(420);\n    address constant NFT_RECIPIENT = address(0x69);\n\n    uint256 constant START_INDEX = 0;\n    uint256 constant NUM_BEFORE_PARTIAL_FILL = 2;\n    uint256 constant PARTIAL_FILL_INDEX = 5;\n    uint256 constant END_INDEX = 10;\n    uint256 constant SLIPPAGE = 1e8; // small % slippage allowed for partial fill quotes (due to numerical instability)\n\n    uint256 constant ID_1155 = 0;\n\n    uint128 delta;\n    uint128 spotPrice;\n\n    /**\n     * Swap Order types\n     */\n    enum BuySwap {\n        ITEM_PARTIAL_PRICE_FULL_721,\n        ITEM_NONE_PRICE_FULL_721,\n        ITEM_FULL_PRICE_PARTIAL_721,\n        ITEM_FULL_PRICE_FULL_721,\n        ITEM_PARTIAL_PRICE_PARTIAL_721,\n        ITEM_FULL_PRICE_NONE_721,\n        ITEM_FULL_PRICE_FULL_1155,\n        ITEM_PARTIAL_PRICE_FULL_1155,\n        ITEM_FULL_PRICE_PARTIAL_1155,\n        ITEM_PARTIAL_PRICE_PARTIAL_1155,\n        ITEM_NONE_PRICE_FULL_1155,\n        ITEM_FULL_PRICE_NONE_1155\n    }\n    enum SellSwap {\n        PRICE_FULL_BALANCE_PARTIAL_721,\n        PRICE_PARTIAL_BALANCE_NONE_721,\n        PRICE_PARTIAL_BALANCE_PARTIAL_721,\n        PRICE_PARTIAL_BALANCE_FULL_721,\n        PRICE_FULL_BALANCE_FULL_721,\n        PRICE_NONE_BALANCE_FULL_721,\n        PRICE_FULL_BALANCE_FULL_1155,\n        PRICE_FULL_BALANCE_PARTIAL_1155,\n        PRICE_PARTIAL_BALANCE_FULL_1155,\n        PRICE_PARTIAL_BALANCE_PARTIAL_1155,\n        PRICE_PARTIAL_BALANCE_NONE_1155,\n        PRICE_NONE_BALANCE_FULL_1155\n    }\n\n    /**\n     * The results of performing a swap\n     */\n    struct BuyResult {\n        address nftRecipient;\n        uint256 numItemsReceived;\n        uint256[] idsReceived;\n        LSSVMPair pair;\n        bool isERC721;\n    }\n\n    struct SellResult {\n        address nftRecipient;\n        uint256 numItemsReceived;\n        uint256[] idsReceived;\n        LSSVMPair pair;\n        bool isERC721;\n        address tokenRecipient;\n        uint256 tokenBalance;\n    }\n\n    function setUp() public {\n        bondingCurve = setupCurve();\n        royaltyEngine = setupRoyaltyEngine();\n        pairFactory = setupFactory(royaltyEngine, payable(address(0)));\n        pairFactory.setBondingCurveAllowed(bondingCurve, true);\n\n        MerklePropertyChecker checker1 = new MerklePropertyChecker();\n        RangePropertyChecker checker2 = new RangePropertyChecker();\n        propertyCheckerFactory = new PropertyCheckerFactory(checker1, checker2);\n\n        router = new VeryFastRouter(pairFactory);\n        pairFactory.setRouterAllowed(LSSVMRouter(payable(address(router))), true);\n\n        (delta, spotPrice) = getReasonableDeltaAndSpotPrice();\n\n        // Give the router caller a large amount of ETH\n        vm.deal(ROUTER_CALLER, 1e18 ether);\n    }\n\n    function _setUpERC721(address nftRecipient, address factoryCaller, address routerCaller)\n        internal\n        returns (IERC721Mintable nft)\n    {\n        nft = setup721();\n        for (uint256 i = START_INDEX; i <= END_INDEX; i++) {\n            nft.mint(nftRecipient, i);\n        }\n        vm.prank(factoryCaller);\n        nft.setApprovalForAll(address(pairFactory), true);\n        vm.prank(routerCaller);\n        nft.setApprovalForAll(address(router), true);\n    }\n\n    function _setUpERC1155(address nftRecipient, address factoryCaller, address routerCaller)\n        internal\n        returns (IERC1155Mintable nft)\n    {\n        nft = setup1155();\n        nft.mint(nftRecipient, ID_1155, END_INDEX + 1);\n        vm.prank(factoryCaller);\n        nft.setApprovalForAll(address(pairFactory), true);\n        vm.prank(routerCaller);\n        nft.setApprovalForAll(address(router), true);\n    }\n\n    function _getArray(uint256 start, uint256 end) internal pure returns (uint256[] memory ids) {\n        ids = new uint256[](end - start + 1);\n        for (uint256 i = 0; i < ids.length; i++) {\n            ids[i] = start + i;\n        }\n    }\n\n    function setUpPairERC721ForSale(uint256 depositAmount, address _propertyChecker, uint256[] memory nftIdsToDeposit)\n        public\n        returns (LSSVMPair pair)\n    {\n        if (_propertyChecker == address(0)) {\n            // Set up pair on behalf of pair creator\n            pair = this.setupPairERC721{value: modifyInputAmount(depositAmount)}(\n                pairFactory,\n                IERC721(address(_setUpERC721(address(this), address(this), ROUTER_CALLER))),\n                bondingCurve,\n                payable(address(0)),\n                LSSVMPair.PoolType.TRADE,\n                delta,\n                0, // fee\n                spotPrice,\n                nftIdsToDeposit,\n                depositAmount,\n                address(router)\n            );\n        } else {\n            pair = this.setupPairWithPropertyCheckerERC721{value: modifyInputAmount(depositAmount)}(\n                PairCreationParamsWithPropertyCheckerERC721({\n                    factory: pairFactory,\n                    nft: IERC721(address(_setUpERC721(address(this), address(this), ROUTER_CALLER))),\n                    bondingCurve: bondingCurve,\n                    assetRecipient: payable(address(0)),\n                    poolType: LSSVMPair.PoolType.TRADE,\n                    delta: delta,\n                    fee: 0,\n                    spotPrice: spotPrice,\n                    _idList: nftIdsToDeposit,\n                    initialTokenBalance: depositAmount,\n                    routerAddress: address(router),\n                    propertyChecker: _propertyChecker\n                })\n            );\n        }\n    }\n\n    function setUpPairERC1155ForSale(\n        uint256 depositAmount,\n        uint256 numNFTsToDeposit,\n        address nftRecipient,\n        address factoryCaller,\n        address routerCaller\n    ) public returns (LSSVMPair pair) {\n        IERC1155 nft = _setUpERC1155(nftRecipient, factoryCaller, routerCaller);\n        pair = this.setupPairERC1155{value: modifyInputAmount(depositAmount)}(\n            CreateERC1155PairParams({\n                factory: pairFactory,\n                nft: nft,\n                bondingCurve: bondingCurve,\n                assetRecipient: payable(address(0)),\n                poolType: LSSVMPair.PoolType.TRADE,\n                delta: delta,\n                fee: 0, // fee\n                spotPrice: spotPrice,\n                nftId: ID_1155,\n                initialNFTBalance: numNFTsToDeposit,\n                initialTokenBalance: depositAmount,\n                routerAddress: address(router)\n            })\n        );\n    }\n\n    function _getBuyOrderAllItemsAvailable(bool is721)\n        internal\n        returns (VeryFastRouter.BuyOrderWithPartialFill memory buyOrder, BuyResult memory result)\n    {\n        uint256[] memory nftIds;\n        LSSVMPair pair;\n        uint256 numNFTsForQuote = END_INDEX + 1;\n\n        if (is721) {\n            // Set up pair with empty property checker as PAIR_CREATOR\n            nftIds = _getArray(START_INDEX, END_INDEX);\n            pair = setUpPairERC721ForSale(0, address(0), nftIds);\n        } else {\n            // Set up ERC1155 pair\n            pair = setUpPairERC1155ForSale(0, numNFTsForQuote, address(this), address(this), ROUTER_CALLER);\n\n            // Set the first value to be the number of assets to swap\n            nftIds = new uint256[](1);\n            nftIds[0] = numNFTsForQuote;\n        }\n\n        (,,, uint256 inputAmount,,) = pair.getBuyNFTQuote(START_INDEX, numNFTsForQuote);\n        uint256[] memory partialFillAmounts =\n            router.getNFTQuoteForBuyOrderWithPartialFill(pair, numNFTsForQuote, SLIPPAGE, START_INDEX);\n\n        // Assert that we are sending as many tokens as needed in the case where we fill everything\n        assertApproxEqRel(inputAmount, partialFillAmounts[partialFillAmounts.length - 1], 1e9, \"Difference too large\");\n\n        buyOrder = VeryFastRouter.BuyOrderWithPartialFill({\n            pair: pair,\n            nftIds: nftIds,\n            maxInputAmount: inputAmount,\n            ethAmount: modifyInputAmount(inputAmount),\n            expectedSpotPrice: pair.spotPrice(),\n            isERC721: is721,\n            maxCostPerNumNFTs: partialFillAmounts\n        });\n        result = BuyResult({\n            nftRecipient: ROUTER_CALLER,\n            numItemsReceived: numNFTsForQuote,\n            idsReceived: nftIds,\n            pair: pair,\n            isERC721: is721\n        });\n    }\n\n    function _getBuyOrderNotAllItemsAvailableAllItemsInPrice(bool is721)\n        internal\n        returns (VeryFastRouter.BuyOrderWithPartialFill memory buyOrder, BuyResult memory result)\n    {\n        uint256 numNFTsToReceive = PARTIAL_FILL_INDEX + 1;\n        uint256 numNFTsForQuote = END_INDEX + 1;\n        uint256[] memory nftsInPair;\n        uint256[] memory nftIds;\n        LSSVMPair pair;\n\n        if (is721) {\n            // Set up pair with empty property checker as PAIR_CREATOR\n            // Only deposit from START_INDEX to PARTIAL_FILL_INDEX number of items\n            nftsInPair = _getArray(START_INDEX, PARTIAL_FILL_INDEX);\n            pair = setUpPairERC721ForSale(0, address(0), nftsInPair);\n\n            // Get set of all ids from START_INDEX to END_INDEX\n            nftIds = _getArray(START_INDEX, END_INDEX);\n        } else {\n            pair = setUpPairERC1155ForSale(0, numNFTsToReceive, address(this), address(this), ROUTER_CALLER);\n            // Set the first value to be the number of assets to swap\n            nftIds = new uint256[](1);\n            nftIds[0] = numNFTsForQuote;\n        }\n\n        // Still get the partial fill quotes\n        (,,, uint256 inputAmount,,) = pair.getBuyNFTQuote(START_INDEX, numNFTsForQuote);\n        uint256[] memory partialFillAmounts =\n            router.getNFTQuoteForBuyOrderWithPartialFill(pair, numNFTsForQuote, SLIPPAGE, START_INDEX);\n\n        // Construct the same buy order\n        buyOrder = VeryFastRouter.BuyOrderWithPartialFill({\n            pair: pair,\n            nftIds: nftIds,\n            maxInputAmount: inputAmount,\n            ethAmount: modifyInputAmount(inputAmount),\n            expectedSpotPrice: pair.spotPrice() + 1, // We increase by one to trigger the partial fill logic\n            isERC721: is721,\n            maxCostPerNumNFTs: partialFillAmounts\n        });\n\n        // Expected results now have only the nfts in the pair\n        result = BuyResult({\n            nftRecipient: address(this),\n            numItemsReceived: numNFTsToReceive,\n            idsReceived: nftsInPair,\n            pair: pair,\n            isERC721: is721\n        });\n    }\n\n    function _getBuyOrderAllItemsAvailableNotAllItemsInPrice(bool is721)\n        internal\n        returns (VeryFastRouter.BuyOrderWithPartialFill memory buyOrder, BuyResult memory result)\n    {\n        LSSVMPair pair;\n        uint256[] memory nftInfo;\n        uint256 numNFTsToDeposit = END_INDEX + 1;\n\n        // Set up pair with empty property checker as PAIR_CREATOR\n        if (is721) {\n            uint256[] memory nftIds = _getArray(START_INDEX, END_INDEX);\n            pair = setUpPairERC721ForSale(0, address(0), nftIds);\n            nftInfo = nftIds;\n        } else {\n            pair = setUpPairERC1155ForSale(0, numNFTsToDeposit, address(this), address(this), ROUTER_CALLER);\n            // Set the first value to be the number of assets to swap\n            nftInfo = new uint256[](1);\n            nftInfo[0] = numNFTsToDeposit;\n        }\n\n        // Get the partial fill quotes\n        (,,, uint256 inputAmount,,) = pair.getBuyNFTQuote(START_INDEX, numNFTsToDeposit);\n        uint256[] memory partialFillAmounts =\n            router.getNFTQuoteForBuyOrderWithPartialFill(pair, numNFTsToDeposit, SLIPPAGE, START_INDEX);\n\n        // Assume that PARTIAL_FILL number of items have been bought\n        (, uint256 newSpotPrice, uint256 newDelta,,,) = pair.getBuyNFTQuote(START_INDEX, PARTIAL_FILL_INDEX);\n\n        // Set the spotPrice and delta to be the new values\n        pair.changeDelta(uint128(newDelta));\n        pair.changeSpotPrice(uint128(newSpotPrice));\n\n        // Construct the buy order\n        buyOrder = VeryFastRouter.BuyOrderWithPartialFill({\n            pair: pair,\n            nftIds: nftInfo,\n            maxInputAmount: inputAmount,\n            ethAmount: modifyInputAmount(inputAmount),\n            expectedSpotPrice: pair.spotPrice() + 1, // We increase by one to trigger the partial fill logic\n            isERC721: is721,\n            maxCostPerNumNFTs: partialFillAmounts\n        });\n\n        // Expected results now have only the remaining NFTs\n        uint256[] memory expectedNFTs = _getArray(START_INDEX, END_INDEX - PARTIAL_FILL_INDEX);\n\n        // Construct the post swap results\n        result = BuyResult({\n            nftRecipient: address(this),\n            numItemsReceived: expectedNFTs.length,\n            idsReceived: expectedNFTs,\n            pair: pair,\n            isERC721: is721\n        });\n    }\n\n    function _getBuyOrderNotAllitemsAvailableNotAllItemsInPrice(bool is721)\n        internal\n        returns (VeryFastRouter.BuyOrderWithPartialFill memory buyOrder, BuyResult memory result)\n    {\n        LSSVMPair pair;\n        uint256[] memory nftInfo;\n        uint256 numNFTsToDeposit = PARTIAL_FILL_INDEX + 1;\n        uint256 numNFTsTotal = END_INDEX + 1;\n\n        if (is721) {\n            // Get only up to partial fill number of NFTs to deposit\n            uint256[] memory nftsInPair = _getArray(START_INDEX, PARTIAL_FILL_INDEX);\n\n            // Get set of all ids from START_INDEX to END_INDEX\n            uint256[] memory nftIds = _getArray(START_INDEX, END_INDEX);\n\n            // Set up pair with empty property checker as PAIR_CREATOR\n            // Only deposit from START_INDEX to PARTIAL_FILL_INDEX number of items\n            pair = setUpPairERC721ForSale(0, address(0), nftsInPair);\n\n            nftInfo = nftIds;\n        } else {\n            pair = setUpPairERC1155ForSale(0, numNFTsToDeposit, address(this), address(this), ROUTER_CALLER);\n            // Set the first value to be the number of assets to swap\n            nftInfo = new uint256[](1);\n            nftInfo[0] = numNFTsToDeposit;\n        }\n\n        // Get the partial fill quotes assuming we can buy all of the items\n        (,,, uint256 inputAmount,,) = pair.getBuyNFTQuote(START_INDEX, numNFTsTotal);\n        uint256[] memory partialFillAmounts =\n            router.getNFTQuoteForBuyOrderWithPartialFill(pair, numNFTsTotal, SLIPPAGE, START_INDEX);\n\n        // Assume that NUM_BEFORE_PARTIAL_FILL + PARTIAL_FILL number of items have been bought first\n        (, uint256 newSpotPrice, uint256 newDelta,,,) =\n            pair.getBuyNFTQuote(START_INDEX, PARTIAL_FILL_INDEX + NUM_BEFORE_PARTIAL_FILL);\n\n        // Set the spotPrice and delta to be the new values assuming this change\n        pair.changeDelta(uint128(newDelta));\n        pair.changeSpotPrice(uint128(newSpotPrice));\n\n        // Construct the buy order\n        buyOrder = VeryFastRouter.BuyOrderWithPartialFill({\n            pair: pair,\n            nftIds: nftInfo, // Attempt to get all of the NFT IDs\n            maxInputAmount: inputAmount,\n            ethAmount: modifyInputAmount(inputAmount),\n            expectedSpotPrice: pair.spotPrice() + 1, // We increase by one to trigger the partial fill logic\n            isERC721: is721,\n            maxCostPerNumNFTs: partialFillAmounts\n        });\n\n        // Expected results now have only the nfts in the pair, but only some of them\n        uint256[] memory actualReceivedNFTs = _getArray(START_INDEX, PARTIAL_FILL_INDEX - NUM_BEFORE_PARTIAL_FILL);\n        result = BuyResult({\n            nftRecipient: address(this),\n            numItemsReceived: actualReceivedNFTs.length,\n            idsReceived: actualReceivedNFTs,\n            pair: pair,\n            isERC721: is721\n        });\n    }\n\n    function _getBuyOrderAllItemsUnavailable(bool is721)\n        internal\n        returns (VeryFastRouter.BuyOrderWithPartialFill memory buyOrder, BuyResult memory result)\n    {\n        uint256[] memory nftInfo;\n        uint256 numNFTsTotal = END_INDEX + 1;\n        uint256[] memory emptyList = new uint256[](0);\n        LSSVMPair pair;\n\n        if (is721) {\n            // Get set of all ids from START_INDEX to END_INDEX\n            uint256[] memory nftIds = _getArray(START_INDEX, END_INDEX);\n            nftInfo = nftIds;\n\n            // Set up pair with empty property checker as PAIR_CREATOR\n            // Deposit none of the NFTs\n            pair = setUpPairERC721ForSale(0, address(0), emptyList);\n        } else {\n            // Deposit no NFTs\n            pair = setUpPairERC1155ForSale(0, 0, address(this), address(this), ROUTER_CALLER);\n            // Set the first value to be the number of assets to swap\n            nftInfo = new uint256[](1);\n            nftInfo[0] = numNFTsTotal;\n        }\n\n        // Get the partial fill quotes assuming we can buy all of the items\n        (,,, uint256 inputAmount,,) = pair.getBuyNFTQuote(START_INDEX, numNFTsTotal);\n        uint256[] memory partialFillAmounts =\n            router.getNFTQuoteForBuyOrderWithPartialFill(pair, numNFTsTotal, SLIPPAGE, START_INDEX);\n\n        // Construct the buy order\n        buyOrder = VeryFastRouter.BuyOrderWithPartialFill({\n            pair: pair,\n            nftIds: nftInfo, // Attempt to get all of the NFT IDs\n            maxInputAmount: inputAmount,\n            ethAmount: modifyInputAmount(inputAmount),\n            expectedSpotPrice: pair.spotPrice() + 1, // We increase by one to trigger the partial fill logic\n            isERC721: is721,\n            maxCostPerNumNFTs: partialFillAmounts\n        });\n\n        // Expected results now have no NFTs\n        result = BuyResult({\n            nftRecipient: address(this),\n            numItemsReceived: 0,\n            idsReceived: emptyList,\n            pair: pair,\n            isERC721: is721\n        });\n    }\n\n    function _getBuyOrderAllItemsNotInPrice(bool is721)\n        internal\n        returns (VeryFastRouter.BuyOrderWithPartialFill memory buyOrder, BuyResult memory result)\n    {\n        uint256[] memory nftInfo;\n        uint256 numNFTsTotal = END_INDEX + 1;\n        LSSVMPair pair;\n\n        if (is721) {\n            uint256[] memory nftIds = _getArray(START_INDEX, END_INDEX);\n            nftInfo = nftIds;\n            pair = setUpPairERC721ForSale(0, address(0), nftIds);\n        } else {\n            // Deposit no NFTs\n            pair = setUpPairERC1155ForSale(numNFTsTotal, 0, address(this), address(this), ROUTER_CALLER);\n            // Set the first value to be the number of assets to swap\n            nftInfo = new uint256[](1);\n            nftInfo[0] = numNFTsTotal;\n        }\n\n        // Get the partial fill quotes\n        (,,, uint256 inputAmount,,) = pair.getBuyNFTQuote(START_INDEX, numNFTsTotal);\n        uint256[] memory partialFillAmounts =\n            router.getNFTQuoteForBuyOrderWithPartialFill(pair, numNFTsTotal, SLIPPAGE, START_INDEX);\n\n        // Assume that *all* items have been bought\n        (, uint256 newSpotPrice, uint256 newDelta,,,) = pair.getBuyNFTQuote(START_INDEX, END_INDEX + 1);\n\n        // Set the spotPrice and delta to be the new values\n        pair.changeDelta(uint128(newDelta));\n        pair.changeSpotPrice(uint128(newSpotPrice));\n\n        // Construct the buy order\n        buyOrder = VeryFastRouter.BuyOrderWithPartialFill({\n            pair: pair,\n            nftIds: nftInfo, // Attempt to get all of the NFT IDs\n            maxInputAmount: inputAmount,\n            ethAmount: modifyInputAmount(inputAmount),\n            expectedSpotPrice: pair.spotPrice() + 1, // We increase by one to trigger the partial fill logic\n            isERC721: is721,\n            maxCostPerNumNFTs: partialFillAmounts\n        });\n\n        // Expected results now have no NFTs\n        uint256[] memory emptyList = new uint256[](0);\n        result = BuyResult({\n            nftRecipient: address(this),\n            numItemsReceived: 0,\n            idsReceived: emptyList,\n            pair: pair,\n            isERC721: is721\n        });\n    }\n\n    function _getBuyOrder(BuySwap swapType)\n        internal\n        returns (VeryFastRouter.BuyOrderWithPartialFill memory buyOrder, BuyResult memory result)\n    {\n        if (swapType == BuySwap.ITEM_PARTIAL_PRICE_FULL_721) {\n            return _getBuyOrderNotAllItemsAvailableAllItemsInPrice(true);\n        } else if (swapType == BuySwap.ITEM_FULL_PRICE_FULL_721) {\n            return _getBuyOrderAllItemsAvailable(true);\n        } else if (swapType == BuySwap.ITEM_FULL_PRICE_PARTIAL_721) {\n            return _getBuyOrderAllItemsAvailableNotAllItemsInPrice(true);\n        } else if (swapType == BuySwap.ITEM_PARTIAL_PRICE_PARTIAL_721) {\n            return _getBuyOrderNotAllitemsAvailableNotAllItemsInPrice(true);\n        } else if (swapType == BuySwap.ITEM_NONE_PRICE_FULL_721) {\n            return _getBuyOrderAllItemsUnavailable(true);\n        } else if (swapType == BuySwap.ITEM_FULL_PRICE_NONE_721) {\n            return _getBuyOrderAllItemsNotInPrice(true);\n        }\n        // 1155 test variants start here\n        else if (swapType == BuySwap.ITEM_FULL_PRICE_FULL_1155) {\n            return _getBuyOrderAllItemsAvailable(false);\n        } else if (swapType == BuySwap.ITEM_PARTIAL_PRICE_FULL_1155) {\n            return _getBuyOrderNotAllItemsAvailableAllItemsInPrice(false);\n        } else if (swapType == BuySwap.ITEM_FULL_PRICE_PARTIAL_1155) {\n            return _getBuyOrderAllItemsAvailableNotAllItemsInPrice(false);\n        } else if (swapType == BuySwap.ITEM_PARTIAL_PRICE_PARTIAL_1155) {\n            return _getBuyOrderNotAllitemsAvailableNotAllItemsInPrice(false);\n        } else if (swapType == BuySwap.ITEM_NONE_PRICE_FULL_1155) {\n            return _getBuyOrderAllItemsUnavailable(false);\n        } else if (swapType == BuySwap.ITEM_FULL_PRICE_NONE_1155) {\n            return _getBuyOrderAllItemsNotInPrice(false);\n        }\n    }\n\n    function _getSellOrderFullPriceFullBalance(bool doPropertyCheck, bool is721)\n        internal\n        returns (VeryFastRouter.SellOrderWithPartialFill memory sellOrder, SellResult memory result)\n    {\n        address propertyCheckerAddress = address(0);\n\n        if (doPropertyCheck) {\n            propertyCheckerAddress = address(propertyCheckerFactory.createRangePropertyChecker(START_INDEX, END_INDEX));\n        }\n\n        LSSVMPair pair;\n        uint256[] memory nftInfo;\n        uint256[] memory emptyList = new uint256[](0);\n        uint256 numNFTsForQuote = END_INDEX + 1;\n\n        if (is721) {\n            // Set up pair with no tokens\n            pair = setUpPairERC721ForSale(0, propertyCheckerAddress, emptyList);\n\n            // Get array of all NFT IDs we want to sell\n            uint256[] memory nftIds = _getArray(START_INDEX, END_INDEX);\n            nftInfo = nftIds;\n        } else {\n            pair = setUpPairERC1155ForSale(0, 0, address(ROUTER_CALLER), address(ROUTER_CALLER), address(ROUTER_CALLER));\n            nftInfo = new uint256[](1);\n            nftInfo[0] = numNFTsForQuote;\n        }\n\n        // Get the amount needed to put in the pair\n        (,,, uint256 outputAmount,, uint256 protocolFee) = pair.bondingCurve().getSellInfo(\n            pair.spotPrice(), pair.delta(), numNFTsForQuote, pair.fee(), pair.factory().protocolFeeMultiplier()\n        );\n\n        // Send that many tokens to the pair\n        sendTokens(pair, outputAmount + protocolFee);\n\n        // Calculate how many tokens we actually get\n        (,,, uint256 expectedOutput,,) = pair.getSellNFTQuote(START_INDEX, numNFTsForQuote);\n\n        bool isETHSell = true;\n        address tokenAddress = getTokenAddress();\n        if (tokenAddress != address(0)) {\n            isETHSell = false;\n        }\n\n        // Construct the sell order\n        sellOrder = VeryFastRouter.SellOrderWithPartialFill({\n            pair: pair,\n            isETHSell: isETHSell,\n            isERC721: is721,\n            nftIds: nftInfo,\n            doPropertyCheck: doPropertyCheck,\n            propertyCheckParams: \"\",\n            expectedSpotPrice: pair.spotPrice(),\n            minExpectedOutput: expectedOutput,\n            minExpectedOutputPerNumNFTs: router.getNFTQuoteForSellOrderWithPartialFill(\n                pair, numNFTsForQuote, SLIPPAGE, START_INDEX\n                )\n        });\n\n        result = SellResult({\n            nftRecipient: address(pair),\n            numItemsReceived: numNFTsForQuote,\n            idsReceived: nftInfo,\n            pair: pair,\n            isERC721: is721,\n            tokenRecipient: TOKEN_RECIPIENT,\n            tokenBalance: expectedOutput\n        });\n    }\n\n    function _getSellOrderFullPricePartialBalance(bool doPropertyCheck, bool is721)\n        internal\n        returns (VeryFastRouter.SellOrderWithPartialFill memory sellOrder, SellResult memory result)\n    {\n        address propertyCheckerAddress = address(0);\n\n        if (doPropertyCheck) {\n            propertyCheckerAddress = address(propertyCheckerFactory.createRangePropertyChecker(START_INDEX, END_INDEX));\n        }\n\n        LSSVMPair pair;\n        uint256[] memory nftInfo;\n        uint256 numNFTsTotal = END_INDEX + 1;\n\n        // Set up pair with no tokens\n        if (is721) {\n            // Get array of all NFT IDs we want to sell\n            uint256[] memory nftIds = _getArray(START_INDEX, END_INDEX);\n            nftInfo = nftIds;\n            pair = setUpPairERC721ForSale(0, propertyCheckerAddress, new uint256[](0));\n        } else {\n            pair = setUpPairERC1155ForSale(0, 0, address(ROUTER_CALLER), address(ROUTER_CALLER), address(ROUTER_CALLER));\n            nftInfo = new uint256[](1);\n            nftInfo[0] = numNFTsTotal;\n        }\n\n        // Get the amount needed to put in the pair to support only selling up to the partial fill amount\n        (,,, uint256 outputAmount,, uint256 protocolFee) = pair.bondingCurve().getSellInfo(\n            pair.spotPrice(), pair.delta(), PARTIAL_FILL_INDEX + 1, pair.fee(), pair.factory().protocolFeeMultiplier()\n        );\n\n        // Send that many tokens to the pair\n        sendTokens(pair, outputAmount + protocolFee);\n\n        bool isETHSell = true;\n        address tokenAddress = getTokenAddress();\n        if (tokenAddress != address(0)) {\n            isETHSell = false;\n        }\n\n        // Construct the sell order\n        // Calculate the max amount we can receive\n        (,,, uint256 expectedOutput,,) = pair.getSellNFTQuote(START_INDEX, numNFTsTotal);\n        sellOrder = VeryFastRouter.SellOrderWithPartialFill({\n            pair: pair,\n            isETHSell: isETHSell,\n            isERC721: is721,\n            nftIds: nftInfo,\n            doPropertyCheck: doPropertyCheck,\n            propertyCheckParams: \"\",\n            expectedSpotPrice: pair.spotPrice() + 1, // Trigger partial fill\n            minExpectedOutput: expectedOutput,\n            minExpectedOutputPerNumNFTs: router.getNFTQuoteForSellOrderWithPartialFill(\n                pair, numNFTsTotal, SLIPPAGE, START_INDEX\n                )\n        });\n\n        // Calculate how many tokens we actually expect to get\n        (,,, expectedOutput,,) = pair.getSellNFTQuote(START_INDEX, PARTIAL_FILL_INDEX + 1);\n        result = SellResult({\n            nftRecipient: address(pair),\n            numItemsReceived: PARTIAL_FILL_INDEX + 1,\n            idsReceived: _getArray(START_INDEX, PARTIAL_FILL_INDEX),\n            pair: pair,\n            isERC721: is721,\n            tokenRecipient: TOKEN_RECIPIENT,\n            tokenBalance: expectedOutput\n        });\n    }\n\n    function _getSellOrderPartialPriceFullBalance(bool doPropertyCheck, bool is721)\n        internal\n        returns (VeryFastRouter.SellOrderWithPartialFill memory sellOrder, SellResult memory result)\n    {\n        address propertyCheckerAddress = address(0);\n\n        if (doPropertyCheck) {\n            propertyCheckerAddress = address(propertyCheckerFactory.createRangePropertyChecker(START_INDEX, END_INDEX));\n        }\n\n        LSSVMPair pair;\n        uint256[] memory nftInfo;\n        uint256 numNFTsTotal = END_INDEX + 1;\n\n        if (is721) {\n            pair = setUpPairERC721ForSale(0, propertyCheckerAddress, new uint256[](0));\n            nftInfo = _getArray(START_INDEX, END_INDEX);\n        } else {\n            pair = setUpPairERC1155ForSale(0, 0, address(ROUTER_CALLER), address(ROUTER_CALLER), address(ROUTER_CALLER));\n            nftInfo = new uint256[](1);\n            nftInfo[0] = numNFTsTotal;\n        }\n\n        // Locally scope to avoid stack too deep\n        {\n            // Get the amount needed to put in the pair to support only selling all\n            (,,, uint256 outputAmount,, uint256 protocolFee) = pair.bondingCurve().getSellInfo(\n                pair.spotPrice(), pair.delta(), numNFTsTotal, pair.fee(), pair.factory().protocolFeeMultiplier()\n            );\n\n            // Send that many tokens to the pair\n            sendTokens(pair, outputAmount + protocolFee);\n        }\n\n        // Get new spot price and delta as if we had sold NUM_BEFORE_PARTIAL_FILL number of NFTs\n        (, uint128 newSpotPrice, uint128 newDelta,,,) = pair.bondingCurve().getSellInfo(\n            pair.spotPrice(), pair.delta(), NUM_BEFORE_PARTIAL_FILL, pair.fee(), pair.factory().protocolFeeMultiplier()\n        );\n\n        bool isETHSell = true;\n        if (getTokenAddress() != address(0)) {\n            isETHSell = false;\n        }\n\n        // Construct the sell order\n        // Calculate the max amount we can receive\n        (,,, uint256 expectedOutput,,) = pair.getSellNFTQuote(START_INDEX, numNFTsTotal);\n        sellOrder = VeryFastRouter.SellOrderWithPartialFill({\n            pair: pair,\n            isETHSell: isETHSell,\n            isERC721: is721,\n            nftIds: nftInfo,\n            doPropertyCheck: doPropertyCheck,\n            propertyCheckParams: \"\",\n            expectedSpotPrice: pair.spotPrice() + 1, // Trigger partial fill calculation\n            minExpectedOutput: expectedOutput,\n            minExpectedOutputPerNumNFTs: router.getNFTQuoteForSellOrderWithPartialFill(\n                pair, numNFTsTotal, SLIPPAGE, START_INDEX\n                )\n        });\n\n        // Set the spotPrice and delta to be the new values (after calculating partial fill calculations)\n        pair.changeDelta(uint128(newDelta));\n        pair.changeSpotPrice(uint128(newSpotPrice));\n\n        // Calculate how many tokens we actually expect to get\n        (,,, expectedOutput,,) = pair.getSellNFTQuote(START_INDEX, numNFTsTotal - NUM_BEFORE_PARTIAL_FILL);\n        result = SellResult({\n            nftRecipient: address(pair),\n            numItemsReceived: numNFTsTotal - NUM_BEFORE_PARTIAL_FILL,\n            idsReceived: _getArray(START_INDEX, numNFTsTotal - NUM_BEFORE_PARTIAL_FILL - 1),\n            pair: pair,\n            isERC721: is721,\n            tokenRecipient: TOKEN_RECIPIENT,\n            tokenBalance: expectedOutput\n        });\n    }\n\n    function _getSellOrderPart"
    }
  ]
}