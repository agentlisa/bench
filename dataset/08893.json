{
  "Title": "[N-13] Typos",
  "Content": "\n*There are 6 instances of this issue:*\n```solidity\nFile: protocol/contracts/BkdLocker.sol\n\n/// @audit invlude\n173:       * @dev This does not invlude the gov. tokens queued for withdrawal.\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L173\n\n```solidity\nFile: protocol/contracts/tokenomics/InflationManager.sol\n\n/// @audit TOOD\n532:      //TOOD: See if this is still needed somewhere\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L532\n\n```solidity\nFile: protocol/contracts/tokenomics/FeeBurner.sol\n\n/// @audit Emmited\n29:       event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token\n\n/// @audit successfull\n29:       event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token\n\n/// @audit Recieve\n35:       receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool\n\n/// @audit Transfering\n84:           // Transfering LP tokens back to sender\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L29\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-backd-findings/issues/109#issuecomment-1159843872):**\n> **1. migrate() still does transfers when the transfer is to the same pool, and this can be done multiple times**<br>\n>Interesting finding, also wonder if this could cause issues with fees, but in lack of POC, I think this is a valid Low Severity finding\n\n> **2. Non-exploitable reentrancy**<br>\n>Agree with severity and finding, would rephrase to \"code doesn't conform to CEI\"\n\n> **3. Users can DOS themselves by executing prepareUnlock(0) many times**<br>\n>This should be downgraded to non-critical because it probably requires tens of thousands of calls, that said the finding is valid\n\n> **4. Unused/empty receive()/fallback() function**<br>\n>I fail to see the need for the extra checks given that the contracts are meant to handle ETH\n\n> **5. safeApprove() is deprecated**<br>\n>Technically valid, however the code is using `safeApprove` correctly, only once, from zero to X\n\n> **6. Missing checks for address(0x0) when assigning values to address state variables**<br>\n>Valid\n\n> **7. _prepareDeadline(), _setConfig(), and _executeDeadline() should be private**<br>\n>Disagree with the alarmist side, but there's validity to this finding.\n\n> **Non-critical Issues**<br>\n>Agree with the findings although it feels like a bot wrote this.\n\n>Overall a really exhaustive report, 3 findings are interesting the rest doesn't stand out, however the thoroughness of the report does.\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-backd",
  "Code": [
    {
      "filename": "protocol/contracts/BkdLocker.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../libraries/ScaledMath.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/EnumerableExtensions.sol\";\nimport \"../libraries/UncheckedMath.sol\";\nimport \"../interfaces/IBkdLocker.sol\";\nimport \"../interfaces/tokenomics/IMigrationContract.sol\";\nimport \"./utils/Preparable.sol\";\nimport \"./access/Authorization.sol\";\n\ncontract BkdLocker is IBkdLocker, Authorization, Preparable {\n    using ScaledMath for uint256;\n    using UncheckedMath for uint256;\n    using SafeERC20 for IERC20;\n    using EnumerableMapping for EnumerableMapping.AddressToUintMap;\n    using EnumerableExtensions for EnumerableMapping.AddressToUintMap;\n\n    bytes32 internal constant _START_BOOST = \"startBoost\";\n    bytes32 internal constant _MAX_BOOST = \"maxBoost\";\n    bytes32 internal constant _INCREASE_PERIOD = \"increasePeriod\";\n    bytes32 internal constant _WITHDRAW_DELAY = \"withdrawDelay\";\n\n    // User-specific data\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public boostFactors;\n    mapping(address => uint256) public lastUpdated;\n    mapping(address => WithdrawStash[]) public stashedGovTokens;\n    mapping(address => uint256) public totalStashed;\n\n    // Global data\n    uint256 public totalLocked;\n    uint256 public totalLockedBoosted;\n    uint256 public lastMigrationEvent;\n    EnumerableMapping.AddressToUintMap private _replacedRewardTokens;\n\n    // Reward token data\n    mapping(address => RewardTokenData) public rewardTokenData;\n    address public override rewardToken;\n    IERC20 public immutable govToken;\n\n    constructor(\n        address _rewardToken,\n        address _govToken,\n        IRoleManager roleManager\n    ) Authorization(roleManager) {\n        rewardToken = _rewardToken;\n        govToken = IERC20(_govToken);\n    }\n\n    function initialize(\n        uint256 startBoost,\n        uint256 maxBoost,\n        uint256 increasePeriod,\n        uint256 withdrawDelay\n    ) external override onlyGovernance {\n        require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED);\n        _setConfig(_START_BOOST, startBoost);\n        _setConfig(_MAX_BOOST, maxBoost);\n        _setConfig(_INCREASE_PERIOD, increasePeriod);\n        _setConfig(_WITHDRAW_DELAY, withdrawDelay);\n    }\n\n    /**\n     * @notice Sets a new token to be the rewardToken. Fees are then accumulated in this token.\n     * @dev Previously used rewardTokens can be set again here.\n     */\n    function migrate(address newRewardToken) external override onlyGovernance {\n        _replacedRewardTokens.remove(newRewardToken);\n        _replacedRewardTokens.set(rewardToken, block.timestamp);\n        lastMigrationEvent = block.timestamp;\n        rewardToken = newRewardToken;\n    }\n\n    /**\n     * @notice Lock gov. tokens.\n     * @dev The amount needs to be approved in advance.\n     */\n    function lock(uint256 amount) external override {\n        return lockFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Deposit fees (in the rewardToken) to be distributed to lockers of gov. tokens.\n     * @dev `deposit` or `depositFor` needs to be called at least once before this function can be called\n     * @param amount Amount of rewardToken to deposit.\n     */\n    function depositFees(uint256 amount) external override {\n        require(amount > 0, Error.INVALID_AMOUNT);\n        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];\n\n        curRewardTokenData.feeIntegral += amount.scaledDiv(totalLockedBoosted);\n        curRewardTokenData.feeBalance += amount;\n        emit FeesDeposited(amount);\n    }\n\n    function claimFees() external override {\n        claimFees(rewardToken);\n    }\n\n    /**\n     * @notice Checkpoint function to update user data, in particular the boost factor.\n     */\n    function userCheckpoint(address user) external override {\n        _userCheckpoint(user, 0, balances[user]);\n    }\n\n    /**\n     * @notice Prepare unlocking of locked gov. tokens.\n     * @dev A delay is enforced and unlocking can only be executed after that.\n     * @param amount Amount of gov. tokens to prepare for unlocking.\n     */\n    function prepareUnlock(uint256 amount) external override {\n        require(\n            totalStashed[msg.sender] + amount <= balances[msg.sender],\n            \"Amount exceeds locked balance\"\n        );\n        totalStashed[msg.sender] += amount;\n        stashedGovTokens[msg.sender].push(\n            WithdrawStash(block.timestamp + currentUInts256[_WITHDRAW_DELAY], amount)\n        );\n        emit WithdrawPrepared(msg.sender, amount);\n    }\n\n    /**\n     * @notice Execute all prepared gov. token withdrawals.\n     */\n    function executeUnlocks() external override {\n        uint256 totalAvailableToWithdraw;\n        WithdrawStash[] storage stashedWithdraws = stashedGovTokens[msg.sender];\n        uint256 length = stashedWithdraws.length;\n        require(length > 0, \"No entries\");\n        uint256 i = length;\n        while (i > 0) {\n            i = i - 1;\n            if (stashedWithdraws[i].releaseTime <= block.timestamp) {\n                totalAvailableToWithdraw += stashedWithdraws[i].amount;\n\n                stashedWithdraws[i] = stashedWithdraws[stashedWithdraws.length - 1];\n\n                stashedWithdraws.pop();\n            }\n        }\n        totalStashed[msg.sender] -= totalAvailableToWithdraw;\n        uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;\n        _userCheckpoint(msg.sender, 0, newTotal);\n        totalLocked -= totalAvailableToWithdraw;\n        govToken.safeTransfer(msg.sender, totalAvailableToWithdraw);\n        emit WithdrawExecuted(msg.sender, totalAvailableToWithdraw);\n    }\n\n    function getUserShare(address user) external view override returns (uint256) {\n        return getUserShare(user, rewardToken);\n    }\n\n    /**\n     * @notice Get the boosted locked balance for a user.\n     * @dev This includes the gov. tokens queued for withdrawal.\n     * @param user Address to get the boosted balance for.\n     * @return boosted balance for user.\n     */\n    function boostedBalance(address user) external view override returns (uint256) {\n        return balances[user].scaledMul(boostFactors[user]);\n    }\n\n    /**\n     * @notice Get the vote weight for a user.\n     * @dev This does not invlude the gov. tokens queued for withdrawal.\n     * @param user Address to get the vote weight for.\n     * @return vote weight for user.\n     */\n    function balanceOf(address user) external view override returns (uint256) {\n        return (balances[user] - totalStashed[user]).scaledMul(boostFactors[user]);\n    }\n\n    /**\n     * @notice Get the share of the total boosted locked balance for a user.\n     * @dev This includes the gov. tokens queued for withdrawal.\n     * @param user Address to get the share of the total boosted balance for.\n     * @return share of the total boosted balance for user.\n     */\n    function getShareOfTotalBoostedBalance(address user) external view override returns (uint256) {\n        return balances[user].scaledMul(boostFactors[user]).scaledDiv(totalLockedBoosted);\n    }\n\n    function getStashedGovTokens(address user)\n        external\n        view\n        override\n        returns (WithdrawStash[] memory)\n    {\n        return stashedGovTokens[user];\n    }\n\n    function claimableFees(address user) external view override returns (uint256) {\n        return claimableFees(user, rewardToken);\n    }\n\n    /**\n     * @notice Claim fees accumulated in the Locker.\n     */\n    function claimFees(address _rewardToken) public override {\n        require(\n            _rewardToken == rewardToken || _replacedRewardTokens.contains(_rewardToken),\n            Error.INVALID_ARGUMENT\n        );\n        _userCheckpoint(msg.sender, 0, balances[msg.sender]);\n        RewardTokenData storage curRewardTokenData = rewardTokenData[_rewardToken];\n        uint256 claimable = curRewardTokenData.userShares[msg.sender];\n        curRewardTokenData.userShares[msg.sender] = 0;\n        curRewardTokenData.feeBalance -= claimable;\n        IERC20(_rewardToken).safeTransfer(msg.sender, claimable);\n        emit RewardsClaimed(msg.sender, _rewardToken, claimable);\n    }\n\n    /**\n     * @notice Lock gov. tokens on behalf of another user.\n     * @dev The amount needs to be approved in advance.\n     * @param user Address of user to lock on behalf of.\n     * @param amount Amount of gov. tokens to lock.\n     */\n    function lockFor(address user, uint256 amount) public override {\n        govToken.safeTransferFrom(msg.sender, address(this), amount);\n        _userCheckpoint(user, amount, balances[user] + amount);\n        totalLocked += amount;\n        emit Locked(user, amount);\n    }\n\n    function getUserShare(address user, address _rewardToken)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return rewardTokenData[_rewardToken].userShares[user];\n    }\n\n    function claimableFees(address user, address _rewardToken)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 currentShare;\n        uint256 userBalance = balances[user];\n        RewardTokenData storage curRewardTokenData = rewardTokenData[_rewardToken];\n\n        // Compute the share earned by the user since they last updated\n        if (userBalance > 0) {\n            currentShare += (curRewardTokenData.feeIntegral -\n                curRewardTokenData.userFeeIntegrals[user]).scaledMul(\n                    userBalance.scaledMul(boostFactors[user])\n                );\n        }\n        return curRewardTokenData.userShares[user] + currentShare;\n    }\n\n    function computeNewBoost(\n        address user,\n        uint256 amountAdded,\n        uint256 newTotal\n    ) public view override returns (uint256) {\n        uint256 newBoost;\n        uint256 balance = balances[user];\n        uint256 startBoost = currentUInts256[_START_BOOST];\n        if (balance == 0 || newTotal == 0) {\n            newBoost = startBoost;\n        } else {\n            uint256 maxBoost = currentUInts256[_MAX_BOOST];\n            newBoost = boostFactors[user];\n            newBoost += (block.timestamp - lastUpdated[user])\n                .scaledDiv(currentUInts256[_INCREASE_PERIOD])\n                .scaledMul(maxBoost - startBoost);\n            if (newBoost > maxBoost) {\n                newBoost = maxBoost;\n            }\n            if (newTotal <= balance) {\n                return newBoost;\n            }\n            newBoost =\n                newBoost.scaledMul(balance.scaledDiv(newTotal)) +\n                startBoost.scaledMul(amountAdded.scaledDiv(newTotal));\n        }\n        return newBoost;\n    }\n\n    function _userCheckpoint(\n        address user,\n        uint256 amountAdded,\n        uint256 newTotal\n    ) internal {\n        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];\n\n        // Compute the share earned by the user since they last updated\n        uint256 userBalance = balances[user];\n        if (userBalance > 0) {\n            curRewardTokenData.userShares[user] += (curRewardTokenData.feeIntegral -\n                curRewardTokenData.userFeeIntegrals[user]).scaledMul(\n                    userBalance.scaledMul(boostFactors[user])\n                );\n\n            // Update values for previous rewardTokens\n            if (lastUpdated[user] < lastMigrationEvent) {\n                uint256 length = _replacedRewardTokens.length();\n                for (uint256 i; i < length; i = i.uncheckedInc()) {\n                    (address token, uint256 replacedAt) = _replacedRewardTokens.at(i);\n                    if (lastUpdated[user] < replacedAt) {\n                        RewardTokenData storage prevRewardTokenData = rewardTokenData[token];\n                        prevRewardTokenData.userShares[user] += (prevRewardTokenData.feeIntegral -\n                            prevRewardTokenData.userFeeIntegrals[user]).scaledMul(\n                                userBalance.scaledMul(boostFactors[user])\n                            );\n                        prevRewardTokenData.userFeeIntegrals[user] = prevRewardTokenData\n                            .feeIntegral;\n                    }\n                }\n            }\n        }\n\n        uint256 newBoost = computeNewBoost(user, amountAdded, newTotal);\n        totalLockedBoosted =\n            totalLockedBoosted +\n            newTotal.scaledMul(newBoost) -\n            balances[user].scaledMul(boostFactors[user]);\n\n        // Update user values\n        curRewardTokenData.userFeeIntegrals[user] = curRewardTokenData.feeIntegral;\n        lastUpdated[user] = block.timestamp;\n        boostFactors[user] = newBoost;\n        balances[user] = newTotal;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/tokenomics/InflationManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"../../interfaces/IStakerVault.sol\";\nimport \"../../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../../interfaces/tokenomics/IKeeperGauge.sol\";\nimport \"../../interfaces/tokenomics/IAmmGauge.sol\";\n\nimport \"../../libraries/EnumerableMapping.sol\";\nimport \"../../libraries/EnumerableExtensions.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../libraries/UncheckedMath.sol\";\n\nimport \"./Minter.sol\";\nimport \"../utils/Preparable.sol\";\nimport \"../access/Authorization.sol\";\n\ncontract InflationManager is Authorization, IInflationManager, Preparable {\n    using UncheckedMath for uint256;\n    using EnumerableMapping for EnumerableMapping.AddressToAddressMap;\n    using EnumerableExtensions for EnumerableMapping.AddressToAddressMap;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IAddressProvider public immutable addressProvider;\n\n    bytes32 internal constant _KEEPER_WEIGHT_KEY = \"keeperWeight\";\n    bytes32 internal constant _AMM_WEIGHT_KEY = \"ammWeight\";\n    bytes32 internal constant _LP_WEIGHT_KEY = \"lpWeight\";\n\n    address public minter;\n    bool public weightBasedKeeperDistributionDeactivated;\n    uint256 public totalKeeperPoolWeight;\n    uint256 public totalLpPoolWeight;\n    uint256 public totalAmmTokenWeight;\n\n    // Pool -> keeperGauge\n    EnumerableMapping.AddressToAddressMap private _keeperGauges;\n    // AMM token -> ammGauge\n    EnumerableMapping.AddressToAddressMap private _ammGauges;\n\n    mapping(address => bool) public gauges;\n\n    event NewKeeperWeight(address indexed pool, uint256 newWeight);\n    event NewLpWeight(address indexed pool, uint256 newWeight);\n    event NewAmmTokenWeight(address indexed token, uint256 newWeight);\n\n    modifier onlyGauge() {\n        require(gauges[msg.sender], Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor(IAddressProvider _addressProvider)\n        Authorization(_addressProvider.getRoleManager())\n    {\n        addressProvider = _addressProvider;\n    }\n\n    function setMinter(address _minter) external override onlyGovernance returns (bool) {\n        require(minter == address(0), Error.ADDRESS_ALREADY_SET);\n        require(_minter != address(0), Error.INVALID_MINTER);\n        minter = _minter;\n        return true;\n    }\n\n    /**\n     * @notice Advance the keeper gauge for a pool by on epoch.\n     * @param pool Pool for which the keeper gauge is advanced.\n     * @return `true` if successful.\n     */\n    function advanceKeeperGaugeEpoch(address pool) external override onlyGovernance returns (bool) {\n        IKeeperGauge(_keeperGauges.get(pool)).advanceEpoch();\n        return true;\n    }\n\n    /**\n     * @notice Mints BKD tokens.\n     * @param beneficiary Address to receive the tokens.\n     * @param amount Amount of tokens to mint.\n     */\n    function mintRewards(address beneficiary, uint256 amount) external override onlyGauge {\n        Minter(minter).mint(beneficiary, amount);\n    }\n\n    /**\n     * @notice Deactivates the weight-based distribution of keeper inflation.\n     * @dev This can only be done once, when the keeper inflation mechanism is altered.\n     * @return `true` if successful.\n     */\n    function deactivateWeightBasedKeeperDistribution()\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(!weightBasedKeeperDistributionDeactivated, \"Weight-based dist. deactivated.\");\n        address[] memory liquidityPools = addressProvider.allPools();\n        uint256 length = liquidityPools.length;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            _removeKeeperGauge(address(liquidityPools[i]));\n        }\n        weightBasedKeeperDistributionDeactivated = true;\n        return true;\n    }\n\n    /**\n     * @notice Checkpoints all gauges.\n     * @dev This is mostly used upon inflation rate updates.\n     * @return `true` if successful.\n     */\n    function checkpointAllGauges() external override returns (bool) {\n        uint256 length = _keeperGauges.length();\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            IKeeperGauge(_keeperGauges.valueAt(i)).poolCheckpoint();\n        }\n        address[] memory stakerVaults = addressProvider.allStakerVaults();\n        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {\n            IStakerVault(stakerVaults[i]).poolCheckpoint();\n        }\n\n        length = _ammGauges.length();\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            IAmmGauge(_ammGauges.valueAt(i)).poolCheckpoint();\n        }\n        return true;\n    }\n\n    /**\n     * @notice Prepare update of a keeper pool weight (with time delay enforced).\n     * @param pool Pool to update the keeper weight for.\n     * @param newPoolWeight New weight for the keeper inflation for the pool.\n     * @return `true` if successful.\n     */\n    function prepareKeeperPoolWeight(address pool, uint256 newPoolWeight)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(_keeperGauges.contains(pool), Error.INVALID_ARGUMENT);\n        bytes32 key = _getKeeperGaugeKey(pool);\n        _prepare(key, newPoolWeight);\n        return true;\n    }\n\n    /**\n     * @notice Execute update of keeper pool weight (with time delay enforced).\n     * @param pool Pool to execute the keeper weight update for.\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return New keeper pool weight.\n     */\n    function executeKeeperPoolWeight(address pool) external override returns (uint256) {\n        bytes32 key = _getKeeperGaugeKey(pool);\n        _executeKeeperPoolWeight(key, pool, isInflationWeightManager(msg.sender));\n        return currentUInts256[key];\n    }\n\n    /**\n     * @notice Prepare update of a batch of keeperGauge weights (with time delay enforced).\n     * @dev Each entry in the pools array corresponds to an entry in the weights array.\n     * @param pools Pools to update the keeper weight for.\n     * @param weights New weights for the keeper inflation for the pools.\n     * @return `true` if successful.\n     */\n    function batchPrepareKeeperPoolWeights(address[] calldata pools, uint256[] calldata weights)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        uint256 length = pools.length;\n        require(length == weights.length, Error.INVALID_ARGUMENT);\n        bytes32 key;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            require(_keeperGauges.contains(pools[i]), Error.INVALID_ARGUMENT);\n            key = _getKeeperGaugeKey(pools[i]);\n            _prepare(key, weights[i]);\n        }\n        return true;\n    }\n\n    function whitelistGauge(address gauge) external override onlyRole(Roles.CONTROLLER) {\n        gauges[gauge] = true;\n    }\n\n    /**\n     * @notice Execute weight updates for a batch of _keeperGauges.\n     * @param pools Pools to execute the keeper weight updates for.\n     * @return `true` if successful.\n     */\n    function batchExecuteKeeperPoolWeights(address[] calldata pools)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = pools.length;\n        bytes32 key;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            key = _getKeeperGaugeKey(pools[i]);\n            _executeKeeperPoolWeight(key, pools[i], isInflationWeightManager(msg.sender));\n        }\n        return true;\n    }\n\n    function removeStakerVaultFromInflation(address stakerVault, address lpToken)\n        external\n        override\n        onlyRole(Roles.CONTROLLER)\n    {\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        _prepare(key, 0);\n        _executeLpPoolWeight(key, lpToken, stakerVault, true);\n    }\n\n    /**\n     * @notice Prepare update of a lp pool weight (with time delay enforced).\n     * @param lpToken LP token to update the weight for.\n     * @param newPoolWeight New LP inflation weight.\n     * @return `true` if successful.\n     */\n    function prepareLpPoolWeight(address lpToken, uint256 newPoolWeight)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        address stakerVault = addressProvider.getStakerVault(lpToken);\n        // Require both that gauge is registered and that pool is still in action\n        require(gauges[IStakerVault(stakerVault).getLpGauge()], Error.GAUGE_DOES_NOT_EXIST);\n        _ensurePoolExists(lpToken);\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        _prepare(key, newPoolWeight);\n        return true;\n    }\n\n    /**\n     * @notice Execute update of lp pool weight (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return New lp pool weight.\n     */\n    function executeLpPoolWeight(address lpToken) external override returns (uint256) {\n        address stakerVault = addressProvider.getStakerVault(lpToken);\n        // Require both that gauge is registered and that pool is still in action\n        require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);\n        _ensurePoolExists(lpToken);\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        _executeLpPoolWeight(key, lpToken, stakerVault, isInflationWeightManager(msg.sender));\n        return currentUInts256[key];\n    }\n\n    /**\n     * @notice Prepare update of a batch of LP token weights (with time delay enforced).\n     * @dev Each entry in the lpTokens array corresponds to an entry in the weights array.\n     * @param lpTokens LpTokens to update the inflation weight for.\n     * @param weights New weights for the inflation for the LpTokens.\n     * @return `true` if successful.\n     */\n    function batchPrepareLpPoolWeights(address[] calldata lpTokens, uint256[] calldata weights)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = lpTokens.length;\n        require(length == weights.length, \"Invalid length of arguments\");\n        bytes32 key;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            address stakerVault = addressProvider.getStakerVault(lpTokens[i]);\n            // Require both that gauge is registered and that pool is still in action\n            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);\n            _ensurePoolExists(lpTokens[i]);\n            key = _getLpStakerVaultKey(stakerVault);\n            _prepare(key, weights[i]);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Execute weight updates for a batch of LpTokens.\n     * @dev If this is called by the INFLATION_MANAGER role address, no time delay is enforced.\n     * @param lpTokens LpTokens to execute the weight updates for.\n     * @return `true` if successful.\n     */\n    function batchExecuteLpPoolWeights(address[] calldata lpTokens)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = lpTokens.length;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            address lpToken = lpTokens[i];\n            address stakerVault = addressProvider.getStakerVault(lpToken);\n            // Require both that gauge is registered and that pool is still in action\n            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);\n            _ensurePoolExists(lpToken);\n            bytes32 key = _getLpStakerVaultKey(stakerVault);\n            _executeLpPoolWeight(key, lpToken, stakerVault, isInflationWeightManager(msg.sender));\n        }\n        return true;\n    }\n\n    /**\n     * @notice Prepare an inflation weight update for an AMM token (with time delay enforced).\n     * @param token AMM token to update the weight for.\n     * @param newTokenWeight New AMM token inflation weight.\n     * @return `true` if successful.\n     */\n    function prepareAmmTokenWeight(address token, uint256 newTokenWeight)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        require(_ammGauges.contains(token), \"amm gauge not found\");\n        bytes32 key = _getAmmGaugeKey(token);\n        _prepare(key, newTokenWeight);\n        return true;\n    }\n\n    /**\n     * @notice Execute update of lp pool weight (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return New lp pool weight.\n     */\n    function executeAmmTokenWeight(address token) external override returns (uint256) {\n        bytes32 key = _getAmmGaugeKey(token);\n        _executeAmmTokenWeight(token, key, isInflationWeightManager(msg.sender));\n        return currentUInts256[key];\n    }\n\n    /**\n     * @notice Registers a pool's strategy with the stakerVault of the pool where the strategy deposits.\n     * @dev This simply avoids the strategy accumulating tokens in the deposit pool.\n     * @param depositStakerVault StakerVault of the pool where the strategy deposits.\n     * @param strategyPool The pool of the strategy to register (avoids blacklisting other addresses).\n     * @return `true` if successful.\n     */\n    function addStrategyToDepositStakerVault(address depositStakerVault, address strategyPool)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        IVault _vault = ILiquidityPool(strategyPool).getVault();\n        IStakerVault(depositStakerVault).addStrategy(address(_vault.getStrategy()));\n        return true;\n    }\n\n    /**\n     * @notice Prepare update of a batch of AMM token weights (with time delay enforced).\n     * @dev Each entry in the tokens array corresponds to an entry in the weights array.\n     * @param tokens AMM tokens to update the inflation weight for.\n     * @param weights New weights for the inflation for the AMM tokens.\n     * @return `true` if successful.\n     */\n    function batchPrepareAmmTokenWeights(address[] calldata tokens, uint256[] calldata weights)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = tokens.length;\n        bytes32 key;\n        require(length == weights.length, \"Invalid length of arguments\");\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            require(_ammGauges.contains(tokens[i]), \"amm gauge not found\");\n            key = _getAmmGaugeKey(tokens[i]);\n            _prepare(key, weights[i]);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Execute weight updates for a batch of AMM tokens.\n     * @dev If this is called by the INFLATION_MANAGER role address, no time delay is enforced.\n     * @param tokens AMM tokens to execute the weight updates for.\n     * @return `true` if successful.\n     */\n    function batchExecuteAmmTokenWeights(address[] calldata tokens)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = tokens.length;\n        bool isWeightManager = isInflationWeightManager(msg.sender);\n        bytes32 key;\n        address token;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            token = tokens[i];\n            key = _getAmmGaugeKey(token);\n            _executeAmmTokenWeight(token, key, isWeightManager);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Sets the KeeperGauge for a pool.\n     * @dev Multiple pools can have the same KeeperGauge.\n     * @param pool Address of pool to set the KeeperGauge for.\n     * @param _keeperGauge Address of KeeperGauge.\n     * @return `true` if successful.\n     */\n    function setKeeperGauge(address pool, address _keeperGauge)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        uint256 length = _keeperGauges.length();\n        bool keeperGaugeExists = false;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            if (address(_keeperGauges.valueAt(i)) == _keeperGauge) {\n                keeperGaugeExists = true;\n                break;\n            }\n        }\n        // Check to make sure that once weight-based dist is deactivated, only one gauge can exist\n        if (!keeperGaugeExists && weightBasedKeeperDistributionDeactivated && length >= 1) {\n            return false;\n        }\n        (bool exists, address keeperGauge) = _keeperGauges.tryGet(pool);\n        require(!exists || keeperGauge != _keeperGauge, Error.INVALID_ARGUMENT);\n\n        if (exists && !IKeeperGauge(keeperGauge).killed()) {\n            IKeeperGauge(keeperGauge).poolCheckpoint();\n            IKeeperGauge(keeperGauge).kill();\n        }\n        _keeperGauges.set(pool, _keeperGauge);\n        gauges[_keeperGauge] = true;\n        return true;\n    }\n\n    function removeKeeperGauge(address pool) external onlyGovernance returns (bool) {\n        _removeKeeperGauge(pool);\n        return true;\n    }\n\n    /**\n     * @notice Sets the AmmGauge for a particular AMM token.\n     * @param token Address of the amm token.\n     * @param _ammGauge Address of AmmGauge.\n     * @return `true` if successful.\n     */\n    function setAmmGauge(address token, address _ammGauge)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(IAmmGauge(_ammGauge).isAmmToken(token), Error.ADDRESS_NOT_WHITELISTED);\n        uint256 length = _ammGauges.length();\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            if (address(_ammGauges.valueAt(i)) == _ammGauge) {\n                return false;\n            }\n        }\n        if (_ammGauges.contains(token)) {\n            address ammGauge = _ammGauges.get(token);\n            IAmmGauge(ammGauge).poolCheckpoint();\n            IAmmGauge(ammGauge).kill();\n        }\n        _ammGauges.set(token, _ammGauge);\n        gauges[_ammGauge] = true;\n        return true;\n    }\n\n    function removeAmmGauge(address token) external override onlyGovernance returns (bool) {\n        if (!_ammGauges.contains(token)) return false;\n        address ammGauge = _ammGauges.get(token);\n        bytes32 key = _getAmmGaugeKey(token);\n        _prepare(key, 0);\n        _executeAmmTokenWeight(token, key, true);\n        IAmmGauge(ammGauge).kill();\n        _ammGauges.remove(token);\n        // Do not delete from the gauges map to allow claiming of remaining balances\n        emit AmmGaugeDelisted(token, ammGauge);\n        return true;\n    }\n\n    function addGaugeForVault(address lpToken) external override returns (bool) {\n        IStakerVault _stakerVault = IStakerVault(msg.sender);\n        require(addressProvider.isStakerVault(msg.sender, lpToken), Error.UNAUTHORIZED_ACCESS);\n        address lpGauge = _stakerVault.getLpGauge();\n        require(lpGauge != address(0), Error.GAUGE_DOES_NOT_EXIST);\n        gauges[lpGauge] = true;\n        return true;\n    }\n\n    function getAllAmmGauges() external view override returns (address[] memory) {\n        return _ammGauges.valuesArray();\n    }\n\n    function getLpRateForStakerVault(address stakerVault) external view override returns (uint256) {\n        if (minter == address(0) || totalLpPoolWeight == 0) {\n            return 0;\n        }\n\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        uint256 lpInflationRate = Minter(minter).getLpInflationRate();\n        uint256 poolInflationRate = (currentUInts256[key] * lpInflationRate) / totalLpPoolWeight;\n\n        return poolInflationRate;\n    }\n\n    function getKeeperRateForPool(address pool) external view override returns (ui"
    }
  ]
}