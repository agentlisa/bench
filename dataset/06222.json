{
  "Title": "[H-11] TOFT `exerciseOption` can be used to steal all underlying erc20 tokens",
  "Content": "\nUnvalidated input data for the [`exerciseOption`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L127) function can be used to steal all the erc20 tokens from the contract.\n\n### Proof of Concept\n\nEach [BaseTOFT](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol) is a wrapper around an `erc20` token and extends the `OFTV2` contract to enable smooth cross-chain transfers through LayerZero.\nDepending on the erc20 token which is used usually the erc20 tokens will be held on one chain and then only the shares of `OFTV2` get transferred around (burnt on one chain, minted on another chain).\nSubject to this attack is `TapiocaOFTs` or `mTapiocaOFTs` which store as an [underlying token an erc20 token(not native)](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/TapiocaOFT.sol#L77). In order to mint `TOFT` shares you need to deposit the underlying erc20 tokens into the contract, and you get `TOFT` shares.\n\nThe attack flow is the following:\n\n1.  The attack starts from the [`exerciseOption`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L127-L146). Nothing is validated here and the only cost of the attack is the [`optionsData.paymentTokenAmount`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L87) which is burned from the attacker. This can be some small amount.\n2.  When the message is received on the remote chain inside the [`exercise`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L153) function it is important that nothing reverts for the attacker.\n3.  For the attacker to go through the attacker needs to pass the following data:\n\n```soldity\nfunction exerciseInternal(\n        address from,\n        uint256 oTAPTokenID,\n        address paymentToken,\n        uint256 tapAmount,\n        address target,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            memory tapSendData,\n        ICommonData.IApproval[] memory approvals\n    ) public {\n        // pass zero approval so this is skipped \n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n        \n        // target is the address which does nothing, but has the exerciseOption implemented\n        ITapiocaOptionsBroker(target).exerciseOption(\n            oTAPTokenID,\n            paymentToken,\n            tapAmount\n        );\n        // tapSendData.withdrawOnAnotherChain = false so we enter else branch\n        if (tapSendData.withdrawOnAnotherChain) {\n            ISendFrom(tapSendData.tapOftAddress).sendFrom(\n                address(this),\n                tapSendData.lzDstChainId,\n                LzLib.addressToBytes32(from),\n                tapAmount,\n                ISendFrom.LzCallParams({\n                    refundAddress: payable(from),\n                    zroPaymentAddress: tapSendData.zroPaymentAddress,\n                    adapterParams: LzLib.buildDefaultAdapterParams(\n                        tapSendData.extraGas\n                    )\n                })\n            );\n        } else {\n            // tapSendData.tapOftAddress is the address of the underlying erc20 token for this TOFT\n            // from is the address of the attacker\n            // tapAmount is the balance of erc20 tokens of this TOFT\n            IERC20(tapSendData.tapOftAddress).safeTransfer(from, tapAmount);\n        }\n    }\n```\n\n4.  So the attack is just simply transferring all the underlying erc20 tokens to the attacker.\n\nThe underlying `ERC20` token for each `TOFT` can be queried through [`erc20()`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFTStorage.sol#L28) function, and the `tapAmount` to pass is `ERC20` balance of the `TOFT`.\n\nThis attack is possible because the `msg.sender` inside the `exerciseInternal` is the address of the `TOFT` which is the owner of all the ERC20 tokens that get stolen.\n\n### Recommended Mitigation Steps\n\nValidate that `tapSendData.tapOftAddress` is the address of [`TapOFT`](https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/TapOFT.sol) token either while sending the message or during the reception of the message on the remote chain.\n\n**[0xRektora (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1307#issuecomment-1703035021)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/tOFT/BaseTOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./BaseTOFTStorage.sol\";\n\n//TOFT MODULES\nimport \"./modules/BaseTOFTLeverageModule.sol\";\nimport \"./modules/BaseTOFTStrategyModule.sol\";\nimport \"./modules/BaseTOFTMarketModule.sol\";\nimport \"./modules/BaseTOFTOptionsModule.sol\";\n\n/// @title BaseTOFT contract \n/// @notice Common tOFT capabilitites\n/// @dev all LayerZero methods are defined here\ncontract BaseTOFT is BaseTOFTStorage, ERC20Permit {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum Module {\n        Leverage,\n        Strategy,\n        Market,\n        Options\n    }\n\n    /// @notice returns the leverage module\n    BaseTOFTLeverageModule public leverageModule;\n\n    /// @notice returns the Strategy module\n    BaseTOFTStrategyModule public strategyModule;\n\n    /// @notice returns the Market module\n    BaseTOFTMarketModule public marketModule;\n\n    /// @notice returns the Options module\n    BaseTOFTOptionsModule public optionsModule;\n\n    // ******************//\n    // *** MODIFIERS *** //\n    // ***************** //\n    /// @notice Require that the caller is on the host chain of the ERC20.\n    modifier onlyHostChain() {\n        require(block.chainid == hostChainID, \"TOFT_host\");\n        _;\n    }\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID,\n        address payable _leverageModule,\n        address payable _strategyModule,\n        address payable _marketModule,\n        address payable _optionsModule\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n        ERC20Permit(string(abi.encodePacked(\"TapiocaOFT-\", _name)))\n    {\n        leverageModule = BaseTOFTLeverageModule(_leverageModule);\n        strategyModule = BaseTOFTStrategyModule(_strategyModule);\n        marketModule = BaseTOFTMarketModule(_marketModule);\n        optionsModule = BaseTOFTOptionsModule(_optionsModule);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice decimal number of the ERC20\n    function decimals() public view override returns (uint8) {\n        if (_decimalCache == 0) return 18; //temporary fix for LZ _sharedDecimals check\n        return _decimalCache;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice triggers a sendFrom to another layer from destination\n    /// @param lzDstChainId LZ destination id\n    /// @param airdropAdapterParams airdrop params\n    /// @param zroPaymentAddress ZRO payment address\n    /// @param amount amount to send back\n    /// @param sendFromData data needed to trigger sendFrom on destination\n    /// @param approvals approvals array\n    function triggerSendFrom(\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        address zroPaymentAddress,\n        uint256 amount,\n        ISendFrom.LzCallParams calldata sendFromData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.triggerSendFrom.selector,\n                lzDstChainId,\n                airdropAdapterParams,\n                zroPaymentAddress,\n                amount,\n                sendFromData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice Exercise an oTAP position\n    /// @param optionsData oTap exerciseOptions data\n    /// @param lzData data needed for the cross chain transer\n    /// @param tapSendData needed for withdrawing Tap token\n    /// @param approvals array\n    function exerciseOption(\n        ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n            calldata optionsData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZData calldata lzData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            calldata tapSendData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.exerciseOption.selector,\n                optionsData,\n                lzData,\n                tapSendData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice inits a multiHopSellCollateral call\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param swapData Swap data used on destination chain for swapping USDO to the underlying TOFT token\n    /// @param lzData LayerZero specific data\n    /// @param externalData External contracts used for the cross chain operation\n    /// @param airdropAdapterParams default or airdrop adapter params\n    /// @param approvals array\n    function initMultiSell(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData,\n        bytes calldata airdropAdapterParams,\n        ICommonData.IApproval[] memory approvals\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                BaseTOFTLeverageModule.initMultiSell.selector,\n                from,\n                share,\n                swapData,\n                lzData,\n                externalData,\n                airdropAdapterParams,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice calls removeCollateral on another layer\n    /// @param from sending address\n    /// @param to receiver address\n    /// @param lzDstChainId LayerZero destination chain id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param withdrawParams withdrawTo specific params\n    /// @param removeParams removeAsset specific params\n    /// @param approvals approvals specific params\n    /// @param adapterParams LZ adapter params\n    function removeCollateral(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ITapiocaOFT.IRemoveParams calldata removeParams,\n        ICommonData.IApproval[] calldata approvals,\n        bytes calldata adapterParams\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                BaseTOFTMarketModule.removeCollateral.selector,\n                from,\n                to,\n                lzDstChainId,\n                zroPaymentAddress,\n                withdrawParams,\n                removeParams,\n                approvals,\n                adapterParams\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param options the operation data\n    function sendToStrategy(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        ICommonData.ISendOptions calldata options\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.sendToStrategy.selector,\n                from,\n                to,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                options\n            ),\n            false\n        );\n    }\n\n    /// @notice extracts TOFT from a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param airdropAdapterParam the LayerZero aidrop adapter params\n    function retrieveFromStrategy(\n        address from,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        bytes memory airdropAdapterParam\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.retrieveFromStrategy.selector,\n                from,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                zroPaymentAddress,\n                airdropAdapterParam\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a borrow operation\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param airdropAdapterParams the LayerZero aidrop adapter params\n    /// @param borrowParams the borrow operation data\n    /// @param withdrawParams the withdraw operation data\n    /// @param options the cross chain send operation data\n    /// @param approvals the cross chain approval operation data\n    function sendToYBAndBorrow(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        ITapiocaOFT.IBorrowParams calldata borrowParams,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ICommonData.ISendOptions calldata options,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                BaseTOFTMarketModule.sendToYBAndBorrow.selector,\n                from,\n                to,\n                lzDstChainId,\n                airdropAdapterParams,\n                borrowParams,\n                withdrawParams,\n                options,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a leverage down operation\n    /// @param amount the amount to use\n    /// @param leverageFor the receiver address\n    /// @param lzData LZ specific data\n    /// @param swapData ISwapper specific data\n    /// @param externalData external contracts used for the flow\n    function sendForLeverage(\n        uint256 amount,\n        address leverageFor,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                BaseTOFTLeverageModule.sendForLeverage.selector,\n                amount,\n                leverageFor,\n                lzData,\n                swapData,\n                externalData\n            ),\n            false\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n\n    //---internal-\n    function _wrap(\n        address _fromAddress,\n        address _toAddress,\n        uint256 _amount\n    ) internal virtual {\n        if (_fromAddress != msg.sender) {\n            require(\n                allowance(_fromAddress, msg.sender) >= _amount,\n                \"TOFT_allowed\"\n            );\n        }\n        IERC20(erc20).safeTransferFrom(_fromAddress, address(this), _amount);\n        _mint(_toAddress, _amount);\n    }\n\n    function _wrapNative(address _toAddress) internal virtual {\n        require(msg.value > 0, \"TOFT_0\");\n        _mint(_toAddress, msg.value);\n    }\n\n    function _unwrap(address _toAddress, uint256 _amount) internal virtual {\n        _burn(msg.sender, _amount);\n\n        if (erc20 == address(0)) {\n            _safeTransferETH(_toAddress, _amount);\n        } else {\n            IERC20(erc20).safeTransfer(_toAddress, _amount);\n        }\n    }\n\n    //---private---\n    function _safeTransferETH(address to, uint256 amount) internal {\n        (bool sent, ) = to.call{value: amount}(\"\");\n        require(sent, \"TOFT_failed\");\n    }\n\n    function _extractModule(Module _module) private view returns (address) {\n        address module;\n        if (_module == Module.Leverage) {\n            module = address(leverageModule);\n        } else if (_module == Module.Strategy) {\n            module = address(strategyModule);\n        } else if (_module == Module.Market) {\n            module = address(marketModule);\n        } else if (_module == Module.Options) {\n            module = address(optionsModule);\n        }\n\n        if (module == address(0)) {\n            revert(\"TOFT_module\");\n        }\n\n        return module;\n    }\n\n    function _executeModule(\n        Module _module,\n        bytes memory _data,\n        bool _forwardRevert\n    ) private returns (bool success, bytes memory returnData) {\n        success = true;\n        address module = _extractModule(_module);\n\n        (success, returnData) = module.delegatecall(_data);\n        if (!success && !_forwardRevert) {\n            revert(_getRevertMsg(returnData));\n        }\n    }\n\n    function _executeOnDestination(\n        Module _module,\n        bytes memory _data,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) private {\n        (bool success, bytes memory returnData) = _executeModule(\n            _module,\n            _data,\n            true\n        );\n        if (!success) {\n            _storeFailedMessage(\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload,\n                returnData\n            );\n        }\n    }\n\n    //---LZ---\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual override {\n        uint256 packetType = _payload.toUint256(0);\n\n        if (packetType == PT_YB_SEND_STRAT) {\n            _executeOnDestination(\n                Module.Strategy,\n                abi.encodeWithSelector(\n                    BaseTOFTStrategyModule.strategyDeposit.selector,\n                    strategyModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload,\n                    IERC20(address(this))\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_YB_RETRIEVE_STRAT) {\n            _executeOnDestination(\n                Module.Strategy,\n                abi.encodeWithSelector(\n                    BaseTOFTStrategyModule.strategyWithdraw.selector,\n                    _srcChainId,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_LEVERAGE_MARKET_DOWN) {\n            _executeOnDestination(\n                Module.Leverage,\n                abi.encodeWithSelector(\n                    BaseTOFTLeverageModule.leverageDown.selector,\n                    leverageModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_YB_SEND_SGL_BORROW) {\n            _executeOnDestination(\n                Module.Market,\n                abi.encodeWithSelector(\n                    BaseTOFTMarketModule.borrow.selector,\n                    marketModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_MARKET_REMOVE_COLLATERAL) {\n            _executeOnDestination(\n                Module.Market,\n                abi.encodeWithSelector(\n                    BaseTOFTMarketModule.remove.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_MARKET_MULTIHOP_SELL) {\n            _executeOnDestination(\n                Module.Leverage,\n                abi.encodeWithSelector(\n                    BaseTOFTLeverageModule.multiHop.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_TAP_EXERCISE) {\n            _executeOnDestination(\n                Module.Options,\n                abi.encodeWithSelector(\n                    BaseTOFTOptionsModule.exercise.selector,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_SEND_FROM) {\n            _executeOnDestination(\n                Module.Options,\n                abi.encodeWithSelector(\n                    BaseTOFTOptionsModule.sendFromDestination.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else {\n            packetType = _payload.toUint8(0);\n            if (packetType == PT_SEND) {\n                _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n            } else if (packetType == PT_SEND_AND_CALL) {\n                _sendAndCallAck(_srcChainId, _srcAddress, _nonce, _payload);\n            } else {\n                revert(\"TOFT_packet\");\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/TapiocaOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\nimport \"./BaseTOFT.sol\";\n\n/*\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n*/\n\n/// @title tOFT contract\n/// @notice tOFT wrapper contract\n/// @dev transforms a normal ERC20 or the native gas token into an OFTV2 type contract\n///      - wrapping & unwrapping of the ERC20/the gas token can only happen on the host chain\ncontract TapiocaOFT is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    /// @notice creates a new TapiocaOFT\n    /// @param _lzEndpoint LayerZero endpoint address\n    /// @param _erc20 true the underlying ERC20 address\n    /// @param _yieldBox the YieldBox address\n    /// @param _name the TOFT name\n    /// @param _symbol the TOFT symbol\n    /// @param _decimal the TOFT decimal\n    /// @param _hostChainID the TOFT host chain LayerZero id\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID,\n        address payable _leverageModule,\n        address payable _strategyModule,\n        address payable _marketModule,\n        address payable _optionsModule\n    )\n        BaseTOFT(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID,\n            _leverageModule,\n            _strategyModule,\n            _marketModule,\n            _optionsModule\n        )\n    {}\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Wrap an ERC20 with a 1:1 ratio with a fee if existing.\n    /// @dev Since it can be executed only on the main chain, if an address exists on the OP chain it will not allowed to wrap.\n    /// @param _fromAddress The address to wrap from.\n    /// @param _toAddress The address to wrap the ERC20 to.\n    /// @param _amount The amount of ERC20 to wrap.\n    function wrap(\n        address _fromAddress,\n        address _toAddress,\n        uint256 _amount\n    ) external payable onlyHostChain {\n        if (erc20 == address(0)) {\n            _wrapNative(_toAddress);\n        } else {\n            _wrap(_fromAddress, _toAddress, _amount);\n        }\n    }\n\n    /// @notice Unwrap an ERC20/Native with a 1:1 ratio. Called only on host chain.\n    /// @param _toAddress The address to unwrap the tokens to.\n    /// @param _amount The amount of tokens to unwrap.\n\n    function unwrap(\n        address _toAddress,\n        uint256 _amount\n    ) external onlyHostChain {\n        _unwrap(_toAddress, _amount);\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/BaseTOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./BaseTOFTStorage.sol\";\n\n//TOFT MODULES\nimport \"./modules/BaseTOFTLeverageModule.sol\";\nimport \"./modules/BaseTOFTStrategyModule.sol\";\nimport \"./modules/BaseTOFTMarketModule.sol\";\nimport \"./modules/BaseTOFTOptionsModule.sol\";\n\n/// @title BaseTOFT contract \n/// @notice Common tOFT capabilitites\n/// @dev all LayerZero methods are defined here\ncontract BaseTOFT is BaseTOFTStorage, ERC20Permit {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum Module {\n        Leverage,\n        Strategy,\n        Market,\n        Options\n    }\n\n    /// @notice returns the leverage module\n    BaseTOFTLeverageModule public leverageModule;\n\n    /// @notice returns the Strategy module\n    BaseTOFTStrategyModule public strategyModule;\n\n    /// @notice returns the Market module\n    BaseTOFTMarketModule public marketModule;\n\n    /// @notice returns the Options module\n    BaseTOFTOptionsModule public optionsModule;\n\n    // ******************//\n    // *** MODIFIERS *** //\n    // ***************** //\n    /// @notice Require that the caller is on the host chain of the ERC20.\n    modifier onlyHostChain() {\n        require(block.chainid == hostChainID, \"TOFT_host\");\n        _;\n    }\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID,\n        address payable _leverageModule,\n        address payable _strategyModule,\n        address payable _marketModule,\n        address payable _optionsModule\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n        ERC20Permit(string(abi.encodePacked(\"TapiocaOFT-\", _name)))\n    {\n        leverageModule = BaseTOFTLeverageModule(_leverageModule);\n        strategyModule = BaseTOFTStrategyModule(_strategyModule);\n        marketModule = BaseTOFTMarketModule(_marketModule);\n        optionsModule = BaseTOFTOptionsModule(_optionsModule);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice decimal number of the ERC20\n    function decimals() public view override returns (uint8) {\n        if (_decimalCache == 0) return 18; //temporary fix for LZ _sharedDecimals check\n        return _decimalCache;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice triggers a sendFrom to another layer from destination\n    /// @param lzDstChainId LZ destination id\n    /// @param airdropAdapterParams airdrop params\n    /// @param zroPaymentAddress ZRO payment address\n    /// @param amount amount to send back\n    /// @param sendFromData data needed to trigger sendFrom on destination\n    /// @param approvals approvals array\n    function triggerSendFrom(\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        address zroPaymentAddress,\n        uint256 amount,\n        ISendFrom.LzCallParams calldata sendFromData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.triggerSendFrom.selector,\n                lzDstChainId,\n                airdropAdapterParams,\n                zroPaymentAddress,\n                amount,\n                sendFromData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice Exercise an oTAP position\n    /// @param optionsData oTap exerciseOptions data\n    /// @param lzData data needed for the cross chain transer\n    /// @param tapSendData needed for withdrawing Tap token\n    /// @param approvals array\n    function exerciseOption(\n        ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n            calldata optionsData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZData calldata lzData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            calldata tapSendData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.exerciseOption.selector,\n                optionsData,\n                lzData,\n                tapSendData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice inits a multiHopSellCollateral call\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param swapData Swap data used on destination chain for swapping USDO to the underlying TOFT token\n    /// @param lzData LayerZero specific data\n    /// @param externalData External contracts used for the cross chain operation\n    /// @param airdropAdapterParams default or airdrop adapter params\n    /// @param approvals array\n    function initMultiSell(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData,\n        bytes calldata airdropAdapterParams,\n        ICommonData.IApproval[] memory approvals\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                BaseTOFTLeverageModule.initMultiSell.selector,\n                from,\n                share,\n                swapData,\n                lzData,\n                externalData,\n                airdropAdapterParams,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice calls removeCollateral on another layer\n    /// @param from sending address\n    /// @param to receiver address\n    /// @param lzDstChainId LayerZero destination chain id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param withdrawParams withdrawTo specific params\n    /// @param removeParams removeAsset specific params\n    /// @param approvals approvals specific params\n    /// @param adapterParams LZ adapter params\n    function removeCollateral(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ITapiocaOFT.IRemoveParams calldata removeParams,\n        ICommonData.IApproval[] calldata approvals,\n        bytes calldata adapterParams\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                BaseTOFTMarketModule.removeCollateral.selector,\n                from,\n                to,\n                lzDstChainId,\n                zroPaymentAddress,\n                withdrawParams,\n                removeParams,\n                approvals,\n                adapterParams\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param options the operation data\n    function sendToStrategy(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        ICommonData.ISendOptions calldata options\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.sendToStrategy.selector,\n                from,\n                to,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                options\n            ),\n            false\n        );\n    }\n\n    /// @notice extracts TOFT from a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param airdropAdapterParam the LayerZero aidrop adapter params\n    function retrieveFromStrategy(\n        address from,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        bytes memory airdropAdapterParam\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.retrieveFromStrategy.selector,\n                from,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                zroPaymentAddress,\n                airdropAdapterParam\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a borrow operation\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param airdropAdapterParams the LayerZero aidrop adapter params\n    /// @param borrowParams the borrow operation data\n    /// @param withdrawParams the withdraw operation data\n    /// @param options the cross chain send operation data\n    /// @param approvals the cross chain approval operation data\n    function sendToYBAndBorrow(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        ITapiocaOFT.IBorrowParams calldata borrowParams,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ICommonData.ISendOptions calldata options,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector("
    }
  ]
}