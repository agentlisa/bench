{
  "Title": "M-1: Vesting contract cannot work with ETH, although it's supposed to.",
  "Content": "# Issue M-1: Vesting contract cannot work with ETH, although it's supposed to. \n\nSource: https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/54 \n\n## Found by \n0x4non, AMOW, GatewayGuardians, HonorLt, NickV, ZdravkoHr., bughuntoor, cats, enfrasico, klaus, merlin, s1ce, thank\\_you, ydlee\n## Summary\nVesting contract cannot work with native token, although it's supposed to. \n\n## Vulnerability Detail\nWithin the claim function, we can see that if `token`  is set to address(1), the contract should operate with ETH\n```solidity\n    function claim() external {\n        address sender = msg.sender;\n\n        UserDetails storage s = userdetails[sender];\n        require(s.userDeposit != 0, \"No Deposit\");\n        require(s.index != vestingPoints.length, \"already claimed\");\n        uint256 pctAmount;\n        uint256 i = s.index;\n        for (i; i <= vestingPoints.length - 1; i++) {\n            if (block.timestamp >= vestingPoints[i][0]) {\n                pctAmount += (s.userDeposit * vestingPoints[i][1]) / 10000;\n            } else {\n                break;\n            }\n        }\n        if (pctAmount != 0) {\n            if (address(token) == address(1)) {\n                (bool sent, ) = payable(sender).call{value: pctAmount}(\"\");  // @audit - here\n                require(sent, \"Failed to send BNB to receiver\");\n            } else {\n                token.safeTransfer(sender, pctAmount);\n            }\n            s.index = uint128(i);\n            s.amountClaimed += pctAmount;\n        }\n    }\n```\n\nHowever, it is actually impossible for the contract to operate with ETH, since `updateUserDeposit` always attempts to do a token transfer. \n```solidity\n    function updateUserDeposit(\n        address[] memory _users,\n        uint256[] memory _amount\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_users.length <= 250, \"array length should be less than 250\");\n        require(_users.length == _amount.length, \"array length should match\");\n        uint256 amount;\n        for (uint256 i = 0; i < _users.length; i++) {\n            userdetails[_users[i]].userDeposit = _amount[i];\n            amount += _amount[i];\n        }\n        token.safeTransferFrom(distributionWallet, address(this), amount); // @audit - this will revert\n    }\n```\n\nSince when the contract is supposed to work with ETH, token is set to address(1), calling `safeTransferFrom` on that address will always revert, thus making it impossible to call this function.\n\n## Impact\nVesting contract is unusable with ETH\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-zap-protocol/blob/main/zap-contracts-labs/contracts/Vesting.sol#L64\n\n## Tool used\n\nManual Review\n\n## Recommendation\nmake the following check \n```solidity\n        if (address(token) != address(1)) token.safeTransferFrom(distributionWallet, address(this), amount);\n```\n\n\n\n\n## Discussion\n\n**shubham-antier**\n\nRemoved ETH functionality from the contract.\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Lithium-Ventures/zap-contracts-labs/pull/5.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/243",
  "Code": [
    {
      "filename": "zap-contracts-labs/contracts/Vesting.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\n\nimport \"./interfaces/IAdmin.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract Vesting is Initializable, AccessControl {\n    using SafeERC20 for IERC20;\n\n    uint256[2][] public vestingPoints;\n    bytes32 public constant OPERATOR = keccak256(\"OPERATOR\");\n    address public tokensale;\n    address public distributionWallet;\n\n    IERC20 public token;\n\n    struct UserDetails {\n        uint256 amountClaimed;\n        uint256 userDeposit;\n        uint256 index;\n    }\n\n    mapping(address => UserDetails) public userdetails;\n\n    modifier validation(address _address) {\n        require(_address != address(0), \"Zero address\");\n        _;\n    }\n\n    function initialize(\n        address operator,\n        address _tokenSale,\n        IERC20 _token,\n        address _distributionWallet,\n        uint128[2][] memory _vestingPoints\n    ) public initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, operator);\n        tokensale = _tokenSale;\n        (vestingPoints, ) = ascendingSort(_vestingPoints);\n        token = _token;\n        distributionWallet = _distributionWallet;\n    }\n\n    function setDistributionWallet(\n        address _distributionWallet\n    ) external validation(_distributionWallet) onlyRole(DEFAULT_ADMIN_ROLE) {\n        distributionWallet = _distributionWallet;\n    }\n\n    function updateUserDeposit(\n        address[] memory _users,\n        uint256[] memory _amount\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_users.length <= 250, \"array length should be less than 250\");\n        require(_users.length == _amount.length, \"array length should match\");\n        uint256 amount;\n        for (uint256 i = 0; i < _users.length; i++) {\n            userdetails[_users[i]].userDeposit = _amount[i];\n            amount += _amount[i];\n        }\n        token.safeTransferFrom(distributionWallet, address(this), amount);\n    }\n\n    function claim() external {\n        address sender = msg.sender;\n\n        UserDetails storage s = userdetails[sender];\n        require(s.userDeposit != 0, \"No Deposit\");\n        require(s.index != vestingPoints.length, \"already claimed\");\n        uint256 pctAmount;\n        uint256 i = s.index;\n        for (i; i <= vestingPoints.length - 1; i++) {\n            if (block.timestamp >= vestingPoints[i][0]) {\n                pctAmount += (s.userDeposit * vestingPoints[i][1]) / 10000;\n            } else {\n                break;\n            }\n        }\n        if (pctAmount != 0) {\n            if (address(token) == address(1)) {\n                (bool sent, ) = payable(sender).call{value: pctAmount}(\"\");\n                require(sent, \"Failed to send BNB to receiver\");\n            } else {\n                token.safeTransfer(sender, pctAmount);\n            }\n            s.index = uint128(i);\n            s.amountClaimed += pctAmount;\n        }\n    }\n\n    function updateVestingPoints(\n        uint128[2][] memory _vestingPoints\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 sum;\n        (vestingPoints, sum) = ascendingSort(_vestingPoints);\n        require(sum == 10000, \"sum not 10000\");\n        require(block.timestamp <= _vestingPoints[0][0], \"Time lapsed\");\n    }\n\n    function getVestingPoints() external view returns (uint256[2][] memory) {\n        return vestingPoints;\n    }\n\n    function setTokenSaleContract(\n        address _address\n    ) external validation(_address) onlyRole(DEFAULT_ADMIN_ROLE) {\n        tokensale = _address;\n    }\n\n    function takeLockedBNB() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(address(this).balance > 0, \"No BNB amount\");\n        (bool sent, ) = payable(distributionWallet).call{\n            value: address(this).balance\n        }(\"\");\n        require(sent, \"Failed to send BNB\");\n    }\n\n    function removeOtherERC20Tokens(\n        address _tokenAddress\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        IERC20(_tokenAddress).safeTransfer(\n            distributionWallet,\n            IERC20(_tokenAddress).balanceOf(address(this))\n        );\n    }\n\n    function ascendingSort(\n        uint128[2][] memory arr\n    ) internal pure returns (uint128[2][] memory, uint256) {\n        uint256 l = arr.length;\n        uint256 sum;\n        for (uint256 i = 0; i < l; i++) {\n            for (uint256 j = i + 1; j < l; j++) {\n                if (arr[i][0] > arr[j][0]) {\n                    uint128[2] memory temp = arr[j];\n                    arr[j] = arr[i];\n                    arr[i] = temp;\n                }\n            }\n            sum += arr[i][1];\n        }\n        return (arr, sum);\n    }\n}"
    }
  ]
}