{
  "Title": "[L-01] Confusing semantics for bridged messages approvals",
  "Content": "\nhttps://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/DestinationBridge.sol#L111\n\nBridged messages get an \"automatic\" approval while the message is being executed in the destination bridge contract, which means that all messages effectively get one approval as soon as they are bridged.\n\nThis implies that \"real\" approvals would require setting a threshold with a `numberOfApprovalsNeeded` of at least two. \n\nThis brings a lot of unnecessary confusing semantics to the approvals scheme and could potentially lead to errors in configuration settings that would allow messages to go through automatically when actually they are expected to be approved. \n\nIt is recommended to remove this automatic approval and treat each approval as an explicit approval action of the set of enabled approvers.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-ondo",
  "Code": [
    {
      "filename": "contracts/bridge/DestinationBridge.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IAxelarGateway.sol\";\nimport \"contracts/interfaces/IAxelarGasService.sol\";\nimport \"contracts/external/axelar/AxelarExecutable.sol\";\nimport \"contracts/interfaces/IRWALike.sol\";\nimport \"contracts/interfaces/IAllowlist.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/Ownable.sol\";\nimport \"contracts/external/openzeppelin/contracts/security/Pausable.sol\";\nimport \"contracts/bridge/MintRateLimiter.sol\";\n\ncontract DestinationBridge is\n  AxelarExecutable,\n  MintTimeBasedRateLimiter,\n  Ownable,\n  Pausable\n{\n  /// @notice Token contract bridged by this contract\n  IRWALike public immutable TOKEN;\n\n  /// @notice Pointer to AxelarGateway contract\n  IAxelarGateway public immutable AXELAR_GATEWAY;\n\n  /// @notice Pointer to USDY allowlist\n  IAllowlist public immutable ALLOWLIST;\n\n  // Mapping used to track approvers, approved msg src's and spent nonces\n  mapping(address => bool) public approvers;\n  mapping(string => bytes32) public chainToApprovedSender;\n  mapping(bytes32 => mapping(uint256 => bool)) public isSpentNonce;\n\n  /// @notice Versioning for payload, must match SourceBridge version\n  bytes32 public constant VERSION = \"1.0\";\n\n  /// @notice Mappings used to track transaction and thresholds\n  mapping(bytes32 => TxnThreshold) public txnToThresholdSet;\n  mapping(string => Threshold[]) public chainToThresholds;\n  mapping(bytes32 => Transaction) public txnHashToTransaction;\n\n  constructor(\n    address _token,\n    address _axelarGateway,\n    address _allowlist,\n    address _ondoApprover,\n    address _owner,\n    uint256 _mintLimit,\n    uint256 _mintDuration\n  )\n    AxelarExecutable(_axelarGateway)\n    MintTimeBasedRateLimiter(_mintDuration, _mintLimit)\n  {\n    TOKEN = IRWALike(_token);\n    AXELAR_GATEWAY = IAxelarGateway(_axelarGateway);\n    ALLOWLIST = IAllowlist(_allowlist);\n    approvers[_ondoApprover] = true;\n    _transferOwnership(_owner);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                         Axelar Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Internal overriden function that is executed when contract is called by Axelar Gateway\n   *\n   * @param srcChain The string of the source chain eg: arbitrum\n   * @param srcAddr  The string of the address of the source contract\n   * @param payload  The payload to pass cross chain\n   */\n  function _execute(\n    string calldata srcChain,\n    string calldata srcAddr,\n    bytes calldata payload\n  ) internal override whenNotPaused {\n    (bytes32 version, address srcSender, uint256 amt, uint256 nonce) = abi\n      .decode(payload, (bytes32, address, uint256, uint256));\n\n    if (version != VERSION) {\n      revert InvalidVersion();\n    }\n    if (chainToApprovedSender[srcChain] == bytes32(0)) {\n      revert ChainNotSupported();\n    }\n    if (chainToApprovedSender[srcChain] != keccak256(abi.encode(srcAddr))) {\n      revert SourceNotSupported();\n    }\n    if (isSpentNonce[chainToApprovedSender[srcChain]][nonce]) {\n      revert NonceSpent();\n    }\n\n    isSpentNonce[chainToApprovedSender[srcChain]][nonce] = true;\n\n    bytes32 txnHash = keccak256(payload);\n    txnHashToTransaction[txnHash] = Transaction(srcSender, amt);\n    _attachThreshold(amt, txnHash, srcChain);\n    _approve(txnHash);\n    _mintIfThresholdMet(txnHash);\n    emit MessageReceived(srcChain, srcSender, amt, nonce);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Internal Functions\n  //////////////////////////////////////////////////////////////*/\n  /**\n   * @notice Internal function used to attach a specific threshold to a given\n   *         `txnHash`.\n   *\n   * @param amount   The amount of the token being bridged\n   * @param txnHash  The transaction hash to associate the threshold with\n   * @param srcChain The chain corresponding to the chain that the token\n   *                 being bridged originated from.\n   */\n  function _attachThreshold(\n    uint256 amount,\n    bytes32 txnHash,\n    string memory srcChain\n  ) internal {\n    Threshold[] memory thresholds = chainToThresholds[srcChain];\n    for (uint256 i = 0; i < thresholds.length; ++i) {\n      Threshold memory t = thresholds[i];\n      if (amount <= t.amount) {\n        txnToThresholdSet[txnHash] = TxnThreshold(\n          t.numberOfApprovalsNeeded,\n          new address[](0)\n        );\n        break;\n      }\n    }\n    if (txnToThresholdSet[txnHash].numberOfApprovalsNeeded == 0) {\n      revert NoThresholdMatch();\n    }\n  }\n\n  /**\n   * @notice Internal function used to approve and conditionally mint for a\n   *         given txn. Approval is conditional on this approver having not\n   *         previously approved the txn\n   *\n   * @param txnHash The txnHash to approve and conditionally mint to\n   */\n  function _approve(bytes32 txnHash) internal {\n    // Check that the approver has not already approved\n    TxnThreshold storage t = txnToThresholdSet[txnHash];\n    if (t.approvers.length > 0) {\n      for (uint256 i = 0; i < t.approvers.length; ++i) {\n        if (t.approvers[i] == msg.sender) {\n          revert AlreadyApproved();\n        }\n      }\n    }\n    t.approvers.push(msg.sender);\n  }\n\n  /**\n   * @notice Internal function used to check if the approval threshold has been\n   *         met for a given transaction.\n   *\n   * @param txnHash The txnHash to check\n   *\n   * @dev If an approver has been removed, any previous approvals are still valid\n   */\n  function _checkThresholdMet(bytes32 txnHash) internal view returns (bool) {\n    TxnThreshold memory t = txnToThresholdSet[txnHash];\n    if (t.numberOfApprovalsNeeded <= t.approvers.length) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Protected Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Protected Function used to approve messages passed to the\n   *         Receiver contract. This function is able to be called by any\n   *         approver that is added and associated with Ondo.\n   *\n   * @param txnHash The keccak256 hash of the payload\n   */\n  function approve(bytes32 txnHash) external {\n    if (!approvers[msg.sender]) {\n      revert NotApprover();\n    }\n    _approve(txnHash);\n    _mintIfThresholdMet(txnHash);\n  }\n\n  /**\n   * @notice Admin function to add an ondo Signer or Axelar Relayer\n   *\n   * @param approver  The address we would like to add\n   */\n  function addApprover(address approver) external onlyOwner {\n    approvers[approver] = true;\n    emit ApproverAdded(approver);\n  }\n\n  /**\n   * @notice Admin function to remove an approver\n   *\n   * @param approver The address of the approver that we would like to remove\n   */\n  function removeApprover(address approver) external onlyOwner {\n    delete approvers[approver];\n    emit ApproverRemoved(approver);\n  }\n\n  /**\n   * @notice Admin function that will allow bridge calls originating from a given address\n   *         on a given chain.\n   * @notice This will initalize a nested mapping in which spent nonces from this `srcAddress`\n   *         are logged and prevented from being reused\n   *\n   * @param srcChain            The chain to support\n   * @param srcContractAddress  The address of the Ondo Bridge on this chain\n   */\n  function addChainSupport(\n    string calldata srcChain,\n    string calldata srcContractAddress\n  ) external onlyOwner {\n    chainToApprovedSender[srcChain] = keccak256(abi.encode(srcContractAddress));\n    emit ChainIdSupported(srcChain, srcContractAddress);\n  }\n\n  /**\n   * @notice Admin function used to clear and set thresholds corresponding to a chain\n   *\n   * @param srcChain       The chain to set the threshold for\n   * @param amounts        The ordered array of values corresponding to\n   *                       the amount for a given threshold\n   * @param numOfApprovers The ordered array of the number of approvals needed\n   *                       for a given threshold\n   *\n   * @dev This function will remove all previously set thresholds for a given chain\n   *      and will thresholds corresponding to the params of this function. Passing\n   *      in empty arrays will remove all thresholds for a given chain\n   */\n  function setThresholds(\n    string calldata srcChain,\n    uint256[] calldata amounts,\n    uint256[] calldata numOfApprovers\n  ) external onlyOwner {\n    if (amounts.length != numOfApprovers.length) {\n      revert ArrayLengthMismatch();\n    }\n    delete chainToThresholds[srcChain];\n    for (uint256 i = 0; i < amounts.length; ++i) {\n      if (i == 0) {\n        chainToThresholds[srcChain].push(\n          Threshold(amounts[i], numOfApprovers[i])\n        );\n      } else {\n        if (chainToThresholds[srcChain][i - 1].amount > amounts[i]) {\n          revert ThresholdsNotInAscendingOrder();\n        }\n        chainToThresholds[srcChain].push(\n          Threshold(amounts[i], numOfApprovers[i])\n        );\n      }\n    }\n    emit ThresholdSet(srcChain, amounts, numOfApprovers);\n  }\n\n  /**\n   * @notice Admin function used to set the mint limit\n   *\n   * @param mintLimit The new mint limit\n   */\n  function setMintLimit(uint256 mintLimit) external onlyOwner {\n    _setMintLimit(mintLimit);\n  }\n\n  /**\n   * @notice Admin function used to set the mint duration\n   *\n   * @param mintDuration The new mint duration\n   */\n  function setMintLimitDuration(uint256 mintDuration) external onlyOwner {\n    _setMintLimitDuration(mintDuration);\n  }\n\n  /**\n   * @notice Admin function used to pause the contract\n   *\n   * @dev Only used for bridge functions\n   */\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /**\n   * @notice Admin function used to unpause the contract\n   *\n   * @dev Only used for bridge functions\n   */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n\n  /**\n   * @notice Admin function used to rescue ERC20 Tokens sent to the contract\n   *\n   * @param _token The address of the token to rescue\n   */\n  function rescueTokens(address _token) external onlyOwner {\n    uint256 balance = IRWALike(_token).balanceOf(address(this));\n    IRWALike(_token).transfer(owner(), balance);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Public Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice internal function to mint a transaction if it has passed the threshold\n   *         for the number of approvers\n   *\n   * @param txnHash The hash of the transaction we wish to mint\n   */\n  function _mintIfThresholdMet(bytes32 txnHash) internal {\n    bool thresholdMet = _checkThresholdMet(txnHash);\n    Transaction memory txn = txnHashToTransaction[txnHash];\n    if (thresholdMet) {\n      _checkAndUpdateInstantMintLimit(txn.amount);\n      if (!ALLOWLIST.isAllowed(txn.sender)) {\n        ALLOWLIST.setAccountStatus(\n          txn.sender,\n          ALLOWLIST.getValidTermIndexes()[0],\n          true\n        );\n      }\n      TOKEN.mint(txn.sender, txn.amount);\n      delete txnHashToTransaction[txnHash];\n      emit BridgeCompleted(txn.sender, txn.amount);\n    }\n  }\n\n  /**\n   * @notice External view function used to get the number of approvers for a\n   *         given txnHash\n   *\n   * @param txnHash The hash to get the number of approvers for\n   */\n  function getNumApproved(bytes32 txnHash) external view returns (uint256) {\n    return txnToThresholdSet[txnHash].approvers.length;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      Structs, Events, Errors\n  //////////////////////////////////////////////////////////////*/\n\n  struct Threshold {\n    uint256 amount;\n    uint256 numberOfApprovalsNeeded;\n  }\n\n  struct TxnThreshold {\n    uint256 numberOfApprovalsNeeded;\n    address[] approvers;\n  }\n\n  struct Transaction {\n    address sender;\n    uint256 amount;\n  }\n\n  /**\n   * @notice event emitted when an address is removed as an approver\n   *\n   * @param approver The address being removed\n   */\n  event ApproverRemoved(address approver);\n\n  /**\n   * @notice event emitted when an address is added as an approver\n   *\n   * @param approver  The address to add\n   */\n  event ApproverAdded(address approver);\n\n  /**\n   * @notice event emitted when a new contract is whitelisted as an approved\n   *         message passer.\n   *\n   * @param srcChain        The chain for the approved address\n   * @param approvedSource  The address corresponding to the source bridge contract\n   */\n  event ChainIdSupported(string srcChain, string approvedSource);\n\n  /**\n   * @notice event emitted when a threshold has been set\n   *\n   * @param chain           The chain for which the threshold was set\n   * @param amounts         The amount of tokens to reach this threshold\n   * @param numOfApprovers  The number of approvals needed\n   */\n  event ThresholdSet(string chain, uint256[] amounts, uint256[] numOfApprovers);\n\n  /**\n   * @notice event emitted when the user has been minted their tokens on the dst chain\n   *\n   * @param user    The recipient address of the newly minted tokens\n   * @param amount  The amount of tokens that have been minted\n   */\n  event BridgeCompleted(address user, uint256 amount);\n\n  /**\n   * @notice event emitted when this bridge contract receives a cross chain message\n   *\n   * @param srcChain  The chain from which the message is originating\n   * @param srcSender The address of the msg.sender on the source chain\n   * @param amt       The amount of tokens being bridged\n   * @param nonce     The nonce corresponding to the contract which originated the msg\n   */\n  event MessageReceived(\n    string srcChain,\n    address srcSender,\n    uint256 amt,\n    uint256 nonce\n  );\n\n  error NotApprover();\n  error NoThresholdMatch();\n  error ThresholdsNotInAscendingOrder();\n\n  error ChainNotSupported();\n  error SourceNotSupported();\n  error NonceSpent();\n  error AlreadyApproved();\n  error InvalidVersion();\n  error ArrayLengthMismatch();\n}"
    }
  ]
}