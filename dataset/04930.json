{
  "Title": "[M-06] Funds locked due to missing transfer check",
  "Content": "\nAll of the user's funds are unretrievably locked in the `PrizeVault` contract.\n\nA combination of issues allows for the following scenario:\n\n1. Alice invokes [`_withdraw(receiver, assets)`](https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L925-L941) (via `burn()` or `withdraw()`).\n2. The contract [computes the number of shares to redeem](https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L933-L934), via `previewWithdraw(assets)`.\n3. The contract [redeems as many shares](https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L935-L936), but the ERC 4626-compliant vault returns fewer shares than expected. At this point, the contract holds fewer than `assets` tokens.\n4. The contract [attempts to `transfer` assets to the receiver](https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L939). This fails due to insufficient funds, but the ERC 20-compliant token does not revert (only returns `false`).\n5. At this point, Alice's assets are locked in the `PrizeVault` contract. They cannot be withdrawn at a later point, because the corresponding prize vault and yield vault shares have been burned.\n\nThe exploit relies on insufficient handling of two corner cases of [ERC-20](https://eips.ethereum.org/EIPS/eip-20) and [ERC-4246](https://eips.ethereum.org/EIPS/eip-4626):\n\n- [ERC-20](https://eips.ethereum.org/EIPS/eip-20) does not stipulate that `transfer` must throw if the message sender holds insufficient balance. Instead, returning `false` is compliant with ERC-20 and implemented by many tokens, including [BAT](https://etherscan.io/token/0x0d8775f648430679a709e98d2b0cb6250d2887ef), [cUSDC](https://etherscan.io/token/0x39aa39c021dfbae8fac545936693ac917d5e7563), [EURS](https://etherscan.io/token/0xdb25f211ab05b1c97d595516f45794528a807ad8), [HuobiToken](https://etherscan.io/token/0x6f259637dcd74c767781e37bc6133cd6a68aa161), [ZRX](https://etherscan.io/token/0xe41d2489571d322189246dafa5ebde1f4699f498) and many more.\n- [ERC-4626](https://eips.ethereum.org/EIPS/eip-4626) does not stipulate that `redeem(previewWithdraw(assets))` transfers at least `assets`. In particular, [`redeem(shares, ...)`](https://eips.ethereum.org/EIPS/eip-4626#redeem) only guarantees that exactly `shares` are burned. The only guaranteed way to gain a certain amount of assets is by calling [`withdraw(assets, ...)`](https://eips.ethereum.org/EIPS/eip-4626#withdraw).\\\n\nWhile this is the most standards-compliant scenario, a malicious vault could simply not transfer the required tokens on purpose, and still trigger the same effect as described above.\n\n### Proof of Concept\n\nWe provide a proof of concept that results in all of Alice's assets locked in the `PrizeVault` contract and all her shares burned.\n\nPlace the file below in `test/unit/PrizeVault/PoCLockedFunds.t.sol` and run the test with:\n\n```\n    $ forge test --mt test_poc_lockedFundsOnLossyWithdrawal\n```\n\n<details>\n\n```solidity\n// Place in test/unit/PrizeVault/PoCLockedFunds.t.sol\npragma solidity ^0.8.24;\n\nimport { UnitBaseSetup } from \"./UnitBaseSetup.t.sol\";\n\nimport { IERC20, IERC4626 } from \"openzeppelin/token/ERC20/extensions/ERC4626.sol\";\nimport { ERC20PermitMock } from \"../../contracts/mock/ERC20PermitMock.sol\";\nimport { ERC4626Mock } from \"openzeppelin/mocks/ERC4626Mock.sol\";\nimport { Math } from \"openzeppelin/utils/math/Math.sol\";\n\n// An ERC20-compliant token that does not throw on insufficient balance.\ncontract NoRevertToken is IERC20 {\n    uint8   public decimals = 18;\n    uint256 public totalSupply;\n\n    mapping (address => uint)                      public balanceOf;\n    mapping (address => mapping (address => uint)) public allowance;\n\n    constructor(uint _totalSupply) {\n        totalSupply = _totalSupply;\n        balanceOf[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    function transfer(address dst, uint wad) external returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n        if (balanceOf[src] < wad) return false;                        // insufficient src bal\n\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n            if (allowance[src][msg.sender] < wad) return false;        // insufficient allowance\n            allowance[src][msg.sender] = allowance[src][msg.sender] - wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n        return true;\n    }\n    function approve(address usr, uint wad) virtual external returns (bool) {\n        allowance[msg.sender][usr] = wad;\n        emit Approval(msg.sender, usr, wad);\n        return true;\n    }\n}\n\n\n// An ERC4626-compliant (yield) vault.\n// `withdraw(assets)` burns `assets * totalSupply / (totalAssets + 1)` shares.\n// `redeem(shares)` transfers `shares * (totalAssets + 1) / (totalSupply + 1)` assets.\ncontract YieldVault is ERC4626Mock {\n    using Math for uint256;\n    constructor(address _asset) ERC4626Mock(_asset) {}\n\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return assets.mulDiv(totalSupply(), totalAssets() + 1);\n    }\n}\n\n// Demonstrate that all of Alice's funds are locked in the PrizeVault,\n// with all corresponding shares burned.\ncontract PoCLockedFunds is UnitBaseSetup {\n    NoRevertToken asset;\n\n    function setUpUnderlyingAsset() public view override returns (ERC20PermitMock) {\n        return ERC20PermitMock(address(asset));\n    }\n\n    function setUpYieldVault() public override returns (IERC4626) {\n        return new YieldVault(address(underlyingAsset));\n    }\n\n    function setUp() public override {\n        return;\n    }\n\n    function test_poc_lockedFundsOnLossyWithdrawal() public {\n        uint256 deposited = 1e18;\n\n        // Mint 10^18 tokens and transfer them to Alice.\n        asset = new NoRevertToken(deposited);\n        super.setUp();\n        asset.transfer(alice, deposited);\n\n        // Alice holds all tokens, the yield vault and the price vaults are empty.\n        assertEq(underlyingAsset.balanceOf(alice), deposited);\n        assertEq(underlyingAsset.balanceOf(address(vault)), 0);\n        assertEq(underlyingAsset.balanceOf(address(yieldVault)), 0);\n        assertEq(yieldVault.totalSupply(), 0);\n        assertEq(yieldVault.balanceOf(address(vault)), 0);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n\n        // Alice enters the vault.\n        vm.startPrank(alice);\n        underlyingAsset.approve(address(vault), deposited);\n        vault.deposit(deposited, alice);\n\n        // All assets were transferred into the yield vault,\n        // as many yield vault shares were minted to the prize vault, and\n        // as many prize vault shares were minted to Alice.\n        assertEq(underlyingAsset.balanceOf(alice), 0);\n        assertEq(underlyingAsset.balanceOf(address(vault)), 0);\n        assertEq(underlyingAsset.balanceOf(address(yieldVault)), deposited);\n        assertEq(yieldVault.totalSupply(), deposited);\n        assertEq(yieldVault.balanceOf(address(vault)), deposited);\n        assertEq(vault.totalSupply(), deposited);\n        assertEq(vault.balanceOf(alice), deposited);\n\n        // Perform the lossy withdraw.\n        vault.withdraw(deposited, alice, alice);\n\n        // At this point Alice should've received all her assets back,\n        // and all prize/yield vault shares should've been burned.\n        // In contrast, no assets were transferred to Alice,\n        // but (almost) all shares have been burned.\n        assertEq(underlyingAsset.balanceOf(alice), 0);\n        assertEq(underlyingAsset.balanceOf(address(vault)), 999999999999999999);\n        assertEq(underlyingAsset.balanceOf(address(yieldVault)), 1);\n        assertEq(yieldVault.totalSupply(), 1);\n        assertEq(yieldVault.balanceOf(address(vault)), 1);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n\n        // As a result, Alice's funds are locked in the vault;\n        // she cannot even withdraw a single asset.\n        vm.expectRevert();\n        vault.withdraw(1, alice, alice);\n        vm.expectRevert();\n        vault.redeem(1, alice, alice);\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nWe recommend to fix both the ERC-20 transfer and ERC-4626 withdrawal.\n\nFor the first, it is easiest to rely on OpenZeppelin's [SafeERC20 `safeTransfer`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8cc7f2dcbf368f2a7ea491389dae41f01c16e352/contracts/token/ERC20/utils/SafeERC20.sol#L32-L38) function:\n\n```diff\ndiff --git a/pt-v5-vault/src/PrizeVault.sol b/pt-v5-vault/src/PrizeVault.sol\nindex fafcff3..de69915 100644\n--- a/pt-v5-vault/src/PrizeVault.sol\n+++ b/pt-v5-vault/src/PrizeVault.sol\n@@ -936,7 +936,7 @@ contract PrizeVault is TwabERC20, Claimable, IERC4626, ILiquidationSource, Ownab\n             yieldVault.redeem(_yieldVaultShares, address(this), address(this));\n         }\n         if (_receiver != address(this)) {\n-            _asset.transfer(_receiver, _assets);\n+            _asset.safeTransfer(_receiver, _assets);\n         }\n     }\n```\n\nThis already mitigates the erroneous locking of assets.\n\nIn addition, we recommend to ensure that at least the necessary amount of shares is withdrawn from the yield vault.\nIn the simplest form, this can be ensured by invoking `withdraw` directly:\n\n```diff\ndiff --git a/pt-v5-vault/src/PrizeVault.sol b/pt-v5-vault/src/PrizeVault.sol\nindex fafcff3..9bb0653 100644\n--- a/pt-v5-vault/src/PrizeVault.sol\n+++ b/pt-v5-vault/src/PrizeVault.sol\n@@ -930,10 +930,7 @@ contract PrizeVault is TwabERC20, Claimable, IERC4626, ILiquidationSource, Ownab\n         // latent balance, we don't need to redeem any yield vault shares.\n         uint256 _latentAssets = _asset.balanceOf(address(this));\n         if (_assets > _latentAssets) {\n-            // The latent balance is subtracted from the withdrawal so we don't withdraw more than we need.\n-            uint256 _yieldVaultShares = yieldVault.previewWithdraw(_assets - _latentAssets);\n-            // Assets are sent to this contract so any leftover dust can be redeposited later.\n-            yieldVault.redeem(_yieldVaultShares, address(this), address(this));\n+            yieldVault.withdraw(_assets - _latentAssets, address(this), address(this));\n         }\n         if (_receiver != address(this)) {\n             _asset.transfer(_receiver, _assets);\n```\n\nIf a tighter bound on redeemed shares is desired, the call to `previewWithdraw`/`redeem` should be followed by a `withdraw` of the outstanding assets:\n\n```diff\ndiff --git a/pt-v5-vault/src/PrizeVault.sol b/pt-v5-vault/src/PrizeVault.sol\nindex fafcff3..622a7a6 100644\n--- a/pt-v5-vault/src/PrizeVault.sol\n+++ b/pt-v5-vault/src/PrizeVault.sol\n@@ -934,6 +934,13 @@ contract PrizeVault is TwabERC20, Claimable, IERC4626, ILiquidationSource, Ownab\n             uint256 _yieldVaultShares = yieldVault.previewWithdraw(_assets - _latentAssets);\n             // Assets are sent to this contract so any leftover dust can be redeposited later.\n             yieldVault.redeem(_yieldVaultShares, address(this), address(this));\n+            \n+            // Redeeming `_yieldVaultShares` may have transferred fewer than the required assets.\n+            // Ask for the outstanding assets directly.\n+            _latentAssets = _asset.balanceOf(address(this));\n+            if (_assets > _latentAssets) {\n+                yieldVault.withdraw(_assets - _latentAssets);\n+            }\n         }\n         if (_receiver != address(this)) {\n             _asset.transfer(_receiver, _assets);\n```\n\n### Assessed type\n\nERC20\n\n**[trmid (PoolTogether) confirmed and commented](https://github.com/code-423n4/2024-03-pooltogether-findings/issues/235#issuecomment-1996001801):**\n > I would like to add that if a \"compatible ERC4626 yield vault returns less assets than expected\", then it is not actually ERC4626 compatible as these behaviors are required in the spec. That being said, there are likely to be some yield vaults that have errors like this and it is a good thing if we can protect against it without inhibiting the default experience!\n> \n> The `safeTransfer` addition seems sufficient, while the other recommended mitigations are unnecessary and would break the \"dust collector\" strategy that the prize vault employs.\n>\n> Mitigation [here](https://github.com/GenerationSoftware/pt-v5-vault/pull/86).\n\n**[hansfriese (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-03-pooltogether-findings/issues/235#issuecomment-2002771823):**\n > The impact is critical if `_asset.transfer()` fails silently and it will be mitigated from [this known issue](https://github.com/code-423n4/2024-03-pooltogether/blob/main/bot-report.md#m-02-erc-20-transfertransferfrom-return-values-should-be-checked).\n> So according to [this criteria](https://docs.code4rena.com/awarding/judging-criteria/supreme-court-decisions-fall-2023#verdict-similar-exploits-under-a-single-issue), this issue might be OOS if it's fully mitigated by adding `safeTransfer`.\n> \n> But another impact is `withdraw()` might revert when `yieldVault.redeem()` returns fewer assets than requested and Medium is appropriate.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-pooltogether",
  "Code": [
    {
      "filename": "pt-v5-vault/src/PrizeVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IERC4626 } from \"openzeppelin/interfaces/IERC4626.sol\";\nimport { SafeERC20, IERC20Permit } from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC20, IERC20, IERC20Metadata } from \"openzeppelin/token/ERC20/ERC20.sol\";\nimport { Math } from \"openzeppelin/utils/math/Math.sol\";\nimport { Ownable } from \"owner-manager-contracts/Ownable.sol\";\n\nimport { Claimable } from \"./abstract/Claimable.sol\";\nimport { TwabERC20 } from \"./TwabERC20.sol\";\n\nimport { ILiquidationSource } from \"pt-v5-liquidator-interfaces/ILiquidationSource.sol\";\nimport { PrizePool } from \"pt-v5-prize-pool/PrizePool.sol\";\nimport { TwabController, SPONSORSHIP_ADDRESS } from \"pt-v5-twab-controller/TwabController.sol\";\n\n/// @title  PoolTogether V5 Prize Vault\n/// @author G9 Software Inc.\n/// @notice The prize vault takes deposits of an asset and earns yield with the deposits through an underlying yield\n///         vault. The yield is then expected to be liquidated and contributed to the prize pool as prize tokens. The\n///         depositors of the prize vault will then be eligible to win prizes from the pool. If a prize is won, The \n///         permitted claimer contract for the prize vault will claim the prize on behalf of the winner. Depositors\n///         can also set custom hooks that are called directly before and after their prize is claimed.\n/// @dev    Share balances are stored in the TwabController contract.\n/// @dev    Depositors should always expect to be able to withdraw their full deposit amount and no more as long as\n///         global withdrawal limits meet or exceed their balance. However, if the underlying yield source loses\n///         assets, depositors will only be able to withdraw a proportional amount of remaining assets based on their\n///         share balance and the total debt balance.\n/// @dev    The prize vault is designed to embody the \"no loss\" spirit of PoolTogether, down to the last wei. Most \n///         ERC4626 yield vaults incur small, necessary rounding errors on deposit and withdrawal to ensure the\n///         internal accounting cannot be taken advantage of. The prize vault employs two strategies in an attempt\n///         to cover these rounding errors with yield to ensure that depositors can withdraw every last wei of their\n///         initial deposit:\n///\n///             1. The \"dust collection strategy\":\n///\n///                Rounding errors are directly related to the exchange rate of the underlying yield vault; the more\n///                assets a single yield vault share is worth, the more severe the rounding errors can become. For\n///                example, if the exchange rate is 100 assets for 1 yield vault share and we assume 0 decimal\n///                precision; if alice deposits 199 assets, the yield vault will round down on the conversion and mint\n///                alice 1 share, essentially donating the remaining 99 assets to the yield vault. This behavior can\n///                open pathways for exploits in the prize vault since a bad actor could repeatedly make deposits and\n///                withdrawals that result in large rounding errors and since the prize vault covers rounding errors\n///                with yield, the attacker could withdraw without loss while essentially donating the yield back to\n///                the yield vault.\n///\n///                To mitigate this issue, the prize vault calculates the amount of yield vault shares that would be\n///                minted during a deposit, but mints those shares directly instead, ensuring that only the exact\n///                amount of assets needed are sent to the yield vault while keeping the remainder as a latent balance\n///                in the prize vault until it can be used in the next deposit or withdraw. An inverse strategy is also\n///                used when withdrawing assets from the yield vault. This reduces the possible rounding errors to just\n///                1 wei per deposit or withdraw.\n///\n///             2. The \"yield buffer\":\n///\n///                Since the prize vault can still incur minimal rounding errors from the yield vault, a yield buffer\n///                is required to ensure that there is always enough yield reserved to cover the rounding errors on \n///                deposits and withdrawals. This buffer should never run dry during normal operating conditions and\n///                expected yield rates. If the yield buffer is ever depleted, new deposits will be prevented and the\n///                prize vault will enter a lossy withdrawal state where depositors will incur the rounding errors on\n///                withdraw.\n///\n/// @dev    The prize vault does not support underlying yield vaults that take a fee on deposit or withdraw.\n///\ncontract PrizeVault is TwabERC20, Claimable, IERC4626, ILiquidationSource, Ownable {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Public Constants and Variables\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The yield fee decimal precision.\n    uint32 public constant FEE_PRECISION = 1e9;\n    \n    /// @notice The max yield fee that can be set.\n    /// @dev Decimal precision is defined by `FEE_PRECISION`.\n    /// @dev If the yield fee is set too high, liquidations won't occur on a regular basis. If a use case requires\n    /// a yield fee higher than this max, a custom liquidation pair can be set to manipulate the yield as required.\n    uint32 public constant MAX_YIELD_FEE = 9e8;\n\n    /// @notice The yield buffer that is reserved for covering rounding errors on withdrawals and deposits.\n    /// @dev The buffer prevents the entire yield balance from being liquidated, which would leave the vault\n    /// in a state where a single rounding error could reduce the totalAssets to less than the totalSupply.\n    /// \n    /// The yield buffer is expected to be of insignificant value and is used to cover rounding\n    /// errors on deposits and withdrawals. Yield is expected to accrue faster than the yield buffer\n    /// can be reasonably depleted.\n    ///\n    /// IT IS RECOMMENDED TO DONATE ASSETS DIRECTLY TO THE PRIZE VAULT AFTER DEPLOYMENT TO FILL THE YIELD\n    /// BUFFER AND COVER ROUNDING ERRORS UNTIL THE DEPOSITS CAN GENERATE ENOUGH YIELD TO KEEP THE BUFFER \n    /// FULL WITHOUT ASSISTANCE.\n    ///\n    /// The yield buffer should be set as high as possible while still being considered insignificant\n    /// for the underlying asset. For example, a reasonable yield buffer for USDC with 6 decimals might be\n    /// 1e5 ($0.10), which will cover up to 100k rounding errors while still being an insignificant value.\n    /// Some assets may be considered incompatible with the prize vault if the yield vault incurs rounding\n    /// errors and the underlying asset has a low precision per dollar ratio.\n    /// \n    /// Precision per dollar (PPD) can be calculated by: (10 ^ DECIMALS) / ($ value of 1 asset).\n    /// For example, USDC has a PPD of (10 ^ 6) / ($1) = 10e6 p/$.\n    /// \n    /// As a rule of thumb, assets with lower PPD than USDC should not be assumed to be compatible since\n    /// the potential loss of a single unit rounding error is likely too high to be made up by yield at \n    /// a reasonable rate. Actual results may vary based on expected gas costs, asset fluctuation, and yield\n    /// accrual rates. If the underlying yield vault does not incur any rounding errors, then the yield buffer\n    /// can be set to zero.\n    ///\n    /// If the yield buffer is depleted on the prize vault, new deposits will be prevented if it would result in\n    /// a rounding error and any rounding errors incurred by withdrawals will not be covered by yield. The yield\n    /// buffer will be replenished automatically as yield accrues.\n    uint256 public immutable yieldBuffer;\n\n    /// @notice Address of the underlying ERC4626 vault generating yield.\n    IERC4626 public immutable yieldVault;\n\n    /// @notice Yield fee percentage represented in integer format with decimal precision defined by `FEE_PRECISION`.\n    /// @dev For example, if `FEE_PRECISION` were 1e9 a value of 1e7 = 0.01 = 1%.\n    uint32 public yieldFeePercentage;\n\n    /// @notice Address of the yield fee recipient.\n    address public yieldFeeRecipient;\n\n    /// @notice The accrued yield fee balance that the fee recipient can claim as vault shares.\n    uint256 public yieldFeeBalance;\n\n    /// @notice Address of the liquidation pair used to liquidate yield for prize token.\n    address public liquidationPair;\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Private Variables\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Address of the underlying asset used by the Vault.\n    IERC20 private immutable _asset;\n\n    /// @notice Underlying asset decimals.\n    uint8 private immutable _underlyingDecimals;\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Events\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Emitted when a new yield fee recipient has been set.\n    /// @param yieldFeeRecipient Address of the new yield fee recipient\n    event YieldFeeRecipientSet(address indexed yieldFeeRecipient);\n\n    /// @notice Emitted when a new yield fee percentage has been set.\n    /// @param yieldFeePercentage New yield fee percentage\n    event YieldFeePercentageSet(uint256 yieldFeePercentage);\n\n    /// @notice Emitted when a user sponsors the Vault.\n    /// @param caller Address that called the function\n    /// @param assets Amount of assets deposited into the Vault\n    /// @param shares Amount of shares minted to the caller address\n    event Sponsor(address indexed caller, uint256 assets, uint256 shares);\n\n    /// @notice Emitted when yield is transferred out by the liquidation pair address.\n    /// @param liquidationPair The liquidation pair address that initiated the transfer\n    /// @param tokenOut The token that was transferred out\n    /// @param recipient The recipient of the tokens\n    /// @param amountOut The amount of tokens sent to the recipient\n    /// @param yieldFee The amount of shares accrued on the yield fee balance\n    event TransferYieldOut(\n        address indexed liquidationPair,\n        address indexed tokenOut,\n        address indexed recipient,\n        uint256 amountOut,\n        uint256 yieldFee\n    );\n\n    /// @notice Emitted when yield fee shares are claimed by the yield fee recipient.\n    /// @param recipient Address receiving the fee shares\n    /// @param shares Amount of shares claimed\n    event ClaimYieldFeeShares(address indexed recipient, uint256 shares);\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Errors\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Thrown when the Yield Vault is set to the zero address.\n    error YieldVaultZeroAddress();\n\n    /// @notice Thrown when the Owner is set to the zero address.\n    error OwnerZeroAddress();\n\n    /// @notice Thrown when a withdrawal of zero assets on the yield vault is attempted\n    error WithdrawZeroAssets();\n\n    /// @notice Thrown when no shares are being burnt during a withdrawal of assets\n    error BurnZeroShares();\n\n    /// @notice Thrown when zero assets are being deposited\n    error DepositZeroAssets();\n\n    /// @notice Thrown when zero shares are being minted\n    error MintZeroShares();\n\n    /// @notice Thrown if `totalAssets` is zero during a withdraw\n    error ZeroTotalAssets();\n\n    /// @notice Thrown when the Liquidation Pair being set is the zero address.\n    error LPZeroAddress();\n\n    /// @notice Thrown when `sweep` is called but no underlying assets are currently held by the Vault.\n    error SweepZeroAssets();\n\n    /// @notice Thrown during the liquidation process when the liquidation amount out is zero.\n    error LiquidationAmountOutZero();\n\n    /// @notice Thrown during the liquidation process when the caller is not the liquidation pair contract.\n    /// @param caller The caller address\n    /// @param liquidationPair The LP address\n    error CallerNotLP(address caller, address liquidationPair);\n\n    /// @notice Thrown if the caller is not the yield fee recipient when withdrawing yield fee shares.\n    /// @param caller The caller address\n    /// @param yieldFeeRecipient The yield fee recipient address\n    error CallerNotYieldFeeRecipient(address caller, address yieldFeeRecipient);\n\n    /// @notice Thrown when the caller of a permit function is not the owner of the assets being permitted.\n    /// @param caller The address of the caller\n    /// @param owner The address of the owner\n    error PermitCallerNotOwner(address caller, address owner);\n\n    /// @notice Thrown when the yield fee percentage being set exceeds the max yield fee allowed.\n    /// @param yieldFeePercentage The yield fee percentage in integer format\n    /// @param maxYieldFeePercentage The max yield fee percentage in integer format\n    error YieldFeePercentageExceedsMax(uint256 yieldFeePercentage, uint256 maxYieldFeePercentage);\n\n    /// @notice Thrown when the yield fee shares being withdrawn exceeds the available yieldFee Balance.\n    /// @param shares The shares being withdrawn\n    /// @param yieldFeeBalance The available yield fee shares\n    error SharesExceedsYieldFeeBalance(uint256 shares, uint256 yieldFeeBalance);\n\n    /// @notice Thrown during the liquidation process when the token in is not the prize token.\n    /// @param tokenIn The provided tokenIn address\n    /// @param prizeToken The prize token address\n    error LiquidationTokenInNotPrizeToken(address tokenIn, address prizeToken);\n\n    /// @notice Thrown during the liquidation process when the token out is not supported.\n    /// @param tokenOut The provided tokenOut address\n    error LiquidationTokenOutNotSupported(address tokenOut);\n\n    /// @notice Thrown during the liquidation process if the total to withdraw is greater than the available yield.\n    /// @param totalToWithdraw The total yield to withdraw\n    /// @param availableYield The available yield\n    error LiquidationExceedsAvailable(uint256 totalToWithdraw, uint256 availableYield);\n\n    /// @notice Thrown when a deposit results in a state where the total assets are less than the total share supply.\n    /// @param totalAssets The total assets controlled by the vault\n    /// @param totalSupply The total shares minted and internally accounted for by the vault\n    error LossyDeposit(uint256 totalAssets, uint256 totalSupply);\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Modifiers\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Requires the caller to be the liquidation pair.\n    modifier onlyLiquidationPair() {\n        if (msg.sender != liquidationPair) {\n            revert CallerNotLP(msg.sender, liquidationPair);\n        }\n        _;\n    }\n\n    /// @notice Requires the caller to be the yield fee recipient.\n    modifier onlyYieldFeeRecipient() {\n        if (msg.sender != yieldFeeRecipient) {\n            revert CallerNotYieldFeeRecipient(msg.sender, yieldFeeRecipient);\n        }\n        _;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Constructor\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Vault constructor\n    /// @param name_ Name of the ERC20 share minted by the vault\n    /// @param symbol_ Symbol of the ERC20 share minted by the vault\n    /// @param yieldVault_ Address of the underlying ERC4626 vault in which assets are deposited to generate yield\n    /// @param prizePool_ Address of the PrizePool that computes prizes\n    /// @param claimer_ Address of the claimer\n    /// @param yieldFeeRecipient_ Address of the yield fee recipient\n    /// @param yieldFeePercentage_ Yield fee percentage\n    /// @param yieldBuffer_ Amount of yield to keep as a buffer\n    /// @param owner_ Address that will gain ownership of this contract\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        IERC4626 yieldVault_,\n        PrizePool prizePool_,\n        address claimer_,\n        address yieldFeeRecipient_,\n        uint32 yieldFeePercentage_,\n        uint256 yieldBuffer_,\n        address owner_\n    ) TwabERC20(name_, symbol_, prizePool_.twabController()) Claimable(prizePool_, claimer_) Ownable(owner_) {\n        if (address(yieldVault_) == address(0)) revert YieldVaultZeroAddress();\n        if (owner_ == address(0)) revert OwnerZeroAddress();\n\n        IERC20 asset_ = IERC20(yieldVault_.asset());\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _underlyingDecimals = success ? assetDecimals : 18;\n        _asset = asset_;\n\n        yieldVault = yieldVault_;\n        yieldBuffer = yieldBuffer_;\n\n        _setYieldFeeRecipient(yieldFeeRecipient_);\n        _setYieldFeePercentage(yieldFeePercentage_);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // ERC20 Overrides\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @inheritdoc IERC20Metadata\n    function decimals() public view override(ERC20, IERC20Metadata) returns (uint8) {\n        return _underlyingDecimals;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // ERC4626 Implementation\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @inheritdoc IERC4626\n    function asset() external view returns (address) {\n        return address(_asset);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev The latent asset balance is included in the total asset count to account for the \"dust collection\n    /// strategy\".\n    function totalAssets() public view returns (uint256) {\n        return yieldVault.convertToAssets(yieldVault.balanceOf(address(this))) + _asset.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 _assets) public view returns (uint256) {\n        uint256 totalDebt_ = totalDebt();\n        uint256 _totalAssets = totalAssets();\n        if (_totalAssets >= totalDebt_) {\n            return _assets;\n        } else {\n            // If the vault controls less assets than what has been deposited a share will be worth a\n            // proportional amount of the total assets. This can happen due to fees, slippage, or loss\n            // of funds in the underlying yield vault.\n            return _assets.mulDiv(totalDebt_, _totalAssets, Math.Rounding.Down);\n        }\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 _shares) public view returns (uint256) {\n        uint256 totalDebt_ = totalDebt();\n        uint256 _totalAssets = totalAssets();\n        if (_totalAssets >= totalDebt_) {\n            return _shares;\n        } else {\n            // If the vault controls less assets than what has been deposited a share will be worth a\n            // proportional amount of the total assets. This can happen due to fees, slippage, or loss\n            // of funds in the underlying yield vault.\n            return _shares.mulDiv(_totalAssets, totalDebt_, Math.Rounding.Down);\n        }\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev Considers the uint96 limit on total share supply in the TwabController\n    /// @dev Returns zero if any deposit would result in a loss of assets\n    /// @dev Any latent balance of assets in the prize vault will be swept in with the deposit as a part of\n    /// the \"dust collection strategy\". This means that the max deposit must account for the latent balance\n    /// by subtracting it from the max deposit available otherwise.\n    function maxDeposit(address) public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        uint256 totalDebt_ = _totalDebt(_totalSupply);\n        if (totalAssets() < totalDebt_) return 0;\n\n        // the vault will never mint more than 1 share per asset, so no need to convert supply limit to assets\n        uint256 twabSupplyLimit_ = _twabSupplyLimit(_totalSupply);\n        uint256 _maxDeposit;\n        uint256 _latentBalance = _asset.balanceOf(address(this));\n        uint256 _maxYieldVaultDeposit = yieldVault.maxDeposit(address(this));\n        if (_latentBalance >= _maxYieldVaultDeposit) {\n            return 0;\n        } else {\n            unchecked {\n                _maxDeposit = _maxYieldVaultDeposit - _latentBalance;\n            }\n            return twabSupplyLimit_ < _maxDeposit ? twabSupplyLimit_ : _maxDeposit;\n        }\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev Returns the same value as `maxDeposit` since shares and assets are 1:1 on mint\n    /// @dev Returns zero if any deposit would result in a loss of assets\n    function maxMint(address _owner) public view returns (uint256) {\n        return maxDeposit(_owner);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev The prize vault maintains a latent balance of assets as part of the \"dust collection strategy\".\n    /// This latent balance are accounted for in the max withdraw limits.\n    function maxWithdraw(address _owner) public view returns (uint256) {\n        uint256 _maxWithdraw = _maxYieldVaultWithdraw() + _asset.balanceOf(address(this));\n\n        // the owner may receive less than 1 asset per share, so we must convert their balance here\n        uint256 _ownerAssets = convertToAssets(balanceOf(_owner));\n        return _ownerAssets < _maxWithdraw ? _ownerAssets : _maxWithdraw;\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev The prize vault maintains a latent balance of assets as part of the \"dust collection strategy\".\n    /// This latent balance are accounted for in the max redeem limits.\n    function maxRedeem(address _owner) public view returns (uint256) {\n        uint256 _maxWithdraw = _maxYieldVaultWithdraw() + _asset.balanceOf(address(this));\n        uint256 _ownerShares = balanceOf(_owner);\n\n        // The owner will never receive more than 1 asset per share, so there is no need to convert max\n        // withdraw to shares unless the owner has more shares than the max withdraw and is redeeming\n        // at a loss (when 1 share is worth less than 1 asset).\n        if (_ownerShares > _maxWithdraw) {\n            uint256 _totalAssets = totalAssets();\n            uint256 totalDebt_ = totalDebt();\n            if (_totalAssets >= totalDebt_) {\n                return _maxWithdraw;\n            } else {\n                // Convert to shares while rounding up. Since 1 asset is guaranteed to be worth more than\n                // 1 share and any upwards rounding will not exceed 1 share, we can be sure that when the\n                // shares are converted back to assets (rounding down) the resulting asset value won't\n                // exceed `_maxWithdraw`.\n                uint256 _maxScaledRedeem = _maxWithdraw.mulDiv(totalDebt_, _totalAssets, Math.Rounding.Up);\n                return _maxScaledRedeem >= _ownerShares ? _ownerShares : _maxScaledRedeem;\n            }\n        } else {\n            return _ownerShares;\n        }\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 _assets) public pure returns (uint256) {\n        // shares represent how many assets an account has deposited, so they are 1:1 on deposit\n        return _assets;\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 _shares) public pure returns (uint256) {\n        // shares represent how many assets an account has deposited, so they are 1:1 on mint\n        return _shares;\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev Reverts if `totalAssets` in the vault is zero\n    function previewWithdraw(uint256 _assets) public view returns (uint256) {\n        uint256 _totalAssets = totalAssets();\n\n        // No withdrawals can occur if the vault controls no assets.\n        if (_totalAssets == 0) revert ZeroTotalAssets();\n\n        uint256 totalDebt_ = totalDebt();\n        if (_totalAssets >= totalDebt_) {\n            return _assets;\n        } else {\n            // Follows the inverse conversion of `convertToAssets`\n            return _assets.mulDiv(totalDebt_, _totalAssets, Math.Rounding.Up);\n        }\n    }\n\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 _shares) public view returns (uint256) {\n        return convertToAssets(_shares);\n    }\n\n    /// @inheritdoc IERC4626\n    function deposit(uint256 _assets, address _receiver) external returns (uint256) {\n        uint256 _shares = previewDeposit(_assets);\n        _depositAndMint(msg.sender, _receiver, _assets, _shares);\n        return _shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 _shares, address _receiver) external returns (uint256) {\n        uint256 _assets = previewMint(_shares);\n        _depositAndMint(msg.sender, _receiver, _assets, _shares);\n        return _assets;\n    }\n\n    /// @inheritdoc IERC4626\n    function withdraw(\n        uint256 _assets,\n        address _receiver,\n        address _owner\n    ) external returns (uint256) {\n        uint256 _shares = previewWithdraw(_assets);\n        _burnAndWithdraw(msg.sender, _receiver, _owner, _shares, _assets);\n        return _shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function redeem(\n        uint256 _shares,\n        address _receiver,\n        address _owner\n    ) external returns (uint256) {\n        uint256 _assets = previewRedeem(_shares);\n        _burnAndWithdraw(msg.sender, _receiver, _owner, _shares, _assets);\n        return _assets;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Additional Deposit Flows\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Approve underlying asset with permit, deposit into the Vault and mint Vault shares to `_owner`.\n    /// @dev Can't be used to deposit on behalf of another user since `permit` does not accept a receiver parameter,\n    /// meaning that anyone could reuse the signature and pass an arbitrary receiver to this function.\n    /// @param _assets Amount of assets to approve and deposit\n    /// @param _owner Address of the owner depositing `_assets` and signing the permit\n    /// @param _deadline Timestamp after which the approval is no longer valid\n    /// @param _v V part of the secp256k1 signature\n    /// @param _r R part of the secp256k1 signature\n    /// @param _s S part of the secp256k1 signature\n    /// @return Amount of Vault shares minted to `_owner`.\n    function depositWithPermit(\n        uint256 _assets,\n        address _owner,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256) {\n        if (_owner != msg.sender) {\n            revert PermitCallerNotOwner(msg.sender, _owner);\n        }\n\n        // Skip the permit call if the allowance has already been set to exactly what is needed. This prevents\n        // griefing attacks where the signature is used by another actor to complete the permit before this\n        // function is executed.\n        if (_asset.allowance(_owner, address(this)) != _assets) {\n            IERC20Permit(address(_asset)).permit(_owner, address(this), _assets, _deadline, _v, _r, _s);\n        }\n\n        uint256 _shares = previewDeposit(_assets);\n        _depositAndMint(_owner, _owner, _assets, _shares);\n        return _shares;\n    }\n\n    /// @notice Deposit assets into the Vault and delegate to the sponsorship address.\n    /// @dev Emits a `Sponsor` event\n    /// @param _assets Amount of assets to deposit\n    /// @return Amount of shares minted to caller.\n    function sponsor(uint256 _assets) external returns (uint256) {\n        address _owner = msg.sender;\n\n        uint256 _shares = previewDeposit(_assets);\n        _depositAndMint(_owner, _owner, _assets, _shares);\n\n        if (twabController.delegateOf(address(this), _owner) != SPONSORSHIP_ADDRESS) {\n            twabController.sponsor(_owner);\n        }\n\n        emit Sponsor(_owner, _assets, _shares);\n\n        return _shares;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Additional Accounting\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Returns the total assets that are owed to share holders and any other internal balances.\n    /// @return The total asset debt of the vault\n    function totalDebt() public view returns (uint256) {\n        return _totalDebt(totalSupply());\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Yield Functions\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Total yield balance of the vault\n    /// @dev Equal to total assets minus total debt\n    /// @return The total yield balance\n    function totalYieldBalance() public view returns (uint256) {\n        return _totalYieldBalance(totalAssets(), totalDebt());\n    }\n\n    /// @notice Total available yield on the vault\n    /// @dev Equal to total assets minus total allocation (total debt + yield buffer)\n    /// @return The available yield balance\n    function availableYieldBalance() public view returns (uint256) {\n        return _availableYieldBalance(totalAssets(), totalDebt());\n    }\n\n    /// @notice Current amount of assets available in the yield buffer\n    /// @return The available assets in the yield buffer\n    function currentYieldBuffer() external view returns (uint256) {\n        uint256 totalYieldBalance_ = _totalYieldBalance(totalAssets(), totalDebt());\n        uint256 _yieldBuffer = yieldBuffer;\n        if (totalYieldBalance_ >= _yieldBuffer) {\n            return _yieldBuffer;\n        } else {\n            return totalYieldBalance_;\n        }\n    }\n\n    /// @notice Transfers yield fee shares to the yield fee recipient\n    /// @param _shares The shares to mint to the yield fee recipient\n    /// @dev Emits a `ClaimYieldFeeShares` event\n    /// @dev Will revert if the caller is not the yield fee recipient or if zero shares are withdrawn\n    function claimYieldFeeShares(uint256 _shares) external onlyYieldFeeRecipient {\n        if (_shares == 0) revert MintZeroShares();\n\n        uint256 _yieldFeeBalance = yieldFeeBalance;\n        if (_shares > _yieldFeeBalance) revert SharesExceedsYieldFeeBalance(_shares, _yieldFeeBalance);\n\n        yieldFeeBalance -= _yieldFeeBalance;\n\n        _mint(msg.sender, _shares);\n\n        emit ClaimYieldFeeShares(msg.sender, _shares);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // LiquidationSource Functions\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @inheritdoc ILiquidationSource\n    /// @dev Returns the liquid amount of `_tokenOut` minus any yield fees.\n    /// @dev Supports the liquidation of either assets or prize vault shares.\n    function liquidatableBalanceOf(address _tokenOut) public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        uint256 _maxAmountOut;\n        if (_tokenOut == address(this)) {\n            // Liquidation of vault shares is capped to the TWAB supply limit.\n            _maxAmountOut = _twabSupplyLimit(_totalSupply);\n        } else if (_tokenOut == address(_asset)) {\n            // Liquidation of yield assets is capped at the max yield vault withdraw plus any latent balance.\n            _maxAmountOut = _maxYieldVaultWithdraw() + _asset.balanceOf(address(this));\n        } else {\n            return 0;\n        }\n\n        // The liquid yield is computed by taking the available yield balance and multiplying it\n        // by (1 - yieldFeePercentage), rounding down, to ensure that enough yield is left for the\n        // yield fee.\n        uint256 _liquidYield = \n            _availableYieldBalance(totalAssets(), _totalDebt(_totalSupply))\n            .mulDiv(FEE_PRECISION - yieldFeePercentage, FEE_PRECISION);\n\n        // The liquid yield is limited by the max that can be minted or withdrawn, depending on\n        // `_tokenOut`.\n        return _liquidYield >= _maxAmountOut ? _maxAmountOut : _liquidYield;\n    }\n\n    /// @inheritdoc ILiquidationSource\n    /// @dev Emits a `TransferYieldOut` event\n    /// @dev Supports the liquidation of either assets or prize vault shares.\n    function transferTokensOut(\n        address,\n        address _receiver,\n        address _tokenOut,\n        uint256 _amountOut\n    ) p"
    }
  ]
}