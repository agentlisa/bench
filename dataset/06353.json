{
  "Title": "[H-02] doesn't calculate the current borrowing amount for the provider, including the provider's borrowed shares and accumulated fees due to inconsistency in `collateralRatio` calculation",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L127>\n\n### Proof of Concept\n\nBorrowers `collateralRatio` in the `liquidation()` function is calculated by:\n\n```solidity\nuint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / getBorrowedOf(onBehalfOf);\n```\n\nNotice it calls the `getBorrowedOf()` function, which\ncalculates the current borrowing amount for the borrower, including the borrowed shares and accumulated fees, not just the borrowed amount.\n\n<https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L253>\n\n```solidity\nfunction getBorrowedOf(address user) public view returns (uint256) {\n        return borrowed[user] + feeStored[user] + _newFee(user);\n    }\n```\n\nHowever, the providers `collateralRatio` in the `rigidRedemption()` function is calculated by:\n\n<https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L161>\n\n```solidity\nuint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];\n```\n\nHere, the deposit asset is divided by only the borrowed amount, missing out on the borrowed shares and accumulated fees.\n\n### Tools Used\n\nVisual Studio Code\n\n### Recommended Mitigation Steps\n\nBe consistent with `collateralRatio` calculation.\n\n**[LybraFinance confirmed](https://github.com/code-423n4/2023-06-lybra-findings/issues/723#issuecomment-1635550670)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/pools/base/LybraPeUSDVaultBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../../interfaces/Iconfigurator.sol\";\nimport \"../../interfaces/IPeUSD.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IPriceFeed {\n    function fetchPrice() external returns (uint256);\n}\n\nabstract contract LybraPeUSDVaultBase {\n    IPeUSD public immutable PeUSD;\n    IERC20 public immutable collateralAsset;\n    Iconfigurator public immutable configurator;\n    uint256 public poolTotalPeUSDCirculation;\n    uint8 immutable vaultType = 1;\n    IPriceFeed immutable etherOracle;\n\n    mapping(address => uint256) public depositedAsset;\n    mapping(address => uint256) borrowed;\n    mapping(address => uint256) feeStored;\n    mapping(address => uint256) feeUpdatedAt;\n\n    event DepositEther(address indexed onBehalfOf, address asset, uint256 etherAmount, uint256 assetAmount, uint256 timestamp);\n\n    event DepositAsset(address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n    event WithdrawAsset(address sponsor, address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n    event Mint(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Burn(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event LiquidationRecord(address provider, address keeper, address indexed onBehalfOf, uint256 eusdamount, uint256 LiquidateAssetAmount, uint256 keeperReward, bool superLiquidation, uint256 timestamp);\n\n    event RigidRedemption(address indexed caller, address indexed provider, uint256 peusdAmount, uint256 assetAmount, uint256 timestamp);\n    event FeeDistribution(address indexed feeAddress, uint256 feeAmount, uint256 timestamp);\n\n    constructor(address _peusd, address _etherOracle, address _collateral, address _configurator) {\n        PeUSD = IPeUSD(_peusd);\n        collateralAsset = IERC20(_collateral);\n        configurator = Iconfigurator(_configurator);\n        etherOracle = IPriceFeed(_etherOracle);\n    }\n\n    function totalDepositedAsset() public view returns (uint256) {\n        return collateralAsset.balanceOf(address(this));\n    }\n\n    function depositEtherToMint(uint256 mintAmount) external payable virtual;\n\n    /**\n     * @notice Deposit staked ETH, update the interest distribution, can mint PeUSD directly\n     * Emits a `DepositAsset` event.\n     *\n     * Requirements:\n     * - `assetAmount` Must be higher than 0.\n     * - `mintAmount` Send 0 if doesn't mint PeUSD\n     */\n    function depositAssetToMint(uint256 assetAmount, uint256 mintAmount) external virtual {\n        require(assetAmount >= 1 ether, \"Deposit should not be less than 1 collateral asset.\");\n        uint256 preBalance = collateralAsset.balanceOf(address(this));\n        collateralAsset.transferFrom(msg.sender, address(this), assetAmount);\n        require(collateralAsset.balanceOf(address(this)) >= preBalance + assetAmount, \"\");\n\n        depositedAsset[msg.sender] += assetAmount;\n        if (mintAmount > 0) {\n            uint256 assetPrice = getAssetPrice();\n            _mintPeUSD(msg.sender, msg.sender, mintAmount, assetPrice);\n        }\n        emit DepositAsset(msg.sender, address(collateralAsset), assetAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Withdraw collateral assets to an address\n     * Emits a `WithdrawAsset` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     *\n     * @dev Withdraw stETH. Check user’s collateral ratio after withdrawal, should be higher than `safeCollateralRatio`\n     */\n    function withdraw(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _withdraw(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice The mint amount number of PeUSD is minted to the address\n     * Emits a `Mint` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0. Individual mint amount shouldn't surpass 10% when the circulation reaches 10_000_000\n     */\n    function mint(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _mintPeUSD(msg.sender, onBehalfOf, amount, getAssetPrice());\n    }\n\n    /**\n     * @notice Burn the amount of PeUSD and payback the amount of minted PeUSD\n     * Emits a `Burn` event.\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     * @dev Calling the internal`_repay`function.\n     */\n    function burn(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _repay(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is above 150%, Keeper liquidates borrowers whose collateral ratio is below badCollateralRatio, using PeUSD provided by Liquidation Provider.\n     *\n     * Requirements:\n     * - onBehalfOf Collateral Ratio should be below badCollateralRatio\n     * - assetAmount should be less than 50% of collateral\n     * - provider should authorize Lybra to utilize PeUSD\n     * @dev After liquidation, borrower's debt is reduced by assetAmount * assetPrice, collateral is reduced by the assetAmount corresponding to 110% of the value. Keeper gets keeperRatio / 110 of Liquidation Reward and Liquidator gets the remaining stETH.\n     */\n    function liquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / getBorrowedOf(onBehalfOf);\n        require(onBehalfOfCollateralRatio < configurator.getBadCollateralRatio(address(this)), \"Borrowers collateral ratio should below badCollateralRatio\");\n\n        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\");\n        require(PeUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n        uint256 peusdAmount = (assetAmount * assetPrice) / 1e18;\n\n        _repay(provider, onBehalfOf, peusdAmount);\n        uint256 reducedAsset = (assetAmount * 11) / 10;\n        depositedAsset[onBehalfOf] -= reducedAsset;\n        uint256 reward2keeper;\n        if (provider == msg.sender) {\n            collateralAsset.transfer(msg.sender, reducedAsset);\n        } else {\n            reward2keeper = (reducedAsset * configurator.vaultKeeperRatio(address(this))) / 110;\n            collateralAsset.transfer(provider, reducedAsset - reward2keeper);\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, peusdAmount, reducedAsset, reward2keeper, false, block.timestamp);\n    }\n\n    /**\n     * @notice Choose a Redemption Provider, Rigid Redeem `peusdAmount` of EUSD and get 1:1 value of stETH\n     * Emits a `RigidRedemption` event.\n     *\n     * *Requirements:\n     * - `provider` must be a Redemption Provider\n     * - `provider`debt must equal to or above`peusdAmount`\n     * @dev Service Fee for rigidRedemption `redemptionFee` is set to 0.5% by default, can be revised by DAO.\n     */\n    function rigidRedemption(address provider, uint256 peusdAmount) external virtual {\n        require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");\n        require(borrowed[provider] >= peusdAmount, \"peusdAmount cannot surpass providers debt\");\n        uint256 assetPrice = getAssetPrice();\n        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];\n        require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");\n        _repay(msg.sender, provider, peusdAmount);\n        uint256 collateralAmount = (((peusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;\n        depositedAsset[provider] -= collateralAmount;\n        collateralAsset.transfer(msg.sender, collateralAmount);\n        emit RigidRedemption(msg.sender, provider, peusdAmount, collateralAmount, block.timestamp);\n    }\n\n    /**\n     * @dev Refresh LBR reward before adding providers debt. Refresh Lybra generated service fee before adding totalSupply. Check providers collateralRatio cannot below `safeCollateralRatio`after minting.\n     */\n    function _mintPeUSD(address _provider, address _onBehalfOf, uint256 _mintAmount, uint256 _assetPrice) internal virtual {\n        require(poolTotalPeUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\");\n        _updateFee(_provider);\n\n        try configurator.refreshMintReward(_provider) {} catch {}\n\n        borrowed[_provider] += _mintAmount;\n\n        PeUSD.mint(_onBehalfOf, _mintAmount);\n        poolTotalPeUSDCirculation += _mintAmount;\n        _checkHealth(_provider, _assetPrice);\n        emit Mint(_provider, _onBehalfOf, _mintAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Burn _provideramount PeUSD to payback minted PeUSD for _onBehalfOf.\n     *\n     * @dev Refresh LBR reward before reducing providers debt. Refresh Lybra generated service fee before reducing totalPeUSDCirculation.\n     */\n    function _repay(address _provider, address _onBehalfOf, uint256 _amount) internal virtual {\n        try configurator.refreshMintReward(_onBehalfOf) {} catch {}\n        _updateFee(_onBehalfOf);\n        uint256 totalFee = feeStored[_onBehalfOf];\n        uint256 amount = borrowed[_onBehalfOf] + totalFee >= _amount ? _amount : borrowed[_onBehalfOf] + totalFee;\n        if(amount >= totalFee) {\n            feeStored[_onBehalfOf] = 0;\n            PeUSD.transferFrom(_provider, address(configurator), totalFee);\n            PeUSD.burn(_provider, amount - totalFee);\n        } else {\n            feeStored[_onBehalfOf] = totalFee - amount;\n            PeUSD.transferFrom(_provider, address(configurator), amount);\n        }\n        try configurator.distributeRewards() {} catch {}\n        borrowed[_onBehalfOf] -= amount;\n        poolTotalPeUSDCirculation -= amount;\n\n        emit Burn(_provider, _onBehalfOf, amount, block.timestamp);\n    }\n\n    function _withdraw(address _provider, address _onBehalfOf, uint256 _amount) internal {\n        require(depositedAsset[_provider] >= _amount, \"Withdraw amount exceeds deposited amount.\");\n        depositedAsset[_provider] -= _amount;\n        collateralAsset.transfer(_onBehalfOf, _amount);\n        if (getBorrowedOf(_provider) > 0) {\n            _checkHealth(_provider, getAssetPrice());\n        }\n        emit WithdrawAsset(_provider, address(collateralAsset), _onBehalfOf, _amount, block.timestamp);\n    }\n\n    /**\n     * @dev Get USD value of current collateral asset and minted EUSD through price oracle / Collateral asset USD value must higher than safe Collateral Ratio.\n     */\n    function _checkHealth(address user, uint256 price) internal view {\n        if (((depositedAsset[user] * price * 100) / getBorrowedOf(user)) < configurator.getSafeCollateralRatio(address(this))) \n            revert(\"collateralRatio is Below safeCollateralRatio\");\n    }\n\n    function _updateFee(address user) internal {\n        if (block.timestamp > feeUpdatedAt[user]) {\n            feeStored[user] += _newFee(user);\n            feeUpdatedAt[user] = block.timestamp;\n        }\n    }\n\n    function _newFee(address user) internal view returns (uint256) {\n        return (borrowed[user] * configurator.vaultMintFeeApy(address(this)) * (block.timestamp - feeUpdatedAt[user])) / (86400 * 365) / 10000;\n    }\n\n    /**\n     * @dev Return USD value of current ETH through Liquity PriceFeed Contract.\n     */\n    function _etherPrice() internal returns (uint256) {\n        return etherOracle.fetchPrice();\n    }\n\n    /**\n     * @dev Returns the current borrowing amount for the user, including borrowed shares and accumulated fees.\n     * @param user The address of the user.\n     * @return The total borrowing amount for the user.\n     */\n    function getBorrowedOf(address user) public view returns (uint256) {\n        return borrowed[user] + feeStored[user] + _newFee(user);\n    }\n\n    function getPoolTotalPeUSDCirculation() public view returns (uint256) {\n        return poolTotalPeUSDCirculation;\n    }\n\n    function getAsset() external view returns (address) {\n        return address(collateralAsset);\n    }\n\n    function getVaultType() external pure returns (uint8) {\n        return vaultType;\n    }\n\n    function getAssetPrice() public virtual returns (uint256);\n}"
    },
    {
      "filename": "contracts/lybra/pools/base/LybraPeUSDVaultBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../../interfaces/Iconfigurator.sol\";\nimport \"../../interfaces/IPeUSD.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IPriceFeed {\n    function fetchPrice() external returns (uint256);\n}\n\nabstract contract LybraPeUSDVaultBase {\n    IPeUSD public immutable PeUSD;\n    IERC20 public immutable collateralAsset;\n    Iconfigurator public immutable configurator;\n    uint256 public poolTotalPeUSDCirculation;\n    uint8 immutable vaultType = 1;\n    IPriceFeed immutable etherOracle;\n\n    mapping(address => uint256) public depositedAsset;\n    mapping(address => uint256) borrowed;\n    mapping(address => uint256) feeStored;\n    mapping(address => uint256) feeUpdatedAt;\n\n    event DepositEther(address indexed onBehalfOf, address asset, uint256 etherAmount, uint256 assetAmount, uint256 timestamp);\n\n    event DepositAsset(address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n    event WithdrawAsset(address sponsor, address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n    event Mint(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Burn(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event LiquidationRecord(address provider, address keeper, address indexed onBehalfOf, uint256 eusdamount, uint256 LiquidateAssetAmount, uint256 keeperReward, bool superLiquidation, uint256 timestamp);\n\n    event RigidRedemption(address indexed caller, address indexed provider, uint256 peusdAmount, uint256 assetAmount, uint256 timestamp);\n    event FeeDistribution(address indexed feeAddress, uint256 feeAmount, uint256 timestamp);\n\n    constructor(address _peusd, address _etherOracle, address _collateral, address _configurator) {\n        PeUSD = IPeUSD(_peusd);\n        collateralAsset = IERC20(_collateral);\n        configurator = Iconfigurator(_configurator);\n        etherOracle = IPriceFeed(_etherOracle);\n    }\n\n    function totalDepositedAsset() public view returns (uint256) {\n        return collateralAsset.balanceOf(address(this));\n    }\n\n    function depositEtherToMint(uint256 mintAmount) external payable virtual;\n\n    /**\n     * @notice Deposit staked ETH, update the interest distribution, can mint PeUSD directly\n     * Emits a `DepositAsset` event.\n     *\n     * Requirements:\n     * - `assetAmount` Must be higher than 0.\n     * - `mintAmount` Send 0 if doesn't mint PeUSD\n     */\n    function depositAssetToMint(uint256 assetAmount, uint256 mintAmount) external virtual {\n        require(assetAmount >= 1 ether, \"Deposit should not be less than 1 collateral asset.\");\n        uint256 preBalance = collateralAsset.balanceOf(address(this));\n        collateralAsset.transferFrom(msg.sender, address(this), assetAmount);\n        require(collateralAsset.balanceOf(address(this)) >= preBalance + assetAmount, \"\");\n\n        depositedAsset[msg.sender] += assetAmount;\n        if (mintAmount > 0) {\n            uint256 assetPrice = getAssetPrice();\n            _mintPeUSD(msg.sender, msg.sender, mintAmount, assetPrice);\n        }\n        emit DepositAsset(msg.sender, address(collateralAsset), assetAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Withdraw collateral assets to an address\n     * Emits a `WithdrawAsset` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     *\n     * @dev Withdraw stETH. Check user’s collateral ratio after withdrawal, should be higher than `safeCollateralRatio`\n     */\n    function withdraw(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _withdraw(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice The mint amount number of PeUSD is minted to the address\n     * Emits a `Mint` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0. Individual mint amount shouldn't surpass 10% when the circulation reaches 10_000_000\n     */\n    function mint(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _mintPeUSD(msg.sender, onBehalfOf, amount, getAssetPrice());\n    }\n\n    /**\n     * @notice Burn the amount of PeUSD and payback the amount of minted PeUSD\n     * Emits a `Burn` event.\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     * @dev Calling the internal`_repay`function.\n     */\n    function burn(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _repay(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is above 150%, Keeper liquidates borrowers whose collateral ratio is below badCollateralRatio, using PeUSD provided by Liquidation Provider.\n     *\n     * Requirements:\n     * - onBehalfOf Collateral Ratio should be below badCollateralRatio\n     * - assetAmount should be less than 50% of collateral\n     * - provider should authorize Lybra to utilize PeUSD\n     * @dev After liquidation, borrower's debt is reduced by assetAmount * assetPrice, collateral is reduced by the assetAmount corresponding to 110% of the value. Keeper gets keeperRatio / 110 of Liquidation Reward and Liquidator gets the remaining stETH.\n     */\n    function liquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / getBorrowedOf(onBehalfOf);\n        require(onBehalfOfCollateralRatio < configurator.getBadCollateralRatio(address(this)), \"Borrowers collateral ratio should below badCollateralRatio\");\n\n        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\");\n        require(PeUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n        uint256 peusdAmount = (assetAmount * assetPrice) / 1e18;\n\n        _repay(provider, onBehalfOf, peusdAmount);\n        uint256 reducedAsset = (assetAmount * 11) / 10;\n        depositedAsset[onBehalfOf] -= reducedAsset;\n        uint256 reward2keeper;\n        if (provider == msg.sender) {\n            collateralAsset.transfer(msg.sender, reducedAsset);\n        } else {\n            reward2keeper = (reducedAsset * configurator.vaultKeeperRatio(address(this))) / 110;\n            collateralAsset.transfer(provider, reducedAsset - reward2keeper);\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, peusdAmount, reducedAsset, reward2keeper, false, block.timestamp);\n    }\n\n    /**\n     * @notice Choose a Redemption Provider, Rigid Redeem `peusdAmount` of EUSD and get 1:1 value of stETH\n     * Emits a `RigidRedemption` event.\n     *\n     * *Requirements:\n     * - `provider` must be a Redemption Provider\n     * - `provider`debt must equal to or above`peusdAmount`\n     * @dev Service Fee for rigidRedemption `redemptionFee` is set to 0.5% by default, can be revised by DAO.\n     */\n    function rigidRedemption(address provider, uint256 peusdAmount) external virtual {\n        require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");\n        require(borrowed[provider] >= peusdAmount, \"peusdAmount cannot surpass providers debt\");\n        uint256 assetPrice = getAssetPrice();\n        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];\n        require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");\n        _repay(msg.sender, provider, peusdAmount);\n        uint256 collateralAmount = (((peusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;\n        depositedAsset[provider] -= collateralAmount;\n        collateralAsset.transfer(msg.sender, collateralAmount);\n        emit RigidRedemption(msg.sender, provider, peusdAmount, collateralAmount, block.timestamp);\n    }\n\n    /**\n     * @dev Refresh LBR reward before adding providers debt. Refresh Lybra generated service fee before adding totalSupply. Check providers collateralRatio cannot below `safeCollateralRatio`after minting.\n     */\n    function _mintPeUSD(address _provider, address _onBehalfOf, uint256 _mintAmount, uint256 _assetPrice) internal virtual {\n        require(poolTotalPeUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\");\n        _updateFee(_provider);\n\n        try configurator.refreshMintReward(_provider) {} catch {}\n\n        borrowed[_provider] += _mintAmount;\n\n        PeUSD.mint(_onBehalfOf, _mintAmount);\n        poolTotalPeUSDCirculation += _mintAmount;\n        _checkHealth(_provider, _assetPrice);\n        emit Mint(_provider, _onBehalfOf, _mintAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Burn _provideramount PeUSD to payback minted PeUSD for _onBehalfOf.\n     *\n     * @dev Refresh LBR reward before reducing providers debt. Refresh Lybra generated service fee before reducing totalPeUSDCirculation.\n     */\n    function _repay(address _provider, address _onBehalfOf, uint256 _amount) internal virtual {\n        try configurator.refreshMintReward(_onBehalfOf) {} catch {}\n        _updateFee(_onBehalfOf);\n        uint256 totalFee = feeStored[_onBehalfOf];\n        uint256 amount = borrowed[_onBehalfOf] + totalFee >= _amount ? _amount : borrowed[_onBehalfOf] + totalFee;\n        if(amount >= totalFee) {\n            feeStored[_onBehalfOf] = 0;\n            PeUSD.transferFrom(_provider, address(configurator), totalFee);\n            PeUSD.burn(_provider, amount - totalFee);\n        } else {\n            feeStored[_onBehalfOf] = totalFee - amount;\n            PeUSD.transferFrom(_provider, address(configurator), amount);\n        }\n        try configurator.distributeRewards() {} catch {}\n        borrowed[_onBehalfOf] -= amount;\n        poolTotalPeUSDCirculation -= amount;\n\n        emit Burn(_provider, _onBehalfOf, amount, block.timestamp);\n    }\n\n    function _withdraw(address _provider, address _onBehalfOf, uint256 _amount) internal {\n        require(depositedAsset[_provider] >= _amount, \"Withdraw amount exceeds deposited amount.\");\n        depositedAsset[_provider] -= _amount;\n        collateralAsset.transfer(_onBehalfOf, _amount);\n        if (getBorrowedOf(_provider) > 0) {\n            _checkHealth(_provider, getAssetPrice());\n        }\n        emit WithdrawAsset(_provider, address(collateralAsset), _onBehalfOf, _amount, block.timestamp);\n    }\n\n    /**\n     * @dev Get USD value of current collateral asset and minted EUSD through price oracle / Collateral asset USD value must higher than safe Collateral Ratio.\n     */\n    function _checkHealth(address user, uint256 price) internal view {\n        if (((depositedAsset[user] * price * 100) / getBorrowedOf(user)) < configurator.getSafeCollateralRatio(address(this))) \n            revert(\"collateralRatio is Below safeCollateralRatio\");\n    }\n\n    function _updateFee(address user) internal {\n        if (block.timestamp > feeUpdatedAt[user]) {\n            feeStored[user] += _newFee(user);\n            feeUpdatedAt[user] = block.timestamp;\n        }\n    }\n\n    function _newFee(address user) internal view returns (uint256) {\n        return (borrowed[user] * configurator.vaultMintFeeApy(address(this)) * (block.timestamp - feeUpdatedAt[user])) / (86400 * 365) / 10000;\n    }\n\n    /**\n     * @dev Return USD value of current ETH through Liquity PriceFeed Contract.\n     */\n    function _etherPrice() internal returns (uint256) {\n        return etherOracle.fetchPrice();\n    }\n\n    /**\n     * @dev Returns the current borrowing amount for the user, including borrowed shares and accumulated fees.\n     * @param user The address of the user.\n     * @return The total borrowing amount for the user.\n     */\n    function getBorrowedOf(address user) public view returns (uint256) {\n        return borrowed[user] + feeStored[user] + _newFee(user);\n    }\n\n    function getPoolTotalPeUSDCirculation() public view returns (uint256) {\n        return poolTotalPeUSDCirculation;\n    }\n\n    function getAsset() external view returns (address) {\n        return address(collateralAsset);\n    }\n\n    function getVaultType() external pure returns (uint8) {\n        return vaultType;\n    }\n\n    function getAssetPrice() public virtual returns (uint256);\n}"
    },
    {
      "filename": "contracts/lybra/pools/base/LybraPeUSDVaultBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../../interfaces/Iconfigurator.sol\";\nimport \"../../interfaces/IPeUSD.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IPriceFeed {\n    function fetchPrice() external returns (uint256);\n}\n\nabstract contract LybraPeUSDVaultBase {\n    IPeUSD public immutable PeUSD;\n    IERC20 public immutable collateralAsset;\n    Iconfigurator public immutable configurator;\n    uint256 public poolTotalPeUSDCirculation;\n    uint8 immutable vaultType = 1;\n    IPriceFeed immutable etherOracle;\n\n    mapping(address => uint256) public depositedAsset;\n    mapping(address => uint256) borrowed;\n    mapping(address => uint256) feeStored;\n    mapping(address => uint256) feeUpdatedAt;\n\n    event DepositEther(address indexed onBehalfOf, address asset, uint256 etherAmount, uint256 assetAmount, uint256 timestamp);\n\n    event DepositAsset(address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n    event WithdrawAsset(address sponsor, address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n    event Mint(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Burn(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event LiquidationRecord(address provider, address keeper, address indexed onBehalfOf, uint256 eusdamount, uint256 LiquidateAssetAmount, uint256 keeperReward, bool superLiquidation, uint256 timestamp);\n\n    event RigidRedemption(address indexed caller, address indexed provider, uint256 peusdAmount, uint256 assetAmount, uint256 timestamp);\n    event FeeDistribution(address indexed feeAddress, uint256 feeAmount, uint256 timestamp);\n\n    constructor(address _peusd, address _etherOracle, address _collateral, address _configurator) {\n        PeUSD = IPeUSD(_peusd);\n        collateralAsset = IERC20(_collateral);\n        configurator = Iconfigurator(_configurator);\n        etherOracle = IPriceFeed(_etherOracle);\n    }\n\n    function totalDepositedAsset() public view returns (uint256) {\n        return collateralAsset.balanceOf(address(this));\n    }\n\n    function depositEtherToMint(uint256 mintAmount) external payable virtual;\n\n    /**\n     * @notice Deposit staked ETH, update the interest distribution, can mint PeUSD directly\n     * Emits a `DepositAsset` event.\n     *\n     * Requirements:\n     * - `assetAmount` Must be higher than 0.\n     * - `mintAmount` Send 0 if doesn't mint PeUSD\n     */\n    function depositAssetToMint(uint256 assetAmount, uint256 mintAmount) external virtual {\n        require(assetAmount >= 1 ether, \"Deposit should not be less than 1 collateral asset.\");\n        uint256 preBalance = collateralAsset.balanceOf(address(this));\n        collateralAsset.transferFrom(msg.sender, address(this), assetAmount);\n        require(collateralAsset.balanceOf(address(this)) >= preBalance + assetAmount, \"\");\n\n        depositedAsset[msg.sender] += assetAmount;\n        if (mintAmount > 0) {\n            uint256 assetPrice = getAssetPrice();\n            _mintPeUSD(msg.sender, msg.sender, mintAmount, assetPrice);\n        }\n        emit DepositAsset(msg.sender, address(collateralAsset), assetAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Withdraw collateral assets to an address\n     * Emits a `WithdrawAsset` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     *\n     * @dev Withdraw stETH. Check user’s collateral ratio after withdrawal, should be higher than `safeCollateralRatio`\n     */\n    function withdraw(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _withdraw(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice The mint amount number of PeUSD is minted to the address\n     * Emits a `Mint` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0. Individual mint amount shouldn't surpass 10% when the circulation reaches 10_000_000\n     */\n    function mint(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _mintPeUSD(msg.sender, onBehalfOf, amount, getAssetPrice());\n    }\n\n    /**\n     * @notice Burn the amount of PeUSD and payback the amount of minted PeUSD\n     * Emits a `Burn` event.\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     * @dev Calling the internal`_repay`function.\n     */\n    function burn(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _repay(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is above 150%, Keeper liquidates borrowers whose collateral ratio is below badCollateralRatio, using PeUSD provided by Liquidation Provider.\n     *\n     * Requirements:\n     * - onBehalfOf Collateral Ratio should be below badCollateralRatio\n     * - assetAmount should be less than 50% of collateral\n     * - provider should authorize Lybra to utilize PeUSD\n     * @dev After liquidation, borrower's debt is reduced by assetAmount * assetPrice, collateral is reduced by the assetAmount corresponding to 110% of the value. Keeper gets keeperRatio / 110 of Liquidation Reward and Liquidator gets the remaining stETH.\n     */\n    function liquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / getBorrowedOf(onBehalfOf);\n        require(onBehalfOfCollateralRatio < configurator.getBadCollateralRatio(address(this)), \"Borrowers collateral ratio should below badCollateralRatio\");\n\n        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\");\n        require(PeUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n        uint256 peusdAmount = (assetAmount * assetPrice) / 1e18;\n\n        _repay(provider, onBehalfOf, peusdAmount);\n        uint256 reducedAsset = (assetAmount * 11) / 10;\n        depositedAsset[onBehalfOf] -= reducedAsset;\n        uint256 reward2keeper;\n        if (provider == msg.sender) {\n            collateralAsset.transfer(msg.sender, reducedAsset);\n        } else {\n            reward2keeper = (reducedAsset * configurator.vaultKeeperRatio(address(this))) / 110;\n            collateralAsset.transfer(provider, reducedAsset - reward2keeper);\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, peusdAmount, reducedAsset, reward2keeper, false, block.timestamp);\n    }\n\n    /**\n     * @notice Choose a Redemption Provider, Rigid Redeem `peusdAmount` of EUSD and get 1:1 value of stETH\n     * Emits a `RigidRedemption` event.\n     *\n     * *Requirements:"
    }
  ]
}