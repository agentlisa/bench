{
  "Title": "payUser fails silently if the bonus was already paid",
  "Content": "In the [`payUser`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L34) function of the `AirDrop` contract, an [`if`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L37) clause is used to check whether a bonus has already been paid. In the case the condition `amount &gt; 0` is not satisfied, the payment will not be performed, giving the caller no notice that it didn’t go through apart from the lack of an associated event.\n\n\nConsider complementing the `if` with an `else` clause that handles the logic when the condition fails.\n\n\n***Update:** an event is now [emitted](https://github.com/jeualvarez/Token-Airdrop/blob/master/contracts/AirDrop.sol#L71) in case the `if` condition fails.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Airdrop.sol",
      "content": "pragma solidity ^0.4.0;\npragma experimental \"v0.5.0\";\n\nimport \"../node_modules/openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"../node_modules/openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\ncontract AirDrop is Ownable {\n    address public renderTokenAddress;\n    bool public listFinalized = false;\n    uint256 public totalBonus;\n    uint256 public nextUserToBePaid = 0;\n\n    mapping (address => uint256) public bonusAmounts;\n    address[] public bonusAddresses;\n\n    event AddedUser(address userAddress, uint256 userIndex, uint256 bonusAmount);\n    event PaidUser(address userAddress, uint256 userIndex, uint256 amountPaid);\n\n    constructor(address _renderTokenAddress) public {\n        renderTokenAddress = _renderTokenAddress;\n    }\n    \n    function getUserCount() public view returns (uint256) {\n        return bonusAddresses.length;\n    }\n    \n    function addUser(address _userAddress, uint256 _amount) internal {\n        require (bonusAmounts[_userAddress] == 0, \"User bonus shouldn't exist before adding\");\n        bonusAmounts[_userAddress] = _amount;\n        totalBonus += _amount;\n        emit AddedUser(_userAddress, bonusAddresses.push(_userAddress) - 1, _amount);\n    }\n\n    function payUser(uint256 _id) internal returns(uint256 amount) {\n        amount = bonusAmounts[bonusAddresses[_id]];\n\n        if (amount > 0) { // If bonus hasn't been paid yet\n            bonusAmounts[bonusAddresses[_id]] = 0;\n            totalBonus -= amount;\n            ERC20(renderTokenAddress).transfer(bonusAddresses[_id], amount);\n            emit PaidUser(bonusAddresses[_id], _id, amount);\n        }\n    }\n\n    function addManyUsers(address[] _recipients, uint256[] _amounts) public onlyOwner {\n        require(!listFinalized, \"Adding users allowed only when list isn't finalized\");\n        for (uint i = 0; i < _recipients.length; i++) {\n            addUser(_recipients[i], _amounts[i]);\n        }\n    }\n    \n    function payUserRange(uint256 _idFrom, uint256 _idTo) internal returns(uint256 totalPaid) {\n        require(_idTo < bonusAddresses.length, \"idTo should be less than user count\");\n        require(_idFrom <= _idTo, \"idFrom shouldn't be greater than idTo\");\n        for (uint i = _idFrom; i <= _idTo; i++) { // idTo included\n            totalPaid += payUser(i);\n        }\n        nextUserToBePaid = _idTo + 1;\n    }\n    \n    function payManyUsers(uint256 batchSize) public onlyOwner returns(uint256 totalPaid) {\n        require(listFinalized, \"Payment can be called only after list is finalized\");\n        uint256 idFrom = nextUserToBePaid;\n        uint256 idTo = idFrom + batchSize - 1;\n        if (idTo >= bonusAddresses.length) idTo = bonusAddresses.length - 1;\n        return payUserRange(idFrom, idTo);\n    }\n\n    function finalizeList() public onlyOwner {\n        require(!listFinalized, \"Can be called only if list isn't finalized\");\n        listFinalized = true;\n    }\n    \n    function returnTokens() public onlyOwner {\n        uint256 amount = ERC20(renderTokenAddress).balanceOf(address(this));\n        ERC20(renderTokenAddress).transfer(owner, amount);\n    }\n}"
    },
    {
      "filename": "contracts/AirDrop.sol",
      "content": "pragma solidity ^0.4.24;\n\nimport { ERC20, SafeERC20 } from \"../node_modules/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\nimport { Ownable } from \"../node_modules/openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport { SafeMath } from \"../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n * @title AirDrop\n *\n * @dev RNDRToken GenesisBonus AirDrop contract\n * For workflow see:\n * https://github.com/jeualvarez/Token-Airdrop\n */\n\ncontract AirDrop is Ownable {\n  using SafeERC20 for ERC20;\n  using SafeMath for uint256;\n\n  address public renderTokenAddress;\n  address public refundAddress;\n  bool public listFinalized = false;\n  uint256 public totalBonus = 0; // Before finalizing - check if totalBonus matches the total bonus amount to distribute\n  uint256 public nextUserToBePaid = 0;\n\n  mapping (address => uint256) public bonusAmounts;\n  address[] public bonusAddresses;\n\n  event AddedUser(address indexed userAddress, uint256 userIndex, uint256 bonusAmount);\n  event PaidUser(address indexed userAddress, uint256 userIndex, uint256 amountPaid);\n  event DoublePayAttempt(address indexed userAddress, uint256 userIndex, uint256 amountPaid);\n\n  /**\n  * @notice Create Airdrop contract\n  * @param _renderTokenAddress Address of current RNDR token ERC20 contract\n  * @param _refundAddress Address where to refund the excess of RNDR tokens\n  */\n  constructor(address _renderTokenAddress, address _refundAddress) public {\n    require(_renderTokenAddress != address(0), \"_renderTokenAddress must not be null\");\n    require(_refundAddress != address(0), \"_refundAddress must not be null\");\n    renderTokenAddress = _renderTokenAddress;\n    refundAddress = _refundAddress;\n  }\n\n  //\n  // Internal functions\n  //\n\n  /**\n  * @dev Adds a user to bonus-list.\n  * @param _userAddress The address of a user\n  * @param _amount The amount of bonus to send to the specified user\n  */\n  function _addUser(address _userAddress, uint256 _amount) internal {\n    require (bonusAmounts[_userAddress] == 0, \"User bonus shouldn't exist before adding\");\n    bonusAmounts[_userAddress] = _amount;\n    totalBonus = totalBonus.add(_amount);\n    uint256 userIndex = bonusAddresses.push(_userAddress).sub(1);\n    emit AddedUser(_userAddress, userIndex, _amount);\n  }\n\n  /**\n  * @dev Pays a user based on his ID in bonus-list\n  * @param _id User ID from bonus-list\n  * @return Amount of bonus tokens paid to this user\n  */\n  function _payUser(uint256 _id) internal returns(uint256 amount) {\n    amount = bonusAmounts[bonusAddresses[_id]];\n\n    if (amount > 0) { // If bonus hasn't been paid yet\n      bonusAmounts[bonusAddresses[_id]] = 0;\n      totalBonus = totalBonus.sub(amount);\n      ERC20(renderTokenAddress).safeTransfer(bonusAddresses[_id], amount);\n      emit PaidUser(bonusAddresses[_id], _id, amount);\n    } else {\n      emit DoublePayAttempt(bonusAddresses[_id], _id, amount); // This basically can't happen. Check why there was an attempt to double-pay?\n    }\n  }\n\n  /**\n  * @dev Pays many users based on their IDs in bonus-list (from-to)\n  * @param _idFrom User ID to start paying from\n  * @param _idTo User ID to finish paying (included)\n  * @return Amount of total bonus paid\n  */\n  function _payUserRange(uint256 _idFrom, uint256 _idTo) internal returns(uint256 totalPaid) {\n    require(_idTo < bonusAddresses.length, \"idTo should be less than user count\");\n    require(_idFrom <= _idTo, \"idFrom shouldn't be greater than idTo\");\n    for (uint256 i = _idFrom; i <= _idTo; i++) { // idTo included\n      totalPaid = totalPaid.add(_payUser(i));\n    }\n    nextUserToBePaid = _idTo.add(1);\n  }\n\n  //\n  // External functions\n  //\n\n  /**\n  * @notice Gets total users count\n  * @dev Use this to determine if bonus-list has the correct number of users before finalizing\n  * @return Count of all users in bonus-list\n  */\n  function getUserCount() external view returns (uint256) {\n    return bonusAddresses.length;\n  }\n\n  /**\n  * @notice Adds many users from arrays of addresses and correspoding amounts\n  * @param _recipients Array containing addresses of users\n  * @param _amounts Array containing amounts of bonus to send to users from _recepients array\n  */\n  function addManyUsers(address[] _recipients, uint256[] _amounts) external onlyOwner {\n    require(!listFinalized, \"Adding users allowed only when list isn't finalized\");\n    require(_recipients.length == _amounts.length, \"_recipients and _amounts arrays have different number of elements\");\n    for (uint256 i = 0; i < _recipients.length; i++) {\n      _addUser(_recipients[i], _amounts[i]);\n    }\n  }\n\n  /**\n  * @notice Pays next batch of users\n  * @param batchSize How many users to pay\n  * @return Amount of total bonus paid\n  */\n  function payManyUsers(uint256 batchSize) external onlyOwner returns(uint256 totalPaid) {\n    require(listFinalized, \"Payment can be called only after list is finalized\");\n    require(batchSize > 0, \"Batch size should not be 0\");\n    uint256 idFrom = nextUserToBePaid;\n    uint256 idTo = idFrom.add(batchSize).sub(1);\n    if (idTo >= bonusAddresses.length) {\n      idTo = bonusAddresses.length.sub(1);\n    }\n    return _payUserRange(idFrom, idTo);\n  }\n\n  /**\n  * @notice Finalize bonus-list. Can't add more users after the list is finalized\n  * @dev Verify user count, totalBonus, and all individual user addresses & amounts after finalizing and before sending any tokens to the contract\n  */\n  function finalizeList() external onlyOwner {\n    require(!listFinalized, \"Can be called only if list isn't finalized\");\n    listFinalized = true;\n  }\n\n  /**\n  * @notice Return the unpaid excess of tokens to refundAddress\n  */\n  function returnTokens() external onlyOwner {\n    uint256 amount = ERC20(renderTokenAddress).balanceOf(address(this));\n    ERC20(renderTokenAddress).transfer(refundAddress, amount);\n  }\n}"
    }
  ]
}