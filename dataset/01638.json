{
  "Title": "H-3: Anyone can sell other users' tokens as `fromToken`, and get the `toToken`'s themselves due to `decodeData.payer` is never checked.",
  "Content": "# Issue H-3: Anyone can sell other users' tokens as `fromToken`, and get the `toToken`'s themselves due to `decodeData.payer` is never checked. \n\nSource: https://github.com/sherlock-audit/2023-06-dodo-judging/issues/106 \n\n## Found by \ndirk\\_y, jprod15, osmanozdemir1, qckhp\n## Summary\nAnyone can sell other users' tokens as `fromToken`, and get the `toToken`'s themselves due to `decodeData.payer` is never checked.\n\n## Vulnerability Detail\nLet's examine the token-selling process and the transaction flow.\n\nThe user will initiate the transaction with the `sellTokens()` method in the `D3Proxy.sol` contract, and provide multiple inputs like `pool`, `fromToken`, `toToken`, `fromAmount`, `data` etc.\n\n[https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/periphery/D3Proxy.sol#L80-L101](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/periphery/D3Proxy.sol#L80-L101)\n\n```solidity\n// File: D3Proxy.sol\n    function sellTokens(\n        address pool,\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 minReceiveAmount,\n        bytes calldata data,\n        uint256 deadLine\n    ) public payable judgeExpired(deadLine) returns (uint256 receiveToAmount) {\n        if (fromToken == _ETH_ADDRESS_) {\n            require(msg.value == fromAmount, \"D3PROXY_VALUE_INVALID\");\n            receiveToAmount = ID3MM(pool).sellToken(to, _WETH_, toToken, fromAmount, minReceiveAmount, data);\n        } else if (toToken == _ETH_ADDRESS_) {\n            receiveToAmount =\n                ID3MM(pool).sellToken(address(this), fromToken, _WETH_, fromAmount, minReceiveAmount, data);\n            _withdrawWETH(to, receiveToAmount);\n            // multicall withdraw weth to user\n        } else {\n            receiveToAmount = ID3MM(pool).sellToken(to, fromToken, toToken, fromAmount, minReceiveAmount, data);\n        }\n    }\n```\n\nAfter some checks, this method in the `D3Proxy.sol` will make a call to the `sellToken()` function in the pool contract (inherits *D3Trading.sol*). After this call, things that will happen in the pool contract are:\n\n1. Transferring the `toToken`'s to the \"to\" address (with `_transferOut`)\n    \n2. Making a callback to `D3Proxy` contract to deposit `fromToken`'s to the pool. (with `IDODOSwapCallback(msg.sender).d3MMSwapCallBack`)\n    \n3. Checking the pool balance and making sure that the `fromToken`'s are actually deposited to the pool. (with this line: `IERC20(fromToken).balanceOf(address(this)) - state.balances[fromToken] >= fromAmount`)\n    \n\nYou can see the code here:  \n[https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Trading.sol#L108-L118](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Trading.sol#L108-L118)\n\n```solidity\n// File: D3Trading.sol\n// Method: sellToken()\n108.-->  _transferOut(to, toToken, receiveToAmount);\n109.\n110.     // external call & swap callback\n111.-->  IDODOSwapCallback(msg.sender).d3MMSwapCallBack(fromToken, fromAmount, data);\n112.     // transfer mtFee to maintainer\n113.     _transferOut(state._MAINTAINER_, toToken, mtFee);\n114.\n115.     require(\n116.-->      IERC20(fromToken).balanceOf(address(this)) - state.balances[fromToken] >= fromAmount,\n117.         Errors.FROMAMOUNT_NOT_ENOUGH\n118.     );\n```\n\nThe source of the vulnerability is the `d3MMSwapCallBack()` function in the `D3Proxy`. It is called by the pool contract with the `fromToken`, `fromAmount` and `data` inputs to make a `fromToken` deposit to the pool.\n\nThe issue is that the deposit is made from `decodeData.payer` and **it is never checked if that payer is actually the seller**. Here is the line that causes this vulnerability:  \n[https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/periphery/D3Proxy.sol#L142](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/periphery/D3Proxy.sol#L142)\n\n```solidity\n//File: D3Proxy.sol \n    /// @notice This callback is used to deposit token into D3MM\n    /// @param token The address of token\n    /// @param value The amount of token need to deposit to D3MM\n    /// @param _data Any data to be passed through to the callback\n    function d3MMSwapCallBack(address token, uint256 value, bytes calldata _data) external override {\n        require(ID3Vault(_D3_VAULT_).allPoolAddrMap(msg.sender), \"D3PROXY_CALLBACK_INVALID\");\n        SwapCallbackData memory decodeData;\n        decodeData = abi.decode(_data, (SwapCallbackData));\n-->     _deposit(decodeData.payer, msg.sender, token, value);\n    }\n```\n\nAn attacker can create a `SwapCallbackData` struct with any regular user's address, encode it and pass it through the `sellTokens()` function, and get the `toToken`'s.\n\nYou can say that `_deposit()` will need the payer's approval but the attackers will know that too. A regular user might have already approved the pool & proxy for the max amount. Attackers can easily check any token's allowances and exploit already approved tokens. Or they can simply watch the mempool and front-run any normal seller right after they approve but before they call the `sellTokens()`.\n\n## Impact\nAn attacker can sell any user's tokens and steal their funds.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/periphery/D3Proxy.sol#L80-L101\n\n```solidity\nThe `sellTokens()` function in the `D3Proxy.sol`:\n// File: D3Proxy.sol\n    function sellTokens(\n        address pool,\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 minReceiveAmount,\n        bytes calldata data,\n        uint256 deadLine\n    ) public payable judgeExpired(deadLine) returns (uint256 receiveToAmount) {\n        if (fromToken == _ETH_ADDRESS_) {\n            require(msg.value == fromAmount, \"D3PROXY_VALUE_INVALID\");\n            receiveToAmount = ID3MM(pool).sellToken(to, _WETH_, toToken, fromAmount, minReceiveAmount, data);\n        } else if (toToken == _ETH_ADDRESS_) {\n            receiveToAmount =\n                ID3MM(pool).sellToken(address(this), fromToken, _WETH_, fromAmount, minReceiveAmount, data);\n            _withdrawWETH(to, receiveToAmount);\n            // multicall withdraw weth to user\n        } else {\n            receiveToAmount = ID3MM(pool).sellToken(to, fromToken, toToken, fromAmount, minReceiveAmount, data);\n        }\n    }\n```\n\nThe `sellToken()` function in the `D3Trading.sol`:\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Trading.sol#L90-L126\n\n```solidity\n// File: D3Trading.sol\n// Method: sellToken()\n108.-->  _transferOut(to, toToken, receiveToAmount);\n109.\n110.     // external call & swap callback\n111.-->  IDODOSwapCallback(msg.sender).d3MMSwapCallBack(fromToken, fromAmount, data);\n112.     // transfer mtFee to maintainer\n113.     _transferOut(state._MAINTAINER_, toToken, mtFee);\n114.\n115.     require(\n116.-->      IERC20(fromToken).balanceOf(address(this)) - state.balances[fromToken] >= fromAmount,\n117.         Errors.FROMAMOUNT_NOT_ENOUGH\n118.     );\n```\n\nThe `d3MMSwapCallBack()` function in the `D3Proxy.sol`:\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/periphery/D3Proxy.sol#L134-L143\n\n```solidity\n//File: D3Proxy.sol \n    /// @notice This callback is used to deposit token into D3MM\n    /// @param token The address of token\n    /// @param value The amount of token need to deposit to D3MM\n    /// @param _data Any data to be passed through to the callback\n    function d3MMSwapCallBack(address token, uint256 value, bytes calldata _data) external override {\n        require(ID3Vault(_D3_VAULT_).allPoolAddrMap(msg.sender), \"D3PROXY_CALLBACK_INVALID\");\n        SwapCallbackData memory decodeData;\n        decodeData = abi.decode(_data, (SwapCallbackData));\n-->     _deposit(decodeData.payer, msg.sender, token, value);\n    }\n```\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\nI would recommend to check if the `decodeData.payer == msg.sender` in the beginning of the `sellTokens()` function in `D3Proxy` contract. Because msg.sender will be the pool's address if you want to check it in the `d3MMSwapCallBack()` function, and this check will not be valid to see if the payer is actually the seller. \n\nAnother option might be creating a local variable called \"seller\" and saving the msg.sender value when they first started the transaction. After that make `decodeData.payer == seller` check in the `d3MMSwapCallBack()`.\n\n\n\n\n## Discussion\n\n**Attens1423**\n\nfix pr: https://github.com/DODOEX/new-dodo-v3/pull/41/commits/292141d1bb3be71cde6b154f7619c52d628ca18c\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/89",
  "Code": [
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/periphery/D3Proxy.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"../lib/PMMRangeOrder.sol\";\nimport \"../lib/Errors.sol\";\nimport {ID3MM} from \"../intf/ID3MM.sol\";\nimport {ID3Factory} from \"../intf/ID3Factory.sol\";\nimport {IWETH} from \"contracts/intf/IWETH.sol\";\nimport {IDODOSwapCallback} from \"../intf/IDODOSwapCallback.sol\";\nimport {IDODOApproveProxy} from \"contracts/intf/IDODOApproveProxy.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ID3Vault} from \"../intf/ID3Vault.sol\";\n\ncontract D3Proxy is IDODOSwapCallback {\n    using SafeERC20 for IERC20;\n\n    address public immutable _DODO_APPROVE_PROXY_;\n    address public immutable _WETH_;\n    address public immutable _D3_VAULT_;\n    address public immutable _ETH_ADDRESS_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    struct SwapCallbackData {\n        bytes data;\n        address payer;\n    }\n\n    // ============ Modifiers ============\n\n    modifier judgeExpired(uint256 deadLine) {\n        require(deadLine >= block.timestamp, \"D3PROXY_EXPIRED\");\n        _;\n    }\n\n    // ============ Constructor ============\n\n    constructor(address approveProxy, address weth, address d3Vault) {\n        _DODO_APPROVE_PROXY_ = approveProxy;\n        _WETH_ = weth;\n        _D3_VAULT_ = d3Vault;\n    }\n\n    // ======================================\n\n    fallback() external payable {}\n\n    receive() external payable {\n        require(msg.sender == _WETH_, \"D3PROXY_NOT_WETH9\");\n    }\n\n    // ======================================\n\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) public payable returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                assembly {\n                    revert(add(result, 32), mload(result))\n                }\n            }\n\n            results[i] = result;\n        }\n    }\n\n    /// @notice Sell certain amount of tokens, i.e., fromToken amount is known\n    /// @param pool The address of the pool to which you want to sell tokens\n    /// @param to The address to receive the return back token\n    /// @param fromToken The address of the fromToken\n    /// @param toToken The address of the toToken\n    /// @param fromAmount The amount of the fromToken you want to sell\n    /// @param minReceiveAmount The minimal amount you expect to receive\n    /// @param data Any data to be passed through to the callback\n    /// @param deadLine The transaction should be processed before the deadline\n    function sellTokens(\n        address pool,\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 minReceiveAmount,\n        bytes calldata data,\n        uint256 deadLine\n    ) public payable judgeExpired(deadLine) returns (uint256 receiveToAmount) {\n        if (fromToken == _ETH_ADDRESS_) {\n            require(msg.value == fromAmount, \"D3PROXY_VALUE_INVALID\");\n            receiveToAmount = ID3MM(pool).sellToken(to, _WETH_, toToken, fromAmount, minReceiveAmount, data);\n        } else if (toToken == _ETH_ADDRESS_) {\n            receiveToAmount =\n                ID3MM(pool).sellToken(address(this), fromToken, _WETH_, fromAmount, minReceiveAmount, data);\n            _withdrawWETH(to, receiveToAmount);\n            // multicall withdraw weth to user\n        } else {\n            receiveToAmount = ID3MM(pool).sellToken(to, fromToken, toToken, fromAmount, minReceiveAmount, data);\n        }\n    }\n\n    /// @notice Buy certain amount of tokens, i.e., toToken amount is known\n    /// @param pool The address of the pool to which you want to sell tokens\n    /// @param to The address to receive the return back token\n    /// @param fromToken The address of the fromToken\n    /// @param toToken The address of the toToken\n    /// @param quoteAmount The amount of the toToken you want to buy\n    /// @param maxPayAmount The maximum amount of fromToken you would like to pay\n    /// @param data Any data to be passed through to the callback\n    /// @param deadLine The transaction should be processed before the deadline\n    function buyTokens(\n        address pool,\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 quoteAmount,\n        uint256 maxPayAmount,\n        bytes calldata data,\n        uint256 deadLine\n    ) public payable judgeExpired(deadLine) returns (uint256 payFromAmount) {\n        if (fromToken == _ETH_ADDRESS_) {\n            payFromAmount = ID3MM(pool).buyToken(to, _WETH_, toToken, quoteAmount, maxPayAmount, data);\n            // multicall refund eth to user\n        } else if (toToken == _ETH_ADDRESS_) {\n            payFromAmount = ID3MM(pool).buyToken(address(this), fromToken, _WETH_, quoteAmount, maxPayAmount, data);\n            _withdrawWETH(to, quoteAmount);\n            // multicall withdraw weth to user\n        } else {\n            payFromAmount = ID3MM(pool).buyToken(to, fromToken, toToken, quoteAmount, maxPayAmount, data);\n        }\n    }\n\n    /// @notice This callback is used to deposit token into D3MM\n    /// @param token The address of token\n    /// @param value The amount of token need to deposit to D3MM\n    /// @param _data Any data to be passed through to the callback\n    function d3MMSwapCallBack(address token, uint256 value, bytes calldata _data) external override {\n        require(ID3Vault(_D3_VAULT_).allPoolAddrMap(msg.sender), \"D3PROXY_CALLBACK_INVALID\");\n        SwapCallbackData memory decodeData;\n        decodeData = abi.decode(_data, (SwapCallbackData));\n        _deposit(decodeData.payer, msg.sender, token, value);\n    }\n\n    /// @notice LP deposit token into pool\n    /// @param user the one who own dtokens\n    /// @param  token The address of token\n    /// @param amount The amount of token\n    function userDeposit(address user, address token, uint256 amount) external payable {\n        if (token == _ETH_ADDRESS_) {\n            require(msg.value == amount, \"D3PROXY_PAYMENT_NOT_MATCH\");\n            _deposit(msg.sender, _D3_VAULT_, _WETH_, amount);\n            ID3Vault(_D3_VAULT_).userDeposit(user, _WETH_);\n        } else {\n            _deposit(msg.sender, _D3_VAULT_, token, amount);\n            ID3Vault(_D3_VAULT_).userDeposit(user, token);\n        }\n    }\n\n    function userWithdraw(address to, address token, address dToken, uint256 dTokenAmount) external payable returns(uint256 amount){\n        _deposit(msg.sender, address(this), dToken, dTokenAmount);\n        if (token != _ETH_ADDRESS_) {\n            amount = ID3Vault(_D3_VAULT_).userWithdraw(to, msg.sender, token, dTokenAmount);\n        } else {\n            amount = ID3Vault(_D3_VAULT_).userWithdraw(address(this), msg.sender, _WETH_, dTokenAmount);\n            _withdrawWETH(to, amount);\n        }\n    }\n\n    /// @notice Pool owner deposit token into pool\n    /// @param pool The address of pool\n    /// @param  token The address of token\n    /// @param amount The amount of token\n    function makerDeposit(address pool, address token, uint256 amount) external payable {\n        if (token == _ETH_ADDRESS_) {\n            require(msg.value == amount, \"D3PROXY_PAYMENT_NOT_MATCH\");\n            _deposit(msg.sender, pool, _WETH_, amount);\n            ID3MM(pool).makerDeposit(_WETH_);\n        } else{\n            _deposit(msg.sender, pool, token, amount);\n            ID3MM(pool).makerDeposit(token);\n        }\n    }\n\n\n    // ======= external refund =======\n\n    /// @dev when fromToken = ETH and call buyTokens, call this function to refund user's eth\n    function refundETH() external payable {\n        if (address(this).balance > 0) {\n            _safeTransferETH(msg.sender, address(this).balance);\n        }\n    }\n\n    /// @dev when toToken == eth, call this function to get eth\n    /// @param to The account address to receive ETH\n    /// @param minAmount The minimum amount to withdraw\n    function withdrawWETH(address to, uint256 minAmount) external payable {\n        uint256 withdrawAmount = IWETH(_WETH_).balanceOf(address(this));\n        require(withdrawAmount >= minAmount, \"D3PROXY_WETH_NOT_ENOUGH\");\n\n        _withdrawWETH(to, withdrawAmount);\n    }\n\n    // ======= internal =======\n\n    /// @notice Before the first pool swap, contract call _deposit to get ERC20 token through DODOApprove / transfer ETH to WETH\n    /// @dev ETH transfer is allowed\n    /// @param from The address which will transfer token out\n    /// @param to The address which will receive the token\n    /// @param token The token address\n    /// @param value The token amount\n    function _deposit(address from, address to, address token, uint256 value) internal {\n        if (token == _WETH_ && address(this).balance >= value) {\n            // pay with WETH9\n            IWETH(_WETH_).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(_WETH_).transfer(to, value);\n        } else {\n            // pull payment\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(token, from, to, value);\n        }\n    }\n\n    /// @dev Withdraw ETH from WETH\n    /// @param to The account address to receive ETH\n    /// @param withdrawAmount The amount to withdraw\n    function _withdrawWETH(address to, uint256 withdrawAmount) internal {\n        IWETH(_WETH_).withdraw(withdrawAmount);\n        _safeTransferETH(to, withdrawAmount);\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `ETH_TRANSFER_FAIL`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function _safeTransferETH(address to, uint256 value) internal {\n        (bool success,) = to.call{value: value}(new bytes(0));\n        require(success, \"D3PROXY_ETH_TRANSFER_FAIL\");\n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Trading.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"../lib/PMMRangeOrder.sol\";\nimport \"../lib/Errors.sol\";\nimport {IDODOSwapCallback} from \"../intf/IDODOSwapCallback.sol\";\nimport {ID3Maker} from \"../intf/ID3Maker.sol\";\nimport {ID3Vault} from \"../intf/ID3Vault.sol\";\nimport {D3Funding} from \"./D3Funding.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract D3Trading is D3Funding {\n    using SafeERC20 for IERC20;\n\n    modifier onlyMaker() {\n        require(msg.sender == state._MAKER_, \"not maker\");\n        _;\n    }\n\n    // =============== Read ===============\n\n    /// @notice for external users to read tokenMMInfo\n    function getTokenMMPriceInfoForRead(\n        address token\n    )\n        external\n        view\n        returns (uint256 askDownPrice, uint256 askUpPrice, uint256 bidDownPrice, uint256 bidUpPrice, uint256 swapFee)\n    {\n        (Types.TokenMMInfo memory tokenMMInfo, ) =\n            ID3Maker(state._MAKER_).getTokenMMInfoForPool(token);\n\n        askDownPrice = tokenMMInfo.askDownPrice;\n        askUpPrice = tokenMMInfo.askUpPrice;\n        bidDownPrice = tokenMMInfo.bidDownPrice;\n        bidUpPrice = tokenMMInfo.bidUpPrice;\n        swapFee = tokenMMInfo.swapFeeRate;\n    }\n\n    function getTokenMMOtherInfoForRead(\n        address token\n    )\n        external\n        view\n        returns (\n            uint256 askAmount,\n            uint256 bidAmount,\n            uint256 kAsk,\n            uint256 kBid,\n            uint256 cumulativeAsk,\n            uint256 cumulativeBid\n        )\n    {\n        (Types.TokenMMInfo memory tokenMMInfo, uint256 tokenIndex) =\n            ID3Maker(state._MAKER_).getTokenMMInfoForPool(token);\n        cumulativeAsk = allFlag >> (tokenIndex) & 1 == 0 ? 0 : tokenCumMap[token].cumulativeAsk;\n        cumulativeBid = allFlag >> (tokenIndex) & 1 == 0 ? 0 : tokenCumMap[token].cumulativeBid;\n\n        bidAmount = tokenMMInfo.bidAmount;\n        askAmount = tokenMMInfo.askAmount;\n        kAsk = tokenMMInfo.kAsk;\n        kBid = tokenMMInfo.kBid;\n    }\n\n    // ============ Swap =============\n    /// @notice get swap status for internal swap\n    function getRangeOrderState(\n        address fromToken,\n        address toToken\n    ) public view returns (Types.RangeOrderState memory roState) {\n        roState.oracle = state._ORACLE_;\n        uint256 fromTokenIndex;\n        uint256 toTokenIndex;\n        (roState.fromTokenMMInfo, fromTokenIndex) = ID3Maker(state._MAKER_).getTokenMMInfoForPool(fromToken);\n        (roState.toTokenMMInfo, toTokenIndex) = ID3Maker(state._MAKER_).getTokenMMInfoForPool(toToken);\n\n        // deal with update flag\n\n        roState.fromTokenMMInfo.cumulativeAsk =\n            allFlag >> (fromTokenIndex) & 1 == 0 ? 0 : tokenCumMap[fromToken].cumulativeAsk;\n        roState.fromTokenMMInfo.cumulativeBid =\n            allFlag >> (fromTokenIndex) & 1 == 0 ? 0 : tokenCumMap[fromToken].cumulativeBid;\n        roState.toTokenMMInfo.cumulativeAsk =\n            allFlag >> (toTokenIndex) & 1 == 0 ? 0 : tokenCumMap[toToken].cumulativeAsk;\n        roState.toTokenMMInfo.cumulativeBid =\n            allFlag >> (toTokenIndex) & 1 == 0 ? 0 : tokenCumMap[toToken].cumulativeAsk;\n    }\n\n    /// @notice user sell a certain amount of fromToken,  get toToken\n    function sellToken(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 minReceiveAmount,\n        bytes calldata data\n    ) external poolOngoing nonReentrant returns (uint256) {\n        require(ID3Maker(state._MAKER_).checkHeartbeat(), Errors.HEARTBEAT_CHECK_FAIL);\n\n        _updateCumulative(fromToken);\n        _updateCumulative(toToken);\n\n        (uint256 payFromAmount, uint256 receiveToAmount, uint256 vusdAmount, uint256 swapFee, uint256 mtFee) =\n            querySellTokens(fromToken, toToken, fromAmount);\n        require(receiveToAmount >= minReceiveAmount, Errors.MINRES_NOT_ENOUGH);\n\n        _transferOut(to, toToken, receiveToAmount);\n\n        // external call & swap callback\n        IDODOSwapCallback(msg.sender).d3MMSwapCallBack(fromToken, fromAmount, data);\n        // transfer mtFee to maintainer\n        _transferOut(state._MAINTAINER_, toToken, mtFee);\n\n        require(\n            IERC20(fromToken).balanceOf(address(this)) - state.balances[fromToken] >= fromAmount,\n            Errors.FROMAMOUNT_NOT_ENOUGH\n        );\n\n        // record swap\n        _recordSwap(fromToken, toToken, vusdAmount, receiveToAmount + swapFee);\n        require(checkSafe(), Errors.BELOW_IM_RATIO);\n\n        emit Swap(to, fromToken, toToken, payFromAmount, receiveToAmount, swapFee, mtFee, 0);\n        return receiveToAmount;\n    }\n\n    /// @notice user ask for a certain amount of toToken, fromToken's amount will be determined by toToken's amount\n    function buyToken(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 quoteAmount,\n        uint256 maxPayAmount,\n        bytes calldata data\n    ) external poolOngoing nonReentrant returns (uint256) {\n        require(ID3Maker(state._MAKER_).checkHeartbeat(), Errors.HEARTBEAT_CHECK_FAIL);\n\n        _updateCumulative(fromToken);\n        _updateCumulative(toToken);\n\n        // query amount and transfer out\n        (uint256 payFromAmount, uint256 receiveToAmount, uint256 vusdAmount, uint256 swapFee, uint256 mtFee) =\n            queryBuyTokens(fromToken, toToken, quoteAmount);\n        require(payFromAmount <= maxPayAmount, Errors.MAXPAY_NOT_ENOUGH);\n\n        _transferOut(to, toToken, receiveToAmount);\n\n        // external call & swap callback\n        IDODOSwapCallback(msg.sender).d3MMSwapCallBack(fromToken, payFromAmount, data);\n        // transfer mtFee to maintainer\n        _transferOut(state._MAINTAINER_, toToken, mtFee);\n\n        require(\n            IERC20(fromToken).balanceOf(address(this)) - state.balances[fromToken] >= payFromAmount,\n            Errors.FROMAMOUNT_NOT_ENOUGH\n        );\n\n        // record swap\n        _recordSwap(fromToken, toToken, vusdAmount, receiveToAmount + swapFee);\n        require(checkSafe(), Errors.BELOW_IM_RATIO);\n\n        emit Swap(to, fromToken, toToken, payFromAmount, receiveToAmount, swapFee, mtFee, 1);\n        return payFromAmount;\n    }\n\n    /// @notice user could query sellToken result deducted swapFee, assign fromAmount\n    /// @return payFromAmount fromToken's amount = fromAmount\n    /// @return receiveToAmount toToken's amount\n    /// @return vusdAmount fromToken bid vusd\n    /// @return swapFee dodo takes the fee\n    function querySellTokens(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount\n    ) public view returns (uint256 payFromAmount, uint256 receiveToAmount, uint256 vusdAmount, uint256 swapFee, uint256 mtFee) {\n        require(fromAmount > 1000, Errors.AMOUNT_TOO_SMALL);\n        Types.RangeOrderState memory D3State = getRangeOrderState(fromToken, toToken);\n\n        (payFromAmount, receiveToAmount, vusdAmount) =\n            PMMRangeOrder.querySellTokens(D3State, fromToken, toToken, fromAmount);\n\n        receiveToAmount = receiveToAmount > state.balances[toToken] ? state.balances[toToken] : receiveToAmount;\n\n        uint256 swapFeeRate = D3State.fromTokenMMInfo.swapFeeRate +  D3State.toTokenMMInfo.swapFeeRate;\n        swapFee = DecimalMath.mulFloor(receiveToAmount, swapFeeRate);\n        uint256 mtFeeRate = D3State.fromTokenMMInfo.mtFeeRate +  D3State.toTokenMMInfo.mtFeeRate;\n        mtFee = DecimalMath.mulFloor(receiveToAmount, mtFeeRate);\n\n        return (payFromAmount, receiveToAmount - swapFee, vusdAmount, swapFee, mtFee);\n    }\n\n    /// @notice user could query sellToken result deducted swapFee, assign toAmount\n    /// @return payFromAmount fromToken's amount\n    /// @return receiveToAmount toToken's amount = toAmount\n    /// @return vusdAmount fromToken bid vusd\n    /// @return swapFee dodo takes the fee\n    function queryBuyTokens(\n        address fromToken,\n        address toToken,\n        uint256 toAmount\n    ) public view returns (uint256 payFromAmount, uint256 receiveToAmount, uint256 vusdAmount, uint256 swapFee, uint256 mtFee) {\n        require(toAmount > 1000, Errors.AMOUNT_TOO_SMALL);\n        Types.RangeOrderState memory D3State = getRangeOrderState(fromToken, toToken);\n\n        // query amount and transfer out\n        {\n        uint256 swapFeeRate = D3State.fromTokenMMInfo.swapFeeRate +  D3State.toTokenMMInfo.swapFeeRate;\n        swapFee = DecimalMath.mulFloor(toAmount, swapFeeRate);\n        uint256 mtFeeRate = D3State.fromTokenMMInfo.mtFeeRate +  D3State.toTokenMMInfo.mtFeeRate;\n        mtFee = DecimalMath.mulFloor(toAmount, mtFeeRate);\n        toAmount += swapFee;\n        }\n\n        require(toAmount <= state.balances[toToken], Errors.BALANCE_NOT_ENOUGH);\n\n        uint256 receiveToAmountWithFee;\n        (payFromAmount, receiveToAmountWithFee , vusdAmount) =\n            PMMRangeOrder.queryBuyTokens(D3State, fromToken, toToken, toAmount);\n\n        return (payFromAmount, receiveToAmountWithFee - swapFee, vusdAmount, swapFee, mtFee);\n    }\n\n    // ================ internal ==========================\n\n    function _recordSwap(address fromToken, address toToken, uint256 fromAmount, uint256 toAmount) internal {\n        tokenCumMap[fromToken].cumulativeBid += fromAmount;\n        tokenCumMap[toToken].cumulativeAsk += toAmount;\n\n        _updateReserve(fromToken);\n        _updateReserve(toToken);\n    }\n\n    function _updateCumulative(address token) internal {\n        uint256 tokenIndex = ID3Maker(state._MAKER_).getOneTokenOriginIndex(token);\n        uint256 tokenFlag = (allFlag >> tokenIndex) & 1;\n        if (tokenFlag == 0) {\n            tokenCumMap[token].cumulativeAsk = 0;\n            tokenCumMap[token].cumulativeBid = 0;\n            allFlag |= (1 << tokenIndex);\n        }\n    }\n\n    function _transferOut(address to, address token, uint256 amount) internal {\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    // ================ call by maker ==========================\n    function setNewAllFlag(uint256 newFlag) external onlyMaker {\n        allFlag = newFlag;\n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/periphery/D3Proxy.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"../lib/PMMRangeOrder.sol\";\nimport \"../lib/Errors.sol\";\nimport {ID3MM} from \"../intf/ID3MM.sol\";\nimport {ID3Factory} from \"../intf/ID3Factory.sol\";\nimport {IWETH} from \"contracts/intf/IWETH.sol\";\nimport {IDODOSwapCallback} from \"../intf/IDODOSwapCallback.sol\";\nimport {IDODOApproveProxy} from \"contracts/intf/IDODOApproveProxy.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ID3Vault} from \"../intf/ID3Vault.sol\";\n\ncontract D3Proxy is IDODOSwapCallback {\n    using SafeERC20 for IERC20;\n\n    address public immutable _DODO_APPROVE_PROXY_;\n    address public immutable _WETH_;\n    address public immutable _D3_VAULT_;\n    address public immutable _ETH_ADDRESS_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    struct SwapCallbackData {\n        bytes data;\n        address payer;\n    }\n\n    // ============ Modifiers ============\n\n    modifier judgeExpired(uint256 deadLine) {\n        require(deadLine >= block.timestamp, \"D3PROXY_EXPIRED\");\n        _;\n    }\n\n    // ============ Constructor ============\n\n    constructor(address approveProxy, address weth, address d3Vault) {\n        _DODO_APPROVE_PROXY_ = approveProxy;\n        _WETH_ = weth;\n        _D3_VAULT_ = d3Vault;\n    }\n\n    // ======================================\n\n    fallback() external payable {}\n\n    receive() external payable {\n        require(msg.sender == _WETH_, \"D3PROXY_NOT_WETH9\");\n    }\n\n    // ======================================\n\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) public payable returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                assembly {\n                    revert(add(result, 32), mload(result))\n                }\n            }\n\n            results[i] = result;\n        }\n    }\n\n    /// @notice Sell certain amount of tokens, i.e., fromToken amount is known\n    /// @param pool The address of the pool to which you want to sell tokens\n    /// @param to The address to receive the return back token\n    /// @param fromToken The address of the fromToken\n    /// @param toToken The address of the toToken\n    /// @param fromAmount The amount of the fromToken you want to sell\n    /// @param minReceiveAmount The minimal amount you expect to receive\n    /// @param data Any data to be passed through to the callback\n    /// @param deadLine The transaction should be processed before the deadline\n    function sellTokens(\n        address pool,\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 minReceiveAmount,\n        bytes calldata data,\n        uint256 deadLine\n    ) public payable judgeExpired(deadLine) returns (uint256 receiveToAmount) {\n        if (fromToken == _ETH_ADDRESS_) {\n            require(msg.value == fromAmount, \"D3PROXY_VALUE_INVALID\");\n            receiveToAmount = ID3MM(pool).sellToken(to, _WETH_, toToken, fromAmount, minReceiveAmount, data);\n        } else if (toToken == _ETH_ADDRESS_) {\n            receiveToAmount =\n                ID3MM(pool).sellToken(address(this), fromToken, _WETH_, fromAmount, minReceiveAmount, data);\n            _withdrawWETH(to, receiveToAmount);\n            // multicall withdraw weth to user\n        } else {\n            receiveToAmount = ID3MM(pool).sellToken(to, fromToken, toToken, fromAmount, minReceiveAmount, data);\n        }\n    }\n\n    /// @notice Buy certain amount of tokens, i.e., toToken amount is known\n    /// @param pool The address of the pool to which you want to sell tokens\n    /// @param to The address to receive the return back token\n    /// @param fromToken The address of the fromToken\n    /// @param toToken The address of the toToken\n    /// @param quoteAmount The amount of the toToken you want to buy\n    /// @param maxPayAmount The maximum amount of fromToken you would like to pay\n    /// @param data Any data to be passed through to the callback\n    /// @param deadLine The transaction should be processed before the deadline\n    function buyTokens(\n        address pool,\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 quoteAmount,\n        uint256 maxPayAmount,\n        bytes calldata data,\n        uint256 deadLine\n    ) public payable judgeExpired(deadLine) returns (uint256 payFromAmount) {\n        if (fromToken == _ETH_ADDRESS_) {\n            payFromAmount = ID3MM(pool).buyToken(to, _WETH_, toToken, quoteAmount, maxPayAmount, data);\n            // multicall refund eth to user\n        } else if (toToken == _ETH_ADDRESS_) {\n            payFromAmount = ID3MM(pool).buyToken(address(this), fromToken, _WETH_, quoteAmount, maxPayAmount, data);\n            _withdrawWETH(to, quoteAmount);\n            // multicall withdraw weth to user\n        } else {\n            payFromAmount = ID3MM(pool).buyToken(to, fromToken, toToken, quoteAmount, maxPayAmount, data);\n        }\n    }\n\n    /// @notice This callback is used to deposit token into D3MM\n    /// @param token The address of token\n    /// @param value The amount of token need to deposit to D3MM\n    /// @param _data Any data to be passed through to the callback\n    function d3MMSwapCallBack(address token, uint256 value, bytes calldata _data) external override {\n        require(ID3Vault(_D3_VAULT_).allPoolAddrMap(msg.sender), \"D3PROXY_CALLBACK_INVALID\");\n        SwapCallbackData memory decodeData;\n        decodeData = abi.decode(_data, (SwapCallbackData));\n        _deposit(decodeData.payer, msg.sender, token, value);\n    }\n\n    /// @notice LP deposit token into pool\n    /// @param user the one who own dtokens\n    /// @param  token The address of token\n    /// @param amount The amount of token\n    function userDeposit(address user, address token, uint256 amount) external payable {\n        if (token == _ETH_ADDRESS_) {\n            require(msg.value == amount, \"D3PROXY_PAYMENT_NOT_MATCH\");\n            _deposit(msg.sender, _D3_VAULT_, _WETH_, amount);\n            ID3Vault(_D3_VAULT_).userDeposit(user, _WETH_);\n        } else {\n            _deposit(msg.sender, _D3_VAULT_, token, amount);\n            ID3Vault(_D3_VAULT_).userDeposit(user, token);\n        }\n    }\n\n    function userWithdraw(address to, address token, address dToken, uint256 dTokenAmount) external payable returns(uint256 amount){\n        _deposit(msg.sender, address(this), dToken, dTokenAmount);\n        if (token != _ETH_ADDRESS_) {\n            amount = ID3Vault(_D3_VAULT_).userWithdraw(to, msg.sender, token, dTokenAmount);\n        } else {\n            amount = ID3Vault(_D3_VAULT_).userWithdraw(address(this), msg.sender, _WETH_, dTokenAmount);\n            _withdrawWETH(to, amount);\n        }\n    }\n\n    /// @notice Pool owner deposit token into pool\n    /// @param pool The address of pool\n    /// @param  token The address of token\n    /// @param amount The amount of token\n    function makerDeposit(address pool, address token, uint256 amount) external payable {\n        if (token == _ETH_ADDRESS_) {\n            require(msg.value == amount, \"D3PROXY_PAYMENT_NOT_MATCH\");\n            _deposit(msg.sender, pool, _WETH_, amount);\n            ID3MM(pool).makerDeposit(_WETH_);\n        } else{\n            _deposit(msg.sender, pool, token, amount);\n            ID3MM(pool).makerDeposit(token);\n        }\n    }\n\n\n    // ======= external refund =======\n\n    /// @dev when fromToken = ETH and call buyTokens, call this function to refund user's eth\n    function refundETH() external payable {\n        if (address(this).balance > 0) {\n            _safeTransferETH(msg.sender, address(this).balance);\n        }\n    }\n\n    /// @dev when toToken == eth, call this function to get eth\n    /// @param to The account address to receive ETH\n    /// @param minAmount The minimum amount to withdraw\n    function withdrawWETH(address to, uint256 minAmount) external payable {\n        uint256 withdrawAmount = IWETH(_WETH_).balanceOf(address(this));\n        require(withdrawAmount >= minAmount, \"D3PROXY_WETH_NOT_ENOUGH\");\n\n        _withdrawWETH(to, withdrawAmount);\n    }\n\n    // ======= internal =======\n\n    /// @notice Before the first pool swap, contract call _deposit to get ERC20 token through DODOApprove / transfer ETH to WETH\n    /// @dev ETH transfer is allowed\n    /// @param from The address which will transfer token out\n    /// @param to The address which will receive the token\n    /// @param token The token address\n    /// @param value The token amount\n    function _deposit(address from, address to, address token, uint256 value) internal {\n        if (token == _WETH_ && address(this).balance >= value) {\n            // pay with WETH9\n            IWETH(_WETH_).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(_WETH_).transfer(to, value);\n        } else {\n            // pull payment\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(token, from, to, value);\n        }\n    }\n\n    /// @dev Withdraw ETH from WETH\n    /// @param to The account address to receive ETH\n    /// @param withdrawAmount The amount to withdraw\n    function _withdrawWETH(address to, uint256 withdrawAmount) internal {\n        IWETH(_WETH_).withdraw(withdrawAmount);\n        _safeTransferETH(to, withdrawAmount);\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `ETH_TRANSFER_FAIL`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function _safeTransferETH(address to, uint256 value) internal {\n        (bool success,) = to.call{value: value}(new bytes(0));\n        require(success, \"D3PROXY_ETH_TRANSFER_FAIL\");\n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/periphery/D3Proxy.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"../lib/PMMRangeOrder.sol\";\nimport \"../lib/Errors.sol\";\nimport {ID3MM} from \"../intf/ID3MM.sol\";\nimport {ID3Factory} from \"../intf/ID3Factory.sol\";\nimport {IWETH} from \"contracts/intf/IWETH.sol\";\nimport {IDODOSwapCallback} from \"../intf/IDODOSwapCallback.sol\";\nimport {IDODOApproveProxy} from \"contracts/intf/IDODOApproveProxy.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ID3Vault} from \"../intf/ID3Vault.sol\";\n\ncontract D3Proxy is IDODOSwapCallback {\n    using SafeERC20 for IERC20;\n\n    address public immutable _DODO_APPROVE_PROXY_;\n    address public immutable _WETH_;\n    address public immutable _D3_VAULT_;\n    address public immutable _ETH_ADDRESS_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    struct SwapCallbackData {\n        bytes data;\n        address payer;\n    }\n\n    // ============ Modifiers ============\n\n    modifier judgeExpired(uint256 deadLine) {\n        require(deadLine >= block.timestamp, \"D3PROXY_EXPIRED\");\n        _;\n    }\n\n    // ============ Constructor ============\n\n    constructor(address approveProxy, address weth, address d3Vault) {\n        _DODO_APPROVE_PROXY_ = approveProxy;\n        _WETH_ = weth;\n        _D3_VAULT_ = d3Vault;\n    }\n\n    // ======================================\n\n    fallback() external payable {}\n\n    receive() external payable {\n        require(msg.sender == _WETH_, \"D3PROXY_NOT_WETH9\");\n    }\n\n    // ======================================\n\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) public payable returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for ("
    }
  ]
}