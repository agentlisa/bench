{
  "Title": "M-3: `universalApproveMax` will not work for some tokens that don't support approve `type(uint256).max` amount.",
  "Content": "# Issue M-3: `universalApproveMax` will not work for some tokens that don't support approve `type(uint256).max` amount. \n\nSource: https://github.com/sherlock-audit/2022-11-dodo-judging/issues/41 \n\n## Found by \nTomo, jayphbee\n\n## Summary\n`universalApproveMax` will not work for some tokens that don't support approve `type(uint256).max` amount.\n\n## Vulnerability Detail\nThere are tokens that doesn't support approve spender `type(uint256).max` amount. So the `universalApproveMax` will not work for some tokens like `UNI` or `COMP` who will revert when approve `type(uint256).max` amount.\n\n## Impact\nTokens that don't support approve `type(uint256).max` amount could not be swapped by calling `externalSwap` function.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-dodo/blob/main/contracts/SmartRoute/DODORouteProxy.sol#L181-L183\n```solidity\n            if (approveTarget != address(0)) {\n                IERC20(fromToken).universalApproveMax(approveTarget, fromTokenAmount);\n            }\n```\nhttps://github.com/sherlock-audit/2022-11-dodo/blob/main/contracts/SmartRoute/lib/UniversalERC20.sol#L36-L48\n```solidity\nfunction universalApproveMax(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        uint256 allowance = token.allowance(address(this), to);\n        if (allowance < amount) {\n            if (allowance > 0) {\n                token.safeApprove(to, 0);\n            }\n            token.safeApprove(to, type(uint256).max);\n        }\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nI would suggest approve only the necessay amount of token to the `approveTarget` instead of the `type(uint256).max` amount.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/21",
  "Code": [
    {
      "filename": "contracts/SmartRoute/DODORouteProxy.sol",
      "content": "/*\n\n    Copyright 2022 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.16;\npragma experimental ABIEncoderV2;\n\nimport { IDODOApproveProxy } from \"../DODOApproveProxy.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IWETH } from \"../intf/IWETH.sol\";\nimport { DecimalMath } from \"../lib/DecimalMath.sol\";\nimport { UniversalERC20 } from \"./lib/UniversalERC20.sol\";\nimport { IDODOAdapter } from \"./intf/IDODOAdapter.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title DODORouteProxy\n/// @author DODO Breeder\n/// @notice new routeProxy contract with fee rebate to manage all route. It provides three methods to swap, \n/// including mixSwap, multiSwap and externalSwap. Mixswap is for linear swap, which describes one token path \n/// with one pool each time. Multiswap is a simplified version about 1inch, which describes one token path \n/// with several pools each time. ExternalSwap is for other routers like 0x, 1inch and paraswap. Dodo and \n/// front-end users could take certain route fee rebate from each swap. Wherein dodo will get a fixed percentage, \n/// and front-end users could assign any proportion through function parameters.\n/// @dev dependence: DODOApprove.sol / DODOApproveProxy.sol / IDODOAdapter.sol\n/// In dodo's contract system, there is only one approve entrance DODOApprove.sol. DODOApprove manages DODOApproveProxy,\n/// Any contract which needs claim user's tokens must be registered in DODOApproveProxy. They used in DODORouteProxy are \n/// to manage user's token, all user's token must be claimed through DODOApproveProxy and DODOApprove\n/// IDODOAdapter determine the interface of adapter, in which swap happened. There are different adapters for different\n/// pools. Adapter addresses are parameters contructed off chain so they are loose coupling with routeProxy.\n/// adapters have two interface functions. func sellBase(address to, address pool, bytes memory moreInfo) and func sellQuote(address to, address pool, bytes memory moreInfo)\n\ncontract DODORouteProxy is Ownable {\n\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n\n    address constant _ETH_ADDRESS_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public immutable _WETH_;\n    // dodo appprove proxy address, the only entrance to get user's token\n    address public immutable _DODO_APPROVE_PROXY_;\n    // used in multiSwap for split, sum of pool weight must equal totalWeight\n    // in PoolInfo, pool weight has 8 bit, so totalWeight < 2**8\n    uint256 public totalWeight = 100;\n    // check safe safe for external call, add trusted external swap contract, 0x,1inch, paraswap\n    // only owner could manage\n    mapping(address => bool) public isWhiteListedContract; \n    // check safe for external approve, add trusted external swap approve contract, 0x, 1inch, paraswap\n    // only owner could manage\n    // Specially for 0x swap from eth, add zero address\n    mapping(address => bool) public isApproveWhiteListedContract; \n\n    // dodo route fee rate, unit is 10**18, default fee rate is 1.5 * 1e15 / 1e18 = 0.0015 = 0.015%\n    uint256 public routeFeeRate = 1500000000000000; \n    // dodo route fee receiver\n    address public routeFeeReceiver;\n\n    struct PoolInfo {\n        // pool swap direciton, 0 is for sellBase, 1 is for sellQuote\n        uint256 direction;\n        // distinct transferFrom pool(like dodoV1) and transfer pool\n        // 1 is for transferFrom pool, pool call transferFrom function to get tokens from adapter\n        // 2 is for transfer pool, pool determine swapAmount through balanceOf(Token) - reserve\n        uint256 poolEdition;\n        // pool weight, actualWeight = weight/totalWeight, totalAmount * actualWeight = amount through this pool swap\n        uint256 weight;\n        // pool address\n        address pool;\n        // pool adapter, making actual swap call in corresponding adapter\n        address adapter;\n        // pool adapter's Info, record addtional infos(could be zero-bytes) needed by each pool adapter\n        bytes moreInfo;\n    }\n\n    // ============ Events ============\n\n    event OrderHistory(\n        address fromToken,\n        address toToken,\n        address sender,\n        uint256 fromAmount,\n        uint256 returnAmount\n    );\n\n    // ============ Modifiers ============\n\n    modifier judgeExpired(uint256 deadLine) {\n        require(deadLine >= block.timestamp, \"DODORouteProxy: EXPIRED\");\n        _;\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Constructor ============\n\n    constructor(address payable weth, address dodoApproveProxy, address feeReceiver) public {\n        require(feeReceiver != address(0), \"DODORouteProxy: feeReceiver invalid\");\n        require(dodoApproveProxy != address(0), \"DODORouteProxy: dodoApproveProxy invalid\");\n        require(weth != address(0), \"DODORouteProxy: weth address invalid\");\n\n        _WETH_ = weth;\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\n        routeFeeReceiver = feeReceiver;\n    }\n\n    // ============ Owner only ============\n\n    function addWhiteList(address contractAddr) public onlyOwner {\n        isWhiteListedContract[contractAddr] = true;\n    }\n\n    function removeWhiteList(address contractAddr) public onlyOwner {\n        isWhiteListedContract[contractAddr] = false;\n    }\n\n    function addApproveWhiteList(address contractAddr) public onlyOwner {\n        isApproveWhiteListedContract[contractAddr] = true;\n    }\n\n    function removeApproveWhiteList(address contractAddr) public onlyOwner {\n        isApproveWhiteListedContract[contractAddr] = false;\n    }\n\n    function changeRouteFeeRate(uint256 newFeeRate) public onlyOwner {\n        require(newFeeRate < 10**18, \"DODORouteProxy: newFeeRate overflowed\");\n        routeFeeRate = newFeeRate;\n    }\n  \n    function changeRouteFeeReceiver(address newFeeReceiver) public onlyOwner {\n        require(newFeeReceiver != address(0), \"DODORouteProxy: feeReceiver invalid\");\n        routeFeeReceiver = newFeeReceiver;\n    }\n\n    function changeTotalWeight(uint256 newTotalWeight) public onlyOwner {\n        require(newTotalWeight < 2 ** 8, \"DODORouteProxy: totalWeight overflowed\");\n        totalWeight = newTotalWeight;\n    }\n\n    /// @notice used for emergency, generally there wouldn't be tokens left\n    function superWithdraw(address token) public onlyOwner {\n        if(token != _ETH_ADDRESS_) {\n            uint256 restAmount = IERC20(token).universalBalanceOf(address(this));\n            IERC20(token).universalTransfer(payable(routeFeeReceiver), restAmount);\n        } else {\n            uint256 restAmount = address(this).balance;\n            payable(routeFeeReceiver).transfer(restAmount);\n        }\n    }\n\n    // ============ Swap ============\n\n\n    /// @notice Call external black box contracts to finish a swap\n    /// @param approveTarget external swap approve address\n    /// @param swapTarget external swap address\n    /// @param feeData route fee info\n    /// @param callDataConcat external swap data\n    function externalSwap(\n        address fromToken,\n        address toToken,\n        address approveTarget,\n        address swapTarget,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        bytes memory feeData,\n        bytes memory callDataConcat,\n        uint256 deadLine\n    ) external payable judgeExpired(deadLine) returns (uint256 receiveAmount) {      \n        require(isWhiteListedContract[swapTarget], \"DODORouteProxy: Not Whitelist Contract\");  \n        require(isApproveWhiteListedContract[approveTarget], \"DODORouteProxy: Not Whitelist Appprove Contract\");  \n\n        // transfer in fromToken\n        if (fromToken != _ETH_ADDRESS_) {\n            // approve if needed\n            if (approveTarget != address(0)) {\n                IERC20(fromToken).universalApproveMax(approveTarget, fromTokenAmount);\n            }\n\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n                fromToken,\n                msg.sender,\n                address(this),\n                fromTokenAmount\n            );\n        }\n\n        // swap\n        uint256 toTokenOriginBalance;\n        if(toToken != _ETH_ADDRESS_) {\n            toTokenOriginBalance = IERC20(toToken).universalBalanceOf(address(this));\n        } else {\n            toTokenOriginBalance = IERC20(_WETH_).universalBalanceOf(address(this));\n        }\n\n        {\n            require(swapTarget != _DODO_APPROVE_PROXY_, \"DODORouteProxy: Risk Target\");\n            (bool success, bytes memory result) = swapTarget.call{\n                value: fromToken == _ETH_ADDRESS_ ? fromTokenAmount : 0\n            }(callDataConcat);\n            // revert with lowlevel info\n            if (success == false) {\n                assembly {\n                    revert(add(result,32),mload(result))\n                }\n            }\n        }\n\n        // calculate toToken amount\n        if(toToken != _ETH_ADDRESS_) {\n            receiveAmount = IERC20(toToken).universalBalanceOf(address(this)) - (\n                toTokenOriginBalance\n            );\n        } else {\n            receiveAmount = IERC20(_WETH_).universalBalanceOf(address(this)) - (\n                toTokenOriginBalance\n            );\n        }\n        \n        // distribute toToken\n        _routeWithdraw(toToken, receiveAmount, feeData, minReturnAmount);\n\n        emit OrderHistory(fromToken, toToken, msg.sender, fromTokenAmount, receiveAmount);\n    }\n\n    /// @notice linear version, describes one token path with one pool each time\n    /// @param mixAdapters adapter address array, record each pool's interrelated adapter in order\n    /// @param mixPairs pool address array, record pool address of the whole route in order\n    /// @param assetTo asset Address（pool or proxy）, describe pool adapter's receiver address. Specially assetTo[0] is deposit receiver before all\n    /// @param directions pool directions aggregation, one bit represent one pool direction, 0 means sellBase, 1 means sellQuote\n    /// @param moreInfos pool adapter's Info set, record addtional infos(could be zero-bytes) needed by each pool adapter, keeping order with adapters\n    /// @param feeData route fee info, bytes decode into broker and brokerFee, determine rebate proportion, brokerFee in [0, 1e18]\n    function mixSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] memory mixAdapters,\n        address[] memory mixPairs,\n        address[] memory assetTo,\n        uint256 directions,\n        bytes[] memory moreInfos,\n        bytes memory feeData,\n        uint256 deadLine\n    ) external payable judgeExpired(deadLine) returns (uint256 receiveAmount) {\n        require(mixPairs.length > 0, \"DODORouteProxy: PAIRS_EMPTY\");\n        require(mixPairs.length == mixAdapters.length, \"DODORouteProxy: PAIR_ADAPTER_NOT_MATCH\");\n        require(mixPairs.length == assetTo.length - 1, \"DODORouteProxy: PAIR_ASSETTO_NOT_MATCH\");\n        require(minReturnAmount > 0, \"DODORouteProxy: RETURN_AMOUNT_ZERO\");\n\n        address _toToken = toToken;\n        {\n        uint256 _fromTokenAmount = fromTokenAmount;\n        address _fromToken = fromToken;\n\n        uint256 toTokenOriginBalance;\n        if(_toToken != _ETH_ADDRESS_) {\n            toTokenOriginBalance = IERC20(_toToken).universalBalanceOf(address(this));\n        } else {\n            toTokenOriginBalance = IERC20(_WETH_).universalBalanceOf(address(this));\n        }\n\n        // transfer in fromToken\n        _deposit(\n            msg.sender,\n            assetTo[0],\n            _fromToken,\n            _fromTokenAmount,\n            _fromToken == _ETH_ADDRESS_\n        );\n\n        // swap\n        for (uint256 i = 0; i < mixPairs.length; i++) {\n            if (directions & 1 == 0) {\n                IDODOAdapter(mixAdapters[i]).sellBase(\n                    assetTo[i + 1],\n                    mixPairs[i],\n                    moreInfos[i]\n                );\n            } else {\n                IDODOAdapter(mixAdapters[i]).sellQuote(\n                    assetTo[i + 1],\n                    mixPairs[i],\n                    moreInfos[i]\n                );\n            }\n            directions = directions >> 1;\n        }\n\n        // calculate toToken amount\n        if(_toToken != _ETH_ADDRESS_) {\n            receiveAmount = IERC20(_toToken).universalBalanceOf(address(this)) - (\n                toTokenOriginBalance\n            );\n        } else {\n            receiveAmount = IERC20(_WETH_).universalBalanceOf(address(this)) - (\n                toTokenOriginBalance\n            );\n        }\n        }\n\n        // distribute toToken\n        _routeWithdraw(_toToken, receiveAmount, feeData, minReturnAmount);\n\n        emit OrderHistory(fromToken, toToken, msg.sender, fromTokenAmount, receiveAmount);\n    }\n\n    /// @notice split version, describes one token path with several pools each time. Called one token pair with several pools \"one split\"\n    /// @param splitNumber record pool number in one split, determine sequence(poolInfo) array subscript in transverse. Begin with 0\n    /// for example, [0,1, 3], mean the first split has one(1 - 0) pool, the second split has 2 (3 - 1) pool\n    /// @param midToken middle token set, record token path in order. \n    /// Specially midToken[1] is WETH addresss when fromToken is ETH. Besides midToken[1] is also fromToken \n    /// Specially midToken[length - 2] is WETH address and midToken[length -1 ] is ETH address when toToken is ETH. Besides midToken[length -1]\n    /// is the last toToken and midToken[length - 2] is common second last middle token.\n    /// @param assetFrom asset Address（pool or proxy）describe pool adapter's receiver address. Specially assetFrom[0] is deposit receiver before all\n    /// @param sequence PoolInfo sequence, describe each pool's attributions, ordered by spiltNumber\n    /// @param feeData route fee info, bytes decode into broker and brokerFee, determine rebate proportion, brokerFee in [0, 1e18]\n    function dodoMutliSwap(\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        uint256[] memory splitNumber,  \n        address[] memory midToken,\n        address[] memory assetFrom,\n        bytes[] memory sequence, \n        bytes memory feeData,\n        uint256 deadLine\n    ) external payable judgeExpired(deadLine) returns (uint256 receiveAmount) {\n        address toToken = midToken[midToken.length - 1];\n        {\n        require(\n            assetFrom.length == splitNumber.length,\n            \"DODORouteProxy: PAIR_ASSETTO_NOT_MATCH\"\n        );\n        require(minReturnAmount > 0, \"DODORouteProxy: RETURN_AMOUNT_ZERO\");\n        uint256 _fromTokenAmount = fromTokenAmount;\n        address fromToken = midToken[0];\n\n        uint256 toTokenOriginBalance;\n        if(toToken != _ETH_ADDRESS_) {\n            toTokenOriginBalance = IERC20(toToken).universalBalanceOf(address(this));\n        } else {\n            toTokenOriginBalance = IERC20(_WETH_).universalBalanceOf(address(this));\n        }\n\n        // transfer in fromToken\n        _deposit(\n            msg.sender,\n            assetFrom[0],\n            fromToken,\n            _fromTokenAmount,\n            fromToken == _ETH_ADDRESS_\n        );\n\n        // swap\n        _multiSwap(midToken, splitNumber, sequence, assetFrom);\n\n        // calculate toToken amount\n        if(toToken != _ETH_ADDRESS_) {\n            receiveAmount = IERC20(toToken).universalBalanceOf(address(this)) - (\n                toTokenOriginBalance\n            );\n        } else {\n            receiveAmount = IERC20(_WETH_).universalBalanceOf(address(this)) - (\n                toTokenOriginBalance\n            );\n        }\n        }\n        // distribute toToken\n        _routeWithdraw(toToken, receiveAmount, feeData, minReturnAmount);\n\n        emit OrderHistory(\n            midToken[0], //fromToken\n            midToken[midToken.length - 1], //toToken\n            msg.sender,\n            fromTokenAmount,\n            receiveAmount\n        );\n    }\n\n    //====================== internal =======================\n    /// @notice multiSwap process\n    function _multiSwap(\n        address[] memory midToken,\n        uint256[] memory splitNumber,\n        bytes[] memory swapSequence,\n        address[] memory assetFrom\n    ) internal {\n        for (uint256 i = 1; i < splitNumber.length; i++) {\n            // begin one split(one token pair with one or more pools)\n            // define midtoken address, ETH -> WETH address\n            uint256 curTotalAmount = IERC20(midToken[i]).tokenBalanceOf(assetFrom[i - 1]);\n            uint256 curTotalWeight = totalWeight;\n\n            // split amount into all pools if needed, transverse all pool in this split\n            for (uint256 j = splitNumber[i - 1]; j < splitNumber[i]; j++) {\n                PoolInfo memory curPoolInfo;\n                {\n                    (address pool, address adapter, uint256 mixPara, bytes memory moreInfo) = abi\n                        .decode(swapSequence[j], (address, address, uint256, bytes));\n\n                    curPoolInfo.direction = mixPara >> 17;\n                    curPoolInfo.weight = (0xffff & mixPara) >> 9;\n                    curPoolInfo.poolEdition = (0xff & mixPara);\n                    curPoolInfo.pool = pool;\n                    curPoolInfo.adapter = adapter;\n                    curPoolInfo.moreInfo = moreInfo;\n                }\n\n                // assetFrom[i - 1] is routeProxy when there are more than one pools in this split\n                if (assetFrom[i - 1] == address(this)) {\n                    uint256 curAmount = curTotalAmount * curPoolInfo.weight / curTotalWeight;\n\n                    if (curPoolInfo.poolEdition == 1) {\n                        //For using transferFrom pool (like dodoV1, Curve), pool call transferFrom function to get tokens from adapter\n                        IERC20(midToken[i]).transfer(curPoolInfo.adapter, curAmount);\n                    } else {\n                        //For using transfer pool (like dodoV2), pool determine swapAmount through balanceOf(Token) - reserve\n                        IERC20(midToken[i]).transfer(curPoolInfo.pool, curAmount);\n                    }\n                }\n\n                if (curPoolInfo.direction == 0) {\n                    IDODOAdapter(curPoolInfo.adapter).sellBase(\n                        assetFrom[i],\n                        curPoolInfo.pool,\n                        curPoolInfo.moreInfo\n                    );\n                } else {\n                    IDODOAdapter(curPoolInfo.adapter).sellQuote(\n                        assetFrom[i],\n                        curPoolInfo.pool,\n                        curPoolInfo.moreInfo\n                    );\n                }\n            }\n        }\n    }\n\n    /// @notice before the first pool swap, contract call _deposit to get ERC20 token through DODOApprove/transfer ETH to WETH\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount,\n        bool isETH\n    ) internal {\n        if (isETH) {\n            if (amount > 0) {\n                require(msg.value == amount, \"ETH_VALUE_WRONG\");\n                IWETH(_WETH_).deposit{value: amount}();\n                if (to != address(this)) SafeERC20.safeTransfer(IERC20(_WETH_), to, amount);\n            }\n        } else {\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(token, from, to, amount);\n        }\n    }\n\n    /// @notice after all swaps, transfer tokens to original receiver(user) and distribute fees to DODO and broker\n    /// Specially when toToken is ETH, distribute WETH\n    function _routeWithdraw(\n        address toToken,\n        uint256 receiveAmount,\n        bytes memory feeData,\n        uint256 minReturnAmount\n    ) internal {\n        address originToToken = toToken;\n        if(toToken == _ETH_ADDRESS_) {\n            toToken = _WETH_;\n        }\n        (address broker, uint256 brokerFeeRate) = abi.decode(feeData, (address, uint256));\n        require(brokerFeeRate < 10**18, \"DODORouteProxy: brokerFeeRate overflowed\");\n\n        uint256 routeFee = DecimalMath.mulFloor(receiveAmount, routeFeeRate);\n        IERC20(toToken).universalTransfer(payable(routeFeeReceiver), routeFee);\n\n        uint256 brokerFee = DecimalMath.mulFloor(receiveAmount, brokerFeeRate);\n        IERC20(toToken).universalTransfer(payable(broker), brokerFee);\n        \n        receiveAmount = receiveAmount - routeFee - brokerFee;\n        require(receiveAmount >= minReturnAmount, \"DODORouteProxy: Return amount is not enough\");\n        \n        if (originToToken == _ETH_ADDRESS_) {\n            IWETH(_WETH_).withdraw(receiveAmount);\n            payable(msg.sender).transfer(receiveAmount);\n        } else {\n            IERC20(toToken).universalTransfer(payable(msg.sender), receiveAmount);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/SmartRoute/lib/UniversalERC20.sol",
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.16;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary UniversalERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 private constant ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    // 1. skip 0 amount\n    // 2. handle ETH transfer\n    function universalTransfer(\n        IERC20 token,\n        address payable to,\n        uint256 amount\n    ) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                to.transfer(amount);\n            } else {\n                token.safeTransfer(to, amount);\n            }\n        }\n    }\n\n    function universalApproveMax(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        uint256 allowance = token.allowance(address(this), to);\n        if (allowance < amount) {\n            if (allowance > 0) {\n                token.safeApprove(to, 0);\n            }\n            token.safeApprove(to, type(uint256).max);\n        }\n    }\n\n    function universalBalanceOf(IERC20 token, address who) internal view returns (uint256) {\n        if (isETH(token)) {\n            return who.balance;\n        } else {\n            return token.balanceOf(who);\n        }\n    }\n\n    function tokenBalanceOf(IERC20 token, address who) internal view returns (uint256) {\n        return token.balanceOf(who);\n    }\n\n    function isETH(IERC20 token) internal pure returns (bool) {\n        return token == ETH_ADDRESS;\n    }\n}"
    }
  ]
}