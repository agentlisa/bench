{
  "Title": "[M-16] USDC blacklisted accounts can DoS the withdrawal system",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53-L67\n\n\n# Vulnerability details\n\n## Impact\nDoS of USDC withdrawal system\n\n## Proof of Concept\nCurrently, withdrawals are queued in an array and processed sequentially in a for loop.\nHowever, a `safeTransfer()` to USDC blacklisted user will fail. It will also brick the withdrawal system because the blacklisted user is never cleared.\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53-L67\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\nPossible solutions:\n1st solution:\nImplement 2-step withdrawals:\n    - In a for loop, increase the user's amount that can be safely withdrawn.\n    - A user himself withdraws his balance\n\n2st solution:\nSkip blacklisted users in a processWithdrawals loop\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-hubble-contest",
  "Code": [
    {
      "filename": "contracts/VUSD.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC20PresetMinterPauserUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\n\nimport { VanillaGovernable } from \"./legos/Governable.sol\";\n\ncontract VUSD is VanillaGovernable, ERC20PresetMinterPauserUpgradeable {\n    using SafeERC20 for IERC20;\n\n    struct Withdrawal {\n        address usr;\n        uint amount;\n    }\n\n    /// @notice vUSD is backed 1:1 with reserveToken (USDC)\n    IERC20 public immutable reserveToken;\n\n    Withdrawal[] public withdrawals;\n\n    /// @dev withdrawals will start processing at withdrawals[start]\n    uint public start;\n\n    /// @dev Constrained by block gas limit\n    uint public maxWithdrawalProcesses;\n\n    uint256[50] private __gap;\n\n    constructor(address _reserveToken) {\n        require(_reserveToken != address(0), \"vUSD: null _reserveToken\");\n        reserveToken = IERC20(_reserveToken);\n    }\n\n    function init(address _governance) external {\n        super.initialize(\"Hubble USD\", \"hUSD\"); // has initializer modifier\n        _setGovernace(_governance);\n        maxWithdrawalProcesses = 100;\n    }\n\n    function mintWithReserve(address to, uint amount) external {\n        reserveToken.safeTransferFrom(msg.sender, address(this), amount);\n        _mint(to, amount);\n    }\n\n    function withdraw(uint amount) external {\n        burn(amount);\n        withdrawals.push(Withdrawal(msg.sender, amount));\n    }\n\n    function processWithdrawals() external {\n        uint reserve = reserveToken.balanceOf(address(this));\n        require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');\n        uint i = start;\n        while (i < withdrawals.length && (i - start) <= maxWithdrawalProcesses) {\n            Withdrawal memory withdrawal = withdrawals[i];\n            if (reserve < withdrawal.amount) {\n                break;\n            }\n            reserveToken.safeTransfer(withdrawal.usr, withdrawal.amount);\n            reserve -= withdrawal.amount;\n            i += 1;\n        }\n        start = i;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n    function setMaxWithdrawalProcesses(uint _maxWithdrawalProcesses) external onlyGovernance {\n        maxWithdrawalProcesses = _maxWithdrawalProcesses;\n    }\n}"
    }
  ]
}