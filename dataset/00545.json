{
  "Title": "M-5: Users unable to withdraw their funds due to FRAX admin action",
  "Content": "# Issue M-5: Users unable to withdraw their funds due to FRAX admin action \n\nSource: https://github.com/sherlock-audit/2024-01-napier-judging/issues/95 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nxiaoming90\n## Summary\n\nFRAX admin action can lead to the fund of Naiper protocol and its users being stuck, resulting in users being unable to withdraw their assets.\n\n## Vulnerability Detail\n\nPer the contest page, the admins of the protocols that Napier integrates with are considered \"RESTRICTED\". This means that any issue related to FRAX's admin action that could negatively affect Napier protocol/users will be considered valid in this audit contest.\n\n> Q: Are the admins of the protocols your contracts integrate with (if any) TRUSTED or RESTRICTED?\n> RESTRICTED\n\nWhen the Adaptor needs to unstake its staked ETH to replenish its ETH buffer so that users can redeem/withdraw their funds, it will first join the FRAX's redemption queue, and the queue will issue a redemption NFT afterward. After a certain period, the adaptor can claim their ETH by burning the redemption NFT at Line 65 via the `burnRedemptionTicketNft` function.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/frax/SFrxETHAdapter.sol#L65\n\n```solidity\nFile: SFrxETHAdapter.sol\n53:     function claimWithdrawal() external override {\n54:         uint256 _requestId = requestId;\n55:         uint256 _withdrawalQueueEth = withdrawalQueueEth;\n56:         if (_requestId == 0) revert NoPendingWithdrawal();\n57: \n58:         /// WRITE ///\n59:         delete withdrawalQueueEth;\n60:         delete requestId;\n61:         bufferEth += _withdrawalQueueEth.toUint128();\n62: \n63:         /// INTERACT ///\n64:         uint256 balanceBefore = address(this).balance;\n65:         REDEMPTION_QUEUE.burnRedemptionTicketNft(_requestId, payable(this));\n66:         if (address(this).balance < balanceBefore + _withdrawalQueueEth) revert InvariantViolation();\n67: \n68:         IWETH9(Constants.WETH).deposit{value: _withdrawalQueueEth}();\n69:     }\n```\n\nHowever, it is possible for FRAX's admin to disrupt the redemption process of the adaptor, resulting in Napier users being unable to withdraw their funds. When the `burnRedemptionTicketNft` function is executed, the redemption NFT will be burned, and native ETH residing in the `FraxEtherRedemptionQueue` contract will be sent to the adaptor at Line 498 below\n\nhttps://etherscan.io/address/0x82bA8da44Cd5261762e629dd5c605b17715727bd#code#L3761\n\n```solidity\nFile: FraxEtherRedemptionQueue.sol\n473:     function burnRedemptionTicketNft(uint256 _nftId, address payable _recipient) external nonReentrant {\n..SNIP..\n494:         // Effects: Burn frxEth to match the amount of ether sent to user 1:1\n495:         FRX_ETH.burn(_redemptionQueueItem.amount);\n496: \n497:         // Interactions: Transfer ETH to recipient, minus the fee\n498:         (bool _success, ) = _recipient.call{ value: _redemptionQueueItem.amount }(\"\");\n499:         if (!_success) revert InvalidEthTransfer();\n```\n\nFRAX admin could execute the `recoverEther` function to transfer out all the Native ETH residing in the `FraxEtherRedemptionQueue` contract, resulting in the NFT redemption failing due to lack of ETH. \n\nhttps://etherscan.io/address/0x82bA8da44Cd5261762e629dd5c605b17715727bd#code#L3381\n\n```solidity\nFile: FraxEtherRedemptionQueue.sol\n185:     /// @notice Recover ETH from exits where people early exited their NFT for frxETH, or when someone mistakenly directly sends ETH here\n186:     /// @param _amount Amount of ETH to recover\n187:     function recoverEther(uint256 _amount) external {\n188:         _requireSenderIsTimelock();\n189: \n190:         (bool _success, ) = address(msg.sender).call{ value: _amount }(\"\");\n191:         if (!_success) revert InvalidEthTransfer();\n192: \n193:         emit RecoverEther({ recipient: msg.sender, amount: _amount });\n194:     }\n```\n\nAs a result, Napier users will not be able to withdraw their funds.\n\n## Impact\n\nThe fund of Naiper protocol and its users will be stuck, resulting in users being unable to withdraw their assets.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/frax/SFrxETHAdapter.sol#L65\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure that the protocol team and its users are aware of the risks of such an event and develop a contingency plan to manage it.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: per contest ReadMe; this should be valid; medium(11)\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/171",
  "Code": [
    {
      "filename": "napier-v1/src/adapters/frax/SFrxETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\nimport {IWETH9} from \"../../interfaces/IWETH9.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts@4.9.3/interfaces/IERC4626.sol\";\nimport {IFrxETHMinter} from \"./interfaces/IFrxETHMinter.sol\";\nimport {IFraxEtherRedemptionQueue} from \"./interfaces/IFraxEtherRedemptionQueue.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts@4.9.3/token/ERC721/IERC721Receiver.sol\";\n\nimport {ERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/ERC20.sol\";\nimport {BaseLSTAdapter} from \"../BaseLSTAdapter.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport \"../../Constants.sol\" as Constants;\n\n/// @title SFrxETHAdapter - esfrxETH\n/// @dev Important security note:\n/// 1. The vault share price (esfrxETH / WETH) increases as sfrxETH accrues staking rewards.\n/// However, the share price decreases when frxETH (sfrxETH) is withdrawn.\n/// Withdrawals are processed by the FraxEther redemption queue contract.\n/// Frax takes a fee at the time of withdrawal requests, which temporarily reduces the share price.\n/// This loss is pro-rated among all esfrxETH holders.\n/// As a mitigation measure, we allow only authorized rebalancers to request withdrawals.\n///\n/// 2. This contract doesn't independently keep track of the sfrxETH balance, so it is possible\n/// for an attacker to directly transfer sfrxETH to this contract, increase the share price.\ncontract SFrxETHAdapter is BaseLSTAdapter, IERC721Receiver {\n    using SafeCast for uint256;\n\n    error InvariantViolation();\n\n    /// @notice frxETH\n    IERC20 constant FRXETH = IERC20(Constants.FRXETH);\n\n    /// @notice sfrxETH\n    IERC4626 constant STAKED_FRXETH = IERC4626(Constants.STAKED_FRXETH);\n\n    /// @dev FraxEther redemption queue contract https://etherscan.io/address/0x82bA8da44Cd5261762e629dd5c605b17715727bd\n    IFraxEtherRedemptionQueue constant REDEMPTION_QUEUE =\n        IFraxEtherRedemptionQueue(0x82bA8da44Cd5261762e629dd5c605b17715727bd);\n\n    /// @dev FraxEther minter contract\n    IFrxETHMinter constant FRXETH_MINTER = IFrxETHMinter(0xbAFA44EFE7901E04E39Dad13167D089C559c1138);\n\n    receive() external payable {}\n\n    constructor(address _rebalancer) BaseLSTAdapter(_rebalancer) ERC20(\"Napier FrxETH Adapter\", \"eFrxETH\") {\n        FRXETH.approve(address(STAKED_FRXETH), type(uint256).max);\n        FRXETH.approve(address(REDEMPTION_QUEUE), type(uint256).max);\n    }\n\n    function claimWithdrawal() external override {\n        uint256 _requestId = requestId;\n        uint256 _withdrawalQueueEth = withdrawalQueueEth;\n        if (_requestId == 0) revert NoPendingWithdrawal();\n\n        /// WRITE ///\n        delete withdrawalQueueEth;\n        delete requestId;\n        bufferEth += _withdrawalQueueEth.toUint128();\n\n        /// INTERACT ///\n        uint256 balanceBefore = address(this).balance;\n        REDEMPTION_QUEUE.burnRedemptionTicketNft(_requestId, payable(this));\n        if (address(this).balance < balanceBefore + _withdrawalQueueEth) revert InvariantViolation();\n\n        IWETH9(Constants.WETH).deposit{value: _withdrawalQueueEth}();\n    }\n\n    /// @notice Mint sfrxETH using WETH\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        FRXETH_MINTER.submit{value: stakeAmount}();\n        uint256 received = STAKED_FRXETH.deposit(stakeAmount, address(this));\n        if (received == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    function requestWithdrawalAll() external override nonReentrant onlyRebalancer {\n        if (requestId != 0) revert WithdrawalPending();\n        uint256 _requestId = REDEMPTION_QUEUE.redemptionQueueState().nextNftId;\n        /// INTERACT ///\n        // Redeem all sfrxETH for frxETH\n        uint256 balance = STAKED_FRXETH.balanceOf(address(this));\n        uint256 withdrawAmount = STAKED_FRXETH.redeem(balance, address(this), address(this));\n\n        REDEMPTION_QUEUE.enterRedemptionQueue({amountToRedeem: withdrawAmount.toUint120(), recipient: address(this)});\n\n        /// WRITE ///\n        withdrawalQueueEth = REDEMPTION_QUEUE.nftInformation(_requestId).amount; // cast uint120 to uint128\n        requestId = _requestId;\n    }\n\n    /// @notice Request about `withdrawAmount` of ETH to be unstaked from sfrxETH.\n    /// @param withdrawAmount Amount of ETH to withdraw\n    function _requestWithdrawal(uint256 withdrawAmount) internal override returns (uint256, uint256) {\n        uint256 _requestId = REDEMPTION_QUEUE.redemptionQueueState().nextNftId; // Dev: Ensure id is not 0\n        /// INTERACT ///\n        uint256 frxEthBalanceBefore = FRXETH.balanceOf(address(this)); // 0 is expected if no one has donated frxETH to this contract\n        STAKED_FRXETH.withdraw(withdrawAmount, address(this), address(this));\n        uint256 frxEthWithdrawn = FRXETH.balanceOf(address(this)) - frxEthBalanceBefore;\n        // Transfer frxETH and mint redemption ticket.\n        // note: `amountToRedeem` is an amount in frxETH, not ETH.\n        // However, frxETH would be soft-pegged to ETH, so we treat them as 1:1 for simplicity here.\n        // Also, actual ETH amount to withdraw would be slightly less than `withdrawAmount` due to the redemption fee.\n        REDEMPTION_QUEUE.enterRedemptionQueue({amountToRedeem: frxEthWithdrawn.toUint120(), recipient: address(this)});\n        /// WRITE ///\n        // Note: The redemption queue contract returns the exact amount of ETH to withdraw.\n        uint256 queueEth = REDEMPTION_QUEUE.nftInformation(_requestId).amount; // cast uint120 to uint128\n        return (queueEth, _requestId);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        uint256 balance = STAKED_FRXETH.balanceOf(address(this));\n        uint256 balanceInFrxEth = STAKED_FRXETH.convertToAssets(balance);\n        return withdrawalQueueEth + bufferEth + balanceInFrxEth; // 1 frxEth = 1 ETH\n    }\n\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return 0x150b7a02; // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n    }\n}"
    },
    {
      "filename": "napier-v1/src/adapters/frax/SFrxETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\nimport {IWETH9} from \"../../interfaces/IWETH9.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts@4.9.3/interfaces/IERC4626.sol\";\nimport {IFrxETHMinter} from \"./interfaces/IFrxETHMinter.sol\";\nimport {IFraxEtherRedemptionQueue} from \"./interfaces/IFraxEtherRedemptionQueue.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts@4.9.3/token/ERC721/IERC721Receiver.sol\";\n\nimport {ERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/ERC20.sol\";\nimport {BaseLSTAdapter} from \"../BaseLSTAdapter.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport \"../../Constants.sol\" as Constants;\n\n/// @title SFrxETHAdapter - esfrxETH\n/// @dev Important security note:\n/// 1. The vault share price (esfrxETH / WETH) increases as sfrxETH accrues staking rewards.\n/// However, the share price decreases when frxETH (sfrxETH) is withdrawn.\n/// Withdrawals are processed by the FraxEther redemption queue contract.\n/// Frax takes a fee at the time of withdrawal requests, which temporarily reduces the share price.\n/// This loss is pro-rated among all esfrxETH holders.\n/// As a mitigation measure, we allow only authorized rebalancers to request withdrawals.\n///\n/// 2. This contract doesn't independently keep track of the sfrxETH balance, so it is possible\n/// for an attacker to directly transfer sfrxETH to this contract, increase the share price.\ncontract SFrxETHAdapter is BaseLSTAdapter, IERC721Receiver {\n    using SafeCast for uint256;\n\n    error InvariantViolation();\n\n    /// @notice frxETH\n    IERC20 constant FRXETH = IERC20(Constants.FRXETH);\n\n    /// @notice sfrxETH\n    IERC4626 constant STAKED_FRXETH = IERC4626(Constants.STAKED_FRXETH);\n\n    /// @dev FraxEther redemption queue contract https://etherscan.io/address/0x82bA8da44Cd5261762e629dd5c605b17715727bd\n    IFraxEtherRedemptionQueue constant REDEMPTION_QUEUE =\n        IFraxEtherRedemptionQueue(0x82bA8da44Cd5261762e629dd5c605b17715727bd);\n\n    /// @dev FraxEther minter contract\n    IFrxETHMinter constant FRXETH_MINTER = IFrxETHMinter(0xbAFA44EFE7901E04E39Dad13167D089C559c1138);\n\n    receive() external payable {}\n\n    constructor(address _rebalancer) BaseLSTAdapter(_rebalancer) ERC20(\"Napier FrxETH Adapter\", \"eFrxETH\") {\n        FRXETH.approve(address(STAKED_FRXETH), type(uint256).max);\n        FRXETH.approve(address(REDEMPTION_QUEUE), type(uint256).max);\n    }\n\n    function claimWithdrawal() external override {\n        uint256 _requestId = requestId;\n        uint256 _withdrawalQueueEth = withdrawalQueueEth;\n        if (_requestId == 0) revert NoPendingWithdrawal();\n\n        /// WRITE ///\n        delete withdrawalQueueEth;\n        delete requestId;\n        bufferEth += _withdrawalQueueEth.toUint128();\n\n        /// INTERACT ///\n        uint256 balanceBefore = address(this).balance;\n        REDEMPTION_QUEUE.burnRedemptionTicketNft(_requestId, payable(this));\n        if (address(this).balance < balanceBefore + _withdrawalQueueEth) revert InvariantViolation();\n\n        IWETH9(Constants.WETH).deposit{value: _withdrawalQueueEth}();\n    }\n\n    /// @notice Mint sfrxETH using WETH\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        FRXETH_MINTER.submit{value: stakeAmount}();\n        uint256 received = STAKED_FRXETH.deposit(stakeAmount, address(this));\n        if (received == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    function requestWithdrawalAll() external override nonReentrant onlyRebalancer {\n        if (requestId != 0) revert WithdrawalPending();\n        uint256 _requestId = REDEMPTION_QUEUE.redemptionQueueState().nextNftId;\n        /// INTERACT ///\n        // Redeem all sfrxETH for frxETH\n        uint256 balance = STAKED_FRXETH.balanceOf(address(this));\n        uint256 withdrawAmount = STAKED_FRXETH.redeem(balance, address(this), address(this));\n\n        REDEMPTION_QUEUE.enterRedemptionQueue({amountToRedeem: withdrawAmount.toUint120(), recipient: address(this)});\n\n        /// WRITE ///\n        withdrawalQueueEth = REDEMPTION_QUEUE.nftInformation(_requestId).amount; // cast uint120 to uint128\n        requestId = _requestId;\n    }\n\n    /// @notice Request about `withdrawAmount` of ETH to be unstaked from sfrxETH.\n    /// @param withdrawAmount Amount of ETH to withdraw\n    function _requestWithdrawal(uint256 withdrawAmount) internal override returns (uint256, uint256) {\n        uint256 _requestId = REDEMPTION_QUEUE.redemptionQueueState().nextNftId; // Dev: Ensure id is not 0\n        /// INTERACT ///\n        uint256 frxEthBalanceBefore = FRXETH.balanceOf(address(this)); // 0 is expected if no one has donated frxETH to this contract\n        STAKED_FRXETH.withdraw(withdrawAmount, address(this), address(this));\n        uint256 frxEthWithdrawn = FRXETH.balanceOf(address(this)) - frxEthBalanceBefore;\n        // Transfer frxETH and mint redemption ticket.\n        // note: `amountToRedeem` is an amount in frxETH, not ETH.\n        // However, frxETH would be soft-pegged to ETH, so we treat them as 1:1 for simplicity here.\n        // Also, actual ETH amount to withdraw would be slightly less than `withdrawAmount` due to the redemption fee.\n        REDEMPTION_QUEUE.enterRedemptionQueue({amountToRedeem: frxEthWithdrawn.toUint120(), recipient: address(this)});\n        /// WRITE ///\n        // Note: The redemption queue contract returns the exact amount of ETH to withdraw.\n        uint256 queueEth = REDEMPTION_QUEUE.nftInformation(_requestId).amount; // cast uint120 to uint128\n        return (queueEth, _requestId);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        uint256 balance = STAKED_FRXETH.balanceOf(address(this));\n        uint256 balanceInFrxEth = STAKED_FRXETH.convertToAssets(balance);\n        return withdrawalQueueEth + bufferEth + balanceInFrxEth; // 1 frxEth = 1 ETH\n    }\n\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return 0x150b7a02; // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n    }\n}"
    }
  ]
}