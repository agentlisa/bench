{
  "Title": "[G-10] Do not assign `offset` in the last call of `UnsafeBytes.readAddress` in `L1WethBridge.sol`",
  "Content": "\nA simple test in Remix IDE has been created, to compare gas usage of assigning more than one value from function call:\n\n```\n  function getUints() public pure returns (uint, uint) {return (1, 2);}\n   function getAll() public view {\n    uint a; uint b; \n    (a, b) = getUints();\n    uint g = gasleft();\n    (a, b) = getUints();\n    console.log(g - gasleft());\n   }\n    function getOne() public view {\n    uint a; uint b; \n    (a, b) = getUints();\n    uint g = gasleft();\n    (a, ) = getUints();\n    console.log(g - gasleft());\n   }\n```\n\n`getOne()` costs 74 gas, while `getAll()` costs 82 gas. This implies, that we shouldn't assign every parameter from function call if it's not needed. In the last call of `UnsafeBytes.readAddress(_message, offset)` (line 298):\n\n[File: ethereum/contracts/bridge/L1WethBridge.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/L1WethBridge.sol#L298)\n\n```\n(l1WethReceiver, offset) = UnsafeBytes.readAddress(_message, offset);\n```\n\nWe won't need `offset` anymore, thus we can change line 298 to: `(l1WethReceiver, ) = UnsafeBytes.readAddress(_message, offset)`.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/bridge/L1WethBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IL1Bridge.sol\";\nimport \"./interfaces/IL2WethBridge.sol\";\nimport \"./interfaces/IL2Bridge.sol\";\nimport \"./interfaces/IWETH9.sol\";\nimport \"../zksync/interfaces/IZkSync.sol\";\nimport \"../common/interfaces/IAllowList.sol\";\n\nimport \"./libraries/BridgeInitializationHelper.sol\";\n\nimport \"../common/AllowListed.sol\";\nimport \"../common/libraries/UnsafeBytes.sol\";\nimport \"../common/ReentrancyGuard.sol\";\nimport \"../common/libraries/L2ContractHelper.sol\";\nimport {L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR} from \"../common/L2ContractAddresses.sol\";\nimport \"../vendor/AddressAliasHelper.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev This contract is designed to streamline and enhance the user experience\n/// for bridging WETH tokens between L1 and L2 networks. The primary goal of this bridge is to\n/// simplify the process by minimizing the number of transactions required, thus improving\n/// efficiency and user experience.\n/// @dev The default workflow for bridging WETH is performing three separate transactions: unwrap WETH to ETH,\n/// deposit ETH to L2, and wrap ETH to WETH on L2. The `L1WethBridge` reduces this to a single\n/// transaction, enabling users to bridge their WETH tokens directly between L1 and L2 networks.\n/// @dev This contract accepts WETH deposits on L1, unwraps them to ETH, and sends the ETH to the L2\n/// WETH bridge contract, where it is wrapped back into WETH and delivered to the L2 recipient.\n/// @dev For withdrawals, the contract receives ETH from the L2 WETH bridge contract, wraps it into\n/// WETH, and sends the WETH to the L1 recipient.\n/// @dev The `L1WethBridge` contract works in conjunction with its L2 counterpart, `L2WethBridge`.\ncontract L1WethBridge is IL1Bridge, AllowListed, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @dev Event emitted when ETH is received by the contract.\n    event EthReceived(uint256 amount);\n\n    /// @dev The address of the WETH token on L1\n    address payable public immutable l1WethAddress;\n\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList public immutable allowList;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IZkSync public immutable zkSync;\n\n    /// @dev The address of deployed L2 WETH bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address of the WETH on L2\n    address public l2WethAddress;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 WETH message was already processed\n    mapping(uint256 => mapping(uint256 => bool)) public isWithdrawalFinalized;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(address payable _l1WethAddress, IZkSync _zkSync, IAllowList _allowList) reentrancyGuardInitializer {\n        l1WethAddress = _l1WethAddress;\n        zkSync = _zkSync;\n        allowList = _allowList;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 WETH bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 WETH bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 WETH bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 WETH bridge\n    /// @param _l2WethAddress Pre-calculated address of L2 WETH token\n    /// @param _governor Address which can change L2 WETH token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee The fee that will be paid for the L1 -> L2 transaction for deploying L2\n    /// bridge implementation\n    /// @param _deployBridgeProxyFee The fee that will be paid for the L1 -> L2 transaction for deploying L2 bridge\n    /// proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        address _l2WethAddress,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2WethAddress != address(0), \"L2 WETH address cannot be zero\");\n        require(_governor != address(0), \"Governor address cannot be zero\");\n        require(_factoryDeps.length == 2, \"Invalid factory deps length provided\");\n        require(\n            msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee,\n            \"Miscalculated deploy transactions fees\"\n        );\n\n        l2WethAddress = _l2WethAddress;\n\n        bytes32 l2WethBridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[0]);\n        bytes32 l2WethBridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[1]);\n\n        // Deploy L2 bridge implementation contract\n        address wethBridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2WethBridgeImplementationBytecodeHash,\n            \"\", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2WethBridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2WethBridge.initialize,\n                (address(this), l1WethAddress, _l2WethAddress)\n            );\n            l2WethBridgeProxyConstructorData = abi.encode(\n                wethBridgeImplementationAddr,\n                _governor,\n                proxyInitializationParams\n            );\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2WethBridgeProxyBytecodeHash,\n            l2WethBridgeProxyConstructorData,\n            // No factory deps are needed for L2 bridge proxy, because it is already passed in the previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Initiates a WETH deposit by depositing WETH into the L1 bridge contract, unwrapping it to ETH\n    /// and sending it to the L2 bridge contract where ETH will be wrapped again to WETH and sent to the L2 recipient.\n    /// @param _l2Receiver The account address that should receive WETH on L2\n    /// @param _l1Token The L1 token address which is deposited (needs to be WETH address)\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox,\n    /// since the Mailbox applies address aliasing to the from address for the L2 tx if the L1 msg.sender is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx\n    /// requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return txHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable nonReentrant senderCanCallFunction(allowList) returns (bytes32 txHash) {\n        require(_l1Token == l1WethAddress, \"Invalid L1 token address\");\n        require(_amount != 0, \"Amount cannot be zero\");\n\n        // Deposit WETH tokens from the depositor address to the smart contract address\n        IERC20(l1WethAddress).safeTransferFrom(msg.sender, address(this), _amount);\n        // Unwrap WETH tokens (smart contract address receives the equivalent amount of ETH)\n        IWETH9(l1WethAddress).withdraw(_amount);\n\n        // Request the finalization of the deposit on the L2 side\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, l1WethAddress, _amount);\n\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        txHash = zkSync.requestL2Transaction{value: _amount + msg.value}(\n            l2Bridge,\n            _amount,\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        emit DepositInitiated(txHash, msg.sender, _l2Receiver, _l1Token, _amount);\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 WETH bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) internal pure returns (bytes memory txCalldata) {\n        txCalldata = abi.encodeCall(\n            IL2Bridge.finalizeDeposit,\n            (_l1Sender, _l2Receiver, _l1Token, _amount, new bytes(0))\n        );\n    }\n\n    /// @notice Withdraw funds from the initiated deposit, that failed when finalizing on L2.\n    /// Note: Refund is performed by sending an equivalent amount of ETH on L2 to the specified deposit refund\n    /// recipient address.\n    function claimFailedDeposit(\n        address, // _depositSender,\n        address, // _l1Token,\n        bytes32, // _l2TxHash\n        uint256, // _l2BatchNumber,\n        uint256, // _l2MessageIndex,\n        uint16, // _l2TxNumberInBatch,\n        bytes32[] calldata // _merkleProof\n    ) external pure {\n        revert(\"Method not supported. Failed deposit funds are sent to the L2 refund recipient address.\");\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the ETH (WETH) withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the ETH\n    /// withdrawal message containing additional data about WETH withdrawal\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the ETH withdrawal log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant senderCanCallFunction(allowList) {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], \"Withdrawal is already finalized\");\n\n        (address l1WethWithdrawReceiver, uint256 amount) = _parseL2EthWithdrawalMessage(_message);\n\n        // Check if the withdrawal has already been finalized on L2.\n        bool alreadyFinalised = zkSync.isEthWithdrawalFinalized(_l2BatchNumber, _l2MessageIndex);\n        if (alreadyFinalised) {\n            // Check that the specified message was actually sent while withdrawing eth from L2.\n            L2Message memory l2ToL1Message = L2Message({\n                txNumberInBatch: _l2TxNumberInBatch,\n                sender: L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR,\n                data: _message\n            });\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, \"vq\");\n        } else {\n            // Finalize the withdrawal if it is not yet done.\n            zkSync.finalizeEthWithdrawal(_l2BatchNumber, _l2MessageIndex, _l2TxNumberInBatch, _message, _merkleProof);\n        }\n\n        // Wrap ETH to WETH tokens (smart contract address receives the equivalent amount of WETH)\n        IWETH9(l1WethAddress).deposit{value: amount}();\n        // Transfer WETH tokens from the smart contract address to the withdrawal receiver\n        IERC20(l1WethAddress).safeTransfer(l1WethWithdrawReceiver, amount);\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n\n        emit WithdrawalFinalized(l1WethWithdrawReceiver, l1WethAddress, amount);\n    }\n\n    /// @dev Decode the ETH withdraw message with additional data about WETH withdrawal that came from L2EthToken\n    /// contract\n    function _parseL2EthWithdrawalMessage(\n        bytes memory _message\n    ) internal view returns (address l1WethReceiver, uint256 ethAmount) {\n        // Check that the message length is correct.\n        // additionalData (WETH withdrawal data): l2 sender address + weth receiver address = 20 + 20 = 40 (bytes)\n        // It should be equal to the length of the function signature + eth receiver address + uint256 amount +\n        // additionalData = 4 + 20 + 32 + 40 = 96 (bytes).\n        require(_message.length == 96, \"Incorrect ETH message with additional data length\");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_message, 0);\n        require(\n            bytes4(functionSignature) == IMailbox.finalizeEthWithdrawal.selector,\n            \"Incorrect ETH message function selector\"\n        );\n\n        address l1EthReceiver;\n        (l1EthReceiver, offset) = UnsafeBytes.readAddress(_message, offset);\n        require(l1EthReceiver == address(this), \"Wrong L1 ETH withdraw receiver\");\n\n        (ethAmount, offset) = UnsafeBytes.readUint256(_message, offset);\n\n        address l2Sender;\n        (l2Sender, offset) = UnsafeBytes.readAddress(_message, offset);\n        require(l2Sender == l2Bridge, \"The withdrawal was not initiated by L2 bridge\");\n\n        // Parse additional data\n        (l1WethReceiver, offset) = UnsafeBytes.readAddress(_message, offset);\n    }\n\n    /// @return l2Token Address of an L2 token counterpart.\n    function l2TokenAddress(address _l1Token) public view override returns (address l2Token) {\n        l2Token = _l1Token == l1WethAddress ? l2WethAddress : address(0);\n    }\n\n    /// @dev The receive function is called when ETH is sent directly to the contract.\n    receive() external payable {\n        // Expected to receive ether in two cases:\n        // 1. l1 WETH sends ether on `withdraw`\n        // 2. zkSync contract withdraw funds in `finalizeEthWithdrawal`\n        require(msg.sender == l1WethAddress || msg.sender == address(zkSync), \"pn\");\n        emit EthReceived(msg.value);\n    }\n}"
    }
  ]
}