{
  "Title": "[L13] Missing validations [core]",
  "Content": "* The [`compensate`](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/EntryPoint.sol#L80) function in `EntryPoint` takes a `beneficiary` address as input and sends the amount specified to that address. This happens as the final step of a `handleOps` or `handleOp` function call. The code does not check that `beneficiary` is not 0, which could lead to accidental loss of funds. Consider adding a check to verify that `beneficiary` is a non-zero value.\n* In the [`EntryPoint` constructor](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/EntryPoint.sol#L42-L45), there are no checks to ensure the immutable contract variables are set to non-zero values. If `_create2factory`, `_paymasterStake`, or `_unstakeDelaySec` were accidentally set to 0, the contract would need to be redeployed because there is no mechanism to update these values. Consider adding a non-zero check for each of the constructor parameters.\n\n\n***Update**: Fixed in pull requests [#59](https://github.com/eth-infinitism/account-abstraction/pull/59/files) and [#63](https://github.com/eth-infinitism/account-abstraction/pull/63/files). Checks that reject zero values have been added for `beneficiary`, `_create2factory`, `_paymasterStake`, and `unstakeDelaySec`.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/EntryPoint.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.7;\n\nimport \"./StakeManager.sol\";\nimport \"./UserOperation.sol\";\nimport \"./IWallet.sol\";\nimport \"./IPaymaster.sol\";\n\ninterface ICreate2Deployer {\n    function deploy(bytes memory _initCode, bytes32 _salt) external returns (address);\n}\n\ncontract EntryPoint is StakeManager {\n\n    using UserOperationLib for UserOperation;\n\n    enum PaymentMode {\n        paymasterStake, // if paymaster is set, use paymaster's stake to pay.\n        walletStake // pay with wallet deposit.\n    }\n\n    uint public immutable paymasterStake;\n    address public immutable create2factory;\n\n    event UserOperationEvent(bytes32 indexed requestId, address indexed sender, address indexed paymaster, uint nonce, uint actualGasCost, uint actualGasPrice, bool success);\n    event UserOperationRevertReason(bytes32 indexed requestId, address indexed sender, uint nonce, bytes revertReason);\n\n    //handleOps reverts with this error struct, to mark the offending op\n    // NOTE: if simulateOp passes successfully, there should be no reason for handleOps to fail on it.\n    // @param opIndex - index into the array of ops to the failed one (in simulateOp, this is always zero)\n    // @param paymaster - if paymaster.validatePaymasterUserOp fails, this will be the paymaster's address. if validateUserOp failed,\n    //      this value will be zero (since it failed before accessing the paymaster)\n    // @param reason - revert reason\n    //  only to aid troubleshooting of wallet/paymaster reverts\n    error FailedOp(uint opIndex, address paymaster, string reason);\n\n    /**\n     * @param _create2factory - contract to \"create2\" wallets (not the EntryPoint itself, so that it can be upgraded)\n     * @param _paymasterStake - locked stake of paymaster (actual value should also cover TX cost)\n     * @param _unstakeDelaySec - minimum time (in seconds) a paymaster stake must be locked\n     */\n    constructor(address _create2factory, uint _paymasterStake, uint32 _unstakeDelaySec) StakeManager(_unstakeDelaySec) {\n        create2factory = _create2factory;\n        paymasterStake = _paymasterStake;\n    }\n\n    /**\n     * Execute the given UserOperation.\n     * @param op the operation to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOp(UserOperation calldata op, address payable beneficiary) public {\n\n        uint preGas = gasleft();\n\n    unchecked {\n        bytes32 requestId = getRequestId(op);\n        (uint256 prefund, PaymentMode paymentMode, bytes memory context) = _validatePrepayment(0, op, requestId);\n        UserOpInfo memory opInfo = UserOpInfo(\n            requestId,\n            prefund,\n            paymentMode,\n            0,\n            preGas - gasleft() + op.preVerificationGas\n        );\n\n        uint actualGasCost;\n\n        try this.internalHandleOp(op, opInfo, context) returns (uint _actualGasCost) {\n            actualGasCost = _actualGasCost;\n        } catch {\n            uint actualGas = preGas - gasleft() + opInfo.preOpGas;\n            actualGasCost = handlePostOp(0, IPaymaster.PostOpMode.postOpReverted, op, opInfo, context, actualGas);\n        }\n\n        compensate(beneficiary, actualGasCost);\n    } // unchecked\n    }\n\n    function compensate(address payable beneficiary, uint amount) internal {\n        (bool success,) = beneficiary.call{value : amount}(\"\");\n        require(success);\n    }\n\n    /**\n     * Execute a batch of UserOperation.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) public {\n\n        uint opslen = ops.length;\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\n    unchecked {\n        for (uint i = 0; i < opslen; i++) {\n            uint preGas = gasleft();\n            UserOperation calldata op = ops[i];\n\n            bytes memory context;\n            uint contextOffset;\n            bytes32 requestId = getRequestId(op);\n            uint prefund;\n            PaymentMode paymentMode;\n            (prefund, paymentMode, context) = _validatePrepayment(i, op, requestId);\n            assembly {contextOffset := context}\n            opInfos[i] = UserOpInfo(\n                requestId,\n                prefund,\n                paymentMode,\n                contextOffset,\n                preGas - gasleft() + op.preVerificationGas\n            );\n        }\n\n        uint collected = 0;\n\n        for (uint i = 0; i < ops.length; i++) {\n            uint preGas = gasleft();\n            UserOperation calldata op = ops[i];\n            UserOpInfo memory opInfo = opInfos[i];\n            uint contextOffset = opInfo._context;\n            bytes memory context;\n            assembly {context := contextOffset}\n\n            try this.internalHandleOp(op, opInfo, context) returns (uint _actualGasCost) {\n                collected += _actualGasCost;\n            } catch {\n                uint actualGas = preGas - gasleft() + opInfo.preOpGas;\n                collected += handlePostOp(i, IPaymaster.PostOpMode.postOpReverted, op, opInfo, context, actualGas);\n            }\n        }\n\n        compensate(beneficiary, collected);\n    } //unchecked\n    }\n\n    struct UserOpInfo {\n        bytes32 requestId;\n        uint prefund;\n        PaymentMode paymentMode;\n        uint _context;\n        uint preOpGas;\n    }\n\n    function internalHandleOp(UserOperation calldata op, UserOpInfo calldata opInfo, bytes calldata context) external returns (uint actualGasCost) {\n        uint preGas = gasleft();\n        require(msg.sender == address(this));\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (op.callData.length > 0) {\n\n            (bool success,bytes memory result) = address(op.getSender()).call{gas : op.callGas}(op.callData);\n            if (!success) {\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(opInfo.requestId, op.getSender(), op.nonce, result);\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n    unchecked {\n        uint actualGas = preGas - gasleft() + opInfo.preOpGas;\n        return handlePostOp(0, mode, op, opInfo, context, actualGas);\n    }\n    }\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature).\n     */\n    function getRequestId(UserOperation calldata userOp) public view returns (bytes32) {\n        return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n    }\n\n    /**\n    * Simulate a call to wallet.validateUserOp and paymaster.validatePaymasterUserOp.\n    * Validation succeeds of the call doesn't revert.\n    * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the wallet's data.\n     *      In order to split the running opcodes of the wallet (validateUserOp) from the paymaster's validatePaymasterUserOp,\n     *      it should look for the NUMBER opcode at depth=1 (which itself is a banned opcode)\n     * @return preOpGas total gas used by validation (including contract creation)\n     * @return prefund the amount the wallet had to prefund (zero in case a paymaster pays)\n     */\n    function simulateValidation(UserOperation calldata userOp) external returns (uint preOpGas, uint prefund) {\n        uint preGas = gasleft();\n\n        bytes32 requestId = getRequestId(userOp);\n        (prefund,,) = _validatePrepayment(0, userOp, requestId);\n        preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n\n        require(msg.sender == address(0), \"must be called off-chain with from=zero-addr\");\n    }\n\n    function _getPaymentInfo(UserOperation calldata userOp) internal view returns (uint requiredPrefund, PaymentMode paymentMode) {\n        requiredPrefund = userOp.requiredPreFund();\n        if (userOp.hasPaymaster()) {\n            paymentMode = PaymentMode.paymasterStake;\n        } else {\n            paymentMode = PaymentMode.walletStake;\n        }\n    }\n\n    // create the sender's contract if needed.\n    function _createSenderIfNeeded(UserOperation calldata op) internal {\n        if (op.initCode.length != 0) {\n            // note that we're still under the gas limit of validate, so probably\n            // this create2 creates a proxy account.\n            // @dev initCode must be unique (e.g. contains the signer address), to make sure\n            //   it can only be executed from the entryPoint, and called with its initialization code (callData)\n            address sender1 = ICreate2Deployer(create2factory).deploy(op.initCode, bytes32(op.nonce));\n            require(sender1 != address(0), \"create2 failed\");\n            require(sender1 == op.getSender(), \"sender doesn't match create2 address\");\n        }\n    }\n\n    /// Get counterfactual sender address.\n    ///  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n    function getSenderAddress(bytes memory initCode, uint _salt) public view returns (address) {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(create2factory),\n                _salt,\n                keccak256(initCode)\n            )\n        );\n\n        // NOTE: cast last 20 bytes of hash to address\n        return address(uint160(uint256(hash)));\n    }\n\n    //call wallet.validateUserOp, and validate that it paid as needed.\n    // return actual value sent from wallet to \"this\"\n    function _validateWalletPrepayment(uint opIndex, UserOperation calldata op, bytes32 requestId, uint requiredPrefund, PaymentMode paymentMode) internal returns (uint gasUsedByValidateUserOp, uint prefund) {\n    unchecked {\n        uint preGas = gasleft();\n        _createSenderIfNeeded(op);\n        uint missingWalletFunds = 0;\n        address sender = op.getSender();\n        if (paymentMode != PaymentMode.paymasterStake) {\n            uint bal = balanceOf(sender);\n            missingWalletFunds = bal > requiredPrefund ? 0 : requiredPrefund - bal;\n        }\n        try IWallet(sender).validateUserOp{gas : op.verificationGas}(op, requestId, missingWalletFunds) {\n        } catch Error(string memory revertReason) {\n            revert FailedOp(opIndex, address(0), revertReason);\n        } catch {\n            revert FailedOp(opIndex, address(0), \"\");\n        }\n        if (paymentMode != PaymentMode.paymasterStake) {\n            if (requiredPrefund > balanceOf(sender)) {\n                revert FailedOp(opIndex, address(0), \"wallet didn't pay prefund\");\n            }\n            internalDecrementDeposit(sender, requiredPrefund);\n            prefund = requiredPrefund;\n        } else {\n            prefund = 0;\n        }\n        gasUsedByValidateUserOp = preGas - gasleft();\n    }\n    }\n\n    //validate paymaster.validatePaymasterUserOp\n    function _validatePaymasterPrepayment(uint opIndex, UserOperation calldata op, bytes32 requestId, uint requiredPreFund, uint gasUsedByValidateUserOp) internal view returns (bytes memory context) {\n    unchecked {\n        //validate a paymaster has enough stake (including for payment for this TX)\n        // NOTE: when submitting a batch, caller has to make sure a paymaster has enough stake to cover\n        // all its transactions in the batch.\n        if (!isPaymasterStaked(op.paymaster, paymasterStake + requiredPreFund)) {\n            revert FailedOp(opIndex, op.paymaster, \"not enough stake\");\n        }\n        //no pre-pay from paymaster\n        uint gas = op.verificationGas - gasUsedByValidateUserOp;\n        try IPaymaster(op.paymaster).validatePaymasterUserOp{gas : gas}(op, requestId, requiredPreFund) returns (bytes memory _context){\n            context = _context;\n        } catch Error(string memory revertReason) {\n            revert FailedOp(opIndex, op.paymaster, revertReason);\n        } catch {\n            revert FailedOp(opIndex, op.paymaster, \"\");\n        }\n    }\n    }\n\n    function _validatePrepayment(uint opIndex, UserOperation calldata userOp, bytes32 requestId) private returns (uint prefund, PaymentMode paymentMode, bytes memory context){\n\n        uint preGas = gasleft();\n        uint maxGasValues = userOp.preVerificationGas | userOp.verificationGas |\n        userOp.callGas | userOp.maxFeePerGas | userOp.maxPriorityFeePerGas;\n        require(maxGasValues < type(uint120).max, \"gas values overflow\");\n        uint gasUsedByValidateUserOp;\n        uint requiredPreFund;\n        (requiredPreFund, paymentMode) = _getPaymentInfo(userOp);\n\n        (gasUsedByValidateUserOp, prefund) = _validateWalletPrepayment(opIndex, userOp, requestId, requiredPreFund, paymentMode);\n\n        //a \"marker\" where wallet opcode validation is done, by paymaster opcode validation is about to start\n        // (used only by off-chain simulateValidation)\n        uint marker = block.number;\n        (marker);\n\n        if (paymentMode == PaymentMode.paymasterStake) {\n            (context) = _validatePaymasterPrepayment(opIndex, userOp, requestId, requiredPreFund, gasUsedByValidateUserOp);\n        } else {\n            context = \"\";\n        }\n    unchecked {\n        uint gasUsed = preGas - gasleft();\n\n        if (userOp.verificationGas < gasUsed) {\n            revert FailedOp(opIndex, userOp.paymaster, \"Used more than verificationGas\");\n        }\n    }\n    }\n\n    function handlePostOp(uint opIndex, IPaymaster.PostOpMode mode, UserOperation calldata op, UserOpInfo memory opInfo, bytes memory context, uint actualGas) private returns (uint actualGasCost) {\n        uint preGas = gasleft();\n        uint gasPrice = UserOperationLib.gasPrice(op);\n    unchecked {\n        actualGasCost = actualGas * gasPrice;\n        if (opInfo.paymentMode != PaymentMode.paymasterStake) {\n            if (opInfo.prefund < actualGasCost) {\n                revert (\"wallet prefund below actualGasCost\");\n            }\n            uint refund = opInfo.prefund - actualGasCost;\n            internalIncrementDeposit(op.getSender(), refund);\n        } else {\n            if (context.length > 0) {\n                if (mode != IPaymaster.PostOpMode.postOpReverted) {\n                    IPaymaster(op.paymaster).postOp{gas : op.verificationGas}(mode, context, actualGasCost);\n                } else {\n                    try IPaymaster(op.paymaster).postOp{gas : op.verificationGas}(mode, context, actualGasCost) {}\n                    catch Error(string memory reason) {\n                        revert FailedOp(opIndex, op.paymaster, reason);\n                    }\n                    catch {\n                        revert FailedOp(opIndex, op.paymaster, \"postOp revert\");\n                    }\n                }\n            }\n            //paymaster pays for full gas, including for postOp\n            actualGas += preGas - gasleft();\n            actualGasCost = actualGas * gasPrice;\n            //paymaster balance known to be high enough, and to be locked for this block\n            internalDecrementDeposit(op.paymaster, actualGasCost);\n        }\n        bool success = mode == IPaymaster.PostOpMode.opSucceeded;\n        emit UserOperationEvent(opInfo.requestId, op.getSender(), op.paymaster, op.nonce, actualGasCost, gasPrice, success);\n    } // unchecked\n    }\n\n\n    function isPaymasterStaked(address paymaster, uint stake) public view returns (bool) {\n        return isStaked(paymaster, stake, unstakeDelaySec);\n    }\n}"
    },
    {
      "filename": "contracts/EntryPoint.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.7;\n\nimport \"./StakeManager.sol\";\nimport \"./UserOperation.sol\";\nimport \"./IWallet.sol\";\nimport \"./IPaymaster.sol\";\n\ninterface ICreate2Deployer {\n    function deploy(bytes memory _initCode, bytes32 _salt) external returns (address);\n}\n\ncontract EntryPoint is StakeManager {\n\n    using UserOperationLib for UserOperation;\n\n    enum PaymentMode {\n        paymasterStake, // if paymaster is set, use paymaster's stake to pay.\n        walletStake // pay with wallet deposit.\n    }\n\n    uint public immutable paymasterStake;\n    address public immutable create2factory;\n\n    event UserOperationEvent(bytes32 indexed requestId, address indexed sender, address indexed paymaster, uint nonce, uint actualGasCost, uint actualGasPrice, bool success);\n    event UserOperationRevertReason(bytes32 indexed requestId, address indexed sender, uint nonce, bytes revertReason);\n\n    //handleOps reverts with this error struct, to mark the offending op\n    // NOTE: if simulateOp passes successfully, there should be no reason for handleOps to fail on it.\n    // @param opIndex - index into the array of ops to the failed one (in simulateOp, this is always zero)\n    // @param paymaster - if paymaster.validatePaymasterUserOp fails, this will be the paymaster's address. if validateUserOp failed,\n    //      this value will be zero (since it failed before accessing the paymaster)\n    // @param reason - revert reason\n    //  only to aid troubleshooting of wallet/paymaster reverts\n    error FailedOp(uint opIndex, address paymaster, string reason);\n\n    /**\n     * @param _create2factory - contract to \"create2\" wallets (not the EntryPoint itself, so that it can be upgraded)\n     * @param _paymasterStake - locked stake of paymaster (actual value should also cover TX cost)\n     * @param _unstakeDelaySec - minimum time (in seconds) a paymaster stake must be locked\n     */\n    constructor(address _create2factory, uint _paymasterStake, uint32 _unstakeDelaySec) StakeManager(_unstakeDelaySec) {\n        create2factory = _create2factory;\n        paymasterStake = _paymasterStake;\n    }\n\n    /**\n     * Execute the given UserOperation.\n     * @param op the operation to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOp(UserOperation calldata op, address payable beneficiary) public {\n\n        uint preGas = gasleft();\n\n    unchecked {\n        bytes32 requestId = getRequestId(op);\n        (uint256 prefund, PaymentMode paymentMode, bytes memory context) = _validatePrepayment(0, op, requestId);\n        UserOpInfo memory opInfo = UserOpInfo(\n            requestId,\n            prefund,\n            paymentMode,\n            0,\n            preGas - gasleft() + op.preVerificationGas\n        );\n\n        uint actualGasCost;\n\n        try this.internalHandleOp(op, opInfo, context) returns (uint _actualGasCost) {\n            actualGasCost = _actualGasCost;\n        } catch {\n            uint actualGas = preGas - gasleft() + opInfo.preOpGas;\n            actualGasCost = handlePostOp(0, IPaymaster.PostOpMode.postOpReverted, op, opInfo, context, actualGas);\n        }\n\n        compensate(beneficiary, actualGasCost);\n    } // unchecked\n    }\n\n    function compensate(address payable beneficiary, uint amount) internal {\n        (bool success,) = beneficiary.call{value : amount}(\"\");\n        require(success);\n    }\n\n    /**\n     * Execute a batch of UserOperation.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) public {\n\n        uint opslen = ops.length;\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\n    unchecked {\n        for (uint i = 0; i < opslen; i++) {\n            uint preGas = gasleft();\n            UserOperation calldata op = ops[i];\n\n            bytes memory context;\n            uint contextOffset;\n            bytes32 requestId = getRequestId(op);\n            uint prefund;\n            PaymentMode paymentMode;\n            (prefund, paymentMode, context) = _validatePrepayment(i, op, requestId);\n            assembly {contextOffset := context}\n            opInfos[i] = UserOpInfo(\n                requestId,\n                prefund,\n                paymentMode,\n                contextOffset,\n                preGas - gasleft() + op.preVerificationGas\n            );\n        }\n\n        uint collected = 0;\n\n        for (uint i = 0; i < ops.length; i++) {\n            uint preGas = gasleft();\n            UserOperation calldata op = ops[i];\n            UserOpInfo memory opInfo = opInfos[i];\n            uint contextOffset = opInfo._context;\n            bytes memory context;\n            assembly {context := contextOffset}\n\n            try this.internalHandleOp(op, opInfo, context) returns (uint _actualGasCost) {\n                collected += _actualGasCost;\n            } catch {\n                uint actualGas = preGas - gasleft() + opInfo.preOpGas;\n                collected += handlePostOp(i, IPaymaster.PostOpMode.postOpReverted, op, opInfo, context, actualGas);\n            }\n        }\n\n        compensate(beneficiary, collected);\n    } //unchecked\n    }\n\n    struct UserOpInfo {\n        bytes32 requestId;\n        uint prefund;\n        PaymentMode paymentMode;\n        uint _context;\n        uint preOpGas;\n    }\n\n    function internalHandleOp(UserOperation calldata op, UserOpInfo calldata opInfo, bytes calldata context) external returns (uint actualGasCost) {\n        uint preGas = gasleft();\n        require(msg.sender == address(this));\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (op.callData.length > 0) {\n\n            (bool success,bytes memory result) = address(op.getSender()).call{gas : op.callGas}(op.callData);\n            if (!success) {\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(opInfo.requestId, op.getSender(), op.nonce, result);\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n    unchecked {\n        uint actualGas = preGas - gasleft() + opInfo.preOpGas;\n        return handlePostOp(0, mode, op, opInfo, context, actualGas);\n    }\n    }\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature).\n     */\n    function getRequestId(UserOperation calldata userOp) public view returns (bytes32) {\n        return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n    }\n\n    /**\n    * Simulate a call to wallet.validateUserOp and paymaster.validatePaymasterUserOp.\n    * Validation succeeds of the call doesn't revert.\n    * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the wallet's data.\n     *      In order to split the running opcodes of the wallet (validateUserOp) from the paymaster's validatePaymasterUserOp,\n     *      it should look for the NUMBER opcode at depth=1 (which itself is a banned opcode)\n     * @return preOpGas total gas used by validation (including contract creation)\n     * @return prefund the amount the wallet had to prefund (zero in case a paymaster pays)\n     */\n    function simulateValidation(UserOperation calldata userOp) external returns (uint preOpGas, uint prefund) {\n        uint preGas = gasleft();\n\n        bytes32 requestId = getRequestId(userOp);\n        (prefund,,) = _validatePrepayment(0, userOp, requestId);\n        preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n\n        require(msg.sender == address(0), \"must be called off-chain with from=zero-addr\");\n    }\n\n    function _getPaymentInfo(UserOperation calldata userOp) internal view returns (uint requiredPrefund, PaymentMode paymentMode) {\n        requiredPrefund = userOp.requiredPreFund();\n        if (userOp.hasPaymaster()) {\n            paymentMode = PaymentMode.paymasterStake;\n        } else {\n            paymentMode = PaymentMode.walletStake;\n        }\n    }\n\n    // create the sender's contract if needed.\n    function _createSenderIfNeeded(UserOperation calldata op) internal {\n        if (op.initCode.length != 0) {\n            // note that we're still under the gas limit of validate, so probably\n            // this create2 creates a proxy account.\n            // @dev initCode must be unique (e.g. contains the signer address), to make sure\n            //   it can only be executed from the entryPoint, and called with its initialization code (callData)\n            address sender1 = ICreate2Deployer(create2factory).deploy(op.initCode, bytes32(op.nonce));\n            require(sender1 != address(0), \"create2 failed\");\n            require(sender1 == op.getSender(), \"sender doesn't match create2 address\");\n        }\n    }\n\n    /// Get counterfactual sender address.\n    ///  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n    function getSenderAddress(bytes memory initCode, uint _salt) public view returns (address) {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(create2factory),\n                _salt,\n                keccak256(initCode)\n            )\n        );\n\n        // NOTE: cast last 20 bytes of hash to address\n        return address(uint160(uint256(hash)));\n    }\n\n    //call wallet.validateUserOp, and validate that it paid as needed.\n    // return actual value sent from wallet to \"this\"\n    function _validateWalletPrepayment(uint opIndex, UserOperation calldata op, bytes32 requestId, uint requiredPrefund, PaymentMode paymentMode) internal returns (uint gasUsedByValidateUserOp, uint prefund) {\n    unchecked {\n        uint preGas = gasleft();\n        _createSenderIfNeeded(op);\n        uint missingWalletFunds = 0;\n        address sender = op.getSender();\n        if (paymentMode != PaymentMode.paymasterStake) {\n            uint bal = balanceOf(sender);\n            missingWalletFunds = bal > requiredPrefund ? 0 : requiredPrefund - bal;\n        }\n        try IWallet(sender).validateUserOp{gas : op.verificationGas}(op, requestId, missingWalletFunds) {\n        } catch Error(string memory revertReason) {\n            revert FailedOp(opIndex, address(0), revertReason);\n        } catch {\n            revert FailedOp(opIndex, address(0), \"\");\n        }\n        if (paymentMode != PaymentMode.paymasterStake) {\n            if (requiredPrefund > balanceOf(sender)) {\n                revert FailedOp(opIndex, address(0), \"wallet didn't pay prefund\");\n            }\n            internalDecrementDeposit(sender, requiredPrefund);\n            prefund = requiredPrefund;\n        } else {\n            prefund = 0;\n        }\n        gasUsedByValidateUserOp = preGas - gasleft();\n    }\n    }\n\n    //validate paymaster.validatePaymasterUserOp\n    function _validatePaymasterPrepayment(uint opIndex, UserOperation calldata op, bytes32 requestId, uint requiredPreFund, uint gasUsedByValidateUserOp) internal view returns (bytes memory context) {\n    unchecked {\n        //validate a paymaster has enough stake (including for payment for this TX)\n        // NOTE: when submitting a batch, caller has to make sure a paymaster has enough stake to cover\n        // all its transactions in the batch.\n        if (!isPaymasterStaked(op.paymaster, paymasterStake + requiredPreFund)) {\n            revert FailedOp(opIndex, op.paymaster, \"not enough stake\");\n        }\n        //no pre-pay from paymaster\n        uint gas = op.verificationGas - gasUsedByValidateUserOp;\n        try IPaymaster(op.paymaster).validatePaymasterUserOp{gas : gas}(op, requestId, requiredPreFund) returns (bytes memory _context){\n            context = _context;\n        } catch Error(string memory revertReason) {\n            revert FailedOp(opIndex, op.paymaster, revertReason);\n        } catch {\n            revert FailedOp(opIndex, op.paymaster, \"\");\n        }\n    }\n    }\n\n    function _validatePrepayment(uint opIndex, UserOperation calldata userOp, bytes32 requestId) private returns (uint prefund, PaymentMode paymentMode, bytes memory context){\n\n        uint preGas = gasleft();\n        uint maxGasValues = userOp.preVerificationGas | userOp.verificationGas |\n        userOp.callGas | userOp.maxFeePerGas | userOp.maxPriorityFeePerGas;\n        require(maxGasValues < type(uint120).max, \"gas values overflow\");\n        uint gasUsedByValidateUserOp;\n        uint requiredPreFund;\n        (requiredPreFund, paymentMode) = _getPaymentInfo(userOp);\n\n        (gasUsedByValidateUserOp, prefund) = _validateWalletPrepayment(opIndex, userOp, requestId, requiredPreFund, paymentMode);\n\n        //a \"marker\" where wallet opcode validation is done, by paymaster opcode validation is about to start\n        // (used only by off-chain simulateValidation)\n        uint marker = block.number;\n        (marker);\n\n        if (paymentMode == PaymentMode.paymasterStake) {\n            (context) = _validatePaymasterPrepayment(opIndex, userOp, requestId, requiredPreFund, gasUsedByValidateUserOp);\n        } else {\n            context = \"\";\n        }\n    unchecked {\n        uint gasUsed = preGas - gasleft();\n\n        if (userOp.verificationGas < gasUsed) {\n            revert FailedOp(opIndex, userOp.paymaster, \"Used more than verificationGas\");\n        }\n    }\n    }\n\n    function handlePostOp(uint opIndex, IPaymaster.PostOpMode mode, UserOperation calldata op, UserOpInfo memory opInfo, bytes memory context, uint actualGas) private returns (uint actualGasCost) {\n        uint preGas = gasleft();\n        uint gasPrice = UserOperationLib.gasPrice(op);\n    unchecked {\n        actualGasCost = actualGas * gasPrice;\n        if (opInfo.paymentMode != PaymentMode.paymasterStake) {\n            if (opInfo.prefund < actualGasCost) {\n                revert (\"wallet prefund below actualGasCost\");\n            }\n            uint refund = opInfo.prefund - actualGasCost;\n            internalIncrementDeposit(op.getSender(), refund);\n        } else {\n            if (context.length > 0) {\n                if (mode != IPaymaster.PostOpMode.postOpReverted) {\n                    IPaymaster(op.paymaster).postOp{gas : op.verificationGas}(mode, context, actualGasCost);\n                } else {\n                    try IPaymaster(op.paymaster).postOp{gas : op.verificationGas}(mode, context, actualGasCost) {}\n                    catch Error(string memory reason) {\n                        revert FailedOp(opIndex, op.paymaster, reason);\n                    }\n                    catch {\n                        revert FailedOp(opIndex, op.paymaster, \"postOp revert\");\n                    }\n                }\n            }\n            //paymaster pays for full gas, including for postOp\n            actualGas += preGas - gasleft();\n            actualGasCost = actualGas * gasPrice;\n            //paymaster balance known to be high enough, and to be locked for this block\n            internalDecrementDeposit(op.paymaster, actualGasCost);\n        }\n        bool success = mode == IPaymaster.PostOpMode.opSucceeded;\n        emit UserOperationEvent(opInfo.requestId, op.getSender(), op.paymaster, op.nonce, actualGasCost, gasPrice, success);\n    } // unchecked\n    }\n\n\n    function isPaymasterStaked(address paymaster, uint stake) public view returns (bool) {\n        return isStaked(paymaster, stake, unstakeDelaySec);\n    }\n}"
    }
  ]
}