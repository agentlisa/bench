{
  "Title": "An incorrect comment",
  "Content": "##### Description\nThere is a comment that says that volume is used to calculate volatility, which is wrong https://github.com/cryptoalgebra/Algebra/blob/6f57b3e218630106a4d41aedefd38f9e83b41e2b/src/plugins/contracts/libraries/AdaptiveFee.sol#L36.\n\n##### Recommendation\nWe recommend updating the comment.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/plugins/contracts/libraries/AdaptiveFee.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport '@cryptoalgebra/core/contracts/libraries/Constants.sol';\nimport '../base/AlgebraFeeConfiguration.sol';\n\n/// @title AdaptiveFee\n/// @notice Calculates fee based on combination of sigmoids\n/// @dev Version for AlgebraBasePluginV1\nlibrary AdaptiveFee {\n  uint16 internal constant INITIAL_MIN_FEE = 0.01e4; // 0.01%\n\n  /// @notice Returns default initial fee configuration\n  function initialFeeConfiguration() internal pure returns (AlgebraFeeConfiguration memory) {\n    return\n      AlgebraFeeConfiguration(\n        3000 - INITIAL_MIN_FEE, // alpha1, max value of the first sigmoid in hundredths of a bip, i.e. 1e-6\n        15000 - 3000, // alpha2, max value of the second sigmoid in hundredths of a bip, i.e. 1e-6\n        360, // beta1, shift along the x-axis (volatility) for the first sigmoid\n        60000, // beta2, shift along the x-axis (volatility) for the second sigmoid\n        59, // gamma1, horizontal stretch factor for the first sigmoid\n        8500, // gamma2, horizontal stretch factor for the second sigmoid\n        INITIAL_MIN_FEE // baseFee in hundredths of a bip, i.e. 1e-6\n      );\n  }\n\n  /// @notice Validates fee configuration.\n  /// @dev Maximum fee value capped by baseFee + alpha1 + alpha2 must be <= type(uint16).max\n  /// gammas must be > 0\n  function validateFeeConfiguration(AlgebraFeeConfiguration memory _config) internal pure {\n    require(uint256(_config.alpha1) + uint256(_config.alpha2) + uint256(_config.baseFee) <= type(uint16).max, 'Max fee exceeded');\n    require(_config.gamma1 != 0 && _config.gamma2 != 0, 'Gammas must be > 0');\n  }\n\n  /// @notice Calculates fee based on formula:\n  /// baseFee + sigmoidVolume(sigmoid1(volatility, volumePerLiquidity) + sigmoid2(volatility, volumePerLiquidity))\n  /// maximum value capped by baseFee + alpha1 + alpha2\n  function getFee(uint88 volatility, AlgebraFeeConfiguration memory config) internal pure returns (uint16 fee) {\n    unchecked {\n      volatility /= 15; // normalize for 15 sec interval\n      uint256 sumOfSigmoids = sigmoid(volatility, config.gamma1, config.alpha1, config.beta1) +\n        sigmoid(volatility, config.gamma2, config.alpha2, config.beta2);\n\n      uint256 result = uint256(config.baseFee) + sumOfSigmoids;\n      assert(result <= type(uint16).max); // should always be true\n\n      return uint16(result); // safe since alpha1 + alpha2 + baseFee _must_ be <= type(uint16).max\n    }\n  }\n\n  /// @notice calculates α / (1 + e^( (β-x) / γ))\n  /// that is a sigmoid with a maximum value of α, x-shifted by β, and stretched by γ\n  /// @dev returns uint256 for fuzzy testing. Guaranteed that the result is not greater than alpha\n  function sigmoid(uint256 x, uint16 g, uint16 alpha, uint256 beta) internal pure returns (uint256 res) {\n    unchecked {\n      if (x > beta) {\n        x = x - beta;\n        if (x >= 6 * uint256(g)) return alpha; // so x < 19 bits\n        uint256 g4 = uint256(g) ** 4; // < 64 bits (4*16)\n        uint256 ex = expXg4(x, g, g4); // < 155 bits\n        res = (alpha * ex) / (g4 + ex); // in worst case: (16 + 155 bits) / 155 bits\n        // so res <= alpha\n      } else {\n        x = beta - x;\n        if (x >= 6 * uint256(g)) return 0; // so x < 19 bits\n        uint256 g4 = uint256(g) ** 4; // < 64 bits (4*16)\n        uint256 ex = g4 + expXg4(x, g, g4); // < 156 bits\n        res = (alpha * g4) / ex; // in worst case: (16 + 128 bits) / 156 bits\n        // g8 <= ex, so res <= alpha\n      }\n    }\n  }\n\n  /// @notice calculates e^(x/g) * g^4 in a series, since (around zero):\n  /// e^x = 1 + x + x^2/2 + ... + x^n/n! + ...\n  /// e^(x/g) = 1 + x/g + x^2/(2*g^2) + ... + x^(n)/(g^n * n!) + ...\n  /// @dev has good accuracy only if x/g < 6\n  function expXg4(uint256 x, uint16 g, uint256 gHighestDegree) internal pure returns (uint256 res) {\n    uint256 closestValue; // nearest 'table' value of e^(x/g), multiplied by 10^20\n    assembly {\n      let xdg := div(x, g)\n      switch xdg\n      case 0 {\n        closestValue := 100000000000000000000 // 1\n      }\n      case 1 {\n        closestValue := 271828182845904523536 // ~= e\n      }\n      case 2 {\n        closestValue := 738905609893065022723 // ~= e^2\n      }\n      case 3 {\n        closestValue := 2008553692318766774092 // ~= e^3\n      }\n      case 4 {\n        closestValue := 5459815003314423907811 // ~= e^4\n      }\n      default {\n        closestValue := 14841315910257660342111 // ~= e^5\n      }\n\n      x := mod(x, g)\n    }\n\n    unchecked {\n      if (x >= g / 2) {\n        // (x - closestValue) >= 0.5, so closestValue := closestValue * e^0.5\n        x -= g / 2;\n        closestValue = (closestValue * 164872127070012814684) / 1e20;\n      }\n\n      // After calculating the closestValue x/g is <= 0.5, so that the series in the neighborhood of zero converges with sufficient speed\n      uint256 xLowestDegree = x;\n      res = gHighestDegree; // g**4, res < 64 bits\n\n      gHighestDegree /= g; // g**3\n      res += xLowestDegree * gHighestDegree; // g**4 + x*g**3, res < 68\n\n      gHighestDegree /= g; // g**2\n      xLowestDegree *= x; // x**2\n      // g**4 + x * g**3 + (x**2 * g**2) / 2, res < 71\n      res += (xLowestDegree * gHighestDegree) / 2;\n\n      gHighestDegree /= g; // g\n      xLowestDegree *= x; // x**3\n      // g^4 + x * g^3 + (x^2 * g^2)/2 + x^3(g*4 + x)/24, res < 73\n      res += (xLowestDegree * g * 4 + xLowestDegree * x) / 24;\n\n      // res = g^4 * (1 + x/g + x^2/(2*g^2) + x^3/(6*g^3) + x^4/(24*g^4)) * closestValue / 10^20, closestValue < 75 bits, res < 155\n      res = (res * closestValue) / (1e20);\n    }\n  }\n}"
    }
  ]
}