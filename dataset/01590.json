{
  "Title": "M-17: Hedgers are not incentivized to respond to user's closing requests",
  "Content": "# Issue M-17: Hedgers are not incentivized to respond to user's closing requests \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/239 \n\n## Found by \nxiaoming90\n## Summary\n\nHedgers could intentionally force the users to close the positions themselves via the `forceClosePosition` and charge a spread to earn more, which results in the users closing at a worse price, leading to a loss of profit for them.\n\n## Vulnerability Detail\n\n#### How `fillCloseRequest` function works?\n\nFor a Long position, when PartyB (Hedger) calls the `fillCloseRequest` function to fill a close position under normal circumstances, the hedger cannot charge a spread because the hedger has to close at the user's requested close price (`quote.requestedClosePrice`), \n\nIf the hedger decides to close at a higher price, it is permissible by the function, but the hedger will lose more, and the users will gain more because the users' profit is computed based on `long profit = closing price - opening price`. \n\nUnder normal circumstances, most users will set the requested close price (`quote.requestedClosePrice`) close to the market price most of the time.\n\nIn short, the `fillCloseRequest` function requires the hedger to match or exceed the user' requested price. The hedger cannot close at a price below the user's requested price in order to charge a spread.\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L256\n\n```solidity\nfunction fillCloseRequest(\n..SNIP..\n    if (quote.positionType == PositionType.LONG) {\n        require(\n            closedPrice >= quote.requestedClosePrice,\n            \"PartyBFacet: Closed price isn't valid\"\n        )\n```\n\n#### How `forceClosePosition` function works?\n\nFor a Long position, the `forceCloseGapRatio` will allow the hedger to charge a spread from the user's requested price (`quote.requestedClosePrice`) when the user (PartyA) attempts to force close the position.\n\nThe `upnlSig.price` is the market price and `quote.requestedClosePrice` is the price users ask to close at. By having the `forceCloseGapRatio`, assuming that `forceCloseGapRatio` is 5%, this will create a spread between the two prices (`upnlSig.price` and `quote.requestedClosePrice`) that represent a cost that the users (PartyA) need to \"pay\" in order to force close a position.\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L253\n\n```solidity\nfunction forceClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n..SNIP..\n    if (quote.positionType == PositionType.LONG) {\n        require(\n            upnlSig.price >=\n                quote.requestedClosePrice +\n                    (quote.requestedClosePrice * maLayout.forceCloseGapRatio) /\n                    1e18,\n            \"PartyAFacet: Requested close price not reached\"\n        );\n    ..SNIP..\n    LibQuote.closeQuote(quote, filledAmount, quote.requestedClosePrice);\n```\n\n#### Issue with current design\n\nAssume a hedger ignores the user's close request. In this case, the users (PartyA) have to call the `forceClosePosition` function by themselves to close the position and pay a spread.\n\nThe hedgers can abuse this mechanic to their benefit. Assuming the users (PartyA) ask to close a LONG position at a fair value, and the hedgers respond by calling the `fillCloseRequest` to close it. In this case, the hedgers won't be able to charge a spread because the hedgers are forced to close at a price equal to or higher than the user's asking closing price (`quote.requestedClosePrice`). \n\nHowever, if the hedger chooses to ignore the user's close request, this will force the user to call the `forceClosePosition,` and the user will have to pay a spread to the hedgers due to the gap ratio. In this case, the hedgers will benefit more due to the spread.\n\nIn the long run, the hedgers will be incentivized to ignore users' close requests.\n\n## Impact\n\nThe hedgers will be incentivized to ignore users' close requests, resulting in the users having to wait for the cooldown before being able to force close a position themselves. The time spent waiting could potentially lead to a loss of opportunity cost for the users.\n\nIn addition, hedgers could intentionally force the users to close the positions themselves via the `forceClosePosition` and charge a spread to earn more, which results in the users closing at a worse price, leading to a loss of profit for them.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L253\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nHedgers should not be entitled to charge a spread within the `forceClosePosition` function because some hedgers might intentionally choose not to respond to user requests in order to force the users to close the position themselves. In addition, hedgers are incentivized to force users to close the position themselves as the `forceClosePosition` function allows them the charge a spread.\n\nWithin the `forceClosePosition` function, consider removing the gap ratio to remove the spread and fill the position at the market price (`upnlSig.price`).\n\n```diff\n    function forceClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n..SNIP..\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                upnlSig.price >=\n+\t\t\t\t\tquote.requestedClosePrice,                \n-                   quote.requestedClosePrice +\n-                        (quote.requestedClosePrice * maLayout.forceCloseGapRatio) /\n-                        1e18,\n                \"PartyAFacet: Requested close price not reached\"\n            );\n        } else {\n            require(\n                upnlSig.price <=\n+               \tquote.requestedClosePrice,\n-                   quote.requestedClosePrice -\n-                        (quote.requestedClosePrice * maLayout.forceCloseGapRatio) /\n-                        1e18,\n                \"PartyAFacet: Requested close price not reached\"\n            );\n        }\n..SNIP..\n-       LibQuote.closeQuote(quote, filledAmount, quote.requestedClosePrice);\n+\t\tLibQuote.closeQuote(quote, filledAmount, upnlSig.price);\n    }\n```\n\nFor long-term improvement to the protocol, assuming that the user's requested price is of fair value:\n\n1) Hedger should be penalized for not responding to the user's closing request in a timely manner; OR\n2) Hegder should be incentivized to respond to the user's closing request. For instance, they are entitled to charge a spread if they respond to user closing requests.\n\n\n\n## Discussion\n\n**mstpr**\n\nEscalate\n\nHedgers are not incentivized to hold the position because\n\n1- price can move, it is not a safe bet to keep the position for couple more days always. When hedgers take the risk of not closing a position they also take the risk of price movements against their position. \n\n2- Hedgers are not taking any spread. Quote is closed at the requested close price.\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L296\n\nBoth partyA and partyB shouldn't be penalized for these actions. Recommendation says that the hedger (partyB) should be penalized if things go to forcing. However, this can also be easily abusable by partyA, partyA can create close requests near the market price and continuously cash out the profits knowing that partyB will forced to close the request rather than keep it waiting.\n\nIf the market price is used for force close as stated in recommendation it is even worse. Now, the partyB has a chance, will he keep the trade and wish for the price to move to its favor or just take the trade. Now, partyB is actually kind of incentivized to hold the position. Current design ensures that the request is closed as the requested price. There is a small buffer to keep partyA not abusing this which makes sense. I don't think anything is wrong here and everything is design choice.  \n\n**sherlock-admin2**\n\n > Escalate\n> \n> Hedgers are not incentivized to hold the position because\n> \n> 1- price can move, it is not a safe bet to keep the position for couple more days always. When hedgers take the risk of not closing a position they also take the risk of price movements against their position. \n> \n> 2- Hedgers are not taking any spread. Quote is closed at the requested close price.\n> https://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L296\n> \n> Both partyA and partyB shouldn't be penalized for these actions. Recommendation says that the hedger (partyB) should be penalized if things go to forcing. However, this can also be easily abusable by partyA, partyA can create close requests near the market price and continuously cash out the profits knowing that partyB will forced to close the request rather than keep it waiting.\n> \n> If the market price is used for force close as stated in recommendation it is even worse. Now, the partyB has a chance, will he keep the trade and wish for the price to move to its favor or just take the trade. Now, partyB is actually kind of incentivized to hold the position. Current design ensures that the request is closed as the requested price. There is a small buffer to keep partyA not abusing this which makes sense. I don't think anything is wrong here and everything is design choice.  \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**imherefortech**\n\nEscalate\n\nTo add some arguments, if hedgers do not respond to the requests in time, users will move to other hedgers. Remember, that users provide a whitelist of hedgers that can respond to their quotes. Hedgers are pretty clearly incentivized this way.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> To add some arguments, if hedgers do not respond to the requests in time, users will move to other hedgers. Remember, that users provide a whitelist of hedgers that can respond to their quotes. Hedgers are pretty clearly incentivized this way.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**xiaoming9090**\n\n> Escalate\n> \n> Hedgers are not incentivized to hold the position because\n> \n> 1- price can move, it is not a safe bet to keep the position for couple more days always. When hedgers take the risk of not closing a position they also take the risk of price movements against their position.\n> \n> 2- Hedgers are not taking any spread. Quote is closed at the requested close price. https://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L296\n> \n> Both partyA and partyB shouldn't be penalized for these actions. Recommendation says that the hedger (partyB) should be penalized if things go to forcing. However, this can also be easily abusable by partyA, partyA can create close requests near the market price and continuously cash out the profits knowing that partyB will forced to close the request rather than keep it waiting.\n> \n> If the market price is used for force close as stated in recommendation it is even worse. Now, the partyB has a chance, will he keep the trade and wish for the price to move to its favor or just take the trade. Now, partyB is actually kind of incentivized to hold the position. Current design ensures that the request is closed as the requested price. There is a small buffer to keep partyA not abusing this which makes sense. I don't think anything is wrong here and everything is design choice.\n\nPoint 1 is irrelevant. If the PartyB (Hedger) choose not to close the position, obviously they have evaluated and chosen to accept the risk of price movements.\n\nPoint 2 is incorrect. The `require` statement and the `forceCloseGapRatio` [here](https://github.com/sherlock-audit/2023-06-symmetrical/blame/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L270) ensure that there is spread.\n\nThere is a misunderstanding. The report is not saying that PartyA and/or PartyB (Hedger) should be penalized. Instead, the report is saying that PartyB (Hedger) should not be rewarded with a spread if it does not do its job by responding to user's close position request.\n\n\n**xiaoming9090**\n\n> Escalate\n> \n> To add some arguments, if hedgers do not respond to the requests in time, users will move to other hedgers. Remember, that users provide a whitelist of hedgers that can respond to their quotes. Hedgers are pretty clearly incentivized this way.\n\nIf such a measure did not exist in the first place, the issue would have been graded as 'High' since there would be less deterrence to ensure that PartyB (Hedger) behaves appropriately. However, in this case, it has been downgraded to Medium taking into consideration of other factors. Also, the main goal (root problem) of this report is to highlight the fact that Hedgers are still being rewarded with the spread even though they do not do their job by responding to users' close position requests.\n\nIn addition, it does not make sense for a user who has to manually force close their position because the Hedger refuses to do its job, and yet the user has to pay a spread and reward it to the Hedger for not doing its job.\n\n**mstpr**\n\n\"However, if the hedger chooses to ignore the user's close request, this will force the user to call the forceClosePosition, and the user will have to pay a spread to the hedgers due to the gap ratio. In this case, the hedgers will benefit more due to the spread.\"\n\nthe position is closed at the requested close price not at the requested close price + buffer. There is only a buffer for partyA to not abuse the system which make sense. If hedger does not want to close the position at the requested price of partyA, which is totally understandable and fine, then the hedger is not necessarily safe or incentivized. It means that the hedger is still exposed to the price movements during the time. \n\nBoth partyA and partyB are counterparties of a trade. PartyB does not have to follow the rules of partyA. \n\nI would kindly ask for you to provide a scenario where its \"always\" in benefit of partyB to stall the close request. I think your recommended fix is an another medium finding for Sherlock. \n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/17\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nAfter considering the above discussion considering this issue a valid medium. Agree with the comments [here](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/239#issuecomment-1654986894) \nThere is a spread in addition to the requested close price. Additionally, the fix also acknowledges the problem\nSome comments from the Sponsor on the function:\n> Hedgers have the option to close their positions on the broker side, adding a spread on top of it. However, when it comes to filling the contract side, it is preferable for them to match or exceed the user's requested price. Regarding the force close mechanism, the gap ratio allows hedgers to charge a spread on the broker side. Additionally, during a force close, the position should be filled at the market price rather than the user's requested price.\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [mstpr](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/239/#issuecomment-1653465075): rejected\n- [imherefortech](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/239/#issuecomment-1654821536): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyBFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function lockQuote(uint256 quoteId, SingleUpnlSig memory upnlSig, bool increaseNonce) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, quote.partyA);\n        checkPartyBValidationToLockQuote(quoteId, upnlSig.upnl);\n        if (increaseNonce) {\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        }\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.LOCKED;\n        quote.partyB = msg.sender;\n        // lock funds for partyB\n        accountLayout.partyBPendingLockedBalances[msg.sender][quote.partyA].addQuote(quote);\n        quoteLayout.partyBPendingQuotes[msg.sender][quote.partyA].push(quote.id);\n    }\n\n    function unlockQuote(uint256 quoteId) internal returns (QuoteStatus) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.LOCKED, \"PartyBFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            QuoteStatus result = LibQuote.expireQuote(quoteId);\n            return result;\n        } else {\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n            quote.modifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.PENDING;\n            accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyBPendingQuotes(quote);\n            quote.partyB = address(0);\n            return QuoteStatus.PENDING;\n        }\n    }\n\n    function acceptCancelRequest(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.CANCEL_PENDING, \"PartyBFacet: Invalid state\");\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CANCELED;\n        accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n        accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n        // send trading Fee back to partyA\n        LibQuote.returnTradingFee(quoteId);\n\n        LibQuote.removeFromPendingQuotes(quote);\n    }\n\n    function checkPartyBValidationToLockQuote(uint256 quoteId, int256 upnl) internal view {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.PENDING, \"PartyBFacet: Invalid state\");\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        require(quoteId <= quoteLayout.lastId, \"PartyBFacet: Invalid quoteId\");\n        int256 availableBalance = LibAccount.partyBAvailableForQuote(\n            upnl,\n            msg.sender,\n            quote.partyA\n        );\n        require(availableBalance >= 0, \"PartyBFacet: Available balance is lower than zero\");\n        require(\n            uint256(availableBalance) >= quote.lockedValues.total(),\n            \"PartyBFacet: insufficient available balance\"\n        );\n        require(\n            !maLayout.partyBLiquidationStatus[msg.sender][quote.partyA],\n            \"PartyBFacet: PartyB isn't solvent\"\n        );\n        bool isValidPartyB;\n        if (quote.partyBsWhiteList.length == 0) {\n            require(msg.sender != quote.partyA, \"PartyBFacet: PartyA can't be partyB too\");\n            isValidPartyB = true;\n        } else {\n            for (uint8 index = 0; index < quote.partyBsWhiteList.length; index++) {\n                if (msg.sender == quote.partyBsWhiteList[index]) {\n                    isValidPartyB = true;\n                    break;\n                }\n            }\n        }\n        require(isValidPartyB, \"PartyBFacet: Sender isn't whitelisted\");\n    }\n\n    function openPosition(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 openedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(\n            quote.quoteStatus == QuoteStatus.LOCKED ||\n            quote.quoteStatus == QuoteStatus.CANCEL_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        if (quote.orderType == OrderType.LIMIT) {\n            require(\n                quote.quantity >= filledAmount && filledAmount > 0,\n                \"PartyBFacet: Invalid filledAmount\"\n            );\n        } else {\n            require(quote.quantity == filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        }\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                openedPrice <= quote.requestedOpenPrice,\n                \"PartyBFacet: Opened price isn't valid\"\n            );\n        } else {\n            require(\n                openedPrice >= quote.requestedOpenPrice,\n                \"PartyBFacet: Opened price isn't valid\"\n            );\n        }\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n\n        quote.openedPrice = openedPrice;\n        LibSolvency.isSolventAfterOpenPosition(quoteId, filledAmount, upnlSig);\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n\n        LibQuote.removeFromPendingQuotes(quote);\n\n        if (quote.quantity == filledAmount) {\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n\n            if (quote.orderType == OrderType.LIMIT) {\n                quote.lockedValues.mul(openedPrice).div(quote.requestedOpenPrice);\n            }\n            accountLayout.lockedBalances[quote.partyA].addQuote(quote);\n            accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].addQuote(quote);\n        }\n        // partially fill\n        else {\n            currentId = ++quoteLayout.lastId;\n            QuoteStatus newStatus;\n            if (quote.quoteStatus == QuoteStatus.CANCEL_PENDING) {\n                newStatus = QuoteStatus.CANCELED;\n            } else {\n                newStatus = QuoteStatus.PENDING;\n                quoteLayout.partyAPendingQuotes[quote.partyA].push(currentId);\n            }\n            LockedValues memory filledLockedValues = LockedValues(\n                (quote.lockedValues.cva * filledAmount) / quote.quantity,\n                (quote.lockedValues.mm * filledAmount) / quote.quantity,\n                (quote.lockedValues.lf * filledAmount) / quote.quantity\n            );\n            LockedValues memory appliedFilledLockedValues = filledLockedValues;\n            appliedFilledLockedValues = appliedFilledLockedValues.mulMem(openedPrice);\n            appliedFilledLockedValues = appliedFilledLockedValues.divMem(quote.requestedOpenPrice);\n            // check that opened position is not minor position\n            require(\n                appliedFilledLockedValues.total() >=\n                SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyBFacet: Quote value is low\"\n            );\n            // check that new pending position is not minor position\n            require(\n                (quote.lockedValues.total() - filledLockedValues.total()) >=\n                SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyBFacet: Quote value is low\"\n            );\n\n            Quote memory q = Quote({\n                id: currentId,\n                partyBsWhiteList: quote.partyBsWhiteList,\n                symbolId: quote.symbolId,\n                positionType: quote.positionType,\n                orderType: quote.orderType,\n                openedPrice: 0,\n                requestedOpenPrice: quote.requestedOpenPrice,\n                marketPrice: quote.marketPrice,\n                quantity: quote.quantity - filledAmount,\n                closedAmount: 0,\n                lockedValues: LockedValues(0, 0, 0),\n                initialLockedValues: LockedValues(0, 0, 0),\n                maxInterestRate: quote.maxInterestRate,\n                partyA: quote.partyA,\n                partyB: address(0),\n                quoteStatus: newStatus,\n                avgClosedPrice: 0,\n                requestedClosePrice: 0,\n                parentId: quote.id,\n                createTimestamp: quote.createTimestamp,\n                modifyTimestamp: block.timestamp,\n                quantityToClose: 0,\n                deadline: quote.deadline\n            });\n\n            quoteLayout.quoteIdsOf[quote.partyA].push(currentId);\n            quoteLayout.quotes[currentId] = q;\n            Quote storage newQuote = quoteLayout.quotes[currentId];\n\n            if (newStatus == QuoteStatus.CANCELED) {\n                // send trading Fee back to partyA\n                LibQuote.returnTradingFee(currentId);\n                // part of quote has been filled and part of it has been canceled\n                accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(\n                    quote\n                );\n            } else {\n                accountLayout.pendingLockedBalances[quote.partyA].sub(filledLockedValues);\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].sub(\n                    filledLockedValues\n                );\n            }\n            newQuote.lockedValues = quote.lockedValues.sub(filledLockedValues);\n            newQuote.initialLockedValues = newQuote.lockedValues;\n            quote.quantity = filledAmount;\n            quote.lockedValues = appliedFilledLockedValues;\n\n            // lock with amount of filledAmount\n            accountLayout.lockedBalances[quote.partyA].addQuote(quote);\n            accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].addQuote(quote);\n        }\n        quote.quoteStatus = QuoteStatus.OPENED;\n        LibQuote.addToOpenPositions(quoteId);\n    }\n\n    function fillCloseRequest(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 closedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(\n            quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                closedPrice >= quote.requestedClosePrice,\n                \"PartyBFacet: Closed price isn't valid\"\n            );\n        } else {\n            require(\n                closedPrice <= quote.requestedClosePrice,\n                \"PartyBFacet: Closed price isn't valid\"\n            );\n        }\n        if (quote.orderType == OrderType.LIMIT) {\n            require(quote.quantityToClose >= filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        } else {\n            require(quote.quantityToClose == filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        }\n\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterClosePosition(quoteId, filledAmount, closedPrice, upnlSig);\n\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        accountLayout.partyANonces[quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, closedPrice);\n    }\n\n    function acceptCancelCloseRequest(uint256 quoteId) internal {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        AccountStorage.layout().partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.OPENED;\n        quote.requestedClosePrice = 0;\n        quote.quantityToClose = 0;\n    }\n\n    function emergencyClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.OPENED, \"PartyBFacet: Invalid state\");\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        uint256 filledAmount = LibQuote.quoteOpenAmount(quote);\n        quote.quantityToClose = filledAmount;\n        quote.requestedClosePrice = upnlSig.price;\n        LibSolvency.isSolventAfterClosePosition(quoteId, filledAmount, upnlSig.price, upnlSig);\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        accountLayout.partyANonces[quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, upnlSig.price);\n    }\n\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyAFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function sendQuote(\n        address[] memory partyBsWhiteList,\n        uint256 symbolId,\n        PositionType positionType,\n        OrderType orderType,\n        uint256 price,\n        uint256 quantity,\n        uint256 cva,\n        uint256 mm,\n        uint256 lf,\n        uint256 maxInterestRate,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n\n        require(\n            quoteLayout.partyAPendingQuotes[msg.sender].length < maLayout.pendingQuotesValidLength,\n            \"PartyAFacet: Number of pending quotes out of range\"\n        );\n        require(symbolLayout.symbols[symbolId].isValid, \"PartyAFacet: Symbol is not valid\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n\n        LockedValues memory lockedValues = LockedValues(cva, mm, lf);\n        uint256 tradingPrice = orderType == OrderType.LIMIT ? price : upnlSig.price;\n        uint256 notionalValue = (quantity * tradingPrice) / 1e18;\n        require(\n            lockedValues.total() <= notionalValue,\n            \"PartyAFacet: Leverage can't be lower than one\"\n        );\n\n        require(\n            lockedValues.lf >=\n                (symbolLayout.symbols[symbolId].minAcceptablePortionLF * lockedValues.total()) /\n                    1e18,\n            \"PartyAFacet: LF is not enough\"\n        );\n\n        require(\n            lockedValues.total() >= symbolLayout.symbols[symbolId].minAcceptableQuoteValue,\n            \"PartyAFacet: Quote value is low\"\n        );\n        for (uint8 i = 0; i < partyBsWhiteList.length; i++) {\n            require(\n                partyBsWhiteList[i] != msg.sender,\n                \"PartyAFacet: Sender isn't allowed in partyBWhiteList\"\n            );\n        }\n\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, msg.sender, symbolId);\n\n        int256 availableBalance = LibAccount.partyAAvailableForQuote(upnlSig.upnl, msg.sender);\n        require(availableBalance > 0, \"PartyAFacet: Available balance is lower than zero\");\n        require(\n            uint256(availableBalance) >=\n                lockedValues.total() +\n                    ((quantity * tradingPrice * symbolLayout.symbols[symbolId].tradingFee) / 1e36),\n            \"PartyAFacet: insufficient available balance\"\n        );\n\n        // lock funds the in middle of way\n        accountLayout.pendingLockedBalances[msg.sender].add(lockedValues);\n        currentId = ++quoteLayout.lastId;\n        accountLayout.partyANonces[msg.sender] += 1;\n\n        // create quote.\n        Quote memory quote = Quote({\n            id: currentId,\n            partyBsWhiteList: partyBsWhiteList,\n            symbolId: symbolId,\n            positionType: positionType,\n            orderType: orderType,\n            openedPrice: 0,\n            requestedOpenPrice: price,\n            marketPrice: upnlSig.price,\n            quantity: quantity,\n            closedAmount: 0,\n            lockedValues: lockedValues,\n            initialLockedValues: lockedValues,\n            maxInterestRate: maxInterestRate,\n            partyA: msg.sender,\n            partyB: address(0),\n            quoteStatus: QuoteStatus.PENDING,\n            avgClosedPrice: 0,\n            requestedClosePrice: 0,\n            parentId: 0,\n            createTimestamp: block.timestamp,\n            modifyTimestamp: block.timestamp,\n            quantityToClose: 0,\n            deadline: deadline\n        });\n        quoteLayout.quoteIdsOf[msg.sender].push(currentId);\n        quoteLayout.partyAPendingQuotes[msg.sender].push(currentId);\n        quoteLayout.quotes[currentId] = quote;\n\n        LibQuote.receiveTradingFee(currentId);\n    }\n\n    function requestToCancelQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING || quote.quoteStatus == QuoteStatus.LOCKED,\n            \"PartyAFacet: Invalid state\"\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n\n        if (block.timestamp > quote.deadline) {\n            result = LibQuote.expireQuote(quoteId);\n        } else if (quote.quoteStatus == QuoteStatus.PENDING) {\n            quote.quoteStatus = QuoteStatus.CANCELED;\n            LibQuote.returnTradingFee(quoteId);\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyAPendingQuotes(quote);\n            result = QuoteStatus.CANCELED;\n        } else {\n            // Quote is locked\n            quote.quoteStatus = QuoteStatus.CANCEL_PENDING;\n            result = QuoteStatus.CANCEL_PENDING;\n        }\n        quote.modifyTimestamp = block.timestamp;\n    }\n\n    function requestToClosePosition(\n        uint256 quoteId,\n        uint256 closePrice,\n        uint256 quantityToClose,\n        OrderType orderType,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.OPENED, \"PartyAFacet: Invalid state\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n        require(\n            LibQuote.quoteOpenAmount(quote) >= quantityToClose,\n            \"PartyAFacet: Invalid quantityToClose\"\n        );\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterRequestToClosePosition(\n            quoteId,\n            closePrice,\n            quantityToClose,\n            upnlSig\n        );\n\n        // check that remaining position is not too small\n        if (LibQuote.quoteOpenAmount(quote) > quantityToClose) {\n            require(\n                ((LibQuote.quoteOpenAmount(quote) - quantityToClose) * quote.lockedValues.total()) /\n                    LibQuote.quoteOpenAmount(quote) >=\n                    symbolLayout.symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyAFacet: Remaining quote value is low\"\n            );\n        }\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CLOSE_PENDING;\n        quote.requestedClosePrice = closePrice;\n        quote.quantityToClose = quantityToClose;\n        quote.orderType = orderType;\n        quote.deadline = deadline;\n    }\n\n    function requestToCancelCloseRequest(uint256 quoteId) internal returns (QuoteStatus) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            LibQuote.expireQuote(quoteId);\n            return QuoteStatus.OPENED;\n        } else {\n            accountLayout.partyANonces[quote.partyA] += 1;\n            quote.modifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.CANCEL_CLOSE_PENDING;\n            return QuoteStatus.CANCEL_CLOSE_PENDING;\n        }\n    }\n\n    function forceCancelQuote(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CANCEL_PENDING, \"PartyAFacet: Invalid state\");\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCancelCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CANCELED;\n        accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n        accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n\n        // send trading Fee back to partyA\n        LibQuote.returnTradingFee(quoteId);\n\n        LibQuote.removeFromPendingQuotes(quote);\n    }\n\n    function forceCancelCloseRequest(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyAFacet: Invalid state\"\n        );\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCancelCloseCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.OPENED;\n        quote.requestedClosePrice = 0;\n        quote.quantityToClose = 0;\n    }\n\n    function forceClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        uint256 filledAmount = quote.quantityToClose;\n        require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCloseCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        require(\n            quote.orderType == OrderType.LIMIT,\n            \"PartyBFacet: Quote's order type should be LIMIT\"\n        );\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                upnlSig.price >=\n                    quote.requestedClosePrice +\n                        (quote.requestedClosePrice * maLayout.forceCloseGapRatio) /\n                        1e18,\n                \"PartyAFacet: Requested close price not reached\"\n            );\n        } else {\n            require(\n                upnlSig.price <=\n                    quote.requestedClosePrice -\n                        (quote.requestedClosePrice * maLayout.forceCloseGapRatio) /\n                        1e18,\n                \"PartyAFacet: Requested close price not reached\"\n            );\n        }\n\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterClosePosition(\n            quoteId,\n            filledAmount,\n            quote.requestedClosePrice,\n            upnlSig\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, quote.requestedClosePrice);\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyAFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function sendQuote(\n        address[] memory partyBsWhiteList,\n        uint256 symbolId,\n        PositionType positionType,\n        OrderType orderType,\n        uint256 price,\n        uint256 quantity,\n        uint256 cva,\n        uint256 mm,\n        uint256 lf,\n        uint256 maxInterestRate,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n\n        require(\n            quoteLayout.partyAPendingQuotes[msg.sender].length < maLayout.pendingQuotesValidLength,\n            \"PartyAFacet: Number of pending quotes out of range\"\n        );\n        require(symbolLayout.symbols[symbolId].isValid, \"PartyAFacet: Symbol is not valid\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n\n        LockedValues memory lockedValues = LockedValues(cva, mm, lf);\n        uint256 tradingPrice = orderType == OrderType.LIMIT ? price : upnlSig.price;\n        uint256 notionalValue = (quantity * tradingPrice) / 1e18;\n        require(\n            lockedValues.total() <= notionalValue,\n            \"PartyAFacet: Leverage can't be lower than one\"\n        );\n\n        require(\n            lockedValues.lf >=\n                (symbolLayout.symbols[symbolId].minAcceptablePortionLF * lockedValues.total()) /\n                    1e18,\n            \"PartyAFacet: LF is not enough\"\n        );\n\n        require(\n            lockedValues.total() >= symbolLayout.symbols[symbolId].minAcceptableQuoteValue,\n            \"PartyAFacet: Quote value is low\"\n        );\n        for (uint8 i = 0; i < partyBsWhiteList.length; i++) {\n            require(\n                partyBsWhiteList[i] != msg.sender,\n                \"PartyAFacet: Sender isn't allowed in partyBWhiteList\"\n            );\n        }\n\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, msg.sender, symbolId);\n\n        int256 availableBalance = LibAccount.partyAAvailableForQuote(upnlSig.upnl, msg.sender);\n        require(availableBalance > 0, \"PartyAFacet: Available balance is lower than zero\");\n        require(\n            uint256(availableBalance) >=\n                lockedValues.total() +\n                    ((quantity * tradingPrice * symbolLayout.symbols[symbolId].tradingFee) / 1e36),\n            \"PartyAFacet: insufficient available balance\"\n        );\n\n        // lock funds the in middle of way\n        accountLayout.pendingLockedBalances[msg.sender].add(lockedValues);\n        currentId = ++quoteLayout.lastId;\n        accountLayout.partyANonces[msg.sender] += 1;\n\n        // create quote.\n        Quote memory quote = Quote({\n            id: currentId,\n            partyBsWhiteList: partyBsWhiteList,\n            symbolId: symbolId,\n            positionType: positionType,\n            orderType: orderType,\n            openedPrice: 0,\n            requestedOpenPrice: price,\n            marketPrice: upnlSig.price,\n            quantity: quantity,\n            closedAmount: 0,\n            lockedValues: lockedValues,\n            initialLockedValues: lockedValues,\n            maxInterestRate: maxInterestRate,\n            partyA: msg.sender,\n            partyB: address(0),\n            quoteStatus: QuoteStatus.PENDING,\n            avgClosedPrice: 0,\n            requestedClosePrice: 0,\n            parentId: 0,\n            createTimestamp: block.timestamp,\n            modifyTimestamp: block.timestamp,\n            quantityToClose: 0,\n            deadline: deadline\n        });\n        quoteLayout.quoteIdsOf[msg.sender].push(currentId);\n        quoteLayout.partyAPendingQuotes[msg.sender].push(currentId);\n        quoteLayout.quotes[currentId] = quote;\n\n        LibQuote.receiveTradingFee(currentId);\n    }\n\n    function requestToCancelQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING || quote.quoteStatus == QuoteStatus.LOCKED,\n            \"PartyAFacet: Invalid state\"\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n\n        if (block.timestamp > quote.deadline) {\n            result = LibQuote.expireQuote(quoteId);\n        } else if (quote.quoteStatus == QuoteStatus.PENDING) {\n            quote.quoteStatus = QuoteStatus.CANCELED;\n            LibQuote.returnTradingFee(quoteId);\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyAPendingQuotes(quote);\n            result = QuoteStatus.CANCELED;\n        } else {\n            // Quote is"
    }
  ]
}