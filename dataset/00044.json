{
  "Title": "M-1: `currentStakeLimit` depletes faster in some adapters, due to actual amount spent less than the input `stakeAmount`",
  "Content": "# Issue M-1: `currentStakeLimit` depletes faster in some adapters, due to actual amount spent less than the input `stakeAmount` \n\nSource: https://github.com/sherlock-audit/2024-05-napier-update-judging/issues/8 \n\n## Found by \nVarun\\_05, blutorque\n## Summary\n## Vulnerability Detail\nIn the `BaseLSTAdapterUpgradeable.prefundedDeposit()`, the stake amount is capped to the `currentStakeLimit`.This is to prevent the buffer from being completed drained. \n\n```solidity\n      // Update the stake limit state in the storage\n      $.packedStakeLimitData.setStorageStakeLimitStruct(data.updatePrevStakeLimit(currentStakeLimit - stakeAmount)); \n```\n\nBefore the staking occur, its checks whether the `stakeAmount` exceed current stakeLimit, if not modify the new stake limit to `currentStakeLimit - stakeAmount`. The issue is, the actual amount going to be spent could possibly lower than the `stakeAmount`\n\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/BaseLSTAdapterUpgradeable.sol#L157-L158\n\n```solidity\n        // Actual amount of ETH spent may be less than the requested amount.\n        stakeAmount = _stake(stakeAmount); // stake amount can be 0\n```\n\nwhich means the stake limit that was updated previously does not account for the actual amount that we staked. I found one instance of adapters where this could possibly occur, \n\n**kelp/RsETHAdapter.sol**: Input `stakeAmount` modified to lower value if its [greater](https://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/kelp/RsETHAdapter.sol#L72-L75) than the stakeLimit of RsETHDeposit pool, \n\n\n## Impact\nWith every `prefundedDeposit` call where excess WETH is left to stake, the stake limit will deplete faster.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/BaseLSTAdapterUpgradeable.sol#L157\n## Tool used\nManual Review\n## Recommendation\nThe `_stake()` method do returns the actual spent amount, therefore I suggest to [update](https://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/BaseLSTAdapterUpgradeable.sol#L153-L158) the staking limit after the staking has been done. \n\n```solidity\n        /// INTERACT ///\n        // Deposit into the yield source\n        // Actual amount of ETH spent may be less than the requested amount.\n        stakeAmount = _stake(stakeAmount); // stake amount can be 0\n\n        /// WRITE ///\n        // Update the stake limit state in the storage\n        $.packedStakeLimitData.setStorageStakeLimitStruct(data.updatePrevStakeLimit(currentStakeLimit - stakeAmount));\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/napierfi/napier-v1/pull/219\n https://github.com/napierfi/napier-uups-adapters/pull/9\n\n\n**sherlock-admin2**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/369",
  "Code": [
    {
      "filename": "napier-uups-adapters/src/adapters/BaseLSTAdapterUpgradeable.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {StakeLimitTypes, StakeLimitUtils} from \"@napier/v1-tranche/utils/StakeLimitUtils.sol\";\nimport {LSTAdapterStorage} from \"../Structs.sol\";\nimport {WETH} from \"../Constants.sol\";\n\nimport {BaseLSTVaultUpgradeable} from \"./BaseLSTVaultUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable@4.9.3/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @notice Adapter for Liquid Staking Token (LST)\n/// @dev This adapter facilitates immediate ETH withdrawals without a waiting period.\n/// It maintains an ETH buffer to enable these withdrawals. The size of this buffer is determined\n/// by a specified desired buffer percentage. The maintenance of the buffer\n/// are handled by a designated account.\n/// @dev LST Adapter is NOT compatible with EIP4626 standard. We don't expect it to be used by other contracts other than Tranche.\nabstract contract BaseLSTAdapterUpgradeable is BaseLSTVaultUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeCast for uint256;\n    using StakeLimitTypes for StakeLimitTypes.Uint256Data;\n    using StakeLimitTypes for StakeLimitTypes.Data;\n    using StakeLimitUtils for StakeLimitTypes.Data;\n\n    error WithdrawalPending();\n    error InvalidWithdrawalAmount();\n    error NoPendingWithdrawal();\n\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    event StakingPaused();\n    event StakingUnpaused();\n    event ClaimWithdrawal(uint256 requestId, uint256 queueAmount);\n    event RequestWithdrawal(uint256 requestId, uint256 queueAmount);\n\n    /// @dev Adapter itself is the target token\n    function __BaseLSTAdapter_init(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) internal onlyInitializing {\n        __ReentrancyGuard_init();\n        __BaseLSTVault_init(_owner);\n\n        LSTAdapterStorage storage $ = _getStorage();\n        $.rebalancer = _rebalancer;\n        $.targetBufferPercentage = 0.1 * 1e18; // 10% desired buffer percentage\n\n        // Set the initial stake limit state\n        StakeLimitTypes.Data memory data = StakeLimitTypes.Data({\n            prevStakeBlockNumber: uint32(block.number),\n            prevStakeLimit: 0,\n            maxStakeLimitGrowthBlocks: 0,\n            maxStakeLimit: 0\n        });\n        $.packedStakeLimitData.setStorageStakeLimitStruct(\n            data.setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n    }\n\n    ////////////////////////////////////////////////////////\n    /// VIEW METHOD\n    ////////////////////////////////////////////////////////\n\n    function totalQueueEth() public view returns (uint256) {\n        return _getStorage().totalQueueEth;\n    }\n\n    function bufferEth() public view returns (uint256) {\n        return _getStorage().bufferEth;\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADAPTER METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Handles prefunded deposits\n    /// @return The amount of staked ETH\n    /// @return The amount of shares minted\n    function prefundedDeposit() external nonReentrant onlyTranche returns (uint256, uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        uint256 bufferEthCache = $.bufferEth; // cache storage reads\n        uint256 queueEthCache = $.totalQueueEth; // cache storage reads\n        uint256 assets = IWETH9(WETH).balanceOf(address(this)) - bufferEthCache; // amount of WETH deposited at this time\n        uint256 shares = previewDeposit(assets);\n\n        if (assets == 0) return (0, 0);\n        if (shares == 0) revert ZeroShares();\n\n        // Calculate the target buffer amount considering the user's deposit.\n        // bufferRatio is defined as the ratio of ETH balance to the total assets in the adapter in ETH.\n        // Formula:\n        // desiredBufferRatio = (totalQueueEth + bufferEth + assets - s) / (totalQueueEth + bufferEth + stakedEth + assets)\n        // Where:\n        // assets := Amount of ETH the user is depositing\n        // s := Amount of ETH to stake at this time, s <= bufferEth + assets.\n        //\n        // Thus, the formula can be simplified to:\n        // s = (totalQueueEth + bufferEth + assets) - (totalQueueEth + bufferEth + stakedEth + assets) * desiredBufferRatio\n        //   = (totalQueueEth + bufferEth + assets) - targetBufferEth\n        //\n        // Flow:\n        // If `s` <= 0, don't stake any ETH.\n        // If `s` < bufferEth + assets, stake `s` amount of ETH.\n        // If `s` >= bufferEth + assets, all available ETH can be staked in theory.\n        // However, we cap the stake amount. This is to prevent the buffer from being completely drained.\n        //\n        // Let `a` be the available amount of ETH in the buffer after the deposit. `a` is calculated as:\n        // a = (bufferEth + assets) - s\n        uint256 targetBufferEth = ((totalAssets() + assets) * $.targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        /// WRITE ///\n        _mint(msg.sender, shares);\n\n        uint256 availableEth = bufferEthCache + assets; // non-zero\n\n        // If the buffer is insufficient or staking is paused, doesn't stake any of the deposit\n        StakeLimitTypes.Data memory data = $.packedStakeLimitData.getStorageStakeLimitStruct();\n        if (targetBufferEth >= availableEth + queueEthCache || data.isStakingPaused()) {\n            /// WRITE ///\n            $.bufferEth = availableEth.toUint128();\n            return (assets, shares);\n        }\n\n        // Calculate the amount of ETH to stake\n        uint256 stakeAmount; // can be 0\n        unchecked {\n            stakeAmount = availableEth + queueEthCache - targetBufferEth; // non-zero, no underflow\n        }\n        // If the calculated stake amount exceeds the available ETH, simply assign the available ETH to the stake amount.\n        // Possible scenarios:\n        // - Target buffer percentage was changed to a lower value and there is a large withdrawal request pending.\n        // - There is a pending withdrawal request and the available ETH are not left in the buffer.\n        // - There is no pending withdrawal request and the available ETH are not left in the buffer.\n        if (stakeAmount > availableEth) {\n            // Note: Admins should be aware of this situation and take action to refill the buffer.\n            // - Pause staking to prevent further staking until the buffer is refilled\n            // - Update stake limit to a lower value\n            // - Increase the target buffer percentage\n            stakeAmount = availableEth; // All available ETH\n        }\n\n        // If the amount of ETH to stake exceeds the current stake limit, cap the stake amount.\n        // This is to prevent the buffer from being completely drained. This is not a complete solution.\n        uint256 currentStakeLimit = StakeLimitUtils.calculateCurrentStakeLimit(data); // can be 0 if the stake limit is exhausted\n        if (stakeAmount > currentStakeLimit) {\n            stakeAmount = currentStakeLimit;\n        }\n        /// WRITE ///\n        // Update the stake limit state in the storage\n        $.packedStakeLimitData.setStorageStakeLimitStruct(data.updatePrevStakeLimit(currentStakeLimit - stakeAmount));\n\n        /// INTERACT ///\n        // Deposit into the yield source\n        // Actual amount of ETH spent may be less than the requested amount.\n        stakeAmount = _stake(stakeAmount); // stake amount can be 0\n\n        /// WRITE ///\n        $.bufferEth = (availableEth - stakeAmount).toUint128(); // no underflow theoretically\n\n        return (assets, shares);\n    }\n\n    /// @notice Handles prefunded redemptions\n    /// @dev Withdraw from the buffer. If the buffer is insufficient, revert with an error\n    /// @param recipient The address to receive the redeemed WETH\n    /// @return The amount of redeemed WETH\n    /// @return The amount of shares burned\n    function prefundedRedeem(address recipient) external virtual onlyTranche returns (uint256, uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        uint256 shares = balanceOf(address(this));\n        uint256 assets = previewRedeem(shares);\n\n        if (shares == 0) return (0, 0);\n        if (assets == 0) revert ZeroAssets();\n\n        uint256 bufferEthCache = $.bufferEth;\n        // If the buffer is insufficient, shares cannot be redeemed immediately\n        // Need to wait for the withdrawal to be completed and the buffer to be refilled.\n        if (assets > bufferEthCache) revert InsufficientBuffer();\n\n        unchecked {\n            /// WRITE ///\n            // Reduce the buffer and burn the shares\n            $.bufferEth = (bufferEthCache - assets).toUint128(); // no underflow\n            _burn(address(this), shares);\n        }\n\n        /// INTERACT ///\n        IWETH9(WETH).transfer(recipient, assets);\n\n        return (assets, shares);\n    }\n\n    ////////////////////////////////////////////////////////\n    /// VIRTUAL METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Request a withdrawal of ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    /// @dev Reverts if the buffer is sufficient to cover the desired buffer percentage of the total assets\n    function requestWithdrawal() external virtual nonReentrant onlyRebalancer {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        uint256 targetBufferEth = (totalAssets() * $.targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        // If the buffer exceeds the target buffer, revert.\n        // If the buffer is insufficient, request a withdrawal to refill the buffer.\n        // note: use `>=` instead of `>` to prevent amount of ETH to withdraw to be 0\n        uint256 sum = $.bufferEth + $.totalQueueEth;\n        if (sum >= targetBufferEth) revert BufferTooLarge();\n\n        unchecked {\n            uint256 withdrawAmount = targetBufferEth - sum; // no underflow\n\n            /// WRITE & INTERACT ///\n            // Record the pending withdrawal request\n            // Request a withdrawal\n            (uint256 queueAmount, uint256 _requestId) = _requestWithdrawal(withdrawAmount);\n\n            if ($.queueWithdrawal[_requestId] != 0) revert WithdrawalPending();\n            $.totalQueueEth += queueAmount.toUint128();\n            $.queueWithdrawal[_requestId] = queueAmount;\n        }\n    }\n\n    /// @notice Request a withdrawal of all staked ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    function requestWithdrawalAll() external virtual;\n\n    /// @notice Claim the finized withdrawal request\n    /// @param _requestId The request Id of the withdrawal request\n    /// @dev This function is called by anyone\n    /// @dev Reverts if there is no pending withdrawal request\n    function claimWithdrawal(uint256 _requestId) external virtual;\n\n    /// @notice Request a withdrawal of the given amount of ETH from the yield source\n    /// @param withdrawAmount The amount of ETH to withdraw\n    /// @return queueAmount The amount of ETH withdrawn\n    /// @return requestId The request Id of the withdrawal request\n    function _requestWithdrawal(\n        uint256 withdrawAmount\n    ) internal virtual returns (uint256 queueAmount, uint256 requestId);\n\n    ////////////////////////////////////////////////////////\n    /// VIEW METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Returns the present buffer percentage in WAD. e.g) 10% => 0.1 * 1e18\n    function bufferPresentPercentage() external view override returns (uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        return (($.bufferEth + $.totalQueueEth) * BUFFER_PERCENTAGE_PRECISION) / totalAssets();\n    }\n\n    /// @notice Check staking state: whether it's paused or not\n    function isStakingPaused() external view returns (bool) {\n        return _getStorage().packedStakeLimitData.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n    /// @notice Returns how much Ether can be staked into a yield source (Lido, RocketPool, etc.)\n    /// @dev Special return values:\n    /// - 0 if staking is paused or if limit is exhausted.\n    function getCurrentStakeLimit() external view returns (uint256) {\n        StakeLimitTypes.Data memory data = _getStorage().packedStakeLimitData.getStorageStakeLimitStruct();\n        if (data.isStakingPaused()) {\n            return 0;\n        }\n        return data.calculateCurrentStakeLimit();\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADMIN METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Sets the staking rate limit\n    ///\n    /// ▲ Stake limit\n    /// │.....  .....   ........ ...            ....     ... Stake limit = max\n    /// │      .       .        .   .   .      .    . . .\n    /// │     .       .              . .  . . .      . .\n    /// │            .                .  . . .\n    /// │──────────────────────────────────────────────────> Time\n    /// │     ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n    ///\n    /// @dev Reverts if:\n    /// - `_maxStakeLimit` == 0\n    /// - `_maxStakeLimit` >= 2^96\n    /// - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n    /// - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n    ///\n    /// Emits `StakingLimitSet` event\n    ///\n    /// @param _maxStakeLimit max stake limit value\n    /// @param _stakeLimitIncreasePerBlock stake limit increase per single block\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external onlyOwner {\n        LSTAdapterStorage storage $ = _getStorage();\n        StakeLimitTypes.Data memory data = $.packedStakeLimitData.getStorageStakeLimitStruct();\n        /// WRITE ///\n        $.packedStakeLimitData.setStorageStakeLimitStruct(\n            data.setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    function pauseStaking() external onlyOwner {\n        LSTAdapterStorage storage $ = _getStorage();\n        StakeLimitTypes.Data memory data = $.packedStakeLimitData.getStorageStakeLimitStruct();\n        /// WRITE ///\n        $.packedStakeLimitData.setStorageStakeLimitStruct(data.setStakeLimitPauseState(true));\n        emit StakingPaused();\n    }\n\n    function unpauseStaking() external onlyOwner {\n        LSTAdapterStorage storage $ = _getStorage();\n        StakeLimitTypes.Data memory data = $.packedStakeLimitData.getStorageStakeLimitStruct();\n        /// WRITE ///\n        $.packedStakeLimitData.setStorageStakeLimitStruct(data.setStakeLimitPauseState(false));\n        emit StakingUnpaused();\n    }\n}"
    },
    {
      "filename": "napier-uups-adapters/src/adapters/kelp/RsETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\nimport {ILRTOracle} from \"./interfaces/ILRTOracle.sol\";\nimport {ILRTDepositPool} from \"./interfaces/ILRTDepositPool.sol\";\n\n// libs\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable@4.9.3/token/ERC20/IERC20Upgradeable.sol\";\nimport {LSTAdapterStorage} from \"../../Structs.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapterUpgradeable} from \"../BaseLSTAdapterUpgradeable.sol\";\n\n/// @notice RsETHAdapter - eRsETH (Napier rsETH Adapter)\n/// @notice rsETH is a Liquid Restaked Token (LRT) issued by Kelp DAO designed\n/// to offer liquidity to illiquid assets deposited into restaking platforms,\n///  such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking\ncontract RsETHAdapter is BaseLSTAdapterUpgradeable {\n    /// @notice LRTDepositPool\n    ILRTDepositPool constant RSETH_DEPOSIT_POOL = ILRTDepositPool(Constants.RSETH_DEPOSIT_POOL);\n\n    /// @notice LRTOracle\n    ILRTOracle constant RSETH_ORACLE = ILRTOracle(Constants.RSETH_ORACLE);\n\n    /// @notice rsETH\n    IERC20Upgradeable constant RSETH = IERC20Upgradeable(Constants.RSETH);\n\n    /// @notice RSETH referral id\n    string constant REFERRAL_ID = \"Napier-RsETHAdapter\";\n\n    error OnlyWETHOrRETH();\n    error InvariantViolation();\n    error MinAmountToDepositError();\n    error ProtocolPaused();\n\n    receive() external payable {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) public initializer {\n        __BaseLSTAdapter_init(_owner, _rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock);\n        __ERC20_init(\"Napier rsETH Adapter\", \"eRsETH\");\n    }\n\n    /// @notice Claim withdrawal from Kelp\n    /// @dev Kelp doesn't have claim functionality yet.\n    function claimWithdrawal(uint256) external pure override {\n        revert NotImplemented();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Rebalancer functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @notice Kelp allows ETH, ETHx, stETH or sfrxETH via LRTDepositPool.\n    /// @dev Kelp has a limit on the amount of ETH that can be staked.\n    /// @dev Need to check the current staking limit before staking to prevent DoS.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n\n        // Check LRTDepositPool stake limit\n        uint256 stakeLimit = RSETH_DEPOSIT_POOL.getAssetCurrentLimit(Constants.ETH);\n        if (stakeAmount > stakeLimit) {\n            // Cap stake amount\n            stakeAmount = stakeLimit;\n        }\n        // Check LRTDepositPool minAmountToDeposit\n        if (stakeAmount <= RSETH_DEPOSIT_POOL.minAmountToDeposit()) revert MinAmountToDepositError();\n        // Check paused of LRTDepositPool\n        if (RSETH_DEPOSIT_POOL.paused()) revert ProtocolPaused();\n\n        // Interact\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _rsETHAmt = RSETH.balanceOf(address(this));\n        RSETH_DEPOSIT_POOL.depositETH{value: stakeAmount}(0, REFERRAL_ID);\n        _rsETHAmt = RSETH.balanceOf(address(this)) - _rsETHAmt;\n\n        if (_rsETHAmt == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawal() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawalAll() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function _requestWithdrawal(uint256) internal pure override returns (uint256, uint256) {\n        revert NotImplemented();\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n        return $.totalQueueEth + $.bufferEth + (RSETH.balanceOf(address(this)) * RSETH_ORACLE.rsETHPrice()) / 1e18;\n    }\n}"
    },
    {
      "filename": "napier-uups-adapters/src/adapters/BaseLSTAdapterUpgradeable.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {StakeLimitTypes, StakeLimitUtils} from \"@napier/v1-tranche/utils/StakeLimitUtils.sol\";\nimport {LSTAdapterStorage} from \"../Structs.sol\";\nimport {WETH} from \"../Constants.sol\";\n\nimport {BaseLSTVaultUpgradeable} from \"./BaseLSTVaultUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable@4.9.3/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @notice Adapter for Liquid Staking Token (LST)\n/// @dev This adapter facilitates immediate ETH withdrawals without a waiting period.\n/// It maintains an ETH buffer to enable these withdrawals. The size of this buffer is determined\n/// by a specified desired buffer percentage. The maintenance of the buffer\n/// are handled by a designated account.\n/// @dev LST Adapter is NOT compatible with EIP4626 standard. We don't expect it to be used by other contracts other than Tranche.\nabstract contract BaseLSTAdapterUpgradeable is BaseLSTVaultUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeCast for uint256;\n    using StakeLimitTypes for StakeLimitTypes.Uint256Data;\n    using StakeLimitTypes for StakeLimitTypes.Data;\n    using StakeLimitUtils for StakeLimitTypes.Data;\n\n    error WithdrawalPending();\n    error InvalidWithdrawalAmount();\n    error NoPendingWithdrawal();\n\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    event StakingPaused();\n    event StakingUnpaused();\n    event ClaimWithdrawal(uint256 requestId, uint256 queueAmount);\n    event RequestWithdrawal(uint256 requestId, uint256 queueAmount);\n\n    /// @dev Adapter itself is the target token\n    function __BaseLSTAdapter_init(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) internal onlyInitializing {\n        __ReentrancyGuard_init();\n        __BaseLSTVault_init(_owner);\n\n        LSTAdapterStorage storage $ = _getStorage();\n        $.rebalancer = _rebalancer;\n        $.targetBufferPercentage = 0.1 * 1e18; // 10% desired buffer percentage\n\n        // Set the initial stake limit state\n        StakeLimitTypes.Data memory data = StakeLimitTypes.Data({\n            prevStakeBlockNumber: uint32(block.number),\n            prevStakeLimit: 0,\n            maxStakeLimitGrowthBlocks: 0,\n            maxStakeLimit: 0\n        });\n        $.packedStakeLimitData.setStorageStakeLimitStruct(\n            data.setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n    }\n\n    ////////////////////////////////////////////////////////\n    /// VIEW METHOD\n    ////////////////////////////////////////////////////////\n\n    function totalQueueEth() public view returns (uint256) {\n        return _getStorage().totalQueueEth;\n    }\n\n    function bufferEth() public view returns (uint256) {\n        return _getStorage().bufferEth;\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADAPTER METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Handles prefunded deposits\n    /// @return The amount of staked ETH\n    /// @return The amount of shares minted\n    function prefundedDeposit() external nonReentrant onlyTranche returns (uint256, uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        uint256 bufferEthCache = $.bufferEth; // cache storage reads\n        uint256 queueEthCache = $.totalQueueEth; // cache storage reads\n        uint256 assets = IWETH9(WETH).balanceOf(address(this)) - bufferEthCache; // amount of WETH deposited at this time\n        uint256 shares = previewDeposit(assets);\n\n        if (assets == 0) return (0, 0);\n        if (shares == 0) revert ZeroShares();\n\n        // Calculate the target buffer amount considering the user's deposit.\n        // bufferRatio is defined as the ratio of ETH balance to the total assets in the adapter in ETH.\n        // Formula:\n        // desiredBufferRatio = (totalQueueEth + bufferEth + assets - s) / (totalQueueEth + bufferEth + stakedEth + assets)\n        // Where:\n        // assets := Amount of ETH the user is depositing\n        // s := Amount of ETH to stake at this time, s <= bufferEth + assets.\n        //\n        // Thus, the formula can be simplified to:\n        // s = (totalQueueEth + bufferEth + assets) - (totalQueueEth + bufferEth + stakedEth + assets) * desiredBufferRatio\n        //   = (totalQueueEth + bufferEth + assets) - targetBufferEth\n        //\n        // Flow:\n        // If `s` <= 0, don't stake any ETH.\n        // If `s` < bufferEth + assets, stake `s` amount of ETH.\n        // If `s` >= bufferEth + assets, all available ETH can be staked in theory.\n        // However, we cap the stake amount. This is to prevent the buffer from being completely drained.\n        //\n        // Let `a` be the available amount of ETH in the buffer after the deposit. `a` is calculated as:\n        // a = (bufferEth + assets) - s\n        uint256 targetBufferEth = ((totalAssets() + assets) * $.targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        /// WRITE ///\n        _mint(msg.sender, shares);\n\n        uint256 availableEth = bufferEthCache + assets; // non-zero\n\n        // If the buffer is insufficient or staking is paused, doesn't stake any of the deposit\n        StakeLimitTypes.Data memory data = $.packedStakeLimitData.getStorageStakeLimitStruct();\n        if (targetBufferEth >= availableEth + queueEthCache || data.isStakingPaused()) {\n            /// WRITE ///\n            $.bufferEth = availableEth.toUint128();\n            return (assets, shares);\n        }\n\n        // Calculate the amount of ETH to stake\n        uint256 stakeAmount; // can be 0\n        unchecked {\n            stakeAmount = availableEth + queueEthCache - targetBufferEth; // non-zero, no underflow\n        }\n        // If the calculated stake amount exceeds the available ETH, simply assign the available ETH to the stake amount.\n        // Possible scenarios:\n        // - Target buffer percentage was changed to a lower value and there is a large withdrawal request pending.\n        // - There is a pending withdrawal request and the available ETH are not left in the buffer.\n        // - There is no pending withdrawal request and the available ETH are not left in the buffer.\n        if (stakeAmount > availableEth) {\n            // Note: Admins should be aware of this situation and take action to refill the buffer.\n            // - Pause staking to prevent further staking until the buffer is refilled\n            // - Update stake limit to a lower value\n            // - Increase the target buffer percentage\n            stakeAmount = availableEth; // All available ETH\n        }\n\n        // If the amount of ETH to stake exceeds the current stake limit, cap the stake amount.\n        // This is to prevent the buffer from being completely drained. This is not a complete solution.\n        uint256 currentStakeLimit = StakeLimitUtils.calculateCurrentStakeLimit(data); // can be 0 if the stake limit is exhausted\n        if (stakeAmount > currentStakeLimit) {\n            stakeAmount = currentStakeLimit;\n        }\n        /// WRITE ///\n        // Update the stake limit state in the storage\n        $.packedStakeLimitData.setStorageStakeLimitStruct(data.updatePrevStakeLimit(currentStakeLimit - stakeAmount));\n\n        /// INTERACT ///\n        // Deposit into the yield source\n        // Actual amount of ETH spent may be less than the requested amount.\n        stakeAmount = _stake(stakeAmount); // stake amount can be 0\n\n        /// WRITE ///\n        $.bufferEth = (availableEth - stakeAmount).toUint128(); // no underflow theoretically\n\n        return (assets, shares);\n    }\n\n    /// @notice Handles prefunded redemptions\n    /// @dev Withdraw from the buffer. If the buffer is insufficient, revert with an error\n    /// @param recipient The address to receive the redeemed WETH\n    /// @return The amount of redeemed WETH\n    /// @return The amount of shares burned\n    function prefundedRedeem(address recipient) external virtual onlyTranche returns (uint256, uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        uint256 shares = balanceOf(address(this));\n        uint256 assets = previewRedeem(shares);\n\n        if (shares == 0) return (0, 0);\n        if (assets == 0) revert ZeroAssets();\n\n        uint256 bufferEthCache = $.bufferEth;\n        // If the buffer is insufficient, shares cannot be redeemed immediately\n        // Need to wait for the withdrawal to be completed and the buffer to be refilled.\n        if (assets > bufferEthCache) revert InsufficientBuffer();\n\n        unchecked {\n            /// WRITE ///\n            // Reduce the buffer and burn the shares\n            $.bufferEth = (bufferEthCache - assets).toUint128(); // no underflow\n            _burn(address(this), shares);\n        }\n\n        /// INTERACT ///\n        IWETH9(WETH).transfer(recipient, assets);\n\n        return (assets, shares);\n    }\n\n    ////////////////////////////////////////////////////////\n    /// VIRTUAL METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Request a withdrawal of ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    /// @dev Reverts if the buffer is sufficient to cover the desired buffer percentage of the total assets\n    function requestWithdrawal() external virtual nonReentrant onlyRebalancer {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        uint256 targetBufferEth = (totalAssets() * $.targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        // If the buffer exceeds the target buffer, revert.\n        // If the buffer is insufficient, request a withdrawal to refill the buffer.\n        // note: use `>=` instead of `>` to prevent amount of ETH to withdraw to be 0\n        uint256 sum = $.bufferEth + $.totalQueueEth;\n        if (sum >= targetBufferEth) revert BufferTooLarge();\n\n        unchecked {\n            uint256 withdrawAmount = targetBufferEth - sum; // no underflow\n\n            /// WRITE & INTERACT ///\n            // Record the pending withdrawal request\n            // Request a withdrawal\n            (uint256 queueAmount, uint256 _requestId) = _requestWithdrawal(withdrawAmount);\n\n            if ($.queueWithdrawal[_requestId] != 0) revert WithdrawalPending();\n            $.totalQueueEth += queueAmount.toUint128();\n            $.queueWithdrawal[_requestId] = queueAmount;\n        }\n    }\n\n    /// @notice Request a withdrawal of all staked ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    function requestWithdrawalAll() external virtual;\n\n    /// @notice Claim the finized withdrawal request\n    /// @param _requestId The request Id of the withdrawal request\n    /// @dev This function is called by anyone\n    /// @dev Reverts if there is no pending withdrawal request\n    function claimWithdrawal(uint256 _requestId) external virtual;\n\n    /// @notice Request a withdrawal of the given amount of ETH from the yield source\n    /// @param withdrawAmount The amount of ETH to withdraw\n    /// @return queueAmount The amount of ETH withdrawn\n    /// @return requestId The request Id of the withdrawal request\n    function _requestWithdrawal(\n        uint256 withdrawAmount\n    ) internal virtual returns (uint256 queueAmount, uint256 requestId);\n\n    ////////////////////////////////////////////////////////\n    /// VIEW METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Returns the present buffer percentage in WAD. e.g) 10% => 0.1 * 1e18\n    function bufferPresentPercentage() external view override returns (uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        return (($.bufferEth + $.totalQueueEth) * BUFFER_PERCENTAGE_PRECISION) / totalAssets();\n    }\n\n    /// @notice Check staking state: whether it's paused or not\n    function isStakingPaused() external view returns (bool) {\n        return _getStorage().packedStakeLimitData.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n    /// @notice Returns how much Ether can be staked into a yield source (Lido, RocketPool, etc.)\n    /// @dev Special return values:\n    /// - 0 if staking is paused or if limit is exhausted.\n    function getCurrentStakeLimit() external view returns (uint256) {\n        StakeLimitTypes.Data memory data = _getStorage().packedStakeLimitData.getStorageStakeLimitStruct();\n        if (data.isStakingPaused()) {\n            return 0;\n        }\n        return data.calculateCurrentStakeLimit();\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADMIN METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Sets the staking rate limit\n    ///\n    /// ▲ Stake limit\n    /// │.....  .....   ........ ...            ....     ... Stake limit = max\n    /// │      .       .        .   .   .      .    . . .\n    /// │     .       .              . .  . . .      . .\n    /// │"
    }
  ]
}