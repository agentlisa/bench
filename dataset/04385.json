{
  "Title": "[M03] Function put allows storing invalid signed data",
  "Content": "The [`put` function](https://github.com/compound-finance/open-oracle/blob/e7a928334e5e454a88eec38e4ee1be5ee3b13f08/contracts/OpenOraclePriceData.sol#L34) of the `OpenOraclePriceData` is used to submit signed price data. It first recovers the signing address from the given signature and message by means of the inherited [`source` function](https://github.com/compound-finance/open-oracle/blob/e7a928334e5e454a88eec38e4ee1be5ee3b13f08/contracts/OpenOraclePriceData.sol#L36), and then uses the recovered address (i.e., the source) to update the price and timestamp under the corresponding source address and asset symbol.\n\n\nThe inherited [`source` function](https://github.com/compound-finance/open-oracle/blob/e7a928334e5e454a88eec38e4ee1be5ee3b13f08/contracts/OpenOracleData.sol#L38) uses the [`ecrecover` precompile](https://github.com/compound-finance/open-oracle/blob/e7a928334e5e454a88eec38e4ee1be5ee3b13f08/contracts/OpenOracleData.sol#L41) to recover the signing address. If there is an error during the recovering process, `ecrecover` will return the zero address (as stated in [its documentation](https://solidity.readthedocs.io/en/v0.5.12/units-and-global-variables.html#mathematical-and-cryptographic-functions)). Since the returned address is never validated in the `put` function, this could lead to submitting invalid data with a successful transaction. While this does not pose a security risk, since data would be written in an entry corresponding to the zero address, the function should fail earlier to favor a more predictable behavior.\n\n\nConsider ensuring the address returned by the `source` function is not the zero address before continuing execution in the `put` function.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/OpenOraclePriceData.sol",
      "content": "pragma solidity ^0.5.12;\n\nimport \"./OpenOracleData.sol\";\n\n/**\n * @title The Open Oracle Price Data Contract\n * @notice Values stored in this contract should represent a USD price with 6 decimals precision\n * @author Compound Labs, Inc.\n */\ncontract OpenOraclePriceData is OpenOracleData {\n    ///@notice The event emitted when a source writes to its storage\n    event Write(address indexed source, string key, uint64 timestamp, uint64 value);\n    ///@notice The event emitted when the timestamp on a price is invalid and it is not written to storage\n    event NotWritten(uint64 priorTimestamp, uint256 messageTimestamp, uint256 blockTimestamp);\n\n    ///@notice The fundamental unit of storage for a reporter source\n    struct Datum {\n        uint64 timestamp;\n        uint64 value;\n    }\n\n    /**\n     * @notice The most recent authenticated data from all sources\n     * @dev This is private because dynamic mapping keys preclude auto-generated getters.\n     */\n    mapping(address => mapping(string => Datum)) private data;\n\n    /**\n     * @notice Write a bunch of signed datum to the authenticated storage mapping\n     * @param message The payload containing the timestamp, and (key, value) pairs\n     * @param signature The cryptographic signature of the message payload, authorizing the source to write\n     * @return The keys that were written\n     */\n    function put(bytes calldata message, bytes calldata signature) external returns (string memory) {\n        // Recover the source address\n        address source = source(message, signature);\n\n        // Decode the message and check the kind\n        (string memory kind, uint64 timestamp, string memory key, uint64 value) = abi.decode(message, (string, uint64, string, uint64));\n        require(keccak256(abi.encodePacked(kind)) == keccak256(abi.encodePacked(\"prices\")), \"Kind of data must be 'prices'\");\n\n        // Only update if newer than stored, according to source\n        Datum storage prior = data[source][key];\n        if (timestamp > prior.timestamp && timestamp < block.timestamp + 60 minutes) {\n            data[source][key] = Datum(timestamp, value);\n            emit Write(source, key, timestamp, value);\n        } else {\n            emit NotWritten(prior.timestamp, timestamp, block.timestamp);\n        }\n\n        return key;\n    }\n\n    /**\n     * @notice Read a single key from an authenticated source\n     * @param source The verifiable author of the data\n     * @param key The selector for the value to return\n     * @return The claimed Unix timestamp for the data and the price value (defaults to (0, 0))\n     */\n    function get(address source, string calldata key) external view returns (uint64, uint64) {\n        Datum storage datum = data[source][key];\n        return (datum.timestamp, datum.value);\n    }\n\n    /**\n     * @notice Read only the value for a single key from an authenticated source\n     * @param source The verifiable author of the data\n     * @param key The selector for the value to return\n     * @return The price value (defaults to 0)\n     */\n    function getPrice(address source, string calldata key) external view returns (uint64) {\n        return data[source][key].value;\n    }\n}"
    },
    {
      "filename": "contracts/OpenOracleData.sol",
      "content": "pragma solidity ^0.5.12;\npragma experimental ABIEncoderV2;\n\n/**\n * @title The Open Oracle Data Base Contract\n * @author Compound Labs, Inc.\n */\ncontract OpenOracleData {\n    /**\n     * @notice The event emitted when a source writes to its storage\n     */\n    //event Write(address indexed source, <Key> indexed key, string kind, uint64 timestamp, <Value> value);\n\n    /**\n     * @notice Write a bunch of signed datum to the authenticated storage mapping\n     * @param message The payload containing the timestamp, and (key, value) pairs\n     * @param signature The cryptographic signature of the message payload, authorizing the source to write\n     * @return The keys that were written\n     */\n    //function put(bytes calldata message, bytes calldata signature) external returns (<Key> memory);\n\n    /**\n     * @notice Read a single key with a pre-defined type signature from an authenticated source\n     * @param source The verifiable author of the data\n     * @param key The selector for the value to return\n     * @return The claimed Unix timestamp for the data and the encoded value (defaults to (0, 0x))\n     */\n    //function get(address source, <Key> key) external view returns (uint, <Value>);\n\n    /**\n     * @notice Recovers the source address which signed a message\n     * @dev Comparing to a claimed address would add nothing,\n     *  as the caller could simply perform the recover and claim that address.\n     * @param message The data that was presumably signed\n     * @param signature The fingerprint of the data + private key\n     * @return The source address which signed the message, presumably\n     */\n    function source(bytes memory message, bytes memory signature) public pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = abi.decode(signature, (bytes32, bytes32, uint8));\n        bytes32 hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(message)));\n        return ecrecover(hash, v, r, s);\n    }\n}"
    }
  ]
}