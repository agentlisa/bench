{
  "Title": "Discontinuous Reward Pattern",
  "Content": "Rebases occur by [discontinuously increasing](https://github.com/mountainprotocol/tokens/blob/d548aa6f037d9c7ed653a8004f83949b70133c7a/contracts/USDM.sol#L424) all user balances. This implies that a USDM token purchased immediately before the rebase transaction is worth more than one purchased immediately afterwards. In principle, this means that the price of USDM tokens should follow a [sawtooth wave](https://en.wikipedia.org/wiki/Sawtooth_wave).\n\n\nIn practice, the effect size will be minimal because the daily interest rate is expected to be less than 0.02%. Nevertheless, we believe it is worth considering because:\n\n\n* The expected impact depends on external factors, such as the actual yield, the availability of Ethereum, the reliability and availability of Mountain Protocol's external infrastructure, any events that require pausing the contract, etc.\n* Any discontinuity creates front-running, back-running or transaction delay opportunities. In this case, a transfer of a fixed number of USDM is worth slightly less if executed after the update. Similarly, anyone who wants to spend an allowance would get more value if they spent it before the update. Even with a small effect size, it could introduce a new market behavior.\n\n\nConsider whether it is worth the extra complexity to smooth the discontinuity. This would involve distributing the daily yield over time rather than in one step.\n\n\n***Update:** Acknowledged, not resolved. The Mountain Protocol team stated:*\n\n\n\n> *Given the minimal effect size, smoothing the rebases is not worth the extra complexity. However, we will describe the edge case in our risk documentation.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/USDM.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {CountersUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ECDSAUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\nimport {EIP712Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {IERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\";\n\ncontract USDM is\n    IERC20Upgradeable,\n    AccessControlUpgradeable,\n    PausableUpgradeable,\n    UUPSUpgradeable,\n    IERC20PermitUpgradeable,\n    EIP712Upgradeable\n{\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    string private _name;\n    string private _symbol;\n    uint256 private _totalShares;\n    uint256 private constant _BASE = 1e18;\n    /**\n     * @dev rewardMultiplier represents a coefficient used in reward calculation logic.\n     * The value is represented with 18 decimal places for precision.\n     */\n    uint256 public rewardMultiplier;\n\n    mapping(address => uint256) private _shares;\n    mapping(address => bool) private _blocklist;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n    bytes32 public constant BLOCKLIST_ROLE = keccak256(\"BLOCKLIST_ROLE\");\n    bytes32 public constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n    bytes32 public constant UPGRADE_ROLE = keccak256(\"UPGRADE_ROLE\");\n    bytes32 public constant PAUSE_ROLE = keccak256(\"PAUSE_ROLE\");\n\n    event AccountBlocklisted(address indexed addr);\n    event AccountUnblocklisted(address indexed addr);\n    event RewardMultiplier(uint256 indexed value);\n\n    /**\n     * @notice Initializes the contract.\n     * @param name_ The name of the token.\n     * @param symbol_ The symbol of the token.\n     * @param initialSupply The initial amount of tokens for the contract creator.\n     */\n    function initialize(string memory name_, string memory symbol_, uint256 initialSupply) external initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _setRewardMultiplier(_BASE);\n\n        __AccessControl_init();\n        __Pausable_init();\n        __UUPSUpgradeable_init();\n        __EIP712_init(name_, \"1\");\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _mint(_msgSender(), initialSupply);\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Ensures that only accounts with UPGRADE_ROLE can upgrade the contract.\n     */\n    function _authorizeUpgrade(address) internal override onlyRole(UPGRADE_ROLE) {}\n\n    /**\n     * @notice Returns the name of the token.\n     * @return A string representing the token's name.\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @notice Returns the symbol of the token.\n     * @return A string representing the token's symbol.\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @notice Returns the number of decimals the token uses.\n     * @dev This value is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including.\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     * @return The number of decimals (18)\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @notice Converts an amount of tokens to shares.\n     * @param amount The amount of tokens to convert.\n     * @return The equivalent amount of shares.\n     */\n    function convertToShares(uint256 amount) public view returns (uint256) {\n        return (amount * _BASE) / rewardMultiplier;\n    }\n\n    /**\n     * @notice Converts an amount of shares to tokens.\n     * @param shares The amount of shares to convert.\n     * @return The equivalent amount of tokens.\n     */\n    function convertToAmount(uint256 shares) public view returns (uint256) {\n        return (shares * rewardMultiplier) / _BASE;\n    }\n\n    /**\n     * @notice Returns the total amount of shares.\n     * @return The total amount of shares.\n     */\n    function totalShares() external view returns (uint256) {\n        return _totalShares;\n    }\n\n    /**\n     * @notice Returns the total supply of tokens.\n     * @return The total supply of tokens.\n     */\n    function totalSupply() external view returns (uint256) {\n        return convertToAmount(_totalShares);\n    }\n\n    /**\n     * @notice Returns the amount of shares owned by the account.\n     * @param account The account to check.\n     * @return The amount of shares owned by the account.\n     */\n    function sharesOf(address account) public view returns (uint256) {\n        return _shares[account];\n    }\n\n    /**\n     * @notice Returns the balance of the specified address.\n     * @dev Balances are dynamic and equal the `account`'s share in the amount of the\n     * total reserves controlled by the protocol. See `sharesOf`.\n     * @param account The address to query the balance of.\n     * @return The balance of the specified address.\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return convertToAmount(sharesOf(account));\n    }\n\n    /**\n     * @dev Internal function that mints a specified number of tokens to the given address.\n     * Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - Only users with MINTER_ROLE can call this function.\n     * - `account` cannot be the zero address.\n     * @param to The address to which tokens will be minted.\n     * @param amount The number of tokens to mint.\n     */\n    function _mint(address to, uint256 amount) private {\n        require(to != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), to, amount);\n\n        uint256 shares = convertToShares(amount);\n        _totalShares += shares;\n\n        unchecked {\n            // Overflow not possible: shares + shares amount is at most totalShares + shares amount\n            // which is checked above.\n            _shares[to] += shares;\n        }\n\n        _afterTokenTransfer(address(0), to, amount);\n    }\n\n    /**\n     * @notice Creates new tokens to the specified address.\n     * @dev See {_mint}.\n     * @param to The address to mint the tokens to.\n     * @param amount The amount of tokens to mint.\n     */\n    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Burns `amount` tokens from `account`, reducing the total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - Only users with BURNER_ROLE can call this function.\n     * - The contract must not be paused.\n     * @param account The address from which tokens will be burned.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address account, uint256 amount) private {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 shares = convertToShares(amount);\n\n        uint256 accountShares = sharesOf(account);\n        require(accountShares >= shares, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _shares[account] = accountShares - shares;\n            // Overflow not possible: amount <= accountShares <= totalShares.\n            _totalShares -= shares;\n        }\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @notice Destroys a specified amount of tokens from the given address.\n     * @dev See {_burn}.\n     * @param from The address from which tokens will be burned.\n     * @param amount The amount of tokens to burn.\n     */\n    function burn(address from, uint256 amount) external onlyRole(BURNER_ROLE) {\n        _burn(from, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfer(address from, address /* to */, uint256 /* amount */) private view {\n        // Each blocklist check is an SLOAD, which is gas intensive.\n        // We only block sender not receiver, so we don't tax every user\n        require(!isBlocklisted(from), \"Address is blocklisted\");\n        // Useful for scenarios such as preventing trades until the end of an evaluation\n        // period, or having an emergency switch for freezing all token transfers in the\n        // event of a large bug.\n        require(!paused(), \"Transfers not allowed while paused\");\n    }\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) private {\n        emit Transfer(from, to, amount);\n    }\n\n    /**\n     * @dev Internal function that transfers a specified number of tokens from one address to another.\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     * @param from The address from which tokens will be transferred.\n     * @param to The address to which tokens will be transferred.\n     * @param amount The number of tokens to transfer.\n     */\n    function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 shares = convertToShares(amount);\n        uint256 fromShares = _shares[from];\n        require(fromShares >= shares, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _shares[from] = fromShares - shares;\n            // Overflow not possible: the sum of all shares is capped by totalShares, and the sum is preserved by\n            // decrementing then incrementing.\n            _shares[to] += shares;\n        }\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /**\n     * @notice Transfers a specified number of tokens from the caller's address to the recipient.\n     * @dev See {_transfer}.\n     * @param to The address to which tokens will be transferred.\n     * @param amount The number of tokens to transfer.\n     * @return A boolean value indicating whether the operation succeeded.\n     */\n    function transfer(address to, uint256 amount) external returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Internal function that blocklists the specified address.\n     * @param account The address to blocklist.\n     */\n    function _blocklistAccount(address account) private {\n        require(!_blocklist[account], \"Address already blocklisted\");\n        _blocklist[account] = true;\n        emit AccountBlocklisted(account);\n    }\n\n    /**\n     * @dev Internal function that removes the specified address from the blocklist.\n     * @param account The address to remove from the blocklist.\n     */\n    function _unblocklistAccount(address account) private {\n        require(_blocklist[account], \"Address is not blocklisted\");\n        _blocklist[account] = false;\n        emit AccountUnblocklisted(account);\n    }\n\n    /**\n     * @notice Blocklists multiple accounts at once.\n     * @dev This function can only be called by an account with BLOCKLIST_ROLE.\n     * @param addresses An array of addresses to be blocklisted.\n     */\n    function blocklistAccounts(address[] calldata addresses) external onlyRole(BLOCKLIST_ROLE) {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            _blocklistAccount(addresses[i]);\n        }\n    }\n\n    /**\n     * @notice Removes multiple accounts from the blocklist at once.\n     * @dev This function can only be called by an account with BLOCKLIST_ROLE.\n     * @param addresses An array of addresses to be removed from the blocklist.\n     */\n    function unblocklistAccounts(address[] calldata addresses) external onlyRole(BLOCKLIST_ROLE) {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            _unblocklistAccount(addresses[i]);\n        }\n    }\n\n    /**\n     * @notice Checks if the specified address is blocklisted.\n     * @param account The address to check.\n     * @return A boolean value indicating whether the address is blocklisted.\n     */\n    function isBlocklisted(address account) public view returns (bool) {\n        return _blocklist[account];\n    }\n\n    /**\n     * @notice Pauses token transfers and other operations.\n     * @dev This function can only be called by an account with PAUSE_ROLE.\n     * @dev Inherits the _pause function from @openzeppelin/PausableUpgradeable contract.\n     */\n    function pause() external onlyRole(PAUSE_ROLE) {\n        super._pause();\n    }\n\n    /**\n     * @notice Unpauses token transfers and other operations.\n     * @dev This function can only be called by an account with PAUSE_ROLE.\n     * @dev Inherits the _unpause function from @openzeppelin/PausableUpgradeable contract.\n     */\n    function unpause() external onlyRole(PAUSE_ROLE) {\n        super._unpause();\n    }\n\n    /**\n     * @dev Internal function to set the reward multiplier.\n     * @param _rewardMultiplier The new reward multiplier.\n     */\n    function _setRewardMultiplier(uint256 _rewardMultiplier) private {\n        require(_rewardMultiplier >= 1 ether, \"Invalid reward multiplier\");\n        rewardMultiplier = _rewardMultiplier;\n\n        emit RewardMultiplier(rewardMultiplier);\n    }\n\n    /**\n     * @notice Sets the reward multiplier.\n     * @dev This function can only be called by ADMIN_ROLE.\n     * @param _rewardMultiplier The new reward multiplier.\n     */\n    function setRewardMultiplier(uint256 _rewardMultiplier) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setRewardMultiplier(_rewardMultiplier);\n    }\n\n    /**\n     * @notice Adds the given amount to the current reward multiplier.\n     * @dev This function can only be called by an account with ORACLE_ROLE.\n     * @param _rewardMultiplier The new reward multiplier.\n     */\n    function addRewardMultiplier(uint256 _rewardMultiplier) external onlyRole(ORACLE_ROLE) {\n        require(_rewardMultiplier > 0, \"Invalid reward multiplier\");\n\n        _setRewardMultiplier(rewardMultiplier + _rewardMultiplier);\n    }\n\n    /**\n     * @dev Internal function to set `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This private function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @notice Approves an allowance for a spender.\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice Returns the remaining amount of tokens that `spender` is allowed to spend on behalf of `owner`.\n     * @dev See {IERC20-allowance}.\n     * @param owner The address of the token owner.\n     * @param spender The address of the spender.\n     * @return The remaining allowance of the spender on behalf of the owner.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) private {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Moves tokens from an address to another one using the allowance mechanism.\n     * @dev See {IERC20-transferFrom}.\n     *\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. This allows applications to reconstruct the allowance\n     * for all accounts just by listening to said events.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     * @param from The address from which tokens will be transferred.\n     * @param to The address to which tokens will be transferred.\n     * @param amount The number of tokens to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice Increases the allowance granted to spender by the caller.\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @notice Decreases the allowance granted to spender by the caller.\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Returns the EIP-712 DOMAIN_SEPARATOR.\n     * @return A bytes32 value representing the EIP-712 DOMAIN_SEPARATOR.\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @notice Returns the current nonce for the given owner address.\n     * @param owner The address whose nonce is to be retrieved.\n     * @return The current nonce as a uint256 value.\n     */\n    function nonces(address owner) external view returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev Internal function that increments and returns the current nonce for a given owner address.\n     * @param owner The address whose nonce is to be incremented.\n     */\n    function _useNonce(address owner) private returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @notice Allows an owner to approve a spender with a one-time signature, bypassing the need for a transaction.\n     * @dev Uses the EIP-2612 standard.\n     * @param owner The address of the token owner.\n     * @param spender The address of the spender.\n     * @param value The amount of tokens to be approved.\n     * @param deadline The expiration time of the signature, specified as a Unix timestamp.\n     * @param v The recovery byte of the signature.\n     * @param r The first 32 bytes of the signature.\n     * @param s The second 32 bytes of the signature.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}"
    }
  ]
}