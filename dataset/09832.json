{
  "Title": "[M-06] Simple interest calculation is not exact",
  "Content": "\n<https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts%2Fmoney-market-contracts%2Fcontracts%2Fmarket%2Fsrc%2Fborrow.rs#L304>\n\nThe borrow rate uses a simple interest formula to compute the accrued debt, instead of a compounding formula.\n\n```rust\npub fn compute_interest_raw(\n    state: &mut State,\n    block_height: u64,\n    balance: Uint256,\n    aterra_supply: Uint256,\n    borrow_rate: Decimal256,\n    target_deposit_rate: Decimal256,\n) {\n  // @audit simple interest\n    let passed_blocks = Decimal256::from_uint256(block_height - state.last_interest_updated);\n\n    let interest_factor = passed_blocks * borrow_rate;\n    let interest_accrued = state.total_liabilities * interest_factor;\n    // ...\n}\n```\n\nThis means the actual borrow rate and interest for suppliers depend on how often updates are made.<br>\nThis difference should be negligible in highly active markets, but it could lead to a lower borrow rate in low-activity markets, leading to suppliers losing out on interest.\n\n### Recommended Mitigation Steps\n\nEnsure that the markets are accrued regularly, or switch to a compound interest formula (which has a higher computational cost due to exponentiation, but can be approximated, see Aave).\n\n**[Alex the Entreprenerd (triage) commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/41#issuecomment-1207281281):**\n > Without Code and explanation, I'm skeptical of Med (loss of yield), as it could just be dust amount, provided that interest is compounded roughly 1 per month or similar (see compound interest math, and how `e` limits max autocompounds to dust variation)\n> \n> Either way, the observation is correct.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-anchor-contest",
  "Code": [
    {
      "filename": "contracts%2Fmoney-market-contracts%2Fcontracts%2Fmarket%2Fsrc%2Fborrow.rs",
      "content": "use anchor_token::distributor::ExecuteMsg as FaucetExecuteMsg;\nuse cosmwasm_bignumber::{Decimal256, Uint256};\nuse cosmwasm_std::{\n    attr, to_binary, Addr, BankMsg, Coin, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Response,\n    StdResult, WasmMsg,\n};\nuse moneymarket::interest_model::BorrowRateResponse;\nuse moneymarket::market::{BorrowerInfoResponse, BorrowerInfosResponse};\nuse moneymarket::overseer::BorrowLimitResponse;\nuse moneymarket::querier::{deduct_tax, query_balance, query_supply};\n\nuse crate::deposit::compute_exchange_rate_raw;\nuse crate::error::ContractError;\nuse crate::querier::{query_borrow_limit, query_borrow_rate, query_target_deposit_rate};\nuse crate::state::{\n    read_borrower_info, read_borrower_infos, read_config, read_state, store_borrower_info,\n    store_state, BorrowerInfo, Config, State,\n};\n\npub fn borrow_stable(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    borrow_amount: Uint256,\n    to: Option<Addr>,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n\n    let mut state: State = read_state(deps.storage)?;\n\n    let borrower = info.sender;\n    let borrower_raw = deps.api.addr_canonicalize(borrower.as_str())?;\n    let mut liability: BorrowerInfo = read_borrower_info(deps.storage, &borrower_raw);\n\n    // Compute interest\n    compute_interest(deps.as_ref(), &config, &mut state, env.block.height, None)?;\n    compute_borrower_interest(&state, &mut liability);\n\n    // Compute ANC reward\n    compute_reward(&mut state, env.block.height);\n    compute_borrower_reward(&state, &mut liability);\n\n    let overseer = deps.api.addr_humanize(&config.overseer_contract)?;\n    let borrow_limit_res: BorrowLimitResponse = query_borrow_limit(\n        deps.as_ref(),\n        overseer,\n        borrower.clone(),\n        Some(env.block.time.seconds()),\n    )?;\n\n    if borrow_limit_res.borrow_limit < borrow_amount + liability.loan_amount {\n        return Err(ContractError::BorrowExceedsLimit(\n            borrow_limit_res.borrow_limit.into(),\n        ));\n    }\n\n    let current_balance = query_balance(\n        deps.as_ref(),\n        env.contract.address,\n        config.stable_denom.to_string(),\n    )?;\n\n    // Assert borrow amount\n    assert_max_borrow_factor(&config, &state, current_balance, borrow_amount)?;\n\n    liability.loan_amount += borrow_amount;\n    state.total_liabilities += Decimal256::from_uint256(borrow_amount);\n    store_state(deps.storage, &state)?;\n    store_borrower_info(deps.storage, &borrower_raw, &liability)?;\n\n    Ok(Response::new()\n        .add_message(CosmosMsg::Bank(BankMsg::Send {\n            to_address: to.unwrap_or_else(|| borrower.clone()).to_string(),\n            amount: vec![deduct_tax(\n                deps.as_ref(),\n                Coin {\n                    denom: config.stable_denom,\n                    amount: borrow_amount.into(),\n                },\n            )?],\n        }))\n        .add_attributes(vec![\n            attr(\"action\", \"borrow_stable\"),\n            attr(\"borrower\", borrower),\n            attr(\"borrow_amount\", borrow_amount),\n        ]))\n}\n\npub fn repay_stable_from_liquidation(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    borrower: Addr,\n    prev_balance: Uint256,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n    if config.overseer_contract != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let cur_balance: Uint256 = query_balance(\n        deps.as_ref(),\n        env.contract.address.clone(),\n        config.stable_denom.to_string(),\n    )?;\n\n    // override env\n    let mut info = info;\n\n    info.sender = borrower;\n    info.funds = vec![Coin {\n        denom: config.stable_denom,\n        amount: (cur_balance - prev_balance).into(),\n    }];\n\n    repay_stable(deps, env, info)\n}\n\npub fn repay_stable(deps: DepsMut, env: Env, info: MessageInfo) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n\n    // Check stable denom deposit\n    let amount: Uint256 = info\n        .funds\n        .iter()\n        .find(|c| c.denom == config.stable_denom)\n        .map(|c| Uint256::from(c.amount))\n        .unwrap_or_else(Uint256::zero);\n\n    // Cannot deposit zero amount\n    if amount.is_zero() {\n        return Err(ContractError::ZeroRepay(config.stable_denom));\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n\n    let borrower = info.sender;\n    let borrower_raw = deps.api.addr_canonicalize(borrower.as_str())?;\n    let mut liability: BorrowerInfo = read_borrower_info(deps.storage, &borrower_raw);\n\n    // Compute interest\n    compute_interest(\n        deps.as_ref(),\n        &config,\n        &mut state,\n        env.block.height,\n        Some(amount),\n    )?;\n    compute_borrower_interest(&state, &mut liability);\n\n    // Compute ANC reward\n    compute_reward(&mut state, env.block.height);\n    compute_borrower_reward(&state, &mut liability);\n\n    let repay_amount: Uint256;\n    let mut messages: Vec<CosmosMsg> = vec![];\n    if liability.loan_amount < amount {\n        repay_amount = liability.loan_amount;\n        liability.loan_amount = Uint256::zero();\n\n        // Payback left repay amount to sender\n        messages.push(CosmosMsg::Bank(BankMsg::Send {\n            to_address: borrower.to_string(),\n            amount: vec![deduct_tax(\n                deps.as_ref(),\n                Coin {\n                    denom: config.stable_denom,\n                    amount: (amount - repay_amount).into(),\n                },\n            )?],\n        }));\n    } else {\n        repay_amount = amount;\n        liability.loan_amount = liability.loan_amount - repay_amount;\n    }\n\n    state.total_liabilities = state.total_liabilities - Decimal256::from_uint256(repay_amount);\n\n    store_borrower_info(deps.storage, &borrower_raw, &liability)?;\n    store_state(deps.storage, &state)?;\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        attr(\"action\", \"repay_stable\"),\n        attr(\"borrower\", borrower),\n        attr(\"repay_amount\", repay_amount),\n    ]))\n}\n\npub fn claim_rewards(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    to: Option<Addr>,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n    let mut state: State = read_state(deps.storage)?;\n\n    let borrower = info.sender;\n    let borrower_raw = deps.api.addr_canonicalize(borrower.as_str())?;\n    let mut liability: BorrowerInfo = read_borrower_info(deps.storage, &borrower_raw);\n\n    // Compute interest\n    compute_interest(deps.as_ref(), &config, &mut state, env.block.height, None)?;\n    compute_borrower_interest(&state, &mut liability);\n\n    // Compute ANC reward\n    compute_reward(&mut state, env.block.height);\n    compute_borrower_reward(&state, &mut liability);\n\n    let claim_amount = liability.pending_rewards * Uint256::one();\n    liability.pending_rewards = liability.pending_rewards - Decimal256::from_uint256(claim_amount);\n\n    store_state(deps.storage, &state)?;\n    store_borrower_info(deps.storage, &borrower_raw, &liability)?;\n\n    let messages: Vec<CosmosMsg> = if !claim_amount.is_zero() {\n        vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: deps\n                .api\n                .addr_humanize(&config.distributor_contract)?\n                .to_string(),\n            funds: vec![],\n            msg: to_binary(&FaucetExecuteMsg::Spend {\n                recipient: if let Some(to) = to {\n                    to.to_string()\n                } else {\n                    borrower.to_string()\n                },\n                amount: claim_amount.into(),\n            })?,\n        })]\n    } else {\n        vec![]\n    };\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        attr(\"action\", \"claim_rewards\"),\n        attr(\"claim_amount\", claim_amount),\n    ]))\n}\n\n/// Compute interest and update state\n/// total liabilities and total reserves\npub fn compute_interest(\n    deps: Deps,\n    config: &Config,\n    state: &mut State,\n    block_height: u64,\n    deposit_amount: Option<Uint256>,\n) -> StdResult<()> {\n    if state.last_interest_updated >= block_height {\n        return Ok(());\n    }\n\n    let aterra_supply = query_supply(deps, deps.api.addr_humanize(&config.aterra_contract)?)?;\n    let balance: Uint256 = query_balance(\n        deps,\n        deps.api.addr_humanize(&config.contract_addr)?,\n        config.stable_denom.to_string(),\n    )? - deposit_amount.unwrap_or_else(Uint256::zero);\n\n    let borrow_rate_res: BorrowRateResponse = query_borrow_rate(\n        deps,\n        deps.api.addr_humanize(&config.interest_model)?,\n        balance,\n        state.total_liabilities,\n        state.total_reserves,\n    )?;\n\n    let target_deposit_rate: Decimal256 =\n        query_target_deposit_rate(deps, deps.api.addr_humanize(&config.overseer_contract)?)?;\n\n    compute_interest_raw(\n        state,\n        block_height,\n        balance,\n        aterra_supply,\n        borrow_rate_res.rate,\n        target_deposit_rate,\n    );\n\n    Ok(())\n}\n\n// CONTRACT: to use this function as state update purpose,\n// executor must update following three state after execution\n// * state.prev_aterra_supply\n// * state.prev_exchange_rate\n// * state.last_interest_updated\npub fn compute_interest_raw(\n    state: &mut State,\n    block_height: u64,\n    balance: Uint256,\n    aterra_supply: Uint256,\n    borrow_rate: Decimal256,\n    target_deposit_rate: Decimal256,\n) {\n    if state.last_interest_updated >= block_height {\n        return;\n    }\n\n    let passed_blocks = Decimal256::from_uint256(block_height - state.last_interest_updated);\n\n    let interest_factor = passed_blocks * borrow_rate;\n    let interest_accrued = state.total_liabilities * interest_factor;\n\n    state.global_interest_index =\n        state.global_interest_index * (Decimal256::one() + interest_factor);\n    state.total_liabilities += interest_accrued;\n\n    let mut exchange_rate = compute_exchange_rate_raw(state, aterra_supply, balance);\n    let effective_deposit_rate = exchange_rate / state.prev_exchange_rate;\n    let deposit_rate = (effective_deposit_rate - Decimal256::one()) / passed_blocks;\n\n    if deposit_rate > target_deposit_rate {\n        // excess_deposit_rate(_per_block)\n        let excess_deposit_rate = deposit_rate - target_deposit_rate;\n        let prev_deposits =\n            Decimal256::from_uint256(state.prev_aterra_supply * state.prev_exchange_rate);\n\n        // excess_yield = prev_deposits * excess_deposit_rate(_per_block) * blocks\n        let excess_yield = prev_deposits * passed_blocks * excess_deposit_rate;\n\n        state.total_reserves += excess_yield;\n        exchange_rate = compute_exchange_rate_raw(state, aterra_supply, balance);\n    }\n\n    state.prev_aterra_supply = aterra_supply;\n    state.prev_exchange_rate = exchange_rate;\n    state.last_interest_updated = block_height;\n}\n\n/// Compute new interest and apply to liability\npub(crate) fn compute_borrower_interest(state: &State, liability: &mut BorrowerInfo) {\n    liability.loan_amount =\n        liability.loan_amount * state.global_interest_index / liability.interest_index;\n    liability.interest_index = state.global_interest_index;\n}\n\n/// Compute distributed reward and update global index\npub fn compute_reward(state: &mut State, block_height: u64) {\n    if state.last_reward_updated >= block_height {\n        return;\n    }\n\n    let passed_blocks = Decimal256::from_uint256(block_height - state.last_reward_updated);\n    let reward_accrued = passed_blocks * state.anc_emission_rate;\n    let borrow_amount = state.total_liabilities / state.global_interest_index;\n\n    if !reward_accrued.is_zero() && !borrow_amount.is_zero() {\n        state.global_reward_index += reward_accrued / borrow_amount;\n    }\n\n    state.last_reward_updated = block_height;\n}\n\n/// Compute reward amount a borrower received\npub(crate) fn compute_borrower_reward(state: &State, liability: &mut BorrowerInfo) {\n    liability.pending_rewards += Decimal256::from_uint256(liability.loan_amount)\n        / state.global_interest_index\n        * (state.global_reward_index - liability.reward_index);\n    liability.reward_index = state.global_reward_index;\n}\n\npub fn query_borrower_info(\n    deps: Deps,\n    env: Env,\n    borrower: Addr,\n    block_height: Option<u64>,\n) -> StdResult<BorrowerInfoResponse> {\n    let mut borrower_info: BorrowerInfo = read_borrower_info(\n        deps.storage,\n        &deps.api.addr_canonicalize(borrower.as_str())?,\n    );\n\n    let block_height = if let Some(block_height) = block_height {\n        block_height\n    } else {\n        env.block.height\n    };\n\n    let config: Config = read_config(deps.storage)?;\n    let mut state: State = read_state(deps.storage)?;\n\n    compute_interest(deps, &config, &mut state, block_height, None)?;\n    compute_borrower_interest(&state, &mut borrower_info);\n\n    compute_reward(&mut state, block_height);\n    compute_borrower_reward(&state, &mut borrower_info);\n\n    Ok(BorrowerInfoResponse {\n        borrower: borrower.to_string(),\n        interest_index: borrower_info.interest_index,\n        reward_index: borrower_info.reward_index,\n        loan_amount: borrower_info.loan_amount,\n        pending_rewards: borrower_info.pending_rewards,\n    })\n}\n\npub fn query_borrower_infos(\n    deps: Deps,\n    start_after: Option<Addr>,\n    limit: Option<u32>,\n) -> StdResult<BorrowerInfosResponse> {\n    let start_after = if let Some(start_after) = start_after {\n        Some(deps.api.addr_canonicalize(start_after.as_str())?)\n    } else {\n        None\n    };\n\n    let borrower_infos: Vec<BorrowerInfoResponse> = read_borrower_infos(deps, start_after, limit)?;\n    Ok(BorrowerInfosResponse { borrower_infos })\n}\n\nfn assert_max_borrow_factor(\n    config: &Config,\n    state: &State,\n    current_balance: Uint256,\n    borrow_amount: Uint256,\n) -> Result<(), ContractError> {\n    let current_balance = Decimal256::from_uint256(current_balance);\n    let borrow_amount = Decimal256::from_uint256(borrow_amount);\n\n    // Assert max borrow factor\n    if state.total_liabilities + borrow_amount\n        > (current_balance + state.total_liabilities - state.total_reserves)\n            * config.max_borrow_factor\n    {\n        return Err(ContractError::MaxBorrowFactorReached(\n            config.stable_denom.clone(),\n        ));\n    }\n\n    // Assert available balance\n    if borrow_amount + state.total_reserves > current_balance {\n        return Err(ContractError::NoStableAvailable(\n            config.stable_denom.clone(),\n        ));\n    }\n\n    Ok(())\n}"
    }
  ]
}