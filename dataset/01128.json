{
  "Title": "Use of Non-Production-Ready Trusted Forwarder",
  "Content": "The `GasSwap` contract inherits from `ERC2771Context` thereby allowing meta-transactions to work with its functions. It relies on a trusted forwarder [that is set in the constructor](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/gas-swap/GasSwap.sol#L79). The trusted forwarder that it depends on is the `MinimalForwarder`, which is [located in the `External` contract](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/External.sol#L7). However, the `MinimalForwarder` is not ready for production use and is [mainly meant for testing](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/metatx/MinimalForwarder.sol#L9-L16).\n\n\nBy using the `MinimalForwarder`, ETH could [potentially be lost](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3664). In addition, the `MinimalForwader`'s signed requests do not expire and lack batching, which is useful when dealing with a large volume of requests to be forwarded.\n\n\nConsider using OpenZeppelin's `ERC2771Forwarder` instead. While this contract is not available until v5.0 is released, the source code can be obtained from the [`master` branch](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Forwarder.sol) and inserted into the codebase.\n\n\n***Update:** Partially resolved in [pull request #843](https://github.com/scroll-tech/scroll/pull/843) at commit [709101a](https://github.com/scroll-tech/scroll/pull/843/commits/709101a5b253b08480ad22f16f07fd90b396e3ab). The Scroll team replaced the `MinimalForwarder` with the `ERC2771Forwarder` contract but did not remove the [`MinimalForwarder`](https://github.com/scroll-tech/scroll/blob/709101a5b253b08480ad22f16f07fd90b396e3ab/contracts/src/External.sol#L7) import from the [`External.sol` file](https://github.com/scroll-tech/scroll/blob/709101a5b253b08480ad22f16f07fd90b396e3ab/contracts/src/External.sol)*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/gas-swap/GasSwap.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\nimport {OwnableBase} from \"../libraries/common/OwnableBase.sol\";\n\n// solhint-disable no-empty-blocks\n\ncontract GasSwap is ERC2771Context, ReentrancyGuard, OwnableBase {\n    using SafeERC20 for IERC20;\n\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the fee ratio is updated.\n    /// @param feeRatio The new fee ratio, multiplied by 1e18.\n    event UpdateFeeRatio(uint256 feeRatio);\n\n    /// @notice Emitted when the status of target is updated.\n    /// @param target The address of target contract.\n    /// @param status The status updated.\n    event UpdateApprovedTarget(address target, bool status);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @dev The fee precision.\n    uint256 private constant PRECISION = 1e18;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct PermitData {\n        // The address of token to spend.\n        address token;\n        // The amount of token to spend.\n        uint256 value;\n        // The deadline of the permit.\n        uint256 deadline;\n        // Below three are signatures.\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct SwapData {\n        // The address of target contract to call.\n        address target;\n        // The calldata passed to target contract.\n        bytes data;\n        // The minimum amount of Ether should receive.\n        uint256 minOutput;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Keep track whether an address is approved.\n    mapping(address => bool) public approvedTargets;\n\n    /// @notice The fee ratio charged for each swap, multiplied by 1e18.\n    uint256 public feeRatio;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {\n        owner = msg.sender;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    receive() external payable {}\n\n    /// @notice Swap some token for ether.\n    /// @param _permit The permit data, see comments from `PermitData`.\n    /// @param _swap The swap data, see comments from `SwapData`.\n    function swap(PermitData memory _permit, SwapData memory _swap) external nonReentrant {\n        require(approvedTargets[_swap.target], \"target not approved\");\n        address _sender = _msgSender();\n\n        // do permit\n        IERC20Permit(_permit.token).permit(\n            _sender,\n            address(this),\n            _permit.value,\n            _permit.deadline,\n            _permit.v,\n            _permit.r,\n            _permit.s\n        );\n\n        // transfer token\n        IERC20(_permit.token).safeTransferFrom(_sender, address(this), _permit.value);\n\n        // approve\n        IERC20(_permit.token).safeApprove(_swap.target, 0);\n        IERC20(_permit.token).safeApprove(_swap.target, _permit.value);\n\n        // do swap\n        uint256 _outputTokenAmount = address(this).balance;\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool _success, bytes memory _res) = _swap.target.call(_swap.data);\n        require(_success, string(concat(bytes(\"swap failed: \"), bytes(getRevertMsg(_res)))));\n        _outputTokenAmount = address(this).balance - _outputTokenAmount;\n\n        // take fee\n        uint256 _fee = (_outputTokenAmount * feeRatio) / PRECISION;\n        _outputTokenAmount = _outputTokenAmount - _fee;\n        require(_outputTokenAmount >= _swap.minOutput, \"insufficient output amount\");\n\n        // tranfer ETH to sender\n        (_success, ) = _sender.call{value: _outputTokenAmount}(\"\");\n        require(_success, \"transfer ETH failed\");\n\n        // refund rest token\n        uint256 _dust = IERC20(_permit.token).balanceOf(address(this));\n        if (_dust > 0) {\n            IERC20(_permit.token).safeTransfer(_sender, _dust);\n        }\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Withdraw stucked tokens.\n    /// @param _token The address of token to withdraw. Use `address(0)` if you want to withdraw Ether.\n    /// @param _amount The amount of token to withdraw.\n    function withdraw(address _token, uint256 _amount) external onlyOwner {\n        if (_token == address(0)) {\n            (bool success, ) = msg.sender.call{value: _amount}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(_token).safeTransfer(msg.sender, _amount);\n        }\n    }\n\n    /// @notice Update the fee ratio.\n    /// @param _feeRatio The new fee ratio.\n    function updateFeeRatio(uint256 _feeRatio) external onlyOwner {\n        feeRatio = _feeRatio;\n\n        emit UpdateFeeRatio(_feeRatio);\n    }\n\n    /// @notice Update the status of a target address.\n    /// @param _target The address of target to update.\n    /// @param _status The new status.\n    function updateApprovedTarget(address _target, bool _status) external onlyOwner {\n        approvedTargets[_target] = _status;\n\n        emit UpdateApprovedTarget(_target, _status);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to concat two bytes array.\n    function concat(bytes memory a, bytes memory b) internal pure returns (bytes memory) {\n        return abi.encodePacked(a, b);\n    }\n\n    /// @dev Internal function decode revert message from return data.\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _returnData := add(_returnData, 0x04)\n        }\n\n        return abi.decode(_returnData, (string));\n    }\n}"
    }
  ]
}