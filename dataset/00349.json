{
  "Title": "M-8: Settlement of batch auction can exceed the gas limit",
  "Content": "# Issue M-8: Settlement of batch auction can exceed the gas limit \n\nSource: https://github.com/sherlock-audit/2024-03-axis-finance-judging/issues/237 \n\n## Found by \n0xR360, Kose, MrjoryStewartBaxter, flacko, shaka\n## Summary\n\nSettlement of batch auction can exceed the gas limit, making it impossible to settle the auction.\n\n## Vulnerability Detail\n\nWhen a batch auction (EMPAM) is settled, to calculate the lot marginal price, the contract [iterates over all bids](https://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/modules/auctions/EMPAM.sol#L611-L651) until the capacity is reached or a bid below the minimum price is found. \n\nAs some of the operations performed in the loop are gas-intensive, the contract may run out of gas if the number of bids is too high.\n\nNote that additionally, there is [another loop](https://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/modules/auctions/EMPAM.sol#L772-L781) in the `_settle` function that iterates over all the remaining bids to delete them from the queue. While this loop consumes much less gas per iteration and would require the number of bids to be much higher to run out of gas, it adds to the problem.\n\n## Impact\n\nSettlement of batch auction will revert, causing sellers and bidders to lose their funds.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/modules/auctions/EMPAM.sol#L611-L651\n\n## Proof of concept\n\nChange the minimum bid percent to 0.1% in the `EmpaModuleTest` contract in `EMPAModuleTest.sol`.\n\n```diff\n-   uint24 internal constant _MIN_BID_PERCENT = 1000; // 1%\n+   uint24 internal constant _MIN_BID_PERCENT = 100; // 0.1%\n```\n\nAdd the following code to the contract `EmpaModuleSettleTest` in `settle.t.sol` and run `forge test --mt test_settleOog`.\n\n```solidity\nmodifier givenBidsCreated() {\n    uint96 amountOut = 0.01e18;\n    uint96 amountIn = 0.01e18;\n    uint256 numBids = 580;\n\n    for (uint256 i = 0; i < numBids; i++) {\n        _createBid(_BIDDER, amountIn, amountOut);\n    }\n    \n    _;\n}\n\nfunction test_settleOog() external\n    givenLotIsCreated\n    givenLotHasStarted\n    givenBidsCreated\n    givenLotHasConcluded\n    givenPrivateKeyIsSubmitted\n    givenLotIsDecrypted\n{        \n    uint256 gasBefore = gasleft();\n    _settle();\n\n    assert(gasBefore - gasleft() > 30_000_000);\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAn easy way to tackle the issue would be to change the `_MIN_BID_PERCENT` value from 10 (0.01%) to 1000 (1%) in the `EMPAM.sol` contract, which would limit the number of iterations to 100.\n\nA more appropriate solution, if it is not acceptable to increase the min bid percent, would be to change the settlement logic so that can be handled in batches of bids to avoid running out of gas.\n\nIn both cases, it would also be recommended to limit the number of decrypted bids that can be deleted from the queue in a single transaction.\n\n\n\n## Discussion\n\n**Oighty**\n\nAcknowledge. This is valid. We had changed the queue implementation to be less gas intensive on inserts, but it ended up making removals (i.e. settle) more expensive. A priority for us is supporting as many bids on settlement as we can (which allows smaller bid sizes). We're likely going to switch to a linked list implementation to achieve this.\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Axis-Fi/moonraker/pull/137\n\n\n**10xhash**\n\n> The protocol team fixed this issue in the following PRs/commits: [Axis-Fi/moonraker#137](https://github.com/Axis-Fi/moonraker/pull/137)\n\nFixed\nThe implementation is changed from heap to linked list to reduce the gas cost and the max bid count for settlement is reduced to 2500 making the max gas expenditure around 8million for settlement\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/206",
  "Code": [
    {
      "filename": "moonraker/src/modules/auctions/EMPAM.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\n/// Protocol dependencies\nimport {AuctionModule, Auction} from \"src/modules/Auction.sol\";\nimport {Veecode, toVeecode} from \"src/modules/Modules.sol\";\n\n// Libraries\nimport {FixedPointMathLib as Math} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {ECIES, Point} from \"src/lib/ECIES.sol\";\nimport {MaxPriorityQueue, Queue, Bid as QueueBid} from \"src/lib/MaxPriorityQueue.sol\";\n\ncontract EncryptedMarginalPriceAuctionModule is AuctionModule {\n    using MaxPriorityQueue for Queue;\n\n    // ========== ERRORS ========== //\n    error Auction_InvalidKey();\n    error Auction_WrongState(uint96 lotId); // TODO shift into Auction?\n    error Bid_WrongState(uint96 lotId, uint64 bidId);\n    error NotPermitted(address caller);\n\n    // ========== EVENTS ========== //\n    event BidDecrypted(\n        uint96 indexed lotId, uint64 indexed bidId, uint96 amountIn, uint96 amountOut\n    );\n\n    // ========== DATA STRUCTURES ========== //\n\n    enum BidStatus {\n        Submitted,\n        Decrypted,\n        // Bid status will also be set to claimed if the bid is cancelled/refunded\n        Claimed\n    }\n\n    /// @notice        Core data for a bid\n    ///\n    /// @param         status              The status of the bid\n    /// @param         bidder              The address of the bidder\n    /// @param         amount              The amount of the bid\n    /// @param         minAmountOut        The minimum amount out (not set until the bid is decrypted)\n    /// @param         referrer            The address of the referrer\n    struct Bid {\n        address bidder; // 20 +\n        uint96 amount; // 12 = 32 - end of slot 1\n        uint96 minAmountOut; // 12 +\n        address referrer; // 20 = 32 - end of slot 2\n        BidStatus status; // 1 - slot 3\n    }\n\n    /// @notice        Struct containing data for an encrypted bid\n    ///\n    /// @param         encryptedAmountOut  The encrypted amount out, the bid amount is encrypted with a symmetric key that can be derived from the bidPubKey using the private key for the provided auction public key on the alt_bn128 curve\n    /// @param         bidPubKey           The alt_bn128 public key used to encrypt the amount out (see bid() for more details)\n    struct EncryptedBid {\n        uint256 encryptedAmountOut;\n        Point bidPubKey;\n    }\n\n    /// @notice        Struct containing auction-specific data\n    ///\n    /// @param         status              The status of the auction\n    /// @param         nextBidId           The ID of the next bid to be submitted\n    /// @param         nextDecryptIndex    The index of the next bid to decrypt\n    /// @param         marginalPrice       The marginal price of the auction (determined at settlement, blank before)\n    /// @param         publicKey           The public key used to encrypt bids (a point on the alt_bn128 curve from the generator point (1,2))\n    /// @param         privateKey          The private key used to decrypt bids (not provided until after the auction ends)\n    /// @param         bidIds              The list of bid IDs to decrypt in order of submission, excluding cancelled bids\n    struct AuctionData {\n        uint64 nextBidId; // 8 +\n        uint96 marginalPrice; // 12 +\n        uint96 minPrice; // 12 = 32 - end of slot 1\n        uint64 nextDecryptIndex; // 8 +\n        uint96 minFilled; // 12 +\n        uint96 minBidSize; // 12 = 32 - end of slot 2\n        Auction.Status status; // 1 +\n        uint64 marginalBidId; // 8 = 9 - end of slot 3\n        Point publicKey; // 64 - slots 4 and 5\n        uint256 privateKey; // 32 - slot 6\n        uint64[] bidIds; // slots 7+\n    }\n\n    struct AuctionDataParams {\n        uint96 minPrice;\n        uint24 minFillPercent;\n        uint24 minBidPercent;\n        Point publicKey;\n    }\n\n    /// @dev    Memory only, no need to pack\n    struct MarginalPriceResult {\n        uint96 marginalPrice;\n        uint64 marginalBidId;\n        uint64 partialFillBidId;\n        uint256 totalAmountIn;\n        uint256 capacityExpended;\n    }\n\n    // ========== STATE VARIABLES ========== //\n\n    /// @notice Constant for percentages\n    /// @dev    1% = 1_000 or 1e3. 100% = 100_000 or 1e5.\n    uint24 internal constant _MIN_BID_PERCENT = 10; // 0.01%\n\n    /// @notice     Auction-specific data for a lot\n    mapping(uint96 lotId => AuctionData) public auctionData;\n\n    /// @notice     General information about bids on a lot\n    mapping(uint96 lotId => mapping(uint64 bidId => Bid)) public bids;\n\n    /// @notice     Data for encryption information for a specific bid\n    mapping(uint96 lotId => mapping(uint64 bidId => EncryptedBid)) public encryptedBids; // each encrypted amount is 5 slots (length + 4 slots) due to using 1024-bit RSA encryption\n\n    /// @notice     Queue of decrypted bids for a lot (populated on decryption)\n    mapping(uint96 lotId => Queue) public decryptedBids;\n\n    // ========== SETUP ========== //\n\n    constructor(address auctionHouse_) AuctionModule(auctionHouse_) {\n        // Set the minimum auction duration to 1 day initially\n        minAuctionDuration = 1 days;\n    }\n\n    function VEECODE() public pure override returns (Veecode) {\n        return toVeecode(\"01EMPAM\");\n    }\n\n    function TYPE() public pure override returns (Type) {\n        return Type.Auction;\n    }\n\n    // ========== MODIFIERS ========== //\n\n    // ========== AUCTION ========== //\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The start and duration of the lot have been validated\n    ///\n    ///             This function reverts if:\n    ///             - The parameters cannot be decoded into the correct format\n    ///             - The minimum price is zero\n    ///             - The minimum fill percent is greater than 100%\n    ///             - The minimum bid percent is less than the minimum or greater than 100%\n    ///             - The public key is not valid\n    function _auction(uint96 lotId_, Lot memory lot_, bytes memory params_) internal override {\n        // Decode implementation params\n        AuctionDataParams memory implParams = abi.decode(params_, (AuctionDataParams));\n\n        // Validate params\n\n        // minPrice must not be zero\n        if (implParams.minPrice == 0) revert Auction_InvalidParams();\n\n        // minFillPercent must be less than or equal to 100%\n        if (implParams.minFillPercent > _ONE_HUNDRED_PERCENT) revert Auction_InvalidParams();\n\n        // minBidPercent must be greater than or equal to the global min and less than or equal to 100%\n        if (\n            implParams.minBidPercent < _MIN_BID_PERCENT\n                || implParams.minBidPercent > _ONE_HUNDRED_PERCENT\n        ) {\n            revert Auction_InvalidParams();\n        }\n\n        // publicKey must be a valid point for the encryption library\n        if (!ECIES.isValid(implParams.publicKey)) revert Auction_InvalidParams();\n\n        // Set auction data\n        AuctionData storage data = auctionData[lotId_];\n        data.minPrice = implParams.minPrice;\n        // These calculations won't overflow if capacity doesn't overflow uint96 because the minFillPercent and minBidPercent are both less than or equal to 100%\n        // We round up to be conservative with the minimums\n        data.minFilled = uint96(\n            Math.mulDivUp(\n                uint256(lot_.capacity),\n                uint256(implParams.minFillPercent),\n                uint256(_ONE_HUNDRED_PERCENT)\n            )\n        );\n        data.minBidSize = uint96(\n            Math.mulDivUp(\n                uint256(lot_.capacity), implParams.minBidPercent, uint256(_ONE_HUNDRED_PERCENT)\n            )\n        );\n        data.publicKey = implParams.publicKey;\n        data.nextBidId = 1;\n\n        decryptedBids[lotId_].initialize();\n    }\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes the following:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction has not concluded\n    ///\n    ///             This function reverts if:\n    ///             - The auction is active or has not concluded\n    function _cancelAuction(uint96 lotId_) internal override {\n        // Validation\n        // Batch auctions cannot be cancelled once started, otherwise the seller could cancel the auction after bids have been submitted\n        _revertIfLotActive(lotId_);\n\n        // Set auction status to claimed so that bids can be refunded\n        auctionData[lotId_].status = Auction.Status.Claimed;\n    }\n\n    // ========== BID ========== //\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function performs the following:\n    ///             - Validates inputs\n    ///             - Stores the encrypted bid\n    ///             - Adds the bid ID to the list of bids to decrypt (in `AuctionData.bidIds`)\n    ///             - Returns the bid ID\n    ///\n    ///             This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction is active\n    ///\n    ///             This function reverts if:\n    ///             - The parameters cannot be decoded into the correct format\n    ///             - The amount is less than the minimum bid size for the lot\n    ///             - The bid public key is not valid\n    function _bid(\n        uint96 lotId_,\n        address bidder_,\n        address referrer_,\n        uint96 amount_,\n        bytes calldata auctionData_\n    ) internal override returns (uint64 bidId) {\n        // Decode auction data\n        (uint256 encryptedAmountOut, Point memory bidPubKey) =\n            abi.decode(auctionData_, (uint256, Point));\n\n        // Validate inputs\n\n        // Amount must be at least the minimum bid size at the minimum price\n        uint256 minAmount = Math.mulDivDown(\n            uint256(auctionData[lotId_].minBidSize),\n            uint256(auctionData[lotId_].minPrice),\n            10 ** lotData[lotId_].baseTokenDecimals\n        );\n        if (amount_ < minAmount) revert Auction_AmountLessThanMinimum();\n\n        // Check that the bid public key is a valid point for the encryption library\n        if (!ECIES.isValid(bidPubKey)) revert Auction_InvalidKey();\n\n        // Store bid data\n        bidId = auctionData[lotId_].nextBidId++;\n        Bid storage userBid = bids[lotId_][bidId];\n        userBid.bidder = bidder_;\n        userBid.amount = amount_;\n        userBid.referrer = referrer_;\n        userBid.status = BidStatus.Submitted;\n\n        // Store encrypted amount out and bid public key\n        encryptedBids[lotId_][bidId] = EncryptedBid(encryptedAmountOut, bidPubKey);\n\n        // Push bid ID to list of bids to decrypt\n        auctionData[lotId_].bidIds.push(bidId);\n\n        return bidId;\n    }\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function performs the following:\n    ///             - Validates inputs\n    ///             - Marks the bid as refunded\n    ///             - Removes the bid from the list of bids to decrypt\n    ///             - Returns the amount to be refunded\n    ///\n    ///             The encrypted bid is not deleted from storage, so that the details can be fetched later.\n    ///\n    ///             This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The bid ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction is active\n    ///             - The bid has already been refunded\n    function _refundBid(\n        uint96 lotId_,\n        uint64 bidId_,\n        address\n    ) internal override returns (uint96 refund) {\n        // Set bid status to claimed\n        bids[lotId_][bidId_].status = BidStatus.Claimed;\n\n        // Remove bid from list of bids to decrypt\n        uint64[] storage bidIds = auctionData[lotId_].bidIds;\n        uint256 len = bidIds.length;\n        for (uint256 i; i < len; i++) {\n            if (bidIds[i] == bidId_) {\n                bidIds[i] = bidIds[len - 1];\n                bidIds.pop();\n                break;\n            }\n        }\n\n        // Return the amount to be refunded\n        return bids[lotId_][bidId_].amount;\n    }\n\n    /// @notice     Claims a bid and calculates the paid and payout amounts\n    /// @dev        This function performs the following:\n    ///             - Validates inputs\n    ///             - Marks the bid as claimed\n    ///             - Calculates the paid and payout amounts\n    ///\n    ///             This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The bid ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction is not settled\n    ///             - The bid has not already been claimed\n    function _claimBid(\n        uint96 lotId_,\n        uint64 bidId_\n    ) internal returns (BidClaim memory bidClaim, bytes memory auctionOutput_) {\n        // Load bid data\n        Bid storage bidData = bids[lotId_][bidId_];\n\n        // Set the bid status to claimed\n        bidData.status = BidStatus.Claimed;\n\n        // Load the referrer and bidder\n        bidClaim.bidder = bidData.bidder;\n        bidClaim.referrer = bidData.referrer;\n\n        // Calculate the bid price\n        uint256 baseScale = 10 ** lotData[lotId_].baseTokenDecimals;\n        uint96 price = uint96(\n            bidData.minAmountOut == 0\n                ? 0 // TODO technically minAmountOut == 0 should be an infinite price, but need to check that later. Need to be careful we don't introduce a way to claim a bid when we set marginalPrice to type(uint96).max when it cannot be settled.\n                : Math.mulDivUp(uint256(bidData.amount), baseScale, uint256(bidData.minAmountOut))\n        );\n\n        // If the bid price is greater than the marginal price, the bid is filled.\n        // If the bid price is equal to the marginal price and the bid was submitted before or is the marginal bid, the bid is filled.\n        // Auctions that do not meet capacity or price thresholds to settle will have their marginal price set at the maximum uint96\n        // Therefore, all bids will be refunded.\n        // We handle the only potential marginal fill during settlement. All other bids are either completely filled or refunded.\n        uint96 marginalPrice = auctionData[lotId_].marginalPrice;\n        if (\n            price > marginalPrice\n                || (price == marginalPrice && bidId_ <= auctionData[lotId_].marginalBidId)\n        ) {\n            // Payout is calculated using the marginal price of the auction\n            bidClaim.paid = bidData.amount;\n            bidClaim.payout = uint96(Math.mulDivDown(bidClaim.paid, baseScale, marginalPrice));\n        } else {\n            // Bidder is refunded the paid amount and receives no payout\n            bidClaim.paid = bidData.amount;\n        }\n\n        return (bidClaim, auctionOutput_);\n    }\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function performs the following:\n    ///             - Validates inputs\n    ///             - Marks the bid as claimed\n    ///             - Calculates the paid and payout amounts\n    ///\n    ///             This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction is not settled\n    function _claimBids(\n        uint96 lotId_,\n        uint64[] calldata bidIds_\n    ) internal override returns (BidClaim[] memory bidClaims, bytes memory auctionOutput_) {\n        uint256 len = bidIds_.length;\n        bidClaims = new BidClaim[](len);\n        for (uint256 i; i < len; i++) {\n            // Validate\n            _revertIfBidInvalid(lotId_, bidIds_[i]);\n            _revertIfBidClaimed(lotId_, bidIds_[i]);\n\n            (bidClaims[i],) = _claimBid(lotId_, bidIds_[i]);\n        }\n\n        return (bidClaims, auctionOutput_);\n    }\n\n    // ========== DECRYPTION ========== //\n\n    /// @notice         Submits the private key for the auction lot and decrypts an initial number of bids\n    ///                 It does not require gating. If the seller wishes to limit who can call, they can simply not reveal the key to anyone else.\n    ///                 On the other hand, if a key management service is used, then anyone can call it once the key is revealed.\n    ///\n    /// @dev            This function reverts if:\n    ///                 - The lot ID is invalid\n    ///                 - The lot is not active\n    ///                 - The lot has not concluded\n    ///                 - The private key has already been submitted\n    function submitPrivateKey(uint96 lotId_, uint256 privateKey_, uint64 num_) external {\n        // Validation\n        _revertIfLotInvalid(lotId_);\n        _revertIfLotActive(lotId_);\n        _revertIfBeforeLotStart(lotId_);\n\n        // Revert if the private key has already been verified and set\n        if (auctionData[lotId_].privateKey != 0) revert Auction_WrongState(lotId_);\n\n        // Check that the private key is valid for the public key\n        // We assume that all public keys are derived from the same generator: (1, 2)\n        Point memory calcPubKey = ECIES.calcPubKey(Point(1, 2), privateKey_);\n        Point memory pubKey = auctionData[lotId_].publicKey;\n        if (calcPubKey.x != pubKey.x || calcPubKey.y != pubKey.y) revert Auction_InvalidKey();\n\n        // Store the private key\n        auctionData[lotId_].privateKey = privateKey_;\n\n        // Decrypt and sort bids\n        _decryptAndSortBids(lotId_, num_);\n    }\n\n    /// @notice         Decrypts a batch of bids and sorts them by price in descending order\n    /// @dev            This function handles the following:\n    ///                 - Performs state validation\n    ///                 - Iterates over the encrypted bids:\n    ///                     - Decrypts the bid\n    ///                     - Ignores if the bid is incorrectly encrypted\n    ///                     - Does not add to the sorted bid queue if the decrypted amount out is less than the minimum bid size or overflows\n    ///                     - Otherwise, adds to the sorted bid queue for use during settlement\n    ///                 - Determines the next decrypt index\n    ///                 - Sets the auction status to decrypted if all bids have been decrypted\n    ///\n    ///                 This function reverts if:\n    ///                 - The lot ID is invalid\n    ///                 - The lot has not concluded\n    ///                 - The lot has already been decrypted in full\n    ///                 - The private key has not been provided\n    ///\n    /// @param          lotId_          The lot ID of the auction to decrypt bids for\n    /// @param          num_            The number of bids to decrypt. Reduced to the number remaining if greater.\n    function decryptAndSortBids(uint96 lotId_, uint64 num_) external {\n        // Check that lotId is valid\n        _revertIfLotInvalid(lotId_);\n        _revertIfBeforeLotStart(lotId_);\n        _revertIfLotActive(lotId_);\n\n        // Revert if already decrypted or if the private key has not been provided\n        if (\n            auctionData[lotId_].status != Auction.Status.Created\n                || auctionData[lotId_].privateKey == 0\n        ) {\n            revert Auction_WrongState(lotId_);\n        }\n\n        // Decrypt and sort bids\n        _decryptAndSortBids(lotId_, num_);\n    }\n\n    function _decryptAndSortBids(uint96 lotId_, uint64 num_) internal {\n        // Load next decrypt index and min bid size\n        AuctionData storage lotBidData = auctionData[lotId_];\n        uint64 nextDecryptIndex = lotBidData.nextDecryptIndex;\n        uint96 minBidSize = auctionData[lotId_].minBidSize;\n\n        // Check that the number of decrypts is less than or equal to the number of bids remaining to be decrypted\n        // If so, reduce to the number remaining\n        uint64[] storage bidIds = auctionData[lotId_].bidIds;\n        if (num_ > bidIds.length - nextDecryptIndex) {\n            num_ = uint64(bidIds.length) - nextDecryptIndex;\n        }\n\n        // Iterate over the provided number of bids, decrypt them, and then store them in the sorted bid queue\n        // All submitted bids will be marked as decrypted, but only those with valid values will have the minAmountOut set and be stored in the sorted bid queue\n        for (uint64 i; i < num_; i++) {\n            // Load encrypted bid\n            uint64 bidId = bidIds[nextDecryptIndex + i];\n\n            // Decrypt the bid\n            uint96 amountOut;\n            {\n                uint256 result = _decrypt(lotId_, bidId, lotBidData.privateKey);\n\n                // Only set the amount out if it is less than or equal to the maximum value of a uint96\n                if (result <= type(uint96).max) {\n                    amountOut = uint96(result);\n                }\n            }\n\n            // Set bid status to decrypted\n            Bid storage bidData = bids[lotId_][bidId];\n            bidData.status = BidStatus.Decrypted;\n\n            // Only store the decrypt if the amount out is greater than or equal to the minimum bid size\n            if (amountOut > 0 && amountOut >= minBidSize) {\n                // Only store the decrypt if the price does not overflow\n                // We don't need to check for a zero bid price, because the smallest possible bid price is 1, due to the use of mulDivUp\n                // 1 * 10^6 / type(uint96).max = 1\n                if (\n                    Math.mulDivUp(\n                        uint256(bidData.amount),\n                        10 ** lotData[lotId_].baseTokenDecimals,\n                        uint256(amountOut)\n                    ) < type(uint96).max\n                ) {\n                    // Store the decrypt in the sorted bid queue and set the min amount out on the bid\n                    decryptedBids[lotId_].insert(bidId, bidData.amount, amountOut);\n                    bidData.minAmountOut = amountOut;\n                }\n            }\n\n            // Emit event\n            emit BidDecrypted(lotId_, bidId, bidData.amount, amountOut);\n        }\n\n        // Increment next decrypt index\n        auctionData[lotId_].nextDecryptIndex += num_;\n\n        // If all bids have been decrypted, set auction status to decrypted\n        if (auctionData[lotId_].nextDecryptIndex == bidIds.length) {\n            auctionData[lotId_].status = Auction.Status.Decrypted;\n        }\n    }\n\n    function _decrypt(\n        uint96 lotId_,\n        uint64 bidId_,\n        uint256 privateKey_\n    ) internal view returns (uint256 amountOut) {\n        // Load the encrypted bid data\n        EncryptedBid memory encryptedBid = encryptedBids[lotId_][bidId_];\n\n        // Decrypt the message\n        // We expect a salt calculated as the keccak256 hash of lot id, bidder, and amount to provide some (not total) uniqueness to the encryption, even if the same shared secret is used\n        Bid storage bidData = bids[lotId_][bidId_];\n        uint256 message = ECIES.decrypt(\n            encryptedBid.encryptedAmountOut,\n            encryptedBid.bidPubKey,\n            privateKey_,\n            uint256(keccak256(abi.encodePacked(lotId_, bidData.bidder, bidData.amount)))\n        );\n\n        // Convert the message into the amount out\n        // We don't need larger than 16 bytes for a message\n        // To avoid attacks that check for leading zero values, encrypted bids should use a 128-bit random number\n        // as a seed to randomize the message. The seed should be the first 16 bytes.\n        // During encryption, we subtract the seed from the amount out to get a masked value.\n        // After decryption, we can combine them again (adding the seed to the masked value) and get the amount out\n        // This works due to the overflow/underflow properties of modular arithmetic\n        uint128 maskedValue = uint128(message);\n        uint128 seed = uint128(message >> 128);\n\n        // We want to allow underflow here\n        unchecked {\n            amountOut = uint256(maskedValue + seed);\n        }\n    }\n\n    // ========== SETTLEMENT ========== //\n\n    /// @notice         Helper function to get the next bid from the queue and calculate the price\n    /// @dev            This is split into a different function to avoid stack too deep errors\n    ///\n    /// @param          queue_          The queue to get the next bid from\n    /// @param          baseScale_      The scaling factor for the base token\n    /// @return         bidId           The ID of the bid\n    /// @return         amountIn        The amount in of the bid (in quote token units)\n    /// @return         price           The price of the bid (in quote token units), or 0 if it could not be determined\n    function _getNextBid(\n        Queue storage queue_,\n        uint256 baseScale_\n    ) internal returns (uint64 bidId, uint96 amountIn, uint96 price) {\n        bidId = queue_.getMaxId();\n\n        // Load bid info (in quote token units)\n        QueueBid memory qBid = queue_.delMax();\n        amountIn = qBid.amountIn;\n\n        // A zero minAmountOut value should be filtered out during decryption. However, cover the case here to avoid a potential division by zero error that would brick settlement.\n        if (qBid.minAmountOut == 0) {\n            // A zero price would be filtered out being below the minimum price\n            return (bidId, amountIn, 0);\n        }\n\n        // Calculate the price of the bid\n        // Cannot overflow on cast back to uint96. It was checked during decryption.\n        price = uint96(Math.mulDivUp(amountIn, baseScale_, qBid.minAmountOut));\n\n        return (bidId, amountIn, price);\n    }\n\n    /// @notice     Calculates the marginal price of a lot\n    ///\n    /// @param      lotId_          The lot ID of the auction to calculate the marginal price for\n    /// @return     result          The result of the marginal price calculation\n    function _getLotMarginalPrice(uint96 lotId_)\n        internal\n        returns (MarginalPriceResult memory result)\n    {\n        // Cache values used in the loop\n        // Capacity is always in base token units for this auction type\n        uint256 capacity = lotData[lotId_].capacity;\n        uint256 baseScale = 10 ** lotData[lotId_].baseTokenDecimals;\n        AuctionData memory lotAuctionData = auctionData[lotId_];\n\n        // Iterate over bid queue (sorted in descending price) to calculate the marginal clearing price of the auction\n        {\n            Queue storage queue = decryptedBids[lotId_];\n            uint96 lastPrice;\n            uint64 lastBidId;\n            uint256 numBids = queue.getNumBids();\n            for (uint256 i = 0; i < numBids; i++) {\n                // A bid can be considered if:\n                // - the bid price is greater than or equal to the minimum\n                // - previous bids did not fill the capacity\n                //\n                // There is no need to check if the bid is the minimum bid size, as this was checked during decryption\n\n                // Get bid info\n                (uint64 bidId, uint96 amountIn, uint96 price) = _getNextBid(queue, baseScale);\n\n                // If the price is below the minimum price, then determine a marginal price from the previous bids with the knowledge that no other bids will be considered\n                // This will also handle a zero price returned from `_getNextBid()`, since `minPrice` is always greater than zero\n                if (price < lotAuctionData.minPrice) {\n                    // We know that the lastPrice was not sufficient to fill capacity or the loop would have exited\n                    // We check if minimum price can result in a fill. If so, find the exact marginal price between last price and minimum price\n                    // If not, we set the marginal price to the minimum price. Whether the capacity filled meets the minimum filled will be checked later in the settlement process.\n                    if (\n                        lotAuctionData.minPrice == 0\n                            || Math.mulDivDown(result.totalAmountIn, baseScale, lotAuctionData.minPrice)\n                                >= capacity\n                    ) {\n                        result.marginalPrice =\n                            uint96(Math.mulDivUp(result.totalAmountIn, baseScale, capacity));\n                    } else {\n                        result.marginalPrice = lotAuctionData.minPrice; // note this cannot be zero since it is checked above\n                    }\n\n                    // If the marginal price is re-calculated and is the same as the previous, we need to set the marginal bid id, otherwise the previous bid will not be able to claim.\n                    if (lastPrice == result.marginalPrice) {\n                        result.marginalBidId = lastBidId;\n                    }\n\n                    // Update capacity expended with the new marginal price\n                    result.capacityExpended = Math.mulDivDown(\n                        result.totalAmountIn, baseScale, uint256(result.marginalPrice)\n                    );\n                    // marginal bid id can be zero, there are no bids at the marginal price\n\n                    // Exit the outer loop\n                    break;\n                }\n\n                // Check if the auction can clear with the existing bids at a price between current price and last price\n                // There will be no partial fills because we select the price that exactly fills the capacity\n                // Note: totalAmountIn here has not had the current bid added to it\n                result.capacityExpended = Math.mulDivDown(result.totalAmountIn, baseScale, price);\n                if (result.capacityExpended >= capacity) {\n                    result.marginalPrice =\n                        uint96(Math.mulDivUp(result.totalAmountIn, baseScale, capacity));\n\n                    // If the marginal price is re-calculated and is the same as the previous, we need to set the marginal bid id, otherwise the previous bid will not be able to claim.\n                    if (lastPrice == result.marginalPrice) {\n                        result.marginalBidId = lastBidId;\n                    } else {\n                        result.marginalBidId = uint64(0); // we set this to zero so that any bids at the current price are not considered in the case that capacityExpended == capacity\n                    }\n\n                    // Calculate the capacity expended in the same way as before, instead of setting it to `capacity`\n                    // This will normally equal `capacity`, except when rounding would cause the the capacity expended to be slightly less than `capacity`\n                    result.capacityExpended =\n                        Math.mulDivDown(result.totalAmountIn, baseScale, result.marginalPrice); // updated based on the marginal price\n                    break;\n                }\n\n                // The current price will now be considered, so we can set this\n                lastPrice = price;\n                lastBidId = bidId;\n\n                // Increment total amount in\n                result.totalAmountIn += amountIn;\n\n                // Determine total capacity expended at this price (in base token units)\n                // quote scale * base scale / quote scale = base scale\n                result.capacityExpended =\n                    Math.mulDivDown(result.totalAmountIn, baseScale, uint256(price));\n\n                // If total capacity expended is greater than or equal to the capacity, we have found the marginal price\n                // If capacity expended is strictly greater than capacity, then we have a partially filled bid\n                if (result.capacityExpended >= capacity) {\n                    result.marginalPrice = price;\n                    result.marginalBidId = bidId;\n                    if (result.capacityExpended > capacity) {\n                        result.partialFillBidId = bidId;\n                    }\n                    break;\n                }\n\n                // If we have reached the end of the queue, we check the same cases as when the price of a bid is below the minimum price.\n                if (i == numBids - 1) {\n                    // We know that the price was not sufficient to fill capacity or the loop would have exited\n                    // We check if minimum price can result in a complete fill. If so, find the exact marginal price between last price and minimum price\n                    // If not, we set the marginal price to the minimum price. Whether the capacity filled meets the minimum filled will be checked l"
    }
  ]
}