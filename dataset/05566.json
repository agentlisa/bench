{
  "Title": "[L-05] `arrayIndex` value is not deleted when we remove cpd",
  "Content": "https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/CdpManagerStorage.sol#L269-L274\n\nhttps://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/CdpManagerStorage.sol#L471\n\nWhen we remove cpd, we zero all it's values, but `arrayIndex` remains.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-badger",
  "Code": [
    {
      "filename": "packages/contracts/contracts/CdpManagerStorage.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./Interfaces/ICdpManager.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/IEBTCToken.sol\";\nimport \"./Interfaces/ISortedCdps.sol\";\nimport \"./Dependencies/EbtcBase.sol\";\nimport \"./Dependencies/ReentrancyGuard.sol\";\nimport \"./Dependencies/ICollateralTokenOracle.sol\";\nimport \"./Dependencies/AuthNoOwner.sol\";\n\n/// @title CDP Manager storage and shared functions with LiquidationLibrary\n/// @dev All features around Cdp management are split into separate parts to get around contract size limitations.\n/// @dev Liquidation related functions are delegated to LiquidationLibrary contract code.\n/// @dev Both CdpManager and LiquidationLibrary must maintain **the same storage layout**, so shared storage components\n/// @dev and shared functions are added here in CdpManagerStorage to de-dup code\ncontract CdpManagerStorage is EbtcBase, ReentrancyGuard, ICdpManagerData, AuthNoOwner {\n    // NOTE: No packing cause it's the last var, no need for u64\n    uint128 public constant UNSET_TIMESTAMP = type(uint128).max;\n    uint128 public constant MINIMUM_GRACE_PERIOD = 15 minutes;\n\n    uint128 public lastGracePeriodStartTimestamp = UNSET_TIMESTAMP; // use max to signify\n    uint128 public recoveryModeGracePeriodDuration = MINIMUM_GRACE_PERIOD;\n\n    /// @notice Start the recovery mode grace period, if the system is in RM and the grace period timestamp has not already been set\n    /// @dev Trusted function to allow BorrowerOperations actions to set RM Grace Period\n    /// @dev Assumes BorrowerOperations has correctly calculated and passed in the new system TCR\n    /// @dev To maintain CEI compliance we use this trusted function\n    /// @param tcr The TCR to be checked whether Grace Period should be started\n    function notifyStartGracePeriod(uint256 tcr) external {\n        _requireCallerIsBorrowerOperations();\n        _startGracePeriod(tcr);\n    }\n\n    /// @notice End the recovery mode grace period, if the system is no longer in RM\n    /// @dev Trusted function to allow BorrowerOperations actions to set RM Grace Period\n    /// @dev Assumes BorrowerOperations has correctly calculated and passed in the new system TCR\n    /// @dev To maintain CEI compliance we use this trusted function\n    /// @param tcr The TCR to be checked whether Grace Period should be ended\n    function notifyEndGracePeriod(uint256 tcr) external {\n        _requireCallerIsBorrowerOperations();\n        _endGracePeriod(tcr);\n    }\n\n    /// @dev Internal notify called by Redemptions and Liquidations\n    /// @dev Specified TCR is emitted for notification pruposes regardless of whether the Grace Period timestamp is set\n    function _startGracePeriod(uint256 _tcr) internal {\n        emit TCRNotified(_tcr);\n\n        if (lastGracePeriodStartTimestamp == UNSET_TIMESTAMP) {\n            lastGracePeriodStartTimestamp = uint128(block.timestamp);\n\n            emit GracePeriodStart();\n        }\n    }\n\n    /// @notice Clear RM Grace Period timestamp if it has been set\n    /// @notice No input validation, calling function must confirm that the system is not in recovery mode to be valid\n    /// @dev Specified TCR is emitted for notification pruposes regardless of whether the Grace Period timestamp is set\n    /// @dev Internal notify called by Redemptions and Liquidations\n    function _endGracePeriod(uint256 _tcr) internal {\n        emit TCRNotified(_tcr);\n\n        if (lastGracePeriodStartTimestamp != UNSET_TIMESTAMP) {\n            lastGracePeriodStartTimestamp = UNSET_TIMESTAMP;\n\n            emit GracePeriodEnd();\n        }\n    }\n\n    function _syncGracePeriod() internal {\n        uint256 price = priceFeed.fetchPrice();\n        uint256 tcr = _getCachedTCR(price);\n        bool isRecoveryMode = _checkRecoveryModeForTCR(tcr);\n\n        if (isRecoveryMode) {\n            _startGracePeriod(tcr);\n        } else {\n            _endGracePeriod(tcr);\n        }\n    }\n\n    /// @dev Set RM grace period based on specified system collShares, system debt, and price\n    /// @dev Variant for internal use in redemptions and liquidations\n    function _syncGracePeriodForGivenValues(\n        uint256 systemCollShares,\n        uint256 systemDebt,\n        uint256 price\n    ) internal {\n        // Compute TCR with specified values\n        uint256 newTCR = EbtcMath._computeCR(\n            collateral.getPooledEthByShares(systemCollShares),\n            systemDebt,\n            price\n        );\n\n        if (newTCR < CCR) {\n            // Notify system is in RM\n            _startGracePeriod(newTCR);\n        } else {\n            // Notify system is outside RM\n            _endGracePeriod(newTCR);\n        }\n    }\n\n    /// @notice Set grace period duratin\n    /// @notice Permissioned governance function, must set grace period duration above hardcoded minimum\n    /// @param _gracePeriod new grace period duration, in seconds\n    function setGracePeriod(uint128 _gracePeriod) external requiresAuth {\n        require(\n            _gracePeriod >= MINIMUM_GRACE_PERIOD,\n            \"CdpManager: Grace period below minimum duration\"\n        );\n\n        syncGlobalAccountingAndGracePeriod();\n        recoveryModeGracePeriodDuration = _gracePeriod;\n        emit GracePeriodDurationSet(_gracePeriod);\n    }\n\n    string public constant NAME = \"CdpManager\";\n\n    // --- Connected contract declarations ---\n\n    address public immutable borrowerOperationsAddress;\n\n    ICollSurplusPool immutable collSurplusPool;\n\n    IEBTCToken public immutable override ebtcToken;\n\n    address public immutable liquidationLibrary;\n\n    // A doubly linked list of Cdps, sorted by their sorted by their collateral ratios\n    ISortedCdps public immutable sortedCdps;\n\n    // --- Data structures ---\n\n    uint256 public constant SECONDS_IN_ONE_MINUTE = 60;\n\n    uint256 public constant MIN_REDEMPTION_FEE_FLOOR = (DECIMAL_PRECISION * 5) / 1000; // 0.5%\n    uint256 public redemptionFeeFloor = MIN_REDEMPTION_FEE_FLOOR;\n    bool public redemptionsPaused;\n    /*\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 => d = (1/2)^(1/720)\n     */\n    uint256 public minuteDecayFactor = 999037758833783000;\n    uint256 public constant MIN_MINUTE_DECAY_FACTOR = 1; // Non-zero\n    uint256 public constant MAX_MINUTE_DECAY_FACTOR = 999999999999999999; // Corresponds to a very fast decay rate, but not too extreme\n\n    uint256 internal immutable deploymentStartTime;\n\n    /*\n     * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction,\n     * in order to calc the new base rate from a redemption.\n     * Corresponds to (1 / ALPHA) in the Liquity white paper.\n     */\n    uint256 public beta = 2;\n\n    uint256 public baseRate;\n\n    uint256 public stakingRewardSplit;\n\n    // The timestamp of the latest fee operation (redemption or new EBTC issuance)\n    uint256 public lastRedemptionTimestamp;\n\n    mapping(bytes32 => Cdp) public Cdps;\n\n    uint256 public override totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation and split fee claim\n    uint256 public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool, immediately after the latest liquidation and split fee claim\n    uint256 public totalCollateralSnapshot;\n\n    /*\n     * systemDebtRedistributionIndex track the sums of accumulated socialized liquidations per unit staked.\n     * During its lifetime, each stake earns:\n     *\n     * A systemDebt increase  of ( stake * [systemDebtRedistributionIndex - systemDebtRedistributionIndex(0)] )\n     *\n     * Where systemDebtRedistributionIndex(0) are snapshots of systemDebtRedistributionIndex\n     * for the active Cdp taken at the instant the stake was made\n     */\n    uint256 public systemDebtRedistributionIndex;\n\n    // Map active cdps to their RewardSnapshot (eBTC debt redistributed)\n    mapping(bytes32 => uint256) public cdpDebtRedistributionIndex;\n\n    // Error trackers for the cdp redistribution calculation\n    uint256 public lastEBTCDebtErrorRedistribution;\n\n    /* Global Index for (Full Price Per Share) of underlying collateral token */\n    uint256 public override stEthIndex;\n    /* Global Fee accumulator (never decreasing) per stake unit in CDPManager, similar to systemDebtRedistributionIndex */\n    uint256 public override systemStEthFeePerUnitIndex;\n    /* Global Fee accumulator calculation error due to integer division, similar to redistribution calculation */\n    uint256 public override systemStEthFeePerUnitIndexError;\n    /* Individual CDP Fee accumulator tracker, used to calculate fee split distribution */\n    mapping(bytes32 => uint256) public cdpStEthFeePerUnitIndex;\n\n    // Array of all active cdp Ids - used to to compute an approximate hint off-chain, for the sorted list insertion\n    bytes32[] public CdpIds;\n\n    /// @notice Initializes the contract with the provided addresses and sets up the required initial state\n    /// @param _liquidationLibraryAddress The address of the Liquidation Library\n    /// @param _authorityAddress The address of the Authority\n    /// @param _borrowerOperationsAddress The address of Borrower Operations\n    /// @param _collSurplusPool The address of the Collateral Surplus Pool\n    /// @param _ebtcToken The address of the eBTC Token contract\n    /// @param _sortedCdps The address of the Sorted CDPs contract\n    /// @param _activePool The address of the Active Pool\n    /// @param _priceFeed The address of the Price Feed\n    /// @param _collateral The address of the Collateral token\n    constructor(\n        address _liquidationLibraryAddress,\n        address _authorityAddress,\n        address _borrowerOperationsAddress,\n        address _collSurplusPool,\n        address _ebtcToken,\n        address _sortedCdps,\n        address _activePool,\n        address _priceFeed,\n        address _collateral\n    ) EbtcBase(_activePool, _priceFeed, _collateral) {\n        deploymentStartTime = block.timestamp;\n        liquidationLibrary = _liquidationLibraryAddress;\n\n        _initializeAuthority(_authorityAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPool);\n        ebtcToken = IEBTCToken(_ebtcToken);\n        sortedCdps = ISortedCdps(_sortedCdps);\n    }\n\n    /// @notice BorrowerOperations and CdpManager share reentrancy status by confirming the other's locked flag before beginning operation\n    /// @dev This is an alternative to the more heavyweight solution of both being able to set the reentrancy flag on a 3rd contract.\n    modifier nonReentrantSelfAndBOps() {\n        require(locked == OPEN, \"CdpManager: Reentrancy in nonReentrant call\");\n        require(\n            ReentrancyGuard(borrowerOperationsAddress).locked() == OPEN,\n            \"BorrowerOperations: Reentrancy in nonReentrant call\"\n        );\n\n        locked = LOCKED;\n\n        _;\n\n        locked = OPEN;\n    }\n\n    function _closeCdp(bytes32 _cdpId, Status closedStatus) internal {\n        _closeCdpWithoutRemovingSortedCdps(_cdpId, closedStatus);\n        sortedCdps.remove(_cdpId);\n    }\n\n    function _closeCdpWithoutRemovingSortedCdps(bytes32 _cdpId, Status closedStatus) internal {\n        require(\n            closedStatus != Status.nonExistent && closedStatus != Status.active,\n            \"CdpManagerStorage: close non-exist or non-active CDP!\"\n        );\n\n        uint256 cdpIdsArrayLength = CdpIds.length;\n        _requireMoreThanOneCdpInSystem(cdpIdsArrayLength);\n\n        _removeStake(_cdpId);\n\n        Cdps[_cdpId].status = closedStatus;\n        Cdps[_cdpId].coll = 0;\n        Cdps[_cdpId].debt = 0;\n        Cdps[_cdpId].liquidatorRewardShares = 0;\n\n        cdpDebtRedistributionIndex[_cdpId] = 0;\n        cdpStEthFeePerUnitIndex[_cdpId] = 0;\n\n        _removeCdp(_cdpId, cdpIdsArrayLength);\n    }\n\n    /*\n     * Updates snapshots of system total stakes and total collateral,\n     * excluding a given collateral remainder from the calculation.\n     * Used in a liquidation sequence.\n     *\n     * The calculation excludes a portion of collateral that is in the ActivePool:\n     *\n     * the total stETH liquidator reward compensation from the liquidation sequence\n     *\n     * The stETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n     */\n    function _updateSystemSnapshotsExcludeCollRemainder(uint256 _collRemainder) internal {\n        uint256 _totalStakesSnapshot = totalStakes;\n        totalStakesSnapshot = _totalStakesSnapshot;\n\n        uint256 _totalCollateralSnapshot = activePool.getSystemCollShares() - _collRemainder;\n        totalCollateralSnapshot = _totalCollateralSnapshot;\n\n        emit SystemSnapshotsUpdated(_totalStakesSnapshot, _totalCollateralSnapshot);\n    }\n\n    /// @dev get the pending Cdp debt \"reward\" (i.e. the amount of extra debt assigned to the Cdp) from liquidation redistribution events, earned by their stake\n    function _getPendingRedistributedDebt(\n        bytes32 _cdpId\n    ) internal view returns (uint256 pendingEBTCDebtReward, uint256 _debtIndexDiff) {\n        Cdp storage cdp = Cdps[_cdpId];\n\n        if (cdp.status != Status.active) {\n            return (0, 0);\n        }\n\n        _debtIndexDiff = systemDebtRedistributionIndex - cdpDebtRedistributionIndex[_cdpId];\n\n        if (_debtIndexDiff > 0) {\n            pendingEBTCDebtReward = (cdp.stake * _debtIndexDiff) / DECIMAL_PRECISION;\n        } else {\n            return (0, 0);\n        }\n    }\n\n    /*\n     * A Cdp has pending redistributed debt if its snapshot is less than the current rewards per-unit-staked sum:\n     * this indicates that redistributions have occured since the snapshot was made, and the user therefore has\n     * pending debt\n     */\n    function _hasRedistributedDebt(bytes32 _cdpId) internal view returns (bool) {\n        if (Cdps[_cdpId].status != Status.active) {\n            return false;\n        }\n\n        return (cdpDebtRedistributionIndex[_cdpId] < systemDebtRedistributionIndex);\n    }\n\n    /// @dev Sync Cdp debt redistribution index to global value\n    function _updateRedistributedDebtIndex(bytes32 _cdpId) internal {\n        uint256 _systemDebtRedistributionIndex = systemDebtRedistributionIndex;\n\n        cdpDebtRedistributionIndex[_cdpId] = _systemDebtRedistributionIndex;\n        emit CdpDebtRedistributionIndexUpdated(_cdpId, _systemDebtRedistributionIndex);\n    }\n\n    /// @dev Calculate the new collateral and debt values for a given CDP, based on pending state changes\n    function _syncAccounting(bytes32 _cdpId) internal {\n        // Ensure global states like systemStEthFeePerUnitIndex get updated in a timely fashion\n        // whenever there is a CDP modification operation,\n        // such as opening, closing, adding collateral, repaying debt, or liquidating\n        _syncGlobalAccounting();\n\n        uint256 _oldPerUnitCdp = cdpStEthFeePerUnitIndex[_cdpId];\n        uint256 _systemStEthFeePerUnitIndex = systemStEthFeePerUnitIndex;\n\n        (\n            uint256 _newColl,\n            uint256 _newDebt,\n            uint256 _feeSplitDistributed,\n            uint _pendingDebt,\n            uint256 _debtIndexDelta\n        ) = _calcSyncedAccounting(_cdpId, _oldPerUnitCdp, _systemStEthFeePerUnitIndex);\n\n        // If any collShares or debt changes occured\n        if (_feeSplitDistributed > 0 || _debtIndexDelta > 0) {\n            Cdp storage _cdp = Cdps[_cdpId];\n\n            uint prevCollShares = _cdp.coll;\n            uint256 prevDebt = _cdp.debt;\n\n            // Apply Fee Split\n            if (_feeSplitDistributed > 0) {\n                _applyAccumulatedFeeSplit(\n                    _cdpId,\n                    _newColl,\n                    _feeSplitDistributed,\n                    _oldPerUnitCdp,\n                    _systemStEthFeePerUnitIndex\n                );\n            }\n\n            // Apply Debt Redistribution\n            if (_debtIndexDelta > 0) {\n                _updateRedistributedDebtIndex(_cdpId);\n\n                if (prevDebt != _newDebt) {\n                    {\n                        // Apply pending debt redistribution to this CDP\n                        _cdp.debt = _newDebt;\n                    }\n                }\n            }\n            emit CdpUpdated(\n                _cdpId,\n                ISortedCdps(sortedCdps).getOwnerAddress(_cdpId),\n                msg.sender,\n                prevDebt,\n                prevCollShares,\n                _newDebt,\n                _newColl,\n                _cdp.stake,\n                CdpOperation.syncAccounting\n            );\n        }\n\n        // sync per stake index for given CDP\n        if (_oldPerUnitCdp != _systemStEthFeePerUnitIndex) {\n            cdpStEthFeePerUnitIndex[_cdpId] = _systemStEthFeePerUnitIndex;\n        }\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(bytes32 _cdpId) internal {\n        uint256 _newTotalStakes = totalStakes - Cdps[_cdpId].stake;\n        totalStakes = _newTotalStakes;\n        Cdps[_cdpId].stake = 0;\n        emit TotalStakesUpdated(_newTotalStakes);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    // and update totalStakes accordingly as well\n    function _updateStakeAndTotalStakes(bytes32 _cdpId) internal returns (uint256) {\n        (uint256 newStake, uint256 oldStake) = _updateStakeForCdp(_cdpId);\n\n        uint256 _newTotalStakes = totalStakes + newStake - oldStake;\n        totalStakes = _newTotalStakes;\n\n        emit TotalStakesUpdated(_newTotalStakes);\n\n        return newStake;\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeForCdp(bytes32 _cdpId) internal returns (uint256, uint256) {\n        Cdp storage _cdp = Cdps[_cdpId];\n        uint256 newStake = _computeNewStake(_cdp.coll);\n        uint256 oldStake = _cdp.stake;\n        _cdp.stake = newStake;\n\n        return (newStake, oldStake);\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint256 _coll) internal view returns (uint256) {\n        uint256 stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*\n             * The following check holds true because:\n             * - The system always contains >= 1 cdp\n             * - When we close or liquidate a cdp, we redistribute the pending rewards,\n             * so if all cdps were closed/liquidated,\n             * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n             */\n            require(totalStakesSnapshot > 0, \"CdpManagerStorage: zero totalStakesSnapshot!\");\n            stake = (_coll * totalStakesSnapshot) / totalCollateralSnapshot;\n        }\n        return stake;\n    }\n\n    /*\n     * Remove a Cdp owner from the CdpOwners array, not preserving array order. Removing owner 'B' does the following:\n     * [A B C D E] => [A E C D], and updates E's Cdp struct to point to its new array index.\n     */\n    function _removeCdp(bytes32 _cdpId, uint256 cdpIdsArrayLength) internal {\n        Status cdpStatus = Cdps[_cdpId].status;\n        // It’s set in caller function `_closeCdp`\n        require(\n            cdpStatus != Status.nonExistent && cdpStatus != Status.active,\n            \"CdpManagerStorage: remove non-exist or non-active CDP!\"\n        );\n\n        uint128 index = Cdps[_cdpId].arrayIndex;\n        uint256 length = cdpIdsArrayLength;\n        uint256 idxLast = length - 1;\n\n        require(index <= idxLast, \"CdpManagerStorage: CDP indexing overflow!\");\n\n        bytes32 idToMove = CdpIds[idxLast];\n\n        CdpIds[index] = idToMove;\n        Cdps[idToMove].arrayIndex = index;\n        emit CdpArrayIndexUpdated(idToMove, index);\n\n        CdpIds.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    // Calculate TCR given an price, and the entire system coll and debt.\n    function _computeTCRWithGivenSystemValues(\n        uint256 _systemCollShares,\n        uint256 _systemDebt,\n        uint256 _price\n    ) internal view returns (uint256) {\n        uint256 _totalColl = collateral.getPooledEthByShares(_systemCollShares);\n        return EbtcMath._computeCR(_totalColl, _systemDebt, _price);\n    }\n\n    // --- Staking-Reward Fee split functions ---\n\n    /// @notice Claim split fee if there is staking-reward coming\n    /// @notice and update global index & fee-per-unit variables\n    /// @dev only BorrowerOperations is allowed to call this\n    /// @dev otherwise use syncGlobalAccountingAndGracePeriod()\n    function syncGlobalAccounting() external {\n        _requireCallerIsBorrowerOperations();\n        _syncGlobalAccounting();\n    }\n\n    function _syncGlobalAccounting() internal {\n        (uint256 _oldIndex, uint256 _newIndex) = _readStEthIndex();\n        _syncStEthIndex(_oldIndex, _newIndex);\n        if (_newIndex > _oldIndex && totalStakes > 0) {\n            (\n                uint256 _feeTaken,\n                uint256 _newFeePerUnit,\n                uint256 _perUnitError\n            ) = _calcSyncedGlobalAccounting(_newIndex, _oldIndex);\n            _takeSplitAndUpdateFeePerUnit(_feeTaken, _newFeePerUnit, _perUnitError);\n            _updateSystemSnapshotsExcludeCollRemainder(0);\n        }\n    }\n\n    /// @notice Claim fee split, if there is staking-reward coming\n    /// @notice and update global index & fee-per-unit variables\n    /// @notice and toggles Grace Period accordingly.\n    /// @dev Call this if you want to help eBTC system to accrue split fee\n    function syncGlobalAccountingAndGracePeriod() public {\n        _syncGlobalAccounting(); // Apply // Could trigger RM\n        _syncGracePeriod(); // Synch Grace Period\n    }\n\n    /// @return existing(old) local stETH index AND\n    /// @return current(new) stETH index from collateral token\n    function _readStEthIndex() internal view returns (uint256, uint256) {\n        return (stEthIndex, collateral.getPooledEthByShares(DECIMAL_PRECISION));\n    }\n\n    // Update the global index via collateral token\n    function _syncStEthIndex(uint256 _oldIndex, uint256 _newIndex) internal {\n        if (_newIndex != _oldIndex) {\n            stEthIndex = _newIndex;\n            emit StEthIndexUpdated(_oldIndex, _newIndex, block.timestamp);\n        }\n    }\n\n    /// @notice Calculate fee for given pair of collateral indexes\n    /// @param _newIndex The value synced with stETH.getPooledEthByShares(1e18)\n    /// @param _prevIndex The cached global value of `stEthIndex`\n    /// @return _feeTaken The fee split in collateral token which will be deduced from current total system collateral\n    /// @return _deltaFeePerUnit The fee split increase per unit, used to added to `systemStEthFeePerUnitIndex`\n    /// @return _perUnitError The fee split calculation error, used to update `systemStEthFeePerUnitIndexError`\n    function calcFeeUponStakingReward(\n        uint256 _newIndex,\n        uint256 _prevIndex\n    ) public view returns (uint256, uint256, uint256) {\n        require(_newIndex > _prevIndex, \"CDPManager: only take fee with bigger new index\");\n        uint256 deltaIndex = _newIndex - _prevIndex;\n        uint256 deltaIndexFees = (deltaIndex * stakingRewardSplit) / MAX_REWARD_SPLIT;\n\n        // we take the fee for all CDPs immediately which is scaled by index precision\n        uint256 _deltaFeeSplit = deltaIndexFees * getSystemCollShares();\n        uint256 _cachedAllStakes = totalStakes;\n        // return the values to update the global fee accumulator\n        uint256 _feeTaken = collateral.getSharesByPooledEth(_deltaFeeSplit) / DECIMAL_PRECISION;\n        uint256 _deltaFeeSplitShare = (_feeTaken * DECIMAL_PRECISION) +\n            systemStEthFeePerUnitIndexError;\n        uint256 _deltaFeePerUnit = _deltaFeeSplitShare / _cachedAllStakes;\n        uint256 _perUnitError = _deltaFeeSplitShare - (_deltaFeePerUnit * _cachedAllStakes);\n        return (_feeTaken, _deltaFeePerUnit, _perUnitError);\n    }\n\n    // Take the cut from staking reward\n    // and update global fee-per-unit accumulator\n    function _takeSplitAndUpdateFeePerUnit(\n        uint256 _feeTaken,\n        uint256 _newPerUnit,\n        uint256 _newErrorPerUnit\n    ) internal {\n        uint256 _oldPerUnit = systemStEthFeePerUnitIndex;\n\n        systemStEthFeePerUnitIndex = _newPerUnit;\n        systemStEthFeePerUnitIndexError = _newErrorPerUnit;\n\n        require(activePool.getSystemCollShares() > _feeTaken, \"CDPManager: fee split is too big\");\n        activePool.allocateSystemCollSharesToFeeRecipient(_feeTaken);\n\n        emit CollateralFeePerUnitUpdated(_oldPerUnit, _newPerUnit, _feeTaken);\n    }\n\n    // Apply accumulated fee split distributed to the CDP\n    // and update its accumulator tracker accordingly\n    function _applyAccumulatedFeeSplit(\n        bytes32 _cdpId,\n        uint256 _newColl,\n        uint256 _feeSplitDistributed,\n        uint256 _oldPerUnitCdp,\n        uint256 _systemStEthFeePerUnitIndex\n    ) internal {\n        // apply split fee to given CDP\n        Cdps[_cdpId].coll = _newColl;\n\n        emit CdpFeeSplitApplied(\n            _cdpId,\n            _oldPerUnitCdp,\n            _systemStEthFeePerUnitIndex,\n            _feeSplitDistributed,\n            _newColl\n        );\n    }\n\n    /// @notice Calculate the applied split fee(scaled by 1e18) and the resulting CDP collateral share after applied\n    /// @param _cdpId The Cdp to which the calculated split fee is going to be applied\n    /// @param _systemStEthFeePerUnitIndex The fee-per-stake-unit value to be used in fee split calculation, could be result of calcFeeUponStakingReward()\n    /// @return _feeSplitDistributed The applied fee split to the specified Cdp (scaled up by 1e18)\n    /// @return _cdpCol The new collateral share of the specified Cdp after fe split applied\n    function getAccumulatedFeeSplitApplied(\n        bytes32 _cdpId,\n        uint256 _systemStEthFeePerUnitIndex\n    ) public view returns (uint256, uint256) {\n        uint256 _cdpStEthFeePerUnitIndex = cdpStEthFeePerUnitIndex[_cdpId];\n        uint256 _cdpCol = Cdps[_cdpId].coll;\n\n        if (\n            _cdpStEthFeePerUnitIndex == 0 ||\n            _cdpCol == 0 ||\n            _cdpStEthFeePerUnitIndex == _systemStEthFeePerUnitIndex\n        ) {\n            return (0, _cdpCol);\n        }\n\n        uint256 _feeSplitDistributed = Cdps[_cdpId].stake *\n            (_systemStEthFeePerUnitIndex - _cdpStEthFeePerUnitIndex);\n\n        uint256 _scaledCdpColl = _cdpCol * DECIMAL_PRECISION;\n\n        if (_scaledCdpColl > _feeSplitDistributed) {\n            return (\n                _feeSplitDistributed,\n                (_scaledCdpColl - _feeSplitDistributed) / DECIMAL_PRECISION\n            );\n        } else {\n            // extreme unlikely case to skip fee split on this CDP to avoid revert\n            return (0, _cdpCol);\n        }\n    }\n\n    // -- Modifier functions --\n    function _requireCdpIsActive(bytes32 _cdpId) internal view {\n        require(Cdps[_cdpId].status == Status.active, \"CdpManager: Cdp does not exist or is closed\");\n    }\n\n    function _requireMoreThanOneCdpInSystem(uint256 CdpOwnersArrayLength) internal view {\n        require(\n            CdpOwnersArrayLength > 1 && sortedCdps.getSize() > 1,\n            \"CdpManager: Only one cdp in the system\"\n        );\n    }\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress,\n            \"CdpManager: Caller is not the BorrowerOperations contract\"\n        );\n    }\n\n    // --- Helper functions ---\n\n    /// @notice Return the Nominal Collateral Ratio (NICR) of the specified Cdp as \"cached view\" (maybe outdated).\n    /// @dev Takes a cdp's pending coll and debt rewards from redistributions into account.\n    /// @param _cdpId The CdpId whose NICR to be queried\n    /// @return The Nominal Collateral Ratio (NICR) of the specified Cdp.\n    /// @dev Use getSyncedNominalICR() instead if pending fee split and debt redistribution should be considered\n    function getCachedNominalICR(bytes32 _cdpId) external view returns (uint256) {\n        (uint256 currentEBTCDebt, uint256 currentCollShares) = getSyncedDebtAndCollShares(_cdpId);\n\n        uint256 NICR = EbtcMath._computeNominalCR(currentCollShares, currentEBTCDebt);\n        return NICR;\n    }\n\n    /// @notice Return the Nominal Collateral Ratio (NICR) of the specified Cdp.\n    /// @dev Takes a cdp's pending coll and debt rewards as well as stETH Index into account.\n    /// @param _cdpId The CdpId whose NICR to be queried\n    /// @return The Nominal Collateral Ratio (NICR) of the specified Cdp with fee split and debt redistribution considered.\n    function getSyncedNominalICR(bytes32 _cdpId) external view returns (uint256) {\n        (uint256 _oldIndex, uint256 _newIndex) = _readStEthIndex();\n        (, uint256 _newGlobalSplitIdx, ) = _calcSyncedGlobalAccounting(_newIndex, _oldIndex);\n        (uint256 _newColl, uint256 _newDebt, , uint256 _pendingDebt, ) = _calcSyncedAccounting(\n            _cdpId,\n            cdpStEthFeePerUnitIndex[_cdpId],\n            _newGlobalSplitIdx /// NOTE: This is latest index\n        );\n\n        uint256 NICR = EbtcMath._computeNominalCR(_newColl, _newDebt);\n        return NICR;\n    }\n\n    /// @notice Return the Individual Collateral Ratio (ICR) of the specified Cdp as \"cached view\" (maybe outdated).\n    /// @param _cdpId The CdpId whose ICR to be queried\n    /// @return The Individual Collateral Ratio (ICR) of the specified Cdp.\n    /// @dev Use getSyncedICR() instead if pending fee split and debt redistribution should be considered\n    function getCachedICR(bytes32 _cdpId, uint256 _price) public view returns (uint256) {\n        (uint256 currentEBTCDebt, uint256 currentCollShares) = getSyncedDebtAndCollShares(_cdpId);\n        uint256 ICR = _calculateCR(currentCollShares, currentEBTCDebt, _price);\n        return ICR;\n    }\n\n    function _calculateCR(\n        uint256 currentCollShare,\n        uint256 currentDebt,\n        uint256 _price\n    ) internal view returns (uint256) {\n        uint256 _underlyingCollateral = collateral.getPooledEthByShares(currentCollShare);\n        return EbtcMath._computeCR(_underlyingCollateral, currentDebt, _price);\n    }\n\n    /// @notice Return the pending extra debt assigned to the Cdp from liquidation redistribution, calcualted by Cdp's stake\n    /// @param _cdpId The CdpId whose pending debt redistribution to be queried\n    /// @return pendingEBTCDebtReward The pending debt redistribution of the specified Cdp.\n    function getPendingRedistributedDebt(\n        bytes32 _cdpId\n    ) public view returns (uint256 pendingEBTCDebtReward) {\n        (uint256 _pendingDebt, ) = _getPendingRedistributedDebt(_cdpId);\n        return _pendingDebt;\n    }\n\n    /// @return Whether the debt redistribution tracking index of the specified Cdp is less than the global tracking one (meaning it might get pending debt redistribution)\n    /// @param _cdpId The CdpId whose debt redistribution tracking index to be queried against the gloabl one\n    function hasPendingRedistributedDebt(bytes32 _cdpId) public view returns (bool) {\n        return _hasRedistributedDebt(_cdpId);\n    }\n\n    // Return the Cdps entire debt and coll struct\n    function _getSyncedDebtAndCollShares(\n        bytes32 _cdpId\n    ) internal view returns (CdpDebtAndCollShares memory) {\n        (uint256 entireDebt, uint256 entireColl) = getSyncedDebtAndCollShares(_cdpId);\n        return CdpDebtAndCollShares(entireDebt, entireColl);\n    }\n\n    /// @notice Calculate the Cdps entire debt and coll, including pending debt redistributions and collateral reduction from split fee.\n    /// @param _cdpId The CdpId to be queried\n    /// @return debt The total debt value of the Cdp including debt redistribution considered\n    /// @return coll The total collateral value of the Cdp including possible fee split considered\n    /// @dev Should always use this as the first(default) choice for Cdp position size query\n    function getSyncedDebtAndCollShares(\n        bytes32 _cdpId\n    ) public view returns (uint256 debt, uint256 coll) {\n        (uint256 _newColl, uint256 _newDebt, , , ) = _calcSyncedAccounting(\n            _cdpId,\n            cdpStEthFeePerUnitIndex[_cdpId],\n            systemStEthFeePerUnitIndex\n        );\n        coll = _newColl;\n        debt = _newDebt;\n    }\n\n    /// @dev calculate pending global state change to be applied:\n    /// @return split fee taken (if any) AND\n    /// @return new split index per stake unit AND\n    /// @return new split index error\n    function _calcSyncedGlobalAccounting(\n        uint256 _newIndex,\n        uint256 _oldIndex\n    ) internal view returns (uint256, uint256, uint256) {\n        if (_newIndex > _oldIndex && totalStakes > 0) {\n            /// @audit-ok We don't"
    }
  ]
}