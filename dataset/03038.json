{
  "Title": "M-3: AccountManager: Liquidations not possible when transfer fails",
  "Content": "# Issue M-3: AccountManager: Liquidations not possible when transfer fails \nSource: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/033-M \n## Found by \npanprog, csanuragjain, Czar102, carrot, PwnPatrol, Lambda, kirk-baird, berndartmueller, rbserver, Chom, \\_\\_141345\\_\\_\n\n## Summary\nWhen the transfer of one asset fails, liquidations become impossible.\n\n## Vulnerability Detail\n`_liquidate` calls `sweepTo`, which iterates over all assets. When one of those transfers fails, the whole liquidation process therefore fails. There are multiple reasons why a transfer could fail:\n1.) Blocked addresses (e.g., USDC)\n2.) The balance of the asset is 0, but it is still listed under asset. This can be for instance triggered by performing a 0 value Uniswap swap, in which case it is still added to `tokensIn`. Another way to trigger is to call `deposit` with `amt = 0` (this is another issue that should be fixed IMO, in practice the assets of an account should not contain any tokens with zero balance)\nSome tokens revert for zero value transfers (see https://github.com/d-xo/weird-erc20)\n3.) Paused tokens\n4.) Upgradeable tokens that changed the implementation.\n\n## Impact\nSee above, an account cannot be liquidated. In certain conditions, this might even be triggerable by the user. For instance, a user could try to get on the USDC blacklist to avoid liquidations.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/protocol/src/core/AccountManager.sol#L384\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/protocol/src/core/Account.sol#L166\n\n## Tool used\n\nManual Review\n\n## Recommendation\nCatch reversions for the transfer and skip this asset (but it could be kept in the assets list to allow retries later on).\n\n## Sentiment Team\nFixed as recommended. PR [here](https://github.com/sentimentxyz/protocol/pull/231).\n\n## Lead Senior Watson\nConfirmed fix. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/1",
  "Code": [
    {
      "filename": "protocol/src/core/AccountManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Helpers} from \"../utils/Helpers.sol\";\nimport {Pausable} from \"../utils/Pausable.sol\";\nimport {IERC20} from \"../interface/tokens/IERC20.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\nimport {IAccount} from \"../interface/core/IAccount.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRiskEngine} from \"../interface/core/IRiskEngine.sol\";\nimport {IAccountFactory} from \"../interface/core/IAccountFactory.sol\";\nimport {IAccountManager} from \"../interface/core/IAccountManager.sol\";\nimport {IControllerFacade} from \"controller/core/IControllerFacade.sol\";\n\n/**\n    @title Account Manager\n    @notice Sentiment Account Manager,\n        All account interactions go via the account manager\n*/\ncontract AccountManager is Pausable, IAccountManager {\n    using Helpers for address;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE_VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice Registry\n    IRegistry public registry;\n\n    /// @notice Risk Engine\n    IRiskEngine public riskEngine;\n\n    /// @notice Controller Facade\n    IControllerFacade public controller;\n\n    /// @notice Account Factory\n    IAccountFactory public accountFactory;\n\n    /// @notice List of inactive accounts per user\n    mapping(address => address[]) public inactiveAccountsOf;\n\n    /// @notice Mapping of collateral enabled tokens\n    mapping(address => bool) public isCollateralAllowed;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier onlyOwner(address account) {\n        if (registry.ownerFor(account) != msg.sender)\n            revert Errors.AccountOwnerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Initializes contract\n        @dev Can only be invoked once\n        @param _registry Address of Registry\n    */\n    function init(IRegistry _registry) external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n        initialized = true;\n        initPausable(msg.sender);\n        registry = _registry;\n    }\n\n    /// @notice Initializes external dependencies\n    function initDep() external adminOnly {\n        riskEngine = IRiskEngine(registry.getAddress('RISK_ENGINE'));\n        controller = IControllerFacade(registry.getAddress('CONTROLLER'));\n        accountFactory =\n            IAccountFactory(registry.getAddress('ACCOUNT_FACTORY'));\n    }\n\n    /**\n        @notice Opens a new account for a user\n        @dev Creates a new account if there are no inactive accounts otherwise\n            reuses an already inactive account\n            Emits AccountAssigned(account, owner) event\n        @param owner Owner of the newly opened account\n    */\n    function openAccount(address owner) external whenNotPaused {\n        if (owner == address(0)) revert Errors.ZeroAddress();\n        address account;\n        uint length = inactiveAccountsOf[owner].length;\n        if (length == 0) {\n            account = accountFactory.create(address(this));\n            IAccount(account).init(address(this));\n            registry.addAccount(account, owner);\n        } else {\n            account = inactiveAccountsOf[owner][length - 1];\n            inactiveAccountsOf[owner].pop();\n            registry.updateAccount(account, owner);\n        }\n        IAccount(account).activate();\n        emit AccountAssigned(account, owner);\n    }\n\n    /**\n        @notice Closes a specified account for a user\n        @dev Account can only be closed when the account has no debt\n            Emits AccountClosed(account, owner) event\n        @param _account Address of account to be closed\n    */\n    function closeAccount(address _account) public onlyOwner(_account) {\n        IAccount account = IAccount(_account);\n        if (account.activationBlock() == block.number)\n            revert Errors.AccountDeactivationFailure();\n        if (!account.hasNoDebt()) revert Errors.OutstandingDebt();\n        account.deactivate();\n        registry.closeAccount(_account);\n        inactiveAccountsOf[msg.sender].push(_account);\n        account.sweepTo(msg.sender);\n        emit AccountClosed(_account, msg.sender);\n    }\n\n    /**\n        @notice Transfers Eth from owner to account\n        @param account Address of account\n    */\n    function depositEth(address account)\n        external\n        payable\n        whenNotPaused\n        onlyOwner(account)\n    {\n        account.safeTransferEth(msg.value);\n    }\n\n    /**\n        @notice Transfers Eth from the account to owner\n        @dev Eth can only be withdrawn if the account remains healthy\n            after withdrawal\n        @param account Address of account\n        @param amt Amount of Eth to withdraw\n    */\n    function withdrawEth(address account, uint amt)\n        external\n        onlyOwner(account)\n    {\n        if(!riskEngine.isWithdrawAllowed(account, address(0), amt))\n            revert Errors.RiskThresholdBreached();\n        account.withdrawEth(msg.sender, amt);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the owner\n            to the account\n        @dev Token must be accepted as collateral by the protocol\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to deposit\n    */\n    function deposit(address account, address token, uint amt)\n        external\n        whenNotPaused\n        onlyOwner(account)\n    {\n        if (!isCollateralAllowed[token])\n            revert Errors.CollateralTypeRestricted();\n        if (IAccount(account).hasAsset(token) == false)\n            IAccount(account).addAsset(token);\n        token.safeTransferFrom(msg.sender, account, amt);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the account\n            to the owner of the account\n        @dev Amount of token can only be withdrawn if the account remains healthy\n            after withdrawal\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to withdraw\n    */\n    function withdraw(address account, address token, uint amt)\n        external\n        onlyOwner(account)\n    {\n        if (!riskEngine.isWithdrawAllowed(account, token, amt))\n            revert Errors.RiskThresholdBreached();\n        account.withdraw(msg.sender, token, amt);\n        if (token.balanceOf(account) == 0)\n            IAccount(account).removeAsset(token);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the LP to the account\n        @dev Specified token must have a LP\n            Account must remain healthy after the borrow, otherwise tx is reverted\n            Emits Borrow(account, msg.sender, token, amount) event\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to borrow\n    */\n    function borrow(address account, address token, uint amt)\n        external\n        whenNotPaused\n        onlyOwner(account)\n    {\n        if (registry.LTokenFor(token) == address(0))\n            revert Errors.LTokenUnavailable();\n        if (!riskEngine.isBorrowAllowed(account, token, amt))\n            revert Errors.RiskThresholdBreached();\n        if (IAccount(account).hasAsset(token) == false)\n            IAccount(account).addAsset(token);\n        if (ILToken(registry.LTokenFor(token)).lendTo(account, amt))\n            IAccount(account).addBorrow(token);\n        emit Borrow(account, msg.sender, token, amt);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the account to the LP\n        @dev Specified token must have a LP\n            Emits Repay(account, msg.sender, token, amount) event\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to borrow\n    */\n    function repay(address account, address token, uint amt)\n        public\n        onlyOwner(account)\n    {\n        ILToken LToken = ILToken(registry.LTokenFor(token));\n        if (address(LToken) == address(0))\n            revert Errors.LTokenUnavailable();\n        LToken.updateState();\n        if (amt == type(uint256).max) amt = LToken.getBorrowBalance(account);\n        account.withdraw(address(LToken), token, amt);\n        if (LToken.collectFrom(account, amt))\n            IAccount(account).removeBorrow(token);\n        if (IERC20(token).balanceOf(account) == 0)\n            IAccount(account).removeAsset(token);\n        emit Repay(account, msg.sender, token, amt);\n    }\n\n    /**\n        @notice Liquidates an account\n        @dev Account can only be liquidated when it's unhealthy\n            Emits AccountLiquidated(account, owner) event\n        @param account Address of account\n    */\n    function liquidate(address account) external {\n        if (riskEngine.isAccountHealthy(account))\n            revert Errors.AccountNotLiquidatable();\n        _liquidate(account);\n        emit AccountLiquidated(account, registry.ownerFor(account));\n    }\n\n    /**\n        @notice Gives a spender approval to spend a given amount of token from\n            the account\n        @dev Spender must have a controller in controller facade\n        @param account Address of account\n        @param token Address of token\n        @param spender Address of spender\n        @param amt Amount of token\n    */\n    function approve(\n        address account,\n        address token,\n        address spender,\n        uint amt\n    )\n        external\n        onlyOwner(account)\n    {\n        if(address(controller.controllerFor(spender)) == address(0))\n            revert Errors.FunctionCallRestricted();\n        account.safeApprove(token, spender, amt);\n    }\n\n    /**\n        @notice A general function that allows the owner to perform specific interactions\n            with external protocols for their account\n        @dev Target must have a controller in controller facade\n        @param account Address of account\n        @param target Address of contract to transact with\n        @param amt Amount of Eth to send to the target contract\n        @param data Encoded sig + params of the function to transact with in the\n            target contract\n    */\n    function exec(\n        address account,\n        address target,\n        uint amt,\n        bytes calldata data\n    )\n        external\n        onlyOwner(account)\n    {\n        bool isAllowed;\n        address[] memory tokensIn;\n        address[] memory tokensOut;\n        (isAllowed, tokensIn, tokensOut) =\n            controller.canCall(target, (amt > 0), data);\n        if (!isAllowed) revert Errors.FunctionCallRestricted();\n        _updateTokensIn(account, tokensIn);\n        (bool success,) = IAccount(account).exec(target, amt, data);\n        if (!success)\n            revert Errors.AccountInteractionFailure(account, target, amt, data);\n        _updateTokensOut(account, tokensOut);\n        if (!riskEngine.isAccountHealthy(account))\n            revert Errors.RiskThresholdBreached();\n    }\n\n    /**\n        @notice Settles an account by repaying all the loans\n        @param account Address of account\n    */\n    function settle(address account) external onlyOwner(account) {\n        address[] memory borrows = IAccount(account).getBorrows();\n        for (uint i; i < borrows.length; i++) {\n            uint balance;\n            if (borrows[i] == address(0)) balance = account.balance;\n            else balance = borrows[i].balanceOf(account);\n            if ( balance > 0 ) repay(account, borrows[i], type(uint).max);\n        }\n    }\n\n    /**\n        @notice Fetches inactive accounts of a user\n        @param user Address of user\n        @return address[] List of inactive accounts\n    */\n    function getInactiveAccountsOf(\n        address user\n    )\n        external\n        view\n        returns (address[] memory)\n    {\n        return inactiveAccountsOf[user];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             Internal Functions                             */\n    /* -------------------------------------------------------------------------- */\n\n    function _updateTokensIn(address account, address[] memory tokensIn)\n        internal\n    {\n        uint tokensInLen = tokensIn.length;\n        for(uint i; i < tokensInLen; ++i) {\n            if (IAccount(account).hasAsset(tokensIn[i]) == false)\n                IAccount(account).addAsset(tokensIn[i]);\n        }\n    }\n\n    function _updateTokensOut(address account, address[] memory tokensOut)\n        internal\n    {\n        uint tokensOutLen = tokensOut.length;\n        for(uint i; i < tokensOutLen; ++i) {\n            if (tokensOut[i].balanceOf(account) == 0)\n                IAccount(account).removeAsset(tokensOut[i]);\n        }\n    }\n\n    function _liquidate(address _account) internal {\n        IAccount account = IAccount(_account);\n        address[] memory accountBorrows = account.getBorrows();\n        uint borrowLen = accountBorrows.length;\n\n        ILToken LToken;\n        uint amt;\n\n        for(uint i; i < borrowLen; ++i) {\n            address token = accountBorrows[i];\n            LToken = ILToken(registry.LTokenFor(token));\n            LToken.updateState();\n            amt = LToken.getBorrowBalance(_account);\n            token.safeTransferFrom(msg.sender, address(LToken), amt);\n            LToken.collectFrom(_account, amt);\n            account.removeBorrow(token);\n        }\n        account.sweepTo(msg.sender);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               ADMIN FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Toggle collateral status of a token\n        @param token Address of token\n    */\n    function toggleCollateralStatus(address token) external adminOnly {\n        isCollateralAllowed[token] = !isCollateralAllowed[token];\n    }\n}"
    },
    {
      "filename": "protocol/src/core/Account.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Helpers} from \"../utils/Helpers.sol\";\nimport {IAccount} from \"../interface/core/IAccount.sol\";\n\n/**\n    @title Sentiment Account\n    @notice Contract that acts as a dynamic and distributed asset reserve\n        which holds a userâ€™s collateral and loaned assets\n*/\ncontract Account is IAccount {\n    using Helpers for address;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              STATE VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Block number for when the account is activated\n    uint public activationBlock;\n\n    /**\n        @notice Address of account manager\n        @dev If the value is 0x0 the contract is not initialized\n    */\n    address public accountManager;\n\n\n    /// @notice A list of ERC-20 assets (Collaterals + Borrows) present in the account\n    address[] public assets;\n\n    /// @notice A list of borrowed ERC-20 assets present in the account\n    address[] public borrows;\n\n    /// @notice A mapping of ERC-20 assets present in the account\n    mapping(address => bool) public hasAsset;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier accountManagerOnly() {\n        if (msg.sender != accountManager) revert Errors.AccountManagerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Initializes the account by setting the address of the account\n            manager\n        @dev Can only be called as long as the address of the accountManager is\n            0x0\n        @param _accountManager address of the account manager\n    */\n    function init(address _accountManager) external {\n        if (accountManager != address(0))\n            revert Errors.ContractAlreadyInitialized();\n        accountManager = _accountManager;\n    }\n\n    /**\n        @notice Activates an account by setting the activationBlock to the\n            current block number\n    */\n    function activate() external accountManagerOnly {\n        activationBlock = block.number;\n    }\n\n    /**\n        @notice Deactivates an account by setting the activationBlock to 0\n    */\n    function deactivate() external accountManagerOnly {\n        activationBlock = 0;\n    }\n\n    /**\n        @notice Returns a list of ERC-20 assets deposited and borrowed by the owner\n        @return assets List of addresses\n    */\n    function getAssets() external view returns (address[] memory) {\n        return assets;\n    }\n\n    /**\n        @notice Returns a list of ERC-20 assets borrowed by the owner\n        @return borrows List of addresses\n    */\n    function getBorrows() external view returns (address[] memory) {\n        return borrows;\n    }\n\n    /**\n        @notice Adds a given ERC-20 token to the assets list\n        @param token Address of the ERC-20 token to add\n    */\n    function addAsset(address token) external accountManagerOnly {\n        assets.push(token);\n        hasAsset[token] = true;\n    }\n\n    /**\n        @notice Adds a given ERC-20 token to the borrows list\n        @param token Address of the ERC-20 token to add\n    */\n    function addBorrow(address token) external accountManagerOnly {\n        borrows.push(token);\n    }\n\n    /**\n        @notice Removes a given ERC-20 token from the assets list\n        @param token Address of the ERC-20 token to remove\n    */\n    function removeAsset(address token) external accountManagerOnly {\n        _remove(assets, token);\n        hasAsset[token] = false;\n    }\n\n    /**\n        @notice Removes a given ERC-20 token from the borrows list\n        @param token Address of the ERC-20 token to remove\n    */\n    function removeBorrow(address token) external accountManagerOnly {\n        _remove(borrows, token);\n    }\n\n    /**\n        @notice Returns whether the account has debt or not by checking the length\n            of the borrows list\n        @return hasNoDebt bool\n    */\n    function hasNoDebt() external view returns (bool) {\n        return borrows.length == 0;\n    }\n\n    /**\n        @notice Generalized utility function to transact with a given contract\n        @param target Address of contract to transact with\n        @param amt Amount of Eth to send to the target contract\n        @param data Encoded sig + params of the function to transact with in the\n            target contract\n        @return success True if transaction was successful, false otherwise\n        @return retData Data returned by given target contract after\n            the transaction\n    */\n    function exec(address target, uint amt, bytes calldata data)\n        external\n        accountManagerOnly\n        returns (bool, bytes memory)\n    {\n        (bool success, bytes memory retData) = target.call{value: amt}(data);\n        return (success, retData);\n    }\n\n    /**\n        @notice Utility function to transfer all assets to a specified account\n            and delete all assets\n        @param toAddress address of the account to send the assets to\n    */\n    function sweepTo(address toAddress) external accountManagerOnly {\n        uint assetsLen = assets.length;\n        for(uint i; i < assetsLen; ++i) {\n            assets[i].safeTransfer(\n                toAddress,\n                assets[i].balanceOf(address(this))\n            );\n            hasAsset[assets[i]] = false;\n        }\n        delete assets;\n        toAddress.safeTransferEth(address(this).balance);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @dev Utility function to remove a given address from a list of addresses\n        @param arr A list of addresses\n        @param token Address to remove\n    */\n    function _remove(address[] storage arr, address token) internal {\n        uint len = arr.length;\n        for(uint i; i < len; ++i) {\n            if (arr[i] == token) {\n                arr[i] = arr[arr.length - 1];\n                arr.pop();\n                break;\n            }\n        }\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}