{
  "Title": "[G-13] Splitting `require()` statements that use `&&` saves gas",
  "Content": "\nSee [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) for an example\n\n1.  File: contracts/ChainlinkPriceOracle.sol (line [51](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/ChainlinkPriceOracle.sol#L51))\n\n```solidity\n        require(_baseAggregator != address(0) && _base != address(0), \"ChainlinkPriceOracle: ZERO\");\n```\n\n2.  File: contracts/ChainlinkPriceOracle.sol (line [86](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/ChainlinkPriceOracle.sol#L86))\n\n```solidity\n        require(basePrice > 0 && quotePrice > 0, \"ChainlinkPriceOracle: NEGATIVE\");\n```\n\n3.  File: contracts/ManagedIndexReweightingLogic.sol (lines [29-34](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/ManagedIndexReweightingLogic.sol#L29-L34))\n\n```solidity\n        require(\n            _updatedAssets.length > 1 &&\n                _updatedWeights.length == _updatedAssets.length &&\n                _updatedAssets.length <= IIndexRegistry(registry).maxComponents(),\n            \"ManagedIndex: INVALID\"\n        );\n```\n\n4.  File: contracts/UniswapV2PriceOracle.sol (line [46](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/UniswapV2PriceOracle.sol#L46))\n\n```solidity\n        require(reserve0 != 0 && reserve1 != 0, \"UniswapV2PriceOracle: RESERVES\");\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-04-phuture-finance-contest",
  "Code": [
    {
      "filename": "contracts/ChainlinkPriceOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\n\nimport \"./libraries/FullMath.sol\";\nimport \"./libraries/FixedPoint112.sol\";\n\nimport \"./interfaces/IChainlinkPriceOracle.sol\";\n\n/// @title Chainlink price oracle\n/// @notice Contains logic for getting asset's price from Chainlink data feed\n/// @dev Oracle works through base asset which is set in initialize function\ncontract ChainlinkPriceOracle is IChainlinkPriceOracle, ERC165 {\n    using FullMath for uint;\n\n    struct AssetInfo {\n        AggregatorV2V3Interface aggregator;\n        uint8 answerDecimals;\n        uint8 decimals;\n        uint lastAssetPerBaseInUQ;\n    }\n\n    /// @notice Role allows configure asset related data/components\n    bytes32 private constant ASSET_MANAGER_ROLE = keccak256(\"ASSET_MANAGER_ROLE\");\n\n    /// @notice Index registry address\n    IAccessControl private immutable registry;\n\n    /// @notice Chainlink aggregator for the base asset\n    AggregatorV2V3Interface private immutable baseAggregator;\n\n    /// @notice Number of decimals in base asset answer\n    uint8 private immutable baseDecimals;\n\n    /// @notice Number of decimals in base asset answer\n    uint8 private immutable baseAnswerDecimals;\n\n    /// @notice Infos of added assets\n    mapping(address => AssetInfo) private assetInfoOf;\n\n    constructor(\n        address _registry,\n        address _base,\n        address _baseAggregator\n    ) {\n        require(_baseAggregator != address(0) && _base != address(0), \"ChainlinkPriceOracle: ZERO\");\n\n        registry = IAccessControl(_registry);\n        baseAnswerDecimals = AggregatorV2V3Interface(_baseAggregator).decimals();\n        baseDecimals = IERC20Metadata(_base).decimals();\n        baseAggregator = AggregatorV2V3Interface(_baseAggregator);\n    }\n\n    /// @inheritdoc IChainlinkPriceOracle\n    function addAsset(address _asset, address _assetAggregator) external override {\n        require(registry.hasRole(ASSET_MANAGER_ROLE, msg.sender), \"ChainlinkPriceOracle: FORBIDDEN\");\n        require(_asset != address(0), \"ChainlinkPriceOracle: ZERO\");\n\n        assetInfoOf[_asset] = AssetInfo({\n            aggregator: AggregatorV2V3Interface(_assetAggregator),\n            answerDecimals: AggregatorV2V3Interface(_assetAggregator).decimals(),\n            decimals: IERC20Metadata(_asset).decimals(),\n            lastAssetPerBaseInUQ: 0\n        });\n\n        refreshedAssetPerBaseInUQ(_asset);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function lastAssetPerBaseInUQ(address _asset) external view override returns (uint) {\n        return assetInfoOf[_asset].lastAssetPerBaseInUQ;\n    }\n\n    /// @inheritdoc IPriceOracle\n    function refreshedAssetPerBaseInUQ(address _asset) public override returns (uint) {\n        AssetInfo storage assetInfo = assetInfoOf[_asset];\n\n        (, int basePrice, , , ) = baseAggregator.latestRoundData();\n        (, int quotePrice, , , ) = assetInfo.aggregator.latestRoundData();\n\n        require(basePrice > 0 && quotePrice > 0, \"ChainlinkPriceOracle: NEGATIVE\");\n\n        uint assetPerBaseInUQ = ((uint(basePrice) * 10**assetInfo.decimals).mulDiv(\n            FixedPoint112.Q112,\n            (uint(quotePrice) * 10**baseDecimals)\n        ) * 10**assetInfo.answerDecimals) / 10**baseAnswerDecimals;\n        assetInfo.lastAssetPerBaseInUQ = assetPerBaseInUQ;\n        return assetPerBaseInUQ;\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IChainlinkPriceOracle).interfaceId ||\n            _interfaceId == type(IPriceOracle).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/ChainlinkPriceOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\n\nimport \"./libraries/FullMath.sol\";\nimport \"./libraries/FixedPoint112.sol\";\n\nimport \"./interfaces/IChainlinkPriceOracle.sol\";\n\n/// @title Chainlink price oracle\n/// @notice Contains logic for getting asset's price from Chainlink data feed\n/// @dev Oracle works through base asset which is set in initialize function\ncontract ChainlinkPriceOracle is IChainlinkPriceOracle, ERC165 {\n    using FullMath for uint;\n\n    struct AssetInfo {\n        AggregatorV2V3Interface aggregator;\n        uint8 answerDecimals;\n        uint8 decimals;\n        uint lastAssetPerBaseInUQ;\n    }\n\n    /// @notice Role allows configure asset related data/components\n    bytes32 private constant ASSET_MANAGER_ROLE = keccak256(\"ASSET_MANAGER_ROLE\");\n\n    /// @notice Index registry address\n    IAccessControl private immutable registry;\n\n    /// @notice Chainlink aggregator for the base asset\n    AggregatorV2V3Interface private immutable baseAggregator;\n\n    /// @notice Number of decimals in base asset answer\n    uint8 private immutable baseDecimals;\n\n    /// @notice Number of decimals in base asset answer\n    uint8 private immutable baseAnswerDecimals;\n\n    /// @notice Infos of added assets\n    mapping(address => AssetInfo) private assetInfoOf;\n\n    constructor(\n        address _registry,\n        address _base,\n        address _baseAggregator\n    ) {\n        require(_baseAggregator != address(0) && _base != address(0), \"ChainlinkPriceOracle: ZERO\");\n\n        registry = IAccessControl(_registry);\n        baseAnswerDecimals = AggregatorV2V3Interface(_baseAggregator).decimals();\n        baseDecimals = IERC20Metadata(_base).decimals();\n        baseAggregator = AggregatorV2V3Interface(_baseAggregator);\n    }\n\n    /// @inheritdoc IChainlinkPriceOracle\n    function addAsset(address _asset, address _assetAggregator) external override {\n        require(registry.hasRole(ASSET_MANAGER_ROLE, msg.sender), \"ChainlinkPriceOracle: FORBIDDEN\");\n        require(_asset != address(0), \"ChainlinkPriceOracle: ZERO\");\n\n        assetInfoOf[_asset] = AssetInfo({\n            aggregator: AggregatorV2V3Interface(_assetAggregator),\n            answerDecimals: AggregatorV2V3Interface(_assetAggregator).decimals(),\n            decimals: IERC20Metadata(_asset).decimals(),\n            lastAssetPerBaseInUQ: 0\n        });\n\n        refreshedAssetPerBaseInUQ(_asset);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function lastAssetPerBaseInUQ(address _asset) external view override returns (uint) {\n        return assetInfoOf[_asset].lastAssetPerBaseInUQ;\n    }\n\n    /// @inheritdoc IPriceOracle\n    function refreshedAssetPerBaseInUQ(address _asset) public override returns (uint) {\n        AssetInfo storage assetInfo = assetInfoOf[_asset];\n\n        (, int basePrice, , , ) = baseAggregator.latestRoundData();\n        (, int quotePrice, , , ) = assetInfo.aggregator.latestRoundData();\n\n        require(basePrice > 0 && quotePrice > 0, \"ChainlinkPriceOracle: NEGATIVE\");\n\n        uint assetPerBaseInUQ = ((uint(basePrice) * 10**assetInfo.decimals).mulDiv(\n            FixedPoint112.Q112,\n            (uint(quotePrice) * 10**baseDecimals)\n        ) * 10**assetInfo.answerDecimals) / 10**baseAnswerDecimals;\n        assetInfo.lastAssetPerBaseInUQ = assetPerBaseInUQ;\n        return assetPerBaseInUQ;\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IChainlinkPriceOracle).interfaceId ||\n            _interfaceId == type(IPriceOracle).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/ManagedIndexReweightingLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport \"./libraries/IndexLibrary.sol\";\n\nimport \"./interfaces/IvToken.sol\";\nimport \"./interfaces/IOrderer.sol\";\nimport \"./interfaces/IvTokenFactory.sol\";\nimport \"./interfaces/IIndexRegistry.sol\";\nimport \"./interfaces/IManagedIndexReweightingLogic.sol\";\n\nimport \"./IndexLayout.sol\";\n\n/// @title ManagedIndex reweighting logic\n/// @notice Contains reweighting logic\ncontract ManagedIndexReweightingLogic is IndexLayout, IManagedIndexReweightingLogic, ERC165 {\n    using FullMath for uint;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Asset role\n    bytes32 internal constant ASSET_ROLE = keccak256(\"ASSET_ROLE\");\n\n    /// @inheritdoc IManagedIndexReweightingLogic\n    function reweight(address[] calldata _updatedAssets, uint8[] calldata _updatedWeights) external override {\n        require(\n            _updatedAssets.length > 1 &&\n                _updatedWeights.length == _updatedAssets.length &&\n                _updatedAssets.length <= IIndexRegistry(registry).maxComponents(),\n            \"ManagedIndex: INVALID\"\n        );\n\n        uint virtualEvaluationInBase;\n        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());\n        for (uint i; i < assets.length(); ++i) {\n            uint priceAssetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));\n            uint availableAssets = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)))\n                .assetBalanceOf(address(this));\n            virtualEvaluationInBase += availableAssets.mulDiv(FixedPoint112.Q112, priceAssetPerBaseInUQ);\n        }\n\n        IOrderer orderer = IOrderer(IIndexRegistry(registry).orderer());\n        uint orderId = orderer.placeOrder();\n\n        uint _totalWeight = IndexLibrary.MAX_WEIGHT;\n\n        for (uint i; i < _updatedAssets.length; ++i) {\n            address asset = _updatedAssets[i];\n            require(asset != address(0), \"ManagedIndex: ZERO\");\n\n            uint8 newWeight = _updatedWeights[i];\n\n            if (i > 0) {\n                // makes sure that there are no duplicate assets\n                require(_updatedAssets[i - 1] < asset, \"ManagedIndex: SORT\");\n            }\n\n            if (newWeight > 0) {\n                require(IAccessControl(registry).hasRole(ASSET_ROLE, asset), \"ManagedIndex: INVALID_ASSET\");\n                assets.add(asset);\n                inactiveAssets.remove(asset);\n\n                uint8 prevWeight = weightOf[asset];\n                if (prevWeight != newWeight) {\n                    emit UpdateAnatomy(asset, newWeight);\n                }\n\n                _totalWeight = _totalWeight + newWeight - prevWeight;\n                weightOf[asset] = newWeight;\n\n                uint amountInBase = (virtualEvaluationInBase * weightOf[asset]) / IndexLibrary.MAX_WEIGHT;\n                uint amountInAsset = amountInBase.mulDiv(oracle.refreshedAssetPerBaseInUQ(asset), FixedPoint112.Q112);\n                (uint newShares, uint oldShares) = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(asset))\n                    .shareChange(address(this), amountInAsset);\n\n                if (newShares > oldShares) {\n                    orderer.addOrderDetails(orderId, asset, newShares - oldShares, IOrderer.OrderSide.Buy);\n                } else if (oldShares > newShares) {\n                    orderer.addOrderDetails(orderId, asset, oldShares - newShares, IOrderer.OrderSide.Sell);\n                }\n            } else {\n                require(assets.remove(asset), \"ManagedIndex: INVALID\");\n                inactiveAssets.add(asset);\n\n                _totalWeight -= weightOf[asset];\n\n                delete weightOf[asset];\n\n                emit UpdateAnatomy(asset, 0);\n            }\n        }\n        address[] memory _inactiveAssets = inactiveAssets.values();\n        for (uint i; i < _inactiveAssets.length; ++i) {\n            uint shares = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(_inactiveAssets[i])).balanceOf(address(this));\n            if (shares > 0) {\n                orderer.addOrderDetails(orderId, _inactiveAssets[i], shares, IOrderer.OrderSide.Sell);\n            } else {\n                inactiveAssets.remove(_inactiveAssets[i]);\n            }\n        }\n        require(_totalWeight == IndexLibrary.MAX_WEIGHT, \"ManagedIndex: MAX\");\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IManagedIndexReweightingLogic).interfaceId || super.supportsInterface(_interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/UniswapV2PriceOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\";\n\nimport \"./interfaces/IUniswapV2PriceOracle.sol\";\n\n/// @title Uniswap V2 price oracle\n/// @notice Contains logic for price calculation of asset using Uniswap V2 Pair\n/// @dev Oracle works through base asset which is set in initialize function\ncontract UniswapV2PriceOracle is IUniswapV2PriceOracle, ERC165 {\n    using UniswapV2OracleLibrary for address;\n\n    /// @notice Minimum oracle update interval\n    /// @dev If min update interval hasn't passed (24h) before update, previously cached value is returned\n    uint private constant MIN_UPDATE_INTERVAL = 24 hours;\n\n    IUniswapV2Pair immutable pair;\n    /// @inheritdoc IUniswapV2PriceOracle\n    address public immutable override asset0;\n    /// @inheritdoc IUniswapV2PriceOracle\n    address public immutable override asset1;\n\n    uint private price0CumulativeLast;\n    uint private price1CumulativeLast;\n    uint32 private blockTimestampLast;\n    uint private price0Average;\n    uint private price1Average;\n\n    constructor(\n        address _factory,\n        address _assetA,\n        address _assetB\n    ) {\n        IUniswapV2Pair _pair = IUniswapV2Pair(IUniswapV2Factory(_factory).getPair(_assetA, _assetB));\n        pair = _pair;\n        asset0 = _pair.token0();\n        asset1 = _pair.token1();\n\n        uint112 reserve0;\n        uint112 reserve1;\n        (reserve0, reserve1, blockTimestampLast) = _pair.getReserves();\n        require(reserve0 != 0 && reserve1 != 0, \"UniswapV2PriceOracle: RESERVES\");\n\n        uint _price0CumulativeLast = _pair.price0CumulativeLast();\n        uint _price1CumulativeLast = _pair.price1CumulativeLast();\n        (uint price0Cml, uint price1Cml, uint32 blockTimestamp) = address(_pair).currentCumulativePrices();\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n        price0CumulativeLast = _price0CumulativeLast;\n        price1CumulativeLast = _price1CumulativeLast;\n        price0Average = (price0Cml - _price0CumulativeLast) / timeElapsed;\n        price1Average = (price1Cml - _price1CumulativeLast) / timeElapsed;\n    }\n\n    /// @inheritdoc IPriceOracle\n    /// @dev Updates and returns cumulative price value\n    /// @dev If min update interval hasn't passed (24h), previously cached value is returned\n    function refreshedAssetPerBaseInUQ(address _asset) external override returns (uint) {\n        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) = address(pair).currentCumulativePrices();\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n\n        if (timeElapsed >= MIN_UPDATE_INTERVAL) {\n            price0Average = (price0Cumulative - price0CumulativeLast) / timeElapsed;\n            price1Average = (price1Cumulative - price1CumulativeLast) / timeElapsed;\n\n            price0CumulativeLast = price0Cumulative;\n            price1CumulativeLast = price1Cumulative;\n            blockTimestampLast = blockTimestamp;\n        }\n\n        return lastAssetPerBaseInUQ(_asset);\n    }\n\n    /// @inheritdoc IPriceOracle\n    /// @dev Returns cumulative price value cached during last refresh call\n    function lastAssetPerBaseInUQ(address _asset) public view override returns (uint) {\n        if (_asset == asset0) {\n            return price1Average;\n        } else {\n            require(_asset == asset1, \"UniswapV2PriceOracle: UNKNOWN\");\n            return price0Average;\n        }\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IUniswapV2PriceOracle).interfaceId ||\n            _interfaceId == type(IPriceOracle).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n}"
    }
  ]
}