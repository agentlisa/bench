{
  "Title": "[H-03] Missing Access Control for `FabricateMIRClaim` and `FabricateANCClaim`",
  "Content": "\n<https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-bAsset-contracts/contracts/anchor_airdrop_registry/src/contract.rs#L109><br>\n<https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-bAsset-contracts/contracts/anchor_airdrop_registry/src/contract.rs#L71><br>\n\n`FabricateMIRClaim` and `FabricateANCClaim` should only be issued by the Hub contract (the central hub for all minted bLuna managed by Lido). However, `execute_fabricate_anchor_claim` and `execute_fabricate_mir_claim` do not restrict the caller, allowing anyone to submit these msgs.\n\n### Recommended Mitigation Steps\n\nRecommended to add at least simple access control checks in the contract to ensure that these functions can only be called by the Hub and not by others.\n\nSee a below for a potential code snippet.\n\n    // only hub contract can send this message.\n    let config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.hub_contract {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n**[Alex the Entreprenerd (triage) commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/58#issuecomment-1207280476):**\n > The finding is correct in that anyone can call the function.\n> \n> The finding lacks any form of impact as to what would happen.\n> \n> I think these may be test functions also.\n> \n> Not convinced the report makes sense for high severity given the lack of detail.\n\n\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-02-anchor-contest",
  "Code": [
    {
      "filename": "contracts/anchor-bAsset-contracts/contracts/anchor_airdrop_registry/src/contract.rs",
      "content": "#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    attr, to_binary, Binary, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Response, StdError,\n    StdResult, SubMsg, Uint128, WasmMsg,\n};\n\nuse crate::state::{\n    read_airdrop_info, read_all_airdrop_infos, read_config, remove_airdrop_info,\n    store_airdrop_info, store_config, update_airdrop_info, Config, CONFIG,\n};\nuse basset::airdrop::{\n    ANCAirdropHandleMsg, AirdropInfo, AirdropInfoElem, AirdropInfoResponse, ConfigResponse,\n    ExecuteMsg, InstantiateMsg, MIRAirdropHandleMsg, PairHandleMsg, QueryMsg,\n};\nuse basset::hub::ExecuteMsg as HubHandleMsg;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -> StdResult<Response> {\n    let sndr_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n\n    let config = Config {\n        owner: sndr_raw,\n        hub_contract: msg.hub_contract,\n        reward_contract: msg.reward_contract,\n        airdrop_tokens: vec![],\n    };\n\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -> StdResult<Response> {\n    match msg {\n        ExecuteMsg::FabricateMIRClaim {\n            stage,\n            amount,\n            proof,\n        } => execute_fabricate_mir_claim(deps, env, info, stage, amount, proof),\n        ExecuteMsg::FabricateANCClaim {\n            stage,\n            amount,\n            proof,\n        } => execute_fabricate_anchor_claim(deps, env, info, stage, amount, proof),\n        ExecuteMsg::UpdateConfig {\n            owner,\n            hub_contract,\n            reward_contract,\n        } => execute_update_config(deps, env, info, owner, hub_contract, reward_contract),\n        ExecuteMsg::AddAirdropInfo {\n            airdrop_token,\n            airdrop_info,\n        } => execute_add_airdrop(deps, env, info, airdrop_token, airdrop_info),\n        ExecuteMsg::RemoveAirdropInfo { airdrop_token } => {\n            execute_remove_airdrop(deps, env, info, airdrop_token)\n        }\n        ExecuteMsg::UpdateAirdropInfo {\n            airdrop_token,\n            airdrop_info,\n        } => execute_update_airdrop(deps, env, info, airdrop_token, airdrop_info),\n    }\n}\n\nfn execute_fabricate_mir_claim(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    stage: u8,\n    amount: Uint128,\n    proof: Vec<String>,\n) -> StdResult<Response> {\n    let config = read_config(deps.storage)?;\n\n    let mut messages: Vec<SubMsg> = vec![];\n\n    let airdrop_info = read_airdrop_info(deps.storage, \"MIR\".to_string()).unwrap();\n    messages.push(SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: config.hub_contract,\n        msg: to_binary(&HubHandleMsg::ClaimAirdrop {\n            airdrop_token_contract: airdrop_info.airdrop_token_contract,\n            airdrop_contract: airdrop_info.airdrop_contract,\n            airdrop_swap_contract: airdrop_info.airdrop_swap_contract,\n            claim_msg: to_binary(&MIRAirdropHandleMsg::Claim {\n                stage,\n                amount,\n                proof,\n            })?,\n            swap_msg: to_binary(&PairHandleMsg::Swap {\n                belief_price: airdrop_info.swap_belief_price,\n                max_spread: airdrop_info.swap_max_spread,\n                to: Some(config.reward_contract),\n            })?,\n        })?,\n        funds: vec![],\n    })));\n\n    Ok(Response::new()\n        .add_submessages(messages)\n        .add_attributes(vec![attr(\"action\", \"fabricate_mir_claim\")]))\n}\n\nfn execute_fabricate_anchor_claim(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    stage: u8,\n    amount: Uint128,\n    proof: Vec<String>,\n) -> StdResult<Response> {\n    let config = read_config(deps.storage)?;\n\n    let mut messages: Vec<SubMsg> = vec![];\n\n    let airdrop_info = read_airdrop_info(deps.storage, \"ANC\".to_string())?;\n    messages.push(SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: config.hub_contract,\n        msg: to_binary(&HubHandleMsg::ClaimAirdrop {\n            airdrop_token_contract: airdrop_info.airdrop_token_contract,\n            airdrop_contract: airdrop_info.airdrop_contract,\n            airdrop_swap_contract: airdrop_info.airdrop_swap_contract,\n            claim_msg: to_binary(&ANCAirdropHandleMsg::Claim {\n                stage,\n                amount,\n                proof,\n            })?,\n            swap_msg: to_binary(&PairHandleMsg::Swap {\n                belief_price: airdrop_info.swap_belief_price,\n                max_spread: airdrop_info.swap_max_spread,\n                to: Some(config.reward_contract),\n            })?,\n        })?,\n        funds: vec![],\n    })));\n\n    Ok(Response::new()\n        .add_submessages(messages)\n        .add_attributes(vec![attr(\"action\", \"fabricate_anc_claim\")]))\n}\npub fn execute_update_config(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    owner: Option<String>,\n    hub_contract: Option<String>,\n    reward_contract: Option<String>,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let mut config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    if let Some(o) = owner {\n        let owner_raw = deps.api.addr_canonicalize(&o)?;\n        config.owner = owner_raw\n    }\n    if let Some(hub) = hub_contract {\n        config.hub_contract = hub;\n    }\n    if let Some(reward_addr) = reward_contract {\n        config.reward_contract = reward_addr;\n    }\n\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::new().add_attributes(vec![attr(\"action\", \"update_config\")]))\n}\n\npub fn execute_add_airdrop(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    airdrop_token: String,\n    airdrop_info: AirdropInfo,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let exists = read_airdrop_info(deps.storage, airdrop_token.clone());\n    if exists.is_ok() {\n        return Err(StdError::generic_err(format!(\n            \"There is a token info with this {}\",\n            airdrop_token\n        )));\n    }\n\n    CONFIG.update(deps.storage, |mut conf| -> StdResult<Config> {\n        conf.airdrop_tokens.push(airdrop_token.clone());\n        Ok(conf)\n    })?;\n\n    store_airdrop_info(deps.storage, airdrop_token.clone(), airdrop_info)?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"add_airdrop_info\"),\n        attr(\"airdrop_token\", airdrop_token),\n    ]))\n}\n\npub fn execute_update_airdrop(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    airdrop_token: String,\n    airdrop_info: AirdropInfo,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let exists = read_airdrop_info(deps.storage, airdrop_token.clone());\n    if exists.is_err() {\n        return Err(StdError::generic_err(format!(\n            \"There is no token info with this {}\",\n            airdrop_token\n        )));\n    }\n\n    update_airdrop_info(deps.storage, airdrop_token.clone(), airdrop_info)?;\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"update_airdrop_info\"),\n        attr(\"airdrop_token\", airdrop_token),\n    ]))\n}\n\npub fn execute_remove_airdrop(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    airdrop_token: String,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let exists = read_airdrop_info(deps.storage, airdrop_token.clone());\n    if exists.is_err() {\n        return Err(StdError::generic_err(format!(\n            \"There is no token info with this {}\",\n            airdrop_token\n        )));\n    }\n\n    CONFIG.update(deps.storage, |mut conf| -> StdResult<Config> {\n        conf.airdrop_tokens.retain(|item| item != &airdrop_token);\n        Ok(conf)\n    })?;\n\n    remove_airdrop_info(deps.storage, airdrop_token.clone())?;\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"remove_airdrop_info\"),\n        attr(\"airdrop_token\", airdrop_token),\n    ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    match msg {\n        QueryMsg::Config {} => to_binary(&query_config(deps)?),\n        QueryMsg::AirdropInfo {\n            airdrop_token,\n            start_after,\n            limit,\n        } => to_binary(&query_airdrop_infos(\n            deps,\n            airdrop_token,\n            start_after,\n            limit,\n        )?),\n    }\n}\n\nfn query_config(deps: Deps) -> StdResult<ConfigResponse> {\n    let config = read_config(deps.storage)?;\n    let owner_addr = deps.api.addr_humanize(&config.owner)?;\n\n    Ok(ConfigResponse {\n        owner: owner_addr.to_string(),\n        hub_contract: config.hub_contract,\n        reward_contract: config.reward_contract,\n        airdrop_tokens: config.airdrop_tokens,\n    })\n}\n\nfn query_airdrop_infos(\n    deps: Deps,\n    airdrop_token: Option<String>,\n    start_after: Option<String>,\n    limit: Option<u32>,\n) -> StdResult<AirdropInfoResponse> {\n    if let Some(air_token) = airdrop_token {\n        let info = read_airdrop_info(deps.storage, air_token.clone()).unwrap();\n\n        Ok(AirdropInfoResponse {\n            airdrop_info: vec![AirdropInfoElem {\n                airdrop_token: air_token,\n                info,\n            }],\n        })\n    } else {\n        let infos = read_all_airdrop_infos(deps.storage, start_after, limit)?;\n        Ok(AirdropInfoResponse {\n            airdrop_info: infos,\n        })\n    }\n}"
    },
    {
      "filename": "contracts/anchor-bAsset-contracts/contracts/anchor_airdrop_registry/src/contract.rs",
      "content": "#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    attr, to_binary, Binary, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Response, StdError,\n    StdResult, SubMsg, Uint128, WasmMsg,\n};\n\nuse crate::state::{\n    read_airdrop_info, read_all_airdrop_infos, read_config, remove_airdrop_info,\n    store_airdrop_info, store_config, update_airdrop_info, Config, CONFIG,\n};\nuse basset::airdrop::{\n    ANCAirdropHandleMsg, AirdropInfo, AirdropInfoElem, AirdropInfoResponse, ConfigResponse,\n    ExecuteMsg, InstantiateMsg, MIRAirdropHandleMsg, PairHandleMsg, QueryMsg,\n};\nuse basset::hub::ExecuteMsg as HubHandleMsg;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -> StdResult<Response> {\n    let sndr_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n\n    let config = Config {\n        owner: sndr_raw,\n        hub_contract: msg.hub_contract,\n        reward_contract: msg.reward_contract,\n        airdrop_tokens: vec![],\n    };\n\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -> StdResult<Response> {\n    match msg {\n        ExecuteMsg::FabricateMIRClaim {\n            stage,\n            amount,\n            proof,\n        } => execute_fabricate_mir_claim(deps, env, info, stage, amount, proof),\n        ExecuteMsg::FabricateANCClaim {\n            stage,\n            amount,\n            proof,\n        } => execute_fabricate_anchor_claim(deps, env, info, stage, amount, proof),\n        ExecuteMsg::UpdateConfig {\n            owner,\n            hub_contract,\n            reward_contract,\n        } => execute_update_config(deps, env, info, owner, hub_contract, reward_contract),\n        ExecuteMsg::AddAirdropInfo {\n            airdrop_token,\n            airdrop_info,\n        } => execute_add_airdrop(deps, env, info, airdrop_token, airdrop_info),\n        ExecuteMsg::RemoveAirdropInfo { airdrop_token } => {\n            execute_remove_airdrop(deps, env, info, airdrop_token)\n        }\n        ExecuteMsg::UpdateAirdropInfo {\n            airdrop_token,\n            airdrop_info,\n        } => execute_update_airdrop(deps, env, info, airdrop_token, airdrop_info),\n    }\n}\n\nfn execute_fabricate_mir_claim(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    stage: u8,\n    amount: Uint128,\n    proof: Vec<String>,\n) -> StdResult<Response> {\n    let config = read_config(deps.storage)?;\n\n    let mut messages: Vec<SubMsg> = vec![];\n\n    let airdrop_info = read_airdrop_info(deps.storage, \"MIR\".to_string()).unwrap();\n    messages.push(SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: config.hub_contract,\n        msg: to_binary(&HubHandleMsg::ClaimAirdrop {\n            airdrop_token_contract: airdrop_info.airdrop_token_contract,\n            airdrop_contract: airdrop_info.airdrop_contract,\n            airdrop_swap_contract: airdrop_info.airdrop_swap_contract,\n            claim_msg: to_binary(&MIRAirdropHandleMsg::Claim {\n                stage,\n                amount,\n                proof,\n            })?,\n            swap_msg: to_binary(&PairHandleMsg::Swap {\n                belief_price: airdrop_info.swap_belief_price,\n                max_spread: airdrop_info.swap_max_spread,\n                to: Some(config.reward_contract),\n            })?,\n        })?,\n        funds: vec![],\n    })));\n\n    Ok(Response::new()\n        .add_submessages(messages)\n        .add_attributes(vec![attr(\"action\", \"fabricate_mir_claim\")]))\n}\n\nfn execute_fabricate_anchor_claim(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    stage: u8,\n    amount: Uint128,\n    proof: Vec<String>,\n) -> StdResult<Response> {\n    let config = read_config(deps.storage)?;\n\n    let mut messages: Vec<SubMsg> = vec![];\n\n    let airdrop_info = read_airdrop_info(deps.storage, \"ANC\".to_string())?;\n    messages.push(SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: config.hub_contract,\n        msg: to_binary(&HubHandleMsg::ClaimAirdrop {\n            airdrop_token_contract: airdrop_info.airdrop_token_contract,\n            airdrop_contract: airdrop_info.airdrop_contract,\n            airdrop_swap_contract: airdrop_info.airdrop_swap_contract,\n            claim_msg: to_binary(&ANCAirdropHandleMsg::Claim {\n                stage,\n                amount,\n                proof,\n            })?,\n            swap_msg: to_binary(&PairHandleMsg::Swap {\n                belief_price: airdrop_info.swap_belief_price,\n                max_spread: airdrop_info.swap_max_spread,\n                to: Some(config.reward_contract),\n            })?,\n        })?,\n        funds: vec![],\n    })));\n\n    Ok(Response::new()\n        .add_submessages(messages)\n        .add_attributes(vec![attr(\"action\", \"fabricate_anc_claim\")]))\n}\npub fn execute_update_config(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    owner: Option<String>,\n    hub_contract: Option<String>,\n    reward_contract: Option<String>,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let mut config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    if let Some(o) = owner {\n        let owner_raw = deps.api.addr_canonicalize(&o)?;\n        config.owner = owner_raw\n    }\n    if let Some(hub) = hub_contract {\n        config.hub_contract = hub;\n    }\n    if let Some(reward_addr) = reward_contract {\n        config.reward_contract = reward_addr;\n    }\n\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::new().add_attributes(vec![attr(\"action\", \"update_config\")]))\n}\n\npub fn execute_add_airdrop(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    airdrop_token: String,\n    airdrop_info: AirdropInfo,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let exists = read_airdrop_info(deps.storage, airdrop_token.clone());\n    if exists.is_ok() {\n        return Err(StdError::generic_err(format!(\n            \"There is a token info with this {}\",\n            airdrop_token\n        )));\n    }\n\n    CONFIG.update(deps.storage, |mut conf| -> StdResult<Config> {\n        conf.airdrop_tokens.push(airdrop_token.clone());\n        Ok(conf)\n    })?;\n\n    store_airdrop_info(deps.storage, airdrop_token.clone(), airdrop_info)?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"add_airdrop_info\"),\n        attr(\"airdrop_token\", airdrop_token),\n    ]))\n}\n\npub fn execute_update_airdrop(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    airdrop_token: String,\n    airdrop_info: AirdropInfo,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let exists = read_airdrop_info(deps.storage, airdrop_token.clone());\n    if exists.is_err() {\n        return Err(StdError::generic_err(format!(\n            \"There is no token info with this {}\",\n            airdrop_token\n        )));\n    }\n\n    update_airdrop_info(deps.storage, airdrop_token.clone(), airdrop_info)?;\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"update_airdrop_info\"),\n        attr(\"airdrop_token\", airdrop_token),\n    ]))\n}\n\npub fn execute_remove_airdrop(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    airdrop_token: String,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let exists = read_airdrop_info(deps.storage, airdrop_token.clone());\n    if exists.is_err() {\n        return Err(StdError::generic_err(format!(\n            \"There is no token info with this {}\",\n            airdrop_token\n        )));\n    }\n\n    CONFIG.update(deps.storage, |mut conf| -> StdResult<Config> {\n        conf.airdrop_tokens.retain(|item| item != &airdrop_token);\n        Ok(conf)\n    })?;\n\n    remove_airdrop_info(deps.storage, airdrop_token.clone())?;\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"remove_airdrop_info\"),\n        attr(\"airdrop_token\", airdrop_token),\n    ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    match msg {\n        QueryMsg::Config {} => to_binary(&query_config(deps)?),\n        QueryMsg::AirdropInfo {\n            airdrop_token,\n            start_after,\n            limit,\n        } => to_binary(&query_airdrop_infos(\n            deps,\n            airdrop_token,\n            start_after,\n            limit,\n        )?),\n    }\n}\n\nfn query_config(deps: Deps) -> StdResult<ConfigResponse> {\n    let config = read_config(deps.storage)?;\n    let owner_addr = deps.api.addr_humanize(&config.owner)?;\n\n    Ok(ConfigResponse {\n        owner: owner_addr.to_string(),\n        hub_contract: config.hub_contract,\n        reward_contract: config.reward_contract,\n        airdrop_tokens: config.airdrop_tokens,\n    })\n}\n\nfn query_airdrop_infos(\n    deps: Deps,\n    airdrop_token: Option<String>,\n    start_after: Option<String>,\n    limit: Option<u32>,\n) -> StdResult<AirdropInfoResponse> {\n    if let Some(air_token) = airdrop_token {\n        let info = read_airdrop_info(deps.storage, air_token.clone()).unwrap();\n\n        Ok(AirdropInfoResponse {\n            airdrop_info: vec![AirdropInfoElem {\n                airdrop_token: air_token,\n                info,\n            }],\n        })\n    } else {\n        let infos = read_all_airdrop_infos(deps.storage, start_after, limit)?;\n        Ok(AirdropInfoResponse {\n            airdrop_info: infos,\n        })\n    }\n}"
    }
  ]
}