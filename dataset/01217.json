{
  "Title": "[L-4] Yield update will not happen at the 1k ETH threshold",
  "Content": "# [L-4] Yield update will not happen at the 1k ETH threshold\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/BridgeRouterFacet.sol#L164\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/BridgeRouterFacet.sol#L164</a>\n\n\n## Summary\nYield updates happen for a vault when the `BRIDGE_YIELD_UPDATE_THRESHOLD` is met for the vault after a large bridge deposit. The `maybeUpdateYield` function handles this logic for updates when that happens (1000 ETH to be exact).\n\n## Vulnerability Details\nThreshold constant from:\n```solidity\nFILE: 2023-09-ditto/contracts/libraries/Constants.sol\n\nLine 17:\nuint256 internal constant BRIDGE_YIELD_UPDATE_THRESHOLD = 1000 ether;\n\nLine 18:\nuint256 internal constant BRIDGE_YIELD_PERCENT_THRESHOLD = 0.01 ether; // 1%\n```\n\n```solidity\nFILE: 2023-09-ditto/contracts/facets/BridgeRouterFacet.sol\n\nfunction maybeUpdateYield(uint256 vault, uint88 amount) private {\n        uint88 zethTotal = s.vault[vault].zethTotal;\n        if (\n            zethTotal > Constants.BRIDGE_YIELD_UPDATE_THRESHOLD\n                && amount.div(zethTotal) > Constants.BRIDGE_YIELD_PERCENT_THRESHOLD\n        ) { // @audit should be >= to account for when threshold is met\n            // Update yield for \"large\" bridge deposits\n            vault.updateYield();\n        }\n    }\n```\n\n## Impact\nIn reality the yield update for the vault will not happen in the instances of 1000 ETH deposits unless the bridge deposit amount into the vault is > 1000 ETH and the percent is greater than 1%.\n\n## Tools Used\nManual review\n\n## Recommendations\nChange the `>` operand in the `maybeUpdateYield` function to be `>=`.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/BridgeRouterFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IBridge} from \"contracts/interfaces/IBridge.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {LibBridge} from \"contracts/libraries/LibBridge.sol\";\nimport {LibVault} from \"contracts/libraries/LibVault.sol\";\nimport {Constants, Vault} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract BridgeRouterFacet is Modifiers {\n    using U256 for uint256;\n    using U88 for uint88;\n    using LibBridge for uint256;\n    using LibBridge for address;\n    using LibVault for uint256;\n\n    address private immutable rethBridge;\n    address private immutable stethBridge;\n\n    constructor(address _rethBridge, address _stethBridge) {\n        rethBridge = _rethBridge;\n        stethBridge = _stethBridge;\n    }\n\n    function getZethTotal(uint256 vault)\n        external\n        view\n        nonReentrantView\n        returns (uint256)\n    {\n        return vault.getZethTotal();\n    }\n\n    //@dev does not need read only re-entrancy\n    function getBridges(uint256 vault) external view returns (address[] memory) {\n        return s.vaultBridges[vault];\n    }\n\n    function deposit(address bridge, uint88 amount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (amount < Constants.MIN_DEPOSIT) revert Errors.UnderMinimumDeposit();\n        // @dev amount after deposit might be less, if bridge takes a fee\n        uint88 zethAmount = uint88(IBridge(bridge).deposit(msg.sender, amount)); // @dev(safe-cast)\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        vault.addZeth(zethAmount);\n        maybeUpdateYield(vault, zethAmount);\n        emit Events.Deposit(bridge, msg.sender, zethAmount);\n    }\n\n    function depositEth(address bridge)\n        external\n        payable\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (msg.value < Constants.MIN_DEPOSIT) revert Errors.UnderMinimumDeposit();\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        uint88 zethAmount = uint88(IBridge(bridge).depositEth{value: msg.value}()); // Assumes 1 ETH = 1 ZETH\n        vault.addZeth(zethAmount);\n        maybeUpdateYield(vault, zethAmount);\n        emit Events.DepositEth(bridge, msg.sender, zethAmount);\n    }\n\n    function withdraw(address bridge, uint88 zethAmount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint88 fee;\n        uint256 withdrawalFee = bridge.withdrawalFee();\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        if (withdrawalFee > 0) {\n            fee = zethAmount.mulU88(withdrawalFee);\n            zethAmount -= fee;\n            s.vaultUser[vault][address(this)].ethEscrowed += fee;\n        }\n\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n        vault.removeZeth(zethAmount, fee);\n        IBridge(bridge).withdraw(msg.sender, ethAmount);\n        emit Events.Withdraw(bridge, msg.sender, zethAmount, fee);\n    }\n\n    function unstakeEth(address bridge, uint88 zethAmount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint88 fee = zethAmount.mulU88(bridge.unstakeFee());\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        if (fee > 0) {\n            zethAmount -= fee;\n            s.vaultUser[vault][address(this)].ethEscrowed += fee;\n        }\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n        vault.removeZeth(zethAmount, fee);\n        IBridge(bridge).unstake(msg.sender, ethAmount);\n        emit Events.UnstakeEth(bridge, msg.sender, zethAmount, fee);\n    }\n\n    function withdrawTapp(address bridge, uint88 zethAmount)\n        external\n        onlyDAO\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n\n        s.vaultUser[vault][address(this)].ethEscrowed -= zethAmount;\n        s.vault[vault].zethTotal -= zethAmount;\n\n        IBridge(bridge).withdraw(msg.sender, ethAmount);\n        emit Events.WithdrawTapp(bridge, msg.sender, zethAmount);\n    }\n\n    function maybeUpdateYield(uint256 vault, uint88 amount) private {\n        uint88 zethTotal = s.vault[vault].zethTotal;\n        if (\n            zethTotal > Constants.BRIDGE_YIELD_UPDATE_THRESHOLD\n                && amount.div(zethTotal) > Constants.BRIDGE_YIELD_PERCENT_THRESHOLD\n        ) {\n            // Update yield for \"large\" bridge deposits\n            vault.updateYield();\n        }\n    }\n\n    function _ethConversion(uint256 vault, uint88 amount) private view returns (uint88) {\n        uint256 zethTotalNew = vault.getZethTotal();\n        uint88 zethTotal = s.vault[vault].zethTotal;\n\n        if (zethTotalNew >= zethTotal) {\n            // when yield is positive 1 zeth = 1 eth\n            return amount;\n        } else {\n            // negative yield means 1 zeth < 1 eth\n            return amount.mulU88(zethTotalNew).divU88(zethTotal);\n        }\n    }\n}"
    }
  ]
}