{
  "Title": "H-3: Ineffective slippage mechanism when redeeming proportionally",
  "Content": "# Issue H-3: Ineffective slippage mechanism when redeeming proportionally \n\nSource: https://github.com/sherlock-audit/2023-02-notional-judging/issues/12 \n\n## Found by \nxiaoming90\n\n## Summary\n\nA trade will continue to be executed regardless of how bad the slippage is since the minimum amount returned by the `TwoTokenPoolUtils._getMinExitAmounts` function does not work effectively. Thus, a trade might incur significant slippage, resulting in the vault receiving fewer tokens in return, leading to losses for the vault shareholders.\n\n## Vulnerability Detail\n\nThe `params.minPrimary` and `params.minSecondary` are calculated automatically based on the share of the Curve pool with a small discount within the `Curve2TokenConvexHelper._executeSettlement` function (Refer to Line 124 below)\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/external/Curve2TokenConvexHelper.sol#L112\n\n```solidity\nFile: Curve2TokenConvexHelper.sol\n112:     function _executeSettlement(\n113:         StrategyContext calldata strategyContext,\n114:         Curve2TokenPoolContext calldata poolContext,\n115:         uint256 maturity,\n116:         uint256 poolClaimToSettle,\n117:         uint256 redeemStrategyTokenAmount,\n118:         RedeemParams memory params\n119:     ) private {\n120:         (uint256 spotPrice, uint256 oraclePrice) = poolContext._getSpotPriceAndOraclePrice(strategyContext);\n121: \n122:         /// @notice params.minPrimary and params.minSecondary are not required to be passed in by the caller\n123:         /// for this strategy vault\n124:         (params.minPrimary, params.minSecondary) = poolContext.basePool._getMinExitAmounts({\n125:             strategyContext: strategyContext,\n126:             oraclePrice: oraclePrice,\n127:             spotPrice: spotPrice,\n128:             poolClaim: poolClaimToSettle\n129:         });\n```\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/common/internal/pool/TwoTokenPoolUtils.sol#L48\n\n```solidity\nFile: TwoTokenPoolUtils.sol\n46:     /// @notice calculates the expected primary and secondary amounts based on\n47:     /// the given spot price and oracle price\n48:     function _getMinExitAmounts(\n49:         TwoTokenPoolContext calldata poolContext,\n50:         StrategyContext calldata strategyContext,\n51:         uint256 spotPrice,\n52:         uint256 oraclePrice,\n53:         uint256 poolClaim\n54:     ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n55:         strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n56: \n57:         // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n58:         uint256 totalPoolSupply = poolContext.poolToken.totalSupply();\n        minPrimary = (poolContext.primaryBalance * poolClaim * \n            strategyContext.vaultSettings.poolSlippageLimitPercent) / // @audit-info poolSlippageLimitPercent = 9975, # 0.25%\n            (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS)); // @audit-info VAULT_PERCENT_BASIS = 1e4 = 10000\n62:         minSecondary = (poolContext.secondaryBalance * poolClaim * \n63:             strategyContext.vaultSettings.poolSlippageLimitPercent) / \n64:             (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS));\n65:     }\n```\n\nWhen LP tokens are redeemed proportionally via the Curve Pool's [`remove_liquidity`](https://github.com/curvefi/curve-contract/blob/b0bbf77f8f93c9c5f4e415bce9cd71f0cdee960e/contracts/pools/steth/StableSwapSTETH.vy#L477) function, the tokens received are based on the share of the Curve pool as the source code.\n\n```python\n@external\n@nonreentrant('lock')\ndef remove_liquidity(\n    _amount: uint256,\n    _min_amounts: uint256[N_COINS],\n) -> uint256[N_COINS]:\n    \"\"\"\n    @notice Withdraw coins from the pool\n    @dev Withdrawal amounts are based on current deposit ratios\n    @param _amount Quantity of LP tokens to burn in the withdrawal\n    @param _min_amounts Minimum amounts of underlying coins to receive\n    @return List of amounts of coins that were withdrawn\n    \"\"\"\n    amounts: uint256[N_COINS] = self._balances()\n    lp_token: address = self.lp_token\n    total_supply: uint256 = ERC20(lp_token).totalSupply()\n    CurveToken(lp_token).burnFrom(msg.sender, _amount)  # dev: insufficient funds\n\n    for i in range(N_COINS):\n        value: uint256 = amounts[i] * _amount / total_supply\n        assert value >= _min_amounts[i], \"Withdrawal resulted in fewer coins than expected\"\n\n        amounts[i] = value\n        if i == 0:\n            raw_call(msg.sender, b\"\", value=value)\n        else:\n            assert ERC20(self.coins[1]).transfer(msg.sender, value)\n\n    log RemoveLiquidity(msg.sender, amounts, empty(uint256[N_COINS]), total_supply - _amount)\n\n    return amounts\n```\n\nAssume a Curve Pool with the following state:\n\n- Consists of 200 US Dollars worth of tokens (100 DAI and 100 USDC). DAI is the primary token\n- DAI <> USDC price is 1:1\n- Total Supply = 100 LP Pool Tokens\n\nAssume that 50 LP Pool Tokens will be claimed during vault settlement. \n\n`TwoTokenPoolUtils._getMinExitAmounts` function will return `49.875 DAI` as `params.minPrimary` and `49.875 USDC` as `params.minSecondary` based on the following calculation\n\n```solidity\nminPrimary = (poolContext.primaryBalance * poolClaim * strategyContext.vaultSettings.poolSlippageLimitPercent /  (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS)\nminPrimary = (100 DAI * 50 LP_TOKEN * 99.75% /  (100 LP_TOKEN * 100%)\n\nRewrite for clarity (ignoring rounding error):\nminPrimary = 100 DAI * (50 LP_TOKEN/100 LP_TOKEN) * (99.75%/100%) = 49.875 DAI\n\nminSecondary = same calculation = 49.875 USDC\n```\n\nCurve Pool's [`remove_liquidity`](https://github.com/curvefi/curve-contract/blob/b0bbf77f8f93c9c5f4e415bce9cd71f0cdee960e/contracts/pools/steth/StableSwapSTETH.vy#L477) function will return `50 DAI` and `50 USDC` if 50 LP Pool Tokens are redeemed.\n\nNote that `TwoTokenPoolUtils._getMinExitAmounts` function performs the calculation based on the spot balance of the pool similar to the approach of the Curve Pool's [`remove_liquidity`](https://github.com/curvefi/curve-contract/blob/b0bbf77f8f93c9c5f4e415bce9cd71f0cdee960e/contracts/pools/steth/StableSwapSTETH.vy#L477) function. However, the `TwoTokenPoolUtils._getMinExitAmounts` function applied a discount to the returned result, while the Curve Pool's [`remove_liquidity`](https://github.com/curvefi/curve-contract/blob/b0bbf77f8f93c9c5f4e415bce9cd71f0cdee960e/contracts/pools/steth/StableSwapSTETH.vy#L477) function did not. \n\nAs such, the number of tokens returned by Curve Pool's [`remove_liquidity`](https://github.com/curvefi/curve-contract/blob/b0bbf77f8f93c9c5f4e415bce9cd71f0cdee960e/contracts/pools/steth/StableSwapSTETH.vy#L477) function will always be larger than the number of tokens returned by the `TwoTokenPoolUtils._getMinExitAmounts` function regardless of the on-chain economic condition or the pool state (e.g. imbalance). Thus, the minimum amounts (`minAmounts`) pass into the Curve Pool's `remove_liquidity` function will never be triggered under any circumstance.\n\n```solidity\na = Curve Pool's remove_liquidity => x DAI\nb = TwoTokenPoolUtils._getMinExitAmounts => (x DAI - 0.25% discount)\na > b => true (for all instances)\n```\n\nThus, the `TwoTokenPoolUtils._getMinExitAmounts` function is not effective in determining the slippage when redeeming proportionally.\n\n## Impact\n\nA trade will always be executed even if it returns fewer than expected assets since the minimum amount returned by the `TwoTokenPoolUtils._getMinExitAmounts` function does not work effectively. Thus, a trade might incur unexpected slippage, resulting in the vault receiving fewer tokens in return, leading to losses for the vault shareholders.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/external/Curve2TokenConvexHelper.sol#L112\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/common/internal/pool/TwoTokenPoolUtils.sol#L48\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen redeeming proportional, the`TwoTokenPoolUtils._getMinExitAmounts` function can be removed. Instead, give the caller the flexibility to define the slippage/minimum amount (`params.minPrimary` and `params.minSecondary`). To prevent the caller from setting a slippage that is too large, consider restricting the slippage to an acceptable range.\n\nThe proper way of computing the minimum amount of tokens to receive from a proportional trade (`remove_liquidity`) is to call the Curve's Pool [`calc_token_amount`](https://github.com/curvefi/curve-contract/blob/b0bbf77f8f93c9c5f4e415bce9cd71f0cdee960e/contracts/pools/steth/StableSwapSTETH.vy#L266) function off-chain and reduce the values returned by the allowed slippage amount.\n\nNote that `calc_token_amount` cannot be used solely on-chain for computing the minimum amount because the result can be manipulated because it uses spot balances for computation.\n\nSidenote: Removing `TwoTokenPoolUtils._getMinExitAmounts` function also removes the built-in spot price and oracle price validation. Thus, the caller must remember to define the slippage. Otherwise, the vault settlement will risk being sandwiched. Alternatively, shift the `strategyContext._checkPriceLimit(oraclePrice, spotPrice)` code outside the `TwoTokenPoolUtils._getMinExitAmounts` function.\n\n## Discussion\n\n**jeffywu**\n\nValid, min amounts should be specified by the caller to eliminate the risk of sandwich attacks.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/52",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/external/Curve2TokenConvexHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    Curve2TokenConvexStrategyContext,\n    Curve2TokenPoolContext\n} from \"../CurveVaultTypes.sol\";\nimport {\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState,\n    TwoTokenPoolContext,\n    DepositParams,\n    RedeemParams,\n    ReinvestRewardParams\n} from \"../../common/VaultTypes.sol\";\nimport {TwoTokenPoolUtils} from \"../../common/internal/pool/TwoTokenPoolUtils.sol\";\nimport {SettlementUtils} from \"../../common/internal/settlement/SettlementUtils.sol\";\nimport {StrategyUtils} from \"../../common/internal/strategy/StrategyUtils.sol\";\nimport {VaultStorage} from \"../../common/VaultStorage.sol\";\nimport {VaultEvents} from \"../../common/VaultEvents.sol\";\nimport {Curve2TokenPoolUtils} from \"../internal/pool/Curve2TokenPoolUtils.sol\";\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\n\nlibrary Curve2TokenConvexHelper {\n    using Curve2TokenPoolUtils for Curve2TokenPoolContext;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using StrategyUtils for StrategyContext;\n    using SettlementUtils for StrategyContext;\n    using VaultStorage for StrategyVaultState;\n\n    function deposit(\n        Curve2TokenConvexStrategyContext memory context,\n        uint256 deposit,\n        bytes calldata data\n    ) external returns (uint256 strategyTokensMinted) {\n        DepositParams memory params = abi.decode(data, (DepositParams));\n\n        strategyTokensMinted = context.poolContext._deposit({\n            strategyContext: context.baseStrategy,\n            stakingContext: context.stakingContext,\n            deposit: deposit,\n            params: params\n        });\n    }\n\n    function redeem(\n        Curve2TokenConvexStrategyContext memory context,\n        uint256 strategyTokens,\n        bytes calldata data\n    ) external returns (uint256 finalPrimaryBalance) {\n        RedeemParams memory params = abi.decode(data, (RedeemParams));\n\n        finalPrimaryBalance = context.poolContext._redeem({\n            strategyContext: context.baseStrategy,\n            stakingContext: context.stakingContext,\n            strategyTokens: strategyTokens,\n            params: params\n        });\n    }\n\n    function settleVault(\n        Curve2TokenConvexStrategyContext calldata context,\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        RedeemParams memory params\n    ) external {\n        uint256 poolClaimToSettle = context.baseStrategy._convertStrategyTokensToPoolClaim(strategyTokensToRedeem);\n        \n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            poolClaimToSettle: poolClaimToSettle,\n            redeemStrategyTokenAmount: strategyTokensToRedeem,\n            params: params\n        });\n\n        emit VaultEvents.VaultSettlement(maturity, poolClaimToSettle, strategyTokensToRedeem);\n    }\n\n    function settleVaultEmergency(\n        Curve2TokenConvexStrategyContext calldata context, \n        uint256 maturity, \n        bytes calldata data\n    ) external {\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.emergencySettlementSlippageLimitPercent,\n            data\n        );\n\n        uint256 poolClaimToSettle = context.baseStrategy._getEmergencySettlementParams({\n            maturity: maturity, \n            totalPoolSupply: context.poolContext.basePool.poolToken.totalSupply()\n        });\n\n        uint256 redeemStrategyTokenAmount = \n            context.baseStrategy._convertPoolClaimToStrategyTokens(poolClaimToSettle);\n\n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            poolClaimToSettle: poolClaimToSettle,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n\n        emit VaultEvents.EmergencyVaultSettlement(maturity, poolClaimToSettle, redeemStrategyTokenAmount);    \n    }\n\n    function _executeSettlement(\n        StrategyContext calldata strategyContext,\n        Curve2TokenPoolContext calldata poolContext,\n        uint256 maturity,\n        uint256 poolClaimToSettle,\n        uint256 redeemStrategyTokenAmount,\n        RedeemParams memory params\n    ) private {\n        (uint256 spotPrice, uint256 oraclePrice) = poolContext._getSpotPriceAndOraclePrice(strategyContext);\n\n        /// @notice params.minPrimary and params.minSecondary are not required to be passed in by the caller\n        /// for this strategy vault\n        (params.minPrimary, params.minSecondary) = poolContext.basePool._getMinExitAmounts({\n            strategyContext: strategyContext,\n            oraclePrice: oraclePrice,\n            spotPrice: spotPrice,\n            poolClaim: poolClaimToSettle\n        });\n\n        int256 expectedUnderlyingRedeemed = poolContext._convertStrategyToUnderlying({\n            strategyContext: strategyContext,\n            strategyTokenAmount: redeemStrategyTokenAmount,\n            oraclePrice: oraclePrice,\n            spotPrice: spotPrice\n        });\n\n        strategyContext._executeSettlement({\n            maturity: maturity,\n            expectedUnderlyingRedeemed: expectedUnderlyingRedeemed,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });    \n    }\n\n    function reinvestReward(\n        Curve2TokenConvexStrategyContext calldata context,\n        ReinvestRewardParams calldata params\n    ) external {\n        StrategyContext memory strategyContext = context.baseStrategy;\n        Curve2TokenPoolContext calldata poolContext = context.poolContext; \n\n        (\n            address rewardToken, \n            uint256 primaryAmount, \n            uint256 secondaryAmount\n        ) = poolContext.basePool._executeRewardTrades({\n            rewardTokens: context.stakingContext.rewardTokens,\n            tradingModule: strategyContext.tradingModule,\n            data: params.tradeData\n        });\n\n        // Make sure we are joining with the right proportion to minimize slippage\n        poolContext._validateSpotPriceAndPairPrice({\n            strategyContext: strategyContext,\n            oraclePrice: poolContext.basePool._getOraclePairPrice(strategyContext),\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount\n        });\n\n        uint256 poolClaimAmount = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: context.stakingContext,\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount,\n            /// @notice minPoolClaim is not required to be set by the caller because primaryAmount\n            /// and secondaryAmount are already validated\n            minPoolClaim: params.minPoolClaim      \n        });\n\n        strategyContext.vaultState.totalPoolClaim += poolClaimAmount;\n        strategyContext.vaultState.setStrategyVaultState(); \n\n        emit VaultEvents.RewardReinvested(rewardToken, primaryAmount, secondaryAmount, poolClaimAmount);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/common/internal/pool/TwoTokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {\n    TwoTokenPoolContext, \n    StrategyContext, \n    DepositTradeParams, \n    TradeParams,\n    SingleSidedRewardTradeParams,\n    Proportional2TokenRewardTradeParams,\n    RedeemParams\n} from \"../../VaultTypes.sol\";\nimport {VaultConstants} from \"../../VaultConstants.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {RewardUtils} from \"../reward/RewardUtils.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {IERC20} from \"../../../../../interfaces/IERC20.sol\";\n\nlibrary TwoTokenPoolUtils {\n    using StrategyUtils for StrategyContext;\n\n    /// @notice Gets the oracle price pair price between two tokens using a weighted\n    /// average between a chainlink oracle and the balancer TWAP oracle.\n    /// @param poolContext oracle context variables\n    /// @param strategyContext strategy context variables\n    /// @return oraclePairPrice oracle price for the pair in 18 decimals\n    function _getOraclePairPrice(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext\n    ) internal view returns (uint256 oraclePairPrice) {\n        (int256 rate, int256 decimals) = strategyContext.tradingModule.getOraclePrice(\n            poolContext.primaryToken, poolContext.secondaryToken\n        );\n        require(rate > 0);\n        require(decimals >= 0);\n\n        if (uint256(decimals) != strategyContext.poolClaimPrecision) {\n            rate = (rate * int256(strategyContext.poolClaimPrecision)) / decimals;\n        }\n\n        // No overflow in rate conversion, checked above\n        oraclePairPrice = uint256(rate);\n    }\n\n    /// @notice calculates the expected primary and secondary amounts based on\n    /// the given spot price and oracle price\n    function _getMinExitAmounts(\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 spotPrice,\n        uint256 oraclePrice,\n        uint256 poolClaim\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalPoolSupply = poolContext.poolToken.totalSupply();\n        minPrimary = (poolContext.primaryBalance * poolClaim * \n            strategyContext.vaultSettings.poolSlippageLimitPercent) / \n            (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * poolClaim * \n            strategyContext.vaultSettings.poolSlippageLimitPercent) / \n            (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _getTimeWeightedPrimaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        uint256 poolClaim,\n        uint256 oraclePrice,\n        uint256 spotPrice\n    ) internal view returns (uint256 primaryAmount) {\n        // Make sure spot price is within oracleDeviationLimit of pairPrice\n        strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n        \n        // Get shares of primary and secondary balances with the provided poolClaim\n        uint256 totalSupply = poolContext.poolToken.totalSupply();\n        uint256 primaryBalance = poolContext.primaryBalance * poolClaim / totalSupply;\n        uint256 secondaryBalance = poolContext.secondaryBalance * poolClaim / totalSupply;\n\n        // Value the secondary balance in terms of the primary token using the oraclePairPrice\n        uint256 secondaryAmountInPrimary = secondaryBalance * strategyContext.poolClaimPrecision / oraclePrice;\n\n        // Make sure primaryAmount is reported in primaryPrecision\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        primaryAmount = (primaryBalance + secondaryAmountInPrimary) * primaryPrecision / strategyContext.poolClaimPrecision;\n    }\n\n    /// @notice Trade primary currency for secondary if the trade is specified\n    function _tradePrimaryForSecondary(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        bytes memory data\n    ) internal returns (uint256 primarySold, uint256 secondaryBought) {\n        (DepositTradeParams memory params) = abi.decode(data, (DepositTradeParams));\n\n        (primarySold, secondaryBought) = StrategyUtils._executeTradeExactIn({\n            params: params.tradeParams, \n            tradingModule: strategyContext.tradingModule, \n            sellToken: poolContext.primaryToken, \n            buyToken: poolContext.secondaryToken, \n            amount: params.tradeAmount,\n            useDynamicSlippage: true\n        });\n    }\n\n    function _sellSecondaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        RedeemParams memory params,\n        uint256 secondaryBalance\n    ) internal returns (uint256 primaryPurchased) {\n        (TradeParams memory tradeParams) = abi.decode(\n            params.secondaryTradeParams, (TradeParams)\n        );\n\n        ( /*uint256 amountSold */, primaryPurchased) = \n            StrategyUtils._executeTradeExactIn({\n                params: tradeParams,\n                tradingModule: strategyContext.tradingModule,\n                sellToken: poolContext.secondaryToken,\n                buyToken: poolContext.primaryToken,\n                amount: secondaryBalance,\n                useDynamicSlippage: true\n            });\n    }\n\n    function _validateTrades(\n        IERC20[] memory rewardTokens,\n        SingleSidedRewardTradeParams memory primaryTrade,\n        SingleSidedRewardTradeParams memory secondaryTrade,\n        address primaryToken,\n        address secondaryToken\n    ) private pure {\n        // Validate trades\n        if (!RewardUtils._isValidRewardToken(rewardTokens, primaryTrade.sellToken)) {\n            revert Errors.InvalidRewardToken(primaryTrade.sellToken);\n        }\n        if (secondaryTrade.sellToken != primaryTrade.sellToken) {\n            revert Errors.InvalidRewardToken(secondaryTrade.sellToken);\n        }\n        if (primaryTrade.buyToken != primaryToken) {\n            revert Errors.InvalidRewardToken(primaryTrade.buyToken);\n        }\n        if (secondaryTrade.buyToken != secondaryToken) {\n            revert Errors.InvalidRewardToken(secondaryTrade.buyToken);\n        }\n    }\n\n    function _executeRewardTrades(\n        TwoTokenPoolContext calldata poolContext,\n        IERC20[] memory rewardTokens,\n        ITradingModule tradingModule,\n        bytes calldata data\n    ) internal returns (address rewardToken, uint256 primaryAmount, uint256 secondaryAmount) {\n        Proportional2TokenRewardTradeParams memory params = abi.decode(\n            data,\n            (Proportional2TokenRewardTradeParams)\n        );\n\n        _validateTrades(\n            rewardTokens,\n            params.primaryTrade,\n            params.secondaryTrade,\n            poolContext.primaryToken,\n            poolContext.secondaryToken\n        );\n\n        (/*uint256 amountSold*/, primaryAmount) = StrategyUtils._executeTradeExactIn({\n            params: params.primaryTrade.tradeParams,\n            tradingModule: tradingModule,\n            sellToken: params.primaryTrade.sellToken,\n            buyToken: params.primaryTrade.buyToken,\n            amount: params.primaryTrade.amount,\n            useDynamicSlippage: false\n        });\n\n        (/*uint256 amountSold*/, secondaryAmount) = StrategyUtils._executeTradeExactIn({\n            params: params.secondaryTrade.tradeParams,\n            tradingModule: tradingModule,\n            sellToken: params.secondaryTrade.sellToken,\n            buyToken: params.secondaryTrade.buyToken,\n            amount: params.secondaryTrade.amount,\n            useDynamicSlippage: false\n        });\n\n        rewardToken = params.primaryTrade.sellToken;\n    }\n}"
    },
    {
      "filename": "contracts/pools/steth/StableSwapSTETH.vy",
      "content": "# @version 0.2.8\n\"\"\"\n@title Curve ETH/stETH StableSwap\n@author Curve.Fi\n@license Copyright (c) Curve.Fi, 2020 - all rights reserved\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\n\ninterface CurveToken:\n    def mint(_to: address, _value: uint256) -> bool: nonpayable\n    def burnFrom(_to: address, _value: uint256) -> bool: nonpayable\n\n\n# Events\nevent TokenExchange:\n    buyer: indexed(address)\n    sold_id: int128\n    tokens_sold: uint256\n    bought_id: int128\n    tokens_bought: uint256\n\nevent TokenExchangeUnderlying:\n    buyer: indexed(address)\n    sold_id: int128\n    tokens_sold: uint256\n    bought_id: int128\n    tokens_bought: uint256\n\nevent AddLiquidity:\n    provider: indexed(address)\n    token_amounts: uint256[N_COINS]\n    fees: uint256[N_COINS]\n    invariant: uint256\n    token_supply: uint256\n\nevent RemoveLiquidity:\n    provider: indexed(address)\n    token_amounts: uint256[N_COINS]\n    fees: uint256[N_COINS]\n    token_supply: uint256\n\nevent RemoveLiquidityOne:\n    provider: indexed(address)\n    token_amount: uint256\n    coin_amount: uint256\n\nevent RemoveLiquidityImbalance:\n    provider: indexed(address)\n    token_amounts: uint256[N_COINS]\n    fees: uint256[N_COINS]\n    invariant: uint256\n    token_supply: uint256\n\nevent CommitNewAdmin:\n    deadline: indexed(uint256)\n    admin: indexed(address)\n\nevent NewAdmin:\n    admin: indexed(address)\n\nevent CommitNewFee:\n    deadline: indexed(uint256)\n    fee: uint256\n    admin_fee: uint256\n\nevent NewFee:\n    fee: uint256\n    admin_fee: uint256\n\nevent RampA:\n    old_A: uint256\n    new_A: uint256\n    initial_time: uint256\n    future_time: uint256\n\nevent StopRampA:\n    A: uint256\n    t: uint256\n\n\n# These constants must be set prior to compiling\nN_COINS: constant(int128) = 2\n\n# fixed constants\nFEE_DENOMINATOR: constant(uint256) = 10 ** 10\nPRECISION: constant(uint256) = 10 ** 18  # The precision to convert to\n\nMAX_ADMIN_FEE: constant(uint256) = 10 * 10 ** 9\nMAX_FEE: constant(uint256) = 5 * 10 ** 9\n\nMAX_A: constant(uint256) = 10 ** 6\nMAX_A_CHANGE: constant(uint256) = 10\nA_PRECISION: constant(uint256) = 100\n\nADMIN_ACTIONS_DELAY: constant(uint256) = 3 * 86400\nMIN_RAMP_TIME: constant(uint256) = 86400\n\ncoins: public(address[N_COINS])\nadmin_balances: public(uint256[N_COINS])\n\nfee: public(uint256)  # fee * 1e10\nadmin_fee: public(uint256)  # admin_fee * 1e10\n\nowner: public(address)\nlp_token: public(address)\n\ninitial_A: public(uint256)\nfuture_A: public(uint256)\ninitial_A_time: public(uint256)\nfuture_A_time: public(uint256)\n\nadmin_actions_deadline: public(uint256)\ntransfer_ownership_deadline: public(uint256)\nfuture_fee: public(uint256)\nfuture_admin_fee: public(uint256)\nfuture_owner: public(address)\n\nis_killed: bool\nkill_deadline: uint256\nKILL_DEADLINE_DT: constant(uint256) = 2 * 30 * 86400\n\n\n@external\ndef __init__(\n    _owner: address,\n    _coins: address[N_COINS],\n    _pool_token: address,\n    _A: uint256,\n    _fee: uint256,\n    _admin_fee: uint256\n):\n    \"\"\"\n    @notice Contract constructor\n    @param _owner Contract owner address\n    @param _coins Addresses of ERC20 conracts of coins\n    @param _pool_token Address of the token representing LP share\n    @param _A Amplification coefficient multiplied by n * (n - 1)\n    @param _fee Fee to charge for exchanges\n    @param _admin_fee Admin fee\n    \"\"\"\n    assert _coins[0] == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n    assert _coins[1] != ZERO_ADDRESS\n\n    self.coins = _coins\n    self.initial_A = _A * A_PRECISION\n    self.future_A = _A * A_PRECISION\n    self.fee = _fee\n    self.admin_fee = _admin_fee\n    self.owner = _owner\n    self.kill_deadline = block.timestamp + KILL_DEADLINE_DT\n    self.lp_token = _pool_token\n\n\n@view\n@internal\ndef _A() -> uint256:\n    t1: uint256 = self.future_A_time\n    A1: uint256 = self.future_A\n\n    if block.timestamp < t1:\n        # handle ramping up and down of A\n        A0: uint256 = self.initial_A\n        t0: uint256 = self.initial_A_time\n        # Expressions in uint256 cannot have negative numbers, thus \"if\"\n        if A1 > A0:\n            return A0 + (A1 - A0) * (block.timestamp - t0) / (t1 - t0)\n        else:\n            return A0 - (A0 - A1) * (block.timestamp - t0) / (t1 - t0)\n\n    else:  # when t1 == 0 or block.timestamp >= t1\n        return A1\n\n\n@view\n@external\ndef A() -> uint256:\n    return self._A() / A_PRECISION\n\n\n@view\n@external\ndef A_precise() -> uint256:\n    return self._A()\n\n\n@view\n@internal\ndef _balances(_value: uint256 = 0) -> uint256[N_COINS]:\n    return [\n        self.balance - self.admin_balances[0] - _value,\n        ERC20(self.coins[1]).balanceOf(self) - self.admin_balances[1]\n    ]\n\n\n@view\n@external\ndef balances(i: uint256) -> uint256:\n    \"\"\"\n    @notice Get the current balance of a coin within the\n            pool, less the accrued admin fees\n    @param i Index value for the coin to query balance of\n    @return Token balance\n    \"\"\"\n    return self._balances()[i]\n\n\n@pure\n@internal\ndef get_D(xp: uint256[N_COINS], amp: uint256) -> uint256:\n    \"\"\"\n    D invariant calculation in non-overflowing integer operations\n    iteratively\n\n    A * sum(x_i) * n**n + D = A * D * n**n + D**(n+1) / (n**n * prod(x_i))\n\n    Converging solution:\n    D[j+1] = (A * n**n * sum(x_i) - D[j]**(n+1) / (n**n prod(x_i))) / (A * n**n - 1)\n    \"\"\"\n    S: uint256 = 0\n    Dprev: uint256 = 0\n\n    for _x in xp:\n        S += _x\n    if S == 0:\n        return 0\n\n    D: uint256 = S\n    Ann: uint256 = amp * N_COINS\n    for _i in range(255):\n        D_P: uint256 = D\n        for _x in xp:\n            D_P = D_P * D / (_x * N_COINS + 1)  # +1 is to prevent /0\n        Dprev = D\n        D = (Ann * S / A_PRECISION + D_P * N_COINS) * D / ((Ann - A_PRECISION) * D / A_PRECISION + (N_COINS + 1) * D_P)\n        # Equality with the precision of 1\n        if D > Dprev:\n            if D - Dprev <= 1:\n                return D\n        else:\n            if Dprev - D <= 1:\n                return D\n    # convergence typically occurs in 4 rounds or less, this should be unreachable!\n    # if it does happen the pool is borked and LPs can withdraw via `remove_liquidity`\n    raise\n\n\n@view\n@external\ndef get_virtual_price() -> uint256:\n    \"\"\"\n    @notice The current virtual price of the pool LP token\n    @dev Useful for calculating profits\n    @return LP token virtual price normalized to 1e18\n    \"\"\"\n    D: uint256 = self.get_D(self._balances(), self._A())\n    # D is in the units similar to DAI (e.g. converted to precision 1e18)\n    # When balanced, D = n * x_u - total virtual value of the portfolio\n    token_supply: uint256 = ERC20(self.lp_token).totalSupply()\n    return D * PRECISION / token_supply\n\n\n@view\n@external\ndef calc_token_amount(amounts: uint256[N_COINS], is_deposit: bool) -> uint256:\n    \"\"\"\n    @notice Calculate addition or reduction in token supply from a deposit or withdrawal\n    @dev This calculation accounts for slippage, but not fees.\n         Needed to prevent front-running, not for precise calculations!\n    @param amounts Amount of each coin being deposited\n    @param is_deposit set True for deposits, False for withdrawals\n    @return Expected amount of LP tokens received\n    \"\"\"\n    amp: uint256 = self._A()\n    balances: uint256[N_COINS] = self._balances()\n    D0: uint256 = self.get_D(balances, amp)\n    for i in range(N_COINS):\n        if is_deposit:\n            balances[i] += amounts[i]\n        else:\n            balances[i] -= amounts[i]\n    D1: uint256 = self.get_D(balances, amp)\n    token_amount: uint256 = ERC20(self.lp_token).totalSupply()\n    diff: uint256 = 0\n    if is_deposit:\n        diff = D1 - D0\n    else:\n        diff = D0 - D1\n    return diff * token_amount / D0\n\n\n@payable\n@external\n@nonreentrant('lock')\ndef add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256) -> uint256:\n    \"\"\"\n    @notice Deposit coins into the pool\n    @param amounts List of amounts of coins to deposit\n    @param min_mint_amount Minimum amount of LP tokens to mint from the deposit\n    @return Amount of LP tokens received by depositing\n    \"\"\"\n    assert not self.is_killed  # dev: is killed\n\n    # Initial invariant\n    amp: uint256 = self._A()\n    old_balances: uint256[N_COINS] = self._balances(msg.value)\n    D0: uint256 = self.get_D(old_balances, amp)\n\n    lp_token: address = self.lp_token\n    token_supply: uint256 = ERC20(lp_token).totalSupply()\n    new_balances: uint256[N_COINS] = old_balances\n    for i in range(N_COINS):\n        if token_supply == 0:\n            assert amounts[i] > 0  # dev: initial deposit requires all coins\n        new_balances[i] += amounts[i]\n\n    # Invariant after change\n    D1: uint256 = self.get_D(new_balances, amp)\n    assert D1 > D0\n\n    # We need to recalculate the invariant accounting for fees\n    # to calculate fair user's share\n    fees: uint256[N_COINS] = empty(uint256[N_COINS])\n    mint_amount: uint256 = 0\n    D2: uint256 = 0\n    if token_supply > 0:\n        # Only account for fees if we are not the first to deposit\n        fee: uint256 = self.fee * N_COINS / (4 * (N_COINS - 1))\n        admin_fee: uint256 = self.admin_fee\n        for i in range(N_COINS):\n            ideal_balance: uint256 = D1 * old_balances[i] / D0\n            difference: uint256 = 0\n            if ideal_balance > new_balances[i]:\n                difference = ideal_balance - new_balances[i]\n            else:\n                difference = new_balances[i] - ideal_balance\n            fees[i] = fee * difference / FEE_DENOMINATOR\n            if admin_fee != 0:\n                self.admin_balances[i] += fees[i] * admin_fee / FEE_DENOMINATOR\n            new_balances[i] -= fees[i]\n        D2 = self.get_D(new_balances, amp)\n        mint_amount = token_supply * (D2 - D0) / D0\n    else:\n        mint_amount = D1  # Take the dust if there was any\n\n    assert mint_amount >= min_mint_amount, \"Slippage screwed you\"\n\n    # Take coins from the sender\n    assert msg.value == amounts[0]\n    if amounts[1] > 0:\n        assert ERC20(self.coins[1]).transferFrom(msg.sender, self, amounts[1])\n\n    # Mint pool tokens\n    CurveToken(lp_token).mint(msg.sender, mint_amount)\n\n    log AddLiquidity(msg.sender, amounts, fees, D1, token_supply + mint_amount)\n\n    return mint_amount\n\n\n@view\n@internal\ndef get_y(i: int128, j: int128, x: uint256, xp: uint256[N_COINS]) -> uint256:\n    \"\"\"\n    Calculate x[j] if one makes x[i] = x\n\n    Done by solving quadratic equation iteratively.\n    x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n    x_1**2 + b*x_1 = c\n\n    x_1 = (x_1**2 + c) / (2*x_1 + b)\n    \"\"\"\n    # x in the input is converted to the same price/precision\n\n    assert i != j       # dev: same coin\n    assert j >= 0       # dev: j below zero\n    assert j < N_COINS  # dev: j above N_COINS\n\n    # should be unreachable, but good for safety\n    assert i >= 0\n    assert i < N_COINS\n\n    amp: uint256 = self._A()\n    D: uint256 = self.get_D(xp, amp)\n    Ann: uint256 = amp * N_COINS\n    c: uint256 = D\n    S_: uint256 = 0\n    _x: uint256 = 0\n    y_prev: uint256 = 0\n\n    for _i in range(N_COINS):\n        if _i == i:\n            _x = x\n        elif _i != j:\n            _x = xp[_i]\n        else:\n            continue\n        S_ += _x\n        c = c * D / (_x * N_COINS)\n    c = c * D * A_PRECISION / (Ann * N_COINS)\n    b: uint256 = S_ + D * A_PRECISION / Ann  # - D\n    y: uint256 = D\n    for _i in range(255):\n        y_prev = y\n        y = (y*y + c) / (2 * y + b - D)\n        # Equality with the precision of 1\n        if y > y_prev:\n            if y - y_prev <= 1:\n                return y\n        else:\n            if y_prev - y <= 1:\n                return y\n    raise\n\n\n@view\n@external\ndef get_dy(i: int128, j: int128, dx: uint256) -> uint256:\n    xp: uint256[N_COINS] = self._balances()\n    x: uint256 = xp[i] + dx\n    y: uint256 = self.get_y(i, j, x, xp)\n    dy: uint256 = xp[j] - y - 1\n    fee: uint256 = self.fee * dy / FEE_DENOMINATOR\n    return dy - fee\n\n\n@payable\n@external\n@nonreentrant('lock')\ndef exchange(i: int128, j: int128, dx: uint256, min_dy: uint256) -> uint256:\n    \"\"\"\n    @notice Perform an exchange between two coins\n    @dev Index values can be found via the `coins` public getter method\n    @param i Index value for the coin to send\n    @param j Index valie of the coin to recieve\n    @param dx Amount of `i` being exchanged\n    @param min_dy Minimum amount of `j` to receive\n    @return Actual amount of `j` received\n    \"\"\"\n    assert not self.is_killed  # dev: is killed\n    # dx and dy are in aTokens\n\n    xp: uint256[N_COINS] = self._balances(msg.value)\n\n    x: uint256 = xp[i] + dx\n    y: uint256 = self.get_y(i, j, x, xp)\n    dy: uint256 = xp[j] - y - 1\n    dy_fee: uint256 = dy * self.fee / FEE_DENOMINATOR\n\n    # Convert all to real units\n    dy = dy - dy_fee\n    assert dy >= min_dy, \"Exchange resulted in fewer coins than expected\"\n\n    admin_fee: uint256 = self.admin_fee\n    if admin_fee != 0:\n        dy_admin_fee: uint256 = dy_fee * admin_fee / FEE_DENOMINATOR\n        if dy_admin_fee != 0:\n            self.admin_balances[j] += dy_admin_fee\n\n    coin: address = self.coins[1]\n    if i == 0:\n        assert msg.value == dx\n        assert ERC20(coin).transfer(msg.sender, dy)\n    else:\n        assert msg.value == 0\n        assert ERC20(coin).transferFrom(msg.sender, self, dx)\n        raw_call(msg.sender, b\"\", value=dy)\n\n    log TokenExchange(msg.sender, i, dx, j, dy)\n\n    return dy\n\n\n@external\n@nonreentrant('lock')\ndef remove_liquidity(\n    _amount: uint256,\n    _min_amounts: uint256[N_COINS],\n) -> uint256[N_COINS]:\n    \"\"\"\n    @notice Withdraw coins from the pool\n    @dev Withdrawal amounts are based on current deposit ratios\n    @param _amount Quantity of LP tokens to burn in the withdrawal\n    @param _min_amounts Minimum amounts of underlying coins to receive\n    @return List of amounts of coins that were withdrawn\n    \"\"\"\n    amounts: uint256[N_COINS] = self._balances()\n    lp_token: address = self.lp_token\n    total_supply: uint256 = ERC20(lp_token).totalSupply()\n    CurveToken(lp_token).burnFrom(msg.sender, _amount)  # dev: insufficient funds\n\n    for i in range(N_COINS):\n        value: uint256 = amounts[i] * _amount / total_supply\n        assert value >= _min_amounts[i], \"Withdrawal resulted in fewer coins than expected\"\n\n        amounts[i] = value\n        if i == 0:\n            raw_call(msg.sender, b\"\", value=value)\n        else:\n            assert ERC20(self.coins[1]).transfer(msg.sender, value)\n\n    log RemoveLiquidity(msg.sender, amounts, empty(uint256[N_COINS]), total_supply - _amount)\n\n    return amounts\n\n\n@external\n@nonreentrant('lock')\ndef remove_liquidity_imbalance(\n    _amounts: uint256[N_COINS],\n    _max_burn_amount: uint256\n) -> uint256:\n    \"\"\"\n    @notice Withdraw coins from the pool in an imbalanced amount\n    @param _amounts List of amounts of underlying coins to withdraw\n    @param _max_burn_amount Maximum amount of LP token to burn in the withdrawal\n    @return Actual amount of the LP token burned in the withdrawal\n    \"\"\"\n    assert not self.is_killed  # dev: is killed\n\n    amp: uint256 = self._A()\n    old_balances: uint256[N_COINS] = self._balances()\n    D0: uint256 = self.get_D(old_balances, amp)\n    new_balances: uint256[N_COINS] = old_balances\n    for i in range(N_COINS):\n        new_balances[i] -= _amounts[i]\n    D1: uint256 = self.get_D(new_balances, amp)\n\n    fees: uint256[N_COINS] = empty(uint256[N_COINS])\n    fee: uint256 = self.fee * N_COINS / (4 * (N_COINS - 1))\n    admin_fee: uint256 = self.admin_fee\n    for i in range(N_COINS):\n        ideal_balance: uint256 = D1 * old_balances[i] / D0\n        new_balance: uint256 = new_balances[i]\n        difference: uint256 = 0\n        if ideal_balance > new_balance:\n            difference = ideal_balance - new_balance\n        else:\n            difference = new_balance - ideal_balance\n        fees[i] = fee * difference / FEE_DENOMINATOR\n        if admin_fee != 0:\n            self.admin_balances[i] += fees[i] * admin_fee / FEE_DENOMINATOR\n        new_balances[i] -= fees[i]\n    D2: uint256 = self.get_D(new_balances, amp)\n\n    lp_token: address = self.lp_token\n    token_supply: uint256 = ERC20(lp_token).totalSupply()\n    token_amount: uint256 = (D0 - D2) * token_supply / D0\n\n    assert token_amount != 0  # dev: zero tokens burned\n    assert token_amount <= _max_burn_amount, \"Slippage screwed you\"\n\n    CurveToken(lp_token).burnFrom(msg.sender, token_amount)  # dev: insufficient funds\n\n    if _amounts[0] != 0:\n        raw_call(msg.sender, b\"\", value=_amounts[0])\n    if _amounts[1] != 0:\n        assert ERC20(self.coins[1]).transfer(msg.sender, _amounts[1])\n\n    log RemoveLiquidityImbalance(msg.sender, _amounts, fees, D1, token_supply - token_amount)\n\n    return token_amount\n\n\n@pure\n@internal\ndef get_y_D(A_: uint256, i: int128, xp: uint256[N_COINS], D: uint256) -> uint256:\n    \"\"\"\n    Calculate x[i] if one reduces D from being calculated for xp to D\n\n    Done by solving quadratic equation iteratively.\n    x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n    x_1**2 + b*x_1 = c\n\n    x_1 = (x_1**2 + c) / (2*x_1 + b)\n    \"\"\"\n    # x in the input is converted to the same price/precision\n\n    assert i >= 0       # dev: i below zero\n    assert i < N_COINS  # dev: i above N_COINS\n\n    Ann: uint256 = A_ * N_COINS\n    c: uint256 = D\n    S_: uint256 = 0\n    _x: uint256 = 0\n    y_prev: uint256 = 0\n\n    for _i in range(N_COINS):\n        if _i != i:\n            _x = x"
    }
  ]
}