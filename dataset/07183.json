{
  "Title": "[G-24] Avoid contract existence checks by using solidity version 0.8.10 or later",
  "Content": "\nPrior to 0.8.10 the compiler inserted extra code, including EXTCODESIZE (100 gas), to check for contract existence for external calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value\n\n57 results - 6 files:\n\n```solidity\npackages\\v2-token\\src\\TimeswapV2LiquidityToken.sol:\n   66:    amount = balanceOf(owner, _timeswapV2LiquidityTokenPositionIds[timeswapV2LiquidityTokenPosition.toKey()]);\n\n   71:    safeTransferFrom(from, to, _timeswapV2LiquidityTokenPositionIds[timeswapV2LiquidityTokenPosition.toKey()], liquidityAmount, bytes(\"\"));\n\n   81:    uint256 id = _timeswapV2LiquidityTokenPositionIds[position.toKey()];\n \n  109:    bytes32 key = timeswapV2LiquidityTokenPosition.toKey();\n  \n  153:    bytes32 key = TimeswapV2LiquidityTokenPosition({token0: param.token0, token1: param.token1, strike: param.strike, maturity: param.maturity}).toKey();\n \n  185:    bytes32 key = TimeswapV2LiquidityTokenPosition({token0: param.token0, token1: param.token1, strike: param.strike, maturity: param.maturity}).toKey();\n\n  125:    uint160 liquidityBalanceTarget = ITimeswapV2Pool(poolPair).liquidityOf(param.strike, param.maturity, address(this)) + param.liquidityAmount;\n\n  143:    Error.checkEnough(ITimeswapV2Pool(poolPair).liquidityOf(param.strike, param.maturity, address(this)), liquidityBalanceTarget);\n\n  125:    uint160 liquidityBalanceTarget = ITimeswapV2Pool(poolPair).liquidityOf(param.strike, param.maturity, address(this)) + param.liquidityAmount;\n\n  143:    Error.checkEnough(ITimeswapV2Pool(poolPair).liquidityOf(param.strike, param.maturity, address(this)), liquidityBalanceTarget);\n\n  131:    data = ITimeswapV2LiquidityTokenMintCallback(msg.sender).timeswapV2LiquidityTokenMintCallback(\n\n  163:    data = ITimeswapV2LiquidityTokenBurnCallback(msg.sender).timeswapV2LiquidityTokenBurnCallback(\n\n  160:    ITimeswapV2Pool(poolPair).transferLiquidity(param.strike, param.maturity, param.to, param.liquidityAmount);\n\n  193:    ITimeswapV2Pool(poolPair).transferFees(param.strike, param.maturity, param.to, long0Fees, long1Fees, shortFees);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2LiquidityToken.sol#L66\n\n```solidity\npackages\\v2-token\\src\\TimeswapV2Token.sol:\n   67:    amount = ERC1155.balanceOf(owner, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()]);\n\n   72:    safeTransferFrom(from, to, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], (amount), bytes(\"\"));\n\n   97:    bytes32 key = timeswapV2TokenPosition.toKey();\n  \n  127:    bytes32 key = timeswapV2TokenPosition.toKey();\n \n  156:    bytes32 key = timeswapV2TokenPosition.toKey();\n  \n  240:    _burn(msg.sender, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], param.long0Amount);\n\n  254:    _burn(msg.sender, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], param.long1Amount);\n\n  268:    _burn(msg.sender, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], param.shortAmount);\n\n   87:    long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + param.long0Amount;\n\n  117:    long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + param.long1Amount;\n\n  146:    shortBalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + param.shortAmount;\n\n  186:    if (param.long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);\n\n  189:    if (param.long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);\n\n  192:    if (param.shortAmount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), shortBalanceTarget);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2Token.sol#L67\n\n```solidity\npackages\\v2-pool\\src\\TimeswapV2Pool.sol:\n  189:    ITimeswapV2PoolFactory(poolFactory).owner().checkIfOwner();\n\n  267:    if (long0Amount != 0) long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + long0Amount;\n  \n  271:    if (long1Amount != 0) long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + long1Amount;\n  \n  274:    uint256 shortBalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + shortAmount;\n  \n  293:    if (long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);\n  \n  295:    if (long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);\n  \n  297:    Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), shortBalanceTarget);\n  \n  393:    if (long0Amount != 0) long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + long0Amount;\n  \n  397:    if (long1Amount != 0) long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + long1Amount;\n  \n  411:    if (long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);\n  \n  413:    if (long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);\n  \n  444:    uint256 balanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + shortAmount;\n  \n  461:    Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), balanceTarget);\n  \n  479:    uint256 balanceTarget = ITimeswapV2Option(optionPair).positionOf(\n  \n  511:    ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), param.isLong0ToLong1 ? TimeswapV2OptionPosition.Long0 : TimeswapV2OptionPosition.Long1),\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/TimeswapV2Pool.sol#L189\n\n```solidity\npackages\\v2-option\\src\\libraries\\OptionFactory.sol:\n  28:     optionPair = ITimeswapV2OptionFactory(optionFactory).get(token0, token1);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/libraries/OptionFactory.sol#L28\n\n```solidity\npackages\\v2-pool\\src\\libraries\\PoolFactory.sol:\n  32:     poolPair = ITimeswapV2PoolFactory(poolFactory).get(optionPair);\n  \n  46:     poolPair = ITimeswapV2PoolFactory(poolFactory).get(optionPair);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/libraries/PoolFactory.sol#L32\n\n```solidity\npackages\\v2-option\\src\\TimeswapV2Option.sol:\n  128:    IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n  \n  129:    IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount\n  \n  145:    if (token0AndLong0Amount != 0) Error.checkEnough(IERC20(token0).balanceOf(address(this)), currentProcess.balance0Target);\n  \n  148:    if (token1AndLong1Amount != 0) Error.checkEnough(IERC20(token1).balanceOf(address(this)), currentProcess.balance1Target);\n  \n  215:    param.isLong0ToLong1 ? IERC20(token0).balanceOf(address(this)) - token0AndLong0Amount : IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n  \n  216:    param.isLong0ToLong1 ? IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount : IERC20(token1).balanceOf(address(this)) - token1AndLong1Amount\n  \n  172:    if (token0AndLong0Amount != 0) IERC20(token0).safeTransfer(param.token0To, token0AndLong0Amount);\n  \n  175:    if (token1AndLong1Amount != 0) IERC20(token1).safeTransfer(param.token1To, token1AndLong1Amount);\n  \n  220:    IERC20(param.isLong0ToLong1 ? token0 : token1).safeTransfer(param.tokenTo, param.isLong0ToLong1 ? token0AndLong0Amount : token1AndLong1Amount);\n  \n  259:    if (token0Amount != 0) IERC20(token0).safeTransfer(param.token0To, token0Amount);\n  \n  262:    if (token1Amount != 0) IERC20(token1).safeTransfer(param.token1To, token1Amount);\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L128\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-token/src/TimeswapV2LiquidityToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\nimport {ITimeswapV2Pool} from \"@timeswap-labs/v2-pool/src/interfaces/ITimeswapV2Pool.sol\";\n\nimport {PoolFactoryLibrary} from \"@timeswap-labs/v2-pool/src/libraries/PoolFactory.sol\";\nimport {ReentrancyGuard} from \"@timeswap-labs/v2-pool/src/libraries/ReentrancyGuard.sol\";\n\nimport {ITimeswapV2LiquidityToken} from \"./interfaces/ITimeswapV2LiquidityToken.sol\";\n\nimport {ITimeswapV2LiquidityTokenMintCallback} from \"./interfaces/callbacks/ITimeswapV2LiquidityTokenMintCallback.sol\";\nimport {ITimeswapV2LiquidityTokenBurnCallback} from \"./interfaces/callbacks/ITimeswapV2LiquidityTokenBurnCallback.sol\";\nimport {ITimeswapV2LiquidityTokenCollectCallback} from \"./interfaces/callbacks/ITimeswapV2LiquidityTokenCollectCallback.sol\";\n\nimport {ERC1155Enumerable} from \"./base/ERC1155Enumerable.sol\";\n\nimport {TimeswapV2LiquidityTokenPosition, PositionLibrary} from \"./structs/Position.sol\";\nimport {FeesPosition, FeesPositionLibrary} from \"./structs/FeesPosition.sol\";\nimport {TimeswapV2LiquidityTokenMintParam, TimeswapV2LiquidityTokenBurnParam, TimeswapV2LiquidityTokenCollectParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2LiquidityTokenMintCallbackParam, TimeswapV2LiquidityTokenBurnCallbackParam, TimeswapV2LiquidityTokenCollectCallbackParam} from \"./structs/CallbackParam.sol\";\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\n/// @title An implementation for TS-V2 liquidity token system\n/// @author Timeswap Labs\ncontract TimeswapV2LiquidityToken is ITimeswapV2LiquidityToken, ERC1155Enumerable {\n    using ReentrancyGuard for uint96;\n\n    using PositionLibrary for TimeswapV2LiquidityTokenPosition;\n    using FeesPositionLibrary for FeesPosition;\n\n    address public immutable optionFactory;\n    address public immutable poolFactory;\n\n    constructor(address chosenOptionFactory, address chosenPoolFactory) ERC1155(\"Timeswap V2 uint160 address\") {\n        optionFactory = chosenOptionFactory;\n        poolFactory = chosenPoolFactory;\n    }\n\n    mapping(bytes32 => uint96) private reentrancyGuards;\n\n    mapping(uint256 => TimeswapV2LiquidityTokenPosition) private _timeswapV2LiquidityTokenPositions;\n\n    mapping(bytes32 => uint256) private _timeswapV2LiquidityTokenPositionIds;\n\n    mapping(uint256 => mapping(address => FeesPosition)) private _feesPositions;\n\n    function changeInteractedIfNecessary(bytes32 key) private {\n        if (reentrancyGuards[key] == ReentrancyGuard.NOT_INTERACTED) reentrancyGuards[key] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /// @dev internal function to start the reentrancy guard\n    function raiseGuard(bytes32 key) private {\n        reentrancyGuards[key].check();\n        reentrancyGuards[key] = ReentrancyGuard.ENTERED;\n    }\n\n    /// @dev internal function to end the reentrancy guard\n    function lowerGuard(bytes32 key) private {\n        reentrancyGuards[key] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /// @inheritdoc ITimeswapV2LiquidityToken\n    function positionOf(address owner, TimeswapV2LiquidityTokenPosition calldata timeswapV2LiquidityTokenPosition) external view returns (uint256 amount) {\n        amount = balanceOf(owner, _timeswapV2LiquidityTokenPositionIds[timeswapV2LiquidityTokenPosition.toKey()]);\n    }\n\n    /// @inheritdoc ITimeswapV2LiquidityToken\n    function transferTokenPositionFrom(address from, address to, TimeswapV2LiquidityTokenPosition calldata timeswapV2LiquidityTokenPosition, uint160 liquidityAmount) external {\n        safeTransferFrom(from, to, _timeswapV2LiquidityTokenPositionIds[timeswapV2LiquidityTokenPosition.toKey()], liquidityAmount, bytes(\"\"));\n    }\n\n    /// @inheritdoc ITimeswapV2LiquidityToken\n    function transferFeesFrom(address from, address to, TimeswapV2LiquidityTokenPosition calldata position, uint256 long0Fees, uint256 long1Fees, uint256 shortFees) external override {\n        if (from == address(0)) Error.zeroAddress();\n        if (to == address(0)) Error.zeroAddress();\n\n        if (!isApprovedForAll(from, msg.sender)) revert NotApprovedToTransferFees();\n\n        uint256 id = _timeswapV2LiquidityTokenPositionIds[position.toKey()];\n\n        if (long0Fees != 0 || long1Fees != 0 || shortFees != 0) _addTokenEnumeration(from, to, id, 0);\n\n        // add/mint the fees for the new user\n        _feesPositions[id][to].mint(long0Fees, long1Fees, shortFees);\n\n        _updateFeesPositions(from, to, id);\n\n        // remove/burn the fees\n        _feesPositions[id][from].burn(long0Fees, long1Fees, shortFees);\n\n        if (long0Fees != 0 || long1Fees != 0 || shortFees != 0) _removeTokenEnumeration(from, to, id, 0);\n\n        emit TransferFees(from, to, position, long0Fees, long1Fees, shortFees);\n    }\n\n    /// @inheritdoc ITimeswapV2LiquidityToken\n    function mint(TimeswapV2LiquidityTokenMintParam calldata param) external returns (bytes memory data) {\n        ParamLibrary.check(param);\n\n        TimeswapV2LiquidityTokenPosition memory timeswapV2LiquidityTokenPosition = TimeswapV2LiquidityTokenPosition({\n            token0: param.token0,\n            token1: param.token1,\n            strike: param.strike,\n            maturity: param.maturity\n        });\n\n        bytes32 key = timeswapV2LiquidityTokenPosition.toKey();\n        uint256 id = _timeswapV2LiquidityTokenPositionIds[key];\n\n        // if the position does not exist, create it\n        if (id == 0) {\n            id = totalSupply() + 1;\n            _timeswapV2LiquidityTokenPositions[id] = timeswapV2LiquidityTokenPosition;\n            _timeswapV2LiquidityTokenPositionIds[key] = id;\n        }\n\n        changeInteractedIfNecessary(key);\n        raiseGuard(key);\n\n        (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, param.token0, param.token1);\n\n        // calculate the amount of liquidity tokens to mint\n        uint160 liquidityBalanceTarget = ITimeswapV2Pool(poolPair).liquidityOf(param.strike, param.maturity, address(this)) + param.liquidityAmount;\n\n        // mint the liquidity tokens to the recipient\n        _mint(param.to, id, param.liquidityAmount, bytes(\"\"));\n\n        // ask the msg.sender to transfer the liquidity to this contract\n        data = ITimeswapV2LiquidityTokenMintCallback(msg.sender).timeswapV2LiquidityTokenMintCallback(\n            TimeswapV2LiquidityTokenMintCallbackParam({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                liquidityAmount: param.liquidityAmount,\n                data: param.data\n            })\n        );\n\n        // check if the enough liquidity amount target is received\n        Error.checkEnough(ITimeswapV2Pool(poolPair).liquidityOf(param.strike, param.maturity, address(this)), liquidityBalanceTarget);\n\n        // stop the reentrancy guard\n        lowerGuard(key);\n    }\n\n    /// @inheritdoc ITimeswapV2LiquidityToken\n    function burn(TimeswapV2LiquidityTokenBurnParam calldata param) external returns (bytes memory data) {\n        ParamLibrary.check(param);\n\n        bytes32 key = TimeswapV2LiquidityTokenPosition({token0: param.token0, token1: param.token1, strike: param.strike, maturity: param.maturity}).toKey();\n\n        raiseGuard(key);\n\n        (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, param.token0, param.token1);\n\n        // transfer the equivalent liquidity amount to the recipient from pool\n        ITimeswapV2Pool(poolPair).transferLiquidity(param.strike, param.maturity, param.to, param.liquidityAmount);\n\n        if (param.data.length != 0)\n            data = ITimeswapV2LiquidityTokenBurnCallback(msg.sender).timeswapV2LiquidityTokenBurnCallback(\n                TimeswapV2LiquidityTokenBurnCallbackParam({\n                    token0: param.token0,\n                    token1: param.token1,\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    liquidityAmount: param.liquidityAmount,\n                    data: param.data\n                })\n            );\n\n        // burn the liquidity tokens from the msg.sender\n        _burn(msg.sender, _timeswapV2LiquidityTokenPositionIds[key], param.liquidityAmount);\n\n        // stop the guard for reentrancy\n        lowerGuard(key);\n    }\n\n    /// @inheritdoc ITimeswapV2LiquidityToken\n    function collect(TimeswapV2LiquidityTokenCollectParam calldata param) external returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees, bytes memory data) {\n        ParamLibrary.check(param);\n\n        bytes32 key = TimeswapV2LiquidityTokenPosition({token0: param.token0, token1: param.token1, strike: param.strike, maturity: param.maturity}).toKey();\n\n        // start the reentrancy guard\n        raiseGuard(key);\n\n        (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, param.token0, param.token1);\n\n        // transfer the fees amount to the recipient\n        ITimeswapV2Pool(poolPair).transferFees(param.strike, param.maturity, param.to, long0Fees, long1Fees, shortFees);\n\n        uint256 id = _timeswapV2LiquidityTokenPositionIds[key];\n\n        _updateFeesPositions(msg.sender, address(0), id);\n\n        (long0Fees, long1Fees, shortFees) = _feesPositions[id][msg.sender].getFees(param.long0FeesDesired, param.long1FeesDesired, param.shortFeesDesired);\n\n        if (param.data.length != 0)\n            data = ITimeswapV2LiquidityTokenCollectCallback(msg.sender).timeswapV2LiquidityTokenCollectCallback(\n                TimeswapV2LiquidityTokenCollectCallbackParam({\n                    token0: param.token0,\n                    token1: param.token1,\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    long0Fees: long0Fees,\n                    long1Fees: long1Fees,\n                    shortFees: shortFees,\n                    data: param.data\n                })\n            );\n\n        // burn the desired fees from the fees position\n        _feesPositions[id][msg.sender].burn(long0Fees, long1Fees, shortFees);\n\n        if (long0Fees != 0 || long1Fees != 0 || shortFees != 0) _removeTokenEnumeration(msg.sender, address(0), id, 0);\n\n        // stop the reentrancy guard\n        lowerGuard(key);\n    }\n\n    function _beforeTokenTransfer(address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i; i < ids.length; ) {\n            if (amounts[i] != 0) _updateFeesPositions(from, to, ids[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _updateFeesPositions(address from, address to, uint256 id) private {\n        if (from != to) {\n            TimeswapV2LiquidityTokenPosition memory timeswapV2LiquidityTokenPosition = _timeswapV2LiquidityTokenPositions[id];\n\n            uint256 long0FeeGrowth;\n            uint256 long1FeeGrowth;\n            uint256 shortFeeGrowth;\n            {\n                (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, timeswapV2LiquidityTokenPosition.token0, timeswapV2LiquidityTokenPosition.token1);\n\n                (long0FeeGrowth, long1FeeGrowth, shortFeeGrowth) = ITimeswapV2Pool(poolPair).feeGrowth(timeswapV2LiquidityTokenPosition.strike, timeswapV2LiquidityTokenPosition.maturity);\n            }\n\n            if (from != address(0)) _feesPositions[id][from].update(uint160(balanceOf(from, id)), long0FeeGrowth, long1FeeGrowth, shortFeeGrowth);\n\n            if (to != address(0)) _feesPositions[id][to].update(uint160(balanceOf(to, id)), long0FeeGrowth, long1FeeGrowth, shortFeeGrowth);\n        }\n    }\n\n    function _additionalConditionAddTokenToOwnerEnumeration(address to, uint256 id) internal view override returns (bool) {\n        return _additionalConditionForOwnerTokenEnumeration(to, id);\n    }\n\n    function _additionalConditionRemoveTokenFromOwnerEnumeration(address from, uint256 id) internal view override returns (bool) {\n        return _additionalConditionForOwnerTokenEnumeration(from, id);\n    }\n\n    function _additionalConditionForOwnerTokenEnumeration(address owner, uint256 id) private view returns (bool) {\n        TimeswapV2LiquidityTokenPosition memory timeswapV2LiquidityTokenPosition = _timeswapV2LiquidityTokenPositions[id];\n\n        uint256 long0FeeGrowth;\n        uint256 long1FeeGrowth;\n        uint256 shortFeeGrowth;\n        {\n            (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, timeswapV2LiquidityTokenPosition.token0, timeswapV2LiquidityTokenPosition.token1);\n\n            (long0FeeGrowth, long1FeeGrowth, shortFeeGrowth) = ITimeswapV2Pool(poolPair).feeGrowth(timeswapV2LiquidityTokenPosition.strike, timeswapV2LiquidityTokenPosition.maturity);\n        }\n\n        FeesPosition memory feesPosition = _feesPositions[id][owner];\n\n        (uint256 long0Fees, uint256 long1Fees, uint256 shortFees) = feesPosition.feesEarnedOf(uint160(balanceOf(owner, id)), long0FeeGrowth, long1FeeGrowth, shortFeeGrowth);\n\n        return long0Fees == 0 && long1Fees == 0 && shortFees == 0;\n    }\n}"
    },
    {
      "filename": "packages/v2-token/src/TimeswapV2Token.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"forge-std/console.sol\";\n\nimport {ITimeswapV2Option} from \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\";\n\nimport {OptionFactoryLibrary} from \"@timeswap-labs/v2-option/src/libraries/OptionFactory.sol\";\nimport {ReentrancyGuard} from \"@timeswap-labs/v2-pool/src/libraries/ReentrancyGuard.sol\";\n\nimport {TimeswapV2OptionPosition} from \"@timeswap-labs/v2-option/src/enums/Position.sol\";\n\nimport {ITimeswapV2Token} from \"./interfaces/ITimeswapV2Token.sol\";\n\nimport {ITimeswapV2TokenMintCallback} from \"./interfaces/callbacks/ITimeswapV2TokenMintCallback.sol\";\nimport {ITimeswapV2TokenBurnCallback} from \"./interfaces/callbacks/ITimeswapV2TokenBurnCallback.sol\";\n\nimport {ERC1155Enumerable} from \"./base/ERC1155Enumerable.sol\";\n\nimport {TimeswapV2TokenPosition, PositionLibrary} from \"./structs/Position.sol\";\nimport {TimeswapV2TokenMintParam, TimeswapV2TokenBurnParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2TokenMintCallbackParam, TimeswapV2TokenBurnCallbackParam} from \"./structs/CallbackParam.sol\";\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\n/// @title\n/// @author Timeswap Labs\n/// @notice TimeswapV2Token tokenizes the TimeswapV2 native option positions (long0, long1, short)\ncontract TimeswapV2Token is ITimeswapV2Token, ERC1155Enumerable {\n    using ReentrancyGuard for uint96;\n\n    using PositionLibrary for TimeswapV2TokenPosition;\n\n    address public immutable optionFactory;\n\n    mapping(bytes32 => uint96) private reentrancyGuards;\n\n    mapping(uint256 => TimeswapV2TokenPosition) private _timeswapV2TokenPositions;\n    mapping(bytes32 => uint256) private _timeswapV2TokenPositionIds;\n\n    constructor(address chosenOptionFactory) ERC1155(\"Timeswap V2 address\") {\n        optionFactory = chosenOptionFactory;\n    }\n\n    function changeInteractedIfNecessary(address token0, address token1, uint256 strike, uint256 maturity) private {\n        bytes32 key = keccak256(abi.encode(token0, token1, strike, maturity));\n\n        if (reentrancyGuards[key] == ReentrancyGuard.NOT_INTERACTED) reentrancyGuards[key] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /// @dev internal function to start the reentrancy guard\n    function raiseGuard(address token0, address token1, uint256 strike, uint256 maturity) private {\n        bytes32 key = keccak256(abi.encode(token0, token1, strike, maturity));\n\n        reentrancyGuards[key].check();\n        reentrancyGuards[key] = ReentrancyGuard.ENTERED;\n    }\n\n    /// @dev internal function to end the reentrancy guard\n    function lowerGuard(address token0, address token1, uint256 strike, uint256 maturity) private {\n        bytes32 key = keccak256(abi.encode(token0, token1, strike, maturity));\n        reentrancyGuards[key] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /// @inheritdoc ITimeswapV2Token\n    function positionOf(address owner, TimeswapV2TokenPosition calldata timeswapV2TokenPosition) public view returns (uint256 amount) {\n        amount = ERC1155.balanceOf(owner, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()]);\n    }\n\n    /// @inheritdoc ITimeswapV2Token\n    function transferTokenPositionFrom(address from, address to, TimeswapV2TokenPosition calldata timeswapV2TokenPosition, uint256 amount) external override {\n        safeTransferFrom(from, to, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], (amount), bytes(\"\"));\n    }\n\n    /// @inheritdoc ITimeswapV2Token\n    function mint(TimeswapV2TokenMintParam calldata param) external override returns (bytes memory data) {\n        ParamLibrary.check(param);\n        changeInteractedIfNecessary(param.token0, param.token1, param.strike, param.maturity);\n        raiseGuard(param.token0, param.token1, param.strike, param.maturity);\n\n        address optionPair = OptionFactoryLibrary.getWithCheck(optionFactory, param.token0, param.token1);\n\n        uint256 long0BalanceTarget;\n        // mints TimeswapV2Token in case of the long0 position\n        if (param.long0Amount != 0) {\n            // get the initial balance of the long0 position and add the long0 amount to mint\n            long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + param.long0Amount;\n\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Long0\n            });\n\n            bytes32 key = timeswapV2TokenPosition.toKey();\n            // get the unique id of the TimeswapV2Token position\n            uint256 id = _timeswapV2TokenPositionIds[key];\n\n            // if the id is 0, it means that the position has not been minted yet\n            if (id == 0) {\n                id = totalSupply() + 1;\n                _timeswapV2TokenPositions[id] = timeswapV2TokenPosition;\n                _timeswapV2TokenPositionIds[key] = id;\n            }\n\n            // mint the TimeswapV2Token long0 position\n            console.log(\"reaches right before mint in timeswapv2Tokne::mint\");\n            _mint(param.long0To, id, (param.long0Amount), bytes(\"\"));\n        }\n\n        uint256 long1BalanceTarget;\n        // mints TimeswapV2Token in case of the long1 position\n        if (param.long1Amount != 0) {\n            // get the initial balance of the long1 position and add the long1 amount to mint\n            long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + param.long1Amount;\n\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Long1\n            });\n\n            bytes32 key = timeswapV2TokenPosition.toKey();\n            // get the unique id of the TimeswapV2Token position\n            uint256 id = _timeswapV2TokenPositionIds[key];\n\n            // if the id is 0, it means that the position has not been minted yet\n            if (id == 0) {\n                id = totalSupply() + 1;\n                _timeswapV2TokenPositions[id] = timeswapV2TokenPosition;\n                _timeswapV2TokenPositionIds[key] = id;\n            }\n\n            // mint the TimeswapV2Token long1 position\n            _mint(param.long1To, id, (param.long1Amount), bytes(\"\"));\n        }\n\n        uint256 shortBalanceTarget;\n        // mints TimeswapV2Token in case of the short position\n        if (param.shortAmount != 0) {\n            // get the initial balance of the short position and add the short amount to mint\n            shortBalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + param.shortAmount;\n\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Short\n            });\n\n            bytes32 key = timeswapV2TokenPosition.toKey();\n            // get the unique id of the TimeswapV2Token position\n            uint256 id = _timeswapV2TokenPositionIds[key];\n\n            // if the id is 0, it means that the position has not been minted yet\n            if (id == 0) {\n                id = totalSupply() + 1;\n                _timeswapV2TokenPositions[id] = timeswapV2TokenPosition;\n                _timeswapV2TokenPositionIds[key] = id;\n            }\n\n            // mint the TimeswapV2Token short position\n            _mint(param.shortTo, id, (param.shortAmount), bytes(\"\"));\n        }\n        // console.log()\n        // ask the msg.sender to transfer the long0/long1/short amount to the this contract\n        data = ITimeswapV2TokenMintCallback(msg.sender).timeswapV2TokenMintCallback(\n            TimeswapV2TokenMintCallbackParam({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                long0Amount: param.long0Amount,\n                long1Amount: param.long1Amount,\n                shortAmount: param.shortAmount,\n                data: param.data\n            })\n        );\n\n        // check if the long0 position token balance target is achieved. If not, revert the transaction\n        if (param.long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);\n\n        // check if the long1 position token balance target is achieved. If not, revert the transaction\n        if (param.long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);\n\n        // check if the short position token balance target is achieved. If not, revert the transaction\n        if (param.shortAmount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), shortBalanceTarget);\n\n        lowerGuard(param.token0, param.token1, param.strike, param.maturity);\n    }\n\n    /// @inheritdoc ITimeswapV2Token\n    function burn(TimeswapV2TokenBurnParam calldata param) external override returns (bytes memory data) {\n        ParamLibrary.check(param);\n        raiseGuard(param.token0, param.token1, param.strike, param.maturity);\n\n        address optionPair = OptionFactoryLibrary.getWithCheck(optionFactory, param.token0, param.token1);\n\n        // case when the long0 position is to be burned\n        if (param.long0Amount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long0To, TimeswapV2OptionPosition.Long0, param.long0Amount);\n\n        // case when the long1 position is to be burned\n        if (param.long1Amount != 0)\n            // transfer the underlying equivalent long1 position amount to address of the recipient of long1 position.\n            ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long1To, TimeswapV2OptionPosition.Long1, param.long1Amount);\n\n        // case when the short position is to be burned\n        if (param.shortAmount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.shortTo, TimeswapV2OptionPosition.Short, param.shortAmount);\n\n        if (param.data.length != 0)\n            data = ITimeswapV2TokenBurnCallback(msg.sender).timeswapV2TokenBurnCallback(\n                TimeswapV2TokenBurnCallbackParam({\n                    token0: param.token0,\n                    token1: param.token1,\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    long0Amount: param.long0Amount,\n                    long1Amount: param.long1Amount,\n                    shortAmount: param.shortAmount,\n                    data: param.data\n                })\n            );\n\n        // case when the long0 position is to be burned\n        if (param.long0Amount != 0) {\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Long0\n            });\n\n            // burn the TimeswapV2Token representing long0 position\n            _burn(msg.sender, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], param.long0Amount);\n        }\n\n        // case when the long1 position is to be burned\n        if (param.long1Amount != 0) {\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Long1\n            });\n\n            // burn the TimeswapV2Token representing long1 position\n            _burn(msg.sender, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], param.long1Amount);\n        }\n\n        // case when the short position is to be burned\n        if (param.shortAmount != 0) {\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Short\n            });\n\n            // burn the TimeswapV2Token representing short position\n            _burn(msg.sender, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], param.shortAmount);\n        }\n\n        // stop the guard of reentrancy\n        lowerGuard(param.token0, param.token1, param.strike, param.maturity);\n    }\n}"
    },
    {
      "filename": "packages/v2-pool/src/TimeswapV2Pool.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {Ownership} from \"@timeswap-labs/v2-library/src/Ownership.sol\";\n\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\nimport {ITimeswapV2Option} from \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\";\n\nimport {TimeswapV2OptionPosition} from \"@timeswap-labs/v2-option/src/enums/Position.sol\";\n\nimport {StrikeAndMaturity} from \"@timeswap-labs/v2-option/src/structs/StrikeAndMaturity.sol\";\n\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\n\nimport {ITimeswapV2Pool} from \"./interfaces/ITimeswapV2Pool.sol\";\nimport {ITimeswapV2PoolFactory} from \"./interfaces/ITimeswapV2PoolFactory.sol\";\nimport {ITimeswapV2PoolDeployer} from \"./interfaces/ITimeswapV2PoolDeployer.sol\";\n\nimport {ITimeswapV2PoolMintCallback} from \"./interfaces/callbacks/ITimeswapV2PoolMintCallback.sol\";\nimport {ITimeswapV2PoolBurnCallback, ITimeswapV2PoolBurn2Callback} from \"./interfaces/callbacks/ITimeswapV2PoolBurnCallback.sol\";\nimport {ITimeswapV2PoolDeleverageCallback} from \"./interfaces/callbacks/ITimeswapV2PoolDeleverageCallback.sol\";\nimport {ITimeswapV2PoolLeverageCallback} from \"./interfaces/callbacks/ITimeswapV2PoolLeverageCallback.sol\";\nimport {ITimeswapV2PoolRebalanceCallback} from \"./interfaces/callbacks/ITimeswapV2PoolRebalanceCallback.sol\";\n\nimport {ReentrancyGuard} from \"./libraries/ReentrancyGuard.sol\";\n\nimport {LiquidityPosition, LiquidityPositionLibrary} from \"./structs/LiquidityPosition.sol\";\n\nimport {Pool, PoolLibrary} from \"./structs/Pool.sol\";\nimport {TimeswapV2PoolCollectParam, TimeswapV2PoolMintParam, TimeswapV2PoolBurnParam, TimeswapV2PoolDeleverageParam, TimeswapV2PoolLeverageParam, TimeswapV2PoolRebalanceParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2PoolMintChoiceCallbackParam, TimeswapV2PoolMintCallbackParam, TimeswapV2PoolBurnChoiceCallbackParam, TimeswapV2PoolBurnCallbackParam, TimeswapV2PoolDeleverageChoiceCallbackParam, TimeswapV2PoolDeleverageCallbackParam, TimeswapV2PoolLeverageCallbackParam, TimeswapV2PoolLeverageChoiceCallbackParam, TimeswapV2PoolRebalanceCallbackParam} from \"./structs/CallbackParam.sol\";\n\nimport {TimeswapV2PoolMint, TimeswapV2PoolBurn, TimeswapV2PoolDeleverage, TimeswapV2PoolLeverage, TimeswapV2PoolRebalance, TransactionLibrary} from \"./enums/Transaction.sol\";\n\ncontract TimeswapV2Pool is ITimeswapV2Pool, NoDelegateCall {\n    using PoolLibrary for Pool;\n    using Ownership for address;\n    using LiquidityPositionLibrary for LiquidityPosition;\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    address public immutable override poolFactory;\n    /// @inheritdoc ITimeswapV2Pool\n    address public immutable override optionPair;\n    /// @inheritdoc ITimeswapV2Pool\n    uint256 public immutable override transactionFee;\n    /// @inheritdoc ITimeswapV2Pool\n    uint256 public immutable override protocolFee;\n\n    mapping(uint256 => mapping(uint256 => uint96)) private reentrancyGuards;\n    mapping(uint256 => mapping(uint256 => Pool)) private pools;\n\n    StrikeAndMaturity[] private listOfPools;\n\n    function addPoolEnumerationIfNecessary(uint256 strike, uint256 maturity) private {\n        if (reentrancyGuards[strike][maturity] == ReentrancyGuard.NOT_INTERACTED) {\n            reentrancyGuards[strike][maturity] = ReentrancyGuard.NOT_ENTERED;\n            listOfPools.push(StrikeAndMaturity({strike: strike, maturity: maturity}));\n        }\n    }\n\n    /* ===== MODIFIER ===== */\n\n    function raiseGuard(uint256 strike, uint256 maturity) private {\n        ReentrancyGuard.check(reentrancyGuards[strike][maturity]);\n        reentrancyGuards[strike][maturity] = ReentrancyGuard.ENTERED;\n    }\n\n    function lowerGuard(uint256 strike, uint256 maturity) private {\n        reentrancyGuards[strike][maturity] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /* ===== INIT ===== */\n\n    constructor() NoDelegateCall() {\n        (poolFactory, optionPair, transactionFee, protocolFee) = ITimeswapV2PoolDeployer(msg.sender).parameter();\n    }\n\n    // Can be overidden for testing purposes.\n    function blockTimestamp(uint96 durationForward) internal view virtual returns (uint96) {\n        return uint96(block.timestamp + durationForward); // truncation is desired\n    }\n\n    /* ===== VIEW ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    function getByIndex(uint256 id) external view override returns (StrikeAndMaturity memory) {\n        return listOfPools[id];\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function numberOfPools() external view override returns (uint256) {\n        return listOfPools.length;\n    }\n\n    function hasLiquidity(uint256 strike, uint256 maturity) private view {\n        if (pools[strike][maturity].liquidity == 0) Error.requireLiquidity();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLiquidity(uint256 strike, uint256 maturity) external view override returns (uint160) {\n        return pools[strike][maturity].liquidity;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function sqrtInterestRate(uint256 strike, uint256 maturity) external view override returns (uint160) {\n        return pools[strike][maturity].sqrtInterestRate;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function liquidityOf(uint256 strike, uint256 maturity, address owner) external view override returns (uint160) {\n        return pools[strike][maturity].liquidityPositions[owner].liquidity;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function feeGrowth(uint256 strike, uint256 maturity) external view override returns (uint256 long0FeeGrowth, uint256 long1FeeGrowth, uint256 shortFeeGrowth) {\n        return pools[strike][maturity].feeGrowth();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function feesEarnedOf(uint256 strike, uint256 maturity, address owner) external view override returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees) {\n        return pools[strike][maturity].feesEarnedOf(owner);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function protocolFee"
    }
  ]
}