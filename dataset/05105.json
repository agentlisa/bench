{
  "Title": "[M-16] A user can lose more value than he specifies in the spread when he enters a `PowerFarm`",
  "Content": "\nWhen a user enters or exits a `PowerFarm`, he specifies an allowed spread. The spread specifies the minimum value of the position allowed at the end of the transaction.\n\nE.g. a spread of 105% on a position with a value of `$1000` ensures the value does not fall below `$950`.\n\n`1000 * (200-105) / 100 = 950`\n\nWhen a user opens a position on Arbitrum, the `ENTRY_ASSET` is converted to WETH on UniswapV3. The second argument in line 434 specifies the minimum value for the swap. The spread is applied to this argument. Hence, the `_depositAmount` in line 432 cannot go less than what the spread allows.\n\n[PendlePowerFarmLeverageLogic.sol#L423-L440](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L423-L440)\n\n```solidity\n426:         uint256 reverseAllowedSpread = 2\n427:             * PRECISION_FACTOR_E18\n428:             - _allowedSpread;\n429: \n430:         if (block.chainid == ARB_CHAIN_ID) {\n431: \n432:             _depositAmount = _getTokensUniV3(\n433:                 _depositAmount,\n434:                 _getEthInTokens(\n435:                         ENTRY_ASSET,\n436:                         _depositAmount\n437:                     )\n438:                 * reverseAllowedSpread\n439:                 / PRECISION_FACTOR_E18,\n440:                 WETH_ADDRESS,\n441:                 ENTRY_ASSET\n442:             );\n443:         }\n```\n\nThe value at the end of the transaction is checked in line 508 below to ensure it does not go below the allowed spread. The `ethValueBefore` is calculated from `_depositAmount` in line 489. Note that if the swap on Uniswap occurred the `_depositAmount` may already be the minimum value. The `ethValueAfter` is scaled with the allowed spread in line `501`.\n\n[PendlePowerFarmLeverageLogic.sol#L485-L505](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L485-L505)\n\n```solidity\n489:         uint256 ethValueBefore = _getTokensInETH(\n490:             ENTRY_ASSET,\n491:             _depositAmount\n492:         );\n493: \n494:         (\n495:             uint256 receivedShares\n496:             ,\n497:         ) = IPendleChild(PENDLE_CHILD).depositExactAmount(\n498:             netLpOut\n499:         );\n500:         // @audit-issue the calculation for ethValueAfter below is incorrect\n501:         uint256 ethValueAfter = _getTokensInETH(\n502:             PENDLE_CHILD,\n503:             receivedShares\n504:         )\n505:             * _allowedSpread\n506:             / PRECISION_FACTOR_E18;\n507:         // @audit-issue ethValueBefore on Arbitrum uses the depositAmount that allowedSpread has already been applied\n508:         if (ethValueAfter < ethValueBefore) {\n509:             revert TooMuchValueLost();\n510:         }\n```\n\nThus the comparison in line 508 may compare `ethValueAfter` with the minimum value of the spread instead of the value of the initial deposit. With this implementation, if the spread for a `$1000` transaction is 105%, the minimum value after the transaction becomes `$902.5`.\n\n`(1000 * 95 / 100) * (95/100) = 902.5`. The user can lose `$47.5` (`950-902.5`).\n\nNote: In the implementation, the value at the end is scaled up instead of the value at the beginning being scaled down like the examples show. Hence, the actual minimum value is lesser i.e. `~$904.76` (`950/1.05`). This is a different bug.\n\n### Proof of Concept\n\n1. A user enters the market with `$1000` of WBTC and specifies a spread of 105%.\n2. At the end of the transaction the comparison is done against `$950`. So the actual value he gets can be between `~$904.76` and `$950` and the transaction would pass.\n3. The user may lose between `$0` and `$45.24` (`950 - 904.76`).\n\n### Recommended Mitigation Steps\n\nConsider storing the actual deposit and using it to calculate `ethValueBefore`.\n\n[PendlePowerFarmLeverageLogic.sol#L423-L488](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L423-L488)\n\n```solidity\n        uint256 reverseAllowedSpread = 2\n            * PRECISION_FACTOR_E18\n            - _allowedSpread;\n+       unit256 actualDeposit = _depositAmount;\n        if (block.chainid == ARB_CHAIN_ID) {\n\n            _depositAmount = _getTokensUniV3(\n                _depositAmount,\n                _getEthInTokens(\n                        ENTRY_ASSET,\n                        _depositAmount\n                    )\n                * reverseAllowedSpread\n                / PRECISION_FACTOR_E18,\n                WETH_ADDRESS,\n                ENTRY_ASSET\n            );\n        }\n\n    ...\n    \n        uint256 ethValueBefore = _getTokensInETH(\n            ENTRY_ASSET,\n-            _depositAmount\n+.           actualDeposit\n        );\n\n```\n\n### Assessed type\n\nUniswap\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/31#issuecomment-2082924786):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./PendlePowerFarmMathLogic.sol\";\n\nabstract contract PendlePowerFarmLeverageLogic is\n    PendlePowerFarmMathLogic,\n    IFlashLoanRecipient\n{\n    /**\n     * @dev Wrapper function preparing balancer flashloan and\n     * loading data to pass into receiver.\n     */\n    function _executeBalancerFlashLoan(\n        uint256 _nftId,\n        uint256 _flashAmount,\n        uint256 _initialAmount,\n        uint256 _lendingShares,\n        uint256 _borrowShares,\n        uint256 _allowedSpread,\n        bool _ethBack,\n        bool _isAave\n    )\n        internal\n    {\n        IERC20[] memory tokens = new IERC20[](1);\n        uint256[] memory amount = new uint256[](1);\n\n        address flashAsset = WETH_ADDRESS;\n\n        tokens[0] = IERC20(flashAsset);\n        amount[0] = _flashAmount;\n\n        allowEnter = true;\n\n        BALANCER_VAULT.flashLoan(\n            this,\n            tokens,\n            amount,\n            abi.encode(\n                _nftId,\n                _initialAmount,\n                _lendingShares,\n                _borrowShares,\n                _allowedSpread,\n                msg.sender,\n                _ethBack,\n                _isAave\n            )\n        );\n    }\n\n    /**\n     * @dev Receive function from balancer flashloan. Body\n     * is called from balancer at the end of their {flashLoan()}\n     * logic. Overwritten with opening flows.\n     */\n    function receiveFlashLoan(\n        IERC20[] memory _flashloanToken,\n        uint256[] memory _flashloanAmounts,\n        uint256[] memory _feeAmounts,\n        bytes memory _userData\n    )\n        external\n    {\n        if (allowEnter == false) {\n            revert AccessDenied();\n        }\n\n        allowEnter = false;\n\n        if (_flashloanToken.length == 0) {\n            revert InvalidParam();\n        }\n\n        if (msg.sender != BALANCER_ADDRESS) {\n            revert NotBalancerVault();\n        }\n\n        uint256 totalDebtBalancer = _flashloanAmounts[0]\n            + _feeAmounts[0];\n\n        (\n            uint256 nftId,\n            uint256 initialAmount,\n            uint256 lendingShares,\n            uint256 borrowShares,\n            uint256 allowedSpread,\n            address caller,\n            bool ethBack,\n            bool isAave\n        ) = abi.decode(\n            _userData,\n            (\n                uint256,\n                uint256,\n                uint256,\n                uint256,\n                uint256,\n                address,\n                bool,\n                bool\n            )\n        );\n\n        if (initialAmount > 0) {\n            _logicOpenPosition(\n                isAave,\n                nftId,\n                _flashloanAmounts[0] + initialAmount,\n                totalDebtBalancer,\n                allowedSpread\n            );\n\n            return;\n        }\n\n        _logicClosePosition(\n            nftId,\n            borrowShares,\n            lendingShares,\n            totalDebtBalancer,\n            allowedSpread,\n            caller,\n            ethBack,\n            isAave\n        );\n    }\n\n    /**\n     * @dev Closes position using balancer flashloans.\n     */\n    function _logicClosePosition(\n        uint256 _nftId,\n        uint256 _borrowShares,\n        uint256 _lendingShares,\n        uint256 _totalDebtBalancer,\n        uint256 _allowedSpread,\n        address _caller,\n        bool _ethBack,\n        bool _isAave\n    )\n        private\n    {\n        _paybackExactShares(\n            _isAave,\n            _nftId,\n            _borrowShares\n        );\n\n        uint256 withdrawnLpsAmount = _withdrawPendleLPs(\n            _nftId,\n            _lendingShares\n        );\n\n        uint256 ethValueBefore = _getTokensInETH(\n            PENDLE_CHILD,\n            withdrawnLpsAmount\n        );\n\n        (\n            uint256 netSyOut\n            ,\n        ) = PENDLE_ROUTER.removeLiquiditySingleSy(\n            {\n                _receiver: address(this),\n                _market: address(PENDLE_MARKET),\n                _netLpToRemove: withdrawnLpsAmount,\n                _minSyOut: 0\n            }\n        );\n\n        address tokenOut = block.chainid == 1\n            ? ST_ETH_ADDRESS\n            : ENTRY_ASSET;\n\n        uint256 tokenOutAmount = PENDLE_SY.redeem(\n            {\n                _receiver: address(this),\n                _amountSharesToRedeem: netSyOut,\n                _tokenOut: tokenOut,\n                _minTokenOut: 0,\n                _burnFromInternalBalance: false\n            }\n        );\n\n        uint256 reverseAllowedSpread = 2\n            * PRECISION_FACTOR_E18\n            - _allowedSpread;\n\n        uint256 ethAmount = _getEthBack(\n            tokenOutAmount,\n            _getTokensInETH(\n                block.chainid == 1\n                    ? WETH_ADDRESS\n                    : ENTRY_ASSET,\n                tokenOutAmount\n            )\n                * reverseAllowedSpread\n                / PRECISION_FACTOR_E18\n        );\n\n        uint256 ethValueAfter = _getTokensInETH(\n            WETH_ADDRESS,\n            ethAmount\n        )\n            * _allowedSpread\n            / PRECISION_FACTOR_E18;\n\n        if (ethValueAfter < ethValueBefore) {\n            revert TooMuchValueLost();\n        }\n\n        if (_ethBack == true) {\n            _closingRouteETH(\n                ethAmount,\n                _totalDebtBalancer,\n                _caller\n            );\n\n            return;\n        }\n\n        _closingRouteToken(\n            ethAmount,\n            _totalDebtBalancer,\n            _caller\n        );\n    }\n\n    function _getEthBack(\n        uint256 _swapAmount,\n        uint256 _minOutAmount\n    )\n        internal\n        returns (uint256)\n    {\n        if (block.chainid == ETH_CHAIN_ID) {\n            return _swapStETHintoETH(\n                _swapAmount,\n                _minOutAmount\n            );\n        }\n\n        if (block.chainid == ARB_CHAIN_ID) {\n            uint256 wethAmount = _getTokensUniV3(\n                _swapAmount,\n                _minOutAmount,\n                ENTRY_ASSET,\n                WETH_ADDRESS\n            );\n\n            _unwrapETH(\n                wethAmount\n            );\n\n            return wethAmount;\n        }\n\n        revert WrongChainId();\n    }\n\n    function _getTokensUniV3(\n        uint256 _amountIn,\n        uint256 _minOutAmount,\n        address _tokenIn,\n        address _tokenOut\n    )\n        internal\n        returns (uint256)\n    {\n        return UNISWAP_V3_ROUTER.exactInputSingle(\n            IUniswapV3.ExactInputSingleParams(\n                {\n                    tokenIn: _tokenIn,\n                    tokenOut: _tokenOut,\n                    fee: UNISWAP_V3_FEE,\n                    recipient: address(this),\n                    deadline: block.timestamp,\n                    amountIn: _amountIn,\n                    amountOutMinimum: _minOutAmount,\n                    sqrtPriceLimitX96: 0\n                }\n            )\n        );\n    }\n\n    /**\n     * @dev Internal wrapper function for curve swap\n     * of stETH into ETH.\n     */\n    function _swapStETHintoETH(\n        uint256 _swapAmount,\n        uint256 _minOutAmount\n    )\n        internal\n        returns (uint256)\n    {\n        return CURVE.exchange(\n            {\n                fromIndex: 1,\n                toIndex: 0,\n                exactAmountFrom: _swapAmount,\n                minReceiveAmount: _minOutAmount\n            }\n        );\n    }\n\n    function _withdrawPendleLPs(\n        uint256 _nftId,\n        uint256 _lendingShares\n    )\n        private\n        returns (uint256 withdrawnLpsAmount)\n    {\n        return IPendleChild(PENDLE_CHILD).withdrawExactShares(\n            WISE_LENDING.withdrawExactShares(\n                _nftId,\n                PENDLE_CHILD,\n                _lendingShares\n            )\n        );\n    }\n\n    function _paybackExactShares(\n        bool _isAave,\n        uint256 _nftId,\n        uint256 _borrowShares\n    )\n        internal\n    {\n        if (_isAave == true) {\n            AAVE_HUB.paybackExactShares(\n                _nftId,\n                WETH_ADDRESS,\n                _borrowShares\n            );\n\n            return;\n        }\n\n        WISE_LENDING.paybackExactShares(\n            _nftId,\n            WETH_ADDRESS,\n            _borrowShares\n        );\n    }\n\n    /**\n     * @dev Internal wrapper function for a closing route\n     * which returns {ENTRY_ASSET} to the owner in the end.\n     */\n    function _closingRouteToken(\n        uint256 _tokenAmount,\n        uint256 _totalDebtBalancer,\n        address _caller\n    )\n        private\n    {\n        _wrapETH(\n            _tokenAmount\n        );\n\n        _safeTransfer(\n            WETH_ADDRESS,\n            msg.sender,\n            _totalDebtBalancer\n        );\n\n        _safeTransfer(\n            WETH_ADDRESS,\n            _caller,\n            _tokenAmount\n                - _totalDebtBalancer\n        );\n    }\n\n    /**\n     * @dev Internal wrapper function for a closing route\n     * which returns ETH to the owner in the end.\n     */\n    function _closingRouteETH(\n        uint256 _ethAmount,\n        uint256 _totalDebtBalancer,\n        address _caller\n    )\n        internal\n    {\n        _wrapETH(\n            _totalDebtBalancer\n        );\n\n        _safeTransfer(\n            WETH_ADDRESS,\n            msg.sender,\n            _totalDebtBalancer\n        );\n\n        _sendValue(\n            _caller,\n            _ethAmount\n                - _totalDebtBalancer\n        );\n    }\n\n    /**\n     * @dev Internal function executing the\n     * collateral deposit by converting ETH\n     * into {ENTRY_ASSET}, adding it as collateral and\n     * borrowing the flashloan token to pay\n     * back {_totalDebtBalancer}.\n     */\n    function _logicOpenPosition(\n        bool _isAave,\n        uint256 _nftId,\n        uint256 _depositAmount,\n        uint256 _totalDebtBalancer,\n        uint256 _allowedSpread\n    )\n        internal\n    {\n        uint256 reverseAllowedSpread = 2\n            * PRECISION_FACTOR_E18\n            - _allowedSpread;\n\n        if (block.chainid == ARB_CHAIN_ID) {\n\n            _depositAmount = _getTokensUniV3(\n                _depositAmount,\n                _getEthInTokens(\n                        ENTRY_ASSET,\n                        _depositAmount\n                    )\n                * reverseAllowedSpread\n                / PRECISION_FACTOR_E18,\n                WETH_ADDRESS,\n                ENTRY_ASSET\n            );\n        }\n\n        uint256 syReceived = PENDLE_SY.deposit(\n            {\n                _receiver: address(this),\n                _tokenIn: ENTRY_ASSET,\n                _amountTokenToDeposit: _depositAmount,\n                _minSharesOut: PENDLE_SY.previewDeposit(\n                    ENTRY_ASSET,\n                    _depositAmount\n                )\n            }\n        );\n\n        (   ,\n            uint256 netPtFromSwap,\n            ,\n            ,\n            ,\n        ) = PENDLE_ROUTER_STATIC.addLiquiditySingleSyStatic(\n            address(PENDLE_MARKET),\n            syReceived\n        );\n\n        (\n            uint256 netLpOut\n            ,\n        ) = PENDLE_ROUTER.addLiquiditySingleSy(\n            {\n                _receiver: address(this),\n                _market: address(PENDLE_MARKET),\n                _netSyIn: syReceived,\n                _minLpOut: 0,\n                _guessPtReceivedFromSy: ApproxParams(\n                    {\n                        guessMin: netPtFromSwap - 100,\n                        guessMax: netPtFromSwap + 100,\n                        guessOffchain: 0,\n                        maxIteration: 50,\n                        eps: 1e15\n                    }\n                )\n            }\n        );\n\n        uint256 ethValueBefore = _getTokensInETH(\n            ENTRY_ASSET,\n            _depositAmount\n        );\n\n        (\n            uint256 receivedShares\n            ,\n        ) = IPendleChild(PENDLE_CHILD).depositExactAmount(\n            netLpOut\n        );\n\n        uint256 ethValueAfter = _getTokensInETH(\n            PENDLE_CHILD,\n            receivedShares\n        )\n            * _allowedSpread\n            / PRECISION_FACTOR_E18;\n\n        if (ethValueAfter < ethValueBefore) {\n            revert TooMuchValueLost();\n        }\n\n        WISE_LENDING.depositExactAmount(\n            _nftId,\n            PENDLE_CHILD,\n            receivedShares\n        );\n\n        _borrowExactAmount(\n            _isAave,\n            _nftId,\n            _totalDebtBalancer\n        );\n\n        if (_checkDebtRatio(_nftId) == false) {\n            revert DebtRatioTooHigh();\n        }\n\n        _safeTransfer(\n            WETH_ADDRESS,\n            BALANCER_ADDRESS,\n            _totalDebtBalancer\n        );\n    }\n\n    function _borrowExactAmount(\n        bool _isAave,\n        uint256 _nftId,\n        uint256 _totalDebtBalancer\n    )\n        internal\n    {\n        if (_isAave == true) {\n            AAVE_HUB.borrowExactAmount(\n                _nftId,\n                WETH_ADDRESS,\n                _totalDebtBalancer\n            );\n\n            return;\n        }\n\n        WISE_LENDING.borrowExactAmount(\n            _nftId,\n            WETH_ADDRESS,\n            _totalDebtBalancer\n        );\n    }\n\n    /**\n     * @dev Internal function summarizing liquidation\n     * checks and interface call for core liquidation\n     * from wise lending.\n     */\n    function _coreLiquidation(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        uint256 _shareAmountToPay\n    )\n        internal\n        returns (\n            uint256 paybackAmount,\n            uint256 receivingAmount\n        )\n    {\n        if (_checkDebtRatio(_nftId) == true) {\n            revert DebtRatioTooLow();\n        }\n\n        address paybackToken = isAave[_nftId] == true\n            ? AAVE_WETH_ADDRESS\n            : WETH_ADDRESS;\n\n        paybackAmount = WISE_LENDING.paybackAmount(\n            paybackToken,\n            _shareAmountToPay\n        );\n\n        uint256 cutoffShares = isAave[_nftId] == true\n            ? _getPositionBorrowSharesAave(_nftId)\n                * FIVTY_PERCENT\n                / PRECISION_FACTOR_E18\n            : _getPositionBorrowShares(_nftId)\n                * FIVTY_PERCENT\n                / PRECISION_FACTOR_E18;\n\n        if (_shareAmountToPay > cutoffShares) {\n            revert TooMuchShares();\n        }\n\n        receivingAmount = WISE_LENDING.coreLiquidationIsolationPools(\n            _nftId,\n            _nftIdLiquidator,\n            msg.sender,\n            paybackToken,\n            PENDLE_CHILD,\n            paybackAmount,\n            _shareAmountToPay\n        );\n    }\n}"
    },
    {
      "filename": "contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./PendlePowerFarmMathLogic.sol\";\n\nabstract contract PendlePowerFarmLeverageLogic is\n    PendlePowerFarmMathLogic,\n    IFlashLoanRecipient\n{\n    /**\n     * @dev Wrapper function preparing balancer flashloan and\n     * loading data to pass into receiver.\n     */\n    function _executeBalancerFlashLoan(\n        uint256 _nftId,\n        uint256 _flashAmount,\n        uint256 _initialAmount,\n        uint256 _lendingShares,\n        uint256 _borrowShares,\n        uint256 _allowedSpread,\n        bool _ethBack,\n        bool _isAave\n    )\n        internal\n    {\n        IERC20[] memory tokens = new IERC20[](1);\n        uint256[] memory amount = new uint256[](1);\n\n        address flashAsset = WETH_ADDRESS;\n\n        tokens[0] = IERC20(flashAsset);\n        amount[0] = _flashAmount;\n\n        allowEnter = true;\n\n        BALANCER_VAULT.flashLoan(\n            this,\n            tokens,\n            amount,\n            abi.encode(\n                _nftId,\n                _initialAmount,\n                _lendingShares,\n                _borrowShares,\n                _allowedSpread,\n                msg.sender,\n                _ethBack,\n                _isAave\n            )\n        );\n    }\n\n    /**\n     * @dev Receive function from balancer flashloan. Body\n     * is called from balancer at the end of their {flashLoan()}\n     * logic. Overwritten with opening flows.\n     */\n    function receiveFlashLoan(\n        IERC20[] memory _flashloanToken,\n        uint256[] memory _flashloanAmounts,\n        uint256[] memory _feeAmounts,\n        bytes memory _userData\n    )\n        external\n    {\n        if (allowEnter == false) {\n            revert AccessDenied();\n        }\n\n        allowEnter = false;\n\n        if (_flashloanToken.length == 0) {\n            revert InvalidParam();\n        }\n\n        if (msg.sender != BALANCER_ADDRESS) {\n            revert NotBalancerVault();\n        }\n\n        uint256 totalDebtBalancer = _flashloanAmounts[0]\n            + _feeAmounts[0];\n\n        (\n            uint256 nftId,\n            uint256 initialAmount,\n            uint256 lendingShares,\n            uint256 borrowShares,\n            uint256 allowedSpread,\n            address caller,\n            bool ethBack,\n            bool isAave\n        ) = abi.decode(\n            _userData,\n            (\n                uint256,\n                uint256,\n                uint256,\n                uint256,\n                uint256,\n                address,\n                bool,\n                bool\n            )\n        );\n\n        if (initialAmount > 0) {\n            _logicOpenPosition(\n                isAave,\n                nftId,\n                _flashloanAmounts[0] + initialAmount,\n                totalDebtBalancer,\n                allowedSpread\n            );\n\n            return;\n        }\n\n        _logicClosePosition(\n            nftId,\n            borrowShares,\n            lendingShares,\n            totalDebtBalancer,\n            allowedSpread,\n            caller,\n            ethBack,\n            isAave\n        );\n    }\n\n    /**\n     * @dev Closes position using balancer flashloans.\n     */\n    function _logicClosePosition(\n        uint256 _nftId,\n        uint256 _borrowShares,\n        uint256 _lendingShares,\n        uint256 _totalDebtBalancer,\n        uint256 _allowedSpread,\n        address _caller,\n        bool _ethBack,\n        bool _isAave\n    )\n        private\n    {\n        _paybackExactShares(\n            _isAave,\n            _nftId,\n            _borrowShares\n        );\n\n        uint256 withdrawnLpsAmount = _withdrawPendleLPs(\n            _nftId,\n            _lendingShares\n        );\n\n        uint256 ethValueBefore = _getTokensInETH(\n            PENDLE_CHILD,\n            withdrawnLpsAmount\n        );\n\n        (\n            uint256 netSyOut\n            ,\n        ) = PENDLE_ROUTER.removeLiquiditySingleSy(\n            {\n                _receiver: address(this),\n                _market: address(PENDLE_MARKET),\n                _netLpToRemove: withdrawnLpsAmount,\n                _minSyOut: 0\n            }\n        );\n\n        address tokenOut = block.chainid == 1\n            ? ST_ETH_ADDRESS\n            : ENTRY_ASSET;\n\n        uint256 tokenOutAmount = PENDLE_SY.redeem(\n            {\n                _receiver: address(this),\n                _amountSharesToRedeem: netSyOut,\n                _tokenOut: tokenOut,\n                _minTokenOut: 0,\n                _burnFromInternalBalance: false\n            }\n        );\n\n        uint256 reverseAllowedSpread = 2\n            * PRECISION_FACTOR_E18\n            - _allowedSpread;\n\n        uint256 ethAmount = _getEthBack(\n            tokenOutAmount,\n            _getTokensInETH(\n                block.chainid == 1\n                    ? WETH_ADDRESS\n                    : ENTRY_ASSET,\n                tokenOutAmount\n            )\n                * reverseAllowedSpread\n                / PRECISION_FACTOR_E18\n        );\n\n        uint256 ethValueAfter = _getTokensInETH(\n            WETH_ADDRESS,\n            ethAmount\n        )\n            * _allowedSpread\n            / PRECISION_FACTOR_E18;\n\n        if (ethValueAfter < ethValueBefore) {\n            revert TooMuchValueLost();\n        }\n\n        if (_ethBack == true) {\n            _closingRouteETH(\n                ethAmount,\n                _totalDebtBalancer,\n                _caller\n            );\n\n            return;\n        }\n\n        _closingRouteToken(\n            ethAmount,\n            _totalDebtBalancer,\n            _caller\n        );\n    }\n\n    function _getEthBack(\n        uint256 _swapAmount,\n        uint256 _minOutAmount\n    )\n        internal\n        returns (uint256)\n    {\n        if (block.chainid == ETH_CHAIN_ID) {\n            return _swapStETHintoETH(\n                _swapAmount,\n                _minOutAmount\n            );\n        }\n\n        if (block.chainid == ARB_CHAIN_ID) {\n            uint256 wethAmount = _getTokensUniV3(\n                _swapAmount,\n                _minOutAmount,\n                ENTRY_ASSET,\n                WETH_ADDRESS\n            );\n\n            _unwrapETH(\n                wethAmount\n            );\n\n            return wethAmount;\n        }\n\n        revert WrongChainId();\n    }\n\n    function _getTokensUniV3(\n        uint256 _amountIn,\n        uint256 _minOutAmount,\n        address _tokenIn,\n        address _tokenOut\n    )\n        internal\n        returns (uint256)\n    {\n        return UNISWAP_V3_ROUTER.exactInputSingle(\n            IUniswapV3.ExactInputSingleParams(\n                {\n                    tokenIn: _tokenIn,\n                    tokenOut: _tokenOut,\n                    fee: UNISWAP_V3_FEE,\n                    recipient: address(this),\n                    deadline: block.timestamp,\n                    amountIn: _amountIn,\n                    amountOutMinimum: _minOutAmount,\n                    sqrtPriceLimitX96: 0\n                }\n            )\n        );\n    }\n\n    /**\n     * @dev Internal wrapper function for curve swap\n     * of stETH into ETH.\n     */\n    function _swapStETHintoETH(\n        uint256 _swapAmount,\n        uint256 _minOutAmount\n    )\n        internal\n        returns (uint256)\n    {\n        return CURVE.exchange(\n            {\n                fromIndex: 1,\n                toIndex: 0,\n                exactAmountFrom: _swapAmount,\n                minReceiveAmount: _minOutAmount\n            }\n        );\n    }\n\n    function _withdrawPendleLPs(\n        uint256 _nftId,\n        uint256 _lendingShares\n    )\n        private\n        returns (uint256 withdrawnLpsAmount)\n    {\n        return IPendleChild(PENDLE_CHILD).withdrawExactShares(\n            WISE_LENDING.withdrawExactShares(\n                _nftId,\n                PENDLE_CHILD,\n                _lendingShares\n            )\n        );\n    }\n\n    function _paybackExactShares(\n        bool _isAave,\n        uint256 _nftId,\n        uint256 _borrowShares\n    )\n        internal\n    {\n        if (_isAave == true) {\n            AAVE_HUB.paybackExactShares(\n                _nftId,\n                WETH_ADDRESS,\n                _borrowShares\n            );\n\n            return;\n        }\n\n        WISE_LENDING.paybackExactShares(\n            _nftId,\n            WETH_ADDRESS,\n            _borrowShares\n        );\n    }\n\n    /**\n     * @dev Internal wrapper function for a closing route\n     * which returns {ENTRY_ASSET} to the owner in the end.\n     */\n    function _closingRouteToken(\n        uint256 _tokenAmount,\n        uint256 _totalDebtBalancer,\n        address _caller\n    )\n        private\n    {\n        _wrapETH(\n            _tokenAmount\n        );\n\n        _safeTransfer(\n            WETH_ADDRESS,\n            msg.sender,\n            _totalDebtBalancer\n        );\n\n        _safeTransfer(\n            WETH_ADDRESS,\n            _caller,\n            _tokenAmount\n                - _totalDebtBalancer\n        );\n    }\n\n    /**\n     * @dev Internal wrapper function for a closing route\n     * which returns ETH to the owner in the end.\n     */\n    function _closingRouteETH(\n        uint256 _ethAmount,\n        uint256 _totalDebtBalancer,\n        address _caller\n    )\n        internal\n    {\n        _wrapETH(\n            _totalDebtBalancer\n        );\n\n        _safeTransfer(\n            WETH_ADDRESS,\n            msg.sender,\n            _totalDebtBalancer\n        );\n\n        _sendValue(\n            _caller,\n            _ethAmount\n                - _totalDebtBalancer\n        );\n    }\n\n    /**\n     * @dev Internal function executing the\n     * collateral deposit by converting ETH\n     * into {ENTRY_ASSET}, adding it as collateral and\n     * borrowing the flashloan token to pay\n     * back {_totalDebtBalancer}.\n     */\n    function _logicOpenPosition(\n        bool _isAave,\n        uint256 _nftId,\n        uint256 _depositAmount,\n        uint256 _totalDebtBalancer,\n        uint256 _allowedSpread\n    )\n        internal\n    {\n        uint256 reverseAllowedSpread = 2\n            * PRECISION_FACTOR_E18\n            - _allowedSpread;\n\n        if (block.chainid == ARB_CHAIN_ID) {\n\n            _depositAmount = _getTokensUniV3(\n                _depositAmount,\n                _getEthInTokens(\n                        ENTRY_ASSET,\n                        _depositAmount\n                    )\n                * reverseAllowedSpread\n                / PRECISION_FACTOR_E18,\n                WETH_ADDRESS,\n                ENTRY_ASSET\n            );\n        }\n\n        uint256 syReceived = PENDLE_SY.deposit(\n            {\n                _receiver: address(this),\n                _tokenIn: ENTRY_ASSET,\n                _amountTokenToDeposit: _depositAmount,\n                _minSharesOut: PENDLE_SY.previewDeposit(\n                    ENTRY_ASSET,\n                    _depositAmount\n                )\n            }\n        );\n\n        (   ,\n            uint256 netPtFromSwap,\n            ,\n            ,\n            ,\n        ) = PENDLE_ROUTER_STATIC.addLiquiditySingleSyStatic(\n            address(PENDLE_MARKET),\n            syReceived\n        );\n\n        (\n            uint256 netLpOut\n            ,\n        ) = PENDLE_ROUTER.addLiquiditySingleSy(\n            {\n                _receiver: address(this),\n                _market: address(PENDLE_MARKET),\n                _netSyIn: syReceived,\n                _minLpOut: 0,\n                _guessPtReceivedFromSy: ApproxParams(\n                    {\n                        guessMin: netPtFromSwap - 100,\n                        guessMax: netPtFromSwap + 100,\n                        guessOffchain: 0,\n                        maxIteration: 50,\n                        eps: 1e15\n                    }\n                )\n            }\n        );\n\n        uint256 ethValueBefore = _getTokensInETH(\n            ENTRY_ASSET,\n            _depositAmount\n        );\n\n        (\n            uint256 receivedShares\n            ,\n        ) = IPendleChild(PENDLE_CHILD).depositExactAmount(\n            netLpOut\n        );\n\n        uint256 ethValueAfter = _getTokensInETH(\n            PENDLE_CHILD,\n            receivedShares\n        )\n            * _allowedSpread\n            / PRECISION_FACTOR_E18;\n\n        if (ethValueAfter < ethValueBefore) {\n            revert TooMuchValueLost();\n        }\n\n        WISE_LENDING.depositExactAmount(\n            _nftId,\n            PENDLE_CHILD,\n            receivedShares\n        );\n\n        _borrowExactAmount(\n            _isAave,\n            _nftId,\n            _totalDebtBalancer\n        );\n\n        if (_checkDebtRatio(_nftId) == false) {\n            revert DebtRatioTooHigh();\n        }\n\n        _safeTransfer(\n            WETH_ADDRESS,\n            BALANCER_ADDRESS,\n            _totalDebtBalancer\n        );\n    }\n\n    function _borrowExactAmount(\n        bool _isAave,\n        uint256 _nftId,\n        uint256 _totalDebtBalancer\n    )\n        internal\n    {\n        if (_isAave == true) {\n            AAVE_HUB.borrowExactAmount(\n                _nftId,\n                WETH_ADDRESS,\n                _totalDebtBalancer\n            );\n\n            return;\n        }\n\n        WISE_LENDING.borrowExactAmount(\n            _nftId,\n            WETH_ADDRESS,\n            _totalDebtBalancer\n        );\n    }\n\n    /**\n     * @dev Internal function summarizing liquidation\n     * checks and interface call for core liquidation\n     * from wise lending.\n     */\n    function _coreLiquidation(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        uint256 _shareAmountToPay\n    )\n        internal\n        returns (\n            uint256 paybackAmount,\n            uint256 receivingAmount\n        )\n    {\n        if (_checkDebtRatio(_nftId) == true) {\n            revert DebtRatioTooLow();\n        }\n\n        address paybackToken = isAave[_nftId] == true\n            ? AAVE_WETH_ADDRESS\n            : WETH_ADDRESS;\n\n        paybackAmount = WISE_LENDING.paybackAmount(\n            paybackToken,\n            _shareAmountToPay\n        );\n\n        uint256 cutoffShares = isAave[_nftId] == true\n            ? _getPositionBorrowSharesAave(_nftId)\n                * FIVTY_PERCENT\n                / PRECISION_FACTOR_E18\n            : _getPositionBorrowShares(_nftId)\n                * FIVTY_PERCENT\n                / PRECISION_FACTOR_E18;\n\n        if (_shareAmountToPay > cutoffShares) {\n            revert TooMuchShares();\n        }\n\n        receivingAmount = WISE_LENDING.coreLiquidationIsolationPools(\n            _nftId,\n            _nftIdLiquidator,\n            msg.sender,\n            paybackToken,\n            PENDLE_CHILD,\n            paybackAmount,\n            _shareAmountToPay\n        );\n    }\n}"
    },
    {
      "filename": "contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./PendlePowerFarmMathLogic.sol\";\n\nabstract contract PendlePowerFarmLeverageLogic is\n    PendlePowerFarmMathLogic,\n    IFlashLoanRecipient\n{\n    /**\n     * @dev Wrapper function preparing balancer flashloan and\n     * loading data to pass into receiver.\n     */\n    function _executeBalancerFlashLoan(\n        uint256 _nftId,\n        uint256 _flashAmount,\n        uint256 _initialAmount,\n        uint256 _lendingShares,\n        uint256 _borrowShares,\n        uint256 _allowedSpread,\n        bool _ethBack,\n        bool _isAave\n    )\n        internal\n    {\n        IERC20[] memory tokens = new IERC20[](1);\n        uint256[] memory amount = new uint256[](1);\n\n        address flashAsset = WETH_ADDRESS;\n\n        tokens[0] = IERC20(flashAsset);\n        amount[0] = _flashAmount;\n\n        allowEnter = true;\n\n        BALANCER_VAULT.flashLoan(\n            this,\n            tokens,\n            amount,\n            abi.encode(\n                _nftId,\n                _initialAmount,\n                _lendingShares,\n                _borrowShares,\n                _allowedSpread,\n                msg.sender,\n                _ethBack,\n                _isAave\n            )\n        );\n    }\n\n    /**\n     * @dev Receive function from balancer flashloan. Body\n     * is called from balancer at the end of their {flashLoan()}\n     * logic. Overwritten with opening flows.\n     */\n    function receiveFlashLoan(\n        IERC20[] memory _flashloanToken,\n        uint256[] memory _flashloanAmounts,\n        uint256[] memory _feeAmounts,\n        bytes memory _userData\n    )\n        external\n    {\n        if (allowEnter == false) {\n            revert AccessDenied();\n        }\n\n        allowEnter = false;\n\n        if (_flashloanToken.length == 0) {\n            revert InvalidParam();\n        }\n\n        if (msg.sender != BALANCER_ADDRESS) {\n            revert NotBalancerVault();\n        }\n\n        uint256 totalDebtBalancer = _flashloanAmounts[0]\n            + _feeAmounts[0];\n\n        (\n            uint256 nftId,\n            uint256 initialAmount,\n            uint256 lendingShares,\n            uint256 borrowShares,\n            uint256 allowedSpread,\n            address caller,\n            bool ethBack,\n            bool isAave\n        ) = abi.decode(\n            _userData,\n            (\n                uint256,\n                uint256,\n                uint256,\n                uint256,\n                uint256,\n                address,\n                bool,\n                bool\n            )\n        );\n\n        if (initialAmount > 0) {\n            _logicOpenPosition(\n                isAave,\n                nftId,\n                _flashloanAmounts[0] + initialAmount,\n                totalDebtBalancer,\n                allowedSpread\n            );\n\n            return;\n        }\n\n        _logicClosePosition(\n            nftId,\n            borrowShares,\n            lendingShares,\n            totalDebtBalancer,\n            allowedSpread,\n            caller,\n            ethBack,\n            isAave\n        );\n    }\n\n    /**\n     * @dev Closes position using balancer flashloans.\n     */\n    function _logicClosePosition(\n        uint256 _nftId,\n        uint256 _borrowShares,\n        uint256 _lendingShares,\n        uint256 _totalDebtBalancer,\n        uint256 _allowedSpread,\n        address _caller,\n        bool _ethBack,\n        bool _isAave\n    )\n        private\n    {\n        _paybackExactShares(\n            _i"
    }
  ]
}