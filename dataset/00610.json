{
  "Title": "Deployment Edge Case",
  "Content": "The `World` contract's `initialize` function sets up the `CoreSystem` functionality. To make it only callable once, it checks if there is [no existing `\"core\"` module](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/World.sol#L82) installed.\n\n\nHowever, the [core module is installed](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/World.sol#L118) under the name that the module responds with. If it responds with a different name, `initialize` will still be callable. This should not happen if the `World` creator is honest. A malicious owner can utilize this function as a backdoor through the [delegate call](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/World.sol#L110). As the `initialize` function's access is bound to the [creator role](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/World.sol#L47), this attack vector is active despite potentially revoking any root namespace ownership. Also, it allows [overwriting any other record](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/World.sol#L118) in the table of installed modules.\n\n\nIt is worth noting that the [initial validation](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/World.sol#L82) reads a record from the `InstalledModules` table before it is registered, and the subsequent [update](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/World.sol#L118) assumes the core module registered the table. This still works whether or not the core module actually registers the `InstalledModules` table because both operations directly access the contract storage location where the relevant table record *would be* stored. Nevertheless, it undermines the expected table abstraction.\n\n\nConsider explicitly installing the core module under the [`CORE_MODULE_NAME`](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/modules/core/constants.sol#L13) to ensure the `initialize` function is single-use. Alternatively, to avoid accessing an unregistered table, consider introducing a new initialization flag.\n\n\n***Update:** Resolved in [pull request #2170](https://github.com/latticexyz/mud/pull/2170). There is a new `CoreModuleAddress` table to save the address.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/world/src/World.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { StoreData } from \"@latticexyz/store/src/StoreData.sol\";\nimport { IStore } from \"@latticexyz/store/src/IStore.sol\";\nimport { StoreCore } from \"@latticexyz/store/src/StoreCore.sol\";\nimport { Bytes } from \"@latticexyz/store/src/Bytes.sol\";\nimport { Schema } from \"@latticexyz/store/src/Schema.sol\";\nimport { PackedCounter } from \"@latticexyz/store/src/PackedCounter.sol\";\nimport { FieldLayout } from \"@latticexyz/store/src/FieldLayout.sol\";\n\nimport { WORLD_VERSION } from \"./version.sol\";\nimport { System } from \"./System.sol\";\nimport { ResourceId, WorldResourceIdInstance } from \"./WorldResourceId.sol\";\nimport { ROOT_NAMESPACE_ID, ROOT_NAMESPACE, ROOT_NAME } from \"./constants.sol\";\nimport { AccessControl } from \"./AccessControl.sol\";\nimport { SystemCall } from \"./SystemCall.sol\";\nimport { WorldContextProviderLib } from \"./WorldContext.sol\";\nimport { revertWithBytes } from \"./revertWithBytes.sol\";\nimport { Delegation } from \"./Delegation.sol\";\nimport { requireInterface } from \"./requireInterface.sol\";\n\nimport { NamespaceOwner } from \"./codegen/tables/NamespaceOwner.sol\";\nimport { InstalledModules } from \"./codegen/tables/InstalledModules.sol\";\nimport { UserDelegationControl } from \"./codegen/tables/UserDelegationControl.sol\";\nimport { NamespaceDelegationControl } from \"./codegen/tables/NamespaceDelegationControl.sol\";\n\nimport { IModule, MODULE_INTERFACE_ID } from \"./IModule.sol\";\nimport { IWorldKernel } from \"./IWorldKernel.sol\";\nimport { IDelegationControl } from \"./IDelegationControl.sol\";\n\nimport { Systems } from \"./codegen/tables/Systems.sol\";\nimport { SystemHooks } from \"./codegen/tables/SystemHooks.sol\";\nimport { FunctionSelectors } from \"./codegen/tables/FunctionSelectors.sol\";\nimport { Balances } from \"./codegen/tables/Balances.sol\";\nimport { CORE_MODULE_NAME } from \"./modules/core/constants.sol\";\n\n/**\n * @title World Contract\n * @dev This contract is the core \"World\" contract containing various methods for\n * data manipulation, system calls, and dynamic function selector handling.\n */\ncontract World is StoreData, IWorldKernel {\n  using WorldResourceIdInstance for ResourceId;\n\n  /// @notice Address of the contract's creator.\n  address public immutable creator;\n\n  /// @return The current version of the world contract.\n  function worldVersion() public pure returns (bytes32) {\n    return WORLD_VERSION;\n  }\n\n  /// @dev Event emitted when the World contract is created.\n  constructor() {\n    creator = msg.sender;\n    emit HelloWorld(WORLD_VERSION);\n  }\n\n  /**\n   * @dev Prevents the World contract from calling itself.\n   */\n  modifier requireNoCallback() {\n    if (msg.sender == address(this)) {\n      revert World_CallbackNotAllowed(msg.sig);\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes the World by installing the core module.\n   * @param coreModule The core module to initialize the World with.\n   * @dev Only the initial creator can initialize. This can be done only once.\n   */\n  function initialize(IModule coreModule) public requireNoCallback {\n    // Only the initial creator of the World can initialize it\n    if (msg.sender != creator) {\n      revert World_AccessDenied(ROOT_NAMESPACE_ID.toString(), msg.sender);\n    }\n\n    // The World can only be initialized once\n    if (InstalledModules._get(CORE_MODULE_NAME, keccak256(\"\")) != address(0)) {\n      revert World_AlreadyInitialized();\n    }\n\n    // Initialize the World by installing the core module\n    _installRootModule(coreModule, new bytes(0));\n  }\n\n  /**\n   * @notice Installs a given root module in the World.\n   * @param module The module to be installed.\n   * @param args Arguments for module installation.\n   * @dev The caller must own the root namespace.\n   */\n  function installRootModule(IModule module, bytes memory args) public requireNoCallback {\n    AccessControl.requireOwner(ROOT_NAMESPACE_ID, msg.sender);\n    _installRootModule(module, args);\n  }\n\n  /**\n   * @dev Internal function to install a root module.\n   * @param module The module to be installed.\n   * @param args Arguments for module installation.\n   */\n  function _installRootModule(IModule module, bytes memory args) internal {\n    // Require the provided address to implement the IModule interface\n    requireInterface(address(module), MODULE_INTERFACE_ID);\n\n    WorldContextProviderLib.delegatecallWithContextOrRevert({\n      msgSender: msg.sender,\n      msgValue: 0,\n      target: address(module),\n      callData: abi.encodeCall(IModule.installRoot, (args))\n    });\n\n    // Register the module in the InstalledModules table\n    InstalledModules._set(module.getName(), keccak256(args), address(module));\n  }\n\n  /************************************************************************\n   *\n   *    WORLD STORE METHODS\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Writes a record in the table identified by `tableId`.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param staticData Static data (fixed length fields) of the record.\n   * @param encodedLengths Encoded lengths of data.\n   * @param dynamicData Dynamic data (variable length fields) of the record.\n   * @dev Requires the caller to have access to the table's namespace or name (encoded in the tableId).\n   */\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    bytes calldata staticData,\n    PackedCounter encodedLengths,\n    bytes calldata dynamicData\n  ) public virtual requireNoCallback {\n    // Require access to the namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Set the record\n    StoreCore.setRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData);\n  }\n\n  /**\n   * @notice Modifies static (fixed length) data in a record at the specified position.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param start Position from where the static data modification should start.\n   * @param data Data to splice into the static data of the record.\n   */\n  function spliceStaticData(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint48 start,\n    bytes calldata data\n  ) public virtual requireNoCallback {\n    // Require access to the namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Splice the static data\n    StoreCore.spliceStaticData(tableId, keyTuple, start, data);\n  }\n\n  /**\n   * @notice Modifies dynamic (variable length) data in a record for a specified field.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param dynamicFieldIndex Index of the dynamic field to modify.\n   * @param startWithinField Start position within the specified dynamic field.\n   * @param deleteCount Number of bytes to delete starting from the `startWithinField`.\n   * @param data Data to splice into the dynamic data of the field.\n   */\n  function spliceDynamicData(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    bytes calldata data\n  ) public virtual requireNoCallback {\n    // Require access to the namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Splice the dynamic data\n    StoreCore.spliceDynamicData(tableId, keyTuple, dynamicFieldIndex, startWithinField, deleteCount, data);\n  }\n\n  /**\n   * @notice Writes data into a specified field in the table identified by `tableId`.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param fieldIndex Index of the field to modify.\n   * @param data Data to write into the specified field.\n   */\n  function setField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    bytes calldata data\n  ) public virtual requireNoCallback {\n    // Require access to namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Set the field\n    StoreCore.setField(tableId, keyTuple, fieldIndex, data);\n  }\n\n  /**\n   * @notice Writes data into a specified field in the table, adhering to a specific layout.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param fieldIndex Index of the field to modify.\n   * @param data Data to write into the specified field.\n   * @param fieldLayout The layout to adhere to when modifying the field.\n   */\n  function setField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    bytes calldata data,\n    FieldLayout fieldLayout\n  ) public virtual requireNoCallback {\n    // Require access to namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Set the field\n    StoreCore.setField(tableId, keyTuple, fieldIndex, data, fieldLayout);\n  }\n\n  /**\n   * @notice Writes data into a static (fixed length) field in the table identified by `tableId`.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param fieldIndex Index of the static field to modify.\n   * @param data Data to write into the specified static field.\n   * @param fieldLayout The layout to adhere to when modifying the field.\n   * @dev Requires the caller to have access to the table's namespace or name (encoded in the tableId).\n   */\n  function setStaticField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    bytes calldata data,\n    FieldLayout fieldLayout\n  ) public virtual requireNoCallback {\n    // Require access to namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Set the field\n    StoreCore.setStaticField(tableId, keyTuple, fieldIndex, data, fieldLayout);\n  }\n\n  /**\n   * @notice Writes data into a dynamic (varible length) field in the table identified by `tableId`.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param dynamicFieldIndex Index of the dynamic field to modify.\n   * @param data Data to write into the specified dynamic field.\n   */\n  function setDynamicField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes calldata data\n  ) public virtual requireNoCallback {\n    // Require access to namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Set the field\n    StoreCore.setDynamicField(tableId, keyTuple, dynamicFieldIndex, data);\n  }\n\n  /**\n   * @notice Appends data to the end of a dynamic (variable length) field in the table identified by `tableId`.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param dynamicFieldIndex Index of the dynamic field to append to.\n   * @param dataToPush Data to append to the specified dynamic field.\n   */\n  function pushToDynamicField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes calldata dataToPush\n  ) public virtual requireNoCallback {\n    // Require access to namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Push to the field\n    StoreCore.pushToDynamicField(tableId, keyTuple, dynamicFieldIndex, dataToPush);\n  }\n\n  /**\n   * @notice Removes a specified amount of data from the end of a dynamic (variable length) field in the table identified by `tableId`.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param dynamicFieldIndex Index of the dynamic field to remove data from.\n   * @param byteLengthToPop The number of bytes to remove from the end of the dynamic field.\n   */\n  function popFromDynamicField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 byteLengthToPop\n  ) public virtual requireNoCallback {\n    // Require access to namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Push to the field\n    StoreCore.popFromDynamicField(tableId, keyTuple, dynamicFieldIndex, byteLengthToPop);\n  }\n\n  /**\n   * @notice Deletes a record from the table identified by `tableId`.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record to delete.\n   * @dev Requires the caller to have access to the table's namespace or name.\n   */\n  function deleteRecord(ResourceId tableId, bytes32[] calldata keyTuple) public virtual requireNoCallback {\n    // Require access to namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Delete the record\n    StoreCore.deleteRecord(tableId, keyTuple);\n  }\n\n  /************************************************************************\n   *\n   *    SYSTEM CALLS\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Calls a system with a given system ID.\n   * @param systemId The ID of the system to be called.\n   * @param callData The data for the system call.\n   * @return Return data from the system call.\n   * @dev If system is private, caller must have appropriate access.\n   */\n  function call(\n    ResourceId systemId,\n    bytes memory callData\n  ) external payable virtual requireNoCallback returns (bytes memory) {\n    return SystemCall.callWithHooksOrRevert(msg.sender, systemId, callData, msg.value);\n  }\n\n  /**\n   * @notice Calls a system with a given system ID on behalf of the given delegator.\n   * @param delegator The address on whose behalf the system is called.\n   * @param systemId The ID of the system to be called.\n   * @param callData The ABI data for the system call.\n   * @return Return data from the system call.\n   * @dev If system is private, caller must have appropriate access.\n   */\n  function callFrom(\n    address delegator,\n    ResourceId systemId,\n    bytes memory callData\n  ) external payable virtual requireNoCallback returns (bytes memory) {\n    // If the delegator is the caller, call the system directly\n    if (delegator == msg.sender) {\n      return SystemCall.callWithHooksOrRevert(msg.sender, systemId, callData, msg.value);\n    }\n\n    // Check if there is an individual authorization for this caller to perform actions on behalf of the delegator\n    ResourceId individualDelegationId = UserDelegationControl._get({ delegator: delegator, delegatee: msg.sender });\n\n    if (Delegation.verify(individualDelegationId, delegator, msg.sender, systemId, callData)) {\n      // forward the call as `delegator`\n      return SystemCall.callWithHooksOrRevert(delegator, systemId, callData, msg.value);\n    }\n\n    // Check if the delegator has a fallback delegation control set\n    ResourceId userFallbackDelegationId = UserDelegationControl._get({ delegator: delegator, delegatee: address(0) });\n    if (Delegation.verify(userFallbackDelegationId, delegator, msg.sender, systemId, callData)) {\n      // forward the call as `delegator`\n      return SystemCall.callWithHooksOrRevert(delegator, systemId, callData, msg.value);\n    }\n\n    // Check if the namespace has a fallback delegation control set\n    ResourceId namespaceFallbackDelegationId = NamespaceDelegationControl._get(systemId.getNamespaceId());\n    if (Delegation.verify(namespaceFallbackDelegationId, delegator, msg.sender, systemId, callData)) {\n      // forward the call as `delegator`\n      return SystemCall.callWithHooksOrRevert(delegator, systemId, callData, msg.value);\n    }\n\n    revert World_DelegationNotFound(delegator, msg.sender);\n  }\n\n  /************************************************************************\n   *\n   *    DYNAMIC FUNCTION SELECTORS\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Accepts ETH and adds to the root namespace's balance.\n   */\n  receive() external payable {\n    uint256 rootBalance = Balances._get(ROOT_NAMESPACE_ID);\n    Balances._set(ROOT_NAMESPACE_ID, rootBalance + msg.value);\n  }\n\n  /**\n   * @dev Fallback function to call registered function selectors.\n   */\n  fallback() external payable requireNoCallback {\n    (ResourceId systemId, bytes4 systemFunctionSelector) = FunctionSelectors._get(msg.sig);\n\n    if (ResourceId.unwrap(systemId) == 0) revert World_FunctionSelectorNotFound(msg.sig);\n\n    // Replace function selector in the calldata with the system function selector\n    bytes memory callData = Bytes.setBytes4(msg.data, 0, systemFunctionSelector);\n\n    // Call the function and forward the call data\n    bytes memory returnData = SystemCall.callWithHooksOrRevert(msg.sender, systemId, callData, msg.value);\n\n    // If the call was successful, return the return data\n    assembly {\n      return(add(returnData, 0x20), mload(returnData))\n    }\n  }\n}"
    },
    {
      "filename": "packages/world/src/World.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { StoreData } from \"@latticexyz/store/src/StoreData.sol\";\nimport { IStore } from \"@latticexyz/store/src/IStore.sol\";\nimport { StoreCore } from \"@latticexyz/store/src/StoreCore.sol\";\nimport { Bytes } from \"@latticexyz/store/src/Bytes.sol\";\nimport { Schema } from \"@latticexyz/store/src/Schema.sol\";\nimport { PackedCounter } from \"@latticexyz/store/src/PackedCounter.sol\";\nimport { FieldLayout } from \"@latticexyz/store/src/FieldLayout.sol\";\n\nimport { WORLD_VERSION } from \"./version.sol\";\nimport { System } from \"./System.sol\";\nimport { ResourceId, WorldResourceIdInstance } from \"./WorldResourceId.sol\";\nimport { ROOT_NAMESPACE_ID, ROOT_NAMESPACE, ROOT_NAME } from \"./constants.sol\";\nimport { AccessControl } from \"./AccessControl.sol\";\nimport { SystemCall } from \"./SystemCall.sol\";\nimport { WorldContextProviderLib } from \"./WorldContext.sol\";\nimport { revertWithBytes } from \"./revertWithBytes.sol\";\nimport { Delegation } from \"./Delegation.sol\";\nimport { requireInterface } from \"./requireInterface.sol\";\n\nimport { NamespaceOwner } from \"./codegen/tables/NamespaceOwner.sol\";\nimport { InstalledModules } from \"./codegen/tables/InstalledModules.sol\";\nimport { UserDelegationControl } from \"./codegen/tables/UserDelegationControl.sol\";\nimport { NamespaceDelegationControl } from \"./codegen/tables/NamespaceDelegationControl.sol\";\n\nimport { IModule, MODULE_INTERFACE_ID } from \"./IModule.sol\";\nimport { IWorldKernel } from \"./IWorldKernel.sol\";\nimport { IDelegationControl } from \"./IDelegationControl.sol\";\n\nimport { Systems } from \"./codegen/tables/Systems.sol\";\nimport { SystemHooks } from \"./codegen/tables/SystemHooks.sol\";\nimport { FunctionSelectors } from \"./codegen/tables/FunctionSelectors.sol\";\nimport { Balances } from \"./codegen/tables/Balances.sol\";\nimport { CORE_MODULE_NAME } from \"./modules/core/constants.sol\";\n\n/**\n * @title World Contract\n * @dev This contract is the core \"World\" contract containing various methods for\n * data manipulation, system calls, and dynamic function selector handling.\n */\ncontract World is StoreData, IWorldKernel {\n  using WorldResourceIdInstance for ResourceId;\n\n  /// @notice Address of the contract's creator.\n  address public immutable creator;\n\n  /// @return The current version of the world contract.\n  function worldVersion() public pure returns (bytes32) {\n    return WORLD_VERSION;\n  }\n\n  /// @dev Event emitted when the World contract is created.\n  constructor() {\n    creator = msg.sender;\n    emit HelloWorld(WORLD_VERSION);\n  }\n\n  /**\n   * @dev Prevents the World contract from calling itself.\n   */\n  modifier requireNoCallback() {\n    if (msg.sender == address(this)) {\n      revert World_CallbackNotAllowed(msg.sig);\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes the World by installing the core module.\n   * @param coreModule The core module to initialize the World with.\n   * @dev Only the initial creator can initialize. This can be done only once.\n   */\n  function initialize(IModule coreModule) public requireNoCallback {\n    // Only the initial creator of the World can initialize it\n    if (msg.sender != creator) {\n      revert World_AccessDenied(ROOT_NAMESPACE_ID.toString(), msg.sender);\n    }\n\n    // The World can only be initialized once\n    if (InstalledModules._get(CORE_MODULE_NAME, keccak256(\"\")) != address(0)) {\n      revert World_AlreadyInitialized();\n    }\n\n    // Initialize the World by installing the core module\n    _installRootModule(coreModule, new bytes(0));\n  }\n\n  /**\n   * @notice Installs a given root module in the World.\n   * @param module The module to be installed.\n   * @param args Arguments for module installation.\n   * @dev The caller must own the root namespace.\n   */\n  function installRootModule(IModule module, bytes memory args) public requireNoCallback {\n    AccessControl.requireOwner(ROOT_NAMESPACE_ID, msg.sender);\n    _installRootModule(module, args);\n  }\n\n  /**\n   * @dev Internal function to install a root module.\n   * @param module The module to be installed.\n   * @param args Arguments for module installation.\n   */\n  function _installRootModule(IModule module, bytes memory args) internal {\n    // Require the provided address to implement the IModule interface\n    requireInterface(address(module), MODULE_INTERFACE_ID);\n\n    WorldContextProviderLib.delegatecallWithContextOrRevert({\n      msgSender: msg.sender,\n      msgValue: 0,\n      target: address(module),\n      callData: abi.encodeCall(IModule.installRoot, (args))\n    });\n\n    // Register the module in the InstalledModules table\n    InstalledModules._set(module.getName(), keccak256(args), address(module));\n  }\n\n  /************************************************************************\n   *\n   *    WORLD STORE METHODS\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Writes a record in the table identified by `tableId`.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param staticData Static data (fixed length fields) of the record.\n   * @param encodedLengths Encoded lengths of data.\n   * @param dynamicData Dynamic data (variable length fields) of the record.\n   * @dev Requires the caller to have access to the table's namespace or name (encoded in the tableId).\n   */\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    bytes calldata staticData,\n    PackedCounter encodedLengths,\n    bytes calldata dynamicData\n  ) public virtual requireNoCallback {\n    // Require access to the namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Set the record\n    StoreCore.setRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData);\n  }\n\n  /**\n   * @notice Modifies static (fixed length) data in a record at the specified position.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param start Position from where the static data modification should start.\n   * @param data Data to splice into the static data of the record.\n   */\n  function spliceStaticData(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint48 start,\n    bytes calldata data\n  ) public virtual requireNoCallback {\n    // Require access to the namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Splice the static data\n    StoreCore.spliceStaticData(tableId, keyTuple, start, data);\n  }\n\n  /**\n   * @notice Modifies dynamic (variable length) data in a record for a specified field.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param dynamicFieldIndex Index of the dynamic field to modify.\n   * @param startWithinField Start position within the specified dynamic field.\n   * @param deleteCount Number of bytes to delete starting from the `startWithinField`.\n   * @param data Data to splice into the dynamic data of the field.\n   */\n  function spliceDynamicData(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    bytes calldata data\n  ) public virtual requireNoCallback {\n    // Require access to the namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Splice the dynamic data\n    StoreCore.spliceDynamicData(tableId, keyTuple, dynamicFieldIndex, startWithinField, deleteCount, data);\n  }\n\n  /**\n   * @notice Writes data into a specified field in the table identified by `tableId`.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param fieldIndex Index of the field to modify.\n   * @param data Data to write into the specified field.\n   */\n  function setField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    bytes calldata data\n  ) public virtual requireNoCallback {\n    // Require access to namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Set the field\n    StoreCore.setField(tableId, keyTuple, fieldIndex, data);\n  }\n\n  /**\n   * @notice Writes data into a specified field in the table, adhering to a specific layout.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param fieldIndex Index of the field to modify.\n   * @param data Data to write into the specified field.\n   * @param fieldLayout The layout to adhere to when modifying the field.\n   */\n  function setField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    bytes calldata data,\n    FieldLayout fieldLayout\n  ) public virtual requireNoCallback {\n    // Require access to namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Set the field\n    StoreCore.setField(tableId, keyTuple, fieldIndex, data, fieldLayout);\n  }\n\n  /**\n   * @notice Writes data into a static (fixed length) field in the table identified by `tableId`.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param fieldIndex Index of the static field to modify.\n   * @param data Data to write into the specified static field.\n   * @param fieldLayout The layout to adhere to when modifying the field.\n   * @dev Requires the caller to have access to the table's namespace or name (encoded in the tableId).\n   */\n  function setStaticField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 fieldIndex,\n    bytes calldata data,\n    FieldLayout fieldLayout\n  ) public virtual requireNoCallback {\n    // Require access to namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Set the field\n    StoreCore.setStaticField(tableId, keyTuple, fieldIndex, data, fieldLayout);\n  }\n\n  /**\n   * @notice Writes data into a dynamic (varible length) field in the table identified by `tableId`.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param dynamicFieldIndex Index of the dynamic field to modify.\n   * @param data Data to write into the specified dynamic field.\n   */\n  function setDynamicField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes calldata data\n  ) public virtual requireNoCallback {\n    // Require access to namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Set the field\n    StoreCore.setDynamicField(tableId, keyTuple, dynamicFieldIndex, data);\n  }\n\n  /**\n   * @notice Appends data to the end of a dynamic (variable length) field in the table identified by `tableId`.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param dynamicFieldIndex Index of the dynamic field to append to.\n   * @param dataToPush Data to append to the specified dynamic field.\n   */\n  function pushToDynamicField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes calldata dataToPush\n  ) public virtual requireNoCallback {\n    // Require access to namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Push to the field\n    StoreCore.pushToDynamicField(tableId, keyTuple, dynamicFieldIndex, dataToPush);\n  }\n\n  /**\n   * @notice Removes a specified amount of data from the end of a dynamic (variable length) field in the table identified by `tableId`.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param dynamicFieldIndex Index of the dynamic field to remove data from.\n   * @param byteLengthToPop The number of bytes to remove from the end of the dynamic field.\n   */\n  function popFromDynamicField(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 byteLengthToPop\n  ) public virtual requireNoCallback {\n    // Require access to namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Push to the field\n    StoreCore.popFromDynamicField(tableId, keyTuple, dynamicFieldIndex, byteLengthToPop);\n  }\n\n  /**\n   * @notice Deletes a record from the table identified by `tableId`.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record to delete.\n   * @dev Requires the caller to have access to the table's namespace or name.\n   */\n  function deleteRecord(ResourceId tableId, bytes32[] calldata keyTuple) public virtual requireNoCallback {\n    // Require access to namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Delete the record\n    StoreCore.deleteRecord(tableId, keyTuple);\n  }\n\n  /************************************************************************\n   *\n   *    SYSTEM CALLS\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Calls a system with a given system ID.\n   * @param systemId The ID of the system to be called.\n   * @param callData The data for the system call.\n   * @return Return data from the system call.\n   * @dev If system is private, caller must have appropriate access.\n   */\n  function call(\n    ResourceId systemId,\n    bytes memory callData\n  ) external payable virtual requireNoCallback returns (bytes memory) {\n    return SystemCall.callWithHooksOrRevert(msg.sender, systemId, callData, msg.value);\n  }\n\n  /**\n   * @notice Calls a system with a given system ID on behalf of the given delegator.\n   * @param delegator The address on whose behalf the system is called.\n   * @param systemId The ID of the system to be called.\n   * @param callData The ABI data for the system call.\n   * @return Return data from the system call.\n   * @dev If system is private, caller must have appropriate access.\n   */\n  function callFrom(\n    address delegator,\n    ResourceId systemId,\n    bytes memory callData\n  ) external payable virtual requireNoCallback returns (bytes memory) {\n    // If the delegator is the caller, call the system directly\n    if (delegator == msg.sender) {\n      return SystemCall.callWithHooksOrRevert(msg.sender, systemId, callData, msg.value);\n    }\n\n    // Check if there is an individual authorization for this caller to perform actions on behalf of the delegator\n    ResourceId individualDelegationId = UserDelegationControl._get({ delegator: delegator, delegatee: msg.sender });\n\n    if (Delegation.verify(individualDelegationId, delegator, msg.sender, systemId, callData)) {\n      // forward the call as `delegator`\n      return SystemCall.callWithHooksOrRevert(delegator, systemId, callData, msg.value);\n    }\n\n    // Check if the delegator has a fallback delegation control set\n    ResourceId userFallbackDelegationId = UserDelegationControl._get({ delegator: delegator, delegatee: address(0) });\n    if (Delegation.verify(userFallbackDelegationId, delegator, msg.sender, systemId, callData)) {\n      // forward the call as `delegator`\n      return SystemCall.callWithHooksOrRevert(delegator, systemId, callData, msg.value);\n    }\n\n    // Check if the namespace has a fallback delegation control set\n    ResourceId namespaceFallbackDelegationId = NamespaceDelegationControl._get(systemId.getNamespaceId());\n    if (Delegation.verify(namespaceFallbackDelegationId, delegator, msg.sender, systemId, callData)) {\n      // forward the call as `delegator`\n      return SystemCall.callWithHooksOrRevert(delegator, systemId, callData, msg.value);\n    }\n\n    revert World_DelegationNotFound(delegator, msg.sender);\n  }\n\n  /************************************************************************\n   *\n   *    DYNAMIC FUNCTION SELECTORS\n   *\n   **************"
    }
  ]
}