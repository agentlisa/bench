{
  "Title": "M-23: _getInterest() function uses block.timestamp instead of the inputted timestamp",
  "Content": "# Issue M-23: _getInterest() function uses block.timestamp instead of the inputted timestamp \n\nSource: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/25 \n\n## Found by \nobront, sorrynotsorry\n\n## Summary\n\nThe `_getInterest()` function takes a timestamp as input. However, in a crucial check in the function, it uses `block.timestamp` instead. The result is that other functions expecting accurate interest amounts will receive incorrect values.\n\n## Vulnerability Detail\n\nThe `_getInterest()` function takes a lien and a timestamp as input. The intention is for it to calculate the amount of time that has passed in the lien (`delta_t`) and multiply this value by the rate and the amount to get the interest generated by this timestamp.\n\nHowever, the function uses the following check regarding the timestamp:\n\n```solidity\nif (block.timestamp >= lien.start + lien.duration) {\n  delta_t = uint256(lien.start + lien.duration - lien.last);\n} \n```\n\nBecause this check uses `block.timestamp` before returning the maximum interest payment, the function will incorrectly determine which path to take, and return an incorrect interest value.\n\n## Impact\n\nThere are two negative consequences that can come from this miscalculation:\n\n- if the function is called when the lien is over (`block.timestamp >= lien.start + lien.duration`) to check an interest amount from a timestamp during the lien, it will incorrectly return the maximum interest value\n- If the function is called when the lien is active for a timestamp long after the lien is over, it will skip the check to return maximum value and return the value that would have been generated if interest kept accruing indefinitely (using `delta_t = uint256(timestamp.safeCastTo32() - lien.last);`)\n\nThis `_getInterest()` function is used in many crucial protocol functions (`_getOwed()`, `calculateSlope()`, `changeInSlope()`, `getTotalDebtForCollateralToken()`), so these incorrect values can have surprising and unexpected negative impacts on the protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L177-L196\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange `block.timestamp` to `timestamp` so that the if statement checks correctly.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/8",
  "Code": [
    {
      "filename": "src/LienToken.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {IAuctionHouse} from \"gpl/interfaces/IAuctionHouse.sol\";\nimport {IERC721, IERC165} from \"gpl/interfaces/IERC721.sol\";\nimport {ITransferProxy} from \"gpl/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {Base64} from \"./libraries/Base64.sol\";\nimport {CollateralLookup} from \"./libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"./interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"./interfaces/ICollateralToken.sol\";\nimport {ILienBase, ILienToken} from \"./interfaces/ILienToken.sol\";\n\nimport {IPublicVault} from \"./PublicVault.sol\";\nimport {VaultImplementation} from \"./VaultImplementation.sol\";\n\ncontract TransferAgent {\n  address public immutable WETH;\n  ITransferProxy public immutable TRANSFER_PROXY;\n\n  constructor(ITransferProxy _TRANSFER_PROXY, address _WETH) {\n    TRANSFER_PROXY = _TRANSFER_PROXY;\n    WETH = _WETH;\n  }\n}\n\n/**\n * @title LienToken\n * @author androolloyd\n * @notice This contract handles the creation, payments, buyouts, and liquidations of tokenized NFT-collateralized debt (liens). Vaults which originate loans against supported collateral are issued a LienToken representing the right to loan repayments and auctioned funds on liquidation.\n */\ncontract LienToken is ERC721, ILienToken, Auth, TransferAgent {\n  using FixedPointMathLib for uint256;\n  using CollateralLookup for address;\n  using SafeCastLib for uint256;\n\n  IAuctionHouse public AUCTION_HOUSE;\n  IAstariaRouter public ASTARIA_ROUTER;\n  ICollateralToken public COLLATERAL_TOKEN;\n\n  uint256 INTEREST_DENOMINATOR = 1e18; //wad per second\n\n  uint256 constant MAX_LIENS = uint256(5);\n\n  mapping(uint256 => Lien) public lienData;\n  mapping(uint256 => uint256[]) public liens;\n\n  /**\n   * @dev Setup transfer authority and initialize the buyoutNumerator and buyoutDenominator for the lien buyout premium.\n   * @param _AUTHORITY The authority manager.\n   * @param _TRANSFER_PROXY The TransferProxy for balance transfers.\n   * @param _WETH The WETH address to use for transfers.\n   */\n  constructor(\n    Authority _AUTHORITY,\n    ITransferProxy _TRANSFER_PROXY,\n    address _WETH\n  )\n    Auth(address(msg.sender), _AUTHORITY)\n    TransferAgent(_TRANSFER_PROXY, _WETH)\n    ERC721(\"Astaria Lien Token\", \"ALT\")\n  {}\n\n  /**\n   * @notice Sets addresses for the AuctionHouse, CollateralToken, and AstariaRouter contracts to use.\n   * @param what The identifier for what is being filed.\n   * @param data The encoded address data to be decoded and filed.\n   */\n  function file(bytes32 what, bytes calldata data) external requiresAuth {\n    if (what == \"setAuctionHouse\") {\n      address addr = abi.decode(data, (address));\n      AUCTION_HOUSE = IAuctionHouse(addr);\n    } else if (what == \"setCollateralToken\") {\n      address addr = abi.decode(data, (address));\n      COLLATERAL_TOKEN = ICollateralToken(addr);\n    } else if (what == \"setAstariaRouter\") {\n      address addr = abi.decode(data, (address));\n      ASTARIA_ROUTER = IAstariaRouter(addr);\n    } else {\n      revert UnsupportedFile();\n    }\n    emit File(what, data);\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ILienToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @notice Purchase a LienToken for its buyout price.\n   * @param params The LienActionBuyout data specifying the lien position, receiver address, and underlying CollateralToken information of the lien.\n   */\n\n  function buyoutLien(ILienToken.LienActionBuyout calldata params) external {\n    (bool valid, IAstariaRouter.LienDetails memory ld) = ASTARIA_ROUTER\n      .validateCommitment(params.incoming);\n\n    if (!valid) {\n      revert InvalidTerms();\n    }\n\n    uint256 collateralId = params.incoming.tokenContract.computeId(\n      params.incoming.tokenId\n    );\n    (uint256 owed, uint256 buyout) = getBuyout(collateralId, params.position);\n    uint256 lienId = liens[collateralId][params.position];\n\n    //the borrower shouldn't incur more debt from the buyout than they already owe\n    if (ld.maxAmount < owed) {\n      revert InvalidBuyoutDetails(ld.maxAmount, owed);\n    }\n    if (!ASTARIA_ROUTER.isValidRefinance(lienData[lienId], ld)) {\n      revert InvalidRefinance();\n    }\n\n    TRANSFER_PROXY.tokenTransferFrom(\n      WETH,\n      address(msg.sender),\n      getPayee(lienId),\n      uint256(buyout)\n    );\n\n    lienData[lienId].last = block.timestamp.safeCastTo32();\n    lienData[lienId].start = block.timestamp.safeCastTo32();\n    lienData[lienId].rate = ld.rate.safeCastTo240();\n    lienData[lienId].duration = ld.duration.safeCastTo32();\n\n    _transfer(ownerOf(lienId), address(params.receiver), lienId);\n  }\n\n  /**\n   * @notice Public view function that computes the interest for a LienToken since its last payment.\n   * @param collateralId The ID of the underlying CollateralToken\n   * @param position The position of the lien to calculate interest for.\n   */\n  function getInterest(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (uint256)\n  {\n    uint256 lien = liens[collateralId][position];\n    return _getInterest(lienData[lien], block.timestamp);\n  }\n\n  /**\n   * @dev Computes the interest accrued for a lien since its last payment.\n   * @param lien The Lien for the loan to calculate interest for.\n   * @param timestamp The timestamp at which to compute interest for.\n   */\n  function _getInterest(Lien memory lien, uint256 timestamp)\n    internal\n    view\n    returns (uint256)\n  {\n    if (!lien.active) {\n      return uint256(0);\n    }\n    uint256 delta_t;\n    if (block.timestamp >= lien.start + lien.duration) {\n      delta_t = uint256(lien.start + lien.duration - lien.last);\n    } else {\n      delta_t = uint256(timestamp.safeCastTo32() - lien.last);\n    }\n    return\n      delta_t.mulDivDown(lien.rate, 1).mulDivDown(\n        lien.amount,\n        INTEREST_DENOMINATOR\n      );\n  }\n\n  /**\n   * @notice Stops accruing interest for all liens against a single CollateralToken.\n   * @param collateralId The ID for the  CollateralToken of the NFT used as collateral for the liens.\n   */\n  function stopLiens(uint256 collateralId)\n    external\n    requiresAuth\n    returns (uint256 reserve, uint256[] memory lienIds)\n  {\n    reserve = 0;\n    lienIds = liens[collateralId];\n    for (uint256 i = 0; i < lienIds.length; ++i) {\n      Lien storage lien = lienData[lienIds[i]];\n      unchecked {\n        lien.amount = _getOwed(lien);\n        reserve += lien.amount;\n      }\n      lien.active = false;\n    }\n  }\n\n  /**\n   * @dev See {IERC721Metadata-tokenURI}.\n   */\n  function tokenURI(uint256 tokenId)\n    public\n    pure\n    override\n    returns (string memory)\n  {\n    return \"\";\n  }\n\n  /**\n   * @notice Creates a new lien against a CollateralToken.\n   * @param params LienActionEncumber data containing CollateralToken information and lien parameters (rate, duration, and amount, rate, and debt caps).\n   */\n  function createLien(ILienBase.LienActionEncumber memory params)\n    external\n    requiresAuth\n    returns (uint256 lienId)\n  {\n    // require that the auction is not under way\n\n    uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n\n    if (AUCTION_HOUSE.auctionExists(collateralId)) {\n      revert InvalidCollateralState(InvalidStates.AUCTION);\n    }\n\n    (address tokenContract, ) = COLLATERAL_TOKEN.getUnderlying(collateralId);\n    if (tokenContract == address(0)) {\n      revert InvalidCollateralState(InvalidStates.NO_DEPOSIT);\n    }\n\n    uint256 totalDebt = getTotalDebtForCollateralToken(collateralId);\n    uint256 impliedRate = getImpliedRate(collateralId);\n\n    uint256 potentialDebt = totalDebt *\n      (impliedRate + 1) *\n      params.terms.duration;\n\n    if (potentialDebt > params.terms.maxPotentialDebt) {\n      revert InvalidCollateralState(InvalidStates.DEBT_LIMIT);\n    }\n\n    lienId = uint256(\n      keccak256(\n        abi.encodePacked(\n          abi.encode(\n            bytes32(collateralId),\n            params.vault,\n            WETH,\n            params.terms.maxAmount,\n            params.terms.rate,\n            params.terms.duration,\n            params.terms.maxPotentialDebt\n          ),\n          params.strategyRoot\n        )\n      )\n    );\n\n    //0 - 4 are valid\n    require(\n      uint256(liens[collateralId].length) < MAX_LIENS,\n      \"too many liens active\"\n    );\n\n    uint8 newPosition = uint8(liens[collateralId].length);\n\n    _mint(VaultImplementation(params.vault).recipient(), lienId);\n    lienData[lienId] = Lien({\n      collateralId: collateralId,\n      position: newPosition,\n      amount: params.amount,\n      active: true,\n      rate: params.terms.rate.safeCastTo240(),\n      last: block.timestamp.safeCastTo32(),\n      start: block.timestamp.safeCastTo32(),\n      duration: params.terms.duration.safeCastTo32(),\n      payee: address(0)\n    });\n\n    liens[collateralId].push(lienId);\n    emit NewLien(lienId, lienData[lienId]);\n  }\n\n  /**\n   * @notice Removes all liens for a given CollateralToken.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @param remainingLiens The IDs for the unpaid liens\n   */\n  function removeLiens(uint256 collateralId, uint256[] memory remainingLiens)\n    external\n    requiresAuth\n  {\n    for (uint256 i = 0; i < remainingLiens.length; i++) {\n      delete lienData[remainingLiens[i]];\n      _burn(remainingLiens[i]);\n    }\n    delete liens[collateralId];\n    emit RemovedLiens(collateralId);\n  }\n\n  /**\n   * @notice Retrieves all liens taken out against the underlying NFT of a CollateralToken.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @return The IDs of the liens against the CollateralToken.\n   */\n  function getLiens(uint256 collateralId)\n    public\n    view\n    returns (uint256[] memory)\n  {\n    return liens[collateralId];\n  }\n\n  /**\n   * @notice Retrieves a specific Lien by its ID.\n   * @param lienId The ID of the requested Lien.\n   * @return lien The Lien for the lienId.\n   */\n  function getLien(uint256 lienId) public view returns (Lien memory lien) {\n    lien = lienData[lienId];\n    lien.amount = _getOwed(lien);\n    lien.last = block.timestamp.safeCastTo32();\n  }\n\n  /**\n   * @notice Retrives a specific Lien from the ID of the CollateralToken for the underlying NFT and the lien position.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @param position The requested lien position.\n   *  @ return lien The Lien for the lienId.\n   */\n  function getLien(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (Lien memory)\n  {\n    uint256 lienId = liens[collateralId][position];\n    return getLien(lienId);\n  }\n\n  /**\n   * @notice Computes and returns the buyout amount for a Lien.\n   * @param collateralId The ID for the underlying CollateralToken.\n   * @param position The position of the Lien to compute the buyout amount for.\n   * @return The outstanding debt for the lien and the buyout amount for the Lien.\n   */\n  function getBuyout(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (uint256, uint256)\n  {\n    Lien memory lien = getLien(collateralId, position);\n\n    uint256 remainingInterest = _getRemainingInterest(lien, true);\n    uint256 buyoutTotal = lien.amount +\n      ASTARIA_ROUTER.getBuyoutFee(remainingInterest);\n\n    return (lien.amount, buyoutTotal);\n  }\n\n  /**\n   * @notice Make a payment for the debt against a CollateralToken.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param paymentAmount The amount to pay against the debt.\n   */\n  function makePayment(uint256 collateralId, uint256 paymentAmount) public {\n    _makePayment(collateralId, paymentAmount);\n  }\n\n  /**\n   * @notice Make a payment for the debt against a CollateralToken for a specific lien.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param paymentAmount The amount to pay against the debt.\n   * @param position The lien position to make a payment to.\n   */\n  function makePayment(\n    uint256 collateralId,\n    uint256 paymentAmount,\n    uint8 position\n  ) external {\n    _payment(collateralId, position, paymentAmount, address(msg.sender));\n  }\n\n  /**\n   * @notice Have a specified paymer make a payment for the debt against a CollateralToken.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param totalCapitalAvailable The amount to pay against the debts\n   */\n  function _makePayment(uint256 collateralId, uint256 totalCapitalAvailable)\n    internal\n  {\n    uint256[] memory openLiens = liens[collateralId];\n    uint256 paymentAmount = totalCapitalAvailable;\n    for (uint256 i = 0; i < openLiens.length; ++i) {\n      uint256 capitalSpent = _payment(\n        collateralId,\n        uint8(i),\n        paymentAmount,\n        address(msg.sender)\n      );\n      paymentAmount -= capitalSpent;\n    }\n  }\n\n  function makePayment(\n    uint256 collateralId,\n    uint256 paymentAmount,\n    uint8 position,\n    address payer\n  ) public requiresAuth {\n    _payment(collateralId, position, paymentAmount, payer);\n  }\n\n  /**\n   * @notice Computes the rate for a specified lien.\n   * @param lienId The ID for the lien.\n   * @return The rate for the specified lien, in WETH per second.\n   */\n  function calculateSlope(uint256 lienId) public view returns (uint256) {\n    Lien memory lien = lienData[lienId];\n    uint256 end = (lien.start + lien.duration);\n    uint256 owedAtEnd = _getOwed(lien, end);\n    return (owedAtEnd - lien.amount).mulDivDown(1, end - lien.last);\n  }\n\n  /**\n   * @notice Computes the change in rate for a lien if a specific payment amount was made.\n   * @param lienId The ID for the lien.\n   * @param paymentAmount The hypothetical payment amount that would be made to the lien.\n   * @return slope The difference between the current lien rate and the lien rate if the payment was made.\n   */\n  function changeInSlope(uint256 lienId, uint256 paymentAmount)\n    public\n    view\n    returns (uint256 slope)\n  {\n    Lien memory lien = lienData[lienId];\n    uint256 oldSlope = calculateSlope(lienId);\n    uint256 newAmount = (lien.amount - paymentAmount);\n\n    // slope = (rate*time*amount - amount) / time -> amount(rate*time - 1) / time\n    uint256 newSlope = newAmount.mulDivDown(\n      (uint256(lien.rate).mulDivDown(lien.duration, 1) - 1),\n      lien.duration\n    );\n\n    slope = oldSlope - newSlope;\n  }\n\n  /**\n   * @notice Computes the total amount owed on all liens against a CollateralToken.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @return totalDebt The aggregate debt for all loans against the collateral.\n   */\n  function getTotalDebtForCollateralToken(uint256 collateralId)\n    public\n    view\n    returns (uint256 totalDebt)\n  {\n    uint256[] memory openLiens = getLiens(collateralId);\n    totalDebt = 0;\n    for (uint256 i = 0; i < openLiens.length; ++i) {\n      totalDebt += _getOwed(lienData[openLiens[i]]);\n    }\n  }\n\n  /**\n   * @notice Computes the total amount owed on all liens against a CollateralToken at a specified timestamp.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param timestamp The timestamp to use to calculate owed debt.\n   * @return totalDebt The aggregate debt for all loans against the specified collateral at the specified timestamp.\n   */\n  function getTotalDebtForCollateralToken(\n    uint256 collateralId,\n    uint256 timestamp\n  ) public view returns (uint256 totalDebt) {\n    uint256[] memory openLiens = getLiens(collateralId);\n    totalDebt = 0;\n\n    for (uint256 i = 0; i < openLiens.length; ++i) {\n      totalDebt += _getOwed(lienData[openLiens[i]], timestamp);\n    }\n  }\n\n  /**\n   * @notice Computes the combined rate of all liens against a CollateralToken\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @return impliedRate The aggregate rate for all loans against the specified collateral.\n   */\n  function getImpliedRate(uint256 collateralId)\n    public\n    view\n    returns (uint256 impliedRate)\n  {\n    uint256 totalDebt = getTotalDebtForCollateralToken(collateralId);\n    uint256[] memory openLiens = getLiens(collateralId);\n    impliedRate = 0;\n    for (uint256 i = 0; i < openLiens.length; ++i) {\n      Lien memory lien = lienData[openLiens[i]];\n\n      impliedRate += lien.rate * lien.amount;\n    }\n\n    if (totalDebt > uint256(0)) {\n      impliedRate = impliedRate.mulDivDown(1, totalDebt);\n    }\n  }\n\n  /**\n   * @dev Computes the debt owed to a Lien.\n   * @param lien The specified Lien.\n   * @return The amount owed to the specified Lien.\n   */\n  function _getOwed(Lien memory lien) internal view returns (uint256) {\n    return _getOwed(lien, block.timestamp);\n  }\n\n  /**\n   * @dev Computes the debt owed to a Lien at a specified timestamp.\n   * @param lien The specified Lien.\n   * @return The amount owed to the Lien at the specified timestamp.\n   */\n  function _getOwed(Lien memory lien, uint256 timestamp)\n    internal\n    view\n    returns (uint256)\n  {\n    return lien.amount + _getInterest(lien, timestamp);\n  }\n\n  /**\n   * @dev Computes the interest still owed to a Lien.\n   * @param lien The specified Lien.\n   * @param buyout compute with a ceiling based on the buyout interest window\n   * @return The WETH still owed in interest to the Lien.\n   */\n  function _getRemainingInterest(Lien memory lien, bool buyout)\n    internal\n    view\n    returns (uint256)\n  {\n    uint256 end = lien.start + lien.duration;\n    if (buyout) {\n      uint32 getBuyoutInterestWindow = ASTARIA_ROUTER.getBuyoutInterestWindow();\n      if (\n        lien.start + lien.duration >= block.timestamp + getBuyoutInterestWindow\n      ) {\n        end = block.timestamp + getBuyoutInterestWindow;\n      }\n    }\n\n    uint256 delta_t = end - block.timestamp;\n\n    return\n      delta_t.mulDivDown(lien.rate, 1).mulDivDown(\n        lien.amount,\n        INTEREST_DENOMINATOR\n      );\n  }\n\n  function getInterest(uint256 lienId) public view returns (uint256) {\n    return _getInterest(lienData[lienId], block.timestamp);\n  }\n\n  /**\n   * @dev Make a payment from a payer to a specific lien against a CollateralToken.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param position The position of the lien to make a payment to.\n   * @param paymentAmount The amount to pay against the debt.\n   * @param payer The address to make the payment.\n   * @return The paymentAmount for the payment.\n   */\n  function _payment(\n    uint256 collateralId,\n    uint8 position,\n    uint256 paymentAmount,\n    address payer\n  ) internal returns (uint256) {\n    if (paymentAmount == uint256(0)) {\n      return uint256(0);\n    }\n\n    uint256 lienId = liens[collateralId][position];\n    Lien storage lien = lienData[lienId];\n    uint256 end = (lien.start + lien.duration);\n    require(\n      block.timestamp < end || address(msg.sender) == address(AUCTION_HOUSE),\n      \"cannot pay off an expired lien\"\n    );\n\n    address lienOwner = ownerOf(lienId);\n    bool isPublicVault = IPublicVault(lienOwner).supportsInterface(\n      type(IPublicVault).interfaceId\n    );\n\n    lien.amount = _getOwed(lien);\n\n    address payee = getPayee(lienId);\n    if (isPublicVault) {\n      IPublicVault(lienOwner).beforePayment(lienId, paymentAmount);\n    }\n    if (lien.amount > paymentAmount) {\n      lien.amount -= paymentAmount;\n      lien.last = block.timestamp.safeCastTo32();\n      // slope does not need to be updated if paying off the rest, since we neutralize slope in beforePayment()\n      if (isPublicVault) {\n        IPublicVault(lienOwner).afterPayment(lienId);\n      }\n    } else {\n      if (isPublicVault && !AUCTION_HOUSE.auctionExists(collateralId)) {\n        // since the openLiens count is only positive when there are liens that haven't been paid off\n        // that should be liquidated, this lien should not be counted anymore\n        IPublicVault(lienOwner).decreaseEpochLienCount(\n          IPublicVault(lienOwner).getLienEpoch(end)\n        );\n      }\n      //delete liens\n      _deleteLienPosition(collateralId, position);\n      delete lienData[lienId]; //full delete\n\n      _burn(lienId);\n    }\n\n    TRANSFER_PROXY.tokenTransferFrom(WETH, payer, payee, paymentAmount);\n\n    emit Payment(lienId, paymentAmount);\n    return paymentAmount;\n  }\n\n  function _deleteLienPosition(uint256 collateralId, uint256 position) public {\n    uint256[] storage stack = liens[collateralId];\n    require(position < stack.length, \"index out of bounds\");\n\n    emit RemoveLien(\n      stack[position],\n      lienData[stack[position]].collateralId,\n      lienData[stack[position]].position\n    );\n    for (uint256 i = position; i < stack.length - 1; i++) {\n      stack[i] = stack[i + 1];\n    }\n    stack.pop();\n  }\n\n  /**\n   * @notice Retrieve the payee (address that receives payments and auction funds) for a specified Lien.\n   * @param lienId The ID of the Lien.\n   * @return The address of the payee for the Lien.\n   */\n  function getPayee(uint256 lienId) public view returns (address) {\n    return\n      lienData[lienId].payee != address(0)\n        ? lienData[lienId].payee\n        : ownerOf(lienId);\n  }\n\n  /**\n   * @notice Change the payee for a specified Lien.\n   * @param lienId The ID of the Lien.\n   * @param newPayee The new Lien payee.\n   */\n  function setPayee(uint256 lienId, address newPayee) public {\n    if (AUCTION_HOUSE.auctionExists(lienData[lienId].collateralId)) {\n      revert InvalidCollateralState(InvalidStates.AUCTION);\n    }\n    require(\n      !AUCTION_HOUSE.auctionExists(lienData[lienId].collateralId),\n      \"collateralId is being liquidated, cannot change payee from LiquidationAccountant\"\n    );\n    require(\n      msg.sender == ownerOf(lienId) || msg.sender == address(ASTARIA_ROUTER),\n      \"invalid owner\"\n    );\n\n    lienData[lienId].payee = newPayee;\n    emit PayeeChanged(lienId, newPayee);\n  }\n}"
    }
  ]
}