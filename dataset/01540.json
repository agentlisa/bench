{
  "Title": "M-6: Target raises can be highly damaging for dutch auctions with multiple components",
  "Content": "# Issue M-6: Target raises can be highly damaging for dutch auctions with multiple components \n\nSource: https://github.com/sherlock-audit/2023-06-Index-judging/issues/45 \n\n## Found by \n0x52\n## Summary\n\nMulti-component dutch auctions are fundamentally incompatible with target raises and will lead to inefficient pricing causing loss to set token.\n\n## Vulnerability Detail\n\nThe AuctionRebalanceModuleV1 allows targets to be increased when all component targets have been met and there is still excess quote token. When combined with multiple components, it his highly likely that these target raises will lead to inefficient pricing which will cause loss to the set token.\n\nConsider the following a set token has the following composition that has target raises enabled:\n\n40% USDC\n30% WBTC\n30% WETH\n\nThe manager wishes to rebalance the set to the following using USDC as the quote token:\n\n20% USDC\n40% WBTC\n40% WETH\n\nAssume the WETH portion of the execute within the first hour of the auction. The WBTC on the other hand doesn't execute until 12 hours in. Assume there is excess quote so the target is increased. The issue is that now because of the change in time, the WETH auction is now well above the market price. This buys the WETH for a large loss compared to the market price of WETH.\n\n## Impact\n\nPricing after target raises will likely be heavily skewed from market prices for some components lead to set token losses\n\n## Code Snippet\n\n[AuctionRebalanceModuleV1.sol#L359-L380](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L359-L380)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTarget raises should reset `rebalanceStartTime` allowing the dutch auction to restart and properly price the assets\n\n\n\n## Discussion\n\n**pblivin0x**\n\nAgree, especially since the raising of targets is onlyAllowedBidder, we should reset the pricings. \n\nIn the fix, I think we will make it such that the rebalance still ends at the same time. \n\n**bizzyvinci**\n\nEscalate\n\nThis is invalid. Let's take a look at why would we would raise target based on the [docs](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L351)\n```solidity\n* @dev ACCESS LIMITED: Increases asset targets uniformly when all target units have been met but there is remaining quote asset.\n```\n\nraiseAssetTarget is meant for uniformly raising targets **when all target units have been met**. Everything else (such as price and ratio) can be resolved by calling `startRebalance`.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is invalid. Let's take a look at why would we would raise target based on the [docs](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L351)\n> ```solidity\n> * @dev ACCESS LIMITED: Increases asset targets uniformly when all target units have been met but there is remaining quote asset.\n> ```\n> \n> raiseAssetTarget is meant for uniformly raising targets **when all target units have been met**. Everything else (such as price and ratio) can be resolved by calling `startRebalance`.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\n@bizzyvinci Could you please elaborate a bit further as to what exactly is invalid about the points raised in the issue?\n\n**bizzyvinci**\n\nFirst of all, I believe the auction buy and sell is to be used instead of trade module and this was mentioned on the [discord channel](https://discord.com/channels/812037309376495636/1127977547372703764/1128308198722523216). And the way it works is that it provides discount over market price to motivate bidder. And this discount increases linearly, exponential or logarithmically.\n\nAnd an assumption is that the discount will start low e.g 0% till a cap the manager is comfortable with e.g 5%. Whether you're buying or selling, the focus is on `discount` and that's why price would decrease during sell and price would increase during buy of quoteAsset. The price change is the discount and that's what grows or fall with the mathematical equation.\n\n\nAssuming manager/operator wants to move from 40% USDC, 30% WBTC, 30% WETH\n\nTo 20% USDC, 40% WBTC, 40% WETH using USDC\n\nIf after an hour, the ratio are 35% USDC, 30% WBTC, 35% WETH. It's safe to assume that price on WETH was too good but price on WBTC wasn't. The operator can call `startRebalance` to **update this prices**.\n\nIf the price is indeed good and the market/whale is just crazy for WBTC and it reaches 30% USDC, 30% WBTC, 40% WETH. Then no one can bid on WETH again, because of the following [requirements](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L918-L926)\n```solidity\nrequire(currentUnit != targetUnit, \"Target already met\");\n\n// Determine whether the component is being sold (sendToken) or bought\nisSellAuction = targetNotional < currentNotional;\n\n// Calculate the max quantity of the component to be exchanged. If buying, account for the protocol fees.\nmaxComponentQty = isSellAuction\n    ? currentNotional.sub(targetNotional)\n    : targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee));\n```\n\nTherefore, the best thing to do is wait till the discount on WBTC is suitable and every WBTC is munched on. Thereby reaching the goal of `20% USDC, 40% WBTC, 40% WETH`.\n\nExcess USDC means USDC is greater than 20%. And that also means either WBTC or WETH is less than 40% or both. And it is possible to be unable to bid cause targetUnit of WBTC and WETH has been reached. However, all target unit has not been reached because of USDC. The solution is to call startRebalance again and **update targetUnits** (and maybe price too is depending on what is considered fair price).\n\n\n\n**bizzyvinci**\n\nAn example of when to use `raiseAssetTargets`.\n\nAssuming USDC is quoteAsset but not a component. And we want WETH and WBTC to be 50 and 50 respectively.\n\nIf targetUnit and hence the 50:50 is reached and there's still USDC. We could use raiseAssetTarget to uniformly raise the target unit by 10% to 55:55. And that's still a 50% ratio for each component.\n\n\n**pblivin0x**\n\nI believe this is a valid medium\n\n**bizzyvinci**\n\nI still stand by my escalation because my argument is that the manager could call `startRebalance` at any point in time during an active auction. With this function `startRebalance`, they could change price, price curve, and target unit. Therefore no matter the unfavourable price, target unit or ratio, the manager has the option to call `startRebalance` instead of `raiseAssetTarget`.\n\nThe only reason a manager would call `raiseAssetTarget` instead of `startRebalance` is when \n* All target unit have been met\n* And they want to uniformly raise all the target units\n\nAnd (though it was not explicitly stated in the [docs](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L351))\n* manager is comfortable with the current price and direction. Cause if they are not, they could call `startRebalance` to update the price while raising all target units.\n\n\n**pblivin0x**\n\n> I still stand by my escalation because my argument is that the manager could call `startRebalance` at any point in time during an active auction. With this function `startRebalance`, they could change price, price curve, and target unit. Therefore no matter the unfavourable price, target unit or ratio, the manager has the option to call `startRebalance` instead of `raiseAssetTarget`.\n> \n> The only reason a manager would call `raiseAssetTarget` instead of `startRebalance` is when\n> \n> * All target unit have been met\n> * And they want to uniformly raise all the target units\n> \n> And (though it was not explicitly stated in the [docs](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L351))\n> \n> * manager is comfortable with the current price and direction. Cause if they are not, they could call `startRebalance` to update the price while raising all target units.\n\nUpon further review, I actually change my opinion, and agree with this escalation. \n\nI think that the listed remediation is not satisfactory and that it is on the SetToken manager to decide whether raiseAssetTargets or a fresh startRebalance call is preferable given their price curves. \n\n---\n\nAssume fair market prices of 1850 for ETH and 29000 for WBTC. \n\nSuppose we have a rebalance with the following individual component auctions\n+ An auction that sells WETH in exchange for DAI. Auction price begins at 2200 and lowers to a price of 1800. \n+ An auction that buys WBTC with DAI. Auction price begins at 25000 and raises to a price of 30000. \n\nNow suppose that the auctions fill, there are remaining DAI units, and both auction price curves have reached their final price (1800 and 30000). \n\nIf asset targets are raised, all auctions now become buy auctions. \n\nIf we do not reset `rebalanceStartTime` when we raise asset targets, we have\n+ Good: An auction that buys WETH with DAI at a price of 1800. This is below market value, unlikely to get filled, but not a risk for SetToken holders\n+ Bad: An auction that buys WBTC with DAI at a price of 30000. This is above market value, and a risk to SetToken holders to lose NAV\n\nIf we do reset `rebalanceStartTime` when we raise asset targets, we have\n+ Bad: An auction that buys WETH with DAI at a price of 2200. This is above market value, and a risk to SetToken holders to lose NAV\n+ Good: An auction that buys WBTC with DAI at a price of 25000. This is below market value, unlikely to get filled, but not a risk for SetToken holders\n\n---\n\nIn conclusion\n+ I agree with the stated vulnerability - `Target raises can be highly damaging for dutch auctions with multiple components`\n+ I disagree with the listed remediation - resetting the `rebalanceStartTime` does not automatically lead to proper pricing of the component auctions, because sell auctions have flipped to buy auctions on the target raise. \n+ I agree with the escalation - It is on the SetToken manager to decide whether their auction price curves are appropriate for a nonzero `raiseTargetPercentage`. If it is not appropriate, then they need to call a fresh `startRebalance()`. \n\n\n\n\n**bizzyvinci**\n\n`raiseAssetTargets` is for when you are buying all components (those listed for bidding) and you want to sell `quoteAsset` till it reaches 0 or a specified limit. This was also mentioned in the [docs](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L353) (@pblivin0x could update docs if the wordings are not clear enough for most users)\n\n> This helps in reducing tracking error and providing greater granularity in reaching an equilibrium between the excess quote asset and the components to be purchased.\n\n**hrishibhat**\n\nAdditional Sponsor comment:\n> confirming i see this as a low. manager needs to decide between proper calls (setTargetRaisePercentage or startRebalance) based on the AuctionExecutionParams they inputted\n\n\n**pblivin0x**\n\nThis issue's remediation has been removed from https://github.com/IndexCoop/index-protocol/pull/25 pending escalation resolution\n\n**IAm0x52**\n\nI disagree that this is admin's responsibility. The feature is dangerous in this scenario. There is no \"safe\" parameter that admin can use. Their only option is to not use the feature, which I don't think is a valid. It also has to be considered that the admin can't turn off rebalances after they have been enabled. I still hold this is a valid medium. #44 also provides another way this can be abused. I know that sponsor has commented that donation doesn't work but the donation occurs before the buy which causes the donated balance to be counted and to reflect in the set token balances when it updates the balances of the set token. Both this and #44 have the same root cause (not resetting the price after increase) which is why I didn't escalate that one.\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nAlthough the suggested remediation does not solve the problem the issue identified is valid. \nSponsor:\n> I agree with the stated vulnerability - Target raises can be highly damaging for dutch auctions with multiple components\n\nAdditional Sponsor comment:\n> raising asset targets is a legacy feature from the GeneralIndexModule, and as your issue correctly points out, it doesnt really make sense with dutch auctions\n\n> i am fine with any issue validity ruling here.\n\nConsidering this a valid medium based on the additional sponsor comment and the Lead Watson [comment](https://github.com/sherlock-audit/2023-06-Index-judging/issues/45#issuecomment-1672156329)\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [bizzyvinci](https://github.com/sherlock-audit/2023-06-Index-judging/issues/45/#issuecomment-1659916781): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/91",
  "Code": [
    {
      "filename": "index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol",
      "content": "/*\n    Copyright 2023 Index Coop\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.6.10;\npragma experimental \"ABIEncoderV2\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/math/Math.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport { AddressArrayUtils } from \"../../../lib/AddressArrayUtils.sol\";\nimport { IAuctionPriceAdapterV1 } from \"../../../interfaces/IAuctionPriceAdapterV1.sol\";\nimport { IController } from \"../../../interfaces/IController.sol\";\nimport { Invoke } from \"../../lib/Invoke.sol\";\nimport { ISetToken } from \"../../../interfaces/ISetToken.sol\";\nimport { ModuleBase } from \"../../lib/ModuleBase.sol\";\nimport { Position } from \"../../lib/Position.sol\";\nimport { PreciseUnitMath } from \"../../../lib/PreciseUnitMath.sol\";\n\n/**\n * @title AuctionRebalanceModuleV1\n * @author Index Coop\n * @notice Facilitates rebalances for index sets via single-asset auctions. Managers initiate\n * rebalances specifying target allocations in precise units (scaled by 10^18), quote asset\n * (e.g., WETH, USDC), auction parameters per component, and rebalance duration through\n * startRebalance(). Bidders can participate via bid() for individual components. Excess\n * quote asset can be managed by proportionally increasing the targets using raiseAssetTargets().\n *\n * @dev Compatible with StreamingFeeModule and BasicIssuanceModule. Review compatibility if used\n * with additional modules.\n */\ncontract AuctionRebalanceModuleV1 is ModuleBase, ReentrancyGuard {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using Position for uint256;\n    using Math for uint256;\n    using Position for ISetToken;\n    using Invoke for ISetToken;\n    using AddressArrayUtils for address[];\n    using AddressArrayUtils for IERC20[];\n\n    /* ============ Structs ============ */\n\n    struct AuctionExecutionParams {\n        uint256 targetUnit;                      // Target quantity of the component in Set, in precise units (10 ** 18).\n        string priceAdapterName;                 // Identifier for the price adapter to be used.\n        bytes priceAdapterConfigData;            // Encoded data for configuring the chosen price adapter.\n    }\n\n    struct BidPermissionInfo {\n        bool isAnyoneAllowedToBid;               // Flag indicating if bids are open to anyone (true) or restricted (false).\n        address[] biddersHistory;                // List of addresses that have been permissioned to bid.\n        mapping(address => bool) bidAllowList;   // Mapping of addresses to a boolean indicating if they are allowed to bid.\n    }\n\n    struct RebalanceInfo {\n        IERC20 quoteAsset;                       // Reference to the ERC20 token used to quote auctions.\n        uint256 rebalanceStartTime;              // Unix timestamp marking the start of the rebalance.\n        uint256 rebalanceDuration;               // Duration of the rebalance in seconds.\n        uint256 positionMultiplier;              // Position multiplier when target units were calculated.\n        uint256 raiseTargetPercentage;           // Optional percentage to increase all target units if allowed, in precise units.\n        address[] rebalanceComponents;           // List of component tokens involved in the rebalance.\n    }\n\n    struct BidInfo {\n        ISetToken setToken;                      // Instance of the SetToken contract that is being rebalanced.\n        IERC20 sendToken;                        // The ERC20 token being sent in this bid.\n        IERC20 receiveToken;                     // The ERC20 token being received in this bid.\n        IAuctionPriceAdapterV1 priceAdapter;     // Instance of the price adapter contract used for this bid.\n        bytes priceAdapterConfigData;            // Data for configuring the price adapter.\n        bool isSellAuction;                      // Indicates if this is a sell auction (true) or a buy auction (false).\n        uint256 auctionQuantity;                 // The quantity of the component being auctioned.\n        uint256 componentPrice;                  // The price of the component as quoted by the price adapter.\n        uint256 quantitySentBySet;               // Quantity of tokens sent by SetToken in this bid.\n        uint256 quantityReceivedBySet;           // Quantity of tokens received by SetToken in this bid.\n        uint256 preBidTokenSentBalance;          // Balance of tokens being sent by SetToken before the bid.\n        uint256 preBidTokenReceivedBalance;      // Balance of tokens being received by SetToken before the bid.\n        uint256 setTotalSupply;                  // Total supply of the SetToken at the time of the bid.\n    }\n\n    /* ============ Events ============ */\n\n    /**\n     * @dev Emitted when the target percentage increase is modified via setRaiseTargetPercentage()\n     * @param setToken                   Reference to the SetToken undergoing rebalancing\n     * @param newRaiseTargetPercentage   Updated percentage for potential target unit increases, in precise units (10 ** 18)\n     */\n    event RaiseTargetPercentageUpdated(\n        ISetToken indexed setToken, \n        uint256 newRaiseTargetPercentage\n    );\n\n    /**\n     * @dev Emitted upon calling raiseAssetTargets()\n     * @param setToken                Reference to the SetToken undergoing rebalancing\n     * @param newPositionMultiplier   Updated position multiplier for the SetToken rebalance\n     */\n    event AssetTargetsRaised(\n        ISetToken indexed setToken, \n        uint256 newPositionMultiplier\n    );\n\n    /**\n     * @dev Emitted upon toggling the bid permission setting via setAnyoneBid()\n     * @param setToken               Reference to the SetToken undergoing rebalancing\n     * @param isAnyoneAllowedToBid   Flag indicating if bids are open to all (true) or restricted (false)\n     */\n    event AnyoneBidUpdated(\n        ISetToken indexed setToken, \n        bool isAnyoneAllowedToBid\n    );\n\n    /**\n     * @dev Emitted when the bidding status of an address is changed via setBidderStatus()\n     * @param setToken          Reference to the SetToken undergoing rebalancing\n     * @param bidder            Address whose bidding permission status is toggled\n     * @param isBidderAllowed   Flag indicating if the address is allowed (true) or not allowed (false) to bid\n     */\n    event BidderStatusUpdated(\n        ISetToken indexed setToken, \n        address indexed bidder, \n        bool isBidderAllowed\n    );\n\n    /**\n     * @dev Emitted when a rebalance is initiated using the startRebalance() function.\n     * @param setToken                    Instance of the SetToken contract that is undergoing rebalancing.\n     * @param quoteAsset                  The ERC20 token that is used as a quote currency for the auctions.\n     * @param isSetTokenLocked            Indicates if the rebalance process locks the SetToken (true) or not (false).\n     * @param rebalanceDuration           Duration of the rebalance process in seconds.\n     * @param initialPositionMultiplier   Position multiplier when target units were calculated.\n     * @param componentsInvolved          Array of addresses of the component tokens involved in the rebalance.\n     * @param auctionParameters           Array of AuctionExecutionParams structs, containing auction parameters for each component token.\n     */\n    event RebalanceStarted(\n        ISetToken indexed setToken,\n        IERC20 indexed quoteAsset,\n        bool isSetTokenLocked,\n        uint256 rebalanceDuration,\n        uint256 initialPositionMultiplier,\n        address[] componentsInvolved,\n        AuctionExecutionParams[] auctionParameters\n    );\n\n    /**\n     * @dev Emitted upon execution of a bid via the bid() function.\n     * @param setToken                   Instance of the SetToken contract that is being rebalanced.\n     * @param sendToken                  The ERC20 token that is being sent by the bidder.\n     * @param receiveToken               The ERC20 token that is being received by the bidder.\n     * @param bidder                     The address of the bidder.\n     * @param priceAdapter               Instance of the price adapter contract used for this bid.\n     * @param isSellAuction              Indicates if this is a sell auction (true) or a buy auction (false).\n     * @param price                      The price of the component in precise units (10 ** 18).\n     * @param netQuantitySentBySet       The net amount of tokens sent by the SetToken in the bid.\n     * @param netQuantityReceivedBySet   The net amount of tokens received by the SetToken in the bid.\n     * @param protocolFee                The amount of the received token allocated as a protocol fee.\n     * @param setTotalSupply             The total supply of the SetToken at the time of the bid.\n     */\n    event BidExecuted(\n        ISetToken indexed setToken,\n        address indexed sendToken,\n        address indexed receiveToken,\n        address bidder,\n        IAuctionPriceAdapterV1 priceAdapter,\n        bool isSellAuction,\n        uint256 price,\n        uint256 netQuantitySentBySet,\n        uint256 netQuantityReceivedBySet,\n        uint256 protocolFee,\n        uint256 setTotalSupply\n    );\n\n    /**\n     * @dev Emitted when a locked rebalance is concluded early via the unlock() function.\n     * @param setToken            Instance of the SetToken contract that is being rebalanced.\n     */\n    event LockedRebalanceEndedEarly(\n        ISetToken indexed setToken\n    );\n\n\n    /* ============ Constants ============ */\n\n    uint256 private constant AUCTION_MODULE_V1_PROTOCOL_FEE_INDEX = 0;   // Index of the protocol fee percentage assigned to this module in the Controller.\n\n    /* ============ State Variables ============ */\n\n    mapping(ISetToken => mapping(IERC20 => AuctionExecutionParams)) public executionInfo;   // Maps SetToken to component tokens and their respective auction execution parameters.\n    mapping(ISetToken => BidPermissionInfo) public permissionInfo;                          // Maps SetToken to information regarding bid permissions during a rebalance.\n    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Maps SetToken to data relevant to the most recent rebalance.\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyAllowedBidder(ISetToken _setToken) {\n        _validateOnlyAllowedBidder(_setToken);\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    constructor(IController _controller) public ModuleBase(_controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @dev MANAGER ONLY: Initiates the rebalance process by setting target allocations for the SetToken. Opens auctions\n     * for filling by the Set's designated bidders. The function takes in new components to be added with their target units\n     * and existing components with updated target units (set to 0 if removing). A positionMultiplier is supplied to adjust\n     * target units, e.g., in cases where fee accrual affects the positionMultiplier of the SetToken, ensuring proportional\n     * allocation among components. If target allocations are not met within the specified duration, the rebalance concludes\n     * with the allocations achieved.\n     *\n     * @param _setToken                     The SetToken to be rebalanced.\n     * @param _quoteAsset                   ERC20 token used as the quote asset in auctions.\n     * @param _newComponents                Addresses of new components to be added.\n     * @param _newComponentsAuctionParams   AuctionExecutionParams for new components, indexed corresponding to _newComponents.\n     * @param _oldComponentsAuctionParams   AuctionExecutionParams for existing components, indexed corresponding to\n     *                                      the current component positions. Set to 0 for components being removed.\n     * @param _shouldLockSetToken           Indicates if the rebalance should lock the SetToken.\n     * @param _rebalanceDuration            Duration of the rebalance in seconds.\n     * @param _initialPositionMultiplier    Position multiplier at the start of the rebalance.\n     */\n    function startRebalance(\n        ISetToken _setToken,\n        IERC20 _quoteAsset,\n        address[] calldata _newComponents,\n        AuctionExecutionParams[] memory _newComponentsAuctionParams,\n        AuctionExecutionParams[] memory _oldComponentsAuctionParams,\n        bool _shouldLockSetToken,\n        uint256 _rebalanceDuration,\n        uint256 _initialPositionMultiplier\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Lock the SetToken if the _shouldLockSetToken flag is true and the SetToken is not already locked by this module\n        if (_shouldLockSetToken && _setToken.locker() != address(this)) {\n            _setToken.lock();\n        }\n\n        // Aggregate components and auction parameters\n        (address[] memory allComponents, AuctionExecutionParams[] memory allAuctionParams) = _aggregateComponentsAndAuctionParams(\n            _setToken.getComponents(),\n            _newComponents,\n            _newComponentsAuctionParams,\n            _oldComponentsAuctionParams\n        );\n\n        // Set the execution information\n        for (uint256 i = 0; i < allComponents.length; i++) {\n            require(!_setToken.hasExternalPosition(allComponents[i]), \"External positions not allowed\");\n            executionInfo[_setToken][IERC20(allComponents[i])] = allAuctionParams[i];\n        }\n\n        // Set the rebalance information\n        rebalanceInfo[_setToken].quoteAsset = _quoteAsset;\n        rebalanceInfo[_setToken].rebalanceStartTime = block.timestamp;\n        rebalanceInfo[_setToken].rebalanceDuration = _rebalanceDuration;\n        rebalanceInfo[_setToken].positionMultiplier = _initialPositionMultiplier;\n        rebalanceInfo[_setToken].rebalanceComponents = allComponents;\n\n        // Emit the RebalanceStarted event\n        emit RebalanceStarted(_setToken, _quoteAsset, _shouldLockSetToken, _rebalanceDuration, _initialPositionMultiplier, allComponents, allAuctionParams);\n    }\n\n   /**\n     * @dev ACCESS LIMITED: Only approved addresses can call this function unless isAnyoneAllowedToBid is enabled. This function\n     * is used to push the current component units closer to the target units defined in startRebalance().\n     *\n     * Bidders specify the amount of the component they intend to buy or sell, and also specify the maximum/minimum amount \n     * of the quote asset they are willing to spend/receive.\n     *\n     * The auction parameters, which are set by the manager, are used to determine the price of the component. Any bids that \n     * either don't move the component units towards the target, or overshoot the target, will be reverted.\n     *\n     * If protocol fees are enabled, they are collected in the token received in a bid.\n     * \n     * SELL AUCTIONS:\n     * At the start of the rebalance, sell auctions are available to be filled in their full size.\n     * \n     * BUY AUCTIONS:\n     * Buy auctions can be filled up to the amount of quote asset available in the SetToken. This means that if the SetToken \n     * does not contain the quote asset as a component, buy auctions cannot be bid on until sell auctions have been executed \n     * and there is quote asset available in the SetToken.\n     *\n     * @param _setToken          The SetToken to be rebalanced.\n     * @param _component         The component for which the auction is to be bid on.\n     * @param _componentAmount   The amount of component in the bid.\n     * @param _quoteAssetLimit   The maximum or minimum amount of quote asset that can be spent or received during the bid.\n     */\n    function bid(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _componentAmount,\n        uint256 _quoteAssetLimit\n    )\n        external\n        nonReentrant\n        onlyAllowedBidder(_setToken)\n    {\n        // Validate whether the bid targets are legitimate\n        _validateBidTargets(_setToken, _component);\n\n        // Create the bid information structure\n        BidInfo memory bidInfo = _createBidInfo(_setToken, _component, _componentAmount, _quoteAssetLimit);\n\n        // Execute the token transfer specified in the bid information\n        _executeBid(bidInfo);\n\n        // Accrue protocol fee and store the amount\n        uint256 protocolFeeAmount = _accrueProtocolFee(bidInfo);\n\n        // Update the position state and store the net amounts\n        (uint256 netAmountSent, uint256 netAmountReceived) = _updatePositionState(bidInfo);\n\n        // Emit the BidExecuted event\n        emit BidExecuted(\n            bidInfo.setToken,\n            address(bidInfo.sendToken),\n            address(bidInfo.receiveToken),\n            msg.sender,\n            bidInfo.priceAdapter,\n            bidInfo.isSellAuction,\n            bidInfo.componentPrice,\n            netAmountSent,\n            netAmountReceived,\n            protocolFeeAmount,\n            bidInfo.setTotalSupply\n        );\n    }\n\n    /**\n     * @dev ACCESS LIMITED: Increases asset targets uniformly when all target units have been met but there is remaining quote asset.\n     * Can be called multiple times if necessary. Targets are increased by the percentage specified by raiseAssetTargetsPercentage set by the manager.\n     * This helps in reducing tracking error and providing greater granularity in reaching an equilibrium between the excess quote asset\n     * and the components to be purchased. However, excessively raising targets may result in under-allocating to the quote asset as more of\n     * it is spent buying components to meet the new targets.\n     *\n     * @param _setToken   The SetToken to be rebalanced.\n     */\n    function raiseAssetTargets(ISetToken _setToken)\n        external\n        onlyAllowedBidder(_setToken)\n        virtual\n    {\n        // Ensure the rebalance is in progress\n        require(!_isRebalanceDurationElapsed(_setToken), \"Rebalance must be in progress\");\n\n        // Ensure that all targets are met and there is excess quote asset\n        require(_canRaiseAssetTargets(_setToken), \"Targets not met or quote asset =~ 0\");\n\n        // Calculate the new positionMultiplier\n        uint256 newPositionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(\n            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)\n        );\n\n        // Update the positionMultiplier in the RebalanceInfo struct\n        rebalanceInfo[_setToken].positionMultiplier = newPositionMultiplier;\n\n        // Emit the AssetTargetsRaised event\n        emit AssetTargetsRaised(_setToken, newPositionMultiplier);\n    }\n\n    /**\n     * @dev Unlocks the SetToken after rebalancing. Can be called once the rebalance duration has elapsed.\n     * Can only be called before the rebalance duration has elapsed if all targets are met, there is excess\n     * or at-target quote asset, and raiseTargetPercentage is zero.\n     *\n     * @param _setToken The SetToken to be unlocked.\n     */\n    function unlock(ISetToken _setToken) external {\n        bool isRebalanceDurationElapsed = _isRebalanceDurationElapsed(_setToken);\n        bool canUnlockEarly = _canUnlockEarly(_setToken);\n\n        // Ensure that either the rebalance duration has elapsed or the conditions for early unlock are met\n        require(isRebalanceDurationElapsed || canUnlockEarly, \"Cannot unlock early unless all targets are met and raiseTargetPercentage is zero\");\n\n        // If unlocking early, update the state\n        if (canUnlockEarly) {\n            delete rebalanceInfo[_setToken].rebalanceDuration;\n            emit LockedRebalanceEndedEarly(_setToken);\n        }\n\n        // Unlock the SetToken\n        _setToken.unlock();\n    }\n\n    /**\n     * @dev MANAGER ONLY: Sets the percentage by which the target units for all components can be increased.\n     * Can be called at any time by the manager.\n     *\n     * @param _setToken               The SetToken to be rebalanced.\n     * @param _raiseTargetPercentage  The percentage (in precise units) by which the target units can be increased.\n     */\n    function setRaiseTargetPercentage(\n        ISetToken _setToken,\n        uint256 _raiseTargetPercentage\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Ensure the raise target percentage is greater than 0\n        require(_raiseTargetPercentage > 0, \"Target percentage must be greater than 0\");\n\n        // Update the raise target percentage in the RebalanceInfo struct\n        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;\n\n        // Emit an event to log the updated raise target percentage\n        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);\n    }\n\n    /**\n     * @dev MANAGER ONLY: Toggles the permission status of specified addresses to call the `bid()` function.\n     * The manager can call this function at any time.\n     *\n     * @param _setToken  The SetToken being rebalanced.\n     * @param _bidders   An array of addresses whose bidding permission status is to be toggled.\n     * @param _statuses  An array of booleans indicating the new bidding permission status for each corresponding address in `_bidders`.\n     */\n    function setBidderStatus(\n        ISetToken _setToken,\n        address[] memory _bidders,\n        bool[] memory _statuses\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Validate that the input arrays have the same length\n        _bidders.validatePairsWithArray(_statuses);\n\n        // Iterate through the input arrays and update the permission status for each bidder\n        for (uint256 i = 0; i < _bidders.length; i++) {\n            _updateBiddersHistory(_setToken, _bidders[i], _statuses[i]);\n            permissionInfo[_setToken].bidAllowList[_bidders[i]] = _statuses[i];\n\n            // Emit an event to log the updated permission status\n            emit BidderStatusUpdated(_setToken, _bidders[i], _statuses[i]);\n        }\n    }\n\n    /**\n     * @dev MANAGER ONLY: Toggles whether or not anyone is allowed to call the `bid()` function.\n     * If set to true, it bypasses the bidAllowList, allowing any address to call the `bid()` function.\n     * The manager can call this function at any time.\n     *\n     * @param _setToken  The SetToken instance.\n     * @param _status    A boolean indicating if anyone can bid.\n     */\n    function setAnyoneBid(\n        ISetToken _setToken,\n        bool _status\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Update the anyoneBid status in the PermissionInfo struct\n        permissionInfo[_setToken].isAnyoneAllowedToBid = _status;\n\n        // Emit an event to log the updated anyoneBid status\n        emit AnyoneBidUpdated(_setToken, _status);\n    }\n\n\n    /**\n     * @dev MANAGER ONLY: Initializes the module for a SetToken, enabling access to AuctionModuleV1 for rebalances.\n     * Retrieves the current units for each asset in the Set and sets the targetUnit to match the current unit, effectively\n     * preventing any bidding until `startRebalance()` is explicitly called. The position multiplier is also logged to ensure that\n     * any changes to the position multiplier do not unintentionally open the Set for rebalancing.\n     *\n     * @param _setToken   Address of the Set Token\n     */\n    function initialize(ISetToken _setToken)\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        ISetToken.Position[] memory positions = _setToken.getPositions();\n\n        for (uint256 i = 0; i < positions.length; i++) {\n            ISetToken.Position memory position = positions[i];\n            require(position.positionState == 0, \"External positions not allowed\");\n            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();\n        }\n\n        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();\n        _setToken.initializeModule();\n    }\n\n\n    /**\n     * @dev Called by a SetToken to notify that this module was removed from the SetToken.\n     * Clears the `rebalanceInfo` and `permissionsInfo` of the calling SetToken.\n     * IMPORTANT: The auction execution settings of the SetToken, including auction parameters,\n     * are NOT DELETED. Restoring a previously removed module requires careful initialization of\n     * the execution settings.\n     */\n    function removeModule() external override {\n        BidPermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];\n\n        for (uint256 i = 0; i < tokenPermissionInfo.biddersHistory.length; i++) {\n            tokenPermissionInfo.bidAllowList[tokenPermissionInfo.biddersHistory[i]] = false;\n        }\n\n        delete rebalanceInfo[ISetToken(msg.sender)];\n        delete permissionInfo[ISetToken(msg.sender)];\n    }\n\n\n    /* ============ External View Functions ============ */\n\n    /**\n     * @dev Checks externally if the rebalance duration has elapsed for the given SetToken.\n     *\n     * @param _setToken The SetToken whose rebalance duration is being checked.\n     * @return bool True if the rebalance duration has elapsed; false otherwise.\n     */\n    function isRebalanceDurationElapsed(ISetToken _setToken) external view returns (bool) {\n        return _isRebalanceDurationElapsed(_setToken);\n    }\n\n    /**\n     * @dev Retrieves the array of components that are involved in the rebalancing of the given SetToken.\n     *\n     * @param _setToken    Instance of the SetToken.\n     *\n     * @return address[]   Array of component addresses involved in the rebalance.\n     */\n    function getRebalanceComponents(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return rebalanceInfo[_setToken].rebalanceComponents;\n    }\n\n    /**\n     * @dev Calculates the quantity of a component involved in the rebalancing of the given SetToken,\n     * and determines if the component is being bought or sold.\n     *\n     * @param _setToken    Instance of the SetToken being rebalanced.\n     * @param _component   Instance of the IERC20 component to bid on.\n     *\n     * @return isSellAuction       Indicates if this is a sell auction (true) or a buy auction (false).\n     * @return componentQuantity   Quantity of the component involved in the bid.\n     */\n    function getAuctionSizeAndDirection(\n        ISetToken _setToken,\n        IERC20 _component\n    )\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool isSellAuction, uint256 componentQuantity)\n    {\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            \"Component not part of rebalance\"\n        );\n        \n        uint256 totalSupply = _setToken.totalSupply();\n        return _calculateAuctionSizeAndDirection(_setToken, _component, totalSupply);\n    }\n\n    /**\n     * @dev Retrieves the balance of the quote asset for a given SetToken.\n     *\n     * @param _setToken The SetToken whose quote asset balance is being retrieved.\n     * @return uint256 The balance of the quote asset.\n     */\n    function getQuoteAssetBalance(ISetToken _setToken) external view returns (uint256) {\n        RebalanceInfo storage rebalance = rebalanceInfo[_setToken];\n        return IERC20(rebalance.quoteAsset).balanceOf(address(_setToken));\n    }\n\n    /**\n     * @dev Generates a preview of the bid for a given component in the rebalancing of the SetToken.\n     * It calculates the quantity of the component that will be exchanged and the direction of exchange.\n     *\n     * @param _setToken             Instance of the SetToken being rebalanced.\n     * @param _component            Instance of the component auction to bid on.\n     * @param _componentQuantity    Quantity of the component involved in the bid.\n     * @param _quoteQuantityLimit   Maximum or minimum amount of quote asset spent or received during the bid.\n     *\n     * @return BidInfo              Struct containing data for the bid.\n     */\n    function getBidPreview(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _componentQuantity,\n        uint256 _quoteQuantityLimit\n    )\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (BidInfo memory)\n    {\n        _validateBidTargets(_setToken, _component);\n        BidInfo memory bidInfo = _createBidInfo(_setToken, _component, _componentQuantity, _quoteQuantityLimit);\n        \n        return bidInfo;\n    }\n\n    /**\n     * @dev Checks externally if the conditions for early unlock are met.\n     *\n     * @param _setToken The SetToken being checked.\n     * @return bool True if early unlock conditions are met; false otherwise.\n     */\n    function canUnlockEarly(ISetToken _setToken) external view returns (bool) {\n        return _canUnlockEarly(_setToken);\n    }\n\n    /**\n     * @dev Checks externally if the conditions to raise asset targets are met.\n     *\n     * @param _setToken The SetToken being checked.\n     * @return bool True if conditions to raise asset targets are met; false otherwise.\n     */\n    function canRaiseAssetTargets(ISetToken _setToken) external view returns (bool) {\n        return _canRaiseAssetTargets(_setToken);\n    }\n\n    /**\n     * @dev Checks externally if all target units for components have been met.\n     *\n     * @param _setToken Instance of the SetToken to be rebalanced.\n     * @return bool True if all component's target units have been met; false otherwise.\n     */\n    function allTargetsMet(ISetToken _setToken) external view returns (bool) {\n        return _allTargetsMet(_setToken);\n    }\n\n    /**\n     * @dev Checks externally if the quote asset is in excess or at target.\n     *\n     * @param _setToken The SetToken being checked.\n     * @return bool True if the quote asset is in excess or at target; false otherwise.\n     */\n    function isQuoteAssetExcessOrAtTarget(ISetToken _setToken) external view returns (bool) {\n        return _isQuoteAssetExcessOrAtTarget(_setToken);\n    }\n\n    /**\n     * @dev Determines whether the given bidder address is allowed to participate in the auction.\n     *\n     * @param _setToken   Instance of the SetToken for which the bid is being placed.\n     * @param _bidder     Address of the bidder.\n     *\n     * @return bool       True if the given `_bidder` is permitted to bid, false otherwise.\n     */\n    function isAllowedBidder(ISetToken _setToken, address _bidder)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool)\n    {\n        return _isAllowedBidder(_setToken, _bidder);\n    }\n\n    /**\n     * @dev Retrieves the list of addresses that are permitted to participate in the auction by calling `bid()`.\n     *\n     * @param _setToken           Instance of the SetToken for which to retrieve the list of allowed bidders.\n     *\n     * @return address[]          Array of addresses representing the allowed bidders.\n     */\n    function getAllowedBidders(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return permissionInfo[_setToken].biddersHistory;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @dev Aggregates the current SetToken components with the new components and validates their auction parameters.\n     * Ensures that the sizes of the new components and new auction parameters arrays are the same, and that the number of current component auction parameters\n     * matches the number of current components. Additionally, it validates that the price adapter exists, the price adapter configuration data is valid for the adapter,\n     * and the target unit is greater than zero for new components. T"
    }
  ]
}