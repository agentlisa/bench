{
  "Title": "M-7: Wrong calculation of solvency after request to close and after close position",
  "Content": "# Issue M-7: Wrong calculation of solvency after request to close and after close position \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/184 \n\n## Found by \nshaka\n## Summary\n\n`isSolventAfterClosePosition` and `isSolventAfterRequestToClosePosition` do not account for the extra profit that the user would get from closing the position.\n\n## Vulnerability Detail\n\nWhen a party A creates a request for closing a position, the `isSolventAfterRequestToClosePosition` function is called to check if the user is solvent after the request. In the same way, when someone tries to close a position, the `isSolventAfterClosePosition` function is called to check if both party A and party B are solvent after closing the position.\n\nBoth functions calculate the available balance for party A and party B, and revert if it is lower than zero. After that, the function accounts for the  the extra loss that the user would get as a result of the difference between `closePrice` and `upnlSig.price`, and checks if the user is solvent after that.\n\nThe problem is that the function does not account for the opposite case, that is the case where the user would get an extra profit as a result of the difference between `closePrice` and `upnlSig.price`. This means that the user would not be able to close the position, even if at the end of the transaction they would be solvent.\n\n## Proof of Concept\n\nThere is an open position with:\n- Position type: LONG\n- Quantity: 1\n- Locked: 50\n- Opened price: 100\n- Current price: 110\n- Quote position uPnL Party A: 10\n\nParty B calls `fillCloseRequest` with:\n- Closed price: 120\n\nIn `isSolventAfterClosePosition` the following is calculated:\n```solidity\npartyAAvailableBalance = freeBalance + upnl + unlockedAmount = -5\n```\n\nAnd it reverts on:\n```solidity\nrequire(\n    partyBAvailableBalance >= 0 && partyAAvailableBalance >= 0,\n    \"LibSolvency: Available balance is lower than zero\"\n);\n```\n\nHowever, the extra profit for `closedPrice - upnlSig.price = 120 - 110 = 10` is not accounted for in the `partyAAvailableBalance` calculation, that should be `partyAAvailableBalance = - 5 + 10 = 5`. Party A would be solvent after closing the position, but the transaction reverts.\n\n## Impact\n\nIn a situation where the difference between the closed price and the current price will make the user solvent, users will not be able to close their positions, even if at the end of the transaction they would be solvent.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibSolvency.sol#L109-L152\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibSolvency.sol#L166-L184\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd the extra profit to the `partyAAvailableBalance` calculation.\n\n\n\n## Discussion\n\n**MoonKnightDev**\n\nThe line that is checking whether the available balance is less than zero or not and reverts, is assessing the user's status if the position were to close right now. If it doesn't meet these conditions and doesn't pass, it implies that the user is already insolvent.\n\n**shaka0x**\n\nEscalate.\n\nEven if the user is not solvent at the beginning of the close process, I cannot find any reason for not allowing a user to close a position if the outcome is that they are not insolvent anymore and both parties receive what they are due, in the same way as a user may increase their collateral to recover solvency.\n\n**sherlock-admin2**\n\n > Escalate.\n> \n> Even if the user is not solvent at the beginning of the close process, I cannot find any reason for not allowing a user to close a position if the outcome is that they are not insolvent anymore and both parties receive what they are due, in the same way as a user may increase their collateral to recover solvency.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**panprog**\n\nI agree with @shaka0x that this is a valid issue, even though very unlikely, but still possible, and it's more fair to let partyB close position with a price more favorable to partyA than requested, if it leads to solvent accounts after closure (even if partyA is insolvent at the current price).\n\nOn the other hand, I also understand the other point of view: if the user is already insolvent at the current price, he can be denied all position actions which will also be fair (as he's insolvent - he should be liquidated and no other actions allowed).\n\nUltimately I think this is a design choice, so it's up to developers to decide what is the expected behavior.\n\n**MoonKnightDev**\n\nThe system is designed to verify the user's solvency after a request to close, but I agree that this step may be unnecessary. It might be sufficient to check solvency solely within the fillCloseRequest() function.\n\n**panprog**\n\n> The system is designed to verify the user's solvency after a request to close, but I agree that this step may be unnecessary. It might be sufficient to check solvency solely within the fillCloseRequest() function.\n\nThe report is not about user being insolvent at the time of request to close, it's about user being insolvent at market price, but solvent at the requested price (during request to close) or at the closePrice (during fill close request).\n\nDuring request (long position):\n- Current price is $1000. User is insolvent at this price, but solvent at price $1010. He requests to close at $1010, but transaction reverts (although it should allow user request to be closed at price $1010)\n\nDuring fillCloseRequest:\n- User requested to close at market price $1000, he was solvent at that time\n- By the time partyB calls fillCloseRequest, market price is still $1000, but user is insolvent at price $1000 (due to the other positions he has), but is solvent at price $1010.\n- PartyB calls fillCloseRequest with a closePrice = $1010 (when market price = $1000). User is solvent at price $1010 and position should close successfully, but it reverts because user is insolvent at current market price ($1000).\n\n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/21\n\n**hrishibhat**\n\nResult:\nMedium\nUnique \nConsidering this a valid medium based on the above comments\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [shaka0x](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/184/#issuecomment-1654013440): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/libraries/LibSolvency.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../storages/MuonStorage.sol\";\nimport \"../storages/QuoteStorage.sol\";\nimport \"./LibAccount.sol\";\nimport \"./LibQuote.sol\";\n\nlibrary LibSolvency {\n    using LockedValuesOps for LockedValues;\n\n    function isSolventAfterOpenPosition(\n        uint256 quoteId,\n        uint256 filledAmount,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal view returns (bool) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        int256 partyBAvailableBalance = LibAccount.partyBAvailableBalance(\n            upnlSig.upnlPartyB,\n            quote.partyB,\n            quote.partyA\n        );\n        int256 partyAAvailableBalance = LibAccount.partyAAvailableBalance(\n            upnlSig.upnlPartyA,\n            quote.partyA\n        );\n\n        uint256 lockedAmount;\n        uint256 lockedMM;\n        if (quote.orderType == OrderType.LIMIT) {\n            lockedAmount =\n                (filledAmount * (quote.lockedValues.cva + quote.lockedValues.lf)) /\n                quote.quantity;\n            lockedMM = (filledAmount * quote.lockedValues.mm) / quote.quantity;\n        } else {\n            lockedAmount = quote.lockedValues.cva + quote.lockedValues.lf;\n            lockedMM = quote.lockedValues.mm;\n        }\n\n        partyAAvailableBalance -= int256(lockedAmount);\n        partyBAvailableBalance -= int256(lockedAmount);\n\n        if (quote.positionType == PositionType.LONG) {\n            if (quote.openedPrice >= upnlSig.price) {\n                uint256 diff = (filledAmount * (quote.openedPrice - upnlSig.price)) / 1e18;\n                uint256 max = diff > lockedMM ? diff : lockedMM;\n                require(\n                    partyAAvailableBalance - int256(max) >= 0,\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n                require(\n                    partyBAvailableBalance + int256(diff) - int256(lockedMM) >= 0,\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n            } else {\n                uint256 diff = (filledAmount * (upnlSig.price - quote.openedPrice)) / 1e18;\n                uint256 max = diff > lockedMM ? diff : lockedMM;\n                require(\n                    partyBAvailableBalance - int256(max) >= 0,\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n                require(\n                    partyAAvailableBalance + int256(diff) - int256(lockedMM) >= 0,\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n            }\n        } else if (quote.positionType == PositionType.SHORT) {\n            if (quote.openedPrice >= upnlSig.price) {\n                uint256 diff = (filledAmount * (quote.openedPrice - upnlSig.price)) / 1e18;\n                uint256 max = diff > lockedMM ? diff : lockedMM;\n                require(\n                    partyBAvailableBalance - int256(max) >= 0,\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n                require(\n                    partyAAvailableBalance + int256(diff) - int256(lockedMM) >= 0,\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n            } else {\n                uint256 diff = (filledAmount * (upnlSig.price - quote.openedPrice)) / 1e18;\n                uint256 max = diff > lockedMM ? diff : lockedMM;\n                require(\n                    partyAAvailableBalance - int256(max) >= 0,\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n                require(\n                    partyBAvailableBalance + int256(diff) - int256(lockedMM) >= 0,\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n            }\n        }\n\n        return true;\n    }\n\n    function isSolventAfterClosePosition(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 closedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal view returns (bool) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        uint256 unlockedAmount = (filledAmount * (quote.lockedValues.cva + quote.lockedValues.lf)) /\n            LibQuote.quoteOpenAmount(quote);\n\n        int256 partyBAvailableBalance = LibAccount.partyBAvailableBalanceForLiquidation(\n            upnlSig.upnlPartyB,\n            quote.partyB,\n            quote.partyA\n        ) + int256(unlockedAmount);\n\n        int256 partyAAvailableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnlPartyA,\n            quote.partyA\n        ) + int256(unlockedAmount);\n\n        require(\n            partyBAvailableBalance >= 0 && partyAAvailableBalance >= 0,\n            \"LibSolvency: Available balance is lower than zero\"\n        );\n        if (quote.positionType == PositionType.LONG) {\n            if (closedPrice >= upnlSig.price) {\n                require(\n                    uint256(partyBAvailableBalance) >=\n                        ((filledAmount * (closedPrice - upnlSig.price)) / 1e18),\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n            } else {\n                require(\n                    uint256(partyAAvailableBalance) >=\n                        ((filledAmount * (upnlSig.price - closedPrice)) / 1e18),\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n            }\n        } else if (quote.positionType == PositionType.SHORT) {\n            if (closedPrice <= upnlSig.price) {\n                require(\n                    uint256(partyBAvailableBalance) >=\n                        ((filledAmount * (upnlSig.price - closedPrice)) / 1e18),\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n            } else {\n                require(\n                    uint256(partyAAvailableBalance) >=\n                        ((filledAmount * (closedPrice - upnlSig.price)) / 1e18),\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n            }\n        }\n        return true;\n    }\n\n    function isSolventAfterRequestToClosePosition(\n        uint256 quoteId,\n        uint256 closePrice,\n        uint256 quantityToClose,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal view returns (bool) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        uint256 unlockedAmount = (quantityToClose *\n            (quote.lockedValues.cva + quote.lockedValues.lf)) / LibQuote.quoteOpenAmount(quote);\n\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            msg.sender\n        ) + int256(unlockedAmount);\n\n        require(availableBalance >= 0, \"LibSolvency: Available balance is lower than zero\");\n        if (quote.positionType == PositionType.LONG && closePrice <= upnlSig.price) {\n            require(\n                uint256(availableBalance) >=\n                    ((quantityToClose * (upnlSig.price - closePrice)) / 1e18),\n                \"LibSolvency: partyA will be liquidatable\"\n            );\n        } else if (quote.positionType == PositionType.SHORT && closePrice >= upnlSig.price) {\n            require(\n                uint256(availableBalance) >=\n                    ((quantityToClose * (closePrice - upnlSig.price)) / 1e18),\n                \"LibSolvency: partyA will be liquidatable\"\n            );\n        }\n        return true;\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/libraries/LibSolvency.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../storages/MuonStorage.sol\";\nimport \"../storages/QuoteStorage.sol\";\nimport \"./LibAccount.sol\";\nimport \"./LibQuote.sol\";\n\nlibrary LibSolvency {\n    using LockedValuesOps for LockedValues;\n\n    function isSolventAfterOpenPosition(\n        uint256 quoteId,\n        uint256 filledAmount,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal view returns (bool) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        int256 partyBAvailableBalance = LibAccount.partyBAvailableBalance(\n            upnlSig.upnlPartyB,\n            quote.partyB,\n            quote.partyA\n        );\n        int256 partyAAvailableBalance = LibAccount.partyAAvailableBalance(\n            upnlSig.upnlPartyA,\n            quote.partyA\n        );\n\n        uint256 lockedAmount;\n        uint256 lockedMM;\n        if (quote.orderType == OrderType.LIMIT) {\n            lockedAmount =\n                (filledAmount * (quote.lockedValues.cva + quote.lockedValues.lf)) /\n                quote.quantity;\n            lockedMM = (filledAmount * quote.lockedValues.mm) / quote.quantity;\n        } else {\n            lockedAmount = quote.lockedValues.cva + quote.lockedValues.lf;\n            lockedMM = quote.lockedValues.mm;\n        }\n\n        partyAAvailableBalance -= int256(lockedAmount);\n        partyBAvailableBalance -= int256(lockedAmount);\n\n        if (quote.positionType == PositionType.LONG) {\n            if (quote.openedPrice >= upnlSig.price) {\n                uint256 diff = (filledAmount * (quote.openedPrice - upnlSig.price)) / 1e18;\n                uint256 max = diff > lockedMM ? diff : lockedMM;\n                require(\n                    partyAAvailableBalance - int256(max) >= 0,\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n                require(\n                    partyBAvailableBalance + int256(diff) - int256(lockedMM) >= 0,\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n            } else {\n                uint256 diff = (filledAmount * (upnlSig.price - quote.openedPrice)) / 1e18;\n                uint256 max = diff > lockedMM ? diff : lockedMM;\n                require(\n                    partyBAvailableBalance - int256(max) >= 0,\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n                require(\n                    partyAAvailableBalance + int256(diff) - int256(lockedMM) >= 0,\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n            }\n        } else if (quote.positionType == PositionType.SHORT) {\n            if (quote.openedPrice >= upnlSig.price) {\n                uint256 diff = (filledAmount * (quote.openedPrice - upnlSig.price)) / 1e18;\n                uint256 max = diff > lockedMM ? diff : lockedMM;\n                require(\n                    partyBAvailableBalance - int256(max) >= 0,\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n                require(\n                    partyAAvailableBalance + int256(diff) - int256(lockedMM) >= 0,\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n            } else {\n                uint256 diff = (filledAmount * (upnlSig.price - quote.openedPrice)) / 1e18;\n                uint256 max = diff > lockedMM ? diff : lockedMM;\n                require(\n                    partyAAvailableBalance - int256(max) >= 0,\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n                require(\n                    partyBAvailableBalance + int256(diff) - int256(lockedMM) >= 0,\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n            }\n        }\n\n        return true;\n    }\n\n    function isSolventAfterClosePosition(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 closedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal view returns (bool) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        uint256 unlockedAmount = (filledAmount * (quote.lockedValues.cva + quote.lockedValues.lf)) /\n            LibQuote.quoteOpenAmount(quote);\n\n        int256 partyBAvailableBalance = LibAccount.partyBAvailableBalanceForLiquidation(\n            upnlSig.upnlPartyB,\n            quote.partyB,\n            quote.partyA\n        ) + int256(unlockedAmount);\n\n        int256 partyAAvailableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnlPartyA,\n            quote.partyA\n        ) + int256(unlockedAmount);\n\n        require(\n            partyBAvailableBalance >= 0 && partyAAvailableBalance >= 0,\n            \"LibSolvency: Available balance is lower than zero\"\n        );\n        if (quote.positionType == PositionType.LONG) {\n            if (closedPrice >= upnlSig.price) {\n                require(\n                    uint256(partyBAvailableBalance) >=\n                        ((filledAmount * (closedPrice - upnlSig.price)) / 1e18),\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n            } else {\n                require(\n                    uint256(partyAAvailableBalance) >=\n                        ((filledAmount * (upnlSig.price - closedPrice)) / 1e18),\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n            }\n        } else if (quote.positionType == PositionType.SHORT) {\n            if (closedPrice <= upnlSig.price) {\n                require(\n                    uint256(partyBAvailableBalance) >=\n                        ((filledAmount * (upnlSig.price - closedPrice)) / 1e18),\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n            } else {\n                require(\n                    uint256(partyAAvailableBalance) >=\n                        ((filledAmount * (closedPrice - upnlSig.price)) / 1e18),\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n            }\n        }\n        return true;\n    }\n\n    function isSolventAfterRequestToClosePosition(\n        uint256 quoteId,\n        uint256 closePrice,\n        uint256 quantityToClose,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal view returns (bool) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        uint256 unlockedAmount = (quantityToClose *\n            (quote.lockedValues.cva + quote.lockedValues.lf)) / LibQuote.quoteOpenAmount(quote);\n\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            msg.sender\n        ) + int256(unlockedAmount);\n\n        require(availableBalance >= 0, \"LibSolvency: Available balance is lower than zero\");\n        if (quote.positionType == PositionType.LONG && closePrice <= upnlSig.price) {\n            require(\n                uint256(availableBalance) >=\n                    ((quantityToClose * (upnlSig.price - closePrice)) / 1e18),\n                \"LibSolvency: partyA will be liquidatable\"\n            );\n        } else if (quote.positionType == PositionType.SHORT && closePrice >= upnlSig.price) {\n            require(\n                uint256(availableBalance) >=\n                    ((quantityToClose * (closePrice - upnlSig.price)) / 1e18),\n                \"LibSolvency: partyA will be liquidatable\"\n            );\n        }\n        return true;\n    }\n}"
    }
  ]
}