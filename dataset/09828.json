{
  "Title": "[M-02] `bEth` Rewards May Be Depleted By Flashloans or Whales",
  "Content": "\n<https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-bEth-contracts/contracts/anchor_beth_reward/src/user.rs#L187-L212>\n\nRewards are dispersed to users as a percentage of the user's balance vs total balance (of `bEth`). Rewards are accumulated each time a user calls `execute_decrease_balance()`, `execute_increase_balance()` or `execute_claim_rewards()` as these functions will in term call `update_global_index()` before any balance adjustments.\n\nThere is an attack vector where a user may arbitrarily increase their `bEth` balance either by flashloan of purchase of wormhole eth, then converting it bEth via `anchor_beth_converter`. The attacker may then have a significant portion of the total balance. This use can then call the contract which pushes rewards to `anchor_beth_reward` this will increase the `reward_balance` of the contract. Since the attacker controls a large portion of the bEth balance they will receive a higher portion of the rewards. They may then convert the bEth back to wormhole eth and close their position.\n\nThe result is the user has not contributed anything to the system but still gained a high portion of the rewards.\n\n### Proof of Concept\n\nThe logic for `update_global_index()` does not account for users suddenly increasing the balance.\n\n    fn update_global_index(state: &mut State, reward_balance: Uint128) -> StdResult<()> {\n        // Zero staking balance check\n        if state.total_balance.is_zero() {\n            // nothing balance, skip update\n            return Ok(());\n        }\n\n        // No change check\n        if state.prev_reward_balance == reward_balance {\n            // balance didnt change, skip update\n            return Ok(());\n        }\n\n        // claimed_rewards = current_balance - prev_balance;\n        let claimed_rewards = reward_balance.checked_sub(state.prev_reward_balance)?;\n\n        // update state\n        state.prev_reward_balance = reward_balance;\n        // global_index += claimed_rewards / total_balance;\n        state.global_index = decimal_summation_in_256(\n            state.global_index,\n            Decimal::from_ratio(claimed_rewards, state.total_balance),\n        );\n\n        Ok(())\n    }\n\nSteps:<br>\na) Flashloan (or buy) a significant portion of wormhole Eth<br>\nb) Convert to Anchor bEth via `anchor_beth_converter`<br>\nc) Push rewards on `anchor_beth_rewards`<br>\nd) `anchor_beth_rewards::execute_claim_rewards()`<br>\ne) Convert Anchor bEth to wormhole Eth<br>\nf) Repay flashloan (or sell wormhole eth)<br>\n\n### Recommended Mitigation Steps\n\nThere are multiple possible mitigations to this issue.\n\nFirst, option is to only allow the `global_index` to be updated once per block. In addition to this, cap the amount of rewards that may be paid per block (keeping the remaining rewards for the next block). This would reduce the effectiveness of the attack and limit the amount they may earn per block.\n\nAnother option is to induce a wait time before the user may begin earning rewards. However, this would require a second transaction from the user to begin collection their reward which may hurt UX.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-anchor-contest",
  "Code": [
    {
      "filename": "contracts/anchor-bEth-contracts/contracts/anchor_beth_reward/src/user.rs",
      "content": "use crate::state::{\n    read_config, read_contract_addr, read_holder, read_holders, read_state, store_holder,\n    store_state, Config, Holder, State,\n};\nuse beth::reward::{AccruedRewardsResponse, HolderResponse, HoldersResponse};\n\nuse cosmwasm_std::{\n    attr, Addr, BankMsg, CanonicalAddr, Coin, CosmosMsg, Decimal, Deps, DepsMut, Env, MessageInfo,\n    Response, StdError, StdResult, Uint128,\n};\n\nuse crate::math::{\n    decimal_multiplication_in_256, decimal_subtraction_in_256, decimal_summation_in_256,\n};\nuse beth::deduct_tax;\nuse std::str::FromStr;\nuse terra_cosmwasm::TerraMsgWrapper;\n\npub fn execute_claim_rewards(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    recipient: Option<Addr>,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let contract_addr = env.contract.address;\n    let holder_addr = info.sender.clone();\n    let holder_addr_raw = deps.api.addr_canonicalize(holder_addr.as_str())?;\n    let recipient = match recipient {\n        Some(value) => value,\n        None => info.sender,\n    };\n\n    let mut holder: Holder = read_holder(deps.storage, &holder_addr_raw)?;\n    let mut state: State = read_state(deps.storage)?;\n    let config: Config = read_config(deps.storage)?;\n\n    // Load the reward contract balance\n    let reward_balance = deps\n        .querier\n        .query_balance(contract_addr, config.reward_denom.as_str())\n        .unwrap();\n\n    // Update state's global index before calculating user rewards\n    update_global_index(&mut state, reward_balance.amount)?;\n\n    let reward_with_decimals =\n        calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n\n    let all_reward_with_decimals =\n        decimal_summation_in_256(reward_with_decimals, holder.pending_rewards);\n    let decimals = get_decimals(all_reward_with_decimals).unwrap();\n\n    let rewards = all_reward_with_decimals * Uint128::new(1);\n\n    if rewards.is_zero() {\n        return Err(StdError::generic_err(\"No rewards have accrued yet\"));\n    }\n\n    state.prev_reward_balance = state.prev_reward_balance.checked_sub(rewards)?;\n    store_state(deps.storage, &state)?;\n\n    holder.pending_rewards = decimals;\n    holder.index = state.global_index;\n    store_holder(deps.storage, &holder_addr_raw, &holder)?;\n\n    let bank_msg: CosmosMsg<TerraMsgWrapper> = BankMsg::Send {\n        to_address: recipient.to_string(),\n        amount: vec![deduct_tax(\n            deps.as_ref(),\n            Coin {\n                denom: config.reward_denom,\n                amount: rewards,\n            },\n        )?],\n    }\n    .into();\n\n    Ok(Response::new()\n        .add_attributes(vec![\n            attr(\"action\", \"claim_reward\"),\n            attr(\"holder_address\", holder_addr),\n            attr(\"rewards\", rewards),\n        ])\n        .add_message(bank_msg))\n}\n\npub fn execute_increase_balance(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    address: Addr,\n    amount: Uint128,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let config = read_config(deps.storage)?;\n    let token_address = assert_token_contract(config.token_contract)?;\n    let address_raw = deps.api.addr_canonicalize(address.as_str())?;\n    let sender = deps.api.addr_canonicalize(info.sender.as_str())?;\n\n    // Check sender is token contract\n    if sender != token_address {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n    let mut holder: Holder = read_holder(deps.storage, &address_raw)?;\n\n    // Load the reward contract balance\n    let reward_balance = deps\n        .querier\n        .query_balance(env.contract.address, config.reward_denom.as_str())\n        .unwrap();\n\n    // Update state's global index\n    update_global_index(&mut state, reward_balance.amount)?;\n\n    // Get decimals\n    let rewards = calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n\n    holder.index = state.global_index;\n    holder.pending_rewards = decimal_summation_in_256(rewards, holder.pending_rewards);\n    holder.balance += amount;\n    state.total_balance += amount;\n\n    store_holder(deps.storage, &address_raw, &holder)?;\n    store_state(deps.storage, &state)?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"increase_balance\"),\n        attr(\"holder_address\", address),\n        attr(\"amount\", amount),\n    ]))\n}\n\npub fn execute_decrease_balance(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    address: Addr,\n    amount: Uint128,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let config = read_config(deps.storage)?;\n    let token_address = assert_token_contract(config.token_contract)?;\n    let address_raw = deps.api.addr_canonicalize(address.as_str())?;\n    let sender = deps.api.addr_canonicalize(info.sender.as_str())?;\n\n    // Check sender is token contract\n    if sender != token_address {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n    let mut holder: Holder = read_holder(deps.storage, &address_raw)?;\n    if holder.balance < amount {\n        return Err(StdError::generic_err(format!(\n            \"Decrease amount cannot exceed user balance: {}\",\n            holder.balance\n        )));\n    }\n\n    // Load the reward contract balance\n    let reward_balance = deps\n        .querier\n        .query_balance(env.contract.address, config.reward_denom.as_str())\n        .unwrap();\n\n    // Update state's global index\n    update_global_index(&mut state, reward_balance.amount)?;\n\n    let rewards = calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n\n    holder.index = state.global_index;\n    holder.pending_rewards = decimal_summation_in_256(rewards, holder.pending_rewards);\n    holder.balance = holder.balance.checked_sub(amount).unwrap();\n    state.total_balance = state.total_balance.checked_sub(amount).unwrap();\n\n    store_holder(deps.storage, &address_raw, &holder)?;\n    store_state(deps.storage, &state)?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"decrease_balance\"),\n        attr(\"holder_address\", address),\n        attr(\"amount\", amount),\n    ]))\n}\n\n/// Increase global_index according to claimed rewards amount\nfn update_global_index(state: &mut State, reward_balance: Uint128) -> StdResult<()> {\n    // Zero staking balance check\n    if state.total_balance.is_zero() {\n        // nothing balance, skip update\n        return Ok(());\n    }\n\n    // No change check\n    if state.prev_reward_balance == reward_balance {\n        // balance didnt change, skip update\n        return Ok(());\n    }\n\n    // claimed_rewards = current_balance - prev_balance;\n    let claimed_rewards = reward_balance.checked_sub(state.prev_reward_balance)?;\n\n    // update state\n    state.prev_reward_balance = reward_balance;\n    // global_index += claimed_rewards / total_balance;\n    state.global_index = decimal_summation_in_256(\n        state.global_index,\n        Decimal::from_ratio(claimed_rewards, state.total_balance),\n    );\n\n    Ok(())\n}\n\npub fn query_accrued_rewards(deps: Deps, address: Addr) -> StdResult<AccruedRewardsResponse> {\n    let mut state = read_state(deps.storage)?;\n    let config = read_config(deps.storage)?;\n\n    let contract_addr_raw = read_contract_addr(deps.storage)?;\n    let contract_addr = deps.api.addr_humanize(&contract_addr_raw)?;\n\n    // Load the reward contract balance\n    let reward_balance = deps\n        .querier\n        .query_balance(contract_addr, config.reward_denom.as_str())\n        .unwrap();\n\n    // Update state's global index\n    update_global_index(&mut state, reward_balance.amount)?;\n\n    let holder: Holder = read_holder(deps.storage, &deps.api.addr_canonicalize(address.as_str())?)?;\n    let reward_with_decimals =\n        calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n    let all_reward_with_decimals =\n        decimal_summation_in_256(reward_with_decimals, holder.pending_rewards);\n\n    let rewards = all_reward_with_decimals * Uint128::new(1);\n\n    Ok(AccruedRewardsResponse { rewards })\n}\n\npub fn query_holder(deps: Deps, address: Addr) -> StdResult<HolderResponse> {\n    let holder: Holder = read_holder(deps.storage, &deps.api.addr_canonicalize(address.as_str())?)?;\n    Ok(HolderResponse {\n        address: address.to_string(),\n        balance: holder.balance,\n        index: holder.index,\n        pending_rewards: holder.pending_rewards,\n    })\n}\n\npub fn query_holders(\n    deps: Deps,\n    start_after: Option<Addr>,\n    limit: Option<u32>,\n) -> StdResult<HoldersResponse> {\n    let start_after = if let Some(start_after) = start_after {\n        Some(deps.api.addr_canonicalize(start_after.as_str())?)\n    } else {\n        None\n    };\n\n    let holders: Vec<HolderResponse> = read_holders(deps, start_after, limit)?;\n\n    Ok(HoldersResponse { holders })\n}\n\n// calculate the reward based on the sender's index and the global index.\nfn calculate_decimal_rewards(\n    global_index: Decimal,\n    user_index: Decimal,\n    user_balance: Uint128,\n) -> StdResult<Decimal> {\n    let decimal_balance = Decimal::from_ratio(user_balance, Uint128::new(1));\n    Ok(decimal_multiplication_in_256(\n        decimal_subtraction_in_256(global_index, user_index),\n        decimal_balance,\n    ))\n}\n\n// calculate the reward with decimal\nfn get_decimals(value: Decimal) -> StdResult<Decimal> {\n    let stringed: &str = &*value.to_string();\n    let parts: &[&str] = &*stringed.split('.').collect::<Vec<&str>>();\n    match parts.len() {\n        1 => Ok(Decimal::zero()),\n        2 => {\n            let decimals = Decimal::from_str(&*(\"0.\".to_owned() + parts[1]))?;\n            Ok(decimals)\n        }\n        _ => Err(StdError::generic_err(\"Unexpected number of dots\")),\n    }\n}\n\nfn assert_token_contract(token_contract: Option<CanonicalAddr>) -> StdResult<CanonicalAddr> {\n    match token_contract {\n        Some(v) => Ok(v),\n        None => Err(StdError::generic_err(\"Token contract has not been set\")),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    pub fn proper_calculate_rewards() {\n        let global_index = Decimal::from_ratio(Uint128::new(9), Uint128::new(100));\n        let user_index = Decimal::zero();\n        let user_balance = Uint128::new(1000);\n        let reward = calculate_decimal_rewards(global_index, user_index, user_balance).unwrap();\n        assert_eq!(reward.to_string(), \"90\");\n    }\n\n    #[test]\n    pub fn proper_get_decimals() {\n        let global_index = Decimal::from_ratio(Uint128::new(9999999), Uint128::new(100000000));\n        let user_index = Decimal::zero();\n        let user_balance = Uint128::new(10);\n        let reward = get_decimals(\n            calculate_decimal_rewards(global_index, user_index, user_balance).unwrap(),\n        )\n        .unwrap();\n        assert_eq!(reward.to_string(), \"0.9999999\");\n    }\n}"
    }
  ]
}