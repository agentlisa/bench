{
  "Title": "M-8: `MarginDex::execute_limit_order` will always revert",
  "Content": "# Issue M-8: `MarginDex::execute_limit_order` will always revert \n\nSource: https://github.com/sherlock-audit/2023-06-unstoppable-judging/issues/111 \n\n## Found by \nDug\n## Summary\nAll calls to the `MarginDex`'s `execute_limit_order` will always revert due the limit order being cleared in storage ahead of a call to `remove_limit_order`.\n\n## Vulnerability Detail\nThe `execute_limit_order` function includes the following logic...\n\n```vyper\n    self.limit_orders[_uid] = empty(LimitOrder)\n    \n    trade: Trade = self._open_trade(\n        limit_order.account,\n        limit_order.position_token,\n        limit_order.min_position_amount_out,\n        limit_order.debt_token,\n        limit_order.debt_amount,\n        limit_order.margin_amount,\n        limit_order.tp_orders,\n        limit_order.sl_orders\n    )\n\n    self._remove_limit_order(_uid)\n```\n\nThe limit order is being set to `empty(LimitOrder)` in storage. Then a call to `self._remove_limit_order` is called for the same `_uid`.\n\n`_remove_limit_order` has the following logic...\n\n```vyper\n    order: LimitOrder = self.limit_orders[_uid]\n    self.limit_orders[_uid] = empty(LimitOrder)\n\n    uids: DynArray[bytes32, 1024] = self.limit_order_uids[order.account]\n    for i in range(1024):\n        if uids[i] == _uid:\n            uids[i] = uids[len(uids) - 1]\n            uids.pop()\n            break\n        if i == len(uids) - 1: // @audit - Reverts when uids is empty\n            raise\n    self.limit_order_uids[order.account] = uids\n```\n\nThe newly-empty order is read from storage, and it's associated `account` is used fetch the `limit_order_uids`. \n\nThe issue is that this account is the zero address, which is the default value after the order was cleared in the preceding function. This will cause the `uids` array to be empty, and the loop will revert when `i == len(uids) - 1`.\n\n## Impact\nThis means that all calls to `execute_limit_order` will revert, and no limit orders can be executed, which is a major piece of functionality for the protocol.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-unstoppable/blob/main/unstoppable-dex-audit/contracts/margin-dex/MarginDex.vy#L568-L597\n\nhttps://github.com/sherlock-audit/2023-06-unstoppable/blob/main/unstoppable-dex-audit/contracts/margin-dex/MarginDex.vy#L619-L632\n\n## Tool used\n\nManual Review\n\n## Recommendation\n`execute_limit_order` should not clear the limit order in storage before calling `remove_limit_order`. This will allow the `limit_order_uids` to be fetched correctly.\n\n\n\n## Discussion\n\n**Unstoppable-DeFi**\n\nhttps://github.com/Unstoppable-DeFi/unstoppable-dex-audit/pull/15\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/95",
  "Code": [
    {
      "filename": "unstoppable-dex-audit/contracts/margin-dex/MarginDex.vy",
      "content": "# @version ^0.3.7\n\n###################################################################\n#\n# @title Unstoppable Margin DEX - Trading Logic\n# @license GNU AGPLv3\n# @author unstoppable.ooo\n#\n# @custom:security-contact team@unstoppable.ooo\n#\n# @notice\n#    This contract is part of the Unstoppable Margin DEX.\n#\n#    It is the main contract traders interact with in order\n#    to create leveraged 1:1 backed spot trades.\n#    \n#    It allows users to open trades, manage their trades and \n#    use advanced features like Limit Orders, Stop Loss & Take\n#    Profit orders.\n#\n###################################################################\n\nfrom vyper.interfaces import ERC20\n\nPRECISION: constant(uint256) = 10**18\nPERCENTAGE_BASE: constant(uint256) = 10000 # == 100%\n\n\n\n# VAULT\ninterface Vault:\n    def open_position(\n        _account: address, \n        _position_token: address,\n        _min_position_amount_out: uint256,\n        _debt_token: address, \n        _debt_amount: uint256,\n        _margin_amount: uint256\n    ) -> (bytes32, uint256): nonpayable\n    def close_position(_position_uid: bytes32, _min_amount_out: uint256) -> uint256: nonpayable\n    def reduce_position(_position_uid: bytes32, _reduce_by_amount: uint256, _min_amount_out: uint256) -> uint256: nonpayable\n    def liquidate(_position_uid: bytes32): nonpayable\n    def is_enabled_market(_token1: address, _token2: address) -> bool: view\n    def debt(_position_uid: bytes32) -> uint256: view\n    def position_amount(_position_uid: bytes32) -> uint256: view\n    def add_margin(_position_uid: bytes32, _amount: uint256): nonpayable\n    def remove_margin(_position_uid: bytes32, _amount: uint256): nonpayable\n    def effective_leverage(_position_uid: bytes32) -> uint256: view\n    def current_exchange_rate(_position_uid: bytes32) -> uint256: view\n    def is_liquidatable(_position_uid: bytes32) -> bool: view\n    def swap_margin(_account: address, _token_in: address, _token_out: address, _amount_in: uint256, _min_amount_out: uint256) -> uint256: nonpayable\n\nvault: public(address)\n\n\n#################\n#    TRADING\n#################\nstruct TakeProfitOrder:\n    reduce_by_amount: uint256\n    min_amount_out: uint256\n    executed: bool\n\nstruct StopLossOrder:\n    trigger_price: uint256\n    reduce_by_amount: uint256\n    executed: bool\n\nstruct Trade:\n    uid: bytes32\n    account: address\n    vault_position_uid: bytes32\n    tp_orders: DynArray[TakeProfitOrder, 8]\n    sl_orders: DynArray[StopLossOrder, 8]\n\nstruct LimitOrder:\n    uid: bytes32\n    account: address\n    position_token: address\n    min_position_amount_out: uint256\n    debt_token: address\n    margin_amount: uint256\n    debt_amount: uint256\n    valid_until: uint256\n    tp_orders: DynArray[TakeProfitOrder, 8]\n    sl_orders: DynArray[StopLossOrder, 8]\n\n\n# uid -> LimitOrder\nlimit_orders: public(HashMap[bytes32, LimitOrder])\n# account -> LimitOrder\nlimit_order_uids: public(HashMap[address, DynArray[bytes32, 1024]])\n\nuid_nonce: uint256\n# account -> Trade.uid\ntrades_by_account: public(HashMap[address, DynArray[bytes32, 1024]])\n# uid -> Trade\nopen_trades: public(HashMap[bytes32, Trade])\n\n# owner -> delegate accounts\nis_delegate: public(HashMap[address, HashMap[address, bool]])\n\nadmin: public(address)\nsuggested_admin: public(address)\n\nis_accepting_new_orders: public(bool)\n\n\n@external\ndef __init__():\n    self.admin = msg.sender\n\n\n#####################################\n#\n#              TRADING\n#\n#####################################\n\n\nevent TradeOpened:\n    account: indexed(address)\n    uid: bytes32\n    trade: Trade\n\n@nonpayable\n@external\ndef open_trade(\n    _account: address,\n    _position_token: address,\n    _min_position_amount_out: uint256,\n    _debt_token: address,\n    _debt_amount: uint256,\n    _margin_amount: uint256,\n    _tp_orders: DynArray[TakeProfitOrder, 8],\n    _sl_orders: DynArray[StopLossOrder, 8],\n) -> Trade:\n    assert (_account == msg.sender) or self.is_delegate[_account][msg.sender], \"unauthorized\"\n\n    return self._open_trade(\n        _account,\n        _position_token,\n        _min_position_amount_out,\n        _debt_token,\n        _debt_amount,\n        _margin_amount,\n        _tp_orders,\n        _sl_orders,\n    )\n\n\n@internal\ndef _open_trade(\n    _account: address,\n    _position_token: address,\n    _min_position_amount_out: uint256,\n    _debt_token: address,\n    _debt_amount: uint256,\n    _margin_amount: uint256,\n    _tp_orders: DynArray[TakeProfitOrder, 8],\n    _sl_orders: DynArray[StopLossOrder, 8],\n) -> Trade:\n    \"\"\"\n    @notice\n        Creates a new Trade for user by opening a\n        leveraged spot position in the Vault.\n\n        Requires the user to have a positive margin\n        balance in the Vault.\n        Requires liquidity to be available in the Vault.\n\n        All trades and their underlying positions are\n        fully isolated.\n    \"\"\"\n    buy_amount: uint256 = _debt_amount + _margin_amount\n\n    position_uid: bytes32 = empty(bytes32)\n    amount_bought: uint256 = 0\n    (position_uid, amount_bought) = Vault(self.vault).open_position(\n        _account,\n        _position_token,\n        _min_position_amount_out,\n        _debt_token,\n        _debt_amount,\n        _margin_amount,\n    )\n\n    trade: Trade = Trade(\n        {\n            uid: position_uid,\n            account: _account,\n            vault_position_uid: position_uid,\n            tp_orders: _tp_orders,\n            sl_orders: _sl_orders,\n        }\n    )\n\n    self.open_trades[position_uid] = trade\n    self.trades_by_account[_account].append(position_uid)\n\n    log TradeOpened(_account, position_uid, trade)\n    return trade\n\n\n@external\ndef close_trade(_trade_uid: bytes32, _min_amount_out: uint256) -> uint256:\n    trade: Trade = self.open_trades[_trade_uid]\n    assert (trade.account == msg.sender) or self.is_delegate[trade.account][msg.sender], \"unauthorized\"\n\n    return self._full_close(trade, _min_amount_out)\n\nevent TradeClosed:\n    account: indexed(address)\n    uid: bytes32\n    trade: Trade\n    amount_received: uint256\n\n\n@nonreentrant(\"lock\")\n@internal\ndef _full_close(_trade: Trade, _min_amount_out: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Completely closes the underlying Vault Position, repays all debt\n        and accrued interest and credits/debits the users Vault margin \n        with the remaining pnl.\n    \"\"\"\n    amount_out_received: uint256 = Vault(self.vault).close_position(\n        _trade.vault_position_uid, _min_amount_out\n    )\n\n    # cleanup trade\n    self.open_trades[_trade.uid] = empty(Trade)\n    uids: DynArray[bytes32, 1024] = self.trades_by_account[_trade.account]\n    for i in range(1024):\n        if uids[i] == _trade.uid:\n            uids[i] = uids[len(uids) - 1]\n            uids.pop()\n            break\n        if i == len(uids) - 1:\n            raise\n    self.trades_by_account[_trade.account] = uids\n\n    log TradeClosed(_trade.account, _trade.uid, _trade, amount_out_received)\n    return amount_out_received\n\n\nevent TradeReduced:\n    account: indexed(address)\n    uid: bytes32\n    trade: Trade\n    amount_received: uint256\n\n\n@external\ndef partial_close_trade(\n    _trade_uid: bytes32, _reduce_by_amount: uint256, _min_amount_out: uint256\n):\n    trade: Trade = self.open_trades[_trade_uid]\n    assert (trade.account == msg.sender) or self.is_delegate[trade.account][msg.sender], \"unauthorized\"\n    self._partial_close(trade, _reduce_by_amount, _min_amount_out)\n\n\n@internal\ndef _partial_close(\n    _trade: Trade, _reduce_by_amount: uint256, _min_amount_out: uint256\n) -> uint256:\n    \"\"\"\n    @notice\n        Partially closes the Trade by selling some of the underlying\n        asset to repay some of the debt and reclaim some of the margin.\n    \"\"\"\n    amount_out_received: uint256 = Vault(self.vault).reduce_position(\n        _trade.vault_position_uid, _reduce_by_amount, _min_amount_out\n    )\n\n    log TradeReduced(_trade.account, _trade.uid, _trade, amount_out_received)\n    return amount_out_received\n\n\n@view\n@external\ndef get_all_open_trades(_account: address) -> DynArray[Trade, 1024]:\n    uids: DynArray[bytes32, 1024] = self.trades_by_account[_account]\n    trades: DynArray[Trade, 1024] = empty(DynArray[Trade, 1024])\n\n    for uid in uids:\n        trades.append(self.open_trades[uid])\n\n    return trades\n\n\n@external\ndef swap_margin(\n    _account: address,\n    _token_in: address,\n    _token_out: address,\n    _amount_in: uint256,\n    _min_amount_out: uint256,\n) -> uint256:\n    \"\"\"\n    @notice\n        Allows a user to easily swap between his margin balances.\n    \"\"\"\n    assert (_account == msg.sender) or self.is_delegate[_account][msg.sender], \"unauthorized\"\n\n    return Vault(self.vault).swap_margin(\n        _account, _token_in, _token_out, _amount_in, _min_amount_out\n    )\n\n\n#####################################\n#\n#    CONDITIONAL ORDERS - TP/SL\n#\n#####################################\n\n\nevent TpOrderAdded:\n    trade_uid: bytes32\n    order: TakeProfitOrder\n\n\nevent SlOrderAdded:\n    trade_uid: bytes32\n    order: StopLossOrder\n\n\n@external\ndef add_tp_order(_trade_uid: bytes32, _tp_order: TakeProfitOrder):\n    \"\"\"\n    @notice\n        Adds a new TakeProfit order to an already open trade.\n    \"\"\"\n    trade: Trade = self.open_trades[_trade_uid]\n    assert (trade.account == msg.sender) or self.is_delegate[trade.account][msg.sender], \"unauthorized\"\n    assert self.is_accepting_new_orders, \"paused\"\n\n    assert _tp_order.reduce_by_amount > 0, \"amount must be set\"\n\n    tp_order: TakeProfitOrder = _tp_order\n    tp_order.executed = False\n    trade.tp_orders.append(tp_order)\n\n    self.open_trades[_trade_uid] = trade\n\n    log TpOrderAdded(_trade_uid, tp_order)\n\n\n@external\ndef add_sl_order(_trade_uid: bytes32, _sl_order: StopLossOrder):\n    \"\"\"\n    @notice\n        Adds a new StopLoss order to an already open trade.\n    \"\"\"\n    trade: Trade = self.open_trades[_trade_uid]\n    assert (trade.account == msg.sender) or self.is_delegate[trade.account][msg.sender], \"unauthorized\"\n    assert self.is_accepting_new_orders, \"paused\"\n\n    assert _sl_order.reduce_by_amount > 0, \"amount must be set\"\n\n    sl_order: StopLossOrder = _sl_order\n    sl_order.executed = False\n    trade.sl_orders.append(sl_order)\n\n    self.open_trades[_trade_uid] = trade\n\n    log SlOrderAdded(_trade_uid, sl_order)\n\n\nevent TpExecuted:\n    trade_uid: bytes32\n    reduce_by_amount: uint256\n    amount_out_received: uint256\n\n\n@external\ndef execute_tp_order(_trade_uid: bytes32, _tp_order_index: uint8):\n    \"\"\"\n    @notice\n        Allows a TakeProfit order to be executed.\n        Any msg.sender may execute conditional orders for all accounts.\n        The specified min_amount_out ensures TakeProfit orders\n        are only executed when intended.\n    \"\"\"\n    trade: Trade = self.open_trades[_trade_uid]\n\n    tp_order: TakeProfitOrder = trade.tp_orders[_tp_order_index]\n\n    assert tp_order.executed == False, \"order already executed\"\n\n    tp_order.executed = True\n    trade.tp_orders[_tp_order_index] = tp_order\n    self.open_trades[_trade_uid] = trade\n\n    position_amount: uint256 = Vault(self.vault).position_amount(\n        trade.vault_position_uid\n    )\n    amount_out_received: uint256 = 0\n    if tp_order.reduce_by_amount == position_amount:\n        amount_out_received = self._full_close(trade, tp_order.min_amount_out)\n    else:\n        amount_out_received = self._partial_close(\n            trade, tp_order.reduce_by_amount, tp_order.min_amount_out\n        )\n\n    log TpExecuted(_trade_uid, tp_order.reduce_by_amount, amount_out_received)\n\n\nevent SlExecuted:\n    trade_uid: bytes32\n    reduce_by_amount: uint256\n    amount_out_received: uint256\n\n\n@external\ndef execute_sl_order(_trade_uid: bytes32, _sl_order_index: uint8):\n    \"\"\"\n    @notice\n        Allows a StopLoss order to be executed.\n        Any msg.sender may execute conditional orders for all accounts.\n        The specified trigger_price and Chainlink based current_exchange_rate \n        ensures orders are only executed when intended.\n    \"\"\"\n    trade: Trade = self.open_trades[_trade_uid]\n\n    sl_order: StopLossOrder = trade.sl_orders[_sl_order_index]\n\n    current_exchange_rate: uint256 = Vault(self.vault).current_exchange_rate(\n        trade.vault_position_uid\n    )\n    assert sl_order.trigger_price >= current_exchange_rate, \"trigger price not reached\"\n    assert sl_order.executed == False, \"order already executed\"\n\n    sl_order.executed = True\n    trade.sl_orders[_sl_order_index] = sl_order\n    self.open_trades[_trade_uid] = trade\n\n    position_amount: uint256 = Vault(self.vault).position_amount(\n        trade.vault_position_uid\n    )\n\n    amount_out_received: uint256 = 0\n    if sl_order.reduce_by_amount >= position_amount:\n        amount_out_received = self._full_close(trade, 0)\n    else:\n        amount_out_received = self._partial_close(trade, sl_order.reduce_by_amount, 0)\n\n    log SlExecuted(_trade_uid, sl_order.reduce_by_amount, amount_out_received)\n\n\nevent TpRemoved:\n    trade: Trade\n\n\n@external\ndef cancel_tp_order(_trade_uid: bytes32, _tp_order_index: uint8):\n    \"\"\"\n    @notice\n        Removes a pending TakeProfit order.\n    \"\"\"\n    trade: Trade = self.open_trades[_trade_uid]\n    assert (trade.account == msg.sender) or self.is_delegate[trade.account][msg.sender], \"unauthorized\"\n\n    if len(trade.tp_orders) > 1:\n        trade.tp_orders[_tp_order_index] = trade.tp_orders[len(trade.tp_orders) - 1]\n\n    trade.tp_orders.pop()\n    self.open_trades[_trade_uid] = trade\n\n    log TpRemoved(trade)\n\n\nevent SlRemoved:\n    trade: Trade\n\n\n@external\ndef cancel_sl_order(_trade_uid: bytes32, _sl_order_index: uint8):\n    \"\"\"\n    @notice\n        Removes a pending StopLoss order.\n    \"\"\"\n    trade: Trade = self.open_trades[_trade_uid]\n    assert (trade.account == msg.sender) or self.is_delegate[trade.account][msg.sender], \"unauthorized\"\n\n    if len(trade.sl_orders) > 1:\n        trade.sl_orders[_sl_order_index] = trade.sl_orders[len(trade.sl_orders) - 1]\n\n    trade.sl_orders.pop()\n    self.open_trades[_trade_uid] = trade\n\n    log SlRemoved(trade)\n\n\n#####################################\n#\n#           LIMIT ORDERS\n#\n#####################################\n\n\nevent LimitOrderPosted:\n    uid: bytes32\n    account: indexed(address)\n    token_in: indexed(address)\n    token_out: indexed(address)\n    amount_in: uint256\n    min_amount_out: uint256\n    valid_until: uint256\n\n\n@external\ndef post_limit_order(\n    _account: address,\n    _position_token: address,\n    _debt_token: address,\n    _margin_amount: uint256,\n    _debt_amount: uint256,\n    _min_amount_out: uint256,\n    _valid_until: uint256,\n    _tp_orders: DynArray[TakeProfitOrder, 8],\n    _sl_orders: DynArray[StopLossOrder, 8],\n) -> LimitOrder:\n    \"\"\"\n    @notice\n        Allows users to post a LimitOrder that can open a Trade\n        under specified conditions.\n    \"\"\"\n    assert self.is_accepting_new_orders, \"not accepting new orders\"\n    assert (_account == msg.sender) or self.is_delegate[_account][msg.sender], \"unauthorized\"\n\n    assert Vault(self.vault).is_enabled_market(_debt_token, _position_token)\n    assert _margin_amount > 0, \"invalid margin amount\"\n    assert _debt_amount > _margin_amount, \"invalid debt amount\"\n\n    uid: bytes32 = self._generate_uid()\n\n    limit_order: LimitOrder = LimitOrder(\n        {\n            uid: uid,\n            account: _account,\n            position_token: _position_token,\n            min_position_amount_out: _min_amount_out,\n            debt_token: _debt_token,\n            margin_amount: _margin_amount,\n            debt_amount: _debt_amount,\n            valid_until: _valid_until,\n            tp_orders: _tp_orders,\n            sl_orders: _sl_orders,\n        }\n    )\n\n    self.limit_orders[uid] = limit_order\n    self.limit_order_uids[_account].append(uid)\n\n    amount_in: uint256 = _margin_amount + _debt_amount\n    log LimitOrderPosted(uid, _account, _debt_token, _position_token, amount_in, _min_amount_out, _valid_until)\n\n    return limit_order\n\n\nevent LimitOrderExecuted:\n    account: indexed(address)\n    trade: Trade\n\n\n@external\ndef execute_limit_order(_uid: bytes32):\n    \"\"\"\n    @notice\n        Allows executing a pending LimitOrder.\n        Any msg.sender may execute LimitOrders for all accounts.\n        The specified min_amount_out ensures the Trade is only\n        opened at the intended exchange rate / price.\n    \"\"\"\n    assert self.is_accepting_new_orders, \"not accepting new orders\"\n \n    limit_order: LimitOrder = self.limit_orders[_uid]\n    assert limit_order.valid_until >= block.timestamp, \"expired\"\n\n    self.limit_orders[_uid] = empty(LimitOrder)\n    \n    trade: Trade = self._open_trade(\n        limit_order.account,\n        limit_order.position_token,\n        limit_order.min_position_amount_out,\n        limit_order.debt_token,\n        limit_order.debt_amount,\n        limit_order.margin_amount,\n        limit_order.tp_orders,\n        limit_order.sl_orders\n    )\n\n    self._remove_limit_order(_uid)\n\n    log LimitOrderExecuted(trade.account, trade)\n\n\nevent LimitOrderCancelled:\n    account: indexed(address)\n    uid: bytes32\n\n\n@external\ndef cancel_limit_order(_uid: bytes32):\n    \"\"\"\n    @notice\n        Removes a pending LimitOrder.\n    \"\"\"\n    order: LimitOrder = self.limit_orders[_uid]\n    assert (order.account == msg.sender) or self.is_delegate[order.account][msg.sender], \"unauthorized\"\n\n    self._remove_limit_order(_uid)\n\n    log LimitOrderCancelled(order.account, _uid)\n\n\n@internal\ndef _remove_limit_order(_uid: bytes32):\n    order: LimitOrder = self.limit_orders[_uid]\n    self.limit_orders[_uid] = empty(LimitOrder)\n\n    uids: DynArray[bytes32, 1024] = self.limit_order_uids[order.account]\n    for i in range(1024):\n        if uids[i] == _uid:\n            uids[i] = uids[len(uids) - 1]\n            uids.pop()\n            break\n        if i == len(uids) - 1:\n            raise\n    self.limit_order_uids[order.account] = uids\n\n\n#####################################\n#\n#           LIQUIDATIONS\n#\n#####################################\n\n@view\n@external\ndef is_liquidatable(_trade_uid: bytes32) -> bool:\n    \"\"\"\n    @notice\n        Trades are leveraged and based on an undercollateralized\n        loan in the Vault Position.\n        If the Trades effective leverage exceeds the maximum allowed\n        leverage for that market, the Trade and its underlying Vault\n        Position become liquidatable.\n    \"\"\"\n    return self._is_liquidatable(_trade_uid)\n\n@view\n@internal\ndef _is_liquidatable(_trade_uid: bytes32) -> bool:\n    trade: Trade = self.open_trades[_trade_uid]\n    return Vault(self.vault).is_liquidatable(trade.vault_position_uid)\n\n\nevent Liquidation:\n    account: indexed(address)\n    uid: bytes32\n    trade: Trade\n\n\n@nonreentrant(\"lock\")\n@external\ndef liquidate(_trade_uid: bytes32):\n    \"\"\"\n    @notice\n        Allows to liquidate a Trade that exceeds the maximum\n        allowed leverage.\n    \"\"\"\n    trade: Trade = self.open_trades[_trade_uid]\n    Vault(self.vault).liquidate(trade.vault_position_uid)\n    log Liquidation(trade.account, _trade_uid, trade)\n\n\n#####################################\n#\n#     LEVERAGE & TRADE HEALTH\n#\n#####################################\n\n@view\n@external\ndef effective_leverage(_trade_uid: bytes32) -> uint256:\n    return self._effective_leverage(_trade_uid)\n\n@view\n@internal\ndef _effective_leverage(_trade_uid: bytes32) -> uint256:\n    trade: Trade = self.open_trades[_trade_uid]\n    return Vault(self.vault).effective_leverage(trade.vault_position_uid)\n\n@external\ndef add_margin(_trade_uid: bytes32, _amount: uint256):\n    \"\"\"\n    @notice\n        Allows traders to add additional margin to a Trades underlying\n        Vault position and reduce the leverage.\n    \"\"\"\n    trade: Trade = self.open_trades[_trade_uid]\n    assert (trade.account == msg.sender) or self.is_delegate[trade.account][msg.sender], \"unauthorized\"\n\n    Vault(self.vault).add_margin(trade.vault_position_uid, _amount)\n\n\n@external\ndef remove_margin(_trade_uid: bytes32, _amount: uint256):\n    \"\"\"\n    @notice\n        Allows traders to remove excess margin from a Trades underlying\n        Vault position and increase leverage.\n    \"\"\"\n    trade: Trade = self.open_trades[_trade_uid]\n    assert (trade.account == msg.sender) or self.is_delegate[trade.account][msg.sender], \"unauthorized\"\n\n    Vault(self.vault).remove_margin(trade.vault_position_uid, _amount)\n\n\n#####################################\n#\n#    ACCOUNT ACCESS & DELEGATION \n#\n#\n#    @notice\n#        Delegates are additional accounts that are allowed\n#        to perform trading actions on behalf of a main account.\n#        They can open/manage/close trades for another account.\n#\n#        This allows for example to have a main account protected\n#        with a hardware wallet and use a hot wallet for daily trading.\n#\n#####################################\n\nevent DelegateAdded:\n    account: indexed(address)\n    delegate_account: indexed(address)\n\n\n@nonpayable\n@external\ndef add_delegate(_delegate: address):\n    \"\"\"\n    @notice\n        Allows _delegate to perform any trading actions\n        on behalf of msg.sender.\n    \"\"\"\n    self.is_delegate[msg.sender][_delegate] = True\n    log DelegateAdded(msg.sender, _delegate)\n\n\nevent DelegateRemoved:\n    account: indexed(address)\n    delegate_account: indexed(address)\n\n@nonpayable\n@external\ndef remove_delegate(_delegate: address):\n    \"\"\"\n    @notice\n        Removes a _delegates permission to execute\n        trading actions on behalf of msg.sender.\n    \"\"\"\n    self.is_delegate[msg.sender][_delegate] = False\n    log DelegateRemoved(msg.sender, _delegate)\n    \n\n#####################################\n#\n#               UTIL \n#\n#####################################\n\n@internal\ndef _generate_uid() -> bytes32:\n    uid: bytes32 = keccak256(_abi_encode(chain.id, self.uid_nonce, block.timestamp))\n    self.uid_nonce += 1\n    return uid\n\n\n#####################################\n#\n#              ADMIN \n#\n#####################################\n\nevent NewAdminSuggested:\n    new_admin: indexed(address)\n    suggested_by: indexed(address)\n\n@external\ndef suggest_admin(_new_admin: address):\n    \"\"\"\n    @notice\n        Step 1 of the 2 step process to transfer adminship.\n        Current admin suggests a new admin.\n        Requires the new admin to accept adminship in step 2.\n    @param _new_admin\n        The address of the new admin.\n    \"\"\"\n    assert msg.sender == self.admin, \"unauthorized\"\n    assert _new_admin != empty(address), \"cannot set admin to zero address\"\n    self.suggested_admin = _new_admin\n    log NewAdminSuggested(_new_admin, msg.sender)\n\n\nevent AdminTransferred:\n    new_admin: indexed(address)\n    promoted_by: indexed(address)\n\n@external\ndef accept_admin():\n    \"\"\"\n    @notice\n        Step 2 of the 2 step process to transfer admin.\n        The suggested admin accepts the transfer and becomes the\n        new admin.\n    \"\"\"\n    assert msg.sender == self.suggested_admin, \"unauthorized\"\n    prev_admin: address = self.admin\n    self.admin = self.suggested_admin\n    log AdminTransferred(self.admin, prev_admin)\n\n\n@external\ndef set_is_accepting_new_orders(_is_accepting_new_orders: bool):\n    \"\"\"\n    @notice\n        Allows admin to put protocol in defensive or winddown mode.\n        Open trades can still be completed but no new trades are accepted.\n    \"\"\"\n    assert msg.sender == self.admin, \"unauthorized\"\n    self.is_accepting_new_orders = _is_accepting_new_orders\n\n\n@external\ndef set_vault(_vault: address):\n    \"\"\"\n    @notice\n        Sets the corresponding Vault where the assets are located.\n    \"\"\"\n    assert msg.sender == self.admin, \"unauthorized\"\n    self.vault = _vault"
    },
    {
      "filename": "unstoppable-dex-audit/contracts/margin-dex/MarginDex.vy",
      "content": "# @version ^0.3.7\n\n###################################################################\n#\n# @title Unstoppable Margin DEX - Trading Logic\n# @license GNU AGPLv3\n# @author unstoppable.ooo\n#\n# @custom:security-contact team@unstoppable.ooo\n#\n# @notice\n#    This contract is part of the Unstoppable Margin DEX.\n#\n#    It is the main contract traders interact with in order\n#    to create leveraged 1:1 backed spot trades.\n#    \n#    It allows users to open trades, manage their trades and \n#    use advanced features like Limit Orders, Stop Loss & Take\n#    Profit orders.\n#\n###################################################################\n\nfrom vyper.interfaces import ERC20\n\nPRECISION: constant(uint256) = 10**18\nPERCENTAGE_BASE: constant(uint256) = 10000 # == 100%\n\n\n\n# VAULT\ninterface Vault:\n    def open_position(\n        _account: address, \n        _position_token: address,\n        _min_position_amount_out: uint256,\n        _debt_token: address, \n        _debt_amount: uint256,\n        _margin_amount: uint256\n    ) -> (bytes32, uint256): nonpayable\n    def close_position(_position_uid: bytes32, _min_amount_out: uint256) -> uint256: nonpayable\n    def reduce_position(_position_uid: bytes32, _reduce_by_amount: uint256, _min_amount_out: uint256) -> uint256: nonpayable\n    def liquidate(_position_uid: bytes32): nonpayable\n    def is_enabled_market(_token1: address, _token2: address) -> bool: view\n    def debt(_position_uid: bytes32) -> uint256: view\n    def position_amount(_position_uid: bytes32) -> uint256: view\n    def add_margin(_position_uid: bytes32, _amount: uint256): nonpayable\n    def remove_margin(_position_uid: bytes32, _amount: uint256): nonpayable\n    def effective_leverage(_position_uid: bytes32) -> uint256: view\n    def current_exchange_rate(_position_uid: bytes32) -> uint256: view\n    def is_liquidatable(_position_uid: bytes32) -> bool: view\n    def swap_margin(_account: address, _token_in: address, _token_out: address, _amount_in: uint256, _min_amount_out: uint256) -> uint256: nonpayable\n\nvault: public(address)\n\n\n#################\n#    TRADING\n#################\nstruct TakeProfitOrder:\n    reduce_by_amount: uint256\n    min_amount_out: uint256\n    executed: bool\n\nstruct StopLossOrder:\n    trigger_price: uint256\n    reduce_by_amount: uint256\n    executed: bool\n\nstruct Trade:\n    uid: bytes32\n    account: address\n    vault_position_uid: bytes32\n    tp_orders: DynArray[TakeProfitOrder, 8]\n    sl_orders: DynArray[StopLossOrder, 8]\n\nstruct LimitOrder:\n    uid: bytes32\n    account: address\n    position_token: address\n    min_position_amount_out: uint256\n    debt_token: address\n    margin_amount: uint256\n    debt_amount: uint256\n    valid_until: uint256\n    tp_orders: DynArray[TakeProfitOrder, 8]\n    sl_orders: DynArray[StopLossOrder, 8]\n\n\n# uid -> LimitOrder\nlimit_orders: public(HashMap[bytes32, LimitOrder])\n# account -> LimitOrder\nlimit_order_uids: public(HashMap[address, DynArray[bytes32, 1024]])\n\nuid_nonce: uint256\n# account -> Trade.uid\ntrades_by_account: public(HashMap[address, DynArray[bytes32, 1024]])\n# uid -> Trade\nopen_trades: public(HashMap[bytes32, Trade])\n\n# owner -> delegate accounts\nis_delegate: public(HashMap[address, HashMap[address, bool]])\n\nadmin: public(address)\nsuggested_admin: public(address)\n\nis_accepting_new_orders: public(bool)\n\n\n@external\ndef __init__():\n    self.admin = msg.sender\n\n\n#####################################\n#\n#              TRADING\n#\n#####################################\n\n\nevent TradeOpened:\n    account: indexed(address)\n    uid: bytes32\n    trade: Trade\n\n@nonpayable\n@external\ndef open_trade(\n    _account: address,\n    _position_token: address,\n    _min_position_amount_out: uint256,\n    _debt_token: address,\n    _debt_amount: uint256,\n    _margin_amount: uint256,\n    _tp_orders: DynArray[TakeProfitOrder, 8],\n    _sl_orders: DynArray[StopLossOrder, 8],\n) -> Trade:\n    assert (_account == msg.sender) or self.is_delegate[_account][msg.sender], \"unauthorized\"\n\n    return self._open_trade(\n        _account,\n        _position_token,\n        _min_position_amount_out,\n        _debt_token,\n        _debt_amount,\n        _margin_amount,\n        _tp_orders,\n        _sl_orders,\n    )\n\n\n@internal\ndef _open_trade(\n    _account: address,\n    _position_token: address,\n    _min_position_amount_out: uint256,\n    _debt_token: address,\n    _debt_amount: uint256,\n    _margin_amount: uint256,\n    _tp_orders: DynArray[TakeProfitOrder, 8],\n    _sl_orders: DynArray[StopLossOrder, 8],\n) -> Trade:\n    \"\"\"\n    @notice\n        Creates a new Trade for user by opening a\n        leveraged spot position in the Vault.\n\n        Requires the user to have a positive margin\n        balance in the Vault.\n        Requires liquidity to be available in the Vault.\n\n        All trades and their underlying positions are\n        fully isolated.\n    \"\"\"\n    buy_amount: uint256 = _debt_amount + _margin_amount\n\n    position_uid: bytes32 = empty(bytes32)\n    amount_bought: uint256 = 0\n    (position_uid, amount_bought) = Vault(self.vault).open_position(\n        _account,\n        _position_token,\n        _min_position_amount_out,\n        _debt_token,\n        _debt_amount,\n        _margin_amount,\n    )\n\n    trade: Trade = Trade(\n        {\n            uid: position_uid,\n            account: _account,\n            vault_position_uid: position_uid,\n            tp_orders: _tp_orders,\n            sl_orders: _sl_orders,\n        }\n    )\n\n    self.open_trades[position_uid] = trade\n    self.trades_by_account[_account].append(position_uid)\n\n    log TradeOpened(_account, position_uid, trade)\n    return trade\n\n\n@external\ndef close_trade(_trade_uid: bytes32, _min_amount_out: uint256) -> uint256:\n    trade: Trade = self.open_trades[_trade_uid]\n    assert (trade.account == msg.sender) or self.is_delegate[trade.account][msg.sender], \"unauthorized\"\n\n    return self._full_close(trade, _min_amount_out)\n\nevent TradeClosed:\n    account: indexed(address)\n    uid: bytes32\n    trade: Trade\n    amount_received: uint256\n\n\n@nonreentrant(\"lock\")\n@internal\ndef _full_close(_trade: Trade, _min_amount_out: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Completely closes the underlying Vault Position, repays all debt\n        and accrued interest and credits/debits the users Vault margin \n        with the remaining pnl.\n    \"\"\"\n    amount_out_received: uint256 = Vault(self.vault).close_position(\n        _trade.vault_position_uid, _min_amount_out\n    )\n\n    # cleanup trade\n    self.open_trades[_trade.uid] = empty(Trade)\n    uids: DynArray[bytes32, 1024] = self.trades_by_account[_trade.account]\n    for i in range(1024):\n        if uids[i] == _trade.uid:\n            uids[i] = uids[len(uids) - 1]\n            uids.pop()\n            break\n        if i == len(uids) - 1:\n            raise\n    self.trades_by_account[_trade.account] = uids\n\n    log TradeClosed(_trade.account, _trade.uid, _trade, amount_out_received)\n    return amount_out_received\n\n\nevent TradeReduced:\n    account: indexed(address)\n    uid: bytes32\n    trade: Trade\n    amount_received: uint256\n\n\n@external\ndef partial_close_trade(\n    _trade_uid: bytes32, _reduce_by_amount: uint256, _min_amount_out: uint256\n):\n    trade: Trade = self.open_trades[_trade_uid]\n    assert (trade.account == msg.sender) or self.is_delegate[trade.account][msg.sender], \"unauthorized\"\n    self._partial_close(trade, _reduce_by_amount, _min_amount_out)\n\n\n@internal\ndef _partial_close(\n    _trade: Trade, _reduce_by_amount: uint256, _min_amount_out: uint256\n) -> uint256:\n    \"\"\"\n    @notice\n        Partially closes the Trade by selling some of the underlying\n        asset to repay some of the debt and reclaim some of the margin.\n    \"\"\"\n    amount_out_received: uint256 = Vault(self.vault).reduce_position(\n        _trade.vault_position_uid, _reduce_by_amount, _min_amount_out\n    )\n\n    log TradeReduced(_trade.account, _trade.uid, _trade, amount_out_received)\n    return amount_out_received\n\n\n@view\n@external\ndef get_all_open_trades(_account: address) -> DynArray[Trade, 1024]:\n    uids: DynArray[bytes32, 1024] = self.trades_by_account[_account]\n    trades: DynArray[Trade, 1024] = empty(DynArray[Trade, 1024])\n\n    for uid in uids:\n        trades.append(self.open_trades[uid])\n\n    return trades\n\n\n@external\ndef swap_margin(\n    _account: address,\n    _token_in: address,\n    _token_out: address,\n    _amount_in: uint256,\n    _min_amount_out: uint256,\n) -> uint256:\n    \"\"\"\n    @notice\n        Allows a user to easily swap between his margin balances.\n    \"\"\"\n    assert (_account == msg.sender) or self.is_delegate[_account][msg.sender], \"unauthorized\"\n\n    return Vault(self.vault).swap_margin(\n        _account, _token_in, _token_out, _amount_in, _min_amount_out\n    )\n\n\n#####################################\n#\n#    CONDITIONAL ORDERS - TP/SL\n#\n#####################################\n\n\nevent TpOrderAdded:\n    trade_uid: bytes32\n    order: TakeProfitOrder\n\n\nevent SlOrderAdded:\n    trade_uid: bytes32\n    order: StopLossOrder\n\n\n@external\ndef add_tp_order(_trade_uid: bytes32, _tp_order: TakeProfitOrder):\n    \"\"\"\n    @notice\n        Adds a new TakeProfit order to an already open trade.\n    \"\"\"\n    trade: Trade = self.open_trades[_trade_uid]\n    as"
    }
  ]
}