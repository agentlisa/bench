{
  "Title": "[M-30] `Heart::beat()` could be called several times in one block if no one called it for a some time",
  "Content": "_Submitted by rvierdiiev, also found by datapunk, devtooligan, itsmeSTYJ, Jeiwan, Lambda, Trust, and zzzitron_\n\n`beat()` function is allowed to be called by anyone once in `frequency()` period. The purpose of it is to update the prices and do another operations related to bond market. User who ran it are rewarded. There is no need to run this function more then 1 time in `frequency()` period.\nHowever if `beat()` was last time called more then `frequency()` time ago then user can execute `beat()` function `(block.timestamp - lastBeat)/frequency()` times in a row in same block and get rewards.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L92><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103>\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103><br>\nChange this line to `lastBeat = block.timestamp - (block.timestamp - lastBeat) % frequency();`<br>\nSo no matter how much time the `beat()` was not called, it is possible to call it only once per `frequency()`.\n\n**[Oighty (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/79#issuecomment-1239882530):**\n > See comment on [#405](https://github.com/code-423n4/2022-08-olympus-findings/issues/405#issuecomment-1239878294). This approach actually solves both of our issues though.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/79#issuecomment-1251018524):**\n > Going to use this issue as the primary since the solution is elegant and solves the problem. \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/policies/Heart.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IHeart} from \"policies/interfaces/IHeart.sol\";\nimport {IOperator} from \"policies/interfaces/IOperator.sol\";\n\nimport {OlympusPrice} from \"modules/PRICE.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// @title  Olympus Heart\n/// @notice Olympus Heart (Policy) Contract\n/// @dev    The Olympus Heart contract provides keeper rewards to call the heart beat function which fuels\n///         Olympus market operations. The Heart orchestrates state updates in the correct order to ensure\n///         market operations use up to date information.\ncontract OlympusHeart is IHeart, Policy, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    error Heart_OutOfCycle();\n    error Heart_BeatStopped();\n    error Heart_InvalidParams();\n\n    event Beat(uint256 timestamp_);\n    event RewardIssued(address to_, uint256 rewardAmount_);\n    event RewardUpdated(ERC20 token_, uint256 rewardAmount_);\n\n    /// @notice Status of the Heart, false = stopped, true = beating\n    bool public active;\n\n    /// @notice Timestamp of the last beat (UTC, in seconds)\n    uint256 public lastBeat;\n\n    /// @notice Reward for beating the Heart (in reward token decimals)\n    uint256 public reward;\n\n    /// @notice Reward token address that users are sent for beating the Heart\n    ERC20 public rewardToken;\n\n    // Modules\n    OlympusPrice internal PRICE;\n\n    // Policies\n    IOperator internal _operator;\n\n    /*//////////////////////////////////////////////////////////////\n                            POLICY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        IOperator operator_,\n        ERC20 rewardToken_,\n        uint256 reward_\n    ) Policy(kernel_) {\n        _operator = operator_;\n\n        active = true;\n        lastBeat = block.timestamp;\n        rewardToken = rewardToken_;\n        reward = reward_;\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](1);\n        dependencies[0] = toKeycode(\"PRICE\");\n\n        PRICE = OlympusPrice(getModuleAddress(dependencies[0]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        permissions = new Permissions[](1);\n        permissions[0] = Permissions(PRICE.KEYCODE(), PRICE.updateMovingAverage.selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function beat() external nonReentrant {\n        if (!active) revert Heart_BeatStopped();\n        if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle();\n\n        // Update the moving average on the Price module\n        PRICE.updateMovingAverage();\n\n        // Trigger price range update and market operations\n        _operator.operate();\n\n        // Update the last beat timestamp\n        lastBeat += frequency();\n\n        // Issue reward to sender\n        _issueReward(msg.sender);\n\n        emit Beat(block.timestamp);\n    }\n\n    function _issueReward(address to_) internal {\n        rewardToken.safeTransfer(to_, reward);\n        emit RewardIssued(to_, reward);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function frequency() public view returns (uint256) {\n        return uint256(PRICE.observationFrequency());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function resetBeat() external onlyRole(\"heart_admin\") {\n        lastBeat = block.timestamp - frequency();\n    }\n\n    /// @inheritdoc IHeart\n    function toggleBeat() external onlyRole(\"heart_admin\") {\n        active = !active;\n    }\n\n    /// @inheritdoc IHeart\n    function setRewardTokenAndAmount(ERC20 token_, uint256 reward_)\n        external\n        onlyRole(\"heart_admin\")\n    {\n        rewardToken = token_;\n        reward = reward_;\n        emit RewardUpdated(token_, reward_);\n    }\n\n    /// @inheritdoc IHeart\n    function withdrawUnspentRewards(ERC20 token_) external onlyRole(\"heart_admin\") {\n        token_.safeTransfer(msg.sender, token_.balanceOf(address(this)));\n    }\n}"
    },
    {
      "filename": "src/policies/Heart.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IHeart} from \"policies/interfaces/IHeart.sol\";\nimport {IOperator} from \"policies/interfaces/IOperator.sol\";\n\nimport {OlympusPrice} from \"modules/PRICE.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// @title  Olympus Heart\n/// @notice Olympus Heart (Policy) Contract\n/// @dev    The Olympus Heart contract provides keeper rewards to call the heart beat function which fuels\n///         Olympus market operations. The Heart orchestrates state updates in the correct order to ensure\n///         market operations use up to date information.\ncontract OlympusHeart is IHeart, Policy, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    error Heart_OutOfCycle();\n    error Heart_BeatStopped();\n    error Heart_InvalidParams();\n\n    event Beat(uint256 timestamp_);\n    event RewardIssued(address to_, uint256 rewardAmount_);\n    event RewardUpdated(ERC20 token_, uint256 rewardAmount_);\n\n    /// @notice Status of the Heart, false = stopped, true = beating\n    bool public active;\n\n    /// @notice Timestamp of the last beat (UTC, in seconds)\n    uint256 public lastBeat;\n\n    /// @notice Reward for beating the Heart (in reward token decimals)\n    uint256 public reward;\n\n    /// @notice Reward token address that users are sent for beating the Heart\n    ERC20 public rewardToken;\n\n    // Modules\n    OlympusPrice internal PRICE;\n\n    // Policies\n    IOperator internal _operator;\n\n    /*//////////////////////////////////////////////////////////////\n                            POLICY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        IOperator operator_,\n        ERC20 rewardToken_,\n        uint256 reward_\n    ) Policy(kernel_) {\n        _operator = operator_;\n\n        active = true;\n        lastBeat = block.timestamp;\n        rewardToken = rewardToken_;\n        reward = reward_;\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](1);\n        dependencies[0] = toKeycode(\"PRICE\");\n\n        PRICE = OlympusPrice(getModuleAddress(dependencies[0]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        permissions = new Permissions[](1);\n        permissions[0] = Permissions(PRICE.KEYCODE(), PRICE.updateMovingAverage.selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function beat() external nonReentrant {\n        if (!active) revert Heart_BeatStopped();\n        if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle();\n\n        // Update the moving average on the Price module\n        PRICE.updateMovingAverage();\n\n        // Trigger price range update and market operations\n        _operator.operate();\n\n        // Update the last beat timestamp\n        lastBeat += frequency();\n\n        // Issue reward to sender\n        _issueReward(msg.sender);\n\n        emit Beat(block.timestamp);\n    }\n\n    function _issueReward(address to_) internal {\n        rewardToken.safeTransfer(to_, reward);\n        emit RewardIssued(to_, reward);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function frequency() public view returns (uint256) {\n        return uint256(PRICE.observationFrequency());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function resetBeat() external onlyRole(\"heart_admin\") {\n        lastBeat = block.timestamp - frequency();\n    }\n\n    /// @inheritdoc IHeart\n    function toggleBeat() external onlyRole(\"heart_admin\") {\n        active = !active;\n    }\n\n    /// @inheritdoc IHeart\n    function setRewardTokenAndAmount(ERC20 token_, uint256 reward_)\n        external\n        onlyRole(\"heart_admin\")\n    {\n        rewardToken = token_;\n        reward = reward_;\n        emit RewardUpdated(token_, reward_);\n    }\n\n    /// @inheritdoc IHeart\n    function withdrawUnspentRewards(ERC20 token_) external onlyRole(\"heart_admin\") {\n        token_.safeTransfer(msg.sender, token_.balanceOf(address(this)));\n    }\n}"
    },
    {
      "filename": "src/policies/Heart.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IHeart} from \"policies/interfaces/IHeart.sol\";\nimport {IOperator} from \"policies/interfaces/IOperator.sol\";\n\nimport {OlympusPrice} from \"modules/PRICE.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// @title  Olympus Heart\n/// @notice Olympus Heart (Policy) Contract\n/// @dev    The Olympus Heart contract provides keeper rewards to call the heart beat function which fuels\n///         Olympus market operations. The Heart orchestrates state updates in the correct order to ensure\n///         market operations use up to date information.\ncontract OlympusHeart is IHeart, Policy, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    error Heart_OutOfCycle();\n    error Heart_BeatStopped();\n    error Heart_InvalidParams();\n\n    event Beat(uint256 timestamp_);\n    event RewardIssued(address to_, uint256 rewardAmount_);\n    event RewardUpdated(ERC20 token_, uint256 rewardAmount_);\n\n    /// @notice Status of the Heart, false = stopped, true = beating\n    bool public active;\n\n    /// @notice Timestamp of the last beat (UTC, in seconds)\n    uint256 public lastBeat;\n\n    /// @notice Reward for beating the Heart (in reward token decimals)\n    uint256 public reward;\n\n    /// @notice Reward token address that users are sent for beating the Heart\n    ERC20 public rewardToken;\n\n    // Modules\n    OlympusPrice internal PRICE;\n\n    // Policies\n    IOperator internal _operator;\n\n    /*//////////////////////////////////////////////////////////////\n                            POLICY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        IOperator operator_,\n        ERC20 rewardToken_,\n        uint256 reward_\n    ) Policy(kernel_) {\n        _operator = operator_;\n\n        active = true;\n        lastBeat = block.timestamp;\n        rewardToken = rewardToken_;\n        reward = reward_;\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](1);\n        dependencies[0] = toKeycode(\"PRICE\");\n\n        PRICE = OlympusPrice(getModuleAddress(dependencies[0]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        permissions = new Permissions[](1);\n        permissions[0] = Permissions(PRICE.KEYCODE(), PRICE.updateMovingAverage.selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function beat() external nonReentrant {\n        if (!active) revert Heart_BeatStopped();\n        if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle();\n\n        // Update the moving average on the Price module\n        PRICE.updateMovingAverage();\n\n        // Trigger price range update and market operations\n        _operator.operate();\n\n        // Update the last beat timestamp\n        lastBeat += frequency();\n\n        // Issue reward to sender\n        _issueReward(msg.sender);\n\n        emit Beat(block.timestamp);\n    }\n\n    function _issueReward(address to_) internal {\n        rewardToken.safeTransfer(to_, reward);\n        emit RewardIssued(to_, reward);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function frequency() public view returns (uint256) {\n        return uint256(PRICE.observationFrequency());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function resetBeat() external onlyRole(\"heart_admin\") {\n        lastBeat = block.timestamp - frequency();\n    }\n\n    /// @inheritdoc IHeart\n    function toggleBeat() external onlyRole(\"heart_admin\") {\n        active = !active;\n    }\n\n    /// @inheritdoc IHeart\n    function setRewardTokenAndAmount(ERC20 token_, uint256 reward_)\n        external\n        onlyRole(\"heart_admin\")\n    {\n        rewardToken = token_;\n        reward = reward_;\n        emit RewardUpdated(token_, reward_);\n    }\n\n    /// @inheritdoc IHeart\n    function withdrawUnspentRewards(ERC20 token_) external onlyRole(\"heart_admin\") {\n        token_.safeTransfer(msg.sender, token_.balanceOf(address(this)));\n    }\n}"
    }
  ]
}