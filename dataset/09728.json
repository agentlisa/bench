{
  "Title": "[H-02] Mint spread collateral-less and conjuring collateral claims out of thin air with implicit arithmetic rounding and flawed int to uint conversion",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/QuantMath.sol#L137\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/QuantMath.sol#L151\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/SignedConverter.sol#L28\n\n\n# Vulnerability details\n\n## Impact\n\nThis report presents 2 different incorrect behaviour that can affect the correctness of math calculations\n1. Unattended Implicit rounding in QuantMath.sol `div` and `mul`\n2. Inappropriate method of casting integer to unsigned integer in SignedConverter.sol `intToUint`\n\nBug 1 affects the correctness when calculating collateral required for `_mintSpread`. Bug 2 expands the attack surface and allows attackers to target the `_claimCollateral` phase instead. Both attacks may result in tokens being stolen from Controller in the worst case, but is most likely too costly to exploit under current BNB chain environment. The potential impact however, should not be taken lightly, since it is known that the ethereum environment in highly volatile and minor changes in the environment can suddenly make those bugs cheap to exploit.\n\n\n## Proof of Concept\n\nIn this section, we will first present bug 1, and then demonstrate how this bug can be exploited. Then we will discuss how bug 2 opens up more attack chances and go over another PoC.\n\nBefore getting started, we should go over an important concept while dealing with fixed point number -- rounding.\nMath has no limits on precision, but computers do. This problem is especially critical to systems handling large amount of \"money\" that is allowed to be arbitrarily divided. A common way for ethereum smart contract developers to handle this is through rounding numbers. Rolla is no exception.\n\nIn QuantMath, Rolla explicitly wrote the `toScaledUint` function to differentiate between rounding numbers up or down when scaling numbers to different precision (or we call it `_decimals` here). The intended usage is to scale calculated numbers (amount of tokens) up when Controller is the receiver, and scale it down when Controller is sender. In theory, this function should guarantee Controller can never \"lose tokens\" due to rounding.\n\n```\nlibrary QuantMath {\n    ...\n    struct FixedPointInt {\n        int256 value;\n    }\n\n    int256 private constant _SCALING_FACTOR = 1e27;\n    uint256 private constant _BASE_DECIMALS = 27;\n\n    ...\n\n    function toScaledUint(\n        FixedPointInt memory _a,\n        uint256 _decimals,\n        bool _roundDown\n    ) internal pure returns (uint256) {\n        uint256 scaledUint;\n\n        if (_decimals == _BASE_DECIMALS) {\n            scaledUint = _a.value.intToUint();\n        } else if (_decimals > _BASE_DECIMALS) {\n            uint256 exp = _decimals - _BASE_DECIMALS;\n            scaledUint = (_a.value).intToUint() * 10**exp;\n        } else {\n            uint256 exp = _BASE_DECIMALS - _decimals;\n            uint256 tailing;\n            if (!_roundDown) {\n                uint256 remainer = (_a.value).intToUint() % 10**exp;\n                if (remainer > 0) tailing = 1;\n            }\n            scaledUint = (_a.value).intToUint() / 10**exp + tailing;\n        }\n\n        return scaledUint;\n    }\n    ...\n}\n```\n\nIn practice, the above function also works quite well (sadly, not perfect, notice the `intToUint` function within. We will come back to this later), but it only works if we can promise that before entering this function, all numbers retain full precision and is not already rounded. This is where `div` and `mul` comes into play. As we can easily see in the snippet below, both functions involve the division operator '/', which by default discards the decimal part of the calculated result (be aware to not confuse this with the `_decimal` used while scaling FixedPointInt). The operation here results in an implicit round down, which limits the effectiveness of  explicit rounding in `toScaledUint` showned above.\n\n```\n    function mul(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt((a.value * b.value) / _SCALING_FACTOR);\n    }\n\n\n    function div(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt((a.value * _SCALING_FACTOR) / b.value);\n    }\n```\n\nNow let's see how this implicit rounding can causes troubles. We start with the `_mintSpread` procedure creating a call credit spread. For brevity, the related code is not shown, but here's a summary of what is done.\n\n* `Controller._mintSpread`\n  * `QuantCalculator.getCollateralRequirement`\n    * `FundsCalculator.getCollateralRequirement`\n      * `FundsCalculator.getOptionCollateralRequirement`\n        * `FundsCalculator.getCallCollateralRequirement`\n          * scales `_qTokenToMintStrikePrice` from\n             `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`\n          * scales `_qTokenForCollateralStrikePrice` from\n             `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`\n          * `collateralPerOption = (collateralStrikePrice.sub(mintStrikePrice)).div(collateralStrikePrice)`\n        * scale `_optionsAmount` from `_optionsDecimals (18)` to `_BASE_DECIMALS (27)`\n        * `collateralAmount = _optionsAmount.mul(collateralPerOption)`\n      * uses `qTokenToMint.underlyingAsset` (weth or wbtc) as collateral\n    * scale and round up `collateralAmountFP` from `_BASE_DECIMALS (27)` to `payoutDecimals (18)`\n\nIf we extract all the math related stuff, it would be something like below\n\n```\ndef callCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):\n        X1 = _qTokenToMintStrikePrice * 10^19\n        X2 = _qTokenForCollateralStrikePrice * 10^19\n        X3 = _optionsAmount * 10^9\n\n        assert X1 < X2          #credit spread\n\n        Y1 = (X2 - X1) * 10^27 // X2    #implicit round down due to div\n        Y2 = Y1 * X3 // 10^27   #implicit round down due to mul\n\n        Z = Y2 // 10^9\n        if Y2 % 10^9 > 0:       #round up since we are minting spread (Controller is receiver)\n                Z+=1\n        return Z\n```\n\nBoth implicit round downs can be abused, but we shall focus on the `mul` one here.\nAssume we follow the following actions\n\n1. create option `A` with strike price `10 + 10^-8 BUSD (10^9 + 1 under 8 decimals) <-> 1 WETH`\n2. create option `B` with strike price `10 BUSD (10^9 under 8 decimals) <-> 1 WETH`\n3. mint `10^-18` (1 under 18 decimals) option `A`\n        3-1. `pay 1 eth`\n4. mint `10^-18` (1 under 18 decimals) spread `B` with `A` as collateral\n        4-1. `X1 = _qTokenToMintStrikePrice * 10^19 = 10^9 * 10^19 = 10^28`\n        4-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^9 + 1) * 10^19 = 10^28 + 10^19`\n        4-3. `X3 = _optionsAmount * 10^9 = 1 * 10^9 = 10^9`\n        4-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^28 + 10^19 - 10^28) * 10^27 // (10^28 + 10^19) = 99999999000000000`\n        4-5. `Y2 = Y1 * X3 // 10^27 = 99999999000000000 * 10^9 / 10^27 = 0`\n        4-6. `Z = Y2 // 10^9 = 0`\n        4-7. `Y2 % 10^9 = 0` so `Z` remains unchanged\n\nWe minted a call credit spread without paying any fee.\n\nNow let's think about how to extract the value we conjured out of thin air. To be able to withdraw excessive collateral, we can choose to do a excercise+claim or neutralize current options. Here we take the neutralize path.\n\nFor neutralizing spreads, the procedure is basically the same as minting spreads, except that the explicit round down is taken since `Controller` is the payer here. The neutralize procedure returns the `qToken` used as collateral and pays the collateral fee back. The math part can be summarized as below.\n\n```\ndef neutralizeCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):\n        X1 = _qTokenToMintStrikePrice * 10^19\n        X2 = _qTokenForCollateralStrikePrice * 10^19\n        X3 = _optionsAmount * 10^9\n\n        assert X1 < X2          #credit spread\n\n        Y1 = (X2 - X1) * 10^27 // X2    #implicit round down due to div\n        Y2 = Y1 * X3 // 10^27   #implicit round down due to mul\n\n        Z = Y2 // 10^9  #explicit scaling\n        return Z\n```\n\nThere are two challenges that need to be bypassed, the first one is to avoid implicit round down in `mul`, and the second is to ensure the revenue is not rounded away during explicit scaling.\nTo achieve this, we first mint `10^-9 + 2 * 10^-18` spreads seperately (10^9 + 2 under 18 decimals), and as shown before, no additional fees are required while minting spread from original option.\nThen we neutralize all those spreads at once, the calculation is shown below\n\n1. neutralize `10^-9 + 2 * 10^-18` (10^9 + 2 under 18 decimals) spread `B`\n        4-1. `X1 = _qTokenToMintStrikePrice * 10^19 = 10^9 * 10^19 = 10^28`\n        4-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^9 + 1) * 10^19 = 10^28 + 10^19`\n        4-3. `X3 = _optionsAmount * 10^9 = (10^9 + 2) * 10^9 = 10^18 + 2`\n        4-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^28 + 10^19 - 10^28) * 10^27 // (10^28 + 10^19) = 99999999000000000`\n        4-5. `Y2 = Y1 * X3 // 10^27 = 99999999000000000 * (10^18 + 2) / 10^27 = 1000000000`\n        4-6. `Z = Y2 // 10^9 = 10^9 // 10^9 = 1`\n\nAnd with this, we managed to generate 10^-18 weth of revenue.\n\nThis approach is pretty impractical due to the requirement of minting 10^-18 for `10^9 + 2` times. This montrous count mostly likely requires a lot of gas to pull off, and offsets the marginal revenue generated through our attack. This leads us to explore other possible methods to bypass this limitation.\n\nIt's time to start looking at the second bug.\n\nRecall we mentioned the second bug is in `intToUint`, so here's the implementation of it. It is not hard to see that this is actually an `abs` function named as `intToUint`.\n\n```\n    function intToUint(int256 a) internal pure returns (uint256) {\n        if (a < 0) {\n            return uint256(-a);\n        } else {\n            return uint256(a);\n        }\n    }\n```\n\nWhere is this function used? And yes, you guessed it, in `QuantCalculator.calculateClaimableCollateral`. The process of claiming collateral is quite complex, but we will only look at the specific case relevant to the exploit. Before reading code, let's first show the desired scenario. Note that while we wait for expiry, there are no need to sell any option/spread.\n\n1. mint a `qTokenLong` option\n2. mint a `qTokenShort` spread with `qTokenLong` as collateral\n3. wait until expire, and expect expiryPrice to be between qTokenLong and qTokenShort\n\n```\n----------- qTokenLong strike price\n\n----------- expiryPrice\n\n----------- qTokenShort strike price\n```\n\nHere is the outline of the long waited claimCollateral for spread.\n\n* `Controller._claimCollateral`\n  * `QuantCalculator.calculateClaimableCollateral`\n    * `FundsCalculator.getSettlementPriceWithDecimals`\n    * `FundsCalculator.getPayout` for qTokenLong\n      * qTokenLong strike price is above expiry price, worth 0\n    * `FundsCalculator.getCollateralRequirement`\n      * This part we saw earlier, omit details\n    * `FundsCalculator.getPayout` for qTokenShort\n      * uses `qTokenToMint.underlyingAsset` (weth or wbtc) as collateral\n      * `FundsCalculator.getPayoutAmount` for qTokenShort\n        * scale `_strikePrice` from\n          `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`\n        * scale `_expiryPrice.price` from\n          `_expiryPrice.decimals (8)` to `_BASE_DECIMALS (27)`\n        * scale `_amount` from\n          `_optionsDecimals (18)` to `_BASE_DECIMALS (27)`\n        * `FundsCalculator.getPayoutForCall` for qTokenShort\n          * `payoutAmount = expiryPrice.sub(strikePrice).mul(amount).div(expiryPrice)`\n    * `returnableCollateral = payoutFromLong.add(collateralRequirement).sub(payoutFromShort)`\n    * scale and round down `abs(returnableCollateral)` from `_BASE_DECIMALS (27)` to `payoutDecimals (18)`\n\n\nAgain, we summarize the math part into a function\n\n```\ndef claimableCollateralCallCreditSpreadExpiryInbetween(_qTokenShortStrikePrice, _qTokenLongStrikePrice, _expiryPrice, _amount):\n\n        def callCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):\n                X1 = _qTokenToMintStrikePrice * 10^19\n                X2 = _qTokenForCollateralStrikePrice * 10^19\n                X3 = _optionsAmount * 10^9\n\n                Y1 = (X2 - X1) * 10^27 // X2\n                Y2 = Y1 * X3 // 10^27\n                return Y2\n\n        def callCreditSpreadQTokenShortPayout(_strikePrice, _expiryPrice, _amount):\n                X1 = _strikePrice * 10^19\n                X2 = _expiryPrice * 10^19\n                X3 = _amount * 10^9\n\n                Y1 = (X2-X1) * X3 // 10^27\n                Y2 = Y1 * 10^27 // X2\n                return Y2\n\n\n        assert _qTokenShortStrikePrice > _expiryPrice > _qTokenLongStrikePrice\n\n        A1 = payoutFromLong = 0\n        A2 = collateralRequirement = callCreditSpreadCollateralRequirement(_qTokenShortStrikePrice, _qTokenLongStrikePrice, _amount)\n        A3 = payoutFromShort = callCreditSpreadQTokenShortPayout(_qTokenShortStrikePrice, _expiryPrice, _amount)\n\n        B1 = A1 + A2 - A3\n\n        Z = abs(B1) // 10^9\n        return Z\n```\n\nGiven the context, it should be pretty easy to imagine what I am aiming here, to make `B1 < 0`. We already know `A1 = 0`, so the gaol basically boils down to making `A2 < A3`. Let's further simplify this requirement and see if the equation is solvable.\n\n```\nX = _qTokenLongStrikePrice (8 decimals)\nY = _expiryPrice (8 decimals)\nZ = _qTokenShortStrikePrice (8 decimals)\nA = _amount (scaled to 27 decimals)\n\nassert X>Y>Z>0\nassert X,Y,Z are integers\nassert (((X - Z) * 10^27 // X) * A // 10^27) < (((Y - Z) * A // 10^27) * 10^27 // Y)\n```\n\nNotice apart from the use of `X` and `Y`, the two sides of the equation only differs by when `A` is mixed into the equation, meaning that if we temporarily ignore the limitation and set `X = Y`, as long as left hand side of equation does an implicit rounding after dividing by X, right hand side will most likely be larger.\n\nUtilizing this, we turn to solve the equation of\n\n```\n(X-Z) / X - (Y-Z) / Y < 10^-27\n=> Z / Y - Z / X < 10^-27\n=> (Z = 1 yields best solution)\n=> 1 / Y - 1 / X < 10^-27\n=> X - Y < X * Y * 10^-27\n=> 0 < X * Y - 10^27 * X + 10^27 * Y\n\n=> require X > Y, so model Y as X - B, where B > 0 and B is an integer\n=> 0 < X^2 - B * X - 10^27 * B\n```\n\nIt is not easy to see that the larger `X` is, the larger the range of allowed `B`. This is pretty important since `B` stands for the range of expiry prices where attack could work, so the larger it is, the less accurate our guess can be to profit.\n\nApart form range of `B`, value of `X` is the long strike price and upper bound of range `B`, so we would also care about it, a simple estimation shows that `X` must be above `10^13.5 (8 decimals)` for there to be a solution, which amounts to about `316228 BUSD <-> 1 WETH`. This is an extremely high price, but not high enough to be concluded as unreachable in the near future. So let's take a slightly generous number of `10^14 - 1` as X and calculate the revenue generated following this exploit path.\n\n```\n0 < (10^14 - 1)^2 - B * (10^14 - 1) - 10^27 * B\n=> (10^14 - 1)^2 / (10^14 - 1 + 10^27) > B\n=> B <= 9\n```\n\nNow we've got the range of profitable expiry price. As we concluded earlier, the range is extremely small with a modest long strike price, but let's settle with this for now and see how much profit can be generated if we get lucky. To calculate profit, we take `_qTokenLongStrikePrice = 10^14 - 1 (8 decimals)`, `_qTokenShortStrikePrice = 1 (8 decimals)`, `_expiryPrice = 10^14 - 2 (8 decimals)` and `_amount = 10^28 (18 decimals)` and plug it back into the function.\n1. in `callCreditSpreadCollateralRequirement`\n        1-1. `X1 = _qTokenForCollateralStrikePrice * 10^19 = 1 * 10^19 = 10^19`\n        1-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^14 - 1) * 10^19 = 10^33 - 10^19`\n        1-3. `X3 = _optionsAmount * 10^9 = 10^28 * 10^9 = 10^37`\n        1-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^33 - 2 * 10^19) * 10^27 // (10^33 - 10^19) = 999999999999989999999999999`\n        1-5. `Y2 = Y1 * X3 // 10^27 = 999999999999989999999999999 * 10^37 // 10^27 = 999999999999989999999999999 * 10^10`\n2. in `callCreditSpreadQTokenShortPayout`\n        2-1. `X1 = _strikePrice * 10^19 = 1 * 10^19 = 10^19`\n        2-2. `X2 = _expiryPrice * 10^19 = (10^14 - 2) * 10^19 = 10^33 - 2 * 10^19`\n        2-3. `X3 = _amount * 10^9 = 10^28 * 10^9 = 10^37`\n        2-4. `Y1 = (X2 - X1) * X3 // 10^27 = (10^33 - 3 * 10^19) * 10^37 // 10^27 = 99999999999997 * 10^29`\n        2-5. `Y2 = Y1 * 10^27 / X2 = (99999999999997 * 10^28) * 10^27 / (10^33 - 2 * 10^19) = 9999999999999899999999999997999999999\n3. combine terms\n        3-1. `B1 = A1 + A2 - A3 = 0 + 9999999999999899999999999990000000000 - 9999999999999899999999999997999999999 = -2000000001\n        3-2. `Z = abs(B1) // 10^9 = 2000000000 // 10^9 = 2\n\nAnd with this, we managed to squeeze 2 wei from a presumably worthless collateral.\n\nThis attack still suffers from several problems\n1. cost of WETH in BUSD is way higher than current market\n2. need to predict target price accurately to profit\n3. requires large amount of WETH to profit\n\nWhile it is still pretty hard to pull off attack, the requirements seems pretty more likely to be achievable compared to the first version of exploit. Apart from this, there is also the nice property that this attack allows profit to scale with money invested.\n\nThis concludes our demonstration of two attacks against the potential flaws in number handling.\n\n## Tools Used\n\nvim, ganache-cli\n\n## Recommended Mitigation Steps\n\nFor `div` and `mul`, adding in a similar opt-out round up argument would work. This would require some refactoring of code, but is the only way to fundamentally solve the problem.\n\nFor `intToUint`, I still can't understand what the original motive is to design it as `abs` in disguise. Since nowhere in this project would we benefit from the current `abs` behaviour, in my opinion, it would be best to adopt a similar strategy to the `uintToInt` function. If the value goes out of directly convertable range ( < 0), revert and throw an error message.\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-03-rolla-contest",
  "Code": [
    {
      "filename": "quant-protocol/contracts/libraries/QuantMath.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"./SignedConverter.sol\";\n\n/**\n * @title QuantMath\n * @author Rolla\n * @notice FixedPoint library\n */\nlibrary QuantMath {\n    using SignedConverter for int256;\n    using SignedConverter for uint256;\n\n    struct FixedPointInt {\n        int256 value;\n    }\n\n    int256 private constant _SCALING_FACTOR = 1e27;\n    uint256 private constant _BASE_DECIMALS = 27;\n\n    /**\n     * @notice constructs an `FixedPointInt` from an unscaled int, e.g., `b=5` gets stored internally as `5**27`.\n     * @param a int to convert into a FixedPoint.\n     * @return the converted FixedPoint.\n     */\n    function fromUnscaledInt(int256 a)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt(a * _SCALING_FACTOR);\n    }\n\n    /**\n     * @notice constructs an FixedPointInt from an scaled uint with {_decimals} decimals\n     * Examples:\n     * (1)  USDC    decimals = 6\n     *      Input:  5 * 1e6 USDC  =>    Output: 5 * 1e27 (FixedPoint 8.0 USDC)\n     * (2)  cUSDC   decimals = 8\n     *      Input:  5 * 1e6 cUSDC =>    Output: 5 * 1e25 (FixedPoint 0.08 cUSDC)\n     * @param _a uint256 to convert into a FixedPoint.\n     * @param _decimals  original decimals _a has\n     * @return the converted FixedPoint, with 27 decimals.\n     */\n    function fromScaledUint(uint256 _a, uint256 _decimals)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        FixedPointInt memory fixedPoint;\n\n        if (_decimals == _BASE_DECIMALS) {\n            fixedPoint = FixedPointInt(_a.uintToInt());\n        } else if (_decimals > _BASE_DECIMALS) {\n            uint256 exp = _decimals - _BASE_DECIMALS;\n            fixedPoint = FixedPointInt((_a / 10**exp).uintToInt());\n        } else {\n            uint256 exp = _BASE_DECIMALS - _decimals;\n            fixedPoint = FixedPointInt((_a * 10**exp).uintToInt());\n        }\n\n        return fixedPoint;\n    }\n\n    /**\n     * @notice convert a FixedPointInt number to an uint256 with a specific number of decimals\n     * @param _a FixedPointInt to convert\n     * @param _decimals number of decimals that the uint256 should be scaled to\n     * @param _roundDown True to round down the result, False to round up\n     * @return the converted uint256\n     */\n    function toScaledUint(\n        FixedPointInt memory _a,\n        uint256 _decimals,\n        bool _roundDown\n    ) internal pure returns (uint256) {\n        uint256 scaledUint;\n\n        if (_decimals == _BASE_DECIMALS) {\n            scaledUint = _a.value.intToUint();\n        } else if (_decimals > _BASE_DECIMALS) {\n            uint256 exp = _decimals - _BASE_DECIMALS;\n            scaledUint = (_a.value).intToUint() * 10**exp;\n        } else {\n            uint256 exp = _BASE_DECIMALS - _decimals;\n            uint256 tailing;\n            if (!_roundDown) {\n                uint256 remainer = (_a.value).intToUint() % 10**exp;\n                if (remainer > 0) tailing = 1;\n            }\n            scaledUint = (_a.value).intToUint() / 10**exp + tailing;\n        }\n\n        return scaledUint;\n    }\n\n    /**\n     * @notice add two signed integers, a + b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return sum of the two signed integers\n     */\n    function add(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt(a.value + b.value);\n    }\n\n    /**\n     * @notice subtract two signed integers, a-b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return difference of two signed integers\n     */\n    function sub(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt(a.value - b.value);\n    }\n\n    /**\n     * @notice multiply two signed integers, a by b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return mul of two signed integers\n     */\n    function mul(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt((a.value * b.value) / _SCALING_FACTOR);\n    }\n\n    /**\n     * @notice divide two signed integers, a by b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return div of two signed integers\n     */\n    function div(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt((a.value * _SCALING_FACTOR) / b.value);\n    }\n\n    /**\n     * @notice minimum between two signed integers, a and b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return min of two signed integers\n     */\n    function min(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return a.value < b.value ? a : b;\n    }\n\n    /**\n     * @notice maximum between two signed integers, a and b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return max of two signed integers\n     */\n    function max(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return a.value > b.value ? a : b;\n    }\n\n    /**\n     * @notice is a is equal to b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if equal, False if not\n     */\n    function isEqual(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return a.value == b.value;\n    }\n\n    /**\n     * @notice is a greater than b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if a > b, False if not\n     */\n    function isGreaterThan(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return a.value > b.value;\n    }\n\n    /**\n     * @notice is a greater than or equal to b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if a >= b, False if not\n     */\n    function isGreaterThanOrEqual(\n        FixedPointInt memory a,\n        FixedPointInt memory b\n    ) internal pure returns (bool) {\n        return a.value >= b.value;\n    }\n\n    /**\n     * @notice is a is less than b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if a < b, False if not\n     */\n    function isLessThan(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return a.value < b.value;\n    }\n\n    /**\n     * @notice is a less than or equal to b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if a <= b, False if not\n     */\n    function isLessThanOrEqual(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return a.value <= b.value;\n    }\n}"
    },
    {
      "filename": "quant-protocol/contracts/libraries/QuantMath.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"./SignedConverter.sol\";\n\n/**\n * @title QuantMath\n * @author Rolla\n * @notice FixedPoint library\n */\nlibrary QuantMath {\n    using SignedConverter for int256;\n    using SignedConverter for uint256;\n\n    struct FixedPointInt {\n        int256 value;\n    }\n\n    int256 private constant _SCALING_FACTOR = 1e27;\n    uint256 private constant _BASE_DECIMALS = 27;\n\n    /**\n     * @notice constructs an `FixedPointInt` from an unscaled int, e.g., `b=5` gets stored internally as `5**27`.\n     * @param a int to convert into a FixedPoint.\n     * @return the converted FixedPoint.\n     */\n    function fromUnscaledInt(int256 a)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt(a * _SCALING_FACTOR);\n    }\n\n    /**\n     * @notice constructs an FixedPointInt from an scaled uint with {_decimals} decimals\n     * Examples:\n     * (1)  USDC    decimals = 6\n     *      Input:  5 * 1e6 USDC  =>    Output: 5 * 1e27 (FixedPoint 8.0 USDC)\n     * (2)  cUSDC   decimals = 8\n     *      Input:  5 * 1e6 cUSDC =>    Output: 5 * 1e25 (FixedPoint 0.08 cUSDC)\n     * @param _a uint256 to convert into a FixedPoint.\n     * @param _decimals  original decimals _a has\n     * @return the converted FixedPoint, with 27 decimals.\n     */\n    function fromScaledUint(uint256 _a, uint256 _decimals)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        FixedPointInt memory fixedPoint;\n\n        if (_decimals == _BASE_DECIMALS) {\n            fixedPoint = FixedPointInt(_a.uintToInt());\n        } else if (_decimals > _BASE_DECIMALS) {\n            uint256 exp = _decimals - _BASE_DECIMALS;\n            fixedPoint = FixedPointInt((_a / 10**exp).uintToInt());\n        } else {\n            uint256 exp = _BASE_DECIMALS - _decimals;\n            fixedPoint = FixedPointInt((_a * 10**exp).uintToInt());\n        }\n\n        return fixedPoint;\n    }\n\n    /**\n     * @notice convert a FixedPointInt number to an uint256 with a specific number of decimals\n     * @param _a FixedPointInt to convert\n     * @param _decimals number of decimals that the uint256 should be scaled to\n     * @param _roundDown True to round down the result, False to round up\n     * @return the converted uint256\n     */\n    function toScaledUint(\n        FixedPointInt memory _a,\n        uint256 _decimals,\n        bool _roundDown\n    ) internal pure returns (uint256) {\n        uint256 scaledUint;\n\n        if (_decimals == _BASE_DECIMALS) {\n            scaledUint = _a.value.intToUint();\n        } else if (_decimals > _BASE_DECIMALS) {\n            uint256 exp = _decimals - _BASE_DECIMALS;\n            scaledUint = (_a.value).intToUint() * 10**exp;\n        } else {\n            uint256 exp = _BASE_DECIMALS - _decimals;\n            uint256 tailing;\n            if (!_roundDown) {\n                uint256 remainer = (_a.value).intToUint() % 10**exp;\n                if (remainer > 0) tailing = 1;\n            }\n            scaledUint = (_a.value).intToUint() / 10**exp + tailing;\n        }\n\n        return scaledUint;\n    }\n\n    /**\n     * @notice add two signed integers, a + b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return sum of the two signed integers\n     */\n    function add(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt(a.value + b.value);\n    }\n\n    /**\n     * @notice subtract two signed integers, a-b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return difference of two signed integers\n     */\n    function sub(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt(a.value - b.value);\n    }\n\n    /**\n     * @notice multiply two signed integers, a by b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return mul of two signed integers\n     */\n    function mul(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt((a.value * b.value) / _SCALING_FACTOR);\n    }\n\n    /**\n     * @notice divide two signed integers, a by b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return div of two signed integers\n     */\n    function div(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return FixedPointInt((a.value * _SCALING_FACTOR) / b.value);\n    }\n\n    /**\n     * @notice minimum between two signed integers, a and b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return min of two signed integers\n     */\n    function min(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return a.value < b.value ? a : b;\n    }\n\n    /**\n     * @notice maximum between two signed integers, a and b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return max of two signed integers\n     */\n    function max(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (FixedPointInt memory)\n    {\n        return a.value > b.value ? a : b;\n    }\n\n    /**\n     * @notice is a is equal to b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if equal, False if not\n     */\n    function isEqual(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return a.value == b.value;\n    }\n\n    /**\n     * @notice is a greater than b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if a > b, False if not\n     */\n    function isGreaterThan(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return a.value > b.value;\n    }\n\n    /**\n     * @notice is a greater than or equal to b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if a >= b, False if not\n     */\n    function isGreaterThanOrEqual(\n        FixedPointInt memory a,\n        FixedPointInt memory b\n    ) internal pure returns (bool) {\n        return a.value >= b.value;\n    }\n\n    /**\n     * @notice is a is less than b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if a < b, False if not\n     */\n    function isLessThan(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return a.value < b.value;\n    }\n\n    /**\n     * @notice is a less than or equal to b\n     * @param a FixedPointInt\n     * @param b FixedPointInt\n     * @return True if a <= b, False if not\n     */\n    function isLessThanOrEqual(FixedPointInt memory a, FixedPointInt memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return a.value <= b.value;\n    }\n}"
    },
    {
      "filename": "quant-protocol/contracts/libraries/SignedConverter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\n/**\n * @title SignedConverter\n * @author Rolla\n * @notice A library to convert an unsigned integer to signed integer or signed integer to unsigned integer.\n */\nlibrary SignedConverter {\n    /**\n     * @notice convert an unsigned integer to a signed integer\n     * @param a uint to convert into a signed integer\n     * @return converted signed integer\n     */\n    function uintToInt(uint256 a) internal pure returns (int256) {\n        require(a < 2**255, \"QuantMath: out of int range\");\n\n        return int256(a);\n    }\n\n    /**\n     * @notice convert a signed integer to an unsigned integer\n     * @param a int to convert into an unsigned integer\n     * @return converted unsigned integer\n     */\n    function intToUint(int256 a) internal pure returns (uint256) {\n        if (a < 0) {\n            return uint256(-a);\n        } else {\n            return uint256(a);\n        }\n    }\n}"
    }
  ]
}