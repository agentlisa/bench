{
  "Title": "Non-Standard RLP Encoding of Integer Zero",
  "Content": "In the `L1MessageQueue`, the [`computeTransactionHash` function](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/L1MessageQueue.sol#L109) implements the [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718) standard. Here, the transaction type of `0x7E` is concatenated with the RLP-encoded transaction values and hashed.\n\n\nThere is an issue in the inline [`store_uint` assembly function](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/L1MessageQueue.sol#L142) which gives the non-standard encoding for the integer value zero. While the standard foresees that zero is encoded as `0x80`, the implementation encodes it as `0x00`. Hence, this leads to a non-standard encoding and therefore different hash. Given the `uint256` type, `_queueIndex`, `_value`, and `_gasLimit` are affected. While the `_queueIndex` will only be zero for the first ever message, `_value` is going to be zero for the vast majority of L1 message requests, because the `L1ScrollMessenger` uses the `appendCrossDomainMessage` function, [calling `_queueTransaction` with zero](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/L1MessageQueue.sol#L251) and then computing the transaction hash with `_value` zero.\n\n\nDuring the committing of batches, hashes of the message queue [become part of the commitment](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/ScrollChain.sol#L507) that will be proven during finalization. Considering the non-standard L1 transaction hashes, this commitment is expected to not align with the proof coming from the zk-circuit, hence making the first and majority of L1 messages impossible to finalize.\n\n\nConsider patching the `store_uint` function to catch this zero-integer edge case and achieve a standard encoding.\n\n\n***Update:** Resolved in [pull request #558](https://github.com/scroll-tech/scroll/pull/558) at commit [869111b](https://github.com/scroll-tech/scroll/pull/558/commits/869111b04ee45976273aa5656e95eb639a9f05cf).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/rollup/L1MessageQueue.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {IL2GasPriceOracle} from \"./IL2GasPriceOracle.sol\";\nimport {IL1MessageQueue} from \"./IL1MessageQueue.sol\";\n\nimport {AddressAliasHelper} from \"../../libraries/common/AddressAliasHelper.sol\";\n\n/// @title L1MessageQueue\n/// @notice This contract will hold all L1 to L2 messages.\n/// Each appended message is assigned with a unique and increasing `uint256` index.\ncontract L1MessageQueue is OwnableUpgradeable, IL1MessageQueue {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address _oldGasOracle, address _newGasOracle);\n\n    /// @notice Emitted when owner updates EnforcedTxGateway contract.\n    /// @param _oldGateway The address of old EnforcedTxGateway contract.\n    /// @param _newGateway The address of new EnforcedTxGateway contract.\n    event UpdateEnforcedTxGateway(address _oldGateway, address _newGateway);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ScrollMessenger contract.\n    address public messenger;\n\n    /// @notice The address of ScrollChain contract.\n    address public scrollChain;\n\n    /// @notice The address EnforcedTxGateway contract.\n    address public enforcedTxGateway;\n\n    /// @notice The address of GasOracle contract.\n    address public gasOracle;\n\n    /// @notice The list of queued cross domain messages.\n    bytes32[] public messageQueue;\n\n    /// @inheritdoc IL1MessageQueue\n    uint256 public pendingQueueIndex;\n\n    /// @notice The max gas limit of L1 transactions.\n    uint256 public maxGasLimit;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    function initialize(\n        address _messenger,\n        address _scrollChain,\n        address _enforcedTxGateway,\n        address _gasOracle,\n        uint256 _maxGasLimit\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        messenger = _messenger;\n        scrollChain = _scrollChain;\n        enforcedTxGateway = _enforcedTxGateway;\n        gasOracle = _gasOracle;\n        maxGasLimit = _maxGasLimit;\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1MessageQueue\n    function nextCrossDomainMessageIndex() external view returns (uint256) {\n        return messageQueue.length;\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function getCrossDomainMessage(uint256 _queueIndex) external view returns (bytes32) {\n        return messageQueue[_queueIndex];\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function estimateCrossDomainMessageFee(uint256 _gasLimit) external view override returns (uint256) {\n        address _oracle = gasOracle;\n        if (_oracle == address(0)) return 0;\n        return IL2GasPriceOracle(_oracle).estimateCrossDomainMessageFee(_gasLimit);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function calculateIntrinsicGasFee(bytes memory _calldata) public view override returns (uint256) {\n        address _oracle = gasOracle;\n        if (_oracle == address(0)) return 0;\n        return IL2GasPriceOracle(_oracle).calculateIntrinsicGasFee(_calldata);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function computeTransactionHash(\n        address _sender,\n        uint256 _queueIndex,\n        uint256 _value,\n        address _target,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) public pure override returns (bytes32) {\n        // We use EIP-2718 to encode the L1 message, and the encoding of the message is\n        //      `TransactionType || TransactionPayload`\n        // where\n        //  1. `TransactionType` is 0x7E\n        //  2. `TransactionPayload` is `rlp([queueIndex, gasLimit, to, value, data, sender])`\n        //\n        // The spec of rlp: https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/\n        uint256 transactionType = 0x7E;\n        bytes32 hash;\n        assembly {\n            function get_uint_bytes(v) -> len {\n                if eq(v, 0) {\n                    len := 1\n                    leave\n                }\n                for {\n\n                } gt(v, 0) {\n\n                } {\n                    len := add(len, 1)\n                    v := shr(8, v)\n                }\n            }\n\n            function store_uint(_ptr, v) -> ptr {\n                ptr := _ptr\n                switch lt(v, 128)\n                case 1 {\n                    // single byte in the [0x00, 0x7f]\n                    mstore(ptr, shl(248, v))\n                    ptr := add(ptr, 1)\n                }\n                default {\n                    // 1-32 bytes long\n                    let len := get_uint_bytes(v)\n                    mstore(ptr, shl(248, add(len, 0x80)))\n                    ptr := add(ptr, 1)\n                    mstore(ptr, shl(mul(8, sub(32, len)), v))\n                    ptr := add(ptr, len)\n                }\n            }\n\n            function store_address(_ptr, v) -> ptr {\n                ptr := _ptr\n                // 20 bytes long\n                mstore(ptr, shl(248, 0x94)) // 0x80 + 0x14\n                ptr := add(ptr, 1)\n                mstore(ptr, shl(96, v))\n                ptr := add(ptr, 0x14)\n            }\n\n            // 1 byte for TransactionType\n            // 4 byte for list payload length\n            let start_ptr := add(mload(0x40), 5)\n            let ptr := start_ptr\n            ptr := store_uint(ptr, _queueIndex)\n            ptr := store_uint(ptr, _gasLimit)\n            ptr := store_address(ptr, _target)\n            ptr := store_uint(ptr, _value)\n\n            switch eq(_data.length, 1)\n            case 1 {\n                // single byte\n                ptr := store_uint(ptr, shr(248, calldataload(_data.offset)))\n            }\n            default {\n                switch lt(_data.length, 56)\n                case 1 {\n                    // a string is 0-55 bytes long\n                    mstore(ptr, shl(248, add(0x80, _data.length)))\n                    ptr := add(ptr, 1)\n                    calldatacopy(ptr, _data.offset, _data.length)\n                    ptr := add(ptr, _data.length)\n                }\n                default {\n                    // a string is more than 55 bytes long\n                    let len_bytes := get_uint_bytes(_data.length)\n                    mstore(ptr, shl(248, add(0xb7, len_bytes)))\n                    ptr := add(ptr, 1)\n                    mstore(ptr, shl(mul(8, sub(32, len_bytes)), _data.length))\n                    ptr := add(ptr, len_bytes)\n                    calldatacopy(ptr, _data.offset, _data.length)\n                    ptr := add(ptr, _data.length)\n                }\n            }\n            ptr := store_address(ptr, _sender)\n\n            let payload_len := sub(ptr, start_ptr)\n            let value\n            let value_bytes\n            switch lt(payload_len, 56)\n            case 1 {\n                // the total payload of a list is 0-55 bytes long\n                value := add(0xc0, payload_len)\n                value_bytes := 1\n            }\n            default {\n                // If the total payload of a list is more than 55 bytes long\n                let len_bytes := get_uint_bytes(payload_len)\n                value_bytes := add(len_bytes, 1)\n                value := add(0xf7, len_bytes)\n                value := shl(mul(len_bytes, 8), value)\n                value := or(value, payload_len)\n            }\n            value := or(value, shl(mul(8, value_bytes), transactionType))\n            value_bytes := add(value_bytes, 1)\n            let value_bits := mul(8, value_bytes)\n            value := or(shl(sub(256, value_bits), value), shr(value_bits, mload(start_ptr)))\n            start_ptr := sub(start_ptr, value_bytes)\n            mstore(start_ptr, value)\n            hash := keccak256(start_ptr, sub(ptr, start_ptr))\n        }\n        return hash;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1MessageQueue\n    function appendCrossDomainMessage(\n        address _target,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) external override {\n        require(msg.sender == messenger, \"Only callable by the L1ScrollMessenger\");\n\n        // validate gas limit\n        _validateGasLimit(_gasLimit, _data);\n\n        // do address alias to avoid replay attack in L2.\n        address _sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n\n        _queueTransaction(_sender, _target, 0, _gasLimit, _data);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function appendEnforcedTransaction(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) external override {\n        require(msg.sender == enforcedTxGateway, \"Only callable by the EnforcedTxGateway\");\n        // We will check it in EnforcedTxGateway, just in case.\n        require(_sender.code.length == 0, \"only EOA\");\n\n        // validate gas limit\n        _validateGasLimit(_gasLimit, _data);\n\n        _queueTransaction(_sender, _target, _value, _gasLimit, _data);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function popCrossDomainMessage(\n        uint256 _startIndex,\n        uint256 _count,\n        uint256 _skippedBitmap\n    ) external {\n        require(msg.sender == scrollChain, \"Only callable by the ScrollChain\");\n\n        require(_count <= 256, \"pop too many messages\");\n        require(pendingQueueIndex == _startIndex, \"start index mismatch\");\n\n        unchecked {\n            for (uint256 i = 0; i < _count; i++) {\n                if ((_skippedBitmap >> i) & 1 == 0) {\n                    messageQueue[_startIndex + i] = bytes32(0);\n                }\n            }\n\n            pendingQueueIndex = _startIndex + _count;\n        }\n\n        emit DequeueTransaction(_startIndex, _count, _skippedBitmap);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of gas oracle.\n    /// @dev This function can only called by contract owner.\n    /// @param _newGasOracle The address to update.\n    function updateGasOracle(address _newGasOracle) external onlyOwner {\n        address _oldGasOracle = gasOracle;\n        gasOracle = _newGasOracle;\n\n        emit UpdateGasOracle(_oldGasOracle, _newGasOracle);\n    }\n\n    /// @notice Update the address of EnforcedTxGateway.\n    /// @dev This function can only called by contract owner.\n    /// @param _newGateway The address to update.\n    function updateEnforcedTxGateway(address _newGateway) external onlyOwner {\n        address _oldGateway = enforcedTxGateway;\n        enforcedTxGateway = _newGateway;\n\n        emit UpdateEnforcedTxGateway(_oldGateway, _newGateway);\n    }\n\n    /// @notice Update the max gas limit.\n    /// @dev This function can only called by contract owner.\n    /// @param _newMaxGasLimit The new max gas limit.\n    function updateMaxGasLimit(uint256 _newMaxGasLimit) external onlyOwner {\n        uint256 _oldMaxGasLimit = maxGasLimit;\n        maxGasLimit = _newMaxGasLimit;\n\n        emit UpdateMaxGasLimit(_oldMaxGasLimit, _newMaxGasLimit);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to queue a L1 transaction.\n    /// @param _sender The address of sender who will initiate this transaction in L2.\n    /// @param _target The address of target contract to call in L2.\n    /// @param _value The value passed\n    /// @param _gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param _data The calldata passed to target contract.\n    function _queueTransaction(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) internal {\n        // compute transaction hash\n        uint256 _queueIndex = messageQueue.length;\n        bytes32 _hash = computeTransactionHash(_sender, _queueIndex, _value, _target, _gasLimit, _data);\n        messageQueue.push(_hash);\n\n        // emit event\n        emit QueueTransaction(_sender, _target, _value, _queueIndex, _gasLimit, _data);\n    }\n\n    function _validateGasLimit(uint256 _gasLimit, bytes memory _calldata) internal view {\n        require(_gasLimit <= maxGasLimit, \"Gas limit must not exceed maxGasLimit\");\n        // check if the gas limit is above intrinsic gas\n        uint256 intrinsicGas = calculateIntrinsicGasFee(_calldata);\n        require(_gasLimit >= intrinsicGas, \"Insufficient gas limit, must be above intrinsic gas\");\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/rollup/L1MessageQueue.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {IL2GasPriceOracle} from \"./IL2GasPriceOracle.sol\";\nimport {IL1MessageQueue} from \"./IL1MessageQueue.sol\";\n\nimport {AddressAliasHelper} from \"../../libraries/common/AddressAliasHelper.sol\";\n\n/// @title L1MessageQueue\n/// @notice This contract will hold all L1 to L2 messages.\n/// Each appended message is assigned with a unique and increasing `uint256` index.\ncontract L1MessageQueue is OwnableUpgradeable, IL1MessageQueue {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address _oldGasOracle, address _newGasOracle);\n\n    /// @notice Emitted when owner updates EnforcedTxGateway contract.\n    /// @param _oldGateway The address of old EnforcedTxGateway contract.\n    /// @param _newGateway The address of new EnforcedTxGateway contract.\n    event UpdateEnforcedTxGateway(address _oldGateway, address _newGateway);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ScrollMessenger contract.\n    address public messenger;\n\n    /// @notice The address of ScrollChain contract.\n    address public scrollChain;\n\n    /// @notice The address EnforcedTxGateway contract.\n    address public enforcedTxGateway;\n\n    /// @notice The address of GasOracle contract.\n    address public gasOracle;\n\n    /// @notice The list of queued cross domain messages.\n    bytes32[] public messageQueue;\n\n    /// @inheritdoc IL1MessageQueue\n    uint256 public pendingQueueIndex;\n\n    /// @notice The max gas limit of L1 transactions.\n    uint256 public maxGasLimit;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    function initialize(\n        address _messenger,\n        address _scrollChain,\n        address _enforcedTxGateway,\n        address _gasOracle,\n        uint256 _maxGasLimit\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        messenger = _messenger;\n        scrollChain = _scrollChain;\n        enforcedTxGateway = _enforcedTxGateway;\n        gasOracle = _gasOracle;\n        maxGasLimit = _maxGasLimit;\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1MessageQueue\n    function nextCrossDomainMessageIndex() external view returns (uint256) {\n        return messageQueue.length;\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function getCrossDomainMessage(uint256 _queueIndex) external view returns (bytes32) {\n        return messageQueue[_queueIndex];\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function estimateCrossDomainMessageFee(uint256 _gasLimit) external view override returns (uint256) {\n        address _oracle = gasOracle;\n        if (_oracle == address(0)) return 0;\n        return IL2GasPriceOracle(_oracle).estimateCrossDomainMessageFee(_gasLimit);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function calculateIntrinsicGasFee(bytes memory _calldata) public view override returns (uint256) {\n        address _oracle = gasOracle;\n        if (_oracle == address(0)) return 0;\n        return IL2GasPriceOracle(_oracle).calculateIntrinsicGasFee(_calldata);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function computeTransactionHash(\n        address _sender,\n        uint256 _queueIndex,\n        uint256 _value,\n        address _target,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) public pure override returns (bytes32) {\n        // We use EIP-2718 to encode the L1 message, and the encoding of the message is\n        //      `TransactionType || TransactionPayload`\n        // where\n        //  1. `TransactionType` is 0x7E\n        //  2. `TransactionPayload` is `rlp([queueIndex, gasLimit, to, value, data, sender])`\n        //\n        // The spec of rlp: https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/\n        uint256 transactionType = 0x7E;\n        bytes32 hash;\n        assembly {\n            function get_uint_bytes(v) -> len {\n                if eq(v, 0) {\n                    len := 1\n                    leave\n                }\n                for {\n\n                } gt(v, 0) {\n\n                } {\n                    len := add(len, 1)\n                    v := shr(8, v)\n                }\n            }\n\n            function store_uint(_ptr, v) -> ptr {\n                ptr := _ptr\n                switch lt(v, 128)\n                case 1 {\n                    // single byte in the [0x00, 0x7f]\n                    mstore(ptr, shl(248, v))\n                    ptr := add(ptr, 1)\n                }\n                default {\n                    // 1-32 bytes long\n                    let len := get_uint_bytes(v)\n                    mstore(ptr, shl(248, add(len, 0x80)))\n                    ptr := add(ptr, 1)\n                    mstore(ptr, shl(mul(8, sub(32, len)), v))\n                    ptr := add(ptr, len)\n                }\n            }\n\n            function store_address(_ptr, v) -> ptr {\n                ptr := _ptr\n                // 20 bytes long\n                mstore(ptr, shl(248, 0x94)) // 0x80 + 0x14\n                ptr := add(ptr, 1)\n                mstore(ptr, shl(96, v))\n                ptr := add(ptr, 0x14)\n            }\n\n            // 1 byte for TransactionType\n            // 4 byte for list payload length\n            let start_ptr := add(mload(0x40), 5)\n            let ptr := start_ptr\n            ptr := store_uint(ptr, _queueIndex)\n            ptr := store_uint(ptr, _gasLimit)\n            ptr := store_address(ptr, _target)\n            ptr := store_uint(ptr, _value)\n\n            switch eq(_data.length, 1)\n            case 1 {\n                // single byte\n                ptr := store_uint(ptr, shr(248, calldataload(_data.offset)))\n            }\n            default {\n                switch lt(_data.length, 56)\n                case 1 {\n                    // a string is 0-55 bytes long\n                    mstore(ptr, shl(248, add(0x80, _data.length)))\n                    ptr := add(ptr, 1)\n                    calldatacopy(ptr, _data.offset, _data.length)\n                    ptr := add(ptr, _data.length)\n                }\n                default {\n                    // a string is more than 55 bytes long\n                    let len_bytes := get_uint_bytes(_data.length)\n                    mstore(ptr, shl(248, add(0xb7, len_bytes)))\n                    ptr := add(ptr, 1)\n                    mstore(ptr, shl(mul(8, sub(32, len_bytes)), _data.length))\n                    ptr := add(ptr, len_bytes)\n                    calldatacopy(ptr, _data.offset, _data.length)\n                    ptr := add(ptr, _data.length)\n                }\n            }\n            ptr := store_address(ptr, _sender)\n\n            let payload_len := sub(ptr, start_ptr)\n            let value\n            let value_bytes\n            switch lt(payload_len, 56)\n            case 1 {\n                // the total payload of a list is 0-55 bytes long\n                value := add(0xc0, payload_len)\n                value_bytes := 1\n            }\n            default {\n                // If the total payload of a list is more than 55 bytes long\n                let len_bytes := get_uint_bytes(payload_len)\n                value_bytes := add(len_bytes, 1)\n                value := add(0xf7, len_bytes)\n                value := shl(mul(len_bytes, 8), value)\n                value := or(value, payload_len)\n            }\n            value := or(value, shl(mul(8, value_bytes), transactionType))\n            value_bytes := add(value_bytes, 1)\n            let value_bits := mul(8, value_bytes)\n            value := or(shl(sub(256, value_bits), value), shr(value_bits, mload(start_ptr)))\n            start_ptr := sub(start_ptr, value_bytes)\n            mstore(start_ptr, value)\n            hash := keccak256(start_ptr, sub(ptr, start_ptr))\n        }\n        return hash;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1MessageQueue\n    function appendCrossDomainMessage(\n        address _target,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) external override {\n        require(msg.sender == messenger, \"Only callable by the L1ScrollMessenger\");\n\n        // validate gas limit\n        _validateGasLimit(_gasLimit, _data);\n\n        // do address alias to avoid replay attack in L2.\n        address _sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n\n        _queueTransaction(_sender, _target, 0, _gasLimit, _data);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function appendEnforcedTransaction(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) external override {\n        require(msg.sender == enforcedTxGateway, \"Only callable by the EnforcedTxGateway\");\n        // We will check it in EnforcedTxGateway, just in case.\n        require(_sender.code.length == 0, \"only EOA\");\n\n        // validate gas limit\n        _validateGasLimit(_gasLimit, _data);\n\n        _queueTransaction(_sender, _target, _value, _gasLimit, _data);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function popCrossDomainMessage(\n        uint256 _startIndex,\n        uint256 _count,\n        uint256 _skippedBitmap\n    ) external {\n        require(msg.sender == scrollChain, \"Only callable by the ScrollChain\");\n\n        require(_count <= 256, \"pop too many messages\");\n        require(pendingQueueIndex == _startIndex, \"start index mismatch\");\n\n        unchecked {\n            for (uint256 i = 0; i < _count; i++) {\n                if ((_skippedBitmap >> i) & 1 == 0) {\n                    messageQueue[_startIndex + i] = bytes32(0);\n                }\n            }\n\n            pendingQueueIndex = _startIndex + _count;\n        }\n\n        emit DequeueTransaction(_startIndex, _count, _skippedBitmap);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of gas oracle.\n    /// @dev This function can only called by contract owner.\n    /// @param _newGasOracle The address to update.\n    function updateGasOracle(address _newGasOracle) external onlyOwner {\n        address _oldGasOracle = gasOracle;\n        gasOracle = _newGasOracle;\n\n        emit UpdateGasOracle(_oldGasOracle, _newGasOracle);\n    }\n\n    /// @notice Update the address of EnforcedTxGateway.\n    /// @dev This function can only called by contract owner.\n    /// @param _newGateway The address to update.\n    function updateEnforcedTxGateway(address _newGateway) external onlyOwner {\n        address _oldGateway = enforcedTxGateway;\n        enforcedTxGateway = _newGateway;\n\n        emit UpdateEnforcedTxGateway(_oldGateway, _newGateway);\n    }\n\n    /// @notice Update the max gas limit.\n    /// @dev This function can only called by contract owner.\n    /// @param _newMaxGasLimit The new max gas limit.\n    function updateMaxGasLimit(uint256 _newMaxGasLimit) external onlyOwner {\n        uint256 _oldMaxGasLimit = maxGasLimit;\n        maxGasLimit = _newMaxGasLimit;\n\n        emit UpdateMaxGasLimit(_oldMaxGasLimit, _newMaxGasLimit);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to queue a L1 transaction.\n    /// @param _sender The address of sender who will initiate this transaction in L2.\n    /// @param _target The address of target contract to call in L2.\n    /// @param _value The value passed\n    /// @param _gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param _data The calldata passed to target contract.\n    function _queueTransaction(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) internal {\n        // compute transaction hash\n        uint256 _queueIndex = messageQueue.length;\n        bytes32 _hash = computeTransactionHash(_sender, _queueIndex, _value, _target, _gasLimit, _data);\n        messageQueue.push(_hash);\n\n        // emit event\n        emit QueueTransaction(_sender, _target, _value, _queueIndex, _gasLimit, _data);\n    }\n\n    function _validateGasLimit(uint256 _gasLimit, bytes memory _calldata) internal view {\n        require(_gasLimit <= maxGasLimit, \"Gas limit must not exceed maxGasLimit\");\n        // check if the gas limit is above intrinsic gas\n        uint256 intrinsicGas = calculateIntrinsicGasFee(_calldata);\n        require(_gasLimit >= intrinsicGas, \"Insufficient gas limit, must be above intrinsic gas\");\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/rollup/ScrollChain.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {IL1MessageQueue} from \"./IL1MessageQueue.sol\";\nimport {IScrollChain} from \"./IScrollChain.sol\";\nimport {BatchHeaderV0Codec} from \"../../libraries/codec/BatchHeaderV0Codec.sol\";\nimport {ChunkCodec} from \"../../libraries/codec/ChunkCodec.sol\";\nimport {IRollupVerifier} from \"../../libraries/verifier/IRollupVerifier.sol\";\n\n// solhint-disable reason-string\n\n/// @title ScrollChain\n/// @notice This contract maintains data for the Scroll rollup.\ncontract ScrollChain is OwnableUpgradeable, IScrollChain {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates the status of sequencer.\n    /// @param account The address of account updated.\n    /// @param status The status of the account updated.\n    event UpdateSequencer(address indexed account, bool status);\n\n    /// @notice Emitted when the address of rollup verifier is updated.\n    /// @param oldVerifier The address of old rollup verifier.\n    /// @param newVerifier The address of new rollup verifier.\n    event UpdateVerifier(address oldVerifier, address newVerifier);\n\n    /// @notice Emitted when the value of `maxNumL2TxInChunk` is updated.\n    /// @param oldMaxNumL2TxInChunk The old value of `maxNumL2TxInChunk`.\n    /// @param newMaxNumL2TxInChunk The new value of `maxNumL2TxInChunk`.\n    event UpdateMaxNumL2TxInChunk(uint256 oldMaxNumL2TxInChunk, uint256 newMaxNumL2TxInChunk);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The chain id of the corresponding layer 2 chain.\n    uint256 public immutable layer2ChainId;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The maximum number of transactions allowed in each chunk.\n    uint256 public maxNumL2TxInChunk;\n\n    /// @notice The address of L1MessageQueue.\n    address public messageQueue;\n\n    /// @notice The address of RollupVerifier.\n    address public verifier;\n\n    /// @notice Whether an account is a sequencer.\n    mapping(address => bool) public isSequencer;\n\n    /// @notice The latest finalized batch index.\n    uint256 public lastFinalizedBatchIndex;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override committedBatches;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override finalizedStateRoots;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override withdrawRoots;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier OnlySequencer() {\n        // @note In the decentralized mode, it should be only called by a list of validator.\n        require(isSequencer[msg.sender], \"caller not sequencer\");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(uint256 _chainId) {\n        layer2ChainId = _chainId;\n    }\n\n    function initialize(\n        address _messageQueue,\n        address _verifier,\n        uint256 _maxNumL2TxInChunk\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        messageQueue = _messageQueue;\n        verifier = _verifier;\n        maxNumL2TxInChunk = _maxNumL2TxInChunk;\n\n        emit UpdateVerifier(address(0), _verifier);\n        emit UpdateMaxNumL2TxInChunk(0, _maxNumL2TxInChunk);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IScrollChain\n    function isBatchFinalized(uint256 _batchIndex) external view override returns (bool) {\n        return _batchIndex <= lastFinalizedBatchIndex;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Import layer 2 genesis block\n    /// @dev Although `_withdrawRoot` is always zero, we add this parameter for the convenience of unit testing.\n    function importGenesisBatch(\n        bytes calldata _batchHeader,\n        bytes32 _stateRoot,\n        bytes32 _withdrawRoot\n    ) external {\n        // check genesis batch header length\n        require(_stateRoot != bytes32(0), \"zero state root\");\n\n        // check whether the genesis batch is imported\n        require(finalizedStateRoots[0] == bytes32(0), \"Genesis batch imported\");\n\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        // check all fields except `dataHash` and `lastBlockHash` are zero\n        unchecked {\n            uint256 sum = BatchHeaderV0Codec.version(memPtr) +\n                BatchHeaderV0Codec.batchIndex(memPtr) +\n                BatchHeaderV0Codec.l1MessagePopped(memPtr) +\n                BatchHeaderV0Codec.totalL1MessagePopped(memPtr);\n            require(sum == 0, \"not all fields are zero\");\n        }\n        require(BatchHeaderV0Codec.dataHash(memPtr) != bytes32(0), \"zero data hash\");\n        require(BatchHeaderV0Codec.parentBatchHash(memPtr) == bytes32(0), \"nonzero parent batch hash\");\n\n        committedBatches[0] = _batchHash;\n        finalizedStateRoots[0] = _stateRoot;\n        withdrawRoots[0] = _withdrawRoot;\n\n        emit CommitBatch(_batchHash);\n        emit FinalizeBatch(_batchHash, _stateRoot, _withdrawRoot);\n    }\n\n    /// @inheritdoc IScrollChain\n    function commitBatch(\n        uint8 _version,\n        bytes calldata _parentBatchHeader,\n        bytes[] memory _chunks,\n        bytes calldata _skippedL1MessageBitmap\n    ) external override OnlySequencer {\n        require(_version == 0, \"invalid version\");\n\n        // check whether the batch is empty\n        uint256 _chunksLength = _chunks.length;\n        require(_chunksLength > 0, \"batch is empty\");\n\n        // The overall memory layout in this function is organized as follows\n        // +---------------------+-------------------+------------------+\n        // | parent batch header | chunk data hashes | new batch header |\n        // +---------------------+-------------------+------------------+\n        // ^                     ^                   ^\n        // batchPtr              dataPtr             newBatchPtr (re-use var batchPtr)\n        //\n        // 1. We copy the parent batch header from calldata to memory starting at batchPtr\n        // 2. We store `_chunksLength` number of Keccak hashes starting at `dataPtr`. Each Keccak\n        //    hash corresponds to the data hash of a chunk. So we reserve the memory region from\n        //    `dataPtr` to `da"
    }
  ]
}