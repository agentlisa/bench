{
  "Title": "M-5: stakingContext.auraBooster.deposit boolean return value not handled in Boosted3TokenPoolUtils.sol",
  "Content": "# Issue M-5: stakingContext.auraBooster.deposit boolean return value not handled in Boosted3TokenPoolUtils.sol \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/117 \n\n## Found by \nctf\\_sec\n\n## Summary\n\nstakingContext.auraBooster.deposit boolean return value not handled in Boosted3TokenPoolUtils.sol\n\n## Vulnerability Detail\n\nthe function _joinPoolAndStake in Boosted3TokenPoolUtils.sol is used extensively when handling the token stake.\n\nHowever, when entering the stake and interacting with external contract, the logic does not handle the returned boolean value in the code below\n\n```solidity\n        // Transfer token to Aura protocol for boosted staking\n        stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n```\n\nIn the AuraBooster implmenetation, a Boolean is indeed returned to acknowledge that deposit is completely successfully. \n\nhttps://etherscan.io/address/0x7818A1DA7BD1E64c199029E86Ba244a9798eEE10#code#F34#L1\n\n```solidity\n    /**\n     * @notice  Deposits an \"_amount\" to a given gauge (specified by _pid), mints a `DepositToken`\n     *          and subsequently stakes that on Convex BaseRewardPool\n     */\n    function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){\n```\n\n## Impact\n\nNotional -> AuraBooster -> BaseRewardPool\n\nWithout handling the boolean value explitily, there is risk that transaction may be fail sliently.\n\nBecause there are two layers of external call\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol#L325-L346\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol#L345\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the project handle the stakingContext.auraBooster.deposit boolean return value explicitly.\n\n```solidity\n  // Transfer token to Aura protocol for boosted staking\n    bool staked = stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n    require(staked, 'stake failed');\n``` \n\n## Discussion\n\n**jeffywu**\n\n@weitianjie2000 \n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {\n    ThreeTokenPoolContext,\n    TwoTokenPoolContext,\n    BoostedOracleContext,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"../pool/Boosted3TokenPoolUtils.sol\";\nimport {StableMath} from \"../math/StableMath.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {IBoostedPool} from \"../../../../../interfaces/balancer/IBalancerPool.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TwoTokenPoolUtils} from \"./TwoTokenPoolUtils.sol\";\nimport {FixedPoint} from \"../math/FixedPoint.sol\";\n\nlibrary Boosted3TokenPoolUtils {\n    using TypeConvert for uint256;\n    using FixedPoint for uint256;\n    using TypeConvert for int256;\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using Boosted3TokenPoolUtils for ThreeTokenPoolContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using StrategyUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n\n    // Preminted BPT is sometimes called Phantom BPT, as the preminted BPT (which is deposited in the Vault as balance of\n    // the Pool) doesn't belong to any entity until transferred out of the Pool. The Pool's arithmetic behaves as if it\n    // didn't exist, and the BPT total supply is not a useful value: we rely on the 'virtual supply' (how much BPT is\n    // actually owned by some entity) instead.\n    uint256 private constant _MAX_TOKEN_BALANCE = 2**(112) - 1;\n\n    function _getSpotPrice(\n        uint256 ampParam,\n        uint256 invariant,\n        uint256[] memory balances, \n        uint8 tokenIndexIn, \n        uint8 tokenIndexOut\n    ) private pure returns (uint256 spotPrice) {\n        // Trade 1 unit of tokenIn for tokenOut to get the spot price\n        uint256 amountIn = BalancerConstants.BALANCER_PRECISION;\n        uint256 amountOut = StableMath._calcOutGivenIn({\n            amplificationParameter: ampParam,\n            balances: balances,\n            tokenIndexIn: tokenIndexIn,\n            tokenIndexOut: tokenIndexOut,\n            tokenAmountIn: amountIn,\n            invariant: invariant\n        });\n        spotPrice = amountOut;\n    }\n\n    function _validateSpotPrice(\n        StrategyContext memory context,\n        address tokenIn,\n        uint8 tokenIndexIn,\n        address tokenOut,\n        uint8 tokenIndexOut,\n        uint256[] memory balances,\n        uint256 ampParam,\n        uint256 invariant\n    ) private view {\n        (int256 answer, int256 decimals) = context.tradingModule.getOraclePrice(tokenOut, tokenIn);\n        require(decimals == int256(BalancerConstants.BALANCER_PRECISION));\n        \n        uint256 spotPrice = _getSpotPrice({\n            ampParam: ampParam,\n            invariant: invariant,\n            balances: balances, \n            tokenIndexIn: tokenIndexIn, // Primary index\n            tokenIndexOut: tokenIndexOut // Secondary index\n        }); \n\n        uint256 oraclePrice = answer.toUint();\n        uint256 lowerLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - context.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + context.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        // Check spot price against oracle price to make sure it hasn't been manipulated\n        if (spotPrice < lowerLimit || upperLimit < spotPrice) {\n            revert Errors.InvalidPrice(oraclePrice, spotPrice);\n        }\n    }\n\n    function _validateTokenPrices(\n        ThreeTokenPoolContext memory poolContext, \n        StrategyContext memory strategyContext,\n        uint256[] memory balances,\n        uint256 ampParam,\n        uint256 invariant\n    ) private view {\n        address primaryUnderlying = IBoostedPool(address(poolContext.basePool.primaryToken)).getMainToken();\n        address secondaryUnderlying = IBoostedPool(address(poolContext.basePool.secondaryToken)).getMainToken();\n        address tertiaryUnderlying = IBoostedPool(address(poolContext.tertiaryToken)).getMainToken();\n\n        _validateSpotPrice({\n            context: strategyContext,\n            tokenIn: primaryUnderlying,\n            tokenIndexIn: 0, // primary index\n            tokenOut: secondaryUnderlying,\n            tokenIndexOut: 1, // secondary index\n            balances: balances,\n            ampParam: ampParam,\n            invariant: invariant\n        });\n\n        _validateSpotPrice({\n            context: strategyContext,\n            tokenIn: primaryUnderlying,\n            tokenIndexIn: 0, // primary index\n            tokenOut: tertiaryUnderlying,\n            tokenIndexOut: 2, // secondary index\n            balances: balances,\n            ampParam: ampParam,\n            invariant: invariant\n        });\n    }\n\n    function _getVirtualSupply(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext\n    ) internal pure returns (uint256 virtualSupply) {\n        // The initial amount of BPT pre-minted is _MAX_TOKEN_BALANCE and it goes entirely to the pool balance in the\n        // vault. So the virtualSupply (the actual supply in circulation) is defined as:\n        // virtualSupply = totalSupply() - (_balances[_bptIndex] - _dueProtocolFeeBptAmount)\n        //\n        // However, since this Pool never mints or burns BPT outside of the initial supply (except in the event of an\n        // emergency pause), we can simply use `_MAX_TOKEN_BALANCE` instead of `totalSupply()` and save\n        // gas.\n        virtualSupply = _MAX_TOKEN_BALANCE - oracleContext.bptBalance + oracleContext.dueProtocolFeeBptAmount;\n    }\n\n    function _getVirtualSupplyAndBalances(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext\n    ) private pure returns (uint256 virtualSupply, uint256[] memory amountsWithoutBpt) {\n        virtualSupply = _getVirtualSupply(poolContext, oracleContext);\n\n        amountsWithoutBpt = new uint256[](3);\n        amountsWithoutBpt[0] = poolContext.basePool.primaryBalance;\n        amountsWithoutBpt[1] = poolContext.basePool.secondaryBalance;\n        amountsWithoutBpt[2] = poolContext.tertiaryBalance;\n    }\n\n    function _getValidatedPoolData(\n        ThreeTokenPoolContext memory poolContext,\n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext\n    ) internal view returns (uint256 virtualSupply, uint256[] memory balances, uint256 invariant) {\n        (virtualSupply, balances) = \n            _getVirtualSupplyAndBalances(poolContext, oracleContext);\n\n        // Get the current and new invariants. Since we need a bigger new invariant, we round the current one up.\n        invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, balances, true // roundUp = true\n        );\n\n        // validate spot prices against oracle prices\n        _validateTokenPrices({\n            poolContext: poolContext,\n            strategyContext: strategyContext,\n            balances: balances,\n            ampParam: oracleContext.ampParam,\n            invariant: invariant\n        });\n    }\n\n    /// @notice Gets the time-weighted primary token balance for a given bptAmount\n    /// @dev Boosted pool can't use the Balancer oracle, using Chainlink instead\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param bptAmount amount of balancer pool lp tokens\n    /// @return primaryAmount primary token balance\n    function _getTimeWeightedPrimaryBalance(\n        ThreeTokenPoolContext memory poolContext,\n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 primaryAmount) {\n        (\n           uint256 virtualSupply, \n           uint256[] memory balances, \n           uint256 invariant\n        ) = _getValidatedPoolData(poolContext, oracleContext, strategyContext);\n\n        // NOTE: For Boosted 3 token pools, the LP token (BPT) is just another\n        // token in the pool. So, we first use _calcTokenOutGivenExactBptIn\n        // to calculate the value of 1 BPT. Then, we scale it to the BPT\n        // amount to get the value in terms of the primary currency.\n        // Use virtual total supply and zero swap fees for joins\n        primaryAmount = StableMath._calcTokenOutGivenExactBptIn({\n            amp: oracleContext.ampParam, \n            balances: balances, \n            tokenIndex: 0, \n            bptAmountIn: BalancerConstants.BALANCER_PRECISION, // 1 BPT \n            bptTotalSupply: virtualSupply, \n            swapFeePercentage: 0, \n            currentInvariant: invariant\n        });\n\n        uint256 primaryPrecision = 10 ** poolContext.basePool.primaryDecimals;\n        primaryAmount = (primaryAmount * bptAmount * primaryPrecision) / BalancerConstants.BALANCER_PRECISION_SQUARED;\n    }\n\n    function _approveBalancerTokens(ThreeTokenPoolContext memory poolContext, address bptSpender) internal {\n        poolContext.basePool._approveBalancerTokens(bptSpender);\n\n        IERC20(poolContext.tertiaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n\n        // For boosted pools, the tokens inside pool context are AaveLinearPool tokens.\n        // So, we need to approve the _underlyingToken (primary borrow currency) for trading.\n        IBoostedPool underlyingPool = IBoostedPool(poolContext.basePool.primaryToken);\n        address primaryUnderlyingAddress = BalancerUtils.getTokenAddress(underlyingPool.getMainToken());\n        IERC20(primaryUnderlyingAddress).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n    }\n\n    function _joinPoolExactTokensIn(ThreeTokenPoolContext memory context, uint256 primaryAmount, uint256 minBPT)\n        private returns (uint256 bptAmount) {\n        IBoostedPool underlyingPool = IBoostedPool(address(context.basePool.primaryToken));\n\n        // Swap underlyingToken for LinearPool BPT\n        uint256 linearPoolBPT = BalancerUtils._swapGivenIn({\n            poolId: underlyingPool.getPoolId(),\n            tokenIn: underlyingPool.getMainToken(),\n            tokenOut: address(underlyingPool),\n            amountIn: primaryAmount,\n            limit: 0 // slippage checked on the second swap\n        });\n\n        // Swap LinearPool BPT for Boosted BPT\n        bptAmount = BalancerUtils._swapGivenIn({\n            poolId: context.basePool.basePool.poolId,\n            tokenIn: address(underlyingPool),\n            tokenOut: address(context.basePool.basePool.pool), // Boosted pool\n            amountIn: linearPoolBPT,\n            limit: minBPT\n        });\n    }\n\n    function _exitPoolExactBPTIn(ThreeTokenPoolContext memory context, uint256 bptExitAmount, uint256 minPrimary)\n        private returns (uint256 primaryBalance) {\n        IBoostedPool underlyingPool = IBoostedPool(address(context.basePool.primaryToken));\n\n        // Swap Boosted BPT for LinearPool BPT\n        uint256 linearPoolBPT = BalancerUtils._swapGivenIn({\n            poolId: context.basePool.basePool.poolId,\n            tokenIn: address(context.basePool.basePool.pool), // Boosted pool\n            tokenOut: address(underlyingPool),\n            amountIn: bptExitAmount,\n            limit: 0 // slippage checked on the second swap\n        });\n\n        // Swap LinearPool BPT for underlyingToken\n        primaryBalance = BalancerUtils._swapGivenIn({\n            poolId: underlyingPool.getPoolId(),\n            tokenIn: address(underlyingPool),\n            tokenOut: underlyingPool.getMainToken(),\n            amountIn: linearPoolBPT,\n            limit: minPrimary\n        }); \n    }\n\n    function _deposit(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 deposit,\n        uint256 minBPT\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 bptMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            oracleContext: oracleContext,\n            deposit: deposit,\n            minBPT: minBPT\n        });\n\n        strategyTokensMinted = strategyContext._convertBPTClaimToStrategyTokens(bptMinted);\n\n        // Update global supply count\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _redeem(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 strategyTokens,\n        uint256 minPrimary\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n        if (bptClaim == 0) return 0;\n\n        finalPrimaryBalance = _unstakeAndExitPool({\n            stakingContext: stakingContext,\n            poolContext: poolContext,\n            bptClaim: bptClaim,\n            minPrimary: minPrimary\n        });\n\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _joinPoolAndStake(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 deposit,\n        uint256 minBPT\n    ) internal returns (uint256 bptMinted) {\n        bptMinted = _joinPoolExactTokensIn(poolContext, deposit, minBPT);\n\n        // Check BPT threshold to make sure our share of the pool is\n        // below maxBalancerPoolShare\n        uint256 bptThreshold = strategyContext.vaultSettings._bptThreshold(\n            poolContext._getVirtualSupply(oracleContext)\n        );\n        uint256 bptHeldAfterJoin = strategyContext.totalBPTHeld + bptMinted;\n        if (bptHeldAfterJoin > bptThreshold)\n            revert Errors.BalancerPoolShareTooHigh(bptHeldAfterJoin, bptThreshold);\n\n        // Transfer token to Aura protocol for boosted staking\n        stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n    }\n\n    function _unstakeAndExitPool(\n        ThreeTokenPoolContext memory poolContext,\n        AuraStakingContext memory stakingContext,\n        uint256 bptClaim,\n        uint256 minPrimary\n    ) internal returns (uint256 primaryBalance) {\n        // Withdraw BPT tokens back to the vault for redemption\n        stakingContext.auraRewardPool.withdrawAndUnwrap(bptClaim, false); // claimRewards = false\n\n        primaryBalance = _exitPoolExactBPTIn(poolContext, bptClaim, minPrimary);    \n    }\n\n    /// @notice We value strategy tokens in terms of the primary balance. The time weighted\n    /// primary balance is used in order to prevent pool manipulation.\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param strategyTokenAmount amount of strategy tokens\n    /// @return underlyingValue underlying value of strategy tokens\n    function _convertStrategyToUnderlying(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 strategyTokenAmount\n    ) internal view returns (int256 underlyingValue) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokenAmount);\n        \n        underlyingValue = poolContext._getTimeWeightedPrimaryBalance(\n            oracleContext, strategyContext, bptClaim\n        ).toInt();\n    }\n\n    function _getMinBPT(\n        ThreeTokenPoolContext calldata poolContext,\n        BoostedOracleContext calldata oracleContext,\n        StrategyContext calldata strategyContext,\n        uint256 primaryAmount\n    ) internal view returns (uint256 minBPT) {\n        // Calculate minBPT to minimize slippage\n        (\n            uint256 virtualSupply, \n            uint256[] memory balances, \n            uint256 invariant\n        ) = poolContext._getValidatedPoolData(oracleContext, strategyContext);\n\n        uint256[] memory amountsIn = new uint256[](3);\n        // _getValidatedPoolData rearranges the balances so that primary is always in the\n        // zero index spot\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.basePool.primaryDecimals;\n        amountsIn[0] = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n\n        minBPT = StableMath._calcBptOutGivenExactTokensIn({\n            amp: oracleContext.ampParam,\n            balances: balances,\n            amountsIn: amountsIn,\n            bptTotalSupply: virtualSupply,\n            swapFeePercentage: 0,\n            currentInvariant: invariant\n        });\n\n        uint256 swapFeePercentage = IBoostedPool(address(poolContext.basePool.basePool.pool))\n            .getCachedProtocolSwapFeePercentage();\n\n        if (swapFeePercentage > 0) {\n            minBPT -= _getDueProtocolFeeByBpt(minBPT, swapFeePercentage);\n        }\n\n        minBPT = minBPT * strategyContext.vaultSettings.balancerPoolSlippageLimitPercent / \n            uint256(BalancerConstants.VAULT_PERCENT_BASIS);\n    }\n\n    function _addSwapFeeAmount(uint256 amount, uint256 protocolSwapFeePercentage) private view returns (uint256) {\n        // This returns amount + fee amount, so we round up (favoring a higher fee amount).\n        return amount.divUp(FixedPoint.ONE.sub(protocolSwapFeePercentage));\n    }\n\n    function _getDueProtocolFeeByBpt(\n        uint256 bptAmount,\n        uint256 protocolSwapFeePercentage\n    ) private view returns (uint256) {\n        uint256 feeAmount = _addSwapFeeAmount(bptAmount, protocolSwapFeePercentage).sub(bptAmount);\n\n        uint256 protocolFeeAmount = feeAmount.mulDown(protocolSwapFeePercentage);\n        return protocolFeeAmount;\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {\n    ThreeTokenPoolContext,\n    TwoTokenPoolContext,\n    BoostedOracleContext,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"../pool/Boosted3TokenPoolUtils.sol\";\nimport {StableMath} from \"../math/StableMath.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {IBoostedPool} from \"../../../../../interfaces/balancer/IBalancerPool.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TwoTokenPoolUtils} from \"./TwoTokenPoolUtils.sol\";\nimport {FixedPoint} from \"../math/FixedPoint.sol\";\n\nlibrary Boosted3TokenPoolUtils {\n    using TypeConvert for uint256;\n    using FixedPoint for uint256;\n    using TypeConvert for int256;\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using Boosted3TokenPoolUtils for ThreeTokenPoolContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using StrategyUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n\n    // Preminted BPT is sometimes called Phantom BPT, as the preminted BPT (which is deposited in the Vault as balance of\n    // the Pool) doesn't belong to any entity until transferred out of the Pool. The Pool's arithmetic behaves as if it\n    // didn't exist, and the BPT total supply is not a useful value: we rely on the 'virtual supply' (how much BPT is\n    // actually owned by some entity) instead.\n    uint256 private constant _MAX_TOKEN_BALANCE = 2**(112) - 1;\n\n    function _getSpotPrice(\n        uint256 ampParam,\n        uint256 invariant,\n        uint256[] memory balances, \n        uint8 tokenIndexIn, \n        uint8 tokenIndexOut\n    ) private pure returns (uint256 spotPrice) {\n        // Trade 1 unit of tokenIn for tokenOut to get the spot price\n        uint256 amountIn = BalancerConstants.BALANCER_PRECISION;\n        uint256 amountOut = StableMath._calcOutGivenIn({\n            amplificationParameter: ampParam,\n            balances: balances,\n            tokenIndexIn: tokenIndexIn,\n            tokenIndexOut: tokenIndexOut,\n            tokenAmountIn: amountIn,\n            invariant: invariant\n        });\n        spotPrice = amountOut;\n    }\n\n    function _validateSpotPrice(\n        StrategyContext memory context,\n        address tokenIn,\n        uint8 tokenIndexIn,\n        address tokenOut,\n        uint8 tokenIndexOut,\n        uint256[] memory balances,\n        uint256 ampParam,\n        uint256 invariant\n    ) private view {\n        (int256 answer, int256 decimals) = context.tradingModule.getOraclePrice(tokenOut, tokenIn);\n        require(decimals == int256(BalancerConstants.BALANCER_PRECISION));\n        \n        uint256 spotPrice = _getSpotPrice({\n            ampParam: ampParam,\n            invariant: invariant,\n            balances: balances, \n            tokenIndexIn: tokenIndexIn, // Primary index\n            tokenIndexOut: tokenIndexOut // Secondary index\n        }); \n\n        uint256 oraclePrice = answer.toUint();\n        uint256 lowerLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - context.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + context.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        // Check spot price against oracle price to make sure it hasn't been manipulated\n        if (spotPrice < lowerLimit || upperLimit < spotPrice) {\n            revert Errors.InvalidPrice(oraclePrice, spotPrice);\n        }\n    }\n\n    function _validateTokenPrices(\n        ThreeTokenPoolContext memory poolContext, \n        StrategyContext memory strategyContext,\n        uint256[] memory balances,\n        uint256 ampParam,\n        uint256 invariant\n    ) private view {\n        address primaryUnderlying = IBoostedPool(address(poolContext.basePool.primaryToken)).getMainToken();\n        address secondaryUnderlying = IBoostedPool(address(poolContext.basePool.secondaryToken)).getMainToken();\n        address tertiaryUnderlying = IBoostedPool(address(poolContext.tertiaryToken)).getMainToken();\n\n        _validateSpotPrice({\n            context: strategyContext,\n            tokenIn: primaryUnderlying,\n            tokenIndexIn: 0, // primary index\n            tokenOut: secondaryUnderlying,\n            tokenIndexOut: 1, // secondary index\n            balances: balances,\n            ampParam: ampParam,\n            invariant: invariant\n        });\n\n        _validateSpotPrice({\n            context: strategyContext,\n            tokenIn: primaryUnderlying,\n            tokenIndexIn: 0, // primary index\n            tokenOut: tertiaryUnderlying,\n            tokenIndexOut: 2, // secondary index\n            balances: balances,\n            ampParam: ampParam,\n            invariant: invariant\n        });\n    }\n\n    function _getVirtualSupply(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext\n    ) internal pure returns (uint256 virtualSupply) {\n        // The initial amount of BPT pre-minted is _MAX_TOKEN_BALANCE and it goes entirely to the pool balance in the\n        // vault. So the virtualSupply (the actual supply in circulation) is defined as:\n        // virtualSupply = totalSupply() - (_balances[_bptIndex] - _dueProtocolFeeBptAmount)\n        //\n        // However, since this Pool never mints or burns BPT outside of the initial supply (except in the event of an\n        // emergency pause), we can simply use `_MAX_TOKEN_BALANCE` instead of `totalSupply()` and save\n        // gas.\n        virtualSupply = _MAX_TOKEN_BALANCE - oracleContext.bptBalance + oracleContext.dueProtocolFeeBptAmount;\n    }\n\n    function _getVirtualSupplyAndBalances(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext\n    ) private pure returns (uint256 virtualSupply, uint256[] memory amountsWithoutBpt) {\n        virtualSupply = _getVirtualSupply(poolContext, oracleContext);\n\n        amountsWithoutBpt = new uint256[](3);\n        amountsWithoutBpt[0] = poolContext.basePool.primaryBalance;\n        amountsWithoutBpt[1] = poolContext.basePool.secondaryBalance;\n        amountsWithoutBpt[2] = poolContext.tertiaryBalance;\n    }\n\n    function _getValidatedPoolData(\n        ThreeTokenPoolContext memory poolContext,\n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext\n    ) internal view returns (uint256 virtualSupply, uint256[] memory balances, uint256 invariant) {\n        (virtualSupply, balances) = \n            _getVirtualSupplyAndBalances(poolContext, oracleContext);\n\n        // Get the current and new invariants. Since we need a bigger new invariant, we round the current one up.\n        invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, balances, true // roundUp = true\n        );\n\n        // validate spot prices against oracle prices\n        _validateTokenPrices({\n            poolContext: poolContext,\n            strategyContext: strategyContext,\n            balances: balances,\n            ampParam: oracleContext.ampParam,\n            invariant: invariant\n        });\n    }\n\n    /// @notice Gets the time-weighted primary token balance for a given bptAmount\n    /// @dev Boosted pool can't use the Balancer oracle, using Chainlink instead\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param bptAmount amount of balancer pool lp tokens\n    /// @return primaryAmount primary token balance\n    function _getTimeWeightedPrimaryBalance(\n        ThreeTokenPoolContext memory poolContext,\n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 primaryAmount) {\n        (\n           uint256 virtualSupply, \n           uint256[] memory balances, \n           uint256 invariant\n        ) = _getValidatedPoolData(poolContext, oracleContext, strategyContext);\n\n        // NOTE: For Boosted 3 token pools, the LP token (BPT) is just another\n        // token in the pool. So, we first use _calcTokenOutGivenExactBptIn\n        // to calculate the value of 1 BPT. Then, we scale it to the BPT\n        // amount to get the value in terms of the primary currency.\n        // Use virtual total supply and zero swap fees for joins\n        primaryAmount = StableMath._calcTokenOutGivenExactBptIn({\n            amp: oracleContext.ampParam, \n            balances: balances, \n            tokenIndex: 0, \n            bptAmountIn: BalancerConstants.BALANCER_PRECISION, // 1 BPT \n            bptTotalSupply: virtualSupply, \n            swapFeePercentage: 0, \n            currentInvariant: invariant\n        });\n\n        uint256 primaryPrecision = 10 ** poolContext.basePool.primaryDecimals;\n        primaryAmount = (primaryAmount * bptAmount * primaryPrecision) / BalancerConstants.BALANCER_PRECISION_SQUARED;\n    }\n\n    function _approveBalancerTokens(ThreeTokenPoolContext memory poolContext, address bptSpender) internal {\n        poolContext.basePool._approveBalancerTokens(bptSpender);\n\n        IERC20(poolContext.tertiaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n\n        // For boosted pools, the tokens inside pool context are AaveLinearPool tokens.\n        // So, we need to approve the _underlyingToken (primary borrow currency) for trading.\n        IBoostedPool underlyingPool = IBoostedPool(poolContext.basePool.primaryToken);\n        address primaryUnderlyingAddress = BalancerUtils.getTokenAddress(underlyingPool.getMainToken());\n        IERC20(primaryUnderlyingAddress).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n    }\n\n    function _joinPoolExactTokensIn(ThreeTokenPoolContext memory context, uint256 primaryAmount, uint256 minBPT)\n        private returns (uint256 bptAmount) {\n        IBoostedPool underlyingPool = IBoostedPool(address(context.basePool.primaryToken));\n\n        // Swap underlyingToken for LinearPool BPT\n        uint256 linearPoolBPT = BalancerUtils._swapGivenIn({\n            poolId: underlyingPool.getPoolId(),\n            tokenIn: underlyingPool.getMainToken(),\n            tokenOut: address(underlyingPool),\n            amountIn: primaryAmount,\n            limit: 0 // slippage checked on the second swap\n        });\n\n        // Swap LinearPool BPT for Boosted BPT\n        bptAmount = BalancerUtils._swapGivenIn({\n            poolId: context.basePool.basePool.poolId,\n            tokenIn: address(underlyingPool),\n            tokenOut: address(context.basePool.basePool.pool), // Boosted pool\n            amountIn: linearPoolBPT,\n            limit: minBPT\n        });\n    }\n\n    function _exitPoolExactBPTIn(ThreeTokenPoolContext memory context, uint256 bptExitAmount, uint256 minPrimary)\n        private returns (uint256 primaryBalance) {\n        IBoostedPool underlyingPool = IBoostedPool(address(context.basePool.primaryToken));\n\n        // Swap Boosted BPT for LinearPool BPT\n        uint256 linearPoolBPT = BalancerUtils._swapGivenIn({\n            poolId: context.basePool.basePool.poolId,\n            tokenIn: address(context.basePool.basePool.pool), // Boosted pool\n            tokenOut: address(underlyingPool),\n            amountIn: bptExitAmount,\n            limit: 0 // slippage checked on the second swap\n        });\n\n        // Swap LinearPool BPT for underlyingToken\n        primaryBalance = BalancerUtils._swapGivenIn({\n            poolId: underlyingPool.getPoolId(),\n            tokenIn: address(underlyingPool),\n            tokenOut: underlyingPool.getMainToken(),\n            amountIn: linearPoolBPT,\n            limit: minPrimary\n        }); \n    }\n\n    function _deposit(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 deposit,\n        uint256 minBPT\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 bptMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            oracleContext: oracleContext,\n            deposit: deposit,\n            minBPT: minBPT\n        });\n\n        strategyTokensMinted = strategyContext._convertBPTClaimToStrategyTokens(bptMinted);\n\n        // Update global supply count\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _redeem(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 s"
    }
  ]
}