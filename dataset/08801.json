{
  "Title": "[M-07] Current implementation of arbitrary call execute failure handler may break some use case for example NFT bridge.",
  "Content": "_Submitted by Chom_\n\n[Executor.sol#L113-L192](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/helpers/Executor.sol#L113-L192)<br>\n[Executor.sol#L194-L213](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/helpers/Executor.sol#L194-L213)<br>\n\nCurrent implementation of arbitrary call execute failure handler may break some use case for example NFT Bridge.\n\nIn the case of NFT Bridge, NFT may be lost forever.\n\nThis is likely to be happened in the case of out of gas.\n\n### Proof of Concept\n\nRelayer receive the message to unlock BAYC on ETH chain. Relayer call execute on BridgeFacet which then call execute in Executor internally. Continue to these lines:\n\n        // Ensure there is enough gas to handle failures\n        uint256 gas = gasleft() - FAILURE_GAS;\n\n        // Try to execute the callData\n        // the low level call will return `false` if its execution reverts\n        (success, returnData) = ExcessivelySafeCall.excessivelySafeCall(\n          _args.to,\n          gas,\n          isNative ? _args.amount : 0,\n          MAX_COPY,\n          _args.callData\n        );\n\n        // Unset properties\n        properties = LibCrossDomainProperty.EMPTY_BYTES;\n\n        // Unset amount\n        amnt = 0;\n\n        // Handle failure cases\n        if (!success) {\n          _handleFailure(isNative, true, _args.assetId, payable(_args.to), payable(_args.recovery), _args.amount);\n        }\n\nUnfortunately, an enormous NFT project has just started minting their NFT when the relayer perform the execution. Causing gas price to increase by 20x.\n\nAs a result, gasLimit is 20x lesser than what we have calculated causing ExcessivelySafeCall.excessivelySafeCall to fail because of out of gas. We fall into \\_handleFailure function. **Notice that NFT is not unlocked yet because target contract has failed to being executed.**\n\n      function _handleFailure(\n        bool isNative,\n        bool hasIncreased,\n        address _assetId,\n        address payable _to,\n        address payable _recovery,\n        uint256 _amount\n      ) private {\n        if (!isNative) {\n          // Decrease allowance\n          if (hasIncreased) {\n            SafeERC20Upgradeable.safeDecreaseAllowance(IERC20Upgradeable(_assetId), _to, _amount);\n          }\n          // Transfer funds\n          SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(_assetId), _recovery, _amount);\n        } else {\n          // Transfer funds\n          AddressUpgradeable.sendValue(_recovery, _amount);\n        }\n      }\n\n`_handleFailure` just sent dummy fund in the NFT bridge process to the useless fallback address (Useless in NFT bridge case as it doesn't involve any cross chain swapping / token transferring).\n\nFinally, transferId will be marked as used (or reconciled). This transferId cannot be used anymore.\n\n**Recall that BAYC hasn't been unlocked yet as target contract has failed to being executed.**\n\n**And we cannot reuse this transferId to retry anymore in the future as it is marked as used**\n\n**As a result, BAYC is locked forever as target contract call never success anymore since transferId has been marked as used**\n\n### Recommended Mitigation Steps\n\nYou should mix axelar style and connext style of error handling together.\n\nFund shouldn't be sent to fallback address immediately. Instead, leave an option for user to choose whether they want to recall the failed transaction manually or they want to transfer the fund to the fallback address.\n\n**[LayneHaber (Connext) acknowledged and commented](https://github.com/code-423n4/2022-06-connext-findings/issues/223#issuecomment-1167462428):**\n > Acknowledge that this should be an issue, but think that the UX of having to submit multiple destination chain transactions is not great (and causes problems with fees / assuming the user has gas on the destination domain). I think this type of thing needs to be handled by the integrator themselves\n\n**[Chom (warden) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/223#issuecomment-1211520594):**\n > I have reviewed this once again and found another case that current implementation of arbitrary call execute failure handler may break some use case for example NFT bridge.\n> \n> The idea for this to happen is simply do anything to set `success` to false. If NFT is failed to mint on the destination chain and  revert (Likely due to bug in the contract), it cause the same consequence.\n> \n> It would be better to revert and allow it to be executed again in the future by **simply revert in case of arbitrary call failed**. If the destination contract is upgradable, it can be fixed but if not it is out of luck. But current implementation is out of luck in all case.\n> \n> Anyway, the sudden gas price increase problem can't be handled accurately as its may happened very fast. (5 gwei 2 minutes ago, 50 gwei when the NFT unlock as a big NFT project is minting). No one will spare that much gas while locking NFT in the source chain 2 minutes ago.\n\n**[0xleastwood (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-connext-findings/issues/223#issuecomment-1213575364):**\n > Gas limit does not change deterministically. If you make a call which provides X amount of gas at Y price, if gas price changes, it will not affect any pending calls. The issue only arises if the relayer intentionally provides insufficient gas at any price.\n>\n > The recovery address is configured when the bridge transfer is initiated, if this or the executed calldata fails to be used correctly, I think the onus is on the sender. However, there are some legitimate concerns of a bridge relayer intentionally making the callback fail. Because funds aren't at direct risk, `medium` severity would make more sense.\n\n**[Chom (warden) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/223#issuecomment-1217478867):**\n > The recovery address only recover ERC20 tokens managed by the Connext bridge system. Other custom made bridging solution that utilize the arbitrary message passing never utilize that recovery address passed.\n> \n> ### Example\n> For example, if A lock \"multiple BAYC NFT\" on the Ethereum chain along with 1 WETH sent into Connext Amarok. On the destination chain, if executed calldata fails or gas limit is miscalculated (both intentionally and non-intentionally in case ether.js returns too low gas limit, it has happened many times on the complex contracts in 2021 not sure it is fixed or not), only 1 WETH is sent to the recovery address and not \"multiple BAYC NFT\". \"Multiple BAYC NFT\" will be locked on the Ethereum chain indefinitely without any chance to unlock or recovery it in the source chain. So, funds which are \"multiple BAYC NFT\" are at direct risk. BAYC floor price is currently more than 70 ETH. If 3 BAYC lost due to a single error, total 200+ ETH will be lost.\n> \n> Here is an example case that might become common if NFT is not out of hyped but sadly the hype in NFT is currently down. It is \"NFT buying frontrunning\" problem.\n> \n> ![NFT buying frontrunning case](https://user-images.githubusercontent.com/4103490/185040980-5564fa35-00ac-4d00-8d0a-19532f81d658.png)\n> \n> Since Connext bridge requires 2-3 minutes between that times somebody may frontrun buying NFT without using bridge. Then the execution will be fail since NFT has been sold to buyer B. It only refund 10 ETH but not 3 NFT sent.\n> \n> ### Mitigation\n> 1. Simply revert in case of arbitrary call failed.\n> 2. Provide a way for user to cancel the execution, get ERC20 refund into the recovery address and acknowledge contract in the source chain that the bridge is failed to claim back NFT.\n> 3. Force all developers that are using your product to use Upgradeable contract on both source and destination chain to handle cases manually in case something went wrong (Not possible to force everyone).\n> \n> Perfect mitigation is not found yet. There is an ongoing debate about this one at [code-423n4/2022-07-axelar-findings#97](https://github.com/code-423n4/2022-07-axelar-findings/issues/97).\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/223#issuecomment-1217788548):**\n > Fully agree with your take on this. But I still stand by my decision on keeping this as a `medium` risk issue. Mainly because funds are not at direct risk and when they are at risk, certain assumptions must be made for this to hold true. Again, the onus seems to be on the implementer's end.\n> \n> The important thing is to not integrate with Connext with the guarantee that calldata will be successfully executed on the destination contract. This should be clearly documented and I think allowing the bridge user to re-execute calldata upon failure is a potentially useful suggestion, but this doesn't come with its pitfalls too. Added complexity could expand Connext's attack surface. \n>\n > In response to your proposed mitigation(s):\n>  1. This would impact the liveness of bridge transfers. We do not want to allow funds to get stuck due to a reliance on external requirements.\n>  2. While this is a potential solution, I don't think Connext needs to make changes to accommodate this behaviour. The destination contract can check if the calldata was successfully executed and handle this on their end. Seaport already allows for custom behaviour.\n>  3. Again, this would not require Connext to make any changes.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-06-connext",
  "Code": [
    {
      "filename": "contracts/contracts/core/connext/helpers/Executor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n// import {ExcessivelySafeCall} from \"@nomad-xyz/excessively-safe-call/src/ExcessivelySafeCall.sol\";\n// TODO: see note in below file re: npm\nimport {ExcessivelySafeCall} from \"../../../nomad-core/libs/ExcessivelySafeCall.sol\";\n\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\n\nimport {LibCrossDomainProperty, TypedMemView} from \"../libraries/LibCrossDomainProperty.sol\";\n\n/**\n * @title Executor\n * @author Connext <support@connext.network>\n * @notice This library contains an `execute` function that is callabale by\n * an associated Connext contract. This is used to execute\n * arbitrary calldata on a receiving chain.\n */\ncontract Executor is IExecutor {\n  // ============ Libraries =============\n\n  using TypedMemView for bytes29;\n  using TypedMemView for bytes;\n\n  // ============ Properties =============\n\n  address private immutable connext;\n  bytes private properties = LibCrossDomainProperty.EMPTY_BYTES;\n  uint256 private amnt;\n\n  /**\n   * @notice The amount of gas needed to execute _handleFailure\n   * @dev Used to calculate the amount of gas to reserve from transaction\n   * to properly handle failure cases\n   */\n  uint256 public FAILURE_GAS = 100_000; // Allowance decrease + transfer\n\n  /**\n   * @notice The maximum number of bytes to store in the return data\n   */\n  uint16 public MAX_COPY = 256;\n\n  // ============ Constructor =============\n\n  constructor(address _connext) {\n    connext = _connext;\n  }\n\n  // ============ Modifiers =============\n\n  /**\n   * @notice Errors if the sender is not Connext\n   */\n  modifier onlyConnext() {\n    require(msg.sender == connext, \"#OC:027\");\n    _;\n  }\n\n  // ============ Public Functions =============\n\n  /**\n   * @notice Returns the connext contract address (only address that can\n   * call the `execute` function)\n   * @return The address of the associated connext contract\n   */\n  function getConnext() external view override returns (address) {\n    return connext;\n  }\n\n  /**\n   * @notice Allows a `_to` contract to access origin domain sender (i.e. msg.sender of `xcall`)\n   * @dev These properties are set via reentrancy a la L2CrossDomainMessenger from\n   * optimism\n   */\n  function originSender() external view override returns (address) {\n    // The following will revert if it is empty\n    bytes29 _parsed = LibCrossDomainProperty.parseDomainAndSenderBytes(properties);\n    return LibCrossDomainProperty.sender(_parsed);\n  }\n\n  /**\n   * @notice Allows a `_to` contract to access origin domain (i.e. domain of `xcall`)\n   * @dev These properties are set via reentrancy a la L2CrossDomainMessenger from\n   * optimism\n   */\n  function origin() external view override returns (uint32) {\n    // The following will revert if it is empty\n    bytes29 _parsed = LibCrossDomainProperty.parseDomainAndSenderBytes(properties);\n    return LibCrossDomainProperty.domain(_parsed);\n  }\n\n  /**\n   * @notice Allows a `_to` contract to access the amount that was delivered from the\n   * bridge. This is also set during reentrancy, but is set during fast *and* slow\n   * liquidity paths\n   * @dev These properties are set via reentrancy a la L2CrossDomainMessenger from\n   * optimism\n   */\n  function amount() external view override returns (uint256) {\n    return amnt;\n  }\n\n  /**\n   * @notice Executes some arbitrary call data on a given address. The\n   * call data executes can be payable, and will have `amount` sent\n   * along with the function (or approved to the contract). If the\n   * call fails, rather than reverting, funds are sent directly to\n   * some provided fallback address\n   * @param _args ExecutorArgs to function.\n   */\n  function execute(ExecutorArgs memory _args) external payable override onlyConnext returns (bool, bytes memory) {\n    // Check if the callTo is a contract\n    bool success;\n    bytes memory returnData;\n\n    bool isNative = _args.assetId == address(0);\n\n    if (!AddressUpgradeable.isContract(_args.to)) {\n      _handleFailure(isNative, false, _args.assetId, payable(_args.to), payable(_args.recovery), _args.amount);\n      // Emit event\n      emit Executed(\n        _args.transferId,\n        _args.to,\n        _args.recovery,\n        _args.assetId,\n        _args.amount,\n        _args.properties,\n        _args.callData,\n        returnData,\n        success\n      );\n      return (success, returnData);\n    }\n\n    // If it is not ether, approve the callTo\n    // We approve here rather than transfer since many external contracts\n    // simply require an approval, and it is unclear if they can handle\n    // funds transferred directly to them (i.e. Uniswap)\n\n    if (!isNative) {\n      SafeERC20Upgradeable.safeIncreaseAllowance(IERC20Upgradeable(_args.assetId), _args.to, _args.amount);\n    }\n\n    // If it should set the properties, set them.\n    // NOTE: safe to set the properties always because modifier will revert if\n    // it is the wrong type on conversion, and revert occurs with empty type as\n    // well\n    properties = _args.properties;\n\n    // Set the amount as well\n    amnt = _args.amount;\n\n    // Ensure there is enough gas to handle failures\n    uint256 gas = gasleft() - FAILURE_GAS;\n\n    // Try to execute the callData\n    // the low level call will return `false` if its execution reverts\n    (success, returnData) = ExcessivelySafeCall.excessivelySafeCall(\n      _args.to,\n      gas,\n      isNative ? _args.amount : 0,\n      MAX_COPY,\n      _args.callData\n    );\n\n    // Unset properties\n    properties = LibCrossDomainProperty.EMPTY_BYTES;\n\n    // Unset amount\n    amnt = 0;\n\n    // Handle failure cases\n    if (!success) {\n      _handleFailure(isNative, true, _args.assetId, payable(_args.to), payable(_args.recovery), _args.amount);\n    }\n\n    // Emit event\n    emit Executed(\n      _args.transferId,\n      _args.to,\n      _args.recovery,\n      _args.assetId,\n      _args.amount,\n      _args.properties,\n      _args.callData,\n      returnData,\n      success\n    );\n    return (success, returnData);\n  }\n\n  function _handleFailure(\n    bool isNative,\n    bool hasIncreased,\n    address _assetId,\n    address payable _to,\n    address payable _recovery,\n    uint256 _amount\n  ) private {\n    if (!isNative) {\n      // Decrease allowance\n      if (hasIncreased) {\n        SafeERC20Upgradeable.safeDecreaseAllowance(IERC20Upgradeable(_assetId), _to, _amount);\n      }\n      // Transfer funds\n      SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(_assetId), _recovery, _amount);\n    } else {\n      // Transfer funds\n      AddressUpgradeable.sendValue(_recovery, _amount);\n    }\n  }\n}"
    },
    {
      "filename": "contracts/contracts/core/connext/helpers/Executor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n// import {ExcessivelySafeCall} from \"@nomad-xyz/excessively-safe-call/src/ExcessivelySafeCall.sol\";\n// TODO: see note in below file re: npm\nimport {ExcessivelySafeCall} from \"../../../nomad-core/libs/ExcessivelySafeCall.sol\";\n\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\n\nimport {LibCrossDomainProperty, TypedMemView} from \"../libraries/LibCrossDomainProperty.sol\";\n\n/**\n * @title Executor\n * @author Connext <support@connext.network>\n * @notice This library contains an `execute` function that is callabale by\n * an associated Connext contract. This is used to execute\n * arbitrary calldata on a receiving chain.\n */\ncontract Executor is IExecutor {\n  // ============ Libraries =============\n\n  using TypedMemView for bytes29;\n  using TypedMemView for bytes;\n\n  // ============ Properties =============\n\n  address private immutable connext;\n  bytes private properties = LibCrossDomainProperty.EMPTY_BYTES;\n  uint256 private amnt;\n\n  /**\n   * @notice The amount of gas needed to execute _handleFailure\n   * @dev Used to calculate the amount of gas to reserve from transaction\n   * to properly handle failure cases\n   */\n  uint256 public FAILURE_GAS = 100_000; // Allowance decrease + transfer\n\n  /**\n   * @notice The maximum number of bytes to store in the return data\n   */\n  uint16 public MAX_COPY = 256;\n\n  // ============ Constructor =============\n\n  constructor(address _connext) {\n    connext = _connext;\n  }\n\n  // ============ Modifiers =============\n\n  /**\n   * @notice Errors if the sender is not Connext\n   */\n  modifier onlyConnext() {\n    require(msg.sender == connext, \"#OC:027\");\n    _;\n  }\n\n  // ============ Public Functions =============\n\n  /**\n   * @notice Returns the connext contract address (only address that can\n   * call the `execute` function)\n   * @return The address of the associated connext contract\n   */\n  function getConnext() external view override returns (address) {\n    return connext;\n  }\n\n  /**\n   * @notice Allows a `_to` contract to access origin domain sender (i.e. msg.sender of `xcall`)\n   * @dev These properties are set via reentrancy a la L2CrossDomainMessenger from\n   * optimism\n   */\n  function originSender() external view override returns (address) {\n    // The following will revert if it is empty\n    bytes29 _parsed = LibCrossDomainProperty.parseDomainAndSenderBytes(properties);\n    return LibCrossDomainProperty.sender(_parsed);\n  }\n\n  /**\n   * @notice Allows a `_to` contract to access origin domain (i.e. domain of `xcall`)\n   * @dev These properties are set via reentrancy a la L2CrossDomainMessenger from\n   * optimism\n   */\n  function origin() external view override returns (uint32) {\n    // The following will revert if it is empty\n    bytes29 _parsed = LibCrossDomainProperty.parseDomainAndSenderBytes(properties);\n    return LibCrossDomainProperty.domain(_parsed);\n  }\n\n  /**\n   * @notice Allows a `_to` contract to access the amount that was delivered from the\n   * bridge. This is also set during reentrancy, but is set during fast *and* slow\n   * liquidity paths\n   * @dev These properties are set via reentrancy a la L2CrossDomainMessenger from\n   * optimism\n   */\n  function amount() external view override returns (uint256) {\n    return amnt;\n  }\n\n  /**\n   * @notice Executes some arbitrary call data on a given address. The\n   * call data executes can be payable, and will have `amount` sent\n   * along with the function (or approved to the contract). If the\n   * call fails, rather than reverting, funds are sent directly to\n   * some provided fallback address\n   * @param _args ExecutorArgs to function.\n   */\n  function execute(ExecutorArgs memory _args) external payable override onlyConnext returns (bool, bytes memory) {\n    // Check if the callTo is a contract\n    bool success;\n    bytes memory returnData;\n\n    bool isNative = _args.assetId == address(0);\n\n    if (!AddressUpgradeable.isContract(_args.to)) {\n      _handleFailure(isNative, false, _args.assetId, payable(_args.to), payable(_args.recovery), _args.amount);\n      // Emit event\n      emit Executed(\n        _args.transferId,\n        _args.to,\n        _args.recovery,\n        _args.assetId,\n        _args.amount,\n        _args.properties,\n        _args.callData,\n        returnData,\n        success\n      );\n      return (success, returnData);\n    }\n\n    // If it is not ether, approve the callTo\n    // We approve here rather than transfer since many external contracts\n    // simply require an approval, and it is unclear if they can handle\n    // funds transferred directly to them (i.e. Uniswap)\n\n    if (!isNative) {\n      SafeERC20Upgradeable.safeIncreaseAllowance(IERC20Upgradeable(_args.assetId), _args.to, _args.amount);\n    }\n\n    // If it should set the properties, set them.\n    // NOTE: safe to set the properties always because modifier will revert if\n    // it is the wrong type on conversion, and revert occurs with empty type as\n    // well\n    properties = _args.properties;\n\n    // Set the amount as well\n    amnt = _args.amount;\n\n    // Ensure there is enough gas to handle failures\n    uint256 gas = gasleft() - FAILURE_GAS;\n\n    // Try to execute the callData\n    // the low level call will return `false` if its execution reverts\n    (success, returnData) = ExcessivelySafeCall.excessivelySafeCall(\n      _args.to,\n      gas,\n      isNative ? _args.amount : 0,\n      MAX_COPY,\n      _args.callData\n    );\n\n    // Unset properties\n    properties = LibCrossDomainProperty.EMPTY_BYTES;\n\n    // Unset amount\n    amnt = 0;\n\n    // Handle failure cases\n    if (!success) {\n      _handleFailure(isNative, true, _args.assetId, payable(_args.to), payable(_args.recovery), _args.amount);\n    }\n\n    // Emit event\n    emit Executed(\n      _args.transferId,\n      _args.to,\n      _args.recovery,\n      _args.assetId,\n      _args.amount,\n      _args.properties,\n      _args.callData,\n      returnData,\n      success\n    );\n    return (success, returnData);\n  }\n\n  function _handleFailure(\n    bool isNative,\n    bool hasIncreased,\n    address _assetId,\n    address payable _to,\n    address payable _recovery,\n    uint256 _amount\n  ) private {\n    if (!isNative) {\n      // Decrease allowance\n      if (hasIncreased) {\n        SafeERC20Upgradeable.safeDecreaseAllowance(IERC20Upgradeable(_assetId), _to, _amount);\n      }\n      // Transfer funds\n      SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(_assetId), _recovery, _amount);\n    } else {\n      // Transfer funds\n      AddressUpgradeable.sendValue(_recovery, _amount);\n    }\n  }\n}"
    }
  ]
}