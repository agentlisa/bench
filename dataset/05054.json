{
  "Title": "[M-25] Same contract multi permits fundamentally cannot be solved via the chosen standards",
  "Content": "\nThe finding is a direct follow up to: `All cross-chain USDO and TOFT flows using approvals may be susceptible to permit-based DoS griefing` from the Spearbit report.\n\nSince permits are signatures, they will be available to anyone monitoring the chain. They will be usable by anyone, since the goal of permit is allowing some other `msg.sender` to broadcast the signature and have it work.\n\n### POC\n\nDue to this, the current architecture is still subject to front-run exploits via the following:\n\n- Monitor the mempool for any sequence of permit signatures.\n- Execute all of the signatures before the transaction.\n\nAny time, more than one permit is signed to the same token, for example, to Add Exact Allowance and Revoke it, front-running the calls will burn the approvals and reset the allowance down to `0`.\n\nThe transaction, which may have worked had only one of the signatures been front-run, is unable to function as the last signature for revoking will be broadcasted right after the first one. This effectively means that the only architecture that could be used for Tapioca is single signature, with no revokes, which doesn't seem to be the case at this time.\n\n### Mitigation\n\nThe only solution I have found at this time would be to use Permits to grant approvals (with try-catch) and not using permits to revoke approvals, as the revoke permit call could be front-run causing all `xChain` calls to revert.\n\nIf you wish to use exact approvals `xChain`(which I recommend), you'd have to solve for rounding errors when converting shares vs amounts. Due to this, you may recommend people to grant higher allowances, and then change all `toft` tokens to have a `renounceAllowance` function, which would re-set the allowance on behalf of the operator, enforcing a strict `0 -> X -> 0` allowance pattern while avoiding front-run griefs.\n\nThis would ensure that trusted Tapioca Operators receive allowances, and re-set them at the end of all of their operations, which gives a stronger security guarantee. We built something similar for eBTC, with PositionMangers [here](<https://github.com/ebtc-protocol/ebtc/blob/3406f0d88ac9935da53f7371fb078d11c066802e/packages/contracts/contracts/Interfaces/IPositionManagers.sol#L30>).\n\n### Assessed type\n\nMEV\n\n**[cryptotechmaker (Tapioca) confirmed and commented via duplicate Issue #83](https://github.com/code-423n4/2024-02-tapioca-findings/issues/83#issuecomment-2039105724):**\n> PR [here](https://github.com/Tapioca-DAO/tap-yieldbox/pull/4).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "packages/contracts/contracts/Interfaces/IPositionManagers.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IPositionManagers {\n    enum PositionManagerApproval {\n        None,\n        OneTime,\n        Persistent\n    }\n\n    event PositionManagerApprovalSet(\n        address indexed _borrower,\n        address indexed _positionManager,\n        PositionManagerApproval _approval\n    );\n\n    function getPositionManagerApproval(\n        address _borrower,\n        address _positionManager\n    ) external view returns (PositionManagerApproval);\n\n    function setPositionManagerApproval(\n        address _positionManager,\n        PositionManagerApproval _approval\n    ) external;\n\n    function revokePositionManagerApproval(address _positionManager) external;\n\n    function renouncePositionManagerApproval(address _borrower) external;\n\n    function permitPositionManagerApproval(\n        address _borrower,\n        address _positionManager,\n        PositionManagerApproval _approval,\n        uint _deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function version() external view returns (string memory);\n\n    function permitTypeHash() external view returns (bytes32);\n\n    function domainSeparator() external view returns (bytes32);\n}"
    }
  ]
}