{
  "Title": "[16] `_prepareBasicFulfillmentFromCalldata` overwrites memory extensively",
  "Content": "\nThe `_prepareBasicFulfillmentFromCalldata` function prepares ABI encoded data at fixed location in memory (starting at `0x80` and writing as high as `0x1e0+0x20`).\n\nThe overwritten memory does not seem to be saved, and this function has multiple assembly blocks (probably for avoiding `stack too deep errors`?). The only field restored is the zero slot.\n\nThe only use in Seaport is the `Consideration.fulfillBasicOrder` → `_validateAndFulfillBasicOrder` → `_prepareBasicFulfillmentFromCalldata` call chain, where this does not seem to be a problem, because they are not allocating memory prior to entering this function (according to displaying the free memory pointer in the test suite).\n\nThis would become a big issue if some functions would allocate memory. It is also very dependent on the compiler version.\n\n### Proof of Concept\n**Context:** [Consideration.sol#L76](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/Consideration.sol#L76), [BasicOrderFulfiller.sol#L70](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/BasicOrderFulfiller.sol#L70), [BasicOrderFulfiller.sol#L325](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/BasicOrderFulfiller.sol#L325)\n\n### Recommended Mitigation Steps\n\nConsider restoring the dirty memory.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-opensea-seaport",
  "Code": [
    {
      "filename": "contracts/lib/Consideration.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n// prettier-ignore\nimport {\n    ConsiderationInterface\n} from \"../interfaces/ConsiderationInterface.sol\";\n\n// prettier-ignore\nimport {\n    OrderComponents,\n    BasicOrderParameters,\n    OrderParameters,\n    Order,\n    AdvancedOrder,\n    OrderStatus,\n    CriteriaResolver,\n    Fulfillment,\n    FulfillmentComponent,\n    Execution\n} from \"./ConsiderationStructs.sol\";\n\nimport { OrderCombiner } from \"./OrderCombiner.sol\";\n\n/**\n * @title Consideration\n * @author 0age\n * @custom:coauthor d1ll0n\n * @custom:coauthor transmissions11\n * @custom:version 1\n * @notice Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace.\n *         It minimizes external calls to the greatest extent possible and\n *         provides lightweight methods for common routes as well as more\n *         flexible methods for composing advanced orders or groups of orders.\n *         Each order contains an arbitrary number of items that may be spent\n *         (the \"offer\") along with an arbitrary number of items that must be\n *         received back by the indicated recipients (the \"consideration\").\n */\ncontract Consideration is ConsiderationInterface, OrderCombiner {\n    /**\n     * @notice Derive and set hashes, reference chainId, and associated domain\n     *         separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) OrderCombiner(conduitController) {}\n\n    /**\n     * @notice Fulfill an order offering an ERC20, ERC721, or ERC1155 item by\n     *         supplying Ether (or other native tokens), ERC20 tokens, an ERC721\n     *         item, or an ERC1155 item as consideration. Six permutations are\n     *         supported: Native token to ERC721, Native token to ERC1155, ERC20\n     *         to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and ERC1155 to\n     *         ERC20 (with native tokens supplied as msg.value). For an order to\n     *         be eligible for fulfillment via this method, it must contain a\n     *         single offer item (though that item may have a greater amount if\n     *         the item is not an ERC721). An arbitrary number of \"additional\n     *         recipients\" may also be supplied which will each receive native\n     *         tokens or ERC20 items from the fulfiller as consideration. Refer\n     *         to the documentation for a more comprehensive summary of how to\n     *         utilize this method and what orders are compatible with it.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer and the fulfiller must first approve\n     *                   this contract (or their chosen conduit if indicated)\n     *                   before any tokens can be transferred. Also note that\n     *                   contract recipients of ERC1155 consideration items must\n     *                   implement `onERC1155Received` in order to receive those\n     *                   items.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder(BasicOrderParameters calldata parameters)\n        external\n        payable\n        override\n        returns (bool fulfilled)\n    {\n        // Validate and fulfill the basic order.\n        fulfilled = _validateAndFulfillBasicOrder(parameters);\n    }\n\n    /**\n     * @notice Fulfill an order with an arbitrary number of items for offer and\n     *         consideration. Note that this function does not support\n     *         criteria-based orders or partial filling of orders (though\n     *         filling the remainder of a partially-filled order is supported).\n     *\n     * @param order               The order to fulfill. Note that both the\n     *                            offerer and the fulfiller must first approve\n     *                            this contract (or the corresponding conduit if\n     *                            indicated) to transfer any relevant tokens on\n     *                            their behalf and that contracts must implement\n     *                            `onERC1155Received` to receive ERC1155 tokens\n     *                            as consideration.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used (and direct approvals set on\n     *                            Consideration).\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillOrder(Order calldata order, bytes32 fulfillerConduitKey)\n        external\n        payable\n        override\n        returns (bool fulfilled)\n    {\n        // Convert order to \"advanced\" order, then validate and fulfill it.\n        fulfilled = _validateAndFulfillAdvancedOrder(\n            _convertOrderToAdvanced(order),\n            new CriteriaResolver[](0), // No criteria resolvers supplied.\n            fulfillerConduitKey\n        );\n    }\n\n    /**\n     * @notice Fill an order, fully or partially, with an arbitrary number of\n     *         items for offer and consideration alongside criteria resolvers\n     *         containing specific token identifiers and associated proofs.\n     *\n     * @param advancedOrder       The order to fulfill along with the fraction\n     *                            of the order to attempt to fill. Note that\n     *                            both the offerer and the fulfiller must first\n     *                            approve this contract (or their conduit if\n     *                            indicated by the order) to transfer any\n     *                            relevant tokens on their behalf and that\n     *                            contracts must implement `onERC1155Received`\n     *                            to receive ERC1155 tokens as consideration.\n     *                            Also note that all offer and consideration\n     *                            components must have no remainder after\n     *                            multiplication of the respective amount with\n     *                            the supplied fraction for the partial fill to\n     *                            be considered valid.\n     * @param criteriaResolvers   An array where each element contains a\n     *                            reference to a specific offer or\n     *                            consideration, a token identifier, and a proof\n     *                            that the supplied token identifier is\n     *                            contained in the merkle root held by the item\n     *                            in question's criteria element. Note that an\n     *                            empty criteria indicates that any\n     *                            (transferrable) token identifier on the token\n     *                            in question is valid and that no associated\n     *                            proof needs to be supplied.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used (and direct approvals set on\n     *                            Consideration).\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillAdvancedOrder(\n        AdvancedOrder calldata advancedOrder,\n        CriteriaResolver[] calldata criteriaResolvers,\n        bytes32 fulfillerConduitKey\n    ) external payable override returns (bool fulfilled) {\n        // Validate and fulfill the order.\n        fulfilled = _validateAndFulfillAdvancedOrder(\n            advancedOrder,\n            criteriaResolvers,\n            fulfillerConduitKey\n        );\n    }\n\n    /**\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\n     *         of items for offer and consideration. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *         Note that this function does not support criteria-based orders or\n     *         partial filling of orders (though filling the remainder of a\n     *         partially-filled order is supported).\n     *\n     * @param orders                    The orders to fulfill. Note that both\n     *                                  the offerer and the fulfiller must first\n     *                                  approve this contract (or the\n     *                                  corresponding conduit if indicated) to\n     *                                  transfer any relevant tokens on their\n     *                                  behalf and that contracts must implement\n     *                                  `onERC1155Received` to receive ERC1155\n     *                                  tokens as consideration.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used (and\n     *                                  direct approvals set on Consideration).\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function fulfillAvailableOrders(\n        Order[] calldata orders,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        override\n        returns (bool[] memory availableOrders, Execution[] memory executions)\n    {\n        // Convert orders to \"advanced\" orders and fulfill all available orders.\n        return\n            _fulfillAvailableAdvancedOrders(\n                _convertOrdersToAdvanced(orders), // Convert to advanced orders.\n                new CriteriaResolver[](0), // No criteria resolvers supplied.\n                offerFulfillments,\n                considerationFulfillments,\n                fulfillerConduitKey,\n                maximumFulfilled\n            );\n    }\n\n    /**\n     * @notice Attempt to fill a group of orders, fully or partially, with an\n     *         arbitrary number of items for offer and consideration per order\n     *         alongside criteria resolvers containing specific token\n     *         identifiers and associated proofs. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or their conduit if indicated\n     *                                  by the order) to transfer any relevant\n     *                                  tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` in order to receive\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param criteriaResolvers         An array where each element contains a\n     *                                  reference to a specific offer or\n     *                                  consideration, a token identifier, and a\n     *                                  proof that the supplied token identifier\n     *                                  is contained in the merkle root held by\n     *                                  the item in question's criteria element.\n     *                                  Note that an empty criteria indicates\n     *                                  that any (transferrable) token\n     *                                  identifier on the token in question is\n     *                                  valid and that no associated proof needs\n     *                                  to be supplied.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used (and\n     *                                  direct approvals set on Consideration).\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function fulfillAvailableAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        override\n        returns (bool[] memory availableOrders, Execution[] memory executions)\n    {\n        // Fulfill all available orders.\n        return\n            _fulfillAvailableAdvancedOrders(\n                advancedOrders,\n                criteriaResolvers,\n                offerFulfillments,\n                considerationFulfillments,\n                fulfillerConduitKey,\n                maximumFulfilled\n            );\n    }\n\n    /**\n     * @notice Match an arbitrary number of orders, each with an arbitrary\n     *         number of items for offer and consideration along with a set of\n     *         fulfillments allocating offer components to consideration\n     *         components. Note that this function does not support\n     *         criteria-based or partial filling of orders (though filling the\n     *         remainder of a partially-filled order is supported).\n     *\n     * @param orders            The orders to match. Note that both the offerer\n     *                          and fulfiller on each order must first approve\n     *                          this contract (or their conduit if indicated by\n     *                          the order) to transfer any relevant tokens on\n     *                          their behalf and each consideration recipient\n     *                          must implement `onERC1155Received` in order to\n     *                          receive ERC1155 tokens.\n     * @param fulfillments      An array of elements allocating offer components\n     *                          to consideration components. Note that each\n     *                          consideration component must be fully met in\n     *                          order for the match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function matchOrders(\n        Order[] calldata orders,\n        Fulfillment[] calldata fulfillments\n    ) external payable override returns (Execution[] memory executions) {\n        // Convert to advanced, validate, and match orders using fulfillments.\n        return\n            _matchAdvancedOrders(\n                _convertOrdersToAdvanced(orders),\n                new CriteriaResolver[](0), // No criteria resolvers supplied.\n                fulfillments\n            );\n    }\n\n    /**\n     * @notice Match an arbitrary number of full or partial orders, each with an\n     *         arbitrary number of items for offer and consideration, supplying\n     *         criteria resolvers containing specific token identifiers and\n     *         associated proofs as well as fulfillments allocating offer\n     *         components to consideration components.\n     *\n     * @param advancedOrders    The advanced orders to match. Note that both the\n     *                          offerer and fulfiller on each order must first\n     *                          approve this contract (or their conduit if\n     *                          indicated by the order) to transfer any relevant\n     *                          tokens on their behalf and each consideration\n     *                          recipient must implement `onERC1155Received` in\n     *                          order to receive ERC1155 tokens. Also note that\n     *                          the offer and consideration components for each\n     *                          order must have no remainder after multiplying\n     *                          the respective amount with the supplied fraction\n     *                          in order for the group of partial fills to be\n     *                          considered valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order's\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order's merkle root. Note that\n     *                          an empty root indicates that any (transferrable)\n     *                          token identifier is valid and that no associated\n     *                          proof needs to be supplied.\n     * @param fulfillments      An array of elements allocating offer components\n     *                          to consideration components. Note that each\n     *                          consideration component must be fully met in\n     *                          order for the match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function matchAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        Fulfillment[] calldata fulfillments\n    ) external payable override returns (Execution[] memory executions) {\n        // Validate and match the advanced orders using supplied fulfillments.\n        return\n            _matchAdvancedOrders(\n                advancedOrders,\n                criteriaResolvers,\n                fulfillments\n            );\n    }\n\n    /**\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\n     *         or the zone of a given order may cancel it. Callers should ensure\n     *         that the intended order was cancelled by calling `getOrderStatus`\n     *         and confirming that `isCancelled` returns `true`.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders have\n     *                   been successfully cancelled.\n     */\n    function cancel(OrderComponents[] calldata orders)\n        external\n        override\n        returns (bool cancelled)\n    {\n        // Cancel the orders.\n        cancelled = _cancel(orders);\n    }\n\n    /**\n     * @notice Validate an arbitrary number of orders, thereby registering their\n     *         signatures as valid and allowing the fulfiller to skip signature\n     *         verification on fulfillment. Note that validated orders may still\n     *         be unfulfillable due to invalid item amounts or other factors;\n     *         callers should determine whether validated orders are fulfillable\n     *         by simulating the fulfillment call prior to execution. Also note\n     *         that anyone can validate a signed order, but only the offerer can\n     *         validate an order without supplying a signature.\n     *\n     * @param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders have\n     *                   been successfully validated.\n     */\n    function validate(Order[] calldata orders)\n        external\n        override\n        returns (bool validated)\n    {\n        // Validate the orders.\n        validated = _validate(orders);\n    }\n\n    /**\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\n     *         by incrementing a nonce. Note that only the offerer may increment\n     *         the nonce.\n     *\n     * @return newNonce The new nonce.\n     */\n    function incrementNonce() external override returns (uint256 newNonce) {\n        // Increment current nonce for the supplied offerer.\n        newNonce = _incrementNonce();\n    }\n\n    /**\n     * @notice Retrieve the order hash for a given order.\n     *\n     * @param order The components of the order.\n     *\n     * @return orderHash The order hash.\n     */\n    function getOrderHash(OrderComponents calldata order)\n        external\n        view\n        override\n        returns (bytes32 orderHash)\n    {\n        // Derive order hash by supplying order parameters along with the nonce.\n        orderHash = _deriveOrderHash(\n            OrderParameters(\n                order.offerer,\n                order.zone,\n                order.offer,\n                order.consideration,\n                order.orderType,\n                order.startTime,\n                order.endTime,\n                order.zoneHash,\n                order.salt,\n                order.conduitKey,\n                order.consideration.length\n            ),\n            order.nonce\n        );\n    }\n\n    /**\n     * @notice Retrieve the status of a given order by hash, including whether\n     *         the order has been cancelled or validated and the fraction of the\n     *         order that has been filled.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the \"numerator\").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the \"denominator\").\n     */\n    function getOrderStatus(bytes32 orderHash)\n        external\n        view\n        override\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        )\n    {\n        // Retrieve the order status using the order hash.\n        return _getOrderStatus(orderHash);\n    }\n\n    /**\n     * @notice Retrieve the current nonce for a given offerer.\n     *\n     * @param offerer The offerer in question.\n     *\n     * @return nonce The current nonce.\n     */\n    function getNonce(address offerer)\n        external\n        view\n        override\n        returns (uint256 nonce)\n    {\n        // Return the nonce for the supplied offerer.\n        nonce = _getNonce(offerer);\n    }\n\n    /**\n     * @notice Retrieve configuration information for this contract.\n     *\n     * @return version           The contract version.\n     * @return domainSeparator   The domain separator for this contract.\n     * @return conduitController The conduit Controller set for this contract.\n     */\n    function information()\n        external\n        view\n        override\n        returns (\n            string memory version,\n            bytes32 domainSeparator,\n            address conduitController\n        )\n    {\n        // Return the information for this contract.\n        return _information();\n    }\n\n    /**\n     * @notice Retrieve the name of this contract.\n     *\n     * @return contractName The name of this contract.\n     */\n    function name()\n        external\n        pure\n        override\n        returns (string memory contractName)\n    {\n        // Return the name of the contract.\n        contractName = _name();\n    }\n}"
    }
  ]
}