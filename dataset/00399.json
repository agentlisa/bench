{
  "Title": "M-7: SpotHedgeBaseMaker LPs will be able to extract value during a USDT/USDC de-peg",
  "Content": "# Issue M-7: SpotHedgeBaseMaker LPs will be able to extract value during a USDT/USDC de-peg \n\nSource: https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/118 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nIllIllI, PUSH0\n## Summary\n\nThe Perpetual protocol only supports USDT as collateral, but prices everything as though USDT were always equal to 1-for-1. Ongoing [small de-pegs](https://coinmarketcap.com/currencies/tether/) will only leave small amounts for arbitrage, because any arbitrage in size will skew the OracleMaker and UniswapV3 pools' prices to account for the opportunity. One case that cannot be handled is a large de-peg when the SpotHedgeBaseMaker has a lot of base tokens available.\n\n\n## Vulnerability Detail\n\nThe protocol's contest [readme](https://github.com/sherlock-audit/2024-02-perpetual/blob/02f17e70a23da5d71364268ccf7ed9ee7cedf428/README.md?plain=1#L15) says that either USDT or USDC will be used as collateral, and the project [documentation](https://perp.notion.site/PythOraclePool-e99a88be051f4bc8be0b1310eb982cd4) says that it will use Pyth oracles for pricing base tokens. Pyth only has a single oracle for USDT and USDC [each](https://pyth.network/developers/price-feed-ids), which is their USD value. All other Pyth oracles are for the USD price, not the USDT or USDC price.\n\nIn the case of the SpotHedgeBaseMaker, when a user wishes to withdraw their base tokens, it calculates the total value of all of the LP shares, as the [value](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/SpotHedgeBaseMaker.sol#L734-L743) of the vault account plus the net base tokens contributed during all deposit()s/withdraw()s. The price that it uses to convert the value of the vault in the vault's collateral, into the value of the vault in the base token's units, is the &lt;base>/USD price, not a &lt;base>/USDT or &lt;base>/USDC price (because there isn't an oracle for that).\n\n\n## Impact\n\nIf USDT is the collateral token and de-pegs by 30%, instead of valuing the account's collateral at 70% of what was deposited, it keeps it at 100%, letting each LP share withdraw more funds than it should be able to. Only base tokens can be withdrawn, so the first LPs to withdraw during the de-peg will get more than they should, leaving less for all others.\n\nA similar issue exists with all markets whose SpotHedgeBaseMaker's LP deposit/withdraw tokens are wrapped/bridged tokens, vs the actual token itself (e.g. WETH vs ETH). The price the SpotHedgeBaseMaker uses is the price returned by the oracle for the market, which is the actual token's oracle, not the hedging token's oracle. If there is a de-peg there (e.g. because the wrapped token is considered by some jurisdictions as a 'security', whereas the underlying isn't), then the amount of tokens deposited will be over-valued, and at the end when the market is wound down, profits not covered by the deposited hedging tokens will be withdrawable as the collateral token, which will have been over-valued at the expense of the other LPs.\n\n\n## Code Snippet\n\nThe function to calculate the vault value in units of the base token, takes in a price...:\n```solidity\n// File: src/maker/SpotHedgeBaseMaker.sol : SpotHedgeBaseMaker.withdraw()   #1\n\n311            uint256 redeemedRatio = shares.divWad(totalSupply()); // in ratio decimals 18\n...\n320            uint256 price = _getPrice();\n321 @>         uint256 vaultValueInBase = _getVaultValueInBaseSafe(vault, price);\n322            uint256 withdrawnBaseAmount = vaultValueInBase.mulWad(redeemedRatio).formatDecimals(\n323                INTERNAL_DECIMALS,\n324                _getSpotHedgeBaseMakerStorage().baseTokenDecimals\n325:           );\n```\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/SpotHedgeBaseMaker.sol#L311-L325\n\n...which refers to the market's oracle's price:\n```solidity\n// File: src/maker/SpotHedgeBaseMaker.sol : SpotHedgeBaseMaker.price   #2\n\n769        function _getPrice() internal view returns (uint256) {\n770            IAddressManager addressManager = getAddressManager();\n771 @>         (uint256 price, ) = addressManager.getPythOracleAdapter().getPrice(\n772                addressManager.getConfig().getPriceFeedId(_getSpotHedgeBaseMakerStorage().marketId)\n773            );\n774            return price;\n775:       }\n```\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/SpotHedgeBaseMaker.sol#L769-L775\n\nwhich is the price returned from the [pyth](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/oracle/pythOracleAdapter/PythOracleAdapter.sol#L80-L83) contract (converted for decimals), which is a USD price.\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nUse the &lt;quote-token>/USD oracle to convert the &lt;base-token>/USD price to a &lt;base-token>/&lt;quote-token> oracle\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**santipu_** commented:\n> Medium\n\n**takarez** commented:\n>  the ReadMe says \"Oracle (Pyth) is expected to accurately report the price of market\" which kinda mean that the pyth is trusted and realiable\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/219",
  "Code": [
    {
      "filename": "README.md?plain=1",
      "content": "# Perpetual contest details\n\n- Join [Sherlock Discord](https://discord.gg/MABEWyASkp)\n- Submit findings using the issue page in your private contest repo (label issues as med or high)\n- [Read for more details](https://docs.sherlock.xyz/audits/watsons)\n\n# Q&A\n\n### Q: On what chains are the smart contracts going to be deployed?\nOptimism/Blast\n___\n\n### Q: Which ERC20 tokens do you expect will interact with the smart contracts? \n- USDT or USDC\n- Except `SpotHedgeBaseMaker`: it may also interact with other non-collateral tokens as part of its hedging strategy, these tokens are assumed not to possess any \"weird\" traits.\n___\n\n### Q: Which ERC721 tokens do you expect will interact with the smart contracts? \nNone\n___\n\n### Q: Do you plan to support ERC1155?\nNo\n___\n\n### Q: Which ERC777 tokens do you expect will interact with the smart contracts? \nNone\n___\n\n### Q: Are there any FEE-ON-TRANSFER tokens interacting with the smart contracts?\n\nNo\n___\n\n### Q: Are there any REBASING tokens interacting with the smart contracts?\n\nNo\n___\n\n### Q: Are the admins of the protocols your contracts integrate with (if any) TRUSTED or RESTRICTED?\nTRUSTED\n___\n\n### Q: Is the admin/owner of the protocol/contracts TRUSTED or RESTRICTED?\nTRUSTED\n___\n\n### Q: Are there any additional protocol roles? If yes, please explain in detail:\n1. Relayer\n2. Relayer is a permissioned address controlled by us, it'll be used to help users settle their off-chain orders(limit order, market order) on chain.\n3. Match users orders and charge the relayer fee\n4. Apart from matching the user's order, no additional losses should be incurred by the relayer. The relayer may have some value extraction strategies available (for example by delaying the execution of the orders), and is trusted not to use them.\n___\n\n### Q: Is the code/contract expected to comply with any EIPs? Are there specific assumptions around adhering to those EIPs that Watsons should be aware of?\nThe core protocol does not comply with any EIPs. Some components may comply with EIPs like EIP-7265 (Circuit Breaker), ERC-7412, but we may customize the code according to our needs and we do not expect composability in these parts.\n___\n\n### Q: Please list any known issues/acceptable risks that should not result in a valid finding.\n1. Ownable’s owner could potentially disrupt regular operation through the disabling of features, incorrect setting of values, whitelisting malicious tokens, etc\n2. Oracle (Pyth) is expected to accurately report the price of market\n3. OrderGatewayV2’s relayer may not postpone order enough for mitigating others front-run oracle if the maker is OracleMaker\n4. LP deposit and withdrawal of OracleMaker and SpotHedgeBaseMaker is designed to simplify asset transfer in the majority of the cases; however, it is not guaranteed in edge cases when the collateral is low (or when the utilization is high)\n5. LP of SpotHedgedBaseMaker withdraw may change `maker.getUtilRatio`, but didn't trigger `_updateUtilRatio`\n6. OracleMaker/SpotHedgedBaseMaker doesn’t handle inflation attacks when minting/burning shares\n7. SpotHedgedBaseMaker could trigger CircuitBreaker rate limit when swap/withdraw\n8. `OracleMaker.fillOrder()` has hardcoded decimals instead of using `INTERNAL_DECIMALS`\n9. FundingFee will be incorrect if Config’s owner did not trigger FundingFee’s `_updateFundingGrowthIndex` when changing FundingConfig or imRatio\n10. In CircuitBreaker LibLimiter, `limiter.listNodes[currentHead]` not actually deleted\n11. In CircuitBreaker LibLimiter, `limiter.listHead/listTail` no initially set to `currentTickTimestamp`\n12. When the maker's margin ratio is below the minimum margin ratio, only trading that raises it above the minimum margin ratio is accepted, even if it involves reducing the maker’s position (which might increase the ratio)\n13. PnL Pool currently starts empty, so a trader with realized gains may experience temporary illiquidity when he tries to withdraw those gains. This inconvenience will be mitigated in the future with a buffer balance\n14. ClearingHouse may has some surplus margin (from liquidation fee) that can not be withdrawn by anyone yet\n___\n\n### Q: Please provide links to previous audits (if any).\nN/A\n___\n\n### Q: Are there any off-chain mechanisms or off-chain procedures for the protocol (keeper bots, input validation expectations, etc)?\n1. we're using off-chain oracle (Pyth) to fetch the price of assets, when interacting with the protocol, user first obtains a signed price through API, then updates this price to the protocol and interacts.\n2. users can submit off-chain orders(limit order, market order) to our backend system through API, and our relayers will settle those orders on-chain through OrderGatewayV2\n___\n\n### Q: In case of external protocol integrations, are the risks of external contracts pausing or executing an emergency withdrawal acceptable? If not, Watsons will submit issues related to these situations that can harm your protocol's functionality.\nYes it should be acceptable.\n___\n\n### Q: Do you expect to use any of the following tokens with non-standard behaviour with the smart contracts?\nWe will use USDT on OP, not on this list since it’s a bridged token.\n___\n\n### Q: Add links to relevant protocol resources\nhttps://perp.notion.site/Perp-v3-11275f0dcb914b3a992d9c7f915f2c0c?pvs=4\n___\n\n\n\n# Audit scope\n\n\n[perp-contract-v3 @ 8b850742b29ef6cc93d0988dc6eff91506972111](https://github.com/perpetual-protocol/perp-contract-v3/tree/8b850742b29ef6cc93d0988dc6eff91506972111)\n- [perp-contract-v3/src/addressManager/AddressManager.sol](perp-contract-v3/src/addressManager/AddressManager.sol)\n- [perp-contract-v3/src/addressManager/IAddressManager.sol](perp-contract-v3/src/addressManager/IAddressManager.sol)\n- [perp-contract-v3/src/addressResolver/AddressResolverUpgradeable.sol](perp-contract-v3/src/addressResolver/AddressResolverUpgradeable.sol)\n- [perp-contract-v3/src/addressResolver/LibAddressResolver.sol](perp-contract-v3/src/addressResolver/LibAddressResolver.sol)\n- [perp-contract-v3/src/authorization/AuthorizationUpgradeable.sol](perp-contract-v3/src/authorization/AuthorizationUpgradeable.sol)\n- [perp-contract-v3/src/authorization/IAuthorization.sol](perp-contract-v3/src/authorization/IAuthorization.sol)\n- [perp-contract-v3/src/borrowingFee/BorrowingFee.sol](perp-contract-v3/src/borrowingFee/BorrowingFee.sol)\n- [perp-contract-v3/src/borrowingFee/BorrowingFeeModel.sol](perp-contract-v3/src/borrowingFee/BorrowingFeeModel.sol)\n- [perp-contract-v3/src/borrowingFee/BorrowingFeeStruct.sol](perp-contract-v3/src/borrowingFee/BorrowingFeeStruct.sol)\n- [perp-contract-v3/src/borrowingFee/IBorrowingFee.sol](perp-contract-v3/src/borrowingFee/IBorrowingFee.sol)\n- [perp-contract-v3/src/borrowingFee/IBorrowingFeeEvent.sol](perp-contract-v3/src/borrowingFee/IBorrowingFeeEvent.sol)\n- [perp-contract-v3/src/borrowingFee/LibBorrowingFee.sol](perp-contract-v3/src/borrowingFee/LibBorrowingFee.sol)\n- [perp-contract-v3/src/borrowingFee/LibFeeGrowthGlobal.sol](perp-contract-v3/src/borrowingFee/LibFeeGrowthGlobal.sol)\n- [perp-contract-v3/src/circuitBreaker/CircuitBreaker.sol](perp-contract-v3/src/circuitBreaker/CircuitBreaker.sol)\n- [perp-contract-v3/src/circuitBreaker/ICircuitBreaker.sol](perp-contract-v3/src/circuitBreaker/ICircuitBreaker.sol)\n- [perp-contract-v3/src/circuitBreaker/LibLimiter.sol](perp-contract-v3/src/circuitBreaker/LibLimiter.sol)\n- [perp-contract-v3/src/circuitBreaker/LimiterStructs.sol](perp-contract-v3/src/circuitBreaker/LimiterStructs.sol)\n- [perp-contract-v3/src/clearingHouse/ClearingHouse.sol](perp-contract-v3/src/clearingHouse/ClearingHouse.sol)\n- [perp-contract-v3/src/clearingHouse/IClearingHouse.sol](perp-contract-v3/src/clearingHouse/IClearingHouse.sol)\n- [perp-contract-v3/src/clearingHouse/LibLiquidation.sol](perp-contract-v3/src/clearingHouse/LibLiquidation.sol)\n- [perp-contract-v3/src/common/ContextBase.sol](perp-contract-v3/src/common/ContextBase.sol)\n- [perp-contract-v3/src/common/LibConstant.sol](perp-contract-v3/src/common/LibConstant.sol)\n- [perp-contract-v3/src/common/LibError.sol](perp-contract-v3/src/common/LibError.sol)\n- [perp-contract-v3/src/common/LibFormatter.sol](perp-contract-v3/src/common/LibFormatter.sol)\n- [perp-contract-v3/src/common/LugiaMath.sol](perp-contract-v3/src/common/LugiaMath.sol)\n- [perp-contract-v3/src/config/Config.sol](perp-contract-v3/src/config/Config.sol)\n- [perp-contract-v3/src/config/FundingConfig.sol](perp-contract-v3/src/config/FundingConfig.sol)\n- [perp-contract-v3/src/external/universalSigValidator/IUniversalSigValidator.sol](perp-contract-v3/src/external/universalSigValidator/IUniversalSigValidator.sol)\n- [perp-contract-v3/src/external/universalSigValidator/UniversalSigValidator.sol](perp-contract-v3/src/external/universalSigValidator/UniversalSigValidator.sol)\n- [perp-contract-v3/src/fundingFee/FundingFee.sol](perp-contract-v3/src/fundingFee/FundingFee.sol)\n- [perp-contract-v3/src/fundingFee/IFundingFee.sol](perp-contract-v3/src/fundingFee/IFundingFee.sol)\n- [perp-contract-v3/src/maker/IMaker.sol](perp-contract-v3/src/maker/IMaker.sol)\n- [perp-contract-v3/src/maker/IWhitelistLpManager.sol](perp-contract-v3/src/maker/IWhitelistLpManager.sol)\n- [perp-contract-v3/src/maker/OracleMaker.sol](perp-contract-v3/src/maker/OracleMaker.sol)\n- [perp-contract-v3/src/maker/SpotHedgeBaseMaker.sol](perp-contract-v3/src/maker/SpotHedgeBaseMaker.sol)\n- [perp-contract-v3/src/maker/WhitelistLpManager.sol](perp-contract-v3/src/maker/WhitelistLpManager.sol)\n- [perp-contract-v3/src/makerReporter/IMakerReporter.sol](perp-contract-v3/src/makerReporter/IMakerReporter.sol)\n- [perp-contract-v3/src/makerReporter/MakerReporter.sol](perp-contract-v3/src/makerReporter/MakerReporter.sol)\n- [perp-contract-v3/src/oracle/pythOracleAdapter/IPythOracleAdapter.sol](perp-contract-v3/src/oracle/pythOracleAdapter/IPythOracleAdapter.sol)\n- [perp-contract-v3/src/oracle/pythOracleAdapter/PythOracleAdapter.sol](perp-contract-v3/src/oracle/pythOracleAdapter/PythOracleAdapter.sol)\n- [perp-contract-v3/src/orderGatewayV2/LibOrder.sol](perp-contract-v3/src/orderGatewayV2/LibOrder.sol)\n- [perp-contract-v3/src/orderGatewayV2/OrderGatewayV2.sol](perp-contract-v3/src/orderGatewayV2/OrderGatewayV2.sol)\n- [perp-contract-v3/src/quoter/Quoter.sol](perp-contract-v3/src/quoter/Quoter.sol)\n- [perp-contract-v3/src/systemStatus/ISystemStatus.sol](perp-contract-v3/src/systemStatus/ISystemStatus.sol)\n- [perp-contract-v3/src/systemStatus/SystemStatus.sol](perp-contract-v3/src/systemStatus/SystemStatus.sol)\n- [perp-contract-v3/src/vault/FundModelUpgradeable.sol](perp-contract-v3/src/vault/FundModelUpgradeable.sol)\n- [perp-contract-v3/src/vault/IMarginProfile.sol](perp-contract-v3/src/vault/IMarginProfile.sol)\n- [perp-contract-v3/src/vault/IPositionModelEvent.sol](perp-contract-v3/src/vault/IPositionModelEvent.sol)\n- [perp-contract-v3/src/vault/IVault.sol](perp-contract-v3/src/vault/IVault.sol)\n- [perp-contract-v3/src/vault/LibMargin.sol](perp-contract-v3/src/vault/LibMargin.sol)\n- [perp-contract-v3/src/vault/LibPosition.sol](perp-contract-v3/src/vault/LibPosition.sol)\n- [perp-contract-v3/src/vault/LibPositionModel.sol](perp-contract-v3/src/vault/LibPositionModel.sol)\n- [perp-contract-v3/src/vault/MarginProfile.sol](perp-contract-v3/src/vault/MarginProfile.sol)\n- [perp-contract-v3/src/vault/PositionChangedReason.sol](perp-contract-v3/src/vault/PositionChangedReason.sol)\n- [perp-contract-v3/src/vault/PositionModelStruct.sol](perp-contract-v3/src/vault/PositionModelStruct.sol)\n- [perp-contract-v3/src/vault/PositionModelUpgradeable.sol](perp-contract-v3/src/vault/PositionModelUpgradeable.sol)\n- [perp-contract-v3/src/vault/Vault.sol](perp-contract-v3/src/vault/Vault.sol)"
    },
    {
      "filename": "perp-contract-v3/src/maker/SpotHedgeBaseMaker.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { INTERNAL_DECIMALS, WAD } from \"../common/LibConstant.sol\";\nimport { IMaker } from \"./IMaker.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { IUniswapV3Factory } from \"../external/uniswap-v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport { ISwapRouter } from \"../external/uniswap-v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport { IQuoter } from \"../external/uniswap-v3-periphery/contracts/interfaces/IQuoter.sol\";\nimport { Path } from \"../external/uniswap-v3-periphery/contracts/libraries/Path.sol\";\nimport { BytesLib } from \"../external/uniswap-v3-periphery/contracts/libraries/BytesLib.sol\";\nimport { LibFormatter } from \"../common/LibFormatter.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { ContextBase } from \"../common/ContextBase.sol\";\nimport { IWhitelistLpManager } from \"./IWhitelistLpManager.sol\";\n\ncontract SpotHedgeBaseMaker is\n    ContextBase,\n    AddressResolverUpgradeable,\n    Ownable2StepUpgradeable,\n    ERC20Upgradeable,\n    IMaker\n{\n    using SafeERC20 for IERC20Metadata;\n    using BytesLib for bytes;\n    using Path for bytes;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using LibFormatter for uint256;\n    using LibFormatter for int256;\n    using FixedPointMathLib for uint256;\n    using LibAddressResolver for IAddressManager;\n\n    //\n    // STRUCT\n    //\n\n    /// @custom:storage-location erc7201:perp.storage.spotHedgeBaseMaker\n    struct SpotHedgeBaseMakerStorage {\n        uint256 marketId;\n        IERC20Metadata baseToken;\n        IERC20Metadata quoteToken;\n        uint8 baseTokenDecimals;\n        uint8 quoteTokenDecimals;\n        // UniswapV3 related\n        ISwapRouter uniswapV3Router;\n        IUniswapV3Factory uniswapV3Factory;\n        IQuoter uniswapV3Quoter;\n        // Key is a function of (tokenIn, tokenOut).\n        // However, note that since Uniswap's SwapRouter.exactOutput() takes path in reversed order,\n        // one should switch the key's tokenIn and tokenOut when querying paths for exactOutput calls.\n        mapping(bytes32 => bytes) uniswapV3PathMap;\n        // Internal ledger\n        uint256 baseTokenLiability;\n        uint256 minMarginRatio; // Min. marign ratio required by the maker at all time.\n    }\n\n    struct UniswapV3ExactInputParams {\n        address tokenIn;\n        address tokenOut;\n        bytes path;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct UniswapV3ExactOutputParams {\n        address tokenIn;\n        address tokenOut;\n        bytes path;\n        address recipient;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct FillOrderCallbackData {\n        bool isBaseToQuote;\n        bool isExactInput;\n        uint256 amountXSpotDecimals;\n        uint256 oppositeAmountXSpotDecimals;\n    }\n\n    //\n    // Event\n    //\n\n    event Deposited(\n        address depositor,\n        uint256 shares, // Amount of share minted\n        uint256 underlying // Amount of underlying token deposited\n    );\n\n    event Withdrawn(\n        address withdrawer,\n        uint256 shares, // Amount of shares burnt\n        uint256 baseAmount, // Amount of base tokens withdrawn from maker contract\n        uint256 quoteAmount // Amount of quote tokens withdrawn from maker's Perp position\n    );\n\n    event UniswapV3RouterSet(address newUniswapV3Router, address oldUniswapV3Router);\n    event UniswapV3FactorySet(address newUniswapV3Factory, address oldUniswapV3Factory);\n    event UniswapV3QuoterSet(address newUniswapV3Quoter, address oldUniswapV3Quoter);\n\n    // solhint-disable-next-line max-line-length\n    // Forked from https://github.com/perpetual-protocol/kantaban-contract/blob/18e0c1fe16490ccc9cbf0d9514e2204964f31624/contracts/interface/IRouterEvent.sol#L6-L13\n    /**\n     * @dev Emitted when UniswapV3 multihop path of tokenIn/tokenOut pair is changed\n     * @param tokenIn The address of tokenIn\n     * @param tokenOut The address of tokenOut\n     * @param oldPath The old UniswapV3 multihop path\n     * @param newPath The new UniswapV3 multihop path\n     */\n    event UniswapV3PathSet(address tokenIn, address tokenOut, bytes newPath, bytes oldPath);\n\n    event MinMarginRatioSet(uint256 newMinMarginRatio, uint256 oldMinMarginRatio);\n\n    event SHMOrderFilled(\n        uint256 marketId,\n        bytes path,\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 targetAmount, // in INTERNAL_DECIMALS\n        uint256 oppositeAmount, // in INTERNAL_DECIMALS\n        uint256 spread // In percentage (1e6 = 100%)\n    );\n\n    //\n    // STATE\n    //\n\n    // keccak256(abi.encode(uint256(keccak256(\"perp.storage.spotHedgeBaseMaker\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant _SPOT_HEDGE_BASE_MAKER_STORAGE_LOCATION =\n        0xaa0ea57ca6018b18cb09d20625ac40a68ba646a22caa4398d37ac2dfe2dc7500;\n\n    //\n    // MODIFIER\n    //\n    modifier onlyClearingHouse() {\n        if (msg.sender != address(getAddressManager().getClearingHouse())) revert LibError.Unauthorized();\n        _;\n    }\n\n    modifier onlyWhitelistLp() {\n        IWhitelistLpManager whitelistManager = getAddressManager().getWhitelistLpManager();\n        if (address(whitelistManager) != address(0)) {\n            if (!whitelistManager.isLpWhitelisted(_sender())) revert LibError.Unauthorized();\n        }\n        _;\n    }\n\n    //\n    // EXTERNAL NON-VIEW\n    //\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 marketId_,\n        string memory name_,\n        string memory symbol_,\n        address addressManager_,\n        address uniswapV3Router_,\n        address uniswapV3Factory_,\n        address uniswapV3Quoter_,\n        address baseToken_,\n        uint256 minMarginRatio_\n    ) external initializer {\n        __AddressResolver_init(addressManager_);\n        __Ownable2Step_init();\n        __Ownable_init(msg.sender);\n        __ERC20_init(name_, symbol_);\n\n        SpotHedgeBaseMakerStorage storage $ = _getSpotHedgeBaseMakerStorage();\n\n        $.marketId = marketId_;\n\n        setUniswapV3Router(uniswapV3Router_);\n        setUniswapV3Factory(uniswapV3Factory_);\n        setUniswapV3Quoter(uniswapV3Quoter_);\n\n        $.baseToken = IERC20Metadata(baseToken_);\n        $.baseTokenDecimals = IERC20Metadata($.baseToken).decimals();\n        $.quoteToken = IERC20Metadata(_getVault().getCollateralToken());\n        $.quoteTokenDecimals = IERC20Metadata($.quoteToken).decimals();\n\n        setMinMarginRatio(minMarginRatio_);\n    }\n\n    function setUniswapV3Router(address _uniswapV3Router) public onlyOwner {\n        if (_uniswapV3Router == address(0)) revert LibError.ZeroAddress();\n\n        address oldUniswapV3Router = address(_getSpotHedgeBaseMakerStorage().uniswapV3Router);\n        _getSpotHedgeBaseMakerStorage().uniswapV3Router = ISwapRouter(_uniswapV3Router);\n\n        emit UniswapV3RouterSet(_uniswapV3Router, oldUniswapV3Router);\n    }\n\n    function setUniswapV3Factory(address _uniswapV3Factory) public onlyOwner {\n        if (_uniswapV3Factory == address(0)) revert LibError.ZeroAddress();\n\n        address oldUniswapV3Factory = address(_getSpotHedgeBaseMakerStorage().uniswapV3Factory);\n        _getSpotHedgeBaseMakerStorage().uniswapV3Factory = IUniswapV3Factory(_uniswapV3Factory);\n\n        emit UniswapV3FactorySet(_uniswapV3Factory, oldUniswapV3Factory);\n    }\n\n    function setUniswapV3Quoter(address _uniswapV3Quoter) public onlyOwner {\n        if (_uniswapV3Quoter == address(0)) revert LibError.ZeroAddress();\n\n        address oldUniswapV3Quoter = address(_getSpotHedgeBaseMakerStorage().uniswapV3Quoter);\n        _getSpotHedgeBaseMakerStorage().uniswapV3Quoter = IQuoter(_uniswapV3Quoter);\n\n        emit UniswapV3QuoterSet(_uniswapV3Quoter, oldUniswapV3Quoter);\n    }\n\n    // solhint-disable-next-line max-line-length\n    // Forked from https://github.com/perpetual-protocol/kantaban-contract/blob/18e0c1fe16490ccc9cbf0d9514e2204964f31624/contracts/Router.sol#L33-L45\n    function setUniswapV3Path(address tokenIn, address tokenOut, bytes calldata path) external onlyOwner {\n        _verifyPath(tokenIn, tokenOut, path);\n\n        bytes32 key = _getKey(tokenIn, tokenOut);\n        bytes memory oldPath = _getSpotHedgeBaseMakerStorage().uniswapV3PathMap[key];\n        _getSpotHedgeBaseMakerStorage().uniswapV3PathMap[key] = path;\n\n        emit UniswapV3PathSet(tokenIn, tokenOut, path, oldPath);\n    }\n\n    function setMinMarginRatio(uint256 _minMarginRatio) public onlyOwner {\n        if (_minMarginRatio > WAD) {\n            revert LibError.InvalidRatio(_minMarginRatio);\n        }\n        if (_minMarginRatio == 0) {\n            revert LibError.ZeroRatio();\n        }\n        uint256 oldMinMarginRatio = _getSpotHedgeBaseMakerStorage().minMarginRatio;\n        _getSpotHedgeBaseMakerStorage().minMarginRatio = _minMarginRatio;\n\n        emit MinMarginRatioSet(_minMarginRatio, oldMinMarginRatio);\n    }\n\n    function deposit(uint256 amountXBD) external onlyWhitelistLp returns (uint256) {\n        address lp = _sender();\n        address maker = address(this);\n\n        if (amountXBD == 0) revert LibError.ZeroAmount();\n\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = amountXBD;\n        } else {\n            // TODO Should consider slippage once maker has spread or other pricing logic.\n            // For now, we will just get account value from ClearingHouse (assume no slippages).\n            // shares per asset = share (share token precision) / (accountValue (INTERNAL_DECIMALS) / basePrice (pyth precision) + baseBalance (base token precision))\n            // shares (share token precision) =  assets (base token precision) * shares per asset\n\n            // TODO: We should add protections to prevent attackers from manipulating the share price by manipulating oracle reported price.\n            // This is because the attacker could potentially mint large amount of shares by forcing the share price low.\n            // Possible protections like rate limiting share price, or any kind of volatility check.\n\n            uint8 shareDecimals = decimals();\n            uint256 vaultValueInBaseXShareDecimals = _getVaultValueInBaseSafe(_getVault(), _getPrice()).formatDecimals(\n                INTERNAL_DECIMALS,\n                shareDecimals\n            );\n\n            shares =\n                (amountXBD.formatDecimals(_getSpotHedgeBaseMakerStorage().baseTokenDecimals, shareDecimals) *\n                    totalSupply()) /\n                vaultValueInBaseXShareDecimals;\n        }\n\n        uint256 balanceBefore = _getSpotHedgeBaseMakerStorage().baseToken.balanceOf(maker);\n        _getSpotHedgeBaseMakerStorage().baseToken.safeTransferFrom(_sender(), maker, amountXBD);\n        uint256 transferredAmount = _getSpotHedgeBaseMakerStorage().baseToken.balanceOf(maker) - balanceBefore;\n\n        if (transferredAmount != amountXBD) {\n            revert LibError.WrongTransferAmount(transferredAmount, amountXBD);\n        }\n\n        _getSpotHedgeBaseMakerStorage().baseTokenLiability += amountXBD;\n\n        _mint(lp, shares);\n\n        emit Deposited(lp, shares, amountXBD);\n\n        return shares;\n    }\n\n    function withdraw(uint256 shares) external onlyWhitelistLp returns (uint256 baseAmount, uint256 quoteAmount) {\n        address lp = _sender();\n        address maker = address(this);\n        IVault vault = _getVault();\n\n        if (shares == 0) revert LibError.ZeroAmount();\n\n        // Must done before burn.\n        uint256 redeemedRatio = shares.divWad(totalSupply()); // in ratio decimals 18\n\n        // Revert early if shares amount exceeds balance\n        _burn(lp, shares);\n\n        _getSpotHedgeBaseMakerStorage().baseTokenLiability -= _getSpotHedgeBaseMakerStorage().baseTokenLiability.mulWad(\n            redeemedRatio\n        );\n\n        uint256 price = _getPrice();\n        uint256 vaultValueInBase = _getVaultValueInBaseSafe(vault, price);\n        uint256 withdrawnBaseAmount = vaultValueInBase.mulWad(redeemedRatio).formatDecimals(\n            INTERNAL_DECIMALS,\n            _getSpotHedgeBaseMakerStorage().baseTokenDecimals\n        );\n\n        uint256 withdrawnQuoteAmount = 0;\n\n        uint256 spotBaseBalance = _getSpotHedgeBaseMakerStorage().baseToken.balanceOf(maker);\n\n        if (withdrawnBaseAmount > spotBaseBalance) {\n            if (vault.getPositionSize(_getSpotHedgeBaseMakerStorage().marketId, maker) != 0) {\n                revert LibError.NotEnoughSpotBaseTokens(withdrawnBaseAmount, spotBaseBalance);\n            } else {\n                withdrawnQuoteAmount = (withdrawnBaseAmount - spotBaseBalance).mulWad(price).formatDecimals(\n                    _getSpotHedgeBaseMakerStorage().baseTokenDecimals,\n                    _getSpotHedgeBaseMakerStorage().quoteTokenDecimals\n                );\n                withdrawnBaseAmount = FixedPointMathLib.min(withdrawnBaseAmount, spotBaseBalance);\n            }\n        }\n\n        if (withdrawnBaseAmount > 0) {\n            _getSpotHedgeBaseMakerStorage().baseToken.safeTransfer(lp, withdrawnBaseAmount);\n        }\n        if (withdrawnQuoteAmount > 0) {\n            // withdrawnQuoteAmount is calculated base on freeCollateral, and since all conversions are round-down,\n            // we can safely assume withdrawnQuoteAmount <= freeCollateral and the withdraw should always pass.\n            // It may not be possible to withdraw the required amount, due to unsettledPnl that cannot be settled totally.\n            _withdraw(vault, _getSpotHedgeBaseMakerStorage().marketId, withdrawnQuoteAmount);\n            _getSpotHedgeBaseMakerStorage().quoteToken.safeTransfer(lp, withdrawnQuoteAmount);\n        }\n\n        emit Withdrawn(lp, shares, withdrawnBaseAmount, withdrawnQuoteAmount);\n\n        return (withdrawnBaseAmount, withdrawnQuoteAmount);\n    }\n\n    function fillOrderCallback(bytes calldata _data) external onlyClearingHouse {\n        FillOrderCallbackData memory data = abi.decode(_data, (FillOrderCallbackData));\n        _fillOrderCallback(data);\n        _checkMinMarginRatio(_getPrice());\n    }\n\n    function fillOrder(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount,\n        bytes calldata\n    ) external onlyClearingHouse returns (uint256, bytes memory) {\n        IVault vault = _getVault();\n        uint256 _marketId = _getSpotHedgeBaseMakerStorage().marketId;\n        address maker = address(this);\n\n        // Taker perp - maker uniswap matrix:\n        //\n        //                      perp B->Q                   perp Q->B\n        // perp exact input     spot B->Q exact input       spot Q->B exact input\n        // perp exact output    spot B->Q exact output      spot Q->B exact output\n\n        FillOrderCallbackData memory fillOrderCallbackData = FillOrderCallbackData({\n            isBaseToQuote: isBaseToQuote,\n            isExactInput: isExactInput,\n            amountXSpotDecimals: 0, // TBD\n            oppositeAmountXSpotDecimals: 0 // TBD\n        });\n\n        uint256 oppositeAmount;\n        bytes memory path;\n        if (isBaseToQuote) {\n            uint256 quoteTokenAcquired = 0;\n            path = _getPath(\n                address(_getSpotHedgeBaseMakerStorage().baseToken),\n                address(_getSpotHedgeBaseMakerStorage().quoteToken),\n                isExactInput\n            );\n\n            if (isExactInput) {\n                uint256 baseTokenRequired = _formatPerpToSpotBaseDecimals(amount);\n                quoteTokenAcquired = _uniswapV3ExactInput(\n                    UniswapV3ExactInputParams({\n                        tokenIn: address(_getSpotHedgeBaseMakerStorage().baseToken),\n                        tokenOut: address(_getSpotHedgeBaseMakerStorage().quoteToken),\n                        path: path,\n                        recipient: maker,\n                        amountIn: baseTokenRequired,\n                        amountOutMinimum: 0\n                    })\n                );\n                oppositeAmount = _formatSpotToPerpQuoteDecimals(quoteTokenAcquired);\n                // Currently we don't utilize fillOrderCallback for B2Q swaps,\n                // but we still populate the arguments anyways.\n                fillOrderCallbackData.amountXSpotDecimals = baseTokenRequired;\n                fillOrderCallbackData.oppositeAmountXSpotDecimals = quoteTokenAcquired;\n            } else {\n                quoteTokenAcquired = _formatPerpToSpotQuoteDecimals(amount);\n                uint256 oppositeAmountXSpotDecimals = _uniswapV3ExactOutput(\n                    UniswapV3ExactOutputParams({\n                        tokenIn: address(_getSpotHedgeBaseMakerStorage().baseToken),\n                        tokenOut: address(_getSpotHedgeBaseMakerStorage().quoteToken),\n                        path: path,\n                        recipient: maker,\n                        amountOut: quoteTokenAcquired,\n                        amountInMaximum: _getSpotHedgeBaseMakerStorage().baseToken.balanceOf(maker)\n                    })\n                );\n                oppositeAmount = _formatSpotToPerpBaseDecimals(oppositeAmountXSpotDecimals);\n                // Currently we don't utilize fillOrderCallback for B2Q swaps,\n                // but we still populate the arguments anyways.\n                fillOrderCallbackData.amountXSpotDecimals = quoteTokenAcquired;\n                fillOrderCallbackData.oppositeAmountXSpotDecimals = oppositeAmountXSpotDecimals;\n            }\n\n            // Deposit the acquired quote tokens to Vault.\n            _deposit(vault, _marketId, quoteTokenAcquired);\n        } else {\n            // Note we only quote amountIn/Out here and do the swap later in callback.\n            // It is because we are not sure how much USDC the maker could withdraw yet,\n            // because there are potential PnL to be realized after fillOrder(), after the positions are settled,\n            // which may change the maker's free USDC. If we withdraw now, chances are the maker could fall below\n            // margin requirement after PnLs are realized, or the maker might not have enough USDC to\n            // withdraw yet unless we wait until the PnLs are realized.\n            // The best solution is to defer the withdrawal to the callback and withdraw only after\n            // the positions are settled and PnLs are realized.\n            path = _getPath(\n                address(_getSpotHedgeBaseMakerStorage().quoteToken),\n                address(_getSpotHedgeBaseMakerStorage().baseToken),\n                isExactInput\n            );\n\n            if (isExactInput) {\n                uint256 quoteTokenRequired = _formatPerpToSpotQuoteDecimals(amount);\n                // get quote\n                uint256 oppositeAmountXSpotDecimals = _getSpotHedgeBaseMakerStorage().uniswapV3Quoter.quoteExactInput(\n                    path,\n                    quoteTokenRequired\n                );\n                oppositeAmount = _formatSpotToPerpBaseDecimals(oppositeAmountXSpotDecimals);\n\n                fillOrderCallbackData.amountXSpotDecimals = quoteTokenRequired;\n                fillOrderCallbackData.oppositeAmountXSpotDecimals = oppositeAmountXSpotDecimals;\n            } else {\n                uint256 baseTokenRequired = _formatPerpToSpotBaseDecimals(amount);\n                // get quote\n                uint256 oppositeAmountXSpotDecimals = _getSpotHedgeBaseMakerStorage().uniswapV3Quoter.quoteExactOutput(\n                    path,\n                    baseTokenRequired\n                );\n                oppositeAmount = _formatSpotToPerpQuoteDecimals(oppositeAmountXSpotDecimals);\n\n                fillOrderCallbackData.amountXSpotDecimals = baseTokenRequired;\n                fillOrderCallbackData.oppositeAmountXSpotDecimals = oppositeAmountXSpotDecimals;\n            }\n        }\n\n        emit SHMOrderFilled(\n            _getSpotHedgeBaseMakerStorage().marketId,\n            path,\n            isBaseToQuote,\n            isExactInput,\n            amount, // targetAmount\n            oppositeAmount,\n            0 // spread\n        );"
    }
  ]
}