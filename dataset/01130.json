{
  "Title": "Error-Prone Call Encoding",
  "Content": "On [line 126](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/libraries/ScrollMessengerBase.sol#L126) of [`ScrollMessengerBase.sol`](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/libraries/ScrollMessengerBase.sol) a call is encoded with `abi.encodeWithSignature`, which is prone to typographical errors. Instead, consider using the [`abi.encodeCall` function](https://docs.soliditylang.org/en/v0.8.20/cheatsheet.html#abi-encoding-and-decoding-functions) that protects against mistakes. When making this change, ensure that at least Solidity version 0.8.13 or above is used, due to a [bug encoding literals](https://blog.soliditylang.org/2022/03/16/encodecall-bug/).\n\n\n***Update:** Acknowledged, not resolved. The Scroll team stated:*\n\n\n\n> *This is the only `encodeWithSignature` left in the contracts. The reason why we do not fix it is because the `relayMessage` is only used in `L2ScrollMessenger`. If we use `abi.encodeCall`, some L2 only interface will be introduced to the base contract, which is not good in our opinion.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/libraries/ScrollMessengerBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {ScrollConstants} from \"./constants/ScrollConstants.sol\";\nimport {IScrollMessenger} from \"./IScrollMessenger.sol\";\n\n// solhint-disable var-name-mixedcase\n\nabstract contract ScrollMessengerBase is OwnableUpgradeable, IScrollMessenger {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates fee vault contract.\n    /// @param _oldFeeVault The address of old fee vault contract.\n    /// @param _newFeeVault The address of new fee vault contract.\n    event UpdateFeeVault(address _oldFeeVault, address _newFeeVault);\n\n    /*************\n     * Constants *\n     *************/\n\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/security/ReentrancyGuard.sol\n    uint256 internal constant _NOT_ENTERED = 1;\n    uint256 internal constant _ENTERED = 2;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice See {IScrollMessenger-xDomainMessageSender}\n    address public override xDomainMessageSender;\n\n    /// @notice The address of counterpart ScrollMessenger contract in L1/L2.\n    address public counterpart;\n\n    /// @notice The address of fee vault, collecting cross domain messaging fee.\n    address public feeVault;\n\n    // @note move to ScrollMessengerBase in next big refactor\n    /// @dev The status of for non-reentrant check.\n    uint256 private _lock_status;\n\n    /// @dev The storage slots for future usage.\n    uint256[46] private __gap;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_lock_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _lock_status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _lock_status = _NOT_ENTERED;\n    }\n\n    modifier notInExecution() {\n        require(\n            xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER,\n            \"Message is already in execution\"\n        );\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    function _initialize(address _counterpart, address _feeVault) internal {\n        OwnableUpgradeable.__Ownable_init();\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        counterpart = _counterpart;\n        feeVault = _feeVault;\n    }\n\n    // make sure only owner can send ether to messenger to avoid possible user fund loss.\n    receive() external payable onlyOwner {}\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update fee vault contract.\n    /// @dev This function can only called by contract owner.\n    /// @param _newFeeVault The address of new fee vault contract.\n    function updateFeeVault(address _newFeeVault) external onlyOwner {\n        address _oldFeeVault = feeVault;\n\n        feeVault = _newFeeVault;\n        emit UpdateFeeVault(_oldFeeVault, _newFeeVault);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to generate the correct cross domain calldata for a message.\n    /// @param _sender Message sender address.\n    /// @param _target Target contract address.\n    /// @param _value The amount of ETH pass to the target.\n    /// @param _messageNonce Nonce for the provided message.\n    /// @param _message Message to send to the target.\n    /// @return ABI encoded cross domain calldata.\n    function _encodeXDomainCalldata(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(address,address,uint256,uint256,bytes)\",\n                _sender,\n                _target,\n                _value,\n                _messageNonce,\n                _message\n            );\n    }\n}"
    }
  ]
}