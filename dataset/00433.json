{
  "Title": "M-14: `mTOFT` can be forced to receive the wrong ERC20 leading to token lockup",
  "Content": "# Issue M-14: `mTOFT` can be forced to receive the wrong ERC20 leading to token lockup \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/70 \n\n## Found by \nGiuseppeDeLaZara\n## Summary\nDue to Stargate's functionality of swapping one token on the source chain to another token on the destination chain, it is possible to force `mTOFT` to receive the wrong ERC20 token leading to token lockup.\n\n## Vulnerability Detail\nStargate allows for swapping between different tokens. These are usually correlated stablecoins. They are defined as **Stargate Chains Paths** inside the docs: https://stargateprotocol.gitbook.io/stargate/developers/stargate-chain-paths.\n\nTo give an example, a user can:\n\n- Provide USDC on Ethereum and receive USDT on Avalanche. \n- Provide USDC on Avalanche and receive USDT on Arbitrum. \n- etc.\n\nThis can also be observed by just playing around with the Stargate UI: https://stargate.finance/transfer.\n\nThe `Balancer.sol` contract initializes the connected OFTs through the [`initConnectedOFT`](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/Balancer.sol#L224) function.\nThis function is only callable by the admin and he specifies the src and dst pool ids. PoolIds refer to a specific StargatePool that holds the underlying asset(USDC, USDT, etc.): https://stargateprotocol.gitbook.io/stargate/developers/pool-ids.\n\nThe issue here is that poolIds are not enforced during the rebalancing process. As it can be observed the `bytes memory _ercData` is not checked for its content.\n\n```solidity\n## Balancer.sol\n\nfunction _sendToken(\n        address payable _oft,\n        uint256 _amount,\n        uint16 _dstChainId,\n        uint256 _slippage,\n>>>        bytes memory _data\n    ) private {\n        address erc20 = ITOFT(_oft).erc20();\n        if (IERC20Metadata(erc20).balanceOf(address(this)) < _amount) {\n            revert ExceedsBalance();\n        }\n        {\n>>>            (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_data, (uint256, uint256));\n            _routerSwap(_dstChainId, _srcPoolId, _dstPoolId, _amount, _slippage, _oft, erc20);\n        }\n    }\n\n```\n\nIt is simply decoded and passed as is. \n\nThis is a problem and imagine the following scenario:\n\n1. A Gelato bot calls the rebalance method for `mTOFT` that has USDC as erc20 on Ethereum.\n2. The bot encodes the `ercData` so `srcChainId = 1` pointing to USDC but `dstChainId = 2` pointing to USDT on Avalanche.\n3. Destination `mTOFT` is fetched from [`connectedOFTs`](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/Balancer.sol#L307) and points to the mTOFT with USDC as erc20 on Avalanche.\n4. Stargate will take USDC on Ethereum and provide USDT on Avalanche.\n5. mTOFT with USDC as underlying erc20 on Avalanche will receive USDT token and it will remain lost as the balance of the `mTOFT` contract. \n\nAs this is a clear path for locking up wrong tokens inside the `mTOFT` contract, it is a critical issue.\n\n## Impact\nThe impact of this vulnerability is critical. It allows for locking up wrong tokens inside the mTOFT contract causing irreversible loss of funds. \n\n## Code Snippet\n- https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/Balancer.sol#L293\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThe `initConnectedOFT` function should enforce the poolIds for the src and dst chains.The rebalance function should just fetch these saved values and use them.\n\n```diff\n \n@@ -164,14 +176,12 @@ contract Balancer is Ownable {\n      * @param _dstChainId the destination LayerZero id\n      * @param _slippage the destination LayerZero id\n      * @param _amount the rebalanced amount\n-     * @param _ercData custom send data\n      */\n     function rebalance(\n         address payable _srcOft,\n         uint16 _dstChainId,\n         uint256 _slippage,\n-        uint256 _amount,\n-        bytes memory _ercData\n+        uint256 _amount\n     ) external payable onlyValidDestination(_srcOft, _dstChainId) onlyValidSlippage(_slippage) {\n         {\n@@ -188,13 +204,13 @@ contract Balancer is Ownable {\n             if (msg.value == 0) revert FeeAmountNotSet();\n             if (_isNative) {\n                 if (disableEth) revert SwapNotEnabled();\n                 _sendNative(_srcOft, _amount, _dstChainId, _slippage);\n             } else {\n-                _sendToken(_srcOft, _amount, _dstChainId, _slippage, _ercData);\n+                _sendToken(_srcOft, _amount, _dstChainId, _slippage);\n             }\n\n \n@@ -221,7 +237,7 @@ contract Balancer is Ownable {\n      * @param _dstOft the destination TOFT address\n      * @param _ercData custom send data\n      */\n-    function initConnectedOFT(address _srcOft, uint16 _dstChainId, address _dstOft, bytes memory _ercData)\n+    function initConnectedOFT(address _srcOft, uint256 poolId, uint16 _dstChainId, address _dstOft, bytes memory _ercData)\n         external\n         onlyOwner\n     {\n@@ -231,10 +247,8 @@ contract Balancer is Ownable {\n         bool isNative = ITOFT(_srcOft).erc20() == address(0);\n         if (!isNative && _ercData.length == 0) revert PoolInfoRequired();\n \n-        (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_ercData, (uint256, uint256));\n-\n         OFTData memory oftData =\n-            OFTData({srcPoolId: _srcPoolId, dstPoolId: _dstPoolId, dstOft: _dstOft, rebalanceable: 0});\n+            OFTData({srcPoolId: poolId, dstPoolId: poolId, dstOft: _dstOft, rebalanceable: 0});\n \n         connectedOFTs[_srcOft][_dstChainId] = oftData;\n         emit ConnectedChainUpdated(_srcOft, _dstChainId, _dstOft);\n \n     function _sendToken(\n         address payable _oft,\n         uint256 _amount,\n         uint16 _dstChainId,\n-        uint256 _slippage,\n-        bytes memory _data\n+        uint256 _slippage\n     ) private {\n         address erc20 = ITOFT(_oft).erc20();\n         if (IERC20Metadata(erc20).balanceOf(address(this)) < _amount) {\n             revert ExceedsBalance();\n-        }\n+            }\n         {\n-            (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_data, (uint256, uint256));\n-            _routerSwap(_dstChainId, _srcPoolId, _dstPoolId, _amount, _slippage, _oft, erc20);\n+            _routerSwap(_dstChainId, _amount, _slippage, _oft, erc20);\n         }\n     }\n \n     function _routerSwap(\n         uint16 _dstChainId,\n-        uint256 _srcPoolId,\n-        uint256 _dstPoolId,\n         uint256 _amount,\n         uint256 _slippage,\n         address payable _oft,\n         address _erc20\n     ) private {\n         bytes memory _dst = abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft);\n+        uint256 poolId = connectedOFTs[_oft][_dstChainId].srcPoolId;\n         IERC20(_erc20).safeApprove(address(router), _amount);\n         router.swap{value: msg.value}(\n             _dstChainId,\n-            _srcPoolId,\n-            _dstPoolId,\n+            poolId,\n+            poolId,\n             payable(this),\n             _amount,\n             _computeMinAmount(_amount, _slippage),\n```\n\nAdmin is trusted but you can optionally add additional checks inside the `initConnectedOFT` function to ensure that the poolIds are correct for the src and dst mTOFTs. \n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/TapiocaZ/pull/175.\n\n**dmitriia**\n\nEscalate\nWhile the impact is clearly high/critical, the probability of this looks to be low/very low as rebalance() is [permissioned](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/Balancer.sol#L176), so what is described here is a keeper/configuration mistake and there looks to be no way for this to be exploited by an outside attacker. Why user mistakes with the very same full fund loss impact (e.g. #112, #132) are discarded, while keeper mistake isn't?\nNotice that per [contest terms](https://audits.sherlock.xyz/contests/170) all protocol actors are trusted:\n```md\nAre the admins of the protocols your contracts integrate with (if any) TRUSTED or RESTRICTED?\n\nTRUSTED\n\nIs the admin/owner of the protocol/contracts TRUSTED or RESTRICTED?\n\nTRUSTED\n```\nIn the same time, as this is more deep in nature compared to common mistakes, I would say medium severity can be applicable.\n\n**sherlock-admin2**\n\n> Escalate\n> While the impact is clearly high/critical, the probability of this looks to be low/very low as rebalance() is [permissioned](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/Balancer.sol#L176), so what is described here is a keeper/configuration mistake and there looks to be no way for this to be exploited by an outside attacker. Why user mistakes with the very same full fund loss impact (e.g. #112, #132) are discarded, while keeper mistake isn't?\n> Notice that per [contest terms](https://audits.sherlock.xyz/contests/170) all protocol actors are trusted:\n> ```md\n> Are the admins of the protocols your contracts integrate with (if any) TRUSTED or RESTRICTED?\n> \n> TRUSTED\n> \n> Is the admin/owner of the protocol/contracts TRUSTED or RESTRICTED?\n> \n> TRUSTED\n> ```\n> In the same time, as this is more deep in nature compared to common mistakes, I would say medium severity can be applicable.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**windhustler**\n\nThe escalation comment is comparing apples to oranges. User mistakes are completely different than the critical severity attack path described here.\n\n`rebalance` function was meant to be called by an automation system to offload manually calling the function. The function definitely shouldn’t exclude basic input parameters validation which the report above highlights. \n\nSince when are off-chain agents responsible for validating inputs and the smart contract security being offloaded to the off-chain server?\n\nMoreover, most automation systems are either partly or on the road to being decentralized where anyone can become an operator. So there is a clear path for a malicious actor to exploit this. \n\nThe issue is not some obscure, low-likelihood attack path but rather a straightforward way of irreversibly losing all the rebalanced amount.\n\nIf we look at: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/87 ,a hypothetical token with different decimals across chains was accepted as “medium likelihood”, although such a token isn't accepted as collateral right and there is only a small probability a token with such properties will be added in the future.\n\n**dmitriia**\n\nThe lack of any configuration check in a permissioned function usually do not account for anything above medium as the only way for it to cause any damage is operator's mistake.\n\n#87 is about user-facing flow.\n\n**windhustler**\n\nIt's a bit more nuanced than that. Based on the number of issues in the `Balancer` contract it seems that the team has overlooked several scenarios. \nWhen it comes to off-chain agents, most of them are either fully or on their way to becoming decentralized:\n\n- https://keep3r.network/ Anyone can become a keeper. \n- https://forum.gelato.network/discussion/11360-node-operator-staking-wave-1 Gelato network plans are to also become fully decentralized with time. \n\nSo, this issue also highlights the importance of validating inputs with functions meant to be called by these agents. \n\nBut, as always I leave it to the judge to decide on the severity. \n\nhttps://github.com/sherlock-audit/2024-02-tapioca-judging/issues/87 is about Governance setting tokens with different decimals across chains as collateral in the future versions of Tapioca. As these tokens are very uncommon and even less likely to be used as collateral the likelihood of this occurring is very low. The report also doesn't mention a concrete token, so we can assume it's a hypothetical one. \n\n\n**dmitriia**\n\nAnyone cannot run `rebalance()`, its use is fixed to `rebalancer` actor, one address. Permissionless rebalancing setups tend to constitute high severity surfaces on their own. Any decentralized mechanics, i.e. when actors can be random, but, for example, have something at stake, need to be examined for incentives. Say when NPV of the attack payout is greater than actor's stake in a keeper system, then it's a rough equivalent of permissionless setup with lower attack payoff, and might be exploited.\n\n#87 is about a miss in the logic (not converting the input), this is about not checking the configuration of the permissioned call.\n\n**windhustler**\n\nYou have proof I pasted above of how the automation system is decentralized or getting decentralized. The contest README also states: \"External issues/integrations that would affect Tapioca, should be considered.\"\n\nhttps://github.com/sherlock-audit/2024-02-tapioca-judging/issues/87 And an exploit that occurs with a token that doesn't exist yet. \n\n\n\n**cvetanovv**\n\nI think escalation is correct because `rebalance()` is restricted and trusted. The only reason I see a chance for it to remain a valid issue is that in the Readme we have \"External issues/integrations that would affect Tapioca, should be considered.\" \n\nBut that's exactly why it falls into the Medium category. The function is not for everyone and there are too many conditions. Let's look at the Sherlock [documentation](https://docs.sherlock.xyz/audits/judging/judging#v.-how-to-identify-a-medium-issue) for Medium severity: \"Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained.\"\n\nSo I think it's fair to accept the escalation and downgrade to Medium.\n\n**cvetanovv**\n\nPlanning to accept the escalation and make this issue a Medium.\n\n**windhustler**\n\n@cvetanovv Thanks for taking a look. I'd still appreciate it if @Czar102 could take a look at this one. I acknowledge the permissioned nature of the `rebalance` function, but as I've highlighted this can be ambiguous under certain conditions and it's handing over the security to an automation system. Also, consider my points that other issues with very low likelihood https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/87 were judged as high severity. \n\nThanks!  \n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [dmitriia](https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/70/#issuecomment-2034526249): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "TapiocaZ/contracts/Balancer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IStargateRouter, IStargateRouterBase} from \"tapioca-periph/interfaces/external/stargate/IStargateRouter.sol\";\nimport {IStargateEthVault} from \"tapioca-periph/interfaces/external/stargate/IStargateEthVault.sol\";\nimport {ITOFTVault} from \"tapioca-periph/interfaces/tapiocaz/ITOFTVault.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Balancer\n * @author TapiocaDAO\n * @notice Rebalances mTOFT by transferring underlying tokens to other layers through Stargate\n */\ncontract Balancer is Ownable {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice current OFT => chain => destination OFT\n     * @dev chain ids (https://stargateprotocol.gitbook.io/stargate/developers/chain-ids):\n     *         - Ethereum: 101\n     *         - BNB: 102\n     *         - Avalanche: 106\n     *         - Polygon: 109\n     *         - Arbitrum: 110\n     *         - Optimism: 111\n     *         - Fantom: 112\n     *         - Metis: 151\n     *     pool ids https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\n     */\n    mapping(address => mapping(uint16 => OFTData)) public connectedOFTs;\n\n    struct OFTData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        address dstOft;\n        uint256 rebalanceable;\n    }\n\n    IStargateRouter public immutable routerETH;\n    IStargateRouter public immutable router;\n\n    address public rebalancer;\n\n    // @dev swapEth is not available on some chains\n    bool public disableEth;\n\n    event ConnectedChainUpdated(address indexed _srcOft, uint16 indexed _dstChainId, address indexed _dstOft);\n    event Rebalanced(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _slippage, uint256 _amount, bool _isNative\n    );\n    event RebalanceAmountUpdated(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _amount, uint256 _totalAmount\n    );\n    event ToggledSwapEth(bool indexed _old, bool indexed _new);\n    event EmergencySaved(address indexed _token, uint256 indexed _amount, bool indexed _native);\n    event RebalancerUpdated(address indexed prev, address indexed current);\n\n    error NotAuthorized();\n    error RouterNotValid();\n    error ExceedsBalance();\n    error DestinationNotValid();\n    error SlippageNotValid();\n    error FeeAmountNotSet();\n    error PoolInfoRequired();\n    error RebalanceAmountNotSet();\n    error Failed();\n    error SwapNotEnabled();\n    error AlreadyInitialized();\n    error RebalanceAmountNotValid();\n\n    modifier onlyValidDestination(address _srcOft, uint16 _dstChainId) {\n        if (connectedOFTs[_srcOft][_dstChainId].dstOft == address(0)) {\n            revert DestinationNotValid();\n        }\n        _;\n    }\n\n    modifier onlyValidSlippage(uint256 _slippage) {\n        // @dev a slippage higher than 20% shouldn't be necessary\n        if (_slippage >= 2e4) revert SlippageNotValid();\n        _;\n    }\n\n    constructor(address _routerETH, address _router, address _owner) {\n        if (_router == address(0)) revert RouterNotValid();\n        if (_routerETH == address(0)) revert RouterNotValid();\n        routerETH = IStargateRouter(_routerETH);\n        router = IStargateRouter(_router);\n\n        transferOwnership(_owner);\n        rebalancer = _owner;\n        emit RebalancerUpdated(address(0), _owner);\n    }\n\n    receive() external payable {}\n\n    /// =====================\n    /// View\n    /// =====================\n    function checker(address payable _srcOft, uint16 _dstChainId, uint256 _slippage)\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        bytes memory ercData;\n        {\n            if (ITOFT(_srcOft).erc20() != address(0)) {\n                ercData = abi.encode(\n                    connectedOFTs[_srcOft][_dstChainId].srcPoolId, connectedOFTs[_srcOft][_dstChainId].dstPoolId\n                );\n            }\n        }\n\n        canExec = connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0;\n        execPayload = abi.encodeCall(\n            Balancer.rebalance,\n            (_srcOft, _dstChainId, _slippage, connectedOFTs[_srcOft][_dstChainId].rebalanceable, ercData)\n        );\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n\n    /**\n     * @notice set rebalancer role\n     * @param _addr the new address\n     */\n    function setRebalancer(address _addr) external onlyOwner {\n        rebalancer = _addr;\n        emit RebalancerUpdated(rebalancer, _addr);\n    }\n\n    /**\n     * @notice toggle swap eth\n     * @param _val true/false\n     */\n    function setSwapEth(bool _val) external onlyOwner {\n        emit ToggledSwapEth(disableEth, _val);\n        disableEth = _val;\n    }\n\n    /**\n     * @notice performs a rebalance operation\n     * @dev callable only by the owner\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _slippage the destination LayerZero id\n     * @param _amount the rebalanced amount\n     * @param _ercData custom send data\n     */\n    function rebalance(\n        address payable _srcOft,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        uint256 _amount,\n        bytes memory _ercData\n    ) external payable onlyValidDestination(_srcOft, _dstChainId) onlyValidSlippage(_slippage) {\n        if (msg.sender != owner() || msg.sender != rebalancer) revert NotAuthorized();\n\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable < _amount) {\n            revert RebalanceAmountNotSet();\n        }\n\n        //extract\n        ITOFT(_srcOft).extractUnderlying(_amount);\n\n        //send\n        {\n            bool _isNative = ITOFT(_srcOft).erc20() == address(0);\n            if (msg.value == 0) revert FeeAmountNotSet();\n            if (_isNative) {\n                if (disableEth) revert SwapNotEnabled();\n                _sendNative(_srcOft, _amount, _dstChainId, _slippage);\n            } else {\n                _sendToken(_srcOft, _amount, _dstChainId, _slippage, _ercData);\n            }\n\n            connectedOFTs[_srcOft][_dstChainId].rebalanceable -= _amount;\n            emit Rebalanced(_srcOft, _dstChainId, _slippage, _amount, _isNative);\n        }\n    }\n\n    /**\n     * @notice saves token/native gas from this contract\n     * @param _token the token address; `address(0)` should be passed for the Native coin\n     * @param _amount the amount to be saved\n     */\n    function emergencySaveTokens(address _token, uint256 _amount) external onlyOwner {\n        if (_token == address(0)) {\n            (bool sent,) = msg.sender.call{value: _amount}(\"\");\n            if (!sent) revert Failed();\n            emit EmergencySaved(_token, _amount, true);\n        } else {\n            IERC20(_token).safeTransfer(msg.sender, _amount);\n            emit EmergencySaved(_token, _amount, false);\n        }\n    }\n\n    /**\n     * @notice registeres mTapiocaOFT for rebalancing\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _dstOft the destination TOFT address\n     * @param _ercData custom send data\n     */\n    function initConnectedOFT(address _srcOft, uint16 _dstChainId, address _dstOft, bytes memory _ercData)\n        external\n        onlyOwner\n    {\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0) {\n            revert AlreadyInitialized();\n        }\n        bool isNative = ITOFT(_srcOft).erc20() == address(0);\n        if (!isNative && _ercData.length == 0) revert PoolInfoRequired();\n\n        (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_ercData, (uint256, uint256));\n\n        OFTData memory oftData =\n            OFTData({srcPoolId: _srcPoolId, dstPoolId: _dstPoolId, dstOft: _dstOft, rebalanceable: 0});\n\n        connectedOFTs[_srcOft][_dstChainId] = oftData;\n        emit ConnectedChainUpdated(_srcOft, _dstChainId, _dstOft);\n    }\n\n    /**\n     * @notice assings more rebalanceable amount for TOFT\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _amount the rebalanced amount\n     */\n    function addRebalanceAmount(address _srcOft, uint16 _dstChainId, uint256 _amount)\n        external\n        onlyValidDestination(_srcOft, _dstChainId)\n        onlyOwner\n    {\n        connectedOFTs[_srcOft][_dstChainId].rebalanceable += _amount;\n        uint256 totalToftSupply = ITOFTVault(ITOFT(_srcOft).vault()).viewSupply();\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > totalToftSupply) {\n            revert RebalanceAmountNotValid();\n        }\n        emit RebalanceAmountUpdated(_srcOft, _dstChainId, _amount, connectedOFTs[_srcOft][_dstChainId].rebalanceable);\n    }\n\n    function retryRevert(uint16 _srcChainId, bytes calldata _srcAddress, uint256 _nonce) external payable onlyOwner {\n        router.retryRevert{value: msg.value}(_srcChainId, _srcAddress, _nonce);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _sendNative(address payable _oft, uint256 _amount, uint16 _dstChainId, uint256 _slippage) private {\n        if (address(this).balance < _amount) revert ExceedsBalance();\n        uint256 valueAmount = msg.value + _amount;\n        routerETH.swapETH{value: valueAmount}(\n            _dstChainId,\n            payable(this),\n            abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft),\n            _amount,\n            _computeMinAmount(_amount, _slippage)\n        );\n    }\n\n    function _sendToken(\n        address payable _oft,\n        uint256 _amount,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        bytes memory _data\n    ) private {\n        address erc20 = ITOFT(_oft).erc20();\n        if (IERC20Metadata(erc20).balanceOf(address(this)) < _amount) {\n            revert ExceedsBalance();\n        }\n        {\n            (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_data, (uint256, uint256));\n            _routerSwap(_dstChainId, _srcPoolId, _dstPoolId, _amount, _slippage, _oft, erc20);\n        }\n    }\n\n    function _routerSwap(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        uint256 _amount,\n        uint256 _slippage,\n        address payable _oft,\n        address _erc20\n    ) private {\n        bytes memory _dst = abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft);\n        IERC20(_erc20).safeApprove(address(router), _amount);\n        router.swap{value: msg.value}(\n            _dstChainId,\n            _srcPoolId,\n            _dstPoolId,\n            payable(this),\n            _amount,\n            _computeMinAmount(_amount, _slippage),\n            IStargateRouterBase.lzTxObj({dstGasForCall: 0, dstNativeAmount: 0, dstNativeAddr: \"0x0\"}),\n            _dst,\n            \"0x\"\n        );\n    }\n\n    function _computeMinAmount(uint256 _amount, uint256 _slippage) private pure returns (uint256) {\n        return _amount - ((_amount * _slippage) / 1e5);\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/Balancer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IStargateRouter, IStargateRouterBase} from \"tapioca-periph/interfaces/external/stargate/IStargateRouter.sol\";\nimport {IStargateEthVault} from \"tapioca-periph/interfaces/external/stargate/IStargateEthVault.sol\";\nimport {ITOFTVault} from \"tapioca-periph/interfaces/tapiocaz/ITOFTVault.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Balancer\n * @author TapiocaDAO\n * @notice Rebalances mTOFT by transferring underlying tokens to other layers through Stargate\n */\ncontract Balancer is Ownable {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice current OFT => chain => destination OFT\n     * @dev chain ids (https://stargateprotocol.gitbook.io/stargate/developers/chain-ids):\n     *         - Ethereum: 101\n     *         - BNB: 102\n     *         - Avalanche: 106\n     *         - Polygon: 109\n     *         - Arbitrum: 110\n     *         - Optimism: 111\n     *         - Fantom: 112\n     *         - Metis: 151\n     *     pool ids https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\n     */\n    mapping(address => mapping(uint16 => OFTData)) public connectedOFTs;\n\n    struct OFTData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        address dstOft;\n        uint256 rebalanceable;\n    }\n\n    IStargateRouter public immutable routerETH;\n    IStargateRouter public immutable router;\n\n    address public rebalancer;\n\n    // @dev swapEth is not available on some chains\n    bool public disableEth;\n\n    event ConnectedChainUpdated(address indexed _srcOft, uint16 indexed _dstChainId, address indexed _dstOft);\n    event Rebalanced(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _slippage, uint256 _amount, bool _isNative\n    );\n    event RebalanceAmountUpdated(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _amount, uint256 _totalAmount\n    );\n    event ToggledSwapEth(bool indexed _old, bool indexed _new);\n    event EmergencySaved(address indexed _token, uint256 indexed _amount, bool indexed _native);\n    event RebalancerUpdated(address indexed prev, address indexed current);\n\n    error NotAuthorized();\n    error RouterNotValid();\n    error ExceedsBalance();\n    error DestinationNotValid();\n    error SlippageNotValid();\n    error FeeAmountNotSet();\n    error PoolInfoRequired();\n    error RebalanceAmountNotSet();\n    error Failed();\n    error SwapNotEnabled();\n    error AlreadyInitialized();\n    error RebalanceAmountNotValid();\n\n    modifier onlyValidDestination(address _srcOft, uint16 _dstChainId) {\n        if (connectedOFTs[_srcOft][_dstChainId].dstOft == address(0)) {\n            revert DestinationNotValid();\n        }\n        _;\n    }\n\n    modifier onlyValidSlippage(uint256 _slippage) {\n        // @dev a slippage higher than 20% shouldn't be necessary\n        if (_slippage >= 2e4) revert SlippageNotValid();\n        _;\n    }\n\n    constructor(address _routerETH, address _router, address _owner) {\n        if (_router == address(0)) revert RouterNotValid();\n        if (_routerETH == address(0)) revert RouterNotValid();\n        routerETH = IStargateRouter(_routerETH);\n        router = IStargateRouter(_router);\n\n        transferOwnership(_owner);\n        rebalancer = _owner;\n        emit RebalancerUpdated(address(0), _owner);\n    }\n\n    receive() external payable {}\n\n    /// =====================\n    /// View\n    /// =====================\n    function checker(address payable _srcOft, uint16 _dstChainId, uint256 _slippage)\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        bytes memory ercData;\n        {\n            if (ITOFT(_srcOft).erc20() != address(0)) {\n                ercData = abi.encode(\n                    connectedOFTs[_srcOft][_dstChainId].srcPoolId, connectedOFTs[_srcOft][_dstChainId].dstPoolId\n                );\n            }\n        }\n\n        canExec = connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0;\n        execPayload = abi.encodeCall(\n            Balancer.rebalance,\n            (_srcOft, _dstChainId, _slippage, connectedOFTs[_srcOft][_dstChainId].rebalanceable, ercData)\n        );\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n\n    /**\n     * @notice set rebalancer role\n     * @param _addr the new address\n     */\n    function setRebalancer(address _addr) external onlyOwner {\n        rebalancer = _addr;\n        emit RebalancerUpdated(rebalancer, _addr);\n    }\n\n    /**\n     * @notice toggle swap eth\n     * @param _val true/false\n     */\n    function setSwapEth(bool _val) external onlyOwner {\n        emit ToggledSwapEth(disableEth, _val);\n        disableEth = _val;\n    }\n\n    /**\n     * @notice performs a rebalance operation\n     * @dev callable only by the owner\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _slippage the destination LayerZero id\n     * @param _amount the rebalanced amount\n     * @param _ercData custom send data\n     */\n    function rebalance(\n        address payable _srcOft,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        uint256 _amount,\n        bytes memory _ercData\n    ) external payable onlyValidDestination(_srcOft, _dstChainId) onlyValidSlippage(_slippage) {\n        if (msg.sender != owner() || msg.sender != rebalancer) revert NotAuthorized();\n\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable < _amount) {\n            revert RebalanceAmountNotSet();\n        }\n\n        //extract\n        ITOFT(_srcOft).extractUnderlying(_amount);\n\n        //send\n        {\n            bool _isNative = ITOFT(_srcOft).erc20() == address(0);\n            if (msg.value == 0) revert FeeAmountNotSet();\n            if (_isNative) {\n                if (disableEth) revert SwapNotEnabled();\n                _sendNative(_srcOft, _amount, _dstChainId, _slippage);\n            } else {\n                _sendToken(_srcOft, _amount, _dstChainId, _slippage, _ercData);\n            }\n\n            connectedOFTs[_srcOft][_dstChainId].rebalanceable -= _amount;\n            emit Rebalanced(_srcOft, _dstChainId, _slippage, _amount, _isNative);\n        }\n    }\n\n    /**\n     * @notice saves token/native gas from this contract\n     * @param _token the token address; `address(0)` should be passed for the Native coin\n     * @param _amount the amount to be saved\n     */\n    function emergencySaveTokens(address _token, uint256 _amount) external onlyOwner {\n        if (_token == address(0)) {\n            (bool sent,) = msg.sender.call{value: _amount}(\"\");\n            if (!sent) revert Failed();\n            emit EmergencySaved(_token, _amount, true);\n        } else {\n            IERC20(_token).safeTransfer(msg.sender, _amount);\n            emit EmergencySaved(_token, _amount, false);\n        }\n    }\n\n    /**\n     * @notice registeres mTapiocaOFT for rebalancing\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _dstOft the destination TOFT address\n     * @param _ercData custom send data\n     */\n    function initConnectedOFT(address _srcOft, uint16 _dstChainId, address _dstOft, bytes memory _ercData)\n        external\n        onlyOwner\n    {\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0) {\n            revert AlreadyInitialized();\n        }\n        bool isNative = ITOFT(_srcOft).erc20() == address(0);\n        if (!isNative && _ercData.length == 0) revert PoolInfoRequired();\n\n        (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_ercData, (uint256, uint256));\n\n        OFTData memory oftData =\n            OFTData({srcPoolId: _srcPoolId, dstPoolId: _dstPoolId, dstOft: _dstOft, rebalanceable: 0});\n\n        connectedOFTs[_srcOft][_dstChainId] = oftData;\n        emit ConnectedChainUpdated(_srcOft, _dstChainId, _dstOft);\n    }\n\n    /**\n     * @notice assings more rebalanceable amount for TOFT\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _amount the rebalanced amount\n     */\n    function addRebalanceAmount(address _srcOft, uint16 _dstChainId, uint256 _amount)\n        external\n        onlyValidDestination(_srcOft, _dstChainId)\n        onlyOwner\n    {\n        connectedOFTs[_srcOft][_dstChainId].rebalanceable += _amount;\n        uint256 totalToftSupply = ITOFTVault(ITOFT(_srcOft).vault()).viewSupply();\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > totalToftSupply) {\n            revert RebalanceAmountNotValid();\n        }\n        emit RebalanceAmountUpdated(_srcOft, _dstChainId, _amount, connectedOFTs[_srcOft][_dstChainId].rebalanceable);\n    }\n\n    function retryRevert(uint16 _srcChainId, bytes calldata _srcAddress, uint256 _nonce) external payable onlyOwner {\n        router.retryRevert{value: msg.value}(_srcChainId, _srcAddress, _nonce);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _sendNative(address payable _oft, uint256 _amount, uint16 _dstChainId, uint256 _slippage) private {\n        if (address(this).balance < _amount) revert ExceedsBalance();\n        uint256 valueAmount = msg.value + _amount;\n        routerETH.swapETH{value: valueAmount}(\n            _dstChainId,\n            payable(this),\n            abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft),\n            _amount,\n            _computeMinAmount(_amount, _slippage)\n        );\n    }\n\n    function _sendToken(\n        address payable _oft,\n        uint256 _amount,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        bytes memory _data\n    ) private {\n        address erc20 = ITOFT(_oft).erc20();\n        if (IERC20Metadata(erc20).balanceOf(address(this)) < _amount) {\n            revert ExceedsBalance();\n        }\n        {\n            (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_data, (uint256, uint256));\n            _routerSwap(_dstChainId, _srcPoolId, _dstPoolId, _amount, _slippage, _oft, erc20);\n        }\n    }\n\n    function _routerSwap(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        uint256 _amount,\n        uint256 _slippage,\n        address payable _oft,\n        address _erc20\n    ) private {\n        bytes memory _dst = abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft);\n        IERC20(_erc20).safeApprove(address(router), _amount);\n        router.swap{value: msg.value}(\n            _dstChainId,\n            _srcPoolId,\n            _dstPoolId,\n            payable(this),\n            _amount,\n            _computeMinAmount(_amount, _slippage),\n            IStargateRouterBase.lzTxObj({dstGasForCall: 0, dstNativeAmount: 0, dstNativeAddr: \"0x0\"}),\n            _dst,\n            \"0x\"\n        );\n    }\n\n    function _computeMinAmount(uint256 _amount, uint256 _slippage) private pure returns (uint256) {\n        return _amount - ((_amount * _slippage) / 1e5);\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/Balancer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IStargateRouter, IStargateRouterBase} from \"tapioca-periph/interfaces/external/stargate/IStargateRouter.sol\";\nimport {IStargateEthVault} from \"tapioca-periph/interfaces/external/stargate/IStargateEthVault.sol\";\nimport {ITOFTVault} from \"tapioca-periph/interfaces/tapiocaz/ITOFTVault.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Balancer\n * @author TapiocaDAO\n * @notice Rebalances mTOFT by transferring underlying tokens to other layers through Stargate\n */\ncontract Balancer is Ownable {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice current OFT => chain => destination OFT\n     * @dev chain ids (https://stargateprotocol.gitbook.io/stargate/developers/chain-ids):\n     *         - Ethereum: 101\n     *         - BNB: 102\n     *         - Avalanche: 106\n     *         - Polygon: 109\n     *         - Arbitrum: 110\n     *         - Optimism: 111\n     *         - Fantom: 112\n     *         - Metis: 151\n     *     pool ids https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\n     */\n    mapping(address => mapping(uint16 => OFTData)) public connectedOFTs;\n\n    struct OFTData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        address dstOft;\n        uint256 rebalanceable;\n    }\n\n    IStargateRouter public immutable routerETH;\n    IStargateRouter public immutable router;\n\n    address public rebalancer;\n\n    // @dev swapEth is not available on some chains\n    bool public disableEth;\n\n    event ConnectedChainUpdated(address indexed _srcOft, uint16 indexed _dstChainId, address indexed _dstOft);\n    event Rebalanced(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _slippage, uint256 _amount, bool _isNative\n    );\n    event RebalanceAmountUpdated(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _amount, uint256 _totalAmount\n    );\n    event ToggledSwapEth(bool indexed _old, bool indexed _new);\n    event EmergencySaved(address indexed _token, uint256 indexed _amount, bool indexed _native);\n    event RebalancerUpdated(address indexed prev, address indexed current);\n\n    error NotAuthorized();\n    error RouterNotValid();\n    error ExceedsBalance();\n    error DestinationNotValid();\n    error SlippageNotValid();\n    error FeeAmountNotSet();\n    error PoolInfoRequired();\n    error RebalanceAmountNotSet();\n    error Failed();\n    error SwapNotEnabled();\n    error AlreadyInitialized();\n    error RebalanceAmountNotValid();\n\n    modifier onlyValidDestination(address _srcOft, uint16 _dstChainId) {\n        if (connectedOFTs[_srcOft][_dstChainId].dstOft == address(0)) {\n            revert DestinationNotValid();\n        }\n        _;\n    }\n\n    modifier onlyValidSlippage(uint256 _slippage) {\n        // @dev a slippage higher than 20% shouldn't be necessary\n        if (_slippage >= 2e4) revert SlippageNotValid();\n        _;\n    }\n\n    constructor(address _routerETH, address _router, address _owner) {\n        if (_router == address(0)) revert RouterNotValid();\n        if (_routerETH == address(0)) revert RouterNotValid();\n        routerETH = IStargateRouter(_routerETH);\n        router = IStargateRouter(_router);\n\n        transferOwnership(_owner);\n        rebalancer = _owner;\n        emit RebalancerUpdated(address(0), _owner);\n    }\n\n    receive() external payable {}\n\n    /// =====================\n    /// View\n    /// =====================\n    function checker(address payable _srcOft, uint16 _dstChainId, uint256 _slippage)\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        bytes memory ercData;\n        {\n            if (ITOFT(_srcOft).erc20() != address(0)) {\n                ercData = abi.encode(\n                    connectedOFTs[_srcOft][_dstChainId].srcPoolId, connectedOFTs[_srcOft][_dstChainId].dstPoolId\n                );\n            }\n        }\n\n        canExec = connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0;\n        execPayload = abi.encodeCall(\n            Balancer.rebalance,\n            (_srcOft, _dstChainId, _slippage, connectedOFTs[_srcOft][_dstChainId].rebalanceable, ercData)\n        );\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n\n    /**\n     * @notice set rebalancer role\n     * @param _addr the new address\n     */\n    function setRebalancer(address _addr) external onlyOwner {\n        rebalancer = _addr;\n        emit RebalancerUpdated(rebalancer, _addr);\n    }\n\n    /**\n     * @notice toggle swap eth\n     * @param _val true/false\n     */\n    function setSwapEth(bool _val) external onlyOwner {\n        emit ToggledSwapEth(disableEth, _val);\n        disableEth = _val;\n    }\n\n    /**\n     * @notice performs a rebalance operation\n     * @dev callable only by the owner\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _slippage the destination LayerZero id\n     * @param _amount the rebalanced amount\n     * @param _ercData custom send data\n     */\n    function rebalance(\n        address payable _srcOft,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        uint256 _amount,\n        bytes memory _ercData\n    ) external payable onlyValidDestination(_srcOft, _dstChainId) onlyValidSlippage(_slippage) {\n        if (msg.sender != owner() || msg.sender != rebalancer) revert NotAuthorized();\n\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable < _amount) {\n            revert RebalanceAmountNotSet();\n        }\n\n        //extract\n        ITOFT(_srcOft).extractUnderlying(_amount);\n\n        //send\n        {\n            bool _isNative = ITOFT(_srcOft).erc20() == address(0);\n            if (msg.value == 0) revert FeeAmountNotSet();\n            if (_isNative) {\n                if (disableEth) revert SwapNotEnabled();\n                _sendNative(_srcOft, _amount, _dstChainId, _slippage);\n            } else {\n                _sendToken(_srcOft, _amount, _dstChainId, _slippage, _ercData);\n            }\n\n            connectedOFTs[_srcOft][_dstChainId].rebalanceable -= _amount;\n            emit Rebalanced(_srcOft, _dstChainId, _slippage, _amount, _isNative);\n        }\n    }\n\n    /**\n     * @notice saves token/native gas from this contract\n     * @param _token the token address; `address(0)` should be passed for the Native coin\n     * @param _amount the amount to be saved\n     */\n    function emergencySaveTokens(address _token, uint256 _amount) external onlyOwner {\n        if (_token == address(0)) {\n            (bool sent,) = msg.sender.call{value: _amount}(\"\");\n            if (!sent) revert Failed();\n            emit EmergencySaved(_token, _amount, true);\n        } else {\n            IERC20(_token).safeTransfer(msg.sender, _amount);\n            emit EmergencySaved(_token, _amount, false);\n        }\n    }\n\n    /**\n     * @notice registeres mTapiocaOFT for rebalancing\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _dstOft the destination TOFT address\n     * @param _ercData custom send data\n     */\n    function initConnectedOFT(address _srcOft, uint16 _dstChainId, address _dstOft, bytes memory _ercData)\n        external\n        onlyOwner\n    {\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0) {\n            revert AlreadyInitialized();\n        }\n        bool isNative = ITOFT(_srcOft).erc20() == address(0);\n        if (!isNative && _ercData.length == 0) revert PoolInfoRequired();\n\n        (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_ercData, (uint256, uint256));\n\n        OFTData memory oftData =\n            OFTData({srcPoolId: _srcPoolId, dstPoolId: _dstPoolId, dstOft: _dstOft, rebalanceable: 0});\n\n        connectedOFTs[_srcOft][_dstChainId] = oftData;\n        emit ConnectedChainUpdated(_srcOft, _dstChainId, _dstOft);\n    }\n\n    /**\n     * @notice assings more rebalanceable amount for TOFT\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _amount the rebalanced amount\n     */\n    function addRebalanceAmount(address _srcOft, uint16 _dstChainId, uint256 _amount)\n        external\n        onlyValidDestination(_srcOft, _dstChainId)\n        onlyOwner\n    {\n        connectedOFTs[_srcOft][_dstChainId].rebalanceable += _amount;\n        uint256 totalToftSupply = ITOFTVault(ITOFT(_srcOft).vault()).viewSupply();\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > totalToftSupply) {\n            revert RebalanceAmountNotValid();\n        }\n        emit RebalanceAmountUpdated(_srcOft, _dstChainId, _amount, connectedOFTs[_srcOft][_dstChainId].rebalanceable);\n    }\n\n    function retryRevert(uint16 _srcChainId, bytes calldata _srcAddress, uint256 _nonce) external payable onlyOwner {\n        router.retryRevert{value: msg.value}(_srcChainId, _srcAddress, _nonce);\n    }"
    }
  ]
}