{
  "Title": "[M-03] Governance Voting Dis-proportionally Favours Users Who Stake And Vote After A Poll Has Been Created And Had Its Snapshot Taken",
  "Content": "\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/contract.rs#L543-L580><br>\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/contract.rs#L582-L665><br>\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/staking.rs#L15-L57><br>\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/contract.rs#L364-L455><br>\n\nPolls are created by targeting the `receive_cw20` function which is queried whenever the contract receives tokens. By setting the hook message to `Cw20HookMsg::CreatePoll`, the sender is able to create a poll, assuming the amount sent satisfies the minimum deposit amount for poll creation. Users can also choose to call `ExecuteMsg::SnapshotPoll` or have it handled automatically when a user casts a vote on the newly created poll.\n\nThe snapshot simply sets `a_poll.staked_amount`, which represents the total staked amount within the governance contract at a given block. However, during the voting period, other users can stake tokens and effectively have an increasing influence over the outcome of a given poll. There are no check-pointed balances to ensure that a certain user had staked tokens at the time the poll had its snapshot taken.\n\nThis can be abused to skew poll results in favour of users who stake their Anchor tokens after a poll has had its snapshot taken.\n\n### Proof of Concept\n\nLet's assume the share to token exchange rate is `1:1` such that if a user deposits 100 Anchor tokens, they receive 100 shares in return.\n\nConsider the following scenario:\n\n*   There are a total of 100 Anchor tokens in the Governance contract.\n*   Alice creates a poll and executes `ExecuteMsg::SnapshotPoll` such that `a_poll.staked_amount == 100`.\n*   Bob deposits 10 Anchor tokens through the `Cw20HookMsg::StakeVotingTokens` hook message which increases the contract's total balance to 110 and shares to 110 as the exchange rate is `1:1` upon minting and redeeming shares.\n*   At this point, the target poll has a `a_poll.staked_amount == 100`, even though there are really 110 Anchor tokens staked.\n*   As a result, if Bob votes on a poll, they have a 10% degree of influence on the outcome of the poll, even though they have less than 10% of the total staked tokens (i.e. 10/110).\n*   Therefore, poll voters are actually incentivised to stake tokens after a poll has had its snapshot taken in order to maximise their voting power.\n\n### Recommended Mitigation Steps\n\nConsider implementing a check-pointing mechanism such that when a user casts a vote, the user's staked balance is checked at the block height upon which the snapshot was taken instead of checking its most up-to-date staked balance. This check-pointing behaviour is implemented on Ethereum which has a more restrictive block space. The mechanism will simply store the staker's balance on each stake/unstake action. When user's wish to vote, the protocol will check the balance at a specific block (i.e. the snapshotted block). An example implementation can be found [here](https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol#L189-L221).\n\n**[bitn8 (Anchor) disagreed with severity and commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/64#issuecomment-1103012664):**\n > I wouldn't call this a critical bug. Nevertheless, this will be addressed with ve-ANC tokenomics where tokens have to lock for periods of time (curve lock tokenomics). \n\n**[Alex the Entreprenerd (triage) commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/64#issuecomment-1207279376):**\n > Loss of Yield = Medium seems appropriate\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-anchor-contest",
  "Code": [
    {
      "filename": "contracts/anchor-token-contracts/contracts/gov/src/contract.rs",
      "content": "use crate::error::ContractError;\nuse crate::staking::{query_staker, stake_voting_tokens, withdraw_voting_tokens};\nuse crate::state::{\n    bank_read, bank_store, config_read, config_store, poll_indexer_store, poll_read, poll_store,\n    poll_voter_read, poll_voter_store, read_poll_voters, read_polls, read_tmp_poll_id, state_read,\n    state_store, store_tmp_poll_id, Config, ExecuteData, Poll, State,\n};\n\nuse astroport::querier::query_token_balance;\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    attr, from_binary, to_binary, Binary, CanonicalAddr, CosmosMsg, Decimal, Deps, DepsMut, Env,\n    MessageInfo, Reply, Response, StdError, StdResult, SubMsg, Uint128, WasmMsg,\n};\nuse cw20::{Cw20ExecuteMsg, Cw20ReceiveMsg};\n\nuse anchor_token::common::OrderBy;\nuse anchor_token::gov::{\n    ConfigResponse, Cw20HookMsg, ExecuteMsg, InstantiateMsg, PollExecuteMsg, PollResponse,\n    PollStatus, PollsResponse, QueryMsg, StateResponse, VoteOption, VoterInfo, VotersResponse,\n    VotersResponseItem,\n};\n\nconst MIN_TITLE_LENGTH: usize = 4;\nconst MAX_TITLE_LENGTH: usize = 64;\nconst MIN_DESC_LENGTH: usize = 4;\nconst MAX_DESC_LENGTH: usize = 1024;\nconst MIN_LINK_LENGTH: usize = 12;\nconst MAX_LINK_LENGTH: usize = 128;\n\nconst POLL_EXECUTE_REPLY_ID: u64 = 1;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -> Result<Response, ContractError> {\n    validate_quorum(msg.quorum)?;\n    validate_threshold(msg.threshold)?;\n\n    let config = Config {\n        anchor_token: CanonicalAddr::from(vec![]),\n        owner: deps.api.addr_canonicalize(info.sender.as_str())?,\n        quorum: msg.quorum,\n        threshold: msg.threshold,\n        voting_period: msg.voting_period,\n        timelock_period: msg.timelock_period,\n        expiration_period: 0u64, // Depricated\n        proposal_deposit: msg.proposal_deposit,\n        snapshot_period: msg.snapshot_period,\n    };\n\n    let state = State {\n        contract_addr: deps.api.addr_canonicalize(env.contract.address.as_str())?,\n        poll_count: 0,\n        total_share: Uint128::zero(),\n        total_deposit: Uint128::zero(),\n    };\n\n    config_store(deps.storage).save(&config)?;\n    state_store(deps.storage).save(&state)?;\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -> Result<Response, ContractError> {\n    match msg {\n        ExecuteMsg::Receive(msg) => receive_cw20(deps, env, info, msg),\n        ExecuteMsg::ExecutePollMsgs { poll_id } => execute_poll_messages(deps, env, info, poll_id),\n        ExecuteMsg::RegisterContracts { anchor_token } => register_contracts(deps, anchor_token),\n        ExecuteMsg::UpdateConfig {\n            owner,\n            quorum,\n            threshold,\n            voting_period,\n            timelock_period,\n            proposal_deposit,\n            snapshot_period,\n        } => update_config(\n            deps,\n            info,\n            owner,\n            quorum,\n            threshold,\n            voting_period,\n            timelock_period,\n            proposal_deposit,\n            snapshot_period,\n        ),\n        ExecuteMsg::WithdrawVotingTokens { amount } => withdraw_voting_tokens(deps, info, amount),\n        ExecuteMsg::CastVote {\n            poll_id,\n            vote,\n            amount,\n        } => cast_vote(deps, env, info, poll_id, vote, amount),\n        ExecuteMsg::EndPoll { poll_id } => end_poll(deps, env, poll_id),\n        ExecuteMsg::ExecutePoll { poll_id } => execute_poll(deps, env, poll_id),\n        ExecuteMsg::SnapshotPoll { poll_id } => snapshot_poll(deps, env, poll_id),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(deps: DepsMut, _env: Env, msg: Reply) -> Result<Response, ContractError> {\n    match msg.id {\n        POLL_EXECUTE_REPLY_ID => {\n            let poll_id: u64 = read_tmp_poll_id(deps.storage)?;\n            fail_poll(deps, poll_id)\n        }\n        _ => Err(ContractError::InvalidReplyId {}),\n    }\n}\n\npub fn register_contracts(deps: DepsMut, anchor_token: String) -> Result<Response, ContractError> {\n    let mut config: Config = config_read(deps.storage).load()?;\n    if config.anchor_token != CanonicalAddr::from(vec![]) {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    config.anchor_token = deps.api.addr_canonicalize(&anchor_token)?;\n    config_store(deps.storage).save(&config)?;\n\n    Ok(Response::default())\n}\n\npub fn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -> Result<Response, ContractError> {\n    // only asset contract can execute this message\n    let config: Config = config_read(deps.storage).load()?;\n    if config.anchor_token != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    match from_binary(&cw20_msg.msg) {\n        Ok(Cw20HookMsg::StakeVotingTokens {}) => {\n            let api = deps.api;\n            stake_voting_tokens(deps, api.addr_validate(&cw20_msg.sender)?, cw20_msg.amount)\n        }\n        Ok(Cw20HookMsg::CreatePoll {\n            title,\n            description,\n            link,\n            execute_msgs,\n        }) => create_poll(\n            deps,\n            env,\n            cw20_msg.sender,\n            cw20_msg.amount,\n            title,\n            description,\n            link,\n            execute_msgs,\n        ),\n        _ => Err(ContractError::DataShouldBeGiven {}),\n    }\n}\n\n#[allow(clippy::too_many_arguments)]\npub fn update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    owner: Option<String>,\n    quorum: Option<Decimal>,\n    threshold: Option<Decimal>,\n    voting_period: Option<u64>,\n    timelock_period: Option<u64>,\n    proposal_deposit: Option<Uint128>,\n    snapshot_period: Option<u64>,\n) -> Result<Response, ContractError> {\n    let api = deps.api;\n    config_store(deps.storage).update(|mut config| {\n        if config.owner != api.addr_canonicalize(info.sender.as_str())? {\n            return Err(ContractError::Unauthorized {});\n        }\n\n        if let Some(owner) = owner {\n            config.owner = api.addr_canonicalize(&owner)?;\n        }\n\n        if let Some(quorum) = quorum {\n            config.quorum = quorum;\n        }\n\n        if let Some(threshold) = threshold {\n            config.threshold = threshold;\n        }\n\n        if let Some(voting_period) = voting_period {\n            config.voting_period = voting_period;\n        }\n\n        if let Some(timelock_period) = timelock_period {\n            config.timelock_period = timelock_period;\n        }\n\n        if let Some(proposal_deposit) = proposal_deposit {\n            config.proposal_deposit = proposal_deposit;\n        }\n\n        if let Some(period) = snapshot_period {\n            config.snapshot_period = period;\n        }\n\n        Ok(config)\n    })?;\n\n    Ok(Response::new().add_attributes(vec![(\"action\", \"update_config\")]))\n}\n\n/// validate_title returns an error if the title is invalid\nfn validate_title(title: &str) -> StdResult<()> {\n    if title.len() < MIN_TITLE_LENGTH {\n        Err(StdError::generic_err(\"Title too short\"))\n    } else if title.len() > MAX_TITLE_LENGTH {\n        Err(StdError::generic_err(\"Title too long\"))\n    } else {\n        Ok(())\n    }\n}\n\n/// validate_description returns an error if the description is invalid\nfn validate_description(description: &str) -> StdResult<()> {\n    if description.len() < MIN_DESC_LENGTH {\n        Err(StdError::generic_err(\"Description too short\"))\n    } else if description.len() > MAX_DESC_LENGTH {\n        Err(StdError::generic_err(\"Description too long\"))\n    } else {\n        Ok(())\n    }\n}\n\n/// validate_link returns an error if the link is invalid\nfn validate_link(link: &Option<String>) -> StdResult<()> {\n    if let Some(link) = link {\n        if link.len() < MIN_LINK_LENGTH {\n            Err(StdError::generic_err(\"Link too short\"))\n        } else if link.len() > MAX_LINK_LENGTH {\n            Err(StdError::generic_err(\"Link too long\"))\n        } else {\n            Ok(())\n        }\n    } else {\n        Ok(())\n    }\n}\n\n/// validate_quorum returns an error if the quorum is invalid\n/// (we require 0-1)\nfn validate_quorum(quorum: Decimal) -> StdResult<()> {\n    if quorum > Decimal::one() {\n        Err(StdError::generic_err(\"quorum must be 0 to 1\"))\n    } else {\n        Ok(())\n    }\n}\n\n/// validate_threshold returns an error if the threshold is invalid\n/// (we require 0-1)\nfn validate_threshold(threshold: Decimal) -> StdResult<()> {\n    if threshold > Decimal::one() {\n        Err(StdError::generic_err(\"threshold must be 0 to 1\"))\n    } else {\n        Ok(())\n    }\n}\n\n#[allow(clippy::too_many_arguments)]\n/// create a new poll\npub fn create_poll(\n    deps: DepsMut,\n    env: Env,\n    proposer: String,\n    deposit_amount: Uint128,\n    title: String,\n    description: String,\n    link: Option<String>,\n    execute_msgs: Option<Vec<PollExecuteMsg>>,\n) -> Result<Response, ContractError> {\n    validate_title(&title)?;\n    validate_description(&description)?;\n    validate_link(&link)?;\n\n    let config: Config = config_store(deps.storage).load()?;\n    if deposit_amount < config.proposal_deposit {\n        return Err(ContractError::InsufficientProposalDeposit(\n            config.proposal_deposit.u128(),\n        ));\n    }\n\n    let mut state: State = state_store(deps.storage).load()?;\n    let poll_id = state.poll_count + 1;\n\n    // Increase poll count & total deposit amount\n    state.poll_count += 1;\n    state.total_deposit += deposit_amount;\n\n    let mut data_list: Vec<ExecuteData> = vec![];\n    let all_execute_data = if let Some(exe_msgs) = execute_msgs {\n        for msgs in exe_msgs {\n            let execute_data = ExecuteData {\n                order: msgs.order,\n                contract: deps.api.addr_canonicalize(&msgs.contract)?,\n                msg: msgs.msg,\n            };\n            data_list.push(execute_data)\n        }\n        Some(data_list)\n    } else {\n        None\n    };\n\n    let sender_address_raw = deps.api.addr_canonicalize(&proposer)?;\n    let new_poll = Poll {\n        id: poll_id,\n        creator: sender_address_raw,\n        status: PollStatus::InProgress,\n        yes_votes: Uint128::zero(),\n        no_votes: Uint128::zero(),\n        end_height: env.block.height + config.voting_period,\n        title,\n        description,\n        link,\n        execute_data: all_execute_data,\n        deposit_amount,\n        total_balance_at_end_poll: None,\n        staked_amount: None,\n    };\n\n    poll_store(deps.storage).save(&poll_id.to_be_bytes(), &new_poll)?;\n    poll_indexer_store(deps.storage, &PollStatus::InProgress)\n        .save(&poll_id.to_be_bytes(), &true)?;\n\n    state_store(deps.storage).save(&state)?;\n\n    Ok(Response::new().add_attributes(vec![\n        (\"action\", \"create_poll\"),\n        (\n            \"creator\",\n            deps.api\n                .addr_humanize(&new_poll.creator)?\n                .to_string()\n                .as_str(),\n        ),\n        (\"poll_id\", &poll_id.to_string()),\n        (\"end_height\", new_poll.end_height.to_string().as_str()),\n    ]))\n}\n\n/*\n * Ends a poll.\n */\npub fn end_poll(deps: DepsMut, env: Env, poll_id: u64) -> Result<Response, ContractError> {\n    let mut a_poll: Poll = poll_store(deps.storage).load(&poll_id.to_be_bytes())?;\n\n    if a_poll.status != PollStatus::InProgress {\n        return Err(ContractError::PollNotInProgress {});\n    }\n\n    if a_poll.end_height > env.block.height {\n        return Err(ContractError::PollVotingPeriod {});\n    }\n\n    let no = a_poll.no_votes.u128();\n    let yes = a_poll.yes_votes.u128();\n\n    let tallied_weight = yes + no;\n\n    let mut poll_status = PollStatus::Rejected;\n    let mut rejected_reason = \"\";\n    let mut passed = false;\n\n    let mut messages: Vec<CosmosMsg> = vec![];\n    let config: Config = config_read(deps.storage).load()?;\n    let mut state: State = state_read(deps.storage).load()?;\n\n    let (quorum, staked_weight) = if state.total_share.u128() == 0 {\n        (Decimal::zero(), Uint128::zero())\n    } else if let Some(staked_amount) = a_poll.staked_amount {\n        (\n            Decimal::from_ratio(tallied_weight, staked_amount),\n            staked_amount,\n        )\n    } else {\n        let staked_weight = query_token_balance(\n            &deps.querier,\n            deps.api.addr_humanize(&config.anchor_token)?,\n            deps.api.addr_humanize(&state.contract_addr)?,\n        )?\n        .checked_sub(state.total_deposit)?;\n\n        (\n            Decimal::from_ratio(tallied_weight, staked_weight),\n            staked_weight,\n        )\n    };\n\n    if tallied_weight == 0 || quorum < config.quorum {\n        // Quorum: More than quorum of the total staked tokens at the end of the voting\n        // period need to have participated in the vote.\n        rejected_reason = \"Quorum not reached\";\n    } else {\n        if Decimal::from_ratio(yes, tallied_weight) > config.threshold {\n            //Threshold: More than 50% of the tokens that participated in the vote\n            // (after excluding “Abstain” votes) need to have voted in favor of the proposal (“Yes”).\n            poll_status = PollStatus::Passed;\n            passed = true;\n        } else {\n            rejected_reason = \"Threshold not reached\";\n        }\n\n        // Refunds deposit only when quorum is reached\n        if !a_poll.deposit_amount.is_zero() {\n            messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: deps.api.addr_humanize(&config.anchor_token)?.to_string(),\n                funds: vec![],\n                msg: to_binary(&Cw20ExecuteMsg::Transfer {\n                    recipient: deps.api.addr_humanize(&a_poll.creator)?.to_string(),\n                    amount: a_poll.deposit_amount,\n                })?,\n            }))\n        }\n    }\n\n    // Decrease total deposit amount\n    state.total_deposit = state.total_deposit.checked_sub(a_poll.deposit_amount)?;\n    state_store(deps.storage).save(&state)?;\n\n    // Update poll indexer\n    poll_indexer_store(deps.storage, &PollStatus::InProgress).remove(&a_poll.id.to_be_bytes());\n    poll_indexer_store(deps.storage, &poll_status).save(&a_poll.id.to_be_bytes(), &true)?;\n\n    // Update poll status\n    a_poll.status = poll_status;\n    a_poll.total_balance_at_end_poll = Some(staked_weight);\n    poll_store(deps.storage).save(&poll_id.to_be_bytes(), &a_poll)?;\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        (\"action\", \"end_poll\"),\n        (\"poll_id\", &poll_id.to_string()),\n        (\"rejected_reason\", rejected_reason),\n        (\"passed\", &passed.to_string()),\n    ]))\n}\n\n/*\n * Execute a msgs of passed poll as one submsg to catch failures\n */\npub fn execute_poll(deps: DepsMut, env: Env, poll_id: u64) -> Result<Response, ContractError> {\n    let config: Config = config_read(deps.storage).load()?;\n    let a_poll: Poll = poll_store(deps.storage).load(&poll_id.to_be_bytes())?;\n\n    if a_poll.status != PollStatus::Passed {\n        return Err(ContractError::PollNotPassed {});\n    }\n\n    if a_poll.end_height + config.timelock_period > env.block.height {\n        return Err(ContractError::TimelockNotExpired {});\n    }\n\n    store_tmp_poll_id(deps.storage, a_poll.id)?;\n\n    Ok(Response::new().add_submessage(SubMsg::reply_on_error(\n        CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: env.contract.address.to_string(),\n            msg: to_binary(&ExecuteMsg::ExecutePollMsgs { poll_id })?,\n            funds: vec![],\n        }),\n        POLL_EXECUTE_REPLY_ID,\n    )))\n}\n\n/*\n * Execute a msgs of a poll\n */\npub fn execute_poll_messages(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    poll_id: u64,\n) -> Result<Response, ContractError> {\n    if env.contract.address != info.sender {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let mut a_poll: Poll = poll_store(deps.storage).load(&poll_id.to_be_bytes())?;\n\n    poll_indexer_store(deps.storage, &PollStatus::Passed).remove(&poll_id.to_be_bytes());\n    poll_indexer_store(deps.storage, &PollStatus::Executed).save(&poll_id.to_be_bytes(), &true)?;\n\n    a_poll.status = PollStatus::Executed;\n    poll_store(deps.storage).save(&poll_id.to_be_bytes(), &a_poll)?;\n\n    let mut messages: Vec<CosmosMsg> = vec![];\n    if let Some(all_msgs) = a_poll.execute_data {\n        let mut msgs = all_msgs;\n        msgs.sort();\n        for msg in msgs {\n            messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: deps.api.addr_humanize(&msg.contract)?.to_string(),\n                msg: msg.msg,\n                funds: vec![],\n            }));\n        }\n    }\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        (\"action\", \"execute_poll\"),\n        (\"poll_id\", poll_id.to_string().as_str()),\n    ]))\n}\n\n/*\n * Set the status of a poll to Failed if execute_poll fails\n */\npub fn fail_poll(deps: DepsMut, poll_id: u64) -> Result<Response, ContractError> {\n    let mut a_poll: Poll = poll_store(deps.storage).load(&poll_id.to_be_bytes())?;\n\n    poll_indexer_store(deps.storage, &PollStatus::Passed).remove(&poll_id.to_be_bytes());\n    poll_indexer_store(deps.storage, &PollStatus::Failed).save(&poll_id.to_be_bytes(), &true)?;\n\n    a_poll.status = PollStatus::Failed;\n    poll_store(deps.storage).save(&poll_id.to_be_bytes(), &a_poll)?;\n\n    Ok(Response::new().add_attributes(vec![\n        (\"action\", \"fail_poll\"),\n        (\"poll_id\", poll_id.to_string().as_str()),\n    ]))\n}\n\n/// SnapshotPoll is used to take a snapshot of the staked amount for quorum calculation\npub fn snapshot_poll(deps: DepsMut, env: Env, poll_id: u64) -> Result<Response, ContractError> {\n    let config: Config = config_read(deps.storage).load()?;\n    let mut a_poll: Poll = poll_store(deps.storage).load(&poll_id.to_be_bytes())?;\n\n    if a_poll.status != PollStatus::InProgress {\n        return Err(ContractError::PollNotInProgress {});\n    }\n\n    let time_to_end = a_poll.end_height - env.block.height;\n\n    if time_to_end > config.snapshot_period {\n        return Err(ContractError::SnapshotHeight {});\n    }\n\n    if a_poll.staked_amount.is_some() {\n        return Err(ContractError::SnapshotAlreadyOccurred {});\n    }\n\n    // store the current staked amount for quorum calculation\n    let state: State = state_store(deps.storage).load()?;\n\n    let staked_amount = query_token_balance(\n        &deps.querier,\n        deps.api.addr_humanize(&config.anchor_token)?,\n        deps.api.addr_humanize(&state.contract_addr)?,\n    )?\n    .checked_sub(state.total_deposit)?;\n\n    a_poll.staked_amount = Some(staked_amount);\n\n    poll_store(deps.storage).save(&poll_id.to_be_bytes(), &a_poll)?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"snapshot_poll\"),\n        attr(\"poll_id\", poll_id.to_string().as_str()),\n        attr(\"staked_amount\", staked_amount.to_string().as_str()),\n    ]))\n}\n\npub fn cast_vote(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    poll_id: u64,\n    vote: VoteOption,\n    amount: Uint128,\n) -> Result<Response, ContractError> {\n    let sender_address_raw = deps.api.addr_canonicalize(info.sender.as_str())?;\n    let config = config_read(deps.storage).load()?;\n    let state = state_read(deps.storage).load()?;\n    if poll_id == 0 || state.poll_count < poll_id {\n        return Err(ContractError::PollNotFound {});\n    }\n\n    let mut a_poll: Poll = poll_store(deps.storage).load(&poll_id.to_be_bytes())?;\n    if a_poll.status != PollStatus::InProgress || env.block.height > a_poll.end_height {\n        return Err(ContractError::PollNotInProgress {});\n    }\n\n    // Check the voter already has a vote on the poll\n    if poll_voter_read(deps.storage, poll_id)\n        .load(sender_address_raw.as_slice())\n        .is_ok()\n    {\n        return Err(ContractError::AlreadyVoted {});\n    }\n\n    let key = &sender_address_raw.as_slice();\n    let mut token_manager = bank_read(deps.storage).may_load(key)?.unwrap_or_default();\n\n    // convert share to amount\n    let total_share = state.total_share;\n    let total_balance = query_token_balance(\n        &deps.querier,\n        deps.api.addr_humanize(&config.anchor_token)?,\n        deps.api.addr_humanize(&state.contract_addr)?,\n    )?\n    .checked_sub(state.total_deposit)?;\n\n    if token_manager\n        .share\n        .multiply_ratio(total_balance, total_share)\n        < amount\n    {\n        return Err(ContractError::InsufficientStaked {});\n    }\n\n    // update tally info\n    if VoteOption::Yes == vote {\n        a_poll.yes_votes += amount;\n    } else {\n        a_poll.no_votes += amount;\n    }\n\n    let vote_info = VoterInfo {\n        vote,\n        balance: amount,\n    };\n    token_manager\n        .locked_balance\n        .push((poll_id, vote_info.clone()));\n    bank_store(deps.storage).save(key, &token_manager)?;\n\n    // store poll voter && and update poll data\n    poll_voter_store(deps.storage, poll_id).save(sender_address_raw.as_slice(), &vote_info)?;\n\n    // processing snapshot\n    let time_to_end = a_poll.end_height - env.block.height;\n\n    if time_to_end < config.snapshot_period && a_poll.staked_amount.is_none() {\n        a_poll.staked_amount = Some(total_balance);\n    }\n\n    poll_store(deps.storage).save(&poll_id.to_be_bytes(), &a_poll)?;\n\n    Ok(Response::new().add_attributes(vec![\n        (\"action\", \"cast_vote\"),\n        (\"poll_id\", poll_id.to_string().as_str()),\n        (\"amount\", amount.to_string().as_str()),\n        (\"voter\", info.sender.as_str()),\n        (\"vote_option\", vote_info.vote.to_string().as_str()),\n    ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> Result<Binary, ContractError> {\n    match msg {\n        QueryMsg::Config {} => Ok(to_binary(&query_config(deps)?)?),\n        QueryMsg::State {} => Ok(to_binary(&query_state(deps)?)?),\n        QueryMsg::Staker { address } => Ok(to_binary(&query_staker(deps, address)?)?),\n        QueryMsg::Poll { poll_id } => Ok(to_binary(&query_poll(deps, poll_id)?)?),\n        QueryMsg::Polls {\n            filter,\n            start_after,\n            limit,\n            order_by,\n        } => Ok(to_binary(&query_polls(\n            deps,\n            filter,\n            start_after,\n            limit,\n            order_by,\n        )?)?),\n        QueryMsg::Voters {\n            poll_id,\n            start_after,\n            limit,\n            order_by,\n        } => Ok(to_binary(&query_voters(\n            deps,\n            poll_id,\n            start_after,\n            limit,\n            order_by,\n        )?)?),\n    }\n}\n\nfn query_config(deps: Deps) -> Result<ConfigResponse, ContractError> {\n    let config: Config = config_read(deps.storage).load()?;\n    Ok(ConfigResponse {\n        owner: deps.api.addr_humanize(&config.owner)?.to_string(),\n        anchor_token: deps.api.addr_humanize(&config.anchor_token)?.to_string(),\n        quorum: config.quorum,\n        threshold: config.threshold,\n        voting_period: config.voting_period,\n        timelock_period: config.timelock_period,\n        proposal_deposit: config.proposal_deposit,\n        snapshot_period: config.snapshot_period,\n    })\n}\n\nfn query_state(deps: Deps) -> Result<StateResponse, ContractError> {\n    let state: State = state_read(deps.storage).load()?;\n    Ok(StateResponse {\n        poll_count: state.poll_count,\n        total_share: state.total_share,\n        total_deposit: state.total_deposit,\n    })\n}\n\nfn query_poll(deps: Deps, poll_id: u64) -> Result<PollResponse, ContractError> {\n    let poll = match poll_read(deps.storage).may_load(&poll_id.to_be_bytes())? {\n        Some(poll) => Some(poll),\n        None => return Err(ContractError::PollNotFound {}),\n    }\n    .unwrap();\n\n    let mut data_list: Vec<PollExecuteMsg> = vec![];\n\n    Ok(PollResponse {\n        id: poll.id,\n        creator: deps.api.addr_humanize(&poll.creator)?.to_string(),\n        status: poll.status,\n        end_height: poll.end_height,\n        title: poll.title,\n        description: poll.description,\n        link: poll.link,\n        deposit_amount: poll.deposit_amount,\n        execute_data: if let Some(exe_msgs) = poll.execute_data.clone() {\n            for msg in exe_msgs {\n                let execute_data = PollExecuteMsg {\n                    order: msg.order,\n                    contract: deps.api.addr_humanize(&msg.contract)?.to_string(),\n                    msg: msg.msg,\n                };\n                data_list.push(execute_data)\n            }\n            Some(data_list)\n        } else {\n            None\n        },\n        yes_votes: poll.yes_votes,\n        no_votes: poll.no_votes,\n        staked_amount: poll.staked_amount,\n        total_balance_at_end_poll: poll.total_balance_at_end_poll,\n    })\n}\n\nfn query_polls(\n    deps: Deps,\n    filter: Option<PollStatus>,\n    start_after: Option<u64>,\n    limit: Option<u32>,\n    order_by: Option<OrderBy>,\n) -> Result<PollsResponse, ContractError> {\n    let polls = read_polls(deps.storage, filter, start_after, limit, order_by)?;\n\n    let poll_responses: StdResult<Vec<PollResponse>> = polls\n        .iter()\n        .map(|poll| {\n            Ok(PollResponse {\n                id: poll.id,\n                creator: deps.api.addr_humanize(&poll.creator)?.to_string(),\n                status: poll.status.clone(),\n                end_height: poll.end_height,\n                title: poll.title.to_string(),\n                description: poll.description.to_string(),\n                link: poll.link.clone(),\n                deposit_amount: poll.deposit_amount,\n                execute_data: if let Some(exe_msgs) = poll.execute_data.clone() {\n                    let mut data_list: Vec<PollExecuteMsg> = vec![];\n\n                    for msg in exe_msgs {\n                        let execute_data = PollExecuteMsg {\n                            order: msg.order,\n                            contract: deps.api.addr_humanize(&msg.contract)?.to_string(),\n                            msg: msg.msg,\n                        };\n                        data_list.push(execute_data)\n                    }\n                    Some(data_list)\n                } else {\n                    None\n                },\n                yes_votes: poll.yes_votes,\n                no_votes: poll.no_votes,\n                staked_amount: poll.staked_amount,\n                total_balance_at_end_poll: poll.total_balance_at_end_poll,\n            })\n        })\n        .collect();\n\n    Ok(PollsResponse {\n        polls: poll_responses?,\n    })\n}\n\nfn query_voters(\n    deps: Deps,\n    poll_id: u64,\n    start_after: Option<String>,\n    limit: Option<u32>,\n    order_by: Option<OrderBy>,\n) -> Result<VotersResponse, ContractError> {\n    let poll: Poll = match poll_read(deps.storage).may_load(&poll_id.to_be_bytes())? {\n        Some(poll) => Some(poll),\n        None => return Err(ContractError::PollNotFound {}),\n    }\n    .unwrap();\n\n    let voters = if poll.status != PollStatus::InProgress {\n        vec![]\n    } else if let Some(start_after) = start_after {\n        read_poll_voters(\n            deps.storage,\n            poll_id,\n            Some(deps.api.addr_canonicalize(&start_after)?),\n            limit,\n            order_by,\n        )?\n    } else {\n        read_poll_voters(deps.storage, poll_id, None, limit, order_by)?\n    };\n\n    let voters_response: StdResult<Vec<VotersResponseItem>> = voters\n        .iter()\n        .map(|voter_info| {\n            Ok(VotersResponseItem {\n                voter: deps.api.addr_humanize(&voter_info.0)?.to_string(),\n                vote: voter_info.1.vote.clone(),\n                balance: voter_info.1.balance,\n            })\n        })\n        .collect();\n\n    Ok(VotersResponse {\n        voters: voters_response?,\n    })\n}"
    },
    {
      "filename": "contracts/anchor-token-contracts/contracts/gov/src/contract.rs",
      "content": "use crate::error::ContractError;\nuse crate::staking::{query_staker, stake_voting_tokens, withdraw_voting_tokens};\nuse crate::state::{\n    bank_read, bank_store, config_read, config_store, poll_indexer_store, poll_read, poll_store,\n    poll_voter_read, poll_voter_store, read_poll_voters, read_polls, read_tmp_poll_id, state_read,\n    state_store, store_tmp_poll_id, Config, ExecuteData, Poll, State,\n};\n\nuse astroport::querier::query_token_balance;\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    attr, from_binary, to_binary, Binary, CanonicalAddr, CosmosMsg, Decimal, Deps, DepsMut, Env,\n    MessageInfo, Reply, Response, StdError, StdResult, SubMsg, Uint128, WasmMsg,\n};\nuse cw20::{Cw20ExecuteMsg, Cw20ReceiveMsg};\n\nuse anchor_token::common::OrderBy;\nuse anchor_token::gov::{\n    ConfigResponse, Cw20HookMsg, ExecuteMsg, InstantiateMsg, PollExecuteMsg, PollResponse,\n    PollStatus, PollsResponse, QueryMsg, StateResponse, VoteOption, VoterInfo, VotersResponse,\n    VotersResponseItem,\n};\n\nconst MIN_TITLE_LENGTH: usize = 4;\nconst MAX_TITLE_LENGTH: usize = 64;\nconst MIN_DESC_LENGTH: usize = 4;\nconst MAX_DESC_LENGTH: usize = 1024;\nconst MIN_LINK_LENGTH: usize = 12;\nconst MAX_LINK_LENGTH: usize = 128;\n\nconst POLL_EXECUTE_REPLY_ID: u64 = 1;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -> Result<Response, ContractError> {\n    validate_quorum(msg.quorum)?;\n    validate_threshold(msg.threshold)?;\n\n    let config = Config {\n        anchor_token: CanonicalAddr::from(vec![]),\n        owner: deps.api.addr_canonicalize(info.sender.as_str())?,\n        quorum: msg.quorum,\n        threshold: msg.threshold,\n        voting_period: msg.voting_period,\n        timelock_period: msg.timelock_period,\n        expiration_period: 0u64, // Depricated\n        proposal_deposit: msg.proposal_deposit,\n        snapshot_period: msg.snapshot_period,\n    };\n\n    let state = State {\n        contract_addr: deps.api.addr_canonicalize(env.contract.address.as_str())?,\n        poll_count: 0,\n        total_share: Uint128::zero(),\n        total_deposit: Uint128::zero(),\n    };\n\n    config_store(deps.storage).save(&config)?;\n    state_store(deps.storage).save(&state)?;\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -> Result<Response, ContractError> {\n    match msg {\n        ExecuteMsg::Receive(msg) => receive_cw20(deps, env, info, msg),\n        ExecuteMsg::ExecutePollMsgs { poll_id } => execute_poll_messages(deps, env, info, poll_id),\n        ExecuteMsg::RegisterContracts { anchor_token } => register_contracts(deps, anchor_token),\n        ExecuteMsg::UpdateConfig {\n            owner,\n            quorum,\n            threshold,\n            voting_period,\n            timelock_period,\n            proposal_deposit,\n            snapshot_period,\n        } => update_config(\n            deps,\n            info,\n            owner,\n            quorum,\n            threshold,\n            voting_period,\n            timelock_period,\n            proposal_deposit,\n            snapshot_period,\n        ),\n        ExecuteMsg::WithdrawVotingTokens { amount } => withdraw_voting_tokens(deps, info, amount),\n        ExecuteMsg::CastVote {\n            poll_id,\n            vote,\n            amount,\n        } => cast_vote(deps, env, info, poll_id, vote, amount),\n        ExecuteMsg::EndPoll { poll_id } => end_poll(deps, env, poll_id),\n        ExecuteMsg::ExecutePoll { poll_id } => execute_poll(deps, env, poll_id),\n        ExecuteMsg::SnapshotPoll { poll_id } => snapshot_poll(deps, env, poll_id),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(deps: DepsMut, _env: Env, msg: Reply) -> Result<Response, ContractError> {\n    match msg.id {\n        POLL_EXECUTE_REPLY_ID => {\n            let poll_id: u64 = read_tmp_poll_id(deps.storage)?;\n            fail_poll(deps, poll_id)\n        }\n        _ => Err(ContractError::InvalidReplyId {}),\n    }\n}\n\npub fn register_contracts(deps: DepsMut, anchor_token: String) -> Result<Response, ContractError> {\n    let mut config: Config = config_read(deps.storage).load()?;\n    if config.anchor_token != CanonicalAddr::from(vec![]) {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    config.anchor_token = deps.api.addr_canonicalize(&anchor_token)?;\n    config_store(deps.storage).save(&config)?;\n\n    Ok(Response::default())\n}\n\npub fn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -> Result<Response, ContractError> {\n    // only asset contract can execute this message\n    let config: Config = config_read(deps.storage).load()?;\n    if config.anchor_token != deps.api.addr_canonicalize(info"
    }
  ]
}