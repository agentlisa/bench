{
  "Title": "[M-27] Cross chain messages in `MagnetarAssetXChainModule` and `MagnetarMintXChainModule` will not work",
  "Content": "\nIn order to send LZ message `MagnetarBaseModule._withdrawToChain` function is called. This function allows to include composed message only [if `data.unwrap` is set to true](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/modules/MagnetarBaseModule.sol#L71-L81). In this case `_lzCustomWithdraw` function will be used, which [will include composed message](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/modules/MagnetarBaseModule.sol#L155).\n\nIn case if `!data.unwrap`, then `_lzWithdraw` function is called, which [calls `_prepareLzSend` function](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/modules/MagnetarBaseModule.sol#L120), which includes empty composed message. If you want to include composed message, then you should set `data.unwrap` as true.\n\nNow, let's look into `MagnetarMintXChainModule.mintBBLendXChainSGL` function, which [passes false](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/modules/MagnetarMintXChainModule.sol#L86). Then look into `MagnetarAssetXChainModule.depositYBLendSGLLockXchainTOLP` function, which [passes false](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/modules/MagnetarAssetXChainModule.sol#L104).\n\nAs both of them pass `data.unwrap` as false, it means that compose message will not be crafted and this cross chain functionality will not work.\n\n### Impact\n\nIt will be not possible to min `usdo` on one chain and lend it to singularity on another chain.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nPass ``data.unwrap` as true.\n\n### Assessed type\n\nError\n\n**[cryptotechmaker (Tapioca) confirmed and commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/62#issuecomment-2058663107):**\n > PR [here](https://github.com/Tapioca-DAO/tapioca-periph/pull/234/commits/e08f90070e35d7b08331909e1fcde279fe1ebc10).\n> \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/Magnetar/modules/MagnetarBaseModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {\n    PrepareLzCallData,\n    PrepareLzCallReturn,\n    ComposeMsgData\n} from \"tapioca-periph/tapiocaOmnichainEngine/extension/TapiocaOmnichainEngineHelper.sol\";\nimport {TapiocaOmnichainEngineHelper} from\n    \"tapioca-periph/tapiocaOmnichainEngine/extension/TapiocaOmnichainEngineHelper.sol\";\nimport {ITapiocaOmnichainEngine, LZSendParam} from \"tapioca-periph/interfaces/periph/ITapiocaOmnichainEngine.sol\";\nimport {MagnetarWithdrawData} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IOftSender} from \"tapioca-periph/interfaces/oft/IOftSender.sol\";\nimport {IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {MagnetarStorage} from \"../MagnetarStorage.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract MagnetarBaseModule is Ownable, MagnetarStorage {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    error Magnetar_GasMismatch(uint256 expected, uint256 received);\n    error Magnetar_TargetNotWhitelisted(address target);\n    error Magnetar_ExtractTokenFail();\n\n    constructor() MagnetarStorage(IPearlmit(address(0))) {}\n\n    /// =====================\n    /// Internal\n    /// =====================\n    function _withdrawToChain(MagnetarWithdrawData memory data) internal {\n        if (!cluster.isWhitelisted(0, address(data.yieldBox))) {\n            revert Magnetar_TargetNotWhitelisted(address(data.yieldBox));\n        }\n        IYieldBox _yieldBox = IYieldBox(data.yieldBox);\n\n        // perform a same chain withdrawal\n        if (data.lzSendParams.sendParam.dstEid == 0) {\n            _withdrawHere(_yieldBox, data.assetId, data.lzSendParams.sendParam.to, data.lzSendParams.sendParam.amountLD);\n            return;\n        }\n\n        // perform a cross chain withdrawal\n        (, address asset,,) = _yieldBox.assets(data.assetId);\n        if (!cluster.isWhitelisted(0, asset)) {\n            revert Magnetar_TargetNotWhitelisted(asset);\n        }\n\n        _yieldBox.withdraw(data.assetId, address(this), address(this), data.lzSendParams.sendParam.amountLD, 0);\n        // TODO: decide about try-catch here\n        if (data.unwrap) {\n            _lzCustomWithdraw(\n                asset,\n                data.lzSendParams,\n                data.sendGas,\n                data.sendVal,\n                data.composeGas,\n                data.composeVal,\n                data.composeMsgType\n            );\n        } else {\n            _lzWithdraw(asset, data.lzSendParams, data.sendGas, data.sendVal);\n        }\n    }\n\n    function _setApprovalForYieldBox(address _target, IYieldBox _yieldBox) internal {\n        bool isApproved = _yieldBox.isApprovedForAll(address(this), _target);\n        if (!isApproved) {\n            _yieldBox.setApprovalForAll(_target, true);\n        }\n    }\n\n    function _revertYieldBoxApproval(address _target, IYieldBox _yieldBox) internal {\n        bool isApproved = _yieldBox.isApprovedForAll(address(this), _target);\n        if (isApproved) {\n            _yieldBox.setApprovalForAll(_target, false);\n        }\n    }\n\n    function _extractTokens(address _from, address _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n        // IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n        bool isErr = pearlmit.transferFromERC20(_from, address(this), address(_token), _amount);\n        if (isErr) revert Magnetar_ExtractTokenFail();\n        uint256 balanceAfter = IERC20(_token).balanceOf(address(this));\n        if (balanceAfter <= balanceBefore) revert Magnetar_ExtractTokenFail();\n        return balanceAfter - balanceBefore;\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _withdrawHere(IYieldBox _yieldBox, uint256 _assetId, bytes32 _to, uint256 _amount) private {\n        _yieldBox.withdraw(_assetId, address(this), OFTMsgCodec.bytes32ToAddress(_to), _amount, 0);\n    }\n\n    function _lzWithdraw(address _asset, LZSendParam memory _lzSendParam, uint128 _lzSendGas, uint128 _lzSendVal)\n        private\n    {\n        PrepareLzCallReturn memory prepareLzCallReturn = _prepareLzSend(_asset, _lzSendParam, _lzSendGas, _lzSendVal);\n\n        if (msg.value < prepareLzCallReturn.msgFee.nativeFee) {\n            revert Magnetar_GasMismatch(prepareLzCallReturn.msgFee.nativeFee, msg.value);\n        }\n\n        IOftSender(_asset).sendPacket{value: prepareLzCallReturn.msgFee.nativeFee}(\n            prepareLzCallReturn.lzSendParam, prepareLzCallReturn.composeMsg\n        );\n    }\n\n    function _lzCustomWithdraw(\n        address _asset,\n        LZSendParam memory _lzSendParam,\n        uint128 _lzSendGas,\n        uint128 _lzSendVal,\n        uint128 _lzComposeGas,\n        uint128 _lzComposeVal,\n        uint16 _lzComposeMsgType\n    ) private {\n        PrepareLzCallReturn memory prepareLzCallReturn = _prepareLzSend(_asset, _lzSendParam, _lzSendGas, _lzSendVal);\n\n        TapiocaOmnichainEngineHelper _toeHelper = new TapiocaOmnichainEngineHelper();\n        PrepareLzCallReturn memory prepareLzCallReturn2 = _toeHelper.prepareLzCall(\n            ITapiocaOmnichainEngine(_asset),\n            PrepareLzCallData({\n                dstEid: _lzSendParam.sendParam.dstEid,\n                recipient: _lzSendParam.sendParam.to,\n                amountToSendLD: 0,\n                minAmountToCreditLD: 0,\n                msgType: _lzComposeMsgType,\n                composeMsgData: ComposeMsgData({\n                    index: 0,\n                    gas: _lzComposeGas,\n                    value: prepareLzCallReturn.msgFee.nativeFee.toUint128(),\n                    data: _lzSendParam.sendParam.composeMsg,\n                    prevData: bytes(\"\"),\n                    prevOptionsData: bytes(\"\")\n                }),\n                lzReceiveGas: _lzSendGas + _lzComposeGas,\n                lzReceiveValue: _lzComposeVal\n            })\n        );\n\n        if (msg.value < prepareLzCallReturn2.msgFee.nativeFee) {\n            revert Magnetar_GasMismatch(prepareLzCallReturn2.msgFee.nativeFee, msg.value);\n        }\n\n        IOftSender(_asset).sendPacket{value: prepareLzCallReturn2.msgFee.nativeFee}(\n            prepareLzCallReturn2.lzSendParam, prepareLzCallReturn2.composeMsg\n        );\n    }\n\n    function _prepareLzSend(address _asset, LZSendParam memory _lzSendParam, uint128 _lzSendGas, uint128 _lzSendVal)\n        private\n        returns (PrepareLzCallReturn memory prepareLzCallReturn)\n    {\n        TapiocaOmnichainEngineHelper _toeHelper = new TapiocaOmnichainEngineHelper();\n        prepareLzCallReturn = _toeHelper.prepareLzCall(\n            ITapiocaOmnichainEngine(_asset),\n            PrepareLzCallData({\n                dstEid: _lzSendParam.sendParam.dstEid,\n                recipient: _lzSendParam.sendParam.to,\n                amountToSendLD: _lzSendParam.sendParam.amountLD,\n                minAmountToCreditLD: _lzSendParam.sendParam.minAmountLD,\n                msgType: 1, // SEND\n                composeMsgData: ComposeMsgData({\n                    index: 0,\n                    gas: 0,\n                    value: 0,\n                    data: bytes(\"\"),\n                    prevData: bytes(\"\"),\n                    prevOptionsData: bytes(\"\")\n                }),\n                lzReceiveGas: _lzSendGas,\n                lzReceiveValue: _lzSendVal\n            })\n        );\n    }\n}"
    },
    {
      "filename": "contracts/Magnetar/modules/MagnetarBaseModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {\n    PrepareLzCallData,\n    PrepareLzCallReturn,\n    ComposeMsgData\n} from \"tapioca-periph/tapiocaOmnichainEngine/extension/TapiocaOmnichainEngineHelper.sol\";\nimport {TapiocaOmnichainEngineHelper} from\n    \"tapioca-periph/tapiocaOmnichainEngine/extension/TapiocaOmnichainEngineHelper.sol\";\nimport {ITapiocaOmnichainEngine, LZSendParam} from \"tapioca-periph/interfaces/periph/ITapiocaOmnichainEngine.sol\";\nimport {MagnetarWithdrawData} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IOftSender} from \"tapioca-periph/interfaces/oft/IOftSender.sol\";\nimport {IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {MagnetarStorage} from \"../MagnetarStorage.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract MagnetarBaseModule is Ownable, MagnetarStorage {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    error Magnetar_GasMismatch(uint256 expected, uint256 received);\n    error Magnetar_TargetNotWhitelisted(address target);\n    error Magnetar_ExtractTokenFail();\n\n    constructor() MagnetarStorage(IPearlmit(address(0))) {}\n\n    /// =====================\n    /// Internal\n    /// =====================\n    function _withdrawToChain(MagnetarWithdrawData memory data) internal {\n        if (!cluster.isWhitelisted(0, address(data.yieldBox))) {\n            revert Magnetar_TargetNotWhitelisted(address(data.yieldBox));\n        }\n        IYieldBox _yieldBox = IYieldBox(data.yieldBox);\n\n        // perform a same chain withdrawal\n        if (data.lzSendParams.sendParam.dstEid == 0) {\n            _withdrawHere(_yieldBox, data.assetId, data.lzSendParams.sendParam.to, data.lzSendParams.sendParam.amountLD);\n            return;\n        }\n\n        // perform a cross chain withdrawal\n        (, address asset,,) = _yieldBox.assets(data.assetId);\n        if (!cluster.isWhitelisted(0, asset)) {\n            revert Magnetar_TargetNotWhitelisted(asset);\n        }\n\n        _yieldBox.withdraw(data.assetId, address(this), address(this), data.lzSendParams.sendParam.amountLD, 0);\n        // TODO: decide about try-catch here\n        if (data.unwrap) {\n            _lzCustomWithdraw(\n                asset,\n                data.lzSendParams,\n                data.sendGas,\n                data.sendVal,\n                data.composeGas,\n                data.composeVal,\n                data.composeMsgType\n            );\n        } else {\n            _lzWithdraw(asset, data.lzSendParams, data.sendGas, data.sendVal);\n        }\n    }\n\n    function _setApprovalForYieldBox(address _target, IYieldBox _yieldBox) internal {\n        bool isApproved = _yieldBox.isApprovedForAll(address(this), _target);\n        if (!isApproved) {\n            _yieldBox.setApprovalForAll(_target, true);\n        }\n    }\n\n    function _revertYieldBoxApproval(address _target, IYieldBox _yieldBox) internal {\n        bool isApproved = _yieldBox.isApprovedForAll(address(this), _target);\n        if (isApproved) {\n            _yieldBox.setApprovalForAll(_target, false);\n        }\n    }\n\n    function _extractTokens(address _from, address _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n        // IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n        bool isErr = pearlmit.transferFromERC20(_from, address(this), address(_token), _amount);\n        if (isErr) revert Magnetar_ExtractTokenFail();\n        uint256 balanceAfter = IERC20(_token).balanceOf(address(this));\n        if (balanceAfter <= balanceBefore) revert Magnetar_ExtractTokenFail();\n        return balanceAfter - balanceBefore;\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _withdrawHere(IYieldBox _yieldBox, uint256 _assetId, bytes32 _to, uint256 _amount) private {\n        _yieldBox.withdraw(_assetId, address(this), OFTMsgCodec.bytes32ToAddress(_to), _amount, 0);\n    }\n\n    function _lzWithdraw(address _asset, LZSendParam memory _lzSendParam, uint128 _lzSendGas, uint128 _lzSendVal)\n        private\n    {\n        PrepareLzCallReturn memory prepareLzCallReturn = _prepareLzSend(_asset, _lzSendParam, _lzSendGas, _lzSendVal);\n\n        if (msg.value < prepareLzCallReturn.msgFee.nativeFee) {\n            revert Magnetar_GasMismatch(prepareLzCallReturn.msgFee.nativeFee, msg.value);\n        }\n\n        IOftSender(_asset).sendPacket{value: prepareLzCallReturn.msgFee.nativeFee}(\n            prepareLzCallReturn.lzSendParam, prepareLzCallReturn.composeMsg\n        );\n    }\n\n    function _lzCustomWithdraw(\n        address _asset,\n        LZSendParam memory _lzSendParam,\n        uint128 _lzSendGas,\n        uint128 _lzSendVal,\n        uint128 _lzComposeGas,\n        uint128 _lzComposeVal,\n        uint16 _lzComposeMsgType\n    ) private {\n        PrepareLzCallReturn memory prepareLzCallReturn = _prepareLzSend(_asset, _lzSendParam, _lzSendGas, _lzSendVal);\n\n        TapiocaOmnichainEngineHelper _toeHelper = new TapiocaOmnichainEngineHelper();\n        PrepareLzCallReturn memory prepareLzCallReturn2 = _toeHelper.prepareLzCall(\n            ITapiocaOmnichainEngine(_asset),\n            PrepareLzCallData({\n                dstEid: _lzSendParam.sendParam.dstEid,\n                recipient: _lzSendParam.sendParam.to,\n                amountToSendLD: 0,\n                minAmountToCreditLD: 0,\n                msgType: _lzComposeMsgType,\n                composeMsgData: ComposeMsgData({\n                    index: 0,\n                    gas: _lzComposeGas,\n                    value: prepareLzCallReturn.msgFee.nativeFee.toUint128(),\n                    data: _lzSendParam.sendParam.composeMsg,\n                    prevData: bytes(\"\"),\n                    prevOptionsData: bytes(\"\")\n                }),\n                lzReceiveGas: _lzSendGas + _lzComposeGas,\n                lzReceiveValue: _lzComposeVal\n            })\n        );\n\n        if (msg.value < prepareLzCallReturn2.msgFee.nativeFee) {\n            revert Magnetar_GasMismatch(prepareLzCallReturn2.msgFee.nativeFee, msg.value);\n        }\n\n        IOftSender(_asset).sendPacket{value: prepareLzCallReturn2.msgFee.nativeFee}(\n            prepareLzCallReturn2.lzSendParam, prepareLzCallReturn2.composeMsg\n        );\n    }\n\n    function _prepareLzSend(address _asset, LZSendParam memory _lzSendParam, uint128 _lzSendGas, uint128 _lzSendVal)\n        private\n        returns (PrepareLzCallReturn memory prepareLzCallReturn)\n    {\n        TapiocaOmnichainEngineHelper _toeHelper = new TapiocaOmnichainEngineHelper();\n        prepareLzCallReturn = _toeHelper.prepareLzCall(\n            ITapiocaOmnichainEngine(_asset),\n            PrepareLzCallData({\n                dstEid: _lzSendParam.sendParam.dstEid,\n                recipient: _lzSendParam.sendParam.to,\n                amountToSendLD: _lzSendParam.sendParam.amountLD,\n                minAmountToCreditLD: _lzSendParam.sendParam.minAmountLD,\n                msgType: 1, // SEND\n                composeMsgData: ComposeMsgData({\n                    index: 0,\n                    gas: 0,\n                    value: 0,\n                    data: bytes(\"\"),\n                    prevData: bytes(\"\"),\n                    prevOptionsData: bytes(\"\")\n                }),\n                lzReceiveGas: _lzSendGas,\n                lzReceiveValue: _lzSendVal\n            })\n        );\n    }\n}"
    },
    {
      "filename": "contracts/Magnetar/modules/MagnetarMintXChainModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Tapioca\nimport {\n    MintFromBBAndLendOnSGLData,\n    CrossChainMintFromBBAndLendOnSGLData,\n    DepositAndSendForLockingData,\n    LockAndParticipateData,\n    MagnetarWithdrawData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {TapiocaOmnichainEngineCodec} from \"tapioca-periph/tapiocaOmnichainEngine/TapiocaOmnichainEngineCodec.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {MagnetarMintCommonModule} from \"./MagnetarMintCommonModule.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title MagnetarMintXChainModule\n * @author TapiocaDAO\n * @notice Magnetar cross chain BigBang related operations\n */\ncontract MagnetarMintXChainModule is MagnetarMintCommonModule {\n    using SafeERC20 for IERC20;\n\n    /// =====================\n    /// Public\n    /// =====================\n    /**\n     * @notice cross-chain helper to deposit mint from BB, lend on SGL, lock on tOLP and participate on tOB\n     * @dev Cross chain flow:\n     *  step 1: magnetar.mintBBLendXChainSGL (chain A) -->\n     *         step 2: IUsdo compose call calls magnetar.depositYBLendSGLLockXchainTOLP (chain B) -->\n     *              step 3: IToft(sglReceipt) compose call calls magnetar.lockAndParticipate (chain X)\n     *  Mints from BB and sends borrowed Usdo to another layer for lending\n     *  ! Handles `step 1` described above !\n     *  !!! All uint variables should be in the LD format !!!\n     *  !!! Sets `lendAmount` parameter of the next call (step 2) !!!\n     * @param data.user the user to perform the operation for\n     * @param data.bigBang the BB address\n     * @param data.mintData the data needed to mint on BB\n     * @param data.lendSendParams LZ send params for lending on another layer\n     */\n    function mintBBLendXChainSGL(CrossChainMintFromBBAndLendOnSGLData memory data) public payable {\n        // Check sender\n        _checkSender(data.user);\n\n        address yieldBox = IMarket(data.bigBang).yieldBox();\n\n        // if `mint` was requested the following actions are performed:\n        //  - extracts & deposits collateral to YB\n        //  - performs bigBang_.addCollateral\n        //  - performs bigBang_.borrow\n        if (data.mintData.mint) {\n            _depositYBBorrowBB(data.mintData, data.bigBang, IYieldBox(yieldBox), data.user, data.marketHelper);\n        }\n\n        // decode `composeMsg` and re-encode it with updated params\n        (uint16 msgType_,, uint16 msgIndex_, bytes memory tapComposeMsg_, bytes memory nextMsg_) =\n            TapiocaOmnichainEngineCodec.decodeToeComposeMsg(data.lendSendParams.lzParams.sendParam.composeMsg);\n\n        DepositAndSendForLockingData memory lendData = abi.decode(tapComposeMsg_, (DepositAndSendForLockingData));\n        lendData.lendAmount = data.mintData.mintAmount;\n\n        data.lendSendParams.lzParams.sendParam.composeMsg =\n            TapiocaOmnichainEngineCodec.encodeToeComposeMsg(abi.encode(lendData), msgType_, msgIndex_, nextMsg_);\n\n        // send on another layer for lending\n        _withdrawToChain(\n            MagnetarWithdrawData({\n                yieldBox: yieldBox,\n                assetId: IMarket(data.bigBang).assetId(),\n                unwrap: false,\n                lzSendParams: data.lendSendParams.lzParams,\n                sendGas: data.lendSendParams.lzSendGas,\n                composeGas: data.lendSendParams.lzComposeGas,\n                sendVal: data.lendSendParams.lzSendVal,\n                composeVal: data.lendSendParams.lzComposeVal,\n                composeMsg: data.lendSendParams.lzParams.sendParam.composeMsg,\n                composeMsgType: data.lendSendParams.lzComposeMsgType,\n                withdraw: true\n            })\n        );\n    }\n\n    /**\n     * @notice cross-chain helper to deposit mint from BB, lend on SGL, lock on tOLP and participate on tOB\n     * @dev Cross chain flow:\n     *  step 1: magnetar.mintBBLendXChainSGL (chain A) -->\n     *         step 2: IUsdo compose call calls magnetar.depositYBLendSGLLockXchainTOLP (chain B) -->\n     *              step 3: IToft(sglReceipt) compose call calls magnetar.lockAndParticipate (chain X)\n     *  Lock on tOB and/or participate on tOLP\n     *  ! Handles `step 3` described above !\n     *  !!! All uint variables should be in the LD format !!!\n     * @param data.user the user to perform the operation for\n     * @param data.singularity the SGL address\n     * @param data.fraction the amount to lock\n     * @param data.lockData the data needed to lock on tOB\n     * @param data.participateData the data needed to participate on tOLP\n     */\n    function lockAndParticipate(LockAndParticipateData memory data) public payable {\n        // Check sender\n        _checkSender(data.user);\n\n        // if `lockData.lock`:\n        //      - transfer `fraction` from data.user to `address(this)\n        //      - deposits `fraction` to YB for `address(this)`\n        //      - performs tOLP.lock\n        uint256 tOLPTokenId = _lockOnTOB(\n            data.lockData,\n            IYieldBox(IMarket(data.singularity).yieldBox()),\n            data.fraction,\n            data.participateData.participate,\n            data.user,\n            data.singularity\n        );\n\n        // if `participateData.participate`:\n        //      - verify tOLPTokenId\n        //      - performs tOB.participate\n        //      - transfer `oTAPTokenId` to data.user\n        if (data.participateData.participate) {\n            _participateOnTOLP(data.participateData, data.user, data.lockData.target, tOLPTokenId);\n        }\n    }\n}"
    }
  ]
}