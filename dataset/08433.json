{
  "Title": "[N-10]  Non-assembly method available",
  "Content": "`assembly{ id := chainid() }` => `uint256 id = block.chainid`, `assembly { size := extcodesize() }` => `uint256 size = address().code.length`<br>\nThere are some automated tools that will flag a project as having higher complexity if there is inline-assembly, so it's best to avoid using it where it's not necessary.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n98:               chainId := chainid()\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L98\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n577:              size := extcodesize(account)\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L577\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-07-golom",
  "Code": [
    {
      "filename": "contracts/core/GolomTrader.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\ninterface ERC721 {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n\ninterface ERC1155 {\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n}\n\ninterface ERC20 {\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n}\n\ninterface Distributor {\n    function addFee(address[2] calldata addr, uint256 fee) external;\n}\n\ncontract GolomTrader is Ownable, ReentrancyGuard {\n    bytes32 public immutable EIP712_DOMAIN_TYPEHASH;\n    mapping(address => uint256) public nonces; // all nonces other then this nonce\n    mapping(bytes32 => uint256) public filled;\n\n    ERC20 WETH = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    struct Order {\n        address collection; // NFT contract address\n        uint256 tokenId; // order for which tokenId of the collection\n        address signer; // maker of order address\n        uint256 orderType; // 0 if selling nft for eth , 1 if offering weth for nft,2 if offering weth for collection with special criteria root\n        uint256 totalAmt; // price value of the trade // total amt maker is willing to give up per unit of amount\n        Payment exchange; // payment agreed by maker of the order to pay on succesful filling of trade this amt is subtracted from totalamt\n        Payment prePayment; // another payment , can be used for royalty, facilating trades\n        bool isERC721; // standard of the collection , if 721 then true , if 1155 then false\n        uint256 tokenAmt; // token amt useful if standard is 1155 if >1 means whole order can be filled tokenAmt times\n        uint256 refererrAmt; // amt to pay to the address that helps in filling your order\n        bytes32 root; // A merkle root derived from each valid tokenId â€” set to 0 to indicate a collection-level or tokenId-specific order.\n        address reservedAddress; // if not address(0) , only this address can fill the order\n        uint256 nonce; // nonce of order usefull for cancelling in bulk\n        uint256 deadline; // timestamp till order is valid epoch timestamp in secs\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct Payment {\n        uint256 paymentAmt;\n        address paymentAddress;\n    }\n\n    address public governance;\n\n    Distributor public distributor;\n    address public pendingDistributor;\n    uint256 public distributorEnableDate;\n\n    // events\n    event NonceIncremented(address indexed maker, uint256 newNonce);\n\n    event OrderFilled(\n        address indexed maker,\n        address indexed taker,\n        uint256 indexed orderType,\n        bytes32 orderHash,\n        uint256 price\n    );\n\n    event OrderCancelled(bytes32 indexed orderHash);\n\n    /// @param _governance Address of the governance, responsible for setting distributor\n    constructor(address _governance) {\n        // sets governance as owner\n        _transferOwnership(_governance);\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n\n        EIP712_DOMAIN_TYPEHASH = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes('GOLOM.IO')),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function hashPayment(Payment calldata p) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256('payment(uint256 paymentAmt,address paymentAddress)'),\n                    p.paymentAmt,\n                    p.paymentAddress\n                )\n            );\n    }\n\n    function _hashOrder(Order calldata o) private pure returns (bytes32) {\n        return _hashOrderinternal(o, [o.nonce, o.deadline]);\n    }\n\n    function _hashOrderinternal(Order calldata o, uint256[2] memory extra) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        'order(address collection,uint256 tokenId,address signer,uint256 orderType,uint256 totalAmt,payment exchange,payment prePayment,bool isERC721,uint256 tokenAmt,uint256 refererrAmt,bytes32 root,address reservedAddress,uint256 nonce,uint256 deadline)payment(uint256 paymentAmt,address paymentAddress)'\n                    ),\n                    o.collection,\n                    o.tokenId,\n                    o.signer,\n                    o.orderType,\n                    o.totalAmt,\n                    hashPayment(o.exchange),\n                    hashPayment(o.prePayment),\n                    o.isERC721,\n                    o.tokenAmt,\n                    o.refererrAmt,\n                    o.root,\n                    o.reservedAddress,\n                    extra\n                )\n            );\n    }\n\n    function payEther(uint256 payAmt, address payAddress) internal {\n        if (payAmt > 0) {\n            // if royalty has to be paid\n            payable(payAddress).transfer(payAmt); // royalty transfer to royaltyaddress\n        }\n    }\n\n    /// @dev Validates Order and returns OrderStatus, hashedorder, amountRemaining to be filled\n    ///      OrderStatus = 0 , if signature is invalid\n    ///      OrderStatus = 1 , if deadline has been\n    ///      OrderStatus = 2 , order is filled or cancelled\n    ///      OrderStatus = 3 , valid order\n    /// @param o the Order struct to be validated\n    function validateOrder(Order calldata o)\n        public\n        view\n        returns (\n            uint256,\n            bytes32,\n            uint256\n        )\n    {\n        // match signature\n        bytes32 hashStruct = _hashOrder(o);\n        bytes32 hash = keccak256(abi.encodePacked('\\x19\\x01', EIP712_DOMAIN_TYPEHASH, hashStruct));\n        address signaturesigner = ecrecover(hash, o.v, o.r, o.s);\n        require(signaturesigner == o.signer, 'invalid signature');\n        if (signaturesigner != o.signer) {\n            return (0, hashStruct, 0);\n        }\n        //deadline\n        if (block.timestamp > o.deadline) {\n            return (1, hashStruct, 0);\n        }\n        // not cancelled by nonce or by hash\n        if (o.nonce != nonces[o.signer]) {\n            return (2, hashStruct, 0);\n        }\n        if (filled[hashStruct] >= o.tokenAmt) {\n            // handles erc1155\n            return (2, hashStruct, 0);\n        }\n        return (3, hashStruct, o.tokenAmt - filled[hashStruct]);\n    }\n\n    /// @dev function to fill a signed order of ordertype 0, also has a payment param in case the taker wants\n    ///      to send ether to that address on filling the order\n    /// @param o the Order struct to be filled must be orderType 0\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    /// @param receiver address which will receive the NFT\n    function fillAsk(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p,\n        address receiver\n    ) public payable nonReentrant {\n        // check if the signed total amount has all the amounts as well as 50 basis points fee\n        require(\n            o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt + (o.totalAmt * 50) / 10000,\n            'amt not matching'\n        );\n\n        // attached ETH value should be greater than total value of one NFT * total number of NFTs + any extra payment to be given\n        require(msg.value >= o.totalAmt * amount + p.paymentAmt, 'mgmtm');\n\n        if (o.reservedAddress != address(0)) {\n            require(msg.sender == o.reservedAddress);\n        }\n        require(o.orderType == 0, 'invalid orderType');\n\n        (uint256 status, bytes32 hashStruct, uint256 amountRemaining) = validateOrder(o);\n\n        require(status == 3, 'order not valid');\n        require(amountRemaining >= amount, 'order already filled');\n\n        filled[hashStruct] = filled[hashStruct] + amount;\n\n        if (receiver == address(0)) {\n            receiver = msg.sender;\n        }\n        if (o.isERC721) {\n            require(amount == 1, 'only 1 erc721 at 1 time');\n            ERC721(o.collection).transferFrom(o.signer, receiver, o.tokenId);\n        } else {\n            ERC1155(o.collection).safeTransferFrom(o.signer, receiver, o.tokenId, amount, '');\n        }\n\n        // pay fees of 50 basis points to the distributor\n        payEther(((o.totalAmt * 50) / 10000) * amount, address(distributor));\n\n        // pay the exchange share\n        payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);\n\n        // pay the pre payment\n        payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);\n\n        if (o.refererrAmt > 0 && referrer != address(0)) {\n            payEther(o.refererrAmt * amount, referrer);\n            payEther(\n                (o.totalAmt -\n                    (o.totalAmt * 50) /\n                    10000 -\n                    o.exchange.paymentAmt -\n                    o.prePayment.paymentAmt -\n                    o.refererrAmt) * amount,\n                o.signer\n            );\n        } else {\n            payEther(\n                (o.totalAmt - (o.totalAmt * 50) / 10000 - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount,\n                o.signer\n            );\n        }\n        payEther(p.paymentAmt, p.paymentAddress);\n\n        distributor.addFee([o.signer, o.exchange.paymentAddress], ((o.totalAmt * 50) / 10000) * amount);\n        emit OrderFilled(o.signer, msg.sender, 0, hashStruct, o.totalAmt * amount);\n    }\n\n    /// @dev function to fill a signed order of ordertype 1 also has a payment param in case the taker wants\n    ///      to send ether to that address on filling the order\n    /// @param o the Order struct to be filled must be orderType 1\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    function fillBid(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p\n    ) public nonReentrant {\n        require(\n            o.totalAmt * amount >\n                (o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt) * amount + p.paymentAmt\n        ); // cause bidder eth is paying for seller payment p , dont take anything extra from seller\n        // require eth amt is sufficient\n        if (o.reservedAddress != address(0)) {\n            require(msg.sender == o.reservedAddress);\n        }\n        require(o.orderType == 1);\n        (uint256 status, bytes32 hashStruct, uint256 amountRemaining) = validateOrder(o);\n        require(status == 3);\n        require(amountRemaining >= amount);\n        filled[hashStruct] = filled[hashStruct] + amount;\n        if (o.isERC721) {\n            require(amount == 1, 'only 1 erc721 at 1 time');\n            ERC721 nftcontract = ERC721(o.collection);\n            nftcontract.transferFrom(msg.sender, o.signer, o.tokenId);\n        } else {\n            ERC1155 nftcontract = ERC1155(o.collection);\n            nftcontract.safeTransferFrom(msg.sender, o.signer, o.tokenId, amount, '');\n        }\n        emit OrderFilled(msg.sender, o.signer, 1, hashStruct, o.totalAmt * amount);\n        _settleBalances(o, amount, referrer, p);\n    }\n\n    // cancel by nonce and by individual order\n\n    function cancelOrder(Order calldata o) public nonReentrant {\n        require(o.signer == msg.sender);\n        (, bytes32 hashStruct, ) = validateOrder(o);\n        filled[hashStruct] = o.tokenAmt + 1;\n        emit OrderCancelled(hashStruct);\n    }\n\n    /**\n     * Increment a particular maker's nonce, thereby invalidating all orders that were not signed\n     * with the original nonce.\n     */\n    function incrementNonce() external nonReentrant {\n        uint256 newNonce = ++nonces[msg.sender];\n        emit NonceIncremented(msg.sender, newNonce);\n    }\n\n    /// @dev function to fill a signed order of ordertype 2 also has a payment param in case the taker wants\n    ///      to send ether to that address on filling the order, Match an criteria order, ensuring that the supplied proof demonstrates inclusion of the tokenId in the associated merkle root, if root is 0 then any token can be used to fill the order\n    /// @param o the Order struct to be filled must be orderType 2\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    function fillCriteriaBid(\n        Order calldata o,\n        uint256 amount,\n        uint256 tokenId,\n        bytes32[] calldata proof,\n        address referrer,\n        Payment calldata p\n    ) public nonReentrant {\n        require(o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt);\n        // require eth amt is sufficient\n        if (o.reservedAddress != address(0)) {\n            require(msg.sender == o.reservedAddress);\n        }\n        require(o.orderType == 2);\n        (uint256 status, bytes32 hashStruct, uint256 amountRemaining) = validateOrder(o);\n        require(status == 3);\n        require(amountRemaining >= amount);\n\n        filled[hashStruct] = filled[hashStruct] + amount;\n        // Proof verification is performed when there's a non-zero root.\n        if (o.root != bytes32(0)) {\n            _verifyProof(tokenId, o.root, proof);\n        }\n\n        if (o.isERC721) {\n            require(amount == 1, 'only 1 erc721 at 1 time');\n            ERC721 nftcontract = ERC721(o.collection);\n            nftcontract.transferFrom(msg.sender, o.signer, tokenId);\n        } else {\n            ERC1155 nftcontract = ERC1155(o.collection);\n            nftcontract.safeTransferFrom(msg.sender, o.signer, tokenId, amount, '');\n        }\n        emit OrderFilled(msg.sender, o.signer, 2, hashStruct, o.totalAmt * amount);\n        _settleBalances(o, amount, referrer, p);\n    }\n\n    /// @dev function to settle balances when a bid is filled succesfully\n    /// @param o the Order struct to be filled must be orderType 1\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    function _settleBalances(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p\n    ) internal {\n        uint256 protocolfee = ((o.totalAmt * 50) / 10000) * amount;\n        WETH.transferFrom(o.signer, address(this), o.totalAmt * amount);\n        WETH.withdraw(o.totalAmt * amount);\n        payEther(protocolfee, address(distributor));\n        payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);\n        payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);\n        if (o.refererrAmt > 0 && referrer != address(0)) {\n            payEther(o.refererrAmt * amount, referrer);\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *\n                    amount -\n                    p.paymentAmt,\n                msg.sender\n            );\n        } else {\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,\n                msg.sender\n            );\n        }\n        payEther(p.paymentAmt, p.paymentAddress);\n        distributor.addFee([msg.sender, o.exchange.paymentAddress], protocolfee);\n    }\n\n    /// @dev Ensure that a given tokenId is contained within a supplied merkle root using a supplied proof.\n    /// @param leaf The tokenId.\n    /// @param root A merkle root derived from each valid tokenId.\n    /// @param proof A proof that the supplied tokenId is contained within the associated merkle root.\n    function _verifyProof(\n        uint256 leaf,\n        bytes32 root,\n        bytes32[] memory proof\n    ) public pure {\n        bytes32 computedHash = keccak256(abi.encode(leaf));\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        if (computedHash != root) {\n            revert('invalid proof');\n        }\n    }\n\n    /// @dev Efficiently hash two bytes32 elements using memory scratch space.\n    /// @param a The first element included in the hash.\n    /// @param b The second element included in the hash.\n    /// @return value The resultant hash of the two bytes32 elements.\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @notice Sets the distributor contract\n    /// @param _distributor Address of the distributor\n    function setDistributor(address _distributor) external onlyOwner {\n        if (address(distributor) == address(0)) {\n            distributor = Distributor(_distributor);\n        } else {\n            pendingDistributor = _distributor;\n            distributorEnableDate = block.timestamp + 1 days;\n        }\n    }\n\n    /// @notice Executes the set distributor function after the timelock\n    function executeSetDistributor() external onlyOwner {\n        require(distributorEnableDate <= block.timestamp, 'not allowed');\n        distributor = Distributor(pendingDistributor);\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/vote-escrow/VoteEscrowCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport './TokenUriHelper.sol';\n\n/**\n@title Voting Escrow\n@author Curve Finance\n@license MIT\n@notice Votes have a weight depending on time, so that users are\ncommitted to the future of (whatever they are voting for)\n@dev Vote weight decays linearly over time. Lock time cannot be\nmore than `MAXTIME` (4 years).\n\n# Voting escrow to have time-weighted votes\n# Votes have a weight depending on time, so that users are committed\n# to the future of (whatever they are voting for).\n# The weight in this implementation is linear, and lock cannot be more than maxtime:\n# w ^\n# 1 +        /\n#   |      /\n#   |    /\n#   |  /\n#   |/\n# 0 +--------+------> time\n#       maxtime (4 years?)\n*/\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n\nstruct Point {\n    int128 bias;\n    int128 slope; // # -dweight / dt\n    uint256 ts;\n    uint256 blk; // block\n}\n/* We cannot really do block numbers per se b/c slope is per time, not per block\n * and per block could be fairly bad b/c Ethereum changes blocktimes.\n * What we can do is to extrapolate ***At functions */\n\nstruct LockedBalance {\n    int128 amount;\n    uint256 end;\n}\n\ncontract VoteEscrowCore is IERC721, IERC721Metadata {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME,\n        MERGE_TYPE\n    }\n\n    event Deposit(\n        address indexed provider,\n        uint256 tokenId,\n        uint256 value,\n        uint256 indexed locktime,\n        DepositType deposit_type,\n        uint256 ts\n    );\n    event Withdraw(address indexed provider, uint256 tokenId, uint256 value, uint256 ts);\n    event Supply(uint256 prevSupply, uint256 supply);\n\n    uint256 internal constant WEEK = 1 weeks;\n    uint256 internal constant MAXTIME = 4 * 365 * 86400;\n    int128 internal constant iMAXTIME = 4 * 365 * 86400;\n    uint256 internal constant MULTIPLIER = 1 ether;\n\n    address public token;\n    uint256 public supply;\n    mapping(uint256 => LockedBalance) public locked;\n\n    mapping(uint256 => uint256) public ownership_change;\n\n    uint256 public epoch;\n    mapping(uint256 => Point) public point_history; // epoch -> unsigned point\n    mapping(uint256 => Point[1000000000]) public user_point_history; // user -> Point[user_epoch]\n\n    mapping(uint256 => uint256) public user_point_epoch;\n    mapping(uint256 => int128) public slope_changes; // time -> signed slope change\n\n    mapping(uint256 => uint256) public attachments;\n    mapping(uint256 => bool) public voted;\n    address public voter;\n\n    string public constant name = 'veNFT';\n    string public constant symbol = 'veNFT';\n    string public constant version = '1.0.0';\n    uint8 public constant decimals = 18;\n\n    /// @dev Current count of token\n    uint256 internal tokenId;\n\n    /// @dev Mapping from NFT ID to the address that owns it.\n    mapping(uint256 => address) internal idToOwner;\n\n    /// @dev Mapping from NFT ID to approved address.\n    mapping(uint256 => address) internal idToApprovals;\n\n    /// @dev Mapping from owner address to count of his tokens.\n    mapping(address => uint256) internal ownerToNFTokenCount;\n\n    /// @dev Mapping from owner address to mapping of index to tokenIds\n    mapping(address => mapping(uint256 => uint256)) internal ownerToNFTokenIdList;\n\n    /// @dev Mapping from NFT ID to index of owner\n    mapping(uint256 => uint256) internal tokenToOwnerIndex;\n\n    /// @dev Mapping from owner address to mapping of operator addresses.\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\n\n    /// @dev Mapping of interface id to bool about whether or not it's supported\n    mapping(bytes4 => bool) internal supportedInterfaces;\n\n    /// @dev ERC165 interface ID of ERC165\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n\n    /// @dev ERC165 interface ID of ERC721\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n    /// @dev ERC165 interface ID of ERC721Metadata\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n    /// @dev reentrancy guard\n    uint8 internal constant _not_entered = 1;\n    uint8 internal constant _entered = 2;\n    uint8 internal _entered_state = 1;\n    modifier nonreentrant() {\n        require(_entered_state == _not_entered);\n        _entered_state = _entered;\n        _;\n        _entered_state = _not_entered;\n    }\n\n    /// @dev Interface identification is specified in ERC-165.\n    /// @param _interfaceID Id of the interface\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n        return supportedInterfaces[_interfaceID];\n    }\n\n    /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @return Value of the slope\n    function get_last_user_slope(uint256 _tokenId) external view returns (int128) {\n        uint256 uepoch = user_point_epoch[_tokenId];\n        return user_point_history[_tokenId][uepoch].slope;\n    }\n\n    /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @param _idx User epoch number\n    /// @return Epoch time of the checkpoint\n    function user_point_history__ts(uint256 _tokenId, uint256 _idx) external view returns (uint256) {\n        return user_point_history[_tokenId][_idx].ts;\n    }\n\n    /// @notice Get timestamp when `_tokenId`'s lock finishes\n    /// @param _tokenId User NFT\n    /// @return Epoch time of the lock end\n    function locked__end(uint256 _tokenId) external view returns (uint256) {\n        return locked[_tokenId].end;\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function _balance(address _owner) internal view returns (uint256) {\n        return ownerToNFTokenCount[_owner];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function balanceOf(address _owner) external view returns (uint256) {\n        return _balance(_owner);\n    }\n\n    /// @dev Returns the address of the owner of the NFT.\n    /// @param _tokenId The identifier for an NFT.\n    function ownerOf(uint256 _tokenId) public view returns (address) {\n        return idToOwner[_tokenId];\n    }\n\n    /// @dev Get the approved address for a single NFT.\n    /// @"
    }
  ]
}